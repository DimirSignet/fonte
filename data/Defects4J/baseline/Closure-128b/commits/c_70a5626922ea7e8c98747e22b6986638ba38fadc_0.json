{"sha": "70a5626922ea7e8c98747e22b6986638ba38fadc", "log": "Fix various typos, spelling and grammar errors. Fixes issue 734.  Contributed by Robert Gust Bardon  R=nicksantos   Revision created by MOE tool push_codebase. MOE_MIGRATION=4827   ", "commit": "\n--- a/src/com/google/debugging/sourcemap/SourceMapConsumerV1.java\n+++ b/src/com/google/debugging/sourcemap/SourceMapConsumerV1.java\n    * Parses the first section of the source map file that has character\n    * mappings.\n    * @param parser The parser to use\n-   * @param lineCount The number of lines in the generated js\n+   * @param lineCount The number of lines in the generated JS\n    * @return The max id found in the file\n    */\n   private int parseCharacterMap(\n \n   /**\n    * Parse the file mappings section of the source map file.  This maps the\n-   * ids to the filename, line number and colunm number in the original\n+   * ids to the filename, line number and column number in the original\n    * files.\n    * @param parser The parser to get the data from.\n    * @param maxID The maximum id found in the character mapping section.\n    * Keeps track of the information about the line in a more compact way.  It\n    * represents a fragment of the line starting at a specific index and then\n    * looks at offsets from that index stored as a byte, this dramatically\n-   * reduces the memory usuage of this array.\n+   * reduces the memory usage of this array.\n    */\n   private static final class LineFragment {\n     private final int startIndex;\n \n   /**\n    * Keeps track of data about the source file itself.  This is contains a list\n-   * of line offsetsand columns to track down where exactly a line falls into\n+   * of line offsets and columns to track down where exactly a line falls into\n    * the data.\n    */\n   private static final class SourceFile {\n--- a/src/com/google/debugging/sourcemap/SourceMapConsumerV3.java\n+++ b/src/com/google/debugging/sourcemap/SourceMapConsumerV3.java\n   }\n \n   /**\n-   * Compare an array entry's column value to the taget column value.\n+   * Compare an array entry's column value to the target column value.\n    */\n   private int compareEntry(ArrayList<Entry> entries, int entry, int target) {\n     return entries.get(entry).getGeneratedColumn() - target;\n \n     @Override\n     public boolean hasNext() {\n-      return  current < length;\n+      return current < length;\n     }\n   }\n \n--- a/src/com/google/debugging/sourcemap/SourceMapGeneratorV1.java\n+++ b/src/com/google/debugging/sourcemap/SourceMapGeneratorV1.java\n   @Override\n   public void appendTo(Appendable out, String name) throws IOException {\n     // Write the mappings out to the file. The format of the generated\n-    // source map is three sections, each deliminated by a magic comment.\n+    // source map is three sections, each delimited by a magic comment.\n     //\n     // The first section contains an array for each line of the generated\n     // code, where each element in the array is the ID of the mapping which\n--- a/src/com/google/debugging/sourcemap/SourceMapGeneratorV2.java\n+++ b/src/com/google/debugging/sourcemap/SourceMapGeneratorV2.java\n    * Line 1: The entire file is a single JSON object\n    * Line 2: File revision (always the first entry in the object)\n    * Line 3: The name of the file that this source map is associated with.\n-   * Line 4: The number of lines represented in the sourcemap.\n+   * Line 4: The number of lines represented in the source map.\n    * Line 5: \"lineMaps\" field is a JSON array, where each entry represents a\n    *     line in the generated text.\n    * Line 6: A line entry, representing a series of line segments, where each\n--- a/src/com/google/debugging/sourcemap/SourceMapGeneratorV3.java\n+++ b/src/com/google/debugging/sourcemap/SourceMapGeneratorV3.java\n    * Line 1: The entire file is a single JSON object\n    * Line 2: File revision (always the first entry in the object)\n    * Line 3: The name of the file that this source map is associated with.\n-   * Line 4: The number of lines represented in the sourcemap.\n+   * Line 4: The number of lines represented in the source map.\n    * Line 5: An optional source root, useful for relocating source files on a\n    *     server or removing repeated prefix values in the \"sources\" entry.\n    * Line 6: A list of sources used by the \"mappings\" entry relative to the\n--- a/src/com/google/debugging/sourcemap/SourceMapLineDecoder.java\n+++ b/src/com/google/debugging/sourcemap/SourceMapLineDecoder.java\n     }\n \n     boolean hasNext() {\n-      return  current < content.length() -1;\n+      return current < content.length() -1;\n     }\n   }\n }\n--- a/src/com/google/debugging/sourcemap/SourceMapSection.java\n+++ b/src/com/google/debugging/sourcemap/SourceMapSection.java\n public class SourceMapSection {\n \n   /**\n-   * A url for a valid source map file that represents a section of a generate\n+   * A URL for a valid source map file that represents a section of a generate\n    * source file such as when multiple files are concatenated together.\n    */\n   private final String value;\n   }\n \n   /**\n-   * @param sectionUrl The url for the partial sourcemap\n+   * @param sectionUrl The URL for the partial source map\n    * @param line The number of lines into the file where the represented section\n    *    starts.\n    * @param column The number of characters into the line where the represented\n--- a/src/com/google/debugging/sourcemap/SourceMapSupplier.java\n+++ b/src/com/google/debugging/sourcemap/SourceMapSupplier.java\n public interface SourceMapSupplier {\n \n   /**\n-   * @param url The url of the source map.\n-   * @return The contents of the map associated with the url\n+   * @param url The URL of the source map.\n+   * @return The contents of the map associated with the URL\n    * @throws IOException\n    */\n   String getSourceMap(String url) throws IOException;\n--- a/src/com/google/debugging/sourcemap/Util.java\n+++ b/src/com/google/debugging/sourcemap/Util.java\n     return escapeString(s, '\"',  \"\\\\\\\"\", \"\\'\", \"\\\\\\\\\", null);\n   }\n \n-  /** Helper to escape javascript string as well as regular expression */\n+  /** Helper to escape JavaScript string as well as regular expression */\n   static String escapeString(String s, char quote,\n                           String doublequoteEscape,\n                           String singlequoteEscape,\n               appendCharAsHex(sb, c);\n             }\n           } else {\n-            // No charsetEncoder provided - pass straight latin characters\n+            // No charsetEncoder provided - pass straight Latin characters\n             // through, and escape the rest.  Doing the explicit character\n             // check is measurably faster than using the CharsetEncoder.\n             if (c > 0x1f && c <= 0x7f) {\n               sb.append(c);\n             } else {\n-              // Other characters can be misinterpreted by some js parsers,\n+              // Other characters can be misinterpreted by some JS parsers,\n               // or perhaps mangled by proxies along the way,\n-              // so we play it safe and unicode escape them.\n+              // so we play it safe and Unicode escape them.\n               appendCharAsHex(sb, c);\n             }\n           }\n   }\n \n   /**\n-   * Returns a javascript representation of the character in a hex escaped\n+   * Returns a JavaScript representation of the character in a hex escaped\n    * format.\n    * @param out The buffer to which the hex representation should be appended.\n-   * @param codePoint The codepoint to append.\n+   * @param codePoint The code point to append.\n    */\n   private static void appendHexJavaScriptRepresentation(\n       Appendable out, int codePoint)\n       throws IOException {\n     if (Character.isSupplementaryCodePoint(codePoint)) {\n-      // Handle supplementary unicode values which are not representable in\n-      // javascript.  We deal with these by escaping them as two 4B sequences\n-      // so that they will round-trip properly when sent from java to javascript\n+      // Handle supplementary Unicode values which are not representable in\n+      // JavaScript.  We deal with these by escaping them as two 4B sequences\n+      // so that they will round-trip properly when sent from Java to JavaScript\n       // and back.\n       char[] surrogates = Character.toChars(codePoint);\n       appendHexJavaScriptRepresentation(out, surrogates[0]);\n--- a/src/com/google/javascript/jscomp/AbstractCommandLineRunner.java\n+++ b/src/com/google/javascript/jscomp/AbstractCommandLineRunner.java\n   /**\n    * Sets options based on the configurations set flags API.\n    * Called during the run() run() method.\n-   * If you want to ignore the flags API, or intepret flags your own way,\n+   * If you want to ignore the flags API, or interpret flags your own way,\n    * then you should override this method.\n    */\n   protected void setRunOptions(CompilerOptions options)\n   }\n \n   /**\n-   * Creates js source code inputs from a list of files.\n+   * Creates JS source code inputs from a list of files.\n    */\n   private List<SourceFile> createSourceInputs(List<String> files)\n       throws FlagUsageException, IOException {\n   }\n \n   /**\n-   * Creates js extern inputs from a list of files.\n+   * Creates JS extern inputs from a list of files.\n    */\n   private List<SourceFile> createExternInputs(List<String> files)\n       throws FlagUsageException, IOException {\n    * @param specs A list of module specifications, not null or empty. The spec\n    *        format is: <code>name:num-js-files[:[dep,...][:]]</code>. Module\n    *        names must not contain the ':' character.\n-   * @param jsFiles A list of js file paths, not null\n+   * @param jsFiles A list of JS file paths, not null\n    * @return An array of module objects\n    */\n   List<JSModule> createJsModules(\n \n       // We will allow modules of zero input.\n       if (numJsFiles < 0) {\n-        throw new FlagUsageException(\"Invalid js file count '\" + parts[1]\n+        throw new FlagUsageException(\"Invalid JS file count '\" + parts[1]\n             + \"' for module: \" + name);\n       }\n       if (nextJsFileIndex + numJsFiles > totalNumJsFiles) {\n-        throw new FlagUsageException(\"Not enough js files specified. Expected \"\n+        throw new FlagUsageException(\"Not enough JS files specified. Expected \"\n             + (nextJsFileIndex + numJsFiles - totalNumJsFiles)\n             + \" more in module:\" + name);\n       }\n     }\n \n     if (nextJsFileIndex < totalNumJsFiles) {\n-      throw new FlagUsageException(\"Too many js files specified. Expected \"\n+      throw new FlagUsageException(\"Too many JS files specified. Expected \"\n           + nextJsFileIndex + \" but found \" + totalNumJsFiles);\n     }\n \n    * The placeholder will expand to a different value depending on\n    * the current output mode. There are three scenarios:\n    *\n-   * 1) Single js output, single extra output: sub in jsOutputPath.\n-   * 2) Multiple js output, single extra output: sub in the base module name.\n-   * 3) Multiple js output, multiple extra output: sub in the module output\n+   * 1) Single JS output, single extra output: sub in jsOutputPath.\n+   * 2) Multiple JS output, single extra output: sub in the base module name.\n+   * 3) Multiple JS output, multiple extra output: sub in the module output\n    *    file.\n    *\n    * Passing a JSModule to this function automatically triggers case #3.\n   }\n \n   /**\n-   * Converts a file name into a Ouputstream.\n+   * Converts a file name into a Outputstream.\n    * Returns null if the file name is null.\n    */\n   protected OutputStream filenameToOutputStream(String fileName)\n     private final List<String> externs = Lists.newArrayList();\n \n     /**\n-     * The file containing javascript externs. You may specify multiple.\n+     * The file containing JavaScript externs. You may specify multiple.\n      */\n     CommandLineConfig setExterns(List<String> externs) {\n       this.externs.clear();\n     private final List<String> js = Lists.newArrayList();\n \n     /**\n-     * The javascript filename. You may specify multiple.\n+     * The JavaScript filename. You may specify multiple.\n      */\n     CommandLineConfig setJs(List<String> js) {\n       this.js.clear();\n     private final List<String> module = Lists.newArrayList();\n \n     /**\n-     * A javascript module specification. The format is\n+     * A JavaScript module specification. The format is\n      * <name>:<num-js-files>[:[<dep>,...][:]]]. Module names must be\n      * unique. Each dep is the name of a module that this module\n-     * depends on. Modules must be listed in dependency order, and js\n+     * depends on. Modules must be listed in dependency order, and JS\n      * source files must be listed in the corresponding order. Where\n      * --module flags occur in relation to --js flags is unimportant\n      */\n     private final List<String> moduleWrapper = Lists.newArrayList();\n \n     /**\n-     * An output wrapper for a javascript module (optional). See the flag\n+     * An output wrapper for a JavaScript module (optional). See the flag\n      * description for formatting requirements.\n      */\n     CommandLineConfig setModuleWrapper(List<String> moduleWrapper) {\n     private String moduleOutputPathPrefix = \"\";\n \n     /**\n-     * Prefix for filenames of compiled js modules.\n+     * Prefix for filenames of compiled JS modules.\n      * <module-name>.js will be appended to this prefix. Directories\n      * will be created as needed. Use with --module\n      */\n \n     /**\n      * Sets whether to accept input files as ECMAScript5 compliant.\n-     * Otherwise input files are treated as ECMAScript3 compliant.\n+     * Otherwise, input files are treated as ECMAScript3 compliant.\n      */\n     CommandLineConfig setLanguageIn(String languageIn) {\n       this.languageIn = languageIn;\n     private boolean transformAMDToCJSModules = false;\n \n     /**\n-     * Set whether to transform AMD to Common JS modules.\n+     * Set whether to transform AMD to CommonJS modules.\n      */\n     CommandLineConfig setTransformAMDToCJSModules(\n         boolean transformAMDToCJSModules) {\n     private boolean processCommonJSModules = false;\n \n     /**\n-     * Sets whether to process Common JS modules.\n+     * Sets whether to process CommonJS modules.\n      */\n     CommandLineConfig setProcessCommonJSModules(\n         boolean processCommonJSModules) {\n         ProcessCommonJSModules.DEFAULT_FILENAME_PREFIX;\n \n     /**\n-     * Sets the Common JS module path prefix.\n+     * Sets the CommonJS module path prefix.\n      */\n     CommandLineConfig setCommonJSModulePathPrefix(\n         String commonJSModulePathPrefix) {\n--- a/src/com/google/javascript/jscomp/AbstractCompiler.java\n+++ b/src/com/google/javascript/jscomp/AbstractCompiler.java\n   abstract void setHasRegExpGlobalReferences(boolean references);\n \n   /**\n-   * @return Whether the AST constains references to the RegExp global object\n+   * @return Whether the AST contains references to the RegExp global object\n    *     properties.\n    */\n   abstract boolean hasRegExpGlobalReferences();\n--- a/src/com/google/javascript/jscomp/AbstractPeepholeOptimization.java\n+++ b/src/com/google/javascript/jscomp/AbstractPeepholeOptimization.java\n   }\n \n   /**\n-   * @return Whether the source code version is EcmaScript 5 or later.\n+   * @return Whether the source code version is ECMAScript 5 or later.\n    *     Workarounds for quirks in browsers that do not support ES5 can be\n    *     ignored when this is true.\n    */\n--- a/src/com/google/javascript/jscomp/AliasExternals.java\n+++ b/src/com/google/javascript/jscomp/AliasExternals.java\n /**\n  * <p>AliasExternals provides wrappers and aliases for external globals and\n  * properties to that they can be referenced by their full name only once\n- * intead of in all use sites.</p>\n+ * instead of in all use sites.</p>\n  *\n  * <p>The property alias pass creates function wrappers for properties that need\n  * to be accessed externally. These function wrappers are then used by all\n  * RenamePrototypes step.</p>\n  *\n  * <p>Properties that are accessed externally are either system functions\n- * (i.e. window.document), or used by javascript embedded on a page.</p>\n- *\n- * <p>Properties that are rvalues are changed to use array notation with\n+ * (i.e. window.document), or used by JavaScript embedded on a page.</p>\n+ *\n+ * <p>Properties that are r-values are changed to use array notation with\n  * a string that has been defined separately and can be compressed\n  * i.e. document.window -> document[PROP_window].</p>\n  *\n- * <p>Properties that are lvalues and can be renamed are renamed to\n+ * <p>Properties that are l-values and can be renamed are renamed to\n  * SETPROP_prop. I.e. node.innerHTML = '&lt;div&gt;Hello&lt;/div&gt;' ->\n  * SETPROP_innerHTML(node, '&lt;div&gt;hello&lt;/div&gt;').</p>\n  *\n       // meaning inside function bodies and should not be aliased at a global\n       // level.\n       \"arguments\",\n-      // Eval should not be aliased, per the ECMA 262 spec section 15.1.2.1\n+      // Eval should not be aliased, per the ECMA-262 spec section 15.1.2.1\n       \"eval\",\n       // \"NodeFilter\" is not defined in IE and throws an error if you try to\n       // do var foo = NodeFilter.\n       parentNode.removeChild(propDest);\n \n       // Create the call GETPROP_prop() node, using the old propSrc as the\n-      // one paremeter to GETPROP_prop() call.\n+      // one parameter to GETPROP_prop() call.\n       Node callName = IR.name(\n           getMutatorFor(propNameNode.getString()));\n       Node call = IR.call( callName, propSrc, propDest);\n   }\n \n   /**\n-   * Gets references to all of the replacable nodes, as well\n+   * Gets references to all of the replaceable nodes, as well\n    * as counting the usage for each property name.\n    */\n   private final class PropertyGatherer extends AbstractPostOrderCallback {\n \n     /**\n      * Logic for when a getprop can be replaced.\n-     * Can't alias a call to eval per ECMA 262 spec section 15.1.2.1\n+     * Can't alias a call to eval per ECMA-262 spec section 15.1.2.1\n      * Can't be an assign -> no a.b = c;\n      * Can't be inc or dec -> no a.b++; or a.b--;\n      * Must be a GETPROP (NODE, A) where A is a reserved name\n   }\n \n   /**\n-   * Gets references to all of the replacable nodes, as well as counting the\n+   * Gets references to all of the replaceable nodes, as well as counting the\n    * usage for each global.\n    */\n   private final class GlobalGatherer extends AbstractPostOrderCallback {\n--- a/src/com/google/javascript/jscomp/AliasStrings.java\n+++ b/src/com/google/javascript/jscomp/AliasStrings.java\n \n       // \"undefined\" is special-cased, since it needs to be used when JS code\n       // is unloading and therefore variable references aren't available.\n-      // This is because of a bug in FireFox.\n+      // This is because of a bug in Firefox.\n       if (\"undefined\".equals(str)) {\n         return;\n       }\n--- a/src/com/google/javascript/jscomp/AnalyzeNameReferences.java\n+++ b/src/com/google/javascript/jscomp/AnalyzeNameReferences.java\n  * Analyzes names and references usage by determining:\n  * <p><ol>\n  * <li>If the name is reachable from the {@link NameReferenceGraph#MAIN}.</li>\n- * <li>as well as  the deepest common module that references it.</li>\n+ * <li>as well as the deepest common module that references it.</li>\n  * </ol>\n  *\n  * The two pieces of information will be annotated to {@link NameReferenceGraph}\n--- a/src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java\n+++ b/src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java\n   private final Map<String, NameInfo> propertyNameInfo = Maps.newHashMap();\n \n   // All the NameInfo for global functions, hashed by the name of the\n-  // gloval variable that it's assigned to.\n+  // global variable that it's assigned to.\n   private final Map<String, NameInfo> varNameInfo = Maps.newHashMap();\n \n   /**\n--- a/src/com/google/javascript/jscomp/AnonymousFunctionNamingCallback.java\n+++ b/src/com/google/javascript/jscomp/AnonymousFunctionNamingCallback.java\n  * Visitor that performs naming operations on anonymous functions by\n  * means of the FunctionNamer interface.  Anonymous functions are\n  * named based on context.  For example, the anonymous function on the\n- * rhs based on the property at the lhs of the assignment operator.\n+ * RHS based on the property at the LHS of the assignment operator.\n  *\n  * goog.string.htmlEscape = function(str) {\n  * }\n--- a/src/com/google/javascript/jscomp/AstParallelizer.java\n+++ b/src/com/google/javascript/jscomp/AstParallelizer.java\n   private final boolean includeRoot;\n \n   // Maps to place holder to the original function.\n-  private final List<DettachPoint> detachPointList;\n+  private final List<DetachPoint> detachPointList;\n \n   /**\n    * Constructor.\n    *     This is <b>very</b> important for performance as we do not want to\n    *     traverse too much just looking for subtree.\n    * @param placeHolderProvider Specify what type of node should be place as\n-   *     a temporary place holder for where the subtree is dettached.\n+   *     a temporary place holder for where the subtree is detached.\n    * @param root The AST itself.\n    * @param includeRoot Should we include the root inside the forest returned\n    *     by {{@link #split()}.\n   /**\n    * Remembers the split point for use in {@link #join()}.\n    */\n-  private void recordSplitPoint(Node placeHolder, Node before, Node orginal) {\n-    detachPointList.add(new DettachPoint(placeHolder, before, orginal));\n+  private void recordSplitPoint(Node placeHolder, Node before, Node original) {\n+    detachPointList.add(new DetachPoint(placeHolder, before, original));\n   }\n \n   /**\n    * Splits the AST into subtree at different levels. The subtrees itself are\n-   * usually not valid javascript but they are all subtreess of some valid\n-   * javascript.\n+   * usually not valid JavaScript but they are all subtrees of some valid\n+   * JavaScript.\n    */\n   public List<Node> split() {\n     if (includeRoot) {\n   public void join() {\n     // Revert in a reverse order to undo the detachment.\n     while (!detachPointList.isEmpty()) {\n-      DettachPoint entry = detachPointList.remove(detachPointList.size() - 1);\n+      DetachPoint entry = detachPointList.remove(detachPointList.size() - 1);\n       entry.reattach();\n     }\n   }\n    * Normally a Map from Node -> Node is sufficient, however, if we also\n    * remember the node before the place holder, we can avoid using\n    * {@link Node#replaceChild(Node, Node)} which requires a linear search of\n-   * the before node. May be someday we should get a prev pointer for this\n+   * the before node. Maybe someday we should get a prev pointer for this\n    * purpose.\n    */\n-  private static class DettachPoint {\n+  private static class DetachPoint {\n \n     // The place holder to remember where the original node was.\n     private Node placeHolder;\n     // The root of the subtree to be temporary detached.\n     private Node original;\n \n-    private DettachPoint(Node placeHolder, Node before, Node orginal) {\n+    private DetachPoint(Node placeHolder, Node before, Node original) {\n       this.placeHolder = placeHolder;\n       this.before = before;\n-      this.original = orginal;\n+      this.original = original;\n     }\n \n     public void reattach() {\n--- a/src/com/google/javascript/jscomp/AstValidator.java\n+++ b/src/com/google/javascript/jscomp/AstValidator.java\n \n   // Possible enhancements:\n   // * verify NAME, LABEL_NAME, GETPROP property name and unquoted\n-  // object-literal keys are valid javascript identifiers.\n+  // object-literal keys are valid JavaScript identifiers.\n   // * optionally verify every node has source location information.\n   // * optionally verify every node has an assigned JSType\n   //\n         validateChildless(n);\n         return;\n \n-      // General uniary ops\n+      // General unary ops\n       case Token.DELPROP:\n       case Token.POS:\n       case Token.NEG:\n--- a/src/com/google/javascript/jscomp/CallGraph.java\n+++ b/src/com/google/javascript/jscomp/CallGraph.java\n   /**\n    * Creates a call graph object supporting the specified lookups.\n    *\n-   * At leats one (and possibly both) of computeForwardGraph and\n+   * At least one (and possibly both) of computeForwardGraph and\n    * computeBackwardGraph must be true.\n    *\n    * @param compiler The compiler\n \n           String functionName = function.getName();\n           // Anonymous functions will have null names,\n-          // so it is important to  handle that correctly here\n+          // so it is important to handle that correctly here\n           if (functionName != null && desiredName != null) {\n             return desiredName.equals(functionName);\n           } else {\n--- a/src/com/google/javascript/jscomp/CheckAccessControls.java\n+++ b/src/com/google/javascript/jscomp/CheckAccessControls.java\n   }\n \n   /**\n-   * Returns whether it's currently ok to access deprecated names and\n+   * Returns whether it's currently OK to access deprecated names and\n    * properties.\n    *\n    * There are 3 exceptions when we're allowed to use a deprecated\n--- a/src/com/google/javascript/jscomp/CheckGlobalNames.java\n+++ b/src/com/google/javascript/jscomp/CheckGlobalNames.java\n    * must be initialized with its full qualified name.\n    */\n   private static boolean propertyMustBeInitializedByFullName(Name name) {\n-    // If an object literal in the global namespace  is never aliased,\n+    // If an object literal in the global namespace is never aliased,\n     // then all of its properties must be defined using its full qualified\n     // name. This implies that its properties must all be in the global\n     // namespace as well.\n--- a/src/com/google/javascript/jscomp/CheckMissingReturn.java\n+++ b/src/com/google/javascript/jscomp/CheckMissingReturn.java\n   /**\n    * Determines if the given scope should explicitly return. All functions\n    * with non-void or non-unknown return types must have explicit returns.\n-   * @return If a return type is expected, returns it. Otherwise returns null.\n+   * @return If a return type is expected, returns it. Otherwise, returns null.\n    */\n   private JSType explicitReturnExpected(Node scope) {\n     FunctionType scopeType = JSType.toMaybeFunctionType(scope.getJSType());\n--- a/src/com/google/javascript/jscomp/CheckSideEffects.java\n+++ b/src/com/google/javascript/jscomp/CheckSideEffects.java\n       if (gramps.isCall() &&\n           parent == gramps.getFirstChild()) {\n         // Semantically, a direct call to eval is different from an indirect\n-        // call to an eval. See Ecma-262 S15.1.2.1. So it's ok for the first\n+        // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n         // expression to a comma to be a no-op if it's used to indirect\n         // an eval.\n         if (n == parent.getFirstChild() &&\n         // Fall through and look for warnings for the 1st and 3rd child\n         // of a for.\n       } else {\n-        return;  // it might be ok to not have a side-effect\n+        return;  // it might be OK to not have a side-effect\n       }\n     }\n \n--- a/src/com/google/javascript/jscomp/ClosureCodeRemoval.java\n+++ b/src/com/google/javascript/jscomp/ClosureCodeRemoval.java\n  * <p>Currently does the following:</p>\n  *\n  * <ul>\n- *   <li> Instead  of setting abstract methods to a function that throws an\n+ *   <li> Instead of setting abstract methods to a function that throws an\n  *        informative error, this pass allows some binary size reduction by\n  *        removing these methods altogether for production builds.</li>\n  *   <li> Remove calls to assertion functions (like goog.asserts.assert).\n--- a/src/com/google/javascript/jscomp/ClosureCodingConvention.java\n+++ b/src/com/google/javascript/jscomp/ClosureCodingConvention.java\n   }\n \n   /**\n-   * Exctracts X from goog.provide('X'), if the applied Node is goog.\n+   * Extracts X from goog.provide('X'), if the applied Node is goog.\n    *\n    * @return The extracted class name, or null.\n    */\n   }\n \n   /**\n-   * Exctracts X from goog.require('X'), if the applied Node is goog.\n+   * Extracts X from goog.require('X'), if the applied Node is goog.\n    *\n    * @return The extracted class name, or null.\n    */\n--- a/src/com/google/javascript/jscomp/CoalesceVariableNames.java\n+++ b/src/com/google/javascript/jscomp/CoalesceVariableNames.java\n         Var iVar = i.next();\n \n         // Look for all the variables that can be merged (in the graph by now)\n-        // and it is merged with the current coalscedVar.\n+        // and it is merged with the current coalescedVar.\n         if (colorings.peek().getGraph().getNode(iVar) != null &&\n             coalescedVar.equals(colorings.peek().getPartitionSuperNode(iVar))) {\n           allMergedNames.add(iVar.name);\n--- a/src/com/google/javascript/jscomp/CodeConsumer.java\n+++ b/src/com/google/javascript/jscomp/CodeConsumer.java\n       append(\" \");\n     }\n \n-    // Allow formating around the operator.\n+    // Allow formatting around the operator.\n     appendOp(op, binOp);\n \n     // Line breaking after an operator is always safe. Line breaking before an\n--- a/src/com/google/javascript/jscomp/CodeGenerator.java\n+++ b/src/com/google/javascript/jscomp/CodeGenerator.java\n         if (!n.isQuotedString() &&\n             TokenStream.isJSIdentifier(name) &&\n             // do not encode literally any non-literal characters that were\n-            // unicode escaped.\n+            // Unicode escaped.\n             NodeUtil.isLatin(name)) {\n           add(name);\n         } else {\n           }\n \n           // Prefer to break lines in between top-level statements\n-          // because top level statements are more homogeneous.\n+          // because top-level statements are more homogeneous.\n           if (preferLineBreaks) {\n             cc.notePreferredLineBreak();\n           }\n                 !TokenStream.isKeyword(key) &&\n                 TokenStream.isJSIdentifier(key) &&\n                 // do not encode literally any non-literal characters that\n-                // were unicode escaped.\n+                // were Unicode escaped.\n                 NodeUtil.isLatin(key)) {\n               add(key);\n             } else {\n     }\n   }\n \n-  /** Outputs a js string, using the optimal (single/double) quote character */\n+  /** Outputs a JS string, using the optimal (single/double) quote character */\n   private void addJsString(Node n) {\n     String s = n.getString();\n     boolean useSlashV = n.getBooleanProp(Node.SLASH_V);\n     return regexpEscape(s, null);\n   }\n \n-  /** Helper to escape javascript string as well as regular expression */\n+  /** Helper to escape JavaScript string as well as regular expression */\n   private static String strEscape(\n       String s, char quote,\n       String doublequoteEscape,\n               appendHexJavaScriptRepresentation(sb, c);\n             }\n           } else {\n-            // No charsetEncoder provided - pass straight latin characters\n+            // No charsetEncoder provided - pass straight Latin characters\n             // through, and escape the rest.  Doing the explicit character\n             // check is measurably faster than using the CharsetEncoder.\n             if (c > 0x1f && c < 0x7f) {\n               sb.append(c);\n             } else {\n-              // Other characters can be misinterpreted by some js parsers,\n+              // Other characters can be misinterpreted by some JS parsers,\n               // or perhaps mangled by proxies along the way,\n-              // so we play it safe and unicode escape them.\n+              // so we play it safe and Unicode escape them.\n               appendHexJavaScriptRepresentation(sb, c);\n             }\n           }\n       return s;\n     }\n \n-    // Now going through the string to escape non-latin characters if needed.\n+    // Now going through the string to escape non-Latin characters if needed.\n     StringBuilder sb = new StringBuilder();\n     for (int i = 0; i < s.length(); i++) {\n       char c = s.charAt(i);\n   }\n \n   /**\n-   * Returns a javascript representation of the character in a hex escaped\n+   * Returns a JavaScript representation of the character in a hex escaped\n    * format.\n    *\n-   * @param codePoint The codepoint to append.\n+   * @param codePoint The code point to append.\n    * @param out The buffer to which the hex representation should be appended.\n    */\n   private static void appendHexJavaScriptRepresentation(\n       int codePoint, Appendable out)\n       throws IOException {\n     if (Character.isSupplementaryCodePoint(codePoint)) {\n-      // Handle supplementary unicode values which are not representable in\n-      // javascript.  We deal with these by escaping them as two 4B sequences\n-      // so that they will round-trip properly when sent from java to javascript\n+      // Handle supplementary Unicode values which are not representable in\n+      // JavaScript.  We deal with these by escaping them as two 4B sequences\n+      // so that they will round-trip properly when sent from Java to JavaScript\n       // and back.\n       char[] surrogates = Character.toChars(codePoint);\n       appendHexJavaScriptRepresentation(surrogates[0], out);\n--- a/src/com/google/javascript/jscomp/CodePrinter.java\n+++ b/src/com/google/javascript/jscomp/CodePrinter.java\n import java.util.List;\n \n /**\n- * CodePrinter prints out js code in either pretty format or compact format.\n+ * CodePrinter prints out JS code in either pretty format or compact format.\n  *\n  * @see CodeGenerator\n  */\n     // The CompactCodePrinter tries to emit just enough newlines to stop there\n     // being lines longer than the threshold.  Since the output is going to be\n     // gzipped, it makes sense to try to make the newlines appear in similar\n-    // contexts so that GZIP can encode them for 'free'.\n+    // contexts so that gzip can encode them for 'free'.\n     //\n     // This version tries to break the lines at 'preferred' places, which are\n-    // between the top-level forms.  This works because top level forms tend to\n-    // be more uniform than arbitary legal contexts.  Better compression would\n-    // probably require explicit modelling of the gzip algorithm.\n+    // between the top-level forms.  This works because top-level forms tend to\n+    // be more uniform than arbitrary legal contexts.  Better compression would\n+    // probably require explicit modeling of the gzip algorithm.\n \n     private final boolean lineBreak;\n     private final boolean preferLineBreakAtEndOfFile;\n   }\n \n   /**\n-   * Converts a tree to js code\n+   * Converts a tree to JS code\n    */\n   private static String toSource(Node root, Format outputFormat,\n                                  boolean lineBreak,  boolean preferEndOfFileBreak,\n--- a/src/com/google/javascript/jscomp/CodingConvention.java\n+++ b/src/com/google/javascript/jscomp/CodingConvention.java\n \n   /**\n    * Convenience method for determining provided dependencies amongst different\n-   * js scripts.\n+   * JS scripts.\n    */\n   public String extractClassNameIfProvide(Node node, Node parent);\n \n   /**\n    * Convenience method for determining required dependencies amongst different\n-   * js scripts.\n+   * JS scripts.\n    */\n   public String extractClassNameIfRequire(Node node, Node parent);\n \n--- a/src/com/google/javascript/jscomp/CollapseProperties.java\n+++ b/src/com/google/javascript/jscomp/CollapseProperties.java\n         compiler.reportCodeChange();\n \n         // Inlining the variable may have introduced new references\n-        // to descendents of {@code name}. So those need to be collected now.\n+        // to descendants of {@code name}. So those need to be collected now.\n         namespace.scanNewNodes(alias.scope, newNodes);\n         return true;\n       }\n       //     name a$b$c\n       //       NODE\n \n-      // Remove the rvalue (NODE).\n+      // Remove the r-value (NODE).\n       parent.removeChild(rvalue);\n       nameNode.addChildToFront(rvalue);\n \n--- a/src/com/google/javascript/jscomp/CommandLineRunner.java\n+++ b/src/com/google/javascript/jscomp/CommandLineRunner.java\n     private String logging_level = Level.WARNING.getName();\n \n     @Option(name = \"--externs\",\n-        usage = \"The file containing javascript externs. You may specify\"\n+        usage = \"The file containing JavaScript externs. You may specify\"\n         + \" multiple\")\n     private List<String> externs = Lists.newArrayList();\n \n     @Option(name = \"--js\",\n-        usage = \"The javascript filename. You may specify multiple\")\n+        usage = \"The JavaScript filename. You may specify multiple\")\n     private List<String> js = Lists.newArrayList();\n \n     @Option(name = \"--js_output_file\",\n     private String js_output_file = \"\";\n \n     @Option(name = \"--module\",\n-        usage = \"A javascript module specification. The format is \"\n+        usage = \"A JavaScript module specification. The format is \"\n         + \"<name>:<num-js-files>[:[<dep>,...][:]]]. Module names must be \"\n         + \"unique. Each dep is the name of a module that this module \"\n-        + \"depends on. Modules must be listed in dependency order, and js \"\n+        + \"depends on. Modules must be listed in dependency order, and JS \"\n         + \"source files must be listed in the corresponding order. Where \"\n         + \"--module flags occur in relation to --js flags is unimportant\")\n     private List<String> module = Lists.newArrayList();\n     private String output_wrapper = \"\";\n \n     @Option(name = \"--module_wrapper\",\n-        usage = \"An output wrapper for a javascript module (optional). \"\n+        usage = \"An output wrapper for a JavaScript module (optional). \"\n         + \"The format is <name>:<wrapper>. The module name must correspond \"\n         + \"with a module specified using --module. The wrapper must \"\n         + \"contain %s as the code placeholder. The %basename% placeholder can \"\n     private List<String> module_wrapper = Lists.newArrayList();\n \n     @Option(name = \"--module_output_path_prefix\",\n-        usage = \"Prefix for filenames of compiled js modules. \"\n+        usage = \"Prefix for filenames of compiled JS modules. \"\n         + \"<module-name>.js will be appended to this prefix. Directories \"\n         + \"will be created as needed. Use with --module\")\n     private String module_output_path_prefix = \"./\";\n     private List<FormattingOption> formatting = Lists.newArrayList();\n \n     @Option(name = \"--process_common_js_modules\",\n-        usage = \"Process Common JS modules to a concatenable form.\")\n+        usage = \"Process CommonJS modules to a concatenable form.\")\n     private boolean process_common_js_modules = false;\n \n     @Option(name = \"--common_js_module_path_prefix\",\n-        usage = \"Path prefix to be removed from Common JS module names.\")\n+        usage = \"Path prefix to be removed from CommonJS module names.\")\n     private String common_js_path_prefix =\n         ProcessCommonJSModules.DEFAULT_FILENAME_PREFIX;\n \n     private String common_js_entry_module;\n \n     @Option(name = \"--transform_amd_modules\",\n-        usage = \"Transform AMD to Common JS modules.\")\n+        usage = \"Transform AMD to CommonJS modules.\")\n     private boolean transform_amd_modules = false;\n \n     @Option(name = \"--process_closure_primitives\",\n         handler = BooleanOptionHandler.class,\n         usage = \"Only include files in the transitive dependency of the \"\n         + \"entry points (specified by closure_entry_point). Files that do \"\n-        + \"not provide dependencies will be removed. This supercedes\"\n+        + \"not provide dependencies will be removed. This supersedes\"\n         + \"manage_closure_dependencies\")\n     private boolean only_closure_dependencies = false;\n \n         usage = \"Prints out a list of all the files in the compilation. \"\n         + \"If --manage_closure_dependencies is on, this will not include \"\n         + \"files that got dropped because they were not required. \"\n-        + \"The %outname% placeholder expands to the js output file. \"\n+        + \"The %outname% placeholder expands to the JS output file. \"\n         + \"If you're using modularization, using %outname% will create \"\n         + \"a manifest for each module.\")\n     private String output_manifest = \"\";\n--- a/src/com/google/javascript/jscomp/Compiler.java\n+++ b/src/com/google/javascript/jscomp/Compiler.java\n  * <li>checks for undefined variables\n  * <li>performs optimizations such as constant folding and constants inlining\n  * <li>renames variables (to short names)\n- * <li>outputs compact javascript code\n+ * <li>outputs compact JavaScript code\n  * </ul>\n  *\n  * External variables are declared in 'externs' files. For instance, the file\n   static <T> T runCallable(\n       final Callable<T> callable, boolean useLargeStackThread, boolean trace) {\n \n-    // Under JRE 1.6, the jscompiler overflows the stack when running on some\n-    // large or complex js code. Here we start a new thread with a larger\n+    // Under JRE 1.6, the JS Compiler overflows the stack when running on some\n+    // large or complex JS code. Here we start a new thread with a larger\n     // stack in order to let the compiler do its thing, without having to\n     // increase the stack size for *every* thread (which is what -Xss does).\n     // Might want to add thread pool support for clients that compile a lot.\n       jsRoot.detachChildren();\n     }\n \n-    // Parse main js sources.\n+    // Parse main JS sources.\n     jsRoot = IR.block();\n     jsRoot.setIsSyntheticBlock(true);\n \n   //------------------------------------------------------------------------\n \n   /**\n-   * Converts the main parse tree back to js code.\n+   * Converts the main parse tree back to JS code.\n    */\n   public String toSource() {\n     return runInCompilerThread(new Callable<String>() {\n   }\n \n   /**\n-   * Converts the parse tree for each input back to js code.\n+   * Converts the parse tree for each input back to JS code.\n    */\n   public String[] toSourceArray() {\n     return runInCompilerThread(new Callable<String[]>() {\n   }\n \n   /**\n-   * Converts the parse tree for a module back to js code.\n+   * Converts the parse tree for a module back to JS code.\n    */\n   public String toSource(final JSModule module) {\n     return runInCompilerThread(new Callable<String>() {\n \n \n   /**\n-   * Converts the parse tree for each input in a module back to js code.\n+   * Converts the parse tree for each input in a module back to JS code.\n    */\n   public String[] toSourceArray(final JSModule module) {\n     return runInCompilerThread(new Callable<String[]>() {\n   }\n \n   /**\n-   * Writes out js code from a root node. If printing input delimiters, this\n+   * Writes out JS code from a root node. If printing input delimiters, this\n    * method will attach a comment to the start of the text indicating which\n    * input the output derived from. If there were any preserve annotations\n    * within the root's source, they will also be printed in a block comment\n \n   /**\n    * The warning classes that are available from the command-line, and\n-   * are suppressable by the {@code @suppress} annotation.\n+   * are suppressible by the {@code @suppress} annotation.\n    */\n   protected DiagnosticGroups getDiagnosticGroups() {\n     return new DiagnosticGroups();\n   @Override\n   SourceFile getSourceFileByName(String sourceName) {\n     // Here we assume that the source name is the input name, this\n-    // is try of javascript parsed from source.\n+    // is try of JavaScript parsed from source.\n     if (sourceName != null) {\n       CompilerInput input = inputsById.get(new InputId(sourceName));\n       if (input != null) {\n--- a/src/com/google/javascript/jscomp/CompilerInput.java\n+++ b/src/com/google/javascript/jscomp/CompilerInput.java\n     } else {\n       // Otherwise, look at the source code.\n       if (!generatedDependencyInfoFromSource) {\n-        // Note: it's ok to use getName() instead of\n+        // Note: it's OK to use getName() instead of\n         // getPathRelativeToClosureBase() here because we're not using\n         // this to generate deps files. (We're only using it for\n         // symbol dependencies.)\n--- a/src/com/google/javascript/jscomp/CompilerOptions.java\n+++ b/src/com/google/javascript/jscomp/CompilerOptions.java\n    */\n   public String checkMissingGetCssNameBlacklist;\n \n-  /** Checks that the synctactic restrictions of Caja are met. */\n+  /** Checks that the syntactic restrictions of Caja are met. */\n   boolean checkCaja;\n \n   public void setCheckCaja(boolean check) {\n   /** Merge two variables together as one. */\n   public boolean coalesceVariableNames;\n \n-  /** Move methds to a deeper module */\n+  /** Move methods to a deeper module */\n   public boolean crossModuleMethodMotion;\n \n   /** Inlines trivial getters */\n   // Special-purpose alterations\n   //--------------------------------\n \n-  /** Inserts runtime type assertions for debugging. */\n+  /** Inserts run-time type assertions for debugging. */\n   boolean runtimeTypeCheck;\n \n   /**\n-   * A JS function to be used for logging runtime type assertion\n+   * A JS function to be used for logging run-time type assertion\n    * failures. It will be passed the warning as a string and the\n    * faulty expression as arguments.\n    */\n   /** Replacements for tweaks. Will be Boolean, Numbers, or Strings */\n   private Map<String, Object> tweakReplacements;\n \n-  /** Move top level function declarations to the top */\n+  /** Move top-level function declarations to the top */\n   public boolean moveFunctionDeclarations;\n \n   /** Instrumentation template to use with #recordFunctionInformation */\n   /** List of properties that we report invalidation errors for. */\n   Map<String, CheckLevel> propertyInvalidationErrors;\n \n-  /** Transform AMD to Common JS modules. */\n+  /** Transform AMD to CommonJS modules. */\n   boolean transformAMDToCJSModules = false;\n \n-  /** Rewrite Common JS modules so that they can be concatenated together. */\n+  /** Rewrite CommonJS modules so that they can be concatenated together. */\n   boolean processCommonJSModules = false;\n \n-  /** Common JS module prefix. */\n+  /** CommonJS module prefix. */\n   String commonJSModulePathPrefix =\n       ProcessCommonJSModules.DEFAULT_FILENAME_PREFIX;\n \n   /** Prefer line breaks at end of file */\n   public boolean preferLineBreakAtEndOfFile;\n \n-  /** Prints a separator comment before each js script */\n+  /** Prints a separator comment before each JS script */\n   public boolean printInputDelimiter;\n \n   /** The string to use as the separator for printInputDelimiter */\n   }\n \n   /**\n-   * Enable runtime type checking, which adds JS type assertions for debugging.\n+   * Enable run-time type checking, which adds JS type assertions for debugging.\n    *\n-   * @param logFunction A JS function to be used for logging runtime type\n+   * @param logFunction A JS function to be used for logging run-time type\n    *     assertion failures.\n    */\n   public void enableRuntimeTypeCheck(String logFunction) {\n \n   /**\n    * Sets dependency options. See the DependencyOptions class for more info.\n-   * This supercedes manageClosureDependencies.\n+   * This supersedes manageClosureDependencies.\n    */\n   public void setDependencyOptions(DependencyOptions options) {\n     Preconditions.checkNotNull(options);\n   }\n \n   /**\n-   * Activates transformation of AMD to CJS modules.\n+   * Activates transformation of AMD to CommonJS modules.\n    */\n   public void setTransformAMDToCJSModules(boolean transformAMDToCJSModules) {\n     this.transformAMDToCJSModules = transformAMDToCJSModules;\n   }\n \n   /**\n-   * Rewrites CommonJS modulee so that modules can be concatenated together,\n+   * Rewrites CommonJS modules so that modules can be concatenated together,\n    * by renaming all globals to avoid conflicting with other modules.\n    */\n   public void setProcessCommonJSModules(boolean processCommonJSModules) {\n   }\n \n   /**\n-   * Sets a path prefix for Common JS modules.\n+   * Sets a path prefix for CommonJS modules.\n    */\n   public void setCommonJSModulePathPrefix(String commonJSModulePathPrefix) {\n     this.commonJSModulePathPrefix = commonJSModulePathPrefix;\n   /** When to do the extra sanity checks */\n   public static enum LanguageMode {\n     /**\n-     * Tranditional JavaScript\n+     * Traditional JavaScript\n      */\n     ECMASCRIPT3,\n \n   }\n \n   /**\n-   * A Role Specific Interface for JsCompiler that represents a data holder\n+   * A Role Specific Interface for JS Compiler that represents a data holder\n    * object which is used to store goog.scope alias code changes to code made\n    * during a compile. There is no guarantee that individual alias changes are\n    * invoked in the order they occur during compilation, so implementations\n   }\n \n   /**\n-   * A Role Specific Interface for the JsCompiler to report aliases used to\n+   * A Role Specific Interface for the JS Compiler to report aliases used to\n    * change the code during a compile.\n    * <p>\n    * While aliases defined by goog.scope are expected to by only 1 per file, and\n-   * the only top level structure in the file, this is not enforced.\n+   * the only top-level structure in the file, this is not enforced.\n    */\n   public interface AliasTransformation {\n \n--- a/src/com/google/javascript/jscomp/ComposeWarningsGuard.java\n+++ b/src/com/google/javascript/jscomp/ComposeWarningsGuard.java\n  * 2) errors with key JSC_BAR should be marked as warning\n  * 3) the rest should be reported as error\n  *\n- * This class is designed for such behaviour.\n+ * This class is designed for such behavior.\n  *\n  * @author anatol@google.com (Anatol Pomazau)\n  */\n--- a/src/com/google/javascript/jscomp/ConcreteType.java\n+++ b/src/com/google/javascript/jscomp/ConcreteType.java\n     @Override ConcreteFunctionType toFunction() { return this; }\n \n     /**\n-     * Returns the slot representing that a call to it occured.  This is\n+     * Returns the slot representing that a call to it occurred.  This is\n      * assigned a type if the function is called.  This ensures that the body of\n      * the function is processed even if it has no arguments or if the arguments\n      * do not take any concrete types as arguments.\n     /** Stores the normal type information for this instance. */\n     public final ObjectType instanceType;\n \n-    /** The tyep information for the implicit prototype of this type, if any. */\n+    /** The type information for the implicit prototype of this type, if any. */\n     private ConcreteInstanceType prototype;\n \n     /**\n \n   /**\n    * Represents an opaque singleton type that is different from any other.\n-   * This is used by DisambiguteProperties to rename GETPROP nodes that are\n+   * This is used by DisambiguateProperties to rename GETPROP nodes that are\n    * never reached in the TightenTypes flow analysis. This helps subsequent\n    * passes remove unreferenced properties and functions.  ID passed to the\n    * constructor should be unique per-instance as it is used for generating\n--- a/src/com/google/javascript/jscomp/ControlFlowAnalysis.java\n+++ b/src/com/google/javascript/jscomp/ControlFlowAnalysis.java\n     if (nextSibling != null) {\n       return computeFallThrough(nextSibling);\n     } else {\n-      // If there are no more siblings, control is transfered up the AST.\n+      // If there are no more siblings, control is transferred up the AST.\n       return computeFollowNode(fromNode, parent, cfa);\n     }\n   }\n \n   /**\n-   * Computes the destination node of n when we want to fallthough into the\n+   * Computes the destination node of n when we want to fallthrough into the\n    * subtree of n. We don't always create a CFG edge into n itself because of\n    * DOs and FORs.\n    */\n--- a/src/com/google/javascript/jscomp/ControlFlowGraph.java\n+++ b/src/com/google/javascript/jscomp/ControlFlowGraph.java\n \n   /**\n    * A special node marked by the node value key null to a singleton\n-   * \"return\" when control is transfered outside of the current control flow\n+   * \"return\" when control is transferred outside of the current control flow\n    * graph.\n    */\n   private final DiGraphNode<N, ControlFlowGraph.Branch> implicitReturn;\n    * {@code null}. See {@link ControlFlowGraph#getOptionalNodeComparator}.\n    * @param isForward Whether the comparator sorts the nodes in the direction of\n    *    the flow.\n-   * @return a comparator or null (in particular, if not overriden)\n+   * @return a comparator or null (in particular, if not overridden)\n    */\n   public Comparator<DiGraphNode<N, Branch>> getOptionalNodeComparator(\n       boolean isForward) {\n--- a/src/com/google/javascript/jscomp/CrossModuleCodeMotion.java\n+++ b/src/com/google/javascript/jscomp/CrossModuleCodeMotion.java\n \n   /**\n    * return true if the node has any form of conditional in its ancestry\n-   * TODO(nicksantos) keep track of the conditionals in the ancestory, so\n+   * TODO(nicksantos) keep track of the conditionals in the ancestry, so\n    * that we don't have to recrawl it.\n    */\n   private boolean hasConditionalAncestor(Node n) {\n   }\n \n   /**\n-   * Determines whether the given NAME node belongs to a delcaration that\n+   * Determines whether the given NAME node belongs to a declaration that\n    * can be moved across modules. If it is, registers it properly.\n    *\n    * There are four types of movable declarations:\n--- a/src/com/google/javascript/jscomp/DataFlowAnalysis.java\n+++ b/src/com/google/javascript/jscomp/DataFlowAnalysis.java\n    * variable local not to our definition of scope.</li>\n    * <li>Exported variables as they can be needed after the script terminates.\n    * </li>\n-   * <li>Names of named functions because in javascript, <i>function foo(){}</i>\n+   * <li>Names of named functions because in JavaScript, <i>function foo(){}</i>\n    * does not kill <i>foo</i> in the dataflow.</li>\n    */\n   static void computeEscaped(final Scope jsScope, final Set<Var> escaped,\n--- a/src/com/google/javascript/jscomp/DefaultPassConfig.java\n+++ b/src/com/google/javascript/jscomp/DefaultPassConfig.java\n       passes.add(crossModuleCodeMotion);\n     }\n \n-    // Method devirtualization benefits from property disambiguiation so\n+    // Method devirtualization benefits from property disambiguation so\n     // it should run after that pass but before passes that do\n     // optimizations based on global names (like cross module code motion\n     // and inline functions).  Smart Name Removal does better if run before\n     }\n   };\n \n-  /** Generates exports for functions associated with JSUnit. */\n+  /** Generates exports for functions associated with JsUnit. */\n   final PassFactory exportTestFunctions =\n       new PassFactory(\"exportTestFunctions\", true) {\n     @Override\n     }\n   };\n \n-  /** Inserts runtime type assertions for debugging. */\n+  /** Inserts run-time type assertions for debugging. */\n   final PassFactory runtimeTypeCheck =\n       new PassFactory(\"runtimeTypeCheck\", true) {\n     @Override\n--- a/src/com/google/javascript/jscomp/DefinitionsRemover.java\n+++ b/src/com/google/javascript/jscomp/DefinitionsRemover.java\n \n   /**\n    * Represents an name-only external definition.  The definition's\n-   * rhs is missing.\n+   * RHS is missing.\n    */\n   abstract static class IncompleteDefinition extends Definition {\n     private static final Set<Integer> ALLOWED_TYPES =\n \n   /**\n    * Represents an name-only external definition.  The definition's\n-   * rhs is missing.\n+   * RHS is missing.\n    */\n   static final class ExternalNameOnlyDefinition extends IncompleteDefinition {\n \n   }\n \n   /**\n-   * Represents a function formal parameter. The definition's rhs is missing.\n+   * Represents a function formal parameter. The definition's RHS is missing.\n    */\n   static final class FunctionArgumentDefinition extends IncompleteDefinition {\n     FunctionArgumentDefinition(Node function,\n   }\n \n   /**\n-   * Represents a function expression that acts as a rhs.  The defined\n+   * Represents a function expression that acts as a RHS.  The defined\n    * name is only reachable from within the function.\n    */\n   static final class FunctionExpressionDefinition extends FunctionDefinition {\n--- a/src/com/google/javascript/jscomp/Denormalize.java\n+++ b/src/com/google/javascript/jscomp/Denormalize.java\n         Node name = n.getFirstChild();\n         if (!name.hasChildren()\n             && forVar.getString().equals(name.getString())) {\n-          // Ok, the names match, and the var declaration does not have an\n+          // OK, the names match, and the var declaration does not have an\n           // initializer. Move it into the loop.\n           parent.removeChild(n);\n           forNode.replaceChild(forVar, n);\n         && nextSibling.getFirstChild().isEmpty()) {\n \n       // Does the current node contain an in operator?  If so, embedding\n-      // the expression in a for loop can cause some Javascript parsers (such\n-      // as the Playstation 3's browser based on Access's NetFront\n+      // the expression in a for loop can cause some JavaScript parsers (such\n+      // as the PlayStation 3's browser based on Access's NetFront\n       // browser) to fail to parse the code.\n       // See bug 1778863 for details.\n       if (NodeUtil.containsType(n, Token.IN)) {\n--- a/src/com/google/javascript/jscomp/DevirtualizePrototypeMethods.java\n+++ b/src/com/google/javascript/jscomp/DevirtualizePrototypeMethods.java\n \n /**\n  * Rewrites prototyped methods calls as static calls that take \"this\"\n- * as their first argument.  This tranformation simplifies the call\n+ * as their first argument.  This transformation simplifies the call\n  * graph so smart name removal, cross module code motion and other\n  * passes can do more.\n  *\n   /**\n    * @returns The new name for a rewritten method.\n    */\n-  private String getRewrittenMethodName(String orginalMethodName) {\n-    return \"JSCompiler_StaticMethods_\" + orginalMethodName;\n+  private String getRewrittenMethodName(String originalMethodName) {\n+    return \"JSCompiler_StaticMethods_\" + originalMethodName;\n   }\n \n   /**\n--- a/src/com/google/javascript/jscomp/DiagnosticGroups.java\n+++ b/src/com/google/javascript/jscomp/DiagnosticGroups.java\n   // New groups should be added to this list if they are public and should\n   // be listed on the command-line as an available option.\n   //\n-  // If a group is suppressable on a per-file basis, it should be added\n+  // If a group is suppressible on a per-file basis, it should be added\n   // to parser/ParserConfig.properties\n   static final String DIAGNOSTIC_GROUP_NAMES =\n       \"accessControls, ambiguousFunctionDecl, checkRegExp, \" +\n--- a/src/com/google/javascript/jscomp/DisambiguateProperties.java\n+++ b/src/com/google/javascript/jscomp/DisambiguateProperties.java\n     T getType(StaticScope<T> scope, Node node, String prop);\n \n     /**\n-     * Returns true if a field reference on this type will invalidiate all\n+     * Returns true if a field reference on this type will invalidate all\n      * references to that field as candidates for renaming. This is true if the\n      * type is unknown or all-inclusive, as variables with such a type could be\n      * references to any object.\n       }\n \n       // We look up the prototype chain to find the highest place (if any) that\n-      // this appears.  This will make references to overriden properties look\n+      // this appears.  This will make references to overridden properties look\n       // like references to the initial property, so they are renamed alike.\n       ObjectType foundType = null;\n       ObjectType objType = ObjectType.cast(type);\n--- a/src/com/google/javascript/jscomp/ExpandJqueryAliases.java\n+++ b/src/com/google/javascript/jscomp/ExpandJqueryAliases.java\n     this.compiler = compiler;\n     this.convention = compiler.getCodingConvention();\n \n-    // All of the \"early\" peephole optimzations.\n+    // All of the \"early\" peephole optimizations.\n     // These passes should make the code easier to analyze.\n     // Passes, such as StatementFusion, are omitted for this reason.\n     final boolean late = false;\n     }\n \n     // Check to see if the return value is used. If not, replace the original\n-    // call with new block. Otherwise wrap the statements in an\n+    // call with new block. Otherwise, wrap the statements in an\n     // immediately-called anonymous function.\n     if (n.getParent().isExprResult()) {\n       Node parent = n.getParent();\n--- a/src/com/google/javascript/jscomp/ExploitAssigns.java\n+++ b/src/com/google/javascript/jscomp/ExploitAssigns.java\n     switch (value.getType()) {\n       case Token.GETPROP:\n         // Do not collapse GETPROPs on arbitrary objects, because\n-        // they may be implemented  setter functions, and oftentimes\n-        // setter functions fail on native objects. This is ok for \"THIS\"\n+        // they may be implemented setter functions, and oftentimes\n+        // setter functions fail on native objects. This is OK for \"THIS\"\n         // objects, because we assume that they are non-native.\n         return !isLValue || value.getFirstChild().isThis();\n \n    *     a = true;\n    *     </code>\n    *     is equal to the name \"a\" and the boolean \"true\".\n-   * @return Whether the expression was collapsed succesfully.\n+   * @return Whether the expression was collapsed successfully.\n    */\n   private boolean collapseAssignEqualTo(Node expr, Node exprParent,\n       Node value) {\n--- a/src/com/google/javascript/jscomp/ExpressionDecomposer.java\n+++ b/src/com/google/javascript/jscomp/ExpressionDecomposer.java\n    * into IF statements.\n    *\n    * The following terms are used:\n-   *    expressionRoot: The top level node before which the any extracted\n+   *    expressionRoot: The top-level node before which the any extracted\n    *                    expressions should be placed before.\n    *    nonconditionalExpr: The node that will be extracted either expres.\n    *\n         // Now handle the call expression\n         if (isExpressionTreeUnsafe(functionExpression, state.sideEffects)\n             && functionExpression.getFirstChild() != grandchild) {\n-          // TODO(johnlenz): In Internet Explorer, non-javascript objects such\n+          // TODO(johnlenz): In Internet Explorer, non-JavaScript objects such\n           // as DOM objects can not be decomposed.\n           Preconditions.checkState(allowObjectCallDecomposing(),\n               \"Object method calls can not be decomposed.\");\n   private String tempNamePrefix = \"JSCompiler_temp\";\n \n   /**\n-   * Allow the temp name to be overriden to make tests more readable.\n+   * Allow the temp name to be overridden to make tests more readable.\n    */\n   @VisibleForTesting\n   public void setTempNamePrefix(String tempNamePrefix) {\n   /**\n    * Walk the AST from the call site to the expression root and verify that\n    * the portions of the expression that are evaluated before the call are:\n-   * 1) Unaffected by the the side-efects, if any, of the call.\n+   * 1) Unaffected by the the side-effects, if any, of the call.\n    * 2) That there are no side-effects, that may influence the call.\n    *\n    * For example, if x has side-effects:\n           // need to be preserved. Like so:\n           //   var t1 = x, t2 = x.m, t3 = f();\n           //   t2.call(t1, t3);\n-          // As IE doesn't support the call to these non-javascript objects\n+          // As IE doesn't support the call to these non-JavaScript objects\n           // methods in this way. We can't do this.\n           // We don't currently distinguish between these types of objects\n           // in the extern definitions and if we did we would need accurate\n--- a/src/com/google/javascript/jscomp/ExtractPrototypeMemberDeclarations.java\n+++ b/src/com/google/javascript/jscomp/ExtractPrototypeMemberDeclarations.java\n \n     /**\n      * @return <@code true> if the sum of all the extraction instance gain\n-     * outweights the overhead of the temp variable declaration.\n+     * outweighs the overhead of the temp variable declaration.\n      */\n     private boolean shouldExtract() {\n       return totalDelta < 0;\n--- a/src/com/google/javascript/jscomp/FindExportableNodes.java\n+++ b/src/com/google/javascript/jscomp/FindExportableNodes.java\n  * FOO = BAR = 5;\n  * and\n  * var FOO = BAR = 5;\n- * are not supported because the annotation is ambigous to whether it applies\n+ * are not supported because the annotation is ambiguous to whether it applies\n  * to all the variables or only the first one.\n  *\n  */\n--- a/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java\n+++ b/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java\n     candidates = Lists.newLinkedList();\n \n     // Using the forward reaching definition search to find all the inline\n-    // candiates\n+    // candidates\n     new NodeTraversal(compiler, new GatherCandiates()).traverse(\n         t.getScopeRoot().getLastChild());\n \n   /**\n    * Gathers a list of possible candidates for inlining based only on\n    * information from {@link MustBeReachingVariableDef}. The list will be stored\n-   * in {@code candidiates} and the validity of each inlining Candidate should\n+   * in {@code candidates} and the validity of each inlining Candidate should\n    * be later verified with {@link Candidate#canInline()} when\n    * {@link MaybeReachingVariableUse} has been performed.\n    */\n         return false;\n       }\n \n-      // We give up inling stuff with R-Value that has GETPROP, GETELEM,\n+      // We give up inlining stuff with R-Value that has GETPROP, GETELEM,\n       // or anything that creates a new object.\n       // Example:\n       // var x = a.b.c; j.c = 1; print(x);\n--- a/src/com/google/javascript/jscomp/FunctionArgumentInjector.java\n+++ b/src/com/google/javascript/jscomp/FunctionArgumentInjector.java\n         loopsEntered++;\n       }\n \n-      // If we have found all the paremeters, don't bother looking\n+      // If we have found all the parameters, don't bother looking\n       // at the children.\n       return !(sideEffectSeen\n           && parameters.size() == parametersReferenced.size());\n--- a/src/com/google/javascript/jscomp/FunctionInjector.java\n+++ b/src/com/google/javascript/jscomp/FunctionInjector.java\n     final boolean assumeMinimumCapture = this.assumeMinimumCapture;\n \n     // Note: functions that contain function definitions are filtered out\n-    // in isCanidateFunction.\n+    // in isCandidateFunction.\n \n     // TODO(johnlenz): Determining if the called function contains VARs\n     // or if the caller contains inner functions accounts for 20% of the\n-    // runtime cost of this pass.\n+    // run-time cost of this pass.\n \n     // Don't inline functions with var declarations into a scope with inner\n     // functions as the new vars would leak into the inner function and\n--- a/src/com/google/javascript/jscomp/FunctionNames.java\n+++ b/src/com/google/javascript/jscomp/FunctionNames.java\n import java.util.*;\n \n /**\n- * Extract a list of all function nodes defined in a javascript\n+ * Extract a list of all function nodes defined in a JavaScript\n  * program, assigns them globally unique ids and computes their fully\n  * qualified names.  Function names are derived from the property they\n  * are assigned to and the scope they are defined in.  For instance,\n--- a/src/com/google/javascript/jscomp/FunctionRewriter.java\n+++ b/src/com/google/javascript/jscomp/FunctionRewriter.java\n \n     Multimap<Reducer, Reduction> reductionMap = HashMultimap.create();\n \n-    // Accumulate possible reductions in the reduction multi map.  They\n+    // Accumulate possible reductions in the reduction multi-map.  They\n     // will be applied in the loop below.\n     NodeTraversal.traverse(compiler, root,\n                            new ReductionGatherer(reducers, reductionMap));\n    */\n   abstract static class Reducer {\n     /**\n-     * @return js source for helper methods used by this reduction.\n+     * @return JS source for helper methods used by this reduction.\n      */\n     abstract String getHelperSource();\n \n      *   function(<args>) {return this.<name>}\n      * and returns <name> if a match is found.\n      *\n-     * @return STRING node that is the rhs of a this property get; or null.\n+     * @return STRING node that is the RHS of a this property get; or null.\n      */\n     private Node getGetPropertyName(Node functionNode) {\n       Node value = maybeGetSingleReturnRValue(functionNode);\n      *   function(<value>, <rest>) {this.<name> = <value>}\n      * and returns <name> if a match is found.\n      *\n-     * @return STRING node that is the rhs of a this property get; or null.\n+     * @return STRING node that is the RHS of a this property get; or null.\n      */\n     private Node getSetPropertyName(Node functionNode) {\n       Node body = functionNode.getLastChild();\n--- a/src/com/google/javascript/jscomp/FunctionToBlockMutator.java\n+++ b/src/com/google/javascript/jscomp/FunctionToBlockMutator.java\n \n   /**\n    *  Convert returns to assignments and breaks, as needed.\n-   *  For example, with a lableName of 'foo':\n+   *  For example, with a labelName of 'foo':\n    *    {\n    *      return a;\n    *    }\n--- a/src/com/google/javascript/jscomp/FunctionTypeBuilder.java\n+++ b/src/com/google/javascript/jscomp/FunctionTypeBuilder.java\n   }\n \n   /**\n-   * Determines whether the given jsdoc info declares a function type.\n+   * Determines whether the given JsDoc info declares a function type.\n    */\n   static boolean isFunctionTypeDeclaration(JSDocInfo info) {\n     return info.getParameterCount() > 0 ||\n   /**\n    * Check whether a type is resolvable in the future\n    * If this has a supertype that hasn't been resolved yet, then we can assume\n-   * this type will be ok once the super type resolves.\n+   * this type will be OK once the super type resolves.\n    * @param objectType\n    * @return true if objectType is resolvable in the future\n    */\n--- a/src/com/google/javascript/jscomp/GatherSideEffectSubexpressionsCallback.java\n+++ b/src/com/google/javascript/jscomp/GatherSideEffectSubexpressionsCallback.java\n         (node.isAnd()) || (node.isOr()),\n         \"Expected: AND or OR, Got: %s\", Token.name(node.getType()));\n \n-    // keep whole expression if rhs of the branching expression\n+    // keep whole expression if RHS of the branching expression\n     // contains a call.\n     Node left = node.getFirstChild();\n     Node right = left.getNext();\n--- a/src/com/google/javascript/jscomp/GlobalNamespace.java\n+++ b/src/com/google/javascript/jscomp/GlobalNamespace.java\n     }\n \n     /**\n-     * Builds a global namepsace, but only visits nodes that match the\n+     * Builds a global namespace, but only visits nodes that match the\n      * given filter.\n      */\n     BuildGlobalNamespace(Predicate<Node> nodeFilter) {\n     /**\n      * Gets the type of a value or simple expression.\n      *\n-     * @param n An rvalue in an assignment or variable declaration (not null)\n+     * @param n An r-value in an assignment or variable declaration (not null)\n      * @return A {@link Name.Type}\n      */\n     Name.Type getValueType(Node n) {\n     }\n \n     /**\n-     * Updates our respresentation of the global namespace to reflect an\n+     * Updates our representation of the global namespace to reflect an\n      * assignment to a global name in global scope.\n      *\n      * @param t The traversal\n     }\n \n     /**\n-     * Updates our respresentation of the global namespace to reflect an\n+     * Updates our representation of the global namespace to reflect an\n      * assignment to a global name in a local scope.\n      *\n      * @param t The traversal\n     }\n \n     /**\n-     * Updates our respresentation of the global namespace to reflect a read\n+     * Updates our representation of the global namespace to reflect a read\n      * of a global name.\n      *\n      * @param t The traversal\n     }\n \n     /**\n-     * Updates our respresentation of the global namespace to reflect a read\n+     * Updates our representation of the global namespace to reflect a read\n      * of a global name.\n      *\n      * @param t The current node traversal\n     }\n \n     /**\n-     * Updates our respresentation of the global namespace to reflect a read\n+     * Updates our representation of the global namespace to reflect a read\n      * of a global name's longest prefix before the \"prototype\" property if the\n      * name includes the \"prototype\" property. Does nothing otherwise.\n      *\n--- a/src/com/google/javascript/jscomp/GoogleJsMessageIdGenerator.java\n+++ b/src/com/google/javascript/jscomp/GoogleJsMessageIdGenerator.java\n     }\n \n     /**\n-     * Generate fingerprint of \"str\". Equivalent to utf-encoding \"str\" into\n+     * Generate fingerprint of \"str\". Equivalent to UTF-encoding \"str\" into\n      * bytes and then fingerprinting those bytes.\n      */\n     private static long fingerprint(String str) {\n \n   /**\n    * Generates fingerprint for an English message using the FP package.\n-   * This supercedes the message id generation using C fingerprint\n+   * This supersedes the message id generation using C fingerprint\n    * functions and JNI.  This is slower than the C implementation (\n    * we're talking about microseconds here) but it avoids using JNI and\n    * shared libraries.<p>\n--- a/src/com/google/javascript/jscomp/HotSwapCompilerPass.java\n+++ b/src/com/google/javascript/jscomp/HotSwapCompilerPass.java\n  * should implement this interface.\n  * <p>\n  * It is assumed that {@code Node} argument of {@code hotSwapScript} is the root\n- * of a sub-tree in AST that represents a js file and so is of type {@code\n+ * of a sub-tree in AST that represents a JS file and so is of type {@code\n  * Token.SCRIPT}.\n  *\n  * @author bashir@google.com (Bashir Sadjad)\n--- a/src/com/google/javascript/jscomp/InlineCostEstimator.java\n+++ b/src/com/google/javascript/jscomp/InlineCostEstimator.java\n   }\n \n   /**\n-   * Determines the size of the js code.\n+   * Determines the size of the JS code.\n    */\n   static int getCost(Node root) {\n     return getCost(root, Integer.MAX_VALUE);\n   }\n \n   /**\n-   * Determines the estimated size of the js snippet represented by the node.\n+   * Determines the estimated size of the JS snippet represented by the node.\n    */\n   static int getCost(Node root, int costThreshhold) {\n     CompiledSizeEstimator estimator = new CompiledSizeEstimator(costThreshhold);\n--- a/src/com/google/javascript/jscomp/InlineFunctions.java\n+++ b/src/com/google/javascript/jscomp/InlineFunctions.java\n \n         // verify the function meets all the requirements.\n         // TODO(johnlenz): Minimum requirement checks are about 5% of the\n-        // runtime cost of this pass.\n+        // run-time cost of this pass.\n         if (!isCandidateFunction(fn)) {\n           // It doesn't meet the requirements.\n           fs.setInline(false);\n     /** Gets the function node */\n     public Node getFunctionNode();\n \n-    /** Removes itself from the javascript */\n+    /** Removes itself from the JavaScript */\n     public void remove();\n \n     public Node getDeclaringBlock();\n \n     public FunctionExpression(Node fn, int index) {\n       this.fn = fn;\n-      // A number is not a valid function javascript indentifier\n+      // A number is not a valid function JavaScript identifier\n       // so we don't need to worry about collisions.\n       this.fakeName = String.valueOf(index);\n     }\n--- a/src/com/google/javascript/jscomp/InlineObjectLiterals.java\n+++ b/src/com/google/javascript/jscomp/InlineObjectLiterals.java\n \n     /**\n      * Counts the number of direct (full) references to an object.\n-     * Specifically we check for references of the following type:\n+     * Specifically, we check for references of the following type:\n      * <pre>\n      *   x;\n      *   x.fn();\n           return false;\n         }\n \n-        // Make sure that the value is not self-refential. IOW,\n+        // Make sure that the value is not self-referential. IOW,\n         // disallow things like x = {b: x.a}.\n         //\n         // TODO: Only exclude unorderable self-referential\n--- a/src/com/google/javascript/jscomp/InlineSimpleMethods.java\n+++ b/src/com/google/javascript/jscomp/InlineSimpleMethods.java\n   }\n \n   /**\n-   * Finds the occurence of \"this\" in the provided property tree and replaces\n+   * Finds the occurrence of \"this\" in the provided property tree and replaces\n    * it with replacement\n    */\n   private static void replaceThis(Node expectedGetprop, Node replacement) {\n--- a/src/com/google/javascript/jscomp/InlineVariables.java\n+++ b/src/com/google/javascript/jscomp/InlineVariables.java\n       // rather than the context of the window.\n       //   var a = b.c;\n       //   f(a)\n-      // is ok.\n+      // is OK.\n       Node value = initialization.getAssignedValue();\n       Preconditions.checkState(value != null);\n       if (value.isGetProp()\n--- a/src/com/google/javascript/jscomp/InstrumentFunctions.java\n+++ b/src/com/google/javascript/jscomp/InstrumentFunctions.java\n   private final List<String> declarationsToRemove;\n \n   /**\n-   * Creates an intrument functions compiler pass.\n+   * Creates an instrument functions compiler pass.\n    *\n    * @param compiler          The JSCompiler\n    * @param functionNames     Assigned function identifiers.\n--- a/src/com/google/javascript/jscomp/JSModule.java\n+++ b/src/com/google/javascript/jscomp/JSModule.java\n \n   /**\n    * Adds a source code input to this module. Call only if the input might\n-   * already be associated with a module. Otherwise use\n+   * already be associated with a module. Otherwise, use\n    * add(CompilerInput input).\n    */\n   void addAndOverrideModule(CompilerInput input) {\n--- a/src/com/google/javascript/jscomp/JsMessage.java\n+++ b/src/com/google/javascript/jscomp/JsMessage.java\n   }\n \n   /**\n-   * Contains functionality for creating js messages. Generates authoritative\n+   * Contains functionality for creating JS messages. Generates authoritative\n    * keys and fingerprints for a message that must stay constant over time.\n    *\n    * This implementation correctly processes unnamed messages and creates a key\n       return this;\n     }\n \n-    /** Returns the message registred placeholders */\n+    /** Returns the message registered placeholders */\n     public Set<String> getPlaceholders() {\n       return placeholders;\n     }\n         0x2b992ddfa23249d6L; // part of pi, arbitrary\n \n     /** Hash constant (64 bit) */\n-    private  static final long CONSTANT64 =\n+    private static final long CONSTANT64 =\n         0xe08c1d668b756f82L; // part of golden ratio, arbitrary\n \n \n--- a/src/com/google/javascript/jscomp/JsMessageDefinition.java\n+++ b/src/com/google/javascript/jscomp/JsMessageDefinition.java\n import com.google.javascript.rhino.Node;\n \n /**\n- * Container class that holds information about jsmessage source.\n+ * Container class that holds information about JS message source.\n  *\n  * This class is specific to our JsMessage syntax. Allows you to use the\n  * new-style or the old-style messages.\n   private final Node visitingNode;\n \n   /**\n-   * Constructs js message definition.\n+   * Constructs JS message definition.\n    *\n    * @param visitingNode Node that is visited by\n    *     {@link JsMessageVisitor}. Take into\n--- a/src/com/google/javascript/jscomp/JsMessageExtractor.java\n+++ b/src/com/google/javascript/jscomp/JsMessageExtractor.java\n   }\n \n   /**\n-   * Extracts js messages from javascript code.\n+   * Extracts JS messages from JavaScript code.\n    */\n   public Collection<JsMessage> extractMessages(SourceFile... inputs)\n       throws IOException {\n \n \n   /**\n-   * Extracts js messages from javascript code.\n+   * Extracts JS messages from JavaScript code.\n    *\n-   * @param inputs  the javascript source code inputs\n+   * @param inputs  the JavaScript source code inputs\n    * @return the extracted messages collection\n-   * @throws IOException if there is a problem reading the js code\n-   * @throws RuntimeException if there are problems parsing the js code or the\n-   *     js messages, or if two messages have the same key\n+   * @throws IOException if there is a problem reading the JS code\n+   * @throws RuntimeException if there are problems parsing the JS code or the\n+   *     JS messages, or if two messages have the same key\n    */\n   public <T extends SourceFile> Collection<JsMessage> extractMessages(\n       Iterable<T> inputs) throws IOException {\n     ExtractMessagesVisitor extractCompilerPass =\n         new ExtractMessagesVisitor(compiler);\n     for (SourceFile input : inputs) {\n-      // Parse the js files individually, to prevent out-of-memory\n+      // Parse the JS files individually, to prevent out-of-memory\n       // problems.\n       Node root = new JsAst(input).getAstRoot(compiler);\n \n--- a/src/com/google/javascript/jscomp/JsMessageVisitor.java\n+++ b/src/com/google/javascript/jscomp/JsMessageVisitor.java\n   /**\n    * Pattern for unnamed messages.\n    * <p>\n-   * All jsmessages in js code should have unique name but messages in generated\n-   * code (i.e. from soy template) could have duplicated message names. Later we\n-   * replace the message names with ids constructed as a hash of the message\n-   * content.\n+   * All JS messages in JS code should have unique name but messages in\n+   * generated code (i.e. from soy template) could have duplicated message names.\n+   * Later we replace the message names with ids constructed as a hash of the\n+   * message content.\n    * <p>\n    * <link href=\"http://code.google.com/p/closure-templates/\">\n    * Soy</link> generates messages with names MSG_UNNAMED_<NUMBER> . This\n \n   static final String HIDDEN_DESC_PREFIX = \"@hidden\";\n \n-  // For old-style js messages\n+  // For old-style JS messages\n   private static final String DESC_SUFFIX = \"_HELP\";\n \n   private final boolean needToCheckDuplications;\n   private final CheckLevel checkLevel;\n \n   /**\n-   * Creates js message visitor.\n+   * Creates JS message visitor.\n    *\n    * @param compiler the compiler instance\n    * @param needToCheckDuplications whether to check duplicated messages in\n         ? CheckLevel.ERROR : CheckLevel.WARNING;\n \n     // TODO(anatol): add flag that decides whether to process UNNAMED messages.\n-    // Some projects would not want such functionality (unnamed) as they dont\n+    // Some projects would not want such functionality (unnamed) as they don't\n     // use SOY templates.\n   }\n \n    *\n    * @param sourceName the source file name\n    * @param msgName the name of the message\n-   * @param msgNode the node that represents js message\n+   * @param msgNode the node that represents JS message\n    */\n   private void checkIfMessageDuplicated(String sourceName, String msgName,\n       Node msgNode) {\n   }\n \n   /**\n-   * Creates a {@link JsMessage} for a js message defined using a js variable\n+   * Creates a {@link JsMessage} for a JS message defined using a JS variable\n    * declaration (e.g <code>var MSG_X = ...;</code>).\n    *\n    * @param builder the message builder\n-   * @param nameNode a NAME node for a js message variable\n+   * @param nameNode a NAME node for a JS message variable\n    * @param parentNode a VAR node, parent of {@code nameNode}\n    * @param grandParentNode the grandparent of {@code nameNode}. This node is\n    *        only used to get meta data about the message that might be\n    *        surrounding it (e.g. a message description). This argument may be\n    *        null if the meta data is not needed.\n    * @throws MalformedException if {@code varNode} does not\n-   *         correspond to a valid js message VAR node\n+   *         correspond to a valid JS message VAR node\n    */\n   private void extractMessageFromVariable(\n       Builder builder, Node nameNode, Node parentNode,\n   }\n \n   /**\n-   * Creates a {@link JsMessage} for a js message defined using an assignment to\n+   * Creates a {@link JsMessage} for a JS message defined using an assignment to\n    * a qualified name (e.g <code>a.b.MSG_X = goog.getMsg(...);</code>).\n    *\n    * @param builder the message builder\n-   * @param getPropNode a GETPROP node in a js message assignment\n+   * @param getPropNode a GETPROP node in a JS message assignment\n    * @param assignNode an ASSIGN node, parent of {@code getPropNode}.\n    * @throws MalformedException if {@code getPropNode} does not\n-   *         correspond to a valid js message node\n+   *         correspond to a valid JS message node\n    */\n   private void extractMessageFromProperty(\n       Builder builder, Node getPropNode, Node assignNode)\n   }\n \n   /**\n-   * Returns the string value associated with a node representing a js string or\n-   * several js strings added together (e.g. {@code 'str'} or {@code 's' + 't' +\n+   * Returns the string value associated with a node representing a JS string or\n+   * several JS strings added together (e.g. {@code 'str'} or {@code 's' + 't' +\n    * 'r'}).\n    *\n    * @param node the node from where we extract the string\n    * Appends the message parts in a JS message value extracted from the given\n    * text node.\n    *\n-   * @param builder the js message builder to append parts to\n+   * @param builder the JS message builder to append parts to\n    * @param node the node with string literal that contains the message text\n    * @throws MalformedException if {@code value} contains a reference to\n    *         an unregistered placeholder\n \n \n   /**\n-   * Processes found js message. Several examples of \"standard\" processing\n+   * Processes found JS message. Several examples of \"standard\" processing\n    * routines are:\n    * <ol>\n-   * <li>extract all js messages\n-   * <li>replace js messages with localized versions for some specific language\n+   * <li>extract all JS messages\n+   * <li>replace JS messages with localized versions for some specific language\n    * <li>check that messages have correct syntax and present in localization\n    *     bundle\n    * </ol>\n       JsMessageDefinition definition);\n \n   /**\n-   * Returns whether the given js identifier is a valid js message name.\n+   * Returns whether the given JS identifier is a valid JS message name.\n    */\n   boolean isMessageName(String identifier, boolean isNewStyleMessage) {\n     return identifier.startsWith(MSG_PREFIX) &&\n--- a/src/com/google/javascript/jscomp/LinkedFlowScope.java\n+++ b/src/com/google/javascript/jscomp/LinkedFlowScope.java\n \n       // If two flow scopes are in the same function, then they could have\n       // two possible function scopes: the real one and the BOTTOM scope.\n-      // If they have different function scopes, we *should* iterate thru all\n+      // If they have different function scopes, we *should* iterate through all\n       // the variables in each scope and compare. However, 99.9% of the time,\n       // they're not equal. And the other .1% of the time, we can pretend\n       // they're equal--this just means that data flow analysis will have\n    * as possible in a map. Optimized for fast lookup.\n    */\n   private static class FlatFlowScopeCache {\n-    // The Scope for the entire function or for the gloal scope.\n+    // The Scope for the entire function or for the global scope.\n     private final Scope functionScope;\n \n     // The linked flow scope that this cache represents.\n--- a/src/com/google/javascript/jscomp/MakeDeclaredNamesUnique.java\n+++ b/src/com/google/javascript/jscomp/MakeDeclaredNamesUnique.java\n   // the arguments declaration.\n   public static final String ARGUMENTS = \"arguments\";\n \n-  // The name stack is similiar to how we model scopes but handles some\n+  // The name stack is similar to how we model scopes but handles some\n   // additional cases that are not handled by the current Scope object.\n   // Specifically, a Scope currently has only two concepts of scope (global,\n   // and function local).  But there are in reality a couple of additional\n     Node declarationRoot = t.getScopeRoot();\n     Renamer renamer;\n     if (nameStack.isEmpty()) {\n-      // If the contextual renamer is being used the starting context can not\n+      // If the contextual renamer is being used, the starting context can not\n       // be a function.\n       Preconditions.checkState(\n           !declarationRoot.isFunction() ||\n         if (newName != null) {\n           Renamer renamer = nameStack.peek();\n           if (renamer.stripConstIfReplaced()) {\n-            // TODO(johnlenz): Do we need to do anything about the javadoc?\n+            // TODO(johnlenz): Do we need to do anything about the Javadoc?\n             n.removeProp(Node.IS_CONSTANT_NAME);\n           }\n           n.setString(newName);\n \n     /**\n      * For the Var declared in the current scope determine if it is possible\n-     * to revert the name to its orginal form without conflicting with other\n+     * to revert the name to its original form without conflicting with other\n      * values.\n      */\n     void handleScopeVar(Var v) {\n--- a/src/com/google/javascript/jscomp/MarkNoSideEffectCalls.java\n+++ b/src/com/google/javascript/jscomp/MarkNoSideEffectCalls.java\n     SimpleDefinitionFinder defFinder = new SimpleDefinitionFinder(compiler);\n     defFinder.process(externs, root);\n \n-    // Gather the list of function nodes that have @nosideeffect annotations.\n+    // Gather the list of function nodes that have @nosideeffects annotations.\n     // For use by SetNoSideEffectCallProperty.\n     NodeTraversal.traverse(\n         compiler, externs, new GatherNoSideEffectFunctions(true));\n   }\n \n   /**\n-   * Determines if the type of the value of the rhs expression can\n+   * Determines if the type of the value of the RHS expression can\n    * be a function node.\n    */\n   private static boolean definitionTypeContainsFunctionType(Definition def) {\n--- a/src/com/google/javascript/jscomp/MessageBundle.java\n+++ b/src/com/google/javascript/jscomp/MessageBundle.java\n package com.google.javascript.jscomp;\n \n /**\n- * An interface for providing alterative values for user-visible messages in\n- * javascript code.\n+ * An interface for providing alternative values for user-visible messages in\n+ * JavaScript code.\n  *\n  */\n public interface MessageBundle {\n--- a/src/com/google/javascript/jscomp/MoveFunctionDeclarations.java\n+++ b/src/com/google/javascript/jscomp/MoveFunctionDeclarations.java\n import java.util.Map.Entry;\n \n /**\n- * Moves top level function declarations to the top.\n+ * Moves top-level function declarations to the top.\n  *\n  * Enable this pass if a try catch block wraps the output after compilation,\n  * and the output runs on Firefox because function declarations are only\n--- a/src/com/google/javascript/jscomp/NameAnalyzer.java\n+++ b/src/com/google/javascript/jscomp/NameAnalyzer.java\n  * TODO(nicksantos): In the initial implementation of this pass, it was\n  * important to understand namespaced names (e.g., that a.b is distinct from\n  * a.b.c). Now that this pass comes after CollapseProperties, this is no longer\n- * necessary. For now, I've changed so that {@code refernceParentNames}\n+ * necessary. For now, I've changed so that {@code referenceParentNames}\n  * creates a two-way reference between a.b and a.b.c, so that they're\n  * effectively the same name. When someone has the time, we should completely\n  * rip out all the logic that understands namespaces.\n \n   /**\n    * Create JsName objects for variable and function declarations in\n-   * the global scope before computing name references.  In javascript\n+   * the global scope before computing name references.  In JavaScript\n    * it is legal to refer to variable and function names before the\n    * actual declaration.\n    */\n     NodeTraversal.traverse(compiler, root, new FindReferences());\n \n     // Create bi-directional references between parent names and their\n-    // descendents. This may create new names.\n+    // descendants. This may create new names.\n     referenceParentNames();\n \n     // If we modify the property of an alias, make sure that modification\n    * Replace n with a simpler expression, while preserving program\n    * behavior.\n    *\n-   * If the n's value is used, replace it with its rhs; otherwise\n+   * If the n's value is used, replace it with its RHS; otherwise\n    * replace it with the subexpressions that have side effects.\n    */\n   private void replaceWithRhs(Node parent, Node n) {\n   /**\n    * Determine if the parent reads the value of a child expression\n    * directly.  This is true children used in predicates, RETURN\n-   * statements and, rhs of variable declarations and assignments.\n+   * statements and, RHS of variable declarations and assignments.\n    *\n    * In the case of:\n    * if (a) b else c\n    *\n    * This method returns true for \"a\", and false for \"b\" and \"c\": the\n    * IF expression does something special based on \"a\"'s value.  \"b\"\n-   * and \"c\" are effectivelly outputs.  Same logic applies to FOR,\n+   * and \"c\" are effectively outputs.  Same logic applies to FOR,\n    * WHILE and DO loop predicates.  AND/OR/HOOK expressions are\n    * syntactic sugar for IF statements; therefore this method returns\n    * true for the predicate and false otherwise.\n         // process body\n         return getRhsSubexpressions(n.getFirstChild());\n       case Token.FUNCTION:\n-        // function nodes have no rhs\n+        // function nodes have no RHS\n         return Collections.emptyList();\n       case Token.NAME:\n         {\n-          // parent is a var node.  rhs is first child\n+          // parent is a var node.  RHS is the first child\n           Node rhs = n.getFirstChild();\n           if (rhs != null) {\n             return Lists.newArrayList(rhs);\n         }\n       case Token.ASSIGN:\n         {\n-          // add lhs and rhs expressions - lhs may be a complex expression\n+          // add LHS and RHS expressions - LHS may be a complex expression\n           Node lhs = n.getFirstChild();\n           Node rhs = lhs.getNext();\n           return Lists.newArrayList(lhs, rhs);\n--- a/src/com/google/javascript/jscomp/NameAnonymousFunctionsMapped.java\n+++ b/src/com/google/javascript/jscomp/NameAnonymousFunctionsMapped.java\n import java.util.logging.*;\n \n /**\n- * Gives anonymous fuction names that are optimized to be small and provides a\n+ * Gives anonymous function names that are optimized to be small and provides a\n  * mapping back to the original names. This makes it way easier to debug because\n  * debuggers and stack traces use the function names. So if you have\n  *\n--- a/src/com/google/javascript/jscomp/NameReferenceGraph.java\n+++ b/src/com/google/javascript/jscomp/NameReferenceGraph.java\n   // The following are some implicit nodes of the graph.\n \n   // If we have a call site that we absolutely have no idea what variable it\n-  // it calls or reference, we'd point it to UKNOWN.\n+  // it calls or reference, we'd point it to UNKNOWN.\n   final Name UNKNOWN;\n \n   // Represents the \"main\" global block as well as externs.\n   final Name MAIN;\n \n-  // The implict \"window\" object.\n+  // The implicit \"window\" object.\n   final Name WINDOW;\n \n   final AbstractCompiler compiler;\n       // TODO(user) We'll be able to remove the check for call or apply once\n       // the name graph handles those call. The issue for now is that those\n       // calls aren't edges in the graph, so we don't have enough information to\n-      // know ifit's safe to change the method's signature.\n+      // know if it's safe to change the method's signature.\n       return !(isExtern() ||\n           !isCallable() ||\n           isAliased() ||\n--- a/src/com/google/javascript/jscomp/NodeIterators.java\n+++ b/src/com/google/javascript/jscomp/NodeIterators.java\n           return;\n         }\n \n-        // Don't advance past a refrence to the variable that we're trying\n+        // Don't advance past a reference to the variable that we're trying\n         // to inline.\n         Node curNode = iterator.current();\n         if (curNode.isName() &&\n--- a/src/com/google/javascript/jscomp/NodeTraversal.java\n+++ b/src/com/google/javascript/jscomp/NodeTraversal.java\n \n \n /**\n- * Nodetraversal allows an iteration through the nodes in the parse tree,\n+ * NodeTraversal allows an iteration through the nodes in the parse tree,\n  * and facilitates the optimizations on the parse tree.\n  *\n  */\n    * root).\n    *\n    * @param node the node to traverse\n-   * @param parent the node's parent, it may be not be {@code null}\n+   * @param parent the node's parent, it may not be {@code null}\n    * @param refinedScope the refined scope of the scope currently at the top of\n    *     the scope stack or in trivial cases that very scope or {@code null}\n    */\n--- a/src/com/google/javascript/jscomp/NodeUtil.java\n+++ b/src/com/google/javascript/jscomp/NodeUtil.java\n       return null;\n     }\n \n-    // FireFox and IE treat the \"Infinity\" differently. FireFox is case\n+    // Firefox and IE treat the \"Infinity\" differently. Firefox is case\n     // insensitive, but IE treats \"infinity\" as NaN.  So leave it alone.\n     if (s.equals(\"infinity\")\n         || s.equals(\"-infinity\")\n   static TernaryValue isStrWhiteSpaceChar(int c) {\n     switch (c) {\n       case '\\u000B': // <VT>\n-        return TernaryValue.UNKNOWN;  // IE says \"no\", EcmaScript says \"yes\"\n+        return TernaryValue.UNKNOWN;  // IE says \"no\", ECMAScript says \"yes\"\n       case ' ': // <SP>\n       case '\\n': // <LF>\n       case '\\r': // <CR>\n    * </code>\n    * If it is evaluated in a different scope, then it\n    * captures a different variable. Even if the function did not read\n-   * any captured vairables directly, it would still fail this definition,\n+   * any captured variables directly, it would still fail this definition,\n    * because it affects the lifecycle of variables in the enclosing scope.\n    *\n    * However, a function literal with respect to a particular scope is\n         return isValidDefineValue(val.getFirstChild(), defines)\n             && isValidDefineValue(val.getLastChild(), defines);\n \n-      // Uniary operators are valid if the child is valid.\n+      // Unary operators are valid if the child is valid.\n       case Token.NOT:\n       case Token.NEG:\n       case Token.POS:\n   /**\n    * Do calls to this constructor have side effects?\n    *\n-   * @param callNode - construtor call node\n+   * @param callNode - constructor call node\n    */\n   static boolean constructorCallHasSideEffects(Node callNode) {\n     return constructorCallHasSideEffects(callNode, null);\n         return false;\n       }\n \n-      // Math.floor has no sideeffects.\n+      // Math.floor has no side-effects.\n       // TODO(nicksantos): This is a terrible terrible hack, until\n-      // I create a definitionprovider that understands namespacing.\n+      // I create a definitionProvider that understands namespacing.\n       if (nameNode.getFirstChild().isName()) {\n         if (\"Math.floor\".equals(nameNode.getQualifiedName())) {\n           return false;\n       case Token.GT:\n       case Token.LE:\n       case Token.GE:\n-      // Queryies\n+      // Queries\n       case Token.IN:\n       case Token.INSTANCEOF:\n       // Inversion\n         // A finally can only be removed if there is a catch.\n         parent.removeChild(node);\n       } else {\n-        // Otherwise only its children can be removed.\n+        // Otherwise, only its children can be removed.\n         node.detachChildren();\n       }\n     } else if (node.isCatch()) {\n    * We treat \"var x;\" as a pseudo-L-value, which kind of makes sense if you\n    * treat it as \"assignment to 'undefined' at the top of the scope\". But if\n    * we're honest with ourselves, it doesn't make sense, and we only do this\n-   * because it makes sense to treat this as synactically similar to\n+   * because it makes sense to treat this as syntactically similar to\n    * \"var x = 0;\".\n    *\n    * @param n The node\n   }\n \n   /**\n-   * Sets the debug information (source file info and orignal name)\n+   * Sets the debug information (source file info and original name)\n    * on the given node.\n    *\n    * @param node The node on which to set the debug information.\n         // no Unicode escaped characters - some browsers are less tolerant\n         // of Unicode characters that might be valid according to the\n         // language spec.\n-        // Note that by this point, unicode escapes have been converted\n+        // Note that by this point, Unicode escapes have been converted\n         // to UTF-16 characters, so we're only searching for character\n         // values, not escapes.\n         isLatin(name);\n   }\n \n   /**\n-   * A pre-order traversal, calling Vistor.visit for each child matching\n+   * A pre-order traversal, calling Visitor.visit for each child matching\n    * the predicate.\n    */\n   static void visitPreOrder(Node node,\n-                     Visitor vistor,\n+                     Visitor visitor,\n                      Predicate<Node> traverseChildrenPred) {\n-    vistor.visit(node);\n+    visitor.visit(node);\n \n     if (traverseChildrenPred.apply(node)) {\n       for (Node c = node.getFirstChild(); c != null; c = c.getNext()) {\n-        visitPreOrder(c, vistor, traverseChildrenPred);\n-      }\n-    }\n-  }\n-\n-  /**\n-   * A post-order traversal, calling Vistor.visit for each child matching\n+        visitPreOrder(c, visitor, traverseChildrenPred);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * A post-order traversal, calling Visitor.visit for each child matching\n    * the predicate.\n    */\n   static void visitPostOrder(Node node,\n-                     Visitor vistor,\n+                     Visitor visitor,\n                      Predicate<Node> traverseChildrenPred) {\n     if (traverseChildrenPred.apply(node)) {\n       for (Node c = node.getFirstChild(); c != null; c = c.getNext()) {\n-        visitPostOrder(c, vistor, traverseChildrenPred);\n-      }\n-    }\n-\n-    vistor.visit(node);\n+        visitPostOrder(c, visitor, traverseChildrenPred);\n+      }\n+    }\n+\n+    visitor.visit(node);\n   }\n \n   /**\n    *     IS_CONSTANT_NAME property.\n    * <li>The normalize pass renames any variable with the IS_CONSTANT_NAME\n    *     annotation and that is initialized to a constant value with\n-   *     a variable name inlucding $$constant.\n+   *     a variable name including $$constant.\n    * <li>Return true here if the variable includes $$constant in its name.\n    * </ol>\n    *\n--- a/src/com/google/javascript/jscomp/Normalize.java\n+++ b/src/com/google/javascript/jscomp/Normalize.java\n  * all is said and done.\n  *\n  * This pass currently does the following:\n- * 1) Simplifies the AST by splitting var statements, moving initializiers\n+ * 1) Simplifies the AST by splitting var statements, moving initializers\n  *    out of for loops, and converting whiles to fors.\n  * 2) Moves hoisted functions to the top of function scopes.\n  * 3) Rewrites unhoisted named function declarations to be var declarations.\n     // It is important that removeDuplicateDeclarations runs after\n     // MakeDeclaredNamesUnique in order for catch block exception names to be\n     // handled properly. Specifically, catch block exception names are\n-    // only valid within the catch block, but our currect Scope logic\n+    // only valid within the catch block, but our current Scope logic\n     // has no concept of this and includes it in the containing function\n     // (or global scope). MakeDeclaredNamesUnique makes the catch exception\n     // names unique so that removeDuplicateDeclarations() will properly handle\n     //      var e = 1; // f scope 'e'\n     //   }\n     // otherwise 'var e = 1' would be rewritten as 'e = 1'.\n-    // TODO(johnlenz): Introduce a seperate scope for catch nodes.\n+    // TODO(johnlenz): Introduce a separate scope for catch nodes.\n     removeDuplicateDeclarations(externs, root);\n     new PropagateConstantAnnotationsOverVars(compiler, assertOnChange)\n         .process(externs, root);\n         }\n \n         JSDocInfo info = null;\n-        // Find the JSDocInfo for a top level variable.\n+        // Find the JSDocInfo for a top-level variable.\n         Var var = t.getScope().getVar(n.getString());\n         if (var != null) {\n           info = var.getJSDocInfo();\n           Preconditions.checkNotNull(previous);\n           functionBody.removeChildAfter(previous);\n \n-          // Readd the function at the top of the function body (after any\n+          // Read the function at the top of the function body (after any\n           // previous declarations).\n           insertAfter = addToFront(functionBody, current, insertAfter);\n           reportCodeChange(\"Move function declaration not at top of function\");\n       if (v != null && v.getParentNode().isCatch()) {\n         // Redeclaration of a catch expression variable is hard to model\n         // without support for \"with\" expressions.\n-        // The EcmaScript spec (section 12.14), declares that a catch\n+        // The ECMAScript spec (section 12.14), declares that a catch\n         // \"catch (e) {}\" is handled like \"with ({'e': e}) {}\" so that\n         // \"var e\" would refer to the scope variable, but any following\n         // reference would still refer to \"e\" of the catch expression.\n--- a/src/com/google/javascript/jscomp/OptimizeArgumentsArray.java\n+++ b/src/com/google/javascript/jscomp/OptimizeArgumentsArray.java\n  */\n class OptimizeArgumentsArray implements CompilerPass, ScopedCallback {\n \n-  // The arguments object as described by ECMA script version 3\n+  // The arguments object as described by ECMAScript version 3\n   // section 10.1.8\n   private static final String ARGUMENTS = \"arguments\";\n \n--- a/src/com/google/javascript/jscomp/OptimizeParameters.java\n+++ b/src/com/google/javascript/jscomp/OptimizeParameters.java\n   }\n \n   /**\n-   * Detemine which parameter use the same expression.\n+   * Determine which parameters use the same expression.\n    * @return Whether any parameter was found that can be updated.\n    */\n   private boolean findFixedParameters(List<Parameter> parameters, Node cur) {\n     if (formalArgPtr != null) {\n       call.removeChild(formalArgPtr);\n       // The value in the parameter object is the one that is being moved into\n-      // function definition leave that one's references.  For everthing else,\n+      // function definition leave that one's references.  For everything else,\n       // remove any references.\n       if (p.getArg() != formalArgPtr) {\n         removedNodes.add(formalArgPtr);\n--- a/src/com/google/javascript/jscomp/OptimizeReturns.java\n+++ b/src/com/google/javascript/jscomp/OptimizeReturns.java\n  * pass looks for results that are complete unused and rewrite then to be:\n  *   \"return x()\" -->\"x(); return\"\n  * , but it can easily be\n- * expanded to look for use context to avoid unneed type coersion:\n+ * expanded to look for use context to avoid unneeded type coercion:\n  *   - \"return x.toString()\" --> \"return x\"\n  *   - \"return !!x\" --> \"return x\"\n  * @author johnlenz@google.com (John Lenz)\n--- a/src/com/google/javascript/jscomp/ParallelCompilerPass.java\n+++ b/src/com/google/javascript/jscomp/ParallelCompilerPass.java\n         // re-throw it and investigate the cause.\n         result.exceptions.add(e);\n         // One of our thread was interrupted, we'll make the current thread to\n-        // be interrupted so any callers that is interested in cancellable\n+        // be interrupted so any caller that is interested in cancelable\n         // execution can cancel.\n         Thread.currentThread().interrupt();\n       }\n--- a/src/com/google/javascript/jscomp/PassFactory.java\n+++ b/src/com/google/javascript/jscomp/PassFactory.java\n   HotSwapCompilerPass getHotSwapPass(AbstractCompiler compiler) {\n     // TODO(bashir): If in future most of PassFactory's in DefaultPassConfig\n     // turns out to be DefaultPassConfig.HotSwapPassFactory, we should probably\n-    // change the implementaion here by the one in HotSwapPassFactory.\n+    // change the implementation here by the one in HotSwapPassFactory.\n     return null;\n   }\n }\n--- a/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\n+++ b/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\n    * Expressions such as [foo() + 'a' + 'b'] generate parse trees\n    * where no node has two const children ((foo() + 'a') + 'b'), so\n    * tryFoldAdd() won't fold it -- tryFoldLeftChildAdd() will (for Strings).\n-   * Specifically it folds Add exprssions where:\n+   * Specifically, it folds Add expressions where:\n    *  - The left child is also and add expression\n    *  - The right child is a constant value\n    *  - The left child's right child is a STRING constant.\n     double result;\n \n     // TODO(johnlenz): Handle NaN with unknown value. BIT ops convert NaN\n-    // to zero so this is a little akward here.\n+    // to zero so this is a little awkward here.\n \n     Double lValObj = NodeUtil.getNumberValue(left);\n     if (lValObj == null) {\n    * Expressions such as [foo() * 10 * 20] generate parse trees\n    * where no node has two const children ((foo() * 10) * 20), so\n    * performArithmeticOp() won't fold it -- tryFoldLeftChildOp() will.\n-   * Specifically it folds associative expressions where:\n+   * Specifically, it folds associative expressions where:\n    *  - The left child is also an associative expression of the same time.\n    *  - The right child is a constant NUMBER constant.\n    *  - The left child's right child is a NUMBER constant.\n   /** Returns whether two JS strings are equal. */\n   private TernaryValue areStringsEqual(String a, String b) {\n     // In JS, browsers parse \\v differently. So do not consider strings\n-    // equal if one containts \\v.\n+    // equal if one contains \\v.\n     if (a.indexOf('\\u000B') != -1 ||\n         b.indexOf('\\u000B') != -1) {\n       return TernaryValue.UNKNOWN;\n--- a/src/com/google/javascript/jscomp/PeepholeFoldWithTypes.java\n+++ b/src/com/google/javascript/jscomp/PeepholeFoldWithTypes.java\n  *\n  * Currently only Token.TYPEOF is folded -- in the future it may be possible to\n  * fold Token.INSTANCEOF as well. Another possibility is folding when\n- * non-nullable objects are used in boolean logic, such as:\n+ * non-nullable objects are used in Boolean logic, such as:\n  * \"if (x) {\" or \"(!x) ? a : b\" or \"x && foo()\"\n  *\n  * TODO(dcc): Support folding Token.INSTANCEOF and non-nullable objects\n- * in boolean logic.\n+ * in Boolean logic.\n  *\n  * @author dcc@google.com (Devin Coughlin)\n  */\n \n   /**\n    * Folds \"typeof expression\" based on the JSType of \"expression\" if the\n-   * expression  has no side effects.\n+   * expression has no side effects.\n    *\n    * <p>E.g.,\n    * <pre>\n--- a/src/com/google/javascript/jscomp/PeepholeRemoveDeadCode.java\n+++ b/src/com/google/javascript/jscomp/PeepholeRemoveDeadCode.java\n       Preconditions.checkState(executingCase.isDefaultCase()\n           || executingCase.isCase());\n       // We only expect a DEFAULT case if the case we are checking is the\n-      // DEFAULT case.  Otherwise we assume the DEFAULT case has already\n+      // DEFAULT case.  Otherwise, we assume the DEFAULT case has already\n       // been removed.\n       Preconditions.checkState(caseNode == executingCase\n           || !executingCase.isDefaultCase());\n             case Token.VAR:\n               if (blockChild.hasOneChild()\n                   && blockChild.getFirstChild().getFirstChild() == null) {\n-                // Variable declarations without initializations are ok.\n+                // Variable declarations without initializations are OK.\n                 continue;\n               }\n               return false;\n--- a/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java\n+++ b/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java\n   }\n \n   /**\n-   * @return The uppered string Node.\n+   * @return The upped string Node.\n    */\n   private Node tryFoldStringToUpperCase(Node subtree, Node stringNode) {\n     // From Rhino, NativeString.java. See ECMA 15.5.4.12\n-    String uppered = stringNode.getString().toUpperCase(ROOT_LOCALE);\n-    Node replacement = IR.string(uppered);\n+    String upped = stringNode.getString().toUpperCase(ROOT_LOCALE);\n+    Node replacement = IR.string(upped);\n     subtree.getParent().replaceChild(subtree, replacement);\n     reportCodeChange();\n     return replacement;\n         return n;\n       }\n       // Make sure that the parsed number matches the original string\n-      // This prevents rounding differences between the java implementation\n+      // This prevents rounding differences between the Java implementation\n       // and native script.\n       if (!normalizeNumericString(stringVal).equals(normalizedNewVal)) {\n         return n;\n--- a/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n+++ b/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n   /**\n    * @param late When late is false, this mean we are currently running before\n    * most of the other optimizations. In this case we would avoid optimizations\n-   * that would make the code harder to analyze (such as using string spliting,\n+   * that would make the code harder to analyze (such as using string splitting,\n    * merging statements with commas, etc). When this is true, we would\n    * do anything to minimize for size.\n    */\n         Node fixedIfCondition = IR.not(ifCondition)\n             .srcref(ifCondition);\n \n-        // Ok, join the IF expression with the FOR expression\n+        // OK, join the IF expression with the FOR expression\n         Node forCondition = NodeUtil.getConditionExpression(n);\n         if (forCondition.isEmpty()) {\n           n.replaceChild(forCondition, fixedIfCondition);\n               // It only occurs when both of expressions are not NOT expressions\n               if (!leftParent.isNot()\n                   && !rightParent.isNot()) {\n-                // If an expression has higher precendence than && or ||,\n+                // If an expression has higher precedence than && or ||,\n                 // but lower precedence than NOT, an additional () is needed\n                 // Thus we do not preceed\n                 int op_precedence = NodeUtil.precedence(first.getType());\n         && pattern.getString().length() < 100\n \n         && (null == flags || flags.isString())\n-        // don't escape patterns with unicode escapes since Safari behaves badly\n-        // (read can't parse or crashes) on regex literals with unicode escapes\n+        // don't escape patterns with Unicode escapes since Safari behaves badly\n+        // (read can't parse or crashes) on regex literals with Unicode escapes\n         && (isEcmaScript5OrGreater()\n             || !containsUnicodeEscape(pattern.getString()))) {\n \n \n   /**\n    * are the given flags valid regular expression flags?\n-   * Javascript recognizes several suffix flags for regular expressions,\n+   * JavaScript recognizes several suffix flags for regular expressions,\n    * 'g' - global replace, 'i' - case insensitive, 'm' - multi-line.\n-   * They are case insensitive, and javascript does not recognize the extended\n-   * syntax mode, single-line mode, or expression replacement mode from perl5.\n+   * They are case insensitive, and JavaScript does not recognize the extended\n+   * syntax mode, single-line mode, or expression replacement mode from Perl 5.\n    */\n   private static boolean areValidRegexpFlags(String flags) {\n     return REGEXP_FLAGS_RE.matcher(flags).matches();\n    * 'new RegExp('foobar','g')' with '/foobar/g' may change the behavior of\n    * the program if the RegExp is used inside a loop, for example.\n    * <p>\n-   * EmcaScript 5 explicitly disallows pooling of regular expression literals so\n-   * in EcmaScript 5, {@code /foo/g} and {@code new RegExp('foo', 'g')} are\n+   * ECMAScript 5 explicitly disallows pooling of regular expression literals so\n+   * in ECMAScript 5, {@code /foo/g} and {@code new RegExp('foo', 'g')} are\n    * equivalent.\n    * From section 7.8.5:\n    * \"Then each time the literal is evaluated, a new object is created as if by\n   }\n \n   /**\n-   * true if the javascript string would contain a unicode escape when written\n+   * true if the JavaScript string would contain a Unicode escape when written\n    * out as the body of a regular expression literal.\n    */\n   static boolean containsUnicodeEscape(String s) {\n         ++nSlashes;\n       }\n       // if there are an even number of slashes before the \\ u then it is a\n-      // unicode literal.\n+      // Unicode literal.\n       if (0 == (nSlashes & 1)) { return true; }\n     }\n     return false;\n--- a/src/com/google/javascript/jscomp/PrepareAst.java\n+++ b/src/com/google/javascript/jscomp/PrepareAst.java\n \n     /**\n      * In the AST that Rhino gives us, it needs to make a distinction\n-     * between jsdoc on the object literal node and jsdoc on the object literal\n+     * between JsDoc on the object literal node and JsDoc on the object literal\n      * value. For example,\n      * <pre>\n      * var x = {\n--- a/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\n+++ b/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\n \n       case Token.FUNCTION:\n         // If this is a declaration of a provided named function, this is an\n-        // error. Hosited functions will explode if the're provided.\n+        // error. Hoisted functions will explode if they're provided.\n         if (t.inGlobalScope() &&\n             !NodeUtil.isFunctionExpression(n)) {\n           String name = n.getFirstChild().getString();\n     /**\n      * Record function declaration, variable declaration or assignment that\n      * refers to the same name as the provide statement.  Give preference to\n-     * declarations; if no declation exists record a reference to an\n+     * declarations; if no declaration exists, record a reference to an\n      * assignment so it repurposed later.\n      */\n     void addDefinition(Node node, JSModule module) {\n--- a/src/com/google/javascript/jscomp/ProcessCommonJSModules.java\n+++ b/src/com/google/javascript/jscomp/ProcessCommonJSModules.java\n import java.util.regex.Pattern;\n \n /**\n- * Rewrites a Common JS module http://wiki.commonjs.org/wiki/Modules/1.1.1\n+ * Rewrites a CommonJS module http://wiki.commonjs.org/wiki/Modules/1.1.1\n  * into a form that can be safely concatenated.\n  * Does not add a function around the module body but instead adds suffixes\n  * to global variables to avoid conflicts.\n--- a/src/com/google/javascript/jscomp/ProcessDefines.java\n+++ b/src/com/google/javascript/jscomp/ProcessDefines.java\n     }\n \n     @Override\n-    public  void visit(NodeTraversal t, Node n, Node parent) {\n+    public void visit(NodeTraversal t, Node n, Node parent) {\n       RefInfo refInfo = allRefInfo.get(n);\n       if (refInfo != null) {\n         Ref ref = refInfo.ref;\n           // ReplaceOverriddenVars keeps a call graph of all functions and\n           // which functions/variables that they reference, and tries\n           // to statically determine which functions are \"safe\" and which\n-          // are not. But this would be overkill, expecially because\n+          // are not. But this would be overkill, especially because\n           // the intended use of defines is with config_files, where\n           // all the defines are at the top of the bundle.\n           for (DefineInfo info : assignableDefines.values()) {\n--- a/src/com/google/javascript/jscomp/PureFunctionIdentifier.java\n+++ b/src/com/google/javascript/jscomp/PureFunctionIdentifier.java\n         }\n       }\n \n-      // Handle special cases (Math, RegEx)\n+      // Handle special cases (Math, RegExp)\n       if (callNode.isCall()) {\n         Preconditions.checkState(compiler != null);\n         if (!NodeUtil.functionCallHasSideEffects(callNode, compiler)) {\n   }\n \n   /**\n-   * Gather list of functions, functions with @nosideeffect\n+   * Gather list of functions, functions with @nosideeffects\n    * annotations, call sites, and functions that may mutate variables\n    * not defined in the local scope.\n    */\n \n     /**\n      * Record information about the side effects caused by an\n-     * assigment or mutating unary operator.\n+     * assignment or mutating unary operator.\n      *\n      * If the operation modifies this or taints global state, mark the\n      * enclosing function as having those side effects.\n           }\n         }\n       } else {\n-        // TODO(johnlenz): track down what is inserting NULL on the lhs\n+        // TODO(johnlenz): track down what is inserting NULL on the LHS\n         // of an assign.\n \n-        // The only valid lhs expressions are NAME, GETELEM, or GETPROP.\n+        // The only valid LHS expressions are NAME, GETELEM, or GETPROP.\n         // throw new IllegalStateException(\n-        //     \"Unexpected lhs expression:\" + lhs.toStringTree()\n+        //     \"Unexpected LHS expression:\" + lhs.toStringTree()\n         //    + \", parent: \" + op.toStringTree() );\n         sideEffectInfo.setTaintsUnknown();\n       }\n      * Record information about a call site.\n      */\n     private void visitCall(FunctionInformation sideEffectInfo, Node node) {\n-      // Handle special cases (Math, RegEx)\n+      // Handle special cases (Math, RegExp)\n       if (node.isCall()\n           && !NodeUtil.functionCallHasSideEffects(node, compiler)) {\n         return;\n       public boolean apply(Node value) {\n         switch (value.getType()) {\n           case Token.ASSIGN:\n-            // The assignment might cause an alias, look at the lhs.\n+            // The assignment might cause an alias, look at the LHS.\n             return false;\n           case Token.THIS:\n             // TODO(johnlenz): maybe redirect this to be a tainting list for 'this'.\n           Node objectNode = getCallThisObject(callSite);\n           if (objectNode != null && objectNode.isName()\n               && !isCallOrApply(callSite)) {\n-            // Exclude \".call\" and \".apply\" as the value may still be may be\n+            // Exclude \".call\" and \".apply\" as the value may still be\n             // null or undefined. We don't need to worry about this with a\n             // direct method call because null and undefined don't have any\n             // properties.\n--- a/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\n+++ b/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\n   private final Behavior behavior;\n \n   /**\n-   * Javascript compiler to use in traversing.\n+   * JavaScript compiler to use in traversing.\n    */\n   private final AbstractCompiler compiler;\n \n   }\n \n   /**\n-   * Updates block statck and invokes any additional behavior.\n+   * Updates block stack and invokes any additional behavior.\n    */\n   @Override\n   public void exitScope(NodeTraversal t) {\n           //   BLOCK\n           //     CATCH\n           //   BLOCK\n-          // Note that there is an explcit CATCH token but no explicit\n+          // Note that there is an explicit CATCH token but no explicit\n           // FINALLY token. For simplicity, we consider each BLOCK\n           // a separate basic BLOCK.\n           return true;\n      *\n      * Notice that if this function returns false, this doesn't imply that the\n      * variable is used before it's assigned. It just means that we don't\n-     * have enough information to make a definitive judgement.\n+     * have enough information to make a definitive judgment.\n      */\n     protected boolean isWellDefined() {\n       int size = references.size();\n--- a/src/com/google/javascript/jscomp/RemoveUnusedVars.java\n+++ b/src/com/google/javascript/jscomp/RemoveUnusedVars.java\n \n /**\n  * Garbage collection for variable and function definitions. Basically performs\n- * a mark-and-sweep type algorithm over the javascript parse tree.\n+ * a mark-and-sweep type algorithm over the JavaScript parse tree.\n  *\n  * For each scope:\n  * (1) Scan the variable/function declarations at that scope.\n   }\n \n   /**\n-   * Traverses a function, which creates a new scope in javascript.\n+   * Traverses a function, which creates a new scope in JavaScript.\n    *\n    * Note that CATCH blocks also create a new scope, but only for the\n    * catch variable. Declarations within the block actually belong to the\n--- a/src/com/google/javascript/jscomp/RenameLabels.java\n+++ b/src/com/google/javascript/jscomp/RenameLabels.java\n  * Additionally, labels names are only within the statements include in the\n  * label and do not cross function boundaries. This means that it is possible to\n  * create one label name that is used for labels at any given depth of label\n- * nesting. Typically, the name \"a\" will be used for all top level labels, \"b\"\n+ * nesting. Typically, the name \"a\" will be used for all top-level labels, \"b\"\n  * for the next nested label, and so on. For example:\n  *\n  * <code>\n--- a/src/com/google/javascript/jscomp/RenameProperties.java\n+++ b/src/com/google/javascript/jscomp/RenameProperties.java\n import javax.annotation.Nullable;\n \n /**\n- * RenameProperties renames properties (including methods) of all Javascript\n+ * RenameProperties renames properties (including methods) of all JavaScript\n  * objects. This includes prototypes, functions, object literals, etc.\n  *\n  * <p> If provided a VariableMap of previously used names, it tries to reuse\n  * <p> To prevent a property from getting renamed you may extern it (add it to\n  * your externs file) or put it in quotes.\n  *\n- * <p> To avoid runtime Javascript errors, use quotes when accessing properties\n+ * <p> To avoid run-time JavaScript errors, use quotes when accessing properties\n  * that are defined using quotes.\n  *\n  * <pre>\n--- a/src/com/google/javascript/jscomp/RenamePrototypes.java\n+++ b/src/com/google/javascript/jscomp/RenamePrototypes.java\n  * For custom prototype property names that lack leading and trailing\n  * underscores:\n  * - To always rename these, use aggressive renaming.\n- * - If aggresive renaming is off, we use a heuristic to decide whether to\n- *   rename (to avoid most built-in js methods). We rename if the original name\n+ * - If aggressive renaming is off, we use a heuristic to decide whether to\n+ *   rename (to avoid most built-in JS methods). We rename if the original name\n  *   contains at least one character that is not a lowercase letter.\n  *\n  * When a property name is used both in a prototype definition and as an object\n- * literal key, we rename it only if it satisifies both renaming policies.\n+ * literal key, we rename it only if it satisfies both renaming policies.\n  *\n  */\n class RenamePrototypes implements CompilerPass {\n--- a/src/com/google/javascript/jscomp/ReorderConstantExpression.java\n+++ b/src/com/google/javascript/jscomp/ReorderConstantExpression.java\n   // to follow our naming convention.\n   @Override\n   Node optimizeSubtree(Node subtree) {\n-    // if the operator is symertric\n+    // if the operator is symmetric\n     if (NodeUtil.isSymmetricOperation(subtree)\n         || NodeUtil.isRelationalOperation(subtree)) {\n       // right value is immutable and left is not\n--- a/src/com/google/javascript/jscomp/ReplaceMessages.java\n+++ b/src/com/google/javascript/jscomp/ReplaceMessages.java\n           String arg = node.getString();\n \n           // We ignore the case here because the transconsole only supports\n-          // uppercase placeholder names, but function arguments in javascript\n+          // uppercase placeholder names, but function arguments in JavaScript\n           // code can have mixed case.\n           if (arg.equalsIgnoreCase(phRef.getName())) {\n             partNode = IR.name(arg);\n--- a/src/com/google/javascript/jscomp/ReplaceStrings.java\n+++ b/src/com/google/javascript/jscomp/ReplaceStrings.java\n     this.registry = compiler.getTypeRegistry();\n     this.nameGenerator = createNameGenerator(reservedNames);\n \n-    // Intialize the map of functions to inspect for renaming canidates.\n+    // Initialize the map of functions to inspect for renaming candidates.\n     parseConfiguration(functionsToInspect);\n   }\n \n--- a/src/com/google/javascript/jscomp/RescopeGlobalSymbols.java\n+++ b/src/com/google/javascript/jscomp/RescopeGlobalSymbols.java\n     // single symbol by:\n     // (If necessary the 3 traversals could be combined. They are left\n     // separate for readability reasons.)\n-    // 1. turning global named function statements into var assigments.\n+    // 1. turning global named function statements into var assignments.\n     NodeTraversal.traverse(compiler, root,\n         new RewriteGlobalFunctionStatementsToVarAssignmentsCallback());\n     // 2. rewriting all references to be property accesses of the single symbol.\n       }\n       // When the globalSymbolNamespace is used as a local variable name\n       // add suffix to avoid shadowing the namespace. Also add a suffix\n-      // if a name starts with the name of the globalSymbolnamespace and\n+      // if a name starts with the name of the globalSymbolNamespace and\n       // the suffix.\n       if (!var.isExtern() && (name.equals(globalSymbolNamespace) ||\n           name.indexOf(globalSymbolNamespace + DISAMBIGUATION_SUFFIX) == 0)) {\n   }\n \n   /**\n-   * Removes every occurence of var that declares a global variable.\n+   * Removes every occurrence of var that declares a global variable.\n    *\n    * <pre>var NS.a = 1, NS.b = 2;</pre>\n    * becomes\n--- a/src/com/google/javascript/jscomp/RhinoErrorReporter.java\n+++ b/src/com/google/javascript/jscomp/RhinoErrorReporter.java\n import java.util.regex.Pattern;\n \n /**\n- * An error reporter for serizalizing Rhino errors into our error format.\n+ * An error reporter for serializing Rhino errors into our error format.\n  * @author nicksantos@google.com (Nick Santos)\n  */\n class RhinoErrorReporter {\n--- a/src/com/google/javascript/jscomp/RuntimeTypeCheck.java\n+++ b/src/com/google/javascript/jscomp/RuntimeTypeCheck.java\n import javax.annotation.Nullable;\n \n /**\n- * Inserts runtime type assertions.\n+ * Inserts run-time type assertions.\n  *\n  * <p>We add markers to user-defined interfaces and classes in order to check if\n  * an object conforms to that type.\n  *\n- * <p>For each function, we insert a runtime type assertion for each parameter\n+ * <p>For each function, we insert a run-time type assertion for each parameter\n  * and return value for which the compiler has a type.\n  *\n  * <p>The JavaScript code which implements the type assertions is in\n    * {@code C.prototype['instance_of__C']}, and for each interface I it\n    * implements , we add {@code C.prototype['implements__I']}.\n    *\n-   * <p>Since interfaces are not a runtime JS concept, we use these markers to\n+   * <p>Since interfaces are not a run-time JS concept, we use these markers to\n    * recognize an interface implementation at runtime. We also use markers for\n    * user-defined classes, so that we can easily recognize them independently of\n    * which module they are defined in and whether the module is loaded.\n   }\n \n   /**\n-   * Insert calls to the runtime type checking function {@code checkType}, which\n+   * Insert calls to the run-time type checking function {@code checkType}, which\n    * takes an expression to check and a list of checkers (one of which must\n    * match). It returns the expression back to facilitate checking of return\n    * values. We have checkers for value types, class types (user-defined and\n--- a/src/com/google/javascript/jscomp/SanityCheck.java\n+++ b/src/com/google/javascript/jscomp/SanityCheck.java\n   }\n \n   /**\n-   * Sanity checks the AST. This is by verifing the normalization passes do\n+   * Sanity checks the AST. This is by verifying the normalization passes do\n    * nothing.\n    */\n   private void sanityCheckNormalization(Node externs, Node root) {\n--- a/src/com/google/javascript/jscomp/Scope.java\n+++ b/src/com/google/javascript/jscomp/Scope.java\n import java.util.Map;\n \n /**\n- * Scope contains information about a variable scope in javascript.\n+ * Scope contains information about a variable scope in JavaScript.\n  * Scopes can be nested, a scope points back to its parent scope.\n  * A Scope contains information about variables defined in that scope.\n  * <p>\n \n     /**\n      * Returns {@code true} if the variable is declared as a define.\n-     * A variable is a define if it is annotaed by {@code @define}.\n+     * A variable is a define if it is annotated by {@code @define}.\n      */\n     public boolean isDefine() {\n       return isDefine;\n--- a/src/com/google/javascript/jscomp/ScopedAliases.java\n+++ b/src/com/google/javascript/jscomp/ScopedAliases.java\n         }\n       }\n \n-      // Validate the top level of the goog.scope block.\n+      // Validate the top-level of the goog.scope block.\n       if (t.getScopeDepth() == 2) {\n         if (aliasVar != null && NodeUtil.isLValue(n)) {\n           if (aliasVar.getNode() == n) {\n--- a/src/com/google/javascript/jscomp/ShadowVariables.java\n+++ b/src/com/google/javascript/jscomp/ShadowVariables.java\n   /**\n    * @param assignments Map of old variable names to its assignment Objects.\n    * @param varsByFrequency Sorted variable assignments by Frequency.\n-   * @param pseudoNameMap The current psedo name map so this pass can update\n+   * @param pseudoNameMap The current pseudo name map so this pass can update\n    *     it accordingly.\n    */\n   ShadowVariables(\n--- a/src/com/google/javascript/jscomp/SideEffectsAnalysis.java\n+++ b/src/com/google/javascript/jscomp/SideEffectsAnalysis.java\n    * Constructs a new SideEffectsAnalysis with the given location abstraction.\n    *\n    * @param compiler A compiler instance\n-   * @param locationAbstractionMode The location abstration to use. {@code\n+   * @param locationAbstractionMode The location abstraction to use. {@code\n    *    DEGENERATE} will use {@link DegenerateLocationAbstraction} while\n    *    {@code VISIBILITY_BASED} will use {@link VisibilityLocationAbstraction}\n    *\n   public abstract static class AbstractMotionEnvironment {\n \n     /**\n-     * Calculates the set of nodes that this environment represnts.\n+     * Calculates the set of nodes that this environment represents.\n      */\n     public abstract Set<Node> calculateEnvironment();\n   }\n     /**\n      * A low-level concrete environment that allows the client to specify\n      * the environment nodes directly. Clients may wish to use this environment\n-     * if none  of the higher-level environments fit their needs.\n+     * if none of the higher-level environments fit their needs.\n      */\n   public static class RawMotionEnvironment\n       extends AbstractMotionEnvironment {\n--- a/src/com/google/javascript/jscomp/SimpleDefinitionFinder.java\n+++ b/src/com/google/javascript/jscomp/SimpleDefinitionFinder.java\n     // cases, specifically:\n     //  - functions with recursive definitions\n     //  - functions defined in object literals\n-    //  - functions defined in array litersals\n+    //  - functions defined in array literals\n     // Here we defined a set of known function declaration that are 'ok'.\n \n     // Some projects seem to actually define \"JSCompiler_renameProperty\"\n--- a/src/com/google/javascript/jscomp/SpecializeModule.java\n+++ b/src/com/google/javascript/jscomp/SpecializeModule.java\n    *\n    * 4) For each module that directly depends on the initial module, add\n    * fixups for the specialized and removed functions. Right now we add\n-   * fixups for for every function that was specialzed or removed -- we could\n+   * fixups for for every function that was specialized or removed -- we could\n    * be smarter about this and for each dependent module only add the functions\n    * that it needs.\n    *\n       }\n     } while(specializationState.hasChanged());\n \n-    // We must always add dummy variables before replacing the orginal module.\n+    // We must always add dummy variables before replacing the original module.\n     addDummyVarDeclarationsToInitialModule(module);\n     replaceOriginalModuleInputsWithSpecialized();\n     addOriginalFunctionVersionsToDependentModules(module);\n--- a/src/com/google/javascript/jscomp/Strings.java\n+++ b/src/com/google/javascript/jscomp/Strings.java\n   /**\n    * If this given string is of length {@code maxLength} or less, it will\n    * be returned as-is.\n-   * Otherwise it will be trucated to {@code maxLength}, regardless of whether\n+   * Otherwise, it will be truncated to {@code maxLength}, regardless of whether\n    * there are any space characters in the String. If an ellipsis is requested\n    * to be appended to the truncated String, the String will be truncated so\n    * that the ellipsis will also fit within maxLength.\n    * Normalizes {@code index} such that it respects Unicode character\n    * boundaries in {@code str}.\n    *\n-   * <p>If {@code index} is the low surrogate of a unicode character,\n+   * <p>If {@code index} is the low surrogate of a Unicode character,\n    * the method returns {@code index - 1}. Otherwise, {@code index} is\n    * returned.\n    *\n    * as defined by {@link Character#isHighSurrogate} and\n    * {@link Character#isLowSurrogate}.\n    *\n-   * <p>If {@code begin} or {@code end} are the low surrogate of a unicode\n+   * <p>If {@code begin} or {@code end} are the low surrogate of a Unicode\n    * character, it will be offset by -1.\n    *\n    * <p>This behavior guarantees that\n    * @param begin the beginning index, inclusive\n    * @param end the ending index, exclusive\n    * @return the specified substring, possibly adjusted in order to not\n-   *   split unicode surrogate pairs\n+   *   split Unicode surrogate pairs\n    * @throws IndexOutOfBoundsException if the {@code begin} is negative,\n    *   or {@code end} is larger than the length of {@code str}, or\n    *   {@code begin} is larger than {@code end}\n--- a/src/com/google/javascript/jscomp/StripCode.java\n+++ b/src/com/google/javascript/jscomp/StripCode.java\n import java.util.Set;\n \n /**\n- * A pass for stripping a list of provided Javascript object types.\n+ * A pass for stripping a list of provided JavaScript object types.\n  *\n  * The stripping strategy is as follows:\n  *   - Provide: 1) a list of types that should be stripped, and 2) a list of\n   // -------------------------------------------------------------------------\n \n   /**\n-   * A callback that strips debug code from a Javascript parse tree.\n+   * A callback that strips debug code from a JavaScript parse tree.\n    */\n   private class Strip extends AbstractPostOrderCallback {\n \n \n     /**\n      * Removes declarations of any variables whose names are strip names or\n-     * whose whose rvalues are static method calls on strip types. Builds a set\n+     * whose whose r-values are static method calls on strip types. Builds a set\n      * of removed variables so that all references to them can be removed.\n      *\n      * @param t The traversal\n                                                Node parent) {\n       switch (parent.getType()) {\n         case Token.VAR:\n-          // This is a variable decalaration, not a reference.\n+          // This is a variable declaration, not a reference.\n           break;\n \n         case Token.GETPROP:\n                 replaceWithEmpty(gramps, greatGramps);\n                 compiler.reportCodeChange();\n               } else {\n-                // Substitute the rvalue for the assignment.\n+                // Substitute the r-value for the assignment.\n                 Node rvalue = n.getNext();\n                 parent.removeChild(rvalue);\n                 gramps.replaceChild(parent, rvalue);\n                 compiler.reportCodeChange();\n               }\n             } else {\n-              // The var reference is the rvalue. Replace it with null.\n+              // The var reference is the r-value. Replace it with null.\n               replaceWithNull(n, parent);\n               compiler.reportCodeChange();\n             }\n     }\n \n     /**\n-     * Eliminates an assignment if the lvalue is:\n+     * Eliminates an assignment if the l-value is:\n      *  - A field name that's a strip name\n      *  - A qualified name that begins with a strip type\n      *\n     void maybeEliminateAssignmentByLvalueName(NodeTraversal t, Node n,\n                                               Node parent) {\n       // ASSIGN\n-      //   lvalue\n-      //   rvalue\n+      //   l-value\n+      //   r-value\n       Node lvalue = n.getFirstChild();\n       if (nameEndsWithFieldNameToStrip(lvalue) ||\n           qualifiedNameBeginsWithStripType(lvalue)) {\n     }\n \n     /**\n-     * Gets whether a Javascript identifier is the name of a variable or\n+     * Gets whether a JavaScript identifier is the name of a variable or\n      * property that should be stripped.\n      *\n-     * @param name A Javascript identifier\n+     * @param name A JavaScript identifier\n      * @return Whether {@code name} is a name that triggers removal\n      */\n     boolean isStripName(String name) {\n--- a/src/com/google/javascript/jscomp/SuppressDocWarningsGuard.java\n+++ b/src/com/google/javascript/jscomp/SuppressDocWarningsGuard.java\n class SuppressDocWarningsGuard extends WarningsGuard {\n   private static final long serialVersionUID = 1L;\n \n-  /** Warnings guards for each suppressable warnings group, indexed by name. */\n+  /** Warnings guards for each suppressible warnings group, indexed by name. */\n   private final Map<String, DiagnosticGroupWarningsGuard> suppressors =\n       Maps.newHashMap();\n \n   /**\n-   * The suppressable groups, indexed by name.\n+   * The suppressible groups, indexed by name.\n    */\n-  SuppressDocWarningsGuard(Map<String, DiagnosticGroup> suppressableGroups) {\n+  SuppressDocWarningsGuard(Map<String, DiagnosticGroup> suppressibleGroups) {\n     for (Map.Entry<String, DiagnosticGroup> entry :\n-             suppressableGroups.entrySet()) {\n+             suppressibleGroups.entrySet()) {\n       suppressors.put(\n           entry.getKey(),\n           new DiagnosticGroupWarningsGuard(\n--- a/src/com/google/javascript/jscomp/SymbolTable.java\n+++ b/src/com/google/javascript/jscomp/SymbolTable.java\n   }\n \n   /**\n-   * Gets the symbol for the given constuctor or interface.\n+   * Gets the symbol for the given constructor or interface.\n    */\n   public Symbol getSymbolDeclaredBy(FunctionType fn) {\n     Preconditions.checkState(fn.isConstructor() || fn.isInterface());\n                   true,\n                   root.scope,\n                   currentNode,\n-                  null /* jsdoc info */);\n+                  null /* JsDoc info */);\n             }\n \n             if (namespace != null) {\n    * in different ways. For example, \"A.superClass_.foo\" and B.prototype.foo\".\n    *\n    * This resolves that ambiguity by pruning the duplicates.\n-   * If we have a lexical symbol with a constructor in its proeprty\n+   * If we have a lexical symbol with a constructor in its property\n    * chain, then we assume there's also a property path to this symbol.\n    * In other words, we can remove \"A.superClass_.foo\" because it's rooted\n    * at \"A\", and we built a property scope for \"A\" above.\n   }\n \n   /**\n-   * Create symbols and references for all properites of types in\n+   * Create symbols and references for all properties of types in\n    * this symbol table.\n    *\n    * This gets a little bit tricky, because of the way this symbol table\n    * have:\n    *\n    * <code>\n-   * SymbolTable symbolTale = for(\"var x = new Foo();\");\n+   * SymbolTable symbolTable = for(\"var x = new Foo();\");\n    * Symbol x = symbolTable.getGlobalScope().getSlot(\"x\");\n    * Symbol type = symbolTable.getAllSymbolsForType(x.getType()).get(0);\n    * </code>\n         Symbol param = getParameterInFunction(sym, name);\n         if (param == null) {\n           // There is no reference to this parameter in the actual JavaScript\n-          // code, so we'll try to create a special jsdoc-only symbol in\n-          // a jsdoc-only scope.\n+          // code, so we'll try to create a special JsDoc-only symbol in\n+          // a JsDoc-only scope.\n           SourcePosition<Node> typePos = marker.getType();\n           JSType type = null;\n           if (typePos != null) {\n--- a/src/com/google/javascript/jscomp/SyntacticScopeCreator.java\n+++ b/src/com/google/javascript/jscomp/SyntacticScopeCreator.java\n         Scope s, String name, Node n, CompilerInput input) {\n       Node parent = n.getParent();\n \n-      // Don't allow multiple variables to be declared at the top level scope\n+      // Don't allow multiple variables to be declared at the top-level scope\n       if (scope.isGlobal()) {\n         Scope.Var origVar = scope.getVar(name);\n         Node origParent = origVar.getParentNode();\n--- a/src/com/google/javascript/jscomp/TightenTypes.java\n+++ b/src/com/google/javascript/jscomp/TightenTypes.java\n           if (parent.isCatch() && parent.getFirstChild() == n) {\n             // The variable in a catch statement gets defined in the scope of\n             // the catch block. We approximate that, as does the normal type\n-            // sytem, by declaring a variable for it in the scope in which the\n+            // system, by declaring a variable for it in the scope in which the\n             // catch is declared.\n             scope.declareSlot(n.getString(), n,\n                 createUnionWithSubTypes(\n   }\n \n   /**\n-   * A simple class used to pair a concrete type and a js type.  Used to\n+   * A simple class used to pair a concrete type and a JS type.  Used to\n    * memoize the results of a \"createTypeIntersection\" call.\n    */\n   static class ConcreteJSTypePair {\n--- a/src/com/google/javascript/jscomp/Tracer.java\n+++ b/src/com/google/javascript/jscomp/Tracer.java\n  * </pre>\n  * where myTracingStatistic implements the {@link TracingStatistic} interface.\n  * The class com.google.monitoring.tracing.TracingStatistics contains\n- * several useful statistics such as cpu time, wait time, and memory usage.\n+ * several useful statistics such as CPU time, wait time, and memory usage.\n  * If you add your own tracing statistics, the output is not quite as pretty,\n  * but includes additional useful information.\n \n  * It uses threads to identify requests. It is fine to have multiple\n  * requests traced in multiple simultaneous threads but it is not ok\n  * to have any given request traced in multiple threads. (the results\n- * will be scattered accross reports).\n+ * will be scattered across reports).\n  *\n  * Java objects do not support destructors (as in C++) so Tracer is not robust\n  * when exceptions are thrown. Each Tracer object should be wrapped in a\n  *\n  * <p>A thread must call {@link Tracer#initCurrentThreadTrace()} to enable the\n  * Tracer logging, otherwise Tracer does nothing.  The requirement to call\n- * {@code initCurrentThreadTrace} avoids the situtation where Tracer is called\n+ * {@code initCurrentThreadTrace} avoids the situation where Tracer is called\n  * without the explicit knowledge of the application authors because they\n  * happen to use a class in another package that uses Tracer. If {@link\n  * Tracer#logCurrentThreadTrace} is called without calling {@link\n    * Create and start a tracer.\n    * Both type and comment may be null. See class comment for usage.\n    *\n-   * @param type The type for totalling\n+   * @param type The type for totaling\n    * @param comment Comment about this tracer\n    */\n   Tracer(@Nullable String type, @Nullable String comment) {\n      * @param prevEventTime The time of the previous event which appears at\n      *     the left most part of the trace line.\n      * @param indent The indentation to put before the tracer to show the\n-     *     hieararchy.\n+     *     hierarchy.\n      * @param digitsColWidth How many characters the digits should use.\n      * @return The formatted string.\n      */\n--- a/src/com/google/javascript/jscomp/TransformAMDToCJSModule.java\n+++ b/src/com/google/javascript/jscomp/TransformAMDToCJSModule.java\n   final static DiagnosticType NON_TOP_LEVEL_STATEMENT_DEFINE_ERROR =\n       DiagnosticType.error(\n             \"NON_TOP_LEVEL_STATEMENT_DEFINE\",\n-            \"The define function must be called as a top level statement.\");\n+            \"The define function must be called as a top-level statement.\");\n   final static DiagnosticType REQUIREJS_PLUGINS_NOT_SUPPORTED_WARNING =\n     DiagnosticType.warning(\n           \"REQUIREJS_PLUGINS_NOT_SUPPORTED\",\n \n   /**\n    * The modules \"exports\", \"require\" and \"module\" are virtual in terms of\n-   * existing implicitly in CJS.\n+   * existing implicitly in CommonJS.\n    */\n   private boolean isVirtualModuleName(String moduleName) {\n     return \"exports\".equals(moduleName) || \"require\".equals(moduleName) ||\n         }\n       } else {\n         // ignore exports, require and module (because they are implicit\n-        // in CJS);\n+        // in CommonJS);\n         if (isVirtualModuleName(aliasName)) {\n           return;\n         }\n   }\n \n   /**\n-   * Rewrites the return statement of the callback to be an assingment to\n+   * Rewrites the return statement of the callback to be an assignment to\n    * module.exports.\n    */\n   private class DefineCallbackReturnCallback extends\n--- a/src/com/google/javascript/jscomp/TypeCheck.java\n+++ b/src/com/google/javascript/jscomp/TypeCheck.java\n     // as is the functions can have \"extraneous\" bits.\n \n     // For getter and setter property definitions the\n-    // rvalue type != the property type.\n+    // r-value type != the property type.\n     Node rvalue = key.getFirstChild();\n     JSType rightType = NodeUtil.getObjectLitKeyTypeFromValueType(\n         key, getJSType(rvalue));\n   }\n \n   /**\n-   * Returns true if any type in the chain has an implictCast annotation for\n+   * Returns true if any type in the chain has an implicitCast annotation for\n    * the given property.\n    */\n   private boolean propertyIsImplicitCast(ObjectType type, String prop) {\n         report(t, n, CONSTRUCTOR_NOT_CALLABLE, childType.toString());\n       }\n \n-      // Functions with explcit 'this' types must be called in a GETPROP\n+      // Functions with explicit 'this' types must be called in a GETPROP\n       // or GETELEM.\n       if (functionType.isOrdinaryFunction() &&\n           !functionType.getTypeOfThis().isUnknownType() &&\n--- a/src/com/google/javascript/jscomp/TypeInference.java\n+++ b/src/com/google/javascript/jscomp/TypeInference.java\n       if (!objectType.isPropertyTypeDeclared(propName)) {\n         // We do not want a \"stray\" assign to define an inferred property\n         // for every object of this type in the program. So we use a heuristic\n-        // approach to determine whether to infer the propery.\n+        // approach to determine whether to infer the property.\n         //\n         // 1) If the property is already defined, join it with the previously\n         //    inferred type.\n \n   private FlowScope narrowScope(FlowScope scope, Node node, JSType narrowed) {\n     if (node.isThis()) {\n-      // \"this\" references don't need to be modelled in the control flow graph.\n+      // \"this\" references don't need to be modeled in the control flow graph.\n       return scope;\n     }\n \n    *\n    * However, there are a few special syntactic forms where we do some\n    * some half-assed backwards type-inference, because programmers\n-   * expect it in this day and age. To take an example from java,\n+   * expect it in this day and age. To take an example from Java,\n    * <code>\n    * List<String> x = Lists.newArrayList();\n    * </code>\n--- a/src/com/google/javascript/jscomp/TypeValidator.java\n+++ b/src/com/google/javascript/jscomp/TypeValidator.java\n    * Gets a list of type violations.\n    *\n    * For each violation, one element is the expected type and the other is\n-   * the type that is actually found. Order is not signficant.\n+   * the type that is actually found. Order is not significant.\n    */\n   Iterable<TypeMismatch> getMismatches() {\n     return mismatches;\n    */\n   boolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType,\n       JSType leftType, Node owner, String propName) {\n-    // The NoType check is a hack to make typedefs work ok.\n+    // The NoType check is a hack to make typedefs work OK.\n     if (!leftType.isNoType() && !rightType.canAssignTo(leftType)) {\n       if (bothIntrinsics(rightType, leftType)) {\n         // We have a superior warning for this mistake, which gives you\n   }\n \n   /**\n-   * Expect that the peroperty in an interface that this type implements is\n+   * Expect that the property in an interface that this type implements is\n    * implemented and correctly typed.\n    */\n   private void expectInterfaceProperty(NodeTraversal t, Node n,\n--- a/src/com/google/javascript/jscomp/TypedScopeCreator.java\n+++ b/src/com/google/javascript/jscomp/TypedScopeCreator.java\n     declareNativeFunctionType(s, URI_ERROR_FUNCTION_TYPE);\n     declareNativeValueType(s, \"undefined\", VOID_TYPE);\n \n-    // ActiveXObject is unqiuely special, because it can be used to construct\n+    // ActiveXObject is uniquely special, because it can be used to construct\n     // any type (the type that it creates is related to the arguments you\n     // pass to it).\n     declareNativeValueType(s, \"ActiveXObject\", NO_OBJECT_TYPE);\n       implements NodeTraversal.Callback {\n \n     /**\n-     * The scope that we're builidng.\n+     * The scope that we're building.\n      */\n     final Scope scope;\n \n      * @param objLitType The type of the OBJECTLIT node. This might be a named\n      *     type, because of the lends annotation.\n      * @param declareOnOwner If true, declare properties on the objLitType as\n-     *     well. If false, the caller should take crae of this.\n+     *     well. If false, the caller should take care of this.\n      */\n     void processObjectLitProperties(\n         Node objLit, ObjectType objLitType,\n     }\n \n     /**\n-     * Asserts that it's ok to define this node's name.\n+     * Asserts that it's OK to define this node's name.\n      * The node should have a source name and be of the specified type.\n      */\n     void assertDefinitionNode(Node n, int type) {\n     void defineFunctionLiteral(Node n, Node parent) {\n       assertDefinitionNode(n, Token.FUNCTION);\n \n-      // Determine the name and JSDocInfo and lvalue for the function.\n+      // Determine the name and JSDocInfo and l-value for the function.\n       // Any of these may be null.\n       Node lValue = NodeUtil.getBestLValue(n);\n       JSDocInfo info = NodeUtil.getBestJSDocInfo(n);\n      * This handles two cases that are semantically very different, but\n      * are not mutually exclusive:\n      * - A function literal that needs a type attached to it.\n-     * - An assignment expression with function-type info in the jsdoc.\n+     * - An assignment expression with function-type info in the JsDoc.\n      *\n      * All parameters are optional, and we will do the best we can to create\n      * a function type.\n      * This handles two cases that are semantically very different, but\n      * are not mutually exclusive:\n      * - An object literal that needs an enum type attached to it.\n-     * - An assignment expression with an enum tag in the jsdoc.\n+     * - An assignment expression with an enum tag in the JsDoc.\n      *\n      * This function will always create an enum type, so only call it if\n      * you're sure that's what you want.\n     void defineSlot(Node n, Node parent, JSType type, boolean inferred) {\n       Preconditions.checkArgument(inferred || type != null);\n \n-      // Only allow declarations of NAMEs and qualfied names.\n+      // Only allow declarations of NAMEs and qualified names.\n       // Object literal keys will have to compute their names themselves.\n       if (n.isName()) {\n         Preconditions.checkArgument(\n       // 5) ASSIGN to anything else\n       //\n       // 1, 3, and 4 are declarations, 5 is inferred, and 2 is a declaration iff\n-      // the function has jsdoc or has not been declared before.\n+      // the function has JsDoc or has not been declared before.\n       //\n       // FUNCTION literals are special because TypedScopeCreator is very smart\n       // about getting as much type information as possible for them.\n      * of this, but there are some really pathological cases as well).\n      *\n      * The current algorithm checks if either the declaration has\n-     * jsdoc type information, or @const with a known type,\n+     * JsDoc type information, or @const with a known type,\n      * or a function literal with a name we haven't seen before.\n      */\n     private boolean isQualifiedNameInferred(\n     }\n \n     /**\n-     * Resolve any stub delcarations to unknown types if we could not\n+     * Resolve any stub declarations to unknown types if we could not\n      * find types for them during traversal.\n      */\n     void resolveStubDeclarations() {\n    */\n   private final class LocalScopeBuilder extends AbstractScopeBuilder {\n     /**\n-     * @param scope The scope that we're builidng.\n+     * @param scope The scope that we're building.\n      */\n     private LocalScopeBuilder(Scope scope) {\n       super(scope);\n--- a/src/com/google/javascript/jscomp/UnreachableCodeElimination.java\n+++ b/src/com/google/javascript/jscomp/UnreachableCodeElimination.java\n     Node parent = n.getParent();\n     if (n.isEmpty() ||\n         (n.isBlock() && !n.hasChildren())) {\n-      // Not always trivial to remove, let FoldContants work its magic later.\n+      // Not always trivial to remove, let FoldConstants work its magic later.\n       return;\n     }\n \n--- a/src/com/google/javascript/jscomp/UseSite.java\n+++ b/src/com/google/javascript/jscomp/UseSite.java\n \n /**\n  * Information about the context in which a Definition is used.\n- * Includes the refering node, and context in which the reference\n+ * Includes the referring node, and context in which the reference\n  * occurs - including the module in which the reference appears.\n  *\n  */\n--- a/src/com/google/javascript/jscomp/VarCheck.java\n+++ b/src/com/google/javascript/jscomp/VarCheck.java\n     Preconditions.checkState(scriptRoot.isScript());\n     NodeTraversal t = new NodeTraversal(compiler, this);\n     // Note we use the global scope to prevent wrong \"undefined-var errors\" on\n-    // variables that are defined in other js files.\n+    // variables that are defined in other JS files.\n     t.traverseWithScope(scriptRoot,\n         SyntacticScopeCreator.generateUntypedTopScope(compiler));\n     // TODO(bashir) Check if we need to createSynthesizedExternVar like process.\n \n     // Mark the variable as constant if it matches the coding convention\n     // for constant vars.\n-    // NOTE(nicksantos): honestly, i'm not sure how much this matters.\n+    // NOTE(nicksantos): honestly, I'm not sure how much this matters.\n     // AFAIK, all people who use the CONST coding convention also\n     // compile with undeclaredVars as errors. We have some test\n     // cases for this configuration though, and it makes them happier.\n--- a/src/com/google/javascript/jscomp/VerboseMessageFormatter.java\n+++ b/src/com/google/javascript/jscomp/VerboseMessageFormatter.java\n \n /**\n  * Verbose message formatter. This formatter generates very loud and long\n- * messages with multiline source excerpts.\n+ * messages with multi-line source excerpts.\n  *\n  */\n class VerboseMessageFormatter extends AbstractMessageFormatter {\n--- a/src/com/google/javascript/jscomp/WarningLevel.java\n+++ b/src/com/google/javascript/jscomp/WarningLevel.java\n   }\n \n   /**\n-   * Add all the check pass that are possibly relevant to a non googler.\n+   * Add all the check pass that are possibly relevant to a non-googler.\n    * @param options The CompilerOptions object to set the options on.\n    */\n   private static void addVerboseWarnings(CompilerOptions options) {\n--- a/src/com/google/javascript/jscomp/WarningsGuard.java\n+++ b/src/com/google/javascript/jscomp/WarningsGuard.java\n  *   - return null. Does not know what to do with it. Lets the other guard\n  *       decide what to do with it.\n  *\n- * Although the interface is very simple it allows you easyly customize what\n+ * Although the interface is very simple, it allows you easily customize what\n  * warnings you are interested in.\n  *\n  * For example there are could be several implementations:\n  *   StrictGuard - {return ERROR}. All warnings should be treat as errors.\n  *   SilentGuard - {if (WARNING) return OFF}. Suppress all warnings but still\n- *     fail if js has errors.\n+ *     fail if JS has errors.\n  *   WhitelistGuard (if !whitelistErrors.contains(error) return ERROR) return\n  *     error if it does not present in the whitelist.\n  *\n--- a/src/com/google/javascript/jscomp/WhitelistWarningsGuard.java\n+++ b/src/com/google/javascript/jscomp/WhitelistWarningsGuard.java\n  * An extension of {@code WarningsGuard} that provides functionality to maintain\n  * a list of warnings (white-list). It is subclasses' responsibility to decide\n  * what to do with the white-list by implementing the {@code level} function.\n- * Warnings are defined by the name of the js file and the first line of\n+ * Warnings are defined by the name of the JS file and the first line of\n  * warnings description.\n  *\n  * @author anatol@google.com (Anatol Pomazau)\n    * of each white-list string is:\n    * <file-name>:  <warning-description>\n    *\n-   * @param whiteList The set of js-warnings that are white-listed. This is\n+   * @param whiteList The set of JS-warnings that are white-listed. This is\n    *     expected to have similar format as {@code formatWarning(JSError)}.\n    */\n   public WhitelistWarningsGuard(Set<String> whiteList) {\n--- a/src/com/google/javascript/jscomp/XtbMessageBundle.java\n+++ b/src/com/google/javascript/jscomp/XtbMessageBundle.java\n \n   /**\n    * A secure EntityResolver that returns an empty string in response to\n-   * any attempt to resolve an external entitity. The class is used by our\n+   * any attempt to resolve an external entity. The class is used by our\n    * secure version of the internal saxon SAX parser.\n    */\n   private static final class SecureEntityResolver implements EntityResolver {\n--- a/src/com/google/javascript/jscomp/ant/CompileTask.java\n+++ b/src/com/google/javascript/jscomp/ant/CompileTask.java\n   }\n \n   /**\n-   * Set print input delimitter formatting option\n+   * Set print input delimiter formatting option\n    */\n   public void setPrintInputDelimiter(boolean print) {\n     this.printInputDelimiter = print;\n \n   /**\n    * Creates a new {@code <define/>} nested element. Supports name and value\n-   * attribtues.\n+   * attributes.\n    */\n   public Parameter createDefine() {\n     Parameter param = new Parameter();\n       throw new BuildException(e);\n     }\n \n-    log(\"Compiled javascript written to \" + this.outputFile.getAbsolutePath(),\n+    log(\"Compiled JavaScript written to \" + this.outputFile.getAbsolutePath(),\n         Project.MSG_DEBUG);\n   }\n \n--- a/src/com/google/javascript/jscomp/deps/DepsGenerator.java\n+++ b/src/com/google/javascript/jscomp/deps/DepsGenerator.java\n import java.util.logging.Logger;\n \n /**\n- * Generates deps.js files by scanning javascript files for\n+ * Generates deps.js files by scanning JavaScript files for\n  * calls to goog.provide(), goog.require() and goog.addDependency().\n  *\n  * @author agrieve@google.com (Andrew Grieve)\n   }\n \n   /**\n-   * Prints a list of strings formatted as a Javascript array of string\n+   * Prints a list of strings formatted as a JavaScript array of string\n    * literals.\n    */\n   private static void writeJsArray(PrintStream out, Collection<String> values) {\n--- a/src/com/google/javascript/jscomp/deps/JsFileLineParser.java\n+++ b/src/com/google/javascript/jscomp/deps/JsFileLineParser.java\n import java.util.regex.Pattern;\n \n /**\n- * Base class for classes that parse Javascript sources on a line-by-line basis. Strips comments\n+ * Base class for classes that parse JavaScript sources on a line-by-line basis. Strips comments\n  * from files and records all parsing errors.\n  *\n  * @author agrieve@google.com (Andrew Grieve)\n \n   /**\n    * Performs the line-by-line parsing of the given fileContents. This method\n-   * strips out Javascript comments and then uses the abstract parseLine()\n+   * strips out JavaScript comments and then uses the abstract parseLine()\n    * method to do the line parsing.\n    *\n    * @param filePath The path to the file being parsed. Used for reporting parse\n   }\n \n   /**\n-   * Parses a Javascript array of string literals. (eg: ['a', 'b', \"c\"]).\n-   * @param input A string containing an Javascript array of string literals.\n+   * Parses a JavaScript array of string literals. (eg: ['a', 'b', \"c\"]).\n+   * @param input A string containing a JavaScript array of string literals.\n    * @return A list of parsed string literals.\n    * @throws ParseException Thrown if there is a syntax error with the input.\n    */\n--- a/src/com/google/javascript/jscomp/deps/JsFileParser.java\n+++ b/src/com/google/javascript/jscomp/deps/JsFileParser.java\n   }\n \n   /**\n-   * Parses a line of javascript, extracting goog.provide and goog.require\n+   * Parses a line of JavaScript, extracting goog.provide and goog.require\n    * information.\n    */\n   @Override\n--- a/src/com/google/javascript/jscomp/deps/JsFunctionParser.java\n+++ b/src/com/google/javascript/jscomp/deps/JsFunctionParser.java\n   }\n \n   /**\n-   * Parses a line of javascript, extracting dependency information.\n+   * Parses a line of JavaScript, extracting dependency information.\n    */\n   @Override\n   protected boolean parseLine(String line) throws ParseException {\n--- a/src/com/google/javascript/jscomp/jsonml/JsonMLAst.java\n+++ b/src/com/google/javascript/jscomp/jsonml/JsonMLAst.java\n    * Returns a JsonML element with the specified number from the tree in\n    * pre-order walk.\n    *\n-   * @return n-th node or null if the node does not exists\n+   * @return nth node or null if the node does not exists\n    */\n   public JsonML getElementPreOrder(int n) {\n     Preconditions.checkState(jsonml != null);\n--- a/src/com/google/javascript/jscomp/jsonml/Writer.java\n+++ b/src/com/google/javascript/jscomp/jsonml/Writer.java\n \n         break;\n       case Token.NAME:\n-        // caja treats calls to eval in a special way\n+        // Caja treats calls to eval in a special way\n         if (child.getString().equals(\"eval\")) {\n           element = new JsonML(TagType.EvalExpr);\n         } else {\n     currentParent.appendChild(element);\n     if (op.equals(\"++\")) {\n       element.setAttribute(TagAttr.OP, \"++\");\n-    } else { // op.euals(\"--\")\n+    } else { // op.equals(\"--\")\n       element.setAttribute(TagAttr.OP, \"--\");\n     }\n \n     Node child = node.getFirstChild();\n     element.setAttribute(TagAttr.LABEL, child.getString());\n \n-    // the second child represents labelled content\n+    // the second child represents labeled content\n     child = child.getNext();\n     processNode(child, element);\n   }\n     }\n   }\n \n-  private void processDirectives(Node node, JsonML currectParent) {\n+  private void processDirectives(Node node, JsonML currentParent) {\n     Set<String> directives = node.getDirectives();\n \n     if (directives == null) {\n       JsonML element = new JsonML(TagType.PrologueDecl);\n       element.setAttribute(TagAttr.DIRECTIVE, directive);\n       element.setAttribute(TagAttr.VALUE, directive);\n-      currectParent.appendChild(element);\n+      currentParent.appendChild(element);\n     }\n   }\n \n--- a/src/com/google/javascript/jscomp/parsing/Config.java\n+++ b/src/com/google/javascript/jscomp/parsing/Config.java\n   }\n \n   /**\n-   * Whether to parse the descriptions of jsdoc comments.\n+   * Whether to parse the descriptions of JsDoc comments.\n    */\n   final boolean parseJsDocDocumentation;\n \n   /**\n-   * Whether we're in ide mode.\n+   * Whether we're in IDE mode.\n    */\n   final boolean isIdeMode;\n \n--- a/src/com/google/javascript/jscomp/parsing/IRFactory.java\n+++ b/src/com/google/javascript/jscomp/parsing/IRFactory.java\n    *\n    * @param node The JsDoc Comment node to parse.\n    * @param irNode\n-   * @return A JSDocInfoParser. Will contain either fileoverview jsdoc, or\n-   *     normal jsdoc, or no jsdoc (if the method parses to the wrong level).\n+   * @return A JsDocInfoParser. Will contain either fileoverview JsDoc, or\n+   *     normal JsDoc, or no JsDoc (if the method parses to the wrong level).\n    */\n   private JsDocInfoParser createJsDocInfoParser(Comment node, Node irNode) {\n     String comment = node.getValue();\n      * Parse the directives, encode them in the AST, and remove their nodes.\n      *\n      * For information on ES5 directives, see section 14.1 of\n-     * Ecma-262, Edition 5.\n+     * ECMA-262, Edition 5.\n      *\n      * It would be nice if Rhino would eventually take care of this for\n      * us, but right now their directive-processing is a one-off.\n--- a/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\n+++ b/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\n  *\n  */\n // TODO(nicksantos): Unify all the JSDocInfo stuff into one package, instead of\n-// spreading it across mutliple packages.\n+// spreading it across multiple packages.\n public final class JsDocInfoParser {\n \n   private final JsDocTokenStream stream;\n   /**\n    * Sets the JsDocBuilder for the file-level (root) node of this parse. The\n    * parser uses the builder to append any preserve annotations it encounters\n-   * in jsdoc comments.\n+   * in JsDoc comments.\n    *\n    * @param fileLevelJsDocBuilder\n    */\n           if (token == JsDocToken.EOC ||\n               token == JsDocToken.EOF ||\n               // When we're capturing a license block, annotations\n-              // in the block are ok.\n+              // in the block are OK.\n               (token == JsDocToken.ANNOTATION &&\n                option != WhitespaceOption.PRESERVE)) {\n             String multilineText = builder.toString();\n \n         boolean isPipe = token == JsDocToken.PIPE;\n         if (isPipe && match(JsDocToken.PIPE)) {\n-          // We support double pipes for backwards compatiblity.\n+          // We support double pipes for backwards compatibility.\n           next();\n         }\n         skipEOLs();\n       }\n \n       union.addChildToBack(expr);\n-      // We support commas for backwards compatiblity.\n+      // We support commas for backwards compatibility.\n     } while (match(JsDocToken.PIPE, JsDocToken.COMMA));\n \n     if (alternate == null) {\n--- a/src/com/google/javascript/jscomp/parsing/JsDocTokenStream.java\n+++ b/src/com/google/javascript/jscomp/parsing/JsDocTokenStream.java\n           // fall through\n \n         default: {\n-          // recognize a jsdoc string but discard last . if it is followed by\n-          // a non-jsdoc comment char, e.g. Array.<\n+          // recognize a JsDoc string but discard last . if it is followed by\n+          // a non-JsDoc comment char, e.g. Array.<\n           int c1 = c;\n           addToString(c);\n           int c2 = getChar();\n--- a/src/com/google/javascript/jscomp/regex/CaseCanonicalize.java\n+++ b/src/com/google/javascript/jscomp/regex/CaseCanonicalize.java\n import com.google.common.collect.ImmutableList;\n \n /**\n- * Implements the EcmaScript 5\n+ * Implements the ECMAScript 5\n  * <a href=\"http://es5.github.com/#Canonicalize\">Canonicalize</a> operation\n  * used to specify how case-insensitive regular expressions match.\n  *\n \n   // Below are tables that implement the Canonicalize operation.\n   // We cannot use java.lang.Character.toUpperCase since that is based on\n-  // a more modern version of Unicode than that required by the EcmaScript spec.\n+  // a more modern version of Unicode than that required by the ECMAScript spec.\n \n   /**\n    * Set of code units that are case-insensitively equivalent to some other\n   }\n \n   /**\n-   * Returns the case canonical version of the given code-unit.  EcmaScript 5\n+   * Returns the case canonical version of the given code-unit.  ECMAScript 5\n    * explicitly says that code-units are to be treated as their code-point\n    * equivalent, even surrogates.\n    */\n--- a/src/com/google/javascript/jscomp/regex/CharRanges.java\n+++ b/src/com/google/javascript/jscomp/regex/CharRanges.java\n     //     If bit is greater than all elements, then idx will be past the end of\n     //     the array, and will be even since ranges.length is even.\n     //\n-    //     Otherwise bit must be in the space between two runs, so not\n+    //     Otherwise, bit must be in the space between two runs, so not\n     //     contained.\n     //\n     //     In all cases, oddness is equivalent to containedness.\n--- a/src/com/google/javascript/jscomp/regex/RegExpTree.java\n+++ b/src/com/google/javascript/jscomp/regex/RegExpTree.java\n             //     /[^\\0-`{-\\uffff]/i\n             // which matches nothing because the information about whether the\n             // ^ is present has been lost during optimizations and charset\n-            // unioning as in /[...]|[^...]/.\n+            // unionizing as in /[...]|[^...]/.\n             ranges = CaseCanonicalize.expandToAllMatched(ranges);\n           }\n         }\n       }\n \n       /**\n-       * Parses an escape to a codepoint.\n+       * Parses an escape to a code point.\n        * Some of the characters parsed here have special meanings in various\n        * contexts, so contexts must filter those instead.\n        * E.g. '\\b' means a different thing inside a charset than without.\n             }\n             return new BackReference(possibleGroupIndex);\n           } else {\n-            // \\1 - \\7 are octal escaps if there is no such group.\n+            // \\1 - \\7 are octal escapes if there is no such group.\n             // \\8 and \\9 are the literal characters '8' and '9' if there\n             // is no such group.\n             return new Text(Character.toString(\n     final CharRanges ranges;\n     /**\n      * Code units that were mentioned explicitly and that might be matched by\n-     * a group according to EcmaScript 5 but would not because of specification\n+     * a group according to ECMAScript 5 but would not because of specification\n      * violations in IE.\n      */\n     final CharRanges ieExplicits;\n--- a/test/com/google/debugging/sourcemap/SourceMapTestCase.java\n+++ b/test/com/google/debugging/sourcemap/SourceMapTestCase.java\n   }\n \n   /**\n-   * Finds the all the __XX__ tokens in the given Javascript\n+   * Finds the all the __XX__ tokens in the given JavaScript\n    * string.\n    */\n   private Map<String, Token> findTokens(Map<String, String> inputs) {\n   }\n \n   /**\n-   * Finds the all the __XX__ tokens in the given Javascript\n+   * Finds the all the __XX__ tokens in the given JavaScript\n    * string.\n    */\n   private Map<String, Token> findTokens(String src) {\n   }\n \n   /**\n-   * Finds the all the __XX__ tokens in the given Javascript\n+   * Finds the all the __XX__ tokens in the given JavaScript\n    * string.\n    */\n   private Map<String, Token> findTokens(\n--- a/test/com/google/javascript/jscomp/AliasExternalsTest.java\n+++ b/test/com/google/javascript/jscomp/AliasExternalsTest.java\n    * Test combined usage of aliasable and unaliasable global lists.\n    */\n   public void testAliasableAndUnaliasableGlobals() {\n-    // Only aliasable provided - ok\n+    // Only aliasable provided - OK\n     aliasableGlobals = \"foo,bar\";\n     unaliasableGlobals = \"\";\n     test(\"var x;\", \"var x;\");\n \n-    // Only unaliasable provided - ok\n+    // Only unaliasable provided - OK\n     aliasableGlobals = \"\";\n     unaliasableGlobals = \"baz,qux\";\n     test(\"var x;\", \"var x;\");\n \n   /**\n    * Test for modifying both parent and child, as all replacements\n-   * are on a single pass and modfiying both involves being careful with\n+   * are on a single pass and modifying both involves being careful with\n    * references.\n    */\n   public void testParentChild() {\n--- a/test/com/google/javascript/jscomp/AstParallelizerTest.java\n+++ b/test/com/google/javascript/jscomp/AstParallelizerTest.java\n    */\n   private void splitFunctions(String input, String ... output) {\n     Compiler compiler = new Compiler();\n-    Node orginal = compiler.parseTestCode(input);\n-    Node root = orginal.cloneTree();\n+    Node original = compiler.parseTestCode(input);\n+    Node root = original.cloneTree();\n     AstParallelizer parallelizer =\n       AstParallelizer.createNewFunctionLevelAstParallelizer(root, true);\n     List<Node> forest = parallelizer.split();\n     }\n \n     parallelizer.join();\n-    assertTrue(orginal.isEquivalentTo(root));\n+    assertTrue(original.isEquivalentTo(root));\n   }\n \n   private void splitFiles(String[] input) {\n     compiler.init(\n         ImmutableList.<SourceFile>of(), files, new CompilerOptions());\n     compiler.parse();\n-    Node orginal = compiler.getRoot();\n-    Node root = orginal.cloneTree();\n+    Node original = compiler.getRoot();\n+    Node root = original.cloneTree();\n \n     AstParallelizer parallelizer =\n       AstParallelizer.createNewFileLevelAstParallelizer(root);\n     }\n \n     parallelizer.join();\n-    assertTrue(orginal.isEquivalentTo(root));\n+    assertTrue(original.isEquivalentTo(root));\n   }\n }\n--- a/test/com/google/javascript/jscomp/CallGraphTest.java\n+++ b/test/com/google/javascript/jscomp/CallGraphTest.java\n    * and propagating over it.\n    */\n   public void testGetDirectedGraph_backwardOnBackward() {\n-    // For this test we create a simple callback that when, applied until a\n+    // For this test we create a simple callback that, when applied until a\n     // fixedpoint, computes whether a function is \"poisoned\" by an extern.\n     // A function is poisoned if it calls an extern or if it calls another\n     // poisoned function.\n    * and propagating over it.\n    */\n   public void testGetDirectedGraph_backwardOnForward() {\n-    // For this test we create a simple callback that when, applied until a\n+    // For this test we create a simple callback that, when applied until a\n     // fixedpoint, computes whether a function is \"poisoned\" by an extern.\n     // A function is poisoned if it calls an extern or if it calls another\n     // poisoned function.\n    * and propagating over it.\n    */\n   public void testGetDirectedGraph_forwardOnForward() {\n-    // For this test we create a simple callback that when, applied until a\n+    // For this test we create a simple callback that, when applied until a\n     // fixedpoint, computes whether a function is reachable from an initial\n     // set of \"root\" nodes.\n \n    * and propagating over it.\n    */\n   public void testGetDirectedGraph_forwardOnBackward() {\n-    // For this test we create a simple callback that when, applied until a\n+    // For this test we create a simple callback that, when applied until a\n     // fixedpoint, computes whether a function is reachable from an initial\n     // set of \"root\" nodes.\n \n--- a/test/com/google/javascript/jscomp/CheckAccessControlsTest.java\n+++ b/test/com/google/javascript/jscomp/CheckAccessControlsTest.java\n   }\n \n   /**\n-   * Tests that the given Javascript code has a @deprecated marker\n+   * Tests that the given JavaScript code has a @deprecated marker\n    * somewhere in it which raises an error. Also tests that the\n-   * deprecated marker works with a message. The Javascript should\n+   * deprecated marker works with a message. The JavaScript should\n    * have a JsDoc of the form \"@deprecated %s\\n\".\n    *\n-   * @param js The Javascript code to parse and test.\n+   * @param js The JavaScript code to parse and test.\n    * @param reason A simple deprecation reason string, used for testing\n    *    the addition of a deprecation reason to the @deprecated tag.\n    * @param error The deprecation error expected when no reason is given.\n   }\n \n   public void testNoPrivateAccessForProperties7() {\n-    // It's ok to override a private property with a non-private property\n+    // It's OK to override a private property with a non-private property\n     // in the same file, but you'll get yelled at when you try to use it.\n     test(new String[] {\n       \"/** @constructor */ function Foo() {} \" +\n--- a/test/com/google/javascript/jscomp/CheckGlobalNamesTest.java\n+++ b/test/com/google/javascript/jscomp/CheckGlobalNamesTest.java\n   }\n \n   public void testRefToPropertyOfAliasedName() {\n-    // this is ok, because \"a\" was aliased\n+    // this is OK, because \"a\" was aliased\n     testSame(NAMES + \"alert(a); alert(a.x);\");\n   }\n \n--- a/test/com/google/javascript/jscomp/CheckRegExpTest.java\n+++ b/test/com/google/javascript/jscomp/CheckRegExpTest.java\n     testReference(\"new RegExp();\", false);\n     testReference(\"var x = new RegExp();\", false);\n \n-    // Checking for RegExp instances is ok, as well.\n+    // Checking for RegExp instances is OK, as well.\n     testReference(\"x instanceof RegExp;\", false);\n \n     // Any other reference isn't\n--- a/test/com/google/javascript/jscomp/CheckSideEffectsTest.java\n+++ b/test/com/google/javascript/jscomp/CheckSideEffectsTest.java\n   }\n \n   public void testJSDocComments() {\n-    test(\"function A() { /** This is a jsdoc comment */ this.foo; }\", ok);\n+    test(\"function A() { /** This is a JsDoc comment */ this.foo; }\", ok);\n     test(\"function A() { /* This is a normal comment */ this.foo; }\",\n          \"function A() { \" +\n          \" /* This is a normal comment */ JSCOMPILER_PRESERVE(this.foo); }\", e);\n--- a/test/com/google/javascript/jscomp/CoalesceVariableNamesTest.java\n+++ b/test/com/google/javascript/jscomp/CoalesceVariableNamesTest.java\n     //        e     c\n     //         \\   /\n     //           d\n-    // The coloring paritioning would be:\n+    // The coloring partitioning would be:\n     //  a = { a, c }\n     //  b = { b, d }\n     //  e = { e }\n                \"  e=1; a=1; e; a;\");\n \n     // If we favor \"d\" first by declaring \"d\" earlier,\n-    // the coloring paritioning would be:\n+    // the coloring partitioning would be:\n     //  b = { b, e }\n     //  d = { d, a }\n     //  c = { c }\n--- a/test/com/google/javascript/jscomp/CodePrinterTest.java\n+++ b/test/com/google/javascript/jscomp/CodePrinterTest.java\n \n     assertPrint(\"/--> <\\\\/script>/g\", \"/--\\\\> <\\\\/script>/g\");\n \n-    // Break HTML start comments. Certain versions of Webkit\n+    // Break HTML start comments. Certain versions of WebKit\n     // begin an HTML comment when they see this.\n     assertPrint(\"'<!-- I am a string -->'\", \"\\\"<\\\\!-- I am a string --\\\\>\\\"\");\n \n     // Function declaration.\n     assertPrint(\"function f(){}\", \"function f(){}\");\n \n-    // Make sure we don't treat non-latin character escapes as raw strings.\n+    // Make sure we don't treat non-Latin character escapes as raw strings.\n     assertPrint(\"({ 'a': 4, '\\\\u0100': 4 })\", \"({\\\"a\\\":4,\\\"\\\\u0100\\\":4})\");\n     assertPrint(\"({ a: 4, '\\\\u0100': 4 })\", \"({a:4,\\\"\\\\u0100\\\":4})\");\n \n   }\n \n   private void assertPrint(String js, String expected) {\n-    parse(expected); // validate the expected string is valid js\n+    parse(expected); // validate the expected string is valid JS\n     assertEquals(expected,\n         parsePrint(js, false, CodePrinter.DEFAULT_LINE_LENGTH_THRESHOLD));\n   }\n--- a/test/com/google/javascript/jscomp/CollapsePropertiesTest.java\n+++ b/test/com/google/javascript/jscomp/CollapsePropertiesTest.java\n     // TODO(user): Make CollapseProperties even more aggressive so that\n     // a$b.z gets collapsed. Right now, it doesn't get collapsed because the\n     // expression (a.b && a.b.c) could return a.b. But since it returns a.b iff\n-    // a.b *is* safely collapsible, the boolean logic should be smart enough to\n+    // a.b *is* safely collapsible, the Boolean logic should be smart enough to\n     // only consider the right side of the && as aliasing.\n     test(\"var a = {}; a.b = {}; /** @constructor */ a.b.c = function(){};\" +\n          \" a.b.z = 1; var d = a.b && a.b.c;\",\n   }\n \n   public void testStaticFunctionReferencingThis1() {\n-    // Note: Google's Javascript Style Guide says to avoid using the 'this'\n+    // Note: Google's JavaScript Style Guide says to avoid using the 'this'\n     // keyword in a static function.\n     test(\"var a = {}; a.b = function() {this.c}; var d = a.b;\",\n          \"var a$b = function() {this.c}; var d = a$b;\", null, UNSAFE_THIS);\n \n   public void testPropertiesOnBothSidesOfAssignment() {\n     // This verifies that replacements are done in the right order. Collapsing\n-    // the lvalue in an assignment affects the parse tree immediately above\n-    // the rvalue, so we update all rvalues before any lvalues.\n+    // the l-value in an assignment affects the parse tree immediately above\n+    // the r-value, so we update all rvalues before any lvalues.\n     test(\"var a = {b: 0}; a.c = a.b;\", \"var a$b = 0; var a$c = a$b;\");\n   }\n \n--- a/test/com/google/javascript/jscomp/CombinedCompilerPassTest.java\n+++ b/test/com/google/javascript/jscomp/CombinedCompilerPassTest.java\n \n   /**\n    * Collection of data for a traversal test. Contains the traversal callback\n-   * and the exepcted pre- and post-order traversal results.\n+   * and the expected pre- and post-order traversal results.\n    */\n   private static class TestHelper {\n     private ConcatTraversal traversal;\n--- a/test/com/google/javascript/jscomp/CompilerTest.java\n+++ b/test/com/google/javascript/jscomp/CompilerTest.java\n   }\n \n   public void testLocalUndefined() throws Exception {\n-    // Some javascript libraries like to create a local instance of \"undefined\",\n+    // Some JavaScript libraries like to create a local instance of \"undefined\",\n     // to ensure that other libraries don't try to overwrite it.\n     //\n-    // Most of the time, this is ok, because normalization will rename\n+    // Most of the time, this is OK, because normalization will rename\n     // that variable to undefined$$1. But this won't happen if they don't\n     // include the default externs.\n     //\n--- a/test/com/google/javascript/jscomp/CompilerTestCase.java\n+++ b/test/com/google/javascript/jscomp/CompilerTestCase.java\n   /** Whether the Normalize pass runs before pass being tested. */\n   private boolean normalizeEnabled = false;\n \n-  /** Whether the expected js strings should be normalized. */\n+  /** Whether the expected JS strings should be normalized. */\n   private boolean normalizeExpected = false;\n \n   /** Whether to check that all line number information is preserved. */\n    * after running it.\n    *\n    * @param normalizeExpected Whether to perform normalization on the\n-   * expected js result.\n+   * expected JS result.\n    * @see Normalize\n    */\n   protected void enableNormalize(boolean normalizeExpected) {\n   }\n \n   /**\n-   * Parses expected js inputs and returns the root of the parse tree.\n+   * Parses expected JS inputs and returns the root of the parse tree.\n    */\n   protected Node parseExpectedJs(String[] expected) {\n     Compiler compiler = createCompiler();\n--- a/test/com/google/javascript/jscomp/ControlFlowAnalysisTest.java\n+++ b/test/com/google/javascript/jscomp/ControlFlowAnalysisTest.java\n public class ControlFlowAnalysisTest extends TestCase {\n \n   /**\n-   * Given an input in Javascript, test if the control flow analysis\n+   * Given an input in JavaScript, test if the control flow analysis\n    * creates the proper control flow graph by comparing the expected\n    * Dot file output.\n    *\n-   * @param input Input Javascript.\n-   * @param expected Expected Graphvis Dot file.\n+   * @param input Input JavaScript.\n+   * @param expected Expected Graphviz Dot file.\n    */\n   private void testCfg(String input, String expected) {\n     testCfg(input, expected, true);\n   }\n \n   /**\n-   * Given an input in Javascript, get a control flow graph for it.\n+   * Given an input in JavaScript, get a control flow graph for it.\n    *\n-   * @param input Input Javascript.\n+   * @param input Input JavaScript.\n    */\n   private ControlFlowGraph<Node> createCfg(String input,\n       boolean runSynBlockPass) {\n   }\n \n   /**\n-   * Given an input in Javascript, test if the control flow analysis\n+   * Given an input in JavaScript, test if the control flow analysis\n    * creates the proper control flow graph by comparing the expected\n    * Dot file output.\n    *\n-   * @param input Input Javascript.\n-   * @param expected Expected Graphvis Dot file.\n+   * @param input Input JavaScript.\n+   * @param expected Expected Graphviz Dot file.\n    * @param shouldTraverseFunctions Whether to traverse functions when\n    *    constructing the CFG (true by default). Passed in to the\n    *    constructor of {@link ControlFlowAnalysis}.\n--- a/test/com/google/javascript/jscomp/CrossModuleCodeMotionTest.java\n+++ b/test/com/google/javascript/jscomp/CrossModuleCodeMotionTest.java\n     // When the dest module is empty, it might try to move the code to the\n     // one of the modules that the empty module depends on. In some cases\n     // this might ended up to be the same module as the definition of the code.\n-    // When that happens, CrossMooduleCodeMotion might report a code change\n+    // When that happens, CrossModuleCodeMotion might report a code change\n     // while nothing is moved. This should not be a problem if we know all\n     // modules are non-empty.\n     JSModule m1 = new JSModule(\"m1\");\n--- a/test/com/google/javascript/jscomp/CrossModuleMethodMotionTest.java\n+++ b/test/com/google/javascript/jscomp/CrossModuleMethodMotionTest.java\n package com.google.javascript.jscomp;\n \n /**\n- * Tessts for {@link CrossModuleMethodMotion}.\n+ * Tests for {@link CrossModuleMethodMotion}.\n  *\n  * @author nicksantos@google.com (Nick Santos)\n  */\n--- a/test/com/google/javascript/jscomp/DeadAssignmentsEliminationTest.java\n+++ b/test/com/google/javascript/jscomp/DeadAssignmentsEliminationTest.java\n \n \n   public void testDeadPartiallyWithinTheExpression() {\n-    // Sadly, this is not covered. We don't suspect this would happend too\n+    // Sadly, this is not covered. We don't suspect this would happen too\n     // often.\n     inFunction(\"var x; x = 100, x = 101; print(x);\");\n   }\n--- a/test/com/google/javascript/jscomp/DenormalizeTest.java\n+++ b/test/com/google/javascript/jscomp/DenormalizeTest.java\n \n   public void testInOperatorNotInsideFor() {\n     // in operators shouldn't be moved into for loops.\n-    // Some Javascript interpreters (such as the NetFront Access browser\n+    // Some JavaScript interpreters (such as the NetFront Access browser\n     // embedded in the PlayStation 3) will not parse an in operator in\n     // a for loop, even if it's protected by parentheses.\n \n--- a/test/com/google/javascript/jscomp/DisambiguatePropertiesTest.java\n+++ b/test/com/google/javascript/jscomp/DisambiguatePropertiesTest.java\n import java.util.TreeSet;\n \n /**\n- * Unit test for the Compiler DisambiguateProprties pass.\n+ * Unit test for the Compiler DisambiguateProperties pass.\n  *\n  */\n public class DisambiguatePropertiesTest extends CompilerTestCase {\n       + \"/** @type {Buz|Foo} */ var d;\\n\"\n       + \"b.a = 5; c.a = 6; d.a = 7;\";\n \n-    // We are testing the skipping of multiple types caused by unioning with\n+    // We are testing the skipping of multiple types caused by unionizing with\n     // extern types.\n     testSets(false, externs, js, output, \"{a=[[T1], [T2]]}\");\n   }\n     assertEquals(fieldTypes, mapToString(lastPass.getRenamedTypesForTesting()));\n   }\n \n-  /** Sorts the map and converts to a string for comparision purposes. */\n+  /** Sorts the map and converts to a string for comparison purposes. */\n   private <T> String mapToString(Multimap<String, Collection<T>> map) {\n     TreeMap<String, String> retMap = Maps.newTreeMap();\n     for (String key : map.keySet()) {\n--- a/test/com/google/javascript/jscomp/ExpressionDecomposerTest.java\n+++ b/test/com/google/javascript/jscomp/ExpressionDecomposerTest.java\n         \"y = (temp_const$$0.a = temp_const$$1 + foo()) + goo().a\");\n   }\n \n-  // Test mulitple levels\n+  // Test multiple levels\n   public void testExposePlusEquals5() {\n     helperExposeExpression(\n         \"var x = {}; goo().a.b += foo() + 1\",\n--- a/test/com/google/javascript/jscomp/ExternExportsPassTest.java\n+++ b/test/com/google/javascript/jscomp/ExternExportsPassTest.java\n \n   /**\n    * ExternExportsPass relies on type information to emit JSDoc annotations for\n-   * exported externs. However, the user can disable typechecking and still\n+   * exported externs. However, the user can disable type checking and still\n    * ask for externs to be exported. Set this flag to enable or disable checking\n    * of types during a test.\n    */\n   }\n \n   /**\n-   * Compiles the passed in javascript with the passed in externs and returns\n+   * Compiles the passed in JavaScript with the passed in externs and returns\n    * the new externs exported by the this pass.\n    *\n    * @param js the source to be compiled\n--- a/test/com/google/javascript/jscomp/FunctionInjectorTest.java\n+++ b/test/com/google/javascript/jscomp/FunctionInjectorTest.java\n   }\n \n   public void testCanInlineReferenceToFunction24() {\n-    // ... this is ok, because it doesn't introduce a new global name.\n+    // ... this is OK, because it doesn't introduce a new global name.\n     helperCanInlineReferenceToFunction(CanInlineResult.YES,\n         \"function foo(a){return a;}; \" +\n         \"function x() { foo(x++); }\",\n--- a/test/com/google/javascript/jscomp/GenerateExportsTest.java\n+++ b/test/com/google/javascript/jscomp/GenerateExportsTest.java\n   }\n \n   /**\n-   * Nested assignments are ambigous and therefore not supported.\n+   * Nested assignments are ambiguous and therefore not supported.\n    * @see FindExportableNodes\n    */\n   public void testNestedVarAssign() {\n   }\n \n   /**\n-   * Nested assignments are ambigous and therefore not supported.\n+   * Nested assignments are ambiguous and therefore not supported.\n    * @see FindExportableNodes\n    */\n   public void testNestedAssign() {\n--- a/test/com/google/javascript/jscomp/InlineFunctionsTest.java\n+++ b/test/com/google/javascript/jscomp/InlineFunctionsTest.java\n    */\n   @Override\n   protected int getNumRepetitions() {\n-    // Some inlining can only be done in mutliple passes.\n+    // Some inlining can only be done in multiple passes.\n     return 3;\n   }\n \n   }\n \n   public void testShadowVariables5() {\n-    // Can't yet inline mulitple statements functions into expressions\n+    // Can't yet inline multiple statements functions into expressions\n     // (though some are possible using the COMMA operator).\n     allowBlockInlining = false;\n     testSame(\"var a=0;\" +\n   }\n \n   public void testShadowVariables14() {\n-    // There is a colision even though it is not read.\n+    // There is a collision even though it is not read.\n     test(\"var a=0;var b=1;\" +\n          \"function foo(){return a+b}\" +\n          \"function _bar(){var c=foo(),b;alert(c)}\",\n   }\n \n   public void testCostBasedInlining8() {\n-    // Verify mutiple references in the same statement:\n+    // Verify multiple references in the same statement:\n     // Here \"f\" is not known to be removable, as it is a used as parameter\n     // and is not known to be side-effect free.  The first call to f() can\n     // not be inlined on the first pass (as the call to f() as a parameter\n   }\n \n   public void testCostBasedInliningComplex8() {\n-    // Verify mutiple references in the same statement.\n+    // Verify multiple references in the same statement.\n     testSame(\"function _f(a){1+a+a}\" +\n              \"a=_f(1)+_f(1)\");\n   }\n--- a/test/com/google/javascript/jscomp/InlinePropertiesTest.java\n+++ b/test/com/google/javascript/jscomp/InlinePropertiesTest.java\n /**\n  * @author johnlenz@google.com (John Lenz)\n  */\n-public class InlinePropertiesTest  extends CompilerTestCase {\n+public class InlinePropertiesTest extends CompilerTestCase {\n \n   private static final String EXTERNS =\n       \"Function.prototype.call=function(){};\" +\n--- a/test/com/google/javascript/jscomp/InlineSimpleMethodsTest.java\n+++ b/test/com/google/javascript/jscomp/InlineSimpleMethodsTest.java\n \n   /**\n    * Helper for tests that expects definitions to remain unchanged, such\n-   * that {@code definitions+js} is coverted to {@code definitions+expected}.\n+   * that {@code definitions+js} is converted to {@code definitions+expected}.\n    */\n   private void testWithPrefix(String definitions, String js, String expected) {\n     test(definitions + js, definitions + expected);\n--- a/test/com/google/javascript/jscomp/InlineVariablesConstantsTest.java\n+++ b/test/com/google/javascript/jscomp/InlineVariablesConstantsTest.java\n \n   public void testInlineConditionallyDefinedConstant1() {\n     // Note that inlining conditionally defined constants can change the\n-    // runtime behavior of code (e.g. when y is true and x is false in the\n+    // run-time behavior of code (e.g. when y is true and x is false in the\n     // example below). We inline them anyway because if the code author didn't\n     // want one inlined, he/she could define it as a non-const variable instead.\n     test(\"if (x) var ABC = 2; if (y) f(ABC);\",\n--- a/test/com/google/javascript/jscomp/IntegrationTest.java\n+++ b/test/com/google/javascript/jscomp/IntegrationTest.java\n     options.computeFunctionSideEffects = false;\n     options.removeUnusedVars = true;\n \n-    // If we do splits too early, it would add a sideeffect to x.\n+    // If we do splits too early, it would add a side-effect to x.\n     test(options,\n       \"var x=['1','2','3','4','5','6','7']\",\n       \"\");\n       test(options,\n            \"var x = 3; function f() { return x + z; }\",\n            \"function f() { return x + z; }\");\n-      fail(\"Expected runtime exception\");\n+      fail(\"Expected run-time exception\");\n     } catch (RuntimeException e) {\n       assertTrue(e.getMessage().indexOf(\"Unexpected variable x\") != -1);\n     }\n--- a/test/com/google/javascript/jscomp/LiveVariableAnalysisTest.java\n+++ b/test/com/google/javascript/jscomp/LiveVariableAnalysisTest.java\n     assertLiveBeforeX(\"var a;X:1?a=1:1;a()\", \"a\");\n \n     // Unfortunately, we cannot prove the following because we assume there is\n-    // no control flow within a hook (ie: no joins / set unions).\n+    // no control flow within a hook (i.e. no joins / set unions).\n     // assertNotLiveAfterX(\"var a;X:1?a=1:a=2;a\", \"a\");\n     assertLiveBeforeX(\"var a,b;X:b=1?a:2\", \"a\");\n   }\n--- a/test/com/google/javascript/jscomp/LooseTypeCheckTest.java\n+++ b/test/com/google/javascript/jscomp/LooseTypeCheckTest.java\n \n   public void testScoping11() throws Exception {\n     // named anonymous functions create a binding in their body only\n-    // the return is wrong but the assignment is ok since the type of b is ?\n+    // the return is wrong but the assignment is OK since the type of b is ?\n     testTypes(\n         \"/** @return {number} */var a = function b(){ return b };\",\n         \"inconsistent return type\\n\" +\n   }\n \n   public void testFunctionArguments13() throws Exception {\n-    // verifying that the argument type have non-inferrable types\n+    // verifying that the argument type have non-inferable types\n     testTypes(\n         \"/** @return {boolean} */ function u() { return true; }\" +\n         \"/** @param {boolean} b\\n@return {?boolean} */\" +\n \n   public void testCast15() throws Exception {\n     // This fixes a bug where a type cast on an object literal\n-    // would cause a runtime cast exception if the node was visited\n+    // would cause a run-time cast exception if the node was visited\n     // more than once.\n     //\n     // Some code assumes that an object literal must have a object type,\n     // still the same type as the one on the variable\n     assertTrue(googGetpropFoo2Type == googScopeType);\n \n-    // goog.foo type on the left of the top level GETPROP node\n+    // goog.foo type on the left of the top-level GETPROP node\n     // (under second ASSIGN)\n     JSType googFooGetprop2Type = getpropFoo2.getJSType();\n     assertTrue(\"goog.foo incorrectly annotated in goog.foo.bar selection\",\n   //public void testWarningOnInterfacePrototype() throws Exception {\n   //  testTypes(\"/** @interface */ u.T = function() {};\\n\" +\n   //      \"/** @return {number} */ u.T.prototype = function() { };\",\n-  //      \"cannot reference an interface ouside of its definition\");\n+  //      \"cannot reference an interface outside of its definition\");\n   //}\n   //\n   //public void testBadPropertyOnInterface1() throws Exception {\n   //  testTypes(\"/** @interface */ u.T = function() {};\\n\" +\n   //      \"/** @return {number} */ u.T.f = function() { return 1;};\",\n-  //      \"cannot reference an interface ouside of its definition\");\n+  //      \"cannot reference an interface outside of its definition\");\n   //}\n   //\n   //public void testBadPropertyOnInterface2() throws Exception {\n   //  testTypes(\"/** @interface */ function T() {};\\n\" +\n   //      \"/** @return {number} */ T.f = function() { return 1;};\",\n-  //      \"cannot reference an interface ouside of its definition\");\n+  //      \"cannot reference an interface outside of its definition\");\n   //}\n   //\n   //public void testBadPropertyOnInterface3() throws Exception {\n   //  testTypes(\"/** @interface */ u.T = function() {}; u.T.x\",\n-  //      \"cannot reference an interface ouside of its definition\");\n+  //      \"cannot reference an interface outside of its definition\");\n   //}\n   //\n   //public void testBadPropertyOnInterface4() throws Exception {\n   //  testTypes(\"/** @interface */ function T() {}; T.x;\",\n-  //      \"cannot reference an interface ouside of its definition\");\n+  //      \"cannot reference an interface outside of its definition\");\n   //}\n \n   public void testAnnotatedPropertyOnInterface1() throws Exception {\n--- a/test/com/google/javascript/jscomp/MaybeReachingVariableUseTest.java\n+++ b/test/com/google/javascript/jscomp/MaybeReachingVariableUseTest.java\n   private List<Node> uses = null;\n \n   /*\n-   * The test cases consist of a short code snipplet that has an instruction\n+   * The test cases consist of a short code snippet that has an instruction\n    * labeled with D and one or more with label starting with U. When assertMatch\n    * is called, the test suite verifies that all the uses with label starting\n    * with U is reachable to the definition label at D.\n--- a/test/com/google/javascript/jscomp/NodeUtilTest.java\n+++ b/test/com/google/javascript/jscomp/NodeUtilTest.java\n     assertMutableState(false, \"a\");\n     assertMutableState(true, \"[b, c [d, [e]]]\");\n     assertMutableState(true, \"({a: x, b: y, c: z})\");\n-    // Note: RegEx objects are not immutable,  for instance, the exec\n+    // Note: RegExp objects are not immutable,  for instance, the exec\n     // method maintains state for \"global\" searches.\n     assertMutableState(true, \"/abc/gi\");\n     assertMutableState(false, \"'a'\");\n     assertEquals(\n         Double.POSITIVE_INFINITY,\n         NodeUtil.getNumberValue(getNode(\"'+Infinity'\")));\n-    // FireFox treats \"infinity\" as \"Infinity\", IE treats it as NaN\n+    // Firefox treats \"infinity\" as \"Infinity\", IE treats it as NaN\n     assertEquals(null, NodeUtil.getNumberValue(getNode(\"'-infinity'\")));\n     assertEquals(null, NodeUtil.getNumberValue(getNode(\"'infinity'\")));\n     assertEquals(null, NodeUtil.getNumberValue(getNode(\"'+infinity'\")));\n     assertFalse(NodeUtil.isNumericResult(getNode(\"a().b()\")));\n     assertFalse(NodeUtil.isNumericResult(getNode(\"new a()\")));\n \n-    // Definitely not numberic\n+    // Definitely not numeric\n     assertFalse(NodeUtil.isNumericResult(getNode(\"([1,2])\")));\n     assertFalse(NodeUtil.isNumericResult(getNode(\"({a:1})\")));\n \n--- a/test/com/google/javascript/jscomp/NormalizeTest.java\n+++ b/test/com/google/javascript/jscomp/NormalizeTest.java\n   }\n \n   public void testRenamingConstantProperties() {\n-    // In order to detecte that foo.BAR is a constant, we need collapse\n+    // In order to detect that foo.BAR is a constant, we need collapse\n     // properties to run first so that we can tell if the initial value is\n     // non-null and immutable.\n     new WithCollapse().testConstantProperties();\n--- a/test/com/google/javascript/jscomp/OptimizeArgumentsArrayTest.java\n+++ b/test/com/google/javascript/jscomp/OptimizeArgumentsArrayTest.java\n \n   public void testInnerFunctionsAfterArguments() {\n     // This caused a bug earlier due to incorrect push and pop of the arguments\n-    // accesss stack.\n+    // access stack.\n     test(\"function f(  ) { arguments[0]; function b() { function c() { }} }\",\n          \"function f(p0) {           p0; function b() { function c() { }} }\");\n   }\n--- a/test/com/google/javascript/jscomp/PeepholeFoldConstantsTest.java\n+++ b/test/com/google/javascript/jscomp/PeepholeFoldConstantsTest.java\n     fold(\"x = ''.length\", \"x = 0\");\n     fold(\"x = '123'.length\", \"x = 3\");\n \n-    // Test unicode escapes are accounted for.\n+    // Test Unicode escapes are accounted for.\n     fold(\"x = '123\\u01dc'.length\", \"x = 4\");\n   }\n \n     fold(\"x=y*x\", \"x*=y\");\n     fold(\"x.y=x.y+z\", \"x.y+=z\");\n     foldSame(\"next().x = next().x + 1\");\n-    // This is ok, really.\n+    // This is OK, really.\n     fold(\"({a:1}).a = ({a:1}).a + 1\", \"({a:1}).a = 2\");\n   }\n \n     foldSame(\"x=y*x\");\n     foldSame(\"x.y=x.y+z\");\n     foldSame(\"next().x = next().x + 1\");\n-    // This is ok, really.\n+    // This is OK, really.\n     fold(\"({a:1}).a = ({a:1}).a + 1\", \"({a:1}).a = 2\");\n   }\n \n--- a/test/com/google/javascript/jscomp/PeepholeRemoveDeadCodeTest.java\n+++ b/test/com/google/javascript/jscomp/PeepholeRemoveDeadCodeTest.java\n \n   public void testRemoveUselessOps() {\n     // There are four place where expression results are discarded:\n-    //  - a top level expression EXPR_RESULT\n+    //  - a top-level expression EXPR_RESULT\n     //  - the LHS of a COMMA\n     //  - the FOR init expression\n     //  - the FOR increment expression\n   }\n \n   public void testComplex5() {\n-    // can't simplify lhs of short circuit statements with side effects\n+    // can't simplify LHS of short circuit statements with side effects\n     testSame(\"(a() ? 1 : 1 + c()) && foo()\");\n   }\n \n--- a/test/com/google/javascript/jscomp/PeepholeReplaceKnownMethodsTest.java\n+++ b/test/com/google/javascript/jscomp/PeepholeReplaceKnownMethodsTest.java\n     fold(\"x = 'abcdefbe'.lastIndexOf('b')\", \"x = 6\");\n     fold(\"x = 'abcdefbe'.lastIndexOf('b', 5)\", \"x = 1\");\n \n-    // Both elements must be string. Dont do anything if either one is not\n+    // Both elements must be strings. Don't do anything if either one is not\n     // string.\n     fold(\"x = 'abc1def'.indexOf(1)\", \"x = 3\");\n     fold(\"x = 'abcNaNdef'.indexOf(NaN)\", \"x = 3\");\n     fold(\"x = 'abcnulldef'.indexOf(null)\", \"x = 3\");\n     fold(\"x = 'abctruedef'.indexOf(true)\", \"x = 3\");\n \n-    // The following testcase fails with JSC_PARSE_ERROR. Hence omitted.\n+    // The following test case fails with JSC_PARSE_ERROR. Hence omitted.\n     // foldSame(\"x = 1.indexOf('bcd');\");\n     foldSame(\"x = NaN.indexOf('bcd')\");\n     foldSame(\"x = undefined.indexOf('bcd')\");\n--- a/test/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntaxTest.java\n+++ b/test/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntaxTest.java\n  */\n public class PeepholeSubstituteAlternateSyntaxTest extends CompilerTestCase {\n \n-  // Externs for builtin constructors\n+  // Externs for built-in constructors\n   // Needed for testFoldLiteralObjectConstructors(),\n   // testFoldLiteralArrayConstructors() and testFoldRegExp...()\n   private static final String FOLD_CONSTANTS_TEST_EXTERNS =\n \n     // Cannot fold all the way to a literal because there are too few arguments.\n     fold(\"x = new RegExp\",                    \"x = RegExp()\");\n-    // Empty regexp should not fold to // since that is a line comment in js\n+    // Empty regexp should not fold to // since that is a line comment in JS\n     fold(\"x = new RegExp(\\\"\\\")\",              \"x = RegExp(\\\"\\\")\");\n     fold(\"x = new RegExp(\\\"\\\", \\\"i\\\")\",       \"x = RegExp(\\\"\\\",\\\"i\\\")\");\n     // Bogus flags should not fold\n          \"x = RegExp(\\\"foobar\\\",\\\"g\\\")\");\n     fold(\"x = new RegExp(\\\"foobar\\\", \\\"ig\\\")\",\n          \"x = RegExp(\\\"foobar\\\",\\\"ig\\\")\");\n-    // ... unless in EcmaScript 5 mode per section 7.8.5 of EcmaScript 5.\n+    // ... unless in ECMAScript 5 mode per section 7.8.5 of ECMAScript 5.\n     enableEcmaScript5(true);\n     fold(\"x = new RegExp(\\\"foobar\\\", \\\"ig\\\")\",\n          \"x = /foobar/ig\");\n     enableEcmaScript5(false);\n     fold(\"x = new RegExp(\\\"\\\\u2028\\\")\", \"x = RegExp(\\\"\\\\u2028\\\")\");\n     fold(\"x = new RegExp(\\\"\\\\\\\\\\\\\\\\u2028\\\")\", \"x = /\\\\\\\\u2028/\");\n-    // Sunset Safari exclusions for EcmaScript 5 and later.\n+    // Sunset Safari exclusions for ECMAScript 5 and later.\n     enableEcmaScript5(true);\n     fold(\"x = new RegExp(\\\"\\\\u2028\\\\u2029\\\")\", \"x = /\\\\u2028\\\\u2029/\");\n     fold(\"x = new RegExp(\\\"\\\\\\\\u2028\\\")\", \"x = /\\\\u2028/\");\n--- a/test/com/google/javascript/jscomp/ProcessDefinesTest.java\n+++ b/test/com/google/javascript/jscomp/ProcessDefinesTest.java\n \n   /**\n    * Helper for tests that expects definitions to remain unchanged, such\n-   * that {@code definitions+js} is coverted to {@code definitions+expected}.\n+   * that {@code definitions+js} is converted to {@code definitions+expected}.\n    */\n   private void testWithPrefix(String definitions, String js, String expected) {\n     test(definitions + js, definitions + expected);\n--- a/test/com/google/javascript/jscomp/PureFunctionIdentifierTest.java\n+++ b/test/com/google/javascript/jscomp/PureFunctionIdentifierTest.java\n       \" */\\n\" +\n       \"externObj3.prototype.propWithStubBefore = function(s) {};\" +\n \n-      // useless jsdoc\n+      // useless JsDoc\n       \"/**\\n\" +\n       \" * @see {foo}\\n\" +\n       \" */\\n\" +\n       \" */\\n\" +\n       \"externObj4.prototype.propWithStubAfterWithJSDoc = function(s) {};\" +\n \n-      // useless jsdoc\n+      // useless JsDoc\n       \"/**\\n\" +\n       \" * @see {foo}\\n\" +\n       \" */\\n\" +\n     // it does not have global side-effects with \"this\" is\n     // a known local value.\n     // TODO(johnlenz): \"f\" is side-effect free but we need\n-    // to propagate that \"externObjSEThisMethod\" is modifing\n+    // to propagate that \"externObjSEThisMethod\" is modifying\n     // a local object.\n     checkMarkedCalls(\n         \"function f() {\" +\n   }\n \n   public void testLocalizedSideEffects3() throws Exception {\n-    // A local that might be assigned a gobal value and whose properties\n+    // A local that might be assigned a global value and whose properties\n     // are modified must be considered a global side-effect.\n     checkMarkedCalls(\"var g = {foo:1}; function f() {var x = g; x.foo++}\" +\n                      \"f()\",\n--- a/test/com/google/javascript/jscomp/RemoveUnusedClassPropertiesTest.java\n+++ b/test/com/google/javascript/jscomp/RemoveUnusedClassPropertiesTest.java\n   }\n \n   public void testInc1() {\n-    // Increments and Decrements are handled similiarly to compound assignments\n+    // Increments and Decrements are handled similarly to compound assignments\n     // but need a placeholder value when replaced.\n     test(\"this.x++\", \"0\");\n     testSame(\"x = (this.x++)\");\n   }\n \n   public void testInc2() {\n-    // Increments and Decrements are handled similiarly to compound assignments\n+    // Increments and Decrements are handled similarly to compound assignments\n     // but need a placeholder value when replaced.\n     test(\"this.a++, f()\", \"0, f()\");\n     test(\"x = (this.a++, f())\", \"x = (0, f())\");\n--- a/test/com/google/javascript/jscomp/RemoveUnusedPrototypePropertiesTest.java\n+++ b/test/com/google/javascript/jscomp/RemoveUnusedPrototypePropertiesTest.java\n package com.google.javascript.jscomp;\n \n /**\n- * Tessts for {@link RemoveUnusedPrototypeProperties}.\n+ * Tests for {@link RemoveUnusedPrototypeProperties}.\n  *\n  * @author nicksantos@google.com (Nick Santos)\n  */\n--- a/test/com/google/javascript/jscomp/RemoveUnusedVarsTest.java\n+++ b/test/com/google/javascript/jscomp/RemoveUnusedVarsTest.java\n     test(\"var b=function(c,d,e){return d};b(1,2,3);b(new x(),4,new x())\",\n          \"var b=function(c,d){return d};b(0,2);b(new x(),4,new x())\");\n \n-    // Recursive calls are ok.\n+    // Recursive calls are OK.\n     test(\"var b=function(c,d){b(1,2);return d};b(3,4);b(5,6)\",\n          \"var b=function(d){b(2);return d};b(4);b(6)\");\n \n--- a/test/com/google/javascript/jscomp/ReplaceStringsTest.java\n+++ b/test/com/google/javascript/jscomp/ReplaceStringsTest.java\n \n   private void testDebugStrings(String js, String expected,\n                                 String[] substitutedStrings) {\n-    // Verify that the strings are substituted correctly in the js code.\n+    // Verify that the strings are substituted correctly in the JS code.\n     test(js, expected);\n \n     List<Result> results = pass.getResult();\n--- a/test/com/google/javascript/jscomp/ScopedAliasesTest.java\n+++ b/test/com/google/javascript/jscomp/ScopedAliasesTest.java\n   }\n \n   public void testOverridden() {\n-    // Test that the alias doesn't get unaliased when it's overriden by a\n+    // Test that the alias doesn't get unaliased when it's overridden by a\n     // parameter.\n     testScopedNoChanges(\n         \"var g = goog;\", \"goog.x = function(g) {g.z()};\");\n             for (Node typeNode : info.getTypeNodes()) {\n               expectedTypes.add(typeNode);\n             }\n-            assertEquals(\"Wrong number of jsdoc types\",\n+            assertEquals(\"Wrong number of JsDoc types\",\n                 expectedTypes.size(), actualTypes.size());\n             for (int i = 0; i < expectedTypes.size(); i++) {\n               assertNull(\n--- a/test/com/google/javascript/jscomp/ShadowVariablesTest.java\n+++ b/test/com/google/javascript/jscomp/ShadowVariablesTest.java\n  *\n  */\n public class ShadowVariablesTest extends CompilerTestCase{\n-  // Use psedo names to make test easier to read.\n+  // Use pseudo names to make test easier to read.\n   private boolean generatePseudoNames = false;\n   @Override\n   protected CompilerPass getProcessor(Compiler compiler) {\n \n   public void testShadowLotsOfScopes2() {\n     generatePseudoNames = true;\n-    // 'y' does't have a candidate to shadow due to upward referencing.\n+    // 'y' doesn't have a candidate to shadow due to upward referencing.\n     test(\"var  g   = function( x  ) { return function( y  ) \" +\n          \" {return function() {return function() {  x   }}}}\",\n          \"var $g$$ = function($x$$) { return function($y$$) \" +\n \n   public void testShadowLotsOfScopes3() {\n     generatePseudoNames = true;\n-    // 'y' does't have a candidate to shadow due to upward referencing.\n+    // 'y' doesn't have a candidate to shadow due to upward referencing.\n     test(\"var  g   = function( x  ) { return function() \" +\n         \" {return function() {return function() {  x   }; var  y   }}}\",\n         \"var $g$$ = function($x$$) { return function() \" +\n--- a/test/com/google/javascript/jscomp/SyntacticScopeCreatorTest.java\n+++ b/test/com/google/javascript/jscomp/SyntacticScopeCreatorTest.java\n public class SyntacticScopeCreatorTest extends TestCase {\n \n   /**\n-   * Helper to create a top level scope from a javascript string\n+   * Helper to create a top-level scope from a JavaScript string\n    */\n   private static Scope getScope(String js) {\n     Compiler compiler = new Compiler();\n   }\n \n   /**\n-   * Parse the supplied js and create the global SyntaticScope object.\n+   * Parse the supplied JS and create the global SyntaticScope object.\n    * @return The error count.\n    */\n   private int createGlobalScopeHelper(String js) {\n--- a/test/com/google/javascript/jscomp/TypeCheckTest.java\n+++ b/test/com/google/javascript/jscomp/TypeCheckTest.java\n \n   public void testScoping11() throws Exception {\n     // named function expressions create a binding in their body only\n-    // the return is wrong but the assignment is ok since the type of b is ?\n+    // the return is wrong but the assignment is OK since the type of b is ?\n     testTypes(\n         \"/** @return {number} */var a = function b(){ return b };\",\n         \"inconsistent return type\\n\" +\n   }\n \n   public void testFunctionArguments13() throws Exception {\n-    // verifying that the argument type have non-inferrable types\n+    // verifying that the argument type have non-inferable types\n     testTypes(\n         \"/** @return {boolean} */ function u() { return true; }\" +\n         \"/** @param {boolean} b\\n@return {?boolean} */\" +\n   }\n \n   public void testBackwardsTypedefUse8() throws Exception {\n-    // Tehnically, this isn't quite right, because the JS runtime\n+    // Technically, this isn't quite right, because the JS runtime\n     // will coerce null -> the global object. But we'll punt on that for now.\n     testTypes(\n         \"/** @param {!Array} x */ function g(x) {}\" +\n         \"  for (var i = 0; i < 10; i++) {\" +\n         \"    f(y);\" +\n         \"    if (y != null) {\" +\n-        \"      // y is None the first time it goes thru this branch\\n\" +\n+        \"      // y is None the first time it goes through this branch\\n\" +\n         \"    } else {\" +\n         \"      y = {};\" +\n         \"    }\" +\n \n   public void testCast15() throws Exception {\n     // This fixes a bug where a type cast on an object literal\n-    // would cause a runtime cast exception if the node was visited\n+    // would cause a run-time cast exception if the node was visited\n     // more than once.\n     //\n     // Some code assumes that an object literal must have a object type,\n     // still the same type as the one on the variable\n     assertTrue(googGetpropFoo2Type == googScopeType);\n \n-    // goog.foo type on the left of the top level GETPROP node\n+    // goog.foo type on the left of the top-level GETPROP node\n     // (under second ASSIGN)\n     JSType googFooGetprop2Type = getpropFoo2.getJSType();\n     assertTrue(\"goog.foo incorrectly annotated in goog.foo.bar selection\",\n   //public void testBadPropertyOnInterface1() throws Exception {\n   //  testTypes(\"/** @interface */ u.T = function() {};\\n\" +\n   //      \"/** @return {number} */ u.T.f = function() { return 1;};\",\n-  //      \"cannot reference an interface ouside of its definition\");\n+  //      \"cannot reference an interface outside of its definition\");\n   //}\n   //\n   //public void testBadPropertyOnInterface2() throws Exception {\n   //  testTypes(\"/** @interface */ function T() {};\\n\" +\n   //      \"/** @return {number} */ T.f = function() { return 1;};\",\n-  //      \"cannot reference an interface ouside of its definition\");\n+  //      \"cannot reference an interface outside of its definition\");\n   //}\n   //\n   //public void testBadPropertyOnInterface3() throws Exception {\n   //  testTypes(\"/** @interface */ u.T = function() {}; u.T.x\",\n-  //      \"cannot reference an interface ouside of its definition\");\n+  //      \"cannot reference an interface outside of its definition\");\n   //}\n   //\n   //public void testBadPropertyOnInterface4() throws Exception {\n   //  testTypes(\"/** @interface */ function T() {}; T.x;\",\n-  //      \"cannot reference an interface ouside of its definition\");\n+  //      \"cannot reference an interface outside of its definition\");\n   //}\n \n   public void testAnnotatedPropertyOnInterface1() throws Exception {\n     // Notice that the error message is slightly different than\n     // the one for testTypeDef4, even though they should be the same.\n     // This is an implementation detail necessary for NamedTypes work out\n-    // ok, and it should change if NamedTypes ever go away.\n+    // OK, and it should change if NamedTypes ever go away.\n     testTypes(\n         \"/** @param {AB} x */ function f(x) {}\" +\n         \"/** @constructor */ function A() {}\" +\n--- a/test/com/google/javascript/jscomp/TypedScopeCreatorTest.java\n+++ b/test/com/google/javascript/jscomp/TypedScopeCreatorTest.java\n   }\n \n   public void testDeclaredObjectLitProperty6() throws Exception {\n-    testSame(\"var x = {/** This is jsdoc */ prop: function(){}};\");\n+    testSame(\"var x = {/** This is JsDoc */ prop: function(){}};\");\n     Var prop = globalScope.getVar(\"x.prop\");\n     JSType propType = prop.getType();\n     assertEquals(\"function (): undefined\", propType.toString());\n--- a/test/com/google/javascript/jscomp/deps/DepsFileParserTest.java\n+++ b/test/com/google/javascript/jscomp/deps/DepsFileParserTest.java\n         + \"/* blah */goog.addDependency(\\\"yes2\\\", [], [])/* blah*/\\n\"\n         + \"goog.addDependency('yes3', ['a','b'], ['c']); // goog.addDependency('no3', [], []);\\n\"\n         + \"// goog.addDependency('no4', [], []);\\n\"\n-        + \"goog.addDependency(\\\"yes4\\\", [], [ \\\"a\\\",'b' , 'c' ]); //no new line at eof\";\n+        + \"goog.addDependency(\\\"yes4\\\", [], [ \\\"a\\\",'b' , 'c' ]); //no new line at EOF\";\n \n     List<DependencyInfo> result = parser.parseFile(SRC_PATH, CONTENTS);\n     ImmutableList<DependencyInfo> EXPECTED = ImmutableList.<DependencyInfo>of(\n--- a/test/com/google/javascript/jscomp/deps/JsFileParserTest.java\n+++ b/test/com/google/javascript/jscomp/deps/JsFileParserTest.java\n       + \"goog.require('yes3'); // goog.provide('no3');\\n\"\n       + \"// goog.provide('no4');\\n\"\n       + \"goog.require(\\\"bar.data.SuperstarAddStarThreadActionRequestDelegate\\\"); \"\n-      + \"//no new line at eof\";\n+      + \"//no new line at EOF\";\n \n     DependencyInfo expected = new SimpleDependencyInfo(CLOSURE_PATH, SRC_PATH,\n         ImmutableList.of(\"yes1\", \"yes2\"),\n--- a/test/com/google/javascript/jscomp/deps/JsFunctionParserTest.java\n+++ b/test/com/google/javascript/jscomp/deps/JsFunctionParserTest.java\n       + \"// goog.provide('no4');\\n\"\n       + \"goog.require(\\\"\"\n       + \"bar.data.SuperstarAddStarThreadActionRequestDelegate\\\"); \"\n-      + \"//no new line at eof\";\n+      + \"//no new line at EOF\";\n \n     Collection<SymbolInfo> symbols = parser.parseFile(SRC_PATH, CONTENTS);\n \n--- a/test/com/google/javascript/jscomp/parsing/JsDocInfoParserTest.java\n+++ b/test/com/google/javascript/jscomp/parsing/JsDocInfoParserTest.java\n   }\n \n   public void testParseExtendsInvalidName() throws Exception {\n-    // This looks bad, but for the time being it should be ok, as\n-    // we will not find a type with this name in the js parsed tree.\n+    // This looks bad, but for the time being it should be OK, as\n+    // we will not find a type with this name in the JS parsed tree.\n     // If this is fixed in the future, change this test to check for a\n     // warning/error message.\n     assertTypeEquals(\n--- a/test/com/google/javascript/jscomp/parsing/JsDocTokenStreamTest.java\n+++ b/test/com/google/javascript/jscomp/parsing/JsDocTokenStreamTest.java\n   }\n \n   public void testJsDocTokenization14() throws Exception {\n-    // Since ES4 type parsing only requires to parse an ellispis when it is\n+    // Since ES4 type parsing only requires to parse an ellipsis when it is\n     // followed by a comma (,) we are allowing this case to parse this way.\n     // This is a simplification of the tokenizer, but the extra complexity is\n     // never used.\n--- a/test/com/google/javascript/jscomp/regtests/CompileEachLineOfProgramOutput.java\n+++ b/test/com/google/javascript/jscomp/regtests/CompileEachLineOfProgramOutput.java\n     System.out.println(\n         \"Usage: pass in a program to execute (with arguments)\");\n     System.out.println(\n-        \"The program is expected to produce js programs to stdout, \" +\n+        \"The program is expected to produce JS programs to stdout, \" +\n         \"one per line\");\n   }\n }", "timestamp": 1337364554, "metainfo": ""}