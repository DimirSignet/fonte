{"sha": "96c2482878059c2583343afd53c28ea4e7f5f2e2", "log": "Rewrite goog.defineClass to maintain type checks and optimizations.  R=nicksantos DELTA=603  (603 added, 0 deleted, 0 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=5619   ", "commit": "\n--- /dev/null\n+++ b/src/com/google/javascript/jscomp/ClosureRewriteClass.java\n+/*\n+ * Copyright 2012 The Closure Compiler Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.google.javascript.jscomp;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.Lists;\n+import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n+import com.google.javascript.rhino.IR;\n+import com.google.javascript.rhino.JSDocInfo;\n+import com.google.javascript.rhino.Node;\n+\n+import java.util.Collections;\n+import java.util.List;\n+\n+/**\n+ * Rewrites \"goog.defineClass\" into a form that is suitable for\n+ * type checking and dead code elimination.\n+ *\n+ * @author johnlenz@google.com (John Lenz)\n+ */\n+class ClosureRewriteClass extends AbstractPostOrderCallback\n+    implements HotSwapCompilerPass {\n+\n+  // Errors\n+  static final DiagnosticType GOOG_CLASS_TARGET_INVALID = DiagnosticType.error(\n+      \"JSC_GOOG_CLASS_TARGET_INVALID\",\n+      \"Unsupported goog.defineClass expression.\");\n+\n+  static final DiagnosticType GOOG_CLASS_SUPER_CLASS_NOT_VALID = DiagnosticType.error(\n+      \"JSC_GOOG_CLASS_SUPER_CLASS_NOT_VALID\",\n+      \"The super class must be null or a valid name reference\");\n+\n+  static final DiagnosticType GOOG_CLASS_DESCRIPTOR_NOT_VALID = DiagnosticType.error(\n+      \"JSC_GOOG_CLASS_DESCRIPTOR_NOT_VALID\",\n+      \"The class descriptor must be an object literal\");\n+\n+  static final DiagnosticType GOOG_CLASS_CONSTRUCTOR_MISING = DiagnosticType.error(\n+      \"JSC_GOOG_CLASS_CONSTRUCTOR_MISING\",\n+      \"The constructor expression is missing for the class descriptor\");\n+\n+  static final DiagnosticType GOOG_CLASS_MODIFIERS_NOT_VALID = DiagnosticType.error(\n+      \"JSC_CLASS_MODIFIERS_NOT_VALID\",\n+      \"The class modifier list must be an array literal\");\n+\n+  static final DiagnosticType GOOG_CLASS_STATICS_NOT_VALID = DiagnosticType.error(\n+      \"JSC_GOOG_CLASS_STATICS_NOT_VALID\",\n+      \"The class statics descriptor must be an object literal\");\n+\n+  private final AbstractCompiler compiler;\n+\n+  public ClosureRewriteClass(AbstractCompiler compiler) {\n+    this.compiler = compiler;\n+  }\n+\n+  @Override\n+  public void process(Node externs, Node root) {\n+    NodeTraversal.traverse(compiler, root, this);\n+  }\n+\n+  @Override\n+  public void hotSwapScript(Node scriptRoot, Node originalRoot) {\n+    this.compiler.process(this);\n+\n+  }\n+\n+  @Override\n+  public void visit(NodeTraversal t, Node n, Node parent) {\n+    if (n.isVar()) {\n+      Node target = n.getFirstChild();\n+      Node value = target.getFirstChild();\n+      maybeRewriteClassDefinition(t, n, target, value);\n+    } else if (NodeUtil.isExprAssign(n)) {\n+      Node assign = n.getFirstChild();\n+      Node target = assign.getFirstChild();\n+      Node value = assign.getLastChild();\n+      maybeRewriteClassDefinition(t, n, target, value);\n+    }\n+  }\n+\n+  private void maybeRewriteClassDefinition(\n+      NodeTraversal t, Node n, Node target, Node value) {\n+    if (isGoogDefineClass(value)) {\n+      if (!target.isQualifiedName()) {\n+        compiler.report(t.makeError(n, GOOG_CLASS_TARGET_INVALID));\n+      }\n+      ClassDefinition def = extractClassDefinition(t, target, value);\n+      if (def != null) {\n+        value.detachFromParent();\n+        target.detachFromParent();\n+        rewriteGoogDefineClass(n, def);\n+      }\n+    }\n+  }\n+\n+  private static class MemberDefinition {\n+    final JSDocInfo info;\n+    final Node name;\n+    final Node value;\n+\n+    MemberDefinition(JSDocInfo info, Node name, Node value) {\n+      this.info = info;\n+      this.name = name;\n+      this.value = value;\n+    }\n+  }\n+\n+  private final class ClassDefinition {\n+    final Node name;\n+    final Node superClass;\n+    final MemberDefinition constructor;\n+    final List<MemberDefinition> staticProps;\n+    final List<MemberDefinition> props;\n+    final List<Node>  modifiers;\n+\n+    ClassDefinition(\n+        Node name,\n+        Node superClass,\n+        MemberDefinition constructor,\n+        List<MemberDefinition> staticProps,\n+        List<MemberDefinition> props,\n+        List<Node> modifiers) {\n+      this.name = name;\n+      this.superClass = superClass;\n+      this.constructor = constructor;\n+      this.staticProps = staticProps;\n+      this.props = props;\n+      this.modifiers = modifiers;\n+    }\n+  }\n+\n+  /**\n+   * Validates the class definition and if valid, destructively extracts\n+   * the class definition from the AST.\n+   */\n+  private ClassDefinition extractClassDefinition(\n+      NodeTraversal t, Node targetName, Node callNode) {\n+    // name = goog.defineClass(superClass, {...}, [modifier, ...])\n+    Node superClass = NodeUtil.getArgumentForCallOrNew(callNode, 0);\n+    if (superClass == null ||\n+        (!superClass.isNull() && !superClass.isQualifiedName())) {\n+      compiler.report(t.makeError(callNode, GOOG_CLASS_SUPER_CLASS_NOT_VALID));\n+      return null;\n+    }\n+    if (NodeUtil.isNullOrUndefined(superClass)) {\n+      superClass = null;\n+    }\n+\n+    Node description = NodeUtil.getArgumentForCallOrNew(callNode, 1);\n+    if (description == null\n+        || !description.isObjectLit()\n+        || !validateObjLit(description)) {\n+      // report bad class definition\n+      compiler.report(t.makeError(callNode, GOOG_CLASS_DESCRIPTOR_NOT_VALID));\n+      return null;\n+    }\n+\n+    Node constructor = extractProperty(description, \"constructor\");\n+    if (constructor == null) {\n+      // report missing constructor\n+      compiler.report(t.makeError(description, GOOG_CLASS_CONSTRUCTOR_MISING));\n+      return null;\n+    }\n+    JSDocInfo info = NodeUtil.getBestJSDocInfo(constructor);\n+\n+    Node statics = extractProperty(description, \"statics\");\n+    if (statics != null\n+        && !(statics.isObjectLit() && validateObjLit(statics))) {\n+      compiler.report(t.makeError(statics, GOOG_CLASS_STATICS_NOT_VALID));\n+      return null;\n+    }\n+    if (statics == null) {\n+      statics = IR.objectlit();\n+    }\n+\n+    Node modifiers = NodeUtil.getArgumentForCallOrNew(callNode, 2);\n+    if (modifiers != null && !modifiers.isArrayLit()) {\n+      compiler.report(t.makeError(modifiers, GOOG_CLASS_MODIFIERS_NOT_VALID));\n+      return null;\n+    }\n+    if (modifiers == null) {\n+      modifiers = IR.arraylit();\n+    }\n+\n+    // Ok, now rip apart the definition into its component pieces.\n+    maybeDetach(constructor.getParent());  // remove the property node.\n+    maybeDetach(statics.getParent());\n+    ClassDefinition def = new ClassDefinition(\n+        targetName,\n+        maybeDetach(superClass),\n+        new MemberDefinition(info, null, maybeDetach(constructor)),\n+        objectLitToList(maybeDetach(statics)),\n+        objectLitToList(description),\n+        arrayNodeToList(modifiers));\n+    return def;\n+  }\n+\n+  private Node maybeDetach(Node node) {\n+    if (node != null && node.getParent() != null) {\n+      node.detachFromParent();\n+    }\n+    return node;\n+  }\n+\n+  // Only unquoted plain properties are currently supported.\n+  private boolean validateObjLit(Node objlit) {\n+    for (Node key : objlit.children()) {\n+      if (!key.isStringKey() || key.isQuotedString()) {\n+        return false;\n+      }\n+    }\n+    return true;\n+  }\n+\n+  /**\n+   * @return The first property in the objlit that matches the key.\n+   */\n+  private Node extractProperty(Node objlit, String keyName) {\n+    for (Node keyNode : objlit.children()) {\n+      if (keyNode.getString().equals(keyName)) {\n+        return keyNode.isStringKey() ? keyNode.getFirstChild() : null;\n+      }\n+    }\n+    return null;\n+  }\n+\n+  private List<MemberDefinition> objectLitToList(\n+      Node objlit) {\n+    List<MemberDefinition> result = Lists.newArrayList();\n+    for (Node keyNode : objlit.children()) {\n+      result.add(\n+          new MemberDefinition(\n+                NodeUtil.getBestJSDocInfo(keyNode),\n+                keyNode,\n+                keyNode.removeFirstChild()));\n+    }\n+    objlit.detachChildren();\n+    return result;\n+  }\n+\n+  private List<Node> arrayNodeToList(Node arr) {\n+    Preconditions.checkState(arr == null || arr.isArrayLit());\n+\n+    if (arr == null) {\n+      return Collections.<Node>emptyList();\n+    } else {\n+      List<Node> result = Lists.newArrayList(arr.children());\n+      arr.detachChildren();\n+      return result;\n+    }\n+  }\n+\n+  private void rewriteGoogDefineClass(Node exprRoot, ClassDefinition cls) {\n+\n+    // For simplicity add everything into a block, before adding it to the AST.\n+    Node block = IR.block();\n+\n+    if (exprRoot.isVar()) {\n+      // example: var ctr = function(){}\n+      block.addChildToBack(\n+          IR.var(\n+          cls.name.cloneTree(), cls.constructor.value)\n+          .srcref(exprRoot).setJSDocInfo(cls.constructor.info));\n+    } else {\n+      // example: ns.ctr = function(){}\n+      block.addChildToBack(\n+          fixupSrcref(IR.exprResult(\n+          IR.assign(\n+          cls.name.cloneTree(), cls.constructor.value)\n+          .srcref(exprRoot).setJSDocInfo(cls.constructor.info)\n+          .srcref(exprRoot))).setJSDocInfo(cls.constructor.info));\n+    }\n+\n+    if (cls.superClass != null) {\n+      // example: goog.inherits(ctr, superClass)\n+      block.addChildToBack(\n+          fixupSrcref(IR.exprResult(\n+              IR.call(\n+                  NodeUtil.newQualifiedNameNode(\n+                      compiler.getCodingConvention(), \"goog.inherits\")\n+                      .srcrefTree(cls.superClass),\n+                  cls.name.cloneTree(),\n+                  cls.superClass.cloneTree()).srcref(cls.superClass))));\n+    }\n+\n+    for (MemberDefinition def : cls.staticProps) {\n+      // example: ctr.prop = value\n+      block.addChildToBack(\n+          fixupSrcref(IR.exprResult(\n+          fixupSrcref(IR.assign(\n+              IR.getprop(cls.name.cloneTree(),\n+                  IR.string(def.name.getString()).srcref(def.name))\n+                  .srcref(def.name),\n+              def.value)).setJSDocInfo(def.info))));\n+    }\n+\n+    for (MemberDefinition def : cls.props) {\n+      // example: ctr.prototype.prop = value\n+      block.addChildToBack(\n+          fixupSrcref(IR.exprResult(\n+          fixupSrcref(IR.assign(\n+              IR.getprop(\n+                  fixupSrcref(IR.getprop(cls.name.cloneTree(),\n+                      IR.string(\"prototype\").srcref(def.name))),\n+                  IR.string(def.name.getString()).srcref(def.name))\n+                  .srcref(def.name),\n+              def.value)).setJSDocInfo(def.info))));\n+    }\n+\n+    for (Node modifier : cls.modifiers) {\n+      // example: modifier(ctr)\n+      block.addChildToBack(\n+          IR.exprResult(\n+              fixupFreeCall(IR.call(\n+                  modifier,\n+                  cls.name.cloneTree())\n+                  .srcref(modifier)))\n+              .srcref(modifier));\n+\n+    }\n+\n+    exprRoot.getParent().replaceChild(exprRoot, block);\n+    compiler.reportCodeChange();\n+  }\n+\n+  private Node fixupSrcref(Node node) {\n+    node.srcref(node.getFirstChild());\n+    return node;\n+  }\n+\n+  private Node fixupFreeCall(Node call) {\n+    if (call.getFirstChild().isName()) {\n+      call.putBooleanProp(Node.FREE_CALL, true);\n+    }\n+    return call;\n+  }\n+\n+  /**\n+   * @return Whether the call represents a class definition.\n+   */\n+  private boolean isGoogDefineClass(Node value) {\n+    return value != null && value.isCall()\n+        && \"goog.defineClass\".equals(value.getFirstChild().getQualifiedName());\n+  }\n+}\n--- a/src/com/google/javascript/jscomp/DefaultPassConfig.java\n+++ b/src/com/google/javascript/jscomp/DefaultPassConfig.java\n \n     if (options.closurePass) {\n       checks.add(closureGoogScopeAliases);\n+      checks.add(closureRewriteGoogClass);\n     }\n \n     if (options.nameAnonymousFunctionsOnly) {\n           compiler,\n           preprocessorSymbolTable,\n           options.getAliasTransformationHandler());\n+    }\n+  };\n+\n+  /** Rewrites goog.class */\n+  final HotSwapPassFactory closureRewriteGoogClass =\n+      new HotSwapPassFactory(\"closureRewriteGoogClass\", true) {\n+    @Override\n+    protected HotSwapCompilerPass createInternal(AbstractCompiler compiler) {\n+      return new ClosureRewriteClass(compiler);\n     }\n   };\n \n--- a/src/com/google/javascript/rhino/Node.java\n+++ b/src/com/google/javascript/rhino/Node.java\n   /**\n    * Sets the {@link JSDocInfo} attached to this node.\n    */\n-  public void setJSDocInfo(JSDocInfo info) {\n+  public Node setJSDocInfo(JSDocInfo info) {\n       putProp(JSDOC_INFO_PROP, info);\n+      return this;\n   }\n \n   /**\n--- /dev/null\n+++ b/test/com/google/javascript/jscomp/ClosureRewriteClassTest.java\n+/*\n+ * Copyright 2012 The Closure Compiler Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.google.javascript.jscomp;\n+\n+import static com.google.javascript.jscomp.ClosureRewriteClass.GOOG_CLASS_CONSTRUCTOR_MISING;\n+import static com.google.javascript.jscomp.ClosureRewriteClass.GOOG_CLASS_DESCRIPTOR_NOT_VALID;\n+import static com.google.javascript.jscomp.ClosureRewriteClass.GOOG_CLASS_MODIFIERS_NOT_VALID;\n+import static com.google.javascript.jscomp.ClosureRewriteClass.GOOG_CLASS_STATICS_NOT_VALID;\n+import static com.google.javascript.jscomp.ClosureRewriteClass.GOOG_CLASS_SUPER_CLASS_NOT_VALID;\n+\n+/**\n+ * Unit tests for ClosureRewriteGoogClass\n+ * @author johnlenz@google.com (John Lenz)\n+ */\n+public class ClosureRewriteClassTest extends CompilerTestCase {\n+\n+  @Override\n+  protected CompilerPass getProcessor(Compiler compiler) {\n+    return new ClosureRewriteClass(compiler);\n+  }\n+\n+  @Override\n+  protected void setUp() throws Exception {\n+    super.setUp();\n+    this.enableEcmaScript5(false);\n+  }\n+\n+  public void testBasic1() {\n+    test(\n+        \"var x = goog.defineClass(null, {\\n\" +\n+        \"  constructor: function(){}\\n\" +\n+        \"});\",\n+\n+        \"{var x = function() {};}\");\n+  }\n+\n+  public void testBasic2() {\n+    test(\n+        \"var x = {};\\n\" +\n+        \"x.y = goog.defineClass(null, {\\n\" +\n+        \"  constructor: function(){}\\n\" +\n+        \"});\",\n+\n+        \"var x = {};\" +\n+        \"{x.y = function() {};}\");\n+  }\n+\n+  public void testComplete1() {\n+    test(\n+        \"var x = goog.defineClass(some.Super, {\\n\" +\n+        \"  constructor: function(){\\n\" +\n+        \"    this.foo = 1;\\n\" +\n+        \"  },\\n\" +\n+        \"  statics: {\\n\" +\n+        \"    prop1: 1,\\n\" +\n+        \"    /** @const */\\n\" +\n+        \"    PROP2: 2\\n\" +\n+        \"  },\\n\" +\n+        \"  anotherProp: 1,\\n\" +\n+        \"  aMethod: function() {}\\n\" +\n+        \"}, [goog.addSingletonGetter, seal]);\",\n+\n+        \"{\" +\n+        \"var x=function(){this.foo=1};\" +\n+        \"goog.inherits(x,some.Super);\" +\n+        \"x.prop1=1;\" +\n+        \"x.PROP2=2;\" +\n+        \"x.prototype.anotherProp=1;\" +\n+        \"x.prototype.aMethod=function(){};\" +\n+        \"goog.addSingletonGetter(x);\" +\n+        \"seal(x);\" +\n+        \"}\");\n+  }\n+\n+  public void testComplete2() {\n+    test(\n+        \"x.y = goog.defineClass(some.Super, {\\n\" +\n+        \"  constructor: function(){\\n\" +\n+        \"    this.foo = 1;\\n\" +\n+        \"  },\\n\" +\n+        \"  statics: {\\n\" +\n+        \"    prop1: 1,\\n\" +\n+        \"    /** @const */\\n\" +\n+        \"    PROP2: 2\\n\" +\n+        \"  },\\n\" +\n+        \"  anotherProp: 1,\\n\" +\n+        \"  aMethod: function() {}\\n\" +\n+        \"}, [goog.addSingletonGetter, seal]);\",\n+\n+        \"{\\n\" +\n+        \"/** @constructor */\\n\" +\n+        \"x.y=function(){this.foo=1};\\n\" +\n+        \"goog.inherits(x.y,some.Super);\" +\n+        \"x.y.prop1=1;\\n\" +\n+        \"/** @const */\\n\" +\n+        \"x.y.PROP2=2;\\n\" +\n+        \"x.y.prototype.anotherProp=1;\" +\n+        \"x.y.prototype.aMethod=function(){};\" +\n+        \"goog.addSingletonGetter(x.y);\" +\n+        \"seal(x.y);\" +\n+        \"}\");\n+  }\n+\n+\n+  public void testInvalid1() {\n+    testSame(\n+        \"var x = goog.defineClass();\",\n+        GOOG_CLASS_SUPER_CLASS_NOT_VALID, true);\n+    testSame(\n+        \"var x = goog.defineClass('foo');\",\n+        GOOG_CLASS_SUPER_CLASS_NOT_VALID, true);\n+    testSame(\n+        \"var x = goog.defineClass(foo());\",\n+        GOOG_CLASS_SUPER_CLASS_NOT_VALID, true);\n+    testSame(\n+        \"var x = goog.defineClass({'foo':1});\",\n+        GOOG_CLASS_SUPER_CLASS_NOT_VALID, true);\n+    testSame(\n+        \"var x = goog.defineClass({1:1});\",\n+        GOOG_CLASS_SUPER_CLASS_NOT_VALID, true);\n+\n+    this.enableEcmaScript5(true);\n+\n+    testSame(\n+        \"var x = goog.defineClass({get foo() {return 1}});\",\n+        GOOG_CLASS_SUPER_CLASS_NOT_VALID, true);\n+    testSame(\n+        \"var x = goog.defineClass({set foo(a) {}});\",\n+        GOOG_CLASS_SUPER_CLASS_NOT_VALID, true);\n+  }\n+\n+  public void testInvalid2() {\n+    testSame(\n+        \"var x = goog.defineClass(null);\",\n+        GOOG_CLASS_DESCRIPTOR_NOT_VALID, true);\n+    testSame(\n+        \"var x = goog.defineClass(null, null);\",\n+        GOOG_CLASS_DESCRIPTOR_NOT_VALID, true);\n+    testSame(\n+        \"var x = goog.defineClass(null, foo());\",\n+        GOOG_CLASS_DESCRIPTOR_NOT_VALID, true);\n+  }\n+\n+  public void testInvalid3() {\n+    testSame(\n+        \"var x = goog.defineClass(null, {});\",\n+        GOOG_CLASS_CONSTRUCTOR_MISING, true);\n+  }\n+\n+  public void testInvalid4() {\n+    testSame(\n+        \"var x = goog.defineClass(null, {\" +\n+        \"  constructor: function(){},\" +\n+        \"  statics: null\" +\n+        \"});\",\n+        GOOG_CLASS_STATICS_NOT_VALID, true);\n+    testSame(\n+        \"var x = goog.defineClass(null, {\" +\n+        \"  constructor: function(){},\" +\n+        \"  statics: foo\" +\n+        \"});\",\n+        GOOG_CLASS_STATICS_NOT_VALID, true);\n+    testSame(\n+        \"var x = goog.defineClass(null, {\" +\n+        \"  constructor: function(){},\" +\n+        \"  statics: {'foo': 1}\" +\n+        \"});\",\n+        GOOG_CLASS_STATICS_NOT_VALID, true);\n+    testSame(\n+        \"var x = goog.defineClass(null, {\" +\n+        \"  constructor: function(){},\" +\n+        \"  statics: {1: 1}\" +\n+        \"});\",\n+        GOOG_CLASS_STATICS_NOT_VALID, true);  }\n+\n+  public void testInvalid5() {\n+    testSame(\n+        \"var x = goog.defineClass(null, {\" +\n+        \"  constructor: function(){}\" +\n+        \"}, null);\",\n+        GOOG_CLASS_MODIFIERS_NOT_VALID, true);\n+    testSame(\n+        \"var x = goog.defineClass(null, {\" +\n+        \"  constructor: function(){}\" +\n+        \"}, foo);\",\n+        GOOG_CLASS_MODIFIERS_NOT_VALID, true);\n+  }\n+}\n--- a/test/com/google/javascript/jscomp/IntegrationTest.java\n+++ b/test/com/google/javascript/jscomp/IntegrationTest.java\n     assertTrue(options.collapseProperties);\n     // CollapseProperties used to prevent inlining this property.\n     test(options, code, \"alert(2);\");\n+  }\n+\n+  public void testGoogDefineClass1() {\n+    CompilerOptions options = createCompilerOptions();\n+    CompilationLevel level = CompilationLevel.ADVANCED_OPTIMIZATIONS;\n+    level.setOptionsForCompilationLevel(options);\n+    level.setTypeBasedOptimizationOptions(options);\n+\n+    String code = \"\" +\n+        \"var ns = {};\\n\" +\n+        \"ns.C = goog.defineClass(null, {\\n\" +\n+        \"  /** @constructor */\\n\" +\n+        \"  constructor: function () {this.someProperty = 1}\\n\" +\n+        \"});\\n\" +\n+        \"alert(new ns.C().someProperty + new ns.C().someProperty);\\n\";\n+    assertTrue(options.inlineProperties);\n+    assertTrue(options.collapseProperties);\n+    // CollapseProperties used to prevent inlining this property.\n+    test(options, code, \"alert(2);\");\n+  }\n+\n+  public void testGoogDefineClass2() {\n+    CompilerOptions options = createCompilerOptions();\n+    CompilationLevel level = CompilationLevel.ADVANCED_OPTIMIZATIONS;\n+    level.setOptionsForCompilationLevel(options);\n+    level.setTypeBasedOptimizationOptions(options);\n+\n+    String code = \"\" +\n+        \"var C = goog.defineClass(null, {\\n\" +\n+        \"  /** @constructor */\\n\" +\n+        \"  constructor: function () {this.someProperty = 1}\\n\" +\n+        \"});\\n\" +\n+        \"alert(new C().someProperty + new C().someProperty);\\n\";\n+    assertTrue(options.inlineProperties);\n+    assertTrue(options.collapseProperties);\n+    // CollapseProperties used to prevent inlining this property.\n+    test(options, code, \"alert(2);\");\n+  }\n+\n+  public void testGoogDefineClass3() {\n+    CompilerOptions options = createCompilerOptions();\n+    CompilationLevel level = CompilationLevel.ADVANCED_OPTIMIZATIONS;\n+    level.setOptionsForCompilationLevel(options);\n+    level.setTypeBasedOptimizationOptions(options);\n+    WarningLevel warnings = WarningLevel.VERBOSE;\n+    warnings.setOptionsForWarningLevel(options);\n+\n+    String code = \"\" +\n+        \"var C = goog.defineClass(null, {\\n\" +\n+        \"  /** @constructor */\\n\" +\n+        \"  constructor: function () {\\n\" +\n+        \"    /** @type {number} */\\n\" +\n+        \"    this.someProperty = 1},\\n\" +\n+        \"  /** @param {string} a */\\n\" +\n+        \"  someMethod: function (a) {}\\n\" +\n+        \"});\" +\n+        \"var x = new C();\\n\" +\n+        \"x.someMethod(x.someProperty);\\n\";\n+    assertTrue(options.inlineProperties);\n+    assertTrue(options.collapseProperties);\n+    // CollapseProperties used to prevent inlining this property.\n+    test(options, code, TypeValidator.TYPE_MISMATCH_WARNING);\n   }\n \n   public void testCheckConstants1() {", "timestamp": 1349726206, "metainfo": ""}