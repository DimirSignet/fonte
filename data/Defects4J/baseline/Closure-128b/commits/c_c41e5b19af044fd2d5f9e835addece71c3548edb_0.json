{"sha": "c41e5b19af044fd2d5f9e835addece71c3548edb", "log": "Change on 2010/08/04 17:22:12 by nicksantos  \tAdd a pass to strip assertion functions, so that we can get people \tto stop using --strip_type=goog.asserts.  \tR=johnlenz \tDELTA=108  (96 added, 2 deleted, 10 changed)  Revision created by MOE tool push_codebase. MOE_MIGRATION=85013   ", "commit": "\n--- a/src/com/google/javascript/jscomp/ClosureCodeRemoval.java\n+++ b/src/com/google/javascript/jscomp/ClosureCodeRemoval.java\n package com.google.javascript.jscomp;\n \n import com.google.common.collect.Lists;\n+import com.google.common.collect.Sets;\n+import com.google.javascript.jscomp.CodingConvention.AssertionFunctionSpec;\n import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n+import com.google.javascript.jscomp.NodeTraversal.Callback;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n \n import java.util.List;\n+import java.util.Set;\n \n /**\n  * <p>Compiler pass that removes Closure-specific code patterns.</p>\n  *   <li> Instead  of setting abstract methods to a function that throws an\n  *        informative error, this pass allows some binary size reduction by\n  *        removing these methods altogether for production builds.</li>\n+ *   <li> Remove calls to assertion functions (like goog.asserts.assert).\n+ *        If the return value of the assertion function is used, then\n+ *        the first argument (the asserted value) will be directly inlined.\n+ *        Otherwise, the entire call will be removed. It is well-known that\n+ *        this is not provably safe, much like the equivalent assert\n+ *        statement in Java.</li>\n  * </ul>\n  *\n  * @author robbyw@google.com (Robby Walker)\n   /** Name used to denote an abstract function */\n   static final String ABSTRACT_METHOD_NAME = \"goog.abstractMethod\";\n \n+  private final boolean removeAbstractMethods;\n+  private final boolean removeAssertionCalls;\n+\n   /**\n    * List of names referenced in successive generations of finding referenced\n-   * nodes\n+   * nodes.\n    */\n   private final List<RemovableAssignment> abstractMethodAssignmentNodes =\n       Lists.newArrayList();\n+\n+  /**\n+   * List of assertion functions.\n+   */\n+  private final List<Node> assertionCalls = Lists.newArrayList();\n \n \n   /**\n     }\n   }\n \n-\n-\n   /**\n    * Identifies all assignments of the abstract method to a variable.\n    */\n   private class FindAbstractMethods extends AbstractPostOrderCallback {\n-\n+    @Override\n     public void visit(NodeTraversal t, Node n, Node parent) {\n       if (n.getType() == Token.ASSIGN) {\n         Node nameNode = n.getFirstChild();\n \n \n   /**\n+   * Identifies all assertion calls.\n+   */\n+  private class FindAssertionCalls extends AbstractPostOrderCallback {\n+    Set<String> assertionNames = Sets.newHashSet();\n+\n+    FindAssertionCalls() {\n+      for (AssertionFunctionSpec spec :\n+               compiler.getCodingConvention().getAssertionFunctions()) {\n+        assertionNames.add(spec.getFunctionName());\n+      }\n+    }\n+\n+\n+    @Override\n+    public void visit(NodeTraversal t, Node n, Node parent) {\n+      if (n.getType() == Token.CALL) {\n+        String fnName = n.getFirstChild().getQualifiedName();\n+        if (assertionNames.contains(fnName)) {\n+          assertionCalls.add(n);\n+        }\n+      }\n+    }\n+  }\n+\n+\n+  /**\n    * Creates a Closure code remover.\n    *\n    * @param compiler The AbstractCompiler\n-   */\n-  ClosureCodeRemoval(AbstractCompiler compiler) {\n+   * @param removeAbstractMethods Remove declarations of abstract methods.\n+   * @param removeAssertionCalls Remove calls to goog.assert functions.\n+   */\n+  ClosureCodeRemoval(AbstractCompiler compiler, boolean removeAbstractMethods,\n+                     boolean removeAssertionCalls) {\n     this.compiler = compiler;\n+    this.removeAbstractMethods = removeAbstractMethods;\n+    this.removeAssertionCalls = removeAssertionCalls;\n   }\n \n   @Override\n   public void process(Node externs, Node root) {\n-    NodeTraversal.traverse(compiler, root, new FindAbstractMethods());\n+    List<Callback> passes = Lists.newArrayList();\n+    if (removeAbstractMethods) {\n+      passes.add(new FindAbstractMethods());\n+    }\n+    if (removeAssertionCalls) {\n+      passes.add(new FindAssertionCalls());\n+    }\n+    CombinedCompilerPass.traverse(compiler, root, passes);\n \n     for (RemovableAssignment assignment : abstractMethodAssignmentNodes) {\n       assignment.remove();\n     }\n+\n+    for (Node call : assertionCalls) {\n+      // If the assertion is an expression, just strip the whole thing.\n+      Node parent = call.getParent();\n+      if (NodeUtil.isExpressionNode(parent)) {\n+        parent.getParent().removeChild(parent);\n+      } else {\n+        // Otherwise, replace the assertion with its first argument,\n+        // which is the return value of the assertion.\n+        parent.replaceChild(\n+            call, call.getFirstChild().getNext().detachFromParent());\n+      }\n+      compiler.reportCodeChange();\n+    }\n   }\n }\n--- a/src/com/google/javascript/jscomp/CombinedCompilerPass.java\n+++ b/src/com/google/javascript/jscomp/CombinedCompilerPass.java\n \n package com.google.javascript.jscomp;\n \n+import com.google.common.collect.Lists;\n import com.google.javascript.jscomp.NodeTraversal.Callback;\n import com.google.javascript.jscomp.NodeTraversal.ScopedCallback;\n import com.google.javascript.rhino.Node;\n+\n+import java.util.List;\n \n /**\n  * <p>A compiler pass combining multiple {@link Callback}\n    */\n   CombinedCompilerPass(\n       AbstractCompiler compiler, Callback... callbacks) {\n+    this(compiler, Lists.<Callback>newArrayList(callbacks));\n+  }\n+\n+  CombinedCompilerPass(\n+      AbstractCompiler compiler, List<Callback> callbacks) {\n     this.compiler = compiler;\n-    this.callbacks = new CallbackWrapper[callbacks.length];\n-    for (int i = 0; i < callbacks.length; i++) {\n-      this.callbacks[i] = new CallbackWrapper(callbacks[i]);\n+    this.callbacks = new CallbackWrapper[callbacks.size()];\n+    for (int i = 0; i < callbacks.size(); i++) {\n+      this.callbacks[i] = new CallbackWrapper(callbacks.get(i));\n+    }\n+  }\n+\n+  static void traverse(AbstractCompiler compiler, Node root,\n+      List<Callback> callbacks) {\n+    if (callbacks.size() == 1) {\n+      NodeTraversal.traverse(compiler, root, callbacks.get(0));\n+    } else {\n+      (new CombinedCompilerPass(compiler, callbacks)).process(null, root);\n     }\n   }\n \n--- a/src/com/google/javascript/jscomp/DefaultPassConfig.java\n+++ b/src/com/google/javascript/jscomp/DefaultPassConfig.java\n       new PassFactory(\"closureCodeRemoval\", true) {\n     @Override\n     protected CompilerPass createInternal(final AbstractCompiler compiler) {\n-      return new ClosureCodeRemoval(compiler);\n+      // TODO(nicksantos): add flags.\n+      return new ClosureCodeRemoval(compiler, true, false);\n     }\n   };\n \n--- a/test/com/google/javascript/jscomp/ClosureCodeRemovalTest.java\n+++ b/test/com/google/javascript/jscomp/ClosureCodeRemovalTest.java\n          \"goog.abstractMethod;\");\n   }\n \n+  public void testAssertionRemoval1() {\n+    test(\"var x = goog.asserts.assert(y(), 'message');\", \"var x = y();\");\n+  }\n+\n+  public void testAssertionRemoval2() {\n+    test(\"goog.asserts.assert(y(), 'message');\", \"\");\n+  }\n+\n   @Override\n   protected ClosureCodeRemoval getProcessor(Compiler compiler) {\n-    return new ClosureCodeRemoval(compiler);\n+    return new ClosureCodeRemoval(compiler, true, true);\n   }\n }", "timestamp": 1280967732, "metainfo": ""}