{"sha": "cf3fcbbc124d5b8948d7bef5215c45d80dbeae8e", "log": "Correct handling of sparse arrays.  R=nicksantos DELTA=37  (28 added, 2 deleted, 7 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=529   ", "commit": "\n--- a/src/com/google/javascript/jscomp/ClosureCodingConvention.java\n+++ b/src/com/google/javascript/jscomp/ClosureCodingConvention.java\n       }\n \n       if (type == SubclassType.MIXIN) {\n-        // Only consider mixins that mix two prototypes as related to inheritance.\n+        // Only consider mixins that mix two prototypes as related to\n+        // inheritance.\n         if (!endsWithPrototype(superclass)) {\n           return null;\n         }\n     if (\"goog.addDependency\".equals(callName.getQualifiedName()) &&\n         n.getChildCount() >= 3) {\n       Node typeArray = callName.getNext().getNext();\n-      if (typeArray.getType() == Token.ARRAYLIT) {\n+      if (typeArray.getType() == Token.ARRAYLIT\n+          && !NodeUtil.isSparseArray(typeArray)) {\n         List<String> typeNames = Lists.newArrayList();\n         for (Node name = typeArray.getFirstChild(); name != null;\n              name = name.getNext()) {\n--- a/src/com/google/javascript/jscomp/NodeUtil.java\n+++ b/src/com/google/javascript/jscomp/NodeUtil.java\n   }\n \n   static boolean isBooleanResultHelper(Node n) {\n-    // TODO(johnlenz): Add a recursive option to recurse into\n-    // AND, OR, HOOK, COMMA and ASSIGN, like \"getExpressionBooleanValue\".\n     switch (n.getType()) {\n       // Primitives\n       case Token.TRUE:\n    */\n   static boolean isThis(Node node) {\n     return node.getType() == Token.THIS;\n+  }\n+\n+\n+  /**\n+   * Is this an ARRAYLIT node\n+   */\n+  static boolean isArrayLiteral(Node node) {\n+    return node.getType() == Token.ARRAYLIT;\n+  }\n+\n+  /**\n+   * Is this an sparse ARRAYLIT node\n+   */\n+  static boolean isSparseArray(Node node) {\n+    Preconditions.checkArgument(isArrayLiteral(node));\n+    int[] skipList = (int[]) node.getProp(Node.SKIP_INDEXES_PROP);\n+    return skipList != null && skipList.length > 0;\n   }\n \n   /**\n--- a/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\n+++ b/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\n     Node functionName = arrayNode.getNext();\n \n     if ((arrayNode.getType() != Token.ARRAYLIT) ||\n+        NodeUtil.isSparseArray(arrayNode) ||\n         !functionName.getString().equals(\"join\")) {\n       return n;\n     }\n   private Node tryFoldGetElem(Node n, Node left, Node right) {\n     Preconditions.checkArgument(n.getType() == Token.GETELEM);\n \n-    if (left.getType() == Token.ARRAYLIT) {\n+    if (left.getType() == Token.ARRAYLIT && !NodeUtil.isSparseArray(left)) {\n       // TODO(johnlenz): handle sparse arrays\n \n       if (right.getType() != Token.NUMBER) {\n       switch (left.getType()) {\n         case Token.ARRAYLIT:\n           // TODO(johnlenz): handle sparse arrays\n-          if (mayHaveSideEffects(left)) {\n+          if (NodeUtil.isSparseArray(left) || mayHaveSideEffects(left)) {\n             // Nope, can't fold this, without handling the side-effects.\n             return n;\n           }\n--- a/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n+++ b/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n       action = FoldArrayAction.SAFE_TO_FOLD_WITH_ARGS;\n     } else {\n       switch (arg.getType()) {\n-        case (Token.STRING):\n+        case Token.STRING:\n           // \"Array('a')\" --> \"['a']\"\n           action = FoldArrayAction.SAFE_TO_FOLD_WITH_ARGS;\n           break;\n-        case (Token.NUMBER):\n+        case Token.NUMBER:\n           // \"Array(0)\" --> \"[]\"\n           if (arg.getDouble() == 0) {\n             action = FoldArrayAction.SAFE_TO_FOLD_WITHOUT_ARGS;\n           }\n           break;\n-        case (Token.ARRAYLIT):\n+        case Token.ARRAYLIT:\n           // \"Array([args])\" --> \"[[args]]\"\n           action = FoldArrayAction.SAFE_TO_FOLD_WITH_ARGS;\n           break;\n--- a/test/com/google/javascript/jscomp/PeepholeFoldConstantsTest.java\n+++ b/test/com/google/javascript/jscomp/PeepholeFoldConstantsTest.java\n     foldSame(\"x = 'abcdef'.indexOf([1,2])\");\n   }\n \n+  public void testStringJoinAddSparse() {\n+    foldSame(\"x = [,,'a'].join(',')\"); // Could be: x = ',,a'\n+  }\n+\n   public void testStringJoinAdd() {\n     fold(\"x = ['a', 'b', 'c'].join('')\", \"x = \\\"abc\\\"\");\n     fold(\"x = [].join(',')\", \"x = \\\"\\\"\");\n   }\n \n   public void testFoldGetElem() {\n+    foldSame(\"x = [,10][0]\"); // Should be \"x = void 0\";\n     fold(\"x = [10, 20][0]\", \"x = 10\");\n     fold(\"x = [10, 20][1]\", \"x = 20\");\n     fold(\"x = [10, 20][0.5]\", \"\",\n     fold(\"x = [].length\", \"x = 0\");\n     fold(\"x = [1,2,3].length\", \"x = 3\");\n     fold(\"x = [a,b].length\", \"x = 2\");\n+\n+    // Not handled yet\n+    foldSame(\"x = [,,1].length\"); // Should be \"x = 3\"\n \n     // Cannot fold\n     fold(\"x = [foo(), 0].length\", \"x = [foo(),0].length\");", "timestamp": 1297803977, "metainfo": ""}