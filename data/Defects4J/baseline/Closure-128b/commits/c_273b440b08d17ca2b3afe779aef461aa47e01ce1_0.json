{"sha": "273b440b08d17ca2b3afe779aef461aa47e01ce1", "log": "Make it easier to write unit tests that verify that the a peephole optimization does not require multiple passes (some do).  R=blickly DELTA=32 (19 added, 1 deleted, 12 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=6004   ", "commit": "\n--- a/src/com/google/javascript/jscomp/PeepholeOptimizationsPass.java\n+++ b/src/com/google/javascript/jscomp/PeepholeOptimizationsPass.java\n class PeepholeOptimizationsPass\n     implements CompilerPass {\n   private AbstractCompiler compiler;\n-\n+  \n   // Use an array here for faster iteration compared to ImmutableSet\n   private final AbstractPeepholeOptimization[] peepholeOptimizations;\n \n   // Track whether the a scope has been modified so that it can be revisited\n   // immediately.\n   private StateStack traversalState = new StateStack();\n+\n+  private boolean retraverseOnChange = true;\n \n   static private class ScopeState {\n     boolean changed;\n     this.compiler = compiler;\n     this.peepholeOptimizations = optimizations;\n   }\n+  \n+  PeepholeOptimizationsPass setRetraverseOnChange(boolean retraverse) {\n+    this.retraverseOnChange = retraverse;\n+    return this;\n+  }\n \n   public AbstractCompiler getCompiler() {\n     return compiler;\n   }\n \n   private boolean shouldRetraverse(Node node) {\n-    if (node.getParent() != null && node.isFunction() || node.isScript()) {\n+    if (retraverseOnChange\n+        && node.getParent() != null \n+        && (node.isFunction() || node.isScript())) {\n       ScopeState state = traversalState.peek();\n       if (state.changed) {\n         // prepare to re-visit the scope:\n--- a/test/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntaxTest.java\n+++ b/test/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntaxTest.java\n   public CompilerPass getProcessor(final Compiler compiler) {\n     CompilerPass peepholePass =\n       new PeepholeOptimizationsPass(compiler,\n-          new PeepholeSubstituteAlternateSyntax(late));\n+          new PeepholeSubstituteAlternateSyntax(late))\n+      .setRetraverseOnChange(false);\n \n     return peepholePass;\n   }\n \n   @Override\n   protected int getNumRepetitions() {\n-    // Reduce this to 2 if we get better expression evaluators.\n-    return 2;\n+    return 1;\n   }\n \n   private void foldSame(String js) {\n   public void testNotCond() {\n     fold(\"function f(){if(!x)foo()}\", \"function f(){x||foo()}\");\n     fold(\"function f(){if(!x)b=1}\", \"function f(){x||(b=1)}\");\n-    fold(\"if(!x)z=1;else if(y)z=2\", \"x ? y&&(z=2) : z=1\");\n+    fold(\"if(!x)z=1;else if(y)z=2\", \"if(x){y&&(z=2);}else{z=1;}\");\n+    fold(\"if(x)y&&(z=2);else z=1;\", \"x ? y&&(z=2) : z=1\");\n     foldSame(\"function f(){if(!(x=1))a.b=1}\");\n   }\n \n     foldSame(\"for(;;) if (a) { f(); break }\");\n     fold(\"for(;;) if (a) break; else f()\", \"for(;!a;) { { f(); } }\");\n     fold(\"for(;a;) if (b) break\", \"for(;a && !b;);\");\n-    fold(\"for(;a;) { if (b) break; if (c) break; }\", \"for(;(a && !b) && !c;);\");\n+    fold(\"for(;a;) { if (b) break; if (c) break; }\",\n+         \"for(;(a && !b);) if (c) break;\");\n+    fold(\"for(;(a && !b);) if (c) break;\", \"for(;(a && !b) && !c;);\");\n \n     // 'while' is normalized to 'for'\n     enableNormalize(true);\n     fold(\"function f(){return false;}\", \"function f(){return !1}\");\n     foldSame(\"function f(){return null;}\");\n     fold(\"function f(){return void 0;}\",\n+         \"function f(){return}\");\n+    fold(\"function f(){return;}\",\n          \"function f(){}\");\n     foldSame(\"function f(){return void foo();}\");\n     fold(\"function f(){return undefined;}\",\n-         \"function f(){}\");\n+         \"function f(){return}\");\n     fold(\"function f(){if(a()){return undefined;}}\",\n-         \"function f(){if(a()){}}\");\n+         \"function f(){if(a()){return}}\");\n   }\n \n   public void testFoldStandardConstructors() {\n \n     fold(\"(x=2), foo()\", \"x=2; foo()\");\n     fold(\"foo(), boo();\", \"foo(); boo()\");\n-    fold(\"(a(), b()), (c(), d());\", \"a(); b(); c(); d();\");\n-    fold(\"foo(), true\", \"foo();1\");\n-    fold(\"function x(){foo(), !0}\", \"function x(){foo(); 1}\");\n+    fold(\"(a(), b()), (c(), d());\", \"a(); b(); (c(), d());\");\n+    fold(\"a(); b(); (c(), d());\", \"a(); b(); c(); d();\");\n+    fold(\"foo(), true\", \"foo();true\");\n+    fold(\"foo();true\", \"foo();1\");\n+    fold(\"function x(){foo(), !0}\", \"function x(){foo(); !0}\");\n+    fold(\"function x(){foo(); !0}\", \"function x(){foo(); 1}\");\n   }\n \n   public void testComma1() {\n     late = false;\n-    fold(\"1, 2\", \"1; 1\");\n+    fold(\"1, 2\", \"1; 2\");\n+    fold(\"1; 2\", \"1; 1\");\n     late = true;\n     foldSame(\"1, 2\");\n   }", "timestamp": 1355854355, "metainfo": ""}