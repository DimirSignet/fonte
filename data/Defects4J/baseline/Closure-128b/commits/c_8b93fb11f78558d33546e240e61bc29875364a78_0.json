{"sha": "8b93fb11f78558d33546e240e61bc29875364a78", "log": "remove more refs to JSSourceFile  R=johnlenz DELTA=455  (73 added, 36 deleted, 346 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=4323   ", "commit": "\n--- a/test/com/google/javascript/jscomp/AstParallelizerTest.java\n+++ b/test/com/google/javascript/jscomp/AstParallelizerTest.java\n \n package com.google.javascript.jscomp;\n \n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Lists;\n import com.google.javascript.rhino.Node;\n \n import junit.framework.TestCase;\n \n   private void splitFiles(String[] input) {\n     Compiler compiler = new Compiler();\n-    JSSourceFile[] files = new JSSourceFile[input.length];\n+    List<SourceFile> files = Lists.newArrayList();\n \n-    for (int i = 0; i < files.length; i ++) {\n-      files[i] = JSSourceFile.fromCode(\"file\" + i, input[i]);\n+    for (int i = 0; i < input.length; i ++) {\n+      files.add(SourceFile.fromCode(\"file\" + i, input[i]));\n     }\n \n     compiler.init(\n-        new JSSourceFile[0], files, new CompilerOptions());\n+        ImmutableList.<SourceFile>of(), files, new CompilerOptions());\n     compiler.parse();\n     Node orginal = compiler.getRoot();\n     Node root = orginal.cloneTree();\n--- a/test/com/google/javascript/jscomp/CheckRequiresForConstructorsTest.java\n+++ b/test/com/google/javascript/jscomp/CheckRequiresForConstructorsTest.java\n \n import static com.google.javascript.jscomp.CheckRequiresForConstructors.MISSING_REQUIRE_WARNING;\n \n+import com.google.common.collect.ImmutableList;\n import com.google.javascript.jscomp.CheckLevel;\n import com.google.javascript.jscomp.Result;\n \n \n   public void testRequiresAreCaughtBeforeProcessed() {\n     String js = \"var foo = {}; var bar = new foo.bar.goo();\";\n-    JSSourceFile input = JSSourceFile.fromCode(\"foo.js\", js);\n+    SourceFile input = SourceFile.fromCode(\"foo.js\", js);\n     Compiler compiler = new Compiler();\n     CompilerOptions opts = new CompilerOptions();\n     opts.checkRequires = CheckLevel.WARNING;\n     opts.closurePass = true;\n \n-    Result result = compiler.compile(new JSSourceFile[] {},\n-        new JSSourceFile[] {input}, opts);\n+    Result result = compiler.compile(ImmutableList.<SourceFile>of(),\n+        ImmutableList.of(input), opts);\n     JSError[] warnings = result.warnings;\n     assertNotNull(warnings);\n     assertTrue(warnings.length > 0);\n--- a/test/com/google/javascript/jscomp/CommandLineRunnerTest.java\n+++ b/test/com/google/javascript/jscomp/CommandLineRunnerTest.java\n     if (useModules == ModulePattern.NONE) {\n       List<SourceFile> inputs = Lists.newArrayList();\n       for (int i = 0; i < original.length; i++) {\n-        inputs.add(JSSourceFile.fromCode(getFilename(i), original[i]));\n+        inputs.add(SourceFile.fromCode(getFilename(i), original[i]));\n       }\n       inputsSupplier = Suppliers.ofInstance(inputs);\n     } else if (useModules == ModulePattern.STAR) {\n     String[] argStrings = args.toArray(new String[] {});\n     CommandLineRunner runner = new CommandLineRunner(argStrings);\n     Compiler compiler = runner.createCompiler();\n-    List<JSSourceFile> inputs = Lists.newArrayList();\n+    List<SourceFile> inputs = Lists.newArrayList();\n     for (int i = 0; i < original.length; i++) {\n-      inputs.add(JSSourceFile.fromCode(getFilename(i), original[i]));\n+      inputs.add(SourceFile.fromCode(getFilename(i), original[i]));\n     }\n     CompilerOptions options = new CompilerOptions();\n     // ECMASCRIPT5 is the most forgiving.\n--- a/test/com/google/javascript/jscomp/CompilerTest.java\n+++ b/test/com/google/javascript/jscomp/CompilerTest.java\n \n package com.google.javascript.jscomp;\n \n-import java.util.List;\n-\n+import com.google.common.collect.ImmutableList;\n import com.google.common.collect.Lists;\n import com.google.javascript.jscomp.deps.SortedDependencies.CircularDependencyException;\n import com.google.javascript.jscomp.deps.SortedDependencies.MissingProvideException;\n import com.google.javascript.rhino.Node;\n \n import junit.framework.TestCase;\n+\n+import java.util.List;\n \n /**\n  * @author johnlenz@google.com (John Lenz)\n   }\n \n   public void testCyclicalDependencyInInputs() {\n-    JSSourceFile[] inputs = {\n-        JSSourceFile.fromCode(\n+    List<SourceFile> inputs = Lists.newArrayList(\n+        SourceFile.fromCode(\n             \"gin\", \"goog.provide('gin'); goog.require('tonic'); var gin = {};\"),\n-        JSSourceFile.fromCode(\"tonic\",\n+        SourceFile.fromCode(\"tonic\",\n             \"goog.provide('tonic'); goog.require('gin'); var tonic = {};\"),\n-        JSSourceFile.fromCode(\n-            \"mix\", \"goog.require('gin'); goog.require('tonic');\")};\n+        SourceFile.fromCode(\n+            \"mix\", \"goog.require('gin'); goog.require('tonic');\"));\n     CompilerOptions options = new CompilerOptions();\n     options.ideMode = true;\n     options.setManageClosureDependencies(true);\n     Compiler compiler = new Compiler();\n-    compiler.init(new JSSourceFile[0], inputs, options);\n+    compiler.init(ImmutableList.<SourceFile>of(), inputs, options);\n     compiler.parseInputs();\n     assertEquals(compiler.externAndJsRoot, compiler.jsRoot.getParent());\n     assertEquals(compiler.externAndJsRoot, compiler.externsRoot.getParent());\n     CompilationLevel.SIMPLE_OPTIMIZATIONS.setOptionsForCompilationLevel(\n         options);\n     Compiler compiler = new Compiler();\n-    JSSourceFile externs = JSSourceFile.fromCode(\"externs.js\", \"\");\n-    JSSourceFile input = JSSourceFile.fromCode(\"input.js\",\n+    SourceFile externs = SourceFile.fromCode(\"externs.js\", \"\");\n+    SourceFile input = SourceFile.fromCode(\"input.js\",\n         \"(function (undefined) { alert(undefined); })();\");\n     compiler.compile(externs, input, options);\n   }\n \n   public void testCommonJSProvidesAndRequire() throws\n       CircularDependencyException, MissingProvideException {\n-    JSSourceFile[] inputs = {\n-        JSSourceFile.fromCode(\"gin.js\", \"require('tonic')\"),\n-        JSSourceFile.fromCode(\"tonic.js\", \"\"),\n-        JSSourceFile.fromCode(\"mix.js\", \"require('gin'); require('tonic');\")};\n+    List<SourceFile> inputs = Lists.newArrayList(\n+        SourceFile.fromCode(\"gin.js\", \"require('tonic')\"),\n+        SourceFile.fromCode(\"tonic.js\", \"\"),\n+        SourceFile.fromCode(\"mix.js\", \"require('gin'); require('tonic');\"));\n     CompilerOptions options = new CompilerOptions();\n     options.ideMode = true;\n     List<String> entryPoints = Lists.newArrayList(\"module$mix\");\n     options.closurePass = true;\n     options.processCommonJSModules = true;\n     Compiler compiler = new Compiler();\n-    compiler.init(new JSSourceFile[0], inputs, options);\n+    compiler.init(Lists.<SourceFile>newArrayList(), inputs, options);\n     compiler.parseInputs();\n     JSModuleGraph graph = compiler.getModuleGraph();\n     assertEquals(graph.getModuleCount(), 3);\n--- a/test/com/google/javascript/jscomp/CompilerTestCase.java\n+++ b/test/com/google/javascript/jscomp/CompilerTestCase.java\n import com.google.common.base.Joiner;\n import com.google.common.base.Preconditions;\n import com.google.common.base.Predicates;\n+import com.google.common.collect.ImmutableList;\n import com.google.common.collect.Lists;\n import com.google.javascript.jscomp.CodeChangeHandler.RecentChange;\n import com.google.javascript.jscomp.CompilerOptions.LanguageMode;\n public abstract class CompilerTestCase extends TestCase  {\n \n   /** Externs for the test */\n-  private final JSSourceFile[] externsInputs;\n+  private final List<SourceFile> externsInputs;\n \n   /** Whether to compare input and output as trees instead of strings */\n   private final boolean compareAsTree;\n    * </pre>\n    */\n   protected CompilerTestCase(String externs, boolean compareAsTree) {\n-    this.externsInputs = new JSSourceFile[] {\n-        JSSourceFile.fromCode(\"externs\", externs)\n-    };\n+    this.externsInputs = ImmutableList.of(\n+        SourceFile.fromCode(\"externs\", externs));\n     this.compareAsTree = compareAsTree;\n     this.parseTypeInfo = false;\n   }\n   public void test(String externs, String js, String expected,\n                    DiagnosticType error, DiagnosticType warning,\n                    String description) {\n-    JSSourceFile[] externsInputs = new JSSourceFile[]{\n-        JSSourceFile.fromCode(\"externs\", externs)\n-    };\n+    List<SourceFile> externsInputs = ImmutableList.of(\n+        SourceFile.fromCode(\"externs\", externs));\n     test(externsInputs, js, expected, error, warning, description);\n   }\n \n    *      or null if no warning is expected or if the warning's description\n    *      should not be examined\n    */\n-  public void test(JSSourceFile[] externs, String js, String expected,\n+  public void test(List<SourceFile> externs, String js, String expected,\n                    DiagnosticType error,\n                    DiagnosticType warning, String description) {\n     Compiler compiler = createCompiler();\n     // Note that in this context, turning on the checkTypes option won't\n     // actually cause the type check to run.\n     options.checkTypes = parseTypeInfo;\n-    compiler.init(externs, new JSSourceFile[] {\n-        JSSourceFile.fromCode(filename, js) }, options);\n+    compiler.init(externs, ImmutableList.of(\n+        SourceFile.fromCode(filename, js)), options);\n \n     BaseJSTypeTestCase.addNativeProperties(compiler.getTypeRegistry());\n \n     Compiler compiler = createCompiler();\n     lastCompiler = compiler;\n \n-    JSSourceFile[] inputs = new JSSourceFile[js.length];\n+    List<SourceFile> inputs = Lists.newArrayList();\n     for (int i = 0; i < js.length; i++) {\n-      inputs[i] = JSSourceFile.fromCode(\"input\" + i, js[i]);\n+      inputs.add(SourceFile.fromCode(\"input\" + i, js[i]));\n     }\n     compiler.init(externsInputs, inputs, getOptions());\n     test(compiler, expected, error, warning, description);\n     Compiler compiler = createCompiler();\n     lastCompiler = compiler;\n \n-    compiler.init(externsInputs, modules, getOptions());\n+    compiler.initModules(\n+        externsInputs, Lists.newArrayList(modules), getOptions());\n     test(compiler, expected, error, warning);\n   }\n \n    */\n   public void testSame(String externs, String js, DiagnosticType warning,\n                        String description) {\n-    JSSourceFile[] externsInputs = new JSSourceFile[]{\n-        JSSourceFile.fromCode(\"externs\", externs)\n-    };\n+    List<SourceFile> externsInputs = ImmutableList.of(\n+        SourceFile.fromCode(\"externs\", externs));\n     test(externsInputs, js, js, null, warning, description);\n   }\n \n    */\n   protected Node parseExpectedJs(String[] expected) {\n     Compiler compiler = createCompiler();\n-    JSSourceFile[] inputs = new JSSourceFile[expected.length];\n+    List<SourceFile> inputs = Lists.newArrayList();\n     for (int i = 0; i < expected.length; i++) {\n-      inputs[i] = JSSourceFile.fromCode(\"expected\" + i, expected[i]);\n+      inputs.add(SourceFile.fromCode(\"expected\" + i, expected[i]));\n     }\n     compiler.init(externsInputs, inputs, getOptions());\n     Node root = compiler.parseInputs();\n     JSModule[] modules = new JSModule[inputs.length];\n     for (int i = 0; i < inputs.length; i++) {\n       JSModule module = modules[i] = new JSModule(\"m\" + i);\n-      module.add(JSSourceFile.fromCode(\"i\" + i, inputs[i]));\n+      module.add(SourceFile.fromCode(\"i\" + i, inputs[i]));\n     }\n     return modules;\n   }\n--- a/test/com/google/javascript/jscomp/CrossModuleCodeMotionTest.java\n+++ b/test/com/google/javascript/jscomp/CrossModuleCodeMotionTest.java\n     // while nothing is moved. This should not be a problem if we know all\n     // modules are non-empty.\n     JSModule m1 = new JSModule(\"m1\");\n-    m1.add(JSSourceFile.fromCode(\"m1\", \"function x() {}\"));\n+    m1.add(SourceFile.fromCode(\"m1\", \"function x() {}\"));\n \n     JSModule empty = new JSModule(\"empty\");\n     empty.addDependency(m1);\n \n     JSModule m2 = new JSModule(\"m2\");\n-    m2.add(JSSourceFile.fromCode(\"m2\", \"x()\"));\n+    m2.add(SourceFile.fromCode(\"m2\", \"x()\"));\n     m2.addDependency(empty);\n \n     JSModule m3 = new JSModule(\"m3\");\n-    m3.add(JSSourceFile.fromCode(\"m3\", \"x()\"));\n+    m3.add(SourceFile.fromCode(\"m3\", \"x()\"));\n     m3.addDependency(empty);\n \n     test(new JSModule[] {m1,empty,m2,m3},\n--- a/test/com/google/javascript/jscomp/DisambiguatePropertiesTest.java\n+++ b/test/com/google/javascript/jscomp/DisambiguatePropertiesTest.java\n package com.google.javascript.jscomp;\n \n import com.google.common.base.Joiner;\n+import com.google.common.collect.ImmutableList;\n import com.google.common.collect.Maps;\n import com.google.common.collect.Multimap;\n import com.google.common.collect.Sets;\n \n     Compiler compiler = new Compiler();\n     CompilerOptions options = new CompilerOptions();\n-    compiler.init(new JSSourceFile[]{JSSourceFile.fromCode(\"externs\", \"\")},\n-                  new JSSourceFile[]{\n-                      JSSourceFile.fromCode(\"testcode\", js)}, options);\n+    compiler.init(ImmutableList.of(SourceFile.fromCode(\"externs\", \"\")),\n+        ImmutableList.of(SourceFile.fromCode(\"testcode\", js)),\n+        options);\n \n     Node root = compiler.parseInputs();\n     Node externsRoot = root.getFirstChild();\n     this.runTightenTypes = runTightenTypes;\n     Compiler compiler = new Compiler();\n     CompilerOptions options = new CompilerOptions();\n-    compiler.init(new JSSourceFile[]{JSSourceFile.fromCode(\"externs\", \"\")},\n-                  new JSSourceFile[]{\n-                      JSSourceFile.fromCode(\"testcode\", js)}, options);\n+    compiler.init(\n+        ImmutableList.of(SourceFile.fromCode(\"externs\", \"\")),\n+        ImmutableList.of(SourceFile.fromCode(\"testcode\", js)),\n+        options);\n \n     Node root = compiler.parseInputs();\n     assertTrue(\"Unexpected parse error(s): \" +\n--- a/test/com/google/javascript/jscomp/ExternExportsPassTest.java\n+++ b/test/com/google/javascript/jscomp/ExternExportsPassTest.java\n \n \n import com.google.common.base.Joiner;\n+import com.google.common.collect.Lists;\n \n import junit.framework.TestCase;\n \n+import java.util.List;\n \n /**\n  * Tests for {@link ExternExportsPass}.\n     options.checkSymbols = true;\n     options.checkTypes = runCheckTypes;\n \n-    JSSourceFile[] inputs = {\n-      JSSourceFile.fromCode(\"testcode\",\n+    List<SourceFile> inputs = Lists.newArrayList(\n+      SourceFile.fromCode(\"testcode\",\n                             \"var goog = {};\" +\n                             \"goog.exportSymbol = function(a, b) {}; \" +\n                             \"goog.exportProperty = function(a, b, c) {}; \" +\n-                            js)\n-    };\n-\n-    JSSourceFile[] externFiles = {\n-        JSSourceFile.fromCode(\"externs\", externs)\n-    };\n+                            js));\n+\n+    List<SourceFile> externFiles = Lists.newArrayList(\n+        SourceFile.fromCode(\"externs\", externs));\n \n     Result result = compiler.compile(externFiles, inputs, options);\n \n--- a/test/com/google/javascript/jscomp/FunctionInjectorTest.java\n+++ b/test/com/google/javascript/jscomp/FunctionInjectorTest.java\n \n package com.google.javascript.jscomp;\n \n+import com.google.common.collect.Lists;\n import com.google.common.collect.Sets;\n import com.google.javascript.jscomp.AbstractCompiler.LifeCycleStage;\n import com.google.javascript.jscomp.FunctionInjector.CanInlineResult;\n \n import junit.framework.TestCase;\n \n+import java.util.List;\n import java.util.Set;\n \n /**\n         assumeStrictThis,\n         assumeMinimumCapture);\n \n-    JSSourceFile[] externsInputs = new JSSourceFile[] {\n-        JSSourceFile.fromCode(\"externs\", \"\")\n-    };\n+    List<SourceFile> externsInputs = Lists.newArrayList(\n+        SourceFile.fromCode(\"externs\", \"\"));\n \n     CompilerOptions options = new CompilerOptions();\n     options.setCodingConvention(new GoogleCodingConvention());\n-    compiler.init(externsInputs, new JSSourceFile[] {\n-        JSSourceFile.fromCode(\"code\", code) }, options);\n+    compiler.init(externsInputs, Lists.newArrayList(\n+        SourceFile.fromCode(\"code\", code)), options);\n     Node parseRoot = compiler.parseInputs();\n     Node externsRoot = parseRoot.getFirstChild();\n     final Node tree = parseRoot.getLastChild();\n--- a/test/com/google/javascript/jscomp/GlobalVarReferenceMapTest.java\n+++ b/test/com/google/javascript/jscomp/GlobalVarReferenceMapTest.java\n public class GlobalVarReferenceMapTest extends TestCase {\n \n   private final CompilerInput INPUT1 =\n-      new CompilerInput(JSSourceFile.fromCode(\"input1\", \"\"), false);\n+      new CompilerInput(SourceFile.fromCode(\"input1\", \"\"), false);\n   private final CompilerInput INPUT2 =\n-      new CompilerInput(JSSourceFile.fromCode(\"input2\", \"\"), false);\n+      new CompilerInput(SourceFile.fromCode(\"input2\", \"\"), false);\n   private final CompilerInput INPUT3 =\n-      new CompilerInput(JSSourceFile.fromCode(\"input3\", \"\"), false);\n+      new CompilerInput(SourceFile.fromCode(\"input3\", \"\"), false);\n   private final CompilerInput EXTERN1 =\n-      new CompilerInput(JSSourceFile.fromCode(\"extern1\", \"\"), true);\n+      new CompilerInput(SourceFile.fromCode(\"extern1\", \"\"), true);\n \n   private final GlobalVarReferenceMap map = new GlobalVarReferenceMap(\n       Lists.newArrayList(INPUT1, INPUT2, INPUT3), Lists.newArrayList(EXTERN1));\n--- a/test/com/google/javascript/jscomp/IntegrationTest.java\n+++ b/test/com/google/javascript/jscomp/IntegrationTest.java\n \n import com.google.common.base.Joiner;\n import com.google.common.collect.ArrayListMultimap;\n+import com.google.common.collect.ImmutableList;\n import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Lists;\n import com.google.common.collect.Sets;\n import com.google.javascript.jscomp.CompilerOptions.LanguageMode;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n \n import junit.framework.TestCase;\n+\n+import java.util.List;\n \n /**\n  * Tests for {@link PassFactory}.\n public class IntegrationTest extends TestCase {\n \n   /** Externs for the test */\n-  private final JSSourceFile[] DEFAULT_EXTERNS = new JSSourceFile[] {\n-    JSSourceFile.fromCode(\"externs\",\n+  private final List<SourceFile> DEFAULT_EXTERNS = ImmutableList.of(\n+    SourceFile.fromCode(\"externs\",\n         \"var arguments;\\n\"\n         + \"/** @constructor */ function Window() {}\\n\"\n         + \"/** @type {string} */ Window.prototype.name;\\n\"\n         + \"/** @nosideeffects */ function noSideEffects() {}\\n\"\n         + \"/** @constructor\\n * @nosideeffects */ function Widget() {}\\n\"\n         + \"/** @modifies {this} */ Widget.prototype.go = function() {};\\n\"\n-        + \"/** @return {string} */ var widgetToken = function() {};\\n\")\n-  };\n-\n-  private JSSourceFile[] externs = DEFAULT_EXTERNS;\n+        + \"/** @return {string} */ var widgetToken = function() {};\\n\"));\n+\n+  private List<SourceFile> externs = DEFAULT_EXTERNS;\n \n   private static final String CLOSURE_BOILERPLATE =\n       \"/** @define {boolean} */ var COMPILED = false; var goog = {};\" +\n     CompilerOptions options = createCompilerOptions();\n \n     options.aliasExternals = true;\n-    externs = new JSSourceFile[] {\n-      JSSourceFile.fromCode(\"externs\", \"extern.foo\")\n-    };\n+    externs = ImmutableList.of(\n+        SourceFile.fromCode(\"externs\", \"extern.foo\"));\n \n     test(options,\n          \"var extern; \" +\n   public void testDuplicateVariablesInExterns() {\n     CompilerOptions options = createCompilerOptions();\n     options.checkSymbols = true;\n-    externs = new JSSourceFile[] {\n-      JSSourceFile.fromCode(\"externs\",\n-          \"var externs = {}; /** @suppress {duplicate} */ var externs = {};\")\n-    };\n+    externs = ImmutableList.of(\n+        SourceFile.fromCode(\"externs\",\n+            \"var externs = {}; /** @suppress {duplicate} */ var externs = {};\"));\n     testSame(options, \"\");\n   }\n \n \n   private Compiler compile(CompilerOptions options, String[] original) {\n     Compiler compiler = lastCompiler = new Compiler();\n-    JSSourceFile[] inputs = new JSSourceFile[original.length];\n+    List<SourceFile> inputs = Lists.newArrayList();\n     for (int i = 0; i < original.length; i++) {\n-      inputs[i] = JSSourceFile.fromCode(\"input\" + i, original[i]);\n+      inputs.add(SourceFile.fromCode(\"input\" + i, original[i]));\n     }\n-    compiler.compile(\n-        externs, CompilerTestCase.createModuleChain(original), options);\n+    compiler.compileModules(\n+        externs, Lists.newArrayList(CompilerTestCase.createModuleChain(original)),\n+        options);\n     return compiler;\n   }\n \n   private Node parse(String[] original, CompilerOptions options) {\n     Compiler compiler = new Compiler();\n-    JSSourceFile[] inputs = new JSSourceFile[original.length];\n-    for (int i = 0; i < inputs.length; i++) {\n-      inputs[i] = JSSourceFile.fromCode(\"input\" + i, original[i]);\n+    List<SourceFile> inputs = Lists.newArrayList();\n+    for (int i = 0; i < original.length; i++) {\n+      inputs.add(SourceFile.fromCode(\"input\" + i, original[i]));\n     }\n     compiler.init(externs, inputs, options);\n     checkUnexpectedErrorsOrWarnings(compiler, 0);\n--- a/test/com/google/javascript/jscomp/JSCompilerSourceExcerptProviderTest.java\n+++ b/test/com/google/javascript/jscomp/JSCompilerSourceExcerptProviderTest.java\n package com.google.javascript.jscomp;\n \n \n+import com.google.common.collect.ImmutableList;\n+\n import junit.framework.TestCase;\n \n /**\n \n   @Override\n   protected void setUp() throws Exception {\n-    JSSourceFile foo = JSSourceFile.fromCode(\"foo\",\n+    SourceFile foo = SourceFile.fromCode(\"foo\",\n         \"foo:first line\\nfoo:second line\\nfoo:third line\\n\");\n-    JSSourceFile bar = JSSourceFile.fromCode(\"bar\",\n+    SourceFile bar = SourceFile.fromCode(\"bar\",\n         \"bar:first line\\nbar:second line\\nbar:third line\\nbar:fourth line\\n\");\n-    JSSourceFile foo2 = JSSourceFile.fromCode(\"foo2\",\n+    SourceFile foo2 = SourceFile.fromCode(\"foo2\",\n         \"foo2:first line\\nfoo2:second line\\nfoo2:third line\");\n     Compiler compiler = new Compiler();\n     CompilerOptions options = new CompilerOptions();\n     compiler.init(\n-        new JSSourceFile[] {}, new JSSourceFile[] {foo, bar, foo2}, options);\n+        ImmutableList.<SourceFile>of(),\n+        ImmutableList.of(foo, bar, foo2),\n+        options);\n     this.provider = compiler;\n   }\n \n--- a/test/com/google/javascript/jscomp/JSModuleGraphTest.java\n+++ b/test/com/google/javascript/jscomp/JSModuleGraphTest.java\n   }\n \n   public void testCoalesceDuplicateFiles() {\n-    A.add(JSSourceFile.fromCode(\"a.js\", \"\"));\n-\n-    B.add(JSSourceFile.fromCode(\"a.js\", \"\"));\n-    B.add(JSSourceFile.fromCode(\"b.js\", \"\"));\n-\n-    C.add(JSSourceFile.fromCode(\"b.js\", \"\"));\n-    C.add(JSSourceFile.fromCode(\"c.js\", \"\"));\n-\n-    E.add(JSSourceFile.fromCode(\"c.js\", \"\"));\n-    E.add(JSSourceFile.fromCode(\"d.js\", \"\"));\n+    A.add(SourceFile.fromCode(\"a.js\", \"\"));\n+\n+    B.add(SourceFile.fromCode(\"a.js\", \"\"));\n+    B.add(SourceFile.fromCode(\"b.js\", \"\"));\n+\n+    C.add(SourceFile.fromCode(\"b.js\", \"\"));\n+    C.add(SourceFile.fromCode(\"c.js\", \"\"));\n+\n+    E.add(SourceFile.fromCode(\"c.js\", \"\"));\n+    E.add(SourceFile.fromCode(\"d.js\", \"\"));\n \n     graph.coalesceDuplicateFiles();\n \n     return inputNames;\n   }\n \n-  private JSSourceFile code(\n+  private SourceFile code(\n       String sourceName, List<String> provides, List<String> requires) {\n     String text = \"\";\n     for (String p : provides) {\n     for (String r : requires) {\n       text += \"goog.require('\" + r + \"');\\n\";\n     }\n-    return JSSourceFile.fromCode(sourceName, text);\n+    return SourceFile.fromCode(sourceName, text);\n   }\n \n   private List<String> provides(String ... strings) {\n--- a/test/com/google/javascript/jscomp/JSModuleTest.java\n+++ b/test/com/google/javascript/jscomp/JSModuleTest.java\n \n   public void testSortInputs() throws Exception {\n     CompilerInput a = new CompilerInput(\n-        JSSourceFile.fromCode(\"a.js\",\n+        SourceFile.fromCode(\"a.js\",\n             \"goog.require('b');goog.require('c')\"));\n     CompilerInput b = new CompilerInput(\n-        JSSourceFile.fromCode(\"b.js\",\n+        SourceFile.fromCode(\"b.js\",\n             \"goog.provide('b');goog.require('d')\"));\n     CompilerInput c = new CompilerInput(\n-        JSSourceFile.fromCode(\"c.js\",\n+        SourceFile.fromCode(\"c.js\",\n             \"goog.provide('c');goog.require('d')\"));\n     CompilerInput d = new CompilerInput(\n-        JSSourceFile.fromCode(\"d.js\",\n+        SourceFile.fromCode(\"d.js\",\n             \"goog.provide('d')\"));\n \n     // Independent modules.\n     CompilerInput e = new CompilerInput(\n-        JSSourceFile.fromCode(\"e.js\",\n+        SourceFile.fromCode(\"e.js\",\n             \"goog.provide('e')\"));\n     CompilerInput f = new CompilerInput(\n-        JSSourceFile.fromCode(\"f.js\",\n+        SourceFile.fromCode(\"f.js\",\n             \"goog.provide('f')\"));\n \n     assertSortedInputs(\n--- a/test/com/google/javascript/jscomp/JsMessageExtractorTest.java\n+++ b/test/com/google/javascript/jscomp/JsMessageExtractorTest.java\n     try {\n       String sourceCode = Joiner.on(\"\\n\").join(js);\n       return new JsMessageExtractor(null, RELAX)\n-          .extractMessages(JSSourceFile.fromCode(\"testcode\", sourceCode));\n+          .extractMessages(SourceFile.fromCode(\"testcode\", sourceCode));\n     } catch (IOException e) {\n       fail(e.getMessage());\n       return null;\n--- a/test/com/google/javascript/jscomp/LooseTypeCheckTest.java\n+++ b/test/com/google/javascript/jscomp/LooseTypeCheckTest.java\n   private TypeCheckResult parseAndTypeCheckWithScope(\n       String externs, String js) {\n     compiler.init(\n-        Lists.newArrayList(JSSourceFile.fromCode(\"[externs]\", externs)),\n-        Lists.newArrayList(JSSourceFile.fromCode(\"[testcode]\", js)),\n+        Lists.newArrayList(SourceFile.fromCode(\"[externs]\", externs)),\n+        Lists.newArrayList(SourceFile.fromCode(\"[testcode]\", js)),\n         compiler.getOptions());\n \n     Node n = compiler.getInput(new InputId(\"[testcode]\")).getAstRoot(compiler);\n--- a/test/com/google/javascript/jscomp/NormalizeTest.java\n+++ b/test/com/google/javascript/jscomp/NormalizeTest.java\n   public void testNormalizeSyntheticCode() {\n     Compiler compiler = new Compiler();\n     compiler.init(\n-        Lists.<JSSourceFile>newArrayList(),\n-        Lists.<JSSourceFile>newArrayList(), new CompilerOptions());\n+        Lists.<SourceFile>newArrayList(),\n+        Lists.<SourceFile>newArrayList(), new CompilerOptions());\n     Node code = Normalize.parseAndNormalizeSyntheticCode(\n         compiler, \"function f(x) {} function g(x) {}\", \"prefix_\");\n     assertEquals(\n--- a/test/com/google/javascript/jscomp/PeepholeFoldConstantsTest.java\n+++ b/test/com/google/javascript/jscomp/PeepholeFoldConstantsTest.java\n     Compiler compiler = createCompiler();\n     CompilerOptions options = getOptions();\n     compiler.init(\n-        new JSSourceFile[] {},\n-        new JSSourceFile[] { JSSourceFile.fromCode(\"testcode\", js) },\n+        ImmutableList.<SourceFile>of(),\n+        ImmutableList.of(SourceFile.fromCode(\"testcode\", js)),\n         options);\n     Node root = compiler.parseInputs();\n     assertTrue(\"Unexpected parse error(s): \" +\n--- a/test/com/google/javascript/jscomp/ProcessClosurePrimitivesTest.java\n+++ b/test/com/google/javascript/jscomp/ProcessClosurePrimitivesTest.java\n \n           // Inject additional code at the beginning.\n           if (additionalCode != null) {\n-            JSSourceFile file =\n-                JSSourceFile.fromCode(\"additionalcode\", additionalCode);\n+            SourceFile file =\n+                SourceFile.fromCode(\"additionalcode\", additionalCode);\n             Node scriptNode = root.getFirstChild();\n             Node newScriptNode = new CompilerInput(file).getAstRoot(compiler);\n             if (addAdditionalNamespace) {\n \n           // Inject additional code at the end.\n           if (additionalEndCode != null) {\n-            JSSourceFile file =\n-                JSSourceFile.fromCode(\"additionalendcode\", additionalEndCode);\n+            SourceFile file =\n+                SourceFile.fromCode(\"additionalendcode\", additionalEndCode);\n             Node scriptNode = root.getFirstChild();\n             Node newScriptNode = new CompilerInput(file).getAstRoot(compiler);\n             if (addAdditionalNamespace) {\n--- a/test/com/google/javascript/jscomp/RecordFunctionInformationTest.java\n+++ b/test/com/google/javascript/jscomp/RecordFunctionInformationTest.java\n \n package com.google.javascript.jscomp;\n \n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Lists;\n import com.google.javascript.rhino.Node;\n \n import junit.framework.TestCase;\n-\n \n /**\n  * Tests for {@link RecordFunctionInformation}\n \n   private void test(String js, FunctionInformationMap expected) {\n     Compiler compiler = new Compiler();\n-    compiler.init(new JSSourceFile[] { JSSourceFile.fromCode(\"externs\", \"\") },\n-                  new JSSourceFile[] { JSSourceFile.fromCode(\"testcode\", js) },\n+    compiler.init(ImmutableList.of(SourceFile.fromCode(\"externs\", \"\")),\n+                  ImmutableList.of(SourceFile.fromCode(\"testcode\", js)),\n                   new CompilerOptions());\n     test(compiler, expected);\n   }\n \n   private Compiler compilerFor(JSModule[] modules) {\n       Compiler compiler = new Compiler();\n-      compiler.init(new JSSourceFile[] { JSSourceFile.fromCode(\"externs\", \"\") },\n-                    modules,\n-                    new CompilerOptions());\n+      compiler.initModules(\n+          ImmutableList.of(SourceFile.fromCode(\"externs\", \"\")),\n+          Lists.newArrayList(modules),\n+          new CompilerOptions());\n       return compiler;\n   }\n \n--- a/test/com/google/javascript/jscomp/RenamePropertiesTest.java\n+++ b/test/com/google/javascript/jscomp/RenamePropertiesTest.java\n \n package com.google.javascript.jscomp;\n \n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Lists;\n \n /**\n  * {@link RenameProperties} tests.\n                        \"var noo;noo.getC(noo);noo.zoo=noo;noo.cloo=noo;\";\n \n     JSModule module1 = new JSModule(\"m1\");\n-    module1.add(JSSourceFile.fromCode(\"input1\", module1Js));\n+    module1.add(SourceFile.fromCode(\"input1\", module1Js));\n \n     JSModule module2 = new JSModule(\"m2\");\n-    module2.add(JSSourceFile.fromCode(\"input2\", module2Js));\n+    module2.add(SourceFile.fromCode(\"input2\", module2Js));\n \n     JSModule module3 = new JSModule(\"m3\");\n-    module3.add(JSSourceFile.fromCode(\"input3\", module3Js));\n+    module3.add(SourceFile.fromCode(\"input3\", module3Js));\n \n     JSModule[] modules = new JSModule[] { module1, module2, module3 };\n     Compiler compiler = compileModules(\"\", modules);\n   }\n \n   private Compiler compileModules(String externs, JSModule[] modules) {\n-    JSSourceFile externsInput = JSSourceFile.fromCode(\"externs\", externs);\n+    SourceFile externsInput = SourceFile.fromCode(\"externs\", externs);\n \n     CompilerOptions options = new CompilerOptions();\n     options.propertyRenaming = PropertyRenamingPolicy.ALL_UNQUOTED;\n \n     Compiler compiler = new Compiler();\n-    compiler.compile(externsInput, modules, options);\n+    compiler.compileModules(\n+        ImmutableList.of(externsInput), Lists.newArrayList(modules), options);\n     return compiler;\n   }\n \n--- a/test/com/google/javascript/jscomp/RhinoErrorReporterTest.java\n+++ b/test/com/google/javascript/jscomp/RhinoErrorReporterTest.java\n \n package com.google.javascript.jscomp;\n \n+import com.google.common.collect.ImmutableList;\n import com.google.common.collect.Iterables;\n import com.google.common.collect.Lists;\n import com.google.javascript.rhino.Node;\n \n import junit.framework.TestCase;\n+\n+import java.util.List;\n \n /**\n  * Tests for error message filtering.\n   private void assertError(\n       String code, DiagnosticType type, String description) {\n     Compiler compiler = new Compiler();\n-    JSSourceFile[] externs = new JSSourceFile[] {};\n-    JSSourceFile[] inputs =  new JSSourceFile[] {\n-      JSSourceFile.fromCode(\"input\", code)\n-    };\n+    List<SourceFile> externs = ImmutableList.of();\n+    List<SourceFile> inputs = ImmutableList.of(\n+        SourceFile.fromCode(\"input\", code));\n     compiler.init(externs, inputs, new CompilerOptions());\n     compiler.parseInputs();\n     assertEquals(\"Expected error\", 1, compiler.getErrorCount());\n--- a/test/com/google/javascript/jscomp/RuntimeTypeCheckTest.java\n+++ b/test/com/google/javascript/jscomp/RuntimeTypeCheckTest.java\n \n   private void testChecks(String js, String expected) {\n     Compiler compiler = new Compiler();\n-    compiler.init(Lists.<JSSourceFile>newArrayList(),\n-                  Lists.<JSSourceFile>newArrayList(),\n+    compiler.init(Lists.<SourceFile>newArrayList(),\n+                  Lists.<SourceFile>newArrayList(),\n                   new CompilerOptions());\n     Node boilerplateCode =\n         RuntimeTypeCheck.getBoilerplateCode(compiler, null);\n--- a/test/com/google/javascript/jscomp/SymbolTableTest.java\n+++ b/test/com/google/javascript/jscomp/SymbolTableTest.java\n   }\n \n   private SymbolTable createSymbolTable(String input) {\n-    List<JSSourceFile> inputs = Lists.newArrayList(\n-        JSSourceFile.fromCode(\"in1\", input));\n-    List<JSSourceFile> externs = Lists.newArrayList(\n-        JSSourceFile.fromCode(\"externs1\", EXTERNS));\n+    List<SourceFile> inputs = Lists.newArrayList(\n+        SourceFile.fromCode(\"in1\", input));\n+    List<SourceFile> externs = Lists.newArrayList(\n+        SourceFile.fromCode(\"externs1\", EXTERNS));\n \n     Compiler compiler = new Compiler();\n     compiler.compile(externs, inputs, options);\n--- a/test/com/google/javascript/jscomp/TypeCheckTest.java\n+++ b/test/com/google/javascript/jscomp/TypeCheckTest.java\n   private TypeCheckResult parseAndTypeCheckWithScope(\n       String externs, String js) {\n     compiler.init(\n-        Lists.newArrayList(JSSourceFile.fromCode(\"[externs]\", externs)),\n-        Lists.newArrayList(JSSourceFile.fromCode(\"[testcode]\", js)),\n+        Lists.newArrayList(SourceFile.fromCode(\"[externs]\", externs)),\n+        Lists.newArrayList(SourceFile.fromCode(\"[testcode]\", js)),\n         compiler.getOptions());\n \n     Node n = compiler.getInput(new InputId(\"[testcode]\")).getAstRoot(compiler);\n--- a/test/com/google/javascript/jscomp/VarCheckTest.java\n+++ b/test/com/google/javascript/jscomp/VarCheckTest.java\n \n package com.google.javascript.jscomp;\n \n+import com.google.common.collect.ImmutableList;\n import com.google.common.collect.Lists;\n import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n import com.google.javascript.rhino.Node;\n-\n \n public class VarCheckTest extends CompilerTestCase {\n   private static final String EXTERNS = \"var window; function alert() {}\";\n   private void testTwoModules(String code1, String code2, boolean m2DependsOnm1,\n                               DiagnosticType error, DiagnosticType warning) {\n     JSModule m1 = new JSModule(\"m1\");\n-    m1.add(JSSourceFile.fromCode(\"input1\", code1));\n+    m1.add(SourceFile.fromCode(\"input1\", code1));\n     JSModule m2 = new JSModule(\"m2\");\n-    m2.add(JSSourceFile.fromCode(\"input2\", code2));\n+    m2.add(SourceFile.fromCode(\"input2\", code2));\n     if (m2DependsOnm1) {\n       m2.addDependency(m1);\n     }\n         DiagnosticGroup.forType(VarCheck.UNDEFINED_VAR_ERROR),\n         CheckLevel.OFF);\n     compiler.init(\n-        new JSSourceFile[] { JSSourceFile.fromCode(\"extern\", extern) },\n-        new JSSourceFile[] { JSSourceFile.fromCode(\"input\", input) },\n+        ImmutableList.of(SourceFile.fromCode(\"extern\", extern)),\n+        ImmutableList.of(SourceFile.fromCode(\"input\", input)),\n         options);\n     compiler.parseInputs();\n     assertFalse(compiler.hasErrors());\n--- a/test/com/google/javascript/jscomp/regtests/CompileEachLineOfProgramOutput.java\n+++ b/test/com/google/javascript/jscomp/regtests/CompileEachLineOfProgramOutput.java\n import com.google.javascript.jscomp.CompilationLevel;\n import com.google.javascript.jscomp.Compiler;\n import com.google.javascript.jscomp.CompilerOptions;\n-import com.google.javascript.jscomp.JSSourceFile;\n+import com.google.javascript.jscomp.SourceFile;\n import com.google.javascript.jscomp.Result;\n import com.google.javascript.jscomp.WarningLevel;\n \n public class CompileEachLineOfProgramOutput {\n-  private static final JSSourceFile extern =\n-      JSSourceFile.fromCode(\"externs.js\", \"\");\n+  private static final SourceFile extern =\n+      SourceFile.fromCode(\"externs.js\", \"\");\n   private static final CompilerOptions options =\n       new CompilerOptions();\n \n   }\n \n   public static Result compile(String program, int num) {\n-    JSSourceFile input = JSSourceFile.fromCode(\"\"+num, program);\n+    SourceFile input = SourceFile.fromCode(\"\"+num, program);\n     Compiler compiler = new Compiler();\n     Result result = compiler.compile(extern, input, options);\n     return result;", "timestamp": 1330992834, "metainfo": ""}