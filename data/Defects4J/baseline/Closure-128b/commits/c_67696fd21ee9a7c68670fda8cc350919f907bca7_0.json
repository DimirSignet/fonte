{"sha": "67696fd21ee9a7c68670fda8cc350919f907bca7", "log": "Remove references to passes when we're done with them. This appears to relieve memory pressure a bunch  R=johnlenz DELTA=44  (43 added, 0 deleted, 1 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=5335   ", "commit": "\n--- a/src/com/google/javascript/jscomp/CompilerOptions.java\n+++ b/src/com/google/javascript/jscomp/CompilerOptions.java\n    * </ul>\n    */\n   public boolean ideMode;\n+\n+  boolean saveDataStructures = false;\n \n   /**\n    * Even if checkTypes is disabled, clients might want to still infer types.\n     this.ideMode = ideMode;\n   }\n \n+  /**\n+   * Whether to keep internal data structures around after we're\n+   * finished compiling. We do this by default when IDE mode is on.\n+   */\n+  public void setSaveDataStructures(boolean save) {\n+    this.saveDataStructures = save;\n+  }\n+\n   public void setSkipAllPasses(boolean skipAllPasses) {\n     this.skipAllPasses = skipAllPasses;\n   }\n--- a/src/com/google/javascript/jscomp/DefaultPassConfig.java\n+++ b/src/com/google/javascript/jscomp/DefaultPassConfig.java\n       } else {\n         checks.add(inferJsDocInfo.makeOneTimePass());\n       }\n+\n+      // We assume that only IDE-mode clients will try to query the\n+      // typed scope creator after the compile job.\n+      if (!options.ideMode && !options.saveDataStructures) {\n+        checks.add(clearTypedScopePass.makeOneTimePass());\n+      }\n     }\n \n     if (options.checkUnreachableCode.isOn() ||\n     }\n   };\n \n+  /** Clears the typed scope when we're done. */\n+  final PassFactory clearTypedScopePass =\n+      new PassFactory(\"clearTypedScopePass\", false) {\n+    @Override\n+    protected CompilerPass createInternal(AbstractCompiler compiler) {\n+      return new ClearTypedScope();\n+    }\n+  };\n+\n   /** Runs type inference. */\n   final HotSwapPassFactory inferTypes =\n       new HotSwapPassFactory(\"inferTypes\", false) {\n     @Override\n     public void hotSwapScript(Node scriptRoot, Node originalRoot) {\n       patchGlobalTypedScope(compiler, scriptRoot);\n+    }\n+  }\n+\n+  /** A compiler pass that clears the global scope. */\n+  class ClearTypedScope implements CompilerPass {\n+    @Override\n+    public void process(Node externs, Node root) {\n+      clearTypedScope();\n     }\n   }\n \n--- a/src/com/google/javascript/jscomp/PassConfig.java\n+++ b/src/com/google/javascript/jscomp/PassConfig.java\n     topScope = typedScopeCreator.createScope(root, null);\n   }\n \n+  void clearTypedScope() {\n+    internalScopeCreator = null;\n+    typedScopeCreator = null;\n+    topScope = null;\n+  }\n+\n   /**\n    * Regenerates the top scope potentially only for a sub-tree of AST and then\n    * copies information for the old global scope.\n--- a/src/com/google/javascript/jscomp/PhaseOptimizer.java\n+++ b/src/com/google/javascript/jscomp/PhaseOptimizer.java\n   }\n \n   /**\n-   * Delegates to a PassFactory for processing.\n+   * Wraps every pass factory as a pass, to ensure that we don't\n+   * keep references to passes and their data structures.\n    */\n   private class PassFactoryDelegate extends NamedPass {\n     private final AbstractCompiler myCompiler;", "timestamp": 1344617246, "metainfo": ""}