{"sha": "c2e1d41c876befd2c6b80861b2680685d8f54a5e", "log": "redeclare prototypes of native types when we see them in the externs. This ensures that they get proper source info  R=johnlenz DELTA=94  (32 added, 2 deleted, 60 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=3900   ", "commit": "\n--- a/src/com/google/javascript/jscomp/TypeValidator.java\n+++ b/src/com/google/javascript/jscomp/TypeValidator.java\n    * @param variableName The name of the variable.\n    * @param newType The type being applied to the variable. Mostly just here\n    *     for the benefit of the warning.\n-   */\n-  void expectUndeclaredVariable(String sourceName, CompilerInput input,\n+   * @return The variable we end up with. Most of the time, this will just\n+   *     be {@code var}, but in some rare cases we will need to declare\n+   *     a new var with new source info.\n+   */\n+  Var expectUndeclaredVariable(String sourceName, CompilerInput input,\n       Node n, Node parent, Var var, String variableName, JSType newType) {\n+    Var newVar = var;\n     boolean allowDupe = false;\n     if (n.isGetProp() ||\n         NodeUtil.isObjectLitKey(n, parent)) {\n       if (var.input == null) {\n         Scope s = var.getScope();\n         s.undeclare(var);\n-        s.declare(variableName, n, varType, input, false);\n+        newVar = s.declare(variableName, n, varType, input, false);\n \n         n.setJSType(varType);\n         if (parent.isVar()) {\n         }\n       }\n     }\n+\n+    return newVar;\n   }\n \n   /**\n--- a/src/com/google/javascript/jscomp/TypedScopeCreator.java\n+++ b/src/com/google/javascript/jscomp/TypedScopeCreator.java\n         }\n       }\n \n+      // The input may be null if we are working with a AST snippet. So read\n+      // the extern info from the node.\n+      boolean isExtern = n.isFromExterns();\n+      Var newVar = null;\n+\n       // declared in closest scope?\n       CompilerInput input = compiler.getInput(inputId);\n       if (scopeToDeclareIn.isDeclared(variableName, false)) {\n         Var oldVar = scopeToDeclareIn.getVar(variableName);\n-        validator.expectUndeclaredVariable(\n+        newVar = validator.expectUndeclaredVariable(\n             sourceName, input, n, parent, oldVar, variableName, type);\n       } else {\n         if (!inferred) {\n           setDeferredType(n, type);\n         }\n \n-        // The input may be null if we are working with a AST snippet.\n-        boolean isExtern = n.isFromExterns();\n-        Var newVar =\n-            scopeToDeclareIn.declare(variableName, n, type, input, inferred);\n+        newVar =\n+          scopeToDeclareIn.declare(variableName, n, type, input, inferred);\n \n         if (type instanceof EnumType) {\n           Node initialValue = newVar.getInitialValue();\n             compiler.report(JSError.make(sourceName, n, ENUM_INITIALIZER));\n           }\n         }\n-\n-        // We need to do some additional work for constructors and interfaces.\n-        FunctionType fnType = JSType.toMaybeFunctionType(type);\n-        if (fnType != null &&\n-            // We don't want to look at empty function types.\n-            !type.isEmptyType()) {\n-          if ((fnType.isConstructor() || fnType.isInterface()) &&\n-              !fnType.equals(getNativeType(U2U_CONSTRUCTOR_TYPE))) {\n-            // Declare var.prototype in the scope chain.\n-            FunctionType superClassCtor = fnType.getSuperClassConstructor();\n-            ObjectType.Property prototypeSlot = fnType.getSlot(\"prototype\");\n-\n-            String prototypeName = variableName + \".prototype\";\n-\n-            // There are some rare cases where the prototype will already\n-            // be declared. See TypedScopeCreatorTest#testBogusPrototypeInit.\n-            // Fortunately, other warnings will complain if this happens.\n-            if (scopeToDeclareIn.getOwnSlot(prototypeName) == null) {\n-              // When we declare the function prototype implicitly, we\n-              // want to make sure that the function and its prototype\n-              // are declared at the same node. We also want to make sure\n-              // that the if a symbol has both a Var and a JSType, they have\n-              // the same node.\n-              //\n-              // This consistency is helpful to users of SymbolTable,\n-              // because everything gets declared at the same place.\n-              prototypeSlot.setNode(n);\n-\n-              scopeToDeclareIn.declare(prototypeName,\n-                  n, prototypeSlot.getType(), input,\n-                  /* declared iff there's an explicit supertype */\n-                  superClassCtor == null ||\n-                  superClassCtor.getInstanceType().equals(\n-                      getNativeType(OBJECT_TYPE)));\n-            }\n-\n-            // Make sure the variable is initialized to something if\n-            // it constructs itself.\n-            if (newVar.getInitialValue() == null &&\n-                !isExtern &&\n-                // We want to make sure that when we declare a new instance\n-                // type (with @constructor) that there's actually a ctor for it.\n-                // This doesn't apply to structural constructors\n-                // (like function(new:Array). Checking the constructed\n-                // type against the variable name is a sufficient check for\n-                // this.\n-                variableName.equals(\n-                    fnType.getInstanceType().getReferenceName())) {\n-              compiler.report(\n-                  JSError.make(sourceName, n,\n-                      fnType.isConstructor() ?\n-                          CTOR_INITIALIZER : IFACE_INITIALIZER,\n-                      variableName));\n-            }\n+      }\n+\n+      // We need to do some additional work for constructors and interfaces.\n+      FunctionType fnType = JSType.toMaybeFunctionType(type);\n+      if (fnType != null &&\n+          // We don't want to look at empty function types.\n+          !type.isEmptyType()) {\n+        if ((fnType.isConstructor() || fnType.isInterface()) &&\n+            !fnType.equals(getNativeType(U2U_CONSTRUCTOR_TYPE))) {\n+          // Declare var.prototype in the scope chain.\n+          FunctionType superClassCtor = fnType.getSuperClassConstructor();\n+          ObjectType.Property prototypeSlot = fnType.getSlot(\"prototype\");\n+\n+          // When we declare the function prototype implicitly, we\n+          // want to make sure that the function and its prototype\n+          // are declared at the same node. We also want to make sure\n+          // that the if a symbol has both a Var and a JSType, they have\n+          // the same node.\n+          //\n+          // This consistency is helpful to users of SymbolTable,\n+          // because everything gets declared at the same place.\n+          prototypeSlot.setNode(n);\n+\n+          String prototypeName = variableName + \".prototype\";\n+\n+          // There are some rare cases where the prototype will already\n+          // be declared. See TypedScopeCreatorTest#testBogusPrototypeInit.\n+          // Fortunately, other warnings will complain if this happens.\n+          Var prototypeVar = scopeToDeclareIn.getVar(prototypeName);\n+          if (prototypeVar != null && prototypeVar.scope == scopeToDeclareIn) {\n+            scopeToDeclareIn.undeclare(prototypeVar);\n+          }\n+\n+          scopeToDeclareIn.declare(prototypeName,\n+              n, prototypeSlot.getType(), input,\n+              /* declared iff there's an explicit supertype */\n+              superClassCtor == null ||\n+              superClassCtor.getInstanceType().equals(\n+                  getNativeType(OBJECT_TYPE)));\n+\n+          // Make sure the variable is initialized to something if\n+          // it constructs itself.\n+          if (newVar.getInitialValue() == null &&\n+              !isExtern &&\n+              // We want to make sure that when we declare a new instance\n+              // type (with @constructor) that there's actually a ctor for it.\n+              // This doesn't apply to structural constructors\n+              // (like function(new:Array). Checking the constructed\n+              // type against the variable name is a sufficient check for\n+              // this.\n+              variableName.equals(\n+                  fnType.getInstanceType().getReferenceName())) {\n+            compiler.report(\n+                JSError.make(sourceName, n,\n+                    fnType.isConstructor() ?\n+                    CTOR_INITIALIZER : IFACE_INITIALIZER,\n+                    variableName));\n           }\n         }\n       }\n--- a/test/com/google/javascript/jscomp/CompilerTypeTestCase.java\n+++ b/test/com/google/javascript/jscomp/CompilerTypeTestCase.java\n       \"/** @type {!Function} */ Function.prototype.call;\" +\n       \"/** @constructor \\n * @param {*} arg \\n @return {string} */\" +\n       \"function String(arg) {}\" +\n+      \"/** @param {number} sliceArg */\\n\" +\n+      \"String.prototype.slice = function(sliceArg) {};\" +\n       \"/** @type {number} */ String.prototype.length;\" +\n       \"/** @constructor \\n * @param {*} var_args \\n @return {!Array} */\" +\n       \"function Array(var_args) {}\" +\n--- a/test/com/google/javascript/jscomp/SymbolTableTest.java\n+++ b/test/com/google/javascript/jscomp/SymbolTableTest.java\n     assertEquals(Foo, dom.getPropertyScope().getSlot(\"Foo\"));\n   }\n \n+  public void testSymbolForScopeOfNatives() throws Exception {\n+    SymbolTable table = createSymbolTable(\"\");\n+\n+    // From the externs.\n+    Symbol sliceArg = getLocalVar(table, \"sliceArg\");\n+    assertNotNull(sliceArg);\n+\n+    Symbol scope = table.getSymbolForScope(table.getScope(sliceArg));\n+    assertNotNull(scope);\n+    assertEquals(scope, getGlobalVar(table, \"String.prototype.slice\"));\n+\n+    Symbol proto = getGlobalVar(table, \"String.prototype\");\n+    assertEquals(\n+        \"externs1\", proto.getDeclaration().getNode().getSourceFileName());\n+  }\n+\n   private void assertSymmetricOrdering(\n       Ordering<Symbol> ordering, Symbol first, Symbol second) {\n     assertTrue(ordering.compare(first, first) == 0);", "timestamp": 1322769385, "metainfo": ""}