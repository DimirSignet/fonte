{"sha": "82a721378e12bb8c66cccbc535db4adac3deef77", "log": "Automated g4 rollback.  *** Reason for rollback ***  Chrome 15 has been released.  *** Original change description ***  true -> !0 causes a preformance regression.  Consider reenabling this once Chrome 15 is the stable release.  R=acleung DELTA=83  (39 added, 9 deleted, 35 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=3637   ", "commit": "\n--- a/src/com/google/javascript/jscomp/DefaultPassConfig.java\n+++ b/src/com/google/javascript/jscomp/DefaultPassConfig.java\n       new PassFactory(\"peepholeOptimizations\", false) {\n     @Override\n     protected CompilerPass createInternal(AbstractCompiler compiler) {\n+      final boolean late = false;\n       return new PeepholeOptimizationsPass(compiler,\n-            new PeepholeSubstituteAlternateSyntax(false),\n+            new PeepholeSubstituteAlternateSyntax(late),\n             new PeepholeReplaceKnownMethods(),\n             new PeepholeRemoveDeadCode(),\n-            new PeepholeFoldConstants(),\n+            new PeepholeFoldConstants(late),\n             new PeepholeCollectPropertyAssignments());\n     }\n   };\n       new PassFactory(\"latePeepholeOptimizations\", true) {\n     @Override\n     protected CompilerPass createInternal(AbstractCompiler compiler) {\n+      final boolean late = true;\n       return new PeepholeOptimizationsPass(compiler,\n             new StatementFusion(),\n             new PeepholeRemoveDeadCode(),\n-            new PeepholeSubstituteAlternateSyntax(true),\n+            new PeepholeSubstituteAlternateSyntax(late),\n             new PeepholeReplaceKnownMethods(),\n-            new PeepholeFoldConstants()\n+            new PeepholeFoldConstants(late)\n             // TODO(johnlenz): reenable this once Chrome 15 is stable\n             // new ReorderConstantExpression()\n             );\n--- a/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\n+++ b/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\n       \"Fractional bitwise operand: {0}\");\n \n   private static final double MAX_FOLD_NUMBER = Math.pow(2, 53);\n+\n+  private final boolean late;\n+\n+  /**\n+   * @param late When late is false, this mean we are currently running before\n+   * most of the other optimizations. In this case we would avoid optimizations\n+   * that would make the code harder to analyze. When this is true, we would\n+   * do anything to minimize for size.\n+   */\n+  PeepholeFoldConstants(boolean late) {\n+    this.late = late;\n+  }\n \n   @Override\n   Node optimizeSubtree(Node subtree) {\n \n     switch (n.getType()) {\n       case Token.NOT:\n-        // TODO(johnlenz): skip folding !0/!1 during late fold,\n-        // when it is folded there.\n-        /*\n         // Don't fold !0 and !1 back to false.\n-        if (left.getType() == Token.NUMBER) {\n+        if (late && left.getType() == Token.NUMBER) {\n           double numValue = left.getDouble();\n           if (numValue == 0 || numValue == 1) {\n             return n;\n           }\n         }\n-        */\n         int result = leftVal.toBoolean(true) ? Token.FALSE : Token.TRUE;\n         Node replacementNode = new Node(result);\n         parent.replaceChild(n, replacementNode);\n--- a/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n+++ b/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n         return result;\n \n       case Token.COMMA:\n-        return tryFoldComma(node);\n+        return trySplitComma(node);\n \n       case Token.NAME:\n         return tryReplaceUndefined(node);\n     }\n   }\n \n-  private Node tryFoldComma(Node n) {\n+  private Node trySplitComma(Node n) {\n     if (!late) {\n       return n;\n     }\n   }\n \n   private Node reduceTrueFalse(Node n) {\n-    // TODO(johnlenz): Re-enable this with Chrome 15.\n-    /*\n     if (late) {\n       Node not = new Node(Token.NOT,\n           Node.newNumber(n.getType() == Token.TRUE ? 0 : 1));\n       reportCodeChange();\n       return not;\n     }\n-    */\n     return n;\n   }\n \n--- a/test/com/google/javascript/jscomp/CommandLineRunnerTest.java\n+++ b/test/com/google/javascript/jscomp/CommandLineRunnerTest.java\n          \"/** @define {number} */ var BAR = 3;\" +\n          \"/** @define {boolean} */ var CCC = false;\" +\n          \"/** @define {boolean} */ var DDD = false;\",\n-         \"var FOO = true, BAR = 5, CCC = true, DDD = true;\");\n+         \"var FOO = !0, BAR = 5, CCC = !0, DDD = !0;\");\n   }\n \n   public void testDefineFlag2() {\n     test(\"goog.asserts.assert(false)\",\n          \"\");\n     args.add(\"--debug\");\n-    test(\"goog.asserts.assert(false)\", \"goog.$asserts$.$assert$(false)\");\n+    test(\"goog.asserts.assert(false)\", \"goog.$asserts$.$assert$(!1)\");\n   }\n \n   public void testMissingReturnCheckOnWithVerbose() {\n--- a/test/com/google/javascript/jscomp/CreateSyntheticBlocksTest.java\n+++ b/test/com/google/javascript/jscomp/CreateSyntheticBlocksTest.java\n         new PeepholeOptimizationsPass(compiler,\n             new PeepholeRemoveDeadCode(),\n             new PeepholeSubstituteAlternateSyntax(true),\n-            new PeepholeFoldConstants())\n+            new PeepholeFoldConstants(true))\n             .process(externs, js);\n         new MinimizeExitPoints(compiler).process(externs, js);\n \n--- a/test/com/google/javascript/jscomp/PeepholeFoldConstantsTest.java\n+++ b/test/com/google/javascript/jscomp/PeepholeFoldConstantsTest.java\n  */\n public class PeepholeFoldConstantsTest extends CompilerTestCase {\n \n+  private boolean late;\n+\n   // TODO(user): Remove this when we no longer need to do string comparison.\n   private PeepholeFoldConstantsTest(boolean compareAsTree) {\n     super(\"\", compareAsTree);\n \n   @Override\n   public void setUp() {\n+    late = false;\n     enableLineNumberCheck(true);\n   }\n \n   @Override\n   public CompilerPass getProcessor(final Compiler compiler) {\n     CompilerPass peepholePass = new PeepholeOptimizationsPass(compiler,\n-          new PeepholeFoldConstants());\n-\n+          new PeepholeFoldConstants(late));\n     return peepholePass;\n   }\n \n   }\n \n   public void testNotFoldBackToTrueFalse() {\n-    // TODO(johnlenz): disable this for late folding once it has been reenabled.\n+    late = false;\n     fold(\"!0\", \"true\");\n     fold(\"!1\", \"false\");\n     fold(\"!3\", \"false\");\n+\n+    late = true;\n+    foldSame(\"!0\");\n+    foldSame(\"!1\");\n+    fold(\"!3\", \"false\");\n+    foldSame(\"false\");\n+    foldSame(\"true\");\n   }\n \n   public void testFoldBangConstants() {\n           \"void 0\",\n           \"true\",\n           \"false\",\n-          // TODO(johnlenz): Add these two back.\n-          // \"!0\",\n-          // \"!1\",\n+          \"!0\",\n+          \"!1\",\n           \"0\",\n           \"1\",\n           \"''\",\n   }\n \n   public void testCommutativeOperators() {\n+    late = true;\n     List<String> operators =\n         ImmutableList.of(\n             \"==\",\n--- a/test/com/google/javascript/jscomp/PeepholeIntegrationTest.java\n+++ b/test/com/google/javascript/jscomp/PeepholeIntegrationTest.java\n  */\n public class PeepholeIntegrationTest extends CompilerTestCase {\n \n-  private boolean doCommaSplitting = true;\n+  private boolean late = true;\n \n   // TODO(user): Remove this when we no longer need to do string comparison.\n   private PeepholeIntegrationTest(boolean compareAsTree) {\n   @Override\n   public void setUp() throws Exception {\n     super.setUp();\n-    this.doCommaSplitting = true;\n+    this.late = true;\n     enableLineNumberCheck(true);\n \n     // TODO(nicksantos): Turn this on. There are some normalizations\n   public CompilerPass getProcessor(final Compiler compiler) {\n     PeepholeOptimizationsPass peepholePass =\n       new PeepholeOptimizationsPass(compiler,\n-        new PeepholeSubstituteAlternateSyntax(doCommaSplitting),\n+        new PeepholeSubstituteAlternateSyntax(late),\n         new PeepholeRemoveDeadCode(),\n-        new PeepholeFoldConstants()\n+        new PeepholeFoldConstants(late)\n       );\n \n     return peepholePass;\n     scTest.disableNormalize();\n \n     scTest.test(js, expected);\n+  }\n+\n+  public void testTrueFalse() {\n+    late = false;\n+    foldSame(\"x = true\");\n+    foldSame(\"x = false\");\n+    fold(\"x = !1\", \"x = false\");\n+    fold(\"x = !0\", \"x = true\");\n+    late = true;\n+    fold(\"x = true\", \"x = !0\");\n+    fold(\"x = false\", \"x = !1\");\n+    foldSame(\"x = !1\");\n+    foldSame(\"x = !0\");\n   }\n \n   /** Check that removing blocks with 1 child works */\n     fold(\"function z() {if (a) { return true }\" +\n          \"else if (b) { return true }\" +\n          \"else { return true }}\",\n-         \"function z() {return true;}\");\n+         \"function z() {return !0;}\");\n \n     fold(\"function z() {if (a()) { return true }\" +\n          \"else if (b()) { return true }\" +\n          \"else { return true }}\",\n-         \"function z() {a()||b();return true;}\");\n+         \"function z() {a()||b();return !0;}\");\n   }\n \n   public void testFoldLogicalOpIntegration() {\n   }\n \n   public void testTrueFalseFolding() {\n-    fold(\"x = true\", \"x = true\");\n-    fold(\"x = false\", \"x = false\");\n-    fold(\"x = !3\", \"x = false\");\n-    fold(\"x = true && !0\", \"x = true\");\n-    fold(\"x = !!!!!!!!!!!!3\", \"x = true\");\n+    fold(\"x = true\", \"x = !0\");\n+    fold(\"x = false\", \"x = !1\");\n+    fold(\"x = !3\", \"x = !1\");\n+    fold(\"x = true && !0\", \"x = !0\");\n+    fold(\"x = !!!!!!!!!!!!3\", \"x = !0\");\n     fold(\"if(!3){x()}\", \"\");\n     fold(\"if(!!3){x()}\", \"x()\");\n   }\n \n   public void testAvoidCommaSplitting() {\n     fold(\"x(),y(),z()\", \"x();y();z()\");\n-    doCommaSplitting = false;\n+    late = false;\n     foldSame(\"x(),y(),z()\");\n   }\n \n--- a/test/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntaxTest.java\n+++ b/test/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntaxTest.java\n          \"function z() {(a) ? foo() : goo(); return !0}\");\n     fold(\"function z() {if (a) { foo(); x = true; return true \" +\n          \"} else { goo(); x = true; return true }}\",\n-         \"function z() {(a) ? foo() : goo(); x = true; return true}\");\n+         \"function z() {(a) ? foo() : goo(); x = !0; return !0}\");\n \n     fold(\"function z() {\" +\n          \"  if (a) { bar(); foo(); return true }\" +\n          \"function z() {\" +\n          \"  if (a) { bar(); foo(); }\" +\n          \"    else { bar(); goo(); }\" +\n-         \"  return true;\" +\n+         \"  return !0;\" +\n          \"}\");\n   }\n \n   }\n \n   public void testFoldReturnResult() {\n-    fold(\"function f(){return false;}\", \"function f(){return false}\");\n+    fold(\"function f(){return false;}\", \"function f(){return !1}\");\n     foldSame(\"function f(){return null;}\");\n     fold(\"function f(){return void 0;}\",\n          \"function f(){}\");\n   }\n \n   public void testFoldTrueFalse() {\n-    fold(\"x = true\", \"x = true\");\n-    fold(\"x = false\", \"x = false\");\n+    fold(\"x = true\", \"x = !0\");\n+    fold(\"x = false\", \"x = !1\");\n   }\n \n   public void testIssue291() {", "timestamp": 1320693835, "metainfo": ""}