{"sha": "61336bdc14f94b57ba58042f958c2a3227a55a3f", "log": "Better property checks, by creating a notion of \"synthetic\" types that we use for internal bookkeeping, and not using those for property checks. fixes issue 725  R=johnlenz DELTA=63  (58 added, 0 deleted, 5 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=4832   ", "commit": "\n--- a/src/com/google/javascript/rhino/jstype/JSTypeRegistry.java\n+++ b/src/com/google/javascript/rhino/jstype/JSTypeRegistry.java\n     if (typesIndexedByProperty.containsKey(propertyName)) {\n       for (JSType alt :\n                typesIndexedByProperty.get(propertyName).getAlternates()) {\n-        if (!alt.getGreatestSubtype(type).isEmptyType()) {\n+        JSType greatestSubtype = alt.getGreatestSubtype(type);\n+        if (!greatestSubtype.isEmptyType()) {\n+          // We've found a type with this property. Now we just have to make\n+          // sure it's not a type used for internal bookkeeping.\n+          RecordType maybeRecordType = greatestSubtype.toMaybeRecordType();\n+          if (maybeRecordType != null && maybeRecordType.isSynthetic()) {\n+            continue;\n+          }\n+\n           return true;\n         }\n       }\n--- a/src/com/google/javascript/rhino/jstype/ObjectType.java\n+++ b/src/com/google/javascript/rhino/jstype/ObjectType.java\n   public abstract ObjectType getImplicitPrototype();\n \n   /**\n-   * Defines a property whose type is synthesized (i.e. not inferred).\n+   * Defines a property whose type is explicitly declared by the programmer.\n    * @param propertyName the property's name\n    * @param type the type\n    * @param propertyNode the node corresponding to the declaration of property\n     registry.registerPropertyOnType(propertyName, this);\n \n     return result;\n+  }\n+\n+  /**\n+   * Defines a property whose type is on a synthesized object. These objects\n+   * don't actually exist in the user's program. They're just used for\n+   * bookkeeping in the type system.\n+   */\n+  public final boolean defineSynthesizedProperty(String propertyName,\n+      JSType type, Node propertyNode) {\n+    return defineProperty(propertyName, type, false, propertyNode);\n   }\n \n   /**\n--- a/src/com/google/javascript/rhino/jstype/RecordType.java\n+++ b/src/com/google/javascript/rhino/jstype/RecordType.java\n   private static final long serialVersionUID = 1L;\n \n   private final SortedMap<String, JSType> properties = Maps.newTreeMap();\n+  private final boolean declared;\n   private boolean isFrozen = false;\n+\n+  RecordType(JSTypeRegistry registry, Map<String, RecordProperty> properties) {\n+    this(registry, properties, true);\n+  }\n \n   /**\n    * Creates a record type.\n    *\n    * @param registry The type registry under which this type lives.\n    * @param properties A map of all the properties of this record type.\n+   * @param declared Whether this is a declared or synthesized type.\n+   *     A synthesized record type is just used for bookkeeping\n+   *     in the type system. A declared record type was actually used in the\n+   *     user's program.\n    * @throws IllegalStateException if the {@code RecordProperty} associated\n    *         with a property is null.\n    */\n-  RecordType(JSTypeRegistry registry, Map<String, RecordProperty> properties) {\n+  RecordType(JSTypeRegistry registry, Map<String, RecordProperty> properties,\n+      boolean declared) {\n     super(registry, null, null);\n     setPrettyPrint(true);\n+    this.declared = declared;\n \n     for (String property : properties.keySet()) {\n       RecordProperty prop = properties.get(property);\n         throw new IllegalStateException(\n             \"RecordProperty associated with a property should not be null!\");\n       }\n-      defineDeclaredProperty(property, prop.getType(), prop.getPropertyNode());\n+      if (declared) {\n+        defineDeclaredProperty(\n+            property, prop.getType(), prop.getPropertyNode());\n+      } else {\n+        defineSynthesizedProperty(\n+            property, prop.getType(), prop.getPropertyNode());\n+      }\n     }\n \n     // Freeze the record type.\n     isFrozen = true;\n+  }\n+\n+  /** @return Is this synthesized for internal bookkeeping? */\n+  boolean isSynthetic() {\n+    return !declared;\n   }\n \n   @Override\n     if (that.isRecordType()) {\n       RecordType thatRecord = that.toMaybeRecordType();\n       RecordTypeBuilder builder = new RecordTypeBuilder(registry);\n+      builder.setSynthesized(true);\n \n       // The greatest subtype consists of those *unique* properties of both\n       // record types. If any property conflicts, then the NO_TYPE type\n--- a/src/com/google/javascript/rhino/jstype/RecordTypeBuilder.java\n+++ b/src/com/google/javascript/rhino/jstype/RecordTypeBuilder.java\n  */\n public class RecordTypeBuilder {\n   private boolean isEmpty = true;\n+  private boolean isDeclared = true;\n   private final JSTypeRegistry registry;\n   private final HashMap<String, RecordProperty> properties = Maps.newHashMap();\n \n   public RecordTypeBuilder(JSTypeRegistry registry) {\n     this.registry = registry;\n+  }\n+\n+  /** See the comments on RecordType about synthetic types. */\n+  void setSynthesized(boolean synthesized) {\n+    isDeclared = !synthesized;\n   }\n \n   /**\n        return registry.getNativeObjectType(JSTypeNative.OBJECT_TYPE);\n     }\n \n-    return registry.createRecordType(Collections.unmodifiableMap(properties));\n+    return new RecordType(\n+        registry, Collections.unmodifiableMap(properties), isDeclared);\n   }\n \n   static class RecordProperty {\n--- a/test/com/google/javascript/jscomp/TypeCheckTest.java\n+++ b/test/com/google/javascript/jscomp/TypeCheckTest.java\n         \"callee();\");\n   }\n \n+  public void testIssue725() throws Exception {\n+    testTypes(\n+        \"/** @typedef {{name: string}} */ var RecordType1;\" +\n+        \"/** @typedef {{name2: string}} */ var RecordType2;\" +\n+        \"/** @param {RecordType1} rec */ function f(rec) {\" +\n+        \"  alert(rec.name2);\" +\n+        \"}\",\n+        \"Property name2 never defined on rec\");\n+  }\n+\n   /**\n    * Tests that the || operator is type checked correctly, that is of\n    * the type of the first argument or of the second argument. See", "timestamp": 1337615910, "metainfo": ""}