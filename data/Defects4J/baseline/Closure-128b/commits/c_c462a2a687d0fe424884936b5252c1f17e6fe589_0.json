{"sha": "c462a2a687d0fe424884936b5252c1f17e6fe589", "log": "Cleanup of some of the main compiler classes.  R=nicksantos DELTA=628 (5 added, 457 deleted, 166 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=6037   ", "commit": "\n--- a/src/com/google/javascript/jscomp/CleanupPasses.java\n+++ b/src/com/google/javascript/jscomp/CleanupPasses.java\n   final PassFactory fieldCleanupPassFactory =\n       new HotSwapPassFactory(\"FieldCleaupPassFactory\", false) {\n         @Override\n-        protected HotSwapCompilerPass createInternal(\n+        protected HotSwapCompilerPass create(\n             AbstractCompiler compiler) {\n           return new FieldCleanupPass(compiler);\n         }\n   final PassFactory scopeCleanupPassFactory =\n       new HotSwapPassFactory(\"ScopeCleanupPassFactory\", false) {\n         @Override\n-        protected HotSwapCompilerPass createInternal(\n+        protected HotSwapCompilerPass create(\n             AbstractCompiler compiler) {\n           return new MemoizedScopeCleanupPass(compiler);\n         }\n   final PassFactory globalVarRefCleanupPassFactory =\n       new HotSwapPassFactory(\"GlobalVarRefCleanupPassFactory\", false) {\n         @Override\n-        protected HotSwapCompilerPass createInternal(\n+        protected HotSwapCompilerPass create(\n             AbstractCompiler compiler) {\n           return new GlobalVarRefCleanupPass(compiler);\n         }\n--- a/src/com/google/javascript/jscomp/Compiler.java\n+++ b/src/com/google/javascript/jscomp/Compiler.java\n   private final PassFactory sanityCheck =\n       new PassFactory(\"sanityCheck\", false) {\n     @Override\n-    protected CompilerPass createInternal(AbstractCompiler compiler) {\n+    protected CompilerPass create(AbstractCompiler compiler) {\n       return new SanityCheck(compiler);\n     }\n   };\n     }\n     phaseOptimizer.consume(getPassConfig().getOptimizations());\n     phaseOptimizer.process(externsRoot, jsRoot);\n-    if (hasErrors()) {\n-      return;\n-    }\n   }\n \n   @Override\n--- a/src/com/google/javascript/jscomp/DefaultPassConfig.java\n+++ b/src/com/google/javascript/jscomp/DefaultPassConfig.java\n     }\n \n     if (options.jqueryPass) {\n-      checks.add(jqueryAliases.makeOneTimePass());\n+      checks.add(jqueryAliases);\n     }\n \n     checks.add(checkSideEffects);\n     }\n \n     if (options.closurePass) {\n-      checks.add(closurePrimitives.makeOneTimePass());\n+      checks.add(closurePrimitives);\n     }\n \n     if (options.closurePass && options.checkMissingGetCssNameLevel.isOn()) {\n     }\n \n     if (options.checkTypes || options.inferTypes) {\n-      checks.add(resolveTypes.makeOneTimePass());\n-      checks.add(inferTypes.makeOneTimePass());\n+      checks.add(resolveTypes);\n+      checks.add(inferTypes);\n       if (options.checkTypes) {\n-        checks.add(checkTypes.makeOneTimePass());\n+        checks.add(checkTypes);\n       } else {\n-        checks.add(inferJsDocInfo.makeOneTimePass());\n+        checks.add(inferJsDocInfo);\n       }\n \n       // We assume that only IDE-mode clients will try to query the\n       // typed scope creator after the compile job.\n       if (!options.ideMode && !options.saveDataStructures) {\n-        checks.add(clearTypedScopePass.makeOneTimePass());\n+        checks.add(clearTypedScopePass);\n       }\n     }\n \n         passes.add(crossModuleMethodMotion);\n       }\n \n-      passes.add(specializeInitialModule.makeOneTimePass());\n+      passes.add(specializeInitialModule);\n     }\n \n     passes.addAll(getMainOptimizationLoop());\n    */\n   final HotSwapPassFactory checkSideEffects =\n       new HotSwapPassFactory(\"checkSideEffects\", true) {\n-\n-    @Override\n-    protected HotSwapCompilerPass createInternal(final AbstractCompiler\n-        compiler) {\n+    @Override\n+    protected HotSwapCompilerPass create(final AbstractCompiler compiler) {\n       // The current approach to protecting \"hidden\" side-effects is to\n       // wrap them in a function call that is stripped later, this shouldn't\n       // be done in IDE mode where AST changes may be unexpected.\n    */\n   final PassFactory stripSideEffectProtection =\n       new PassFactory(\"stripSideEffectProtection\", true) {\n-\n-    @Override\n-    protected CompilerPass createInternal(final AbstractCompiler\n+    @Override\n+    protected CompilerPass create(final AbstractCompiler\n         compiler) {\n       return new CheckSideEffects.StripProtection(compiler);\n     }\n   /**\n    * Checks for code that is probably wrong (such as stray expressions).\n    */\n-  // TODO(bolinfest): Write a CompilerPass for this.\n   final HotSwapPassFactory suspiciousCode =\n       new HotSwapPassFactory(\"suspiciousCode\", true) {\n-\n-    @Override\n-    protected HotSwapCompilerPass createInternal(final AbstractCompiler\n-        compiler) {\n+    @Override\n+    protected HotSwapCompilerPass create(final AbstractCompiler compiler) {\n       List<Callback> sharedCallbacks = Lists.newArrayList();\n       if (options.checkSuspiciousCode) {\n         sharedCallbacks.add(new CheckSuspiciousCode());\n   final HotSwapPassFactory checkControlStructures =\n       new HotSwapPassFactory(\"checkControlStructures\", true) {\n     @Override\n-    protected HotSwapCompilerPass createInternal(AbstractCompiler compiler) {\n+    protected HotSwapCompilerPass create(AbstractCompiler compiler) {\n       return new ControlStructureCheck(compiler);\n     }\n   };\n   final HotSwapPassFactory checkRequires =\n       new HotSwapPassFactory(\"checkRequires\", true) {\n     @Override\n-    protected HotSwapCompilerPass createInternal(AbstractCompiler compiler) {\n+    protected HotSwapCompilerPass create(AbstractCompiler compiler) {\n       return new CheckRequiresForConstructors(compiler, options.checkRequires);\n     }\n   };\n   final HotSwapPassFactory checkProvides =\n       new HotSwapPassFactory(\"checkProvides\", true) {\n     @Override\n-    protected HotSwapCompilerPass createInternal(AbstractCompiler compiler) {\n+    protected HotSwapCompilerPass create(AbstractCompiler compiler) {\n       return new CheckProvides(compiler, options.checkProvides);\n     }\n   };\n           \"functions are set.\");\n \n   /** Generates exports for @export annotations. */\n-  final PassFactory generateExports =\n-      new PassFactory(\"generateExports\", true) {\n-    @Override\n-    protected CompilerPass createInternal(AbstractCompiler compiler) {\n+  final PassFactory generateExports = new PassFactory(\"generateExports\", true) {\n+    @Override\n+    protected CompilerPass create(AbstractCompiler compiler) {\n       CodingConvention convention = compiler.getCodingConvention();\n       if (convention.getExportSymbolFunction() != null &&\n           convention.getExportPropertyFunction() != null) {\n   final PassFactory exportTestFunctions =\n       new PassFactory(\"exportTestFunctions\", true) {\n     @Override\n-    protected CompilerPass createInternal(AbstractCompiler compiler) {\n+    protected CompilerPass create(AbstractCompiler compiler) {\n       CodingConvention convention = compiler.getCodingConvention();\n       if (convention.getExportSymbolFunction() != null) {\n         return new ExportTestFunctions(compiler,\n \n   /** Raw exports processing pass. */\n   final PassFactory gatherRawExports =\n-      new PassFactory(\"gatherRawExports\", false) {\n-    @Override\n-    protected CompilerPass createInternal(AbstractCompiler compiler) {\n+      new PassFactory(\"gatherRawExports\", true) {\n+    @Override\n+    protected CompilerPass create(AbstractCompiler compiler) {\n       final GatherRawExports pass = new GatherRawExports(\n           compiler);\n \n   /** Closure pre-processing pass. */\n   @SuppressWarnings(\"deprecation\")\n   final HotSwapPassFactory closurePrimitives =\n-      new HotSwapPassFactory(\"closurePrimitives\", false) {\n-    @Override\n-    protected HotSwapCompilerPass createInternal(AbstractCompiler compiler) {\n+      new HotSwapPassFactory(\"closurePrimitives\", true) {\n+    @Override\n+    protected HotSwapCompilerPass create(AbstractCompiler compiler) {\n       maybeInitializePreprocessorSymbolTable(compiler);\n       final ProcessClosurePrimitives pass = new ProcessClosurePrimitives(\n           compiler,\n   };\n \n   /** Expand jQuery Primitives and Aliases pass. */\n-  final PassFactory jqueryAliases =\n-      new PassFactory(\"jqueryAliases\", true) {\n-    @Override\n-    protected CompilerPass createInternal(AbstractCompiler compiler) {\n+  final PassFactory jqueryAliases = new PassFactory(\"jqueryAliases\", true) {\n+    @Override\n+    protected CompilerPass create(AbstractCompiler compiler) {\n       return new ExpandJqueryAliases(compiler);\n     }\n   };\n    * A lot of the options are not configurable, because ReplaceMessages\n    * has a lot of legacy logic.\n    */\n-  final PassFactory replaceMessages =\n-      new PassFactory(\"replaceMessages\", true) {\n-    @Override\n-    protected CompilerPass createInternal(final AbstractCompiler compiler) {\n+  final PassFactory replaceMessages = new PassFactory(\"replaceMessages\", true) {\n+    @Override\n+    protected CompilerPass create(final AbstractCompiler compiler) {\n       return new ReplaceMessages(compiler,\n           options.messageBundle,\n           /* warn about message dupes */\n   final PassFactory replaceMessagesForChrome =\n       new PassFactory(\"replaceMessages\", true) {\n     @Override\n-    protected CompilerPass createInternal(final AbstractCompiler compiler) {\n+    protected CompilerPass create(final AbstractCompiler compiler) {\n       return new ReplaceMessagesForChrome(compiler,\n           new GoogleJsMessageIdGenerator(options.tcProjectId),\n           /* warn about message dupes */\n   final HotSwapPassFactory closureGoogScopeAliases =\n       new HotSwapPassFactory(\"closureGoogScopeAliases\", true) {\n     @Override\n-    protected HotSwapCompilerPass createInternal(AbstractCompiler compiler) {\n+    protected HotSwapCompilerPass create(AbstractCompiler compiler) {\n       maybeInitializePreprocessorSymbolTable(compiler);\n       return new ScopedAliases(\n           compiler,\n   final HotSwapPassFactory closureRewriteGoogClass =\n       new HotSwapPassFactory(\"closureRewriteGoogClass\", true) {\n     @Override\n-    protected HotSwapCompilerPass createInternal(AbstractCompiler compiler) {\n+    protected HotSwapCompilerPass create(AbstractCompiler compiler) {\n       return new ClosureRewriteClass(compiler);\n     }\n   };\n   final PassFactory closureCheckGetCssName =\n       new PassFactory(\"closureCheckGetCssName\", true) {\n     @Override\n-    protected CompilerPass createInternal(AbstractCompiler compiler) {\n+    protected CompilerPass create(AbstractCompiler compiler) {\n       String blacklist = options.checkMissingGetCssNameBlacklist;\n       Preconditions.checkState(blacklist != null && !blacklist.isEmpty(),\n           \"Not checking use of goog.getCssName because of empty blacklist.\");\n   final PassFactory closureReplaceGetCssName =\n       new PassFactory(\"closureReplaceGetCssName\", true) {\n     @Override\n-    protected CompilerPass createInternal(final AbstractCompiler compiler) {\n+    protected CompilerPass create(final AbstractCompiler compiler) {\n       return new CompilerPass() {\n         @Override\n         public void process(Node externs, Node jsRoot) {\n   final PassFactory createSyntheticBlocks =\n       new PassFactory(\"createSyntheticBlocks\", true) {\n     @Override\n-    protected CompilerPass createInternal(AbstractCompiler compiler) {\n+    protected CompilerPass create(AbstractCompiler compiler) {\n       return new CreateSyntheticBlocks(compiler,\n           options.syntheticBlockStartMarker,\n           options.syntheticBlockEndMarker);\n   final PassFactory peepholeOptimizations =\n       new PassFactory(\"peepholeOptimizations\", false) {\n     @Override\n-    protected CompilerPass createInternal(AbstractCompiler compiler) {\n+    protected CompilerPass create(AbstractCompiler compiler) {\n       final boolean late = false;\n       return new PeepholeOptimizationsPass(compiler,\n             new PeepholeSubstituteAlternateSyntax(late),\n   final PassFactory latePeepholeOptimizations =\n       new PassFactory(\"latePeepholeOptimizations\", true) {\n     @Override\n-    protected CompilerPass createInternal(AbstractCompiler compiler) {\n+    protected CompilerPass create(AbstractCompiler compiler) {\n       final boolean late = true;\n       return new PeepholeOptimizationsPass(compiler,\n             new StatementFusion(),\n   final HotSwapPassFactory checkVars =\n       new HotSwapPassFactory(\"checkVars\", true) {\n     @Override\n-    protected HotSwapCompilerPass createInternal(AbstractCompiler compiler) {\n+    protected HotSwapCompilerPass create(AbstractCompiler compiler) {\n       return new VarCheck(compiler);\n     }\n   };\n   final PassFactory checkRegExp =\n       new PassFactory(\"checkRegExp\", true) {\n     @Override\n-    protected CompilerPass createInternal(final AbstractCompiler compiler) {\n+    protected CompilerPass create(final AbstractCompiler compiler) {\n       final CheckRegExp pass = new CheckRegExp(compiler);\n \n       return new CompilerPass() {\n   final HotSwapPassFactory checkVariableReferences =\n       new HotSwapPassFactory(\"checkVariableReferences\", true) {\n     @Override\n-    protected HotSwapCompilerPass createInternal(AbstractCompiler compiler) {\n+    protected HotSwapCompilerPass create(AbstractCompiler compiler) {\n       return new VariableReferenceCheck(\n           compiler, options.aggressiveVarCheck);\n     }\n   final PassFactory objectPropertyStringPreprocess =\n       new PassFactory(\"ObjectPropertyStringPreprocess\", true) {\n     @Override\n-    protected CompilerPass createInternal(AbstractCompiler compiler) {\n+    protected CompilerPass create(AbstractCompiler compiler) {\n       return new ObjectPropertyStringPreprocess(compiler);\n     }\n   };\n \n   /** Creates a typed scope and adds types to the type registry. */\n   final HotSwapPassFactory resolveTypes =\n-      new HotSwapPassFactory(\"resolveTypes\", false) {\n-    @Override\n-    protected HotSwapCompilerPass createInternal(AbstractCompiler compiler) {\n+      new HotSwapPassFactory(\"resolveTypes\", true) {\n+    @Override\n+    protected HotSwapCompilerPass create(AbstractCompiler compiler) {\n       return new GlobalTypeResolver(compiler);\n     }\n   };\n \n   /** Clears the typed scope when we're done. */\n   final PassFactory clearTypedScopePass =\n-      new PassFactory(\"clearTypedScopePass\", false) {\n-    @Override\n-    protected CompilerPass createInternal(AbstractCompiler compiler) {\n+      new PassFactory(\"clearTypedScopePass\", true) {\n+    @Override\n+    protected CompilerPass create(AbstractCompiler compiler) {\n       return new ClearTypedScope();\n     }\n   };\n \n   /** Runs type inference. */\n   final HotSwapPassFactory inferTypes =\n-      new HotSwapPassFactory(\"inferTypes\", false) {\n-    @Override\n-    protected HotSwapCompilerPass createInternal(final AbstractCompiler\n-        compiler) {\n+      new HotSwapPassFactory(\"inferTypes\", true) {\n+    @Override\n+    protected HotSwapCompilerPass create(final AbstractCompiler compiler) {\n       return new HotSwapCompilerPass() {\n         @Override\n         public void process(Node externs, Node root) {\n   };\n \n   final HotSwapPassFactory inferJsDocInfo =\n-    new HotSwapPassFactory(\"inferJsDocInfo\", false) {\n+      new HotSwapPassFactory(\"inferJsDocInfo\", true) {\n   @Override\n-  protected HotSwapCompilerPass createInternal(\n-      final AbstractCompiler compiler) {\n+  protected HotSwapCompilerPass create(final AbstractCompiler compiler) {\n     return new HotSwapCompilerPass() {\n       @Override\n       public void process(Node externs, Node root) {\n \n   /** Checks type usage */\n   final HotSwapPassFactory checkTypes =\n-      new HotSwapPassFactory(\"checkTypes\", false) {\n-    @Override\n-    protected HotSwapCompilerPass createInternal(final AbstractCompiler\n-        compiler) {\n+      new HotSwapPassFactory(\"checkTypes\", true) {\n+    @Override\n+    protected HotSwapCompilerPass create(final AbstractCompiler compiler) {\n       return new HotSwapCompilerPass() {\n         @Override\n         public void process(Node externs, Node root) {\n   final HotSwapPassFactory checkControlFlow =\n       new HotSwapPassFactory(\"checkControlFlow\", true) {\n     @Override\n-    protected HotSwapCompilerPass createInternal(AbstractCompiler compiler) {\n+    protected HotSwapCompilerPass create(AbstractCompiler compiler) {\n       List<Callback> callbacks = Lists.newArrayList();\n       if (options.checkUnreachableCode.isOn()) {\n         callbacks.add(\n   final HotSwapPassFactory checkAccessControls =\n       new HotSwapPassFactory(\"checkAccessControls\", true) {\n     @Override\n-    protected HotSwapCompilerPass createInternal(AbstractCompiler compiler) {\n+    protected HotSwapCompilerPass create(AbstractCompiler compiler) {\n       return new CheckAccessControls(compiler);\n     }\n   };\n   final PassFactory checkGlobalNames =\n       new PassFactory(\"checkGlobalNames\", true) {\n     @Override\n-    protected CompilerPass createInternal(final AbstractCompiler compiler) {\n+    protected CompilerPass create(final AbstractCompiler compiler) {\n       return new CompilerPass() {\n         @Override\n         public void process(Node externs, Node jsRoot) {\n   final PassFactory checkStrictMode =\n       new PassFactory(\"checkStrictMode\", true) {\n     @Override\n-    protected CompilerPass createInternal(AbstractCompiler compiler) {\n+    protected CompilerPass create(AbstractCompiler compiler) {\n       return new StrictModeCheck(compiler,\n           !options.checkSymbols,  // don't check variables twice\n           !options.checkCaja);    // disable eval check if not Caja\n   /** Process goog.tweak.getTweak() calls. */\n   final PassFactory processTweaks = new PassFactory(\"processTweaks\", true) {\n     @Override\n-    protected CompilerPass createInternal(final AbstractCompiler compiler) {\n+    protected CompilerPass create(final AbstractCompiler compiler) {\n       return new CompilerPass() {\n         @Override\n         public void process(Node externs, Node jsRoot) {\n   };\n \n   /** Override @define-annotated constants. */\n-  final PassFactory processDefines =\n-      new PassFactory(\"processDefines\", true) {\n-    @Override\n-    protected CompilerPass createInternal(final AbstractCompiler compiler) {\n+  final PassFactory processDefines = new PassFactory(\"processDefines\", true) {\n+    @Override\n+    protected CompilerPass create(final AbstractCompiler compiler) {\n       return new CompilerPass() {\n         @Override\n         public void process(Node externs, Node jsRoot) {\n   final PassFactory garbageCollectChecks =\n       new HotSwapPassFactory(\"garbageCollectChecks\", true) {\n     @Override\n-    protected HotSwapCompilerPass createInternal(\n-        final AbstractCompiler compiler) {\n+    protected HotSwapCompilerPass create(final AbstractCompiler compiler) {\n       return new HotSwapCompilerPass() {\n         @Override\n         public void process(Node externs, Node jsRoot) {\n   };\n \n   /** Checks that all constants are not modified */\n-  final PassFactory checkConsts =\n-      new PassFactory(\"checkConsts\", true) {\n-    @Override\n-    protected CompilerPass createInternal(AbstractCompiler compiler) {\n+  final PassFactory checkConsts = new PassFactory(\"checkConsts\", true) {\n+    @Override\n+    protected CompilerPass create(AbstractCompiler compiler) {\n       return new ConstCheck(compiler);\n     }\n   };\n   final PassFactory computeFunctionNames =\n       new PassFactory(\"computeFunctionNames\", true) {\n     @Override\n-    protected CompilerPass createInternal(AbstractCompiler compiler) {\n+    protected CompilerPass create(AbstractCompiler compiler) {\n       return ((functionNames = new FunctionNames(compiler)));\n     }\n   };\n   final PassFactory ignoreCajaProperties =\n       new PassFactory(\"ignoreCajaProperties\", true) {\n     @Override\n-    protected CompilerPass createInternal(AbstractCompiler compiler) {\n+    protected CompilerPass create(AbstractCompiler compiler) {\n       return new IgnoreCajaProperties(compiler);\n     }\n   };\n   final PassFactory runtimeTypeCheck =\n       new PassFactory(\"runtimeTypeCheck\", true) {\n     @Override\n-    protected CompilerPass createInternal(AbstractCompiler compiler) {\n+    protected CompilerPass create(AbstractCompiler compiler) {\n       return new RuntimeTypeCheck(compiler,\n           options.runtimeTypeCheckLogFunction);\n     }\n   final PassFactory replaceIdGenerators =\n       new PassFactory(\"replaceIdGenerators\", true) {\n     @Override\n-    protected CompilerPass createInternal(final AbstractCompiler compiler) {\n+    protected CompilerPass create(final AbstractCompiler compiler) {\n       return new CompilerPass() {\n         @Override public void process(Node externs, Node root) {\n           ReplaceIdGenerators pass =\n   };\n \n   /** Replace strings. */\n-  final PassFactory replaceStrings =\n-      new PassFactory(\"replaceStrings\", true) {\n-    @Override\n-    protected CompilerPass createInternal(final AbstractCompiler compiler) {\n+  final PassFactory replaceStrings = new PassFactory(\"replaceStrings\", true) {\n+    @Override\n+    protected CompilerPass create(final AbstractCompiler compiler) {\n       return new CompilerPass() {\n         @Override public void process(Node externs, Node root) {\n           ReplaceStrings pass = new ReplaceStrings(\n   final PassFactory optimizeArgumentsArray =\n       new PassFactory(\"optimizeArgumentsArray\", true) {\n     @Override\n-    protected CompilerPass createInternal(AbstractCompiler compiler) {\n+    protected CompilerPass create(AbstractCompiler compiler) {\n       return new OptimizeArgumentsArray(compiler);\n     }\n   };\n   final PassFactory closureCodeRemoval =\n       new PassFactory(\"closureCodeRemoval\", true) {\n     @Override\n-    protected CompilerPass createInternal(final AbstractCompiler compiler) {\n+    protected CompilerPass create(final AbstractCompiler compiler) {\n       return new ClosureCodeRemoval(compiler, options.removeAbstractMethods,\n           options.removeClosureAsserts);\n     }\n   final PassFactory closureOptimizePrimitives =\n       new PassFactory(\"closureOptimizePrimitives\", true) {\n     @Override\n-    protected CompilerPass createInternal(final AbstractCompiler compiler) {\n+    protected CompilerPass create(final AbstractCompiler compiler) {\n       return new ClosureOptimizePrimitives(compiler);\n     }\n   };\n   final PassFactory rescopeGlobalSymbols =\n       new PassFactory(\"rescopeGlobalSymbols\", true) {\n     @Override\n-    protected CompilerPass createInternal(AbstractCompiler compiler) {\n+    protected CompilerPass create(AbstractCompiler compiler) {\n       return new RescopeGlobalSymbols(compiler, options.renamePrefixNamespace);\n     }\n   };\n   final PassFactory collapseProperties =\n       new PassFactory(\"collapseProperties\", true) {\n     @Override\n-    protected CompilerPass createInternal(AbstractCompiler compiler) {\n+    protected CompilerPass create(AbstractCompiler compiler) {\n       return new CollapseProperties(\n           compiler, options.collapsePropertiesOnExternTypes,\n           !isInliningForbidden());\n   final PassFactory collapseObjectLiterals =\n       new PassFactory(\"collapseObjectLiterals\", false) {\n     @Override\n-    protected CompilerPass createInternal(AbstractCompiler compiler) {\n+    protected CompilerPass create(AbstractCompiler compiler) {\n       return new InlineObjectLiterals(\n           compiler, compiler.getUniqueNameIdSupplier());\n     }\n   final PassFactory tightenTypesBuilder =\n       new PassFactory(\"tightenTypes\", true) {\n     @Override\n-    protected CompilerPass createInternal(AbstractCompiler compiler) {\n+    protected CompilerPass create(AbstractCompiler compiler) {\n       if (!options.checkTypes) {\n         return new ErrorPass(compiler, TIGHTEN_TYPES_WITHOUT_TYPE_CHECK);\n       }\n   final PassFactory disambiguateProperties =\n       new PassFactory(\"disambiguateProperties\", true) {\n     @Override\n-    protected CompilerPass createInternal(AbstractCompiler compiler) {\n+    protected CompilerPass create(AbstractCompiler compiler) {\n       if (tightenTypes == null) {\n         return DisambiguateProperties.forJSTypeSystem(compiler,\n             options.propertyInvalidationErrors);\n   /**\n    * Chain calls to functions that return this.\n    */\n-  final PassFactory chainCalls =\n-      new PassFactory(\"chainCalls\", true) {\n-    @Override\n-    protected CompilerPass createInternal(AbstractCompiler compiler) {\n+  final PassFactory chainCalls = new PassFactory(\"chainCalls\", true) {\n+    @Override\n+    protected CompilerPass create(AbstractCompiler compiler) {\n       return new ChainCalls(compiler);\n     }\n   };\n   final PassFactory devirtualizePrototypeMethods =\n       new PassFactory(\"devirtualizePrototypeMethods\", true) {\n     @Override\n-    protected CompilerPass createInternal(AbstractCompiler compiler) {\n+    protected CompilerPass create(AbstractCompiler compiler) {\n       return new DevirtualizePrototypeMethods(compiler);\n     }\n   };\n   final PassFactory optimizeCallsAndRemoveUnusedVars =\n       new PassFactory(\"optimizeCalls_and_removeUnusedVars\", false) {\n     @Override\n-    protected CompilerPass createInternal(AbstractCompiler compiler) {\n+    protected CompilerPass create(AbstractCompiler compiler) {\n       OptimizeCalls passes = new OptimizeCalls(compiler);\n       if (options.optimizeReturns) {\n         // Remove unused return values.\n   final PassFactory markPureFunctions =\n       new PassFactory(\"markPureFunctions\", true) {\n     @Override\n-    protected CompilerPass createInternal(AbstractCompiler compiler) {\n+    protected CompilerPass create(AbstractCompiler compiler) {\n       return new PureFunctionIdentifier.Driver(\n           compiler, options.debugFunctionSideEffectsPath, false);\n     }\n   final PassFactory markNoSideEffectCalls =\n       new PassFactory(\"markNoSideEffectCalls\", true) {\n     @Override\n-    protected CompilerPass createInternal(AbstractCompiler compiler) {\n+    protected CompilerPass create(AbstractCompiler compiler) {\n       return new MarkNoSideEffectCalls(compiler);\n     }\n   };\n   final PassFactory inlineVariables =\n       new PassFactory(\"inlineVariables\", false) {\n     @Override\n-    protected CompilerPass createInternal(AbstractCompiler compiler) {\n+    protected CompilerPass create(AbstractCompiler compiler) {\n       if (isInliningForbidden()) {\n         // In old renaming schemes, inlining a variable can change whether\n         // or not a property is renamed. This is bad, and those old renaming\n   final PassFactory inlineConstants =\n       new PassFactory(\"inlineConstants\", false) {\n     @Override\n-    protected CompilerPass createInternal(AbstractCompiler compiler) {\n+    protected CompilerPass create(AbstractCompiler compiler) {\n       return new InlineVariables(\n           compiler, InlineVariables.Mode.CONSTANTS_ONLY, true);\n     }\n   final PassFactory minimizeExitPoints =\n       new PassFactory(\"minimizeExitPoints\", false) {\n     @Override\n-    protected CompilerPass createInternal(AbstractCompiler compiler) {\n+    protected CompilerPass create(AbstractCompiler compiler) {\n       return new MinimizeExitPoints(compiler);\n     }\n   };\n   final PassFactory removeUnreachableCode =\n       new PassFactory(\"removeUnreachableCode\", false) {\n     @Override\n-    protected CompilerPass createInternal(AbstractCompiler compiler) {\n+    protected CompilerPass create(AbstractCompiler compiler) {\n       return new UnreachableCodeElimination(compiler, true);\n     }\n   };\n   final PassFactory removeUnusedPrototypeProperties =\n       new PassFactory(\"removeUnusedPrototypeProperties\", false) {\n     @Override\n-    protected CompilerPass createInternal(AbstractCompiler compiler) {\n+    protected CompilerPass create(AbstractCompiler compiler) {\n       return new RemoveUnusedPrototypeProperties(\n           compiler, options.removeUnusedPrototypePropertiesInExterns,\n           !options.removeUnusedVars);\n   final PassFactory removeUnusedClassProperties =\n       new PassFactory(\"removeUnusedClassProperties\", false) {\n     @Override\n-    protected CompilerPass createInternal(AbstractCompiler compiler) {\n+    protected CompilerPass create(AbstractCompiler compiler) {\n       return new RemoveUnusedClassProperties(compiler);\n     }\n   };\n   final PassFactory smartNamePass =\n       new PassFactory(\"smartNamePass\", true) {\n     @Override\n-    protected CompilerPass createInternal(final AbstractCompiler compiler) {\n+    protected CompilerPass create(final AbstractCompiler compiler) {\n       return new CompilerPass() {\n         @Override\n         public void process(Node externs, Node root) {\n    * Process smart name processing - removes unused classes and does referencing\n    * starting with minimum set of names.\n    */\n-  final PassFactory smartNamePass2 =\n-      new PassFactory(\"smartNamePass\", true) {\n-    @Override\n-    protected CompilerPass createInternal(final AbstractCompiler compiler) {\n+  final PassFactory smartNamePass2 = new PassFactory(\"smartNamePass\", true) {\n+    @Override\n+    protected CompilerPass create(final AbstractCompiler compiler) {\n       return new CompilerPass() {\n         @Override\n         public void process(Node externs, Node root) {\n   final PassFactory inlineSimpleMethods =\n       new PassFactory(\"inlineSimpleMethods\", false) {\n     @Override\n-    protected CompilerPass createInternal(AbstractCompiler compiler) {\n+    protected CompilerPass create(AbstractCompiler compiler) {\n       return new InlineSimpleMethods(compiler);\n     }\n   };\n   final PassFactory deadAssignmentsElimination =\n       new PassFactory(\"deadAssignmentsElimination\", false) {\n     @Override\n-    protected CompilerPass createInternal(AbstractCompiler compiler) {\n+    protected CompilerPass create(AbstractCompiler compiler) {\n       return new DeadAssignmentsElimination(compiler);\n     }\n   };\n   final PassFactory inlineFunctions =\n       new PassFactory(\"inlineFunctions\", false) {\n     @Override\n-    protected CompilerPass createInternal(AbstractCompiler compiler) {\n+    protected CompilerPass create(AbstractCompiler compiler) {\n       boolean enableBlockInlining = !isInliningForbidden();\n       return new InlineFunctions(\n           compiler,\n   final PassFactory inlineProperties =\n       new PassFactory(\"inlineProperties\", false) {\n     @Override\n-    protected CompilerPass createInternal(AbstractCompiler compiler) {\n+    protected CompilerPass create(AbstractCompiler compiler) {\n       return new InlineProperties(compiler);\n     }\n   };\n   final PassFactory removeUnusedVars =\n       new PassFactory(\"removeUnusedVars\", false) {\n     @Override\n-    protected CompilerPass createInternal(AbstractCompiler compiler) {\n+    protected CompilerPass create(AbstractCompiler compiler) {\n       boolean removeOnlyLocals = options.removeUnusedLocalVars\n           && !options.removeUnusedVars;\n       boolean preserveAnonymousFunctionNames =\n   final PassFactory crossModuleCodeMotion =\n       new PassFactory(\"crossModuleCodeMotion\", false) {\n     @Override\n-    protected CompilerPass createInternal(AbstractCompiler compiler) {\n+    protected CompilerPass create(AbstractCompiler compiler) {\n       return new CrossModuleCodeMotion(compiler, compiler.getModuleGraph());\n     }\n   };\n   final PassFactory crossModuleMethodMotion =\n       new PassFactory(\"crossModuleMethodMotion\", false) {\n     @Override\n-    protected CompilerPass createInternal(AbstractCompiler compiler) {\n+    protected CompilerPass create(AbstractCompiler compiler) {\n       return new CrossModuleMethodMotion(\n           compiler, crossModuleIdGenerator,\n           // Only move properties in externs if we're not treating\n   final PassFactory specializeInitialModule =\n       new PassFactory(\"specializeInitialModule\", true) {\n     @Override\n-    protected CompilerPass createInternal(AbstractCompiler compiler) {\n+    protected CompilerPass create(AbstractCompiler compiler) {\n       return new SpecializeModule(compiler, devirtualizePrototypeMethods,\n           inlineFunctions, removeUnusedPrototypeProperties);\n     }\n   final PassFactory flowSensitiveInlineVariables =\n       new PassFactory(\"flowSensitiveInlineVariables\", true) {\n     @Override\n-    protected CompilerPass createInternal(AbstractCompiler compiler) {\n+    protected CompilerPass create(AbstractCompiler compiler) {\n       return new FlowSensitiveInlineVariables(compiler);\n     }\n   };\n   final PassFactory coalesceVariableNames =\n       new PassFactory(\"coalesceVariableNames\", true) {\n     @Override\n-    protected CompilerPass createInternal(AbstractCompiler compiler) {\n+    protected CompilerPass create(AbstractCompiler compiler) {\n       return new CoalesceVariableNames(compiler, options.generatePseudoNames);\n     }\n   };\n    * Some simple, local collapses (e.g., {@code var x; var y;} becomes\n    * {@code var x,y;}.\n    */\n-  final PassFactory exploitAssign =\n-      new PassFactory(\"exploitAssign\", true) {\n-    @Override\n-    protected CompilerPass createInternal(AbstractCompiler compiler) {\n+  final PassFactory exploitAssign = new PassFactory(\"exploitAssign\", true) {\n+    @Override\n+    protected CompilerPass create(AbstractCompiler compiler) {\n       return new PeepholeOptimizationsPass(compiler,\n           new ExploitAssigns());\n     }\n   final PassFactory collapseVariableDeclarations =\n       new PassFactory(\"collapseVariableDeclarations\", true) {\n     @Override\n-    protected CompilerPass createInternal(AbstractCompiler compiler) {\n+    protected CompilerPass create(AbstractCompiler compiler) {\n       return new CollapseVariableDeclarations(compiler);\n     }\n   };\n   final PassFactory groupVariableDeclarations =\n       new PassFactory(\"groupVariableDeclarations\", true) {\n     @Override\n-    protected CompilerPass createInternal(AbstractCompiler compiler) {\n+    protected CompilerPass create(AbstractCompiler compiler) {\n       return new GroupVariableDeclarations(compiler);\n     }\n   };\n   final PassFactory extractPrototypeMemberDeclarations =\n       new PassFactory(\"extractPrototypeMemberDeclarations\", true) {\n     @Override\n-    protected CompilerPass createInternal(AbstractCompiler compiler) {\n+    protected CompilerPass create(AbstractCompiler compiler) {\n       return new ExtractPrototypeMemberDeclarations(\n           compiler, Pattern.USE_GLOBAL_TEMP);\n     }\n   final PassFactory rewriteFunctionExpressions =\n       new PassFactory(\"rewriteFunctionExpressions\", true) {\n     @Override\n-    protected CompilerPass createInternal(AbstractCompiler compiler) {\n+    protected CompilerPass create(AbstractCompiler compiler) {\n       return new FunctionRewriter(compiler);\n     }\n   };\n   final PassFactory collapseAnonymousFunctions =\n       new PassFactory(\"collapseAnonymousFunctions\", true) {\n     @Override\n-    protected CompilerPass createInternal(AbstractCompiler compiler) {\n+    protected CompilerPass create(AbstractCompiler compiler) {\n       return new CollapseAnonymousFunctions(compiler);\n     }\n   };\n   final PassFactory moveFunctionDeclarations =\n       new PassFactory(\"moveFunctionDeclarations\", true) {\n     @Override\n-    protected CompilerPass createInternal(AbstractCompiler compiler) {\n+    protected CompilerPass create(AbstractCompiler compiler) {\n       return new MoveFunctionDeclarations(compiler);\n     }\n   };\n   final PassFactory nameUnmappedAnonymousFunctions =\n       new PassFactory(\"nameAnonymousFunctions\", true) {\n     @Override\n-    protected CompilerPass createInternal(AbstractCompiler compiler) {\n+    protected CompilerPass create(AbstractCompiler compiler) {\n       return new NameAnonymousFunctions(compiler);\n     }\n   };\n   final PassFactory nameMappedAnonymousFunctions =\n       new PassFactory(\"nameAnonymousFunctions\", true) {\n     @Override\n-    protected CompilerPass createInternal(final AbstractCompiler compiler) {\n+    protected CompilerPass create(final AbstractCompiler compiler) {\n       return new CompilerPass() {\n         @Override public void process(Node externs, Node root) {\n           NameAnonymousFunctionsMapped naf =\n   };\n \n   /** Alias external symbols. */\n-  final PassFactory aliasExternals =\n-      new PassFactory(\"aliasExternals\", true) {\n-    @Override\n-    protected CompilerPass createInternal(AbstractCompiler compiler) {\n+  final PassFactory aliasExternals = new PassFactory(\"aliasExternals\", true) {\n+    @Override\n+    protected CompilerPass create(AbstractCompiler compiler) {\n       return new AliasExternals(compiler, compiler.getModuleGraph(),\n           options.unaliasableGlobals, options.aliasableGlobals);\n     }\n    * Alias string literals with global variables, to avoid creating lots of\n    * transient objects.\n    */\n-  final PassFactory aliasStrings =\n-      new PassFactory(\"aliasStrings\", true) {\n-    @Override\n-    protected CompilerPass createInternal(AbstractCompiler compiler) {\n+  final PassFactory aliasStrings = new PassFactory(\"aliasStrings\", true) {\n+    @Override\n+    protected CompilerPass create(AbstractCompiler compiler) {\n       return new AliasStrings(\n           compiler,\n           compiler.getModuleGraph(),\n   };\n \n   /** Aliases common keywords (true, false) */\n-  final PassFactory aliasKeywords =\n-      new PassFactory(\"aliasKeywords\", true) {\n-    @Override\n-    protected CompilerPass createInternal(AbstractCompiler compiler) {\n+  final PassFactory aliasKeywords = new PassFactory(\"aliasKeywords\", true) {\n+    @Override\n+    protected CompilerPass create(AbstractCompiler compiler) {\n       return new AliasKeywords(compiler);\n     }\n   };\n   final PassFactory objectPropertyStringPostprocess =\n       new PassFactory(\"ObjectPropertyStringPostprocess\", true) {\n     @Override\n-    protected CompilerPass createInternal(AbstractCompiler compiler) {\n+    protected CompilerPass create(AbstractCompiler compiler) {\n       return new ObjectPropertyStringPostprocess(compiler);\n     }\n   };\n   final PassFactory ambiguateProperties =\n       new PassFactory(\"ambiguateProperties\", true) {\n     @Override\n-    protected CompilerPass createInternal(AbstractCompiler compiler) {\n+    protected CompilerPass create(AbstractCompiler compiler) {\n       return new AmbiguateProperties(\n           compiler, options.anonymousFunctionNaming.getReservedCharacters());\n     }\n   final PassFactory markUnnormalized =\n       new PassFactory(\"markUnnormalized\", true) {\n     @Override\n-    protected CompilerPass createInternal(final AbstractCompiler compiler) {\n+    protected CompilerPass create(final AbstractCompiler compiler) {\n       return new CompilerPass() {\n         @Override public void process(Node externs, Node root) {\n           compiler.setLifeCycleStage(LifeCycleStage.RAW);\n   };\n \n   /** Denormalize the AST for code generation. */\n-  final PassFactory denormalize =\n-      new PassFactory(\"denormalize\", true) {\n-    @Override\n-    protected CompilerPass createInternal(AbstractCompiler compiler) {\n+  final PassFactory denormalize = new PassFactory(\"denormalize\", true) {\n+    @Override\n+    protected CompilerPass create(AbstractCompiler compiler) {\n       return new Denormalize(compiler);\n     }\n   };\n   final PassFactory invertContextualRenaming =\n       new PassFactory(\"invertContextualRenaming\", true) {\n     @Override\n-    protected CompilerPass createInternal(AbstractCompiler compiler) {\n+    protected CompilerPass create(AbstractCompiler compiler) {\n       return MakeDeclaredNamesUnique.getContextualRenameInverter(compiler);\n     }\n   };\n   final PassFactory renameProperties =\n       new PassFactory(\"renameProperties\", true) {\n     @Override\n-    protected CompilerPass createInternal(final AbstractCompiler compiler) {\n+    protected CompilerPass create(final AbstractCompiler compiler) {\n       final VariableMap prevPropertyMap = options.inputPropertyMap;\n       return new CompilerPass() {\n         @Override public void process(Node externs, Node root) {\n   }\n \n   /** Renames variables. */\n-  final PassFactory renameVars =\n-      new PassFactory(\"renameVars\", true) {\n-    @Override\n-    protected CompilerPass createInternal(final AbstractCompiler compiler) {\n+  final PassFactory renameVars = new PassFactory(\"renameVars\", true) {\n+    @Override\n+    protected CompilerPass create(final AbstractCompiler compiler) {\n       final VariableMap prevVariableMap = options.inputVariableMap;\n       return new CompilerPass() {\n         @Override public void process(Node externs, Node root) {\n   }\n \n   /** Renames labels */\n-  final PassFactory renameLabels =\n-      new PassFactory(\"renameLabels\", true) {\n-    @Override\n-    protected CompilerPass createInternal(AbstractCompiler compiler) {\n+  final PassFactory renameLabels = new PassFactory(\"renameLabels\", true) {\n+    @Override\n+    protected CompilerPass create(AbstractCompiler compiler) {\n       return new RenameLabels(compiler);\n     }\n   };\n   final PassFactory convertToDottedProperties =\n       new PassFactory(\"convertToDottedProperties\", true) {\n     @Override\n-    protected CompilerPass createInternal(AbstractCompiler compiler) {\n+    protected CompilerPass create(AbstractCompiler compiler) {\n       return new ConvertToDottedProperties(compiler);\n     }\n   };\n \n   /** Checks that all variables are defined. */\n-  final PassFactory sanityCheckAst =\n-      new PassFactory(\"sanityCheckAst\", true) {\n-    @Override\n-    protected CompilerPass createInternal(AbstractCompiler compiler) {\n+  final PassFactory sanityCheckAst = new PassFactory(\"sanityCheckAst\", true) {\n+    @Override\n+    protected CompilerPass create(AbstractCompiler compiler) {\n       return new AstValidator();\n     }\n   };\n \n   /** Checks that all variables are defined. */\n-  final PassFactory sanityCheckVars =\n-      new PassFactory(\"sanityCheckVars\", true) {\n-    @Override\n-    protected CompilerPass createInternal(AbstractCompiler compiler) {\n+  final PassFactory sanityCheckVars = new PassFactory(\"sanityCheckVars\", true) {\n+    @Override\n+    protected CompilerPass create(AbstractCompiler compiler) {\n       return new VarCheck(compiler, true);\n     }\n   };\n   final PassFactory instrumentFunctions =\n       new PassFactory(\"instrumentFunctions\", true) {\n     @Override\n-    protected CompilerPass createInternal(final AbstractCompiler compiler) {\n+    protected CompilerPass create(final AbstractCompiler compiler) {\n       return new CompilerPass() {\n         @Override public void process(Node externs, Node root) {\n           try {\n   static PassFactory createEmptyPass(String name) {\n     return new PassFactory(name, true) {\n       @Override\n-      protected CompilerPass createInternal(final AbstractCompiler compiler) {\n+      protected CompilerPass create(final AbstractCompiler compiler) {\n         return runInSerial();\n       }\n     };\n       final CustomPassExecutionTime executionTime) {\n     return new PassFactory(\"runCustomPasses\", true) {\n       @Override\n-      protected CompilerPass createInternal(final AbstractCompiler compiler) {\n+      protected CompilerPass create(final AbstractCompiler compiler) {\n         return runInSerial(options.customPasses.get(executionTime));\n       }\n     };\n   final PassFactory printNameReferenceGraph =\n     new PassFactory(\"printNameReferenceGraph\", true) {\n     @Override\n-    protected CompilerPass createInternal(final AbstractCompiler compiler) {\n+    protected CompilerPass create(final AbstractCompiler compiler) {\n       return new CompilerPass() {\n         @Override\n         public void process(Node externs, Node jsRoot) {\n   final PassFactory printNameReferenceReport =\n       new PassFactory(\"printNameReferenceReport\", true) {\n     @Override\n-    protected CompilerPass createInternal(final AbstractCompiler compiler) {\n+    protected CompilerPass create(final AbstractCompiler compiler) {\n       return new CompilerPass() {\n         @Override\n         public void process(Node externs, Node jsRoot) {\n     }\n \n     @Override\n-    protected abstract HotSwapCompilerPass createInternal(AbstractCompiler\n-        compiler);\n+    protected abstract HotSwapCompilerPass create(AbstractCompiler compiler);\n \n     @Override\n     HotSwapCompilerPass getHotSwapPass(AbstractCompiler compiler) {\n-      return this.createInternal(compiler);\n+      return this.create(compiler);\n     }\n   }\n \n--- a/src/com/google/javascript/jscomp/PassFactory.java\n+++ b/src/com/google/javascript/jscomp/PassFactory.java\n \n package com.google.javascript.jscomp;\n \n-import com.google.common.base.Preconditions;\n-\n-\n-\n /**\n  * A factory for creating JSCompiler passes based on the Options\n  * injected.  Contains all meta-data about compiler passes (like\n \n   private final String name;\n   private final boolean isOneTimePass;\n-  private boolean isCreated = false;\n \n   /**\n    * @param name The name of the pass that this factory creates.\n   }\n \n   /**\n-   * Make a new pass factory that only creates one-time passes.\n-   */\n-  PassFactory makeOneTimePass() {\n-    if (isOneTimePass()) {\n-      return this;\n-    }\n-\n-    final PassFactory self = this;\n-    return new PassFactory(name, true /* one time pass */) {\n-      @Override\n-      protected CompilerPass createInternal(AbstractCompiler compiler) {\n-        return self.createInternal(compiler);\n-      }\n-      @Override\n-      HotSwapCompilerPass getHotSwapPass(AbstractCompiler compiler) {\n-        return self.getHotSwapPass(compiler);\n-      }\n-    };\n-  }\n-\n-  /**\n    * Creates a new compiler pass to be run.\n    */\n-  final CompilerPass create(AbstractCompiler compiler) {\n-    Preconditions.checkState(!isCreated || !isOneTimePass,\n-        \"One-time passes cannot be run multiple times: %s\", name);\n-    isCreated = true;\n-    return createInternal(compiler);\n-  }\n-\n-  /**\n-   * Creates a new compiler pass to be run.\n-   */\n-  abstract protected CompilerPass createInternal(AbstractCompiler compiler);\n+  abstract CompilerPass create(AbstractCompiler compiler);\n \n   /**\n    * Any factory whose CompilerPass has a corresponding hot-swap version should\n--- a/src/com/google/javascript/jscomp/PhaseOptimizer.java\n+++ b/src/com/google/javascript/jscomp/PhaseOptimizer.java\n    * frequency of multi-run passes in a fixed-point loop.\n    */\n   void consume(List<PassFactory> factories) {\n-    Loop currentLoop = new LoopInternal();\n+    Loop currentLoop = new Loop();\n     boolean isCurrentLoopPopulated = false;\n     for (PassFactory factory : factories) {\n       if (factory.isOneTimePass()) {\n         if (isCurrentLoopPopulated) {\n           passes.add(currentLoop);\n-\n-          currentLoop = new LoopInternal();\n+          currentLoop = new Loop();\n           isCurrentLoopPopulated = false;\n         }\n         addOneTimePass(factory);\n    * This pass will be run once.\n    */\n   void addOneTimePass(PassFactory factory) {\n-    passes.add(new PassFactoryDelegate(compiler, factory));\n+    passes.add(new NamedPass(factory));\n   }\n \n   /**\n    * @return The loop structure. Pass suppliers should be added to the loop.\n    */\n   Loop addFixedPointLoop() {\n-    Loop loop = new LoopInternal();\n+    Loop loop = new Loop();\n     passes.add(loop);\n     return loop;\n   }\n   /**\n    * A single compiler pass.\n    */\n-  private abstract class NamedPass implements CompilerPass {\n+  class NamedPass implements CompilerPass {\n     private final String name;\n-\n-    NamedPass(String name) {\n-      this.name = name;\n+    private final PassFactory factory;\n+\n+    NamedPass(PassFactory factory) {\n+      this.name = factory.getName();\n+      this.factory = factory;\n     }\n \n     @Override\n     public void process(Node externs, Node root) {\n       logger.fine(name);\n       startPass(name);\n-      processInternal(externs, root);\n+      // Delay the creation of the actual pass until *after* all previous passes\n+      // have been processed.\n+      // Some precondition checks rely on this, eg, in CoalesceVariableNames.\n+      factory.create(compiler).process(externs, root);\n       endPass(externs, root);\n     }\n-\n-    abstract void processInternal(Node externs, Node root);\n-  }\n-\n-  /**\n-   * Wraps every pass factory as a pass, to ensure that we don't\n-   * keep references to passes and their data structures.\n-   */\n-  private class PassFactoryDelegate extends NamedPass {\n-    private final AbstractCompiler myCompiler;\n-    private final PassFactory factory;\n-\n-    private PassFactoryDelegate(\n-        AbstractCompiler myCompiler, PassFactory factory) {\n-      super(factory.getName());\n-      this.myCompiler = myCompiler;\n-      this.factory = factory;\n-    }\n-\n-    @Override\n-    void processInternal(Node externs, Node root) {\n-      factory.create(myCompiler).process(externs, root);\n-    }\n-  }\n-\n-  /**\n-   * Runs a set of compiler passes until they reach a fixed point.\n-   */\n-  static abstract class Loop implements CompilerPass {\n-    abstract void addLoopedPass(PassFactory factory);\n   }\n \n   /**\n    * Notice that this is a non-static class, because it includes the closure\n    * of PhaseOptimizer.\n    */\n-  private class LoopInternal extends Loop {\n+  class Loop implements CompilerPass {\n     private final List<NamedPass> myPasses = Lists.newArrayList();\n     private final Set<String> myNames = Sets.newHashSet();\n \n-    @Override\n     void addLoopedPass(PassFactory factory) {\n       String name = factory.getName();\n       Preconditions.checkArgument(!myNames.contains(name),\n           \"Already a pass with name '%s' in this loop\", name);\n-      myNames.add(factory.getName());\n-      myPasses.add(new PassFactoryDelegate(compiler, factory));\n+      myNames.add(name);\n+      myPasses.add(new NamedPass(factory));\n     }\n \n     /**\n--- a/src/com/google/javascript/jscomp/SpecializeModule.java\n+++ b/src/com/google/javascript/jscomp/SpecializeModule.java\n     Collection<SpecializationAwareCompilerPass> passes = Lists.newLinkedList();\n \n     for (PassFactory passFactory : specializationPassFactories) {\n-      CompilerPass pass = passFactory.createInternal(compiler);\n+      CompilerPass pass = passFactory.create(compiler);\n \n       Preconditions.checkState(pass instanceof\n           SpecializationAwareCompilerPass);\n--- a/test/com/google/javascript/jscomp/PhaseOptimizerTest.java\n+++ b/test/com/google/javascript/jscomp/PhaseOptimizerTest.java\n     assertPasses(\"x\");\n   }\n \n-  public void testTwoRuns() {\n-    addOneTimePass(\"x\");\n-    optimizer.process(null, null);\n-    try {\n-      optimizer.process(null, null);\n-      fail();\n-    } catch (IllegalStateException e) {\n-      assertEquals(\n-          \"One-time passes cannot be run multiple times: x\", e.getMessage());\n-    }\n-  }\n-\n   public void testLoop1() {\n     Loop loop = optimizer.addFixedPointLoop();\n     addLoopedPass(loop, \"x\", 0);\n       String name, final CompilerPass pass, boolean isOneTime) {\n     return new PassFactory(name, isOneTime) {\n       @Override\n-      protected CompilerPass createInternal(AbstractCompiler compiler) {\n+      protected CompilerPass create(AbstractCompiler compiler) {\n         return pass;\n       }\n     };\n--- a/test/com/google/javascript/jscomp/SpecializeModuleTest.java\n+++ b/test/com/google/javascript/jscomp/SpecializeModuleTest.java\n   private PassFactory inlineFunctions =\n       new PassFactory(\"inlineFunctions\", true) {\n     @Override\n-    protected CompilerPass createInternal(AbstractCompiler compiler) {\n+    protected CompilerPass create(AbstractCompiler compiler) {\n       return new InlineFunctions(compiler,\n           compiler.getUniqueNameIdSupplier(), true, false, true, true, true);\n     }\n   private PassFactory removeUnusedPrototypeProperties =\n     new PassFactory(\"removeUnusedPrototypeProperties\", true) {\n     @Override\n-    protected CompilerPass createInternal(AbstractCompiler compiler) {\n+    protected CompilerPass create(AbstractCompiler compiler) {\n       return new RemoveUnusedPrototypeProperties(compiler, false, false);\n     }\n   };\n   private PassFactory devirtualizePrototypeMethods =\n     new PassFactory(\"devirtualizePrototypeMethods\", true) {\n     @Override\n-    protected CompilerPass createInternal(AbstractCompiler compiler) {\n+    protected CompilerPass create(AbstractCompiler compiler) {\n       return new DevirtualizePrototypeMethods(compiler);\n     }\n   };", "timestamp": 1356119780, "metainfo": ""}