{"sha": "22c4ea0db9484352812536abe754df9540ce7793", "log": "Implement a configuration Environment for JSAnalyzer  Current implementation supports configuring the Passes  Next phase is to collect the output.  R=acleung   Revision created by MOE tool push_codebase. MOE_MIGRATION=2456   ", "commit": "\n--- a/src/com/google/javascript/jscomp/DefaultPassConfig.java\n+++ b/src/com/google/javascript/jscomp/DefaultPassConfig.java\n   }\n \n   /** Checks for validity of the control structures. */\n-  private final HotSwapPassFactory checkControlStructures =\n+  final HotSwapPassFactory checkControlStructures =\n       new HotSwapPassFactory(\"checkControlStructures\", true) {\n     @Override\n     protected HotSwapCompilerPass createInternal(AbstractCompiler compiler) {\n   };\n \n   /** Checks that all constructed classes are goog.require()d. */\n-  private final HotSwapPassFactory checkRequires =\n+  final HotSwapPassFactory checkRequires =\n       new HotSwapPassFactory(\"checkRequires\", true) {\n     @Override\n     protected HotSwapCompilerPass createInternal(AbstractCompiler compiler) {\n   };\n \n   /** Makes sure @constructor is paired with goog.provides(). */\n-  private final HotSwapPassFactory checkProvides =\n+  final HotSwapPassFactory checkProvides =\n       new HotSwapPassFactory(\"checkProvides\", true) {\n     @Override\n     protected HotSwapCompilerPass createInternal(AbstractCompiler compiler) {\n           \"functions are set.\");\n \n   /** Generates exports for @export annotations. */\n-  private final PassFactory generateExports =\n+  final PassFactory generateExports =\n       new PassFactory(\"generateExports\", true) {\n     @Override\n     protected CompilerPass createInternal(AbstractCompiler compiler) {\n   };\n \n   /** Generates exports for functions associated with JSUnit. */\n-  private final PassFactory exportTestFunctions =\n+  final PassFactory exportTestFunctions =\n       new PassFactory(\"exportTestFunctions\", true) {\n     @Override\n     protected CompilerPass createInternal(AbstractCompiler compiler) {\n    * A lot of the options are not configurable, because ReplaceMessages\n    * has a lot of legacy logic.\n    */\n-  private final PassFactory replaceMessages =\n+  final PassFactory replaceMessages =\n       new PassFactory(\"replaceMessages\", true) {\n     @Override\n     protected CompilerPass createInternal(final AbstractCompiler compiler) {\n   };\n \n   /** Checks that CSS class names are wrapped in goog.getCssName */\n-  private final PassFactory closureCheckGetCssName =\n+  final PassFactory closureCheckGetCssName =\n       new PassFactory(\"checkMissingGetCssName\", true) {\n     @Override\n     protected CompilerPass createInternal(AbstractCompiler compiler) {\n    * replacement values for the classnames.  If null, the raw class names are\n    * inlined.\n    */\n-  private final PassFactory closureReplaceGetCssName =\n+  final PassFactory closureReplaceGetCssName =\n       new PassFactory(\"renameCssNames\", true) {\n     @Override\n     protected CompilerPass createInternal(final AbstractCompiler compiler) {\n    * Creates synthetic blocks to prevent FoldConstants from moving code\n    * past markers in the source.\n    */\n-  private final PassFactory createSyntheticBlocks =\n+  final PassFactory createSyntheticBlocks =\n       new PassFactory(\"createSyntheticBlocks\", true) {\n     @Override\n     protected CompilerPass createInternal(AbstractCompiler compiler) {\n   };\n \n   /** Various peephole optimizations. */\n-  private final PassFactory peepholeOptimizations =\n+  final PassFactory peepholeOptimizations =\n       new PassFactory(\"peepholeOptimizations\", false) {\n     @Override\n     protected CompilerPass createInternal(AbstractCompiler compiler) {\n   };\n \n   /** Same as peepholeOptimizations but aggressively merges code together */\n-  private final PassFactory latePeepholeOptimizations =\n+  final PassFactory latePeepholeOptimizations =\n       new PassFactory(\"peepholeOptimizations\", false) {\n     @Override\n     protected CompilerPass createInternal(AbstractCompiler compiler) {\n   };\n \n   /** Checks that all variables are defined. */\n-  private final HotSwapPassFactory checkVars =\n+  final HotSwapPassFactory checkVars =\n       new HotSwapPassFactory(\"checkVars\", true) {\n     @Override\n     protected HotSwapCompilerPass createInternal(AbstractCompiler compiler) {\n   };\n \n   /** Checks for RegExp references. */\n-  private final PassFactory checkRegExp =\n+  final PassFactory checkRegExp =\n       new PassFactory(\"checkRegExp\", true) {\n     @Override\n     protected CompilerPass createInternal(final AbstractCompiler compiler) {\n   };\n \n   /** Checks that no vars are illegally shadowed. */\n-  private final PassFactory checkShadowVars =\n+  final PassFactory checkShadowVars =\n       new PassFactory(\"variableShadowDeclarationCheck\", true) {\n     @Override\n     protected CompilerPass createInternal(AbstractCompiler compiler) {\n   };\n \n   /** Checks that references to variables look reasonable. */\n-  private final HotSwapPassFactory checkVariableReferences =\n+  final HotSwapPassFactory checkVariableReferences =\n       new HotSwapPassFactory(\"checkVariableReferences\", true) {\n     @Override\n     protected HotSwapCompilerPass createInternal(AbstractCompiler compiler) {\n   };\n \n   /** Pre-process goog.testing.ObjectPropertyString. */\n-  private final PassFactory objectPropertyStringPreprocess =\n+  final PassFactory objectPropertyStringPreprocess =\n       new PassFactory(\"ObjectPropertyStringPreprocess\", true) {\n     @Override\n     protected CompilerPass createInternal(AbstractCompiler compiler) {\n };\n \n   /** Checks type usage */\n-  private final HotSwapPassFactory checkTypes =\n+  final HotSwapPassFactory checkTypes =\n       new HotSwapPassFactory(\"checkTypes\", false) {\n     @Override\n     protected HotSwapCompilerPass createInternal(final AbstractCompiler\n    * Checks possible execution paths of the program for problems: missing return\n    * statements and dead code.\n    */\n-  private final HotSwapPassFactory checkControlFlow =\n+  final HotSwapPassFactory checkControlFlow =\n       new HotSwapPassFactory(\"checkControlFlow\", true) {\n     @Override\n     protected HotSwapCompilerPass createInternal(AbstractCompiler compiler) {\n   };\n \n   /** Checks access controls. Depends on type-inference. */\n-  private final HotSwapPassFactory checkAccessControls =\n+  final HotSwapPassFactory checkAccessControls =\n       new HotSwapPassFactory(\"checkAccessControls\", true) {\n     @Override\n     protected HotSwapCompilerPass createInternal(AbstractCompiler compiler) {\n   }\n \n   /** A compiler pass that resolves types in the global scope. */\n-  private class GlobalTypeResolver implements HotSwapCompilerPass {\n+  class GlobalTypeResolver implements HotSwapCompilerPass {\n     private final AbstractCompiler compiler;\n \n     GlobalTypeResolver(AbstractCompiler compiler) {\n   }\n \n   /** Checks global name usage. */\n-  private final PassFactory checkGlobalNames =\n+  final PassFactory checkGlobalNames =\n       new PassFactory(\"Check names\", true) {\n     @Override\n     protected CompilerPass createInternal(final AbstractCompiler compiler) {\n   };\n \n   /** Checks that the code is ES5 or Caja compliant. */\n-  private final PassFactory checkStrictMode =\n+  final PassFactory checkStrictMode =\n       new PassFactory(\"checkStrictMode\", true) {\n     @Override\n     protected CompilerPass createInternal(AbstractCompiler compiler) {\n   };\n \n   /** Checks that all constants are not modified */\n-  private final PassFactory checkConsts =\n+  final PassFactory checkConsts =\n       new PassFactory(\"checkConsts\", true) {\n     @Override\n     protected CompilerPass createInternal(AbstractCompiler compiler) {\n   };\n \n   /** Computes the names of functions for later analysis. */\n-  private final PassFactory computeFunctionNames =\n+  final PassFactory computeFunctionNames =\n       new PassFactory(\"computeFunctionNames\", true) {\n     @Override\n     protected CompilerPass createInternal(AbstractCompiler compiler) {\n   };\n \n   /** Skips Caja-private properties in for-in loops */\n-  private final PassFactory ignoreCajaProperties =\n+  final PassFactory ignoreCajaProperties =\n       new PassFactory(\"ignoreCajaProperties\", true) {\n     @Override\n     protected CompilerPass createInternal(AbstractCompiler compiler) {\n   };\n \n   /** Inserts runtime type assertions for debugging. */\n-  private final PassFactory runtimeTypeCheck =\n+  final PassFactory runtimeTypeCheck =\n       new PassFactory(\"runtimeTypeCheck\", true) {\n     @Override\n     protected CompilerPass createInternal(AbstractCompiler compiler) {\n   };\n \n   /** Generates unique ids. */\n-  private final PassFactory replaceIdGenerators =\n+  final PassFactory replaceIdGenerators =\n       new PassFactory(\"replaceIdGenerators\", true) {\n     @Override\n     protected CompilerPass createInternal(final AbstractCompiler compiler) {\n   };\n \n   /** Replace strings. */\n-  private final PassFactory replaceStrings =\n+  final PassFactory replaceStrings =\n       new PassFactory(\"replaceStrings\", true) {\n     @Override\n     protected CompilerPass createInternal(final AbstractCompiler compiler) {\n   };\n \n   /** Optimizes the \"arguments\" array. */\n-  private final PassFactory optimizeArgumentsArray =\n+  final PassFactory optimizeArgumentsArray =\n       new PassFactory(\"optimizeArgumentsArray\", true) {\n     @Override\n     protected CompilerPass createInternal(AbstractCompiler compiler) {\n   };\n \n   /** Remove variables set to goog.abstractMethod. */\n-  private final PassFactory closureCodeRemoval =\n+  final PassFactory closureCodeRemoval =\n       new PassFactory(\"closureCodeRemoval\", true) {\n     @Override\n     protected CompilerPass createInternal(final AbstractCompiler compiler) {\n   };\n \n   /** Special case optimizations for closure functions. */\n-  private final PassFactory closureOptimizePrimitives =\n+  final PassFactory closureOptimizePrimitives =\n       new PassFactory(\"closureOptimizePrimitives\", true) {\n     @Override\n     protected CompilerPass createInternal(final AbstractCompiler compiler) {\n   };\n \n   /** Collapses names in the global scope. */\n-  private final PassFactory collapseProperties =\n+  final PassFactory collapseProperties =\n       new PassFactory(\"collapseProperties\", true) {\n     @Override\n     protected CompilerPass createInternal(AbstractCompiler compiler) {\n   };\n \n   /** Rewrite properties as variables. */\n-  private final PassFactory collapseObjectLiterals =\n+  final PassFactory collapseObjectLiterals =\n       new PassFactory(\"collapseObjectLiterals\", false) {\n     @Override\n     protected CompilerPass createInternal(AbstractCompiler compiler) {\n    * Try to infer the actual types, which may be narrower\n    * than the declared types.\n    */\n-  private final PassFactory tightenTypesBuilder =\n+  final PassFactory tightenTypesBuilder =\n       new PassFactory(\"tightenTypes\", true) {\n     @Override\n     protected CompilerPass createInternal(AbstractCompiler compiler) {\n   };\n \n   /** Devirtualize property names based on type information. */\n-  private final PassFactory disambiguateProperties =\n+  final PassFactory disambiguateProperties =\n       new PassFactory(\"disambiguateProperties\", true) {\n     @Override\n     protected CompilerPass createInternal(AbstractCompiler compiler) {\n   /**\n    * Chain calls to functions that return this.\n    */\n-  private final PassFactory chainCalls =\n+  final PassFactory chainCalls =\n       new PassFactory(\"chainCalls\", true) {\n     @Override\n     protected CompilerPass createInternal(AbstractCompiler compiler) {\n    * Rewrite instance methods as static methods, to make them easier\n    * to inline.\n    */\n-  private final PassFactory devirtualizePrototypeMethods =\n+  final PassFactory devirtualizePrototypeMethods =\n       new PassFactory(\"devirtualizePrototypeMethods\", true) {\n     @Override\n     protected CompilerPass createInternal(AbstractCompiler compiler) {\n    * Optimizes unused function arguments, unused return values, and inlines\n    * constant parameters. Also runs RemoveUnusedVars.\n    */\n-  private final PassFactory optimizeCallsAndRemoveUnusedVars =\n+  final PassFactory optimizeCallsAndRemoveUnusedVars =\n       new PassFactory(\"optimizeCalls_and_removeUnusedVars\", false) {\n     @Override\n     protected CompilerPass createInternal(AbstractCompiler compiler) {\n    * Look for function calls that are pure, and annotate them\n    * that way.\n    */\n-  private final PassFactory markPureFunctions =\n+  final PassFactory markPureFunctions =\n       new PassFactory(\"markPureFunctions\", true) {\n     @Override\n     protected CompilerPass createInternal(AbstractCompiler compiler) {\n    * Look for function calls that have no side effects, and annotate them\n    * that way.\n    */\n-  private final PassFactory markNoSideEffectCalls =\n+  final PassFactory markNoSideEffectCalls =\n       new PassFactory(\"markNoSideEffectCalls\", true) {\n     @Override\n     protected CompilerPass createInternal(AbstractCompiler compiler) {\n   };\n \n   /** Inlines variables heuristically. */\n-  private final PassFactory inlineVariables =\n+  final PassFactory inlineVariables =\n       new PassFactory(\"inlineVariables\", false) {\n     @Override\n     protected CompilerPass createInternal(AbstractCompiler compiler) {\n   };\n \n   /** Inlines variables that are marked as constants. */\n-  private final PassFactory inlineConstants =\n+  final PassFactory inlineConstants =\n       new PassFactory(\"inlineConstants\", false) {\n     @Override\n     protected CompilerPass createInternal(AbstractCompiler compiler) {\n   /**\n    * Perform local control flow optimizations.\n    */\n-  private final PassFactory minimizeExitPoints =\n+  final PassFactory minimizeExitPoints =\n       new PassFactory(\"minimizeExitPoints\", false) {\n     @Override\n     protected CompilerPass createInternal(AbstractCompiler compiler) {\n   /**\n    * Use data flow analysis to remove dead branches.\n    */\n-  private final PassFactory removeUnreachableCode =\n+  final PassFactory removeUnreachableCode =\n       new PassFactory(\"removeUnreachableCode\", false) {\n     @Override\n     protected CompilerPass createInternal(AbstractCompiler compiler) {\n   /**\n    * Remove prototype properties that do not appear to be used.\n    */\n-  private final PassFactory removeUnusedPrototypeProperties =\n+  final PassFactory removeUnusedPrototypeProperties =\n       new PassFactory(\"removeUnusedPrototypeProperties\", false) {\n     @Override\n     protected CompilerPass createInternal(AbstractCompiler compiler) {\n    * Process smart name processing - removes unused classes and does referencing\n    * starting with minimum set of names.\n    */\n-  private final PassFactory smartNamePass =\n+  final PassFactory smartNamePass =\n       new PassFactory(\"smartNamePass\", true) {\n     @Override\n     protected CompilerPass createInternal(final AbstractCompiler compiler) {\n    * Process smart name processing - removes unused classes and does referencing\n    * starting with minimum set of names.\n    */\n-  private final PassFactory smartNamePass2 =\n+  final PassFactory smartNamePass2 =\n       new PassFactory(\"smartNamePass\", true) {\n     @Override\n     protected CompilerPass createInternal(final AbstractCompiler compiler) {\n   };\n \n   /** Inlines simple methods, like getters */\n-  private final PassFactory inlineSimpleMethods =\n+  final PassFactory inlineSimpleMethods =\n       new PassFactory(\"inlineSimpleMethods\", false) {\n     @Override\n     protected CompilerPass createInternal(AbstractCompiler compiler) {\n   };\n \n   /** Kills dead assignments. */\n-  private final PassFactory deadAssignmentsElimination =\n+  final PassFactory deadAssignmentsElimination =\n       new PassFactory(\"deadAssignmentsElimination\", false) {\n     @Override\n     protected CompilerPass createInternal(AbstractCompiler compiler) {\n   };\n \n   /** Inlines function calls. */\n-  private final PassFactory inlineFunctions =\n+  final PassFactory inlineFunctions =\n       new PassFactory(\"inlineFunctions\", false) {\n     @Override\n     protected CompilerPass createInternal(AbstractCompiler compiler) {\n   };\n \n   /** Removes variables that are never used. */\n-  private final PassFactory removeUnusedVars =\n+  final PassFactory removeUnusedVars =\n       new PassFactory(\"removeUnusedVars\", false) {\n     @Override\n     protected CompilerPass createInternal(AbstractCompiler compiler) {\n   /**\n    * Move global symbols to a deeper common module\n    */\n-  private final PassFactory crossModuleCodeMotion =\n+  final PassFactory crossModuleCodeMotion =\n       new PassFactory(\"crossModuleCodeMotion\", false) {\n     @Override\n     protected CompilerPass createInternal(AbstractCompiler compiler) {\n   /**\n    * Move methods to a deeper common module\n    */\n-  private final PassFactory crossModuleMethodMotion =\n+  final PassFactory crossModuleMethodMotion =\n       new PassFactory(\"crossModuleMethodMotion\", false) {\n     @Override\n     protected CompilerPass createInternal(AbstractCompiler compiler) {\n   /**\n    * Specialize the initial module at the cost of later modules\n    */\n-  private final PassFactory specializeInitialModule =\n+  final PassFactory specializeInitialModule =\n       new PassFactory(\"specializeInitialModule\", true) {\n     @Override\n     protected CompilerPass createInternal(AbstractCompiler compiler) {\n   };\n \n   /** A data-flow based variable inliner. */\n-  private final PassFactory flowSensitiveInlineVariables =\n+  final PassFactory flowSensitiveInlineVariables =\n       new PassFactory(\"flowSensitiveInlineVariables\", true) {\n     @Override\n     protected CompilerPass createInternal(AbstractCompiler compiler) {\n   };\n \n   /** Uses register-allocation algorithms to use fewer variables. */\n-  private final PassFactory coalesceVariableNames =\n+  final PassFactory coalesceVariableNames =\n       new PassFactory(\"coalesceVariableNames\", true) {\n     @Override\n     protected CompilerPass createInternal(AbstractCompiler compiler) {\n    * Some simple, local collapses (e.g., {@code var x; var y;} becomes\n    * {@code var x,y;}.\n    */\n-  private final PassFactory exploitAssign =\n+  final PassFactory exploitAssign =\n       new PassFactory(\"expointAssign\", true) {\n     @Override\n     protected CompilerPass createInternal(AbstractCompiler compiler) {\n    * Some simple, local collapses (e.g., {@code var x; var y;} becomes\n    * {@code var x,y;}.\n    */\n-  private final PassFactory collapseVariableDeclarations =\n+  final PassFactory collapseVariableDeclarations =\n       new PassFactory(\"collapseVariableDeclarations\", true) {\n     @Override\n     protected CompilerPass createInternal(AbstractCompiler compiler) {\n   /**\n    * Simple global collapses of variable declarations.\n    */\n-  private final PassFactory groupVariableDeclarations =\n+  final PassFactory groupVariableDeclarations =\n       new PassFactory(\"groupVariableDeclarations\", true) {\n     @Override\n     protected CompilerPass createInternal(AbstractCompiler compiler) {\n   /**\n    * Extracts common sub-expressions.\n    */\n-  private final PassFactory extractPrototypeMemberDeclarations =\n+  final PassFactory extractPrototypeMemberDeclarations =\n       new PassFactory(\"extractPrototypeMemberDeclarations\", true) {\n     @Override\n     protected CompilerPass createInternal(AbstractCompiler compiler) {\n   };\n \n   /** Rewrites common function definitions to be more compact. */\n-  private final PassFactory rewriteFunctionExpressions =\n+  final PassFactory rewriteFunctionExpressions =\n       new PassFactory(\"rewriteFunctionExpressions\", true) {\n     @Override\n     protected CompilerPass createInternal(AbstractCompiler compiler) {\n   };\n \n   /** Collapses functions to not use the VAR keyword. */\n-  private final PassFactory collapseAnonymousFunctions =\n+  final PassFactory collapseAnonymousFunctions =\n       new PassFactory(\"collapseAnonymousFunctions\", true) {\n     @Override\n     protected CompilerPass createInternal(AbstractCompiler compiler) {\n   };\n \n   /** Moves function declarations to the top, to simulate actual hoisting. */\n-  private final PassFactory moveFunctionDeclarations =\n+  final PassFactory moveFunctionDeclarations =\n       new PassFactory(\"moveFunctionDeclarations\", true) {\n     @Override\n     protected CompilerPass createInternal(AbstractCompiler compiler) {\n     }\n   };\n \n-  private final PassFactory nameUnmappedAnonymousFunctions =\n+  final PassFactory nameUnmappedAnonymousFunctions =\n       new PassFactory(\"nameAnonymousFunctions\", true) {\n     @Override\n     protected CompilerPass createInternal(AbstractCompiler compiler) {\n     }\n   };\n \n-  private final PassFactory nameMappedAnonymousFunctions =\n+  final PassFactory nameMappedAnonymousFunctions =\n       new PassFactory(\"nameAnonymousFunctions\", true) {\n     @Override\n     protected CompilerPass createInternal(final AbstractCompiler compiler) {\n     }\n   };\n \n-  private final PassFactory operaCompoundAssignFix =\n+  final PassFactory operaCompoundAssignFix =\n       new PassFactory(\"operaCompoundAssignFix\", true) {\n     @Override\n     protected CompilerPass createInternal(AbstractCompiler compiler) {\n   };\n \n   /** Alias external symbols. */\n-  private final PassFactory aliasExternals =\n+  final PassFactory aliasExternals =\n       new PassFactory(\"aliasExternals\", true) {\n     @Override\n     protected CompilerPass createInternal(AbstractCompiler compiler) {\n    * Alias string literals with global variables, to avoid creating lots of\n    * transient objects.\n    */\n-  private final PassFactory aliasStrings =\n+  final PassFactory aliasStrings =\n       new PassFactory(\"aliasStrings\", true) {\n     @Override\n     protected CompilerPass createInternal(AbstractCompiler compiler) {\n   };\n \n   /** Aliases common keywords (true, false) */\n-  private final PassFactory aliasKeywords =\n+  final PassFactory aliasKeywords =\n       new PassFactory(\"aliasKeywords\", true) {\n     @Override\n     protected CompilerPass createInternal(AbstractCompiler compiler) {\n   };\n \n   /** Handling for the ObjectPropertyString primitive. */\n-  private final PassFactory objectPropertyStringPostprocess =\n+  final PassFactory objectPropertyStringPostprocess =\n       new PassFactory(\"ObjectPropertyStringPostprocess\", true) {\n     @Override\n     protected CompilerPass createInternal(AbstractCompiler compiler) {\n    * Renames properties so that the two properties that never appear on\n    * the same object get the same name.\n    */\n-  private final PassFactory ambiguateProperties =\n+  final PassFactory ambiguateProperties =\n       new PassFactory(\"ambiguateProperties\", true) {\n     @Override\n     protected CompilerPass createInternal(AbstractCompiler compiler) {\n   /**\n    * Mark the point at which the normalized AST assumptions no longer hold.\n    */\n-  private final PassFactory markUnnormalized =\n+  final PassFactory markUnnormalized =\n       new PassFactory(\"markUnnormalized\", true) {\n     @Override\n     protected CompilerPass createInternal(final AbstractCompiler compiler) {\n   };\n \n   /** Denormalize the AST for code generation. */\n-  private final PassFactory denormalize =\n+  final PassFactory denormalize =\n       new PassFactory(\"denormalize\", true) {\n     @Override\n     protected CompilerPass createInternal(AbstractCompiler compiler) {\n   };\n \n   /** Inverting name normalization. */\n-  private final PassFactory invertContextualRenaming =\n+  final PassFactory invertContextualRenaming =\n       new PassFactory(\"invertNames\", true) {\n     @Override\n     protected CompilerPass createInternal(AbstractCompiler compiler) {\n   /**\n    * Renames properties.\n    */\n-  private final PassFactory renameProperties =\n+  final PassFactory renameProperties =\n       new PassFactory(\"renameProperties\", true) {\n     @Override\n     protected CompilerPass createInternal(final AbstractCompiler compiler) {\n   }\n \n   /** Renames variables. */\n-  private final PassFactory renameVars =\n+  final PassFactory renameVars =\n       new PassFactory(\"renameVars\", true) {\n     @Override\n     protected CompilerPass createInternal(final AbstractCompiler compiler) {\n   }\n \n   /** Renames labels */\n-  private final PassFactory renameLabels =\n+  final PassFactory renameLabels =\n       new PassFactory(\"renameLabels\", true) {\n     @Override\n     protected CompilerPass createInternal(AbstractCompiler compiler) {\n   };\n \n   /** Convert bracket access to dot access */\n-  private final PassFactory convertToDottedProperties =\n+  final PassFactory convertToDottedProperties =\n       new PassFactory(\"convertToDottedProperties\", true) {\n     @Override\n     protected CompilerPass createInternal(AbstractCompiler compiler) {\n   };\n \n   /** Checks that all variables are defined. */\n-  private final PassFactory sanityCheckAst =\n+  final PassFactory sanityCheckAst =\n       new PassFactory(\"sanityCheckAst\", true) {\n     @Override\n     protected CompilerPass createInternal(AbstractCompiler compiler) {\n   };\n \n   /** Checks that all variables are defined. */\n-  private final PassFactory sanityCheckVars =\n+  final PassFactory sanityCheckVars =\n       new PassFactory(\"sanityCheckVars\", true) {\n     @Override\n     protected CompilerPass createInternal(AbstractCompiler compiler) {\n   };\n \n   /** Adds instrumentations according to an instrumentation template. */\n-  private final PassFactory instrumentFunctions =\n+  final PassFactory instrumentFunctions =\n       new PassFactory(\"instrumentFunctions\", true) {\n     @Override\n     protected CompilerPass createInternal(final AbstractCompiler compiler) {\n     return additionalReplacements;\n   }\n \n-  private final PassFactory printNameReferenceGraph =\n+  final PassFactory printNameReferenceGraph =\n     new PassFactory(\"printNameReferenceGraph\", true) {\n     @Override\n     protected CompilerPass createInternal(final AbstractCompiler compiler) {\n     }\n   };\n \n-  private final PassFactory printNameReferenceReport =\n+  final PassFactory printNameReferenceReport =\n       new PassFactory(\"printNameReferenceReport\", true) {\n     @Override\n     protected CompilerPass createInternal(final AbstractCompiler compiler) {", "timestamp": 1309380280, "metainfo": ""}