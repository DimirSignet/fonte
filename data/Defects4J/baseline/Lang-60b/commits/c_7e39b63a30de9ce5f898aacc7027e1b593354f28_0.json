{"sha": "7e39b63a30de9ce5f898aacc7027e1b593354f28", "log": "Refactor code in ToStringBuilder.reflectionToString(...) into a new subclass called ReflectionToStringBuilder. All of the ToStringBuilder.reflectionToString(...) forward their calls to equivalent methods in ReflectionToStringBuilde. ReflectionToStringBuilder can  be subclassed to provide Field or value filtering. Since the unit tests exercis ToStringBuilder.reflectionToString(...) which then forwards those calls to ReflectionToStringBuilder, and ReflectionToStringBuilder does not provide new features (yet), there are no new unit test cases (yet).   ", "commit": "\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang/builder/ReflectionToStringBuilder.java\n+package org.apache.commons.lang.builder;\n+\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Modifier;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import org.apache.commons.lang.ClassUtils;\n+\n+/**\n+ * <p>Builds <code>toString()</code> values using reflection.</p>\n+ *\n+ * <p>This class uses reflection to determine the fields to append. \n+ * Because these fields are usually private, the class, \n+ * uses <code>Field.setAccessible</code> to\n+ * change the visibility of the fields. This will fail under a security manager,\n+ * unless the appropriate permissions are set up correctly.</p>\n+ *\n+ * <p>A typical invocation for this method would look like:</p>\n+ * <pre>\n+ * public String toString() {\n+ *   return ReflectionToStringBuilder.toString(this);\n+ * }\n+ * </pre>\n+ *\n+ * <p>You can also use the builder to debug 3rd party objects:</p>\n+ * <pre>\n+ * System.out.println(\"An object: \" + ReflectionToStringBuilder.toString(anObject));\n+ * </pre>\n+ * \n+ * <p>A subclass can control field output by overriding the methods:\n+ * <ul> \n+ * <li>{@link #accept(java.lang.reflect.Field)}</li>\n+ * <li>{@link #getValue(java.lang.reflect.Field)}</li>\n+ * </ul>\n+ * </p>\n+ * \n+ * <p>The exact format of the <code>toString</code> is determined by\n+ * the {@link ToStringStyle} passed into the constructor.</p>\n+ *\n+ * @author <a href=\"mailto:ggregory@seagullsw.com\">Gary Gregory</a>\n+ * @author Stephen Colebourne\n+ * @since 2.0\n+ * @version $Id: ReflectionToStringBuilder.java,v 1.1 2003/06/03 03:51:56 ggregory Exp $\n+ */\n+public class ReflectionToStringBuilder extends ToStringBuilder {\n+\n+    /**\n+     * A registry of objects used by <code>reflectionToString</code> methods to detect cyclical object references \n+     * and avoid infinite loops.\n+     */\n+    private static ThreadLocal registry = new ThreadLocal() {\n+        protected synchronized Object initialValue() {\n+            // The HashSet implementation is not synchronized, \n+            // which is just what we need here. \n+            return new HashSet();\n+        }\n+    };\n+\n+    /**\n+     * Returns the registry of objects being traversed by the \n+     * <code>reflectionToString</code> methods in the current thread.\n+     * @return Set the registry of objects being traversed \n+     */\n+    static Set getRegistry() {\n+        return (Set) registry.get();\n+    }\n+\n+    /**\n+     * Returns <code>true</code> if the registry contains the given object.\n+     * Used by the reflection methods to avoid infinite loops.\n+     * \n+     * @param value The object to lookup in the registry.\n+     * @return boolean <code>true</code> if the registry contains the given object.\n+     */\n+    static boolean isRegistered(Object value) {\n+        return getRegistry().contains(value);\n+    }\n+\n+    /**\n+     * Registers the given object.\n+     * Used by the reflection methods to avoid infinite loops.\n+     * \n+     * @param value The object to register.\n+     */\n+    static void register(Object value) {\n+        getRegistry().add(value);\n+    }\n+    \n+    /**\n+     * <p>This method uses reflection to build a suitable\n+     * <code>toString</code> using the default <code>ToStringStyle</code>.\n+     *\n+     * <p>It uses <code>Field.setAccessible</code> to gain access to private\n+     * fields. This means that it will throw a security exception if run\n+     * under a security manger, if the permissions are not set up correctly.\n+     * It is also not as efficient as testing explicitly.</p>\n+     *\n+     * <p>Transient members will be not be included, as they are likely derived.\n+     * Static fields will not be included. Superclass fields will be appended.</p>\n+     *\n+     * @param object  the Object to be output\n+     * @return the String result\n+     * @throws IllegalArgumentException if the Object is <code>null</code>\n+     */\n+    public static String toString(Object object) {\n+        return toString(object, null, false, null);\n+    }\n+\n+    /**\n+     * <p>This method uses reflection to build a suitable\n+     * <code>toString</code>.</p>\n+     *\n+     * <p>It uses <code>Field.setAccessible</code> to gain access to private\n+     * fields. This means that it will throw a security exception if run\n+     * under a security manger, if the permissions are not set up correctly.\n+     * It is also not as efficient as testing explicitly.</p>\n+     *\n+     * <p>Transient members will be not be included, as they are likely derived.\n+     * Static fields will not be included. Superclass fields will be appended.</p>\n+     *\n+     * <p>If the style is <code>null</code>, the default\n+     * <code>ToStringStyle</code> is used.</p>\n+     * \n+     * @param object  the Object to be output\n+     * @param style  the style of the <code>toString</code> to create,\n+     *  may be <code>null</code>\n+     * @return the String result\n+     * @throws IllegalArgumentException if the Object or\n+     *  <code>ToStringStyle</code> is <code>null</code>\n+     */\n+    public static String toString(Object object, ToStringStyle style) {\n+        return toString(object, style, false, null);\n+    }\n+\n+    /**\n+     * <p>This method uses reflection to build a suitable\n+     * <code>toString</code>.</p>\n+     *\n+     * <p>It uses <code>Field.setAccessible</code> to gain access to private\n+     * fields. This means that it will throw a security exception if run\n+     * under a security manger, if the permissions are not set up correctly.\n+     * It is also not as efficient as testing explicitly. </p>\n+     *\n+     * <p>If the <code>outputTransients</code> is <code>true</code>,\n+     * transient members will be output, otherwise they are ignored,\n+     * as they are likely derived fields, and not part of the value of the\n+     * Object.</p>\n+     *\n+     * <p>Static fields will not be included. Superclass fields will be appended.</p>\n+     *\n+     * <p>\n+     * If the style is <code>null</code>, the default\n+     * <code>ToStringStyle</code> is used.</p>\n+     * \n+     * @param object  the Object to be output\n+     * @param style  the style of the <code>toString</code> to create,\n+     *  may be <code>null</code>\n+     * @param outputTransients  whether to include transient fields\n+     * @return the String result\n+     * @throws IllegalArgumentException if the Object is <code>null</code>\n+     */\n+    public static String toString(Object object, ToStringStyle style, boolean outputTransients) {\n+        return toString(object, style, outputTransients, null);\n+    }\n+\n+    /**\n+     * <p>This method uses reflection to build a suitable\n+     * <code>toString</code>.</p>\n+     *\n+     * <p>It uses <code>Field.setAccessible</code> to gain access to private\n+     * fields. This means that it will throw a security exception if run\n+     * under a security manger, if the permissions are not set up correctly.\n+     * It is also not as efficient as testing explicitly. </p>\n+     *\n+     * <p>If the <code>outputTransients</code> is <code>true</code>,\n+     * transient members will be output, otherwise they are ignored,\n+     * as they are likely derived fields, and not part of the value of the\n+     * Object.</p>\n+     *\n+     * <p>Static fields will not be included. Superclass fields will be appended\n+     * up to and including the specified superclass. A null superclass is treated\n+     * as <code>java.lang.Object</code>.</p>\n+     *\n+     * <p>If the style is <code>null</code>, the default\n+     * <code>ToStringStyle</code> is used.</p>\n+     * \n+     * @param object  the Object to be output\n+     * @param style  the style of the <code>toString</code> to create,\n+     *  may be <code>null</code>\n+     * @param outputTransients  whether to include transient fields\n+     * @param reflectUpToClass  the superclass to reflect up to (inclusive), may be null\n+     * @return the String result\n+     * @throws IllegalArgumentException if the Object is <code>null</code>\n+     */\n+    public static String toString(\n+        Object object,\n+        ToStringStyle style,\n+        boolean outputTransients,\n+        Class reflectUpToClass) {\n+        return new ReflectionToStringBuilder(object, style, null, reflectUpToClass, outputTransients).toString();\n+    }\n+\n+    /**\n+     * Unregisters the given object.\n+     * Used by the reflection methods to avoid infinite loops.\n+     * \n+     * @param value The object to unregister.\n+     */\n+    static void unregister(Object value) {\n+        getRegistry().remove(value);\n+    }\n+\n+    /**\n+     * Whether or not to append transient fields.\n+     */\n+    private boolean appendTransients = false;\n+\n+    /**\n+     * The last super class to stop appending fields for.\n+     */\n+    private Class upToClass = null;\n+\n+    /**\n+     * <p>Constructs a new instance.</p>\n+     *\n+     * <p>This constructor outputs using the default style set with\n+     * <code>setDefaultStyle</code>.</p>\n+     * \n+     * @param object  the Object to build a <code>toString</code> for,\n+     *  must not be <code>null</code>\n+     * @throws IllegalArgumentException  if the Object passed in is\n+     *  <code>null</code>\n+     */\n+    public ReflectionToStringBuilder(Object object) {\n+        super(object);\n+    }\n+\n+    /**\n+     * <p>Constructor specifying the output style.</p>\n+     *\n+     * <p>If the style is <code>null</code>, the default style is used.</p>\n+     * \n+     * @param object  the Object to build a <code>toString</code> for,\n+     *  must not be <code>null</code>\n+     * @param style  the style of the <code>toString</code> to create,\n+     *  may be <code>null</code>\n+     * @throws IllegalArgumentException  if the Object passed in is\n+     *  <code>null</code>\n+     */\n+    public ReflectionToStringBuilder(Object object, ToStringStyle style) {\n+        super(object, style);\n+    }\n+\n+    /**\n+     * <p>Constructors a new instance.</p>\n+     *\n+     * <p>If the style is <code>null</code>, the default style is used.</p>\n+     *\n+     * <p>If the buffer is <code>null</code>, a new one is created.</p>\n+     * \n+     * @param object  the Object to build a <code>toString</code> for,\n+     *  must not be <code>null</code>\n+     * @param style  the style of the <code>toString</code> to create,\n+     *  may be <code>null</code>\n+     * @param buffer  the <code>StringBuffer</code> to populate, may be\n+     *  <code>null</code>\n+     * @throws IllegalArgumentException  if the Object passed in is\n+     *  <code>null</code>\n+     */\n+    public ReflectionToStringBuilder(Object object, ToStringStyle style, StringBuffer buffer) {\n+        super(object, style, buffer);\n+    }\n+\n+    /**\n+     * Constructs a new instance.\n+     * \n+     * @param object  the Object to build a <code>toString</code> for,\n+     *  must not be <code>null</code>\n+     * @param style  the style of the <code>toString</code> to create,\n+     *  may be <code>null</code>\n+     * @param buffer  the <code>StringBuffer</code> to populate, may be\n+     *  <code>null</code>\n+     */\n+    public ReflectionToStringBuilder(\n+        Object object,\n+        ToStringStyle style,\n+        StringBuffer buffer,\n+        Class reflectUpToClass,\n+        boolean outputTransients) {\n+        super(object, style, buffer);\n+        this.setUpToClass(reflectUpToClass);\n+        this.setAppendTransients(outputTransients);\n+    }\n+\n+    /**\n+     * Returns whether or not to append the given <code>Field</code>.\n+     * <ul>\n+     * <li>Static fields are not appended.</li>\n+     * <li>Transient fields are appended only if {@link #isAppendTransients()} returns <code>true</code>.\n+     * <li>Inner class fields are not appened.</li>\n+     * </ul>\n+     * @param field The Field to test.\n+     * @return Whether or not to append the given <code>Field</code>.\n+     */\n+    protected boolean accept(Field field) {\n+        String fieldName = field.getName();\n+        return (fieldName.indexOf(ClassUtils.INNER_CLASS_SEPARATOR_CHAR) == -1)\n+            && (this.isAppendTransients() || !Modifier.isTransient(field.getModifiers()))\n+            && (!Modifier.isStatic(field.getModifiers()));\n+    }\n+\n+    /**\n+     * Appends the fields and values defined by the given object of the\n+     * given Class. If a cycle is detected as an objects is \"toString()'ed\",\n+     * such an object is rendered as if <code>Object.toString()</code> \n+     * had been called and not implemented by the object.\n+     * \n+     * @param clazz The class of object parameter\n+     */\n+    protected void appendFieldsIn(Class clazz) {\n+        if (isRegistered(this.getObject())) {\n+            // The object has already been appended, therefore we have an object cycle. \n+            // Append a simple Object.toString style string. The field name is already appended at this point.\n+            this.appendAsObjectToString(this.getObject());\n+            return;\n+        }\n+        try {\n+            this.registerObject();\n+            if (clazz.isArray()) {\n+                this.reflectionAppendArray(this.getObject());\n+                return;\n+            }\n+            Field[] fields = clazz.getDeclaredFields();\n+            Field.setAccessible(fields, true);\n+            for (int i = 0; i < fields.length; i++) {\n+                Field field = fields[i];\n+                String fieldName = field.getName();\n+                if (this.accept(field)) {\n+                    try {\n+                        // Warning: Field.get(Object) creates wrappers objects for primitive types.\n+                        Object fieldValue = this.getValue(field);\n+                        if (isRegistered(fieldValue) && !field.getType().isPrimitive()) {\n+                            // A known field value has already been appended, therefore we have an object cycle, \n+                            // append a simple Object.toString style string.\n+                            this.getStyle().appendFieldStart(this.getStringBuffer(), fieldName);\n+                            this.appendAsObjectToString(fieldValue);\n+                            // The recursion out of \n+                            //    builder.append(fieldName, fieldValue); \n+                            // below will append the field \n+                            // end marker.\n+                        } else {\n+                            try {\n+                                this.registerObject();\n+                                this.append(fieldName, fieldValue);\n+                            } finally {\n+                                this.unregisterObject();\n+                            }\n+                        }\n+                    } catch (IllegalAccessException ex) {\n+                        //this can't happen. Would get a Security exception instead\n+                        //throw a runtime exception in case the impossible happens.\n+                        throw new InternalError(\"Unexpected IllegalAccessException: \" + ex.getMessage());\n+                    }\n+                }\n+            }\n+        } finally {\n+            this.unregisterObject();\n+        }\n+    }\n+    \n+    /**\n+     * Gets the last super class to stop appending fields for.\n+     * \n+     * @return The last super class to stop appending fields for.\n+     */\n+    public Class getUpToClass() {\n+        return this.upToClass;\n+    }\n+\n+    /**\n+     * Calls <code>java.lang.reflect.Field.get(Object)</code>\n+     * @see java.lang.reflect.Field#get(Object)\n+     * @throws IllegalArgumentException\n+     * @throws IllegalAccessException\n+     */\n+    protected Object getValue(Field field) throws IllegalArgumentException, IllegalAccessException {\n+        return field.get(this.getObject());\n+    }\n+\n+    /**\n+     * Returns whether or not to append transient fields.\n+     * \n+     * @return Whether or not to append transient fields.\n+     */\n+    public boolean isAppendTransients() {\n+        return this.appendTransients;\n+    }\n+    \n+    /**\n+     * <p>Append to the <code>toString</code> an <code>Object</code>\n+     * array.</p>\n+     *\n+     * @param array  the array to add to the <code>toString</code>\n+     * @return this\n+     */\n+    public ToStringBuilder reflectionAppendArray(Object array) {\n+        this.getStyle().reflectionAppendArrayDetail(this.getStringBuffer(), null, array);\n+        return this;\n+    }\n+\n+    /**\n+     * Registers this builder's source object to avoid infinite loops processing circular object references.\n+     */\n+    void registerObject() {\n+        register(this.getObject());\n+    }\n+\n+    /**\n+     * Sets whether or not to append transient fields.\n+     * \n+     * @param appendTransients Whether or not to append transient fields.\n+     */\n+    public void setAppendTransients(boolean appendTransients) {\n+        this.appendTransients = appendTransients;\n+    }\n+\n+    /**\n+     * Sets the last super class to stop appending fields for.\n+     * \n+     * @param clazz The last super class to stop appending fields for.\n+     */\n+    public void setUpToClass(Class clazz) {\n+        this.upToClass = clazz;\n+    }\n+\n+    public String toString() {\n+        if (this.getObject() == null) {\n+            return this.getStyle().getNullText();\n+        }\n+        Class clazz = this.getObject().getClass();\n+        this.appendFieldsIn(clazz);\n+        while (clazz.getSuperclass() != null && clazz != this.getUpToClass()) {\n+            clazz = clazz.getSuperclass();\n+            this.appendFieldsIn(clazz);\n+        }\n+        return super.toString();\n+    }\n+\n+    /**\n+     * Unegisters this builder's source object to avoid infinite loops processing circular object references.\n+     */\n+    void unregisterObject() {\n+        unregister(this.getObject());\n+    }\n+\n+}\n--- a/src/java/org/apache/commons/lang/builder/ToStringBuilder.java\n+++ b/src/java/org/apache/commons/lang/builder/ToStringBuilder.java\n  * <http://www.apache.org/>.\n  */\n package org.apache.commons.lang.builder;\n-\n-import java.lang.reflect.Field;\n-import java.lang.reflect.Modifier;\n-import java.util.HashSet;\n-import java.util.Set;\n \n /**\n  * <p>Builds <code>toString()</code> values.</p>\n  * @author Stephen Colebourne\n  * @author Gary Gregory\n  * @since 1.0\n- * @version $Id: ToStringBuilder.java,v 1.21 2003/05/31 22:22:49 ggregory Exp $\n+ * @version $Id: ToStringBuilder.java,v 1.22 2003/06/03 03:51:56 ggregory Exp $\n  */\n public class ToStringBuilder {\n-    \n+\n     /**\n      * The default style of output to use\n      */\n     private static ToStringStyle defaultStyle = ToStringStyle.DEFAULT_STYLE;\n-\n-    /**\n-     * A registry of objects used by <code>reflectionToString</code> methods to detect cyclical object references \n-     * and avoid infinite loops.\n-     */\n-    private static ThreadLocal reflectionRegistry = new ThreadLocal() {\n-        protected synchronized Object initialValue() {\n-            // The HashSet implementation is not synchronized, which is just what we need here. \n-            return new HashSet();\n-        }\n-    };\n \n     //----------------------------------------------------------------------------\n \n     }\n \n     /**\n-     * Returns the registry of objects being traversed by the \n-     * <code>reflectionToString</code> methods in the current thread.\n-     * @return Set the registry of objects being traversed \n-     */\n-    static Set getReflectionRegistry() {\n-        return (Set) reflectionRegistry.get();\n-    }\n-\n-    /**\n-     * Returns <code>true</code> if the registry contains the given object.\n-     * Used by the reflection methods to avoid infinite loops.\n-     * \n-     * @param value The object to lookup in the registry.\n-     * @return boolean <code>true</code> if the registry contains the given object.\n-     */\n-    static boolean isRegistered(Object value) {\n-        return getReflectionRegistry().contains(value);\n-    }\n-\n-    /**\n-     * Appends the fields and values defined by the given object of the\n-     * given Class. If a cycle is detected as an objects is \"toString()'ed\",\n-     * such an object is rendered as if <code>Object.toString()</code> \n-     * had been called and not implemented by the object.\n-     * \n-     * @param object  the object to append details of\n-     * @param clazz  the class of object parameter\n-     * @param builder  the builder to append to\n-     * @param useTransients  whether to output transient fields\n-     */\n-    private static void reflectionAppend(Object object, Class clazz, ToStringBuilder builder, boolean useTransients) {\n-        if (isRegistered(object)) {\n-            // The object has already been appended, therefore we have an object cycle. \n-            // Append a simple Object.toString style string. The field name is already appended at this point.\n-            builder.appendAsObjectToString(object);\n-            return;\n-        }\n-        try {\n-            register(object);\n-            if (clazz.isArray()) {\n-                builder.reflectionAppendArray(object);\n-                return;\n-            }\n-            Field[] fields = clazz.getDeclaredFields();\n-            Field.setAccessible(fields, true);\n-            for (int i = 0; i < fields.length; i++) {\n-                Field f = fields[i];\n-                String fieldName = f.getName();\n-                if ((fieldName.indexOf('$') == -1)\n-                    && (useTransients || !Modifier.isTransient(f.getModifiers()))\n-                    && (!Modifier.isStatic(f.getModifiers()))) {\n-                    try {\n-                        // Warning: Field.get(Object) creates wrappers objects for primitive types.\n-                        Object fieldValue = f.get(object);\n-                        if (isRegistered(fieldValue)\n-                            && !f.getType().isPrimitive()) {\n-                            // A known field value has already been appended, therefore we have an object cycle, \n-                            // append a simple Object.toString style string.\n-                            builder.getStyle().appendFieldStart(builder.getStringBuffer(), fieldName);\n-                            builder.appendAsObjectToString(fieldValue);\n-                            // The recursion out of \n-                            //    builder.append(fieldName, fieldValue); \n-                            // below will append the field \n-                            // end marker.\n-                        } else {\n-                            try {\n-                                register(object);\n-                                builder.append(fieldName, fieldValue);\n-                            } finally {\n-                                unregister(object);\n-                            }\n-                        }\n-                    } catch (IllegalAccessException ex) {\n-                        //this can't happen. Would get a Security exception instead\n-                        //throw a runtime exception in case the impossible happens.\n-                        throw new InternalError(\"Unexpected IllegalAccessException: \" + ex.getMessage());\n-                    }\n-                }\n-            }\n-        } finally {\n-            unregister(object);\n-        }\n-    }\n-\n-    //-------------------------------------------------------------------------\n-\n-    /**\n-     * <p>This method uses reflection to build a suitable\n-     * <code>toString</code> using the default <code>ToStringStyle</code>.\n-     *\n-     * <p>It uses <code>Field.setAccessible</code> to gain access to private\n-     * fields. This means that it will throw a security exception if run\n-     * under a security manger, if the permissions are not set up correctly.\n-     * It is also not as efficient as testing explicitly.</p>\n-     *\n-     * <p>Transient members will be not be included, as they are likely derived.</p>\n-     *\n-     * <p>Static fields will not be included. Superclass fields will be appended.</p>\n-     *\n-     * @param object  the Object to be output\n-     * @return the String result\n-     * @throws IllegalArgumentException if the Object is <code>null</code>\n+     * Forwards to ReflectionToStringBuilder.\n+     * \n+     * @see ReflectionToStringBuilder#toString(Object)\n      */\n     public static String reflectionToString(Object object) {\n-        return reflectionToString(object, null, false, null);\n-    }\n-\n-    /**\n-     * <p>This method uses reflection to build a suitable\n-     * <code>toString</code>.</p>\n-     *\n-     * <p>It uses <code>Field.setAccessible</code> to gain access to private\n-     * fields. This means that it will throw a security exception if run\n-     * under a security manger, if the permissions are not set up correctly.\n-     * It is also not as efficient as testing explicitly.</p>\n-     *\n-     * <p>Transient members will be not be included, as they are likely\n-     * derived.</p>\n-     *\n-     * <p>Static fields will not be included. Superclass fields will be appended.</p>\n-     *\n-     * <p>If the style is <code>null</code>, the default\n-     * <code>ToStringStyle</code> is used.</p>\n-     * \n-     * @param object  the Object to be output\n-     * @param style  the style of the <code>toString</code> to create,\n-     *  may be <code>null</code>\n-     * @return the String result\n-     * @throws IllegalArgumentException if the Object or\n-     *  <code>ToStringStyle</code> is <code>null</code>\n+        return ReflectionToStringBuilder.toString(object);\n+    }\n+\n+    /**\n+     * Forwards to ReflectionToStringBuilder.\n+     * \n+     * @see ReflectionToStringBuilder#toString(Object,ToStringStyle)\n      */\n     public static String reflectionToString(Object object, ToStringStyle style) {\n-        return reflectionToString(object, style, false, null);\n-    }\n-\n-    /**\n-     * <p>This method uses reflection to build a suitable\n-     * <code>toString</code>.</p>\n-     *\n-     * <p>It uses <code>Field.setAccessible</code> to gain access to private\n-     * fields. This means that it will throw a security exception if run\n-     * under a security manger, if the permissions are not set up correctly.\n-     * It is also not as efficient as testing explicitly. </p>\n-     *\n-     * <p>If the <code>outputTransients</code> is <code>true</code>,\n-     * transient members will be output, otherwise they are ignored,\n-     * as they are likely derived fields, and not part of the value of the\n-     * Object.</p>\n-     *\n-     * <p>Static fields will not be included. Superclass fields will be appended.</p>\n-     *\n-     * <p>\n-     * If the style is <code>null</code>, the default\n-     * <code>ToStringStyle</code> is used.</p>\n-     * \n-     * @param object  the Object to be output\n-     * @param style  the style of the <code>toString</code> to create,\n-     *  may be <code>null</code>\n-     * @param outputTransients  whether to include transient fields\n-     * @return the String result\n-     * @throws IllegalArgumentException if the Object is <code>null</code>\n+        return ReflectionToStringBuilder.toString(object, style);\n+    }\n+\n+    /**\n+     * Forwards to ReflectionToStringBuilder.\n+     * \n+     * @see ReflectionToStringBuilder#toString(Object,ToStringStyle,boolean)\n      */\n     public static String reflectionToString(Object object, ToStringStyle style, boolean outputTransients) {\n-        return reflectionToString(object, style, outputTransients, null);\n-    }\n-\n-    /**\n-     * <p>This method uses reflection to build a suitable\n-     * <code>toString</code>.</p>\n-     *\n-     * <p>It uses <code>Field.setAccessible</code> to gain access to private\n-     * fields. This means that it will throw a security exception if run\n-     * under a security manger, if the permissions are not set up correctly.\n-     * It is also not as efficient as testing explicitly. </p>\n-     *\n-     * <p>If the <code>outputTransients</code> is <code>true</code>,\n-     * transient members will be output, otherwise they are ignored,\n-     * as they are likely derived fields, and not part of the value of the\n-     * Object.</p>\n-     *\n-     * <p>Static fields will not be included. Superclass fields will be appended\n-     * up to and including the specified superclass. A null superclass is treated\n-     * as java.lang.Object.</p>\n-     *\n-     * <p>If the style is <code>null</code>, the default\n-     * <code>ToStringStyle</code> is used.</p>\n-     * \n-     * @param object  the Object to be output\n-     * @param style  the style of the <code>toString</code> to create,\n-     *  may be <code>null</code>\n-     * @param outputTransients  whether to include transient fields\n-     * @param reflectUpToClass  the superclass to reflect up to (inclusive), may be null\n-     * @return the String result\n-     * @throws IllegalArgumentException if the Object is <code>null</code>\n+        return ReflectionToStringBuilder.toString(object, style, outputTransients, null);\n+    }\n+\n+    /**\n+     * Forwards to ReflectionToStringBuilder.\n+     * \n+     * @see ReflectionToStringBuilder#toString(Object,ToStringStyle,boolean,Class)\n      */\n     public static String reflectionToString(\n         Object object,\n         ToStringStyle style,\n         boolean outputTransients,\n         Class reflectUpToClass) {\n-        if (style == null) {\n-            style = getDefaultStyle();\n-        }\n-        if (object == null) {\n-            return style.getNullText();\n-        }\n-        ToStringBuilder builder = new ToStringBuilder(object, style);\n-        Class clazz = object.getClass();\n-        reflectionAppend(object, clazz, builder, outputTransients);\n-        while (clazz.getSuperclass() != null && clazz != reflectUpToClass) {\n-            clazz = clazz.getSuperclass();\n-            reflectionAppend(object, clazz, builder, outputTransients);\n-        }\n-        return builder.toString();\n-    }\n-\n-    /**\n-     * Registers the given object.\n-     * Used by the reflection methods to avoid infinite loops.\n-     * \n-     * @param value The object to register.\n-     */\n-    static void register(Object value) {\n-        getReflectionRegistry().add(value);\n+        return ReflectionToStringBuilder.toString(object, style, outputTransients, reflectUpToClass);\n     }\n \n     /**\n     }\n \n     /**\n-     * Unregisters the given object.\n-     * Used by the reflection methods to avoid infinite loops.\n-     * \n-     * @param value The object to unregister.\n-     */\n-    static void unregister(Object value) {\n-        getReflectionRegistry().remove(value);\n-    }\n-    \n-    /**\n-     * Current toString buffer\n+     * Current toString buffer.\n      */\n     private final StringBuffer buffer;\n-    \n-    /**\n-     * The object being output\n+\n+    /**\n+     * The object being output.\n      */\n     private final Object object;\n-    \n-    /**\n-     * The style of output to use\n+\n+    /**\n+     * The style of output to use.\n      */\n     private final ToStringStyle style;\n \n     }\n \n     /**\n-     * <p>Append to the <code>toString</code> an <code>Object</code>\n-     * array.</p>\n-     *\n-     * @param array  the array to add to the <code>toString</code>\n-     * @return this\n-     */\n-    public ToStringBuilder reflectionAppendArray(Object array) {\n-        style.reflectionAppendArrayDetail(buffer, null, array);\n-        return this;\n-    }\n-\n-    /**\n      * <p>Returns the built <code>toString</code>.</p>\n      * \n      * <p>This method appends the end of the buffer, and can only be called once.\n         return buffer.toString();\n     }\n \n+    /**\n+     * Returns the object being output.\n+     * \n+     * @return The object being output.\n+     */\n+    public Object getObject() {\n+        return object;\n+    }\n+\n }\n--- a/src/java/org/apache/commons/lang/builder/ToStringStyle.java\n+++ b/src/java/org/apache/commons/lang/builder/ToStringStyle.java\n  * the array length.</p>\n  *\n  * @author Stephen Colebourne\n+ * @author <a href=\"mailto:ggregory@seagullsw.com\">Gary Gregory</a>\n  * @since 1.0\n- * @version $Id: ToStringStyle.java,v 1.13 2003/04/18 04:57:19 bayard Exp $\n+ * @version $Id: ToStringStyle.java,v 1.14 2003/06/03 03:51:56 ggregory Exp $\n  */\n public abstract class ToStringStyle implements Serializable {\n     \n      */\n     private String arraySeparator = \",\";\n     /**\n-     * The detail for array content\n+     * The detail for array content.\n      */\n     private boolean arrayContentDetail = true;\n     /**\n      * @param detail  output detail or not\n      */\n     protected void appendInternal(StringBuffer buffer, String fieldName, Object value, boolean detail) {\n-        if (ToStringBuilder.isRegistered(value) \n+        if (ReflectionToStringBuilder.isRegistered(value) \n                 && !(value instanceof Number || value instanceof Boolean || value instanceof Character)) {\n             appendAsObjectToString(buffer, value);\n             ", "timestamp": 1054612316, "metainfo": ""}