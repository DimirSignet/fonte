{"sha": "dd2cd176597eb3acc4d16942a3a9870883366cef", "log": "Added code from Steve Downey,  with some formatting changes and minor bug fixes   ", "commit": "\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang/builder/EqualsBuilder.java\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2002 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.lang.builder;\n+\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Modifier;\n+/**\n+ * <code>Equals</code> generation routines. \n+ * <p>\n+ * This class provides methods to build a good equals method for any class.  \n+ * It follows rules laid out in Effective Java, by Joshua Bloch. In particular\n+ * the rule for comparing <code>doubles </code>, <code>floats</code>, and \n+ * arrays can be tricky. Also, making  sure that <code>equals()</code>\n+ * and <code>hashCode()</code> are consistent can be difficult.\n+ * <p>\n+ * Two object that compare as equals must generate the same hash code. But two\n+ * objects with the same hash code do not have to be equal.\n+ * <p>\n+ * All relevant fields should be included in the calculation of equals. Derived\n+ * fields may be ignored. In particular, any field used in generating a hash \n+ * code must be used in the equals method, and vice versa.\n+ * <p>\n+ * Typical use for the code is as follows:\n+ * <code>\n+ * public boolean equals(Object o) {\n+ *   if (!o instanceof MyClass) {\n+ *    return false;\n+ *   }\n+ *  MyClass rhs = (MyClass) o;\n+ *  return new EqualsBuilder()\n+ *                 .test(field1, rhs.field1)\n+ *                 .test(field2, rhs.field2)\n+ *                 .test(field3, rhs.field3)\n+ *                 .isEquals();\n+ *  }\n+ * </code>\n+ * <p>\n+ * Alternatively, there is a method that uses reflection to determine\n+ * the fields to test. Because these fields are usually private, the method, \n+ * <code>reflectionTest</code>, uses <code>Field.setAccessible</code> to change\n+ * the visibility of the fields. This will fail under a security manager, \n+ * unless the appropriate permissions are set. It is also slower than testing \n+ * explicitly.\n+ * <p>\n+ * A typical invocation for this method would look like:\n+ * <code>\n+ * public boolean equals(Object o) {\n+ *   return EqualsBuilder.reflectionEquals(this, obj);\n+ * }\n+ * </code>\n+ * \n+ * @author <a href=\"mailto:steve.downey@netfolio.com\">Steve Downey</a>\n+ * @author <a href=\"mailto:scolebourne@joda.org\">Stephen Colebourne</a>\n+ * @version $Id: EqualsBuilder.java,v 1.1 2002/09/12 22:00:00 scolebourne Exp $\n+ */\n+public class EqualsBuilder {\n+    /**\n+     * If the fields tested are equals.\n+     */\n+    protected boolean isEquals;\n+\n+    /**\n+     * Constructor for EqualsBuilder.\n+     * Starts off assuming that equals is true.\n+     * @see java.lang.Object#Object()\n+     */\n+    public EqualsBuilder() {\n+        super();\n+        isEquals = true;\n+    }\n+\n+    //-------------------------------------------------------------------------\n+    \n+    /**\n+     * This method uses reflection to determine if the two object are equal. \n+     * <p>\n+     * It uses Field.setAccessible to gain access to private fields. This means\n+     * that it will throw a security exception if run under a security manger, if\n+     * the permissions are not set up.\n+     * It is also not as efficient as testing explicitly. \n+     * Transient members will be not be tested, as they are likely derived \n+     * fields, and not part of the value of the object. \n+     * \n+     * @param lhs - Left Hand Side\n+     * @param rhs - Right Hand Side\n+     * @return boolean - if the two objects have tested equals.\n+     */\n+    public static boolean reflectionEquals(Object lhs, Object rhs) {\n+        return reflectionEquals(lhs, rhs, false);\n+    }\n+\n+    /**\n+     * This method uses reflection to determine if the two object are equal. \n+     * <p>\n+     * It uses Field.setAccessible to gain access to private fields. This means\n+     * that it will throw a security exception if run under a security manger, if\n+     * the permissions are not set up.\n+     * It is also not as efficient as testing explicitly. \n+     * If the TestTransients parameter is set to true, transient members will be\n+     * tested, otherwise they are ignored, as they are likely derived fields, and\n+     * not part of the value of the object. \n+     * \n+     * @param lhs - Left Hand Side\n+     * @param rhs - Right Hand Side\n+     * @param testTransients - whether to include transient fields\n+     * @return boolean - if the two objects have tested equals.\n+     */\n+    public static boolean reflectionEquals(Object lhs, Object rhs, boolean testTransients) {\n+        if (lhs == rhs) {\n+            return true;\n+        }\n+        if (lhs == null || rhs == null) {\n+            return false;\n+        }\n+        Class c1 = lhs.getClass();\n+        if (!c1.isInstance(rhs)) {\n+            return false;\n+        }\n+        Field[] fields = c1.getDeclaredFields();\n+        Field.setAccessible(fields, true);\n+        EqualsBuilder equalsBuilder = new EqualsBuilder();\n+        for (int i = 0; i < fields.length && equalsBuilder.isEquals; ++i) {\n+            Field f = fields[i];\n+            if (testTransients || !Modifier.isTransient(f.getModifiers())) {\n+                try {\n+                    equalsBuilder.append(f.get(lhs), f.get(rhs));\n+                } catch (IllegalAccessException e) {\n+                    //this can't happen. Would get a Security exception instead\n+                    //throw a runtime exception in case the impossible happens.\n+                    throw new InternalError(\"Unexpected IllegalAccessException\");\n+                }\n+            }\n+        }\n+        return equalsBuilder.isEquals();\n+    }\n+\n+    //-------------------------------------------------------------------------\n+    \n+    /**\n+     * Test if two <code>Object</code>s are equal using their <code>equals</code>\n+     *  method.\n+     * @param lhs - Left Hand Side\n+     * @param rhs - Right Hand Side\n+     * @return EqualsBuilder - used to chain calls.\n+     */\n+    public EqualsBuilder append(Object lhs, Object rhs) {\n+        if (isEquals == false) {\n+            return this;\n+        }\n+        if (lhs == rhs) {\n+            return this;\n+        }\n+        if (lhs == null || rhs == null) {\n+            isEquals = false;\n+            return this;\n+        }\n+        Class lhsClass = lhs.getClass();\n+        if (!lhsClass.isArray()) {\n+            //the simple case, not an array, just test the element \n+            isEquals = lhs.equals(rhs);\n+        } else {\n+            //'Switch' on type of array, to dispatch to the correct handler\n+            // This handles multi dimensional arrays\n+            if (lhs instanceof long[]) {\n+                append((long[]) lhs, (long[]) rhs);\n+            } else if (lhs instanceof int[]) {\n+                append((int[]) lhs, (int[]) rhs);\n+            } else if (lhs instanceof short[]) {\n+                append((short[]) lhs, (short[]) rhs);\n+            } else if (lhs instanceof char[]) {\n+                append((char[]) lhs, (char[]) rhs);\n+            } else if (lhs instanceof byte[]) {\n+                append((byte[]) lhs, (byte[]) rhs);\n+            } else if (lhs instanceof double[]) {\n+                append((double[]) lhs, (double[]) rhs);\n+            } else if (lhs instanceof float[]) {\n+                append((float[]) lhs, (float[]) rhs);\n+            } else if (lhs instanceof boolean[]) {\n+                append((boolean[]) lhs, (boolean[]) rhs);\n+            } else {\n+                // Not an array of primitives\n+                append((Object[]) lhs, (Object[]) rhs);\n+            }\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Test if two <code>long</code>s are equal using ==.\n+     * @param lhs - Left Hand Side\n+     * @param rhs - Right Hand Side\n+     * @return EqualsBuilder - used to chain calls.\n+     */\n+    public EqualsBuilder append(long lhs, long rhs) {\n+        if (isEquals == false) {\n+            return this;\n+        }\n+        isEquals = (lhs == rhs);\n+        return this;\n+    }\n+\n+    /**\n+     * Test if two <code>int</code>s are equal using ==.\n+     * @param lhs - Left Hand Side\n+     * @param rhs - Right Hand Side\n+     * @return EqualsBuilder - used to chain calls.\n+     */\n+    public EqualsBuilder append(int lhs, int rhs) {\n+        if (isEquals == false) {\n+            return this;\n+        }\n+        isEquals = (lhs == rhs);\n+        return this;\n+    }\n+\n+    /**\n+     * Test if two <code>short</code>s are equal using ==.\n+     * @param lhs - Left Hand Side\n+     * @param rhs - Right Hand Side\n+     * @return EqualsBuilder - used to chain calls.\n+     */\n+    public EqualsBuilder append(short lhs, short rhs) {\n+        if (isEquals == false) {\n+            return this;\n+        }\n+        isEquals = (lhs == rhs);\n+        return this;\n+    }\n+\n+    /**\n+     * Test if two <code>char</code>s are equal using ==.\n+     * @param lhs - Left Hand Side\n+     * @param rhs - Right Hand Side\n+     * @return EqualsBuilder - used to chain calls.\n+     */\n+    public EqualsBuilder append(char lhs, char rhs) {\n+        if (isEquals == false) {\n+            return this;\n+        }\n+        isEquals = (lhs == rhs);\n+        return this;\n+    }\n+\n+    /**\n+     * Test if two <code>byte</code>s are equal using ==.\n+     * @param lhs - Left Hand Side\n+     * @param rhs - Right Hand Side\n+     * @return EqualsBuilder - used to chain calls.\n+     */\n+    public EqualsBuilder append(byte lhs, byte rhs) {\n+        if (isEquals == false) {\n+            return this;\n+        }\n+        isEquals = (lhs == rhs);\n+        return this;\n+    }\n+\n+    /**\n+     * Test if two <code>double</code>s are equal by testing that the \n+     * pattern of bits returned by doubleToLong are equal. This handles NaNs, \n+     * Infinties, and -0.0. It is compatible with the hash code generated by \n+     * <code>HashCodeBuilder</code>.\n+     * @param lhs - Left Hand Side\n+     * @param rhs - Right Hand Side\n+     * @return EqualsBuilder - used to chain calls.\n+     */\n+    public EqualsBuilder append(double lhs, double rhs) {\n+        if (isEquals == false) {\n+            return this;\n+        }\n+        return append(Double.doubleToLongBits(lhs), Double.doubleToLongBits(rhs));\n+    }\n+\n+    /**\n+     * Test if two <code>float</code>s are equal byt testing that the \n+     * pattern of bits returned by doubleToLong are equal. This handles NaNs, \n+     * Infinties, and -0.0. It is compatible with the hash code generated by \n+     * <code>HashCodeBuilder</code>.\n+     * @param lhs - Left Hand Side\n+     * @param rhs - Right Hand Side\n+     * @return EqualsBuilder - used to chain calls.\n+     */\n+    public EqualsBuilder append(float lhs, float rhs) {\n+        if (isEquals == false) {\n+            return this;\n+        }\n+        return append(Float.floatToIntBits(lhs), Float.floatToIntBits(rhs));\n+    }\n+\n+    /**\n+     * Test if two <code>booleans</code>s are equal using ==.\n+     * @param lhs - Left Hand Side\n+     * @param rhs - Right Hand Side\n+     * @return EqualsBuilder - used to chain calls.\n+      */\n+    public EqualsBuilder append(boolean lhs, boolean rhs) {\n+        if (isEquals == false) {\n+            return this;\n+        }\n+        isEquals = (lhs == rhs);\n+        return this;\n+    }\n+\n+    /**\n+     * Performs a deep comparison of two object arrays. This also will be\n+     * called for the top level of multi-dimensional, ragged, and multi-typed\n+     * arrays. \n+     * @param lhs - Left Hand Side\n+     * @param rhs - Right Hand Side\n+     * @return EqualsBuilder - used to chain calls.\n+     */\n+    public EqualsBuilder append(Object[] lhs, Object[] rhs) {\n+        if (isEquals == false) {\n+            return this;\n+        }\n+        if (lhs == rhs) {\n+            return this;\n+        }\n+        if (lhs == null || rhs == null) {\n+            isEquals = false;\n+            return this;\n+        }\n+        if (lhs.length != rhs.length) {\n+            isEquals = false;\n+            return this;\n+        }\n+        for (int i = 0; i < lhs.length && isEquals; ++i) {\n+            Class lhsClass = lhs[i].getClass();\n+            if (!lhsClass.isInstance(rhs[i])) {\n+                isEquals = false; //If the types don't match, not equal\n+                break;\n+            }\n+            append(lhs[i], rhs[i]);\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Deep comparison of array of <code>long</code> Length and all values\n+     *  are compared. The method append(long, long) is used.\n+     * @param lhs - Left Hand Side\n+     * @param rhs - Right Hand Side\n+     * @return EqualsBuilder - used to chain calls.\n+     */\n+    public EqualsBuilder append(long[] lhs, long[] rhs) {\n+        if (isEquals == false) {\n+            return this;\n+        }\n+        if (lhs == rhs) {\n+            return this;\n+        }\n+        if (lhs == null || rhs == null) {\n+            isEquals = false;\n+            return this;\n+        }\n+        if (lhs.length != rhs.length) {\n+            isEquals = false;\n+            return this;\n+        }\n+        for (int i = 0; i < lhs.length && isEquals; ++i) {\n+            append(lhs[i], rhs[i]);\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Deep comparison of array of <code>int</code> Length and all values\n+     *  are compared. The method append(int, int) is used.\n+     * @param lhs - Left Hand Side\n+     * @param rhs - Right Hand Side\n+     * @return EqualsBuilder - used to chain calls.\n+     */\n+    public EqualsBuilder append(int[] lhs, int[] rhs) {\n+        if (isEquals == false) {\n+            return this;\n+        }\n+        if (lhs == rhs) {\n+            return this;\n+        }\n+        if (lhs == null || rhs == null) {\n+            isEquals = false;\n+            return this;\n+        }\n+        if (lhs.length != rhs.length) {\n+            isEquals = false;\n+            return this;\n+        }\n+        for (int i = 0; i < lhs.length && isEquals; ++i) {\n+            append(lhs[i], rhs[i]);\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Deep comparison of array of <code>short</code> Length and all values\n+     *  are compared. The method append(short, short) is used.\n+     * @param lhs - Left Hand Side\n+     * @param rhs - Right Hand Side\n+     * @return EqualsBuilder - used to chain calls.\n+     */\n+    public EqualsBuilder append(short[] lhs, short[] rhs) {\n+        if (isEquals == false) {\n+            return this;\n+        }\n+        if (lhs == rhs) {\n+            return this;\n+        }\n+        if (lhs == null || rhs == null) {\n+            isEquals = false;\n+            return this;\n+        }\n+        if (lhs.length != rhs.length) {\n+            isEquals = false;\n+            return this;\n+        }\n+        for (int i = 0; i < lhs.length && isEquals; ++i) {\n+            append(lhs[i], rhs[i]);\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Deep comparison of array of <code>char</code> Length and all values\n+     *  are compared. The method append(char, char) is used.\n+     * @param lhs - Left Hand Side\n+     * @param rhs - Right Hand Side\n+     * @return EqualsBuilder - used to chain calls.\n+     */\n+    public EqualsBuilder append(char[] lhs, char[] rhs) {\n+        if (isEquals == false) {\n+            return this;\n+        }\n+        if (lhs == rhs) {\n+            return this;\n+        }\n+        if (lhs == null || rhs == null) {\n+            isEquals = false;\n+            return this;\n+        }\n+        if (lhs.length != rhs.length) {\n+            isEquals = false;\n+            return this;\n+        }\n+        for (int i = 0; i < lhs.length && isEquals; ++i) {\n+            append(lhs[i], rhs[i]);\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Deep comparison of array of <code>byte</code> Length and all values\n+     *  are compared. The method append(byte, byte) is used.\n+     * @param lhs - Left Hand Side\n+     * @param rhs - Right Hand Side\n+     * @return EqualsBuilder - used to chain calls.\n+     */\n+    public EqualsBuilder append(byte[] lhs, byte[] rhs) {\n+        if (isEquals == false) {\n+            return this;\n+        }\n+        if (lhs == rhs) {\n+            return this;\n+        }\n+        if (lhs == null || rhs == null) {\n+            isEquals = false;\n+            return this;\n+        }\n+        if (lhs.length != rhs.length) {\n+            isEquals = false;\n+            return this;\n+        }\n+        for (int i = 0; i < lhs.length && isEquals; ++i) {\n+            append(lhs[i], rhs[i]);\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Deep comparison of array of <code>double</code> Length and all values\n+     *  are compared. The method append(double, double) is used.\n+     * @param lhs - Left Hand Side\n+     * @param rhs - Right Hand Side\n+     * @return EqualsBuilder - used to chain calls.\n+     */\n+    public EqualsBuilder append(double[] lhs, double[] rhs) {\n+        if (isEquals == false) {\n+            return this;\n+        }\n+        if (lhs == rhs) {\n+            return this;\n+        }\n+        if (lhs == null || rhs == null) {\n+            isEquals = false;\n+            return this;\n+        }\n+        if (lhs.length != rhs.length) {\n+            isEquals = false;\n+            return this;\n+        }\n+        for (int i = 0; i < lhs.length && isEquals; ++i) {\n+            append(lhs[i], rhs[i]);\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Deep comparison of array of <code>float</code> Length and all values\n+     *  are compared. The method append(float, float) is used.\n+     * @param lhs - Left Hand Side\n+     * @param rhs - Right Hand Side\n+     * @return EqualsBuilder - used to chain calls.\n+     */\n+    public EqualsBuilder append(float[] lhs, float[] rhs) {\n+        if (isEquals == false) {\n+            return this;\n+        }\n+        if (lhs == rhs) {\n+            return this;\n+        }\n+        if (lhs == null || rhs == null) {\n+            isEquals = false;\n+            return this;\n+        }\n+        if (lhs.length != rhs.length) {\n+            isEquals = false;\n+            return this;\n+        }\n+        for (int i = 0; i < lhs.length && isEquals; ++i) {\n+            append(lhs[i], rhs[i]);\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Deep comparison of array of <code>boolean</code> Length and all values\n+     *  are compared. The method append(boolean, boolean) is used.\n+     * @param lhs - Left Hand Side\n+     * @param rhs - Right Hand Side\n+     * @return EqualsBuilder - used to chain calls.\n+     */\n+    public EqualsBuilder append(boolean[] lhs, boolean[] rhs) {\n+        if (isEquals == false) {\n+            return this;\n+        }\n+        if (lhs == rhs) {\n+            return this;\n+        }\n+        if (lhs == null || rhs == null) {\n+            isEquals = false;\n+            return this;\n+        }\n+        if (lhs.length != rhs.length) {\n+            isEquals = false;\n+            return this;\n+        }\n+        for (int i = 0; i < lhs.length && isEquals; ++i) {\n+            append(lhs[i], rhs[i]);\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Return true if the fields that have been checked are all equal.\n+     * @return boolean\n+     */\n+    public boolean isEquals() {\n+        return isEquals;\n+    }\n+\n+}", "timestamp": 1031868000, "metainfo": ""}