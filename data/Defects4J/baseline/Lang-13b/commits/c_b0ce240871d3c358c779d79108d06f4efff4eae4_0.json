{"sha": "b0ce240871d3c358c779d79108d06f4efff4eae4", "log": "add hashCode and toString methods to AnnotationUtils, plus tests  ", "commit": "\n--- a/src/main/java/org/apache/commons/lang3/AnnotationUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/AnnotationUtils.java\n package org.apache.commons.lang3;\n \n import java.lang.annotation.Annotation;\n+import java.lang.reflect.InvocationTargetException;\n import java.lang.reflect.Method;\n import java.util.Arrays;\n+import java.util.Iterator;\n \n /**\n  * Helper methods for working with {@link Annotation}s.\n     }\n \n     /**\n-     * Learn whether two annotations are equivalent as defined by\n-     * {@link Annotation#equals(Object)}. This method is useful because\n-     * dynamically created {@link Annotation} instances are always proxy\n-     * objects, which, though dependent upon implementation, very often cannot\n-     * be depended upon to behave \"normally\" in terms of {@link #equals(Object)}\n-     * implementation.\n+     * Learn whether two annotations are equivalent; dynamically created\n+     * {@link Annotation} instances are always proxy objects which cannot be\n+     * depended upon to know how to implement {@link Annotation#equals(Object)}\n+     * per spec.\n      * @param a1 the first Annotation to compare\n      * @param a2 the second Annotation to compare\n      */\n     }\n \n     /**\n+     * Generate a hashcode for the given annotation; dynamically created\n+     * {@link Annotation} instances are always proxy objects which cannot be\n+     * depended upon to know how to implement {@link Annotation#hashCode()} per\n+     * spec.\n+     * \n+     * @param a the Annotation for a hashcode calculation is desired\n+     * @return the calculated hashcode\n+     * @throws InvocationTargetException\n+     * @throws IllegalAccessException\n+     * @throws IllegalArgumentException\n+     */\n+    public static int hashCode(Annotation a) throws IllegalArgumentException,\n+            IllegalAccessException, InvocationTargetException {\n+        int result = 0;\n+        Class<? extends Annotation> type = a.annotationType();\n+        for (Method m : type.getDeclaredMethods()) {\n+            result += hashMember(m.getName(), m.invoke(a));\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Generate a string representation of an Annotation, as suggested by\n+     * {@link Annotation#toString()}.\n+     * @param a the annotation of which a string representation is desired\n+     * @return String\n+     */\n+    public static String toString(final Annotation a) {\n+        return new StringBuilder(a.annotationType().getName()).insert(0, '@').append('(')\n+                .append(StringUtils.join(new Iterable<String>() {\n+\n+                    public Iterator<String> iterator() {\n+                        final Method[] methods = a.annotationType().getDeclaredMethods();\n+                        return new Iterator<String>() {\n+                            int pos = 0;\n+\n+                            public boolean hasNext() {\n+                                return pos < methods.length;\n+                            }\n+\n+                            public String next() {\n+                                Method m = methods[pos++];\n+                                try {\n+                                    return new StringBuilder(m.getName()).append('=')\n+                                            .append(m.invoke(a)).toString();\n+                                } catch (Exception e) {\n+                                    throw new RuntimeException(e);\n+                                }\n+                            }\n+\n+                            public void remove() {\n+                                throw new UnsupportedOperationException();\n+                            }\n+\n+                        };\n+                    }\n+\n+                }, \", \")).append(')').toString();\n+    }\n+\n+    //besides modularity, this has the advantage of autoboxing primitives:\n+    private static int hashMember(String name, Object value) throws IllegalArgumentException,\n+            IllegalAccessException, InvocationTargetException {\n+        int part1 = name.hashCode() * 127;\n+        if (value == null) {\n+            return part1;\n+        }\n+        if (value.getClass().isArray()) {\n+            return part1 ^ arrayMemberHash(value.getClass().getComponentType(), value);\n+        }\n+        if (value instanceof Annotation) {\n+            return part1 ^ hashCode((Annotation) value);\n+        }\n+        return part1 ^ value.hashCode();\n+    }\n+\n+    /**\n      * Learn whether the specified type is permitted as an annotation member.\n      * These include {@link String}, {@link Class}, primitive types,\n      * {@link Annotation}s, {@link Enum}s, and arrays of same.\n         }\n         return true;\n     }\n+\n+    private static int arrayMemberHash(Class<?> componentType, Object o) {\n+        if (componentType.equals(Byte.TYPE)) {\n+            return Arrays.hashCode((byte[]) o);\n+        }\n+        if (componentType.equals(Short.TYPE)) {\n+            return Arrays.hashCode((short[]) o);\n+        }\n+        if (componentType.equals(Integer.TYPE)) {\n+            return Arrays.hashCode((int[]) o);\n+        }\n+        if (componentType.equals(Character.TYPE)) {\n+            return Arrays.hashCode((char[]) o);\n+        }\n+        if (componentType.equals(Long.TYPE)) {\n+            return Arrays.hashCode((long[]) o);\n+        }\n+        if (componentType.equals(Float.TYPE)) {\n+            return Arrays.hashCode((float[]) o);\n+        }\n+        if (componentType.equals(Double.TYPE)) {\n+            return Arrays.hashCode((double[]) o);\n+        }\n+        if (componentType.equals(Boolean.TYPE)) {\n+            return Arrays.hashCode((boolean[]) o);\n+        }\n+        return Arrays.hashCode((Object[]) o);\n+    }\n+\n }\n--- a/src/test/java/org/apache/commons/lang3/AnnotationUtilsTest.java\n+++ b/src/test/java/org/apache/commons/lang3/AnnotationUtilsTest.java\n         assertTrue(AnnotationUtils.equals(generated, generated2));\n         assertTrue(AnnotationUtils.equals(generated2, generated));\n     }\n+\n+    @Test(timeout = 666)\n+    public void testHashCode() throws Exception {\n+        final Test testAnno = getClass().getDeclaredMethod(\"testHashCode\")\n+                .getAnnotation(Test.class);\n+        assertEquals(testAnno.hashCode(), AnnotationUtils.hashCode(testAnno));\n+    }\n+\n+    @Test(timeout = 666)\n+    public void testToString() throws Exception {\n+        final Test testAnno = getClass().getDeclaredMethod(\"testToString\")\n+                .getAnnotation(Test.class);\n+        String toString = AnnotationUtils.toString(testAnno);\n+        assertTrue(toString.startsWith(\"@org.junit.Test(\"));\n+        assertTrue(toString.endsWith(\")\"));\n+        assertTrue(toString.contains(\"expected=class org.junit.Test$None\"));\n+        assertTrue(toString.contains(\"timeout=666\"));\n+        assertTrue(toString.contains(\", \"));\n+    }\n }", "timestamp": 1285028860, "metainfo": ""}