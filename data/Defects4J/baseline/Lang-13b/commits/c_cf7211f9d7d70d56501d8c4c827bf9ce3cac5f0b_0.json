{"sha": "cf7211f9d7d70d56501d8c4c827bf9ce3cac5f0b", "log": "[LANG-786] StringUtils equals() relies on undefined behavior; thanks to Daniel Trebbien  ", "commit": "\n--- a/src/main/java/org/apache/commons/lang3/StringUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/StringUtils.java\n     // Equals\n     //-----------------------------------------------------------------------\n     /**\n-     * <p>Compares two CharSequences, returning {@code true} if they are equal.</p>\n+     * <p>Compares two CharSequences, returning {@code true} if they represent\n+     * equal sequences of characters.</p>\n      *\n      * <p>{@code null}s are handled without exceptions. Two {@code null}\n      * references are considered to be equal. The comparison is case sensitive.</p>\n      * StringUtils.equals(\"abc\", \"ABC\") = false\n      * </pre>\n      *\n-     * @see java.lang.String#equals(Object)\n-     * @param cs1  the first CharSequence, may be null\n-     * @param cs2  the second CharSequence, may be null\n-     * @return {@code true} if the CharSequences are equal, case sensitive, or\n-     *  both {@code null}\n+     * @see java.lang.CharSequence#equals(Object)\n+     * @param cs1  the first CharSequence, may be {@code null}\n+     * @param cs2  the second CharSequence, may be {@code null}\n+     * @return {@code true} if the CharSequences are equal (case-sensitive), or both {@code null}\n      * @since 3.0 Changed signature from equals(String, String) to equals(CharSequence, CharSequence)\n      */\n     public static boolean equals(CharSequence cs1, CharSequence cs2) {\n-        return cs1 == null ? cs2 == null : cs1.equals(cs2);\n-    }\n-\n-    /**\n-     * <p>Compares two CharSequences, returning {@code true} if they are equal ignoring\n-     * the case.</p>\n+        if (cs1 == cs2) {\n+            return true;\n+        }\n+        if (cs1 == null || cs2 == null) {\n+            return false;\n+        }\n+        if (cs1 instanceof String && cs2 instanceof String) {\n+            return cs1.equals(cs2);\n+        }\n+        return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));\n+    }\n+\n+    /**\n+     * <p>Compares two CharSequences, returning {@code true} if they represent\n+     * equal sequences of characters, ignoring case.</p>\n      *\n      * <p>{@code null}s are handled without exceptions. Two {@code null}\n      * references are considered equal. Comparison is case insensitive.</p>\n--- a/src/test/java/org/apache/commons/lang3/StringUtilsEqualsIndexOfTest.java\n+++ b/src/test/java/org/apache/commons/lang3/StringUtilsEqualsIndexOfTest.java\n import java.util.Locale;\n \n import junit.framework.TestCase;\n+import org.hamcrest.core.IsNot;\n+import static org.junit.Assert.assertThat;\n \n /**\n  * Unit tests {@link org.apache.commons.lang3.StringUtils} - Substring methods\n         assertTrue( StringUtils.containsWhitespace(\"\\n\") );\n     }\n \n+    // The purpose of this class is to test StringUtils#equals(CharSequence, CharSequence)\n+    // with a CharSequence implementation whose equals(Object) override requires that the\n+    // other object be an instance of CustomCharSequence, even though, as char sequences,\n+    // `seq` may equal the other object.\n+    private static class CustomCharSequence implements CharSequence {\n+        private CharSequence seq;\n+\n+        public CustomCharSequence(CharSequence seq) {\n+            this.seq = seq;\n+        }\n+\n+        public char charAt(int index) {\n+            return seq.charAt(index);\n+        }\n+\n+        public int length() {\n+            return seq.length();\n+        }\n+\n+        public CharSequence subSequence(int start, int end) {\n+            return new CustomCharSequence(seq.subSequence(start, end));\n+        }\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            if (obj == null || !(obj instanceof CustomCharSequence)) {\n+                return false;\n+            }\n+            CustomCharSequence other = (CustomCharSequence) obj;\n+            return seq.equals(other.seq);\n+        }\n+\n+        public String toString() {\n+            return seq.toString();\n+        }\n+    }\n+\n+    public void testCustomCharSequence() {\n+        assertThat((CharSequence) new CustomCharSequence(FOO), IsNot.<CharSequence>not(FOO));\n+        assertThat((CharSequence) FOO, IsNot.<CharSequence>not(new CustomCharSequence(FOO)));\n+        assertEquals(new CustomCharSequence(FOO), new CustomCharSequence(FOO));\n+    }\n+\n     public void testEquals() {\n-        assertEquals(true, StringUtils.equals(null, null));\n-        assertEquals(true, StringUtils.equals(FOO, FOO));\n-        assertEquals(true, StringUtils.equals(FOO, new String(new char[] { 'f', 'o', 'o' })));\n-        assertEquals(false, StringUtils.equals(FOO, new String(new char[] { 'f', 'O', 'O' })));\n-        assertEquals(false, StringUtils.equals(FOO, BAR));\n-        assertEquals(false, StringUtils.equals(FOO, null));\n-        assertEquals(false, StringUtils.equals(null, FOO));\n+        final CharSequence fooCs = FOO, barCs = BAR, foobarCs = FOOBAR;\n+        assertTrue(StringUtils.equals(null, null));\n+        assertTrue(StringUtils.equals(fooCs, fooCs));\n+        assertTrue(StringUtils.equals(fooCs, (CharSequence) new StringBuilder(FOO)));\n+        assertTrue(StringUtils.equals(fooCs, (CharSequence) new String(new char[] { 'f', 'o', 'o' })));\n+        assertTrue(StringUtils.equals(fooCs, (CharSequence) new CustomCharSequence(FOO)));\n+        assertTrue(StringUtils.equals((CharSequence) new CustomCharSequence(FOO), fooCs));\n+        assertFalse(StringUtils.equals(fooCs, (CharSequence) new String(new char[] { 'f', 'O', 'O' })));\n+        assertFalse(StringUtils.equals(fooCs, barCs));\n+        assertFalse(StringUtils.equals(fooCs, null));\n+        assertFalse(StringUtils.equals(null, fooCs));\n+        assertFalse(StringUtils.equals(fooCs, foobarCs));\n+        assertFalse(StringUtils.equals(foobarCs, fooCs));\n+    }\n+\n+    public void testEqualsOnStrings() {\n+        assertTrue(StringUtils.equals(null, null));\n+        assertTrue(StringUtils.equals(FOO, FOO));\n+        assertTrue(StringUtils.equals(FOO, new String(new char[] { 'f', 'o', 'o' })));\n+        assertFalse(StringUtils.equals(FOO, new String(new char[] { 'f', 'O', 'O' })));\n+        assertFalse(StringUtils.equals(FOO, BAR));\n+        assertFalse(StringUtils.equals(FOO, null));\n+        assertFalse(StringUtils.equals(null, FOO));\n+        assertFalse(StringUtils.equals(FOO, FOOBAR));\n+        assertFalse(StringUtils.equals(FOOBAR, FOO));\n     }\n \n     public void testEqualsIgnoreCase() {", "timestamp": 1327340841, "metainfo": ""}