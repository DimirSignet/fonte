{"sha": "85a7311e94b6e63d99ca342d42465bfc7df06b28", "log": "Applying Chas Honton's implementation of DateParser and subsequent integration into FastDateFormat and the time package. See LANG-462.   ", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/lang3/time/DateParser.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang3.time;\n+\n+import java.text.ParseException;\n+import java.text.ParsePosition;\n+import java.util.Date;\n+import java.util.Locale;\n+import java.util.TimeZone;\n+\n+/**\n+ * <p>DateParser is the \"missing\" interface for the parsing methods of \n+ * {@link java.text.DateFormat}.</p>\n+ * \n+ * @since 3.2\n+ */\n+public interface DateParser {\n+\n+    /**\n+     * Equivalent to DateFormat.parse(String). \n+     * \n+     * See {@link java.text.DateFormat#parse(String)} for more information. \n+     * @param source A <code>String</code> whose beginning should be parsed. \n+     * @return A <code>Date</code> parsed from the string\n+     * @throws ParseException if the beginning of the specified string cannot be parsed.\n+     */\n+    public Date parse(String source) throws ParseException;\n+\n+    /**\n+     * Equivalent to DateFormat.parse(String, ParsePosition). \n+     * \n+     * See {@link java.text.DateFormat#parse(String, ParsePosition)} for more information. \n+     * \n+     * @param source A <code>String</code>, part of which should be parsed.\n+     * @param pos A <code>ParsePosition</code> object with index and error index information \n+     * as described above. \n+     * @return A <code>Date</code> parsed from the string. In case of error, returns null. \n+     * @throws NullPointerException if text or pos is null.\n+     */\n+    public Date parse(String source, ParsePosition pos);\n+\n+    // Accessors\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Get the pattern used by this parser.</p>\n+     * \n+     * @return the pattern, {@link java.text.SimpleDateFormat} compatible\n+     */\n+    public String getPattern();\n+\n+    /**\n+     * <p>Get the time zone used by this parser.</p>\n+     *\n+     * <p>This zone is always used for <code>Date</code> formatting.\n+     * If a <code>Calendar</code> is passed in to be formatted, the\n+     * time zone on that may be used depending on\n+     * {@link #getTimeZoneOverridesCalendar()}.</p>\n+     * \n+     * @return the time zone\n+     */\n+    public TimeZone getTimeZone();\n+\n+    /**\n+     * <p>Get the locale used by this parser.</p>\n+     * \n+     * @return the locale\n+     */\n+    public Locale getLocale();\n+\n+    /**\n+     * Parses text from a string to produce a Date.\n+     * See {@link java.text.DateFormat#parseObject(String)} \n+     */\n+    Object parseObject(String source) throws ParseException;\n+\n+    /**\n+     * Parse a date/time string according to the given parse position. \n+     * See {@link java.text.DateFormat#parseObject(String, ParsePosition)} \n+     */\n+    public Object parseObject(String source, ParsePosition pos);\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/lang3/time/DatePrinter.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang3.time;\n+\n+import java.text.FieldPosition;\n+import java.util.Calendar;\n+import java.util.Date;\n+import java.util.Locale;\n+import java.util.TimeZone;\n+\n+/**\n+ * <p>DatePrinter is the \"missing\" interface for the format methods of \n+ * {@link java.text.DateFormat}.</p>\n+ * \n+ * @since 3.2\n+ */\n+public interface DatePrinter {\n+\n+    /**\n+     * <p>Formats a millisecond {@code long} value.</p>\n+     *\n+     * @param millis  the millisecond value to format\n+     * @return the formatted string\n+     * @since 2.1\n+     */\n+    public String format(long millis);\n+\n+    /**\n+     * <p>Formats a {@code Date} object using a {@code GregorianCalendar}.</p>\n+     *\n+     * @param date  the date to format\n+     * @return the formatted string\n+     */\n+    public String format(Date date);\n+\n+    /**\n+     * <p>Formats a {@code Calendar} object.</p>\n+     *\n+     * @param calendar  the calendar to format\n+     * @return the formatted string\n+     */\n+    public String format(Calendar calendar);\n+\n+    /**\n+     * <p>Formats a milliseond {@code long} value into the\n+     * supplied {@code StringBuffer}.</p>\n+     *\n+     * @param millis  the millisecond value to format\n+     * @param buf  the buffer to format into\n+     * @return the specified string buffer\n+     */\n+    public StringBuffer format(long millis, StringBuffer buf);\n+\n+    /**\n+     * <p>Formats a {@code Date} object into the\n+     * supplied {@code StringBuffer} using a {@code GregorianCalendar}.</p>\n+     *\n+     * @param date  the date to format\n+     * @param buf  the buffer to format into\n+     * @return the specified string buffer\n+     */\n+    public StringBuffer format(Date date, StringBuffer buf);\n+\n+    /**\n+     * <p>Formats a {@code Calendar} object into the\n+     * supplied {@code StringBuffer}.</p>\n+     *\n+     * @param calendar  the calendar to format\n+     * @param buf  the buffer to format into\n+     * @return the specified string buffer\n+     */\n+    public StringBuffer format(Calendar calendar, StringBuffer buf);\n+\n+    // Accessors\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Gets the pattern used by this printer.</p>\n+     *\n+     * @return the pattern, {@link java.text.SimpleDateFormat} compatible\n+     */\n+    public String getPattern();\n+\n+    /**\n+     * <p>Gets the time zone used by this printer.</p>\n+     *\n+     * <p>This zone is always used for {@code Date} printing. </p>\n+     *\n+     * @return the time zone\n+     */\n+    public TimeZone getTimeZone();\n+\n+    /**\n+     * <p>Gets the locale used by this printer.</p>\n+     *\n+     * @return the locale\n+     */\n+    public Locale getLocale();\n+\n+    /**\n+     * <p>Formats a {@code Date}, {@code Calendar} or\n+     * {@code Long} (milliseconds) object.</p>\n+     * \n+     * See {@link java.text.DateFormat#format(Object, StringBuffer, FieldPosition)\n+     * \n+     * @param obj  the object to format\n+     * @param toAppendTo  the buffer to append to\n+     * @param pos  the position - ignored\n+     * @return the buffer passed in\n+     */\n+    StringBuffer format(Object obj, StringBuffer toAppendTo, FieldPosition pos);\n+}\n--- a/src/main/java/org/apache/commons/lang3/time/FastDateFormat.java\n+++ b/src/main/java/org/apache/commons/lang3/time/FastDateFormat.java\n  */\n package org.apache.commons.lang3.time;\n \n-import java.io.IOException;\n-import java.io.ObjectInputStream;\n import java.text.DateFormat;\n-import java.text.DateFormatSymbols;\n import java.text.FieldPosition;\n import java.text.Format;\n+import java.text.ParseException;\n import java.text.ParsePosition;\n-import java.util.ArrayList;\n import java.util.Calendar;\n import java.util.Date;\n-import java.util.GregorianCalendar;\n-import java.util.List;\n import java.util.Locale;\n import java.util.TimeZone;\n-import java.util.concurrent.ConcurrentHashMap;\n-import java.util.concurrent.ConcurrentMap;\n-\n-import org.apache.commons.lang3.Validate;\n \n /**\n  * <p>FastDateFormat is a fast and thread-safe version of\n  * {@link java.text.SimpleDateFormat}.</p>\n  *\n  * <p>This class can be used as a direct replacement to\n- * {@code SimpleDateFormat} in most formatting situations.\n+ * {@code SimpleDateFormat} in most formatting and parsing situations.\n  * This class is especially useful in multi-threaded server environments.\n  * {@code SimpleDateFormat} is not thread-safe in any JDK version,\n  * nor will it be as Sun have closed the bug/RFE.\n  * </p>\n  *\n- * <p>Only formatting is supported, but all patterns are compatible with\n+ * <p>All patterns are compatible with\n  * SimpleDateFormat (except time zones and some year patterns - see below).</p>\n+ * \n+ * <p>Since 3.2, FastDateFormat supports parsing as well as printing.</p>\n  *\n  * <p>Java 1.4 introduced a new pattern letter, {@code 'Z'}, to represent\n  * time zones in RFC822 format (eg. {@code +0800} or {@code -1100}).\n  * @since 2.0\n  * @version $Id$\n  */\n-public class FastDateFormat extends Format {\n-    // A lot of the speed in this class comes from caching, but some comes\n-    // from the special int to StringBuffer conversion.\n-    //\n-    // The following produces a padded 2 digit number:\n-    //   buffer.append((char)(value / 10 + '0'));\n-    //   buffer.append((char)(value % 10 + '0'));\n-    //\n-    // Note that the fastest append to StringBuffer is a single char (used here).\n-    // Note that Integer.toString() is not called, the conversion is simply\n-    // taking the value and adding (mathematically) the ASCII value for '0'.\n-    // So, don't change this code! It works and is very fast.\n-\n+public class FastDateFormat extends Format implements DateParser, DatePrinter {\n     /**\n      * Required for serialization support.\n      *\n      * @see java.io.Serializable\n      */\n-    private static final long serialVersionUID = 1L;\n+    private static final long serialVersionUID = 2L;\n \n     /**\n      * FULL locale dependent date or time style.\n \n     private static final FormatCache<FastDateFormat> cache= new FormatCache<FastDateFormat>() {\n         @Override\n-        protected FastDateFormat createInstance(String pattern,    TimeZone timeZone, Locale locale) {\n+        protected FastDateFormat createInstance(String pattern, TimeZone timeZone, Locale locale) {\n             return new FastDateFormat(pattern, timeZone, locale);\n         }\n     };\n \n-    private static ConcurrentMap<TimeZoneDisplayKey, String> cTimeZoneDisplayCache =\n-        new ConcurrentHashMap<TimeZoneDisplayKey, String>(7);\n-\n-    /**\n-     * The pattern.\n-     */\n-    private final String mPattern;\n-    /**\n-     * The time zone.\n-     */\n-    private final TimeZone mTimeZone;\n-    /**\n-     * The locale.\n-     */\n-    private final Locale mLocale;\n-    /**\n-     * The parsed rules.\n-     */\n-    private transient Rule[] mRules;\n-    /**\n-     * The estimated maximum length.\n-     */\n-    private transient int mMaxLengthEstimate;\n-\n+    private final FastDatePrinter printer;\n+    private final FastDateParser parser;\n+    \n     //-----------------------------------------------------------------------\n     /**\n      * <p>Gets a formatter instance using the default pattern in the\n      * @return a date/time formatter\n      */\n     public static FastDateFormat getInstance() {\n-        return cache.getDateTimeInstance(SHORT, SHORT, null, null);\n+        return cache.getInstance();\n     }\n \n     /**\n         return cache.getDateTimeInstance(dateStyle, timeStyle, timeZone, locale);\n     }\n \n-    //-----------------------------------------------------------------------\n-    /**\n-     * <p>Gets the time zone display name, using a cache for performance.</p>\n-     *\n-     * @param tz  the zone to query\n-     * @param daylight  true if daylight savings\n-     * @param style  the style to use {@code TimeZone.LONG} or {@code TimeZone.SHORT}\n-     * @param locale  the locale to use\n-     * @return the textual name of the time zone\n-     */\n-    static String getTimeZoneDisplay(TimeZone tz, boolean daylight, int style, Locale locale) {\n-        TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n-        String value = cTimeZoneDisplayCache.get(key);\n-        if (value == null) {\n-            // This is a very slow call, so cache the results.\n-            value = tz.getDisplayName(daylight, style, locale);\n-            String prior = cTimeZoneDisplayCache.putIfAbsent(key, value);\n-            if (prior != null) {\n-                value= prior;\n-            }\n-        }\n-        return value;\n-    }\n-\n     // Constructor\n     //-----------------------------------------------------------------------\n     /**\n      * @throws NullPointerException if pattern, timeZone, or locale is null.\n      */\n     protected FastDateFormat(String pattern, TimeZone timeZone, Locale locale) {\n-        mPattern = pattern;\n-        mTimeZone = timeZone;\n-        mLocale = locale;\n-\n-        init();\n-    }\n-\n-    /**\n-     * <p>Initializes the instance for first use.</p>\n-     */\n-    private void init() {\n-        List<Rule> rulesList = parsePattern();\n-        mRules = rulesList.toArray(new Rule[rulesList.size()]);\n-\n-        int len = 0;\n-        for (int i=mRules.length; --i >= 0; ) {\n-            len += mRules[i].estimateLength();\n-        }\n-\n-        mMaxLengthEstimate = len;\n-    }\n-\n-    // Parse the pattern\n-    //-----------------------------------------------------------------------\n-    /**\n-     * <p>Returns a list of Rules given a pattern.</p>\n-     *\n-     * @return a {@code List} of Rule objects\n-     * @throws IllegalArgumentException if pattern is invalid\n-     */\n-    protected List<Rule> parsePattern() {\n-        DateFormatSymbols symbols = new DateFormatSymbols(mLocale);\n-        List<Rule> rules = new ArrayList<Rule>();\n-\n-        String[] ERAs = symbols.getEras();\n-        String[] months = symbols.getMonths();\n-        String[] shortMonths = symbols.getShortMonths();\n-        String[] weekdays = symbols.getWeekdays();\n-        String[] shortWeekdays = symbols.getShortWeekdays();\n-        String[] AmPmStrings = symbols.getAmPmStrings();\n-\n-        int length = mPattern.length();\n-        int[] indexRef = new int[1];\n-\n-        for (int i = 0; i < length; i++) {\n-            indexRef[0] = i;\n-            String token = parseToken(mPattern, indexRef);\n-            i = indexRef[0];\n-\n-            int tokenLen = token.length();\n-            if (tokenLen == 0) {\n-                break;\n-            }\n-\n-            Rule rule;\n-            char c = token.charAt(0);\n-\n-            switch (c) {\n-            case 'G': // era designator (text)\n-                rule = new TextField(Calendar.ERA, ERAs);\n-                break;\n-            case 'y': // year (number)\n-                if (tokenLen == 2) {\n-                    rule = TwoDigitYearField.INSTANCE;\n-                } else {\n-                    rule = selectNumberRule(Calendar.YEAR, tokenLen < 4 ? 4 : tokenLen);\n-                }\n-                break;\n-            case 'M': // month in year (text and number)\n-                if (tokenLen >= 4) {\n-                    rule = new TextField(Calendar.MONTH, months);\n-                } else if (tokenLen == 3) {\n-                    rule = new TextField(Calendar.MONTH, shortMonths);\n-                } else if (tokenLen == 2) {\n-                    rule = TwoDigitMonthField.INSTANCE;\n-                } else {\n-                    rule = UnpaddedMonthField.INSTANCE;\n-                }\n-                break;\n-            case 'd': // day in month (number)\n-                rule = selectNumberRule(Calendar.DAY_OF_MONTH, tokenLen);\n-                break;\n-            case 'h': // hour in am/pm (number, 1..12)\n-                rule = new TwelveHourField(selectNumberRule(Calendar.HOUR, tokenLen));\n-                break;\n-            case 'H': // hour in day (number, 0..23)\n-                rule = selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen);\n-                break;\n-            case 'm': // minute in hour (number)\n-                rule = selectNumberRule(Calendar.MINUTE, tokenLen);\n-                break;\n-            case 's': // second in minute (number)\n-                rule = selectNumberRule(Calendar.SECOND, tokenLen);\n-                break;\n-            case 'S': // millisecond (number)\n-                rule = selectNumberRule(Calendar.MILLISECOND, tokenLen);\n-                break;\n-            case 'E': // day in week (text)\n-                rule = new TextField(Calendar.DAY_OF_WEEK, tokenLen < 4 ? shortWeekdays : weekdays);\n-                break;\n-            case 'D': // day in year (number)\n-                rule = selectNumberRule(Calendar.DAY_OF_YEAR, tokenLen);\n-                break;\n-            case 'F': // day of week in month (number)\n-                rule = selectNumberRule(Calendar.DAY_OF_WEEK_IN_MONTH, tokenLen);\n-                break;\n-            case 'w': // week in year (number)\n-                rule = selectNumberRule(Calendar.WEEK_OF_YEAR, tokenLen);\n-                break;\n-            case 'W': // week in month (number)\n-                rule = selectNumberRule(Calendar.WEEK_OF_MONTH, tokenLen);\n-                break;\n-            case 'a': // am/pm marker (text)\n-                rule = new TextField(Calendar.AM_PM, AmPmStrings);\n-                break;\n-            case 'k': // hour in day (1..24)\n-                rule = new TwentyFourHourField(selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen));\n-                break;\n-            case 'K': // hour in am/pm (0..11)\n-                rule = selectNumberRule(Calendar.HOUR, tokenLen);\n-                break;\n-            case 'z': // time zone (text)\n-                if (tokenLen >= 4) {\n-                    rule = new TimeZoneNameRule(mTimeZone, mLocale, TimeZone.LONG);\n-                } else {\n-                    rule = new TimeZoneNameRule(mTimeZone, mLocale, TimeZone.SHORT);\n-                }\n-                break;\n-            case 'Z': // time zone (value)\n-                if (tokenLen == 1) {\n-                    rule = TimeZoneNumberRule.INSTANCE_NO_COLON;\n-                } else {\n-                    rule = TimeZoneNumberRule.INSTANCE_COLON;\n-                }\n-                break;\n-            case '\\'': // literal text\n-                String sub = token.substring(1);\n-                if (sub.length() == 1) {\n-                    rule = new CharacterLiteral(sub.charAt(0));\n-                } else {\n-                    rule = new StringLiteral(sub);\n-                }\n-                break;\n-            default:\n-                throw new IllegalArgumentException(\"Illegal pattern component: \" + token);\n-            }\n-\n-            rules.add(rule);\n-        }\n-\n-        return rules;\n-    }\n-\n-    /**\n-     * <p>Performs the parsing of tokens.</p>\n-     *\n-     * @param pattern  the pattern\n-     * @param indexRef  index references\n-     * @return parsed token\n-     */\n-    protected String parseToken(String pattern, int[] indexRef) {\n-        StringBuilder buf = new StringBuilder();\n-\n-        int i = indexRef[0];\n-        int length = pattern.length();\n-\n-        char c = pattern.charAt(i);\n-        if (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z') {\n-            // Scan a run of the same character, which indicates a time\n-            // pattern.\n-            buf.append(c);\n-\n-            while (i + 1 < length) {\n-                char peek = pattern.charAt(i + 1);\n-                if (peek == c) {\n-                    buf.append(c);\n-                    i++;\n-                } else {\n-                    break;\n-                }\n-            }\n-        } else {\n-            // This will identify token as text.\n-            buf.append('\\'');\n-\n-            boolean inLiteral = false;\n-\n-            for (; i < length; i++) {\n-                c = pattern.charAt(i);\n-\n-                if (c == '\\'') {\n-                    if (i + 1 < length && pattern.charAt(i + 1) == '\\'') {\n-                        // '' is treated as escaped '\n-                        i++;\n-                        buf.append(c);\n-                    } else {\n-                        inLiteral = !inLiteral;\n-                    }\n-                } else if (!inLiteral &&\n-                         (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z')) {\n-                    i--;\n-                    break;\n-                } else {\n-                    buf.append(c);\n-                }\n-            }\n-        }\n-\n-        indexRef[0] = i;\n-        return buf.toString();\n-    }\n-\n-    /**\n-     * <p>Gets an appropriate rule for the padding required.</p>\n-     *\n-     * @param field  the field to get a rule for\n-     * @param padding  the padding required\n-     * @return a new rule with the correct padding\n-     */\n-    protected NumberRule selectNumberRule(int field, int padding) {\n-        switch (padding) {\n-        case 1:\n-            return new UnpaddedNumberField(field);\n-        case 2:\n-            return new TwoDigitNumberField(field);\n-        default:\n-            return new PaddedNumberField(field, padding);\n-        }\n+        printer= new FastDatePrinter(pattern, timeZone, locale);\n+        parser= new FastDateParser(pattern, timeZone, locale);\n     }\n \n     // Format methods\n      */\n     @Override\n     public StringBuffer format(Object obj, StringBuffer toAppendTo, FieldPosition pos) {\n-        if (obj instanceof Date) {\n-            return format((Date) obj, toAppendTo);\n-        } else if (obj instanceof Calendar) {\n-            return format((Calendar) obj, toAppendTo);\n-        } else if (obj instanceof Long) {\n-            return format(((Long) obj).longValue(), toAppendTo);\n-        } else {\n-            throw new IllegalArgumentException(\"Unknown class: \" +\n-                (obj == null ? \"<null>\" : obj.getClass().getName()));\n-        }\n+        return printer.format(obj, toAppendTo, pos);\n     }\n \n     /**\n      * @return the formatted string\n      */\n     public String format(Date date) {\n-        Calendar c = new GregorianCalendar(mTimeZone, mLocale);  // hard code GregorianCalendar\n-        c.setTime(date);\n-        return applyRules(c, new StringBuffer(mMaxLengthEstimate)).toString();\n+        return printer.format(date);\n     }\n \n     /**\n      * @return the formatted string\n      */\n     public String format(Calendar calendar) {\n-        return format(calendar, new StringBuffer(mMaxLengthEstimate)).toString();\n+        return printer.format(calendar);\n     }\n \n     /**\n      * @since 2.1\n      */\n     public StringBuffer format(long millis, StringBuffer buf) {\n-        return format(new Date(millis), buf);\n+        return printer.format(millis, buf);\n     }\n \n     /**\n      * @return the specified string buffer\n      */\n     public StringBuffer format(Date date, StringBuffer buf) {\n-        Calendar c = new GregorianCalendar(mTimeZone, mLocale);  // hard code GregorianCalendar\n-        c.setTime(date);\n-        return applyRules(c, buf);\n+        return printer.format(date, buf);\n     }\n \n     /**\n      * @return the specified string buffer\n      */\n     public StringBuffer format(Calendar calendar, StringBuffer buf) {\n-        return applyRules(calendar, buf);\n-    }\n-\n-    /**\n-     * <p>Performs the formatting by applying the rules to the\n-     * specified calendar.</p>\n-     *\n-     * @param calendar  the calendar to format\n-     * @param buf  the buffer to format into\n-     * @return the specified string buffer\n-     */\n-    protected StringBuffer applyRules(Calendar calendar, StringBuffer buf) {\n-        for (Rule rule : mRules) {\n-            rule.appendTo(buf, calendar);\n-        }\n-        return buf;\n+        return printer.format(calendar, buf);\n     }\n \n     // Parsing\n     //-----------------------------------------------------------------------\n-    /**\n-     * <p>Parsing is not supported.</p>\n-     *\n-     * @param source  the string to parse\n-     * @param pos  the parsing position\n-     * @return {@code null} as not supported\n+\n+    \n+    /* (non-Javadoc)\n+     * @see DateParser#parse(java.lang.String)\n+     */\n+    @Override\n+    public Date parse(String source) throws ParseException {\n+        return parser.parse(source);\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see DateParser#parse(java.lang.String, java.text.ParsePosition)\n+     */\n+    @Override\n+    public Date parse(String source, ParsePosition pos) {\n+            return parser.parse(source, pos);\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see java.text.Format#parseObject(java.lang.String, java.text.ParsePosition)\n      */\n     @Override\n     public Object parseObject(String source, ParsePosition pos) {\n-        pos.setIndex(0);\n-        pos.setErrorIndex(0);\n-        return null;\n+        return parser.parseObject(source, pos);\n     }\n \n     // Accessors\n      * @return the pattern, {@link java.text.SimpleDateFormat} compatible\n      */\n     public String getPattern() {\n-        return mPattern;\n+        return printer.getPattern();\n     }\n \n     /**\n      * @return the time zone\n      */\n     public TimeZone getTimeZone() {\n-        return mTimeZone;\n+        return printer.getTimeZone();\n     }\n \n     /**\n      * @return the locale\n      */\n     public Locale getLocale() {\n-        return mLocale;\n+        return printer.getLocale();\n     }\n \n     /**\n      * @return the maximum formatted length\n      */\n     public int getMaxLengthEstimate() {\n-        return mMaxLengthEstimate;\n+        return printer.getMaxLengthEstimate();\n     }\n \n     // Basics\n             return false;\n         }\n         FastDateFormat other = (FastDateFormat) obj;\n-        return mPattern.equals(other.mPattern)\n-            && mTimeZone.equals(other.mTimeZone) \n-            && mLocale.equals(other.mLocale);\n+        // no need to check parser, as it has same invariants as printer\n+        return printer.equals(other.printer);\n     }\n \n     /**\n      */\n     @Override\n     public int hashCode() {\n-        return mPattern.hashCode() + 13 * (mTimeZone.hashCode() + 13 * mLocale.hashCode());\n+        return printer.hashCode();\n     }\n \n     /**\n      */\n     @Override\n     public String toString() {\n-        return \"FastDateFormat[\" + mPattern + \"]\";\n-    }\n-\n-    // Serializing\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Create the object after serialization. This implementation reinitializes the\n-     * transient properties.\n-     *\n-     * @param in ObjectInputStream from which the object is being deserialized.\n-     * @throws IOException if there is an IO issue.\n-     * @throws ClassNotFoundException if a class cannot be found.\n-     */\n-    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n-        in.defaultReadObject();\n-        init();\n-    }\n-\n-    // Rules\n-    //-----------------------------------------------------------------------\n-    /**\n-     * <p>Inner class defining a rule.</p>\n-     */\n-    private interface Rule {\n-        /**\n-         * Returns the estimated lentgh of the result.\n-         *\n-         * @return the estimated length\n-         */\n-        int estimateLength();\n-\n-        /**\n-         * Appends the value of the specified calendar to the output buffer based on the rule implementation.\n-         *\n-         * @param buffer the output buffer\n-         * @param calendar calendar to be appended\n-         */\n-        void appendTo(StringBuffer buffer, Calendar calendar);\n-    }\n-\n-    /**\n-     * <p>Inner class defining a numeric rule.</p>\n-     */\n-    private interface NumberRule extends Rule {\n-        /**\n-         * Appends the specified value to the output buffer based on the rule implementation.\n-         *\n-         * @param buffer the output buffer\n-         * @param value the value to be appended\n-         */\n-        void appendTo(StringBuffer buffer, int value);\n-    }\n-\n-    /**\n-     * <p>Inner class to output a constant single character.</p>\n-     */\n-    private static class CharacterLiteral implements Rule {\n-        private final char mValue;\n-\n-        /**\n-         * Constructs a new instance of {@code CharacterLiteral}\n-         * to hold the specified value.\n-         *\n-         * @param value the character literal\n-         */\n-        CharacterLiteral(char value) {\n-            mValue = value;\n-        }\n-\n-        /**\n-         * {@inheritDoc}\n-         */\n-        public int estimateLength() {\n-            return 1;\n-        }\n-\n-        /**\n-         * {@inheritDoc}\n-         */\n-        public void appendTo(StringBuffer buffer, Calendar calendar) {\n-            buffer.append(mValue);\n-        }\n-    }\n-\n-    /**\n-     * <p>Inner class to output a constant string.</p>\n-     */\n-    private static class StringLiteral implements Rule {\n-        private final String mValue;\n-\n-        /**\n-         * Constructs a new instance of {@code StringLiteral}\n-         * to hold the specified value.\n-         *\n-         * @param value the string literal\n-         */\n-        StringLiteral(String value) {\n-            mValue = value;\n-        }\n-\n-        /**\n-         * {@inheritDoc}\n-         */\n-        public int estimateLength() {\n-            return mValue.length();\n-        }\n-\n-        /**\n-         * {@inheritDoc}\n-         */\n-        public void appendTo(StringBuffer buffer, Calendar calendar) {\n-            buffer.append(mValue);\n-        }\n-    }\n-\n-    /**\n-     * <p>Inner class to output one of a set of values.</p>\n-     */\n-    private static class TextField implements Rule {\n-        private final int mField;\n-        private final String[] mValues;\n-\n-        /**\n-         * Constructs an instance of {@code TextField}\n-         * with the specified field and values.\n-         *\n-         * @param field the field\n-         * @param values the field values\n-         */\n-        TextField(int field, String[] values) {\n-            mField = field;\n-            mValues = values;\n-        }\n-\n-        /**\n-         * {@inheritDoc}\n-         */\n-        public int estimateLength() {\n-            int max = 0;\n-            for (int i=mValues.length; --i >= 0; ) {\n-                int len = mValues[i].length();\n-                if (len > max) {\n-                    max = len;\n-                }\n-            }\n-            return max;\n-        }\n-\n-        /**\n-         * {@inheritDoc}\n-         */\n-        public void appendTo(StringBuffer buffer, Calendar calendar) {\n-            buffer.append(mValues[calendar.get(mField)]);\n-        }\n-    }\n-\n-    /**\n-     * <p>Inner class to output an unpadded number.</p>\n-     */\n-    private static class UnpaddedNumberField implements NumberRule {\n-        private final int mField;\n-\n-        /**\n-         * Constructs an instance of {@code UnpadedNumberField} with the specified field.\n-         *\n-         * @param field the field\n-         */\n-        UnpaddedNumberField(int field) {\n-            mField = field;\n-        }\n-\n-        /**\n-         * {@inheritDoc}\n-         */\n-        public int estimateLength() {\n-            return 4;\n-        }\n-\n-        /**\n-         * {@inheritDoc}\n-         */\n-        public void appendTo(StringBuffer buffer, Calendar calendar) {\n-            appendTo(buffer, calendar.get(mField));\n-        }\n-\n-        /**\n-         * {@inheritDoc}\n-         */\n-        public final void appendTo(StringBuffer buffer, int value) {\n-            if (value < 10) {\n-                buffer.append((char)(value + '0'));\n-            } else if (value < 100) {\n-                buffer.append((char)(value / 10 + '0'));\n-                buffer.append((char)(value % 10 + '0'));\n-            } else {\n-                buffer.append(Integer.toString(value));\n-            }\n-        }\n-    }\n-\n-    /**\n-     * <p>Inner class to output an unpadded month.</p>\n-     */\n-    private static class UnpaddedMonthField implements NumberRule {\n-        static final UnpaddedMonthField INSTANCE = new UnpaddedMonthField();\n-\n-        /**\n-         * Constructs an instance of {@code UnpaddedMonthField}.\n-         *\n-         */\n-        UnpaddedMonthField() {\n-            super();\n-        }\n-\n-        /**\n-         * {@inheritDoc}\n-         */\n-        public int estimateLength() {\n-            return 2;\n-        }\n-\n-        /**\n-         * {@inheritDoc}\n-         */\n-        public void appendTo(StringBuffer buffer, Calendar calendar) {\n-            appendTo(buffer, calendar.get(Calendar.MONTH) + 1);\n-        }\n-\n-        /**\n-         * {@inheritDoc}\n-         */\n-        public final void appendTo(StringBuffer buffer, int value) {\n-            if (value < 10) {\n-                buffer.append((char)(value + '0'));\n-            } else {\n-                buffer.append((char)(value / 10 + '0'));\n-                buffer.append((char)(value % 10 + '0'));\n-            }\n-        }\n-    }\n-\n-    /**\n-     * <p>Inner class to output a padded number.</p>\n-     */\n-    private static class PaddedNumberField implements NumberRule {\n-        private final int mField;\n-        private final int mSize;\n-\n-        /**\n-         * Constructs an instance of {@code PaddedNumberField}.\n-         *\n-         * @param field the field\n-         * @param size size of the output field\n-         */\n-        PaddedNumberField(int field, int size) {\n-            if (size < 3) {\n-                // Should use UnpaddedNumberField or TwoDigitNumberField.\n-                throw new IllegalArgumentException();\n-            }\n-            mField = field;\n-            mSize = size;\n-        }\n-\n-        /**\n-         * {@inheritDoc}\n-         */\n-        public int estimateLength() {\n-            return 4;\n-        }\n-\n-        /**\n-         * {@inheritDoc}\n-         */\n-        public void appendTo(StringBuffer buffer, Calendar calendar) {\n-            appendTo(buffer, calendar.get(mField));\n-        }\n-\n-        /**\n-         * {@inheritDoc}\n-         */\n-        public final void appendTo(StringBuffer buffer, int value) {\n-            if (value < 100) {\n-                for (int i = mSize; --i >= 2; ) {\n-                    buffer.append('0');\n-                }\n-                buffer.append((char)(value / 10 + '0'));\n-                buffer.append((char)(value % 10 + '0'));\n-            } else {\n-                int digits;\n-                if (value < 1000) {\n-                    digits = 3;\n-                } else {\n-                    Validate.isTrue(value > -1, \"Negative values should not be possible\", value);\n-                    digits = Integer.toString(value).length();\n-                }\n-                for (int i = mSize; --i >= digits; ) {\n-                    buffer.append('0');\n-                }\n-                buffer.append(Integer.toString(value));\n-            }\n-        }\n-    }\n-\n-    /**\n-     * <p>Inner class to output a two digit number.</p>\n-     */\n-    private static class TwoDigitNumberField implements NumberRule {\n-        private final int mField;\n-\n-        /**\n-         * Constructs an instance of {@code TwoDigitNumberField} with the specified field.\n-         *\n-         * @param field the field\n-         */\n-        TwoDigitNumberField(int field) {\n-            mField = field;\n-        }\n-\n-        /**\n-         * {@inheritDoc}\n-         */\n-        public int estimateLength() {\n-            return 2;\n-        }\n-\n-        /**\n-         * {@inheritDoc}\n-         */\n-        public void appendTo(StringBuffer buffer, Calendar calendar) {\n-            appendTo(buffer, calendar.get(mField));\n-        }\n-\n-        /**\n-         * {@inheritDoc}\n-         */\n-        public final void appendTo(StringBuffer buffer, int value) {\n-            if (value < 100) {\n-                buffer.append((char)(value / 10 + '0'));\n-                buffer.append((char)(value % 10 + '0'));\n-            } else {\n-                buffer.append(Integer.toString(value));\n-            }\n-        }\n-    }\n-\n-    /**\n-     * <p>Inner class to output a two digit year.</p>\n-     */\n-    private static class TwoDigitYearField implements NumberRule {\n-        static final TwoDigitYearField INSTANCE = new TwoDigitYearField();\n-\n-        /**\n-         * Constructs an instance of {@code TwoDigitYearField}.\n-         */\n-        TwoDigitYearField() {\n-            super();\n-        }\n-\n-        /**\n-         * {@inheritDoc}\n-         */\n-        public int estimateLength() {\n-            return 2;\n-        }\n-\n-        /**\n-         * {@inheritDoc}\n-         */\n-        public void appendTo(StringBuffer buffer, Calendar calendar) {\n-            appendTo(buffer, calendar.get(Calendar.YEAR) % 100);\n-        }\n-\n-        /**\n-         * {@inheritDoc}\n-         */\n-        public final void appendTo(StringBuffer buffer, int value) {\n-            buffer.append((char)(value / 10 + '0'));\n-            buffer.append((char)(value % 10 + '0'));\n-        }\n-    }\n-\n-    /**\n-     * <p>Inner class to output a two digit month.</p>\n-     */\n-    private static class TwoDigitMonthField implements NumberRule {\n-        static final TwoDigitMonthField INSTANCE = new TwoDigitMonthField();\n-\n-        /**\n-         * Constructs an instance of {@code TwoDigitMonthField}.\n-         */\n-        TwoDigitMonthField() {\n-            super();\n-        }\n-\n-        /**\n-         * {@inheritDoc}\n-         */\n-        public int estimateLength() {\n-            return 2;\n-        }\n-\n-        /**\n-         * {@inheritDoc}\n-         */\n-        public void appendTo(StringBuffer buffer, Calendar calendar) {\n-            appendTo(buffer, calendar.get(Calendar.MONTH) + 1);\n-        }\n-\n-        /**\n-         * {@inheritDoc}\n-         */\n-        public final void appendTo(StringBuffer buffer, int value) {\n-            buffer.append((char)(value / 10 + '0'));\n-            buffer.append((char)(value % 10 + '0'));\n-        }\n-    }\n-\n-    /**\n-     * <p>Inner class to output the twelve hour field.</p>\n-     */\n-    private static class TwelveHourField implements NumberRule {\n-        private final NumberRule mRule;\n-\n-        /**\n-         * Constructs an instance of {@code TwelveHourField} with the specified\n-         * {@code NumberRule}.\n-         *\n-         * @param rule the rule\n-         */\n-        TwelveHourField(NumberRule rule) {\n-            mRule = rule;\n-        }\n-\n-        /**\n-         * {@inheritDoc}\n-         */\n-        public int estimateLength() {\n-            return mRule.estimateLength();\n-        }\n-\n-        /**\n-         * {@inheritDoc}\n-         */\n-        public void appendTo(StringBuffer buffer, Calendar calendar) {\n-            int value = calendar.get(Calendar.HOUR);\n-            if (value == 0) {\n-                value = calendar.getLeastMaximum(Calendar.HOUR) + 1;\n-            }\n-            mRule.appendTo(buffer, value);\n-        }\n-\n-        /**\n-         * {@inheritDoc}\n-         */\n-        public void appendTo(StringBuffer buffer, int value) {\n-            mRule.appendTo(buffer, value);\n-        }\n-    }\n-\n-    /**\n-     * <p>Inner class to output the twenty four hour field.</p>\n-     */\n-    private static class TwentyFourHourField implements NumberRule {\n-        private final NumberRule mRule;\n-\n-        /**\n-         * Constructs an instance of {@code TwentyFourHourField} with the specified\n-         * {@code NumberRule}.\n-         *\n-         * @param rule the rule\n-         */\n-        TwentyFourHourField(NumberRule rule) {\n-            mRule = rule;\n-        }\n-\n-        /**\n-         * {@inheritDoc}\n-         */\n-        public int estimateLength() {\n-            return mRule.estimateLength();\n-        }\n-\n-        /**\n-         * {@inheritDoc}\n-         */\n-        public void appendTo(StringBuffer buffer, Calendar calendar) {\n-            int value = calendar.get(Calendar.HOUR_OF_DAY);\n-            if (value == 0) {\n-                value = calendar.getMaximum(Calendar.HOUR_OF_DAY) + 1;\n-            }\n-            mRule.appendTo(buffer, value);\n-        }\n-\n-        /**\n-         * {@inheritDoc}\n-         */\n-        public void appendTo(StringBuffer buffer, int value) {\n-            mRule.appendTo(buffer, value);\n-        }\n-    }\n-\n-    /**\n-     * <p>Inner class to output a time zone name.</p>\n-     */\n-    private static class TimeZoneNameRule implements Rule {\n-        private final TimeZone mTimeZone;\n-        private final String mStandard;\n-        private final String mDaylight;\n-\n-        /**\n-         * Constructs an instance of {@code TimeZoneNameRule} with the specified properties.\n-         *\n-         * @param timeZone the time zone\n-         * @param locale the locale\n-         * @param style the style\n-         */\n-        TimeZoneNameRule(TimeZone timeZone, Locale locale, int style) {\n-            mTimeZone = timeZone;\n-\n-            mStandard = getTimeZoneDisplay(timeZone, false, style, locale);\n-            mDaylight = getTimeZoneDisplay(timeZone, true, style, locale);\n-        }\n-\n-        /**\n-         * {@inheritDoc}\n-         */\n-        public int estimateLength() {\n-            return Math.max(mStandard.length(), mDaylight.length());\n-        }\n-\n-        /**\n-         * {@inheritDoc}\n-         */\n-        public void appendTo(StringBuffer buffer, Calendar calendar) {\n-            if (mTimeZone.useDaylightTime() && calendar.get(Calendar.DST_OFFSET) != 0) {\n-                buffer.append(mDaylight);\n-            } else {\n-                buffer.append(mStandard);\n-            }\n-        }\n-    }\n-\n-    /**\n-     * <p>Inner class to output a time zone as a number {@code +/-HHMM}\n-     * or {@code +/-HH:MM}.</p>\n-     */\n-    private static class TimeZoneNumberRule implements Rule {\n-        static final TimeZoneNumberRule INSTANCE_COLON = new TimeZoneNumberRule(true);\n-        static final TimeZoneNumberRule INSTANCE_NO_COLON = new TimeZoneNumberRule(false);\n-\n-        final boolean mColon;\n-\n-        /**\n-         * Constructs an instance of {@code TimeZoneNumberRule} with the specified properties.\n-         *\n-         * @param colon add colon between HH and MM in the output if {@code true}\n-         */\n-        TimeZoneNumberRule(boolean colon) {\n-            mColon = colon;\n-        }\n-\n-        /**\n-         * {@inheritDoc}\n-         */\n-        public int estimateLength() {\n-            return 5;\n-        }\n-\n-        /**\n-         * {@inheritDoc}\n-         */\n-        public void appendTo(StringBuffer buffer, Calendar calendar) {\n-            int offset = calendar.get(Calendar.ZONE_OFFSET) + calendar.get(Calendar.DST_OFFSET);\n-\n-            if (offset < 0) {\n-                buffer.append('-');\n-                offset = -offset;\n-            } else {\n-                buffer.append('+');\n-            }\n-\n-            int hours = offset / (60 * 60 * 1000);\n-            buffer.append((char)(hours / 10 + '0'));\n-            buffer.append((char)(hours % 10 + '0'));\n-\n-            if (mColon) {\n-                buffer.append(':');\n-            }\n-\n-            int minutes = offset / (60 * 1000) - 60 * hours;\n-            buffer.append((char)(minutes / 10 + '0'));\n-            buffer.append((char)(minutes % 10 + '0'));\n-        }\n-    }\n-\n-    // ----------------------------------------------------------------------\n-    /**\n-     * <p>Inner class that acts as a compound key for time zone names.</p>\n-     */\n-    private static class TimeZoneDisplayKey {\n-        private final TimeZone mTimeZone;\n-        private final int mStyle;\n-        private final Locale mLocale;\n-\n-        /**\n-         * Constructs an instance of {@code TimeZoneDisplayKey} with the specified properties.\n-         *\n-         * @param timeZone the time zone\n-         * @param daylight adjust the style for daylight saving time if {@code true}\n-         * @param style the timezone style\n-         * @param locale the timezone locale\n-         */\n-        TimeZoneDisplayKey(TimeZone timeZone,\n-                           boolean daylight, int style, Locale locale) {\n-            mTimeZone = timeZone;\n-            if (daylight) {\n-                style |= 0x80000000;\n-            }\n-            mStyle = style;\n-            mLocale = locale;\n-        }\n-\n-        /**\n-         * {@inheritDoc}\n-         */\n-        @Override\n-        public int hashCode() {\n-            return (mStyle * 31 + mLocale.hashCode() ) * 31 + mTimeZone.hashCode();\n-        }\n-\n-        /**\n-         * {@inheritDoc}\n-         */\n-        @Override\n-        public boolean equals(Object obj) {\n-            if (this == obj) {\n-                return true;\n-            }\n-            if (obj instanceof TimeZoneDisplayKey) {\n-                TimeZoneDisplayKey other = (TimeZoneDisplayKey)obj;\n-                return\n-                    mTimeZone.equals(other.mTimeZone) &&\n-                    mStyle == other.mStyle &&\n-                    mLocale.equals(other.mLocale);\n-            }\n-            return false;\n-        }\n-    }\n+        return \"FastDateFormat[\" + printer.getPattern() + \",\" + printer.getLocale() + \",\" + printer.getTimeZone().getID() + \"]\";\n+    }\n+\n+\n+    /**\n+     * <p>Performs the formatting by applying the rules to the\n+     * specified calendar.</p>\n+     *\n+     * @param calendar  the calendar to format\n+     * @param buf  the buffer to format into\n+     * @return the specified string buffer\n+     */\n+    protected StringBuffer applyRules(Calendar calendar, StringBuffer buf) {\n+        return printer.applyRules(calendar, buf);\n+    }\n+\n+\n }\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/lang3/time/FastDateParser.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang3.time;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.Serializable;\n+import java.text.DateFormatSymbols;\n+import java.text.ParseException;\n+import java.text.ParsePosition;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Calendar;\n+import java.util.Comparator;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.SortedMap;\n+import java.util.TimeZone;\n+import java.util.TreeMap;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * <p>FastDateParser is a fast and thread-safe version of\n+ * {@link java.text.SimpleDateFormat}.</p>\n+ * \n+ * <p>This class can be used as a direct replacement to\n+ * <code>SimpleDateFormat</code> in most parsing situations.\n+ * This class is especially useful in multi-threaded server environments.\n+ * <code>SimpleDateFormat</code> is not thread-safe in any JDK version,\n+ * nor will it be as Sun have closed the \n+ * <a href=\"http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4228335\">bug</a>/RFE.\n+ * </p>\n+ *\n+ * <p>Only parsing is supported, but all patterns are compatible with\n+ * SimpleDateFormat.</p>\n+ * \n+ * <p>Timing tests indicate this class is as about as fast as SimpleDateFormat\n+ * in single thread applications and about 25% faster in multi-thread applications.</p>\n+ *\n+ * @since 3.2\n+ */\n+public class FastDateParser implements DateParser, Serializable {\n+    /**\n+     * Required for serialization support.\n+     * \n+     * @see java.io.Serializable\n+     */\n+    private static final long serialVersionUID = 1L;\n+    \n+    private static final ConcurrentMap<Locale,TimeZoneStrategy> tzsCache= \n+        new ConcurrentHashMap<Locale,TimeZoneStrategy>(3);\n+    \n+    // defining fields\n+    private final String pattern;\n+    private final TimeZone timeZone;\n+    private final Locale locale;\n+    \n+    // derived fields\n+    private transient Pattern parsePattern;\n+    private transient Strategy[] strategies;\n+    private transient int thisYear;\n+    private transient ConcurrentMap<Integer, KeyValue[]> nameValues;\n+\n+    // dynamic fields to communicate with Strategy\n+    private transient String currentFormatField;\n+    private transient Strategy nextStrategy;\n+\n+    /**\n+     * <p>Constructs a new FastDateParser.</p>\n+     * \n+     * @param pattern non-null {@link java.text.SimpleDateFormat} compatible\n+     *  pattern\n+     * @param timeZone non-null time zone to use\n+     * @param locale non-null locale\n+     */\n+    protected FastDateParser(String pattern, TimeZone timeZone, Locale locale) {\n+        this.pattern = pattern;\n+        this.timeZone = timeZone;\n+        this.locale = locale;        \n+        init();\n+    }\n+    \n+    /**\n+     * Initialize derived fields from defining fields.\n+     * This is called from constructor and from readObject (de-serialization)   \n+     */\n+    private void init() {\n+        thisYear= Calendar.getInstance(timeZone, locale).get(Calendar.YEAR);\n+        \n+        nameValues= new ConcurrentHashMap<Integer, KeyValue[]>();\n+        \n+        StringBuilder regex= new StringBuilder();\n+        List<Strategy> collector = new ArrayList<Strategy>();\n+        \n+        Matcher patternMatcher= formatPattern.matcher(pattern);\n+        if(!patternMatcher.lookingAt()) {\n+            throw new IllegalArgumentException(\"Invalid pattern\");\n+        }\n+        \n+        currentFormatField= patternMatcher.group();\n+        Strategy currentStrategy= getStrategy(currentFormatField);\n+        for(;;) {\n+            patternMatcher.region(patternMatcher.end(), patternMatcher.regionEnd());\n+            if(!patternMatcher.lookingAt()) {\n+                nextStrategy = null;\n+                break;\n+            }\n+            String nextFormatField= patternMatcher.group();\n+            nextStrategy = getStrategy(nextFormatField);\n+            if(currentStrategy.addRegex(this, regex)) {\n+                collector.add(currentStrategy);                \n+            }\n+            currentFormatField= nextFormatField;\n+            currentStrategy= nextStrategy;\n+        }\n+        if(currentStrategy.addRegex(this, regex)) {\n+            collector.add(currentStrategy);                \n+        }\n+        currentFormatField= null;\n+        strategies= collector.toArray(new Strategy[collector.size()]);\n+        parsePattern= Pattern.compile(regex.toString());\n+    }\n+    \n+    // Accessors\n+    //-----------------------------------------------------------------------\n+    /* (non-Javadoc)\n+     * @see org.apache.commons.lang3.time.DateParser#getPattern()\n+     */\n+    @Override\n+    public String getPattern() {\n+        return pattern;\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see org.apache.commons.lang3.time.DateParser#getTimeZone()\n+     */\n+    @Override\n+    public TimeZone getTimeZone() {\n+        return timeZone;\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see org.apache.commons.lang3.time.DateParser#getLocale()\n+     */\n+    @Override\n+    public Locale getLocale() {\n+        return locale;\n+    }\n+\n+    // Basics\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Compare another object for equality with this object.</p>\n+     * \n+     * @param obj  the object to compare to\n+     * @return <code>true</code>if equal to this instance\n+     */\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (! (obj instanceof FastDateParser) ) {\n+            return false;\n+        }\n+        FastDateParser other = (FastDateParser) obj;\n+        return pattern.equals(other.pattern)\n+            && timeZone.equals(other.timeZone) \n+            && locale.equals(other.locale);\n+    }\n+\n+    /**\n+     * <p>Return a hashcode compatible with equals.</p>\n+     * \n+     * @return a hashcode compatible with equals\n+     */\n+    @Override\n+    public int hashCode() {\n+        return pattern.hashCode() + 13 * (timeZone.hashCode() + 13 * locale.hashCode());\n+    }\n+\n+    /**\n+     * <p>Get a string version of this formatter.</p>\n+     * \n+     * @return a debugging string\n+     */\n+    @Override\n+    public String toString() {\n+        return \"FastDateParser[\" + pattern + \",\" + locale + \",\" + timeZone.getID() + \"]\";\n+    }\n+\n+    // Serializing\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Create the object after serialization. This implementation reinitializes the \n+     * transient properties.\n+     *\n+     * @param in ObjectInputStream from which the object is being deserialized.\n+     * @throws IOException if there is an IO issue.\n+     * @throws ClassNotFoundException if a class cannot be found.\n+     */\n+    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n+        in.defaultReadObject();\n+        init();\n+    }\n+    \n+    /* (non-Javadoc)\n+     * @see org.apache.commons.lang3.time.DateParser#parseObject(java.lang.String)\n+     */\n+    @Override\n+    public Object parseObject(String source) throws ParseException {\n+        return parse(source);\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see org.apache.commons.lang3.time.DateParser#parse(java.lang.String)\n+     */\n+    @Override\n+    public Date parse(String source) throws ParseException {\n+        Date date= parse(source, new ParsePosition(0));\n+        if(date==null) {\n+            throw new ParseException(source+\" does not match \"+parsePattern.pattern(), 0);            \n+        }\n+        return date;\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see org.apache.commons.lang3.time.DateParser#parseObject(java.lang.String, java.text.ParsePosition)\n+     */\n+    @Override\n+    public Object parseObject(String source, ParsePosition pos) {\n+        return parse(source, pos);\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see org.apache.commons.lang3.time.DateParser#parse(java.lang.String, java.text.ParsePosition)\n+     */\n+    @Override\n+    public Date parse(String source, ParsePosition pos) {\n+        int offset= pos.getIndex();\n+        Matcher matcher= parsePattern.matcher(source.substring(offset));\n+        if(!matcher.lookingAt()) {\n+            return null;\n+        }\n+        // timing tests indicate getting new instance is 19% faster than cloning\n+        Calendar cal= Calendar.getInstance(timeZone, locale);\n+        cal.clear();\n+\n+        for(int i=0; i<strategies.length;) {\n+            Strategy strategy= strategies[i++];\n+            strategy.setCalendar(this, cal, matcher.group(i));\n+        }\n+        pos.setIndex(offset+matcher.end());\n+        return cal.getTime();\n+    }\n+        \n+    // Support for strategies\n+    //-----------------------------------------------------------------------\n+\n+    /**\n+     * Escape constant fields into regular expression\n+     * @param regex The destination regex\n+     * @param value The source field\n+     * @param unquote If true, replace two success quotes ('') with single quote (')\n+     * @return The <code>StringBuilder</code>\n+     */\n+    private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) {\n+        boolean wasWhite= false;\n+        for(int i= 0; i<value.length(); ++i) {\n+            char c= value.charAt(i);\n+            if(Character.isWhitespace(c)) {\n+                if(!wasWhite) {\n+                    wasWhite= true;\n+                    regex.append(\"\\\\s*+\");\n+                }\n+                continue;\n+            }\n+            wasWhite= false;\n+            switch(c) {\n+            case '\\'':\n+                if(unquote) {\n+                    if(++i==value.length()) {\n+                        return regex;\n+                    }\n+                    c= value.charAt(i);\n+                }\n+                break;\n+            case '?':\n+            case '[':\n+            case ']':\n+            case '(':\n+            case ')':\n+            case '{':\n+            case '}':\n+            case '\\\\':\n+            case '|':\n+            case '*':\n+            case '+':\n+            case '^':\n+            case '$':\n+            case '.':\n+                regex.append('\\\\');\n+            }\n+            regex.append(c);\n+        }\n+        return regex;\n+    }\n+    \n+    /**\n+     * A class to store Key / Value pairs\n+     */\n+    private static class KeyValue {\n+        public String key;\n+        public int value;\n+\n+        /**\n+         * Construct a Key / Value pair \n+         * @param key The key\n+         * @param value The value\n+         */\n+        public KeyValue(String key, int value) {\n+            this.key= key;\n+            this.value= value;\n+        }\n+    }\n+    \n+    /**\n+     * ignore case comparison of keys\n+     */\n+    private static final Comparator<KeyValue> IGNORE_CASE_COMPARATOR = new Comparator<KeyValue> () {\n+        public int compare(KeyValue left, KeyValue right) {\n+            return left.key.compareToIgnoreCase(right.key);\n+        }        \n+    };\n+\n+    /**\n+     * Get the short and long values displayed for a field\n+     * @param field The field of interest\n+     * @return A sorted array of the field key / value pairs\n+     */\n+    KeyValue[] getDisplayNames(int field) {\n+        KeyValue[] fieldKeyValues= nameValues.get(field);\n+        if(fieldKeyValues==null) {\n+            DateFormatSymbols symbols= DateFormatSymbols.getInstance(locale);\n+            switch(field) {\n+            case Calendar.ERA:\n+                fieldKeyValues= createKeyValues(symbols.getEras(), null);\n+                break;\n+            case Calendar.DAY_OF_WEEK:\n+                fieldKeyValues= createKeyValues(symbols.getWeekdays(), symbols.getShortWeekdays());\n+                break;\n+            case Calendar.AM_PM:\n+                fieldKeyValues= createKeyValues(symbols.getAmPmStrings(), null);\n+                break;\n+            case Calendar.MONTH:\n+                fieldKeyValues= createKeyValues(symbols.getMonths(), symbols.getShortMonths());\n+                break;\n+            default:\n+                throw new IllegalArgumentException(\"Invalid field value \"+field);\n+            }\n+            KeyValue[] prior = nameValues.putIfAbsent(field, fieldKeyValues);\n+            if(prior!=null) {\n+                fieldKeyValues= prior;\n+            }\n+        }\n+        return fieldKeyValues;\n+    }\n+    \n+    /**\n+     * Create key / value pairs from keys \n+     * @param longValues The allowable long names for a field\n+     * @param shortValues The optional allowable short names for a field\n+     * @return The sorted name / value pairs for the field\n+     */\n+    private static KeyValue[] createKeyValues(String[] longValues, String[] shortValues) {\n+        KeyValue[] fieldKeyValues= new KeyValue[count(longValues)+count(shortValues)];\n+        copy(fieldKeyValues, copy(fieldKeyValues, 0, longValues), shortValues);\n+        Arrays.sort(fieldKeyValues, IGNORE_CASE_COMPARATOR);\n+        return fieldKeyValues;\n+    }\n+\n+    /**\n+     * Get a count of valid values in array.  A valid value is of non-zero length. \n+     * @param values The values to check.  This parameter may be null\n+     * @return The number of valid values\n+     */\n+    private static int count(String[] values) {\n+        int count= 0;\n+        if(values!=null) {\n+            for(String value : values) {\n+                if(value.length()>0) {\n+                    ++count;\n+                }\n+            }\n+        }\n+        return count;\n+    }\n+\n+    /**\n+     * Create key / value pairs from values \n+     * @param fieldKeyValues The destination array\n+     * @param offset The offset into the destination array \n+     * @param values The values to use to create key / value pairs.  This parameter may be null.\n+     * @return The offset into the destination array\n+     */\n+    private static int copy(KeyValue[] fieldKeyValues, int offset, String[] values) {\n+        if(values!=null) {\n+            for(int i= 0; i<values.length; ++i) {\n+                String value= values[i];\n+                if(value.length()>0) {\n+                    fieldKeyValues[offset++]= new KeyValue(value, i);\n+                }\n+            }\n+        }\n+        return offset;\n+    }\n+\n+    /**\n+     * Adjust dates to be within 80 years before and 20 years after instantiation\n+     * @param twoDigitYear The year to adjust\n+     * @return A value within -80 and +20 years from instantiation of this instance\n+     */\n+    protected int adjustYear(int twoDigitYear) {\n+        int trial= twoDigitYear + thisYear - thisYear%100;\n+        if(trial < thisYear+20) {\n+            return trial;\n+        }\n+        return trial-100;\n+    }\n+\n+    /**\n+     * Is the next field a number?\n+     * @return true, if next field will be a number \n+     */\n+    boolean isNextNumber() {\n+        return nextStrategy!=null && nextStrategy.isNumber();\n+    }\n+    \n+    /**\n+     * What is the width of the current field?\n+     * @return The number of characters in the current format field\n+     */\n+    int getFieldWidth() {\n+        return currentFormatField.length();\n+    }\n+    \n+    /**\n+     * A strategy to parse a single field from the parsing pattern\n+     */\n+    private interface Strategy {\n+        /**\n+         * Is this field a number?\n+         * @return true, if field is a number\n+         */\n+        boolean isNumber();\n+        /**\n+         * Set the Calendar with the parsed field\n+         * @param parser The parser calling this strategy\n+         * @param cal The <code>Calendar</code> to set\n+         * @param value The parsed field to translate and set in cal\n+         */\n+        void setCalendar(FastDateParser parser, Calendar cal, String value);\n+        /**\n+         * Generate a <code>Pattern</code> regular expression to the <code>StringBuilder</code> \n+         * which will accept this field\n+         * @param parser The parser calling this strategy\n+         * @param regex The <code>StringBuilder</code> to append to\n+         * @return true, if this field will set the calendar; \n+         * false, if this field is a constant value  \n+         */\n+        boolean addRegex(FastDateParser parser, StringBuilder regex);\n+    }\n+    \n+    /**\n+     * A <code>Pattern</code> to parse the user supplied SimpleDateFormat pattern\n+     */\n+    private static Pattern formatPattern= Pattern.compile(\n+            \"D+|E+|F+|G+|H+|K+|M+|S+|W+|Z+|a+|d+|h+|k+|m+|s+|w+|y+|z+|''|'[^']++(''[^']*+)*+'|[^'A-Za-z]++\");\n+    \n+    /**\n+     * Obtain a Strategy given a field from a SimpleDateFormat pattern\n+     * @param formatField A sub-sequence of the SimpleDateFormat pattern\n+     * @return The Strategy that will handle parsing for the field\n+     */\n+    private Strategy getStrategy(String formatField) {\n+        switch(formatField.charAt(0)) {\n+        case '\\'':\n+            if(formatField.length()>2) {\n+                formatField= formatField.substring(1, formatField.length()-1);\n+            }\n+        default:\n+            return new CopyQuotedStrategy(formatField);\n+        case 'D':\n+            return DAY_OF_YEAR_STRATEGY;\n+        case 'E':\n+            return DAY_OF_WEEK_STRATEGY;\n+        case 'F':\n+            return DAY_OF_WEEK_IN_MONTH_STRATEGY;\n+        case 'G':\n+            return ERA_STRATEGY;\n+        case 'H':\n+            return MODULO_HOUR_OF_DAY_STRATEGY;\n+        case 'K':\n+            return HOUR_STRATEGY;\n+        case 'M':\n+            return formatField.length()>=3 ?TEXT_MONTH_STRATEGY :NUMBER_MONTH_STRATEGY;\n+        case 'S':\n+            return MILLISECOND_STRATEGY;\n+        case 'W':\n+            return WEEK_OF_MONTH_STRATEGY;\n+        case 'Z':\n+            break;\n+        case 'a':\n+            return AM_PM_STRATEGY;\n+        case 'd':\n+            return DAY_OF_MONTH_STRATEGY;\n+        case 'h':\n+            return MODULO_HOUR_STRATEGY;\n+        case 'k':\n+            return HOUR_OF_DAY_STRATEGY;\n+        case 'm':\n+            return MINUTE_STRATEGY;\n+        case 's':\n+            return SECOND_STRATEGY;\n+        case 'w':\n+            return WEEK_OF_YEAR_STRATEGY;\n+        case 'y':\n+            return formatField.length()>2 ?LITERAL_YEAR_STRATEGY :ABBREVIATED_YEAR_STRATEGY;\n+        case 'z':\n+            break;\n+        }\n+        TimeZoneStrategy tzs= tzsCache.get(locale);\n+        if(tzs==null) {\n+            tzs= new TimeZoneStrategy(locale);\n+            TimeZoneStrategy inCache= tzsCache.putIfAbsent(locale, tzs);\n+            if(inCache!=null) {\n+                return inCache;\n+            }\n+        }\n+        return tzs;\n+    }\n+\n+    /**\n+     * A strategy that copies the static or quoted field in the parsing pattern\n+     */\n+    private static class CopyQuotedStrategy implements Strategy {\n+        private final String formatField;\n+\n+        /**\n+         * Construct a Strategy that ensures the formatField has literal text\n+         * @param formatField The literal text to match\n+         */\n+        CopyQuotedStrategy(String formatField) {\n+            this.formatField= formatField;\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public boolean isNumber() {\n+            char c= formatField.charAt(0);\n+            if(c=='\\'') {\n+                c= formatField.charAt(1);                \n+            }\n+            return Character.isDigit(c);\n+        }\n+        \n+        /**\n+         * {@inheritDoc}\n+         */\n+        public boolean addRegex(FastDateParser parser, StringBuilder regex) {\n+            escapeRegex(regex, formatField, true);\n+            return false;\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public void setCalendar(FastDateParser parser, Calendar cal, String value) {\n+        }\n+    }\n+\n+    /**\n+     * A strategy that handles a text field in the parsing pattern\n+     */\n+    private static class TextStrategy implements Strategy {\n+        private final int field;\n+        \n+        /**\n+         * Construct a Strategy that parses a Text field\n+         * @param field The Calendar field\n+         */\n+        TextStrategy(int field) {\n+            this.field= field;\n+        }\n+        \n+        /**\n+         * {@inheritDoc}\n+         */\n+        public boolean isNumber() {\n+            return false;\n+        }\n+        \n+        /**\n+         * {@inheritDoc}\n+         */\n+        public boolean addRegex(FastDateParser parser, StringBuilder regex) {\n+            regex.append('(');\n+            for(KeyValue textKeyValue : parser.getDisplayNames(field)) {\n+                escapeRegex(regex, textKeyValue.key, false).append('|');\n+            }\n+            regex.setCharAt(regex.length()-1, ')');\n+            return true;\n+        }\n+        \n+        /**\n+         * {@inheritDoc}\n+         */\n+        public void setCalendar(FastDateParser parser, Calendar cal, String value) {\n+            KeyValue[] textKeyValues= parser.getDisplayNames(field);\n+            int idx= Arrays.binarySearch(textKeyValues, new KeyValue(value, -1), IGNORE_CASE_COMPARATOR);\n+            if(idx<0) {\n+                StringBuilder sb= new StringBuilder(value);\n+                sb.append(\" not in (\");\n+                for(KeyValue textKeyValue : textKeyValues) {\n+                    sb.append(textKeyValue.key).append(' ');\n+                }\n+                sb.setCharAt(sb.length()-1, ')');\n+                throw new IllegalArgumentException(sb.toString());\n+            }\n+            cal.set(field, textKeyValues[idx].value);\n+        }\n+    }\n+\n+    /**\n+     * A strategy that handles a number field in the parsing pattern\n+     */\n+    private static class NumberStrategy implements Strategy {\n+        protected final int field;\n+        \n+        /**\n+         * Construct a Strategy that parses a Number field\n+         * @param field The Calendar field\n+         */\n+        NumberStrategy(int field) {\n+             this.field= field;\n+        }\n+        \n+        /**\n+         * {@inheritDoc}\n+         */\n+        public boolean isNumber() {\n+            return true;\n+        }\n+        \n+        /**\n+         * {@inheritDoc}\n+         */\n+        public boolean addRegex(FastDateParser parser, StringBuilder regex) {\n+            if(parser.isNextNumber()) {\n+                regex.append(\"(\\\\d{\").append(parser.getFieldWidth()).append(\"}+)\");\n+            }\n+            else {\n+                regex.append(\"(\\\\d++)\");\n+            }\n+            return true;\n+        }\n+        \n+        /**\n+         * {@inheritDoc}\n+         */\n+        public void setCalendar(FastDateParser parser, Calendar cal, String value) {\n+            cal.set(field, modify(Integer.parseInt(value)));\n+        }\n+        \n+        /**\n+         * Make any modifications to parsed integer \n+         * @param iValue The parsed integer\n+         * @return The modified value\n+         */\n+        public int modify(int iValue) {\n+            return iValue;            \n+        }\n+    }\n+\n+    private static final Strategy ABBREVIATED_YEAR_STRATEGY = new NumberStrategy(Calendar.YEAR) {\n+        /**\n+         * {@inheritDoc}\n+         */\n+        @Override\n+        public void setCalendar(FastDateParser parser, Calendar cal, String value) {\n+            int iValue= Integer.parseInt(value);\n+            if(iValue<100) {\n+                iValue= parser.adjustYear(iValue);\n+            }\n+            cal.set(Calendar.YEAR, iValue);\n+        }\n+    };\n+    \n+    /**\n+     * A strategy that handles a timezone field in the parsing pattern\n+     */\n+    private static class TimeZoneStrategy implements Strategy {\n+\n+        final String validTimeZoneChars;\n+        final SortedMap<String, TimeZone> tzNames= new TreeMap<String, TimeZone>(String.CASE_INSENSITIVE_ORDER);\n+        \n+        /**\n+         * Construct a Strategy that parses a TimeZone\n+         * @param locale The Locale\n+         */\n+        TimeZoneStrategy(Locale locale) {\n+            for(String id : TimeZone.getAvailableIDs()) {\n+                if(id.startsWith(\"GMT\")) {\n+                    continue;\n+                }\n+                TimeZone tz= TimeZone.getTimeZone(id);\n+                tzNames.put(tz.getDisplayName(false, TimeZone.SHORT, locale), tz);\n+                tzNames.put(tz.getDisplayName(false, TimeZone.LONG, locale), tz);\n+                if(tz.useDaylightTime()) {\n+                    tzNames.put(tz.getDisplayName(true, TimeZone.SHORT, locale), tz);\n+                    tzNames.put(tz.getDisplayName(true, TimeZone.LONG, locale), tz);\n+                }\n+            }\n+            StringBuilder sb= new StringBuilder();\n+            sb.append(\"(GMT[+\\\\-]\\\\d{0,1}\\\\d{2}|[+\\\\-]\\\\d{2}:?\\\\d{2}|\");            \n+            for(String id : tzNames.keySet()) {\n+                escapeRegex(sb, id, false).append('|');\n+            }\n+            sb.setCharAt(sb.length()-1, ')');\n+            validTimeZoneChars= sb.toString();\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public boolean isNumber() {\n+            return false;\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public boolean addRegex(FastDateParser parser, StringBuilder regex) {\n+            regex.append(validTimeZoneChars);\n+            return true;\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public void setCalendar(FastDateParser parser, Calendar cal, String value) {\n+            TimeZone tz;\n+            if(value.charAt(0)=='+' || value.charAt(0)=='-') {\n+                tz= TimeZone.getTimeZone(\"GMT\"+value);\n+            }\n+            else if(value.startsWith(\"GMT\")) {\n+                tz= TimeZone.getTimeZone(value);\n+            }\n+            else {\n+                tz= tzNames.get(value);\n+                if(tz==null) {\n+                    throw new IllegalArgumentException(value + \" is not a supported timezone name\");\n+                }\n+            }\n+            cal.setTimeZone(tz);\n+        }        \n+    };\n+\n+    private static final Strategy ERA_STRATEGY = new TextStrategy(Calendar.ERA);\n+    private static final Strategy DAY_OF_WEEK_STRATEGY = new TextStrategy(Calendar.DAY_OF_WEEK);\n+    private static final Strategy AM_PM_STRATEGY = new TextStrategy(Calendar.AM_PM);\n+    private static final Strategy TEXT_MONTH_STRATEGY = new TextStrategy(Calendar.MONTH);\n+    \n+    private static final Strategy NUMBER_MONTH_STRATEGY = new NumberStrategy(Calendar.MONTH) {\n+        public int modify(int iValue) {\n+            return iValue-1;            \n+        }\n+    };\n+    private static final Strategy LITERAL_YEAR_STRATEGY = new NumberStrategy(Calendar.YEAR);\n+    private static final Strategy WEEK_OF_YEAR_STRATEGY = new NumberStrategy(Calendar.WEEK_OF_YEAR);\n+    private static final Strategy WEEK_OF_MONTH_STRATEGY = new NumberStrategy(Calendar.WEEK_OF_MONTH);\n+    private static final Strategy DAY_OF_YEAR_STRATEGY = new NumberStrategy(Calendar.DAY_OF_YEAR);\n+    private static final Strategy DAY_OF_MONTH_STRATEGY = new NumberStrategy(Calendar.DAY_OF_MONTH);\n+    private static final Strategy DAY_OF_WEEK_IN_MONTH_STRATEGY = new NumberStrategy(Calendar.DAY_OF_WEEK_IN_MONTH);\n+    private static final Strategy HOUR_OF_DAY_STRATEGY = new NumberStrategy(Calendar.HOUR_OF_DAY);\n+    private static final Strategy MODULO_HOUR_OF_DAY_STRATEGY = new NumberStrategy(Calendar.HOUR_OF_DAY) {\n+        public int modify(int iValue) {\n+            return iValue%24;            \n+        }\n+    };\n+    private static final Strategy MODULO_HOUR_STRATEGY = new NumberStrategy(Calendar.HOUR) {\n+        public int modify(int iValue) {\n+            return iValue%12;            \n+        }\n+    };\n+    private static final Strategy HOUR_STRATEGY = new NumberStrategy(Calendar.HOUR);\n+    private static final Strategy MINUTE_STRATEGY = new NumberStrategy(Calendar.MINUTE);\n+    private static final Strategy SECOND_STRATEGY = new NumberStrategy(Calendar.SECOND);\n+    private static final Strategy MILLISECOND_STRATEGY = new NumberStrategy(Calendar.MILLISECOND);\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/lang3/time/FastDatePrinter.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang3.time;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.Serializable;\n+import java.text.DateFormat;\n+import java.text.DateFormatSymbols;\n+import java.text.FieldPosition;\n+import java.util.ArrayList;\n+import java.util.Calendar;\n+import java.util.Date;\n+import java.util.GregorianCalendar;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.TimeZone;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+\n+import org.apache.commons.lang3.Validate;\n+\n+/**\n+ * <p>FastDatePrinter is a fast and thread-safe version of\n+ * {@link java.text.SimpleDateFormat}.</p>\n+ *\n+ * <p>This class can be used as a direct replacement to\n+ * {@code SimpleDateFormat} in most formatting situations.\n+ * This class is especially useful in multi-threaded server environments.\n+ * {@code SimpleDateFormat} is not thread-safe in any JDK version,\n+ * nor will it be as Sun have closed the bug/RFE.\n+ * </p>\n+ *\n+ * <p>Only formatting is supported, but all patterns are compatible with\n+ * SimpleDateFormat (except time zones and some year patterns - see below).</p>\n+ *\n+ * <p>Java 1.4 introduced a new pattern letter, {@code 'Z'}, to represent\n+ * time zones in RFC822 format (eg. {@code +0800} or {@code -1100}).\n+ * This pattern letter can be used here (on all JDK versions).</p>\n+ *\n+ * <p>In addition, the pattern {@code 'ZZ'} has been made to represent\n+ * ISO8601 full format time zones (eg. {@code +08:00} or {@code -11:00}).\n+ * This introduces a minor incompatibility with Java 1.4, but at a gain of\n+ * useful functionality.</p>\n+ *\n+ * <p>Javadoc cites for the year pattern: <i>For formatting, if the number of\n+ * pattern letters is 2, the year is truncated to 2 digits; otherwise it is\n+ * interpreted as a number.</i> Starting with Java 1.7 a pattern of 'Y' or\n+ * 'YYY' will be formatted as '2003', while it was '03' in former Java\n+ * versions. FastDatePrinter implements the behavior of Java 7.</p>\n+ *\n+ * @since 3.2\n+ */\n+public class FastDatePrinter implements DatePrinter, Serializable {\n+    // A lot of the speed in this class comes from caching, but some comes\n+    // from the special int to StringBuffer conversion.\n+    //\n+    // The following produces a padded 2 digit number:\n+    //   buffer.append((char)(value / 10 + '0'));\n+    //   buffer.append((char)(value % 10 + '0'));\n+    //\n+    // Note that the fastest append to StringBuffer is a single char (used here).\n+    // Note that Integer.toString() is not called, the conversion is simply\n+    // taking the value and adding (mathematically) the ASCII value for '0'.\n+    // So, don't change this code! It works and is very fast.\n+\n+    /**\n+     * Required for serialization support.\n+     *\n+     * @see java.io.Serializable\n+     */\n+    private static final long serialVersionUID = 1L;\n+\n+    /**\n+     * FULL locale dependent date or time style.\n+     */\n+    public static final int FULL = DateFormat.FULL;\n+    /**\n+     * LONG locale dependent date or time style.\n+     */\n+    public static final int LONG = DateFormat.LONG;\n+    /**\n+     * MEDIUM locale dependent date or time style.\n+     */\n+    public static final int MEDIUM = DateFormat.MEDIUM;\n+    /**\n+     * SHORT locale dependent date or time style.\n+     */\n+    public static final int SHORT = DateFormat.SHORT;\n+\n+    /**\n+     * The pattern.\n+     */\n+    private final String mPattern;\n+    /**\n+     * The time zone.\n+     */\n+    private final TimeZone mTimeZone;\n+    /**\n+     * The locale.\n+     */\n+    private final Locale mLocale;\n+    /**\n+     * The parsed rules.\n+     */\n+    private transient Rule[] mRules;\n+    /**\n+     * The estimated maximum length.\n+     */\n+    private transient int mMaxLengthEstimate;\n+\n+    // Constructor\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Constructs a new FastDatePrinter.</p>\n+     *\n+     * @param pattern  {@link java.text.SimpleDateFormat} compatible pattern\n+     * @param timeZone  non-null time zone to use\n+     * @param locale  non-null locale to use\n+     * @throws NullPointerException if pattern, timeZone, or locale is null.\n+     */\n+    protected FastDatePrinter(String pattern, TimeZone timeZone, Locale locale) {\n+        mPattern = pattern;\n+        mTimeZone = timeZone;\n+        mLocale = locale;\n+\n+        init();\n+    }\n+\n+    /**\n+     * <p>Initializes the instance for first use.</p>\n+     */\n+    private void init() {\n+        List<Rule> rulesList = parsePattern();\n+        mRules = rulesList.toArray(new Rule[rulesList.size()]);\n+\n+        int len = 0;\n+        for (int i=mRules.length; --i >= 0; ) {\n+            len += mRules[i].estimateLength();\n+        }\n+\n+        mMaxLengthEstimate = len;\n+    }\n+\n+    // Parse the pattern\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Returns a list of Rules given a pattern.</p>\n+     *\n+     * @return a {@code List} of Rule objects\n+     * @throws IllegalArgumentException if pattern is invalid\n+     */\n+    protected List<Rule> parsePattern() {\n+        DateFormatSymbols symbols = new DateFormatSymbols(mLocale);\n+        List<Rule> rules = new ArrayList<Rule>();\n+\n+        String[] ERAs = symbols.getEras();\n+        String[] months = symbols.getMonths();\n+        String[] shortMonths = symbols.getShortMonths();\n+        String[] weekdays = symbols.getWeekdays();\n+        String[] shortWeekdays = symbols.getShortWeekdays();\n+        String[] AmPmStrings = symbols.getAmPmStrings();\n+\n+        int length = mPattern.length();\n+        int[] indexRef = new int[1];\n+\n+        for (int i = 0; i < length; i++) {\n+            indexRef[0] = i;\n+            String token = parseToken(mPattern, indexRef);\n+            i = indexRef[0];\n+\n+            int tokenLen = token.length();\n+            if (tokenLen == 0) {\n+                break;\n+            }\n+\n+            Rule rule;\n+            char c = token.charAt(0);\n+\n+            switch (c) {\n+            case 'G': // era designator (text)\n+                rule = new TextField(Calendar.ERA, ERAs);\n+                break;\n+            case 'y': // year (number)\n+                if (tokenLen == 2) {\n+                    rule = TwoDigitYearField.INSTANCE;\n+                } else {\n+                    rule = selectNumberRule(Calendar.YEAR, tokenLen < 4 ? 4 : tokenLen);\n+                }\n+                break;\n+            case 'M': // month in year (text and number)\n+                if (tokenLen >= 4) {\n+                    rule = new TextField(Calendar.MONTH, months);\n+                } else if (tokenLen == 3) {\n+                    rule = new TextField(Calendar.MONTH, shortMonths);\n+                } else if (tokenLen == 2) {\n+                    rule = TwoDigitMonthField.INSTANCE;\n+                } else {\n+                    rule = UnpaddedMonthField.INSTANCE;\n+                }\n+                break;\n+            case 'd': // day in month (number)\n+                rule = selectNumberRule(Calendar.DAY_OF_MONTH, tokenLen);\n+                break;\n+            case 'h': // hour in am/pm (number, 1..12)\n+                rule = new TwelveHourField(selectNumberRule(Calendar.HOUR, tokenLen));\n+                break;\n+            case 'H': // hour in day (number, 0..23)\n+                rule = selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen);\n+                break;\n+            case 'm': // minute in hour (number)\n+                rule = selectNumberRule(Calendar.MINUTE, tokenLen);\n+                break;\n+            case 's': // second in minute (number)\n+                rule = selectNumberRule(Calendar.SECOND, tokenLen);\n+                break;\n+            case 'S': // millisecond (number)\n+                rule = selectNumberRule(Calendar.MILLISECOND, tokenLen);\n+                break;\n+            case 'E': // day in week (text)\n+                rule = new TextField(Calendar.DAY_OF_WEEK, tokenLen < 4 ? shortWeekdays : weekdays);\n+                break;\n+            case 'D': // day in year (number)\n+                rule = selectNumberRule(Calendar.DAY_OF_YEAR, tokenLen);\n+                break;\n+            case 'F': // day of week in month (number)\n+                rule = selectNumberRule(Calendar.DAY_OF_WEEK_IN_MONTH, tokenLen);\n+                break;\n+            case 'w': // week in year (number)\n+                rule = selectNumberRule(Calendar.WEEK_OF_YEAR, tokenLen);\n+                break;\n+            case 'W': // week in month (number)\n+                rule = selectNumberRule(Calendar.WEEK_OF_MONTH, tokenLen);\n+                break;\n+            case 'a': // am/pm marker (text)\n+                rule = new TextField(Calendar.AM_PM, AmPmStrings);\n+                break;\n+            case 'k': // hour in day (1..24)\n+                rule = new TwentyFourHourField(selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen));\n+                break;\n+            case 'K': // hour in am/pm (0..11)\n+                rule = selectNumberRule(Calendar.HOUR, tokenLen);\n+                break;\n+            case 'z': // time zone (text)\n+                if (tokenLen >= 4) {\n+                    rule = new TimeZoneNameRule(mTimeZone, mLocale, TimeZone.LONG);\n+                } else {\n+                    rule = new TimeZoneNameRule(mTimeZone, mLocale, TimeZone.SHORT);\n+                }\n+                break;\n+            case 'Z': // time zone (value)\n+                if (tokenLen == 1) {\n+                    rule = TimeZoneNumberRule.INSTANCE_NO_COLON;\n+                } else {\n+                    rule = TimeZoneNumberRule.INSTANCE_COLON;\n+                }\n+                break;\n+            case '\\'': // literal text\n+                String sub = token.substring(1);\n+                if (sub.length() == 1) {\n+                    rule = new CharacterLiteral(sub.charAt(0));\n+                } else {\n+                    rule = new StringLiteral(sub);\n+                }\n+                break;\n+            default:\n+                throw new IllegalArgumentException(\"Illegal pattern component: \" + token);\n+            }\n+\n+            rules.add(rule);\n+        }\n+\n+        return rules;\n+    }\n+\n+    /**\n+     * <p>Performs the parsing of tokens.</p>\n+     *\n+     * @param pattern  the pattern\n+     * @param indexRef  index references\n+     * @return parsed token\n+     */\n+    protected String parseToken(String pattern, int[] indexRef) {\n+        StringBuilder buf = new StringBuilder();\n+\n+        int i = indexRef[0];\n+        int length = pattern.length();\n+\n+        char c = pattern.charAt(i);\n+        if (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z') {\n+            // Scan a run of the same character, which indicates a time\n+            // pattern.\n+            buf.append(c);\n+\n+            while (i + 1 < length) {\n+                char peek = pattern.charAt(i + 1);\n+                if (peek == c) {\n+                    buf.append(c);\n+                    i++;\n+                } else {\n+                    break;\n+                }\n+            }\n+        } else {\n+            // This will identify token as text.\n+            buf.append('\\'');\n+\n+            boolean inLiteral = false;\n+\n+            for (; i < length; i++) {\n+                c = pattern.charAt(i);\n+\n+                if (c == '\\'') {\n+                    if (i + 1 < length && pattern.charAt(i + 1) == '\\'') {\n+                        // '' is treated as escaped '\n+                        i++;\n+                        buf.append(c);\n+                    } else {\n+                        inLiteral = !inLiteral;\n+                    }\n+                } else if (!inLiteral &&\n+                         (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z')) {\n+                    i--;\n+                    break;\n+                } else {\n+                    buf.append(c);\n+                }\n+            }\n+        }\n+\n+        indexRef[0] = i;\n+        return buf.toString();\n+    }\n+\n+    /**\n+     * <p>Gets an appropriate rule for the padding required.</p>\n+     *\n+     * @param field  the field to get a rule for\n+     * @param padding  the padding required\n+     * @return a new rule with the correct padding\n+     */\n+    protected NumberRule selectNumberRule(int field, int padding) {\n+        switch (padding) {\n+        case 1:\n+            return new UnpaddedNumberField(field);\n+        case 2:\n+            return new TwoDigitNumberField(field);\n+        default:\n+            return new PaddedNumberField(field, padding);\n+        }\n+    }\n+\n+    // Format methods\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Formats a {@code Date}, {@code Calendar} or\n+     * {@code Long} (milliseconds) object.</p>\n+     *\n+     * @param obj  the object to format\n+     * @param toAppendTo  the buffer to append to\n+     * @param pos  the position - ignored\n+     * @return the buffer passed in\n+     */\n+    @Override\n+    public StringBuffer format(Object obj, StringBuffer toAppendTo, FieldPosition pos) {\n+        if (obj instanceof Date) {\n+            return format((Date) obj, toAppendTo);\n+        } else if (obj instanceof Calendar) {\n+            return format((Calendar) obj, toAppendTo);\n+        } else if (obj instanceof Long) {\n+            return format(((Long) obj).longValue(), toAppendTo);\n+        } else {\n+            throw new IllegalArgumentException(\"Unknown class: \" +\n+                (obj == null ? \"<null>\" : obj.getClass().getName()));\n+        }\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see org.apache.commons.lang3.time.DatePrinter#format(long)\n+     */\n+    @Override\n+    public String format(long millis) {\n+        return format(new Date(millis));\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see org.apache.commons.lang3.time.DatePrinter#format(java.util.Date)\n+     */\n+    @Override\n+    public String format(Date date) {\n+        Calendar c = new GregorianCalendar(mTimeZone, mLocale);  // hard code GregorianCalendar\n+        c.setTime(date);\n+        return applyRules(c, new StringBuffer(mMaxLengthEstimate)).toString();\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see org.apache.commons.lang3.time.DatePrinter#format(java.util.Calendar)\n+     */\n+    @Override\n+    public String format(Calendar calendar) {\n+        return format(calendar, new StringBuffer(mMaxLengthEstimate)).toString();\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see org.apache.commons.lang3.time.DatePrinter#format(long, java.lang.StringBuffer)\n+     */\n+    @Override\n+    public StringBuffer format(long millis, StringBuffer buf) {\n+        return format(new Date(millis), buf);\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see org.apache.commons.lang3.time.DatePrinter#format(java.util.Date, java.lang.StringBuffer)\n+     */\n+    @Override\n+    public StringBuffer format(Date date, StringBuffer buf) {\n+        Calendar c = new GregorianCalendar(mTimeZone, mLocale);  // hard code GregorianCalendar\n+        c.setTime(date);\n+        return applyRules(c, buf);\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see org.apache.commons.lang3.time.DatePrinter#format(java.util.Calendar, java.lang.StringBuffer)\n+     */\n+    @Override\n+    public StringBuffer format(Calendar calendar, StringBuffer buf) {\n+        return applyRules(calendar, buf);\n+    }\n+\n+    /**\n+     * <p>Performs the formatting by applying the rules to the\n+     * specified calendar.</p>\n+     *\n+     * @param calendar  the calendar to format\n+     * @param buf  the buffer to format into\n+     * @return the specified string buffer\n+     */\n+    protected StringBuffer applyRules(Calendar calendar, StringBuffer buf) {\n+        for (Rule rule : mRules) {\n+            rule.appendTo(buf, calendar);\n+        }\n+        return buf;\n+    }\n+\n+    // Accessors\n+    //-----------------------------------------------------------------------\n+    /* (non-Javadoc)\n+     * @see org.apache.commons.lang3.time.DatePrinter#getPattern()\n+     */\n+    @Override\n+    public String getPattern() {\n+        return mPattern;\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see org.apache.commons.lang3.time.DatePrinter#getTimeZone()\n+     */\n+    @Override\n+    public TimeZone getTimeZone() {\n+        return mTimeZone;\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see org.apache.commons.lang3.time.DatePrinter#getLocale()\n+     */\n+    @Override\n+    public Locale getLocale() {\n+        return mLocale;\n+    }\n+\n+    /**\n+     * <p>Gets an estimate for the maximum string length that the\n+     * formatter will produce.</p>\n+     *\n+     * <p>The actual formatted length will almost always be less than or\n+     * equal to this amount.</p>\n+     *\n+     * @return the maximum formatted length\n+     */\n+    public int getMaxLengthEstimate() {\n+        return mMaxLengthEstimate;\n+    }\n+\n+    // Basics\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Compares two objects for equality.</p>\n+     *\n+     * @param obj  the object to compare to\n+     * @return {@code true} if equal\n+     */\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (obj instanceof FastDatePrinter == false) {\n+            return false;\n+        }\n+        FastDatePrinter other = (FastDatePrinter) obj;\n+        return mPattern.equals(other.mPattern)\n+            && mTimeZone.equals(other.mTimeZone) \n+            && mLocale.equals(other.mLocale);\n+    }\n+\n+    /**\n+     * <p>Returns a hashcode compatible with equals.</p>\n+     *\n+     * @return a hashcode compatible with equals\n+     */\n+    @Override\n+    public int hashCode() {\n+        return mPattern.hashCode() + 13 * (mTimeZone.hashCode() + 13 * mLocale.hashCode());\n+    }\n+\n+    /**\n+     * <p>Gets a debugging string version of this formatter.</p>\n+     *\n+     * @return a debugging string\n+     */\n+    @Override\n+    public String toString() {\n+        return \"FastDatePrinter[\" + mPattern + \",\" + mLocale + \",\" + mTimeZone.getID() + \"]\";\n+    }\n+\n+    // Serializing\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Create the object after serialization. This implementation reinitializes the\n+     * transient properties.\n+     *\n+     * @param in ObjectInputStream from which the object is being deserialized.\n+     * @throws IOException if there is an IO issue.\n+     * @throws ClassNotFoundException if a class cannot be found.\n+     */\n+    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n+        in.defaultReadObject();\n+        init();\n+    }\n+\n+    // Rules\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Inner class defining a rule.</p>\n+     */\n+    private interface Rule {\n+        /**\n+         * Returns the estimated lentgh of the result.\n+         *\n+         * @return the estimated length\n+         */\n+        int estimateLength();\n+\n+        /**\n+         * Appends the value of the specified calendar to the output buffer based on the rule implementation.\n+         *\n+         * @param buffer the output buffer\n+         * @param calendar calendar to be appended\n+         */\n+        void appendTo(StringBuffer buffer, Calendar calendar);\n+    }\n+\n+    /**\n+     * <p>Inner class defining a numeric rule.</p>\n+     */\n+    private interface NumberRule extends Rule {\n+        /**\n+         * Appends the specified value to the output buffer based on the rule implementation.\n+         *\n+         * @param buffer the output buffer\n+         * @param value the value to be appended\n+         */\n+        void appendTo(StringBuffer buffer, int value);\n+    }\n+\n+    /**\n+     * <p>Inner class to output a constant single character.</p>\n+     */\n+    private static class CharacterLiteral implements Rule {\n+        private final char mValue;\n+\n+        /**\n+         * Constructs a new instance of {@code CharacterLiteral}\n+         * to hold the specified value.\n+         *\n+         * @param value the character literal\n+         */\n+        CharacterLiteral(char value) {\n+            mValue = value;\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public int estimateLength() {\n+            return 1;\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public void appendTo(StringBuffer buffer, Calendar calendar) {\n+            buffer.append(mValue);\n+        }\n+    }\n+\n+    /**\n+     * <p>Inner class to output a constant string.</p>\n+     */\n+    private static class StringLiteral implements Rule {\n+        private final String mValue;\n+\n+        /**\n+         * Constructs a new instance of {@code StringLiteral}\n+         * to hold the specified value.\n+         *\n+         * @param value the string literal\n+         */\n+        StringLiteral(String value) {\n+            mValue = value;\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public int estimateLength() {\n+            return mValue.length();\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public void appendTo(StringBuffer buffer, Calendar calendar) {\n+            buffer.append(mValue);\n+        }\n+    }\n+\n+    /**\n+     * <p>Inner class to output one of a set of values.</p>\n+     */\n+    private static class TextField implements Rule {\n+        private final int mField;\n+        private final String[] mValues;\n+\n+        /**\n+         * Constructs an instance of {@code TextField}\n+         * with the specified field and values.\n+         *\n+         * @param field the field\n+         * @param values the field values\n+         */\n+        TextField(int field, String[] values) {\n+            mField = field;\n+            mValues = values;\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public int estimateLength() {\n+            int max = 0;\n+            for (int i=mValues.length; --i >= 0; ) {\n+                int len = mValues[i].length();\n+                if (len > max) {\n+                    max = len;\n+                }\n+            }\n+            return max;\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public void appendTo(StringBuffer buffer, Calendar calendar) {\n+            buffer.append(mValues[calendar.get(mField)]);\n+        }\n+    }\n+\n+    /**\n+     * <p>Inner class to output an unpadded number.</p>\n+     */\n+    private static class UnpaddedNumberField implements NumberRule {\n+        private final int mField;\n+\n+        /**\n+         * Constructs an instance of {@code UnpadedNumberField} with the specified field.\n+         *\n+         * @param field the field\n+         */\n+        UnpaddedNumberField(int field) {\n+            mField = field;\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public int estimateLength() {\n+            return 4;\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public void appendTo(StringBuffer buffer, Calendar calendar) {\n+            appendTo(buffer, calendar.get(mField));\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public final void appendTo(StringBuffer buffer, int value) {\n+            if (value < 10) {\n+                buffer.append((char)(value + '0'));\n+            } else if (value < 100) {\n+                buffer.append((char)(value / 10 + '0'));\n+                buffer.append((char)(value % 10 + '0'));\n+            } else {\n+                buffer.append(Integer.toString(value));\n+            }\n+        }\n+    }\n+\n+    /**\n+     * <p>Inner class to output an unpadded month.</p>\n+     */\n+    private static class UnpaddedMonthField implements NumberRule {\n+        static final UnpaddedMonthField INSTANCE = new UnpaddedMonthField();\n+\n+        /**\n+         * Constructs an instance of {@code UnpaddedMonthField}.\n+         *\n+         */\n+        UnpaddedMonthField() {\n+            super();\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public int estimateLength() {\n+            return 2;\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public void appendTo(StringBuffer buffer, Calendar calendar) {\n+            appendTo(buffer, calendar.get(Calendar.MONTH) + 1);\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public final void appendTo(StringBuffer buffer, int value) {\n+            if (value < 10) {\n+                buffer.append((char)(value + '0'));\n+            } else {\n+                buffer.append((char)(value / 10 + '0'));\n+                buffer.append((char)(value % 10 + '0'));\n+            }\n+        }\n+    }\n+\n+    /**\n+     * <p>Inner class to output a padded number.</p>\n+     */\n+    private static class PaddedNumberField implements NumberRule {\n+        private final int mField;\n+        private final int mSize;\n+\n+        /**\n+         * Constructs an instance of {@code PaddedNumberField}.\n+         *\n+         * @param field the field\n+         * @param size size of the output field\n+         */\n+        PaddedNumberField(int field, int size) {\n+            if (size < 3) {\n+                // Should use UnpaddedNumberField or TwoDigitNumberField.\n+                throw new IllegalArgumentException();\n+            }\n+            mField = field;\n+            mSize = size;\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public int estimateLength() {\n+            return 4;\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public void appendTo(StringBuffer buffer, Calendar calendar) {\n+            appendTo(buffer, calendar.get(mField));\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public final void appendTo(StringBuffer buffer, int value) {\n+            if (value < 100) {\n+                for (int i = mSize; --i >= 2; ) {\n+                    buffer.append('0');\n+                }\n+                buffer.append((char)(value / 10 + '0'));\n+                buffer.append((char)(value % 10 + '0'));\n+            } else {\n+                int digits;\n+                if (value < 1000) {\n+                    digits = 3;\n+                } else {\n+                    Validate.isTrue(value > -1, \"Negative values should not be possible\", value);\n+                    digits = Integer.toString(value).length();\n+                }\n+                for (int i = mSize; --i >= digits; ) {\n+                    buffer.append('0');\n+                }\n+                buffer.append(Integer.toString(value));\n+            }\n+        }\n+    }\n+\n+    /**\n+     * <p>Inner class to output a two digit number.</p>\n+     */\n+    private static class TwoDigitNumberField implements NumberRule {\n+        private final int mField;\n+\n+        /**\n+         * Constructs an instance of {@code TwoDigitNumberField} with the specified field.\n+         *\n+         * @param field the field\n+         */\n+        TwoDigitNumberField(int field) {\n+            mField = field;\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public int estimateLength() {\n+            return 2;\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public void appendTo(StringBuffer buffer, Calendar calendar) {\n+            appendTo(buffer, calendar.get(mField));\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public final void appendTo(StringBuffer buffer, int value) {\n+            if (value < 100) {\n+                buffer.append((char)(value / 10 + '0'));\n+                buffer.append((char)(value % 10 + '0'));\n+            } else {\n+                buffer.append(Integer.toString(value));\n+            }\n+        }\n+    }\n+\n+    /**\n+     * <p>Inner class to output a two digit year.</p>\n+     */\n+    private static class TwoDigitYearField implements NumberRule {\n+        static final TwoDigitYearField INSTANCE = new TwoDigitYearField();\n+\n+        /**\n+         * Constructs an instance of {@code TwoDigitYearField}.\n+         */\n+        TwoDigitYearField() {\n+            super();\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public int estimateLength() {\n+            return 2;\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public void appendTo(StringBuffer buffer, Calendar calendar) {\n+            appendTo(buffer, calendar.get(Calendar.YEAR) % 100);\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public final void appendTo(StringBuffer buffer, int value) {\n+            buffer.append((char)(value / 10 + '0'));\n+            buffer.append((char)(value % 10 + '0'));\n+        }\n+    }\n+\n+    /**\n+     * <p>Inner class to output a two digit month.</p>\n+     */\n+    private static class TwoDigitMonthField implements NumberRule {\n+        static final TwoDigitMonthField INSTANCE = new TwoDigitMonthField();\n+\n+        /**\n+         * Constructs an instance of {@code TwoDigitMonthField}.\n+         */\n+        TwoDigitMonthField() {\n+            super();\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public int estimateLength() {\n+            return 2;\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public void appendTo(StringBuffer buffer, Calendar calendar) {\n+            appendTo(buffer, calendar.get(Calendar.MONTH) + 1);\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public final void appendTo(StringBuffer buffer, int value) {\n+            buffer.append((char)(value / 10 + '0'));\n+            buffer.append((char)(value % 10 + '0'));\n+        }\n+    }\n+\n+    /**\n+     * <p>Inner class to output the twelve hour field.</p>\n+     */\n+    private static class TwelveHourField implements NumberRule {\n+        private final NumberRule mRule;\n+\n+        /**\n+         * Constructs an instance of {@code TwelveHourField} with the specified\n+         * {@code NumberRule}.\n+         *\n+         * @param rule the rule\n+         */\n+        TwelveHourField(NumberRule rule) {\n+            mRule = rule;\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public int estimateLength() {\n+            return mRule.estimateLength();\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public void appendTo(StringBuffer buffer, Calendar calendar) {\n+            int value = calendar.get(Calendar.HOUR);\n+            if (value == 0) {\n+                value = calendar.getLeastMaximum(Calendar.HOUR) + 1;\n+            }\n+            mRule.appendTo(buffer, value);\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public void appendTo(StringBuffer buffer, int value) {\n+            mRule.appendTo(buffer, value);\n+        }\n+    }\n+\n+    /**\n+     * <p>Inner class to output the twenty four hour field.</p>\n+     */\n+    private static class TwentyFourHourField implements NumberRule {\n+        private final NumberRule mRule;\n+\n+        /**\n+         * Constructs an instance of {@code TwentyFourHourField} with the specified\n+         * {@code NumberRule}.\n+         *\n+         * @param rule the rule\n+         */\n+        TwentyFourHourField(NumberRule rule) {\n+            mRule = rule;\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public int estimateLength() {\n+            return mRule.estimateLength();\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public void appendTo(StringBuffer buffer, Calendar calendar) {\n+            int value = calendar.get(Calendar.HOUR_OF_DAY);\n+            if (value == 0) {\n+                value = calendar.getMaximum(Calendar.HOUR_OF_DAY) + 1;\n+            }\n+            mRule.appendTo(buffer, value);\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public void appendTo(StringBuffer buffer, int value) {\n+            mRule.appendTo(buffer, value);\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+\n+    private static ConcurrentMap<TimeZoneDisplayKey, String> cTimeZoneDisplayCache =\n+        new ConcurrentHashMap<TimeZoneDisplayKey, String>(7);\n+    /**\n+     * <p>Gets the time zone display name, using a cache for performance.</p>\n+     *\n+     * @param tz  the zone to query\n+     * @param daylight  true if daylight savings\n+     * @param style  the style to use {@code TimeZone.LONG} or {@code TimeZone.SHORT}\n+     * @param locale  the locale to use\n+     * @return the textual name of the time zone\n+     */\n+    static String getTimeZoneDisplay(TimeZone tz, boolean daylight, int style, Locale locale) {\n+        TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n+        String value = cTimeZoneDisplayCache.get(key);\n+        if (value == null) {\n+            // This is a very slow call, so cache the results.\n+            value = tz.getDisplayName(daylight, style, locale);\n+            String prior = cTimeZoneDisplayCache.putIfAbsent(key, value);\n+            if (prior != null) {\n+                value= prior;\n+            }\n+        }\n+        return value;\n+    }\n+\n+    /**\n+     * <p>Inner class to output a time zone name.</p>\n+     */\n+    private static class TimeZoneNameRule implements Rule {\n+        private final TimeZone mTimeZone;\n+        private final String mStandard;\n+        private final String mDaylight;\n+\n+        /**\n+         * Constructs an instance of {@code TimeZoneNameRule} with the specified properties.\n+         *\n+         * @param timeZone the time zone\n+         * @param locale the locale\n+         * @param style the style\n+         */\n+        TimeZoneNameRule(TimeZone timeZone, Locale locale, int style) {\n+            mTimeZone = timeZone;\n+\n+            mStandard = getTimeZoneDisplay(timeZone, false, style, locale);\n+            mDaylight = getTimeZoneDisplay(timeZone, true, style, locale);\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public int estimateLength() {\n+            return Math.max(mStandard.length(), mDaylight.length());\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public void appendTo(StringBuffer buffer, Calendar calendar) {\n+            if (mTimeZone.useDaylightTime() && calendar.get(Calendar.DST_OFFSET) != 0) {\n+                buffer.append(mDaylight);\n+            } else {\n+                buffer.append(mStandard);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * <p>Inner class to output a time zone as a number {@code +/-HHMM}\n+     * or {@code +/-HH:MM}.</p>\n+     */\n+    private static class TimeZoneNumberRule implements Rule {\n+        static final TimeZoneNumberRule INSTANCE_COLON = new TimeZoneNumberRule(true);\n+        static final TimeZoneNumberRule INSTANCE_NO_COLON = new TimeZoneNumberRule(false);\n+\n+        final boolean mColon;\n+\n+        /**\n+         * Constructs an instance of {@code TimeZoneNumberRule} with the specified properties.\n+         *\n+         * @param colon add colon between HH and MM in the output if {@code true}\n+         */\n+        TimeZoneNumberRule(boolean colon) {\n+            mColon = colon;\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public int estimateLength() {\n+            return 5;\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public void appendTo(StringBuffer buffer, Calendar calendar) {\n+            int offset = calendar.get(Calendar.ZONE_OFFSET) + calendar.get(Calendar.DST_OFFSET);\n+\n+            if (offset < 0) {\n+                buffer.append('-');\n+                offset = -offset;\n+            } else {\n+                buffer.append('+');\n+            }\n+\n+            int hours = offset / (60 * 60 * 1000);\n+            buffer.append((char)(hours / 10 + '0'));\n+            buffer.append((char)(hours % 10 + '0'));\n+\n+            if (mColon) {\n+                buffer.append(':');\n+            }\n+\n+            int minutes = offset / (60 * 1000) - 60 * hours;\n+            buffer.append((char)(minutes / 10 + '0'));\n+            buffer.append((char)(minutes % 10 + '0'));\n+        }\n+    }\n+\n+    // ----------------------------------------------------------------------\n+    /**\n+     * <p>Inner class that acts as a compound key for time zone names.</p>\n+     */\n+    private static class TimeZoneDisplayKey {\n+        private final TimeZone mTimeZone;\n+        private final int mStyle;\n+        private final Locale mLocale;\n+\n+        /**\n+         * Constructs an instance of {@code TimeZoneDisplayKey} with the specified properties.\n+         *\n+         * @param timeZone the time zone\n+         * @param daylight adjust the style for daylight saving time if {@code true}\n+         * @param style the timezone style\n+         * @param locale the timezone locale\n+         */\n+        TimeZoneDisplayKey(TimeZone timeZone,\n+                           boolean daylight, int style, Locale locale) {\n+            mTimeZone = timeZone;\n+            if (daylight) {\n+                style |= 0x80000000;\n+            }\n+            mStyle = style;\n+            mLocale = locale;\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        @Override\n+        public int hashCode() {\n+            return (mStyle * 31 + mLocale.hashCode() ) * 31 + mTimeZone.hashCode();\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        @Override\n+        public boolean equals(Object obj) {\n+            if (this == obj) {\n+                return true;\n+            }\n+            if (obj instanceof TimeZoneDisplayKey) {\n+                TimeZoneDisplayKey other = (TimeZoneDisplayKey)obj;\n+                return\n+                    mTimeZone.equals(other.mTimeZone) &&\n+                    mStyle == other.mStyle &&\n+                    mLocale.equals(other.mLocale);\n+            }\n+            return false;\n+        }\n+    }\n+}\n--- a/src/main/java/org/apache/commons/lang3/time/FormatCache.java\n+++ b/src/main/java/org/apache/commons/lang3/time/FormatCache.java\n     private final ConcurrentMap<MultipartKey, F> cInstanceCache \n         = new ConcurrentHashMap<MultipartKey, F>(7);\n     \n-    private final ConcurrentMap<MultipartKey, String> cDateTimeInstanceCache \n+    private static final ConcurrentMap<MultipartKey, String> cDateTimeInstanceCache \n         = new ConcurrentHashMap<MultipartKey, String>(7);\n \n     /**\n         if (locale == null) {\n             locale = Locale.getDefault();\n         }\n+        String pattern = getPatternForStyle(dateStyle, timeStyle, locale);\n+        return getInstance(pattern, timeZone, locale);\n+    }\n+\n+    /**\n+     * <p>Gets a date/time format for the specified styles and locale.</p>\n+     * \n+     * @param dateStyle  date style: FULL, LONG, MEDIUM, or SHORT, null indicates no date in format\n+     * @param timeStyle  time style: FULL, LONG, MEDIUM, or SHORT, null indicates no time in format\n+     * @param locale  The non-null locale of the desired format\n+     * @return a localized standard date/time format\n+     * @throws IllegalArgumentException if the Locale has no date/time pattern defined\n+     */\n+    public static String getPatternForStyle(Integer dateStyle, Integer timeStyle, Locale locale) {\n         MultipartKey key = new MultipartKey(dateStyle, timeStyle, locale);\n \n         String pattern = cDateTimeInstanceCache.get(key);\n                 throw new IllegalArgumentException(\"No date time pattern for locale: \" + locale);\n             }\n         }\n-        \n-        return getInstance(pattern, timeZone, locale);\n+        return pattern;\n     }\n \n     // ----------------------------------------------------------------------\n          */\n         @Override\n         public boolean equals(Object obj) {\n-            if (this == obj) {\n-                return true;\n-            }\n-            if ( obj instanceof MultipartKey == false ) {\n-                return false;\n-            }\n+            // Eliminate the usual boilerplate because\n+            // this inner static class is only used in a generic ConcurrentHashMap\n+            // which will not compare against other Object types\n             return Arrays.equals(keys, ((MultipartKey)obj).keys);\n         }\n \n--- a/src/test/java/org/apache/commons/lang3/time/FastDateFormatTest.java\n+++ b/src/test/java/org/apache/commons/lang3/time/FastDateFormatTest.java\n  */\n package org.apache.commons.lang3.time;\n \n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertSame;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import java.text.Format;\n+import java.text.ParseException;\n import java.text.SimpleDateFormat;\n-import java.util.Calendar;\n import java.util.Date;\n-import java.util.GregorianCalendar;\n import java.util.Locale;\n import java.util.TimeZone;\n-\n-import junit.framework.TestCase;\n-\n-import org.apache.commons.lang3.SerializationUtils;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+import org.junit.Test;\n \n /**\n  * Unit tests {@link org.apache.commons.lang3.time.FastDateFormat}.\n  * @since 2.0\n  * @version $Id$\n  */\n-public class FastDateFormatTest extends TestCase {\n-\n-    public FastDateFormatTest(String name) {\n-        super(name);\n-    }\n-\n+public class FastDateFormatTest {\n+\n+    /*\n+     * Only the cache methods need to be tested here.  \n+     * The print methods are tested by {@link FastDateFormat_PrinterTest}\n+     * and the parse methods are tested by {@link FastDateFormat_ParserTest}\n+     */\n+    @Test\n     public void test_getInstance() {\n         FastDateFormat format1 = FastDateFormat.getInstance();\n         FastDateFormat format2 = FastDateFormat.getInstance();\n         assertSame(format1, format2);\n-        assertEquals(new SimpleDateFormat().toPattern(), format1.getPattern());\n-    }\n-\n+    }\n+\n+    @Test\n     public void test_getInstance_String() {\n         FastDateFormat format1 = FastDateFormat.getInstance(\"MM/DD/yyyy\");\n         FastDateFormat format2 = FastDateFormat.getInstance(\"MM-DD-yyyy\");\n         assertEquals(TimeZone.getDefault(), format2.getTimeZone());\n     }\n \n+    @Test\n     public void test_getInstance_String_TimeZone() {\n         Locale realDefaultLocale = Locale.getDefault();\n         TimeZone realDefaultZone = TimeZone.getDefault();\n         }\n     }\n \n+    @Test\n     public void test_getInstance_String_Locale() {\n         Locale realDefaultLocale = Locale.getDefault();\n         try {\n         }\n     }\n \n+    @Test\n     public void test_changeDefault_Locale_DateInstance() {\n         Locale realDefaultLocale = Locale.getDefault();\n         try {\n         }\n     }\n \n+    @Test\n     public void test_changeDefault_Locale_DateTimeInstance() {\n         Locale realDefaultLocale = Locale.getDefault();\n         try {\n         }\n     }\n \n+    @Test\n     public void test_getInstance_String_TimeZone_Locale() {\n         Locale realDefaultLocale = Locale.getDefault();\n         TimeZone realDefaultZone = TimeZone.getDefault();\n             Locale.setDefault(realDefaultLocale);\n             TimeZone.setDefault(realDefaultZone);\n         }\n-    }\n-\n-    public void testFormat() {\n-        Locale realDefaultLocale = Locale.getDefault();\n-        TimeZone realDefaultZone = TimeZone.getDefault();\n-        try {\n-            Locale.setDefault(Locale.US);\n-            TimeZone.setDefault(TimeZone.getTimeZone(\"America/New_York\"));\n-\n-            GregorianCalendar cal1 = new GregorianCalendar(2003, 0, 10, 15, 33, 20);\n-            GregorianCalendar cal2 = new GregorianCalendar(2003, 6, 10, 9, 00, 00);\n-            Date date1 = cal1.getTime();\n-            Date date2 = cal2.getTime();\n-            long millis1 = date1.getTime();\n-            long millis2 = date2.getTime();\n-\n-            FastDateFormat fdf = FastDateFormat.getInstance(\"yyyy-MM-dd'T'HH:mm:ss\");\n-            SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ss\");\n-            assertEquals(sdf.format(date1), fdf.format(date1));\n-            assertEquals(\"2003-01-10T15:33:20\", fdf.format(date1));\n-            assertEquals(\"2003-01-10T15:33:20\", fdf.format(cal1));\n-            assertEquals(\"2003-01-10T15:33:20\", fdf.format(millis1));\n-            assertEquals(\"2003-07-10T09:00:00\", fdf.format(date2));\n-            assertEquals(\"2003-07-10T09:00:00\", fdf.format(cal2));\n-            assertEquals(\"2003-07-10T09:00:00\", fdf.format(millis2));\n-\n-            fdf = FastDateFormat.getInstance(\"Z\");\n-            assertEquals(\"-0500\", fdf.format(date1));\n-            assertEquals(\"-0500\", fdf.format(cal1));\n-            assertEquals(\"-0500\", fdf.format(millis1));\n-\n-            assertEquals(\"-0400\", fdf.format(date2));\n-            assertEquals(\"-0400\", fdf.format(cal2));\n-            assertEquals(\"-0400\", fdf.format(millis2));\n-\n-            fdf = FastDateFormat.getInstance(\"ZZ\");\n-            assertEquals(\"-05:00\", fdf.format(date1));\n-            assertEquals(\"-05:00\", fdf.format(cal1));\n-            assertEquals(\"-05:00\", fdf.format(millis1));\n-\n-            assertEquals(\"-04:00\", fdf.format(date2));\n-            assertEquals(\"-04:00\", fdf.format(cal2));\n-            assertEquals(\"-04:00\", fdf.format(millis2));\n-\n-            String pattern = \"GGGG GGG GG G yyyy yyy yy y MMMM MMM MM M\" +\n-                \" dddd ddd dd d DDDD DDD DD D EEEE EEE EE E aaaa aaa aa a zzzz zzz zz z\";\n-            fdf = FastDateFormat.getInstance(pattern);\n-            sdf = new SimpleDateFormat(pattern);\n-            // SDF bug fix starting with Java 7\n-            assertEquals(sdf.format(date1).replaceAll(\"2003 03 03 03\", \"2003 2003 03 2003\"), fdf.format(date1));\n-            assertEquals(sdf.format(date2).replaceAll(\"2003 03 03 03\", \"2003 2003 03 2003\"), fdf.format(date2));\n-        } finally {\n-            Locale.setDefault(realDefaultLocale);\n-            TimeZone.setDefault(realDefaultZone);\n-        }\n-    }\n-\n-    /**\n-     * Test case for {@link FastDateFormat#getDateInstance(int, java.util.Locale)}.\n-     */\n-    public void testShortDateStyleWithLocales() {\n-        Locale usLocale = Locale.US;\n-        Locale swedishLocale = new Locale(\"sv\", \"SE\");\n-        Calendar cal = Calendar.getInstance();\n-        cal.set(2004, 1, 3);\n-        FastDateFormat fdf = FastDateFormat.getDateInstance(FastDateFormat.SHORT, usLocale);\n-        assertEquals(\"2/3/04\", fdf.format(cal));\n-\n-        fdf = FastDateFormat.getDateInstance(FastDateFormat.SHORT, swedishLocale);\n-        assertEquals(\"2004-02-03\", fdf.format(cal));\n-\n-    }\n-\n-    /**\n-     * Tests that pre-1000AD years get padded with yyyy\n-     */\n-    public void testLowYearPadding() {\n-        Calendar cal = Calendar.getInstance();\n-        FastDateFormat format = FastDateFormat.getInstance(\"yyyy/MM/DD\");\n-\n-        cal.set(1,0,1);\n-        assertEquals(\"0001/01/01\", format.format(cal));\n-        cal.set(10,0,1);\n-        assertEquals(\"0010/01/01\", format.format(cal));\n-        cal.set(100,0,1);\n-        assertEquals(\"0100/01/01\", format.format(cal));\n-        cal.set(999,0,1);\n-        assertEquals(\"0999/01/01\", format.format(cal));\n-    }\n-    /**\n-     * Show Bug #39410 is solved\n-     */\n-    public void testMilleniumBug() {\n-        Calendar cal = Calendar.getInstance();\n-        FastDateFormat format = FastDateFormat.getInstance(\"dd.MM.yyyy\");\n-\n-        cal.set(1000,0,1);\n-        assertEquals(\"01.01.1000\", format.format(cal));\n-    }\n-\n-    /**\n-     * testLowYearPadding showed that the date was buggy\n-     * This test confirms it, getting 366 back as a date\n-     */\n-    public void testSimpleDate() {\n-        Calendar cal = Calendar.getInstance();\n-        FastDateFormat format = FastDateFormat.getInstance(\"yyyy/MM/dd\");\n-\n-        cal.set(2004,11,31);\n-        assertEquals(\"2004/12/31\", format.format(cal));\n-        cal.set(999,11,31);\n-        assertEquals(\"0999/12/31\", format.format(cal));\n-        cal.set(1,2,2);\n-        assertEquals(\"0001/03/02\", format.format(cal));\n-    }\n-\n-    public void testLang303() {\n-        Calendar cal = Calendar.getInstance();\n-        cal.set(2004,11,31);\n-\n-        FastDateFormat format = FastDateFormat.getInstance(\"yyyy/MM/dd\");\n-        String output = format.format(cal);\n-\n-        format = (FastDateFormat) SerializationUtils.deserialize( SerializationUtils.serialize( format ) );\n-        assertEquals(output, format.format(cal));\n-    }\n-\n-    public void testLang538() {\n-        // more commonly constructed with: cal = new GregorianCalendar(2009, 9, 16, 8, 42, 16)\n-        // for the unit test to work in any time zone, constructing with GMT-8 rather than default locale time zone\n-        GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone(\"GMT-8\"));\n-        cal.clear();\n-        cal.set(2009, 9, 16, 8, 42, 16);\n-\n-        FastDateFormat format = FastDateFormat.getInstance(\"yyyy-MM-dd'T'HH:mm:ss.SSS'Z'\", TimeZone.getTimeZone(\"GMT\"));\n-        assertEquals(\"dateTime\", \"2009-10-16T16:42:16.000Z\", format.format(cal.getTime()));\n-        assertEquals(\"dateTime\", \"2009-10-16T08:42:16.000Z\", format.format(cal));\n-    }\n-\n-    public void testLang645() {\n-        Locale locale = new Locale(\"sv\", \"SE\");\n-\n-        Calendar cal = Calendar.getInstance();\n-        cal.set(2010, 0, 1, 12, 0, 0);\n-        Date d = cal.getTime();\n-\n-        FastDateFormat fdf = FastDateFormat.getInstance(\"EEEE', week 'ww\", locale);\n-\n-        assertEquals(\"fredag, week 53\", fdf.format(d));\n+    }       \n+\n+    @Test\n+    public void testCheckDefaults() {\n+        FastDateFormat format = FastDateFormat.getInstance();\n+        FastDateFormat medium = FastDateFormat.getDateTimeInstance(FastDateFormat.SHORT, FastDateFormat.SHORT);\n+        assertEquals(medium, format);\n+        \n+        SimpleDateFormat sdf = new SimpleDateFormat();\n+        assertEquals(sdf.toPattern(), format.getPattern());\n+        \n+        assertEquals(Locale.getDefault(), format.getLocale());\n+        assertEquals(TimeZone.getDefault(), format.getTimeZone());        \n+    }\n+\n+    @Test\n+    public void testCheckDifferingStyles() {\n+        FastDateFormat shortShort = FastDateFormat.getDateTimeInstance(FastDateFormat.SHORT, FastDateFormat.SHORT, Locale.US);\n+        FastDateFormat shortLong = FastDateFormat.getDateTimeInstance(FastDateFormat.SHORT, FastDateFormat.LONG, Locale.US);\n+        FastDateFormat longShort = FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.SHORT, Locale.US);\n+        FastDateFormat longLong = FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.LONG, Locale.US);\n+        \n+        assertFalse(shortShort.equals(shortLong));\n+        assertFalse(shortShort.equals(longShort));\n+        assertFalse(shortShort.equals(longLong));      \n+        assertFalse(shortLong.equals(longShort));\n+        assertFalse(shortLong.equals(longLong));\n+        assertFalse(longShort.equals(longLong));\n+    }\n+\n+    @Test\n+    public void testDateDefaults() {\n+        assertEquals(FastDateFormat.getDateInstance(FastDateFormat.LONG, Locale.CANADA), \n+                FastDateFormat.getDateInstance(FastDateFormat.LONG, TimeZone.getDefault(), Locale.CANADA));\n+        \n+        assertEquals(FastDateFormat.getDateInstance(FastDateFormat.LONG, TimeZone.getTimeZone(\"America/New_York\")), \n+                FastDateFormat.getDateInstance(FastDateFormat.LONG, TimeZone.getTimeZone(\"America/New_York\"), Locale.getDefault()));\n+\n+        assertEquals(FastDateFormat.getDateInstance(FastDateFormat.LONG), \n+                FastDateFormat.getDateInstance(FastDateFormat.LONG, TimeZone.getDefault(), Locale.getDefault()));\n+    }\n+\n+    @Test\n+    public void testTimeDefaults() {\n+        assertEquals(FastDateFormat.getTimeInstance(FastDateFormat.LONG, Locale.CANADA),\n+                FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getDefault(), Locale.CANADA));\n+\n+        assertEquals(FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getTimeZone(\"America/New_York\")),\n+                FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getTimeZone(\"America/New_York\"), Locale.getDefault()));\n+\n+        assertEquals(FastDateFormat.getTimeInstance(FastDateFormat.LONG),\n+                FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getDefault(), Locale.getDefault()));\n+    }\n+\n+    @Test\n+    public void testTimeDateDefaults() {\n+        assertEquals(FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, Locale.CANADA),\n+                FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, TimeZone.getDefault(), Locale.CANADA));\n+\n+        assertEquals(FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, TimeZone.getTimeZone(\"America/New_York\")),\n+                FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, TimeZone.getTimeZone(\"America/New_York\"), Locale.getDefault()));\n+\n+        assertEquals(FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM),\n+                FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, TimeZone.getDefault(), Locale.getDefault()));\n+    }\n+\n+    @Test\n+    public void testParseSync() throws ParseException, InterruptedException {\n+        final FastDateFormat formatter= FastDateFormat.getInstance(\"yyyy-MM-dd'T'HH:mm:ss.SSS Z\");\n+        \n+        long sdfTime= measureTime(formatter, new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ss.SSS Z\") {\n+                        private static final long serialVersionUID = 1L;  // because SimpleDateFormat is serializable\n+\n+                        @Override\n+                        public Object parseObject(String formattedDate) throws ParseException {\n+                            synchronized(this) {\n+                                return super.parse(formattedDate);\n+                            }\n+                        }\n+        });\n+        \n+        long fdfTime= measureTime(formatter, FastDateFormat.getInstance(\"yyyy-MM-dd'T'HH:mm:ss.SSS Z\"));\n+        \n+        String times= \"FastDateParser:\"+fdfTime+\"  SimpleDateFormat:\"+sdfTime;\n+        System.out.println(times);\n+    }\n+\n+    final static private int NTHREADS= 10;\n+    final static private int NROUNDS= 10000;\n+    \n+    private long measureTime(final Format formatter, final Format parser) throws ParseException, InterruptedException {\n+        final ExecutorService pool = Executors.newFixedThreadPool(NTHREADS);\n+        final AtomicInteger failures= new AtomicInteger(0);\n+        final AtomicLong totalElapsed= new AtomicLong(0);\n+        \n+        for(int i= 0; i<NTHREADS; ++i) {\n+            pool.submit(new Runnable() {\n+                public void run() {\n+                    for(int i= 0; i<NROUNDS; ++i) {\n+                        try {\n+                            Date date= new Date();\n+                            String formattedDate= formatter.format(date);\n+                            long start= System.currentTimeMillis();        \n+                            Object pd= parser.parseObject(formattedDate);\n+                            totalElapsed.addAndGet(System.currentTimeMillis()-start);\n+                            if(!date.equals(pd)) {\n+                                failures.incrementAndGet();\n+                            }\n+                        } catch (Exception e) {\n+                            failures.incrementAndGet();\n+                            e.printStackTrace();\n+                        }\n+                    }\n+                }                \n+            });\n+        }\n+        pool.shutdown();                        \n+        if(!pool.awaitTermination(20, TimeUnit.SECONDS)) {\n+            pool.shutdownNow();\n+            fail(\"did not complete tasks\");\n+        }\n+        assertEquals(0, failures.get());\n+        return totalElapsed.get();\n     }\n }\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/lang3/time/FastDateFormat_ParserTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang3.time;\n+\n+import java.util.Locale;\n+import java.util.TimeZone;\n+\n+/**\n+ * Unit tests for the parse methods of FastDateFormat\n+ *\n+ * @since 3.2\n+ */\n+public class FastDateFormat_ParserTest extends FastDateParserTest {\n+\n+    @Override\n+    protected DateParser getInstance(String format, TimeZone timeZone, Locale locale) {\n+        return FastDateFormat.getInstance(format, timeZone, locale);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/lang3/time/FastDateFormat_PrinterTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang3.time;\n+\n+import java.util.Locale;\n+import java.util.TimeZone;\n+\n+/**\n+ * Unit tests for the print methods of FastDateFormat\n+ *\n+ * @since 3.2\n+ */\n+public class FastDateFormat_PrinterTest extends FastDatePrinterTest {\n+\n+    @Override\n+    protected DatePrinter getInstance(String format, TimeZone timeZone, Locale locale) {\n+        return FastDateFormat.getInstance(format, timeZone, locale);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/lang3/time/FastDateParserTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional inparserion regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang3.time;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n+\n+import java.io.Serializable;\n+import java.text.ParseException;\n+import java.text.SimpleDateFormat;\n+import java.util.Calendar;\n+import java.util.Date;\n+import java.util.GregorianCalendar;\n+import java.util.HashMap;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.TimeZone;\n+\n+import org.apache.commons.lang3.SerializationUtils;\n+import org.junit.Test;\n+\n+/**\n+ * Unit tests {@link org.apache.commons.lang3.time.FastDateParser}.\n+ *\n+ * @since 3.2\n+ */\n+public class FastDateParserTest {\n+    private static final String yMdHmsSZ = \"yyyy-MM-dd'T'HH:mm:ss.SSS Z\";\n+    private static final String DMY_DOT = \"dd.MM.yyyy\";\n+    private static final String YMD_SLASH = \"yyyy/MM/dd\";\n+    private static final String MDY_DASH = \"MM-DD-yyyy\";\n+    private static final String MDY_SLASH = \"MM/DD/yyyy\";\n+    private static final TimeZone REYKJAVIK = TimeZone.getTimeZone(\"Atlantic/Reykjavik\");\n+    private static final TimeZone NEW_YORK = TimeZone.getTimeZone(\"America/New_York\");\n+    private static final Locale SWEDEN = new Locale(\"sv\", \"SE\");\n+\n+    DateParser getInstance(String format) {\n+        return getInstance(format, TimeZone.getDefault(), Locale.getDefault());\n+    }\n+\n+    private DateParser getDateInstance(int dateStyle, Locale locale) {\n+        return getInstance(FormatCache.getPatternForStyle(dateStyle, null, locale), TimeZone.getDefault(), Locale.getDefault());\n+    }\n+\n+    private DateParser getInstance(String format, Locale locale) {\n+        return getInstance(format, TimeZone.getDefault(), locale);\n+    }\n+\n+    private DateParser getInstance(String format, TimeZone timeZone) {\n+        return getInstance(format, timeZone, Locale.getDefault());\n+    }\n+\n+    /**\n+     * Override this method in derived tests to change the construction of instances\n+     * @param format\n+     * @param timeZone\n+     * @param locale\n+     * @return\n+     */\n+    protected DateParser getInstance(String format, TimeZone timeZone, Locale locale) {\n+        return new FastDateParser(format, timeZone, locale);\n+    }\n+\n+    @Test\n+    public void test_Equality_Hash() {        \n+        DateParser[] parsers= {\n+            getInstance(yMdHmsSZ, NEW_YORK, Locale.US),\n+            getInstance(DMY_DOT, NEW_YORK, Locale.US),\n+            getInstance(YMD_SLASH, NEW_YORK, Locale.US),\n+            getInstance(MDY_DASH, NEW_YORK, Locale.US),\n+            getInstance(MDY_SLASH, NEW_YORK, Locale.US),\n+            getInstance(MDY_SLASH, REYKJAVIK, Locale.US),\n+            getInstance(MDY_SLASH, REYKJAVIK, SWEDEN)\n+        };\n+        \n+        Map<DateParser,Integer> map= new HashMap<DateParser,Integer>();\n+        int i= 0;\n+        for(DateParser parser:parsers) {\n+            map.put(parser, i++);            \n+        }\n+\n+        i= 0;\n+        for(DateParser parser:parsers) {\n+            assertEquals(i++, (int)map.get(parser));\n+        }        \n+    }\n+\n+    @Test\n+    public void testParseZone() throws ParseException {\n+        Calendar cal= Calendar.getInstance(NEW_YORK, Locale.US);\n+        cal.clear();\n+        cal.set(2003, 6, 10, 16, 33, 20);\n+        \n+        DateParser fdf = getInstance(yMdHmsSZ, NEW_YORK, Locale.US);\n+        \n+        assertEquals(cal.getTime(), fdf.parse(\"2003-07-10T15:33:20.000 -0500\"));\n+        assertEquals(cal.getTime(), fdf.parse(\"2003-07-10T15:33:20.000 GMT-05:00\"));\n+        assertEquals(cal.getTime(), fdf.parse(\"2003-07-10T16:33:20.000 Eastern Daylight Time\"));\n+        assertEquals(cal.getTime(), fdf.parse(\"2003-07-10T16:33:20.000 EDT\"));\n+        \n+        cal.setTimeZone(TimeZone.getTimeZone(\"GMT-3\"));\n+        cal.set(2003, 1, 10, 9, 0, 0);\n+        \n+        assertEquals(cal.getTime(), fdf.parse(\"2003-02-10T09:00:00.000 -0300\"));\n+        \n+        cal.setTimeZone(TimeZone.getTimeZone(\"GMT+5\"));\n+        cal.set(2003, 1, 10, 15, 5, 6);\n+       \n+        assertEquals(cal.getTime(), fdf.parse(\"2003-02-10T15:05:06.000 +0500\"));\n+    }\n+    \n+    @Test\n+    public void testParseLongShort() throws ParseException {\n+        Calendar cal= Calendar.getInstance(NEW_YORK, Locale.US);        \n+        cal.clear();\n+        cal.set(2003, 1, 10, 15, 33, 20);\n+        cal.set(Calendar.MILLISECOND, 989);\n+        cal.setTimeZone(NEW_YORK);\n+        \n+        DateParser fdf = getInstance(\"yyyy GGGG MMMM dddd aaaa EEEE HHHH mmmm ssss SSSS ZZZZ\", NEW_YORK, Locale.US);\n+        \n+        assertEquals(cal.getTime(), fdf.parse(\"2003 AD February 0010 PM Monday 0015 0033 0020 0989 GMT-05:00\"));\n+        cal.set(Calendar.ERA, GregorianCalendar.BC);\n+        \n+        Date parse = fdf.parse(\"2003 BC February 0010 PM Saturday 0015 0033 0020 0989 GMT-05:00\");\n+                assertEquals(cal.getTime(), parse);\n+                \n+        fdf = getInstance(\"y G M d a E H m s S Z\");\n+        assertEquals(cal.getTime(), fdf.parse(\"03 BC 2 10 PM Sat 15 33 20 989 -0500\"));\n+        \n+        cal.set(Calendar.ERA, GregorianCalendar.AD);\n+        assertEquals(cal.getTime(), fdf.parse(\"03 AD 2 10 PM Saturday 15 33 20 989 -0500\"));\n+    }\n+    \n+    @Test\n+    public void testAmPm() throws ParseException {\n+        Calendar cal= Calendar.getInstance(NEW_YORK, Locale.US);\n+        cal.clear();\n+        \n+        DateParser h = getInstance(\"yyyy-MM-dd hh a mm:ss\", NEW_YORK, Locale.US);        \n+        DateParser K = getInstance(\"yyyy-MM-dd KK a mm:ss\", NEW_YORK, Locale.US);        \n+        DateParser k = getInstance(\"yyyy-MM-dd kk:mm:ss\", NEW_YORK, Locale.US);        \n+        DateParser H = getInstance(\"yyyy-MM-dd HH:mm:ss\", NEW_YORK, Locale.US);        \n+\n+        cal.set(2010, 7, 1, 0, 33, 20);\n+        assertEquals(cal.getTime(), h.parse(\"2010-08-01 12 AM 33:20\"));\n+        assertEquals(cal.getTime(), K.parse(\"2010-08-01 0 AM 33:20\"));\n+        assertEquals(cal.getTime(), k.parse(\"2010-08-01 00:33:20\"));\n+        assertEquals(cal.getTime(), H.parse(\"2010-08-01 00:33:20\"));\n+        \n+        cal.set(2010, 7, 1, 3, 33, 20);\n+        assertEquals(cal.getTime(), h.parse(\"2010-08-01 3 AM 33:20\"));\n+        assertEquals(cal.getTime(), K.parse(\"2010-08-01 3 AM 33:20\"));\n+        assertEquals(cal.getTime(), k.parse(\"2010-08-01 03:33:20\"));\n+        assertEquals(cal.getTime(), H.parse(\"2010-08-01 03:33:20\"));\n+\n+        cal.set(2010, 7, 1, 15, 33, 20);\n+        assertEquals(cal.getTime(), h.parse(\"2010-08-01 3 PM 33:20\"));\n+        assertEquals(cal.getTime(), K.parse(\"2010-08-01 3 PM 33:20\"));\n+        assertEquals(cal.getTime(), k.parse(\"2010-08-01 15:33:20\"));\n+        assertEquals(cal.getTime(), H.parse(\"2010-08-01 15:33:20\"));\n+\n+        cal.set(2010, 7, 1, 12, 33, 20);\n+        assertEquals(cal.getTime(), h.parse(\"2010-08-01 12 PM 33:20\"));\n+        assertEquals(cal.getTime(), K.parse(\"2010-08-01 0 PM 33:20\"));\n+        assertEquals(cal.getTime(), k.parse(\"2010-08-01 12:33:20\"));\n+        assertEquals(cal.getTime(), H.parse(\"2010-08-01 12:33:20\"));\n+    }\n+    \n+    @Test\n+    public void testLocales() throws ParseException {\n+                \n+        for(Locale locale : Locale.getAvailableLocales()) {\n+            Calendar cal= Calendar.getInstance(NEW_YORK, Locale.US);\n+            cal.clear();\n+            cal.set(2003, 1, 10);\n+\n+            try {\n+                String longFormat= \"GGGG/yyyy/MMMM/dddd/aaaa/EEEE/ZZZZ\";\n+                SimpleDateFormat sdf = new SimpleDateFormat(longFormat, locale);\n+                DateParser fdf = getInstance(longFormat, locale);\n+                \n+                                checkParse(cal, sdf, fdf);\n+                \n+                cal.set(Calendar.ERA, GregorianCalendar.BC);\n+                                checkParse(cal, sdf, fdf);\n+                        \n+                String shortFormat= \"G/y/M/d/a/E/Z\";\n+                sdf = new SimpleDateFormat(shortFormat, locale);\n+                fdf = getInstance(shortFormat, locale);\n+                                checkParse(cal, sdf, fdf);\n+                \n+                cal.set(Calendar.ERA, GregorianCalendar.AD);\n+                                checkParse(cal, sdf, fdf);\n+            }\n+            catch(ParseException ex) {\n+                // TODO: why do ja_JP_JP, hi_IN, th_TH, and th_TH_TH fail?\n+                System.out.println(\"Locale \"+locale+ \" failed\");\n+            }\n+        }\n+    }\n+\n+    private void checkParse(Calendar cal, SimpleDateFormat sdf, DateParser fdf) throws ParseException {\n+        String formattedDate= sdf.format(cal.getTime());                \n+        Date expectedTime = sdf.parse(formattedDate);\n+        Date actualTime = fdf.parse(formattedDate);\n+        assertEquals(expectedTime, actualTime);\n+    }\n+    \n+    @Test\n+    public void testParseNumerics() throws ParseException {\n+        Calendar cal= Calendar.getInstance(NEW_YORK, Locale.US);\n+        cal.clear();\n+        cal.set(2003, 1, 10, 15, 33, 20);\n+        cal.set(Calendar.MILLISECOND, 989);\n+        \n+        DateParser fdf = getInstance(\"yyyyMMddHHmmssSSS\", NEW_YORK, Locale.US);\n+        assertEquals(cal.getTime(), fdf.parse(\"20030210153320989\"));\n+    }\n+    \n+    @Test\n+    public void testQuotes() throws ParseException {\n+        Calendar cal= Calendar.getInstance(NEW_YORK, Locale.US);\n+        cal.clear();\n+        cal.set(2003, 1, 10, 15, 33, 20);\n+        cal.set(Calendar.MILLISECOND, 989);\n+        \n+        DateParser fdf = getInstance(\"''yyyyMMdd'A''B'HHmmssSSS''\", NEW_YORK, Locale.US);\n+        assertEquals(cal.getTime(), fdf.parse(\"'20030210A'B153320989'\"));\n+    }\n+    \n+    @Test\n+    public void testDayOf() throws ParseException {\n+        Calendar cal= Calendar.getInstance(NEW_YORK, Locale.US);\n+        cal.clear();\n+        cal.set(2003, 1, 10);\n+        \n+        DateParser fdf = getInstance(\"W w F D y\", NEW_YORK, Locale.US);\n+        assertEquals(cal.getTime(), fdf.parse(\"3 7 2 41 03\"));\n+    }\n+    \n+    /**\n+     * Test case for {@link FastDateParser#getDateInstance(int, java.util.Locale)}.\n+     * @throws ParseException \n+     */\n+    @Test\n+    public void testShortDateStyleWithLocales() throws ParseException {\n+        DateParser fdf = getDateInstance(FastDateFormat.SHORT, Locale.US);\n+        Calendar cal = Calendar.getInstance();\n+        cal.clear();\n+        \n+        cal.set(2004, 1, 3);\n+        assertEquals(cal.getTime(), fdf.parse(\"2/3/04\"));\n+\n+        fdf = getDateInstance(FastDateFormat.SHORT, SWEDEN);\n+        assertEquals(cal.getTime(), fdf.parse(\"2004-02-03\"));\n+    }\n+\n+    /**\n+     * Tests that pre-1000AD years get padded with yyyy\n+     * @throws ParseException \n+     */\n+    @Test\n+    public void testLowYearPadding() throws ParseException {\n+        DateParser parser = getInstance(YMD_SLASH);\n+        Calendar cal = Calendar.getInstance();\n+        cal.clear();\n+\n+        cal.set(1,0,1);\n+        assertEquals(cal.getTime(), parser.parse(\"0001/01/01\"));\n+        cal.set(10,0,1);\n+        assertEquals(cal.getTime(), parser.parse(\"0010/01/01\"));\n+        cal.set(100,0,1);\n+        assertEquals(cal.getTime(), parser.parse(\"0100/01/01\"));\n+        cal.set(999,0,1);\n+        assertEquals(cal.getTime(), parser.parse(\"0999/01/01\"));\n+    }\n+    \n+    /**\n+     * @throws ParseException \n+     */\n+    @Test\n+    public void testMilleniumBug() throws ParseException {\n+        DateParser parser = getInstance(DMY_DOT);\n+        Calendar cal = Calendar.getInstance();\n+        cal.clear();\n+        \n+        cal.set(1000,0,1);\n+        assertEquals(cal.getTime(), parser.parse(\"01.01.1000\"));\n+    }\n+\n+    @Test\n+    public void testLang303() throws ParseException {\n+        DateParser parser = getInstance(YMD_SLASH);\n+        Calendar cal = Calendar.getInstance();\n+        cal.set(2004,11,31);\n+\n+        Date date = parser.parse(\"2004/11/31\");\n+\n+        parser = (DateParser) SerializationUtils.deserialize( SerializationUtils.serialize( (Serializable)parser ) );\n+        assertEquals(date, parser.parse(\"2004/11/31\"));\n+    }\n+\n+    @Test\n+    public void testLang538() throws ParseException {\n+        DateParser parser = getInstance(\"yyyy-MM-dd'T'HH:mm:ss.SSS'Z'\", TimeZone.getTimeZone(\"GMT\"));\n+        \n+        Calendar cal = Calendar.getInstance(TimeZone.getTimeZone(\"GMT-8\"));\n+        cal.clear();\n+        cal.set(2009, 9, 16, 8, 42, 16);\n+\n+        assertEquals(cal.getTime(), parser.parse(\"2009-10-16T16:42:16.000Z\"));\n+    }\n+    \n+    @Test\n+    public void testEquals() {\n+        DateParser parser1= getInstance(YMD_SLASH);\n+        DateParser parser2= getInstance(YMD_SLASH);\n+\n+        assertEquals(parser1, parser2);        \n+        assertEquals(parser1.hashCode(), parser2.hashCode());\n+        \n+        assertFalse(parser1.equals(new Object()));\n+    }\n+\n+    @Test\n+    public void testToStringContainsName() {\n+        DateParser parser= getInstance(YMD_SLASH);\n+        assertTrue(parser.toString().startsWith(\"FastDate\"));\n+    }\n+    \n+    @Test\n+    public void testPatternMatches() {\n+        DateParser parser= getInstance(yMdHmsSZ);\n+        assertEquals(yMdHmsSZ, parser.getPattern());\n+    }\n+    \n+    @Test\n+    public void testLocaleMatches() {\n+        DateParser parser= getInstance(yMdHmsSZ, SWEDEN);\n+        assertEquals(SWEDEN, parser.getLocale());\n+    }\n+    \n+    @Test\n+    public void testTimeZoneMatches() {\n+        DateParser parser= getInstance(yMdHmsSZ, REYKJAVIK);\n+        assertEquals(REYKJAVIK, parser.getTimeZone());\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/lang3/time/FastDatePrinterTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang3.time;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n+\n+import java.io.Serializable;\n+import java.text.SimpleDateFormat;\n+import java.util.Calendar;\n+import java.util.Date;\n+import java.util.GregorianCalendar;\n+import java.util.Locale;\n+import java.util.TimeZone;\n+\n+import org.apache.commons.lang3.SerializationUtils;\n+import org.junit.Test;\n+\n+/**\n+ * Unit tests {@link org.apache.commons.lang3.time.FastDatePrinter}.\n+ *\n+ * @since 3.0\n+ */\n+public class FastDatePrinterTest {\n+    \n+    private static final String YYYY_MM_DD = \"yyyy/MM/dd\";\n+    private static final TimeZone NEW_YORK = TimeZone.getTimeZone(\"America/New_York\");\n+    private static final Locale SWEDEN = new Locale(\"sv\", \"SE\");\n+\n+        DatePrinter getInstance(String format) {\n+        return getInstance(format, TimeZone.getDefault(), Locale.getDefault());\n+    }\n+\n+    private DatePrinter getDateInstance(int dateStyle, Locale locale) {\n+        return getInstance(FormatCache.getPatternForStyle(dateStyle, null, locale), TimeZone.getDefault(), Locale.getDefault());\n+    }\n+\n+    private DatePrinter getInstance(String format, Locale locale) {\n+        return getInstance(format, TimeZone.getDefault(), locale);\n+    }\n+\n+    private DatePrinter getInstance(String format, TimeZone timeZone) {\n+        return getInstance(format, timeZone, Locale.getDefault());\n+    }\n+\n+    /**\n+     * Override this method in derived tests to change the construction of instances\n+     * @param format\n+     * @param timeZone\n+     * @param locale\n+     * @return\n+     */\n+    protected DatePrinter getInstance(String format, TimeZone timeZone, Locale locale) {\n+        return new FastDatePrinter(format, timeZone, locale);\n+    }\n+\n+    @Test\n+    public void testFormat() {\n+        Locale realDefaultLocale = Locale.getDefault();\n+        TimeZone realDefaultZone = TimeZone.getDefault();\n+        try {\n+            Locale.setDefault(Locale.US);\n+            TimeZone.setDefault(NEW_YORK);\n+\n+            GregorianCalendar cal1 = new GregorianCalendar(2003, 0, 10, 15, 33, 20);\n+            GregorianCalendar cal2 = new GregorianCalendar(2003, 6, 10, 9, 00, 00);\n+            Date date1 = cal1.getTime();\n+            Date date2 = cal2.getTime();\n+            long millis1 = date1.getTime();\n+            long millis2 = date2.getTime();\n+\n+            DatePrinter fdf = getInstance(\"yyyy-MM-dd'T'HH:mm:ss\");\n+            SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ss\");\n+            assertEquals(sdf.format(date1), fdf.format(date1));\n+            assertEquals(\"2003-01-10T15:33:20\", fdf.format(date1));\n+            assertEquals(\"2003-01-10T15:33:20\", fdf.format(cal1));\n+            assertEquals(\"2003-01-10T15:33:20\", fdf.format(millis1));\n+            assertEquals(\"2003-07-10T09:00:00\", fdf.format(date2));\n+            assertEquals(\"2003-07-10T09:00:00\", fdf.format(cal2));\n+            assertEquals(\"2003-07-10T09:00:00\", fdf.format(millis2));\n+\n+            fdf = getInstance(\"Z\");\n+            assertEquals(\"-0500\", fdf.format(date1));\n+            assertEquals(\"-0500\", fdf.format(cal1));\n+            assertEquals(\"-0500\", fdf.format(millis1));\n+\n+            assertEquals(\"-0400\", fdf.format(date2));\n+            assertEquals(\"-0400\", fdf.format(cal2));\n+            assertEquals(\"-0400\", fdf.format(millis2));\n+\n+            fdf = getInstance(\"ZZ\");\n+            assertEquals(\"-05:00\", fdf.format(date1));\n+            assertEquals(\"-05:00\", fdf.format(cal1));\n+            assertEquals(\"-05:00\", fdf.format(millis1));\n+\n+            assertEquals(\"-04:00\", fdf.format(date2));\n+            assertEquals(\"-04:00\", fdf.format(cal2));\n+            assertEquals(\"-04:00\", fdf.format(millis2));\n+\n+            String pattern = \"GGGG GGG GG G yyyy yyy yy y MMMM MMM MM M\" +\n+                \" dddd ddd dd d DDDD DDD DD D EEEE EEE EE E aaaa aaa aa a zzzz zzz zz z\";\n+            fdf = getInstance(pattern);\n+            sdf = new SimpleDateFormat(pattern);\n+            // SDF bug fix starting with Java 7\n+            assertEquals(sdf.format(date1).replaceAll(\"2003 03 03 03\", \"2003 2003 03 2003\"), fdf.format(date1));\n+            assertEquals(sdf.format(date2).replaceAll(\"2003 03 03 03\", \"2003 2003 03 2003\"), fdf.format(date2));\n+        } finally {\n+            Locale.setDefault(realDefaultLocale);\n+            TimeZone.setDefault(realDefaultZone);\n+        }\n+    }\n+\n+    /**\n+     * Test case for {@link FastDatePrinter#getDateInstance(int, java.util.Locale)}.\n+     */\n+    @Test\n+    public void testShortDateStyleWithLocales() {\n+        Locale usLocale = Locale.US;\n+        Locale swedishLocale = new Locale(\"sv\", \"SE\");\n+        Calendar cal = Calendar.getInstance();\n+        cal.set(2004, 1, 3);\n+        DatePrinter fdf = getDateInstance(FastDateFormat.SHORT, usLocale);\n+        assertEquals(\"2/3/04\", fdf.format(cal));\n+\n+        fdf = getDateInstance(FastDateFormat.SHORT, swedishLocale);\n+        assertEquals(\"2004-02-03\", fdf.format(cal));\n+\n+    }\n+\n+    /**\n+     * Tests that pre-1000AD years get padded with yyyy\n+     */\n+    @Test\n+    public void testLowYearPadding() {\n+        Calendar cal = Calendar.getInstance();\n+        DatePrinter format = getInstance(YYYY_MM_DD);\n+\n+        cal.set(1,0,1);\n+        assertEquals(\"0001/01/01\", format.format(cal));\n+        cal.set(10,0,1);\n+        assertEquals(\"0010/01/01\", format.format(cal));\n+        cal.set(100,0,1);\n+        assertEquals(\"0100/01/01\", format.format(cal));\n+        cal.set(999,0,1);\n+        assertEquals(\"0999/01/01\", format.format(cal));\n+    }\n+    /**\n+     * Show Bug #39410 is solved\n+     */\n+    @Test\n+    public void testMilleniumBug() {\n+        Calendar cal = Calendar.getInstance();\n+        DatePrinter format = getInstance(\"dd.MM.yyyy\");\n+\n+        cal.set(1000,0,1);\n+        assertEquals(\"01.01.1000\", format.format(cal));\n+    }\n+\n+    /**\n+     * testLowYearPadding showed that the date was buggy\n+     * This test confirms it, getting 366 back as a date\n+     */\n+    @Test\n+    public void testSimpleDate() {\n+        Calendar cal = Calendar.getInstance();\n+        DatePrinter format = getInstance(YYYY_MM_DD);\n+\n+        cal.set(2004,11,31);\n+        assertEquals(\"2004/12/31\", format.format(cal));\n+        cal.set(999,11,31);\n+        assertEquals(\"0999/12/31\", format.format(cal));\n+        cal.set(1,2,2);\n+        assertEquals(\"0001/03/02\", format.format(cal));\n+    }\n+\n+    @Test\n+    public void testLang303() {\n+        Calendar cal = Calendar.getInstance();\n+        cal.set(2004,11,31);\n+\n+        DatePrinter format = getInstance(YYYY_MM_DD);\n+        String output = format.format(cal);\n+\n+        format = (DatePrinter) SerializationUtils.deserialize( SerializationUtils.serialize( (Serializable)format ) );\n+        assertEquals(output, format.format(cal));\n+    }\n+\n+    @Test\n+    public void testLang538() {\n+        // more commonly constructed with: cal = new GregorianCalendar(2009, 9, 16, 8, 42, 16)\n+        // for the unit test to work in any time zone, constructing with GMT-8 rather than default locale time zone\n+        GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone(\"GMT-8\"));\n+        cal.clear();\n+        cal.set(2009, 9, 16, 8, 42, 16);\n+\n+        DatePrinter format = getInstance(\"yyyy-MM-dd'T'HH:mm:ss.SSS'Z'\", TimeZone.getTimeZone(\"GMT\"));\n+        assertEquals(\"dateTime\", \"2009-10-16T16:42:16.000Z\", format.format(cal.getTime()));\n+        assertEquals(\"dateTime\", \"2009-10-16T08:42:16.000Z\", format.format(cal));\n+    }\n+\n+    @Test\n+    public void testLang645() {\n+        Locale locale = new Locale(\"sv\", \"SE\");\n+\n+        Calendar cal = Calendar.getInstance();\n+        cal.set(2010, 0, 1, 12, 0, 0);\n+        Date d = cal.getTime();\n+\n+        DatePrinter fdf = getInstance(\"EEEE', week 'ww\", locale);\n+\n+        assertEquals(\"fredag, week 53\", fdf.format(d));\n+    }\n+    \n+    @Test\n+    public void testEquals() {\n+        DatePrinter printer1= getInstance(YYYY_MM_DD);\n+        DatePrinter printer2= getInstance(YYYY_MM_DD);\n+\n+        assertEquals(printer1, printer2);\n+        assertEquals(printer1.hashCode(), printer2.hashCode());        \n+\n+        assertFalse(printer1.equals(new Object()));\n+    }\n+    \n+    @Test\n+    public void testToStringContainsName() {\n+        DatePrinter printer= getInstance(YYYY_MM_DD);\n+        assertTrue(printer.toString().startsWith(\"FastDate\"));\n+    }\n+    \n+    @Test\n+    public void testPatternMatches() {\n+        DatePrinter printer= getInstance(YYYY_MM_DD);\n+        assertEquals(YYYY_MM_DD, printer.getPattern());\n+    }\n+    \n+    @Test\n+    public void testLocaleMatches() {\n+        DatePrinter printer= getInstance(YYYY_MM_DD, SWEDEN);\n+        assertEquals(SWEDEN, printer.getLocale());\n+    }\n+    \n+    @Test\n+    public void testTimeZoneMatches() {\n+        DatePrinter printer= getInstance(YYYY_MM_DD, NEW_YORK);\n+        assertEquals(NEW_YORK, printer.getTimeZone());\n+    }\n+}", "timestamp": 1327561226, "metainfo": ""}