{"sha": "9839566cf0eb6d299a61d6354522d6f65ab83af3", "log": "Rework time package in preparation for 2.0 release DateUtils split to DateFormatUtils and DurationFormatUtils CalendarUtils renamed to DateUtils StopWatch time format method moved to DurationFormatUtils Tests updated and pass   ", "commit": "\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang/time/DateFormatUtils.java\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2002-2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.lang.time;\n+\n+import java.util.Date;\n+import java.util.Locale;\n+import java.util.TimeZone;\n+\n+/**\n+ * Date and time formatting utilites and constants.\n+ * <p>\n+ * Formatting is performed using the\n+ * {@link org.apache.commons.lang.time.FastDateFormat} class.\n+ *\n+ * @author Apache Ant - DateUtils\n+ * @author <a href=\"mailto:sbailliez@apache.org\">Stephane Bailliez</a>\n+ * @author <a href=\"mailto:stefan.bodewig@epost.de\">Stefan Bodewig</a>\n+ * @author Stephen Colebourne\n+ * @since 2.0\n+ * @version $Id: DateFormatUtils.java,v 1.1 2003/06/08 23:14:23 scolebourne Exp $\n+ */\n+public final class DateFormatUtils {\n+\n+    /**\n+     * ISO8601 formatter for date-time witout timezone.\n+     * The format used is <tt>yyyy-MM-dd'T'HH:mm:ss</tt>.\n+     */\n+    public static final FastDateFormat ISO_DATETIME_FORMAT\n+            = FastDateFormat.getInstance(\"yyyy-MM-dd'T'HH:mm:ss\");\n+\n+    /**\n+     * ISO8601 formatter for date-time with timezone.\n+     * The format used is <tt>yyyy-MM-dd'T'HH:mm:ssZZ</tt>.\n+     */\n+    public static final FastDateFormat ISO_DATETIME_TIMEZONE_FORMAT\n+            = FastDateFormat.getInstance(\"yyyy-MM-dd'T'HH:mm:ssZZ\");\n+\n+    /**\n+     * ISO8601 formatter for date without timezone.\n+     * The format used is <tt>yyyy-MM-dd</tt>.\n+     */\n+    public static final FastDateFormat ISO_DATE_FORMAT\n+            = FastDateFormat.getInstance(\"yyyy-MM-dd\");\n+\n+    /**\n+     * ISO8601-like formatter for date with timezone.\n+     * The format used is <tt>yyyy-MM-ddZZ</tt>.\n+     * This pattern does not comply with the formal ISO8601 specification\n+     * as the standard does not allow a timezone without a time.\n+     */\n+    public static final FastDateFormat ISO_DATE_TIMEZONE_FORMAT\n+            = FastDateFormat.getInstance(\"yyyy-MM-ddZZ\");\n+\n+    /**\n+     * ISO8601 formatter for time without timezone.\n+     * The format used is <tt>'T'HH:mm:ss</tt>.\n+     */\n+    public static final FastDateFormat ISO_TIME_FORMAT\n+            = FastDateFormat.getInstance(\"'T'HH:mm:ss\");\n+\n+    /**\n+     * ISO8601 formatter for time with timezone.\n+     * The format used is <tt>'T'HH:mm:ssZZ</tt>.\n+     */\n+    public static final FastDateFormat ISO_TIME_TIMEZONE_FORMAT\n+            = FastDateFormat.getInstance(\"'T'HH:mm:ssZZ\");\n+\n+    /**\n+     * ISO8601-like formatter for time without timezone.\n+     * The format used is <tt>HH:mm:ss</tt>.\n+     * This pattern does not comply with the formal ISO8601 specification\n+     * as the standard requires the 'T' prefix for times.\n+     */\n+    public static final FastDateFormat ISO_TIME_NO_T_FORMAT\n+            = FastDateFormat.getInstance(\"HH:mm:ss\");\n+\n+    /**\n+     * ISO8601-like formatter for time with timezone.\n+     * The format used is <tt>HH:mm:ssZZ</tt>.\n+     * This pattern does not comply with the formal ISO8601 specification\n+     * as the standard requires the 'T' prefix for times.\n+     */\n+    public static final FastDateFormat ISO_TIME_NO_T_TIMEZONE_FORMAT\n+            = FastDateFormat.getInstance(\"HH:mm:ssZZ\");\n+\n+    /**\n+     * SMTP (and probably other) date headers.\n+     * The format used is <tt>EEE, dd MMM yyyy HH:mm:ss Z</tt> in US locale.\n+     */\n+    public static final FastDateFormat SMTP_DATETIME_FORMAT\n+            = FastDateFormat.getInstance(\"EEE, dd MMM yyyy HH:mm:ss Z\", Locale.US);\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * DateFormatUtils instances should NOT be constructed in standard programming.\n+     * <p>\n+     * This constructor is public to permit tools that require a JavaBean instance\n+     * to operate.\n+     */\n+    public DateFormatUtils() {\n+    }\n+\n+    /**\n+     * Format a date/time into a specific pattern using the UTC timezone.\n+     * \n+     * @param millis  the date to format expressed in milliseconds\n+     * @param pattern  the pattern to use to format the date\n+     * @return the formatted date\n+     */\n+    public static String formatUTC(long millis, String pattern) {\n+        return format(new Date(millis), pattern, DateUtils.UTC_TIMEZONE, null);\n+    }\n+\n+    /**\n+     * Format a date/time into a specific pattern using the UTC timezone.\n+     * \n+     * @param date  the date to format\n+     * @param pattern  the pattern to use to format the date\n+     * @return the formatted date\n+     */\n+    public static String formatUTC(Date date, String pattern) {\n+        return format(date, pattern, DateUtils.UTC_TIMEZONE, null);\n+    }\n+    \n+    /**\n+     * Format a date/time into a specific pattern using the UTC timezone.\n+     * \n+     * @param millis  the date to format expressed in milliseconds\n+     * @param pattern  the pattern to use to format the date\n+     * @param locale  the locale to use, may be null\n+     * @return the formatted date\n+     */\n+    public static String formatUTC(long millis, String pattern, Locale locale) {\n+        return format(new Date(millis), pattern, DateUtils.UTC_TIMEZONE, locale);\n+    }\n+\n+    /**\n+     * Format a date/time into a specific pattern using the UTC timezone.\n+     * \n+     * @param date  the date to format\n+     * @param pattern  the pattern to use to format the date\n+     * @param locale  the locale to use, may be null\n+     * @return the formatted date\n+     */\n+    public static String formatUTC(Date date, String pattern, Locale locale) {\n+        return format(date, pattern, DateUtils.UTC_TIMEZONE, locale);\n+    }\n+    \n+    /**\n+     * Format a date/time into a specific pattern.\n+     * \n+     * @param millis  the date to format expressed in milliseconds\n+     * @param pattern  the pattern to use to format the date\n+     * @return the formatted date\n+     */\n+    public static String format(long millis, String pattern) {\n+        return format(new Date(millis), pattern, null, null);\n+    }\n+\n+    /**\n+     * Format a date/time into a specific pattern.\n+     * \n+     * @param date  the date to format\n+     * @param pattern  the pattern to use to format the date\n+     * @return the formatted date\n+     */\n+    public static String format(Date date, String pattern) {\n+        return format(date, pattern, null, null);\n+    }\n+    \n+    /**\n+     * Format a date/time into a specific pattern in a timezone.\n+     * \n+     * @param millis  the time expressed in milliseconds\n+     * @param pattern  the pattern to use to format the date\n+     * @param timeZone  the timezone to use, may be null\n+     * @return the formatted date\n+     */\n+    public static String format(long millis, String pattern, TimeZone timeZone) {\n+        return format(new Date(millis), pattern, timeZone, null);\n+    }\n+\n+    /**\n+     * Format a date/time into a specific pattern in a timezone.\n+     * \n+     * @param date  the date to format\n+     * @param pattern  the pattern to use to format the date\n+     * @param timeZone  the timezone to use, may be null\n+     * @return the formatted date\n+     */\n+    public static String format(Date date, String pattern, TimeZone timeZone) {\n+        return format(date, pattern, timeZone, null);\n+    }\n+\n+    /**\n+     * Format a date/time into a specific pattern in a locale.\n+     * \n+     * @param millis  the date to format expressed in milliseconds\n+     * @param pattern  the pattern to use to format the date\n+     * @param locale  the locale to use, may be null\n+     * @return the formatted date\n+     */\n+    public static String format(long millis, String pattern, Locale locale) {\n+        return format(new Date(millis), pattern, null, locale);\n+    }\n+\n+    /**\n+     * Format a date/time into a specific pattern in a locale.\n+     * \n+     * @param date  the date to format\n+     * @param pattern  the pattern to use to format the date\n+     * @param locale  the locale to use, may be null\n+     * @return the formatted date\n+     */\n+    public static String format(Date date, String pattern, Locale locale) {\n+        return format(date, pattern, null, locale);\n+    }\n+\n+    /**\n+     * Format a date/time into a specific pattern in a timezone and locale.\n+     * \n+     * @param millis  the date to format expressed in milliseconds\n+     * @param pattern  the pattern to use to format the date\n+     * @param timeZone  the timezone to use, may be null\n+     * @param locale  the locale to use, may be null\n+     * @return the formatted date\n+     */\n+    public static String format(long millis, String pattern, TimeZone timeZone, Locale locale) {\n+        return format(new Date(millis), pattern, timeZone, locale);\n+    }\n+\n+    /**\n+     * Format a date/time into a specific pattern in a timezone and locale.\n+     * \n+     * @param date  the date to format\n+     * @param pattern  the pattern to use to format the date\n+     * @param timeZone  the timezone to use, may be null\n+     * @param locale  the locale to use, may be null\n+     * @return the formatted date\n+     */\n+    public static String format(Date date, String pattern, TimeZone timeZone, Locale locale) {\n+        FastDateFormat df = FastDateFormat.getInstance(pattern, timeZone, locale);\n+        return df.format(date);\n+    }\n+\n+}\n--- a/src/java/org/apache/commons/lang/time/DateUtils.java\n+++ b/src/java/org/apache/commons/lang/time/DateUtils.java\n  */\n package org.apache.commons.lang.time;\n \n-import java.text.ChoiceFormat;\n import java.text.DateFormat;\n-import java.text.MessageFormat;\n+import java.text.DateFormatSymbols;\n+import java.text.ParseException;\n import java.text.SimpleDateFormat;\n import java.util.Calendar;\n import java.util.Date;\n+import java.util.GregorianCalendar;\n+import java.util.Iterator;\n import java.util.Locale;\n+import java.util.NoSuchElementException;\n import java.util.TimeZone;\n \n /**\n- * Helper methods to deal with date/time formatting. [Relies heavily on\n- * code taken from the DateUtils class of the jakarata-ant project.]\n- *\n- * @author <a href=\"mailto:sbailliez@apache.org\">Stephane Bailliez</a>\n- * @author <a href=\"mailto:stefan.bodewig@epost.de\">Stefan Bodewig</a>\n- * @since 2.1\n- * @version $Id: DateUtils.java,v 1.2 2003/02/04 22:19:33 scolebourne Exp $\n+ * A suite of utilities surrounding the use of the Calendar and Date object.\n+ *\n+ * @author <a href=\"mailto:sergek@lokitech.com\">Serge Knystautas</a>\n+ * @author Stephen Colebourne\n+ * @since 2.0\n+ * @version $Id: DateUtils.java,v 1.3 2003/06/08 23:14:23 scolebourne Exp $\n  */\n-public final class DateUtils {\n-\n-    /**\n-     * ISO8601-like pattern for date-time. It does not support timezone.\n-     *  <tt>yyyy-MM-ddTHH:mm:ss</tt>\n-     */\n-    public static final String ISO8601_DATETIME_PATTERN\n-            = \"yyyy-MM-dd'T'HH:mm:ss\";\n-\n-    /**\n-     * ISO8601-like pattern for date. <tt>yyyy-MM-dd</tt>\n-     */\n-    public static final String ISO8601_DATE_PATTERN\n-            = \"yyyy-MM-dd\";\n-\n-    /**\n-     * ISO8601-like pattern for time.  <tt>HH:mm:ss</tt>\n-     */\n-    public static final String ISO8601_TIME_PATTERN\n-            = \"HH:mm:ss\";\n-\n-    /**\n-     * Format used for SMTP (and probably other) Date headers.\n-     */\n-    public static final DateFormat DATE_HEADER_FORMAT\n-        = new SimpleDateFormat(\"EEE, dd MMM yyyy HH:mm:ss \", Locale.US);\n-\n-\n-// code from Magesh moved from DefaultLogger and slightly modified\n-    private static final MessageFormat MINUTE_SECONDS\n-            = new MessageFormat(\"{0}{1}\");\n-\n-    private static final double[] LIMITS = {0, 1, 2};\n-\n-    private static final String[] MINUTES_PART =\n-            {\"\", \"1 minute \", \"{0,number} minutes \"};\n-\n-    private static final String[] SECONDS_PART =\n-            {\"0 seconds\", \"1 second\", \"{1,number} seconds\"};\n-\n-    private static final ChoiceFormat MINUTES_FORMAT =\n-            new ChoiceFormat(LIMITS, MINUTES_PART);\n-\n-    private static final ChoiceFormat SECONDS_FORMAT =\n-            new ChoiceFormat(LIMITS, SECONDS_PART);\n-\n-    static {\n-        MINUTE_SECONDS.setFormat(0, MINUTES_FORMAT);\n-        MINUTE_SECONDS.setFormat(1, SECONDS_FORMAT);\n-    }\n-\n-    /**\n-     * <p>DateUtils instances should NOT be constructed in standard programming.</p>\n-     *\n-     * <p>This constructor is public to permit tools that require a JavaBean instance\n-     * to operate.</p>\n-     */\n-    public DateUtils() {\n-    }\n-\n-\n-    /**\n-     * Format a date/time into a specific pattern.\n-     * @param date the date to format expressed in milliseconds.\n-     * @param pattern the pattern to use to format the date.\n-     * @return the formatted date.\n-     */\n-    public static String format(long date, String pattern) {\n-        return format(new Date(date), pattern);\n-    }\n-\n-\n-    /**\n-     * Format a date/time into a specific pattern.\n-     * @param date the date to format expressed in milliseconds.\n-     * @param pattern the pattern to use to format the date.\n-     * @return the formatted date.\n-     */\n-    public static String format(Date date, String pattern) {\n-        DateFormat df = createDateFormat(pattern);\n-        return df.format(date);\n-    }\n-\n-\n-    /**\n-     * Format an elapsed time into a plurialization correct string.\n-     * It is limited only to report elapsed time in minutes and\n-     * seconds and has the following behavior.\n-     * <ul>\n-     * <li>minutes are not displayed when 0. (ie: \"45 seconds\")</li>\n-     * <li>seconds are always displayed in plural form (ie \"0 seconds\" or\n-     * \"10 seconds\") except for 1 (ie \"1 second\")</li>\n-     * </ul>\n-     * @param time the elapsed time to report in milliseconds.\n-     * @return the formatted text in minutes/seconds.\n-     */\n-    public static String formatElapsedTime(long millis) {\n-        long seconds = millis / 1000;\n-        long minutes = seconds / 60;\n-        Object[] args = {new Long(minutes), new Long(seconds % 60)};\n-        return MINUTE_SECONDS.format(args);\n-    }\n-\n-    /**\n-     * return a lenient date format set to GMT time zone.\n-     * @param pattern the pattern used for date/time formatting.\n-     * @return the configured format for this pattern.\n-     */\n-    private static DateFormat createDateFormat(String pattern) {\n-        SimpleDateFormat sdf = new SimpleDateFormat(pattern);\n-        TimeZone gmt = TimeZone.getTimeZone(\"GMT\");\n-        sdf.setTimeZone(gmt);\n-        sdf.setLenient(true);\n-        return sdf;\n-    }\n-\n-    /**\n-     * Calculate the phase of the moon for a given date.\n-     *\n-     * <p>Code heavily influenced by hacklib.c in <a\n-     * href=\"http://www.nethack.org/\">Nethack</a></p>\n-     *\n-     * <p>The Algorithm:\n-     *\n-     * <pre>\n-     * moon period = 29.53058 days ~= 30, year = 365.2422 days\n-     *\n-     * days moon phase advances on first day of year compared to preceding year\n-     *  = 365.2422 - 12*29.53058 ~= 11\n-     *\n-     * years in Metonic cycle (time until same phases fall on the same days of\n-     *  the month) = 18.6 ~= 19\n-     *\n-     * moon phase on first day of year (epact) ~= (11*(year%19) + 18) % 30\n-     *  (18 as initial condition for 1900)\n-     *\n-     * current phase in days = first day phase + days elapsed in year\n-     *\n-     * 6 moons ~= 177 days\n-     * 177 ~= 8 reported phases * 22\n-     * + 11/22 for rounding\n-     * </pre>\n-     *\n-     * @return The phase of the moon as a number between 0 and 7 with\n-     *         0 meaning new moon and 4 meaning full moon.\n-     *\n-     * @since 1.2, Ant 1.5\n-     */\n-    public static int getPhaseOfMoon(Calendar cal) {\n-        int dayOfTheYear = cal.get(Calendar.DAY_OF_YEAR);\n-        int yearInMetonicCycle = ((cal.get(Calendar.YEAR) - 1900) % 19) + 1;\n-        int epact = (11 * yearInMetonicCycle + 18) % 30;\n-        if ((epact == 25 && yearInMetonicCycle > 11) || epact == 24) {\n-            epact++;\n-        }\n-        return (((((dayOfTheYear + epact) * 6) + 11) % 177) / 22) & 7;\n-    }\n-\n-    /**\n-     * Returns the current Date in a format suitable for a SMTP date\n-     * header.\n-     *\n-     * @since Ant 1.5.2\n-     */\n-    public static String getDateForHeader() {\n-        Calendar cal = Calendar.getInstance();\n-        TimeZone tz = cal.getTimeZone();\n-        int offset = tz.getOffset(cal.get(Calendar.ERA),\n-                                  cal.get(Calendar.YEAR),\n-                                  cal.get(Calendar.MONTH),\n-                                  cal.get(Calendar.DAY_OF_MONTH),\n-                                  cal.get(Calendar.DAY_OF_WEEK),\n-                                  cal.get(Calendar.MILLISECOND));\n-        StringBuffer tzMarker = new StringBuffer(offset < 0 ? \"-\" : \"+\");\n-        offset = Math.abs(offset);\n-        int hours = offset / (60 * 60 * 1000);\n-        int minutes = offset / (60 * 1000) - 60 * hours;\n-        if (hours < 10) {\n-            tzMarker.append(\"0\");\n-        }\n-        tzMarker.append(hours);\n-        if (minutes < 10) {\n-            tzMarker.append(\"0\");\n-        }\n-        tzMarker.append(minutes);\n-        return DATE_HEADER_FORMAT.format(cal.getTime()) + tzMarker.toString();\n-    }\n+public class DateUtils {\n+    \n+    /**\n+     * The UTC timezone (often referred to as GMT).\n+     */\n+    public static final TimeZone UTC_TIMEZONE = TimeZone.getTimeZone(\"GMT\");\n+    /**\n+     * Number of milliseconds in a standard second.\n+     */\n+    public static final int MILLIS_IN_SECOND = 1000;\n+    /**\n+     * Number of milliseconds in a standard minute.\n+     */\n+    public static final int MILLIS_IN_MINUTE = 60 * 1000;\n+    /**\n+     * Number of milliseconds in a standard hour.\n+     */\n+    public static final int MILLIS_IN_HOUR = 60 * 60 * 1000;\n+    /**\n+     * Number of milliseconds in a standard day.\n+     */\n+    public static final int MILLIS_IN_DAY = 24 * 60 * 60 * 1000;\n+\n+    /**\n+     * This is half a month, so this represents whether a date is in the top\n+     * or bottom half of the month.\n+     */\n+    public final static int SEMI_MONTH = 1001;\n+\n+    private static final int[][] fields = {\n+            {Calendar.MILLISECOND},\n+            {Calendar.SECOND},\n+            {Calendar.MINUTE},\n+            {Calendar.HOUR_OF_DAY, Calendar.HOUR},\n+            {Calendar.DATE, Calendar.DAY_OF_MONTH, Calendar.AM_PM /* Calendar.DAY_OF_YEAR, Calendar.DAY_OF_WEEK, Calendar.DAY_OF_WEEK_IN_MONTH */},\n+            {Calendar.MONTH, DateUtils.SEMI_MONTH},\n+            {Calendar.YEAR},\n+            {Calendar.ERA}};\n+\n+    private static DateFormat[] dateFormats = {\n+        //3/31/92 10:00:07 PST\n+        new SimpleDateFormat(\"M/dd/yy h:mm:ss z\"),\n+        //January 23, 1987 10:05pm\n+        new SimpleDateFormat(\"MMM d, yyyy h:mm a\"),\n+        //22:00 GMT\n+        new SimpleDateFormat(\"h:mm z\")};\n+\n+    /**\n+     * A week range, starting on Sunday.\n+     */\n+    public final static int RANGE_WEEK_SUNDAY = 1;\n+\n+    /**\n+     * A week range, starting on Monday.\n+     */\n+    public final static int RANGE_WEEK_MONDAY = 2;\n+\n+    /**\n+     * A week range, starting on the day focused.\n+     */\n+    public final static int RANGE_WEEK_RELATIVE = 3;\n+\n+    /**\n+     * A week range, centered around the day focused.\n+     */\n+    public final static int RANGE_WEEK_CENTER = 4;\n+\n+    /**\n+     * A month range, the week starting on Sunday.\n+     */\n+    public final static int RANGE_MONTH_SUNDAY = 5;\n+\n+    /**\n+     * A month range, the week starting on Monday.\n+     */\n+    public final static int RANGE_MONTH_MONDAY = 6;\n+\n+    /**\n+     * See the other round method.  Works with a Date object.\n+     */\n+    public static Date round(Date val, int field) {\n+        GregorianCalendar gval = new GregorianCalendar();\n+        gval.setTime(val);\n+        modify(gval, field, true);\n+        return gval.getTime();\n+    }\n+\n+    /**\n+     * Round this date, leaving the field specified as the most significant\n+     * field.  For example, if you had the datetime of 28 Mar 2002\n+     * 13:45:01.231, if this was passed with HOUR, it would return 28 Mar\n+     * 2002 14:00:00.000.  If this was passed with MONTH, it would return\n+     * 1 April 2002 0:00:00.000.\n+     */\n+    public static Calendar round(Calendar val, int field) {\n+        Calendar rounded = (Calendar) val.clone();\n+        modify(rounded, field, true);\n+        return rounded;\n+    }\n+\n+    /**\n+     * See the other round method.  Works with an Object, trying to\n+     * use it as either a Date or Calendar.\n+     */\n+    public static Date round(Object val, int field) {\n+        if (val instanceof Date) {\n+            return round((Date) val, field);\n+        } else if (val instanceof Calendar) {\n+            return round((Calendar) val, field).getTime();\n+        } else {\n+            throw new ClassCastException(\"Could not round \" + val);\n+        }\n+    }\n+\n+    /**\n+     * See the other trunc method.  Works with a Date.\n+     */\n+    public static Date trunc(Date val, int field) {\n+        GregorianCalendar gval = new GregorianCalendar();\n+        gval.setTime(val);\n+        modify(gval, field, false);\n+        return gval.getTime();\n+    }\n+\n+    /**\n+     * Truncate this date, leaving the field specified as the most significant\n+     * field.  For example, if you had the datetime of 28 Mar 2002\n+     * 13:45:01.231, if you passed with HOUR, it would return 28 Mar\n+     * 2002 13:00:00.000.  If this was passed with MONTH, it would return\n+     * 1 Mar 2002 0:00:00.000.\n+     */\n+    public static Calendar trunc(Calendar val, int field) {\n+        Calendar truncated = (Calendar) val.clone();\n+        modify(truncated, field, false);\n+        return truncated;\n+    }\n+\n+    /**\n+     * See the other trunc method.  Works with an Object, trying to\n+     * use it as either a Date or Calendar.\n+     */\n+    public static Date trunc(Object val, int field) {\n+        if (val instanceof Date) {\n+            return trunc((Date) val, field);\n+        } else if (val instanceof Calendar) {\n+            return trunc((Calendar) val, field).getTime();\n+        } else {\n+            throw new ClassCastException(\"Could not trunc \" + val);\n+        }\n+    }\n+\n+    private static void modify(Calendar val, int field, boolean round) {\n+        boolean roundUp = false;\n+        for (int i = 0; i < fields.length; i++) {\n+            for (int j = 0; j < fields[i].length; j++) {\n+                if (fields[i][j] == field) {\n+                    //This is our field... we stop looping\n+                    if (round && roundUp) {\n+                        if (field == DateUtils.SEMI_MONTH) {\n+                            //This is a special case that's hard to generalize\n+                            //If the date is 1, we round up to 16, otherwise\n+                            //  we subtract 15 days and add 1 month\n+                            if (val.get(Calendar.DATE) == 1) {\n+                                val.add(Calendar.DATE, 15);\n+                            } else {\n+                                val.add(Calendar.DATE, -15);\n+                                val.add(Calendar.MONTH, 1);\n+                            }\n+                        } else {\n+                            //We need at add one to this field since the\n+                            //  last number causes us to round up\n+                            val.add(fields[i][0], 1);\n+                        }\n+                    }\n+                    return;\n+                }\n+            }\n+            //We have various fields that are not easy roundings\n+            int offset = 0;\n+            boolean offsetSet = false;\n+            //These are special types of fields that require different rounding rules\n+            switch (field) {\n+                case DateUtils.SEMI_MONTH:\n+                    if (fields[i][0] == Calendar.DATE) {\n+                        //If we're going to drop the DATE field's value,\n+                        //  we want to do this our own way.\n+                        //We need to subtrace 1 since the date has a minimum of 1\n+                        offset = val.get(Calendar.DATE) - 1;\n+                        //If we're above 15 days adjustment, that means we're in the\n+                        //  bottom half of the month and should stay accordingly.\n+                        if (offset >= 15) {\n+                            offset -= 15;\n+                        }\n+                        //Record whether we're in the top or bottom half of that range\n+                        roundUp = offset > 7;\n+                        offsetSet = true;\n+                    }\n+                    break;\n+                case Calendar.AM_PM:\n+                    if (fields[i][0] == Calendar.HOUR) {\n+                        //If we're going to drop the HOUR field's value,\n+                        //  we want to do this our own way.\n+                        offset = val.get(Calendar.HOUR);\n+                        if (offset >= 12) {\n+                            offset -= 12;\n+                        }\n+                        roundUp = offset > 6;\n+                        offsetSet = true;\n+                    }\n+                    break;\n+            }\n+            if (!offsetSet) {\n+                int min = val.getActualMinimum(fields[i][0]);\n+                int max = val.getActualMaximum(fields[i][0]);\n+                //Calculate the offset from the minimum allowed value\n+                offset = val.get(fields[i][0]) - min;\n+                //Set roundUp if this is more than half way between the minimum and maximum\n+                roundUp = offset > ((max - min) / 2);\n+            }\n+            //We need to remove this field\n+            val.add(fields[i][0], -offset);\n+        }\n+        throw new RuntimeException(\"We do not support that field.\");\n+\n+    }\n+\n+    /**\n+     * Parses strings the way that CVS supports it (very human readable).\n+     */\n+    public static Calendar parse(String original) {\n+        return parse(original, Locale.getDefault());\n+    }\n+\n+    /**\n+     * Parses strings the way that CVS supports it (very human readable).\n+     */\n+    public static Calendar parse(String original, Locale locale) {\n+        //Get the symbol names\n+        DateFormatSymbols symbols = new DateFormatSymbols(locale);\n+\n+        //Prep the string to parse\n+        String value = original.toLowerCase().trim();\n+\n+        //Get the current date/time\n+        Calendar now = Calendar.getInstance();\n+        if (value.endsWith(\" ago\")) {\n+            //If this was a date that was \"ago\" the current time...\n+            //Strip out the ' ago' part\n+            value = value.substring(0, value.length() - 4);\n+\n+            //Split the value and unit\n+            int start = value.indexOf(\" \");\n+            if (start < 0) {\n+                throw new RuntimeException(\"Could not find space in between value and unit\");\n+            }\n+            String unit = value.substring(start + 1);\n+            value = value.substring(0, start);\n+            //We support \"a week\", so we need to parse the value as \"a\"\n+            int val = 0;\n+            if (value.equals(\"a\") || value.equals(\"an\")) {\n+                val = 1;\n+            } else {\n+                val = Integer.parseInt(value);\n+            }\n+\n+            //Determine the unit\n+            if (unit.equals(\"milliseconds\") || unit.equals(\"millisecond\")) {\n+                now.add(Calendar.MILLISECOND, -val);\n+            } else if (unit.equals(\"seconds\") || unit.equals(\"second\")) {\n+                now.add(Calendar.SECOND, -val);\n+            } else if (unit.equals(\"minutes\") || unit.equals(\"minute\")) {\n+                now.add(Calendar.MINUTE, -val);\n+            } else if (unit.equals(\"hours\") || unit.equals(\"hour\")) {\n+                now.add(Calendar.HOUR, -val);\n+            } else if (unit.equals(\"days\") || unit.equals(\"day\")) {\n+                now.add(Calendar.DATE, -val);\n+            } else if (unit.equals(\"weeks\") || unit.equals(\"week\")) {\n+                now.add(Calendar.DATE, -val * 7);\n+            } else if (unit.equals(\"fortnights\") || unit.equals(\"fortnight\")) {\n+                now.add(Calendar.DATE, -val * 14);\n+            } else if (unit.equals(\"months\") || unit.equals(\"month\")) {\n+                now.add(Calendar.MONTH, -val);\n+            } else if (unit.equals(\"years\") || unit.equals(\"year\")) {\n+                now.add(Calendar.YEAR, -val);\n+            } else {\n+                throw new RuntimeException(\"We do not understand that many units ago\");\n+            }\n+            return now;\n+        } else if (value.startsWith(\"last \")) {\n+            //If this was the last time a certain field was met\n+            //Strip out the 'last ' part\n+            value = value.substring(5);\n+            //Get the current date/time\n+            String[] strings = symbols.getWeekdays();\n+            for (int i = 0; i < strings.length; i++) {\n+                if (value.equalsIgnoreCase(strings[i])) {\n+                    //How many days after Sunday\n+                    int daysAgo = now.get(Calendar.DAY_OF_WEEK) - i;\n+                    if (daysAgo <= 0) {\n+                        daysAgo += 7;\n+                    }\n+                    now.add(Calendar.DATE, -daysAgo);\n+                    return now;\n+                }\n+            }\n+            strings = symbols.getMonths();\n+            for (int i = 0; i < strings.length; i++) {\n+                if (value.equalsIgnoreCase(strings[i])) {\n+                    //How many days after January\n+                    int monthsAgo = now.get(Calendar.MONTH) - i;\n+                    if (monthsAgo <= 0) {\n+                        monthsAgo += 12;\n+                    }\n+                    now.add(Calendar.MONTH, -monthsAgo);\n+                    return now;\n+                }\n+            }\n+            if (value.equals(\"week\")) {\n+                now.add(Calendar.DATE, -7);\n+                return now;\n+            }\n+        } else if (value.equals(\"yesterday\")) {\n+            now.add(Calendar.DATE, -1);\n+            return now;\n+        } else if (value.equals(\"tomorrow\")) {\n+            now.add(Calendar.DATE, 1);\n+            return now;\n+        }\n+        //Try to parse the date a number of different ways\n+        for (int i = 0; i < dateFormats.length; i++) {\n+            try {\n+                Date datetime = dateFormats[i].parse(original);\n+                Calendar cal = Calendar.getInstance();\n+                cal.setTime(datetime);\n+                return cal;\n+            } catch (ParseException pe) {\n+                //we ignore this and just keep trying\n+            }\n+        }\n+\n+        throw new RuntimeException(\"Unable to parse '\" + original + \"'.\");\n+    }\n+\n+    /**\n+     * This constructs an Iterator that will start and stop over a date\n+     * range based on the focused date and the range style.  For instance,\n+     * passing Thursday, July 4, 2002 and a RANGE_MONTH_SUNDAY will return\n+     * an Iterator that starts with Sunday, June 30, 2002 and ends with\n+     * Saturday, August 3, 2002.\n+     */\n+    public static Iterator getCalendarIterator(Calendar focus, int rangeStyle) {\n+        Calendar start = null;\n+        Calendar end = null;\n+        int startCutoff = Calendar.SUNDAY;\n+        int endCutoff = Calendar.SATURDAY;\n+        switch (rangeStyle) {\n+            case RANGE_MONTH_SUNDAY:\n+            case RANGE_MONTH_MONDAY:\n+                //Set start to the first of the month\n+                start = trunc(focus, Calendar.MONTH);\n+                //Set end to the last of the month\n+                end = (Calendar) start.clone();\n+                end.add(Calendar.MONTH, 1);\n+                end.add(Calendar.DATE, -1);\n+                //Loop start back to the previous sunday or monday\n+                if (rangeStyle == RANGE_MONTH_MONDAY) {\n+                    startCutoff = Calendar.MONDAY;\n+                    endCutoff = Calendar.SUNDAY;\n+                }\n+                break;\n+            case RANGE_WEEK_SUNDAY:\n+            case RANGE_WEEK_MONDAY:\n+            case RANGE_WEEK_RELATIVE:\n+            case RANGE_WEEK_CENTER:\n+                //Set start and end to the current date\n+                start = trunc(focus, Calendar.DATE);\n+                end = trunc(focus, Calendar.DATE);\n+                switch (rangeStyle) {\n+                    case RANGE_WEEK_SUNDAY:\n+                        //already set by default\n+                        break;\n+                    case RANGE_WEEK_MONDAY:\n+                        startCutoff = Calendar.MONDAY;\n+                        endCutoff = Calendar.SUNDAY;\n+                        break;\n+                    case RANGE_WEEK_RELATIVE:\n+                        startCutoff = focus.get(Calendar.DAY_OF_WEEK);\n+                        endCutoff = startCutoff - 1;\n+                        break;\n+                    case RANGE_WEEK_CENTER:\n+                        startCutoff = focus.get(Calendar.DAY_OF_WEEK) - 3;\n+                        endCutoff = focus.get(Calendar.DAY_OF_WEEK) + 3;\n+                        break;\n+                }\n+                break;\n+            default:\n+                throw new RuntimeException(\"The range style \" + rangeStyle + \" is not valid.\");\n+        }\n+        if (startCutoff < Calendar.SUNDAY) {\n+            startCutoff += 7;\n+        }\n+        if (startCutoff > Calendar.SATURDAY) {\n+            startCutoff -= 7;\n+        }\n+        if (endCutoff < Calendar.SUNDAY) {\n+            endCutoff += 7;\n+        }\n+        if (endCutoff > Calendar.SATURDAY) {\n+            endCutoff -= 7;\n+        }\n+        while (start.get(Calendar.DAY_OF_WEEK) != startCutoff) {\n+            start.add(Calendar.DATE, -1);\n+        }\n+        while (end.get(Calendar.DAY_OF_WEEK) != endCutoff) {\n+            end.add(Calendar.DATE, 1);\n+        }\n+        final Calendar startFinal = start;\n+        final Calendar endFinal = end;\n+        Iterator it = new Iterator() {\n+            Calendar spot = null;\n+            {\n+                spot = startFinal;\n+                spot.add(Calendar.DATE, -1);\n+            }\n+\n+            public boolean hasNext() {\n+                return spot.before(endFinal);\n+            }\n+\n+            public Object next() {\n+                if (spot.equals(endFinal)) {\n+                    throw new NoSuchElementException();\n+                }\n+                spot.add(Calendar.DATE, 1);\n+                return spot.clone();\n+            }\n+\n+            public void remove() {\n+                throw new UnsupportedOperationException();\n+            }\n+        };\n+        return it;\n+    }\n+\n+    /**\n+     * See the other getCalendarIterator.  Works with a Date.\n+     */\n+    public static Iterator getCalendarIterator(Date focus, int rangeStyle) {\n+        GregorianCalendar gval = new GregorianCalendar();\n+        gval.setTime(focus);\n+        return getCalendarIterator(gval, rangeStyle);\n+    }\n+\n+    /**\n+     * See the other getCalendarIterator.  Works with an Object, trying\n+     * to use it as a Date or Calendar.\n+     */\n+    public static Iterator getCalendarIterator(Object focus, int rangeStyle) {\n+        if (focus instanceof Date) {\n+            return getCalendarIterator((Date) focus, rangeStyle);\n+        } else if (focus instanceof Calendar) {\n+            return getCalendarIterator((Calendar) focus, rangeStyle);\n+        } else {\n+            throw new ClassCastException(\"Could not iterate based on \" + focus);\n+        }\n+    }\n+\n }\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang/time/DurationFormatUtils.java\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2002-2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.lang.time;\n+\n+/**\n+ * Duration formatting utilites and constants.\n+ *\n+ * @author Apache Ant - DateUtils\n+ * @author <a href=\"mailto:sbailliez@apache.org\">Stephane Bailliez</a>\n+ * @author <a href=\"mailto:stefan.bodewig@epost.de\">Stefan Bodewig</a>\n+ * @author Stephen Colebourne\n+ * @since 2.0\n+ * @version $Id: DurationFormatUtils.java,v 1.1 2003/06/08 23:14:23 scolebourne Exp $\n+ */\n+public final class DurationFormatUtils {\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * DurationFormatUtils instances should NOT be constructed in standard programming.\n+     * <p>\n+     * This constructor is public to permit tools that require a JavaBean instance\n+     * to operate.\n+     */\n+    public DurationFormatUtils() {\n+    }\n+\n+    /**\n+     * Format an elapsed time into a plurialization correct string.\n+     * It is limited only to report elapsed time in minutes and\n+     * seconds and has the following behavior.\n+     * <ul>\n+     * <li>minutes are not displayed when 0. (ie: \"45 seconds\")</li>\n+     * <li>seconds are always displayed in plural form (ie \"0 seconds\" or\n+     * \"10 seconds\") except for 1 (ie \"1 second\")</li>\n+     * </ul>\n+     * \n+     * @param millis  the elapsed time to report in milliseconds\n+     * @return the formatted text in minutes/seconds\n+     */\n+    public static String formatWords(long millis, boolean supressLeadingZeroElements, boolean supressTrailingZeroElements) {\n+        long[] values = new long[4];\n+        values[0] = millis / DateUtils.MILLIS_IN_DAY;\n+        values[1] = (millis / DateUtils.MILLIS_IN_HOUR) % 24;\n+        values[2] = (millis / DateUtils.MILLIS_IN_MINUTE) % 60;\n+        values[3] = (millis / DateUtils.MILLIS_IN_SECOND) % 60;\n+        String[] fieldsOne = {\" day \", \" hour \", \" minute \", \" second\"};\n+        String[] fieldsPlural = {\" days \", \" hours \", \" minutes \", \" seconds\"};\n+        \n+        StringBuffer buf = new StringBuffer(64);\n+        boolean valueOutput = false;\n+        \n+        for (int i = 0; i < 4; i++) {\n+            long value = values[i];\n+            if (value == 0) {\n+                // handle zero\n+                if (valueOutput) {\n+                    if (supressTrailingZeroElements == false) {\n+                        buf.append('0').append(fieldsPlural[i]);\n+                    }\n+                } else {\n+                    if (supressLeadingZeroElements == false) {\n+                        buf.append('0').append(fieldsPlural[i]);\n+                    }\n+                }\n+            } else if (value == 1) {\n+                // one\n+                valueOutput = true;\n+                buf.append('1').append(fieldsOne[i]);\n+            } else {\n+                // other\n+                valueOutput = true;\n+                buf.append(value).append(fieldsPlural[i]);\n+            }\n+        }\n+        \n+        return buf.toString().trim();\n+    }\n+\n+    /**\n+     * <p>Get the time gap as a string.</p>\n+     * \n+     * <p>The format used is ISO8601-like.\n+     * <i>hours</i>:<i>minutes</i>:<i>seconds</i>.<i>milliseconds</i>.</p>\n+     * \n+     * @param millis  the duration to format\n+     * @return the time as a String\n+     */\n+    public static String formatISO(long millis) {\n+        int hours, minutes, seconds, milliseconds;\n+        hours = (int) (millis / DateUtils.MILLIS_IN_HOUR);\n+        millis = millis - (hours * DateUtils.MILLIS_IN_HOUR);\n+        minutes = (int) (millis / DateUtils.MILLIS_IN_MINUTE);\n+        millis = millis - (minutes * DateUtils.MILLIS_IN_MINUTE);\n+        seconds = (int) (millis / DateUtils.MILLIS_IN_SECOND);\n+        millis = millis - (seconds * DateUtils.MILLIS_IN_SECOND);\n+        milliseconds = (int) millis;\n+\n+        StringBuffer buf = new StringBuffer(32);\n+        buf.append(hours);\n+        buf.append(':');\n+        buf.append((char)(minutes / 10 + '0'));\n+        buf.append((char)(minutes % 10 + '0'));\n+        buf.append(':');\n+        buf.append((char)(seconds / 10 + '0'));\n+        buf.append((char)(seconds % 10 + '0'));\n+        buf.append('.');\n+        if (milliseconds < 10) {\n+            buf.append('0').append('0');\n+        } else if (milliseconds < 100) {\n+            buf.append('0');\n+        }\n+        buf.append(milliseconds);\n+        return buf.toString();\n+    }\n+\n+}\n--- a/src/java/org/apache/commons/lang/time/FastDateFormat.java\n+++ b/src/java/org/apache/commons/lang/time/FastDateFormat.java\n  */\n package org.apache.commons.lang.time;\n \n-import java.io.Serializable;\n import java.text.DateFormat;\n import java.text.DateFormatSymbols;\n import java.text.FieldPosition;\n import java.util.TimeZone;\n \n /**\n- * FastDateFormat is similar to {@link java.text.SimpleDateFormat}, but \n- * faster and thread-safe.\n+ * FastDateFormat is a fast and thread-safe version of {@link java.text.SimpleDateFormat}.\n  * <p>\n  * Only formatting is supported, but all patterns are compatible with\n- * SimpleDateFormat.\n+ * SimpleDateFormat (except timezones - see below).\n+ * <p>\n+ * Java 1.4 introduced a new pattern letter, 'Z', to represent time zones in\n+ * RFC822 format (eg. +0800 or -1100). This pattern letter can be used here (on\n+ * all JDK versions).\n+ * <p>\n+ * In addition, the pattern 'ZZ' has been made to represent ISO8601 full format\n+ * time zones (eg. +08:00 or -11:00). This introduces a minor incompatability with\n+ * Java 1.4, but at a gain of useful functionality.\n  * <p>\n  * NOTE: Code originally taken from the open source TreeTrove project.\n  *\n  * @author Gary Gregory\n  * @author Stephen Colebourne\n  * @since 2.0\n- * @version $Id: FastDateFormat.java,v 1.5 2003/05/21 23:39:53 scolebourne Exp $\n+ * @version $Id: FastDateFormat.java,v 1.6 2003/06/08 23:14:23 scolebourne Exp $\n  */\n public class FastDateFormat extends Format {\n+    // A lot of the speed in this class comes from caching, but some comes\n+    // from the special int to StringBuffer conversion.\n+    //\n+    // The following produces a padded 2 digit number:\n+    //   buffer.append((char)(value / 10 + '0'));\n+    //   buffer.append((char)(value % 10 + '0'));\n+    //\n+    // Note that the fastest append to StringBuffer is a single char (used here).\n+    // Note that Integer.toString() is not called, the conversion is simply\n+    // taking the value and adding (mathematically) the ASCII value for '0'.\n+    // So, don't change this code! It works and is vary fast.\n     \n-    /** FULL date or time style */\n+    /** FULL locale dependent date or time style */\n     public static final int FULL = SimpleDateFormat.FULL;\n-    /** LONG date or time style */\n+    /** LONG locale dependent date or time style */\n     public static final int LONG = SimpleDateFormat.LONG;\n-    /** MEDIUM date or time style */\n+    /** MEDIUM locale dependent date or time style */\n     public static final int MEDIUM = SimpleDateFormat.MEDIUM;\n-    /** SHORT date or time style */\n+    /** SHORT locale dependent date or time style */\n     public static final int SHORT = SimpleDateFormat.SHORT;\n     \n     // package scoped as used by inner class\n     static final double LOG_10 = Math.log(10);\n \n     private static String cDefaultPattern;\n-    private static TimeZone cDefaultTimeZone = TimeZone.getDefault();\n \n     private static Map cInstanceCache = new HashMap(7);\n     private static Map cDateInstanceCache = new HashMap(7);\n     private final String mPattern;\n     /** The time zone */\n     private final TimeZone mTimeZone;\n+    /** Whether the time zone overrides any on Calendars */\n+    private final boolean mTimeZoneForced;\n     /** The locale */\n     private final Locale mLocale;\n+    /** Whether the locale overrides the default */\n+    private final boolean mLocaleForced;\n     /** The parsed rules */\n-    private final Rule[] mRules;\n+    private Rule[] mRules;\n     /** The estimated maximum length */\n-    private final int mMaxLengthEstimate;\n+    private int mMaxLengthEstimate;\n \n     //-----------------------------------------------------------------------\n     /**\n      * @param timeZone  optional time zone, overrides time zone of formatted date\n      * @param locale  optional locale, overrides system locale\n      * @return a pattern based date/time formatter\n-     * @throws IllegalArgumentException if pattern is invalid\n+     * @throws IllegalArgumentException if pattern is invalid or null\n      */\n     public static synchronized FastDateFormat getInstance(String pattern, TimeZone timeZone, Locale locale) {\n-        Object key = pattern;\n-        if (timeZone != null) {\n-            key = new Pair(key, timeZone);\n-        }\n-        if (locale != null) {\n-            key = new Pair(key, locale);\n-        }\n-\n-        FastDateFormat format = (FastDateFormat) cInstanceCache.get(key);\n+        FastDateFormat emptyFormat = new FastDateFormat(pattern, timeZone, locale);\n+        FastDateFormat format = (FastDateFormat) cInstanceCache.get(emptyFormat);\n         if (format == null) {\n-            if (locale == null) {\n-                locale = Locale.getDefault();\n-            }\n-\n-            format = new FastDateFormat(pattern, timeZone, locale, new DateFormatSymbols(locale));\n-            cInstanceCache.put(key, format);\n+            format = emptyFormat;\n+            format.init();  // convert shell format into usable one\n+            cInstanceCache.put(format, format);  // this is OK!\n         }\n         return format;\n     }\n         return cDefaultPattern;\n     }\n \n+    // Constructor\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructs a new FastDateFormat.\n+     * \n+     * @param pattern  {@link java.text.SimpleDateFormat} compatible pattern\n+     * @param timeZone  time zone to use, null means use default for Date and\n+     *                  value within for Calendar\n+     * @param locale  locale, null means use system default\n+     * @throws IllegalArgumentException if pattern is invalid or null\n+     */\n+    protected FastDateFormat(String pattern, TimeZone timeZone, Locale locale) {\n+        super();\n+        if (pattern == null) {\n+            throw new IllegalArgumentException(\"The pattern must not be null\");\n+        }\n+        mPattern = pattern;\n+        \n+        mTimeZoneForced = (timeZone != null);\n+        if (timeZone == null) {\n+            timeZone = TimeZone.getDefault();\n+        }\n+        mTimeZone = timeZone;\n+        \n+        mLocaleForced = (locale != null);\n+        if (locale == null) {\n+            locale = Locale.getDefault();\n+        }\n+        mLocale = locale;\n+    }\n+\n+    /**\n+     * Initialise the instance for first use.\n+     */\n+    protected void init() {\n+        List rulesList = parsePattern();\n+        mRules = (Rule[]) rulesList.toArray(new Rule[rulesList.size()]);\n+\n+        int len = 0;\n+        for (int i=mRules.length; --i >= 0; ) {\n+            len += mRules[i].estimateLength();\n+        }\n+\n+        mMaxLengthEstimate = len;\n+    }\n+\n+    // Parse the pattern\n+    //-----------------------------------------------------------------------\n     /**\n      * Returns a list of Rules given a pattern.\n      * \n-     * @param pattern  the pattern to parse\n-     * @param timeZone  the time zone to use\n-     * @param locale  the locale to use\n-     * @param symbols  the symbols to use\n      * @return a List of Rule objects\n      * @throws IllegalArgumentException if pattern is invalid\n      */\n-    private static List parse(String pattern, TimeZone timeZone, Locale locale, DateFormatSymbols symbols) {\n+    protected List parsePattern() {\n+        DateFormatSymbols symbols = new DateFormatSymbols(mLocale);\n         List rules = new ArrayList();\n \n         String[] ERAs = symbols.getEras();\n         String[] shortWeekdays = symbols.getShortWeekdays();\n         String[] AmPmStrings = symbols.getAmPmStrings();\n \n-        int length = pattern.length();\n+        int length = mPattern.length();\n         int[] indexRef = new int[1];\n \n         for (int i = 0; i < length; i++) {\n             indexRef[0] = i;\n-            String token = parseToken(pattern, indexRef);\n+            String token = parseToken(mPattern, indexRef);\n             i = indexRef[0];\n \n             int tokenLen = token.length();\n                 break;\n             case 'y': // year (number)\n                 if (tokenLen >= 4) {\n-                    rule = new UnpaddedNumberField(Calendar.YEAR);\n+                    rule = UnpaddedNumberField.INSTANCE_YEAR;\n                 } else {\n-                    rule = new TwoDigitYearField();\n+                    rule = TwoDigitYearField.INSTANCE;\n                 }\n                 break;\n             case 'M': // month in year (text and number)\n                 } else if (tokenLen == 3) {\n                     rule = new TextField(Calendar.MONTH, shortMonths);\n                 } else if (tokenLen == 2) {\n-                    rule = new TwoDigitMonthField();\n+                    rule = TwoDigitMonthField.INSTANCE;\n                 } else {\n-                    rule = new UnpaddedMonthField();\n+                    rule = UnpaddedMonthField.INSTANCE;\n                 }\n                 break;\n             case 'd': // day in month (number)\n                 break;\n             case 'z': // time zone (text)\n                 if (tokenLen >= 4) {\n-                    rule = new TimeZoneRule(timeZone, locale, TimeZone.LONG);\n+                    rule = new TimeZoneNameRule(mTimeZone, mTimeZoneForced, mLocale, TimeZone.LONG);\n                 } else {\n-                    rule = new TimeZoneRule(timeZone, locale, TimeZone.SHORT);\n+                    rule = new TimeZoneNameRule(mTimeZone, mTimeZoneForced, mLocale, TimeZone.SHORT);\n+                }\n+                break;\n+            case 'Z': // time zone (value)\n+                if (tokenLen == 1) {\n+                    rule = TimeZoneNumberRule.INSTANCE_NO_COLON;\n+                } else {\n+                    rule = TimeZoneNumberRule.INSTANCE_COLON;\n                 }\n                 break;\n             case '\\'': // literal text\n      * @param indexRef  index references\n      * @return parsed token\n      */\n-    private static String parseToken(String pattern, int[] indexRef) {\n+    protected String parseToken(String pattern, int[] indexRef) {\n         StringBuffer buf = new StringBuffer();\n \n         int i = indexRef[0];\n      * @param padding  the padding required\n      * @return a new rule with the correct padding\n      */\n-    private static NumberRule selectNumberRule(int field, int padding) {\n+    protected NumberRule selectNumberRule(int field, int padding) {\n         switch (padding) {\n         case 1:\n             return new UnpaddedNumberField(field);\n         }\n     }\n \n-    //-----------------------------------------------------------------------\n-    /**\n-     * Constructs a new FastDateFormat.\n-     * \n-     * @param pattern  {@link java.text.SimpleDateFormat} compatible pattern\n-     * @param timeZone  optional time zone, overrides time zone of formatted date\n-     * @param locale  optional locale, overrides system locale\n-     * @param symbols  optional date format symbols, overrides symbols for provided locale\n-     * @throws IllegalArgumentException if pattern is invalid\n-     */\n-    private FastDateFormat(String pattern, TimeZone timeZone, Locale locale, DateFormatSymbols symbols) {\n-        if (locale == null) {\n-            locale = Locale.getDefault();\n-        }\n-\n-        mPattern = pattern;\n-        mTimeZone = timeZone;\n-        mLocale = locale;\n-\n-        if (symbols == null) {\n-            symbols = new DateFormatSymbols(locale);\n-        }\n-\n-        List rulesList = parse(pattern, timeZone, locale, symbols);\n-        mRules = (Rule[]) rulesList.toArray(new Rule[rulesList.size()]);\n-\n-        int len = 0;\n-        for (int i=mRules.length; --i >= 0; ) {\n-            len += mRules[i].estimateLength();\n-        }\n-\n-        mMaxLengthEstimate = len;\n-    }\n-\n+    // Format methods\n     //-----------------------------------------------------------------------\n     /**\n      * Format either a Date or a Calendar object.\n      * @return the formatted string\n      */\n     public String format(Date date) {\n-        Calendar c = new GregorianCalendar(cDefaultTimeZone);\n+        Calendar c = new GregorianCalendar(mTimeZone);\n         c.setTime(date);\n-        if (mTimeZone != null) {\n-            c.setTimeZone(mTimeZone);\n-        }\n         return applyRules(c, new StringBuffer(mMaxLengthEstimate)).toString();\n     }\n \n      * @return the specified string buffer\n      */\n     public StringBuffer format(Date date, StringBuffer buf) {\n-        Calendar c = new GregorianCalendar(cDefaultTimeZone);\n+        Calendar c = new GregorianCalendar(mTimeZone);\n         c.setTime(date);\n-        if (mTimeZone != null) {\n-            c.setTimeZone(mTimeZone);\n-        }\n         return applyRules(c, buf);\n     }\n \n      * @return the specified string buffer\n      */\n     public StringBuffer format(Calendar calendar, StringBuffer buf) {\n-        if (mTimeZone != null) {\n-            calendar = (Calendar)calendar.clone();\n+        if (mTimeZoneForced) {\n+            calendar = (Calendar) calendar.clone();\n             calendar.setTimeZone(mTimeZone);\n         }\n         return applyRules(calendar, buf);\n      * @param buf  the buffer to format into\n      * @return the specified string buffer\n      */\n-    private StringBuffer applyRules(Calendar calendar, StringBuffer buf) {\n+    protected StringBuffer applyRules(Calendar calendar, StringBuffer buf) {\n         Rule[] rules = mRules;\n         int len = mRules.length;\n         for (int i = 0; i < len; i++) {\n         return buf;\n     }\n \n+    // Parsing\n     //-----------------------------------------------------------------------\n     /**\n      * Parsing not supported.\n         return null;\n     }\n     \n+    // Accessors\n     //-----------------------------------------------------------------------\n     /**\n      * Gets the pattern used by this formatter.\n     }\n \n     /**\n-     * Gets the time zone used by this formatter, or null if time zone of\n-     * formatted dates is used instead.\n+     * Gets the time zone used by this formatter.\n+     * <p>\n+     * This zone is always used for Date formatting.\n+     * If a Calendar is passed in to be formatted, the time zone on that may\n+     * be used depending on {@link #getTimeZoneOverridesCalendar()}.\n      * \n      * @return the time zone\n      */\n     }\n \n     /**\n+     * Returns true if the time zone of the calendar overrides the time zone\n+     * of the formatter\n+     * \n+     * @return true if time zone of formatter overridden for calendars\n+     */\n+    public boolean getTimeZoneOverridesCalendar() {\n+        return mTimeZoneForced;\n+    }\n+\n+    /**\n      * Gets the locale used by this formatter.\n      * \n      * @return the locale\n         return mMaxLengthEstimate;\n     }\n \n+    // Basics\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Compare two objects for equality.\n+     * \n+     * @param obj  the object to compare to\n+     * @return true if equal\n+     */\n+    public boolean equals(Object obj) {\n+        if (obj instanceof FastDateFormat == false) {\n+            return false;\n+        }\n+        FastDateFormat other = (FastDateFormat) obj;\n+        if (\n+            (mPattern == other.mPattern || mPattern.equals(other.mPattern)) &&\n+            (mTimeZone == other.mTimeZone || mTimeZone.equals(other.mTimeZone)) &&\n+            (mLocale == other.mLocale || mLocale.equals(other.mLocale)) &&\n+            (mTimeZoneForced == other.mTimeZoneForced) &&\n+            (mLocaleForced == other.mLocaleForced)\n+            ) {\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * A suitable hashcode.\n+     * \n+     * @return a hashcode compatable with equals\n+     */\n+    public int hashCode() {\n+        int total = 0;\n+        total += mPattern.hashCode();\n+        total += mTimeZone.hashCode();\n+        total += (mTimeZoneForced ? 1 : 0);\n+        total += mLocale.hashCode();\n+        total += (mLocaleForced ? 1 : 0);\n+        return total;\n+    }\n+\n+    /**\n+     * Gets a debugging string version of this formatter.\n+     * \n+     * @return a debugging string\n+     */\n+    public String toString() {\n+        return \"FastDateFormat[\" + mPattern + \"]\";\n+    }\n+    \n+    // Rules\n     //-----------------------------------------------------------------------\n     /**\n      * Inner class defining a rule.\n      * Inner class to output an unpadded number.\n      */\n     private static class UnpaddedNumberField implements NumberRule {\n+        static final UnpaddedNumberField INSTANCE_YEAR = new UnpaddedNumberField(Calendar.YEAR);\n+        \n         private final int mField;\n \n         UnpaddedNumberField(int field) {\n         public final void appendTo(StringBuffer buffer, int value) {\n             if (value < 10) {\n                 buffer.append((char)(value + '0'));\n-            }\n-            else if (value < 100) {\n+            } else if (value < 100) {\n                 buffer.append((char)(value / 10 + '0'));\n                 buffer.append((char)(value % 10 + '0'));\n-            }\n-            else {\n+            } else {\n                 buffer.append(Integer.toString(value));\n             }\n         }\n      * Inner class to output an unpadded month.\n      */\n     private static class UnpaddedMonthField implements NumberRule {\n+        static final UnpaddedMonthField INSTANCE = new UnpaddedMonthField();\n+        \n         UnpaddedMonthField() {\n         }\n \n         public final void appendTo(StringBuffer buffer, int value) {\n             if (value < 10) {\n                 buffer.append((char)(value + '0'));\n-            }\n-            else {\n+            } else {\n                 buffer.append((char)(value / 10 + '0'));\n                 buffer.append((char)(value % 10 + '0'));\n             }\n                 }\n                 buffer.append((char)(value / 10 + '0'));\n                 buffer.append((char)(value % 10 + '0'));\n-            }\n-            else {\n+            } else {\n                 int digits;\n                 if (value < 1000) {\n                     digits = 3;\n-                }\n-                else {\n+                } else {\n                     digits = (int)(Math.log(value) / LOG_10) + 1;\n                 }\n                 for (int i = mSize; --i >= digits; ) {\n             if (value < 100) {\n                 buffer.append((char)(value / 10 + '0'));\n                 buffer.append((char)(value % 10 + '0'));\n-            }\n-            else {\n+            } else {\n                 buffer.append(Integer.toString(value));\n             }\n         }\n      * Inner class to output a two digit year.\n      */\n     private static class TwoDigitYearField implements NumberRule {\n+        static final TwoDigitYearField INSTANCE = new TwoDigitYearField();\n+        \n         TwoDigitYearField() {\n         }\n \n      * Inner class to output a two digit month.\n      */\n     private static class TwoDigitMonthField implements NumberRule {\n+        static final TwoDigitMonthField INSTANCE = new TwoDigitMonthField();\n+        \n         TwoDigitMonthField() {\n         }\n \n     }\n \n     /**\n-     * Inner class to output a time zone.\n-     */\n-    private static class TimeZoneRule implements Rule {\n+     * Inner class to output a time zone name.\n+     */\n+    private static class TimeZoneNameRule implements Rule {\n         private final TimeZone mTimeZone;\n+        private final boolean mTimeZoneForced;\n         private final Locale mLocale;\n         private final int mStyle;\n         private final String mStandard;\n         private final String mDaylight;\n \n-        TimeZoneRule(TimeZone timeZone, Locale locale, int style) {\n+        TimeZoneNameRule(TimeZone timeZone, boolean timeZoneForced, Locale locale, int style) {\n             mTimeZone = timeZone;\n+            mTimeZoneForced = timeZoneForced;\n             mLocale = locale;\n             mStyle = style;\n \n-            if (timeZone != null) {\n+            if (timeZoneForced) {\n                 mStandard = getTimeZoneDisplay(timeZone, false, style, locale);\n                 mDaylight = getTimeZoneDisplay(timeZone, true, style, locale);\n-            }\n-            else {\n+            } else {\n                 mStandard = null;\n                 mDaylight = null;\n             }\n         }\n \n         public int estimateLength() {\n-            if (mTimeZone != null) {\n+            if (mTimeZoneForced) {\n                 return Math.max(mStandard.length(), mDaylight.length());\n-            }\n-            else if (mStyle == TimeZone.SHORT) {\n+            } else if (mStyle == TimeZone.SHORT) {\n                 return 4;\n-            }\n-            else {\n+            } else {\n                 return 40;\n             }\n         }\n \n         public void appendTo(StringBuffer buffer, Calendar calendar) {\n-            TimeZone timeZone;\n-            if ((timeZone = mTimeZone) != null) {\n-                if (timeZone.useDaylightTime() &&\n-                    calendar.get(Calendar.DST_OFFSET) != 0) {\n-\n+            if (mTimeZoneForced) {\n+                if (mTimeZone.useDaylightTime() && calendar.get(Calendar.DST_OFFSET) != 0) {\n                     buffer.append(mDaylight);\n-                }\n-                else {\n+                } else {\n                     buffer.append(mStandard);\n                 }\n-            }\n-            else {\n-                timeZone = calendar.getTimeZone();\n-                if (timeZone.useDaylightTime() &&\n-                    calendar.get(Calendar.DST_OFFSET) != 0) {\n-\n-                    buffer.append(getTimeZoneDisplay\n-                                  (timeZone, true, mStyle, mLocale));\n+            } else {\n+                TimeZone timeZone = calendar.getTimeZone();\n+                if (timeZone.useDaylightTime() && calendar.get(Calendar.DST_OFFSET) != 0) {\n+                    buffer.append(getTimeZoneDisplay(timeZone, true, mStyle, mLocale));\n+                } else {\n+                    buffer.append(getTimeZoneDisplay(timeZone, false, mStyle, mLocale));\n                 }\n-                else {\n-                    buffer.append(getTimeZoneDisplay\n-                                  (timeZone, false, mStyle, mLocale));\n-                }\n-            }\n-        }\n-    }\n-\n-    // ----------------------------------------------------------------------------------\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Inner class to output a time zone as a number +/-HHMM or +/-HH:MM.\n+     */\n+    private static class TimeZoneNumberRule implements Rule {\n+        static final TimeZoneNumberRule INSTANCE_COLON = new TimeZoneNumberRule(true);\n+        static final TimeZoneNumberRule INSTANCE_NO_COLON = new TimeZoneNumberRule(false);\n+        \n+        final boolean mColon;\n+        \n+        TimeZoneNumberRule(boolean colon) {\n+            mColon = colon;\n+        }\n+\n+        public int estimateLength() {\n+            return 5;\n+        }\n+\n+        public void appendTo(StringBuffer buffer, Calendar calendar) {\n+            int offset = calendar.get(Calendar.ZONE_OFFSET) + calendar.get(Calendar.DST_OFFSET);\n+            \n+            if (offset < 0) {\n+                buffer.append('-');\n+                offset = -offset;\n+            } else {\n+                buffer.append('+');\n+            }\n+            \n+            int hours = offset / (60 * 60 * 1000);\n+            buffer.append((char)(hours / 10 + '0'));\n+            buffer.append((char)(hours % 10 + '0'));\n+            \n+            if (mColon) {\n+                buffer.append(':');\n+            }\n+            \n+            int minutes = offset / (60 * 1000) - 60 * hours;\n+            buffer.append((char)(minutes / 10 + '0'));\n+            buffer.append((char)(minutes % 10 + '0'));\n+        }            \n+    }\n+\n+    // ----------------------------------------------------------------------\n     /**\n      * Inner class that acts as a compound key for time zone names.\n      */\n         }\n     }\n \n-    // ----------------------------------------------------------------------------------\n+    // ----------------------------------------------------------------------\n     /**\n      * Helper class for creating compound objects.  One use for this class is to create a\n      * hashtable key out of multiple objects.\n      */\n-    private static class Pair implements Comparable, Serializable {\n+    private static class Pair {\n         private final Object mObj1;\n         private final Object mObj2;\n \n         public Pair(Object obj1, Object obj2) {\n             mObj1 = obj1;\n             mObj2 = obj2;\n-        }\n-\n-        public int compareTo(Object obj) {\n-            if (this == obj) {\n-                return 0;\n-            }\n-\n-            Pair other = (Pair)obj;\n-\n-            Object a = mObj1;\n-            Object b = other.mObj1;\n-\n-            firstTest: {\n-                if (a == null) {\n-                    if (b != null) {\n-                        return 1;\n-                    }\n-                    // Both a and b are null.\n-                    break firstTest;\n-                }\n-                else {\n-                    if (b == null) {\n-                        return -1;\n-                    }\n-                }\n-\n-                int result = ((Comparable)a).compareTo(b);\n-\n-                if (result != 0) {\n-                    return result;\n-                }\n-            }\n-\n-            a = mObj2;\n-            b = other.mObj2;\n-\n-            if (a == null) {\n-                if (b != null) {\n-                    return 1;\n-                }\n-                // Both a and b are null.\n-                return 0;\n-            }\n-            else {\n-                if (b == null) {\n-                    return -1;\n-                }\n-            }\n-\n-            return ((Comparable)a).compareTo(b);\n         }\n \n         public boolean equals(Object obj) {\n--- a/src/java/org/apache/commons/lang/time/StopWatch.java\n+++ b/src/java/org/apache/commons/lang/time/StopWatch.java\n /* ====================================================================\n  * The Apache Software License, Version 1.1\n  *\n- * Copyright (c) 1999-2003 The Apache Software Foundation.  All rights\n+ * Copyright (c) 2002-2003 The Apache Software Foundation.  All rights\n  * reserved.\n  *\n  * Redistribution and use in source and binary forms, with or without\n  * @author Henri Yandell\n  * @author Stephen Colebourne\n  * @since 2.0\n- * @version $Id: StopWatch.java,v 1.3 2003/05/21 23:37:20 scolebourne Exp $\n+ * @version $Id: StopWatch.java,v 1.4 2003/06/08 23:14:23 scolebourne Exp $\n  */\n public class StopWatch {\n     \n-    private static final int MILLIS_IN_HOUR = 60 * 60 * 1000;\n-    private static final int MILLIS_IN_MINUTE = 60 * 1000;\n-\n     /** The start time */\n     private long startTime = -1;\n     /** The stop time */\n     /**\n      * <p>Gets a summary of the time that the stopwatch recorded as a string.</p>\n      * \n-     * <p>The format used is ISO8601,\n+     * <p>The format used is ISO8601-like,\n      * <i>hours</i>:<i>minutes</i>:<i>seconds</i>.<i>milliseconds</i>.</p>\n      * \n      * @return the time as a String\n      */\n     public String toString() {\n-        return StopWatch.toString(getTime());\n-    }\n-\n-    /**\n-     * <p>Get the time gap as a string.</p>\n-     * \n-     * <p>The format used is ISO8601,\n-     * <i>hours</i>:<i>minutes</i>:<i>seconds</i>.<i>milliseconds</i>.</p>\n-     * \n-     * @return the time as a String\n-     */\n-    public static String toString(long time) {\n-        int hours, minutes, seconds, milliseconds;\n-        hours = (int) (time / MILLIS_IN_HOUR);\n-        time = time - (hours * MILLIS_IN_HOUR);\n-        minutes = (int) (time / MILLIS_IN_MINUTE);\n-        time = time - (minutes * MILLIS_IN_MINUTE);\n-        seconds = (int) (time / 1000);\n-        time = time - (seconds * 1000);\n-        milliseconds = (int) time;\n-\n-        StringBuffer buf = new StringBuffer(32);\n-        buf.append(hours);\n-        buf.append(':');\n-        if (minutes < 10) {\n-            buf.append('0');\n-        }\n-        buf.append(minutes);\n-        buf.append(':');\n-        if (seconds < 10) {\n-            buf.append('0');\n-        }\n-        buf.append(seconds);\n-        buf.append('.');\n-        if (milliseconds < 10) {\n-            buf.append(\"00\");\n-        } else if (milliseconds < 100) {\n-            buf.append('0');\n-        }\n-        buf.append(milliseconds);\n-        return buf.toString();\n+        return DurationFormatUtils.formatISO(getTime());\n     }\n \n }\n--- /dev/null\n+++ b/src/test/org/apache/commons/lang/time/DateFormatUtilsTest.java\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2002-2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.lang.time;\n+\n+import java.util.Calendar;\n+import java.util.TimeZone;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+\n+/**\n+ * TestCase for DateFormatUtils.\n+ *\n+ * @author Apache Ant - DateUtilsTest\n+ * @author <a href=\"mailto:sbailliez@apache.org\">Stephane Bailliez</a>\n+ * @author <a href=\"mailto:stefan.bodewig@epost.de\">Stefan Bodewig</a>\n+ * @author Stephen Colebourne\n+ */\n+public class DateFormatUtilsTest extends TestCase {\n+\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+\n+    public static Test suite() {\n+    \tTestSuite suite = new TestSuite(DateFormatUtilsTest.class);\n+    \tsuite.setName(\"DateFormatUtils Tests\");\n+        return suite;\n+    }\n+\n+    public DateFormatUtilsTest(String s) {\n+        super(s);\n+    }\n+\n+    public void testDateTimeISO(){\n+        TimeZone timeZone = TimeZone.getTimeZone(\"GMT-3\");\n+        Calendar cal = Calendar.getInstance(timeZone);\n+        cal.set(2002,1,23,9,11,12);\n+        String text = DateFormatUtils.format(cal.getTime(), \n+                        DateFormatUtils.ISO_DATETIME_FORMAT.getPattern(), timeZone);\n+        assertEquals(\"2002-02-23T09:11:12\", text);\n+        text = DateFormatUtils.format(cal.getTime().getTime(), \n+                      DateFormatUtils.ISO_DATETIME_FORMAT.getPattern(), timeZone);\n+        assertEquals(\"2002-02-23T09:11:12\", text);\n+        text = DateFormatUtils.ISO_DATETIME_FORMAT.format(cal);\n+        assertEquals(\"2002-02-23T09:11:12\", text);\n+        \n+        text = DateFormatUtils.format(cal.getTime(), \n+                      DateFormatUtils.ISO_DATETIME_TIMEZONE_FORMAT.getPattern(), timeZone);\n+        assertEquals(\"2002-02-23T09:11:12-03:00\", text);\n+        text = DateFormatUtils.format(cal.getTime().getTime(), \n+                      DateFormatUtils.ISO_DATETIME_TIMEZONE_FORMAT.getPattern(), timeZone);\n+        assertEquals(\"2002-02-23T09:11:12-03:00\", text);\n+        text = DateFormatUtils.ISO_DATETIME_TIMEZONE_FORMAT.format(cal);\n+        assertEquals(\"2002-02-23T09:11:12-03:00\", text);\n+    }\n+\n+    public void testDateISO(){\n+        TimeZone timeZone = TimeZone.getTimeZone(\"GMT-3\");\n+        Calendar cal = Calendar.getInstance(timeZone);\n+        cal.set(2002,1,23,10,11,12);\n+        String text = DateFormatUtils.format(cal.getTime(), \n+                        DateFormatUtils.ISO_DATE_FORMAT.getPattern(), timeZone);\n+        assertEquals(\"2002-02-23\", text);\n+        text = DateFormatUtils.format(cal.getTime().getTime(), \n+                        DateFormatUtils.ISO_DATE_FORMAT.getPattern(), timeZone);\n+        assertEquals(\"2002-02-23\", text);\n+        text = DateFormatUtils.ISO_DATE_FORMAT.format(cal);\n+        assertEquals(\"2002-02-23\", text);\n+        \n+        text = DateFormatUtils.format(cal.getTime(), \n+                      DateFormatUtils.ISO_DATE_TIMEZONE_FORMAT.getPattern(), timeZone);\n+        assertEquals(\"2002-02-23-03:00\", text);\n+        text = DateFormatUtils.format(cal.getTime().getTime(), \n+                      DateFormatUtils.ISO_DATE_TIMEZONE_FORMAT.getPattern(), timeZone);\n+        assertEquals(\"2002-02-23-03:00\", text);\n+        text = DateFormatUtils.ISO_DATE_TIMEZONE_FORMAT.format(cal);\n+        assertEquals(\"2002-02-23-03:00\", text);\n+    }\n+\n+    public void testTimeISO(){\n+        TimeZone timeZone = TimeZone.getTimeZone(\"GMT-3\");\n+        Calendar cal = Calendar.getInstance(timeZone);\n+        cal.set(2002,1,23,10,11,12);\n+        String text = DateFormatUtils.format(cal.getTime(), \n+                        DateFormatUtils.ISO_TIME_FORMAT.getPattern(), timeZone);\n+        assertEquals(\"T10:11:12\", text);\n+        text = DateFormatUtils.format(cal.getTime().getTime(), \n+                        DateFormatUtils.ISO_TIME_FORMAT.getPattern(), timeZone);\n+        assertEquals(\"T10:11:12\", text);\n+        text = DateFormatUtils.ISO_TIME_FORMAT.format(cal);\n+        assertEquals(\"T10:11:12\", text);\n+        \n+        text = DateFormatUtils.format(cal.getTime(), \n+                      DateFormatUtils.ISO_TIME_TIMEZONE_FORMAT.getPattern(), timeZone);\n+        assertEquals(\"T10:11:12-03:00\", text);\n+        text = DateFormatUtils.format(cal.getTime().getTime(), \n+                      DateFormatUtils.ISO_TIME_TIMEZONE_FORMAT.getPattern(), timeZone);\n+        assertEquals(\"T10:11:12-03:00\", text);\n+        text = DateFormatUtils.ISO_TIME_TIMEZONE_FORMAT.format(cal);\n+        assertEquals(\"T10:11:12-03:00\", text);\n+    }\n+\n+    public void testTimeNoTISO(){\n+        TimeZone timeZone = TimeZone.getTimeZone(\"GMT-3\");\n+        Calendar cal = Calendar.getInstance(timeZone);\n+        cal.set(2002,1,23,10,11,12);\n+        String text = DateFormatUtils.format(cal.getTime(), \n+                        DateFormatUtils.ISO_TIME_NO_T_FORMAT.getPattern(), timeZone);\n+        assertEquals(\"10:11:12\", text);\n+        text = DateFormatUtils.format(cal.getTime().getTime(), \n+                        DateFormatUtils.ISO_TIME_NO_T_FORMAT.getPattern(), timeZone);\n+        assertEquals(\"10:11:12\", text);\n+        text = DateFormatUtils.ISO_TIME_NO_T_FORMAT.format(cal);\n+        assertEquals(\"10:11:12\", text);\n+        \n+        text = DateFormatUtils.format(cal.getTime(), \n+                      DateFormatUtils.ISO_TIME_NO_T_TIMEZONE_FORMAT.getPattern(), timeZone);\n+        assertEquals(\"10:11:12-03:00\", text);\n+        text = DateFormatUtils.format(cal.getTime().getTime(), \n+                      DateFormatUtils.ISO_TIME_NO_T_TIMEZONE_FORMAT.getPattern(), timeZone);\n+        assertEquals(\"10:11:12-03:00\", text);\n+        text = DateFormatUtils.ISO_TIME_NO_T_TIMEZONE_FORMAT.format(cal);\n+        assertEquals(\"10:11:12-03:00\", text);\n+    }\n+\n+    public void testSMTP(){\n+        TimeZone timeZone = TimeZone.getTimeZone(\"GMT-3\");\n+        Calendar cal = Calendar.getInstance(timeZone);\n+        cal.set(2003,5,8,10,11,12);\n+        String text = DateFormatUtils.format(cal.getTime(), \n+                        DateFormatUtils.SMTP_DATETIME_FORMAT.getPattern(), timeZone);\n+        assertEquals(\"Sun, 08 Jun 2003 10:11:12 -0300\", text);\n+        text = DateFormatUtils.format(cal.getTime().getTime(), \n+                        DateFormatUtils.SMTP_DATETIME_FORMAT.getPattern(), timeZone);\n+        assertEquals(\"Sun, 08 Jun 2003 10:11:12 -0300\", text);\n+        text = DateFormatUtils.SMTP_DATETIME_FORMAT.format(cal);\n+        assertEquals(\"Sun, 08 Jun 2003 10:11:12 -0300\", text);\n+        \n+        // format UTC\n+        text = DateFormatUtils.formatUTC(cal.getTime().getTime(), \n+                        DateFormatUtils.SMTP_DATETIME_FORMAT.getPattern());\n+        assertEquals(\"Sun, 08 Jun 2003 13:11:12 +0000\", text);\n+    }\n+\n+}\n--- a/src/test/org/apache/commons/lang/time/DateUtilsTest.java\n+++ b/src/test/org/apache/commons/lang/time/DateUtilsTest.java\n-/*\n+/* ====================================================================\n  * The Apache Software License, Version 1.1\n  *\n- * Copyright (c) 2002 The Apache Software Foundation.  All rights\n+ * Copyright (c) 2002-2003 The Apache Software Foundation.  All rights\n  * reserved.\n  *\n  * Redistribution and use in source and binary forms, with or without\n  *    Alternately, this acknowlegement may appear in the software itself,\n  *    if and wherever such third-party acknowlegements normally appear.\n  *\n- * 4. The names \"The Jakarta Project\", \"Ant\", and \"Apache Software\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n  *    Foundation\" must not be used to endorse or promote products derived\n  *    from this software without prior written permission. For written\n  *    permission, please contact apache@apache.org.\n  *\n  * 5. Products derived from this software may not be called \"Apache\"\n  *    nor may \"Apache\" appear in their names without prior written\n- *    permission of the Apache Group.\n+ *    permission of the Apache Software Foundation.\n  *\n  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n  */\n package org.apache.commons.lang.time;\n \n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n import java.util.Calendar;\n-import java.util.TimeZone;\n-\n+import java.util.Date;\n+import java.util.Iterator;\n+\n+import junit.framework.AssertionFailedError;\n import junit.framework.Test;\n import junit.framework.TestCase;\n import junit.framework.TestSuite;\n import junit.textui.TestRunner;\n \n /**\n- * TestCase for DateUtils.  [Relies heavily on code taken from the\n- * DateUtilsTest class of the jakarata-ant project.]\n- *\n- * @author <a href=\"mailto:sbailliez@apache.org\">Stephane Bailliez</a>\n- * @author <a href=\"mailto:stefan.bodewig@epost.de\">Stefan Bodewig</a>\n+ * Unit tests {@link org.apache.commons.lang.CalendarUtils}.\n+ *\n+ * @author <a href=\"mailto:sergek@lokitech.com\">Serge Knystautas</a>\n  */\n public class DateUtilsTest extends TestCase {\n+    DateFormat dateParser = null;\n+    DateFormat dateTimeParser = null;\n+    Date date1 = null;\n+    Date date2 = null;\n+\n+    public DateUtilsTest(String name) {\n+        super(name);\n+    }\n \n     public static void main(String[] args) {\n         TestRunner.run(suite());\n \n     public static Test suite() {\n     \tTestSuite suite = new TestSuite(DateUtilsTest.class);\n-    \tsuite.setName(\"DateUtils Tests\");\n+    \tsuite.setName(\"CalendarUtilsTest Tests\");\n         return suite;\n     }\n \n-    public DateUtilsTest(String s) {\n-        super(s);\n-    }\n-\n-    public void testElapsedTime(){\n-        String text = DateUtils.formatElapsedTime(50*1000);\n-        assertEquals(\"50 seconds\", text);\n-        text = DateUtils.formatElapsedTime(65*1000);\n-        assertEquals(\"1 minute 5 seconds\", text);\n-        text = DateUtils.formatElapsedTime(120*1000);\n-        assertEquals(\"2 minutes 0 seconds\", text);\n-        text = DateUtils.formatElapsedTime(121*1000);\n-        assertEquals(\"2 minutes 1 second\", text);\n-    }\n-\n-    public void testDateTimeISO(){\n-        TimeZone timeZone = TimeZone.getTimeZone(\"GMT+1\");\n-        Calendar cal = Calendar.getInstance(timeZone);\n-        cal.set(2002,1,23,10,11,12);\n-        String text = DateUtils.format(cal.getTime(),\n-                DateUtils.ISO8601_DATETIME_PATTERN);\n-        assertEquals(\"2002-02-23T09:11:12\", text);\n-    }\n-\n-    public void testDateISO(){\n-        TimeZone timeZone = TimeZone.getTimeZone(\"GMT\");\n-        Calendar cal = Calendar.getInstance(timeZone);\n-        cal.set(2002,1,23);\n-        String text = DateUtils.format(cal.getTime(),\n-                DateUtils.ISO8601_DATE_PATTERN);\n-        assertEquals(\"2002-02-23\", text);\n-    }\n-\n-    public void testTimeISODate(){\n-        // make sure that elapsed time in set via date works\n-        TimeZone timeZone = TimeZone.getTimeZone(\"GMT+1\");\n-        Calendar cal = Calendar.getInstance(timeZone);\n-        cal.set(2002,1,23, 21, 11, 12);\n-        String text = DateUtils.format(cal.getTime(),\n-                DateUtils.ISO8601_TIME_PATTERN);\n-        assertEquals(\"20:11:12\", text);\n-    }\n-\n-    public void testTimeISO(){\n-        // make sure that elapsed time in ms works\n-        long ms = (20*3600 + 11*60 + 12)*1000;\n-        String text = DateUtils.format(ms,\n-                DateUtils.ISO8601_TIME_PATTERN);\n-        assertEquals(\"20:11:12\", text);\n-    }\n-\n-    public void testPhaseOfMoon() {\n-        TimeZone timeZone = TimeZone.getTimeZone(\"GMT\");\n-        Calendar cal = Calendar.getInstance(timeZone);\n-        // should be full moon\n-        cal.set(2002, 2, 27);\n-        assertEquals(4, DateUtils.getPhaseOfMoon(cal));\n-        // should be new moon\n-        cal.set(2002, 2, 12);\n-        assertEquals(0, DateUtils.getPhaseOfMoon(cal));\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+\n+        dateParser = new SimpleDateFormat(\"MMM dd, yyyy\");\n+        dateTimeParser = new SimpleDateFormat(\"MMM dd, yyyy H:mm:ss.SSS\");\n+\n+        date1 = dateTimeParser.parse(\"February 12, 2002 12:34:56.789\");\n+        date2 = dateTimeParser.parse(\"November 18, 2001 1:23:11.321\");\n+    }\n+\n+    protected void tearDown() throws Exception {\n+        super.tearDown();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+\n+\n+    /**\n+     * Tests various values with the round method\n+     */\n+    public void testRound() throws Exception {\n+        assertEquals(\"round year-1 failed\",\n+                dateParser.parse(\"January 1, 2002\"),\n+                DateUtils.round(date1, Calendar.YEAR));\n+        assertEquals(\"round year-2 failed\",\n+                dateParser.parse(\"January 1, 2002\"),\n+                DateUtils.round(date2, Calendar.YEAR));\n+        assertEquals(\"round month-1 failed\",\n+                dateParser.parse(\"February 1, 2002\"),\n+                DateUtils.round(date1, Calendar.MONTH));\n+        assertEquals(\"round month-2 failed\",\n+                dateParser.parse(\"December 1, 2001\"),\n+                DateUtils.round(date2, Calendar.MONTH));\n+        assertEquals(\"round semimonth-1 failed\",\n+                dateParser.parse(\"February 16, 2002\"),\n+                DateUtils.round(date1, DateUtils.SEMI_MONTH));\n+        assertEquals(\"round semimonth-2 failed\",\n+                dateParser.parse(\"November 16, 2001\"),\n+                DateUtils.round(date2, DateUtils.SEMI_MONTH));\n+        assertEquals(\"round date-1 failed\",\n+                dateParser.parse(\"February 13, 2002\"),\n+                DateUtils.round(date1, Calendar.DATE));\n+        assertEquals(\"round date-2 failed\",\n+                dateParser.parse(\"November 18, 2001\"),\n+                DateUtils.round(date2, Calendar.DATE));\n+        assertEquals(\"round hour-1 failed\",\n+                dateTimeParser.parse(\"February 12, 2002 13:00:00.000\"),\n+                DateUtils.round(date1, Calendar.HOUR));\n+        assertEquals(\"round hour-2 failed\",\n+                dateTimeParser.parse(\"November 18, 2001 1:00:00.000\"),\n+                DateUtils.round(date2, Calendar.HOUR));\n+        assertEquals(\"round minute-1 failed\",\n+                dateTimeParser.parse(\"February 12, 2002 12:35:00.000\"),\n+                DateUtils.round(date1, Calendar.MINUTE));\n+        assertEquals(\"round minute-2 failed\",\n+                dateTimeParser.parse(\"November 18, 2001 1:23:00.000\"),\n+                DateUtils.round(date2, Calendar.MINUTE));\n+        assertEquals(\"round second-1 failed\",\n+                dateTimeParser.parse(\"February 12, 2002 12:34:57.000\"),\n+                DateUtils.round(date1, Calendar.SECOND));\n+        assertEquals(\"round second-2 failed\",\n+                dateTimeParser.parse(\"November 18, 2001 1:23:11.000\"),\n+                DateUtils.round(date2, Calendar.SECOND));\n+    }\n+\n+    /**\n+     * Tests various values with the trunc method\n+     */\n+    public void testTrunc() throws Exception {\n+        assertEquals(\"trunc year-1 failed\",\n+                dateParser.parse(\"January 1, 2002\"),\n+                DateUtils.trunc(date1, Calendar.YEAR));\n+        assertEquals(\"trunc year-2 failed\",\n+                dateParser.parse(\"January 1, 2001\"),\n+                DateUtils.trunc(date2, Calendar.YEAR));\n+        assertEquals(\"trunc month-1 failed\",\n+                dateParser.parse(\"February 1, 2002\"),\n+                DateUtils.trunc(date1, Calendar.MONTH));\n+        assertEquals(\"trunc month-2 failed\",\n+                dateParser.parse(\"November 1, 2001\"),\n+                DateUtils.trunc(date2, Calendar.MONTH));\n+        assertEquals(\"trunc semimonth-1 failed\",\n+                dateParser.parse(\"February 1, 2002\"),\n+                DateUtils.trunc(date1, DateUtils.SEMI_MONTH));\n+        assertEquals(\"trunc semimonth-2 failed\",\n+                dateParser.parse(\"November 16, 2001\"),\n+                DateUtils.trunc(date2, DateUtils.SEMI_MONTH));\n+        assertEquals(\"trunc date-1 failed\",\n+                dateParser.parse(\"February 12, 2002\"),\n+                DateUtils.trunc(date1, Calendar.DATE));\n+        assertEquals(\"trunc date-2 failed\",\n+                dateParser.parse(\"November 18, 2001\"),\n+                DateUtils.trunc(date2, Calendar.DATE));\n+        assertEquals(\"trunc hour-1 failed\",\n+                dateTimeParser.parse(\"February 12, 2002 12:00:00.000\"),\n+                DateUtils.trunc(date1, Calendar.HOUR));\n+        assertEquals(\"trunc hour-2 failed\",\n+                dateTimeParser.parse(\"November 18, 2001 1:00:00.000\"),\n+                DateUtils.trunc(date2, Calendar.HOUR));\n+        assertEquals(\"trunc minute-1 failed\",\n+                dateTimeParser.parse(\"February 12, 2002 12:34:00.000\"),\n+                DateUtils.trunc(date1, Calendar.MINUTE));\n+        assertEquals(\"trunc minute-2 failed\",\n+                dateTimeParser.parse(\"November 18, 2001 1:23:00.000\"),\n+                DateUtils.trunc(date2, Calendar.MINUTE));\n+        assertEquals(\"trunc second-1 failed\",\n+                dateTimeParser.parse(\"February 12, 2002 12:34:56.000\"),\n+                DateUtils.trunc(date1, Calendar.SECOND));\n+        assertEquals(\"trunc second-2 failed\",\n+                dateTimeParser.parse(\"November 18, 2001 1:23:11.000\"),\n+                DateUtils.trunc(date2, Calendar.SECOND));\n+\n+    }\n+\n+    /**\n+     * Tests the parse method, which is supposed to handle various strings\n+     * as flexibly as CVS supports.\n+     */\n+    public void testParse() throws Exception {\n+        //This is difficult to test since the \"now\" used in the\n+        //  parse function cannot be controlled.  We could possibly control\n+        //  it by trying before and after and making sure the value we expect\n+        //  is between the two values calculated.\n+        //For now we're just using the custom assertEquals that takes a delta\n+\n+        Calendar now = null;\n+\n+        now = Calendar.getInstance();\n+        now.add(Calendar.MINUTE, -1);\n+        assertEquals(\"parse 1 minute ago\",\n+                now, DateUtils.parse(\"1 minute ago\"), 50);\n+        now = Calendar.getInstance();\n+        now.add(Calendar.MINUTE, -8);\n+        assertEquals(\"parse 8 minutes ago\",\n+                now, DateUtils.parse(\"8 minutes ago\"), 50);\n+\n+        now = Calendar.getInstance();\n+        now.add(Calendar.DATE, -1);\n+        assertEquals(\"parse yesterday\",\n+                now, DateUtils.parse(\"yesterday\"), 50);\n+\n+        now = Calendar.getInstance();\n+        now.add(Calendar.DATE, 1);\n+        assertEquals(\"parse tomorrow\",\n+                now, DateUtils.parse(\"tomorrow\"), 50);\n+\n+        now = Calendar.getInstance();\n+        //Sunday would be 1, Saturday would be 7, so we walk back up to 6 days.\n+        if (now.get(Calendar.DAY_OF_WEEK) == 1) {\n+            //If Sunday already, we go back a full week\n+            now.add(Calendar.DATE, -7);\n+        } else {\n+            now.add(Calendar.DATE, 1 - now.get(Calendar.DAY_OF_WEEK));\n+        }\n+        assertEquals(\"parse last Sunday\",\n+                now, DateUtils.parse(\"last Sunday\"), 50);\n+\n+        now = Calendar.getInstance();\n+        now.add(Calendar.DATE, -7);\n+        assertEquals(\"parse last week\",\n+                now, DateUtils.parse(\"last week\"), 50);\n+\n+        now = Calendar.getInstance();\n+        //January would be 0, December would be 11, so we walk back up to 11 months\n+        if (now.get(Calendar.MONTH) == 0) {\n+            //If January already, we go back a full year\n+            now.add(Calendar.MONTH, -12);\n+        } else {\n+            now.add(Calendar.MONTH, 0 - now.get(Calendar.MONTH));\n+        }\n+        assertEquals(\"parse last January\",\n+                now, DateUtils.parse(\"last January\"), 50);\n+    }\n+\n+    /**\n+     * Tests the calendar iterator for week ranges\n+     */\n+    public void testWeekIterator() throws Exception {\n+        Calendar now = Calendar.getInstance();\n+        for (int i = 0; i< 7; i++) {\n+            Calendar today = DateUtils.trunc(now, Calendar.DATE);\n+            Calendar sunday = DateUtils.trunc(now, Calendar.DATE);\n+            sunday.add(Calendar.DATE, 1 - sunday.get(Calendar.DAY_OF_WEEK));\n+            Calendar monday = DateUtils.trunc(now, Calendar.DATE);\n+            if (monday.get(Calendar.DAY_OF_WEEK) == 1) {\n+                //This is sunday... roll back 6 days\n+                monday.add(Calendar.DATE, -6);\n+            } else {\n+                monday.add(Calendar.DATE, 2 - monday.get(Calendar.DAY_OF_WEEK));\n+            }\n+            Calendar centered = DateUtils.trunc(now, Calendar.DATE);\n+            centered.add(Calendar.DATE, -3);\n+            \n+            Iterator it = DateUtils.getCalendarIterator(now, DateUtils.RANGE_WEEK_SUNDAY);\n+            assertWeekIterator(it, sunday);\n+            it = DateUtils.getCalendarIterator(now, DateUtils.RANGE_WEEK_MONDAY);\n+            assertWeekIterator(it, monday);\n+            it = DateUtils.getCalendarIterator(now, DateUtils.RANGE_WEEK_RELATIVE);\n+            assertWeekIterator(it, today);\n+            it = DateUtils.getCalendarIterator(now, DateUtils.RANGE_WEEK_CENTER);\n+            assertWeekIterator(it, centered);\n+            now.add(Calendar.DATE,1);\n+        }\n+    }\n+\n+    /**\n+     * Tests the calendar iterator for month-based ranges\n+     */\n+    public void testMonthIterator() throws Exception {\n+        Iterator it = DateUtils.getCalendarIterator(date1, DateUtils.RANGE_MONTH_SUNDAY);\n+        assertWeekIterator(it,\n+                dateParser.parse(\"January 27, 2002\"),\n+                dateParser.parse(\"March 2, 2002\"));\n+\n+        it = DateUtils.getCalendarIterator(date1, DateUtils.RANGE_MONTH_MONDAY);\n+        assertWeekIterator(it,\n+                dateParser.parse(\"January 28, 2002\"),\n+                dateParser.parse(\"March 3, 2002\"));\n+\n+        it = DateUtils.getCalendarIterator(date2, DateUtils.RANGE_MONTH_SUNDAY);\n+        assertWeekIterator(it,\n+                dateParser.parse(\"October 28, 2001\"),\n+                dateParser.parse(\"December 1, 2001\"));\n+\n+        it = DateUtils.getCalendarIterator(date2, DateUtils.RANGE_MONTH_MONDAY);\n+        assertWeekIterator(it,\n+                dateParser.parse(\"October 29, 2001\"),\n+                dateParser.parse(\"December 2, 2001\"));\n+    }\n+\n+    /**\n+     * This checks that this is a 7 element iterator of Calendar objects\n+     * that are dates (no time), and exactly 1 day spaced after each other.\n+     */\n+    private static void assertWeekIterator(Iterator it, Calendar start) {\n+        Calendar end = (Calendar) start.clone();\n+        end.add(Calendar.DATE, 6);\n+\n+        assertWeekIterator(it, start, end);\n+    }\n+\n+    /**\n+     * Convenience method for when working with Date objects\n+     */\n+    private static void assertWeekIterator(Iterator it, Date start, Date end) {\n+        Calendar calStart = Calendar.getInstance();\n+        calStart.setTime(start);\n+        Calendar calEnd = Calendar.getInstance();\n+        calEnd.setTime(end);\n+\n+        assertWeekIterator(it, calStart, calEnd);\n+    }\n+\n+    /**\n+     * This checks that this is a 7 divisble iterator of Calendar objects\n+     * that are dates (no time), and exactly 1 day spaced after each other\n+     * (in addition to the proper start and stop dates)\n+     */\n+    private static void assertWeekIterator(Iterator it, Calendar start, Calendar end) {\n+        Calendar cal = (Calendar) it.next();\n+        assertEquals(\"\", start, cal, 0);\n+        Calendar last = null;\n+        int count = 1;\n+        while (it.hasNext()) {\n+            //Check this is just a date (no time component)\n+            assertEquals(\"\", cal, DateUtils.trunc(cal, Calendar.DATE), 0);\n+\n+            last = cal;\n+            cal = (Calendar) it.next();\n+            count++;\n+\n+            //Check that this is one day more than the last date\n+            last.add(Calendar.DATE, 1);\n+            assertEquals(\"\", last, cal, 0);\n+        }\n+        if (count % 7 != 0) {\n+            throw new AssertionFailedError(\"There were \" + count + \" days in this iterator\");\n+        }\n+        assertEquals(\"\", end, cal, 0);\n+    }\n+\n+    /**\n+     * Used to check that Calendar objects are close enough\n+     * delta is in milliseconds\n+     */\n+    public static void assertEquals(String message, Calendar cal1, Calendar cal2, long delta) {\n+        if (Math.abs(cal1.getTime().getTime() - cal2.getTime().getTime()) > delta) {\n+            throw new AssertionFailedError(\n+                    message + \" expected \" + cal1.getTime() + \" but got \" + cal2.getTime());\n+        }\n     }\n }\n+\n--- /dev/null\n+++ b/src/test/org/apache/commons/lang/time/DurationFormatUtilsTest.java\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2002-2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.lang.time;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+\n+/**\n+ * TestCase for DurationFormatUtils.\n+ *\n+ * @author Apache Ant - DateUtilsTest\n+ * @author <a href=\"mailto:sbailliez@apache.org\">Stephane Bailliez</a>\n+ * @author <a href=\"mailto:stefan.bodewig@epost.de\">Stefan Bodewig</a>\n+ * @author Stephen Colebourne\n+ */\n+public class DurationFormatUtilsTest extends TestCase {\n+\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+\n+    public static Test suite() {\n+    \tTestSuite suite = new TestSuite(DurationFormatUtilsTest.class);\n+    \tsuite.setName(\"DurationFormatUtils Tests\");\n+        return suite;\n+    }\n+\n+    public DurationFormatUtilsTest(String s) {\n+        super(s);\n+    }\n+\n+    public void testFormatWords(){\n+        String text = null;\n+        \n+        text = DurationFormatUtils.formatWords(50*1000, true, false);\n+        assertEquals(\"50 seconds\", text);\n+        text = DurationFormatUtils.formatWords(65*1000, true, false);\n+        assertEquals(\"1 minute 5 seconds\", text);\n+        text = DurationFormatUtils.formatWords(120*1000, true, false);\n+        assertEquals(\"2 minutes 0 seconds\", text);\n+        text = DurationFormatUtils.formatWords(121*1000, true, false);\n+        assertEquals(\"2 minutes 1 second\", text);\n+        text = DurationFormatUtils.formatWords(72*60*1000, true, false);\n+        assertEquals(\"1 hour 12 minutes 0 seconds\", text);\n+        \n+        text = DurationFormatUtils.formatWords(50*1000, true, true);\n+        assertEquals(\"50 seconds\", text);\n+        text = DurationFormatUtils.formatWords(65*1000, true, true);\n+        assertEquals(\"1 minute 5 seconds\", text);\n+        text = DurationFormatUtils.formatWords(120*1000, true, true);\n+        assertEquals(\"2 minutes\", text);\n+        text = DurationFormatUtils.formatWords(121*1000, true, true);\n+        assertEquals(\"2 minutes 1 second\", text);\n+        text = DurationFormatUtils.formatWords(72*60*1000, true, true);\n+        assertEquals(\"1 hour 12 minutes\", text);\n+        \n+        text = DurationFormatUtils.formatWords(50*1000, false, true);\n+        assertEquals(\"0 days 0 hours 0 minutes 50 seconds\", text);\n+        text = DurationFormatUtils.formatWords(65*1000, false, true);\n+        assertEquals(\"0 days 0 hours 1 minute 5 seconds\", text);\n+        text = DurationFormatUtils.formatWords(120*1000, false, true);\n+        assertEquals(\"0 days 0 hours 2 minutes\", text);\n+        text = DurationFormatUtils.formatWords(121*1000, false, true);\n+        assertEquals(\"0 days 0 hours 2 minutes 1 second\", text);\n+        text = DurationFormatUtils.formatWords(72*60*1000, false, true);\n+        assertEquals(\"0 days 1 hour 12 minutes\", text);\n+        \n+        text = DurationFormatUtils.formatWords(50*1000, false, false);\n+        assertEquals(\"0 days 0 hours 0 minutes 50 seconds\", text);\n+        text = DurationFormatUtils.formatWords(65*1000, false, false);\n+        assertEquals(\"0 days 0 hours 1 minute 5 seconds\", text);\n+        text = DurationFormatUtils.formatWords(120*1000, false, false);\n+        assertEquals(\"0 days 0 hours 2 minutes 0 seconds\", text);\n+        text = DurationFormatUtils.formatWords(121*1000, false, false);\n+        assertEquals(\"0 days 0 hours 2 minutes 1 second\", text);\n+        text = DurationFormatUtils.formatWords(72*60*1000, false, false);\n+        assertEquals(\"0 days 1 hour 12 minutes 0 seconds\", text);\n+    }\n+\n+    public void testFormatISOStyle(){\n+        long time = 0;\n+        assertEquals(\"0:00:00.000\", DurationFormatUtils.formatISO(time));\n+        \n+        time = 1;\n+        assertEquals(\"0:00:00.001\", DurationFormatUtils.formatISO(time));\n+        \n+        time = 15;\n+        assertEquals(\"0:00:00.015\", DurationFormatUtils.formatISO(time));\n+        \n+        time = 165;\n+        assertEquals(\"0:00:00.165\", DurationFormatUtils.formatISO(time));\n+        \n+        time = 1675;\n+        assertEquals(\"0:00:01.675\", DurationFormatUtils.formatISO(time));\n+        \n+        time = 13465;\n+        assertEquals(\"0:00:13.465\", DurationFormatUtils.formatISO(time));\n+        \n+        time = 72789;\n+        assertEquals(\"0:01:12.789\", DurationFormatUtils.formatISO(time));\n+        \n+        time = 12789 + 32 * 60000;\n+        assertEquals(\"0:32:12.789\", DurationFormatUtils.formatISO(time));\n+        \n+        time = 12789 + 62 * 60000;\n+        assertEquals(\"1:02:12.789\", DurationFormatUtils.formatISO(time));\n+    }\n+    \n+}\n--- a/src/test/org/apache/commons/lang/time/FastDateFormatTest.java\n+++ b/src/test/org/apache/commons/lang/time/FastDateFormatTest.java\n package org.apache.commons.lang.time;\n \n import java.text.SimpleDateFormat;\n+import java.util.Date;\n+import java.util.GregorianCalendar;\n import java.util.Locale;\n import java.util.TimeZone;\n \n  *\n  * @author Sean Schofield\n  * @since 2.0\n- * @version $Id: FastDateFormatTest.java,v 1.3 2003/05/21 23:41:21 scolebourne Exp $\n+ * @version $Id: FastDateFormatTest.java,v 1.4 2003/06/08 23:14:23 scolebourne Exp $\n  */\n public class FastDateFormatTest extends TestCase {\n \n     public void test_getInstance_String() {\n         FastDateFormat format1 = FastDateFormat.getInstance(\"MM/DD/yyyy\");\n         FastDateFormat format2 = FastDateFormat.getInstance(\"MM-DD-yyyy\");\n+        FastDateFormat format3 = FastDateFormat.getInstance(\"MM-DD-yyyy\");\n+        \n         assertTrue(format1 != format2); // -- junit 3.8 version -- assertFalse(format1 == format2);\n-        assertSame(format1, FastDateFormat.getInstance(\"MM/DD/yyyy\"));\n+        assertSame(format2, format3);\n         assertEquals(\"MM/DD/yyyy\", format1.getPattern());\n+        assertEquals(TimeZone.getDefault(), format1.getTimeZone());\n+        assertEquals(TimeZone.getDefault(), format2.getTimeZone());\n+        assertEquals(false, format1.getTimeZoneOverridesCalendar());\n+        assertEquals(false, format2.getTimeZoneOverridesCalendar());\n     }\n \n     public void test_getInstance_String_TimeZone() {\n             FastDateFormat format3 = FastDateFormat.getInstance(\"MM/DD/yyyy\", TimeZone.getDefault());\n             FastDateFormat format4 = FastDateFormat.getInstance(\"MM/DD/yyyy\", TimeZone.getDefault());\n             FastDateFormat format5 = FastDateFormat.getInstance(\"MM-DD-yyyy\", TimeZone.getDefault());\n+            FastDateFormat format6 = FastDateFormat.getInstance(\"MM-DD-yyyy\");\n     \n             assertTrue(format1 != format2); // -- junit 3.8 version -- assertFalse(format1 == format2);\n-            assertTrue(format1.getTimeZone().equals(TimeZone.getTimeZone(\"Atlantic/Reykjavik\")));\n-            assertNull(format2.getTimeZone());\n+            assertEquals(TimeZone.getTimeZone(\"Atlantic/Reykjavik\"), format1.getTimeZone());\n+            assertEquals(true, format1.getTimeZoneOverridesCalendar());\n+            assertEquals(TimeZone.getDefault(), format2.getTimeZone());\n+            assertEquals(false, format2.getTimeZoneOverridesCalendar());\n             assertSame(format3, format4);\n             assertTrue(format3 != format5); // -- junit 3.8 version -- assertFalse(format3 == format5);\n+            assertTrue(format4 != format6); // -- junit 3.8 version -- assertFalse(format3 == format5);\n             \n         } finally {\n             Locale.setDefault(realDefaultLocale);\n                     TimeZone.getDefault(), Locale.GERMANY);\n     \n             assertTrue(format1 != format2); // -- junit 3.8 version -- assertNotSame(format1, format2);\n-            assertEquals(format1.getTimeZone(), TimeZone.getTimeZone(\"Atlantic/Reykjavik\"));\n-            assertNull(format2.getTimeZone());\n-            assertEquals(format3.getTimeZone(), TimeZone.getDefault());\n-            assertEquals(format3.getTimeZone(), TimeZone.getTimeZone(\"America/New_York\"));\n+            assertEquals(TimeZone.getTimeZone(\"Atlantic/Reykjavik\"), format1.getTimeZone());\n+            assertEquals(TimeZone.getDefault(), format2.getTimeZone());\n+            assertEquals(TimeZone.getDefault(), format3.getTimeZone());\n+            assertEquals(true, format1.getTimeZoneOverridesCalendar());\n+            assertEquals(false, format2.getTimeZoneOverridesCalendar());\n+            assertEquals(true, format3.getTimeZoneOverridesCalendar());\n+            assertEquals(Locale.GERMANY, format1.getLocale());\n+            assertEquals(Locale.GERMANY, format2.getLocale());\n+            assertEquals(Locale.GERMANY, format3.getLocale());\n             \n         } finally {\n             Locale.setDefault(realDefaultLocale);\n         }\n     }\n     \n+    public void testFormat() {\n+        Locale realDefaultLocale = Locale.getDefault();\n+        TimeZone realDefaultZone = TimeZone.getDefault();\n+        try {\n+            Locale.setDefault(Locale.US);\n+            TimeZone.setDefault(TimeZone.getTimeZone(\"America/New_York\"));\n+            FastDateFormat fdf = null;\n+            SimpleDateFormat sdf = null;\n+    \n+            GregorianCalendar cal1 = new GregorianCalendar(2003, 0, 10, 15, 33, 20);\n+            GregorianCalendar cal2 = new GregorianCalendar(2003, 6, 10, 9, 00, 00);\n+            Date date1 = cal1.getTime();\n+            Date date2 = cal2.getTime();\n+            \n+            fdf = FastDateFormat.getInstance(\"yyyy-MM-dd'T'HH:mm:ss\");\n+            sdf = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ss\");\n+            assertEquals(sdf.format(date1), fdf.format(date1));\n+            assertEquals(\"2003-01-10T15:33:20\", fdf.format(date1));\n+            assertEquals(\"2003-01-10T15:33:20\", fdf.format(cal1));\n+            assertEquals(\"2003-07-10T09:00:00\", fdf.format(date2));\n+            assertEquals(\"2003-07-10T09:00:00\", fdf.format(cal2));\n+            \n+            fdf = FastDateFormat.getInstance(\"Z\");\n+            assertEquals(\"-0500\", fdf.format(date1));\n+            assertEquals(\"-0500\", fdf.format(cal1));\n+            \n+            fdf = FastDateFormat.getInstance(\"Z\");\n+            assertEquals(\"-0400\", fdf.format(date2));\n+            assertEquals(\"-0400\", fdf.format(cal2));\n+            \n+            fdf = FastDateFormat.getInstance(\"ZZ\");\n+            assertEquals(\"-05:00\", fdf.format(date1));\n+            assertEquals(\"-05:00\", fdf.format(cal1));\n+\n+            fdf = FastDateFormat.getInstance(\"ZZ\");\n+            assertEquals(\"-04:00\", fdf.format(date2));\n+            assertEquals(\"-04:00\", fdf.format(cal2));\n+            \n+            String pattern = \"GGGG GGG GG G yyyy yyy yy y MMMM MMM MM M\" +\n+                \" dddd ddd dd d DDDD DDD DD D EEEE EEE EE E aaaa aaa aa a zzzz zzz zz z\";\n+            fdf = FastDateFormat.getInstance(pattern);\n+            sdf = new SimpleDateFormat(pattern);\n+            assertEquals(sdf.format(date1), fdf.format(date1));\n+            assertEquals(sdf.format(date2), fdf.format(date2));\n+\n+        } finally {\n+            Locale.setDefault(realDefaultLocale);\n+            TimeZone.setDefault(realDefaultZone);\n+        }\n+    }\n+    \n }\n--- a/src/test/org/apache/commons/lang/time/StopWatchTest.java\n+++ b/src/test/org/apache/commons/lang/time/StopWatchTest.java\n  * TestCase for StopWatch.\n  *\n  * @author Stephen Colebourne\n- * @version $Id: StopWatchTest.java,v 1.2 2003/05/21 23:40:24 scolebourne Exp $\n+ * @version $Id: StopWatchTest.java,v 1.3 2003/06/08 23:14:23 scolebourne Exp $\n  */\n public class StopWatchTest extends TestCase {\n \n         super(s);\n     }\n \n-    public void testToString(){\n-        long time = 0;\n-        assertEquals(\"0:00:00.000\", StopWatch.toString(time));\n-        \n-        time = 1;\n-        assertEquals(\"0:00:00.001\", StopWatch.toString(time));\n-        \n-        time = 15;\n-        assertEquals(\"0:00:00.015\", StopWatch.toString(time));\n-        \n-        time = 165;\n-        assertEquals(\"0:00:00.165\", StopWatch.toString(time));\n-        \n-        time = 1675;\n-        assertEquals(\"0:00:01.675\", StopWatch.toString(time));\n-        \n-        time = 13465;\n-        assertEquals(\"0:00:13.465\", StopWatch.toString(time));\n-        \n-        time = 72789;\n-        assertEquals(\"0:01:12.789\", StopWatch.toString(time));\n-        \n-        time = 12789 + 32 * 60000;\n-        assertEquals(\"0:32:12.789\", StopWatch.toString(time));\n-        \n-        time = 12789 + 62 * 60000;\n-        assertEquals(\"1:02:12.789\", StopWatch.toString(time));\n-    }\n-    \n     public void testStopWatchSimple(){\n         StopWatch watch = new StopWatch();\n         assertEquals(0, watch.getTime());\n--- a/src/test/org/apache/commons/lang/time/TimeTestSuite.java\n+++ b/src/test/org/apache/commons/lang/time/TimeTestSuite.java\n /* ====================================================================\n  * The Apache Software License, Version 1.1\n  *\n- * Copyright (c) 2002 The Apache Software Foundation.  All rights\n+ * Copyright (c) 2002-2003 The Apache Software Foundation.  All rights\n  * reserved.\n  *\n  * Redistribution and use in source and binary forms, with or without\n import junit.framework.TestCase;\n import junit.framework.TestSuite;\n import junit.textui.TestRunner;\n+\n /**\n  * Test suite for the Time package.\n  *\n  * @author Stephen Colebourne\n- * @version $Id: TimeTestSuite.java,v 1.3 2003/01/10 03:55:01 bayard Exp $\n+ * @version $Id: TimeTestSuite.java,v 1.4 2003/06/08 23:14:23 scolebourne Exp $\n  */\n public class TimeTestSuite extends TestCase {\n     \n     public static Test suite() {\n         TestSuite suite = new TestSuite();\n         suite.setName(\"Commons-Lang-Time Tests\");\n-        suite.addTest(CalendarUtilsTest.suite());\n         suite.addTest(DateUtilsTest.suite());\n+        suite.addTest(DateFormatUtilsTest.suite());\n+        suite.addTest(DurationFormatUtilsTest.suite());\n         suite.addTest(StopWatchTest.suite());\n         suite.addTest(FastDateFormatTest.suite());\n         return suite;", "timestamp": 1055114063, "metainfo": ""}