{"sha": "06f474f107d278010dd3c54fae35a1f18ca3afb7", "log": "[Bug 35588] - [lang] New interpolation features. Retro-fits the VariableResolver interface into the VariableFormatter class and provides a Map-backed VariableResolver implementation.  ", "commit": "\n--- a/src/java/org/apache/commons/lang/text/VariableFormatter.java\n+++ b/src/java/org/apache/commons/lang/text/VariableFormatter.java\n  * @since 2.2\n  */\n public class VariableFormatter {\n+\n+    /**\n+     * A VariableResolver backed by a {@link Map}.\n+     * \n+     * @author <a href=\"mailto:ggregory@seagullsw.com\">Gary Gregory</a>\n+     * @version $Id$\n+     */\n+    public static class MapVariableResolver implements VariableResolver {\n+        /**\n+         * Map keys are variable names and value\n+         */\n+        private Map map;\n+\n+        /**\n+         * Creates a new VariableResolver backed by a Map.\n+         * \n+         * @param map\n+         *            The variable names and values.\n+         */\n+        public MapVariableResolver(Map map) {\n+            this.setMap(map);\n+        }\n+\n+        /**\n+         * Gets the variable names and values.\n+         * \n+         * @return the variable names and values.\n+         */\n+        public Map getMap() {\n+            return this.map;\n+        }\n+\n+        /**\n+         * Resolves the given variable name with the backing Map.\n+         * \n+         * @param varName\n+         *            a variable name\n+         * @return a value or <code>null</code> if the variable name is not in Map\n+         */\n+        public Object resolveVariable(String varName) {\n+            if (this.getMap() == null) {\n+                return null;\n+            }\n+            return this.getMap().get(varName);\n+        }\n+\n+        /**\n+         * Gets the variable names and values.\n+         * \n+         * @param map\n+         *            the variable names and values.\n+         */\n+        public void setMap(Map map) {\n+            this.map = map;\n+        }\n+    }\n+\n+    /**\n+     * <p>\n+     * Definition of an interface for obtaining values for variables.\n+     * </p>\n+     * <p>\n+     * Objects implementing this interface can be passed to <code>VariableFormatter</code> as source for variables'\n+     * values. The interface is quite simple and defines only a single method for retrieving the value of a specified\n+     * value.\n+     * </p>\n+     */\n+    public static interface VariableResolver {\n+        /**\n+         * Returns the value of the specified variable. The variable's value can be an arbitrary object. If no variable\n+         * with the given name is known, an implementation should return <b>null</b>.\n+         * \n+         * @param varName\n+         *            the name of the searched variable\n+         * @return the variable's value\n+         */\n+        Object resolveVariable(String varName);\n+    }\n+\n+    /** Constant for the default escape character. */\n+    static final char DEFAULT_ESCAPE = '$';\n+\n     /** Constant for the default variable prefix. */\n     static final String DEFAULT_PREFIX = \"${\";\n \n     /** Constant for the default variable suffix. */\n     static final String DEFAULT_SUFFIX = \"}\";\n \n-    /** Constant for the default escape character. */\n-    static final char DEFAULT_ESCAPE = '$';\n-\n-    /** Stores the map with the variables' values. */\n-    private Map valueMap;\n+    /**\n+     * Replaces the occurrences of all variables in the given source data by their current values obtained from the\n+     * passed in map.\n+     * \n+     * @param valueMap\n+     *            the map with the values\n+     * @param source\n+     *            the source text\n+     * @return the result of the replace operation\n+     */\n+    public static String replace(Map valueMap, Object source) {\n+        return new VariableFormatter(valueMap).replace(source);\n+    }\n+\n+    /**\n+     * Replaces the occurrences of all variables in the given source data by their current values obtained from the\n+     * passed in map. This method allows to specifiy a custom variable prefix and suffix\n+     * \n+     * @param valueMap\n+     *            the map with the values\n+     * @param prefix\n+     *            the prefix of variables\n+     * @param suffix\n+     *            the suffix of variables\n+     * @param source\n+     *            the source text\n+     * @return the result of the replace operation\n+     */\n+    public static String replace(Map valueMap, String prefix, String suffix, Object source) {\n+        return new VariableFormatter(valueMap, prefix, suffix).replace(source);\n+    }\n+\n+    /**\n+     * Replaces all variables in the given source data with values obtained from system properties.\n+     * \n+     * @param source\n+     *            the source text\n+     * @return the result of the replace operation\n+     */\n+    public static String replaceSystemProperties(Object source) {\n+        return new VariableFormatter(System.getProperties()).replace(source);\n+    }\n+\n+    /** Stores the escape character. */\n+    private char escapeCharacter;\n \n     /** Stores the variable prefix. */\n     private String variablePrefix;\n \n+    private VariableResolver variableResolver;\n+\n     /** Stores the variable suffix. */\n     private String variableSuffix;\n \n-    /** Stores the escape character. */\n-    private char escapeCharacter;\n+    /**\n+     * Creates a new instance of <code>VariableFormat</code> and initializes it. Uses defaults for variable prefix and\n+     * suffix and the escaping character.\n+     * \n+     * @param valueMap\n+     *            the map with the variables' values\n+     * @throws IllegalArgumentException\n+     *             if the map is undefined\n+     */\n+    public VariableFormatter(Map valueMap) {\n+        this(valueMap, DEFAULT_PREFIX, DEFAULT_SUFFIX, DEFAULT_ESCAPE);\n+    }\n+\n+    /**\n+     * Creates a new instance of <code>VariableFormat</code> and initializes it. Uses a default escaping character.\n+     * \n+     * @param valueMap\n+     *            the map with the variables' values\n+     * @param prefix\n+     *            the prefix for variables\n+     * @param suffix\n+     *            the suffix for variables\n+     * @throws IllegalArgumentException\n+     *             if the map is undefined\n+     */\n+    public VariableFormatter(Map valueMap, String prefix, String suffix) {\n+        this(valueMap, prefix, suffix, DEFAULT_ESCAPE);\n+    }\n \n     /**\n      * Creates a new instance of <code>VariableFormat</code> and initializes it.\n      *             if the map is undefined\n      */\n     public VariableFormatter(Map valueMap, String prefix, String suffix, char escape) {\n-        setValueMap(valueMap);\n-        setVariablePrefix(prefix);\n-        setVariableSuffix(suffix);\n-        setEscapeCharacter(escape);\n-    }\n-\n-    /**\n-     * Creates a new instance of <code>VariableFormat</code> and initializes it.\n-     * Uses a default escaping character.\n-     * \n-     * @param valueMap\n-     *            the map with the variables' values\n-     * @param prefix\n-     *            the prefix for variables\n-     * @param suffix\n-     *            the suffix for variables\n-     * @throws IllegalArgumentException\n-     *             if the map is undefined\n-     */\n-    public VariableFormatter(Map valueMap, String prefix, String suffix) {\n-        this(valueMap, prefix, suffix, DEFAULT_ESCAPE);\n-    }\n-\n-    /**\n-     * Creates a new instance of <code>VariableFormat</code> and initializes it.\n-     * Uses defaults for variable prefix and suffix and the escaping character.\n-     * \n-     * @param valueMap\n-     *            the map with the variables' values\n-     * @throws IllegalArgumentException\n-     *             if the map is undefined\n-     */\n-    public VariableFormatter(Map valueMap) {\n-        this(valueMap, DEFAULT_PREFIX, DEFAULT_SUFFIX, DEFAULT_ESCAPE);\n-    }\n-\n-    /**\n-     * Returns the escape character.\n-     * \n-     * @return the character used for escaping variable references\n-     */\n-    public char getEscapeCharacter() {\n-        return this.escapeCharacter;\n-    }\n-\n-    /**\n-     * Sets the escape character. If this character is placed before a\n-     * variable reference in the source text, this variable will be ignored.\n-     * \n-     * @param escapeCharacter\n-     *            the escape character (0 for disabling escaping)\n-     */\n-    public void setEscapeCharacter(char escapeCharacter) {\n-        this.escapeCharacter = escapeCharacter;\n-    }\n-\n-    /**\n-     * Returns the map with the variables' values.\n-     * \n-     * @return the values of the variables\n-     */\n-    public Map getValueMap() {\n-        return this.valueMap;\n-    }\n-\n-    /**\n-     * Sets the map with the variables' values.\n-     * \n-     * @param valueMap\n-     *            the values of the variables\n-     * @throws IllegalArgumentException\n-     *             if <code>valueMap</code> is <b>null</b>\n-     */\n-    public void setValueMap(Map valueMap) throws IllegalArgumentException {\n-        if (valueMap == null) {\n-            throw new IllegalArgumentException(\"Value map must not be null\");\n-        }\n-        this.valueMap = valueMap;\n-    }\n-\n-    /**\n-     * Returns the prefix for variables.\n-     * \n-     * @return the prefix for variables\n-     */\n-    public String getVariablePrefix() {\n-        return this.variablePrefix;\n-    }\n-\n-    /**\n-     * Sets the prefix for variables.\n-     * \n-     * @param variablePrefix\n-     *            the prefix for variables\n-     * @throws IllegalArgumentException\n-     *             if the prefix is <b>null</b>\n-     */\n-    public void setVariablePrefix(String variablePrefix) throws IllegalArgumentException {\n-        if (variablePrefix == null) {\n-            throw new IllegalArgumentException(\"Variable prefix must not be null!\");\n-        }\n-        this.variablePrefix = variablePrefix;\n-    }\n-\n-    /**\n-     * Returns the suffix for variables.\n-     * \n-     * @return the suffix for variables\n-     */\n-    public String getVariableSuffix() {\n-        return this.variableSuffix;\n-    }\n-\n-    /**\n-     * Sets the suffix for variables\n-     * \n-     * @param variableSuffix\n-     *            the suffix for variables\n-     * @throws IllegalArgumentException\n-     *             if the prefix is <b>null</b>\n-     */\n-    public void setVariableSuffix(String variableSuffix) throws IllegalArgumentException {\n-        if (variableSuffix == null) {\n-            throw new IllegalArgumentException(\"Variable suffix must not be null!\");\n-        }\n-        this.variableSuffix = variableSuffix;\n-    }\n-\n-    /**\n-     * Replaces the occurrences of all variables in the given source data by\n-     * their current values. If the source consists only of a single variable\n-     * reference, this method directly returns the value of this variable\n-     * (which can be an arbitrary object). If the source contains multiple\n-     * variable references or static text, the return value will always be a\n-     * String with the concatenation of all these elements.\n-     * \n-     * @param source\n-     *            the text to be interpolated; this can be an arbitrary object whose <code>toString()</code> method\n-     *            will be called\n-     * @return the result of the replace operation\n-     */\n-    public Object replaceObject(Object source) {\n-        return doReplace(source, null);\n-    }\n-\n-    /**\n-     * Replaces the occurrences of all variables in the given source data by\n-     * their current values.\n-     * \n-     * @param source\n-     *            the text to be interpolated; this can be an arbitrary object whose <code>toString()</code> method\n-     *            will be called\n-     * @return the result of the replace operation\n-     */\n-    public String replace(Object source) {\n-        Object result = replaceObject(source);\n-        return result == null ? null : result.toString();\n-    }\n-\n-    /**\n-     * Replaces the occurrences of all variables in the given source data by\n-     * their current values obtained from the passed in map.\n-     * \n-     * @param valueMap\n-     *            the map with the values\n-     * @param source\n-     *            the source text\n-     * @return the result of the replace operation\n-     */\n-    public static String replace(Map valueMap, Object source) {\n-        return new VariableFormatter(valueMap).replace(source);\n-    }\n-\n-    /**\n-     * Replaces the occurrences of all variables in the given source data by\n-     * their current values obtained from the passed in map. This method\n-     * allows to specifiy a custom variable prefix and suffix\n-     * \n-     * @param valueMap\n-     *            the map with the values\n-     * @param prefix\n-     *            the prefix of variables\n-     * @param suffix\n-     *            the suffix of variables\n-     * @param source\n-     *            the source text\n-     * @return the result of the replace operation\n-     */\n-    public static String replace(Map valueMap, String prefix, String suffix, Object source) {\n-        return new VariableFormatter(valueMap, prefix, suffix).replace(source);\n-    }\n-\n-    /**\n-     * Replaces all variables in the given source data with values obtained\n-     * from system properties.\n-     * \n-     * @param source\n-     *            the source text\n-     * @return the result of the replace operation\n-     */\n-    public static String replaceSystemProperties(Object source) {\n-        return new VariableFormatter(System.getProperties()).replace(source);\n-    }\n-\n-    /**\n-     * Checks if the variable reference found at the specified position is\n-     * escaped and if this is the case, where the escaped text starts.\n-     * \n-     * @param text\n-     *            the text to be processed\n-     * @param beginIndex\n-     *            the start index of the variable reference to check\n-     * @return the starting index of the escaped text or -1 if this reference is not escaped\n-     */\n-    protected int escaped(String text, int beginIndex) {\n-        if (beginIndex < 1 || text.charAt(beginIndex - 1) != getEscapeCharacter()) {\n-            return -1;\n-        }\n-        int idx = beginIndex - 2;\n-        while (idx >= 0 && text.charAt(idx) == getEscapeCharacter()) {\n-            idx--;\n-        }\n-        return idx + 1;\n-    }\n-\n-    /**\n-     * Unescapes an escaped variable reference. This method is called if\n-     * <code>escaped()</code> has determined an escaped variable reference.\n-     * Its purpose is to remove any escaping characters and to add the\n-     * resulting text into the target buffer. This implementation will remove\n-     * the first escape character. So if the default values are used,\n-     * a text portion of <code>$${myvar}</code> will become <code>${myvar}</code>,\n-     * <code>$$$${var with dollars}</code> will result in <code>$$${var with\n-     * dollars}</code>. Text between the first variable start token and the last\n-     * unescaped variable end token can contain variable references and will be\n-     * recursively replaced. So constructs of the following form can be built:\n-     * <code>Variable $${${varName$}} is incorrect!</code> (note how the first\n-     * &quot;}&quot; character is escaped, so that the second &quot;}&quot;\n-     * marks the end of this construct.\n-     * \n-     * @param buf\n-     *            the target buffer\n-     * @param text\n-     *            the text to be processed\n-     * @param beginIndex\n-     *            the begin index of the escaped variable reference\n-     * @param endIndex\n-     *            the end index of the escaped variable reference\n-     * @param priorVariables\n-     *            keeps track of the replaced variables\n-     */\n-    protected void unescape(StringBuffer buf, String text, int beginIndex, int endIndex, List priorVariables) {\n-        int startToken = text.indexOf(getVariablePrefix(), beginIndex);\n-        buf.append(text.substring(beginIndex + 1, startToken));\n-        buf.append(getVariablePrefix());\n-        String escapedContent = text.substring(startToken + getVariablePrefix().length(), endIndex);\n-        buf.append(doReplace(StringUtils.replace(escapedContent, String.valueOf(getEscapeCharacter())\n-            + getVariableSuffix(), getVariableSuffix()), priorVariables));\n-    }\n-\n-    /**\n-     * Searches for a variable end token in the given string from the\n-     * specified start position.\n-     * \n-     * @param text\n-     *            the text to search\n-     * @param beginIndex\n-     *            the start index\n-     * @return the index of the end token or -1 if none was found\n-     */\n-    protected int findEndToken(String text, int beginIndex) {\n-        int pos = beginIndex - getVariableSuffix().length();\n-\n-        do {\n-            pos = text.indexOf(getVariableSuffix(), pos + getVariableSuffix().length());\n-        } while (pos > 0 && getEscapeCharacter() == text.charAt(pos - 1));\n-\n-        return pos;\n-    }\n-\n-    /**\n-     * Resolves the specified variable. This method is called whenever a\n-     * variable reference is detected in the source text. It is passed the\n-     * variable's name and must return the corresponding value.\n-     * This implementation accesses the value map using the variable's name\n-     * as key. Derived classes may override this method to implement a different\n-     * strategy for resolving variables.\n-     * \n-     * @param name\n-     *            the name of the variable\n-     * @return the variable's value or <b>null</b> if the variable is unknown\n-     */\n-    protected Object resolveVariable(String name) {\n-        return getValueMap().get(name);\n-    }\n-\n-    /**\n-     * Recursive handler for multple levels of interpolation. This is the main\n-     * interpolation method, which resolves the values of all variable\n-     * references contained in the passed in text.\n+        this.setVariableResolver(new MapVariableResolver(valueMap));\n+        this.setVariablePrefix(prefix);\n+        this.setVariableSuffix(suffix);\n+        this.setEscapeCharacter(escape);\n+    }\n+\n+    /**\n+     * Recursive handler for multple levels of interpolation. This is the main interpolation method, which resolves the\n+     * values of all variable references contained in the passed in text.\n      * \n      * @param base\n      *            string with the ${key} variables\n         return (objResult != null && objLen > 0 && objLen == result.length()) ? objResult : result.toString();\n     }\n \n+    /**\n+     * Checks if the variable reference found at the specified position is escaped and if this is the case, where the\n+     * escaped text starts.\n+     * \n+     * @param text\n+     *            the text to be processed\n+     * @param beginIndex\n+     *            the start index of the variable reference to check\n+     * @return the starting index of the escaped text or -1 if this reference is not escaped\n+     */\n+    protected int escaped(String text, int beginIndex) {\n+        if (beginIndex < 1 || text.charAt(beginIndex - 1) != getEscapeCharacter()) {\n+            return -1;\n+        }\n+        int idx = beginIndex - 2;\n+        while (idx >= 0 && text.charAt(idx) == getEscapeCharacter()) {\n+            idx--;\n+        }\n+        return idx + 1;\n+    }\n+\n+    /**\n+     * Searches for a variable end token in the given string from the specified start position.\n+     * \n+     * @param text\n+     *            the text to search\n+     * @param beginIndex\n+     *            the start index\n+     * @return the index of the end token or -1 if none was found\n+     */\n+    protected int findEndToken(String text, int beginIndex) {\n+        int pos = beginIndex - getVariableSuffix().length();\n+\n+        do {\n+            pos = text.indexOf(getVariableSuffix(), pos + getVariableSuffix().length());\n+        } while (pos > 0 && getEscapeCharacter() == text.charAt(pos - 1));\n+\n+        return pos;\n+    }\n+\n+    /**\n+     * Returns the escape character.\n+     * \n+     * @return the character used for escaping variable references\n+     */\n+    public char getEscapeCharacter() {\n+        return this.escapeCharacter;\n+    }\n+\n+    /**\n+     * Returns the prefix for variables.\n+     * \n+     * @return the prefix for variables\n+     */\n+    public String getVariablePrefix() {\n+        return this.variablePrefix;\n+    }\n+\n+    public VariableResolver getVariableResolver() {\n+        return this.variableResolver;\n+    }\n+\n+    /**\n+     * Returns the suffix for variables.\n+     * \n+     * @return the suffix for variables\n+     */\n+    public String getVariableSuffix() {\n+        return this.variableSuffix;\n+    }\n+\n+    /**\n+     * Replaces the occurrences of all variables in the given source data by their current values.\n+     * \n+     * @param source\n+     *            the text to be interpolated; this can be an arbitrary object whose <code>toString()</code> method\n+     *            will be called\n+     * @return the result of the replace operation\n+     */\n+    public String replace(Object source) {\n+        Object result = replaceObject(source);\n+        return result == null ? null : result.toString();\n+    }\n+\n+    /**\n+     * Replaces the occurrences of all variables in the given source data by their current values. If the source\n+     * consists only of a single variable reference, this method directly returns the value of this variable (which can\n+     * be an arbitrary object). If the source contains multiple variable references or static text, the return value\n+     * will always be a String with the concatenation of all these elements.\n+     * \n+     * @param source\n+     *            the text to be interpolated; this can be an arbitrary object whose <code>toString()</code> method\n+     *            will be called\n+     * @return the result of the replace operation\n+     */\n+    public Object replaceObject(Object source) {\n+        return doReplace(source, null);\n+    }\n+\n+    /**\n+     * Resolves the specified variable. This method is called whenever a variable reference is detected in the source\n+     * text. It is passed the variable's name and must return the corresponding value. This implementation accesses the\n+     * value map using the variable's name as key. Derived classes may override this method to implement a different\n+     * strategy for resolving variables.\n+     * \n+     * @param name\n+     *            the name of the variable\n+     * @return the variable's value or <b>null</b> if the variable is unknown\n+     */\n+    protected Object resolveVariable(String name) {\n+        if (this.getVariableResolver() == null) {\n+            return null;\n+        }\n+        return this.getVariableResolver().resolveVariable(name);\n+    }\n+\n+    /**\n+     * Sets the escape character. If this character is placed before a variable reference in the source text, this\n+     * variable will be ignored.\n+     * \n+     * @param escapeCharacter\n+     *            the escape character (0 for disabling escaping)\n+     */\n+    public void setEscapeCharacter(char escapeCharacter) {\n+        this.escapeCharacter = escapeCharacter;\n+    }\n+\n+    /**\n+     * Sets the prefix for variables.\n+     * \n+     * @param variablePrefix\n+     *            the prefix for variables\n+     * @throws IllegalArgumentException\n+     *             if the prefix is <b>null</b>\n+     */\n+    public void setVariablePrefix(String variablePrefix) throws IllegalArgumentException {\n+        if (variablePrefix == null) {\n+            throw new IllegalArgumentException(\"Variable prefix must not be null!\");\n+        }\n+        this.variablePrefix = variablePrefix;\n+    }\n+\n+    public void setVariableResolver(VariableResolver variableResolver) {\n+        this.variableResolver = variableResolver;\n+    }\n+\n+    /**\n+     * Sets the suffix for variables\n+     * \n+     * @param variableSuffix\n+     *            the suffix for variables\n+     * @throws IllegalArgumentException\n+     *             if the prefix is <b>null</b>\n+     */\n+    public void setVariableSuffix(String variableSuffix) throws IllegalArgumentException {\n+        if (variableSuffix == null) {\n+            throw new IllegalArgumentException(\"Variable suffix must not be null!\");\n+        }\n+        this.variableSuffix = variableSuffix;\n+    }\n+\n+    /**\n+     * Unescapes an escaped variable reference. This method is called if <code>escaped()</code> has determined an\n+     * escaped variable reference. Its purpose is to remove any escaping characters and to add the resulting text into\n+     * the target buffer. This implementation will remove the first escape character. So if the default values are used,\n+     * a text portion of <code>$${myvar}</code> will become <code>${myvar}</code>,\n+     * <code>$$$${var with dollars}</code> will result in <code>$$${var with\n+     * dollars}</code>. Text between the\n+     * first variable start token and the last unescaped variable end token can contain variable references and will be\n+     * recursively replaced. So constructs of the following form can be built:\n+     * <code>Variable $${${varName$}} is incorrect!</code> (note how the first &quot;}&quot; character is escaped, so\n+     * that the second &quot;}&quot; marks the end of this construct.\n+     * \n+     * @param buf\n+     *            the target buffer\n+     * @param text\n+     *            the text to be processed\n+     * @param beginIndex\n+     *            the begin index of the escaped variable reference\n+     * @param endIndex\n+     *            the end index of the escaped variable reference\n+     * @param priorVariables\n+     *            keeps track of the replaced variables\n+     */\n+    protected void unescape(StringBuffer buf, String text, int beginIndex, int endIndex, List priorVariables) {\n+        int startToken = text.indexOf(getVariablePrefix(), beginIndex);\n+        buf.append(text.substring(beginIndex + 1, startToken));\n+        buf.append(getVariablePrefix());\n+        String escapedContent = text.substring(startToken + getVariablePrefix().length(), endIndex);\n+        buf.append(doReplace(StringUtils.replace(escapedContent, String.valueOf(getEscapeCharacter())\n+            + getVariableSuffix(), getVariableSuffix()), priorVariables));\n+    }\n+\n }\n--- a/src/test/org/apache/commons/lang/text/VariableFormatterTest.java\n+++ b/src/test/org/apache/commons/lang/text/VariableFormatterTest.java\n \n import junit.framework.TestCase;\n \n+import org.apache.commons.lang.text.VariableFormatter.MapVariableResolver;\n+\n /**\n  * Test class for VariableFormatter.\n  * \n     private VariableFormatter format;\n \n     private Map values;\n+\n+    VariableFormatter getFormat() {\n+        return this.format;\n+    }\n+\n+    MapVariableResolver getMapVariableResolver() {\n+        return (MapVariableResolver)this.getFormat().getVariableResolver();\n+    }\n+\n+    private Map getValueMap() {\n+        return this.getMapVariableResolver().getMap();\n+    }\n+\n+    Map getValues() {\n+        return this.values;\n+    }\n+\n+    void setFormat(VariableFormatter format) {\n+        this.format = format;\n+    }\n \n     protected void setUp() throws Exception {\n         super.setUp();\n         setFormat(new VariableFormatter(map));\n     }\n \n-    /**\n-     * Tests creating new <code>VariableFormat</code> objects.\n-     */\n-    public void testInitialize() {\n-        assertNotNull(format.getValueMap());\n-        assertEquals(VariableFormatter.DEFAULT_PREFIX, format.getVariablePrefix());\n-        assertEquals(VariableFormatter.DEFAULT_SUFFIX, format.getVariableSuffix());\n-        assertEquals(VariableFormatter.DEFAULT_ESCAPE, format.getEscapeCharacter());\n-\n-        format = new VariableFormatter(values, \"<<\", \">>\", '\\\\');\n-        assertEquals(\"<<\", format.getVariablePrefix());\n-        assertEquals(\">>\", format.getVariableSuffix());\n-        assertEquals('\\\\', format.getEscapeCharacter());\n-\n+    private void setValueMap(Map valuesMap) {\n+        this.getMapVariableResolver().setMap(valuesMap);\n+    }\n+\n+    void setValues(Map values) {\n+        this.values = values;\n+    }\n+\n+    /**\n+     * Tests a cyclic replace operation. The cycle should be detected and cause an exception to be thrown.\n+     */\n+    public void testCyclicReplacement() {\n+        Map valuesMap = new HashMap();\n+        valuesMap.put(\"animal\", \"${critter}\");\n+        valuesMap.put(\"target\", \"${pet}\");\n+        valuesMap.put(\"pet\", \"${petCharacteristic} dog\");\n+        valuesMap.put(\"petCharacteristic\", \"lazy\");\n+        valuesMap.put(\"critter\", \"${critterSpeed} ${critterColor} ${critterType}\");\n+        valuesMap.put(\"critterSpeed\", \"quick\");\n+        valuesMap.put(\"critterColor\", \"brown\");\n+        valuesMap.put(\"critterType\", \"${animal}\");\n+        this.setValueMap(valuesMap);\n         try {\n-            format = new VariableFormatter(null);\n-            fail(\"Could create format object with null map!\");\n-        } catch (IllegalArgumentException iex) {\n+            this.getFormat().replace(REPLACE_TEMPLATE);\n+            fail(\"Cyclic replacement was not detected!\");\n+        } catch (IllegalStateException isx) {\n             // ok\n         }\n+    }\n+\n+    /**\n+     * Tests escaping variable references.\n+     */\n+    public void testEscape() {\n+        assertEquals(\"${animal}\", this.getFormat().replace(\"$${animal}\"));\n+        this.getValueMap().put(\"var_name\", \"x\");\n+        assertEquals(\"Many $$$$${target} $s\", this.getFormat().replace(\"Many $$$$$${target} $s\"));\n+        assertEquals(\"Variable ${x} must be used!\", this.getFormat().replace(\"Variable $${${var_name$}} must be used!\"));\n+    }\n+\n+    /**\n+     * Tests creating new <code>VariableFormat</code> objects.\n+     */\n+    public void testInitialize() {\n+        assertNotNull(this.getFormat().getVariableResolver());\n+        assertEquals(VariableFormatter.DEFAULT_PREFIX, this.getFormat().getVariablePrefix());\n+        assertEquals(VariableFormatter.DEFAULT_SUFFIX, this.getFormat().getVariableSuffix());\n+        assertEquals(VariableFormatter.DEFAULT_ESCAPE, this.getFormat().getEscapeCharacter());\n+\n+        format = new VariableFormatter(values, \"<<\", \">>\", '\\\\');\n+        assertEquals(\"<<\", this.getFormat().getVariablePrefix());\n+        assertEquals(\">>\", this.getFormat().getVariableSuffix());\n+        assertEquals('\\\\', this.getFormat().getEscapeCharacter());\n+\n+// new VariableFormatter(null) should be OK IMO\n+// Gary Gregory - July 14 2005        \n+//        try {\n+//            format = new VariableFormatter(null);\n+//            fail(\"Could create format object with null map!\");\n+//        } catch (IllegalArgumentException iex) {\n+//            // ok\n+//        }\n \n         try {\n             format = new VariableFormatter(values, \"${\", null);\n     }\n \n     /**\n-     * Tests typical replace operations.\n-     */\n-    public void testReplace() {\n-        assertEquals(\"The quick brown fox jumps over the lazy dog.\", format.replaceObject(REPLACE_TEMPLATE));\n-\n-        format.getValueMap().put(\"animal\", \"cow\");\n-        format.getValueMap().put(\"target\", \"moon\");\n-        assertEquals(\"The cow jumps over the moon.\", format.replace(REPLACE_TEMPLATE));\n-\n-        assertEquals(\"Variable ${var} is unknown!\", format.replace(\"Variable ${var} is unknown!\"));\n-    }\n-\n-    /**\n-     * Tests source texts with nothing to replace.\n-     */\n-    public void testReplaceNothing() {\n-        assertNull(format.replace(null));\n-        assertEquals(\"Nothing to replace.\", format.replace(\"Nothing to replace.\"));\n-        assertEquals(\"42\", format.replace(new Integer(42)));\n-    }\n-\n-    /**\n-     * Tests escaping variable references.\n-     */\n-    public void testEscape() {\n-        assertEquals(\"${animal}\", format.replace(\"$${animal}\"));\n-        format.getValueMap().put(\"var_name\", \"x\");\n-        assertEquals(\"Many $$$$${target} $s\", format.replace(\"Many $$$$$${target} $s\"));\n-        assertEquals(\"Variable ${x} must be used!\", format.replace(\"Variable $${${var_name$}} must be used!\"));\n+     * Tests chaning variable prefix and suffix and the escaping character.\n+     */\n+    public void testNonDefaultTokens() {\n+        format = new VariableFormatter(values, \"<<\", \">>\", '\\\\');\n+        assertEquals(\"The quick brown fox jumps over the lazy dog.\", format\n+                .replace(\"The <<animal>> jumps over the <<target>>.\"));\n+        assertEquals(\"The quick brown fox jumps over the <<target>>.\", format\n+                .replace(\"The <<animal>> jumps over the \\\\<<target>>.\"));\n+    }\n+\n+    /**\n+     * Tests invoking the static convenience methods.\n+     */\n+    public void testNonInstanceMethods() {\n+        assertEquals(\"The quick brown fox jumps over the lazy dog.\", VariableFormatter.replace(values, REPLACE_TEMPLATE));\n+        values.put(\"animal\", \"cow\");\n+        values.put(\"target\", \"moon\");\n+        assertEquals(\"The cow jumps over the moon.\", VariableFormatter.replace(values, \"&\", \";\",\n+                \"The &animal; jumps over the &target;.\"));\n     }\n \n     /**\n         valuesMap.put(\"critterSpeed\", \"quick\");\n         valuesMap.put(\"critterColor\", \"brown\");\n         valuesMap.put(\"critterType\", \"fox\");\n-        format.setValueMap(valuesMap);\n-        assertEquals(\"The quick brown fox jumps over the lazy dog.\", format.replace(REPLACE_TEMPLATE));\n-    }\n-\n-    /**\n-     * Tests a cyclic replace operation. The cycle should be detected and cause an exception to be thrown.\n-     */\n-    public void testCyclicReplacement() {\n-        Map valuesMap = new HashMap();\n-        valuesMap.put(\"animal\", \"${critter}\");\n-        valuesMap.put(\"target\", \"${pet}\");\n-        valuesMap.put(\"pet\", \"${petCharacteristic} dog\");\n-        valuesMap.put(\"petCharacteristic\", \"lazy\");\n-        valuesMap.put(\"critter\", \"${critterSpeed} ${critterColor} ${critterType}\");\n-        valuesMap.put(\"critterSpeed\", \"quick\");\n-        valuesMap.put(\"critterColor\", \"brown\");\n-        valuesMap.put(\"critterType\", \"${animal}\");\n-        format.setValueMap(valuesMap);\n-        try {\n-            format.replace(REPLACE_TEMPLATE);\n-            fail(\"Cyclic replacement was not detected!\");\n-        } catch (IllegalStateException isx) {\n-            // ok\n-        }\n+        this.setValueMap(valuesMap);\n+        assertEquals(\"The quick brown fox jumps over the lazy dog.\", this.getFormat().replace(REPLACE_TEMPLATE));\n+    }\n+\n+    /**\n+     * Tests typical replace operations.\n+     */\n+    public void testReplace() {\n+        assertEquals(\"The quick brown fox jumps over the lazy dog.\", this.getFormat().replaceObject(REPLACE_TEMPLATE));\n+        Map map = this.getValueMap();\n+        map.put(\"animal\", \"cow\");\n+        map.put(\"target\", \"moon\");\n+        assertEquals(\"The cow jumps over the moon.\", this.getFormat().replace(REPLACE_TEMPLATE));\n+\n+        assertEquals(\"Variable ${var} is unknown!\", this.getFormat().replace(\"Variable ${var} is unknown!\"));\n+    }\n+\n+    /**\n+     * Tests source texts with nothing to replace.\n+     */\n+    public void testReplaceNothing() {\n+        assertNull(this.getFormat().replace(null));\n+        assertEquals(\"Nothing to replace.\", this.getFormat().replace(\"Nothing to replace.\"));\n+        assertEquals(\"42\", this.getFormat().replace(new Integer(42)));\n     }\n \n     /**\n      * Tests operating on objects.\n      */\n     public void testReplaceObject() {\n-        format.getValueMap().put(\"value\", new Integer(42));\n-        assertEquals(new Integer(42), format.replaceObject(\"${value}\"));\n-        assertEquals(\"The answer is 42.\", format.replaceObject(\"The answer is ${value}.\"));\n-    }\n-\n-    /**\n-     * Tests chaning variable prefix and suffix and the escaping character.\n-     */\n-    public void testNonDefaultTokens() {\n-        format = new VariableFormatter(values, \"<<\", \">>\", '\\\\');\n-        assertEquals(\"The quick brown fox jumps over the lazy dog.\", format\n-                .replace(\"The <<animal>> jumps over the <<target>>.\"));\n-        assertEquals(\"The quick brown fox jumps over the <<target>>.\", format\n-                .replace(\"The <<animal>> jumps over the \\\\<<target>>.\"));\n-    }\n-\n-    /**\n-     * Tests invoking the static convenience methods.\n-     */\n-    public void testNonInstanceMethods() {\n-        assertEquals(\"The quick brown fox jumps over the lazy dog.\", VariableFormatter.replace(values, REPLACE_TEMPLATE));\n-        values.put(\"animal\", \"cow\");\n-        values.put(\"target\", \"moon\");\n-        assertEquals(\"The cow jumps over the moon.\", VariableFormatter.replace(values, \"&\", \";\",\n-                \"The &animal; jumps over the &target;.\"));\n+        this.getValueMap().put(\"value\", new Integer(42));\n+        assertEquals(new Integer(42), this.getFormat().replaceObject(\"${value}\"));\n+        assertEquals(\"The answer is 42.\", this.getFormat().replaceObject(\"The answer is ${value}.\"));\n     }\n \n     /**\n             + \"working with ${os.name}, your home \"\n             + \"directory is ${user.home}.\"));\n     }\n-\n-    Map getValues() {\n-        return this.values;\n-    }\n-\n-    void setValues(Map values) {\n-        this.values = values;\n-    }\n-\n-    VariableFormatter getFormat() {\n-        return this.format;\n-    }\n-\n-    void setFormat(VariableFormatter format) {\n-        this.format = format;\n-    }\n }", "timestamp": 1121368907, "metainfo": ""}