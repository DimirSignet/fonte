{"sha": "add5f4371ed7106e02c40ed7d8a54c9057015916", "log": "Copying from Collections to Lang  ", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/lang3/compare/ComparatorChain.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.comparators;\n+\n+import java.io.Serializable;\n+import java.util.ArrayList;\n+import java.util.BitSet;\n+import java.util.Comparator;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+/**\n+ * <p>A ComparatorChain is a Comparator that wraps one or\n+ * more Comparators in sequence.  The ComparatorChain\n+ * calls each Comparator in sequence until either 1)\n+ * any single Comparator returns a non-zero result\n+ * (and that result is then returned),\n+ * or 2) the ComparatorChain is exhausted (and zero is\n+ * returned).  This type of sorting is very similar\n+ * to multi-column sorting in SQL, and this class\n+ * allows Java classes to emulate that kind of behaviour\n+ * when sorting a List.</p>\n+ *\n+ * <p>To further facilitate SQL-like sorting, the order of\n+ * any single Comparator in the list can be reversed.</p>\n+ *\n+ * <p>Calling a method that adds new Comparators or\n+ * changes the ascend/descend sort <i>after compare(Object,\n+ * Object) has been called</i> will result in an\n+ * UnsupportedOperationException.  However, <i>take care</i>\n+ * to not alter the underlying List of Comparators\n+ * or the BitSet that defines the sort order.</p>\n+ *\n+ * <p>Instances of ComparatorChain are not synchronized.\n+ * The class is not thread-safe at construction time, but\n+ * it <i>is</i> thread-safe to perform multiple comparisons\n+ * after all the setup operations are complete.</p>\n+ *\n+ * @since Commons Collections 2.0\n+ * @author Morgan Delagrange\n+ * @version $Revision$ $Date$\n+ */\n+public class ComparatorChain<E> implements Comparator<E>, Serializable {\n+\n+    /** Serialization version from Collections 2.0. */\n+    private static final long serialVersionUID = -721644942746081630L;\n+\n+    /** The list of comparators in the chain. */\n+    protected List<Comparator<E>> comparatorChain = null;\n+    /** Order - false (clear) = ascend; true (set) = descend. */\n+    protected BitSet orderingBits = null;\n+   /** Whether the chain has been \"locked\". */\n+    protected boolean isLocked = false;\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Construct a ComparatorChain with no Comparators.\n+     * You must add at least one Comparator before calling\n+     * the compare(Object,Object) method, or an\n+     * UnsupportedOperationException is thrown\n+     */\n+    public ComparatorChain() {\n+        this(new ArrayList<Comparator<E>>(), new BitSet());\n+    }\n+\n+    /**\n+     * Construct a ComparatorChain with a single Comparator,\n+     * sorting in the forward order\n+     *\n+     * @param comparator First comparator in the Comparator chain\n+     */\n+    public ComparatorChain(Comparator<E> comparator) {\n+        this(comparator, false);\n+    }\n+\n+    /**\n+     * Construct a Comparator chain with a single Comparator,\n+     * sorting in the given order\n+     *\n+     * @param comparator First Comparator in the ComparatorChain\n+     * @param reverse    false = forward sort; true = reverse sort\n+     */\n+    public ComparatorChain(Comparator<E> comparator, boolean reverse) {\n+        comparatorChain = new ArrayList<Comparator<E>>(1);\n+        comparatorChain.add(comparator);\n+        orderingBits = new BitSet(1);\n+        if (reverse == true) {\n+            orderingBits.set(0);\n+        }\n+    }\n+\n+    /**\n+     * Construct a ComparatorChain from the Comparators in the\n+     * List.  All Comparators will default to the forward\n+     * sort order.\n+     *\n+     * @param list   List of Comparators\n+     * @see #ComparatorChain(List,BitSet)\n+     */\n+    public ComparatorChain(List<Comparator<E>> list) {\n+        this(list, new BitSet(list.size()));\n+    }\n+\n+    /**\n+     * Construct a ComparatorChain from the Comparators in the\n+     * given List.  The sort order of each column will be\n+     * drawn from the given BitSet.  When determining the sort\n+     * order for Comparator at index <i>i</i> in the List,\n+     * the ComparatorChain will call BitSet.get(<i>i</i>).\n+     * If that method returns <i>false</i>, the forward\n+     * sort order is used; a return value of <i>true</i>\n+     * indicates reverse sort order.\n+     *\n+     * @param list   List of Comparators.  NOTE: This constructor does not perform a\n+     *               defensive copy of the list\n+     * @param bits   Sort order for each Comparator.  Extra bits are ignored,\n+     *               unless extra Comparators are added by another method.\n+     */\n+    public ComparatorChain(List<Comparator<E>> list, BitSet bits) {\n+        comparatorChain = list;\n+        orderingBits = bits;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Add a Comparator to the end of the chain using the\n+     * forward sort order\n+     *\n+     * @param comparator Comparator with the forward sort order\n+     */\n+    public void addComparator(Comparator<E> comparator) {\n+        addComparator(comparator, false);\n+    }\n+\n+    /**\n+     * Add a Comparator to the end of the chain using the\n+     * given sort order\n+     *\n+     * @param comparator Comparator to add to the end of the chain\n+     * @param reverse    false = forward sort order; true = reverse sort order\n+     */\n+    public void addComparator(Comparator<E> comparator, boolean reverse) {\n+        checkLocked();\n+\n+        comparatorChain.add(comparator);\n+        if (reverse == true) {\n+            orderingBits.set(comparatorChain.size() - 1);\n+        }\n+    }\n+\n+    /**\n+     * Replace the Comparator at the given index, maintaining\n+     * the existing sort order.\n+     *\n+     * @param index      index of the Comparator to replace\n+     * @param comparator Comparator to place at the given index\n+     * @exception IndexOutOfBoundsException\n+     *                   if index &lt; 0 or index &gt;= size()\n+     */\n+    public void setComparator(int index, Comparator<E> comparator) throws IndexOutOfBoundsException {\n+        setComparator(index, comparator, false);\n+    }\n+\n+    /**\n+     * Replace the Comparator at the given index in the\n+     * ComparatorChain, using the given sort order\n+     *\n+     * @param index      index of the Comparator to replace\n+     * @param comparator Comparator to set\n+     * @param reverse    false = forward sort order; true = reverse sort order\n+     */\n+    public void setComparator(int index, Comparator<E> comparator, boolean reverse) {\n+        checkLocked();\n+\n+        comparatorChain.set(index,comparator);\n+        if (reverse == true) {\n+            orderingBits.set(index);\n+        } else {\n+            orderingBits.clear(index);\n+        }\n+    }\n+\n+    /**\n+     * Change the sort order at the given index in the\n+     * ComparatorChain to a forward sort.\n+     *\n+     * @param index  Index of the ComparatorChain\n+     */\n+    public void setForwardSort(int index) {\n+        checkLocked();\n+        orderingBits.clear(index);\n+    }\n+\n+    /**\n+     * Change the sort order at the given index in the\n+     * ComparatorChain to a reverse sort.\n+     *\n+     * @param index  Index of the ComparatorChain\n+     */\n+    public void setReverseSort(int index) {\n+        checkLocked();\n+        orderingBits.set(index);\n+    }\n+\n+    /**\n+     * Number of Comparators in the current ComparatorChain.\n+     *\n+     * @return Comparator count\n+     */\n+    public int size() {\n+        return comparatorChain.size();\n+    }\n+\n+    /**\n+     * Determine if modifications can still be made to the\n+     * ComparatorChain.  ComparatorChains cannot be modified\n+     * once they have performed a comparison.\n+     *\n+     * @return true = ComparatorChain cannot be modified; false =\n+     *         ComparatorChain can still be modified.\n+     */\n+    public boolean isLocked() {\n+        return isLocked;\n+    }\n+\n+    // throw an exception if the ComparatorChain is locked\n+    private void checkLocked() {\n+        if (isLocked == true) {\n+            throw new UnsupportedOperationException(\"Comparator ordering cannot be changed after the first comparison is performed\");\n+        }\n+    }\n+\n+    private void checkChainIntegrity() {\n+        if (comparatorChain.size() == 0) {\n+            throw new UnsupportedOperationException(\"ComparatorChains must contain at least one Comparator\");\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Perform comparisons on the Objects as per\n+     * Comparator.compare(o1,o2).\n+     *\n+     * @param o1  the first object to compare\n+     * @param o2  the second object to compare\n+     * @return -1, 0, or 1\n+     * @exception UnsupportedOperationException\n+     *                   if the ComparatorChain does not contain at least one\n+     *                   Comparator\n+     */\n+    public int compare(E o1, E o2) throws UnsupportedOperationException {\n+        if (isLocked == false) {\n+            checkChainIntegrity();\n+            isLocked = true;\n+        }\n+\n+        // iterate over all comparators in the chain\n+        Iterator<Comparator<E>> comparators = comparatorChain.iterator();\n+        for (int comparatorIndex = 0; comparators.hasNext(); ++comparatorIndex) {\n+\n+            Comparator<E> comparator = comparators.next();\n+            int retval = comparator.compare(o1,o2);\n+            if (retval != 0) {\n+                // invert the order if it is a reverse sort\n+                if (orderingBits.get(comparatorIndex) == true) {\n+                    if(Integer.MIN_VALUE == retval) {\n+                        retval = Integer.MAX_VALUE;\n+                    } else {\n+                        retval *= -1;\n+                    }\n+                }\n+                return retval;\n+            }\n+        }\n+\n+        // if comparators are exhausted, return 0\n+        return 0;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Implement a hash code for this comparator that is consistent with\n+     * {@link #equals(Object) equals}.\n+     *\n+     * @return a suitable hash code\n+     * @since Commons Collections 3.0\n+     */\n+    @Override\n+    public int hashCode() {\n+        int hash = 0;\n+        if (null != comparatorChain) {\n+            hash ^= comparatorChain.hashCode();\n+        }\n+        if (null != orderingBits) {\n+            hash ^= orderingBits.hashCode();\n+        }\n+        return hash;\n+    }\n+\n+    /**\n+     * Returns <code>true</code> iff <i>that</i> Object is\n+     * is a {@link Comparator} whose ordering is known to be\n+     * equivalent to mine.\n+     * <p>\n+     * This implementation returns <code>true</code>\n+     * iff <code><i>object</i>.{@link Object#getClass() getClass()}</code>\n+     * equals <code>this.getClass()</code>, and the underlying\n+     * comparators and order bits are equal.\n+     * Subclasses may want to override this behavior to remain consistent\n+     * with the {@link Comparator#equals(Object)} contract.\n+     *\n+     * @param object  the object to compare with\n+     * @return true if equal\n+     * @since Commons Collections 3.0\n+     */\n+    @Override\n+    public boolean equals(Object object) {\n+        if (this == object) {\n+            return true;\n+        }\n+        if (null == object) {\n+            return false;\n+        }\n+        if (object.getClass().equals(this.getClass())) {\n+            ComparatorChain<?> chain = (ComparatorChain<?>) object;\n+            return ((null == orderingBits ? null == chain.orderingBits : orderingBits\n+                    .equals(chain.orderingBits)) && (null == comparatorChain ? null == chain.comparatorChain\n+                    : comparatorChain.equals(chain.comparatorChain)));\n+        }\n+        return false;\n+    }\n+\n+}", "timestamp": 1312780247, "metainfo": ""}