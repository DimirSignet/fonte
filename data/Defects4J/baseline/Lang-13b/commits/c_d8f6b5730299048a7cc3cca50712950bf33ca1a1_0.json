{"sha": "d8f6b5730299048a7cc3cca50712950bf33ca1a1", "log": "Bug #19756 dealt with.  Submitted by:\tPhil Steitz   ", "commit": "\n--- a/src/java/org/apache/commons/lang/math/JVMRandom.java\n+++ b/src/java/org/apache/commons/lang/math/JVMRandom.java\n  * \n  * @author Henri Yandell\n  * @since 2.0\n- * @version $Id: JVMRandom.java,v 1.4 2003/05/12 04:41:40 bayard Exp $\n+ * @version $Id: JVMRandom.java,v 1.5 2003/05/14 02:41:26 bayard Exp $\n  */\n public final class JVMRandom extends Random {\n \n-    // important to not call super() as this will \n-    // call setSeed with the current Time\n+    /** ensures that only the constructor can call reseed */\n+    private boolean constructed = false;\n+\n     public JVMRandom() {\n+        this.constructed = true;\n     }\n     \n     public synchronized void setSeed(long seed) {\n-        throw new UnsupportedOperationException();\n+        if (this.constructed) {\n+            throw new UnsupportedOperationException();\n+        }\n     }\n \n     public synchronized double nextGaussian() {\n--- a/src/test/org/apache/commons/lang/math/MathTestSuite.java\n+++ b/src/test/org/apache/commons/lang/math/MathTestSuite.java\n  * Test suite for the Math package.\n  *\n  * @author Stephen Colebourne\n- * @version $Id: MathTestSuite.java,v 1.2 2002/12/22 19:39:39 scolebourne Exp $\n+ * @version $Id: MathTestSuite.java,v 1.3 2003/05/14 02:41:26 bayard Exp $\n  */\n public class MathTestSuite extends TestCase {\n     \n         suite.addTest(IntRangeTest.suite());\n         suite.addTest(LongRangeTest.suite());\n         suite.addTest(NumberRangeTest.suite());\n+        suite.addTest(RandomUtilsTest.suite());\n         return suite;\n     }\n }\n--- /dev/null\n+++ b/src/test/org/apache/commons/lang/math/RandomUtilsTest.java\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2002-2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.lang.math;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import java.util.Random;\n+\n+/**\n+ * Test cases for the {@link RandomUtils} class.\n+ *\n+ * @author <a href=\"mailto:phil@steitz.com\">Phil Steitz</a>\n+ * @version $Revision: 1.1 $ $Date: 2003/05/14 02:41:26 $\n+ */\n+\n+public final class RandomUtilsTest extends TestCase {\n+\n+    public RandomUtilsTest(String name) {\n+        super(name);\n+    }\n+    \n+    public void setUp() {\n+    }\n+    \n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(RandomUtilsTest.class);\n+        suite.setName(\"RandomUtils Tests\");\n+        return suite;\n+    }\n+    \n+    /** test distribution of nextInt() */\n+    public void testNextInt() {\n+        tstNextInt(null);\n+    }\n+    \n+    /** test distribution of nextInt(Random) */\n+    public void testNextInt2() {\n+        Random rnd = new Random();\n+        rnd.setSeed(System.currentTimeMillis());\n+        tstNextInt(rnd);\n+    } \n+    \n+    /** \n+     * Generate 1000 values for nextInt(bound) and compare\n+     * the observed frequency counts to expected counts using\n+     * a chi-square test.\n+     * @param rnd Random to use if not null\n+     */\n+    private void tstNextInt(Random rnd) {\n+        int bound = 0;\n+        int result = 0;\n+        // test boundary condition: n = Integer.MAX_VALUE;\n+        bound = Integer.MAX_VALUE;\n+        if (rnd == null) {\n+            result = RandomUtils.nextInt(bound);\n+        } else {\n+            result = RandomUtils.nextInt(rnd,bound);\n+        }      \n+        assertTrue(\"result less than bound\",result < bound);\n+        assertTrue(\"result non-negative\",result >= 0);\n+        \n+        // test uniformity -- use Chi-Square test at .01 level\n+        bound = 4;\n+        int[] expected = new int[] {250,250,250,250};\n+        int[] observed = new int[] {0,0,0,0};\n+        for (int i = 0; i < 1000; i ++) {\n+            if (rnd == null) {\n+                result = RandomUtils.nextInt(bound);\n+            } else {\n+                result = RandomUtils.nextInt(rnd,bound);\n+            }     \n+            assertTrue(result < bound);\n+            assertTrue(result >= 0);\n+            observed[result]++;\n+        } \n+        /* Use ChiSquare dist with df = 4-1 = 3, alpha = .01\n+         * Change to 16.27 for alpha = .001\n+         */\n+        assertTrue(\n+            \"chi-square test -- will fail about 1 in 100 times\",\n+            chiSquare(expected,observed) < 11.34);                                                            \n+    }  \n+    \n+    /** test distribution of nextLong() */\n+    public void testNextLong() {\n+        tstNextLong(null);\n+    }\n+    \n+    /** test distribution of nextLong(Random) BROKEN\n+     *  contract of nextLong(Random) is different from\n+     * nextLong() */\n+    public void testNextLong2() {\n+        Random rnd = new Random();\n+        rnd.setSeed(System.currentTimeMillis());\n+        tstNextLong(rnd);\n+    }\n+     \n+    /** \n+     * Generate 1000 values for nextLong and check that\n+     * p(value < long.MAXVALUE/2) ~ 0.5. Use chi-square test\n+     * with df = 2-1 = 1  \n+     * @param rnd Random to use if not null\n+     */\n+    private void tstNextLong(Random rnd) {\n+        int[] expected = new int[] {500,500};\n+        int[] observed = new int[] {0,0};\n+        long result = 0;\n+        long midPoint = Long.MAX_VALUE/2;\n+        for (int i = 0; i < 1000; i ++) {\n+            if (rnd == null) {\n+                result = Math.abs(RandomUtils.nextLong());\n+            } else {\n+                result = Math.abs(RandomUtils.nextLong(rnd));\n+            }  \n+            if (result < midPoint) {\n+                observed[0]++;\n+            } else {\n+                observed[1]++;\n+            }\n+        }\n+        /* Use ChiSquare dist with df = 2-1 = 1, alpha = .01\n+         * Change to 10.83 for alpha = .001 \n+         */ \n+        assertTrue(\n+            \"chi-square test -- will fail about 1 in 100 times\",\n+            chiSquare(expected,observed) < 6.64); \n+    }\n+        \n+    \n+    /** test distribution of nextBoolean() */\n+    public void testNextBoolean() {\n+        tstNextBoolean(null);\n+    }\n+    \n+    /** test distribution of nextBoolean(Random) */\n+    public void testNextBoolean2() {\n+        Random rnd = new Random();\n+        rnd.setSeed(System.currentTimeMillis());\n+        tstNextBoolean(rnd);\n+    }\n+    \n+    /** \n+     * Generate 1000 values for nextBoolean and check that\n+     * p(value = false) ~ 0.5. Use chi-square test\n+     * with df = 2-1 = 1  \n+     * @param rnd Random to use if not null\n+     */\n+    private void tstNextBoolean(Random rnd) {\n+        int[] expected = new int[] {500,500};\n+        int[] observed = new int[] {0,0};\n+        boolean result = false;\n+        for (int i = 0; i < 1000; i ++) {\n+            if (rnd == null) {\n+                result = RandomUtils.nextBoolean();\n+            } else {\n+                result = RandomUtils.nextBoolean(rnd);\n+            }     \n+            if (result) {\n+                observed[0]++;\n+            } else {\n+                observed[1]++;\n+            }\n+        }\n+        /* Use ChiSquare dist with df = 2-1 = 1, alpha = .01\n+         * Change to 10.83 for alpha = .001\n+         */\n+        assertTrue(\n+            \"chi-square test -- will fail about 1 in 100 times\",\n+            chiSquare(expected,observed) < 6.64);  \n+    }\n+    \n+    /** test distribution of nextFloat() */\n+    public void testNextFloat() {\n+        tstNextFloat(null);\n+    }\n+    \n+    /** test distribution of nextFloat(Random) */\n+    public void testNextFloat2() {\n+        Random rnd = new Random();\n+        rnd.setSeed(System.currentTimeMillis());\n+        tstNextFloat(rnd);\n+    }\n+    \n+    /** \n+     * Generate 1000 values for nextFloat and check that\n+     * p(value < 0.5) ~ 0.5. Use chi-square test\n+     * with df = 2-1 = 1  \n+     * @param rnd Random to use if not null\n+     */\n+    private void tstNextFloat(Random rnd) {\n+        int[] expected = new int[] {500,500};\n+        int[] observed = new int[] {0,0};\n+        float result = 0;\n+        for (int i = 0; i < 1000; i ++) {\n+            if (rnd == null) {\n+                result = RandomUtils.nextFloat();\n+            } else {\n+                result = RandomUtils.nextFloat(rnd);\n+            }     \n+            if (result < 0.5) {\n+                observed[0]++;\n+            } else {\n+                observed[1]++;\n+            }\n+        }\n+        /* Use ChiSquare dist with df = 2-1 = 1, alpha = .01\n+         * Change to 10.83 for alpha = .001\n+         */\n+        assertTrue(\n+            \"chi-square test -- will fail about 1 in 100 times\",\n+            chiSquare(expected,observed) < 6.64);  \n+    }\n+    \n+    /** test distribution of nextDouble() */\n+    public void testNextDouble() {\n+        tstNextDouble(null);\n+    }\n+    \n+    /** test distribution of nextDouble(Random) */\n+    public void testNextDouble2() {\n+        Random rnd = new Random();\n+        rnd.setSeed(System.currentTimeMillis());\n+        tstNextDouble(rnd);\n+    }\n+    \n+    /** \n+     * Generate 1000 values for nextFloat and check that\n+     * p(value < 0.5) ~ 0.5. Use chi-square test\n+     * with df = 2-1 = 1  \n+     * @param rnd Random to use if not null\n+     */\n+    private void tstNextDouble(Random rnd) {\n+        int[] expected = new int[] {500,500};\n+        int[] observed = new int[] {0,0};\n+        double result = 0;\n+        for (int i = 0; i < 1000; i ++) {\n+            if (rnd == null) {\n+                result = RandomUtils.nextDouble();\n+            } else {\n+                result = RandomUtils.nextDouble(rnd);\n+            }     \n+            if (result < 0.5) {\n+                observed[0]++;\n+            } else {\n+                observed[1]++;\n+            }\n+        }\n+        /* Use ChiSquare dist with df = 2-1 = 1, alpha = .01\n+         * Change to 10.83 for alpha = .001\n+         */\n+        assertTrue(\n+            \"chi-square test -- will fail about 1 in 100 times\",\n+            chiSquare(expected,observed) < 6.64);  \n+    }\n+    \n+    /** make sure that setSeed fails */\n+    public void testSetSeed() {\n+        try {\n+            RandomUtils.JVM_RANDOM.setSeed(1000);\n+            fail(\"expecting UnsupportedOperationException\");\n+        } catch (UnsupportedOperationException ex) {\n+            ;\n+        }\n+    }\n+    \n+    /**\n+     * Computes Chi-Square statistic given observed and expected counts\n+     * @param observed array of observed frequency counts\n+     * @param expected array of exptected frequency counts\n+     */\n+    private double chiSquare(int[] expected, int[] observed) {\n+        double sumSq = 0.0d;\n+        double dev = 0.0d;\n+        for (int i = 0; i< observed.length; i++) {\n+            dev = (double)(observed[i] - expected[i]);\n+            sumSq += dev*dev/(double)expected[i];\n+        }\n+        return sumSq;\n+    }           \n+\n+}\n+", "timestamp": 1052880086, "metainfo": ""}