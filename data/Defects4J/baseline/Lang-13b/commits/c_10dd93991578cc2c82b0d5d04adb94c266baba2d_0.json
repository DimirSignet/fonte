{"sha": "10dd93991578cc2c82b0d5d04adb94c266baba2d", "log": "Rolling StringUtils and test code back to r1082046. The move to CharSequence is theoretically desirable, but there are no common immutable CharSequence subclasses other than String, making this a complex and useless change. Instead StrBuilder should be enhanced. LANG-687  ", "commit": "\n--- a/src/main/java/org/apache/commons/lang3/StringUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/StringUtils.java\n      *\n      * @since 3.0\n      */\n-    // See also Lucene's ASCIIFoldingFilter (Lucene 2.9) that replaces accented characters by their\n-    // unaccented equivalent (and uncommited bug fix:\n-    // https://issues.apache.org/jira/browse/LUCENE-1343?focusedCommentId=12858907&page=com.atlassian.jira.plugin.system.issuetabpanels%3Acomment-tabpanel#action_12858907).\n+    // See also Lucene's ASCIIFoldingFilter (Lucene 2.9) that replaces accented characters by their unaccented equivalent (and uncommited bug fix: https://issues.apache.org/jira/browse/LUCENE-1343?focusedCommentId=12858907&page=com.atlassian.jira.plugin.system.issuetabpanels%3Acomment-tabpanel#action_12858907).\n     public static String stripAccents(CharSequence input) {\n         if(input == null) {\n             return null;\n             } else if (sunAvailable) {\n                 result = removeAccentsSUN(input);\n             } else {\n-                throw new UnsupportedOperationException(\"The stripAccents(CharSequence) method requires at least \"\n-                        + \"Java 1.6 or a Sun JVM\");\n+                throw new UnsupportedOperationException(\"The stripAccents(CharSequence) method requires at least Java 1.6 or a Sun JVM\");\n             }\n             // Note that none of the above methods correctly remove ligatures...\n             return result;\n     /**\n      * Use {@code java.text.Normalizer#normalize(CharSequence, Normalizer.Form)}\n      * (but be careful, this classe exists in Java 1.3, with an entirely different meaning!)\n-     *\n-     * @param text the text to be processed\n-     * @return the processed string\n-     * @throws IllegalAccessException may be thrown by a reflection call\n-     * @throws InvocationTargetException if a reflection call throws an exception\n-     * @throws IllegalStateException if the {@code Normalizer} class is not available\n-     */\n-    private static String removeAccentsJava6(CharSequence text)\n-        throws IllegalAccessException, InvocationTargetException {\n+     * @param text\n+     */\n+    private static String removeAccentsJava6(CharSequence text) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {\n         /*\n         String decomposed = java.text.Normalizer.normalize(CharSequence, Normalizer.Form.NFD);\n         return java6Pattern.matcher(decomposed).replaceAll(\"\");//$NON-NLS-1$\n \n     /**\n      * Use {@code sun.text.Normalizer#decompose(String, boolean, int)}\n-     *\n-     * @param text the text to be processed\n-     * @return the processed string\n-     * @throws IllegalAccessException may be thrown by a reflection call\n-     * @throws InvocationTargetException if a reflection call throws an exception\n-     * @throws IllegalStateException if the {@code Normalizer} class is not available\n-     */\n-    private static String removeAccentsSUN(CharSequence text)\n-        throws IllegalAccessException, InvocationTargetException {\n+     */\n+    private static String removeAccentsSUN(CharSequence text) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {\n         /*\n         String decomposed = sun.text.Normalizer.decompose(text, false, 0);\n         return sunPattern.matcher(decomposed).replaceAll(\"\");//$NON-NLS-1$\n         try {\n             // java.text.Normalizer.normalize(CharSequence, Normalizer.Form.NFD);\n             // Be careful not to get Java 1.3 java.text.Normalizer!\n-            Class<?> normalizerFormClass = Thread.currentThread().getContextClassLoader()\n-                .loadClass(\"java.text.Normalizer$Form\");//$NON-NLS-1$\n+            Class<?> normalizerFormClass = Thread.currentThread().getContextClassLoader().loadClass(\"java.text.Normalizer$Form\");//$NON-NLS-1$\n             java6NormalizerFormNFD = normalizerFormClass.getField(\"NFD\").get(null);//$NON-NLS-1$\n-            Class<?> normalizerClass = Thread.currentThread().getContextClassLoader()\n-                .loadClass(\"java.text.Normalizer\");//$NON-NLS-1$\n-            java6NormalizeMethod = normalizerClass.getMethod(\"normalize\",\n-                    new Class[] {CharSequence.class, normalizerFormClass});//$NON-NLS-1$\n+            Class<?> normalizerClass = Thread.currentThread().getContextClassLoader().loadClass(\"java.text.Normalizer\");//$NON-NLS-1$\n+            java6NormalizeMethod = normalizerClass.getMethod(\"normalize\", new Class[] {CharSequence.class, normalizerFormClass});//$NON-NLS-1$\n             java6Available = true;\n         } catch (ClassNotFoundException e) {\n             java6Available = false;\n \n         try {\n             // sun.text.Normalizer.decompose(text, false, 0);\n-            Class<?> normalizerClass = Thread.currentThread().getContextClassLoader()\n-                .loadClass(\"sun.text.Normalizer\");//$NON-NLS-1$\n-            sunDecomposeMethod = normalizerClass.getMethod(\"decompose\",\n-                    new Class[] {String.class, Boolean.TYPE, Integer.TYPE});//$NON-NLS-1$\n+            Class<?> normalizerClass = Thread.currentThread().getContextClassLoader().loadClass(\"sun.text.Normalizer\");//$NON-NLS-1$\n+            sunDecomposeMethod = normalizerClass.getMethod(\"decompose\", new Class[] {String.class, Boolean.TYPE, Integer.TYPE});//$NON-NLS-1$\n             sunAvailable = true;\n         } catch (ClassNotFoundException e) {\n             sunAvailable = false;\n     // IndexOf\n     //-----------------------------------------------------------------------\n     /**\n-     * <p>Finds the first index within a CharSequence, handling {@code null}.\n-     * This method uses {@link String#indexOf(int, int)} if possible.</p>\n-     *\n-     * <p>A {@code null} or empty (\"\") CharSequence will return {@code INDEX_NOT_FOUND (-1)}.</p>\n+     * <p>Finds the first index within a String, handling {@code null}.\n+     * This method uses {@link String#indexOf(int)}.</p>\n+     *\n+     * <p>A {@code null} or empty (\"\") String will return {@code INDEX_NOT_FOUND (-1)}.</p>\n      *\n      * <pre>\n      * StringUtils.indexOf(null, *)         = -1\n      * StringUtils.indexOf(\"aabaabaa\", 'b') = 2\n      * </pre>\n      *\n-     * @param seq  the CharSequence to check, may be null\n+     * @param str  the String to check, may be null\n      * @param searchChar  the character to find\n      * @return the first index of the search character,\n      *  -1 if no match or {@code null} string input\n      * @since 2.0\n      */\n-    public static int indexOf(CharSequence seq, int searchChar) {\n-        if (isEmpty(seq)) {\n+    public static int indexOf(String str, int searchChar) {\n+        if (isEmpty(str)) {\n             return INDEX_NOT_FOUND;\n         }\n-        return StringUtils.indexOfSequence(seq, searchChar, 0);\n-    }\n-\n-    /**\n-     * <p>Finds the first index within a CharSequence from a start position,\n+        return str.indexOf(searchChar);\n+    }\n+\n+    /**\n+     * <p>Finds the first index within a String from a start position,\n      * handling {@code null}.\n-     * This method uses {@link String#indexOf(int, int)} if possible.</p>\n-     *\n-     * <p>A {@code null} or empty (\"\") CharSequence will return {@code (INDEX_NOT_FOUND) -1}.\n+     * This method uses {@link String#indexOf(int, int)}.</p>\n+     *\n+     * <p>A {@code null} or empty (\"\") String will return {@code (INDEX_NOT_FOUND) -1}.\n      * A negative start position is treated as zero.\n      * A start position greater than the string length returns {@code -1}.</p>\n      *\n      * StringUtils.indexOf(\"aabaabaa\", 'b', -1) = 2\n      * </pre>\n      *\n-     * @param seq  the CharSequence to check, may be null\n+     * @param str  the String to check, may be null\n      * @param searchChar  the character to find\n      * @param startPos  the start position, negative treated as zero\n      * @return the first index of the search character,\n      *  -1 if no match or {@code null} string input\n      * @since 2.0\n      */\n-    public static int indexOf(CharSequence seq, int searchChar, int startPos) {\n-        if (isEmpty(seq)) {\n+    public static int indexOf(String str, int searchChar, int startPos) {\n+        if (isEmpty(str)) {\n             return INDEX_NOT_FOUND;\n         }\n-        return StringUtils.indexOfSequence(seq, searchChar, startPos);\n-    }\n-\n-    /**\n-     * <p>Finds the first index within a CharSequence, handling {@code null}.\n-     * This method uses {@link String#indexOf(String, int)} if possible.</p>\n-     *\n-     * <p>A {@code null} CharSequence will return {@code -1}.</p>\n+        return str.indexOf(searchChar, startPos);\n+    }\n+\n+    /**\n+     * <p>Finds the first index within a String, handling {@code null}.\n+     * This method uses {@link String#indexOf(String)}.</p>\n+     *\n+     * <p>A {@code null} String will return {@code -1}.</p>\n      *\n      * <pre>\n      * StringUtils.indexOf(null, *)          = -1\n      * StringUtils.indexOf(\"aabaabaa\", \"\")   = 0\n      * </pre>\n      *\n-     * @param seq  the CharSequence to check, may be null\n-     * @param searchSeq  the CharSequence to find, may be null\n-     * @return the first index of the search CharSequence,\n+     * @param str  the String to check, may be null\n+     * @param searchStr  the String to find, may be null\n+     * @return the first index of the search String,\n      *  -1 if no match or {@code null} string input\n      * @since 2.0\n      */\n-    public static int indexOf(CharSequence seq, CharSequence searchSeq) {\n-        if (seq == null || searchSeq == null) {\n+    public static int indexOf(String str, String searchStr) {\n+        if (str == null || searchStr == null) {\n             return INDEX_NOT_FOUND;\n         }\n-        return StringUtils.indexOfSequence(seq, searchSeq, 0);\n-    }\n-\n-    /**\n-     * <p>Finds the first index within a CharSequence, handling {@code null}.\n-     * This method uses {@link String#indexOf(String, int)} if possible.</p>\n-     *\n-     * <p>A {@code null} CharSequence will return {@code -1}.\n+        return str.indexOf(searchStr);\n+    }\n+\n+    /**\n+     * <p>Finds the first index within a String, handling {@code null}.\n+     * This method uses {@link String#indexOf(String, int)}.</p>\n+     *\n+     * <p>A {@code null} String will return {@code -1}.\n      * A negative start position is treated as zero.\n-     * An empty (\"\") search CharSequence always matches.\n+     * An empty (\"\") search String always matches.\n      * A start position greater than the string length only matches\n-     * an empty search CharSequence.</p>\n+     * an empty search String.</p>\n      *\n      * <pre>\n      * StringUtils.indexOf(null, *, *)          = -1\n      * StringUtils.indexOf(\"abc\", \"\", 9)        = 3\n      * </pre>\n      *\n-     * @param seq  the CharSequence to check, may be null\n-     * @param searchSeq  the CharSequence to find, may be null\n+     * @param str  the String to check, may be null\n+     * @param searchStr  the String to find, may be null\n      * @param startPos  the start position, negative treated as zero\n-     * @return the first index of the search CharSequence,\n+     * @return the first index of the search String,\n      *  -1 if no match or {@code null} string input\n      * @since 2.0\n      */\n-    public static int indexOf(CharSequence seq, CharSequence searchSeq, int startPos) {\n-        if (seq == null || searchSeq == null) {\n+    public static int indexOf(String str, String searchStr, int startPos) {\n+        if (str == null || searchStr == null) {\n             return INDEX_NOT_FOUND;\n         }\n-        return StringUtils.indexOfSequence(seq, searchSeq, startPos);\n+        return str.indexOf(searchStr, startPos);\n     }\n \n     /**\n     // LastIndexOf\n     //-----------------------------------------------------------------------\n     /**\n-     * <p>Finds the last index within a CharSequence, handling {@code null}.\n-     * This method uses {@link String#lastIndexOf(int)} if possible.</p>\n-     *\n-     * <p>A {@code null} or empty (\"\") CharSequence will return {@code -1}.</p>\n+     * <p>Finds the last index within a String, handling {@code null}.\n+     * This method uses {@link String#lastIndexOf(int)}.</p>\n+     *\n+     * <p>A {@code null} or empty (\"\") String will return {@code -1}.</p>\n      *\n      * <pre>\n      * StringUtils.lastIndexOf(null, *)         = -1\n      * StringUtils.lastIndexOf(\"aabaabaa\", 'b') = 5\n      * </pre>\n      *\n-     * @param seq  the CharSequence to check, may be null\n+     * @param str  the String to check, may be null\n      * @param searchChar  the character to find\n      * @return the last index of the search character,\n      *  -1 if no match or {@code null} string input\n      * @since 2.0\n      */\n-    public static int lastIndexOf(CharSequence seq, int searchChar) {\n-        if (isEmpty(seq)) {\n+    public static int lastIndexOf(String str, int searchChar) {\n+        if (isEmpty(str)) {\n             return INDEX_NOT_FOUND;\n         }\n-        return StringUtils.lastIndexOfSequence(seq, searchChar, seq.length());\n-    }\n-\n-    /**\n-     * <p>Finds the last index within a CharSequence from a start position,\n+        return str.lastIndexOf(searchChar);\n+    }\n+\n+    /**\n+     * <p>Finds the last index within a String from a start position,\n      * handling {@code null}.\n-     * This method uses {@link String#lastIndexOf(int, int)} if possible.</p>\n-     *\n-     * <p>A {@code null} or empty (\"\") CharSequence will return {@code -1}.\n+     * This method uses {@link String#lastIndexOf(int, int)}.</p>\n+     *\n+     * <p>A {@code null} or empty (\"\") String will return {@code -1}.\n      * A negative start position returns {@code -1}.\n      * A start position greater than the string length searches the whole string.</p>\n      *\n      * StringUtils.lastIndexOf(\"aabaabaa\", 'a', 0)  = 0\n      * </pre>\n      *\n-     * @param seq  the CharSequence to check, may be null\n+     * @param str  the String to check, may be null\n      * @param searchChar  the character to find\n      * @param startPos  the start position\n      * @return the last index of the search character,\n      *  -1 if no match or {@code null} string input\n      * @since 2.0\n      */\n-    public static int lastIndexOf(CharSequence seq, int searchChar, int startPos) {\n-        if (isEmpty(seq)) {\n+    public static int lastIndexOf(String str, int searchChar, int startPos) {\n+        if (isEmpty(str)) {\n             return INDEX_NOT_FOUND;\n         }\n-        return StringUtils.lastIndexOfSequence(seq, searchChar, startPos);\n-    }\n-\n-    /**\n-     * <p>Finds the last index within a CharSequence, handling {@code null}.\n-     * This method uses {@link String#lastIndexOf(String)} if possible.</p>\n-     *\n-     * <p>A {@code null} CharSequence will return {@code -1}.</p>\n+        return str.lastIndexOf(searchChar, startPos);\n+    }\n+\n+    /**\n+     * <p>Finds the last index within a String, handling {@code null}.\n+     * This method uses {@link String#lastIndexOf(String)}.</p>\n+     *\n+     * <p>A {@code null} String will return {@code -1}.</p>\n      *\n      * <pre>\n      * StringUtils.lastIndexOf(null, *)          = -1\n      * StringUtils.lastIndexOf(\"aabaabaa\", \"\")   = 8\n      * </pre>\n      *\n-     * @param seq  the CharSequence to check, may be null\n-     * @param searchSeq  the CharSequence to find, may be null\n+     * @param str  the String to check, may be null\n+     * @param searchStr  the String to find, may be null\n      * @return the last index of the search String,\n      *  -1 if no match or {@code null} string input\n      * @since 2.0\n      */\n-    public static int lastIndexOf(CharSequence seq, CharSequence searchSeq) {\n-        if (seq == null || searchSeq == null) {\n+    public static int lastIndexOf(String str, String searchStr) {\n+        if (str == null || searchStr == null) {\n             return INDEX_NOT_FOUND;\n         }\n-        return StringUtils.lastIndexOfSequence(seq, searchSeq, seq.length());\n+        return str.lastIndexOf(searchStr);\n     }\n \n     /**\n     }\n \n     /**\n-     * <p>Finds the first index within a CharSequence, handling {@code null}.\n-     * This method uses {@link String#lastIndexOf(String, int)} if possible.</p>\n-     *\n-     * <p>A {@code null} CharSequence will return {@code -1}.\n+     * <p>Finds the first index within a String, handling {@code null}.\n+     * This method uses {@link String#lastIndexOf(String, int)}.</p>\n+     *\n+     * <p>A {@code null} String will return {@code -1}.\n      * A negative start position returns {@code -1}.\n-     * An empty (\"\") search CharSequence always matches unless the start position is negative.\n+     * An empty (\"\") search String always matches unless the start position is negative.\n      * A start position greater than the string length searches the whole string.</p>\n      *\n      * <pre>\n      * StringUtils.lastIndexOf(\"aabaabaa\", \"b\", 0)  = -1\n      * </pre>\n      *\n-     * @param seq  the CharSequence to check, may be null\n-     * @param searchSeq  the CharSequence to find, may be null\n+     * @param str  the String to check, may be null\n+     * @param searchStr  the String to find, may be null\n      * @param startPos  the start position, negative treated as zero\n-     * @return the first index of the search CharSequence,\n+     * @return the first index of the search String,\n      *  -1 if no match or {@code null} string input\n      * @since 2.0\n      */\n-    public static int lastIndexOf(CharSequence seq, CharSequence searchSeq, int startPos) {\n-        if (seq == null || searchSeq == null) {\n+    public static int lastIndexOf(String str, String searchStr, int startPos) {\n+        if (str == null || searchStr == null) {\n             return INDEX_NOT_FOUND;\n         }\n-        return StringUtils.lastIndexOfSequence(seq, searchSeq, startPos);\n+        return str.lastIndexOf(searchStr, startPos);\n     }\n \n     /**\n     // Contains\n     //-----------------------------------------------------------------------\n     /**\n-     * <p>Checks if CharSequence contains a search character, handling {@code null}.\n-     * This method uses {@link String#indexOf(int)} if possible.</p>\n-     *\n-     * <p>A {@code null} or empty (\"\") CharSequence will return {@code false}.</p>\n+     * <p>Checks if String contains a search character, handling {@code null}.\n+     * This method uses {@link String#indexOf(int)}.</p>\n+     *\n+     * <p>A {@code null} or empty (\"\") String will return {@code false}.</p>\n      *\n      * <pre>\n      * StringUtils.contains(null, *)    = false\n      * StringUtils.contains(\"abc\", 'z') = false\n      * </pre>\n      *\n-     * @param seq  the CharSequence to check, may be null\n+     * @param str  the String to check, may be null\n      * @param searchChar  the character to find\n-     * @return true if the CharSequence contains the search character,\n+     * @return true if the String contains the search character,\n      *  false if not or {@code null} string input\n      * @since 2.0\n      */\n-    public static boolean contains(CharSequence seq, int searchChar) {\n-        if (isEmpty(seq)) {\n+    public static boolean contains(String str, int searchChar) {\n+        if (isEmpty(str)) {\n             return false;\n         }\n-        return indexOfSequence(seq, searchChar, 0) >= 0;\n-    }\n-\n-    /**\n-     * <p>Checks if CharSequence contains a search CharSequence, handling {@code null}.\n-     * This method uses {@link String#indexOf(String)} if possible.</p>\n-     *\n-     * <p>A {@code null} CharSequence will return {@code false}.</p>\n+        return str.indexOf(searchChar) >= 0;\n+    }\n+\n+    /**\n+     * <p>Checks if String contains a search String, handling {@code null}.\n+     * This method uses {@link String#indexOf(String)}.</p>\n+     *\n+     * <p>A {@code null} String will return {@code false}.</p>\n      *\n      * <pre>\n      * StringUtils.contains(null, *)     = false\n      * StringUtils.contains(\"abc\", \"z\")  = false\n      * </pre>\n      *\n-     * @param seq  the CharSequence to check, may be null\n-     * @param searchSeq  the CharSequence to find, may be null\n-     * @return true if the CharSequence contains the search CharSequence,\n+     * @param str  the String to check, may be null\n+     * @param searchStr  the String to find, may be null\n+     * @return true if the String contains the search String,\n      *  false if not or {@code null} string input\n      * @since 2.0\n      */\n-    public static boolean contains(CharSequence seq, CharSequence searchSeq) {\n-        if (seq == null || searchSeq == null) {\n+    public static boolean contains(String str, String searchStr) {\n+        if (str == null || searchStr == null) {\n             return false;\n         }\n-        return indexOfSequence(seq, searchSeq, 0) >= 0;\n+        return str.indexOf(searchStr) >= 0;\n     }\n \n     /**\n     }\n \n     /**\n-     * Check whether the given CharSequence contains any whitespace characters.\n-     * @param seq the CharSequence to check (may be {@code null})\n-     * @return {@code true} if the CharSequence is not empty and\n+     * Check whether the given String contains any whitespace characters.\n+     * @param str the String to check (may be {@code null})\n+     * @return {@code true} if the String is not empty and\n      * contains at least 1 whitespace character\n      * @see java.lang.Character#isWhitespace\n      * @since 3.0\n      */\n     // From org.springframework.util.StringUtils, under Apache License 2.0\n-    public static boolean containsWhitespace(CharSequence seq) {\n-        if (isEmpty(seq)) {\n+    public static boolean containsWhitespace(String str) {\n+        if (isEmpty(str)) {\n             return false;\n         }\n-        int strLen = seq.length();\n+        int strLen = str.length();\n         for (int i = 0; i < strLen; i++) {\n-            if (Character.isWhitespace(seq.charAt(i))) {\n+            if (Character.isWhitespace(str.charAt(i))) {\n                 return true;\n             }\n         }\n      * @param searchChars  the chars to search for, may be null\n      * @return the index of any of the chars, -1 if no match or null input\n      * @since 2.0\n-     * @since 3.0 Changed signature from indexOfAny(String, String) to indexOfAny(CharSequence, CharSequence)\n-     */\n-    public static int indexOfAny(CharSequence cs, CharSequence searchChars) {\n+     * @since 3.0 Changed signature from indexOfAny(String, String) to indexOfAny(CharSequence, String)\n+     */\n+    public static int indexOfAny(CharSequence cs, String searchChars) {\n         if (isEmpty(cs) || isEmpty(searchChars)) {\n             return INDEX_NOT_FOUND;\n         }\n-        return indexOfAny(cs, toCharArraySequence(searchChars));\n+        return indexOfAny(cs, searchChars.toCharArray());\n     }\n \n     // ContainsAny\n      * {@code false} if no match or null input\n      * @since 2.4\n      */\n-    public static boolean containsAny(CharSequence cs, char[] searchChars) {\n+    public static boolean containsAny(String cs, char[] searchChars) {\n         if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {\n             return false;\n         }\n      * @return the {@code true} if any of the chars are found, {@code false} if no match or null input\n      * @since 2.4\n      */\n-    public static boolean containsAny(CharSequence cs, CharSequence searchChars) {\n+    public static boolean containsAny(String cs, String searchChars) {\n         if (searchChars == null) {\n             return false;\n         }\n-        return containsAny(cs, toCharArraySequence(searchChars));\n+        return containsAny(cs, searchChars.toCharArray());\n     }\n \n     // IndexOfAnyBut chars\n     }\n \n     /**\n-     * <p>Search a CharSequence to find the first index of any\n+     * <p>Search a String to find the first index of any\n      * character not in the given set of characters.</p>\n      *\n-     * <p>A {@code null} CharSequence will return {@code -1}.\n+     * <p>A {@code null} String will return {@code -1}.\n      * A {@code null} or empty search string will return {@code -1}.</p>\n      *\n      * <pre>\n      * StringUtils.indexOfAnyBut(\"aba\",\"ab\")         = -1\n      * </pre>\n      *\n-     * @param seq  the CharSequence to check, may be null\n+     * @param str  the String to check, may be null\n      * @param searchChars  the chars to search for, may be null\n      * @return the index of any of the chars, -1 if no match or null input\n      * @since 2.0\n      */\n-    public static int indexOfAnyBut(CharSequence seq, CharSequence searchChars) {\n-        if (isEmpty(seq) || isEmpty(searchChars)) {\n+    public static int indexOfAnyBut(String str, String searchChars) {\n+        if (isEmpty(str) || isEmpty(searchChars)) {\n             return INDEX_NOT_FOUND;\n         }\n-        int strLen = seq.length();\n+        int strLen = str.length();\n         for (int i = 0; i < strLen; i++) {\n-            char ch = seq.charAt(i);\n-            boolean chFound = indexOfSequence(searchChars, ch, 0) >= 0;\n+            char ch = str.charAt(i);\n+            boolean chFound = searchChars.indexOf(ch) >= 0;\n             if (i + 1 < strLen && Character.isHighSurrogate(ch)) {\n-                char ch2 = seq.charAt(i + 1);\n-                if (chFound && indexOfSequence(searchChars, ch2, 0) < 0) {\n+                char ch2 = str.charAt(i + 1);\n+                if (chFound && searchChars.indexOf(ch2) < 0) {\n                     return i;\n                 }\n             } else {\n      * StringUtils.containsOnly(\"abz\", 'abc')  = false\n      * </pre>\n      *\n-     * @param cs  the CharSequence to check, may be null\n+     * @param cs  the String to check, may be null\n      * @param valid  an array of valid chars, may be null\n      * @return true if it only contains valid chars and is non-null\n      * @since 3.0 Changed signature from containsOnly(String, char[]) to containsOnly(CharSequence, char[])\n      * </pre>\n      *\n      * @param cs  the CharSequence to check, may be null\n-     * @param validChars  a CharSequence of valid chars, may be null\n+     * @param validChars  a String of valid chars, may be null\n      * @return true if it only contains valid chars and is non-null\n      * @since 2.0\n-     * @since 3.0 Changed signature from containsOnly(String, String) to containsOnly(CharSequence, CharSequence)\n-     */\n-    public static boolean containsOnly(CharSequence cs, CharSequence validChars) {\n+     * @since 3.0 Changed signature from containsOnly(String, String) to containsOnly(CharSequence, String)\n+     */\n+    public static boolean containsOnly(CharSequence cs, String validChars) {\n         if (cs == null || validChars == null) {\n             return false;\n         }\n-        return containsOnly(cs, toCharArraySequence(validChars));\n+        return containsOnly(cs, validChars.toCharArray());\n     }\n \n     // ContainsNone\n      * </pre>\n      *\n      * @param cs  the CharSequence to check, may be null\n-     * @param invalidChars  a CharSequence of invalid chars, may be null\n+     * @param invalidChars  a String of invalid chars, may be null\n      * @return true if it contains none of the invalid chars, or is null\n      * @since 2.0\n-     * @since 3.0 Changed signature from containsNone(String, String) to containsNone(CharSequence, CharSequence)\n-     */\n-    public static boolean containsNone(CharSequence cs, CharSequence invalidChars) {\n+     * @since 3.0 Changed signature from containsNone(String, String) to containsNone(CharSequence, String)\n+     */\n+    public static boolean containsNone(CharSequence cs, String invalidChars) {\n         if (cs == null || invalidChars == null) {\n             return true;\n         }\n-        return containsNone(cs, toCharArraySequence(invalidChars));\n+        return containsNone(cs, invalidChars.toCharArray());\n     }\n \n     // IndexOfAny strings\n     /**\n      * <p>Find the first index of any of a set of potential substrings.</p>\n      *\n-     * <p>A {@code null} CharSequence will return {@code -1}.\n+     * <p>A {@code null} String will return {@code -1}.\n      * A {@code null} or zero length search array will return {@code -1}.\n      * A {@code null} search array entry will be ignored, but a search\n      * array containing \"\" will return {@code 0} if {@code str} is not\n-     * null. This method uses {@link String#indexOf(String)} if possible.</p>\n+     * null. This method uses {@link String#indexOf(String)}.</p>\n      *\n      * <pre>\n      * StringUtils.indexOfAny(null, *)                     = -1\n      * StringUtils.indexOfAny(\"\", [\"a\"])                   = -1\n      * </pre>\n      *\n-     * @param str  the CharSequence to check, may be null\n-     * @param searchStrs  the CharSequences to search for, may be null\n+     * @param str  the String to check, may be null\n+     * @param searchStrs  the Strings to search for, may be null\n      * @return the first index of any of the searchStrs in str, -1 if no match\n      */\n-    public static int indexOfAny(CharSequence str, CharSequence[] searchStrs) {\n+    public static int indexOfAny(String str, String[] searchStrs) {\n         if (str == null || searchStrs == null) {\n             return INDEX_NOT_FOUND;\n         }\n \n         int tmp = 0;\n         for (int i = 0; i < sz; i++) {\n-            CharSequence search = searchStrs[i];\n+            String search = searchStrs[i];\n             if (search == null) {\n                 continue;\n             }\n-            tmp = indexOfSequence(str, search, 0);\n+            tmp = str.indexOf(search);\n             if (tmp == INDEX_NOT_FOUND) {\n                 continue;\n             }\n     /**\n      * <p>Find the latest index of any of a set of potential substrings.</p>\n      *\n-     * <p>A {@code null} CharSequence will return {@code -1}.\n+     * <p>A {@code null} String will return {@code -1}.\n      * A {@code null} search array will return {@code -1}.\n      * A {@code null} or zero length search array entry will be ignored,\n      * but a search array containing \"\" will return the length of {@code str}\n-     * if {@code str} is not null. This method uses {@link String#indexOf(String)} if possible</p>\n+     * if {@code str} is not null. This method uses {@link String#indexOf(String)}</p>\n      *\n      * <pre>\n      * StringUtils.lastIndexOfAny(null, *)                   = -1\n      * StringUtils.lastIndexOfAny(\"zzabyycdxx\", [\"mn\",\"\"])   = 10\n      * </pre>\n      *\n-     * @param str  the CharSequence to check, may be null\n-     * @param searchStrs  the CharSequences to search for, may be null\n-     * @return the last index of any of the CharSequences, -1 if no match\n-     */\n-    public static int lastIndexOfAny(CharSequence str, CharSequence[] searchStrs) {\n+     * @param str  the String to check, may be null\n+     * @param searchStrs  the Strings to search for, may be null\n+     * @return the last index of any of the Strings, -1 if no match\n+     */\n+    public static int lastIndexOfAny(String str, String[] searchStrs) {\n         if (str == null || searchStrs == null) {\n             return INDEX_NOT_FOUND;\n         }\n         int ret = INDEX_NOT_FOUND;\n         int tmp = 0;\n         for (int i = 0; i < sz; i++) {\n-            CharSequence search = searchStrs[i];\n+            String search = searchStrs[i];\n             if (search == null) {\n                 continue;\n             }\n-            tmp = lastIndexOfSequence(str, search, str.length());\n+            tmp = str.lastIndexOf(search);\n             if (tmp > ret) {\n                 ret = tmp;\n             }\n     // Substring\n     //-----------------------------------------------------------------------\n     /**\n-     * <p>Gets a substring from the specified CharSequence avoiding exceptions.</p>\n+     * <p>Gets a substring from the specified String avoiding exceptions.</p>\n      *\n      * <p>A negative start position can be used to start {@code n}\n-     * characters from the end of the CharSequence.</p>\n-     *\n-     * <p>A {@code null} CharSequence will return {@code null}.\n-     * An empty (\"\") CharSequence will return \"\".</p>\n+     * characters from the end of the String.</p>\n+     *\n+     * <p>A {@code null} String will return {@code null}.\n+     * An empty (\"\") String will return \"\".</p>\n      *\n      * <pre>\n      * StringUtils.substring(null, *)   = null\n      * StringUtils.substring(\"abc\", -4) = \"abc\"\n      * </pre>\n      *\n-     * @param str  the CharSequence to get the substring from, may be null\n+     * @param str  the String to get the substring from, may be null\n      * @param start  the position to start from, negative means\n-     *  count back from the end of the CharSequence by this many characters\n-     * @return substring from start position, {@code null} if null CharSequence input\n-     */\n-    public static String substring(CharSequence str, int start) {\n+     *  count back from the end of the String by this many characters\n+     * @return substring from start position, {@code null} if null String input\n+     */\n+    public static String substring(String str, int start) {\n         if (str == null) {\n             return null;\n         }\n             return EMPTY;\n         }\n \n-        return str.subSequence(start, str.length()).toString();\n-    }\n-\n-    /**\n-     * <p>Gets a substring from the specified CharSequence avoiding exceptions.</p>\n+        return str.substring(start);\n+    }\n+\n+    /**\n+     * <p>Gets a substring from the specified String avoiding exceptions.</p>\n      *\n      * <p>A negative start position can be used to start/end {@code n}\n-     * characters from the end of the CharSequence.</p>\n+     * characters from the end of the String.</p>\n      *\n      * <p>The returned substring starts with the character in the {@code start}\n      * position and ends before the {@code end} position. All position counting is\n      * zero-based -- i.e., to start at the beginning of the string use\n      * {@code start = 0}. Negative start and end positions can be used to\n-     * specify offsets relative to the end of the CharSequence.</p>\n+     * specify offsets relative to the end of the String.</p>\n      *\n      * <p>If {@code start} is not strictly to the left of {@code end}, \"\"\n      * is returned.</p>\n      * StringUtils.substring(\"abc\", -4, 2)  = \"ab\"\n      * </pre>\n      *\n-     * @param str  the CharSequence to get the substring from, may be null\n+     * @param str  the String to get the substring from, may be null\n      * @param start  the position to start from, negative means\n-     *  count back from the end of the CharSequence by this many characters\n+     *  count back from the end of the String by this many characters\n      * @param end  the position to end at (exclusive), negative means\n-     *  count back from the end of the CharSequence by this many characters\n+     *  count back from the end of the String by this many characters\n      * @return substring from start position to end positon,\n-     *  {@code null} if null CharSequence input\n-     */\n-    public static String substring(CharSequence str, int start, int end) {\n+     *  {@code null} if null String input\n+     */\n+    public static String substring(String str, int start, int end) {\n         if (str == null) {\n             return null;\n         }\n             end = 0;\n         }\n \n-        return str.subSequence(start, end).toString();\n+        return str.substring(start, end);\n     }\n \n     // Left/Right/Mid\n      * StringUtils.left(\"abc\", 4)   = \"abc\"\n      * </pre>\n      *\n-     * @param seq  the CharSequence to get the leftmost characters from, may be null\n+     * @param str  the String to get the leftmost characters from, may be null\n      * @param len  the length of the required String\n      * @return the leftmost characters, {@code null} if null String input\n      */\n-    public static String left(CharSequence seq, int len) {\n-        if (seq == null) {\n+    public static String left(String str, int len) {\n+        if (str == null) {\n             return null;\n         }\n         if (len < 0) {\n             return EMPTY;\n         }\n-        if (seq.length() <= len) {\n-            return seq.toString();\n-        }\n-        return seq.subSequence(0, len).toString();\n+        if (str.length() <= len) {\n+            return str;\n+        }\n+        return str.substring(0, len);\n     }\n \n     /**\n      * StringUtils.right(\"abc\", 4)   = \"abc\"\n      * </pre>\n      *\n-     * @param seq  the CharSequence to get the rightmost characters from, may be null\n+     * @param str  the String to get the rightmost characters from, may be null\n      * @param len  the length of the required String\n      * @return the rightmost characters, {@code null} if null String input\n      */\n-    public static String right(CharSequence seq, int len) {\n-        if (seq == null) {\n+    public static String right(String str, int len) {\n+        if (str == null) {\n             return null;\n         }\n         if (len < 0) {\n             return EMPTY;\n         }\n-        if (seq.length() <= len) {\n-            return seq.toString();\n-        }\n-        return StringUtils.subSequence(seq, seq.length() - len).toString();\n+        if (str.length() <= len) {\n+            return str;\n+        }\n+        return str.substring(str.length() - len);\n     }\n \n     /**\n      * of the String will be returned without an exception. If the\n      * String is {@code null}, {@code null} will be returned.\n      * An empty String is returned if len is negative or exceeds the\n-     * length of {@code seq}.</p>\n+     * length of {@code str}.</p>\n      *\n      * <pre>\n      * StringUtils.mid(null, *, *)    = null\n      * StringUtils.mid(\"abc\", -2, 2)  = \"ab\"\n      * </pre>\n      *\n-     * @param seq  the CharSequence to get the characters from, may be null\n+     * @param str  the String to get the characters from, may be null\n      * @param pos  the position to start from, negative treated as zero\n      * @param len  the length of the required String\n      * @return the middle characters, {@code null} if null String input\n      */\n-    public static String mid(CharSequence seq, int pos, int len) {\n-        if (seq == null) {\n+    public static String mid(String str, int pos, int len) {\n+        if (str == null) {\n             return null;\n         }\n-        if (len < 0 || pos > seq.length()) {\n+        if (len < 0 || pos > str.length()) {\n             return EMPTY;\n         }\n         if (pos < 0) {\n             pos = 0;\n         }\n-        if (seq.length() <= (pos + len)) {\n-            return StringUtils.subSequence(seq, pos).toString();\n-        }\n-        return seq.subSequence(pos, pos + len).toString();\n+        if (str.length() <= (pos + len)) {\n+            return str.substring(pos);\n+        }\n+        return str.substring(pos, pos + len);\n     }\n \n     // SubStringAfter/SubStringBefore\n      * StringUtils.rightPad(\"bat\", -1) = \"bat\"\n      * </pre>\n      *\n-     * @param seq  the CharSequence to pad out, may be null\n+     * @param str  the String to pad out, may be null\n      * @param size  the size to pad to\n      * @return right padded String or original String if no padding is necessary,\n      *  {@code null} if null String input\n      */\n-    public static String rightPad(CharSequence seq, int size) {\n-        return rightPad(seq, size, ' ');\n+    public static String rightPad(String str, int size) {\n+        return rightPad(str, size, ' ');\n     }\n \n     /**\n      * StringUtils.rightPad(\"bat\", -1, 'z') = \"bat\"\n      * </pre>\n      *\n-     * @param seq  the CharSequence to pad out, may be null\n+     * @param str  the String to pad out, may be null\n      * @param size  the size to pad to\n      * @param padChar  the character to pad with\n      * @return right padded String or original String if no padding is necessary,\n      *  {@code null} if null String input\n      * @since 2.0\n      */\n-    public static String rightPad(CharSequence seq, int size, char padChar) {\n-        if (seq == null) {\n+    public static String rightPad(String str, int size, char padChar) {\n+        if (str == null) {\n             return null;\n         }\n-        int pads = size - seq.length();\n+        int pads = size - str.length();\n         if (pads <= 0) {\n-            return seq.toString(); // returns original String when possible\n+            return str; // returns original String when possible\n         }\n         if (pads > PAD_LIMIT) {\n-            return rightPad(seq, size, String.valueOf(padChar));\n-        }\n-        return seq.toString().concat(padding(pads, padChar));\n+            return rightPad(str, size, String.valueOf(padChar));\n+        }\n+        return str.concat(padding(pads, padChar));\n     }\n \n     /**\n      * StringUtils.rightPad(\"bat\", 5, \"\")    = \"bat  \"\n      * </pre>\n      *\n-     * @param seq  the CharSequence to pad out, may be null\n+     * @param str  the String to pad out, may be null\n      * @param size  the size to pad to\n      * @param padStr  the String to pad with, null or empty treated as single space\n      * @return right padded String or original String if no padding is necessary,\n      *  {@code null} if null String input\n      */\n-    public static String rightPad(CharSequence seq, int size, CharSequence padStr) {\n-        if (seq == null) {\n+    public static String rightPad(String str, int size, String padStr) {\n+        if (str == null) {\n             return null;\n         }\n         if (isEmpty(padStr)) {\n             padStr = \" \";\n         }\n         int padLen = padStr.length();\n-        int strLen = seq.length();\n+        int strLen = str.length();\n         int pads = size - strLen;\n         if (pads <= 0) {\n-            return seq.toString(); // returns original String when possible\n+            return str; // returns original String when possible\n         }\n         if (padLen == 1 && pads <= PAD_LIMIT) {\n-            return rightPad(seq, size, padStr.charAt(0));\n+            return rightPad(str, size, padStr.charAt(0));\n         }\n \n         if (pads == padLen) {\n-            return seq.toString().concat(padStr.toString());\n+            return str.concat(padStr);\n         } else if (pads < padLen) {\n-            return seq.toString().concat(padStr.subSequence(0, pads).toString());\n+            return str.concat(padStr.substring(0, pads));\n         } else {\n             char[] padding = new char[pads];\n-            char[] padChars = padStr.toString().toCharArray();\n+            char[] padChars = padStr.toCharArray();\n             for (int i = 0; i < pads; i++) {\n                 padding[i] = padChars[i % padLen];\n             }\n-            return seq.toString().concat(new String(padding));\n+            return str.concat(new String(padding));\n         }\n     }\n \n      * StringUtils.leftPad(\"bat\", -1) = \"bat\"\n      * </pre>\n      *\n-     * @param seq  the CharSequence to pad out, may be null\n+     * @param str  the String to pad out, may be null\n      * @param size  the size to pad to\n      * @return left padded String or original String if no padding is necessary,\n      *  {@code null} if null String input\n      */\n-    public static String leftPad(CharSequence seq, int size) {\n-        return leftPad(seq, size, ' ');\n+    public static String leftPad(String str, int size) {\n+        return leftPad(str, size, ' ');\n     }\n \n     /**\n      * StringUtils.leftPad(\"bat\", -1, 'z') = \"bat\"\n      * </pre>\n      *\n-     * @param seq  the CharSequence to pad out, may be null\n+     * @param str  the String to pad out, may be null\n      * @param size  the size to pad to\n      * @param padChar  the character to pad with\n      * @return left padded String or original String if no padding is necessary,\n      *  {@code null} if null String input\n      * @since 2.0\n      */\n-    public static String leftPad(CharSequence seq, int size, char padChar) {\n-        if (seq == null) {\n+    public static String leftPad(String str, int size, char padChar) {\n+        if (str == null) {\n             return null;\n         }\n-        int pads = size - seq.length();\n+        int pads = size - str.length();\n         if (pads <= 0) {\n-            return seq.toString(); // returns original String when possible\n+            return str; // returns original String when possible\n         }\n         if (pads > PAD_LIMIT) {\n-            return leftPad(seq, size, String.valueOf(padChar));\n-        }\n-        return padding(pads, padChar).concat(seq.toString());\n+            return leftPad(str, size, String.valueOf(padChar));\n+        }\n+        return padding(pads, padChar).concat(str);\n     }\n \n     /**\n      * StringUtils.leftPad(\"bat\", 5, \"\")    = \"  bat\"\n      * </pre>\n      *\n-     * @param seq  the CharSequence to pad out, may be null\n+     * @param str  the String to pad out, may be null\n      * @param size  the size to pad to\n-     * @param padStr  the CharSequence to pad with, null or empty treated as single space\n+     * @param padStr  the String to pad with, null or empty treated as single space\n      * @return left padded String or original String if no padding is necessary,\n      *  {@code null} if null String input\n      */\n-    public static String leftPad(CharSequence seq, int size, CharSequence padStr) {\n-        if (seq == null) {\n+    public static String leftPad(String str, int size, String padStr) {\n+        if (str == null) {\n             return null;\n         }\n         if (isEmpty(padStr)) {\n             padStr = \" \";\n         }\n         int padLen = padStr.length();\n-        int strLen = seq.length();\n+        int strLen = str.length();\n         int pads = size - strLen;\n         if (pads <= 0) {\n-            return seq.toString(); // returns original String when possible\n+            return str; // returns original String when possible\n         }\n         if (padLen == 1 && pads <= PAD_LIMIT) {\n-            return leftPad(seq, size, padStr.charAt(0));\n+            return leftPad(str, size, padStr.charAt(0));\n         }\n \n         if (pads == padLen) {\n-            return padStr.toString().concat(seq.toString());\n+            return padStr.concat(str);\n         } else if (pads < padLen) {\n-            return padStr.subSequence(0, pads).toString().concat(seq.toString());\n+            return padStr.substring(0, pads).concat(str);\n         } else {\n             char[] padding = new char[pads];\n-            char[] padChars = padStr.toString().toCharArray();\n+            char[] padChars = padStr.toCharArray();\n             for (int i = 0; i < pads; i++) {\n                 padding[i] = padChars[i % padLen];\n             }\n-            return new String(padding).concat(seq.toString());\n+            return new String(padding).concat(str);\n         }\n     }\n \n      * StringUtils.center(\"a\", 4)    = \" a  \"\n      * </pre>\n      *\n-     * @param seq  the CharSequence to center, may be null\n+     * @param str  the String to center, may be null\n      * @param size  the int size of new String, negative treated as zero\n      * @return centered String, {@code null} if null String input\n      */\n-    public static String center(CharSequence seq, int size) {\n-        return center(seq, size, ' ');\n+    public static String center(String str, int size) {\n+        return center(str, size, ' ');\n     }\n \n     /**\n      * StringUtils.center(\"a\", 4, 'y')    = \"yayy\"\n      * </pre>\n      *\n-     * @param seq  the CharSequence to center, may be null\n+     * @param str  the String to center, may be null\n      * @param size  the int size of new String, negative treated as zero\n      * @param padChar  the character to pad the new String with\n      * @return centered String, {@code null} if null String input\n      * @since 2.0\n      */\n-    public static String center(CharSequence seq, int size, char padChar) {\n-        if (seq == null) {\n-            return null;\n-        }\n-        if (size <= 0) {\n-            return seq.toString();\n-        }\n-        int strLen = seq.length();\n+    public static String center(String str, int size, char padChar) {\n+        if (str == null || size <= 0) {\n+            return str;\n+        }\n+        int strLen = str.length();\n         int pads = size - strLen;\n         if (pads <= 0) {\n-            return seq.toString();\n-        }\n-        String tmp = leftPad(seq, strLen + pads / 2, padChar);\n-        tmp = rightPad(tmp, size, padChar);\n-        return tmp;\n+            return str;\n+        }\n+        str = leftPad(str, strLen + pads / 2, padChar);\n+        str = rightPad(str, size, padChar);\n+        return str;\n     }\n \n     /**\n      * StringUtils.center(\"abc\", 7, \"\")   = \"  abc  \"\n      * </pre>\n      *\n-     * @param seq  the CharSequence to center, may be null\n+     * @param str  the String to center, may be null\n      * @param size  the int size of new String, negative treated as zero\n-     * @param padStr  the CharSequence to pad the new String with, must not be null or empty\n+     * @param padStr  the String to pad the new String with, must not be null or empty\n      * @return centered String, {@code null} if null String input\n      * @throws IllegalArgumentException if padStr is {@code null} or empty\n      */\n-    public static String center(CharSequence seq, int size, CharSequence padStr) {\n-        if (seq == null) {\n-            return null;\n-        }\n-        if (size <= 0) {\n-            return seq.toString();\n+    public static String center(String str, int size, String padStr) {\n+        if (str == null || size <= 0) {\n+            return str;\n         }\n         if (isEmpty(padStr)) {\n             padStr = \" \";\n         }\n-        int strLen = seq.length();\n+        int strLen = str.length();\n         int pads = size - strLen;\n         if (pads <= 0) {\n-            return seq.toString();\n-        }\n-        String tmp = leftPad(seq, strLen + pads / 2, padStr);\n-        tmp = rightPad(tmp, size, padStr);\n-        return tmp;\n+            return str;\n+        }\n+        str = leftPad(str, strLen + pads / 2, padStr);\n+        str = rightPad(str, size, padStr);\n+        return str;\n     }\n \n     // Case conversion\n      *\n      * <p><strong>Note:</strong> As described in the documentation for {@link String#toUpperCase()},\n      * the result of this method is affected by the current locale.\n-     * For platform-independent case transformations, the method {@link #lowerCase(CharSequence, Locale)}\n+     * For platform-independent case transformations, the method {@link #lowerCase(String, Locale)}\n      * should be used with a specific locale (e.g. {@link Locale#ENGLISH}).</p>\n      *\n-     * @param seq  the CharSequence to upper case, may be null\n+     * @param str  the String to upper case, may be null\n      * @return the upper cased String, {@code null} if null String input\n      */\n-    public static String upperCase(CharSequence seq) {\n-        if (seq == null) {\n+    public static String upperCase(String str) {\n+        if (str == null) {\n             return null;\n         }\n-        return seq.toString().toUpperCase();\n+        return str.toUpperCase();\n     }\n \n     /**\n      * StringUtils.upperCase(\"aBc\", Locale.ENGLISH) = \"ABC\"\n      * </pre>\n      *\n-     * @param seq  the CharSequence to upper case, may be null\n+     * @param str  the String to upper case, may be null\n      * @param locale  the locale that defines the case transformation rules, must not be null\n      * @return the upper cased String, {@code null} if null String input\n      * @since 2.5\n      */\n-    public static String upperCase(CharSequence seq, Locale locale) {\n-        if (seq == null) {\n+    public static String upperCase(String str, Locale locale) {\n+        if (str == null) {\n             return null;\n         }\n-        return seq.toString().toUpperCase(locale);\n+        return str.toUpperCase(locale);\n     }\n \n     /**\n      *\n      * <p><strong>Note:</strong> As described in the documentation for {@link String#toLowerCase()},\n      * the result of this method is affected by the current locale.\n-     * For platform-independent case transformations, the method {@link #lowerCase(CharSequence, Locale)}\n+     * For platform-independent case transformations, the method {@link #lowerCase(String, Locale)}\n      * should be used with a specific locale (e.g. {@link Locale#ENGLISH}).</p>\n      *\n-     * @param seq  the CharSequence to lower case, may be null\n+     * @param str  the String to lower case, may be null\n      * @return the lower cased String, {@code null} if null String input\n      */\n-    public static String lowerCase(CharSequence seq) {\n-        if (seq == null) {\n+    public static String lowerCase(String str) {\n+        if (str == null) {\n             return null;\n         }\n-        return seq.toString().toLowerCase();\n+        return str.toLowerCase();\n     }\n \n     /**\n      * StringUtils.lowerCase(\"aBc\", Locale.ENGLISH) = \"abc\"\n      * </pre>\n      *\n-     * @param seq  the CharSequence to lower case, may be null\n+     * @param str  the String to lower case, may be null\n      * @param locale  the locale that defines the case transformation rules, must not be null\n      * @return the lower cased String, {@code null} if null String input\n      * @since 2.5\n      */\n-    public static String lowerCase(CharSequence seq, Locale locale) {\n-        if (seq == null) {\n+    public static String lowerCase(String str, Locale locale) {\n+        if (str == null) {\n             return null;\n         }\n-        return seq.toString().toLowerCase(locale);\n+        return str.toLowerCase(locale);\n     }\n \n     /**\n      * If you only use ASCII, you will notice no change.\n      * That functionality is available in org.apache.commons.lang3.text.WordUtils.</p>\n      *\n-     * @param seq  the CharSequence to swap case, may be null\n+     * @param str  the String to swap case, may be null\n      * @return the changed String, {@code null} if null String input\n      */\n-    public static String swapCase(CharSequence seq) {\n+    public static String swapCase(String str) {\n         int strLen;\n-        if (seq == null) {\n-            return null;\n-        }\n-        if ( (strLen = seq.length()) == 0) {\n-            return seq.toString();\n+        if (str == null || (strLen = str.length()) == 0) {\n+            return str;\n         }\n         StringBuilder buffer = new StringBuilder(strLen);\n \n         char ch = 0;\n         for (int i = 0; i < strLen; i++) {\n-            ch = seq.charAt(i);\n+            ch = str.charAt(i);\n             if (Character.isUpperCase(ch)) {\n                 ch = Character.toLowerCase(ch);\n             } else if (Character.isTitleCase(ch)) {\n      * <ul>\n      *   <li>If {@code str} is less than {@code maxWidth} characters\n      *       long, return it.</li>\n-     *   <li>Else abbreviate it to {@code (substring(seq, 0, max-3) + \"...\")}.</li>\n+     *   <li>Else abbreviate it to {@code (substring(str, 0, max-3) + \"...\")}.</li>\n      *   <li>If {@code maxWidth} is less than {@code 4}, throw an\n      *       {@code IllegalArgumentException}.</li>\n      *   <li>In no case will it return a String of length greater than\n      * StringUtils.abbreviate(\"abcdefg\", 3) = IllegalArgumentException\n      * </pre>\n      *\n-     * @param seq  the CharSequence to check, may be null\n+     * @param str  the String to check, may be null\n      * @param maxWidth  maximum length of result String, must be at least 4\n      * @return abbreviated String, {@code null} if null String input\n      * @throws IllegalArgumentException if the width is too small\n      * @since 2.0\n      */\n-    public static String abbreviate(CharSequence seq, int maxWidth) {\n-        return abbreviate(seq, 0, maxWidth);\n+    public static String abbreviate(String str, int maxWidth) {\n+        return abbreviate(str, 0, maxWidth);\n     }\n \n     /**\n      * StringUtils.abbreviate(\"abcdefghij\", 5, 6)        = IllegalArgumentException\n      * </pre>\n      *\n-     * @param seq  the CharSequence to check, may be null\n+     * @param str  the String to check, may be null\n      * @param offset  left edge of source String\n      * @param maxWidth  maximum length of result String, must be at least 4\n      * @return abbreviated String, {@code null} if null String input\n      * @throws IllegalArgumentException if the width is too small\n      * @since 2.0\n      */\n-    public static String abbreviate(CharSequence seq, int offset, int maxWidth) {\n-        if (seq == null) {\n+    public static String abbreviate(String str, int offset, int maxWidth) {\n+        if (str == null) {\n             return null;\n         }\n         if (maxWidth < 4) {\n             throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n         }\n-        if (seq.length() <= maxWidth) {\n-            return seq.toString();\n-        }\n-        if (offset > seq.length()) {\n-            offset = seq.length();\n-        }\n-        if ((seq.length() - offset) < (maxWidth - 3)) {\n-            offset = seq.length() - (maxWidth - 3);\n+        if (str.length() <= maxWidth) {\n+            return str;\n+        }\n+        if (offset > str.length()) {\n+            offset = str.length();\n+        }\n+        if ((str.length() - offset) < (maxWidth - 3)) {\n+            offset = str.length() - (maxWidth - 3);\n         }\n         final String abrevMarker = \"...\";\n         if (offset <= 4) {\n-            return seq.subSequence(0, maxWidth - 3) + abrevMarker;\n+            return str.substring(0, maxWidth - 3) + abrevMarker;\n         }\n         if (maxWidth < 7) {\n             throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\");\n         }\n-        if ((offset + (maxWidth - 3)) < seq.length()) {\n-            return abrevMarker + abbreviate(StringUtils.subSequence(seq, offset), maxWidth - 3);\n-        }\n-        return abrevMarker + StringUtils.subSequence(seq, seq.length() - (maxWidth - 3));\n+        if ((offset + (maxWidth - 3)) < str.length()) {\n+            return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3);\n+        }\n+        return abrevMarker + str.substring(str.length() - (maxWidth - 3));\n     }\n \n     /**\n      * StringUtils.abbreviateMiddle(\"abcdef\", \".\", 4)     = \"ab.f\"\n      * </pre>\n      *\n-     * @param seq  the CharSequence to abbreviate, may be null\n-     * @param middle the CharSequence to replace the middle characters with, may be null\n-     * @param length the length to abbreviate {@code seq} to.\n+     * @param str  the String to abbreviate, may be null\n+     * @param middle the String to replace the middle characters with, may be null\n+     * @param length the length to abbreviate {@code str} to.\n      * @return the abbreviated String if the above criteria is met, or the original String supplied for abbreviation.\n      * @since 2.5\n      */\n-    public static String abbreviateMiddle(CharSequence seq, CharSequence middle, int length) {\n-        if (seq == null) {\n-            return null;\n-        }\n-        if (isEmpty(seq) || isEmpty(middle)) {\n-            return seq.toString();\n-        }\n-\n-        if (length >= seq.length() || length < (middle.length()+2)) {\n-            return seq.toString();\n+    public static String abbreviateMiddle(String str, String middle, int length) {\n+        if (isEmpty(str) || isEmpty(middle)) {\n+            return str;\n+        }\n+\n+        if (length >= str.length() || length < (middle.length()+2)) {\n+            return str;\n         }\n \n         int targetSting = length-middle.length();\n         int startOffset = targetSting/2+targetSting%2;\n-        int endOffset = seq.length()-targetSting/2;\n+        int endOffset = str.length()-targetSting/2;\n \n         StringBuilder builder = new StringBuilder(length);\n-        builder.append(seq.subSequence(0,startOffset));\n+        builder.append(str.substring(0,startOffset));\n         builder.append(middle);\n-        builder.append(StringUtils.subSequence(seq, endOffset));\n+        builder.append(str.substring(endOffset));\n \n         return builder.toString();\n     }\n      * @param cs2  the second CharSequence, may be null\n      * @return the index where cs1 and cs2 begin to differ; -1 if they are equal\n      * @since 2.0\n-     * @since 3.0 Changed signature from indexOfDifference(String, String) to\n-     * indexOfDifference(CharSequence, CharSequence)\n+     * @since 3.0 Changed signature from indexOfDifference(String, String) to indexOfDifference(CharSequence, CharSequence)\n      */\n     public static int indexOfDifference(CharSequence cs1, CharSequence cs2) {\n         if (cs1 == cs2) {\n      * @param t  the second String, must not be null\n      * @return result distance\n      * @throws IllegalArgumentException if either String input {@code null}\n-     * @since 3.0 Changed signature from getLevenshteinDistance(String, String) to\n-     * getLevenshteinDistance(CharSequence, CharSequence)\n+     * @since 3.0 Changed signature from getLevenshteinDistance(String, String) to getLevenshteinDistance(CharSequence, CharSequence)\n      */\n     public static int getLevenshteinDistance(CharSequence s, CharSequence t) {\n         if (s == null || t == null) {\n     /**\n      * <p>Returns a new {@code CharSequence} that is a subsequence of this\n      * sequence starting with the {@code char} value at the specified index.</p>\n-     *\n+     * \n      * <p>This provides the {@code CharSequence} equivalent to {@link String#substring(int)}.\n      * The length (in {@code char}) of the returned sequence is {@code length() - start},\n      * so if {@code start == end} then an empty sequence is returned.</p>\n      * @param cs  the specified subsequence, null returns null\n      * @param start  the start index, inclusive, valid\n      * @return a new subsequence, may be null\n-     * @throws IndexOutOfBoundsException if {@code start} is negative or if\n+     * @throws IndexOutOfBoundsException if {@code start} is negative or if \n      *  {@code start} is greater than {@code length()}\n      */\n     public static CharSequence subSequence(CharSequence cs, int start) {\n         return cs == null ? null : cs.subSequence(start, cs.length());\n     }\n \n-    // The following methods are used to support basic java.lang.String functionality\n-    // for CharSequences. Currently keeping these as package private; they may be\n-    // useful as public methods so others can also support CharSequence instead of\n-    // String. At that point they may make more sense on a CharSequenceUtils and\n-    // will want a name change.\n-\n-    /**\n-     * Used by the indexOf(CharSequence methods) as a green implementation of\n-     * indexOf.\n-     *\n-     * @param cs the {@code CharSequence} to be processed\n-     * @param searchChar the char to be searched for\n-     * @param start the start index\n-     * @return the index where the search char was found\n-     */\n-    static int indexOfSequence(CharSequence cs, int searchChar, int start) {\n-        if (cs instanceof String) {\n-            return ((String) cs).indexOf(searchChar, start);\n-        } else {\n-            int sz = cs.length();\n-            if ( start < 0 ) {\n-                start = 0;\n-            }\n-            for ( int i=start; i < sz; i++ ) {\n-                if ( cs.charAt(i) == searchChar) {\n-                    return i;\n-                }\n-            }\n-            return -1;\n-        }\n-    }\n-\n-    /**\n-     * Used by the indexOf(CharSequence methods) as a green implementation of indexOf.\n-     *\n-     * @param cs the {@code CharSequence} to be processed\n-     * @param searchChar the {@code CharSequence} to be searched for\n-     * @param start the start index\n-     * @return the index where the search sequence was found\n-     */\n-    static int indexOfSequence(CharSequence cs, CharSequence searchChar, int start) {\n-        if (cs instanceof String && searchChar instanceof String) {\n-            // TODO: Do we assume searchChar is usually relatively small;\n-            //       If so then calling toString() on it is better than reverting to\n-            //       the green implementation in the else block\n-            return ((String) cs).indexOf( (String) searchChar, start);\n-        } else {\n-            // TODO: Implement rather than convert to String\n-            return cs.toString().indexOf(searchChar.toString(), start);\n-        }\n-    }\n-\n-    /**\n-     * Used by the lastIndexOf(CharSequence methods) as a green implementation of lastIndexOf\n-     *\n-     * @param cs the {@code CharSequence} to be processed\n-     * @param searchChar the char to be searched for\n-     * @param start the start index\n-     * @return the index where the search char was found\n-     */\n-    static int lastIndexOfSequence(CharSequence cs, int searchChar, int start) {\n-        if (cs instanceof String) {\n-            return ((String) cs).lastIndexOf(searchChar, start);\n-        } else {\n-            int sz = cs.length();\n-            if ( start < 0 ) {\n-                return -1;\n-            }\n-            if ( start >= sz ) {\n-                start = sz - 1;\n-            }\n-            for ( int i=start; i >= 0; --i ) {\n-                if ( cs.charAt(i) == searchChar) {\n-                    return i;\n-                }\n-            }\n-            return -1;\n-        }\n-    }\n-\n-    /**\n-     * Used by the lastIndexOf(CharSequence methods) as a green implementation of lastIndexOf\n-     *\n-     * @param cs the {@code CharSequence} to be processed\n-     * @param searchChar the {@code CharSequence} to be searched for\n-     * @param start the start index\n-     * @return the index where the search sequence was found\n-     */\n-    static int lastIndexOfSequence(CharSequence cs, CharSequence searchChar, int start) {\n-        if (cs instanceof String && searchChar instanceof String) {\n-            // TODO: Do we assume searchChar is usually relatively small;\n-            //       If so then calling toString() on it is better than reverting to\n-            //       the green implementation in the else block\n-            return ((String) cs).lastIndexOf( (String) searchChar, start);\n-        } else {\n-            // TODO: Implement rather than convert to String\n-            return cs.toString().lastIndexOf(searchChar.toString(), start);\n-        }\n-    }\n-\n-    /**\n-     * Green implementation of toCharArray.\n-     *\n-     * @param cs the {@code CharSequence} to be processed\n-     * @return the resulting char array\n-     */\n-    //\n-    static char[] toCharArraySequence(CharSequence cs) {\n-        if (cs instanceof String) {\n-            return ((String) cs).toCharArray();\n-        } else {\n-            // TODO: Implement rather than convert to String\n-            return cs.toString().toCharArray();\n-        }\n-    }\n-\n }\n--- a/src/test/java/org/apache/commons/lang3/StringUtilsEqualsIndexOfTest.java\n+++ b/src/test/java/org/apache/commons/lang3/StringUtilsEqualsIndexOfTest.java\n         assertEquals(-1, StringUtils.indexOf(\"\", ' '));\n         assertEquals(0, StringUtils.indexOf(\"aabaabaa\", 'a'));\n         assertEquals(2, StringUtils.indexOf(\"aabaabaa\", 'b'));\n-\n-        assertEquals(2, StringUtils.indexOf(new StringBuilder(\"aabaabaa\"), 'b'));\n     }\n \n     public void testIndexOf_charInt() {\n         assertEquals(5, StringUtils.indexOf(\"aabaabaa\", 'b', 3));\n         assertEquals(-1, StringUtils.indexOf(\"aabaabaa\", 'b', 9));\n         assertEquals(2, StringUtils.indexOf(\"aabaabaa\", 'b', -1));\n-\n-        assertEquals(5, StringUtils.indexOf(new StringBuilder(\"aabaabaa\"), 'b', 3));\n     }\n \n     public void testIndexOf_String() {\n         assertEquals(2, StringUtils.indexOf(\"aabaabaa\", \"b\"));\n         assertEquals(1, StringUtils.indexOf(\"aabaabaa\", \"ab\"));\n         assertEquals(0, StringUtils.indexOf(\"aabaabaa\", \"\"));\n-\n-        assertEquals(2, StringUtils.indexOf(new StringBuilder(\"aabaabaa\"), \"b\"));\n     }\n \n     public void testIndexOf_StringInt() {\n         assertEquals(-1, StringUtils.indexOf(\"aabaabaa\", \"b\", 9));\n         assertEquals(2, StringUtils.indexOf(\"aabaabaa\", \"b\", -1));\n         assertEquals(2,StringUtils.indexOf(\"aabaabaa\", \"\", 2));\n-\n-        assertEquals(5, StringUtils.indexOf(new StringBuilder(\"aabaabaa\"), \"b\", 3));\n     }\n \n     public void testIndexOfAny_StringCharArray() {\n         assertEquals(-1, StringUtils.lastIndexOf(\"\", ' '));\n         assertEquals(7, StringUtils.lastIndexOf(\"aabaabaa\", 'a'));\n         assertEquals(5, StringUtils.lastIndexOf(\"aabaabaa\", 'b'));\n-\n-        assertEquals(5, StringUtils.lastIndexOf(new StringBuilder(\"aabaabaa\"), 'b'));\n     }\n \n     public void testLastIndexOf_charInt() {\n         assertEquals(5, StringUtils.lastIndexOf(\"aabaabaa\", 'b', 9));\n         assertEquals(-1, StringUtils.lastIndexOf(\"aabaabaa\", 'b', -1));\n         assertEquals(0, StringUtils.lastIndexOf(\"aabaabaa\", 'a', 0));\n-\n-        assertEquals(2, StringUtils.lastIndexOf(new StringBuilder(\"aabaabaa\"), 'b', 2));\n     }\n \n     public void testLastIndexOf_String() {\n         assertEquals(7, StringUtils.lastIndexOf(\"aabaabaa\", \"a\"));\n         assertEquals(5, StringUtils.lastIndexOf(\"aabaabaa\", \"b\"));\n         assertEquals(4, StringUtils.lastIndexOf(\"aabaabaa\", \"ab\"));\n-\n-        assertEquals(4, StringUtils.lastIndexOf(new StringBuilder(\"aabaabaa\"), \"ab\"));\n     }\n \n     public void testLastIndexOf_StringInt() {\n         assertEquals(-1, StringUtils.lastIndexOf(\"aabaabaa\", \"b\", -1));\n         assertEquals(-1, StringUtils.lastIndexOf(\"aabaabaa\", \"b\", 0));\n         assertEquals(0, StringUtils.lastIndexOf(\"aabaabaa\", \"a\", 0));\n-\n-        assertEquals(2, StringUtils.lastIndexOf(new StringBuilder(\"aabaabaa\"), \"b\", 3));\n     }\n \n     public void testLastIndexOfAny_StringStringArray() {", "timestamp": 1301874119, "metainfo": ""}