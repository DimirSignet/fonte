{"sha": "84a814fb7c99a5cb3bad6c80932181883f92cacd", "log": "Fix PMD issues: \"These nested if statements could be combined\"  ", "commit": "\n--- a/src/main/java/org/apache/commons/lang3/StringUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/StringUtils.java\n         int lastIdx = strLen - 1;\n         String ret = str.substring(0, lastIdx);\n         char last = str.charAt(lastIdx);\n-        if (last == CharUtils.LF) {\n-            if (ret.charAt(lastIdx - 1) == CharUtils.CR) {\n-                return ret.substring(0, lastIdx - 1);\n-            }\n+        if (last == CharUtils.LF && ret.charAt(lastIdx - 1) == CharUtils.CR) {\n+            return ret.substring(0, lastIdx - 1);\n         }\n         return ret;\n     }\n--- a/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\n         boolean foundDigit = false;\n         // deal with any possible sign up front\n         int start = (chars[0] == '-') ? 1 : 0;\n-        if (sz > start + 1) {\n-            if (chars[start] == '0' && chars[start + 1] == 'x') {\n-                int i = start + 2;\n-                if (i == sz) {\n-                    return false; // str == \"0x\"\n+        if (sz > start + 1 && chars[start] == '0' && chars[start + 1] == 'x') {\n+            int i = start + 2;\n+            if (i == sz) {\n+                return false; // str == \"0x\"\n+            }\n+            // checking hex (it can't be anything else)\n+            for (; i < chars.length; i++) {\n+                if ((chars[i] < '0' || chars[i] > '9')\n+                    && (chars[i] < 'a' || chars[i] > 'f')\n+                    && (chars[i] < 'A' || chars[i] > 'F')) {\n+                    return false;\n                 }\n-                // checking hex (it can't be anything else)\n-                for (; i < chars.length; i++) {\n-                    if ((chars[i] < '0' || chars[i] > '9')\n-                        && (chars[i] < 'a' || chars[i] > 'f')\n-                        && (chars[i] < 'A' || chars[i] > 'F')) {\n-                        return false;\n-                    }\n-                }\n-                return true;\n-            }\n+            }\n+            return true;\n         }\n         sz--; // don't want to loop to the last char, check it afterwords\n               // for type qualifiers\n--- a/src/main/java/org/apache/commons/lang3/reflect/MethodUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/reflect/MethodUtils.java\n         Method bestMatch = null;\n         Method[] methods = cls.getMethods();\n         for (Method method : methods) {\n-            if (method.getName().equals(methodName)) {\n-                // compare parameters\n-                if (ClassUtils.isAssignable(parameterTypes, method\n-                        .getParameterTypes(), true)) {\n-                    // get accessible version of method\n-                    Method accessibleMethod = getAccessibleMethod(method);\n-                    if (accessibleMethod != null) {\n-                        if (bestMatch == null\n-                                || MemberUtils.compareParameterTypes(\n-                                        accessibleMethod.getParameterTypes(),\n-                                        bestMatch.getParameterTypes(),\n-                                        parameterTypes) < 0) {\n-                            bestMatch = accessibleMethod;\n-                        }\n-                    }\n-                }\n+            // compare name and parameters\n+            if (method.getName().equals(methodName) && ClassUtils.isAssignable(parameterTypes, method.getParameterTypes(), true)) {\n+                // get accessible version of method\n+                Method accessibleMethod = getAccessibleMethod(method);\n+                if (accessibleMethod != null && (bestMatch == null || MemberUtils.compareParameterTypes(\n+                            accessibleMethod.getParameterTypes(),\n+                            bestMatch.getParameterTypes(),\n+                            parameterTypes) < 0)) {\n+                        bestMatch = accessibleMethod;\n+                 }\n             }\n         }\n         if (bestMatch != null) {\n--- a/src/main/java/org/apache/commons/lang3/text/StrTokenizer.java\n+++ b/src/main/java/org/apache/commons/lang3/text/StrTokenizer.java\n                 }\n                 \n                 // check for quote, and thus back into quoting mode\n-                if (quoteLen > 0) {\n-                    if (isQuote(chars, pos, len, quoteStart, quoteLen)) {\n-                        quoting = true;\n-                        pos += quoteLen;\n-                        continue;\n-                    }\n+                if (quoteLen > 0 && isQuote(chars, pos, len, quoteStart, quoteLen)) {\n+                    quoting = true;\n+                    pos += quoteLen;\n+                    continue;\n                 }\n                 \n                 // check for ignored (outside quotes), and ignore\n--- a/src/main/java/org/apache/commons/lang3/text/translate/UnicodeUnescaper.java\n+++ b/src/main/java/org/apache/commons/lang3/text/translate/UnicodeUnescaper.java\n      */\n     @Override\n     public int translate(CharSequence input, int index, Writer out) throws IOException {\n-        if(input.charAt(index) == '\\\\') {\n-            if( (index + 1 < input.length()) && input.charAt(index + 1) == 'u') {\n-                // consume optional additional 'u' chars\n-                int i=2;\n-                while( (index + i < input.length()) && input.charAt(index + i) == 'u') {\n-                    i++;\n+        if (input.charAt(index) == '\\\\' && (index + 1 < input.length()) && input.charAt(index + 1) == 'u') {\n+            // consume optional additional 'u' chars\n+            int i = 2;\n+            while ((index + i < input.length()) && input.charAt(index + i) == 'u') {\n+                i++;\n+            }\n+\n+            if ((index + i < input.length()) && (input.charAt(index + i) == '+')) {\n+                i++;\n+            }\n+\n+            if ((index + i + 4 <= input.length())) {\n+                // Get 4 hex digits\n+                CharSequence unicode = input.subSequence(index + i, index + i + 4);\n+\n+                try {\n+                    int value = Integer.parseInt(unicode.toString(), 16);\n+                    out.write((char) value);\n+                } catch (NumberFormatException nfe) {\n+                    throw new IllegalArgumentException(\"Unable to parse unicode value: \" + unicode, nfe);\n                 }\n-\n-                if( (index + i < input.length()) && (input.charAt(index + i) == '+') ) {\n-                    i++;\n-                }\n-\n-                if( (index + i + 4 <= input.length()) ) {\n-                    // Get 4 hex digits\n-                    CharSequence unicode = input.subSequence(index + i, index + i + 4);\n-\n-                    try {\n-                        int value = Integer.parseInt(unicode.toString(), 16);\n-                        out.write((char) value);\n-                    } catch (NumberFormatException nfe) {\n-                        throw new IllegalArgumentException(\"Unable to parse unicode value: \" + unicode, nfe);\n-                    }\n-                    return i + 4;\n-                } else {\n-                    throw new IllegalArgumentException(\"Less than 4 hex digits in unicode value: '\" + \n-                                                       input.subSequence(index, input.length()) +\n-                                                       \"' due to end of CharSequence\");\n-                }\n+                return i + 4;\n+            } else {\n+                throw new IllegalArgumentException(\"Less than 4 hex digits in unicode value: '\" + input.subSequence(index, input.length())\n+                        + \"' due to end of CharSequence\");\n             }\n         }\n         return 0;", "timestamp": 1312310992, "metainfo": ""}