{"sha": "651306550ce5dea558f848fdf7a708c2097a007a", "log": "Refactor ExceptionContext and derived. Context contract stipulates a sequence of label-value entries with support for multiple entries for the same label.  ", "commit": "\n--- a/src/main/java/org/apache/commons/lang3/exception/ContextedException.java\n+++ b/src/main/java/org/apache/commons/lang3/exception/ContextedException.java\n  */\n package org.apache.commons.lang3.exception;\n \n+import java.util.List;\n import java.util.Set;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n \n /**\n  * <p>\n- * An exception that provides an easy and safe way to add contextual information.\n+ * An exception that provides an easy and safe way to add contextual\n+ * information.\n  * </p><p>\n  * An exception trace itself is often insufficient to provide rapid diagnosis of the issue.\n  * Frequently what is needed is a select few pieces of local contextual data.\n  * Providing this data is tricky however, due to concerns over formatting and nulls.\n  * </p><p>\n  * The contexted exception approach allows the exception to be created together with a\n- * map of context values. This additional information is automatically included in the\n- * message and printed stack trace.\n+ * list of context label-value pairs. This additional information is automatically included in\n+ * the message and printed stack trace.\n  * </p><p>\n  * An unchecked version of this exception is provided by ContextedRuntimeException.\n  * </p>\n  *     ...\n  *   } catch (Exception e) {\n  *     throw new ContextedException(\"Error posting account transaction\", e)\n- *          .addValue(\"accountNumber\", accountNumber)\n- *          .addValue(\"amountPosted\", amountPosted)\n- *          .addValue(\"previousBalance\", previousBalance)\n+ *          .addContextValue(\"accountNumber\", accountNumber)\n+ *          .addContextValue(\"amountPosted\", amountPosted)\n+ *          .addContextValue(\"previousBalance\", previousBalance)\n  *   }\n  * }\n  * </pre>\n public class ContextedException extends Exception implements ExceptionContext {\n \n     /** The serialization version. */\n-    private static final long serialVersionUID = 8940917952810290164L;\n+    private static final long serialVersionUID = 20110706L;\n     /** The context where the data is stored. */\n     private final ExceptionContext exceptionContext;\n \n     }\n \n     //-----------------------------------------------------------------------\n+\n     /**\n      * Adds information helpful to a developer in diagnosing and correcting\n      * the problem.  For the information to be meaningful, the value passed\n-     * should have a reasonable toString() implementation. If the added label\n-     * is already available, the label is appended with an index.\n+     * should have a reasonable toString() implementation.  Different values\n+     * can be added with the same label multiple times. \n      * <p>\n      * Note: This exception is only serializable if the object added is serializable.\n      * </p>\n      * \n-     * @param label  a textual label associated with information, null not recommended\n-     * @param value  information needed to understand exception, may be null\n-     * @return this, for method chaining\n-     */\n-    public ContextedException addValue(String label, Object value) {        \n-        exceptionContext.addValue(label, value);\n-        return this;\n-    }\n-\n-    /**\n-     * Replaces information helpful to a developer in diagnosing and correcting\n-     * the problem.  For the information to be meaningful, the value passed\n-     * should have a reasonable toString() implementation. If the replaced\n-     * label does not yet exist, it is simply added.\n-     * <p>\n-     * Note: This exception is only serializable if the object added is serializable.\n-     * </p>\n-     * \n-     * @param label  a textual label associated with information, null not recommended\n-     * @param value  information needed to understand exception, may be null\n-     * @return this, for method chaining\n-     */\n-    public ContextedException replaceValue(String label, Object value) {        \n-        exceptionContext.replaceValue(label, value);\n-        return this;\n-    }\n-\n-    /**\n-     * Retrieves a contextual data value associated with the label.\n-     * \n-     * @param label  the label to get the contextual value for, may be null\n-     * @return the contextual value associated with the label, may be null\n-     */\n-    public Object getValue(String label) {\n-        return exceptionContext.getValue(label);\n-    }\n-\n-    /**\n-     * Retrieves the labels defined in the contextual data.\n-     * \n-     * @return the set of labels, never null\n-     */\n-    public Set<String> getLabelSet() {\n-        return exceptionContext.getLabelSet();\n+     * @param label  a textual label associated with information, {@code null} not recommended\n+     * @param value  information needed to understand exception, may be {@code null}\n+     * @return this, for method chaining\n+     */\n+    public ContextedException addContextValue(String label, Object value) {        \n+        exceptionContext.addContextValue(label, value);\n+        return this;\n+    }\n+\n+    /**\n+     * Adds information helpful to a developer in diagnosing and correcting\n+     * the problem.  For the information to be meaningful, the value passed\n+     * should have a reasonable toString() implementation.  Different values\n+     * can be added with the same label multiple times. \n+     * <p>\n+     * Note: This exception is only serializable if the object added as value is serializable.\n+     * </p>\n+     * \n+     * @param pair a pair of textual label and information\n+     * @throws NullPointerException if {@code pair} is {@code null}\n+     * @return this, for method chaining\n+     */\n+    public ContextedException addContextValue(Pair<String, Object> pair) {\n+        this.exceptionContext.addContextValue(pair);\n+        return this;\n+    }\n+\n+    /**\n+     * Set information helpful to a developer in diagnosing and correcting\n+     * the problem.  For the information to be meaningful, the value passed\n+     * should have a reasonable toString() implementation.  Existing values\n+     * with the same labels are removed before the new one is added.\n+     * <p>\n+     * Note: This exception is only serializable if the object added as value is serializable.\n+     * </p>\n+     * \n+     * @param label  a textual label associated with information, {@code null} not recommended\n+     * @param value  information needed to understand exception, may be {@code null}\n+     * @return this, for method chaining\n+     */\n+    public ContextedException setContextValue(String label, Object value) {        \n+        exceptionContext.setContextValue(label, value);\n+        return this;\n+    }\n+    \n+    /**\n+     * Set information helpful to a developer in diagnosing and correcting\n+     * the problem.  For the information to be meaningful, the value passed\n+     * should have a reasonable toString() implementation.  Existing values\n+     * with the same labels are removed before the new one is added.\n+     * <p>\n+     * Note: This exception is only serializable if the object added as value is serializable.\n+     * </p>\n+     * \n+     * @param pair a pair of textual label and information\n+     * @throws NullPointerException if {@code pair} is {@code null}\n+     * @return this, for method chaining\n+     */\n+    public ContextedException setContextValue(Pair<String, Object> pair) {\n+        this.exceptionContext.setContextValue(pair);\n+        return this;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public List<Object> getContextValues(String label) {\n+        return this.exceptionContext.getContextValues(label);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public Object getFirstContextValue(String label) {\n+        return this.exceptionContext.getFirstContextValue(label);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public List<Pair<String, Object>> getContextEntries() {\n+        return this.exceptionContext.getContextEntries();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public Set<String> getContextLabels() {\n+        return exceptionContext.getContextLabels();\n     }\n \n     /**\n--- a/src/main/java/org/apache/commons/lang3/exception/ContextedRuntimeException.java\n+++ b/src/main/java/org/apache/commons/lang3/exception/ContextedRuntimeException.java\n  */\n package org.apache.commons.lang3.exception;\n \n+import java.util.List;\n import java.util.Set;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n \n /**\n  * <p>\n  * Providing this data is tricky however, due to concerns over formatting and nulls.\n  * </p><p>\n  * The contexted exception approach allows the exception to be created together with a\n- * map of context values. This additional information is automatically included in the\n- * message and printed stack trace.\n+ * list of context label-value pairs. This additional information is automatically included in\n+ * the message and printed stack trace.\n  * </p><p>\n  * An checked version of this exception is provided by ContextedException.\n  * </p>\n  *     ...\n  *   } catch (Exception e) {\n  *     throw new ContextedException(\"Error posting account transaction\", e)\n- *          .addValue(\"accountNumber\", accountNumber)\n- *          .addValue(\"amountPosted\", amountPosted)\n- *          .addValue(\"previousBalance\", previousBalance)\n+ *          .addContextValue(\"accountNumber\", accountNumber)\n+ *          .addContextValue(\"amountPosted\", amountPosted)\n+ *          .addContextValue(\"previousBalance\", previousBalance)\n  *   }\n  * }\n  * </pre>\n public class ContextedRuntimeException extends RuntimeException implements ExceptionContext {\n \n     /** The serialization version. */\n-    private static final long serialVersionUID = 1459691936045811817L;\n+    private static final long serialVersionUID = 20110706L;\n     /** The context where the data is stored. */\n     private final ExceptionContext exceptionContext;\n \n \n     /**\n      * Instantiates ContextedRuntimeException with cause, message, and ExceptionContext.\n+     * <p>\n+     * Note: This exception is only serializable if the object added is serializable.\n+     * </p>\n      * \n      * @param message  the exception message, may be null\n      * @param cause  the underlying cause of the exception, may be null\n     }\n \n     //-----------------------------------------------------------------------\n+\n     /**\n      * Adds information helpful to a developer in diagnosing and correcting\n      * the problem.  For the information to be meaningful, the value passed\n-     * should have a reasonable toString() implementation. If the added label\n-     * is already available, the label is appended with an index.\n+     * should have a reasonable toString() implementation.  Different values\n+     * can be added with the same label multiple times. \n      * <p>\n      * Note: This exception is only serializable if the object added is serializable.\n      * </p>\n      * \n-     * @param label  a textual label associated with information, null not recommended\n-     * @param value  information needed to understand exception, may be null\n-     * @return this, for method chaining\n-     */\n-    public ContextedRuntimeException addValue(String label, Object value) {        \n-        exceptionContext.addValue(label, value);\n-        return this;\n-    }\n-\n-    /**\n-     * Replaces information helpful to a developer in diagnosing and correcting\n-     * the problem.  For the information to be meaningful, the value passed\n-     * should have a reasonable toString() implementation. If the replaced\n-     * label does not yet exist, it is simply added.\n-     * <p>\n-     * Note: This exception is only serializable if the object added is serializable.\n-     * </p>\n-     * \n-     * @param label  a textual label associated with information, null not recommended\n-     * @param value  information needed to understand exception, may be null\n-     * @return this, for method chaining\n-     */\n-    public ContextedRuntimeException replaceValue(String label, Object value) {        \n-        exceptionContext.replaceValue(label, value);\n-        return this;\n-    }\n-\n-    /**\n-     * Retrieves a contextual data value associated with the label.\n-     * \n-     * @param label  the label to get the contextual value for, may be null\n-     * @return the contextual value associated with the label, may be null\n-     */\n-    public Object getValue(String label) {\n-        return exceptionContext.getValue(label);\n-    }\n-\n-    /**\n-     * Retrieves the labels defined in the contextual data.\n-     * \n-     * @return the set of labels, never null\n-     */\n-    public Set<String> getLabelSet() {\n-        return exceptionContext.getLabelSet();\n+     * @param label  a textual label associated with information, {@code null} not recommended\n+     * @param value  information needed to understand exception, may be {@code null}\n+     * @return this, for method chaining\n+     */\n+    public ContextedRuntimeException addContextValue(String label, Object value) {        \n+        exceptionContext.addContextValue(label, value);\n+        return this;\n+    }\n+\n+    /**\n+     * Adds information helpful to a developer in diagnosing and correcting\n+     * the problem.  For the information to be meaningful, the value passed\n+     * should have a reasonable toString() implementation.  Different values\n+     * can be added with the same label multiple times. \n+     * <p>\n+     * Note: This exception is only serializable if the object added as value is serializable.\n+     * </p>\n+     * \n+     * @param pair a pair of textual label and information\n+     * @throws NullPointerException if {@code pair} is {@code null}\n+     * @return this, for method chaining\n+     */\n+    public ContextedRuntimeException addContextValue(Pair<String, Object> pair) {\n+        this.exceptionContext.addContextValue(pair);\n+        return this;\n+    }\n+\n+    /**\n+     * Set information helpful to a developer in diagnosing and correcting\n+     * the problem.  For the information to be meaningful, the value passed\n+     * should have a reasonable toString() implementation.  Existing values\n+     * with the same labels are removed before the new one is added.\n+     * <p>\n+     * Note: This exception is only serializable if the object added as value is serializable.\n+     * </p>\n+     * \n+     * @param label  a textual label associated with information, {@code null} not recommended\n+     * @param value  information needed to understand exception, may be {@code null}\n+     * @return this, for method chaining\n+     */\n+    public ContextedRuntimeException setContextValue(String label, Object value) {        \n+        exceptionContext.setContextValue(label, value);\n+        return this;\n+    }\n+    \n+    /**\n+     * Set information helpful to a developer in diagnosing and correcting\n+     * the problem.  For the information to be meaningful, the value passed\n+     * should have a reasonable toString() implementation.  Existing values\n+     * with the same labels are removed before the new one is added.\n+     * <p>\n+     * Note: This exception is only serializable if the object added as value is serializable.\n+     * </p>\n+     * \n+     * @param pair a pair of textual label and information\n+     * @throws NullPointerException if {@code pair} is {@code null}\n+     * @return this, for method chaining\n+     */\n+    public ContextedRuntimeException setContextValue(Pair<String, Object> pair) {\n+        this.exceptionContext.setContextValue(pair);\n+        return this;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public List<Object> getContextValues(String label) {\n+        return this.exceptionContext.getContextValues(label);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public Object getFirstContextValue(String label) {\n+        return this.exceptionContext.getFirstContextValue(label);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public List<Pair<String, Object>> getContextEntries() {\n+        return this.exceptionContext.getContextEntries();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public Set<String> getContextLabels() {\n+        return exceptionContext.getContextLabels();\n     }\n \n     /**\n--- a/src/main/java/org/apache/commons/lang3/exception/DefaultExceptionContext.java\n+++ b/src/main/java/org/apache/commons/lang3/exception/DefaultExceptionContext.java\n package org.apache.commons.lang3.exception;\n \n import java.io.Serializable;\n-import java.util.LinkedHashMap;\n-import java.util.Map;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n import java.util.Set;\n \n-import org.apache.commons.lang3.SystemUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+import org.apache.commons.lang3.tuple.Pair;\n \n /**\n  * Default implementation of the context storing the label-value pairs for contexted exceptions.\n  * \n  * @since 3.0\n  */\n-class DefaultExceptionContext implements ExceptionContext, Serializable {\n+public class DefaultExceptionContext implements ExceptionContext, Serializable {\n \n     /** The serialization version. */\n-    private static final long serialVersionUID = 293747957535772807L;\n-    /** The ordered map storing the label-data pairs. */\n-    private Map<String, Object> contextValueMap = new LinkedHashMap<String, Object>();\n+    private static final long serialVersionUID = 20110706L;\n+    /** The list storing the label-data pairs. */\n+    private List<Pair<String, Object>> contextValues = new ArrayList<Pair<String,Object>>();\n \n     /**\n-     * Adds a contextual label-value pair into this context.\n-     * <p>\n-     * This label-value pair provides information useful for debugging. If the\n-     * label already exists and the provided information is different, the \n-     * label will be added with an appended index.\n-     * </p>\n-     * \n-     * @param label  the label of the item to add, null not recommended\n-     * @param value  the value of item to add, may be null\n-     * @return this, for method chaining\n+     * {@inheritDoc}\n      */\n-    public ExceptionContext addValue(String label, Object value) {        \n-        String key = label;\n-        int i = 0;\n-        while (contextValueMap.containsKey(key)) {\n-            Object information = contextValueMap.get(key);\n-            if ((value == null && information == null)\n-                    || (value != null && value.equals(information))) {\n-                return this;\n-            }\n-            key = label + \"[\" + ++i +\"]\";\n+    public DefaultExceptionContext addContextValue(String label, Object value) {\n+        return addContextValue(new ImmutablePair<String, Object>(label, value));\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public DefaultExceptionContext addContextValue(Pair<String, Object> pair) {\n+        if (pair == null) {\n+            throw new NullPointerException();\n         }\n-        contextValueMap.put(key, value);\n+        contextValues.add(pair);\n         return this;\n     }\n \n     /**\n-     * Replaces a contextual label-value pair of this context.\n-     * <p>\n-     * This label-value pair provides information useful for debugging. If the\n-     * label does not yet exists, a simply add operation is performed.\n-     * </p>\n-     * \n-     * @param label  the label of the item to add, null not recommended\n-     * @param value  the value of item to add, may be null\n-     * @return this, for method chaining\n+     * {@inheritDoc}\n      */\n-    public ExceptionContext replaceValue(String label, Object value) {        \n-        contextValueMap.put(label, value);\n-        return this;\n+    public DefaultExceptionContext setContextValue(String label, Object value) {\n+        return setContextValue(new ImmutablePair<String, Object>(label, value));\n     }\n \n     /**\n-     * Retrieves a contextual data value associated with the label.\n-     * \n-     * @param label  the label to get the contextual value for, may be null\n-     * @return the contextual value associated with the label, may be null\n+     * {@inheritDoc}\n      */\n-    public Object getValue(String label) {\n-        return contextValueMap.get(label);\n+    public DefaultExceptionContext setContextValue(Pair<String, Object> pair) {\n+        final String label = pair.getKey(); // implicit NPE\n+        for (final Iterator<Pair<String, Object>> iter = contextValues.iterator(); iter.hasNext();) {\n+            final Pair<String, Object> p = iter.next();\n+            if (StringUtils.equals(label, p.getKey())) {\n+                iter.remove();\n+            }\n+        }\n+        return addContextValue(pair);\n     }\n \n     /**\n-     * Retrieves the labels defined in the contextual data.\n-     * \n-     * @return the set of labels, never null\n+     * {@inheritDoc}\n      */\n-    public Set<String> getLabelSet() {\n-        return contextValueMap.keySet();\n+    public List<Object> getContextValues(String label) {\n+        final List<Object> values = new ArrayList<Object>();\n+        for (final Pair<String, Object> pair : contextValues) {\n+            if (StringUtils.equals(label, pair.getKey())) {\n+                values.add(pair.getValue());\n+            }\n+        }\n+        return values;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public Object getFirstContextValue(String label) {\n+        for (final Pair<String, Object> pair : contextValues) {\n+            if (StringUtils.equals(label, pair.getKey())) {\n+                return pair.getValue();\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public Set<String> getContextLabels() {\n+        final Set<String> labels = new HashSet<String>();\n+        for (final Pair<String, Object> pair : contextValues) {\n+            labels.add(pair.getKey());\n+        }\n+        return labels;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public List<Pair<String, Object>> getContextEntries() {\n+        return contextValues;\n     }\n \n     /**\n             buffer.append(baseMessage);\n         }\n         \n-        if (contextValueMap.size() > 0) {\n-            if (buffer.length() > 0l) {\n-                buffer.append(SystemUtils.LINE_SEPARATOR);\n+        if (contextValues.size() > 0) {\n+            if (buffer.length() > 0) {\n+                buffer.append('\\n');\n             }\n-            buffer.append(\"Exception Context:\");\n-            buffer.append(SystemUtils.LINE_SEPARATOR); \n-            buffer.append(\"\\t\");  \n+            buffer.append(\"Exception Context:\\n\");\n             \n             Object value;\n             String valueStr;\n-            for (String label : contextValueMap.keySet()) {\n-                buffer.append(\"[\");\n-                buffer.append(label);\n+            for (final Pair<String, Object> pair : contextValues) {\n+                buffer.append(\"\\t[\");\n+                buffer.append(pair.getKey());\n                 buffer.append(\"=\");\n-                value = this.contextValueMap.get(label);\n+                value = pair.getValue();\n                 if (value == null) {\n                     buffer.append(\"null\");\n                 } else {\n                     }\n                     buffer.append(valueStr);\n                 }\n-                buffer.append(\"]\");\n-                buffer.append(SystemUtils.LINE_SEPARATOR);  \n-                buffer.append(\"\\t\");  \n+                buffer.append(\"]\\n\");\n             }\n             buffer.append(\"---------------------------------\");\n         }\n         return buffer.toString();\n     }\n-\n }\n--- a/src/main/java/org/apache/commons/lang3/exception/ExceptionContext.java\n+++ b/src/main/java/org/apache/commons/lang3/exception/ExceptionContext.java\n  */\n package org.apache.commons.lang3.exception;\n \n+import java.util.List;\n import java.util.Set;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n \n /**\n  * Allows the storage and retrieval of contextual information based on label-value\n  * pairs for exceptions.\n+ * <p>\n+ * Implementations are expected to manage the pairs in a list-style collection\n+ * that keeps the pairs in the sequence of their addition.\n+ * </p>\n  * \n  * @see ContextedException\n  * @see ContextedRuntimeException\n     /**\n      * Adds a contextual label-value pair into this context.\n      * <p>\n-     * This label-value pair provides information useful for debugging. If the\n-     * provided label already exists, it depends on the implementation what\n-     * happens with the new value. \n+     * The pair will be added to the context, independently of an already\n+     * existing pair with the same label.\n      * </p>\n      * \n-     * @param label  the label of the item to add, null not recommended\n-     * @param value  the value of item to add, may be null\n+     * @param label  the label of the item to add, {@code null} not recommended\n+     * @param value  the value of item to add, may be {@code null}\n      * @return context itself to allow method chaining\n      */\n-    public ExceptionContext addValue(String label, Object value);\n+    public ExceptionContext addContextValue(String label, Object value);\n \n     /**\n-     * Replaces a contextual label-value pair of this context.\n+     * Adds a contextual label-value pair into this context.\n      * <p>\n-     * This label-value pair provides information useful for debugging. If the\n-     * label does not exist yet, it depends on the implementation what happens\n-     * with the provided value.\n+     * The pair will be added to the context, independently of an already\n+     * existing pair with the same label.\n      * </p>\n      * \n-     * @param label  the label of the item to add, null not recommended\n-     * @param value  the value of item to add, may be null\n+     * @param pair  the label-value pair to add\n+     * @return context itself to allow method chaining\n+     * @throws NullPointerException if pair is {@code null}\n+     */\n+    public ExceptionContext addContextValue(Pair<String, Object> pair);\n+\n+    /**\n+     * Sets a contextual label-value pair of this context.\n+     * <p>\n+     * The pair will be added normally, but any existing label-value pair with\n+     * the same label is removed from the context.\n+     * </p>\n+     * \n+     * @param label  the label of the item to add, {@code null} not recommended\n+     * @param value  the value of item to add, may be {@code null}\n      * @return context itself to allow method chaining\n      */\n-    public ExceptionContext replaceValue(String label, Object value);\n+    public ExceptionContext setContextValue(String label, Object value);\n \n     /**\n-     * Retrieves a contextual data value associated with the label.\n+     * Sets a contextual label-value pair of this context.\n+     * <p>\n+     * The pair will be added normally, but any existing label-value pair with\n+     * the same label is removed from the context.\n+     * </p>\n      * \n-     * @param label  the label to get the contextual value for, may be null\n-     * @return the contextual value associated with the label, may be null\n+     * @param pair  the label-value pair to add\n+     * @return context itself to allow method chaining\n+     * @throws NullPointerException if pair is {@code null}\n      */\n-    public Object getValue(String label);\n+    public ExceptionContext setContextValue(Pair<String, Object> pair);\n+\n+    /**\n+     * Retrieves contextual data values associated with the label.\n+     * \n+     * @param label  the label to get the contextual values for, may be {@code null}\n+     * @return the contextual values associated with the label, never {@code null}\n+     */\n+    public List<Object> getContextValues(String label);\n+\n+    /**\n+     * Retrieves the first available contextual data value associated with the label.\n+     * \n+     * @param label  the label to get the contextual value for, may be {@code null}\n+     * @return the first contextual value associated with the label, may be {@code null}\n+     */\n+    public Object getFirstContextValue(String label);\n \n     /**\n      * Retrieves the labels defined in the contextual data.\n      * \n-     * @return the set of labels, never null\n+     * @return the set of labels, never {@code null}\n      */\n-    public Set<String> getLabelSet();\n+    public Set<String> getContextLabels();\n+\n+    /**\n+     * Retrieves the label-value pairs defined in the contextual data.\n+     * \n+     * @return the list of pairs, never {@code null}\n+     */\n+    public List<Pair<String, Object>> getContextEntries();\n \n     /**\n      * Implementors provide the given base message with context label/value item \n      * information appended.\n      * \n      * @param baseMessage  the base exception message <b>without</b> context information appended\n-     * @return the exception message <b>with</b> context information appended, never null\n+     * @return the exception message <b>with</b> context information appended, never {@code null}\n      */\n     public String getFormattedExceptionMessage(String baseMessage);\n \n--- /dev/null\n+++ b/src/test/java/org/apache/commons/lang3/exception/AbstractExceptionContextTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang3.exception;\n+\n+import java.io.Serializable;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+\n+import junit.framework.TestCase;\n+\n+\n+/**\n+ * Abstract test of an ExceptionContext implementation.\n+ */\n+public abstract class AbstractExceptionContextTest<T extends ExceptionContext> extends TestCase {\n+\n+    protected static final String TEST_MESSAGE_2 = \"This is monotonous\";\n+    protected static final String TEST_MESSAGE = \"Test Message\";\n+    protected T exceptionContext;\n+\n+    protected static class ObjectWithFaultyToString implements Serializable {\n+\n+        private static final long serialVersionUID = 3495843995332310458L;\n+\n+        @Override\n+        public String toString() {\n+            throw new RuntimeException(\"Crap\");\n+        }\n+    }\n+\n+    @Override\n+    protected void setUp() throws Exception {\n+        exceptionContext\n+            .addContextValue(\"test1\", null)\n+            .addContextValue(\"test2\", \"some value\")\n+            .addContextValue(\"test Date\", new Date())\n+            .addContextValue(\"test Nbr\", new Integer(5))\n+            .addContextValue(\"test Poorly written obj\", new ObjectWithFaultyToString());\n+    }\n+\n+    public void testAddContextValue() {\n+        String message = exceptionContext.getFormattedExceptionMessage(TEST_MESSAGE);\n+        assertTrue(message.indexOf(TEST_MESSAGE) >= 0);\n+        assertTrue(message.indexOf(\"test1\") >= 0);\n+        assertTrue(message.indexOf(\"test2\") >= 0);\n+        assertTrue(message.indexOf(\"test Date\") >= 0);\n+        assertTrue(message.indexOf(\"test Nbr\") >= 0);\n+        assertTrue(message.indexOf(\"some value\") >= 0);\n+        assertTrue(message.indexOf(\"5\") >= 0);\n+\n+        assertTrue(exceptionContext.getFirstContextValue(\"test1\") == null);\n+        assertTrue(exceptionContext.getFirstContextValue(\"test2\").equals(\"some value\"));\n+\n+        assertEquals(5, exceptionContext.getContextLabels().size());\n+        assertTrue(exceptionContext.getContextLabels().contains(\"test1\"));\n+        assertTrue(exceptionContext.getContextLabels().contains(\"test2\"));\n+        assertTrue(exceptionContext.getContextLabels().contains(\"test Date\"));\n+        assertTrue(exceptionContext.getContextLabels().contains(\"test Nbr\"));\n+\n+        exceptionContext.addContextValue(\"test2\", \"different value\");\n+        assertEquals(5, exceptionContext.getContextLabels().size());\n+        assertTrue(exceptionContext.getContextLabels().contains(\"test2\"));\n+\n+        String contextMessage = exceptionContext.getFormattedExceptionMessage(null);\n+        assertTrue(contextMessage.indexOf(TEST_MESSAGE) == -1);\n+    }\n+\n+    public void testSetContextValue() {\n+        exceptionContext.addContextValue(\"test2\", \"different value\");\n+        exceptionContext.setContextValue(\"test3\", \"3\");\n+\n+        String message = exceptionContext.getFormattedExceptionMessage(TEST_MESSAGE);\n+        assertTrue(message.indexOf(TEST_MESSAGE) >= 0);\n+        assertTrue(message.indexOf(\"test Poorly written obj\") >= 0);\n+        assertTrue(message.indexOf(\"Crap\") >= 0);\n+\n+        assertTrue(exceptionContext.getFirstContextValue(\"crap\") == null);\n+        assertTrue(exceptionContext.getFirstContextValue(\"test Poorly written obj\") instanceof ObjectWithFaultyToString);\n+\n+        assertEquals(7, exceptionContext.getContextEntries().size());\n+        assertEquals(6, exceptionContext.getContextLabels().size());\n+\n+        assertTrue(exceptionContext.getContextLabels().contains(\"test Poorly written obj\"));\n+        assertTrue(!exceptionContext.getContextLabels().contains(\"crap\"));\n+\n+        exceptionContext.setContextValue(\"test Poorly written obj\", \"replacement\");\n+\n+        assertEquals(7, exceptionContext.getContextEntries().size());\n+        assertEquals(6, exceptionContext.getContextLabels().size());\n+\n+        exceptionContext.setContextValue(\"test2\", \"another\");\n+\n+        assertEquals(6, exceptionContext.getContextEntries().size());\n+        assertEquals(6, exceptionContext.getContextLabels().size());\n+\n+        String contextMessage = exceptionContext.getFormattedExceptionMessage(null);\n+        assertTrue(contextMessage.indexOf(TEST_MESSAGE) == -1);\n+    }\n+\n+    public void testGetFirstContextValue() {\n+        exceptionContext.addContextValue(\"test2\", \"different value\");\n+\n+        assertTrue(exceptionContext.getFirstContextValue(\"test1\") == null);\n+        assertTrue(exceptionContext.getFirstContextValue(\"test2\").equals(\"some value\"));\n+        assertTrue(exceptionContext.getFirstContextValue(\"crap\") == null);\n+\n+        exceptionContext.setContextValue(\"test2\", \"another\");\n+\n+        assertTrue(exceptionContext.getFirstContextValue(\"test2\").equals(\"another\"));\n+    }\n+\n+    public void testGetContextValues() {\n+        exceptionContext.addContextValue(\"test2\", \"different value\");\n+\n+        assertEquals(exceptionContext.getContextValues(\"test1\"), Collections.singletonList(null));\n+        assertEquals(exceptionContext.getContextValues(\"test2\"), Arrays.asList(\"some value\", \"different value\"));\n+\n+        exceptionContext.setContextValue(\"test2\", \"another\");\n+\n+        assertTrue(exceptionContext.getFirstContextValue(\"test2\").equals(\"another\"));\n+    }\n+\n+    public void testGetContextLabels() {\n+        assertEquals(5, exceptionContext.getContextEntries().size());\n+        \n+        exceptionContext.addContextValue(\"test2\", \"different value\");\n+\n+        Set<String> labels = exceptionContext.getContextLabels();\n+        assertEquals(6, exceptionContext.getContextEntries().size());\n+        assertEquals(5, labels.size());\n+        assertTrue(labels.contains(\"test1\"));\n+        assertTrue(labels.contains(\"test2\"));\n+        assertTrue(labels.contains(\"test Date\"));\n+        assertTrue(labels.contains(\"test Nbr\"));\n+    }\n+\n+    public void testGetContextEntries() {\n+        assertEquals(5, exceptionContext.getContextEntries().size());\n+        \n+        exceptionContext.addContextValue(\"test2\", \"different value\");\n+\n+        List<Pair<String, Object>> entries = exceptionContext.getContextEntries();\n+        assertEquals(6, entries.size());\n+        assertEquals(\"test1\", entries.get(0).getKey());\n+        assertEquals(\"test2\", entries.get(1).getKey());\n+        assertEquals(\"test Date\", entries.get(2).getKey());\n+        assertEquals(\"test Nbr\", entries.get(3).getKey());\n+        assertEquals(\"test Poorly written obj\", entries.get(4).getKey());\n+        assertEquals(\"test2\", entries.get(5).getKey());\n+    }\n+}\n--- a/src/test/java/org/apache/commons/lang3/exception/ContextedExceptionTest.java\n+++ b/src/test/java/org/apache/commons/lang3/exception/ContextedExceptionTest.java\n  */\n package org.apache.commons.lang3.exception;\n \n-import java.io.Serializable;\n import java.util.Date;\n-\n-import junit.framework.TestCase;\n \n import org.apache.commons.lang3.StringUtils;\n \n /**\n  * JUnit tests for ContextedException.\n  */\n-public class ContextedExceptionTest extends TestCase {\n+public class ContextedExceptionTest extends AbstractExceptionContextTest<ContextedException> {\n     \n-    private static final String TEST_MESSAGE_2 = \"This is monotonous\";\n-    private static final String TEST_MESSAGE = \"Test Message\";\n-    private ContextedException contextedException;\n+    @Override\n+    public void setUp() throws Exception {\n+        exceptionContext = new ContextedException(new Exception(TEST_MESSAGE));\n+        super.setUp();\n+    }\n \n     public void testContextedException() {\n-        contextedException = new ContextedException();\n-        String message = contextedException.getMessage();\n-        String trace = ExceptionUtils.getStackTrace(contextedException);\n+        exceptionContext = new ContextedException();\n+        String message = exceptionContext.getMessage();\n+        String trace = ExceptionUtils.getStackTrace(exceptionContext);\n         assertTrue(trace.indexOf(\"ContextedException\")>=0);\n         assertTrue(StringUtils.isEmpty(message));\n     }\n \n     public void testContextedExceptionString() {\n-        contextedException = new ContextedException(TEST_MESSAGE);\n-        assertEquals(TEST_MESSAGE, contextedException.getMessage());\n+        exceptionContext = new ContextedException(TEST_MESSAGE);\n+        assertEquals(TEST_MESSAGE, exceptionContext.getMessage());\n         \n-        String trace = ExceptionUtils.getStackTrace(contextedException);\n+        String trace = ExceptionUtils.getStackTrace(exceptionContext);\n         assertTrue(trace.indexOf(TEST_MESSAGE)>=0);\n     }\n \n     public void testContextedExceptionThrowable() {\n-        contextedException = new ContextedException(new Exception(TEST_MESSAGE));\n-        String message = contextedException.getMessage();\n-        String trace = ExceptionUtils.getStackTrace(contextedException);\n+        exceptionContext = new ContextedException(new Exception(TEST_MESSAGE));\n+        String message = exceptionContext.getMessage();\n+        String trace = ExceptionUtils.getStackTrace(exceptionContext);\n         assertTrue(trace.indexOf(\"ContextedException\")>=0);\n         assertTrue(trace.indexOf(TEST_MESSAGE)>=0);\n         assertTrue(message.indexOf(TEST_MESSAGE)>=0);\n     }\n \n     public void testContextedExceptionStringThrowable() {\n-        contextedException = new ContextedException(TEST_MESSAGE_2, new Exception(TEST_MESSAGE));\n-        String message = contextedException.getMessage();\n-        String trace = ExceptionUtils.getStackTrace(contextedException);\n+        exceptionContext = new ContextedException(TEST_MESSAGE_2, new Exception(TEST_MESSAGE));\n+        String message = exceptionContext.getMessage();\n+        String trace = ExceptionUtils.getStackTrace(exceptionContext);\n         assertTrue(trace.indexOf(\"ContextedException\")>=0);\n         assertTrue(trace.indexOf(TEST_MESSAGE)>=0);\n         assertTrue(trace.indexOf(TEST_MESSAGE_2)>=0);\n     }\n     \n     public void testContextedExceptionStringThrowableContext() {\n-        contextedException = new ContextedException(TEST_MESSAGE_2, new Exception(TEST_MESSAGE), new DefaultExceptionContext());\n-        String message = contextedException.getMessage();\n-        String trace = ExceptionUtils.getStackTrace(contextedException);\n+        exceptionContext = new ContextedException(TEST_MESSAGE_2, new Exception(TEST_MESSAGE), new DefaultExceptionContext());\n+        String message = exceptionContext.getMessage();\n+        String trace = ExceptionUtils.getStackTrace(exceptionContext);\n         assertTrue(trace.indexOf(\"ContextedException\")>=0);\n         assertTrue(trace.indexOf(TEST_MESSAGE)>=0);\n         assertTrue(trace.indexOf(TEST_MESSAGE_2)>=0);\n         assertTrue(message.indexOf(TEST_MESSAGE_2)>=0);\n     }\n \n-    public void testAddValue() {\n-        contextedException = new ContextedException(new Exception(TEST_MESSAGE))\n-        .addValue(\"test1\", null)\n-        .addValue(\"test2\", \"some value\")\n-        .addValue(\"test Date\", new Date())\n-        .addValue(\"test Nbr\", new Integer(5));\n+    public void testNullExceptionPassing() {\n+        exceptionContext = new ContextedException(TEST_MESSAGE_2, new Exception(TEST_MESSAGE), null)\n+        .addContextValue(\"test1\", null)\n+        .addContextValue(\"test2\", \"some value\")\n+        .addContextValue(\"test Date\", new Date())\n+        .addContextValue(\"test Nbr\", new Integer(5))\n+        .addContextValue(\"test Poorly written obj\", new ObjectWithFaultyToString());\n         \n-        String message = contextedException.getMessage();\n-        assertTrue(message.indexOf(TEST_MESSAGE)>=0);\n-        assertTrue(message.indexOf(\"test1\")>=0);\n-        assertTrue(message.indexOf(\"test2\")>=0);\n-        assertTrue(message.indexOf(\"test Date\")>=0);\n-        assertTrue(message.indexOf(\"test Nbr\")>=0);\n-        assertTrue(message.indexOf(\"some value\")>=0);\n-        assertTrue(message.indexOf(\"5\")>=0);\n-        \n-        assertTrue(contextedException.getValue(\"test1\") == null);\n-        assertTrue(contextedException.getValue(\"test2\").equals(\"some value\"));\n-        \n-        assertTrue(contextedException.getLabelSet().size() == 4);\n-        assertTrue(contextedException.getLabelSet().contains(\"test1\"));\n-        assertTrue(contextedException.getLabelSet().contains(\"test2\"));\n-        assertTrue(contextedException.getLabelSet().contains(\"test Date\"));\n-        assertTrue(contextedException.getLabelSet().contains(\"test Nbr\"));\n-\n-        contextedException.addValue(\"test2\", \"different value\");\n-        assertTrue(contextedException.getLabelSet().size() == 5);\n-        assertTrue(contextedException.getLabelSet().contains(\"test2\"));\n-        assertTrue(contextedException.getLabelSet().contains(\"test2[1]\"));\n-        \n-        String contextMessage = contextedException.getFormattedExceptionMessage(null);\n-        assertTrue(contextMessage.indexOf(TEST_MESSAGE) == -1);\n-        assertTrue(contextedException.getMessage().endsWith(contextMessage));\n-    }\n-\n-    public void testReplaceValue() {\n-        contextedException = new ContextedException(new Exception(TEST_MESSAGE))\n-        .addValue(\"test Poorly written obj\", new ObjectWithFaultyToString());\n-        \n-        String message = contextedException.getMessage();\n-        assertTrue(message.indexOf(TEST_MESSAGE)>=0);\n-        assertTrue(message.indexOf(\"test Poorly written obj\")>=0);\n-        assertTrue(message.indexOf(\"Crap\")>=0);\n-        \n-        assertTrue(contextedException.getValue(\"crap\") == null);\n-        assertTrue(contextedException.getValue(\"test Poorly written obj\") instanceof ObjectWithFaultyToString);\n-        \n-        assertTrue(contextedException.getLabelSet().size() == 1);\n-        assertTrue(contextedException.getLabelSet().contains(\"test Poorly written obj\"));\n-        \n-        assertTrue(!contextedException.getLabelSet().contains(\"crap\"));\n-\n-        contextedException.replaceValue(\"test Poorly written obj\", \"replacement\");\n-\n-        assertTrue(contextedException.getLabelSet().size() == 1);\n-\n-        String contextMessage = contextedException.getFormattedExceptionMessage(null);\n-        assertTrue(contextMessage.indexOf(TEST_MESSAGE) == -1);\n-        assertTrue(contextedException.getMessage().endsWith(contextMessage));\n-    }\n-    \n-    public void testNullExceptionPassing() {\n-        contextedException = new ContextedException(TEST_MESSAGE_2, new Exception(TEST_MESSAGE), null)\n-        .addValue(\"test1\", null)\n-        .addValue(\"test2\", \"some value\")\n-        .addValue(\"test Date\", new Date())\n-        .addValue(\"test Nbr\", new Integer(5))\n-        .addValue(\"test Poorly written obj\", new ObjectWithFaultyToString());\n-        \n-        String message = contextedException.getMessage();\n+        String message = exceptionContext.getMessage();\n         assertTrue(message != null);\n-    }\n-    \n-    static class ObjectWithFaultyToString implements Serializable {\n-\n-        private static final long serialVersionUID = 3495843995332310458L;\n-\n-        @Override\n-        public String toString() {\n-            throw new RuntimeException(\"Crap\");\n-        }\n-        \n     }\n \n }\n--- a/src/test/java/org/apache/commons/lang3/exception/ContextedRuntimeExceptionTest.java\n+++ b/src/test/java/org/apache/commons/lang3/exception/ContextedRuntimeExceptionTest.java\n \n import java.util.Date;\n \n-import junit.framework.TestCase;\n-\n import org.apache.commons.lang3.StringUtils;\n-import org.apache.commons.lang3.exception.ContextedExceptionTest.ObjectWithFaultyToString;\n \n /**\n  * JUnit tests for ContextedRuntimeException.\n  *\n  */\n-public class ContextedRuntimeExceptionTest extends TestCase {\n+public class ContextedRuntimeExceptionTest extends AbstractExceptionContextTest<ContextedRuntimeException> {\n     \n-    private static final String TEST_MESSAGE_2 = \"This is monotonous\";\n-    private static final String TEST_MESSAGE = \"Test Message\";\n-    private ContextedRuntimeException contextedRuntimeException;\n+    @Override\n+    protected void setUp() throws Exception {\n+        exceptionContext = new ContextedRuntimeException(new Exception(TEST_MESSAGE));\n+        super.setUp();\n+    }\n \n     public void testContextedException() {\n-        contextedRuntimeException = new ContextedRuntimeException();\n-        String message = contextedRuntimeException.getMessage();\n-        String trace = ExceptionUtils.getStackTrace(contextedRuntimeException);\n+        exceptionContext = new ContextedRuntimeException();\n+        String message = exceptionContext.getMessage();\n+        String trace = ExceptionUtils.getStackTrace(exceptionContext);\n         assertTrue(trace.indexOf(\"ContextedException\")>=0);\n         assertTrue(StringUtils.isEmpty(message));\n     }\n \n     public void testContextedExceptionString() {\n-        contextedRuntimeException = new ContextedRuntimeException(TEST_MESSAGE);\n-        assertEquals(TEST_MESSAGE, contextedRuntimeException.getMessage());\n+        exceptionContext = new ContextedRuntimeException(TEST_MESSAGE);\n+        assertEquals(TEST_MESSAGE, exceptionContext.getMessage());\n         \n-        String trace = ExceptionUtils.getStackTrace(contextedRuntimeException);\n+        String trace = ExceptionUtils.getStackTrace(exceptionContext);\n         assertTrue(trace.indexOf(TEST_MESSAGE)>=0);\n     }\n \n     public void testContextedExceptionThrowable() {\n-        contextedRuntimeException = new ContextedRuntimeException(new Exception(TEST_MESSAGE));\n-        String message = contextedRuntimeException.getMessage();\n-        String trace = ExceptionUtils.getStackTrace(contextedRuntimeException);\n+        exceptionContext = new ContextedRuntimeException(new Exception(TEST_MESSAGE));\n+        String message = exceptionContext.getMessage();\n+        String trace = ExceptionUtils.getStackTrace(exceptionContext);\n         assertTrue(trace.indexOf(\"ContextedException\")>=0);\n         assertTrue(trace.indexOf(TEST_MESSAGE)>=0);\n         assertTrue(message.indexOf(TEST_MESSAGE)>=0);\n     }\n \n     public void testContextedExceptionStringThrowable() {\n-        contextedRuntimeException = new ContextedRuntimeException(TEST_MESSAGE_2, new Exception(TEST_MESSAGE));\n-        String message = contextedRuntimeException.getMessage();\n-        String trace = ExceptionUtils.getStackTrace(contextedRuntimeException);\n+        exceptionContext = new ContextedRuntimeException(TEST_MESSAGE_2, new Exception(TEST_MESSAGE));\n+        String message = exceptionContext.getMessage();\n+        String trace = ExceptionUtils.getStackTrace(exceptionContext);\n         assertTrue(trace.indexOf(\"ContextedException\")>=0);\n         assertTrue(trace.indexOf(TEST_MESSAGE)>=0);\n         assertTrue(trace.indexOf(TEST_MESSAGE_2)>=0);\n     }\n     \n     public void testContextedExceptionStringThrowableContext() {\n-        contextedRuntimeException = new ContextedRuntimeException(TEST_MESSAGE_2, new Exception(TEST_MESSAGE), new DefaultExceptionContext());\n-        String message = contextedRuntimeException.getMessage();\n-        String trace = ExceptionUtils.getStackTrace(contextedRuntimeException);\n+        exceptionContext = new ContextedRuntimeException(TEST_MESSAGE_2, new Exception(TEST_MESSAGE), new DefaultExceptionContext() {});\n+        String message = exceptionContext.getMessage();\n+        String trace = ExceptionUtils.getStackTrace(exceptionContext);\n         assertTrue(trace.indexOf(\"ContextedException\")>=0);\n         assertTrue(trace.indexOf(TEST_MESSAGE)>=0);\n         assertTrue(trace.indexOf(TEST_MESSAGE_2)>=0);\n         assertTrue(message.indexOf(TEST_MESSAGE_2)>=0);\n     }\n \n-    public void testAddValue() {\n-        contextedRuntimeException = new ContextedRuntimeException(new Exception(TEST_MESSAGE))\n-        .addValue(\"test1\", null)\n-        .addValue(\"test2\", \"some value\")\n-        .addValue(\"test Date\", new Date())\n-        .addValue(\"test Nbr\", new Integer(5));\n+    public void testNullExceptionPassing() {\n+        exceptionContext = new ContextedRuntimeException(TEST_MESSAGE_2, new Exception(TEST_MESSAGE), null)\n+        .addContextValue(\"test1\", null)\n+        .addContextValue(\"test2\", \"some value\")\n+        .addContextValue(\"test Date\", new Date())\n+        .addContextValue(\"test Nbr\", new Integer(5))\n+        .addContextValue(\"test Poorly written obj\", new ObjectWithFaultyToString());\n         \n-        String message = contextedRuntimeException.getMessage();\n-        assertTrue(message.indexOf(TEST_MESSAGE)>=0);\n-        assertTrue(message.indexOf(\"test1\")>=0);\n-        assertTrue(message.indexOf(\"test2\")>=0);\n-        assertTrue(message.indexOf(\"test Date\")>=0);\n-        assertTrue(message.indexOf(\"test Nbr\")>=0);\n-        assertTrue(message.indexOf(\"some value\")>=0);\n-        assertTrue(message.indexOf(\"5\")>=0);\n-        \n-        assertTrue(contextedRuntimeException.getValue(\"test1\") == null);\n-        assertTrue(contextedRuntimeException.getValue(\"test2\").equals(\"some value\"));\n-        \n-        assertTrue(contextedRuntimeException.getLabelSet().size() == 4);\n-        assertTrue(contextedRuntimeException.getLabelSet().contains(\"test1\"));\n-        assertTrue(contextedRuntimeException.getLabelSet().contains(\"test2\"));\n-        assertTrue(contextedRuntimeException.getLabelSet().contains(\"test Date\"));\n-        assertTrue(contextedRuntimeException.getLabelSet().contains(\"test Nbr\"));\n-\n-        contextedRuntimeException.addValue(\"test2\", \"different value\");\n-        assertTrue(contextedRuntimeException.getLabelSet().size() == 5);\n-        assertTrue(contextedRuntimeException.getLabelSet().contains(\"test2\"));\n-        assertTrue(contextedRuntimeException.getLabelSet().contains(\"test2[1]\"));\n-        \n-        String contextMessage = contextedRuntimeException.getFormattedExceptionMessage(null);\n-        assertTrue(contextMessage.indexOf(TEST_MESSAGE) == -1);\n-        assertTrue(contextedRuntimeException.getMessage().endsWith(contextMessage));\n-    }\n-\n-    public void testReplaceValue() {\n-        contextedRuntimeException = new ContextedRuntimeException(new Exception(TEST_MESSAGE))\n-        .addValue(\"test Poorly written obj\", new ObjectWithFaultyToString());\n-        \n-        String message = contextedRuntimeException.getMessage();\n-        assertTrue(message.indexOf(TEST_MESSAGE)>=0);\n-        assertTrue(message.indexOf(\"test Poorly written obj\")>=0);\n-        assertTrue(message.indexOf(\"Crap\")>=0);\n-        \n-        assertTrue(contextedRuntimeException.getValue(\"crap\") == null);\n-        assertTrue(contextedRuntimeException.getValue(\"test Poorly written obj\") instanceof ObjectWithFaultyToString);\n-        \n-        assertTrue(contextedRuntimeException.getLabelSet().size() == 1);\n-        assertTrue(contextedRuntimeException.getLabelSet().contains(\"test Poorly written obj\"));\n-        \n-        assertTrue(!contextedRuntimeException.getLabelSet().contains(\"crap\"));\n-\n-        contextedRuntimeException.replaceValue(\"test Poorly written obj\", \"replacement\");\n-\n-        assertTrue(contextedRuntimeException.getLabelSet().size() == 1);\n-\n-        String contextMessage = contextedRuntimeException.getFormattedExceptionMessage(null);\n-        assertTrue(contextMessage.indexOf(TEST_MESSAGE) == -1);\n-        assertTrue(contextedRuntimeException.getMessage().endsWith(contextMessage));\n-    }\n-    \n-    public void testNullExceptionPassing() {\n-        contextedRuntimeException = new ContextedRuntimeException(TEST_MESSAGE_2, new Exception(TEST_MESSAGE), null)\n-        .addValue(\"test1\", null)\n-        .addValue(\"test2\", \"some value\")\n-        .addValue(\"test Date\", new Date())\n-        .addValue(\"test Nbr\", new Integer(5))\n-        .addValue(\"test Poorly written obj\", new ObjectWithFaultyToString());\n-        \n-        String message = contextedRuntimeException.getMessage();\n+        String message = exceptionContext.getMessage();\n         assertTrue(message != null);\n     }\n }\n--- a/src/test/java/org/apache/commons/lang3/exception/DefaultExceptionContextTest.java\n+++ b/src/test/java/org/apache/commons/lang3/exception/DefaultExceptionContextTest.java\n  */\n package org.apache.commons.lang3.exception;\n \n-import java.util.Date;\n-\n-import junit.framework.TestCase;\n-\n-import org.apache.commons.lang3.exception.ContextedExceptionTest.ObjectWithFaultyToString;\n-\n /**\n  * JUnit tests for DefaultExceptionContext.\n  *\n  */\n-public class DefaultExceptionContextTest extends TestCase {\n+public class DefaultExceptionContextTest extends AbstractExceptionContextTest<DefaultExceptionContext> {\n     \n-    private ExceptionContext defaultExceptionContext;\n-\n-    public DefaultExceptionContextTest(String name) {\n-        super(name);\n+    @Override\n+    public void setUp() throws Exception {\n+        exceptionContext = new DefaultExceptionContext();\n+        super.setUp();\n     }\n     \n-    @Override\n-    public void setUp() {\n-        defaultExceptionContext = new DefaultExceptionContext()\n-        .addValue(\"test1\", null)\n-        .addValue(\"test2\", \"some value\")\n-        .addValue(\"test Date\", new Date())\n-        .addValue(\"test Nbr\", new Integer(5))\n-        .addValue(\"test Poorly written obj\", new ObjectWithFaultyToString());\n-    }\n-    \n-    public void testAddValue() {\n-        defaultExceptionContext.addValue(\"test2\", \"different value\");\n-                \n-        String message = defaultExceptionContext.getFormattedExceptionMessage(\"This is an error\");\n-        assertTrue(message.indexOf(\"This is an error\")>=0);\n-        assertTrue(message.indexOf(\"test1\")>=0);\n-        assertTrue(message.indexOf(\"test2\")>=0);\n-        assertTrue(message.indexOf(\"test2[1]\")>=0);\n-        assertTrue(message.indexOf(\"test Date\")>=0);\n-        assertTrue(message.indexOf(\"test Nbr\")>=0);\n-        assertTrue(message.indexOf(\"test Poorly written obj\")>=0);\n-        assertTrue(message.indexOf(\"some value\")>=0);\n-        assertTrue(message.indexOf(\"different value\")>=0);\n-        assertTrue(message.indexOf(\"5\")>=0);\n-        assertTrue(message.indexOf(\"Crap\")>=0);\n-    }\n-    \n-    public void testReplaceValue() {\n-        defaultExceptionContext.replaceValue(\"test2\", \"different value\");\n-        defaultExceptionContext.replaceValue(\"test3\", \"3\");\n-                \n-        String message = defaultExceptionContext.getFormattedExceptionMessage(\"This is an error\");\n-        assertTrue(message.indexOf(\"This is an error\")>=0);\n-        assertTrue(message.indexOf(\"test1\")>=0);\n-        assertTrue(message.indexOf(\"test2\")>=0);\n-        assertTrue(message.indexOf(\"test3\")>=0);\n-        assertTrue(message.indexOf(\"test Date\")>=0);\n-        assertTrue(message.indexOf(\"test Nbr\")>=0);\n-        assertTrue(message.indexOf(\"test Poorly written obj\")>=0);\n-        assertTrue(message.indexOf(\"different value\")>=0);\n-        assertTrue(message.indexOf(\"5\")>=0);\n-        assertTrue(message.indexOf(\"Crap\")>=0);\n-\n-        assertTrue(message.indexOf(\"test2[1]\")<0);\n-        assertTrue(message.indexOf(\"some value\")<0);\n-}\n-    \n     public void testFormattedExceptionMessageNull() {\n-        defaultExceptionContext = new DefaultExceptionContext();\n-        defaultExceptionContext.getFormattedExceptionMessage(null);\n-    }\n-    \n-    public void testGetValue() {\n-        assertTrue(defaultExceptionContext.getValue(\"test1\") == null);\n-        assertTrue(defaultExceptionContext.getValue(\"test2\").equals(\"some value\"));\n-        assertTrue(defaultExceptionContext.getValue(\"crap\") == null);\n-        assertTrue(defaultExceptionContext.getValue(\"test Poorly written obj\") instanceof ObjectWithFaultyToString);\n-    }\n-    \n-    public void testGetLabelSet() {\n-        assertTrue(defaultExceptionContext.getLabelSet().size() == 5);\n-        assertTrue(defaultExceptionContext.getLabelSet().contains(\"test1\"));\n-        assertTrue(defaultExceptionContext.getLabelSet().contains(\"test2\"));\n-        assertTrue(defaultExceptionContext.getLabelSet().contains(\"test Date\"));\n-        assertTrue(defaultExceptionContext.getLabelSet().contains(\"test Nbr\"));\n-        assertTrue(defaultExceptionContext.getLabelSet().contains(\"test Poorly written obj\"));\n-        \n-        assertTrue(!defaultExceptionContext.getLabelSet().contains(\"crap\"));\n+        exceptionContext = new DefaultExceptionContext();\n+        exceptionContext.getFormattedExceptionMessage(null);\n     }\n \n }", "timestamp": 1309996497, "metainfo": ""}