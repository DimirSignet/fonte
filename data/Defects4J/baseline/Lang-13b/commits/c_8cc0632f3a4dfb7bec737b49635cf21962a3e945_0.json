{"sha": "8cc0632f3a4dfb7bec737b49635cf21962a3e945", "log": "Adding Cedrik Lime's patch from LANG-285; adding unaccenting for Java 1.3->1.5 via reflection usage of Sun JVMs  ", "commit": "\n--- a/src/main/java/org/apache/commons/lang3/StringUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/StringUtils.java\n  */\n package org.apache.commons.lang3;\n \n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n import java.util.ArrayList;\n import java.util.Iterator;\n import java.util.List;\n     }\n \n     /**\n-     * <p>Removes the accents from a string. </p>\n-     * <p>NOTE: This is a JDK 1.6 method, it will fail on JDK 1.5. </p>\n+     * <p>Removes diacritics (~= accents) from a string. The case will not be altered.</p>\n+     * <p>For instance, '&agrave;' will be replaced by 'a'.</p>\n+     * <p>Note that ligatures will be left as is.</p>\n+     *\n+     * <p>This method will use the first available implementation of:\n+     * Java 6's {@link java.text.Normalizer}, Java 1.3&ndash;1.5's {@code sun.text.Normalizer}</p>\n      *\n      * <pre>\n      * StringUtils.stripAccents(null)                = null\n      * </pre>\n      *\n      * @param input String to be stripped\n-     * @return String without accents on the text\n+     * @return input text with diacritics removed\n      *\n      * @since 3.0\n      */\n-    public static String stripAccents(String input) {\n+    // See also Lucene's ASCIIFoldingFilter (Lucene 2.9) that replaces accented characters by their unaccented equivalent (and uncommited bug fix: https://issues.apache.org/jira/browse/LUCENE-1343?focusedCommentId=12858907&page=com.atlassian.jira.plugin.system.issuetabpanels%3Acomment-tabpanel#action_12858907).\n+    public static String stripAccents(CharSequence input) {\n         if(input == null) {\n             return null;\n         }\n-        if(SystemUtils.isJavaVersionAtLeast(1.6f)) {\n-\n-            // String decomposed = Normalizer.normalize(input, Normalizer.Form.NFD);\n-\n-            // START of 1.5 reflection - in 1.6 use the line commented out above\n-            try {\n-                // get java.text.Normalizer.Form class\n-                Class<?> normalizerFormClass = ClassUtils.getClass(\"java.text.Normalizer$Form\", false);\n-\n-                // get Normlizer class\n-                Class<?> normalizerClass = ClassUtils.getClass(\"java.text.Normalizer\", false);\n-\n-                // get static method on Normalizer\n-                java.lang.reflect.Method method = normalizerClass.getMethod(\"normalize\", CharSequence.class, normalizerFormClass );\n-\n-                // get Normalizer.NFD field\n-                java.lang.reflect.Field nfd = normalizerFormClass.getField(\"NFD\");\n-\n-                // invoke method\n-                String decomposed = (String) method.invoke( null, input, nfd.get(null) );\n-                // END of 1.5 reflection\n-\n-                java.util.regex.Pattern accentPattern = java.util.regex.Pattern.compile(\"\\\\p{InCombiningDiacriticalMarks}+\");\n-                return accentPattern.matcher(decomposed).replaceAll(\"\");\n-            } catch(ClassNotFoundException cnfe) {\n-                throw new RuntimeException(\"ClassNotFoundException occurred during 1.6 backcompat code\", cnfe);\n-            } catch(NoSuchMethodException nsme) {\n-                throw new RuntimeException(\"NoSuchMethodException occurred during 1.6 backcompat code\", nsme);\n-            } catch(NoSuchFieldException nsfe) {\n-                throw new RuntimeException(\"NoSuchFieldException occurred during 1.6 backcompat code\", nsfe);\n-            } catch(IllegalAccessException iae) {\n-                throw new RuntimeException(\"IllegalAccessException occurred during 1.6 backcompat code\", iae);\n-            } catch(IllegalArgumentException iae) {\n-                throw new RuntimeException(\"IllegalArgumentException occurred during 1.6 backcompat code\", iae);\n-            } catch(java.lang.reflect.InvocationTargetException ite) {\n-                throw new RuntimeException(\"InvocationTargetException occurred during 1.6 backcompat code\", ite);\n-            } catch(SecurityException se) {\n-                throw new RuntimeException(\"SecurityException occurred during 1.6 backcompat code\", se);\n-            }\n-        } else {\n-            throw new UnsupportedOperationException(\"The stripAccents(String) method is not supported until Java 1.6\");\n+        try {\n+            String result = null;\n+            if (java6Available) {\n+                result = removeAccentsJava6(input);\n+            } else if (sunAvailable) {\n+                result = removeAccentsSUN(input);\n+            } else {\n+            \tthrow new UnsupportedOperationException(\"The stripAccents(CharSequence) method requires at least Java 1.6 or a SUN JVM\");\n+            }\n+            // Note that none of the above methods correctly remove ligatures...\n+            return result;\n+        } catch(IllegalArgumentException iae) {\n+            throw new RuntimeException(\"IllegalArgumentException occurred during 1.6 backcompat code\", iae);\n+        } catch(IllegalAccessException iae) {\n+            throw new RuntimeException(\"IllegalAccessException occurred during 1.6 backcompat code\", iae);\n+        } catch(InvocationTargetException ite) {\n+            throw new RuntimeException(\"InvocationTargetException occurred during 1.6 backcompat code\", ite);\n+        } catch(SecurityException se) {\n+            throw new RuntimeException(\"SecurityException occurred during 1.6 backcompat code\", se);\n+        }\n+    }\n+\n+    /**\n+     * Use {@code java.text.Normalizer#normalize(CharSequence, Normalizer.Form)}\n+     * (but be careful, this classe exists in Java 1.3, with an entirely different meaning!)\n+     * @param text\n+     */\n+    private static String removeAccentsJava6(CharSequence text) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {\n+        /*\n+        String decomposed = java.text.Normalizer.normalize(CharSequence, Normalizer.Form.NFD);\n+        return java6Pattern.matcher(decomposed).replaceAll(\"\");//$NON-NLS-1$\n+        */\n+        if (!java6Available || java6NormalizerFormNFD == null) {\n+            throw new IllegalStateException(\"java.text.Normalizer is not available\");\n+        }\n+        String result;\n+        result = (String) java6NormalizeMethod.invoke(null, new Object[] {text, java6NormalizerFormNFD});\n+        result = java6Pattern.matcher(result).replaceAll(\"\");//$NON-NLS-1$\n+        return result;\n+    }\n+\n+    /**\n+     * Use {@code sun.text.Normalizer#decompose(String, boolean, int)}\n+     */\n+    private static String removeAccentsSUN(CharSequence text) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {\n+        /*\n+        String decomposed = sun.text.Normalizer.decompose(text, false, 0);\n+        return sunPattern.matcher(decomposed).replaceAll(\"\");//$NON-NLS-1$\n+        */\n+        if (! sunAvailable) {\n+            throw new IllegalStateException(\"sun.text.Normalizer is not available\");\n+        }\n+        String result;\n+        result = (String) sunDecomposeMethod.invoke(null, new Object[] {text, Boolean.FALSE, Integer.valueOf(0)});\n+        result = sunPattern.matcher(result).replaceAll(\"\");//$NON-NLS-1$\n+        return result;\n+    }\n+\n+    // SUN internal, Java 1.3 -> Java 5\n+    private static boolean sunAvailable = false;\n+    private static Method  sunDecomposeMethod = null;\n+    private static final Pattern sunPattern = Pattern.compile(\"\\\\p{InCombiningDiacriticalMarks}+\");//$NON-NLS-1$\n+    // Java 6+\n+    private static boolean java6Available = false;\n+    private static Method  java6NormalizeMethod = null;\n+    private static Object  java6NormalizerFormNFD = null;\n+    private static final Pattern java6Pattern = sunPattern;\n+\n+    static {\n+        try {\n+            // java.text.Normalizer.normalize(CharSequence, Normalizer.Form.NFD);\n+            // Be careful not to get Java 1.3 java.text.Normalizer!\n+            Class<?> normalizerFormClass = Thread.currentThread().getContextClassLoader().loadClass(\"java.text.Normalizer$Form\");//$NON-NLS-1$\n+            java6NormalizerFormNFD = normalizerFormClass.getField(\"NFD\").get(null);//$NON-NLS-1$\n+            Class<?> normalizerClass = Thread.currentThread().getContextClassLoader().loadClass(\"java.text.Normalizer\");//$NON-NLS-1$\n+            java6NormalizeMethod = normalizerClass.getMethod(\"normalize\", new Class[] {CharSequence.class, normalizerFormClass});//$NON-NLS-1$\n+            java6Available = true;\n+        } catch (Exception e) {\n+            java6Available = false;\n+        }\n+\n+        try {\n+            // sun.text.Normalizer.decompose(text, false, 0);\n+            Class<?> normalizerClass = Thread.currentThread().getContextClassLoader().loadClass(\"sun.text.Normalizer\");//$NON-NLS-1$\n+            sunDecomposeMethod = normalizerClass.getMethod(\"decompose\", new Class[] {String.class, Boolean.TYPE, Integer.TYPE});//$NON-NLS-1$\n+            sunAvailable = true;\n+        } catch (Exception e) {\n+            sunAvailable = false;\n         }\n     }\n ", "timestamp": 1295236787, "metainfo": ""}