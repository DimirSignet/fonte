{"sha": "acf81b5d061d9a1cbb81da07afbc8dca6f6da2b9", "log": "Reapplying more of Oliver's checkstyle fixes from r1083211  ", "commit": "\n--- a/src/main/java/org/apache/commons/lang3/StringUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/StringUtils.java\n             } else if (sunAvailable) {\n                 result = removeAccentsSUN(input);\n             } else {\n-                throw new UnsupportedOperationException(\"The stripAccents(CharSequence) method requires at least Java 1.6 or a Sun JVM\");\n+                throw new UnsupportedOperationException(\"The stripAccents(CharSequence) method requires at least \"\n+                        + \"Java 1.6 or a Sun JVM\");\n             }\n             // Note that none of the above methods correctly remove ligatures...\n             return result;\n     /**\n      * Use {@code java.text.Normalizer#normalize(CharSequence, Normalizer.Form)}\n      * (but be careful, this classe exists in Java 1.3, with an entirely different meaning!)\n-     * @param text\n-     */\n-    private static String removeAccentsJava6(CharSequence text) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {\n+     *\n+     * @param text the text to be processed\n+     * @return the processed string\n+     * @throws IllegalAccessException may be thrown by a reflection call\n+     * @throws InvocationTargetException if a reflection call throws an exception\n+     * @throws IllegalStateException if the {@code Normalizer} class is not available\n+     */\n+    private static String removeAccentsJava6(CharSequence text)\n+        throws IllegalAccessException, InvocationTargetException {\n         /*\n         String decomposed = java.text.Normalizer.normalize(CharSequence, Normalizer.Form.NFD);\n         return java6Pattern.matcher(decomposed).replaceAll(\"\");//$NON-NLS-1$\n \n     /**\n      * Use {@code sun.text.Normalizer#decompose(String, boolean, int)}\n-     */\n-    private static String removeAccentsSUN(CharSequence text) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {\n+     *\n+     * @param text the text to be processed\n+     * @return the processed string\n+     * @throws IllegalAccessException may be thrown by a reflection call\n+     * @throws InvocationTargetException if a reflection call throws an exception\n+     * @throws IllegalStateException if the {@code Normalizer} class is not available\n+     */\n+    private static String removeAccentsSUN(CharSequence text)\n+        throws IllegalAccessException, InvocationTargetException {\n         /*\n         String decomposed = sun.text.Normalizer.decompose(text, false, 0);\n         return sunPattern.matcher(decomposed).replaceAll(\"\");//$NON-NLS-1$\n         try {\n             // java.text.Normalizer.normalize(CharSequence, Normalizer.Form.NFD);\n             // Be careful not to get Java 1.3 java.text.Normalizer!\n-            Class<?> normalizerFormClass = Thread.currentThread().getContextClassLoader().loadClass(\"java.text.Normalizer$Form\");//$NON-NLS-1$\n+            Class<?> normalizerFormClass = Thread.currentThread().getContextClassLoader()\n+                .loadClass(\"java.text.Normalizer$Form\");//$NON-NLS-1$\n             java6NormalizerFormNFD = normalizerFormClass.getField(\"NFD\").get(null);//$NON-NLS-1$\n-            Class<?> normalizerClass = Thread.currentThread().getContextClassLoader().loadClass(\"java.text.Normalizer\");//$NON-NLS-1$\n-            java6NormalizeMethod = normalizerClass.getMethod(\"normalize\", new Class[] {CharSequence.class, normalizerFormClass});//$NON-NLS-1$\n+            Class<?> normalizerClass = Thread.currentThread().getContextClassLoader()\n+                .loadClass(\"java.text.Normalizer\");//$NON-NLS-1$\n+            java6NormalizeMethod = normalizerClass.getMethod(\"normalize\",\n+                    new Class[] {CharSequence.class, normalizerFormClass});//$NON-NLS-1$\n             java6Available = true;\n         } catch (ClassNotFoundException e) {\n             java6Available = false;\n \n         try {\n             // sun.text.Normalizer.decompose(text, false, 0);\n-            Class<?> normalizerClass = Thread.currentThread().getContextClassLoader().loadClass(\"sun.text.Normalizer\");//$NON-NLS-1$\n-            sunDecomposeMethod = normalizerClass.getMethod(\"decompose\", new Class[] {String.class, Boolean.TYPE, Integer.TYPE});//$NON-NLS-1$\n+            Class<?> normalizerClass = Thread.currentThread().getContextClassLoader()\n+                .loadClass(\"sun.text.Normalizer\");//$NON-NLS-1$\n+            sunDecomposeMethod = normalizerClass.getMethod(\"decompose\",\n+                    new Class[] {String.class, Boolean.TYPE, Integer.TYPE});//$NON-NLS-1$\n             sunAvailable = true;\n         } catch (ClassNotFoundException e) {\n             sunAvailable = false;\n      * @param cs2  the second CharSequence, may be null\n      * @return the index where cs1 and cs2 begin to differ; -1 if they are equal\n      * @since 2.0\n-     * @since 3.0 Changed signature from indexOfDifference(String, String) to indexOfDifference(CharSequence, CharSequence)\n+     * @since 3.0 Changed signature from indexOfDifference(String, String) to\n+     * indexOfDifference(CharSequence, CharSequence)\n      */\n     public static int indexOfDifference(CharSequence cs1, CharSequence cs2) {\n         if (cs1 == cs2) {\n      * @param t  the second String, must not be null\n      * @return result distance\n      * @throws IllegalArgumentException if either String input {@code null}\n-     * @since 3.0 Changed signature from getLevenshteinDistance(String, String) to getLevenshteinDistance(CharSequence, CharSequence)\n+     * @since 3.0 Changed signature from getLevenshteinDistance(String, String) to\n+     * getLevenshteinDistance(CharSequence, CharSequence)\n      */\n     public static int getLevenshteinDistance(CharSequence s, CharSequence t) {\n         if (s == null || t == null) {\n     /**\n      * <p>Returns a new {@code CharSequence} that is a subsequence of this\n      * sequence starting with the {@code char} value at the specified index.</p>\n-     * \n+     *\n      * <p>This provides the {@code CharSequence} equivalent to {@link String#substring(int)}.\n      * The length (in {@code char}) of the returned sequence is {@code length() - start},\n      * so if {@code start == end} then an empty sequence is returned.</p>", "timestamp": 1302150875, "metainfo": ""}