{"sha": "aa3eb57d3b8f8f3c89870a970155b33355668282", "log": "Convert to Java 5 enhanced loops.   ", "commit": "\n--- a/src/main/java/org/apache/commons/lang3/ObjectUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/ObjectUtils.java\n     public static int hashCodeMulti(Object... objects) {\n         int hash = 1;\n         if (objects != null) {\n-            for (int i = 0; i < objects.length; i++) {\n-                hash = hash * 31 + ObjectUtils.hashCode(objects[i]);\n+            for (Object object : objects) {\n+                hash = hash * 31 + ObjectUtils.hashCode(object);\n             }\n         }\n         return hash;\n--- a/src/main/java/org/apache/commons/lang3/StringUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/StringUtils.java\n         if (isEmpty(string) || ArrayUtils.isEmpty(searchStrings)) {\n             return false;\n         }\n-        for (int i = 0; i < searchStrings.length; i++) {\n-            CharSequence searchString = searchStrings[i];\n+        for (CharSequence searchString : searchStrings) {\n             if (StringUtils.startsWith(string, searchString)) {\n                 return true;\n             }\n         if (isEmpty(string) || ArrayUtils.isEmpty(searchStrings)) {\n             return false;\n         }\n-        for (int i = 0; i < searchStrings.length; i++) {\n-            CharSequence searchString = searchStrings[i];\n+        for (CharSequence searchString : searchStrings) {\n             if (StringUtils.endsWith(string, searchString)) {\n                 return true;\n             }\n--- a/src/main/java/org/apache/commons/lang3/builder/HashCodeBuilder.java\n+++ b/src/main/java/org/apache/commons/lang3/builder/HashCodeBuilder.java\n         if (array == null) {\n             iTotal = iTotal * iConstant;\n         } else {\n-            for (int i = 0; i < array.length; i++) {\n-                append(array[i]);\n+            for (boolean element : array) {\n+                append(element);\n             }\n         }\n         return this;\n         if (array == null) {\n             iTotal = iTotal * iConstant;\n         } else {\n-            for (int i = 0; i < array.length; i++) {\n-                append(array[i]);\n+            for (byte element : array) {\n+                append(element);\n             }\n         }\n         return this;\n         if (array == null) {\n             iTotal = iTotal * iConstant;\n         } else {\n-            for (int i = 0; i < array.length; i++) {\n-                append(array[i]);\n+            for (char element : array) {\n+                append(element);\n             }\n         }\n         return this;\n         if (array == null) {\n             iTotal = iTotal * iConstant;\n         } else {\n-            for (int i = 0; i < array.length; i++) {\n-                append(array[i]);\n+            for (double element : array) {\n+                append(element);\n             }\n         }\n         return this;\n         if (array == null) {\n             iTotal = iTotal * iConstant;\n         } else {\n-            for (int i = 0; i < array.length; i++) {\n-                append(array[i]);\n+            for (float element : array) {\n+                append(element);\n             }\n         }\n         return this;\n         if (array == null) {\n             iTotal = iTotal * iConstant;\n         } else {\n-            for (int i = 0; i < array.length; i++) {\n-                append(array[i]);\n+            for (int element : array) {\n+                append(element);\n             }\n         }\n         return this;\n         if (array == null) {\n             iTotal = iTotal * iConstant;\n         } else {\n-            for (int i = 0; i < array.length; i++) {\n-                append(array[i]);\n+            for (long element : array) {\n+                append(element);\n             }\n         }\n         return this;\n         if (array == null) {\n             iTotal = iTotal * iConstant;\n         } else {\n-            for (int i = 0; i < array.length; i++) {\n-                append(array[i]);\n+            for (Object element : array) {\n+                append(element);\n             }\n         }\n         return this;\n         if (array == null) {\n             iTotal = iTotal * iConstant;\n         } else {\n-            for (int i = 0; i < array.length; i++) {\n-                append(array[i]);\n+            for (short element : array) {\n+                append(element);\n             }\n         }\n         return this;\n--- a/src/main/java/org/apache/commons/lang3/exception/ExceptionUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/exception/ExceptionUtils.java\n             methodNames = CAUSE_METHOD_NAMES;\n         }\n \n-        for (int i = 0; i < methodNames.length; i++) {\n-            String methodName = methodNames[i];\n+        for (String methodName : methodNames) {\n             if (methodName != null) {\n                 Throwable cause = getCauseUsingMethodName(throwable, methodName);\n                 if (cause != null) {\n             throw new IllegalArgumentException(\"The PrintStream must not be null\");\n         }\n         String trace[] = getRootCauseStackTrace(throwable);\n-        for (int i = 0; i < trace.length; i++) {\n-            stream.println(trace[i]);\n+        for (String element : trace) {\n+            stream.println(element);\n         }\n         stream.flush();\n     }\n             throw new IllegalArgumentException(\"The PrintWriter must not be null\");\n         }\n         String trace[] = getRootCauseStackTrace(throwable);\n-        for (int i = 0; i < trace.length; i++) {\n-            writer.println(trace[i]);\n+        for (String element : trace) {\n+            writer.println(element);\n         }\n         writer.flush();\n     }\n--- a/src/main/java/org/apache/commons/lang3/reflect/FieldUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/reflect/FieldUtils.java\n \n import java.lang.reflect.Field;\n import java.lang.reflect.Modifier;\n-import java.util.Iterator;\n \n import org.apache.commons.lang3.ClassUtils;\n \n         // incase there is a public supersuperclass field hidden by a private/package\n         // superclass field.\n         Field match = null;\n-        for (Iterator<Class<?>> intf = ClassUtils.getAllInterfaces(cls).iterator(); intf\n-                .hasNext();) {\n+        for (Class<?> class1 : ClassUtils.getAllInterfaces(cls)) {\n             try {\n-                Field test = ((Class<?>) intf.next()).getField(fieldName);\n+                Field test = ((Class<?>) class1).getField(fieldName);\n                 if (match != null) {\n-                    throw new IllegalArgumentException(\n-                            \"Reference to field \"\n-                                    + fieldName\n-                                    + \" is ambiguous relative to \"\n-                                    + cls\n-                                    + \"; a matching field exists on two or more implemented interfaces.\");\n+                    throw new IllegalArgumentException(\"Reference to field \" + fieldName + \" is ambiguous relative to \" + cls\n+                            + \"; a matching field exists on two or more implemented interfaces.\");\n                 }\n                 match = test;\n             } catch (NoSuchFieldException ex) { // NOPMD\n--- a/src/main/java/org/apache/commons/lang3/reflect/MethodUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/reflect/MethodUtils.java\n         // search through all methods\n         Method bestMatch = null;\n         Method[] methods = cls.getMethods();\n-        for (int i = 0, size = methods.length; i < size; i++) {\n-            if (methods[i].getName().equals(methodName)) {\n+        for (Method method : methods) {\n+            if (method.getName().equals(methodName)) {\n                 // compare parameters\n-                if (ClassUtils.isAssignable(parameterTypes, methods[i]\n+                if (ClassUtils.isAssignable(parameterTypes, method\n                         .getParameterTypes(), true)) {\n                     // get accessible version of method\n-                    Method accessibleMethod = getAccessibleMethod(methods[i]);\n+                    Method accessibleMethod = getAccessibleMethod(method);\n                     if (accessibleMethod != null) {\n                         if (bestMatch == null\n                                 || MemberUtils.compareParameterTypes(\n--- a/src/main/java/org/apache/commons/lang3/reflect/TypeUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/reflect/TypeUtils.java\n             Type genericInterface = null;\n \n             // find the interface closest to the super class\n-            for (int i = 0; i < interfaceTypes.length; i++) {\n-                Type midType = interfaceTypes[i];\n+            for (Type midType : interfaceTypes) {\n                 Class<?> midClass = null;\n \n                 if (midType instanceof ParameterizedType) {\n--- a/src/main/java/org/apache/commons/lang3/text/ExtendedMessageFormat.java\n+++ b/src/main/java/org/apache/commons/lang3/text/ExtendedMessageFormat.java\n         if (coll == null || coll.size() == 0) {\n             return false;\n         }\n-        for (Iterator<?> iter = coll.iterator(); iter.hasNext();) {\n-            if (iter.next() != null) {\n+        for (Object name : coll) {\n+            if (name != null) {\n                 return true;\n             }\n         }\n--- a/src/main/java/org/apache/commons/lang3/text/StrBuilder.java\n+++ b/src/main/java/org/apache/commons/lang3/text/StrBuilder.java\n      */\n     public StrBuilder appendAll(Object[] array) {\n         if (array != null && array.length > 0) {\n-            for (int i = 0; i < array.length; i++) {\n-                append(array[i]);\n+            for (Object element : array) {\n+                append(element);\n             }\n         }\n         return this;\n--- a/src/main/java/org/apache/commons/lang3/text/WordUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/text/WordUtils.java\n         if (delimiters == null) {\n             return Character.isWhitespace(ch);\n         }\n-        for (int i = 0, isize = delimiters.length; i < isize; i++) {\n-            if (ch == delimiters[i]) {\n+        for (char delimiter : delimiters) {\n+            if (ch == delimiter) {\n                 return true;\n             }\n         }\n--- a/src/main/java/org/apache/commons/lang3/time/DateUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/time/DateUtils.java\n         SimpleDateFormat parser = new SimpleDateFormat();\n         parser.setLenient(lenient);\n         ParsePosition pos = new ParsePosition(0);\n-        for (int i = 0; i < parsePatterns.length; i++) {\n-\n-            String pattern = parsePatterns[i];\n+        for (String parsePattern : parsePatterns) {\n+\n+            String pattern = parsePattern;\n \n             // LANG-530 - need to make sure 'ZZ' output doesn't get passed to SimpleDateFormat\n-            if (parsePatterns[i].endsWith(\"ZZ\")) {\n+            if (parsePattern.endsWith(\"ZZ\")) {\n                 pattern = pattern.substring(0, pattern.length() - 1);\n             }\n             \n \n             String str2 = str;\n             // LANG-530 - need to make sure 'ZZ' output doesn't hit SimpleDateFormat as it will ParseException\n-            if (parsePatterns[i].endsWith(\"ZZ\")) {\n+            if (parsePattern.endsWith(\"ZZ\")) {\n                 str2 = str.replaceAll(\"([-+][0-9][0-9]):([0-9][0-9])$\", \"$1$2\"); \n             }\n \n         // ----------------- Fix for LANG-59 ----------------------- END ----------------\n \n         boolean roundUp = false;\n-        for (int i = 0; i < fields.length; i++) {\n-            for (int j = 0; j < fields[i].length; j++) {\n-                if (fields[i][j] == field) {\n+        for (int[] aField : fields) {\n+            for (int j = 0; j < aField.length; j++) {\n+                if (aField[j] == field) {\n                     //This is our field... we stop looping\n                     if (modType == MODIFY_CEILING || (modType == MODIFY_ROUND && roundUp)) {\n                         if (field == DateUtils.SEMI_MONTH) {\n                         } else {\n                             //We need at add one to this field since the\n                             //  last number causes us to round up\n-                            val.add(fields[i][0], 1);\n+                            val.add(aField[0], 1);\n                         }\n                     }\n                     return;\n             //These are special types of fields that require different rounding rules\n             switch (field) {\n                 case DateUtils.SEMI_MONTH:\n-                    if (fields[i][0] == Calendar.DATE) {\n+                    if (aField[0] == Calendar.DATE) {\n                         //If we're going to drop the DATE field's value,\n                         //  we want to do this our own way.\n                         //We need to subtrace 1 since the date has a minimum of 1\n                     }\n                     break;\n                 case Calendar.AM_PM:\n-                    if (fields[i][0] == Calendar.HOUR_OF_DAY) {\n+                    if (aField[0] == Calendar.HOUR_OF_DAY) {\n                         //If we're going to drop the HOUR field's value,\n                         //  we want to do this our own way.\n                         offset = val.get(Calendar.HOUR_OF_DAY);\n                     break;\n             }\n             if (!offsetSet) {\n-                int min = val.getActualMinimum(fields[i][0]);\n-                int max = val.getActualMaximum(fields[i][0]);\n+                int min = val.getActualMinimum(aField[0]);\n+                int max = val.getActualMaximum(aField[0]);\n                 //Calculate the offset from the minimum allowed value\n-                offset = val.get(fields[i][0]) - min;\n+                offset = val.get(aField[0]) - min;\n                 //Set roundUp if this is more than half way between the minimum and maximum\n                 roundUp = offset > ((max - min) / 2);\n             }\n             //We need to remove this field\n             if (offset != 0) {\n-                val.set(fields[i][0], val.get(fields[i][0]) - offset);\n+                val.set(aField[0], val.get(aField[0]) - offset);\n             }\n         }\n         throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n--- a/src/test/java/org/apache/commons/lang3/CharUtilsPerfRun.java\n+++ b/src/test/java/org/apache/commons/lang3/CharUtilsPerfRun.java\n     private int run_CharSet(int loopCount) {\n         int t = 0;\n         for (int i = 0; i < loopCount; i++) {\n-            for (int j = 0; j < CHAR_SAMPLES.length; j++) {\n-                char ch = CHAR_SAMPLES[j];\n+            for (char ch : CHAR_SAMPLES) {\n                 boolean b = CharSet.ASCII_NUMERIC.contains(ch);\n                 t += b ? 1 : 0;\n             }\n     private int run_CharUtils_isAsciiNumeric(int loopCount) {\n         int t = 0;\n         for (int i = 0; i < loopCount; i++) {\n-            for (int j = 0; j < CHAR_SAMPLES.length; j++) {\n-                char ch = CHAR_SAMPLES[j];\n+            for (char ch : CHAR_SAMPLES) {\n                 boolean b = CharUtils.isAsciiNumeric(ch);\n                 t += b ? 1 : 0;\n             }\n     private int run_inlined_CharUtils_isAsciiNumeric(int loopCount) {\n         int t = 0;\n         for (int i = 0; i < loopCount; i++) {\n-            for (int j = 0; j < CHAR_SAMPLES.length; j++) {\n-                char ch = CHAR_SAMPLES[j];\n+            for (char ch : CHAR_SAMPLES) {\n                 boolean b = (ch >= '0' && ch <= '9');\n                 t += b ? 1 : 0;\n             }\n--- a/src/test/java/org/apache/commons/lang3/ClassUtilsTest.java\n+++ b/src/test/java/org/apache/commons/lang3/ClassUtilsTest.java\n  */\n package org.apache.commons.lang3;\n \n+import static org.apache.commons.lang3.JavaVersion.JAVA_1_5;\n+\n import java.lang.reflect.Constructor;\n import java.lang.reflect.Method;\n import java.lang.reflect.Modifier;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n-\n-import static org.apache.commons.lang3.JavaVersion.*;\n \n import junit.framework.TestCase;\n \n                 Boolean.TYPE, Byte.TYPE, Character.TYPE, Short.TYPE,\n                 Integer.TYPE, Long.TYPE, Float.TYPE, Double.TYPE\n         };\n-        for (int i = 0; i < primitives.length; i++) {\n-            Class<?> wrapperCls = ClassUtils.primitiveToWrapper(primitives[i]);\n+        for (Class<?> primitive : primitives) {\n+            Class<?> wrapperCls = ClassUtils.primitiveToWrapper(primitive);\n             assertFalse(\"Still primitive\", wrapperCls.isPrimitive());\n-            assertEquals(wrapperCls + \" -> \" + primitives[i], primitives[i],\n+            assertEquals(wrapperCls + \" -> \" + primitive, primitive,\n                     ClassUtils.wrapperToPrimitive(wrapperCls));\n         }\n     }\n--- a/src/test/java/org/apache/commons/lang3/LocaleUtilsTest.java\n+++ b/src/test/java/org/apache/commons/lang3/LocaleUtilsTest.java\n  */\n package org.apache.commons.lang3;\n \n+import static org.apache.commons.lang3.JavaVersion.JAVA_1_4;\n+\n import java.lang.reflect.Constructor;\n import java.lang.reflect.Modifier;\n import java.util.Arrays;\n import java.util.List;\n import java.util.Locale;\n import java.util.Set;\n-\n-import static org.apache.commons.lang3.JavaVersion.*;\n \n import junit.framework.TestCase;\n \n         assertNotNull(list);\n         assertSame(list, list2);\n         //search through langauges\n-        for (int i = 0; i < languages.length; i++) {\n+        for (String language : languages) {\n             Iterator<Locale> iterator = list.iterator();\n             boolean found = false;\n             // see if it was returned by the set\n                 assertTrue(locale.getVariant() == null\n                         || locale.getVariant().length() == 0);\n                 assertEquals(country, locale.getCountry());\n-                if (languages[i].equals(locale.getLanguage())) {\n+                if (language.equals(locale.getLanguage())) {\n                     found = true;\n                     break;\n                 }\n             }\n             if (!found) {\n-                fail(\"Cound not find language: \" + languages[i]\n+                fail(\"Cound not find language: \" + language\n                         + \" for country: \" + country);\n             }\n         }\n         assertNotNull(list);\n         assertSame(list, list2);\n         //search through langauges\n-        for (int i = 0; i < countries.length; i++) {\n+        for (String countrie : countries) {\n             Iterator<Locale> iterator = list.iterator();\n             boolean found = false;\n             // see if it was returned by the set\n                 assertTrue(locale.getVariant() == null\n                         || locale.getVariant().length() == 0);\n                 assertEquals(language, locale.getLanguage());\n-                if (countries[i].equals(locale.getCountry())) {\n+                if (countrie.equals(locale.getCountry())) {\n                     found = true;\n                     break;\n                 }\n             }\n             if (!found) {\n-                fail(\"Cound not find language: \" + countries[i]\n+                fail(\"Cound not find language: \" + countrie\n                         + \" for country: \" + language);\n             }\n         }\n--- a/src/test/java/org/apache/commons/lang3/StringUtilsEqualsIndexOfTest.java\n+++ b/src/test/java/org/apache/commons/lang3/StringUtilsEqualsIndexOfTest.java\n         };\n \n         try {\n-            for (int i = 0; i < locales.length; i++) {\n-                Locale.setDefault(locales[i]);\n+            for (Locale locale : locales) {\n+                Locale.setDefault(locale);\n                 for (int j = 0; j < tdata.length; j++) {\n                     assertTrue(Locale.getDefault() + \": \" + j + \" \" + tdata[j][0] + \" \" + tdata[j][1], StringUtils\n                             .containsIgnoreCase(tdata[j][0], tdata[j][1]));\n--- a/src/test/java/org/apache/commons/lang3/StringUtilsStartsEndsWithTest.java\n+++ b/src/test/java/org/apache/commons/lang3/StringUtilsStartsEndsWithTest.java\n package org.apache.commons.lang3;\n \n import junit.framework.TestCase;\n+\n import org.apache.commons.lang3.text.StrBuilder;\n \n /**\n--- a/src/test/java/org/apache/commons/lang3/StringUtilsTest.java\n+++ b/src/test/java/org/apache/commons/lang3/StringUtilsTest.java\n             { \"\", \"\" },\n             { \"a\", \"\" },\n         };\n-        for (int i = 0; i < chopCases.length; i++) {\n-            String original = chopCases[i][0];\n-            String expectedResult = chopCases[i][1];\n+        for (String[] chopCase : chopCases) {\n+            String original = chopCase[0];\n+            String expectedResult = chopCase[1];\n             assertEquals(\"chop(String) failed\",\n                     expectedResult, StringUtils.chop(original));\n         }\n             { null, null },\n             { FOO_UNCAP + \"\\n\\r\", FOO_UNCAP + \"\\n\"}\n         };\n-        for (int i = 0; i < chompCases.length; i++) {\n-            String original = chompCases[i][0];\n-            String expectedResult = chompCases[i][1];\n+        for (String[] chompCase : chompCases) {\n+            String original = chompCase[0];\n+            String expectedResult = chompCase[1];\n             assertEquals(\"chomp(String) failed\",\n                     expectedResult, StringUtils.chomp(original));\n         }\n     public void testStringUtilsCharSequenceContract() {\n         Class<StringUtils> c = StringUtils.class;\n         Method[] methods = c.getMethods();\n-        for (int i=0; i<methods.length; i++) {\n-            Method m = methods[i];\n+        for (Method m : methods) {\n             if (m.getReturnType() == String.class || m.getReturnType() == String[].class) {\n                 // Assume this is mutable and ensure the first parameter is not CharSequence.\n                 // It may be String or it may be something else (String[], Object, Object[]) so \n--- a/src/test/java/org/apache/commons/lang3/SystemUtilsTest.java\n+++ b/src/test/java/org/apache/commons/lang3/SystemUtilsTest.java\n \n package org.apache.commons.lang3;\n \n+import static org.apache.commons.lang3.JavaVersion.JAVA_1_4;\n+\n import java.io.File;\n import java.lang.reflect.Constructor;\n import java.lang.reflect.Modifier;\n \n import junit.framework.Assert;\n import junit.framework.TestCase;\n-\n-import static org.apache.commons.lang3.JavaVersion.*;\n \n /**\n  * Unit tests {@link org.apache.commons.lang3.SystemUtils}.\n--- a/src/test/java/org/apache/commons/lang3/event/EventListenerSupportTest.java\n+++ b/src/test/java/org/apache/commons/lang3/event/EventListenerSupportTest.java\n \n package org.apache.commons.lang3.event;\n \n+import java.beans.PropertyChangeEvent;\n import java.beans.PropertyVetoException;\n-import java.beans.PropertyChangeEvent;\n import java.beans.VetoableChangeListener;\n import java.io.ByteArrayInputStream;\n import java.io.ByteArrayOutputStream;\n--- a/src/test/java/org/apache/commons/lang3/event/EventUtilsTest.java\n+++ b/src/test/java/org/apache/commons/lang3/event/EventUtilsTest.java\n  */\n package org.apache.commons.lang3.event;\n \n-import javax.naming.event.ObjectChangeListener;\n import java.beans.PropertyChangeEvent;\n import java.beans.PropertyChangeListener;\n import java.beans.VetoableChangeListener;\n import java.util.Map;\n import java.util.TreeMap;\n \n+import javax.naming.event.ObjectChangeListener;\n+\n import junit.framework.TestCase;\n \n /**\n--- a/src/test/java/org/apache/commons/lang3/exception/AbstractExceptionContextTest.java\n+++ b/src/test/java/org/apache/commons/lang3/exception/AbstractExceptionContextTest.java\n import java.util.List;\n import java.util.Set;\n \n+import junit.framework.TestCase;\n+\n import org.apache.commons.lang3.SerializationUtils;\n import org.apache.commons.lang3.tuple.Pair;\n-\n-import junit.framework.TestCase;\n \n \n /**\n--- a/src/test/java/org/apache/commons/lang3/exception/ExceptionUtilsTest.java\n+++ b/src/test/java/org/apache/commons/lang3/exception/ExceptionUtilsTest.java\n         Throwable withCause = createExceptionWithCause();\n         String[] stackTrace = ExceptionUtils.getRootCauseStackTrace(withCause);\n         boolean match = false;\n-        for (int i = 0; i < stackTrace.length; i++) {\n-            if (stackTrace[i].startsWith(ExceptionUtils.WRAPPED_MARKER)) {\n+        for (String element : stackTrace) {\n+            if (element.startsWith(ExceptionUtils.WRAPPED_MARKER)) {\n                 match = true;\n                 break;\n             }\n         \n         stackTrace = ExceptionUtils.getRootCauseStackTrace(withoutCause);\n         match = false;\n-        for (int i = 0; i < stackTrace.length; i++) {\n-            if (stackTrace[i].startsWith(ExceptionUtils.WRAPPED_MARKER)) {\n+        for (String element : stackTrace) {\n+            if (element.startsWith(ExceptionUtils.WRAPPED_MARKER)) {\n                 match = true;\n                 break;\n             }\n--- a/src/test/java/org/apache/commons/lang3/math/NumberUtilsTest.java\n+++ b/src/test/java/org/apache/commons/lang3/math/NumberUtilsTest.java\n  */\n package org.apache.commons.lang3.math;\n \n+import static org.apache.commons.lang3.JavaVersion.JAVA_1_3;\n+\n import java.lang.reflect.Constructor;\n import java.lang.reflect.Modifier;\n import java.math.BigDecimal;\n \n import junit.framework.TestCase;\n \n-import static org.apache.commons.lang3.JavaVersion.*;\n import org.apache.commons.lang3.SystemUtils;\n \n /**\n--- a/src/test/java/org/apache/commons/lang3/reflect/MethodUtilsTest.java\n+++ b/src/test/java/org/apache/commons/lang3/reflect/MethodUtilsTest.java\n     public void testGetAccessibleInterfaceMethod() throws Exception {\n \n         Class<?>[][] p = { ArrayUtils.EMPTY_CLASS_ARRAY, null };\n-        for (int i = 0; i < p.length; i++) {\n-            Method method = TestMutable.class.getMethod(\"getValue\", p[i]);\n+        for (Class<?>[] element : p) {\n+            Method method = TestMutable.class.getMethod(\"getValue\", element);\n             Method accessibleMethod = MethodUtils.getAccessibleMethod(method);\n             assertNotSame(accessibleMethod, method);\n             assertSame(Mutable.class, accessibleMethod.getDeclaringClass());\n     public void testGetAccessibleInterfaceMethodFromDescription()\n             throws Exception {\n         Class<?>[][] p = { ArrayUtils.EMPTY_CLASS_ARRAY, null };\n-        for (int i = 0; i < p.length; i++) {\n+        for (Class<?>[] element : p) {\n             Method accessibleMethod = MethodUtils.getAccessibleMethod(\n-                    TestMutable.class, \"getValue\", p[i]);\n+                    TestMutable.class, \"getValue\", element);\n             assertSame(Mutable.class, accessibleMethod.getDeclaringClass());\n         }\n     }\n--- a/src/test/java/org/apache/commons/lang3/text/ExtendedMessageFormatTest.java\n+++ b/src/test/java/org/apache/commons/lang3/text/ExtendedMessageFormatTest.java\n  */\n package org.apache.commons.lang3.text;\n \n+import static org.apache.commons.lang3.JavaVersion.JAVA_1_4;\n+\n import java.text.ChoiceFormat;\n import java.text.DateFormat;\n import java.text.FieldPosition;\n import java.util.Collections;\n import java.util.HashMap;\n import java.util.HashSet;\n-import java.util.Iterator;\n import java.util.Locale;\n import java.util.Map;\n \n import junit.framework.TestCase;\n \n-import static org.apache.commons.lang3.JavaVersion.*;\n import org.apache.commons.lang3.SystemUtils;\n \n /**\n         testLocales.retainAll(Arrays.asList(NumberFormat.getAvailableLocales()));\n         testLocales.add(null);\n \n-        for (Iterator<Locale> l = testLocales.iterator(); l.hasNext();) {\n-            Locale locale = l.next();\n+        for (Locale locale : testLocales) {\n             MessageFormat builtins = createMessageFormat(builtinsPattern, locale);\n             String expectedPattern = extendedPattern + builtins.toPattern();\n             DateFormat df = null;\n         Locale[] availableLocales = ChoiceFormat.getAvailableLocales();\n \n         choicePattern = \"{0,choice,1#One|2#Two|3#Many {0,number}}\";\n-        for (int i = 0; i < values.length; i++) {\n-            checkBuiltInFormat(values[i] + \": \" + choicePattern, new Object[] {values[i]}, availableLocales);\n+        for (Object value : values) {\n+            checkBuiltInFormat(value + \": \" + choicePattern, new Object[] {value}, availableLocales);\n         }\n \n         choicePattern = \"{0,choice,1#''One''|2#\\\"Two\\\"|3#''{Many}'' {0,number}}\";\n-        for (int i = 0; i < values.length; i++) {\n-            checkBuiltInFormat(values[i] + \": \" + choicePattern, new Object[] {values[i]}, availableLocales);\n+        for (Object value : values) {\n+            checkBuiltInFormat(value + \": \" + choicePattern, new Object[] {value}, availableLocales);\n         }\n     }\n \n      */\n     private void checkBuiltInFormat(String pattern, Map<String, ?> registry, Object[] args, Locale[] locales) {\n         checkBuiltInFormat(pattern, registry, args, (Locale) null);\n-        for (int i = 0; i < locales.length; i++) {\n-            checkBuiltInFormat(pattern, registry, args, locales[i]);\n+        for (Locale locale : locales) {\n+            checkBuiltInFormat(pattern, registry, args, locale);\n         }\n     }\n \n--- a/src/test/java/org/apache/commons/lang3/time/DateUtilsTest.java\n+++ b/src/test/java/org/apache/commons/lang3/time/DateUtilsTest.java\n  */\n package org.apache.commons.lang3.time;\n \n+import static org.apache.commons.lang3.JavaVersion.JAVA_1_4;\n+\n import java.lang.reflect.Constructor;\n import java.lang.reflect.Modifier;\n import java.text.DateFormat;\n import junit.framework.AssertionFailedError;\n import junit.framework.TestCase;\n \n-import static org.apache.commons.lang3.JavaVersion.*;\n import org.apache.commons.lang3.SystemUtils;\n \n /**", "timestamp": 1310322376, "metainfo": ""}