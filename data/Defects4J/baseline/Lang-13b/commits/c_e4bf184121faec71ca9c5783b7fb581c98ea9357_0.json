{"sha": "e4bf184121faec71ca9c5783b7fb581c98ea9357", "log": "Copying from Collections to Lang  ", "commit": "\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/lang3/compare/AbstractTestObject.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.OutputStream;\n+import java.io.Serializable;\n+\n+/**\n+ * Abstract test class for {@link java.lang.Object} methods and contracts.\n+ * <p>\n+ * To use, simply extend this class, and implement\n+ * the {@link #makeObject()} method.\n+ * <p>\n+ * If your {@link Object} fails one of these tests by design,\n+ * you may still use this base set of cases.  Simply override the\n+ * test case (method) your {@link Object} fails.\n+ *\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Rodney Waldhoff\n+ * @author Stephen Colebourne\n+ * @author Anonymous\n+ */\n+public abstract class AbstractTestObject extends BulkTest {\n+\n+    /** Current major release for Collections */\n+    public static final int COLLECTIONS_MAJOR_VERSION = 3;\n+    \n+    /**\n+     * JUnit constructor.\n+     * \n+     * @param testName  the test class name\n+     */\n+    public AbstractTestObject(String testName) {\n+        super(testName);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Implement this method to return the object to test.\n+     * \n+     * @return the object to test\n+     */\n+    public abstract Object makeObject();\n+\n+    /**\n+     * Override this method if a subclass is testing an object\n+     * that cannot serialize an \"empty\" Collection.\n+     * (e.g. Comparators have no contents)\n+     * \n+     * @return true\n+     */\n+    public boolean supportsEmptyCollections() {\n+        return true;\n+    }\n+\n+    /**\n+     * Override this method if a subclass is testing an object\n+     * that cannot serialize a \"full\" Collection.\n+     * (e.g. Comparators have no contents)\n+     * \n+     * @return true\n+     */\n+    public boolean supportsFullCollections() {\n+        return true;\n+    }\n+\n+    /**\n+     * Is serialization testing supported.\n+     * Default is true.\n+     */\n+    public boolean isTestSerialization() {\n+        return true;\n+    }\n+\n+    /**\n+     * Returns true to indicate that the collection supports equals() comparisons.\n+     * This implementation returns true;\n+     */\n+    public boolean isEqualsCheckable() {\n+        return true;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testObjectEqualsSelf() {\n+        Object obj = makeObject();\n+        assertEquals(\"A Object should equal itself\", obj, obj);\n+    }\n+\n+    public void testEqualsNull() {\n+        Object obj = makeObject();\n+        assertEquals(false, obj.equals(null)); // make sure this doesn't throw NPE either\n+    }\n+\n+    public void testObjectHashCodeEqualsSelfHashCode() {\n+        Object obj = makeObject();\n+        assertEquals(\"hashCode should be repeatable\", obj.hashCode(), obj.hashCode());\n+    }\n+\n+    public void testObjectHashCodeEqualsContract() {\n+        Object obj1 = makeObject();\n+        if (obj1.equals(obj1)) {\n+            assertEquals(\n+                \"[1] When two objects are equal, their hashCodes should be also.\",\n+                obj1.hashCode(), obj1.hashCode());\n+        }\n+        Object obj2 = makeObject();\n+        if (obj1.equals(obj2)) {\n+            assertEquals(\n+                \"[2] When two objects are equal, their hashCodes should be also.\",\n+                obj1.hashCode(), obj2.hashCode());\n+            assertTrue(\n+                \"When obj1.equals(obj2) is true, then obj2.equals(obj1) should also be true\",\n+                obj2.equals(obj1));\n+        }\n+    }\n+\n+    protected Object serializeDeserialize(Object obj) throws Exception {\n+        ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n+        ObjectOutputStream out = new ObjectOutputStream(buffer);\n+        out.writeObject(obj);\n+        out.close();\n+\n+        ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(buffer.toByteArray()));\n+        Object dest = in.readObject();\n+        in.close();\n+\n+        return dest;\n+    }\n+\n+    public void testSerializeDeserializeThenCompare() throws Exception {\n+        Object obj = makeObject();\n+        if (obj instanceof Serializable && isTestSerialization()) {\n+            Object dest = serializeDeserialize(obj);\n+            if (isEqualsCheckable()) {\n+                assertEquals(\"obj != deserialize(serialize(obj))\", obj, dest);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Sanity check method, makes sure that any Serializable\n+     * class can be serialized and de-serialized in memory, \n+     * using the handy makeObject() method\n+     * \n+     * @throws IOException\n+     * @throws ClassNotFoundException\n+     */\n+    public void testSimpleSerialization() throws Exception {\n+        Object o = makeObject();\n+        if (o instanceof Serializable && isTestSerialization()) {\n+            byte[] objekt = writeExternalFormToBytes((Serializable) o);\n+            readExternalFormFromBytes(objekt);\n+        }\n+    }\n+\n+    /**\n+     * Tests serialization by comparing against a previously stored version in SVN.\n+     * If the test object is serializable, confirm that a canonical form exists.\n+     */\n+    public void testCanonicalEmptyCollectionExists() {\n+        if (supportsEmptyCollections() && isTestSerialization() && !skipSerializedCanonicalTests()) {\n+            Object object = makeObject();\n+            if (object instanceof Serializable) {\n+                String name = getCanonicalEmptyCollectionName(object);\n+                assertTrue(\n+                    \"Canonical empty collection (\" + name + \") is not in SVN\",\n+                    new File(name).exists());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Tests serialization by comparing against a previously stored version in SVN.\n+     * If the test object is serializable, confirm that a canonical form exists.\n+     */\n+    public void testCanonicalFullCollectionExists() {\n+        if (supportsFullCollections() && isTestSerialization() && !skipSerializedCanonicalTests()) {\n+            Object object = makeObject();\n+            if (object instanceof Serializable) {\n+                String name = getCanonicalFullCollectionName(object);\n+                assertTrue(\n+                    \"Canonical full collection (\" + name + \") is not in SVN\",\n+                    new File(name).exists());\n+            }\n+        }\n+    }\n+\n+    // protected implementation\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the version of Collections that this object tries to\n+     * maintain serialization compatibility with. Defaults to 1, the\n+     * earliest Collections version. (Note: some collections did not\n+     * even exist in this version).\n+     * \n+     * This constant makes it possible for TestMap (and other subclasses,\n+     * if necessary) to automatically check SVN for a versionX copy of a\n+     * Serialized object, so we can make sure that compatibility is maintained.\n+     * See, for example, TestMap.getCanonicalFullMapName(Map map).\n+     * Subclasses can override this variable, indicating compatibility\n+     * with earlier Collections versions.\n+     * \n+     * @return The version, or <code>null</code> if this object shouldn't be\n+     * tested for compatibility with previous versions.\n+     */\n+    public String getCompatibilityVersion() {\n+        return \"1\";\n+    }\n+\n+    protected String getCanonicalEmptyCollectionName(Object object) {\n+        StringBuilder retval = new StringBuilder();\n+        retval.append(\"data/test/\");\n+        String colName = object.getClass().getName();\n+        colName = colName.substring(colName.lastIndexOf(\".\") + 1, colName.length());\n+        retval.append(colName);\n+        retval.append(\".emptyCollection.version\");\n+        retval.append(getCompatibilityVersion());\n+        retval.append(\".obj\");\n+        return retval.toString();\n+    }\n+\n+    protected String getCanonicalFullCollectionName(Object object) {\n+        StringBuilder retval = new StringBuilder();\n+        retval.append(\"data/test/\");\n+        String colName = object.getClass().getName();\n+        colName = colName.substring(colName.lastIndexOf(\".\") + 1, colName.length());\n+        retval.append(colName);\n+        retval.append(\".fullCollection.version\");\n+        retval.append(getCompatibilityVersion());\n+        retval.append(\".obj\");\n+        return retval.toString();\n+    }\n+\n+    /**\n+     * Write a Serializable or Externalizable object as\n+     * a file at the given path.  NOT USEFUL as part\n+     * of a unit test; this is just a utility method\n+     * for creating disk-based objects in SVN that can become\n+     * the basis for compatibility tests using\n+     * readExternalFormFromDisk(String path)\n+     * \n+     * @param o Object to serialize\n+     * @param path path to write the serialized Object\n+     * @exception IOException\n+     */\n+    protected void writeExternalFormToDisk(Serializable o, String path) throws IOException {\n+        FileOutputStream fileStream = new FileOutputStream(path);\n+        writeExternalFormToStream(o, fileStream);\n+    }\n+\n+    /**\n+     * Converts a Serializable or Externalizable object to\n+     * bytes.  Useful for in-memory tests of serialization\n+     * \n+     * @param o Object to convert to bytes\n+     * @return serialized form of the Object\n+     * @exception IOException\n+     */\n+    protected byte[] writeExternalFormToBytes(Serializable o) throws IOException {\n+        ByteArrayOutputStream byteStream = new ByteArrayOutputStream();\n+        writeExternalFormToStream(o, byteStream);\n+        return byteStream.toByteArray();\n+    }\n+\n+    /**\n+     * Reads a Serialized or Externalized Object from disk.\n+     * Useful for creating compatibility tests between\n+     * different SVN versions of the same class\n+     * \n+     * @param path path to the serialized Object\n+     * @return the Object at the given path\n+     * @exception IOException\n+     * @exception ClassNotFoundException\n+     */\n+    protected Object readExternalFormFromDisk(String path) throws IOException, ClassNotFoundException {\n+        FileInputStream stream = new FileInputStream(path);\n+        return readExternalFormFromStream(stream);\n+    }\n+\n+    /**\n+     * Read a Serialized or Externalized Object from bytes.\n+     * Useful for verifying serialization in memory.\n+     * \n+     * @param b byte array containing a serialized Object\n+     * @return Object contained in the bytes\n+     * @exception IOException\n+     * @exception ClassNotFoundException\n+     */\n+    protected Object readExternalFormFromBytes(byte[] b) throws IOException, ClassNotFoundException {\n+        ByteArrayInputStream stream = new ByteArrayInputStream(b);\n+        return readExternalFormFromStream(stream);\n+    }\n+\n+    protected boolean skipSerializedCanonicalTests() {\n+        return Boolean.getBoolean(\"org.apache.commons.collections:with-clover\");\n+    }\n+\n+    // private implementation\n+    //-----------------------------------------------------------------------\n+    private Object readExternalFormFromStream(InputStream stream) throws IOException, ClassNotFoundException {\n+        ObjectInputStream oStream = new ObjectInputStream(stream);\n+        return oStream.readObject();\n+    }\n+\n+    private void writeExternalFormToStream(Serializable o, OutputStream stream) throws IOException {\n+        ObjectOutputStream oStream = new ObjectOutputStream(stream);\n+        oStream.writeObject(o);\n+    }\n+\n+}", "timestamp": 1312780716, "metainfo": ""}