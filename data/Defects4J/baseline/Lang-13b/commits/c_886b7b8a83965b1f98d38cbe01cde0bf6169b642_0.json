{"sha": "886b7b8a83965b1f98d38cbe01cde0bf6169b642", "log": "Moving countMatches, ordinalIndexOf and lastOrdinalIndexOf over to a CharSequence-based API. LANG-687  ", "commit": "\n--- a/src/main/java/org/apache/commons/lang3/StringUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/StringUtils.java\n     }\n \n     /**\n-     * <p>Finds the n-th index within a String, handling {@code null}.\n-     * This method uses {@link String#indexOf(String)}.</p>\n-     *\n-     * <p>A {@code null} String will return {@code -1}.</p>\n+     * <p>Finds the n-th index within a CharSequence, handling {@code null}.\n+     * This method uses {@link String#indexOf(String)} if possible.</p>\n+     *\n+     * <p>A {@code null} CharSequence will return {@code -1}.</p>\n      *\n      * <pre>\n      * StringUtils.ordinalIndexOf(null, *, *)          = -1\n      * StringUtils.ordinalIndexOf(\"aabaabaa\", \"\", 2)   = 0\n      * </pre>\n      *\n-     * <p>Note that 'head(String str, int n)' may be implemented as: </p>\n+     * <p>Note that 'head(CharSequence str, int n)' may be implemented as: </p>\n      *\n      * <pre>\n      *   str.substring(0, lastOrdinalIndexOf(str, \"\\n\", n))\n      * </pre>\n      *\n-     * @param str  the String to check, may be null\n-     * @param searchStr  the String to find, may be null\n+     * @param str  the CharSequence to check, may be null\n+     * @param searchStr  the CharSequence to find, may be null\n      * @param ordinal  the n-th {@code searchStr} to find\n-     * @return the n-th index of the search String,\n+     * @return the n-th index of the search CharSequence,\n      *  {@code -1} ({@code INDEX_NOT_FOUND}) if no match or {@code null} string input\n      * @since 2.1\n      */\n-    public static int ordinalIndexOf(String str, String searchStr, int ordinal) {\n+    public static int ordinalIndexOf(CharSequence str, CharSequence searchStr, int ordinal) {\n         return ordinalIndexOf(str, searchStr, ordinal, false);\n     }\n \n     /**\n      * <p>Finds the n-th index within a String, handling {@code null}.\n-     * This method uses {@link String#indexOf(String)}.</p>\n-     *\n-     * <p>A {@code null} String will return {@code -1}.</p>\n-     *\n-     * @param str  the String to check, may be null\n-     * @param searchStr  the String to find, may be null\n+     * This method uses {@link String#indexOf(String)} if possible.</p>\n+     *\n+     * <p>A {@code null} CharSequence will return {@code -1}.</p>\n+     *\n+     * @param str  the CharSequence to check, may be null\n+     * @param searchStr  the CharSequence to find, may be null\n      * @param ordinal  the n-th {@code searchStr} to find\n      * @param lastIndex true if lastOrdinalIndexOf() otherwise false if ordinalIndexOf()\n-     * @return the n-th index of the search String,\n+     * @return the n-th index of the search CharSequence,\n      *  {@code -1} ({@code INDEX_NOT_FOUND}) if no match or {@code null} string input\n      */\n     // Shared code between ordinalIndexOf(String,String,int) and lastOrdinalIndexOf(String,String,int)\n-    private static int ordinalIndexOf(String str, String searchStr, int ordinal, boolean lastIndex) {\n+    private static int ordinalIndexOf(CharSequence str, CharSequence searchStr, int ordinal, boolean lastIndex) {\n         if (str == null || searchStr == null || ordinal <= 0) {\n             return INDEX_NOT_FOUND;\n         }\n         int index = lastIndex ? str.length() : INDEX_NOT_FOUND;\n         do {\n             if (lastIndex) {\n-                index = str.lastIndexOf(searchStr, index - 1);\n+                index = lastIndexOfSequence(str, searchStr, index - 1);\n             } else {\n-                index = str.indexOf(searchStr, index + 1);\n+                index = indexOfSequence(str, searchStr, index + 1);\n             }\n             if (index < 0) {\n                 return index;\n      * StringUtils.lastOrdinalIndexOf(\"aabaabaa\", \"\", 2)   = 8\n      * </pre>\n      *\n-     * <p>Note that 'tail(String str, int n)' may be implemented as: </p>\n+     * <p>Note that 'tail(CharSequence str, int n)' may be implemented as: </p>\n      *\n      * <pre>\n      *   str.substring(lastOrdinalIndexOf(str, \"\\n\", n) + 1)\n      * </pre>\n      *\n-     * @param str  the String to check, may be null\n-     * @param searchStr  the String to find, may be null\n+     * @param str  the CharSequence to check, may be null\n+     * @param searchStr  the CharSequence to find, may be null\n      * @param ordinal  the n-th last {@code searchStr} to find\n-     * @return the n-th last index of the search String,\n+     * @return the n-th last index of the search CharSequence,\n      *  {@code -1} ({@code INDEX_NOT_FOUND}) if no match or {@code null} string input\n      * @since 2.5\n      */\n-    public static int lastOrdinalIndexOf(String str, String searchStr, int ordinal) {\n+    public static int lastOrdinalIndexOf(CharSequence str, CharSequence searchStr, int ordinal) {\n         return ordinalIndexOf(str, searchStr, ordinal, true);\n     }\n \n     // Count matches\n     //-----------------------------------------------------------------------\n     /**\n-     * <p>Counts how many times the substring appears in the larger String.</p>\n+     * <p>Counts how many times the substring appears in the larger string.</p>\n      *\n      * <p>A {@code null} or empty (\"\") String input returns {@code 0}.</p>\n      *\n      * StringUtils.countMatches(\"abba\", \"xxx\") = 0\n      * </pre>\n      *\n-     * @param str  the String to check, may be null\n+     * @param str  the CharSequence to check, may be null\n      * @param sub  the substring to count, may be null\n-     * @return the number of occurrences, 0 if either String is {@code null}\n-     */\n-    public static int countMatches(String str, String sub) {\n+     * @return the number of occurrences, 0 if either CharSequence is {@code null}\n+     */\n+    public static int countMatches(CharSequence str, CharSequence sub) {\n         if (isEmpty(str) || isEmpty(sub)) {\n             return 0;\n         }\n         int count = 0;\n         int idx = 0;\n-        while ((idx = str.indexOf(sub, idx)) != INDEX_NOT_FOUND) {\n+        while ((idx = indexOfSequence(str, sub, idx)) != INDEX_NOT_FOUND) {\n             count++;\n             idx += sub.length();\n         }", "timestamp": 1302067882, "metainfo": ""}