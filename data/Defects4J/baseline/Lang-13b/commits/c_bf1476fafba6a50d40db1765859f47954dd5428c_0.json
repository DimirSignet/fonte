{"sha": "bf1476fafba6a50d40db1765859f47954dd5428c", "log": "Dealing with some of the >120 length lines as per checkstyle. A few still need reducing.   ", "commit": "\n--- a/src/java/org/apache/commons/lang/StringUtils.java\n+++ b/src/java/org/apache/commons/lang/StringUtils.java\n      * @return an array of parsed Strings, <code>null</code> if null String input\n      * @since 2.4\n      */\n-    private static String[] splitByWholeSeparatorWorker(String str, String separator, int max, boolean preserveAllTokens) {\n+    private static String[] splitByWholeSeparatorWorker(String str, String separator, int max, \n+                                                        boolean preserveAllTokens) \n+    {\n         if (str == null) {\n             return null;\n         }\n      * </p>\n      * \n      * <pre>\n-     *  StringUtils.replaceEach(null, *, *, *)        = null\n-     *  StringUtils.replaceEach(\"\", *, *, *)          = \"\"\n+     *  StringUtils.replaceEach(null, *, *, *) = null\n+     *  StringUtils.replaceEach(\"\", *, *, *) = \"\"\n      *  StringUtils.replaceEach(\"aba\", null, null, *) = \"aba\"\n      *  StringUtils.replaceEach(\"aba\", new String[0], null, *) = \"aba\"\n      *  StringUtils.replaceEach(\"aba\", null, new String[0], *) = \"aba\"\n-     *  StringUtils.replaceEach(\"aba\", new String[]{\"a\"}, null, *)  = \"aba\"\n-     *  StringUtils.replaceEach(\"aba\", new String[]{\"a\"}, new String[]{\"\"}, *)  = \"b\"\n-     *  StringUtils.replaceEach(\"aba\", new String[]{null}, new String[]{\"a\"}, *)  = \"aba\"\n-     *  StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"w\", \"t\"}, *)  = \"wcte\"\n+     *  StringUtils.replaceEach(\"aba\", new String[]{\"a\"}, null, *) = \"aba\"\n+     *  StringUtils.replaceEach(\"aba\", new String[]{\"a\"}, new String[]{\"\"}, *) = \"b\"\n+     *  StringUtils.replaceEach(\"aba\", new String[]{null}, new String[]{\"a\"}, *) = \"aba\"\n+     *  StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"w\", \"t\"}, *) = \"wcte\"\n      *  (example of how it repeats)\n-     *  StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"t\"}, false)  = \"dcte\"\n-     *  StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"t\"}, true)  = \"tcte\"\n-     *  StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"ab\"}, true)  = IllegalArgumentException\n-     *  StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"ab\"}, false)  = \"dcabe\"\n+     *  StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"t\"}, false) = \"dcte\"\n+     *  StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"t\"}, true) = \"tcte\"\n+     *  StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"ab\"}, true) = IllegalArgumentException\n+     *  StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"ab\"}, false) = \"dcabe\"\n      * </pre>\n      * \n      * @param text\n      * </p>\n      * \n      * <pre>\n-     *  StringUtils.replaceEach(null, *, *, *)        = null\n-     *  StringUtils.replaceEach(\"\", *, *, *)          = \"\"\n+     *  StringUtils.replaceEach(null, *, *, *) = null\n+     *  StringUtils.replaceEach(\"\", *, *, *) = \"\"\n      *  StringUtils.replaceEach(\"aba\", null, null, *) = \"aba\"\n      *  StringUtils.replaceEach(\"aba\", new String[0], null, *) = \"aba\"\n      *  StringUtils.replaceEach(\"aba\", null, new String[0], *) = \"aba\"\n-     *  StringUtils.replaceEach(\"aba\", new String[]{\"a\"}, null, *)  = \"aba\"\n-     *  StringUtils.replaceEach(\"aba\", new String[]{\"a\"}, new String[]{\"\"}, *)  = \"b\"\n-     *  StringUtils.replaceEach(\"aba\", new String[]{null}, new String[]{\"a\"}, *)  = \"aba\"\n-     *  StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"w\", \"t\"}, *)  = \"wcte\"\n+     *  StringUtils.replaceEach(\"aba\", new String[]{\"a\"}, null, *) = \"aba\"\n+     *  StringUtils.replaceEach(\"aba\", new String[]{\"a\"}, new String[]{\"\"}, *) = \"b\"\n+     *  StringUtils.replaceEach(\"aba\", new String[]{null}, new String[]{\"a\"}, *) = \"aba\"\n+     *  StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"w\", \"t\"}, *) = \"wcte\"\n      *  (example of how it repeats)\n-     *  StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"t\"}, false)  = \"dcte\"\n-     *  StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"t\"}, true)  = \"tcte\"\n-     *  StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"ab\"}, *)  = IllegalArgumentException\n+     *  StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"t\"}, false) = \"dcte\"\n+     *  StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"t\"}, true) = \"tcte\"\n+     *  StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"ab\"}, *) = IllegalArgumentException\n      * </pre>\n      * \n      * @param text\n      *             and/or size 0)\n      * @since 2.4\n      */\n-    private static String replaceEach(String text, String[] searchList, String[] replacementList, boolean repeat, int timeToLive) {\n+    private static String replaceEach(String text, String[] searchList, String[] replacementList, \n+                                      boolean repeat, int timeToLive) \n+    {\n \n         // mchyzer Performance note: This creates very few new objects (one major goal)\n         // let me know if there are performance requests, we can create a harness to measure\n \n-        if (text == null || text.length() == 0 || searchList == null || searchList.length == 0 || replacementList == null || replacementList.length == 0) {\n+        if (text == null || text.length() == 0 || searchList == null || \n+            searchList.length == 0 || replacementList == null || replacementList.length == 0) \n+        {\n             return text;\n         }\n \n         // index of replace array that will replace the search string found\n         // NOTE: logic duplicated below START\n         for (int i = 0; i < searchLength; i++) {\n-            if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].length() == 0 || replacementList[i] == null) {\n+            if (noMoreMatchesForReplIndex[i] || searchList[i] == null || \n+                searchList[i].length() == 0 || replacementList[i] == null) \n+            {\n                 continue;\n             }\n             tempIndex = text.indexOf(searchList[i]);\n             // find the next earliest match\n             // NOTE: logic mostly duplicated above START\n             for (int i = 0; i < searchLength; i++) {\n-                if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].length() == 0 || replacementList[i] == null) {\n+                if (noMoreMatchesForReplIndex[i] || searchList[i] == null || \n+                    searchList[i].length() == 0 || replacementList[i] == null) \n+                {\n                     continue;\n                 }\n                 tempIndex = text.indexOf(searchList[i], start);\n--- a/src/java/org/apache/commons/lang/text/ExtendedMessageFormat.java\n+++ b/src/java/org/apache/commons/lang/text/ExtendedMessageFormat.java\n  * and the formats supported by <code>java.text.MessageFormat</code> can be overridden\n  * at the format and/or format style level (see MessageFormat).  A \"format element\"\n  * embedded in the message pattern is specified (<b>()?</b> signifies optionality):<br />\n- * <code>{</code<i>argument-number</i><b>(</b><code>,</code><i>format-name</i><b>(</b><code>,</code><i>format-style</i><b>)?</b><b>)?</b><code>}</code>\n+ * <code>{</code><i>argument-number</i><b>(</b><code>,</code><i>format-name</i><b>(</b><code>,</code><i>format-style</i><b>)?)?</b><code>}</code>\n  *\n  * <p>\n  * <i>format-name</i> and <i>format-style</i> values are trimmed of surrounding whitespace\n         toPattern = insertFormats(super.toPattern(), foundDescriptions);\n         if (containsElements(foundFormats)) {\n             Format[] origFormats = getFormats();\n-            //only loop over what we know we have, as MessageFormat on Java 1.3 seems to provide an extra format element:\n+            // only loop over what we know we have, as MessageFormat on Java 1.3 \n+            // seems to provide an extra format element:\n             int i = 0;\n             for (Iterator it = foundFormats.iterator(); it.hasNext(); i++) {\n                 Format f = (Format) it.next();", "timestamp": 1205130429, "metainfo": ""}