{"sha": "01ab63a0f1d4b8d17d86dc4be56cbc7b92154a48", "log": "Applying Sven Ludwig's patch from LANG-626. This modifies the SerializationUtils.clone method to use the threadContextLoader if it is unable to find a class using the object's current classloader. This should (hopefully) help with Weblogic and Tomcat situations where Lang is outside the web-inf for some reason (likely user error with Tomcat, by design for Weblogic)  ", "commit": "\n--- a/src/main/java/org/apache/commons/lang3/SerializationUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/SerializationUtils.java\n import java.io.InputStream;\n import java.io.ObjectInputStream;\n import java.io.ObjectOutputStream;\n+import java.io.ObjectStreamClass;\n import java.io.OutputStream;\n import java.io.Serializable;\n \n      * @throws SerializationException (runtime) if the serialization fails\n      */\n     public static <T extends Serializable> T clone(T object) {\n-        /*\n-         * when we serialize and deserialize an object,\n-         * it is reasonable to assume the deserialized object\n-         * is of the same type as the original serialized object\n-         */\n-        @SuppressWarnings(\"unchecked\")\n-        final T result = (T) deserialize(serialize(object));\n-        return result;\n+        if (object == null) {\n+            return null;\n+        }\n+        byte[] objectData = serialize(object);\n+        ByteArrayInputStream bais = new ByteArrayInputStream(objectData);\n+\n+        ClassLoaderAwareObjectInputStream in = null;\n+        try {\n+            // stream closed in the finally\n+            in = new ClassLoaderAwareObjectInputStream(bais, object.getClass().getClassLoader());\n+            /*\n+             * when we serialize and deserialize an object,\n+             * it is reasonable to assume the deserialized object\n+             * is of the same type as the original serialized object\n+             */\n+            return (T) in.readObject();\n+\n+        } catch (ClassNotFoundException ex) {\n+            throw new SerializationException(\"ClassNotFoundException while reading cloned object data\", ex);\n+        } catch (IOException ex) {\n+            throw new SerializationException(\"IOException while reading cloned object data\", ex);\n+        } finally {\n+            try {\n+                if (in != null) {\n+                    in.close();\n+                }\n+            } catch (IOException ex) {\n+                throw new SerializationException(\"IOException on closing cloned object data InputStream.\", ex);\n+            }\n+        }\n     }\n \n     // Serialize\n         return deserialize(bais);\n     }\n \n+    /**\n+     * <p>Custom specialization of the standard JDK {@link java.io.ObjectInputStream}\n+     * that uses a custom  <code>ClassLoader</code> to resolve a class.\n+     * If the specified <code>ClassLoader</code> is not able to resolve the class,\n+     * the context classloader of the current thread will be used.\n+     * This way, the standard deserialization work also in web-application\n+     * containers and application servers, no matter in which of the\n+     * <code>ClassLoader</code> the particular class that encapsulates\n+     * serialization/deserialization lives. </p>\n+     * \n+     * <p>For more in-depth information about the problem for which this\n+     * class here is a workaround, see the JIRA issue LANG-626. </p>\n+     */\n+     static class ClassLoaderAwareObjectInputStream extends ObjectInputStream {\n+        private ClassLoader classLoader;\n+\n+        /**\n+         * Constructor.\n+         * @param in The <code>InputStream</code>.\n+         * @param classLoader classloader to use\n+         * @throws IOException if an I/O error occurs while reading stream header.\n+         * @see java.io.ObjectInputStream\n+         */\n+        public ClassLoaderAwareObjectInputStream(InputStream in, ClassLoader classLoader) throws IOException {\n+            super(in);\n+            this.classLoader = classLoader;\n+        }\n+\n+        /**\n+         * Overriden version that uses the parametrized <code>ClassLoader</code> or the <code>ClassLoader</code>\n+         * of the current <code>Thread</code> to resolve the class.\n+         * @param desc An instance of class <code>ObjectStreamClass</code>.\n+         * @return A <code>Class</code> object corresponding to <code>desc</code>.\n+         * @throws IOException Any of the usual Input/Output exceptions.\n+         * @throws ClassNotFoundException If class of a serialized object cannot be found.\n+         */\n+        @Override\n+        protected Class<?> resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException {\n+            String name = desc.getName();\n+            try {\n+                return Class.forName(name, false, classLoader);\n+            } catch (ClassNotFoundException ex) {\n+                return Class.forName(name, false, Thread.currentThread().getContextClassLoader());\n+            }\n+        }\n+\n+    }\n+\n }", "timestamp": 1312268224, "metainfo": ""}