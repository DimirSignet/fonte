{"sha": "886b84bf4a7c04adf1b9c09e979c2e4abab9feb2", "log": "Improve Tokenizer with CSV and TSV plus change default to StringTokenizer like includes code from Matthew Inger   ", "commit": "\n--- a/src/java/org/apache/commons/lang/Tokenizer.java\n+++ b/src/java/org/apache/commons/lang/Tokenizer.java\n /* ====================================================================\n  * The Apache Software License, Version 1.1\n  *\n- * Copyright (c) 2002-2003 The Apache Software Foundation.  All rights\n+ * Copyright (c) 2003-2004 The Apache Software Foundation.  All rights\n  * reserved.\n  *\n  * Redistribution and use in source and binary forms, with or without\n  * Tokenizes a string based based on delimiters (separators)\n  * and supporting quoting and ignored character concepts.\n  * <p>\n- * This class can split a String into many smaller strings. It aims to do a\n- * similar job to java util StringTokenizer, however it offers much more\n- * control and flexibility.\n+ * This class can split a String into many smaller strings.\n+ * It aims to do a similar job to java util StringTokenizer, however it offers\n+ * much more control and flexibility. By default, it is setup like StringTokenizer.\n  * <p>\n  * The input String is split into a number of <i>tokens</i>.\n  * Each token is separated from the next String by a <i>delimiter</i>.\n  * The processing then strips all the <i>ignored</i> characters from each side of the token.\n  * The token may also have <i>quotes</i> to mark an area not to be stripped or tokenized.\n  * Empty tokens may be removed or returned as null.\n+ * This example is based on the CSV tokenizer.\n  * <pre>\n- * \"a,b,c\"       - Three tokens \"a\",\"b\",\"c\" (comma delimiter)\n- * \"a, b , c\"    - Three tokens \"a\",\"b\",\"c\" (ignored space characters stripped)\n+ * \"a,b,c\"       - Three tokens \"a\",\"b\",\"c\"   (comma delimiter)\n+ * \"a, b , c\"    - Three tokens \"a\",\"b\",\"c\"   (ignored space characters stripped)\n  * \"a, \" b \", c\" - Three tokens \"a\",\" b \",\"c\" (quoted text untouched)\n  * </pre>\n  * <p>\n- * By default, this tokenizer has the following properties:\n- * <pre>\n- * Property                     Default\n- * ---------                    -------\n- * delimiter                    ,  (comma)\n- * quote                        \"  (double quote)\n- * ignored                      char &lt;= 32 (as per trim)\n- * emptyTokenAsNull             false\n- * ignoreEmptyTokens            false\n- * </pre>\n+ *\n+ * This tokenizer has the following properties and options:\n+ *\n+ * <table>\n+ *  <tr>\n+ *   <th>Property</th><th>Type</th><th>Default</th>\n+ *  </tr>\n+ *  <tr>\n+ *   <td>delim</td><td>CharSetMatcher</td><td>{ \\t\\n\\r\\f}</td>\n+ *  </tr>\n+ *  <tr>\n+ *   <td>quote</td><td>NoneMatcher</td><td>{}</td>\n+ *  </tr>\n+ *  <tr>\n+ *   <td>ignore</td><td>NoneMatcher</td><td>{}</td>\n+ *  </tr>\n+ *  <tr>\n+ *   <td>emptyTokenAsNull</td><td>boolean</td><td>false</td>\n+ *  </tr>\n+ *  <tr>\n+ *   <td>ignoreEmptyTokens</td><td>boolean</td><td>true</td>\n+ *  </tr>\n+ * </table>\n  *\n  * @author Matthew Inger\n  * @author Stephen Colebourne\n  * @author Gary D. Gregory\n  * @since 2.1\n- * @version $Id: Tokenizer.java,v 1.3 2004/02/13 01:58:50 ggregory Exp $\n+ * @version $Id: Tokenizer.java,v 1.4 2004/02/14 00:31:55 scolebourne Exp $\n  */\n-public class Tokenizer implements ListIterator {\n-    // TODO: Constructors\n-    // TODO: Tests\n-    // TODO: Static factories CSV/StringTokenizer\n-    \n+public class Tokenizer implements ListIterator, Cloneable {\n+\n     /**\n      * A Matcher which matches the comma character.\n      * Best used for <code>delimiter</code>.\n      */\n     public static final Matcher COMMA_MATCHER = new CharMatcher(',');\n     /**\n+     * A Matcher which matches the tab character.\n+     * Best used for <code>delimiter</code>.\n+     */\n+    public static final Matcher TAB_MATCHER = new CharMatcher('\\t');\n+    /**\n+     * A Matcher which matches the space character.\n+     * Best used for <code>delimiter</code>.\n+     */\n+    public static final Matcher SPACE_MATCHER = new CharMatcher(' ');\n+    /**\n+     * A Matcher which matches the same characters as StringTokenizer,\n+     * namely space, tab, newline, formfeed.\n+     * Best used for <code>delimiter</code>.\n+     */\n+    public static final Matcher SPLIT_MATCHER = new CharSetMatcher(\" \\t\\n\\r\\f\");\n+    /**\n      * A Matcher which matches the double quote character.\n      * Best used for <code>quote</code>.\n      */\n      * A Matcher which matches the String trim() whitespace characters.\n      * Best used for <code>ignored</code>.\n      */\n-    public static final Matcher SPACES_MATCHER = new TrimMatcher();\n+    public static final Matcher TRIM_MATCHER = new TrimMatcher();\n     /**\n      * A Matcher that matches no characters. Don't use this for delimiters!\n      * Best used for <code>ignored</code>.\n      */\n     public static final Matcher NONE_MATCHER = new NoMatcher();\n+    \n+    private static final Tokenizer CSV_TOKENIZER_PROTOTYPE;\n+    private static final Tokenizer TSV_TOKENIZER_PROTOTYPE;\n+\n+    static {\n+        CSV_TOKENIZER_PROTOTYPE = new Tokenizer(StringUtils.EMPTY);\n+        CSV_TOKENIZER_PROTOTYPE.setDelimiterMatcher(COMMA_MATCHER);\n+        CSV_TOKENIZER_PROTOTYPE.setQuoteMatcher(DOUBLE_QUOTE_MATCHER);\n+        CSV_TOKENIZER_PROTOTYPE.setIgnoredMatcher(TRIM_MATCHER);\n+        CSV_TOKENIZER_PROTOTYPE.setEmptyTokenAsNull(false);\n+        CSV_TOKENIZER_PROTOTYPE.setIgnoreEmptyTokens(false);\n+\n+        TSV_TOKENIZER_PROTOTYPE = new Tokenizer(StringUtils.EMPTY);\n+        TSV_TOKENIZER_PROTOTYPE.setDelimiterMatcher(TAB_MATCHER);\n+        TSV_TOKENIZER_PROTOTYPE.setQuoteMatcher(DOUBLE_QUOTE_MATCHER);\n+        TSV_TOKENIZER_PROTOTYPE.setIgnoredMatcher(TRIM_MATCHER);\n+        TSV_TOKENIZER_PROTOTYPE.setEmptyTokenAsNull(false);\n+        TSV_TOKENIZER_PROTOTYPE.setIgnoreEmptyTokens(false);\n+    }\n \n     /** The text to work on */\n     private char chars[];\n+    /** The input text, null if char[] input */\n+    private String text;\n     /** The parsed tokens */\n     private String tokens[];\n     /** The current iteration position */\n     private int tokenPos;\n \n     /** The delimiter matcher */\n-    private Matcher delim = COMMA_MATCHER;\n+    private Matcher delim = SPLIT_MATCHER;\n     /** The quote matcher */\n-    private Matcher quote = DOUBLE_QUOTE_MATCHER;\n+    private Matcher quote = NONE_MATCHER;\n     /** The ignored matcher */\n-    private Matcher ignored = SPACES_MATCHER;\n+    private Matcher ignored = NONE_MATCHER;\n     /** Whether to return empty tokens as null */\n     private boolean emptyAsNull = false;\n     /** Whether to ignore empty tokens */\n-    private boolean ignoreEmptyTokens = false;\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Constructor.\n+    private boolean ignoreEmptyTokens = true;\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get a tokenizer instance which parses Comma Seperated Value\n+     * strings.  You must call a \"reset\" method to set the string which\n+     * you want to parse.\n+     */\n+    public static final Tokenizer getCSVInstance() {\n+        return (Tokenizer)(CSV_TOKENIZER_PROTOTYPE.clone());\n+    }\n+\n+    /**\n+     * Get a tokenizer instance which parses Comma Seperated Value\n+     * strings, initializing it with the given input.\n+     * \n+     * @param input  the string to parse\n+     */\n+    public static final Tokenizer getCSVInstance(String input) {\n+        Tokenizer tok = (Tokenizer)(CSV_TOKENIZER_PROTOTYPE.clone());\n+        tok.reset(input);\n+        return tok;\n+    }\n+\n+    /**\n+     * Get a tokenizer instance which parses Comma Seperated Value\n+     * strings, initializing it with the given input.\n+     * \n+     * @param input  the text to parse\n+     */\n+    public static final Tokenizer getCSVInstance(char[] input) {\n+        Tokenizer tok = (Tokenizer)(CSV_TOKENIZER_PROTOTYPE.clone());\n+        tok.reset(input);\n+        return tok;\n+    }\n+\n+    /**\n+     * Get a tokenizer instance which parses Tab Seperated Value\n+     * strings.  You must call a \"reset\" method to set the string which\n+     * you want to parse.\n+     */\n+    public static final Tokenizer getTSVInstance() {\n+        return (Tokenizer)(TSV_TOKENIZER_PROTOTYPE.clone());\n+    }\n+\n+    /**\n+     * Get a tokenizer instance which parses Tab Seperated Value\n+     * strings, initializing it with the given input.\n+     * \n+     * @param input  the string to parse\n+     */\n+    public static final Tokenizer getTSVInstance(String input) {\n+        Tokenizer tok = (Tokenizer)(TSV_TOKENIZER_PROTOTYPE.clone());\n+        tok.reset(input);\n+        return tok;\n+    }\n+\n+    /**\n+     * Get a tokenizer instance which parses Tab Seperated Value\n+     * strings, initializing it with the given input.\n+     * \n+     * @param input  the text to parse\n+     */\n+    public static final Tokenizer getTSVInstance(char[] input) {\n+        Tokenizer tok = (Tokenizer)(TSV_TOKENIZER_PROTOTYPE.clone());\n+        tok.reset(input);\n+        return tok;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructs a tokenizer splitting on space, tab, newline and formfeed\n+     * as per StringTokenizer.\n      * \n      * @param input  the string which is to be parsed\n      */\n     public Tokenizer(String input) {\n-        this(input.toCharArray());\n-    }\n-\n-    /**\n-     * Constructor.\n+        super();\n+        this.text = input;\n+        this.chars = input.toCharArray();  // no clone as toCharArray() clones\n+    }\n+\n+    /**\n+     * Constructs a tokenizer splitting on space, tab, newline and formfeed\n+     * as per StringTokenizer.\n      * \n      * @param input  the string which is to be parsed\n      * @param delim  the field delimiter character\n      */\n     public Tokenizer(String input, char delim) {\n-        this(input.toCharArray(), delim);\n-    }\n-\n-    /**\n-     * Constructor.\n+        this(input);\n+        setDelimiterChar(delim);\n+    }\n+\n+    /**\n+     * Constructs a tokenizer splitting on space, tab, newline and formfeed\n+     * as per StringTokenizer.\n      * \n      * @param input  the string which is to be parsed\n      * @param delim  the field delimiter character\n      */\n     public Tokenizer(String input, CharSetMatcher delim) {\n-        this(input.toCharArray(), delim);\n-    }\n-\n-    /**\n-     * Constructor.\n+        this(input);\n+        setDelimiterMatcher(delim);\n+    }\n+\n+    /**\n+     * Constructs a tokenizer splitting on space, tab, newline and formfeed\n+     * as per StringTokenizer.\n      * \n      * @param input  the string which is to be parsed\n      * @param delim  the field delimiter character\n      * @param quote  the field quoted string character\n      */\n     public Tokenizer(String input, char delim, char quote) {\n-        this(input.toCharArray(), delim, quote);\n-    }\n-\n-    /**\n-     * Constructor.\n+        this(input, delim);\n+        setQuoteChar(quote);\n+    }\n+\n+    /**\n+     * Constructs a tokenizer splitting on space, tab, newline and formfeed\n+     * as per StringTokenizer.\n      * \n      * @param input  the string which is to be parsed\n      * @param delim  the field delimiter character\n      * @param quote  the field quoted string character\n      */\n     public Tokenizer(String input, CharSetMatcher delim, CharSetMatcher quote) {\n-        this(input.toCharArray(), delim, quote);\n-    }\n-\n-    /**\n-     * Constructor.\n-     * \n-     * @param input  the string which is to be parsed\n+        this(input, delim);\n+        setQuoteMatcher(quote);\n+    }\n+\n+    /**\n+     * Constructs a tokenizer splitting on space, tab, newline and formfeed\n+     * as per StringTokenizer.\n+     * \n+     * @param input  the string which is to be parsed, cloned\n      */\n     public Tokenizer(char[] input) {\n         super();\n+        this.text = null;\n         this.chars = (char[]) input.clone();\n-        this.tokenPos = 0;\n-    }\n-\n-    /**\n-     * Constructor.\n-     * \n-     * @param input  the string which is to be parsed\n+    }\n+\n+    /**\n+     * Constructs a tokenizer splitting on space, tab, newline and formfeed\n+     * as per StringTokenizer.\n+     * \n+     * @param input  the string which is to be parsed, cloned\n      * @param delim the field delimiter character\n      */\n     public Tokenizer(char[] input, char delim) {\n     }\n \n     /**\n-     * Constructor.\n-     * \n-     * @param input  the string which is to be parsed\n+     * Constructs a tokenizer splitting on space, tab, newline and formfeed\n+     * as per StringTokenizer.\n+     * \n+     * @param input  the string which is to be parsed, cloned\n      * @param delim  the field delimiter character\n      */\n     public Tokenizer(char[] input, CharSetMatcher delim) {\n     }\n \n     /**\n-     * Constructor.\n-     * \n-     * @param input  the string which is to be parsed\n+     * Constructs a tokenizer splitting on space, tab, newline and formfeed\n+     * as per StringTokenizer.\n+     * \n+     * @param input  the string which is to be parsed, cloned\n      * @param delim  the field delimiter character\n      * @param quote  the field quoted string character\n      */\n     }\n \n     /**\n-     * Constructor.\n-     * \n-     * @param input  the string which is to be parsed\n+     * Constructs a tokenizer splitting on space, tab, newline and formfeed\n+     * as per StringTokenizer.\n+     * \n+     * @param input  the string which is to be parsed, cloned\n      * @param delim  the field delimiter character\n      * @param quote  the field quoted string character\n      */\n     public void reset() {\n         tokenPos = 0;\n         tokens = null;\n+    }\n+\n+    /**\n+     * Reset this tokenizer, giving it a new input string to parse.\n+     * In this manner you can re-use a tokenizer with the same settings\n+     * on multiple input lines.\n+     * \n+     * @param input  the new string to tokenize\n+     */\n+    public void reset(String input) {\n+        reset();\n+        this.text = input;\n+        chars = input.toCharArray();  // no clone as toCharArray() clones\n+    }\n+\n+    /**\n+     * Reset this tokenizer, giving it a new input string to parse.\n+     * In this manner you can re-use a tokenizer with the same settings\n+     * on multiple input lines.\n+     * \n+     * @param input  the new character array to tokenize, cloned\n+     */\n+    public void reset(char [] input) {\n+        reset();\n+        this.text = null;\n+        chars = (char[]) input.clone();\n     }\n \n     // ListIterator\n         token.setLength(0);\n         int len = chars.length;\n \n-        // skip all leading whitespace, unless it is the\n+        // Skip all leading whitespace, unless it is the\n         // field delimiter or the quote character\n-        while (start < len &&\n-                ignored.isMatch(chars[start]) &&\n-                !delim.isMatch(chars[start]) &&\n-                !quote.isMatch(chars[start])) {\n-            start++;\n-        }\n+        int current = start;\n+        while (current < len &&\n+                ignored.isMatch(chars[current]) &&\n+                !delim.isMatch(chars[current]) &&\n+                !quote.isMatch(chars[current])) {\n+            current++;\n+        }\n+\n+        start = current;\n \n         // Read the token depending on what the first\n         // character is like\n         this.ignoreEmptyTokens = ignoreEmptyTokens;\n     }\n \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the String content that the tokenizer is parsing.\n+     * \n+     * @return the string content being parsed\n+     */\n+    public String getContent() {\n+        if (text == null) {\n+            text = new String(chars);\n+        }\n+        return text;\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Create a new instance of this Tokenizer.\n+     * The new instance is reset so that it will be at the start of the token list.\n+     */\n+    public Object clone() {\n+        try {\n+            Tokenizer cloned = (Tokenizer) super.clone();\n+            // chars[] does not need additional clone as it is treated as immutable\n+            cloned.reset();\n+            return cloned;\n+            \n+        } catch (CloneNotSupportedException ex) {\n+            return null;\n+        }\n+    }\n+\n     //-----------------------------------------------------------------------    \n     /**\n      * Class used to define a set of characters for matching purposes.\n          * @param chars  the characters to match, must not be null\n          */\n         public CharSetMatcher(String chars) {\n-            this(chars.toCharArray());\n+            super();\n+            this.chars = chars.toCharArray();\n+            Arrays.sort(this.chars);\n         }\n \n         /**\n--- a/src/test/org/apache/commons/lang/TokenizerTest.java\n+++ b/src/test/org/apache/commons/lang/TokenizerTest.java\n /* ====================================================================\n  * The Apache Software License, Version 1.1\n  *\n- * Copyright (c) 2002-2003 The Apache Software Foundation.  All rights\n+ * Copyright (c) 2003-2004 The Apache Software Foundation.  All rights\n  * reserved.\n  *\n  * Redistribution and use in source and binary forms, with or without\n         String input = \"a;b;c;\\\"d;\\\"\\\"e\\\";f; ; ;\";\n         Tokenizer tok = new Tokenizer(input);\n         tok.setDelimiterChar(';');\n+        tok.setQuoteChar('\"');\n+        tok.setIgnoredMatcher(Tokenizer.TRIM_MATCHER);\n+        tok.setIgnoreEmptyTokens(false);\n         String tokens [] = tok.getAllTokens();\n \n         String expected[] = new String[]\n         String input = \"a;b;c ;\\\"d;\\\"\\\"e\\\";f; ; ;\";\n         Tokenizer tok = new Tokenizer(input);\n         tok.setDelimiterChar(';');\n+        tok.setQuoteChar('\"');\n         tok.setIgnoredMatcher(Tokenizer.NONE_MATCHER);\n+        tok.setIgnoreEmptyTokens(false);\n         String tokens [] = tok.getAllTokens();\n \n         String expected[] = new String[]\n         String input = \"a;b; c;\\\"d;\\\"\\\"e\\\";f; ; ;\";\n         Tokenizer tok = new Tokenizer(input);\n         tok.setDelimiterChar(';');\n+        tok.setQuoteChar('\"');\n         tok.setIgnoredMatcher(Tokenizer.NONE_MATCHER);\n+        tok.setIgnoreEmptyTokens(false);\n         String tokens [] = tok.getAllTokens();\n \n         String expected[] = new String[]\n         String input = \"a;b; c;\\\"d;\\\"\\\"e\\\";f; ; ;\";\n         Tokenizer tok = new Tokenizer(input);\n         tok.setDelimiterChar(';');\n+        tok.setQuoteChar('\"');\n+        tok.setIgnoredMatcher(Tokenizer.TRIM_MATCHER);\n         tok.setIgnoreEmptyTokens(true);\n         String tokens [] = tok.getAllTokens();\n \n         String input = \"a;b; c;\\\"d;\\\"\\\"e\\\";f; ; ;\";\n         Tokenizer tok = new Tokenizer(input);\n         tok.setDelimiterChar(';');\n+        tok.setQuoteChar('\"');\n+        tok.setIgnoredMatcher(Tokenizer.TRIM_MATCHER);\n+        tok.setIgnoreEmptyTokens(false);\n         tok.setEmptyTokenAsNull(true);\n         String tokens [] = tok.getAllTokens();\n \n         String input = \"a;b; c;\\\"d;\\\"\\\"e\\\";f; ; ;\";\n         Tokenizer tok = new Tokenizer(input);\n         tok.setDelimiterChar(';');\n+        tok.setQuoteChar('\"');\n+        tok.setIgnoredMatcher(Tokenizer.TRIM_MATCHER);\n+        tok.setIgnoreEmptyTokens(false);\n //        tok.setTreatingEmptyAsNull(true);\n         String tokens [] = tok.getAllTokens();\n \n \n         String input = \"a   b c \\\"d e\\\" f \";\n         Tokenizer tok = new Tokenizer(input);\n-        tok.setDelimiterMatcher(Tokenizer.SPACES_MATCHER);\n+        tok.setDelimiterMatcher(Tokenizer.SPACE_MATCHER);\n+        tok.setQuoteMatcher(Tokenizer.DOUBLE_QUOTE_MATCHER);\n         tok.setIgnoredMatcher(Tokenizer.NONE_MATCHER);\n         tok.setIgnoreEmptyTokens(false);\n         String tokens [] = tok.getAllTokens();\n \n         String input = \"a   b c \\\"d e\\\" f \";\n         Tokenizer tok = new Tokenizer(input);\n-        tok.setDelimiterMatcher(Tokenizer.SPACES_MATCHER);\n+        tok.setDelimiterMatcher(Tokenizer.SPACE_MATCHER);\n+        tok.setQuoteMatcher(Tokenizer.DOUBLE_QUOTE_MATCHER);\n         tok.setIgnoredMatcher(Tokenizer.NONE_MATCHER);\n         tok.setIgnoreEmptyTokens(true);\n         String tokens [] = tok.getAllTokens();\n \n     }\n \n+    public void testBasic1() {\n+        String input = \"a  b c\";\n+        Tokenizer tok = new Tokenizer(input);\n+        assertEquals(\"a\", tok.next());\n+        assertEquals(\"b\", tok.next());\n+        assertEquals(\"c\", tok.next());\n+    }\n+    \n+    public void testBasic2() {\n+        String input = \"a \\nb\\fc\";\n+        Tokenizer tok = new Tokenizer(input);\n+        assertEquals(\"a\", tok.next());\n+        assertEquals(\"b\", tok.next());\n+        assertEquals(\"c\", tok.next());\n+    }\n+    \n+    public void testBasic3() {\n+        String input = \"a \\nb\\u0001\\fc\";\n+        Tokenizer tok = new Tokenizer(input);\n+        assertEquals(\"a\", tok.next());\n+        assertEquals(\"b\\u0001\", tok.next());\n+        assertEquals(\"c\", tok.next());\n+    }\n+    \n+    public void testBasic4() {\n+        String input = \"a \\\"b\\\" c\";\n+        Tokenizer tok = new Tokenizer(input);\n+        assertEquals(\"a\", tok.next());\n+        assertEquals(\"\\\"b\\\"\", tok.next());\n+        assertEquals(\"c\", tok.next());\n+    }\n+    \n+    public void testBasicQuoted1() {\n+        String input = \"a \\\"b\\\" c\";\n+        Tokenizer tok = new Tokenizer(input, ' ', '\"');\n+        assertEquals(\"a\", tok.next());\n+        assertEquals(\"b\", tok.next());\n+        assertEquals(\"c\", tok.next());\n+    }\n+    \n+    public void testBasicDelim1() {\n+        String input = \"a:b:c\";\n+        Tokenizer tok = new Tokenizer(input, ':');\n+        assertEquals(\"a\", tok.next());\n+        assertEquals(\"b\", tok.next());\n+        assertEquals(\"c\", tok.next());\n+    }\n+    \n+    public void testBasicDelim2() {\n+        String input = \"a:b:c\";\n+        Tokenizer tok = new Tokenizer(input, ',');\n+        assertEquals(\"a:b:c\", tok.next());\n+    }\n+    \n+    public void testBasicEmpty1() {\n+        String input = \"a  b c\";\n+        Tokenizer tok = new Tokenizer(input);\n+        tok.setIgnoreEmptyTokens(false);\n+        assertEquals(\"a\", tok.next());\n+        assertEquals(\"\", tok.next());\n+        assertEquals(\"b\", tok.next());\n+        assertEquals(\"c\", tok.next());\n+    }\n+    \n+    public void testBasicEmpty2() {\n+        String input = \"a  b c\";\n+        Tokenizer tok = new Tokenizer(input);\n+        tok.setIgnoreEmptyTokens(false);\n+        tok.setEmptyTokenAsNull(true);\n+        assertEquals(\"a\", tok.next());\n+        assertEquals(null, tok.next());\n+        assertEquals(\"b\", tok.next());\n+        assertEquals(\"c\", tok.next());\n+    }\n+    \n+    public void testGetContent() {\n+        String input = \"a   b c \\\"d e\\\" f \";\n+        Tokenizer tok = new Tokenizer(input);\n+        assertSame(input, tok.getContent());\n+        \n+        tok = new Tokenizer(input.toCharArray());\n+        assertEquals(input, tok.getContent());\n+    }\n+\n+    public void testReset() {\n+        String input = \"a b c\";\n+        Tokenizer tok = new Tokenizer(input);\n+        assertEquals(\"a\", tok.next());\n+        assertEquals(\"b\", tok.next());\n+        assertEquals(\"c\", tok.next());\n+        tok.reset();\n+        assertEquals(\"a\", tok.next());\n+        assertEquals(\"b\", tok.next());\n+        assertEquals(\"c\", tok.next());\n+        tok.reset(\"d e\");\n+        assertEquals(\"d\", tok.next());\n+        assertEquals(\"e\", tok.next());\n+        tok.reset(\"f g\".toCharArray());\n+        assertEquals(\"f\", tok.next());\n+        assertEquals(\"g\", tok.next());\n+    }\n+    \n+    public void testMatcher() {\n+        assertEquals(true, Tokenizer.SPACE_MATCHER.isMatch(' '));\n+        assertEquals(false, Tokenizer.SPACE_MATCHER.isMatch('\\n'));\n+        assertEquals(false, Tokenizer.SPACE_MATCHER.isMatch('\\u0001'));\n+        \n+        assertEquals(true, Tokenizer.TRIM_MATCHER.isMatch(' '));\n+        assertEquals(true, Tokenizer.TRIM_MATCHER.isMatch('\\n'));\n+        assertEquals(true, Tokenizer.TRIM_MATCHER.isMatch('\\u0001'));\n+        \n+        assertEquals(true, Tokenizer.SPLIT_MATCHER.isMatch(' '));\n+        assertEquals(true, Tokenizer.SPLIT_MATCHER.isMatch('\\n'));\n+        assertEquals(false, Tokenizer.SPLIT_MATCHER.isMatch('\\u0001'));\n+    }\n+    \n }", "timestamp": 1076718715, "metainfo": ""}