{"sha": "27a6d5796806ee2f6344af5ea0187dce94d10aa8", "log": "Rework to support nulls properly Add support for comparators   ", "commit": "\n--- a/src/java/org/apache/commons/lang/builder/CompareToBuilder.java\n+++ b/src/java/org/apache/commons/lang/builder/CompareToBuilder.java\n \n import java.lang.reflect.Field;\n import java.lang.reflect.Modifier;\n+import java.util.Comparator;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n \n import org.apache.commons.lang.NumberUtils;\n+import org.apache.commons.lang.enum.Enum;\n /** \n  * <p><code>CompareTo</code> generation routines.</p>\n  *\n  * <code>hashcode</code> built with {@link EqualsBuilder} and\n  * {@link HashCodeBuilder}.</p>\n  *\n- * <p>Two object that compare equal using equals should compare equals using\n- * compareTo</p>.\n+ * <p>Two object that compare equal using equals should normally compare \n+ * equals using compareTo</p>.\n  *\n  * <p>All relevant fields should be included in the calculation of the\n  * comparison. Derived fields may be ignored. The same fields, in the same\n  *\n  * @author <a href=\"mailto:steve.downey@netfolio.com\">Steve Downey</a>\n  * @author <a href=\"mailto:scolebourne@joda.org\">Stephen Colebourne</a>\n- * @version $Id: CompareToBuilder.java,v 1.5 2002/11/17 21:46:42 scolebourne Exp $\n+ * @version $Id: CompareToBuilder.java,v 1.6 2002/12/08 21:38:19 scolebourne Exp $\n  */\n public class CompareToBuilder {\n+    \n     /**\n      * If the fields tested are equals.\n      */\n     /**\n      * <p>Constructor for CompareToBuilder.</p>\n      *\n-     * <p>Starts off assuming that the objects are equal.</p>\n-     *\n-     * @see java.lang.Object#Object()\n+     * <p>Starts off assuming that the objects are equal. Multiple calls are \n+     * then made to the various append methods, followed by a call to \n+     * {@link #toComparison} to get the result.</p>\n      */\n     public CompareToBuilder() {\n         super();\n      *\n      * <p>Static fields will not be tested.</p>\n      *\n-     * @param lhs  Left Hand Side\n-     * @param rhs  Right Hand Side\n+     * @param lhs  <code>this</code> object\n+     * @param rhs  the other object\n      * @return a negative integer, zero, or a positive integer as this \n      *  Object is less than, equal to, or greater than the specified Object.\n      * @throws NullPointerException  if either (but not both) parameter is\n      *\n      * <p>Static fields will not be tested.</p>\n      * \n-     * @param lhs  Left Hand Side\n-     * @param rhs  Right Hand Side\n+     * @param lhs  <code>this</code> object\n+     * @param rhs  the other object\n      * @param testTransients  whether to include transient fields\n      * @return a negative integer, zero, or a positive integer as this \n      *  Object is less than, equal to, or greater than the specified Object.\n      * @throws ClassCastException  if the specified Object's type prevents it\n      *  from being compared to this Object.\n      */\n-    public static int reflectionCompare(Object lhs, Object rhs, \n-            boolean testTransients) {\n+    public static int reflectionCompare(Object lhs, Object rhs, boolean testTransients) {\n         if (lhs == rhs) {\n             return 0;\n         }\n                 if (!Modifier.isStatic(f.getModifiers())) {\n                     try {\n                         compareToBuilder.append(f.get(lhs), f.get(rhs));\n-                    } catch (IllegalAccessException e) {\n+                    } catch (IllegalAccessException ex) {\n                         //this can't happen. Would get a Security exception instead\n                         //throw a runtime exception in case the impossible happens.\n                         throw new InternalError(\"Unexpected IllegalAccessException\");\n     //-------------------------------------------------------------------------\n     \n     /**\n-     * <p>Test if two <code>Object</code>s are equal using either the\n-     * <code>compareTo</code> method, or native comparison if the Objects are\n-     * actually arrays.</p>\n-     *\n-     * <p>The objects must be <code>Comparable</code>. If they are not, the\n-     * method will throw a <code>ClassCastException</code>.</p>\n-     *\n-     * @param lhs - Left Hand Side\n-     * @param rhs - Right Hand Side\n-     * @return CompareToBuilder - used to chain calls.\n-     * @throws NullPointerException  if either (but not both) parameter is\n-     *  <code>null</code>\n+     * <p>Comparison of two Object references.</p>\n+     * <ol>\n+     * <li>Check if Objects are same using <code>==</code>\n+     * <li>Check if either is null, a null object is less than a non-null\n+     * <li>Check the object contents\n+     * </ol>\n+     * \n+     * <p>The first parameter to be compared must either be an array or implement\n+     * Comparable.</p>\n+     *\n+     * @param lhs  the Object from <code>this</code> object\n+     * @param rhs  the Object from the other object\n+     * @return CompareToBuilder - used to chain calls.\n      * @throws ClassCastException if the specified Object's type prevents it\n      * from being compared to this Object.\n      */\n     public CompareToBuilder append(Object lhs, Object rhs) {\n-        if (comparison != 0) {\n-            return this;\n-        }\n-        if (lhs == rhs) {\n-            return this;\n-        }\n-        if (lhs == null || rhs == null) {\n-            throw new NullPointerException();\n+        return append(lhs, rhs, null);\n+    }\n+\n+    /**\n+     * <p>Comparison of two Object references.</p>\n+     * <ol>\n+     * <li>Check if Objects are same using <code>==</code>\n+     * <li>Check if either is null, a null object is less than a non-null\n+     * <li>Check the object contents\n+     * </ol>\n+     * \n+     * <p>If the first parameter to be compared is an array, the array methods will\n+     * be used. Otherwise the comparator will be used. If the comparator is null, \n+     * the <code>lhs</code> will be cast to Comparable.</p>\n+     *\n+     * @param lhs  the Object from <code>this</code> object\n+     * @param rhs  the Object from the other object\n+     * @param comparator  the comparator to use to compare the objects,\n+     *  <code>null</code> means to treat the <code>lhs</code> as <code>Comparable</code>.\n+     * @return CompareToBuilder - used to chain calls.\n+     * @throws ClassCastException if the specified Object's type prevents it\n+     * from being compared to this Object.\n+     */\n+    public CompareToBuilder append(Object lhs, Object rhs, Comparator comparator) {\n+        if (comparison != 0) {\n+            return this;\n+        }\n+        if (lhs == rhs) {\n+            return this;\n+        }\n+        if (lhs == null) {\n+            comparison = -1;\n+            return this;\n+        }\n+        if (rhs == null) {\n+            comparison = +1;\n+            return this;\n         }\n         Class lhsClass = lhs.getClass();\n-        if (!lhsClass.isArray()) {\n-            //the simple case, not an array, just test the element \n-            comparison = ((Comparable) lhs).compareTo(rhs);\n-        } else {\n-            //'Switch' on type of array, to dispatch to the correct handler\n+        if (lhsClass.isArray()) {\n+            // 'Switch' on type of array, to dispatch to the correct handler\n             // This handles multi dimensional arrays\n+            // this could throw a ClassCastException is rhs is not the correct array type\n             if (lhs instanceof long[]) {\n                 append((long[]) lhs, (long[]) rhs);\n             } else if (lhs instanceof int[]) {\n                 append((boolean[]) lhs, (boolean[]) rhs);\n             } else {\n                 // Not an array of primitives\n-                append((Object[]) lhs, (Object[]) rhs);\n+                // this could throw a ClassCastException is rhs is not an array\n+                append((Object[]) lhs, (Object[]) rhs, comparator);\n             }\n+        } else {\n+            // the simple case, not an array, just test the element\n+            if (comparator == null) {\n+                comparison = ((Comparable) lhs).compareTo(rhs);\n+            } else {\n+                comparison = comparator.compare(lhs, rhs);\n+            }\n         }\n         return this;\n     }\n     /**\n      * <p>Test if two <code>long</code>s are <, > or ==.</p>\n      *\n-     * @param lhs - Left Hand Side\n-     * @param rhs - Right Hand Side\n+     * @param lhs  the <code>long</code> from <code>this</code> object\n+     * @param rhs  the <code>long</code> from the other object\n      * @return CompareToBuilder - used to chain calls.\n      */\n     public CompareToBuilder append(long lhs, long rhs) {\n     /**\n      * <p>Test if two <code>int</code>s are <, > or ==.</p>\n      *\n-     * @param lhs - Left Hand Side\n-     * @param rhs - Right Hand Side\n+     * @param lhs  the <code>int</code> from <code>this</code> object\n+     * @param rhs  the <code>int</code> from the other object\n      * @return CompareToBuilder - used to chain calls.\n      */\n     public CompareToBuilder append(int lhs, int rhs) {\n \n     /**\n      * <p>Test if two <code>short</code>s are <, > or ==.</p>\n-     * @param lhs - Left Hand Side\n-     * @param rhs - Right Hand Side\n+     * \n+     * @param lhs  the <code>short</code> from <code>this</code> object\n+     * @param rhs  the <code>short</code> from the other object\n      * @return CompareToBuilder - used to chain calls.\n      */\n     public CompareToBuilder append(short lhs, short rhs) {\n     /**\n      * <p>Test if two <code>char</code>s are <, > or ==.</p>\n      *\n-     * @param lhs - Left Hand Side\n-     * @param rhs - Right Hand Side\n+     * @param lhs  the <code>char</code> from <code>this</code> object\n+     * @param rhs  the <code>char</code> from the other object\n      * @return CompareToBuilder - used to chain calls.\n      */\n     public CompareToBuilder append(char lhs, char rhs) {\n \n     /**\n      * <p>Test if two <code>byte</code>s are <, > or ==.</p>\n-     * @param lhs - Left Hand Side\n-     * @param rhs - Right Hand Side\n+     * \n+     * @param lhs  the <code>byte</code> from <code>this</code> object\n+     * @param rhs  the <code>byte</code> from the other object\n      * @return CompareToBuilder - used to chain calls.\n      */\n     public CompareToBuilder append(byte lhs, byte rhs) {\n      * <p>It is compatible with the hash code generated by\n      * <code>HashCodeBuilder</code>.</p>\n      *\n-     * @param lhs - Left Hand Side\n-     * @param rhs - Right Hand Side\n+     * @param lhs  the <code>double</code> from <code>this</code> object\n+     * @param rhs  the <code>double</code> from the other object\n      * @return CompareToBuilder - used to chain calls.\n      */\n     public CompareToBuilder append(double lhs, double rhs) {\n     }\n \n     /**\n-     * <p>Test if two <code>double</code>s are <, > or ==.</p>\n+     * <p>Test if two <code>float</code>s are <, > or ==.</p>\n      *\n      * <p>This handles NaNs, Infinties, and <code>-0.0</code>.</p>\n      *\n      * <p>It is compatible with the hash code generated by\n      * <code>HashCodeBuilder</code>.</p>\n      *\n-     * @param lhs - Left Hand Side\n-     * @param rhs - Right Hand Side\n+     * @param lhs  the <code>float</code> from <code>this</code> object\n+     * @param rhs  the <code>float</code> from the other object\n      * @return CompareToBuilder - used to chain calls.\n      */\n     public CompareToBuilder append(float lhs, float rhs) {\n     /**\n      * <p>Test if two <code>booleans</code>s are <, > or ==.</p>\n      *\n-     * @param lhs - Left Hand Side\n-     * @param rhs - Right Hand Side\n+     * @param lhs  the <code>boolean</code> from <code>this</code> object\n+     * @param rhs  the <code>boolean</code> from the other object\n      * @return CompareToBuilder - used to chain calls.\n       */\n     public CompareToBuilder append(boolean lhs, boolean rhs) {\n     }\n \n     /**\n-     * <p>Performs a deep comparison of two Object arrays.</p>\n-     *\n-     * <p>This also will be called for the top level of multi-dimensional,\n+     * <p>Deep comparison of an <code>Object</code> array.</p>\n+     * <ol>\n+     * <li>Check if arrays are same using <code>==</code>\n+     * <li>Check if either is null, a null array is less than a non-null\n+     * <li>Check array length, a short length array is less than a long length array\n+     * <li>Check array contents element by element using {@link #append(long, long)}\n+     * </ol>\n+     *\n+     * <p>This method will also will be called for the top level of multi-dimensional,\n      * ragged, and multi-typed arrays.</p>\n      *\n-     * <p>If two arrays are of different lengths, and all elements of the\n-     * shorter array are equal to the elements in the longer array, the longer\n-     * array is the greater. This is dictionary, or lexical, ordering.</p>\n-     *\n-     * @param lhs - Left Hand Side\n-     * @param rhs - Right Hand Side\n-     * @return CompareToBuilder - used to chain calls.\n-     * @throws NullPointerException  if either (but not both) parameter is\n-     *  <code>null</code>\n+     * @param lhs  array from <code>this</code> object\n+     * @param rhs  array from the other object\n+     * @return CompareToBuilder - used to chain calls.\n      * @throws ClassCastException  if the specified Object's type prevents it\n      *  from being compared to this Object.\n      */\n     public CompareToBuilder append(Object[] lhs, Object[] rhs) {\n-        if (comparison != 0) {\n-            return this;\n-        }\n-        if (lhs == rhs) {\n-            return this;\n-        }\n-        if (lhs == null || rhs == null) {\n-            throw new NullPointerException();\n-        }\n-\n-        int length = (lhs.length < rhs.length) ? lhs.length : rhs.length;\n-        for (int i = 0; i < length && comparison == 0; ++i) {\n-            Class lhsClass = lhs[i].getClass();\n-            if (!lhsClass.isInstance(rhs[i])) {\n-                throw new ClassCastException();\n-            }\n+        return append(lhs, rhs, null);\n+    }\n+    \n+    /**\n+     * <p>Deep comparison of an <code>Object</code> array.</p>\n+     * <ol>\n+     * <li>Check if arrays are same using <code>==</code>\n+     * <li>Check if either is null, a null array is less than a non-null\n+     * <li>Check array length, a shorter length array is less than a longer length array\n+     * <li>Check array contents element by element using {@link #append(Object, Object, Comparator)}\n+     * </ol>\n+     *\n+     * <p>This method will also will be called for the top level of multi-dimensional,\n+     * ragged, and multi-typed arrays.</p>\n+     *\n+     * @param lhs  array from <code>this</code> object\n+     * @param rhs  array from the other object\n+     * @param comparator  the comparator to use to compare the objects,\n+     *  <code>null</code> means to treat the <code>lhs</code> as <code>Comparable</code>.\n+     * @return CompareToBuilder - used to chain calls.\n+     * @throws ClassCastException  if the specified Object's type prevents it\n+     *  from being compared to this Object.\n+     */\n+    public CompareToBuilder append(Object[] lhs, Object[] rhs, Comparator comparator) {\n+        if (comparison != 0) {\n+            return this;\n+        }\n+        if (lhs == rhs) {\n+            return this;\n+        }\n+        if (lhs == null) {\n+            comparison = -1;\n+            return this;\n+        }\n+        if (rhs == null) {\n+            comparison = +1;\n+            return this;\n+        }\n+        if (lhs.length != rhs.length) {\n+            comparison = (lhs.length < rhs.length) ? -1 : +1;\n+            return this;\n+        }\n+        for (int i = 0; i < lhs.length && comparison == 0; i++) {\n+            append(lhs[i], rhs[i], comparator);\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Deep comparison of a <code>long</code> array.</p>\n+     * <ol>\n+     * <li>Check if arrays are same using <code>==</code>\n+     * <li>Check if either is null, a null array is less than a non-null\n+     * <li>Check array length, a shorter length array is less than a longer length array\n+     * <li>Check array contents element by element using {@link #append(long, long)}\n+     * </ol>\n+     *\n+     * @param lhs  array from <code>this</code> object\n+     * @param rhs  array from the other object\n+     * @return CompareToBuilder - used to chain calls.\n+     */\n+    public CompareToBuilder append(long[] lhs, long[] rhs) {\n+        if (comparison != 0) {\n+            return this;\n+        }\n+        if (lhs == rhs) {\n+            return this;\n+        }\n+        if (lhs == null) {\n+            comparison = -1;\n+            return this;\n+        }\n+        if (rhs == null) {\n+            comparison = +1;\n+            return this;\n+        }\n+        if (lhs.length != rhs.length) {\n+            comparison = (lhs.length < rhs.length) ? -1 : +1;\n+            return this;\n+        }\n+        for (int i = 0; i < lhs.length && comparison == 0; i++) {\n             append(lhs[i], rhs[i]);\n         }\n-        if (comparison == 0 && lhs.length != rhs.length) {\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Deep comparison of an <code>int</code> array.</p>\n+     * <ol>\n+     * <li>Check if arrays are same using <code>==</code>\n+     * <li>Check if either is null, a null array is less than a non-null\n+     * <li>Check array length, a shorter length array is less than a longer length array\n+     * <li>Check array contents element by element using {@link #append(int, int)}\n+     * </ol>\n+     *\n+     * @param lhs  array from <code>this</code> object\n+     * @param rhs  array from the other object\n+     * @return CompareToBuilder - used to chain calls.\n+     */\n+    public CompareToBuilder append(int[] lhs, int[] rhs) {\n+        if (comparison != 0) {\n+            return this;\n+        }\n+        if (lhs == rhs) {\n+            return this;\n+        }\n+        if (lhs == null) {\n+            comparison = -1;\n+            return this;\n+        }\n+        if (rhs == null) {\n+            comparison = +1;\n+            return this;\n+        }\n+        if (lhs.length != rhs.length) {\n             comparison = (lhs.length < rhs.length) ? -1 : +1;\n-        }\n-        return this;\n-    }\n-\n-    /**\n-     * <p>Deep comparison of array of <code>long</code> Length and all values\n-     * are compared.</p>\n-     *\n-     * <p>The method {@link #append(long, long)} is used.</p>\n-     *\n-     * @param lhs - Left Hand Side\n-     * @param rhs - Right Hand Side\n-     * @return CompareToBuilder - used to chain calls.\n-     * @throws NullPointerException  if either (but not both) parameter is\n-     *  <code>null</code>\n-     */\n-    public CompareToBuilder append(long[] lhs, long[] rhs) {\n-        if (comparison != 0) {\n-            return this;\n-        }\n-        if (lhs == rhs) {\n-            return this;\n-        }\n-        if (lhs == null || rhs == null) {\n-            throw new NullPointerException();\n-        }\n-        int length = (lhs.length < rhs.length) ? lhs.length : rhs.length;\n-        for (int i = 0; i < length && comparison == 0; ++i) {\n+            return this;\n+        }\n+        for (int i = 0; i < lhs.length && comparison == 0; i++) {\n             append(lhs[i], rhs[i]);\n         }\n-        if (comparison == 0 && lhs.length != rhs.length) {\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Deep comparison of a <code>short</code> array.</p>\n+     * <ol>\n+     * <li>Check if arrays are same using <code>==</code>\n+     * <li>Check if either is null, a null array is less than a non-null\n+     * <li>Check array length, a shorter length array is less than a longer length array\n+     * <li>Check array contents element by element using {@link #append(short, short)}\n+     * </ol>\n+     *\n+     * @param lhs  array from <code>this</code> object\n+     * @param rhs  array from the other object\n+     * @return CompareToBuilder - used to chain calls.\n+     */\n+    public CompareToBuilder append(short[] lhs, short[] rhs) {\n+        if (comparison != 0) {\n+            return this;\n+        }\n+        if (lhs == rhs) {\n+            return this;\n+        }\n+        if (lhs == null) {\n+            comparison = -1;\n+            return this;\n+        }\n+        if (rhs == null) {\n+            comparison = +1;\n+            return this;\n+        }\n+        if (lhs.length != rhs.length) {\n             comparison = (lhs.length < rhs.length) ? -1 : +1;\n-        }\n-        return this;\n-    }\n-\n-    /**\n-     * <p>Deep comparison of array of <code>int</code> Length and all values\n-     * are compared.</p>\n-     *\n-     * <p>The method {@link #append(int, int)} is used.</p>\n-     *\n-     * @param lhs - Left Hand Side\n-     * @param rhs - Right Hand Side\n-     * @return CompareToBuilder - used to chain calls.\n-     * @throws NullPointerException  if either (but not both) parameter is\n-     *  <code>null</code>\n-     */\n-    public CompareToBuilder append(int[] lhs, int[] rhs) {\n-        if (comparison != 0) {\n-            return this;\n-        }\n-        if (lhs == rhs) {\n-            return this;\n-        }\n-        if (lhs == null || rhs == null) {\n-            throw new NullPointerException();\n-        }\n-        int length = (lhs.length < rhs.length) ? lhs.length : rhs.length;\n-        for (int i = 0; i < length && comparison == 0; ++i) {\n+            return this;\n+        }\n+        for (int i = 0; i < lhs.length && comparison == 0; i++) {\n             append(lhs[i], rhs[i]);\n         }\n-        if (comparison == 0 && lhs.length != rhs.length) {\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Deep comparison of a <code>char</code> array.</p>\n+     * <ol>\n+     * <li>Check if arrays are same using <code>==</code>\n+     * <li>Check if either is null, a null array is less than a non-null\n+     * <li>Check array length, a shorter length array is less than a longer length array\n+     * <li>Check array contents element by element using {@link #append(char, char)}\n+     * </ol>\n+     *\n+     * @param lhs  array from <code>this</code> object\n+     * @param rhs  array from the other object\n+     * @return CompareToBuilder - used to chain calls.\n+     */\n+    public CompareToBuilder append(char[] lhs, char[] rhs) {\n+        if (comparison != 0) {\n+            return this;\n+        }\n+        if (lhs == rhs) {\n+            return this;\n+        }\n+        if (lhs == null) {\n+            comparison = -1;\n+            return this;\n+        }\n+        if (rhs == null) {\n+            comparison = +1;\n+            return this;\n+        }\n+        if (lhs.length != rhs.length) {\n             comparison = (lhs.length < rhs.length) ? -1 : +1;\n-        }\n-        return this;\n-    }\n-\n-    /**\n-     * <p>Deep comparison of array of <code>short</code> Length and all values\n-     * are compared.</p>\n-     *\n-     * <p>The method {@link #append(short, short)} is used.</p>\n-     *\n-     * @param lhs - Left Hand Side\n-     * @param rhs - Right Hand Side\n-     * @return CompareToBuilder - used to chain calls.\n-     * @throws NullPointerException  if either (but not both) parameter is\n-     *  <code>null<code>\n-     */\n-    public CompareToBuilder append(short[] lhs, short[] rhs) {\n-        if (comparison != 0) {\n-            return this;\n-        }\n-        if (lhs == rhs) {\n-            return this;\n-        }\n-        if (lhs == null || rhs == null) {\n-            throw new NullPointerException();\n-        }\n-        int length = (lhs.length < rhs.length) ? lhs.length : rhs.length;\n-        for (int i = 0; i < length && comparison == 0; ++i) {\n+            return this;\n+        }\n+        for (int i = 0; i < lhs.length && comparison == 0; i++) {\n             append(lhs[i], rhs[i]);\n         }\n-        if (comparison == 0 && lhs.length != rhs.length) {\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Deep comparison of a <code>byte</code> array.</p>\n+     * <ol>\n+     * <li>Check if arrays are same using <code>==</code>\n+     * <li>Check if either is null, a null array is less than a non-null\n+     * <li>Check array length, a shorter length array is less than a longer length array\n+     * <li>Check array contents element by element using {@link #append(byte, byte)}\n+     * </ol>\n+     *\n+     * @param lhs  array from <code>this</code> object\n+     * @param rhs  array from the other object\n+     * @return CompareToBuilder - used to chain calls.\n+     */\n+    public CompareToBuilder append(byte[] lhs, byte[] rhs) {\n+        if (comparison != 0) {\n+            return this;\n+        }\n+        if (lhs == rhs) {\n+            return this;\n+        }\n+        if (lhs == null) {\n+            comparison = -1;\n+            return this;\n+        }\n+        if (rhs == null) {\n+            comparison = +1;\n+            return this;\n+        }\n+        if (lhs.length != rhs.length) {\n             comparison = (lhs.length < rhs.length) ? -1 : +1;\n-        }\n-        return this;\n-    }\n-\n-    /**\n-     * <p>Deep comparison of array of <code>char</code> Length and all values\n-     * are compared.</p>\n-     *\n-     * <p>The method {@link #append(char, char)} is used.</p>\n-     *\n-     * @param lhs - Left Hand Side\n-     * @param rhs - Right Hand Side\n-     * @return CompareToBuilder - used to chain calls.\n-     * @throws NullPointerException  if either (but not both) parameter is\n-     *  <code>null</code>\n-     */\n-    public CompareToBuilder append(char[] lhs, char[] rhs) {\n-        if (comparison != 0) {\n-            return this;\n-        }\n-        if (lhs == rhs) {\n-            return this;\n-        }\n-        if (lhs == null || rhs == null) {\n-            throw new NullPointerException();\n-        }\n-        int length = (lhs.length < rhs.length) ? lhs.length : rhs.length;\n-        for (int i = 0; i < length && comparison == 0; ++i) {\n+            return this;\n+        }\n+        for (int i = 0; i < lhs.length && comparison == 0; i++) {\n             append(lhs[i], rhs[i]);\n         }\n-        if (comparison == 0 && lhs.length != rhs.length) {\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Deep comparison of a <code>double</code> array.</p>\n+     * <ol>\n+     * <li>Check if arrays are same using <code>==</code>\n+     * <li>Check if either is null, a null array is less than a non-null\n+     * <li>Check array length, a shorter length array is less than a longer length array\n+     * <li>Check array contents element by element using {@link #append(double, double)}\n+     * </ol>\n+     *\n+     * @param lhs  array from <code>this</code> object\n+     * @param rhs  array from the other object\n+     * @return CompareToBuilder - used to chain calls.\n+     */\n+    public CompareToBuilder append(double[] lhs, double[] rhs) {\n+        if (comparison != 0) {\n+            return this;\n+        }\n+        if (lhs == rhs) {\n+            return this;\n+        }\n+        if (lhs == null) {\n+            comparison = -1;\n+            return this;\n+        }\n+        if (rhs == null) {\n+            comparison = +1;\n+            return this;\n+        }\n+        if (lhs.length != rhs.length) {\n             comparison = (lhs.length < rhs.length) ? -1 : +1;\n-        }\n-        return this;\n-    }\n-\n-    /**\n-     * <p>Deep comparison of array of <code>byte</code> Length and all values\n-     * are compared.</p>\n-     *\n-     * <p>The method {@link #append(byte, byte)} is used.</p>\n-     *\n-     * @param lhs - Left Hand Side\n-     * @param rhs - Right Hand Side\n-     * @return CompareToBuilder - used to chain calls.\n-     * @throws NullPointerException  if either (but not both) parameter is\n-     *  <code>null</code>\n-     */\n-    public CompareToBuilder append(byte[] lhs, byte[] rhs) {\n-        if (comparison != 0) {\n-            return this;\n-        }\n-        if (lhs == rhs) {\n-            return this;\n-        }\n-        if (lhs == null || rhs == null) {\n-            throw new NullPointerException();\n-        }\n-        int length = (lhs.length < rhs.length) ? lhs.length : rhs.length;\n-        for (int i = 0; i < length && comparison == 0; ++i) {\n+            return this;\n+        }\n+        for (int i = 0; i < lhs.length && comparison == 0; i++) {\n             append(lhs[i], rhs[i]);\n         }\n-        if (comparison == 0 && lhs.length != rhs.length) {\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Deep comparison of a <code>float</code> array.</p>\n+     * <ol>\n+     * <li>Check if arrays are same using <code>==</code>\n+     * <li>Check if either is null, a null array is less than a non-null\n+     * <li>Check array length, a shorter length array is less than a longer length array\n+     * <li>Check array contents element by element using {@link #append(float, float)}\n+     * </ol>\n+     *\n+     * @param lhs  array from <code>this</code> object\n+     * @param rhs  array from the other object\n+     * @return CompareToBuilder - used to chain calls.\n+     */\n+    public CompareToBuilder append(float[] lhs, float[] rhs) {\n+        if (comparison != 0) {\n+            return this;\n+        }\n+        if (lhs == rhs) {\n+            return this;\n+        }\n+        if (lhs == null) {\n+            comparison = -1;\n+            return this;\n+        }\n+        if (rhs == null) {\n+            comparison = +1;\n+            return this;\n+        }\n+        if (lhs.length != rhs.length) {\n             comparison = (lhs.length < rhs.length) ? -1 : +1;\n-        }\n-        return this;\n-    }\n-\n-    /**\n-     * <p>Deep comparison of array of <code>double</code> Length and all values\n-     * are compared.</p>\n-     *\n-     * <p>The method {@link #append(double, double)} is used.</p>\n-     *\n-     * @param lhs - Left Hand Side\n-     * @param rhs - Right Hand Side\n-     * @return CompareToBuilder - used to chain calls.\n-     * @throws NullPointerException  if either (but not both) parameter is\n-     *  <code>null</code>\n-     */\n-    public CompareToBuilder append(double[] lhs, double[] rhs) {\n-        if (comparison != 0) {\n-            return this;\n-        }\n-        if (lhs == rhs) {\n-            return this;\n-        }\n-        if (lhs == null || rhs == null) {\n-            throw new NullPointerException();\n-        }\n-        int length = (lhs.length < rhs.length) ? lhs.length : rhs.length;\n-        for (int i = 0; i < length && comparison == 0; ++i) {\n+            return this;\n+        }\n+        for (int i = 0; i < lhs.length && comparison == 0; i++) {\n             append(lhs[i], rhs[i]);\n         }\n-        if (comparison == 0 && lhs.length != rhs.length) {\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Deep comparison of a <code>boolean/code> array.</p>\n+     * <ol>\n+     * <li>Check if arrays are same using <code>==</code>\n+     * <li>Check if either is null, a null array is less than a non-null\n+     * <li>Check array length, a shorter length array is less than a longer length array\n+     * <li>Check array contents element by element using {@link #append(boolean, boolean)}\n+     * </ol>\n+     *\n+     * @param lhs  array from <code>this</code> object\n+     * @param rhs  array from the other object\n+     * @return CompareToBuilder - used to chain calls.\n+     */\n+    public CompareToBuilder append(boolean[] lhs, boolean[] rhs) {\n+        if (comparison != 0) {\n+            return this;\n+        }\n+        if (lhs == rhs) {\n+            return this;\n+        }\n+        if (lhs == null) {\n+            comparison = -1;\n+            return this;\n+        }\n+        if (rhs == null) {\n+            comparison = +1;\n+            return this;\n+        }\n+        if (lhs.length != rhs.length) {\n             comparison = (lhs.length < rhs.length) ? -1 : +1;\n-        }\n-        return this;\n-    }\n-\n-    /**\n-     * <p>Deep comparison of array of <code>float</code> Length and all values\n-     * are compared.</p>\n-     *\n-     * <p>The method {@link #append(float, float)} is used.</p>\n-     *\n-     * @param lhs - Left Hand Side\n-     * @param rhs - Right Hand Side\n-     * @return CompareToBuilder - used to chain calls.\n-     * @throws NullPointerException  if either (but not both) parameter is\n-     *  <code>null</code>\n-     */\n-    public CompareToBuilder append(float[] lhs, float[] rhs) {\n-        if (comparison != 0) {\n-            return this;\n-        }\n-        if (lhs == rhs) {\n-            return this;\n-        }\n-        if (lhs == null || rhs == null) {\n-            throw new NullPointerException();\n-        }\n-        int length = (lhs.length < rhs.length) ? lhs.length : rhs.length;\n-        for (int i = 0; i < length && comparison == 0; ++i) {\n+            return this;\n+        }\n+        for (int i = 0; i < lhs.length && comparison == 0; i++) {\n             append(lhs[i], rhs[i]);\n-        }\n-        if (comparison == 0 && lhs.length != rhs.length) {\n-            comparison = (lhs.length < rhs.length) ? -1 : +1;\n-        }\n-        return this;\n-    }\n-\n-    /**\n-     * <p>Deep comparison of array of <code>boolean</code> Length and all values\n-     * are compared.</p>\n-     *\n-     * <p>The method {@link #append(boolean, boolean)} is used.</p>\n-     *\n-     * @param lhs - Left Hand Side\n-     * @param rhs - Right Hand Side\n-     * @return CompareToBuilder - used to chain calls.\n-     * @throws NullPointerException  if either (but not both) parameter is\n-     *  <code>null</code>\n-     */\n-    public CompareToBuilder append(boolean[] lhs, boolean[] rhs) {\n-        if (comparison != 0) {\n-            return this;\n-        }\n-        if (lhs == rhs) {\n-            return this;\n-        }\n-        if (lhs == null || rhs == null) {\n-            throw new NullPointerException();\n-        }\n-        int length = (lhs.length < rhs.length) ? lhs.length : rhs.length;\n-        for (int i = 0; i < length && comparison == 0; ++i) {\n-            append(lhs[i], rhs[i]);\n-        }\n-        if (comparison == 0 && lhs.length != rhs.length) {\n-            comparison = (lhs.length < rhs.length) ? -1 : +1;\n         }\n         return this;\n     }\n--- a/src/test/org/apache/commons/lang/builder/CompareToBuilderTest.java\n+++ b/src/test/org/apache/commons/lang/builder/CompareToBuilderTest.java\n  *\n  * @author <a href=\"mailto:sdowney@panix.com\">Steve Downey</a>\n  * @author <a href=\"mailto:scolebourne@joda.org\">Stephen Colebourne</a>\n- * @version $Id: CompareToBuilderTest.java,v 1.1 2002/09/15 10:27:06 scolebourne Exp $\n+ * @version $Id: CompareToBuilderTest.java,v 1.2 2002/12/08 21:37:25 scolebourne Exp $\n  */\n public class CompareToBuilderTest extends TestCase {\n \n         Object o2 = new Object();\n         try {\n             CompareToBuilder.reflectionCompare(o1, o2);\n-        } catch (ClassCastException ex) {\n-            return;\n-        }\n-        fail();\n+            fail();\n+        } catch (ClassCastException ex) {}\n     }\n \n     public void testObject() {\n         o2.setA(5);\n         assertTrue(new CompareToBuilder().append(o1, o2).toComparison() < 0);\n         assertTrue(new CompareToBuilder().append(o2, o1).toComparison() > 0);\n-    }\n-\n-    public void testObjectEx1() {\n-        TestObject o1 = new TestObject(4);\n-        try {\n-            new CompareToBuilder().append(o1, null).toComparison();\n-        } catch (NullPointerException ex) {\n-            return;\n-        }\n-        fail();\n+        \n+        assertTrue(new CompareToBuilder().append(o1, null).toComparison() > 0);\n+        assertTrue(new CompareToBuilder().append((Object) null, (Object) null).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(null, o1).toComparison() < 0);\n     }\n \n     public void testObjectEx2() {\n         TestObject o1 = new TestObject(4);\n         Object o2 = new Object();\n         try {\n-            new CompareToBuilder().append(o1, o2).toComparison();\n-        } catch (ClassCastException ex) {\n-            return;\n-        }\n-        fail();\n+            new CompareToBuilder().append(o1, o2);\n+            fail();\n+        } catch (ClassCastException ex) {}\n+    }\n+\n+    public void testObjectComparator() {\n+        String o1 = \"Fred\";\n+        String o2 = \"Fred\";\n+        assertTrue(new CompareToBuilder().append(o1, o1, String.CASE_INSENSITIVE_ORDER).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(o1, o2, String.CASE_INSENSITIVE_ORDER).toComparison() == 0);\n+        o2 = \"FRED\";\n+        assertTrue(new CompareToBuilder().append(o1, o2, String.CASE_INSENSITIVE_ORDER).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(o2, o1, String.CASE_INSENSITIVE_ORDER).toComparison() == 0);\n+        o2 = \"FREDA\";\n+        assertTrue(new CompareToBuilder().append(o1, o2, String.CASE_INSENSITIVE_ORDER).toComparison() < 0);\n+        assertTrue(new CompareToBuilder().append(o2, o1, String.CASE_INSENSITIVE_ORDER).toComparison() > 0);\n+        \n+        assertTrue(new CompareToBuilder().append(o1, null, String.CASE_INSENSITIVE_ORDER).toComparison() > 0);\n+        assertTrue(new CompareToBuilder().append((Object) null, (Object) null, String.CASE_INSENSITIVE_ORDER).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(null, o1, String.CASE_INSENSITIVE_ORDER).toComparison() < 0);\n+    }\n+    \n+    public void testObjectComparatorNull() {\n+        String o1 = \"Fred\";\n+        String o2 = \"Fred\";\n+        assertTrue(new CompareToBuilder().append(o1, o1, null).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(o1, o2, null).toComparison() == 0);\n+        o2 = \"Zebra\";\n+        assertTrue(new CompareToBuilder().append(o1, o2, null).toComparison() < 0);\n+        assertTrue(new CompareToBuilder().append(o2, o1, null).toComparison() > 0);\n+        \n+        assertTrue(new CompareToBuilder().append(o1, null, null).toComparison() > 0);\n+        assertTrue(new CompareToBuilder().append((Object) null, (Object) null, null).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(null, o1, null).toComparison() < 0);\n     }\n \n     public void testLong() {\n         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0);\n         assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0);\n         assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0);\n-\n+        \n         obj1[1] = new TestObject(7);\n         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0);\n         assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0);\n-    }\n-\n-    public void testObjectArrayEx1() {\n-        TestObject[] obj1 = new TestObject[2];\n-        obj1[0] = new TestObject(4);\n-        obj1[1] = new TestObject(5);\n-        try {\n-            new CompareToBuilder().append(obj1, null).toComparison();\n-        } catch (NullPointerException ex) {\n-            return;\n-        }\n-        fail();\n+\n+        assertTrue(new CompareToBuilder().append(obj1, null).toComparison() > 0);\n+        assertTrue(new CompareToBuilder().append((Object[]) null, (Object[]) null).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(null, obj1).toComparison() < 0);\n     }\n \n     public void testLongArray() {\n         obj1[1] = 7;\n         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0);\n         assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0);\n+\n+        assertTrue(new CompareToBuilder().append(obj1, null).toComparison() > 0);\n+        assertTrue(new CompareToBuilder().append((long[]) null, (long[]) null).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(null, obj1).toComparison() < 0);\n     }\n \n     public void testIntArray() {\n         obj1[1] = 7;\n         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0);\n         assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0);\n+\n+        assertTrue(new CompareToBuilder().append(obj1, null).toComparison() > 0);\n+        assertTrue(new CompareToBuilder().append((int[]) null, (int[]) null).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(null, obj1).toComparison() < 0);\n     }\n \n     public void testShortArray() {\n         obj1[1] = 7;\n         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0);\n         assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0);\n+\n+        assertTrue(new CompareToBuilder().append(obj1, null).toComparison() > 0);\n+        assertTrue(new CompareToBuilder().append((short[]) null, (short[]) null).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(null, obj1).toComparison() < 0);\n     }\n \n     public void testCharArray() {\n         obj1[1] = 7;\n         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0);\n         assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0);\n+\n+        assertTrue(new CompareToBuilder().append(obj1, null).toComparison() > 0);\n+        assertTrue(new CompareToBuilder().append((char[]) null, (char[]) null).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(null, obj1).toComparison() < 0);\n     }\n \n     public void testByteArray() {\n         obj1[1] = 7;\n         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0);\n         assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0);\n+\n+        assertTrue(new CompareToBuilder().append(obj1, null).toComparison() > 0);\n+        assertTrue(new CompareToBuilder().append((byte[]) null, (byte[]) null).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(null, obj1).toComparison() < 0);\n     }\n \n     public void testDoubleArray() {\n         obj1[1] = 7;\n         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0);\n         assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0);\n+\n+        assertTrue(new CompareToBuilder().append(obj1, null).toComparison() > 0);\n+        assertTrue(new CompareToBuilder().append((double[]) null, (double[]) null).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(null, obj1).toComparison() < 0);\n     }\n \n     public void testFloatArray() {\n         obj1[1] = 7;\n         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0);\n         assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0);\n+\n+        assertTrue(new CompareToBuilder().append(obj1, null).toComparison() > 0);\n+        assertTrue(new CompareToBuilder().append((float[]) null, (float[]) null).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(null, obj1).toComparison() < 0);\n     }\n \n     public void testBooleanArray() {\n         obj1[1] = true;\n         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0);\n         assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0);\n+\n+        assertTrue(new CompareToBuilder().append(obj1, null).toComparison() > 0);\n+        assertTrue(new CompareToBuilder().append((boolean[]) null, (boolean[]) null).toComparison() == 0);\n+        assertTrue(new CompareToBuilder().append(null, obj1).toComparison() < 0);\n     }\n \n     public void testMultiLongArray() {\n \n         array1[1] = new TestObject(7);\n         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0);\n-        assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0);    }\n+        assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0);\n+    }\n \n     public void testLongArrayHiddenByObject() {\n         long[] array1 = new long[2];", "timestamp": 1039383499, "metainfo": ""}