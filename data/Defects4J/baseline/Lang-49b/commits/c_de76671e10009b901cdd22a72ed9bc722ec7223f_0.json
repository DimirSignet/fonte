{"sha": "de76671e10009b901cdd22a72ed9bc722ec7223f", "log": "Moved from superpackage   ", "commit": "\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang/builder/HashCodeBuilder.java\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2002 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.lang.builder;\n+\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Modifier;\n+/**\n+ * <code>HashCode</code> generation routines.\n+ * <p>\n+ * This class enables a good hashcode to be built for any class. It follows\n+ * the rules laid out in the book Effective Java, by Joshua Bloch. Writing a \n+ * good hashCode is actually quite difficult. This class aims to simplify the \n+ * process.\n+ * <p>\n+ * All relevant fields from the object should be included in the hashCode. Derived\n+ * fields may be excluded. In general, any field used in the equals method must be\n+ * used in the hashCode method. \n+ * <p>\n+ * To use this class write code as follows:\n+ * <code>\n+ * public class Person {\n+ *   String name;\n+ *   int age;\n+ *   boolean isSmoker;\n+ *   ...\n+ * \n+ *   public int hashCode() {\n+ *     // you pick a hard-coded, randomly chosen, non-zero, odd number\n+ *     // ideally different for each class\n+ *     return new HashCodeBuilder(17, 37).   \n+ *       append(name).\n+ *       append(age).\n+ *       append(smoker).\n+ *       toHashCode();\n+ *   }\n+ * }\n+ * </code>\n+ * <p>\n+ * Alternatively, there is a method that uses reflection to determine\n+ * the fields to test. Because these fields are usually private, the method, \n+ * <code>reflectionTest</code>, uses <code>Field.setAccessible</code> to change\n+ * the visibility of the fields. This will fail under a security manager, \n+ * unless the appropriate permissions are set. It is also slower than testing \n+ * explicitly.\n+ * <p>\n+ * A typical invocation for this method would look like:\n+ * <code>\n+ * public boolean hashCode(Object o) {\n+ *   return HashCodeBuilder.reflectionHashCode(this);\n+ * }\n+ * </code>\n+ * \n+ * @author <a href=\"mailto:scolebourne@joda.org\">Stephen Colebourne</a>\n+ * @version $Id: HashCodeBuilder.java,v 1.1 2002/09/12 21:59:01 scolebourne Exp $\n+ */\n+public class HashCodeBuilder {\n+    \n+    /**\n+     * Constant to use in building the hashCode\n+     */\n+    private final int iConstant;\n+    /**\n+     * Running total of the hashCode\n+     */\n+    private int iTotal = 0;\n+    \n+    /**\n+     * Constructor for HashCodeBuilder.\n+     * This constructor uses two hard coded choices for the constants needed\n+     * to build a hashCode.\n+     */\n+    public HashCodeBuilder() {\n+        super();\n+        iConstant = 37;\n+        iTotal = 17;\n+    }\n+    \n+    /**\n+     * Constructor for HashCodeBuilder.\n+     * Two randomly chosen, non-zero, odd numbers must be passed in. Ideally\n+     * these should be different for each class, however this is not vital.\n+     * Prime numbers are preferred, especially for the multiplier.\n+     * \n+     * @param initialNonZeroOddNumber\n+     * @param multiplierNonZeroOddNumber\n+     * @throws IllegalArgumentException if the number is zero or even\n+     */\n+    public HashCodeBuilder(int initialNonZeroOddNumber, int multiplierNonZeroOddNumber) {\n+        super();\n+        if (initialNonZeroOddNumber == 0) {\n+            throw new IllegalArgumentException(\"HashCodeBuilder requires a non zero initial value\");\n+        }\n+        if (initialNonZeroOddNumber % 2 == 0) {\n+            throw new IllegalArgumentException(\"HashCodeBuilder requires an odd initial value\");\n+        }\n+        if (multiplierNonZeroOddNumber == 0) {\n+            throw new IllegalArgumentException(\"HashCodeBuilder requires a non zero multiplier\");\n+        }\n+        if (multiplierNonZeroOddNumber % 2 == 0) {\n+            throw new IllegalArgumentException(\"HashCodeBuilder requires an odd multiplier\");\n+        }\n+        iConstant = multiplierNonZeroOddNumber;\n+        iTotal = initialNonZeroOddNumber;\n+    }\n+\n+    //-------------------------------------------------------------------------\n+    \n+    /**\n+     * This method uses reflection to build a valid hash code. \n+     * <p>\n+     * It uses Field.setAccessible to gain access to private fields. This means\n+     * that it will throw a security exception if run under a security manger, if\n+     * the permissions are not set up.\n+     * It is also not as efficient as testing explicitly. \n+     * Transient members will be not be used, as they are likely derived \n+     * fields, and not part of the value of the object. \n+     * This constructor uses two hard coded choices for the constants needed\n+     * to build a hash code.\n+     * \n+     * @param object  the object to create a hash code for\n+     * @return int hash code\n+     * @throws IllegalArgumentException if the object is null\n+     */\n+    public static int reflectionHashCode(Object object) {\n+        return reflectionHashCode(object, false);\n+    }\n+\n+    /**\n+     * This method uses reflection to build a valid hash code. \n+     * <p>\n+     * It uses Field.setAccessible to gain access to private fields. This means\n+     * that it will throw a security exception if run under a security manger, if\n+     * the permissions are not set up.\n+     * It is also not as efficient as testing explicitly. \n+     * Transient members will be not be used, as they are likely derived \n+     * fields, and not part of the value of the object. \n+     * <p>\n+     * Two randomly chosen, non-zero, odd numbers must be passed in. Ideally\n+     * these should be different for each class, however this is not vital.\n+     * Prime numbers are preferred, especially for the multiplier.\n+     * \n+     * @param initialNonZeroOddNumber\n+     * @param multiplierNonZeroOddNumber\n+     * @param object  the object to create a hash code for\n+     * @return int hash code\n+     * @throws IllegalArgumentException if the object is null\n+     * @throws IllegalArgumentException if the number is zero or even\n+     */\n+    public static int reflectionHashCode(\n+            int initialNonZeroOddNumber, int multiplierNonZeroOddNumber,\n+            Object object) {\n+        return reflectionHashCode(initialNonZeroOddNumber, multiplierNonZeroOddNumber, object);\n+    }\n+    \n+    /**\n+     * This method uses reflection to build a valid hash code. \n+     * <p>\n+     * It uses Field.setAccessible to gain access to private fields. This means\n+     * that it will throw a security exception if run under a security manger, if\n+     * the permissions are not set up.\n+     * It is also not as efficient as testing explicitly. \n+     * If the TestTransients parameter is set to true, transient members will be\n+     * tested, otherwise they are ignored, as they are likely derived fields, and\n+     * not part of the value of the object. \n+     * This constructor uses two hard coded choices for the constants needed\n+     * to build a hash code.\n+     * \n+     * @param object  the object to create a hash code for\n+     * @param testTransients  whether to include transient fields\n+     * @return int hash code\n+     * @throws IllegalArgumentException if the object is null\n+     */\n+    public static int reflectionHashCode(Object object, boolean testTransients) {\n+        return reflectionHashCode(17, 37, object, testTransients);\n+    }\n+        \n+    /**\n+     * This method uses reflection to build a valid hash code. \n+     * <p>\n+     * It uses Field.setAccessible to gain access to private fields. This means\n+     * that it will throw a security exception if run under a security manger, if\n+     * the permissions are not set up.\n+     * It is also not as efficient as testing explicitly. \n+     * If the TestTransients parameter is set to true, transient members will be\n+     * tested, otherwise they are ignored, as they are likely derived fields, and\n+     * not part of the value of the object. \n+     * <p>\n+     * Two randomly chosen, non-zero, odd numbers must be passed in. Ideally\n+     * these should be different for each class, however this is not vital.\n+     * Prime numbers are preferred, especially for the multiplier.\n+     * \n+     * @param initialNonZeroOddNumber\n+     * @param multiplierNonZeroOddNumber\n+     * @param object  the object to create a hash code for\n+     * @param testTransients  whether to include transient fields\n+     * @return int hash code\n+     * @throws IllegalArgumentException if the object is null\n+     * @throws IllegalArgumentException if the number is zero or even\n+     */\n+    public static int reflectionHashCode(\n+            int initialNonZeroOddNumber, int multiplierNonZeroOddNumber,\n+            Object object, boolean testTransients) {\n+                \n+        if (object == null) {\n+            throw new IllegalArgumentException(\"The object to build a hash code for must not be null\");\n+        }\n+        HashCodeBuilder hashCodeBuilder = new HashCodeBuilder(initialNonZeroOddNumber, multiplierNonZeroOddNumber);\n+        Field[] fields = object.getClass().getDeclaredFields();\n+        Field.setAccessible(fields, true);\n+        for (int i = 0; i < fields.length; ++i) {\n+            Field f = fields[i];\n+            if (testTransients || !Modifier.isTransient(f.getModifiers())) {\n+                try {\n+                    hashCodeBuilder.append(f.get(object));\n+                } catch (IllegalAccessException e) {\n+                    //this can't happen. Would get a Security exception instead\n+                    //throw a runtime exception in case the impossible happens.\n+                    throw new InternalError(\"Unexpected IllegalAccessException\");\n+                }\n+            }\n+        }\n+        return hashCodeBuilder.toHashCode();\n+    }\n+\n+    //-------------------------------------------------------------------------\n+    \n+    /**\n+     * Append a hashCode for an Object.\n+     *\n+     * @param object  the object to add to the hashCode\n+     * @return this\n+     */\n+    public HashCodeBuilder append(Object object) {\n+        if (object == null) {\n+            iTotal = iTotal * iConstant;\n+            \n+        } else {\n+            if (object.getClass().isArray() == false) {\n+                //the simple case, not an array, just the element \n+                iTotal = iTotal * iConstant + object.hashCode();\n+                \n+            } else {\n+                //'Switch' on type of array, to dispatch to the correct handler\n+                // This handles multi dimensional arrays\n+                if (object instanceof long[]) {\n+                    append((long[]) object);\n+                } else if (object instanceof int[]) {\n+                    append((int[]) object);\n+                } else if (object instanceof short[]) {\n+                    append((short[]) object);\n+                } else if (object instanceof char[]) {\n+                    append((char[]) object);\n+                } else if (object instanceof byte[]) {\n+                    append((byte[]) object);\n+                } else if (object instanceof double[]) {\n+                    append((double[]) object);\n+                } else if (object instanceof float[]) {\n+                    append((float[]) object);\n+                } else if (object instanceof boolean[]) {\n+                    append((boolean[]) object);\n+                } else { \n+                    // Not an array of primitives\n+                    append((Object[]) object);\n+                }\n+            }\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Append a hashCode for a long.\n+     *\n+     * @param value  the long to add to the hashCode\n+     * @return this\n+     */\n+    public HashCodeBuilder append(long value) {\n+        iTotal = iTotal * iConstant + ((int) (value ^ (value >> 32)));\n+        return this;\n+    }\n+\n+    /**\n+     * Append a hashCode for an int.\n+     *\n+     * @param value  the int to add to the hashCode\n+     * @return this\n+     */\n+    public HashCodeBuilder append(int value) {\n+        iTotal = iTotal * iConstant + value;\n+        return this;\n+    }\n+\n+    /**\n+     * Append a hashCode for a short.\n+     *\n+     * @param value  the short to add to the hashCode\n+     * @return this\n+     */\n+    public HashCodeBuilder append(short value) {\n+        iTotal = iTotal * iConstant + (int) value;\n+        return this;\n+    }\n+\n+    /**\n+     * Append a hashCode for a char.\n+     *\n+     * @param value  the char to add to the hashCode\n+     * @return this\n+     */\n+    public HashCodeBuilder append(char value) {\n+        iTotal = iTotal * iConstant + (int) value;\n+        return this;\n+    }\n+\n+    /**\n+     * Append a hashCode for a byte.\n+     *\n+     * @param value  the byte to add to the hashCode\n+     * @return this\n+     */\n+    public HashCodeBuilder append(byte value) {\n+        iTotal = iTotal * iConstant + (int) value;\n+        return this;\n+    }\n+\n+    /**\n+     * Append a hashCode for a double.\n+     *\n+     * @param value  the double to add to the hashCode\n+     * @return this\n+     */\n+    public HashCodeBuilder append(double value) {\n+        return append(Double.doubleToLongBits(value));\n+    }\n+\n+    /**\n+     * Append a hashCode for a float.\n+     *\n+     * @param value  the float to add to the hashCode\n+     * @return this\n+     */\n+    public HashCodeBuilder append(float value) {\n+        iTotal = iTotal * iConstant + Float.floatToIntBits(value);\n+        return this;\n+    }\n+\n+    /**\n+     * Append a hashCode for a long.\n+     *\n+     * @param value  the long to add to the hashCode\n+     * @return this\n+     */\n+    public HashCodeBuilder append(boolean value) {\n+        iTotal = iTotal * iConstant + (value ? 0 : 1);\n+        return this;\n+    }\n+\n+    /**\n+     * Append a hashCode for an Object array.\n+     *\n+     * @param array  the array to add to the hashCode\n+     * @return this\n+     */\n+    public HashCodeBuilder append(Object[] array) {\n+        if (array == null) {\n+            iTotal = iTotal * iConstant;\n+        } else {\n+            for (int i = 0; i < array.length; i++) {\n+                append(array[i]);\n+            }\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Append a hashCode for a long array.\n+     *\n+     * @param array  the array to add to the hashCode\n+     * @return this\n+     */\n+    public HashCodeBuilder append(long[] array) {\n+        if (array == null) {\n+            iTotal = iTotal * iConstant;\n+        } else {\n+            for (int i = 0; i < array.length; i++) {\n+                append(array[i]);\n+            }\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Append a hashCode for an int array.\n+     *\n+     * @param array  the array to add to the hashCode\n+     * @return this\n+     */\n+    public HashCodeBuilder append(int[] array) {\n+        if (array == null) {\n+            iTotal = iTotal * iConstant;\n+        } else {\n+            for (int i = 0; i < array.length; i++) {\n+                append(array[i]);\n+            }\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Append a hashCode for a short array.\n+     *\n+     * @param array  the array to add to the hashCode\n+     * @return this\n+     */\n+    public HashCodeBuilder append(short[] array) {\n+        if (array == null) {\n+            iTotal = iTotal * iConstant;\n+        } else {\n+            for (int i = 0; i < array.length; i++) {\n+                append(array[i]);\n+            }\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Append a hashCode for a char array.\n+     *\n+     * @param array  the array to add to the hashCode\n+     * @return this\n+     */\n+    public HashCodeBuilder append(char[] array) {\n+        if (array == null) {\n+            iTotal = iTotal * iConstant;\n+        } else {\n+            for (int i = 0; i < array.length; i++) {\n+                append(array[i]);\n+            }\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Append a hashCode for a byte array.\n+     *\n+     * @param array  the array to add to the hashCode\n+     * @return this\n+     */\n+    public HashCodeBuilder append(byte[] array) {\n+        if (array == null) {\n+            iTotal = iTotal * iConstant;\n+        } else {\n+            for (int i = 0; i < array.length; i++) {\n+                append(array[i]);\n+            }\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Append a hashCode for a double array.\n+     *\n+     * @param array  the array to add to the hashCode\n+     * @return this\n+     */\n+    public HashCodeBuilder append(double[] array) {\n+        if (array == null) {\n+            iTotal = iTotal * iConstant;\n+        } else {\n+            for (int i = 0; i < array.length; i++) {\n+                append(array[i]);\n+            }\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Append a hashCode for a float array.\n+     *\n+     * @param array  the array to add to the hashCode\n+     * @return this\n+     */\n+    public HashCodeBuilder append(float[] array) {\n+        if (array == null) {\n+            iTotal = iTotal * iConstant;\n+        } else {\n+            for (int i = 0; i < array.length; i++) {\n+                append(array[i]);\n+            }\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Append a hashCode for a boolean array.\n+     *\n+     * @param array  the array to add to the hashCode\n+     * @return this\n+     */\n+    public HashCodeBuilder append(boolean[] array) {\n+        if (array == null) {\n+            iTotal = iTotal * iConstant;\n+        } else {\n+            for (int i = 0; i < array.length; i++) {\n+                append(array[i]);\n+            }\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Return the computed hashCode\n+     * \n+     * @return int hashCode based on the fields appended\n+     */    \n+    public int toHashCode() {\n+        return iTotal;\n+    }\n+\n+}", "timestamp": 1031867941, "metainfo": ""}