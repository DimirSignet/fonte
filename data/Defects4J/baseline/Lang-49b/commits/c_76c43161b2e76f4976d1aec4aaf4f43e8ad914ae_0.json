{"sha": "76c43161b2e76f4976d1aec4aaf4f43e8ad914ae", "log": "Applying Pete Gieser's enhancement for the CompareToBuilder - a clone of the EqualsBuilder and HashCodeBuilder fixes previously applied. Bugzilla issue #39398  ", "commit": "\n--- a/src/java/org/apache/commons/lang/builder/CompareToBuilder.java\n+++ b/src/java/org/apache/commons/lang/builder/CompareToBuilder.java\n import java.lang.reflect.AccessibleObject;\n import java.lang.reflect.Field;\n import java.lang.reflect.Modifier;\n+import java.util.Arrays;\n+import java.util.Collections;\n import java.util.Comparator;\n+import java.util.List;\n \n import org.apache.commons.lang.math.NumberUtils;\n \n      *  with <code>lhs</code>\n      */\n     public static int reflectionCompare(Object lhs, Object rhs) {\n-        return reflectionCompare(lhs, rhs, false, null);\n+        return reflectionCompare(lhs, rhs, false, null, null);\n     }\n \n     /**\n      *  with <code>lhs</code>\n      */\n     public static int reflectionCompare(Object lhs, Object rhs, boolean compareTransients) {\n-        return reflectionCompare(lhs, rhs, compareTransients, null);\n+        return reflectionCompare(lhs, rhs, compareTransients, null, null);\n+    }\n+\n+    /**\n+     * <p>Compares two <code>Object</code>s via reflection.</p>\n+     *\n+     * <p>Fields can be private, thus <code>AccessibleObject.setAccessible</code>\n+     * is used to bypass normal access control checks. This will fail under a \n+     * security manager unless the appropriate permissions are set.</p>\n+     *\n+     * <ul>\n+     * <li>Static fields will not be compared</li>\n+     * <li>If <code>compareTransients</code> is <code>true</code>,\n+     *     compares transient members.  Otherwise ignores them, as they\n+     *     are likely derived fields.</li>\n+     * <li>Superclass fields will be compared</li>\n+     * </ul>\n+     *\n+     * <p>If both <code>lhs</code> and <code>rhs</code> are <code>null</code>,\n+     * they are considered equal.</p>\n+     *\n+     * @param lhs  left-hand object\n+     * @param rhs  right-hand object\n+     * @param excludeFields  fields to exclude\n+     * @return a negative integer, zero, or a positive integer as <code>lhs</code>\n+     *  is less than, equal to, or greater than <code>rhs</code>\n+     * @throws NullPointerException  if either <code>lhs</code> or <code>rhs</code>\n+     *  (but not both) is <code>null</code>\n+     * @throws ClassCastException  if <code>rhs</code> is not assignment-compatible\n+     *  with <code>lhs</code>\n+     */\n+    public static int reflectionCompare(Object lhs, Object rhs, String[] excludeFields) {\n+        return reflectionCompare(lhs, rhs, false, null, excludeFields);\n     }\n \n     /**\n      *  with <code>lhs</code>\n      * @since 2.0\n      */\n-    public static int reflectionCompare(Object lhs, Object rhs, boolean compareTransients, Class reflectUpToClass) {\n+    public static int reflectionCompare(Object lhs, Object rhs, boolean compareTransients, Class reflectUpToClass, String[] excludeFields) {\n         if (lhs == rhs) {\n             return 0;\n         }\n             throw new ClassCastException();\n         }\n         CompareToBuilder compareToBuilder = new CompareToBuilder();\n-        reflectionAppend(lhs, rhs, lhsClazz, compareToBuilder, compareTransients);\n+        reflectionAppend(lhs, rhs, lhsClazz, compareToBuilder, compareTransients, excludeFields);\n         while (lhsClazz.getSuperclass() != null && lhsClazz != reflectUpToClass) {\n             lhsClazz = lhsClazz.getSuperclass();\n-            reflectionAppend(lhs, rhs, lhsClazz, compareToBuilder, compareTransients);\n+            reflectionAppend(lhs, rhs, lhsClazz, compareToBuilder, compareTransients, excludeFields);\n         }\n         return compareToBuilder.toComparison();\n     }\n      * @param clazz  <code>Class</code> that defines fields to be compared\n      * @param builder  <code>CompareToBuilder</code> to append to\n      * @param useTransients  whether to compare transient fields\n+     * @param excludeFields  fields to exclude\n      */\n     private static void reflectionAppend(\n         Object lhs,\n         Object rhs,\n         Class clazz,\n         CompareToBuilder builder,\n-        boolean useTransients) {\n+        boolean useTransients,\n+        String[] excludeFields) {\n         \n         Field[] fields = clazz.getDeclaredFields();\n+        List excludedFieldList = excludeFields != null ? Arrays.asList(excludeFields) : Collections.EMPTY_LIST;\n         AccessibleObject.setAccessible(fields, true);\n         for (int i = 0; i < fields.length && builder.comparison == 0; i++) {\n             Field f = fields[i];\n-            if ((f.getName().indexOf('$') == -1)\n+            if (!excludedFieldList.contains(f.getName())\n+                && (f.getName().indexOf('$') == -1)\n                 && (useTransients || !Modifier.isTransient(f.getModifiers()))\n                 && (!Modifier.isStatic(f.getModifiers()))) {\n                 try {\n--- a/src/test/org/apache/commons/lang/builder/CompareToBuilderTest.java\n+++ b/src/test/org/apache/commons/lang/builder/CompareToBuilderTest.java\n             this.t = t;\n         }\n     }\n-\n+    \n     public void testReflectionCompare() {\n         TestObject o1 = new TestObject(4);\n         TestObject o2 = new TestObject(4);\n     }\n \n     public void testReflectionHierarchyCompare() {\n-        testReflectionHierarchyCompare(false);\n+        testReflectionHierarchyCompare(false, null);\n+    }\n+    \n+    public void testReflectionHierarchyCompareExcludeFields() {\n+        String[] excludeFields = new String[] { \"b\" };\n+        testReflectionHierarchyCompare(true, excludeFields);\n+        \n+        TestSubObject x;\n+        TestSubObject y;\n+        TestSubObject z;\n+        \n+        x = new TestSubObject(1, 1);\n+        y = new TestSubObject(2, 1);\n+        z = new TestSubObject(3, 1);\n+        assertXYZCompareOrder(x, y, z, true, excludeFields);\n+\n+        x = new TestSubObject(1, 3);\n+        y = new TestSubObject(2, 2);\n+        z = new TestSubObject(3, 1);\n+        assertXYZCompareOrder(x, y, z, true, excludeFields);\n     }\n     \n     public void testReflectionHierarchyCompareTransients() {\n-        testReflectionHierarchyCompare(true);\n+        testReflectionHierarchyCompare(true, null);\n \n         TestTransientSubObject x;\n         TestTransientSubObject y;\n         x = new TestTransientSubObject(1, 1);\n         y = new TestTransientSubObject(2, 2);\n         z = new TestTransientSubObject(3, 3);\n-        assertXYZCompareOrder(x, y, z, true);\n+        assertXYZCompareOrder(x, y, z, true, null);\n         \n         x = new TestTransientSubObject(1, 1);\n         y = new TestTransientSubObject(1, 2);\n         z = new TestTransientSubObject(1, 3);\n-        assertXYZCompareOrder(x, y, z, true);  \n+        assertXYZCompareOrder(x, y, z, true, null);  \n     }\n     \n-    private void assertXYZCompareOrder(Object x, Object y, Object z, boolean testTransients) {\n-        assertTrue(0 == CompareToBuilder.reflectionCompare(x, x, testTransients));\n-        assertTrue(0 == CompareToBuilder.reflectionCompare(y, y, testTransients));\n-        assertTrue(0 == CompareToBuilder.reflectionCompare(z, z, testTransients));\n-        \n-        assertTrue(0 > CompareToBuilder.reflectionCompare(x, y, testTransients));\n-        assertTrue(0 > CompareToBuilder.reflectionCompare(x, z, testTransients));\n-        assertTrue(0 > CompareToBuilder.reflectionCompare(y, z, testTransients));\n-        \n-        assertTrue(0 < CompareToBuilder.reflectionCompare(y, x, testTransients));\n-        assertTrue(0 < CompareToBuilder.reflectionCompare(z, x, testTransients));\n-        assertTrue(0 < CompareToBuilder.reflectionCompare(z, y, testTransients));\n+    private void assertXYZCompareOrder(Object x, Object y, Object z, boolean testTransients, String[] excludeFields) {\n+        assertTrue(0 == CompareToBuilder.reflectionCompare(x, x, testTransients, null, excludeFields));\n+        assertTrue(0 == CompareToBuilder.reflectionCompare(y, y, testTransients, null, excludeFields));\n+        assertTrue(0 == CompareToBuilder.reflectionCompare(z, z, testTransients, null, excludeFields));\n+        \n+        assertTrue(0 > CompareToBuilder.reflectionCompare(x, y, testTransients, null, excludeFields));\n+        assertTrue(0 > CompareToBuilder.reflectionCompare(x, z, testTransients, null, excludeFields));\n+        assertTrue(0 > CompareToBuilder.reflectionCompare(y, z, testTransients, null, excludeFields));\n+        \n+        assertTrue(0 < CompareToBuilder.reflectionCompare(y, x, testTransients, null, excludeFields));\n+        assertTrue(0 < CompareToBuilder.reflectionCompare(z, x, testTransients, null, excludeFields));\n+        assertTrue(0 < CompareToBuilder.reflectionCompare(z, y, testTransients, null, excludeFields));\n     }\n     \n-    public void testReflectionHierarchyCompare(boolean testTransients) {\n+    public void testReflectionHierarchyCompare(boolean testTransients, String[] excludeFields) {\n         TestObject to1 = new TestObject(1);\n         TestObject to2 = new TestObject(2);\n         TestObject to3 = new TestObject(3);\n         TestSubObject tso2 = new TestSubObject(2, 2);\n         TestSubObject tso3 = new TestSubObject(3, 3);\n         \n-        assertReflectionCompareContract(to1, to1, to1, false);\n-        assertReflectionCompareContract(to1, to2, to3, false);\n-        assertReflectionCompareContract(tso1, tso1, tso1, false);\n-        assertReflectionCompareContract(tso1, tso2, tso3, false);\n-        assertReflectionCompareContract(\"1\", \"2\", \"3\", false);\n+        assertReflectionCompareContract(to1, to1, to1, false, excludeFields);\n+        assertReflectionCompareContract(to1, to2, to3, false, excludeFields);\n+        assertReflectionCompareContract(tso1, tso1, tso1, false, excludeFields);\n+        assertReflectionCompareContract(tso1, tso2, tso3, false, excludeFields);\n+        assertReflectionCompareContract(\"1\", \"2\", \"3\", false, excludeFields);\n         \n         assertTrue(0 != CompareToBuilder.reflectionCompare(tso1, new TestSubObject(1, 0), testTransients));\n         assertTrue(0 != CompareToBuilder.reflectionCompare(tso1, new TestSubObject(0, 1), testTransients));\n \n         // root class\n-        assertXYZCompareOrder(to1, to2, to3, true);\n+        assertXYZCompareOrder(to1, to2, to3, true, null);\n         // subclass  \n-        assertXYZCompareOrder(tso1, tso2, tso3, true);  \n+        assertXYZCompareOrder(tso1, tso2, tso3, true, null);  \n     }\n \n     /**\n      * @param y an object to compare\n      * @param z an object to compare\n      * @param testTransients Whether to include transients in the comparison\n+     * @param excludeFields fields to exclude\n      */\n-    public void assertReflectionCompareContract(Object x, Object y, Object z, boolean testTransients) {\n+    public void assertReflectionCompareContract(Object x, Object y, Object z, boolean testTransients, String[] excludeFields) {\n \n         // signum\n-        assertTrue(reflectionCompareSignum(x, y, testTransients) == -reflectionCompareSignum(y, x, testTransients));\n+        assertTrue(reflectionCompareSignum(x, y, testTransients, excludeFields) == -reflectionCompareSignum(y, x, testTransients, excludeFields));\n         \n         // transitive\n-        if (CompareToBuilder.reflectionCompare(x, y, testTransients) > 0 && CompareToBuilder.reflectionCompare(y, z, testTransients) > 0){\n-            assertTrue(CompareToBuilder.reflectionCompare(x, z, testTransients) > 0);\n+        if (CompareToBuilder.reflectionCompare(x, y, testTransients, null, excludeFields) > 0 \n+                && CompareToBuilder.reflectionCompare(y, z, testTransients, null, excludeFields) > 0){\n+            assertTrue(CompareToBuilder.reflectionCompare(x, z, testTransients, null, excludeFields) > 0);\n         }\n         \n         // un-named\n-        if (CompareToBuilder.reflectionCompare(x, y, testTransients) == 0) {\n-            assertTrue(reflectionCompareSignum(x, z, testTransients) == -reflectionCompareSignum(y, z, testTransients));\n+        if (CompareToBuilder.reflectionCompare(x, y, testTransients, null, excludeFields) == 0) {\n+            assertTrue(reflectionCompareSignum(x, z, testTransients, excludeFields) == -reflectionCompareSignum(y, z, testTransients, excludeFields));\n         }\n         \n         // strongly recommended but not strictly required\n      * @param lhs The \"left-hand-side\" of the comparison.\n      * @param rhs The \"right-hand-side\" of the comparison.\n      * @param testTransients Whether to include transients in the comparison\n+     * @param excludeFields fields to exclude\n      * @return int The signum\n      */\n-    private int reflectionCompareSignum(Object lhs, Object rhs, boolean testTransients) {\n+    private int reflectionCompareSignum(Object lhs, Object rhs, boolean testTransients, String[] excludeFields) {\n         return BigInteger.valueOf(CompareToBuilder.reflectionCompare(lhs, rhs, testTransients)).signum();\n     }\n     ", "timestamp": 1146006905, "metainfo": ""}