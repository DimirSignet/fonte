{"sha": "d362f5cf68674aa9c93ee5fef2a69e82937abd49", "log": "Initial commit of StrSubstitutor (VariableFormatter) for review  ", "commit": "\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang/text/StrSubstitutor.java\n+/*\n+ * Copyright 2005-2006 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.lang.text;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Substitutes variables within a string by values.\n+ * <p>\n+ * This class takes a piece of text and substitutes all the variables within it.\n+ * The default definition of a variable is <code>${variableName}</code>.\n+ * The prefix and suffix can be changed via constructors and set methods.\n+ * <p>\n+ * Variable values are typically resolved from a map, but could also be resolved\n+ * from system properties, or by supplying a custom variable resolver.\n+ * <p>\n+ * The simplest example is to use this class to replace Java System properties. For example:\n+ * <pre>\n+ * StrSubstitutor.replaceSystemProperties(\n+ *      \"You are running with java.version = ${java.version} and os.name = ${os.name}.\");\n+ * </pre>\n+ * <p>\n+ * Typical usage of this class follows the following pattern: First an instance is created\n+ * and initialized with the map that contains the values for the available variables.\n+ * If a prefix and/or suffix for variables should be used other than the default ones,\n+ * the appropriate settings can be performed. After that the <code>replace()</code>\n+ * method can be called passing in the source text for interpolation. In the returned\n+ * text all variable references (as long as their values are known) will be resolved.\n+ * The following example demonstrates this:\n+ * <pre>\n+ * Map valuesMap = HashMap();\n+ * valuesMap.put(&quot;animal&quot;, &quot;quick brown fox&quot;);\n+ * valuesMap.put(&quot;target&quot;, &quot;lazy dog&quot;);\n+ * String templateString = &quot;The ${animal} jumped over the ${target}.&quot;;\n+ * StrSubstitutor sub = new StrSubstitutor(valuesMap);\n+ * String resolvedString = sub.replace(templateString);\n+ * </pre>\n+ * yielding:\n+ * <pre>\n+ *      The quick brown fox jumped over the lazy dog.\n+ * </pre>\n+ * <p>\n+ * In addition to this usage pattern there are some static convenience methods that\n+ * cover the most common use cases. These methods can be used without the need of\n+ * manually creating an instance. However if multiple replace operations are to be\n+ * performed, creating and reusing an instance of this class will be more efficient.\n+ * <p>\n+ * Variable replacement works in a recursive way. Thus, if a variable value contains\n+ * a variable then that variable will also be replaced. Cyclic replacements are\n+ * detected and will cause an exception to be thrown.\n+ * <p>\n+ * Sometimes the interpolation's result must contain a variable prefix. As an example\n+ * take the following source text:\n+ * <pre>\n+ *   The variable ${${name}} must be used.\n+ * </pre>\n+ * Here only the variable's name refered to in the text should be replaced resulting\n+ * in the text (assuming that the value of the <code>name</code> variable is <code>x</code>:\n+ * <pre>\n+ *   The variable ${x} must be used.\n+ * </pre>\n+ * To achieve this effect there are two possibilities: Either set a different prefix\n+ * and suffix for variables which do not conflict with the result text you want to\n+ * produce. The other possibility is to use the escape character, by default '$'.\n+ * If this character is placed before a variable reference, this reference is ignored\n+ * and won't be replaced. For example:\n+ * <pre>\n+ *   The variable $${${name}} must be used.\n+ * </pre>\n+ *\n+ * @author Oliver Heger\n+ * @author Stephen Colebourne\n+ * @version $Id: VariableFormatter.java 420491 2006-07-10 11:23:57 +0000 (Mon, 10 Jul 2006) niallp $\n+ * @since 2.2\n+ */\n+public class StrSubstitutor {\n+\n+    /**\n+     * Constant for the default escape character.\n+     */\n+    public static final char DEFAULT_ESCAPE = '$';\n+    /**\n+     * Constant for the default variable prefix.\n+     */\n+    public static final StrMatcher DEFAULT_PREFIX = StrMatcher.stringMatcher(\"${\");\n+    /**\n+     * Constant for the default variable suffix.\n+     */\n+    public static final StrMatcher DEFAULT_SUFFIX = StrMatcher.stringMatcher(\"}\");\n+\n+    /**\n+     * Stores the escape character.\n+     */\n+    private char escapeChar;\n+    /**\n+     * Stores the variable prefix.\n+     */\n+    private StrMatcher prefixMatcher;\n+    /**\n+     * Stores the variable suffix.\n+     */\n+    private StrMatcher suffixMatcher;\n+    /**\n+     * Variable resolution is delegated to an implementor of VariableResolver.\n+     */\n+    private VariableResolver variableResolver;\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Replaces all the occurrences of variables in the given source object with\n+     * their matching values from the map.\n+     *\n+     * @param source  the source text containing the variables to substitute\n+     * @param valueMap  the map with the values\n+     * @return the result of the replace operation\n+     */\n+    public static String replace(Object source, Map valueMap) {\n+        return new StrSubstitutor(valueMap).replace(source);\n+    }\n+\n+    /**\n+     * Replaces all the occurrences of variables in the given source object with\n+     * their matching values from the map. This method allows to specifiy a\n+     * custom variable prefix and suffix\n+     *\n+     * @param source  the source text containing the variables to substitute\n+     * @param valueMap  the map with the values\n+     * @param prefix  the prefix of variables\n+     * @param suffix  the suffix of variables\n+     * @return the result of the replace operation\n+     */\n+    public static String replace(Object source, Map valueMap, String prefix, String suffix) {\n+        return new StrSubstitutor(valueMap, prefix, suffix).replace(source);\n+    }\n+\n+    /**\n+     * Replaces all the occurrences of variables in the given source object with\n+     * their matching values from the system properties.\n+     *\n+     * @param source  the source text containing the variables to substitute\n+     * @return the result of the replace operation\n+     */\n+    public static String replaceSystemProperties(Object source) {\n+        return new StrSubstitutor(System.getProperties()).replace(source);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Creates a new instance with defaults for variable prefix and suffix\n+     * and the escaping character.\n+     */\n+    public StrSubstitutor() {\n+        this((VariableResolver) null, DEFAULT_PREFIX, DEFAULT_SUFFIX, DEFAULT_ESCAPE);\n+    }\n+\n+    /**\n+     * Creates a new instance and initializes it. Uses defaults for variable\n+     * prefix and suffix and the escaping character.\n+     *\n+     * @param valueMap  the map with the variables' values, may be null\n+     */\n+    public StrSubstitutor(Map valueMap) {\n+        this(new MapVariableResolver(valueMap), DEFAULT_PREFIX, DEFAULT_SUFFIX, DEFAULT_ESCAPE);\n+    }\n+\n+    /**\n+     * Creates a new instance and initializes it. Uses a default escaping character.\n+     *\n+     * @param valueMap  the map with the variables' values, may be null\n+     * @param prefix  the prefix for variables, not null\n+     * @param suffix  the suffix for variables, not null\n+     * @throws IllegalArgumentException if the prefix or suffix is null\n+     */\n+    public StrSubstitutor(Map valueMap, String prefix, String suffix) {\n+        this(valueMap, prefix, suffix, DEFAULT_ESCAPE);\n+    }\n+\n+    /**\n+     * Creates a new instance and initializes it.\n+     *\n+     * @param valueMap  the map with the variables' values, may be null\n+     * @param prefix  the prefix for variables, not null\n+     * @param suffix  the suffix for variables, not null\n+     * @param escape  the escape character\n+     * @throws IllegalArgumentException if the prefix or suffix is null\n+     */\n+    public StrSubstitutor(Map valueMap, String prefix, String suffix, char escape) {\n+        this(new MapVariableResolver(valueMap), prefix, suffix, escape);\n+    }\n+\n+    /**\n+     * Creates a new instance and initializes it.\n+     *\n+     * @param variableResolver  the variable resolver, may be null\n+     * @param prefix  the prefix for variables, not null\n+     * @param suffix  the suffix for variables, not null\n+     * @param escape  the escape character\n+     * @throws IllegalArgumentException if the prefix or suffix is null\n+     */\n+    public StrSubstitutor(VariableResolver variableResolver, String prefix, String suffix, char escape) {\n+        this.setVariableResolver(variableResolver);\n+        this.setVariablePrefix(prefix);\n+        this.setVariableSuffix(suffix);\n+        this.setEscapeChar(escape);\n+    }\n+\n+    /**\n+     * Creates a new instance and initializes it.\n+     *\n+     * @param variableResolver  the variable resolver, may be null\n+     * @param prefix  the prefix for variables, not null\n+     * @param suffix  the suffix for variables, not null\n+     * @param escape  the escape character\n+     * @throws IllegalArgumentException if the prefix or suffix is null\n+     */\n+    public StrSubstitutor(VariableResolver variableResolver, StrMatcher prefix, StrMatcher suffix, char escape) {\n+        this.setVariableResolver(variableResolver);\n+        this.setVariablePrefixMatcher(prefix);\n+        this.setVariableSuffixMatcher(suffix);\n+        this.setEscapeChar(escape);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Replaces all the occurrences of variables in the given source array with\n+     * their matching values from the resolver.\n+     *\n+     * @param source  the character array to replace in, not altered, null returns null\n+     * @return the result of the replace operation\n+     */\n+    public String replace(char[] source) {\n+        if (source == null) {\n+            return null;\n+        }\n+        StrBuilder buf = new StrBuilder(source.length).append(source);\n+        substitute(buf, 0, source.length);\n+        return buf.toString();\n+    }\n+\n+    /**\n+     * Replaces all the occurrences of variables in the given source array by with\n+     * their matching values from the resolver.\n+     * Only the specified portion of the array will be processed.\n+     *\n+     * @param source  the character array to replace in, not altered, null returns null\n+     * @param offset  the start offset within the array, must be valid\n+     * @param length  the length within the array to be processed, must be valid\n+     * @return the result of the replace operation\n+     */\n+    public String replace(char[] source, int offset, int length) {\n+        if (source == null) {\n+            return null;\n+        }\n+        StrBuilder buf = new StrBuilder(length).append(source, offset, length);\n+        substitute(buf, 0, length);\n+        return buf.toString();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Replaces all the occurrences of variables in the given source string with\n+     * their matching values from the resolver.\n+     *\n+     * @param source  the string to replace in, null returns null\n+     * @return the result of the replace operation\n+     */\n+    public String replace(String source) {\n+        if (source == null) {\n+            return null;\n+        }\n+        StrBuilder buf = new StrBuilder(source);\n+        if (substitute(buf, 0, source.length()) == false) {\n+            return source;\n+        }\n+        return buf.toString();\n+    }\n+\n+    /**\n+     * Replaces all the occurrences of variables in the given source string by with\n+     * their matching values from the resolver.\n+     * Only the specified portion of the string will be processed.\n+     *\n+     * @param source  the string to replace in, null returns null\n+     * @param offset  the start offset within the array, must be valid\n+     * @param length  the length within the array to be processed, must be valid\n+     * @return the result of the replace operation\n+     */\n+    public String replace(String source, int offset, int length) {\n+        if (source == null) {\n+            return null;\n+        }\n+        StrBuilder buf = new StrBuilder(length).append(source, offset, length);\n+        if (substitute(buf, 0, length) == false) {\n+            return source.substring(offset, length);\n+        }\n+        return buf.toString();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Replaces all the occurrences of variables in the given source object with\n+     * their matching values from the resolver. The input source object is\n+     * converted to a string using <code>toString</code> and is not altered.\n+     *\n+     * @param source  the source to replace in, null returns null\n+     * @return the result of the replace operation\n+     */\n+    public String replace(Object source) {\n+        if (source == null) {\n+            return null;\n+        }\n+        StrBuilder buf = new StrBuilder().append(source);\n+        substitute(buf, 0, buf.length());\n+        return buf.toString();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Replaces all the occurrences of variables within the given source\n+     * builder with their matching values from the resolver.\n+     *\n+     * @param source  the builder to replace in, updated, null returns zero\n+     * @return true if altered\n+     */\n+    public boolean replace(StrBuilder source) {\n+        if (source == null) {\n+            return false;\n+        }\n+        return substitute(source, 0, source.length());\n+    }\n+\n+    /**\n+     * Replaces all the occurrences of variables within the given source\n+     * builder with their matching values from the resolver.\n+     * Only the specified portion of the builder will be processed, with\n+     * the remainder left untouched.\n+     *\n+     * @param source  the builder to replace in, null returns zero\n+     * @param offset  the start offset within the array, must be valid\n+     * @param length  the length within the array to be processed, must be valid\n+     * @return true if altered\n+     */\n+    public boolean replace(StrBuilder source, int offset, int length) {\n+        if (source == null) {\n+            return false;\n+        }\n+        return substitute(source, offset, length);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Main method for substituting variables.\n+     *\n+     * @param buf  the string builder to substitute into, not null\n+     * @param offset  the start offset within the builder, must be valid\n+     * @param length  the length within the builder to be processed, must be valid\n+     * @return true if altered\n+     */\n+    private boolean substitute(StrBuilder buf, int offset, int length) {\n+        return substitute(buf, offset, length, null) > 0;\n+    }\n+\n+    /**\n+     * Recursive handler for multiple levels of interpolation. This is the main\n+     * interpolation method, which resolves the values of all variable references\n+     * contained in the passed in text.\n+     *\n+     * @param buf  the string builder to substitute into, not null\n+     * @param offset  the start offset within the builder, must be valid\n+     * @param length  the length within the builder to be processed, must be valid\n+     * @param priorVariables  the stack keeping track of the replaced variables, may be null\n+     * @return the length change that occurs, unless priorVariables is null when the int\n+     *  represents a boolean flag as to whether any change occurred.\n+     */\n+    private int substitute(StrBuilder buf, int offset, int length, List priorVariables) {\n+        StrMatcher prefixMatcher = getVariablePrefixMatcher();\n+        StrMatcher suffixMatcher = getVariableSuffixMatcher();\n+        char escape = getEscapeChar();\n+        \n+        boolean top = (priorVariables == null);\n+        boolean altered = false;\n+        int lengthChange = 0;\n+        char[] chars = buf.buffer;\n+        int bufEnd = offset + length;\n+        int pos = offset;\n+        while (pos < bufEnd) {\n+            int startMatchLen = prefixMatcher.isMatch(chars, pos, offset, bufEnd);\n+            if (startMatchLen == 0) {\n+                pos++;\n+            } else {\n+                // found variable start marker\n+                if (pos > offset && chars[pos - 1] == escape) {\n+                    // escaped\n+                    buf.deleteCharAt(pos - 1);\n+                    chars = buf.buffer;  // in case buffer was altered\n+                    lengthChange--;\n+                    altered = true;\n+                    bufEnd--;\n+                } else {\n+                    // find suffix\n+                    int startPos = pos;\n+                    pos += startMatchLen;\n+                    int endMatchLen = 0;\n+                    while (pos < bufEnd) {\n+                        endMatchLen = suffixMatcher.isMatch(chars, pos, offset, bufEnd);\n+                        if (endMatchLen == 0) {\n+                            pos++;\n+                        } else {\n+                            // found variable end marker\n+                            String varName = new String(chars, startPos + startMatchLen, pos - startPos - startMatchLen);\n+                            pos += endMatchLen;\n+                            int endPos = pos;\n+                            \n+                            // on the first call initialize priorVariables\n+                            if (priorVariables == null) {\n+                                priorVariables = new ArrayList();\n+                                priorVariables.add(new String(chars, offset, length));\n+                            }\n+                            \n+                            // handle cyclic substitution\n+                            checkCyclicSubstitution(varName, priorVariables);\n+                            priorVariables.add(varName);\n+                            \n+                            // resolve the variable\n+                            String varValue = resolveVariable(varName);\n+                            if (varValue != null) {\n+                                // recursive replace\n+                                int varLen = varValue.length();\n+                                buf.replace(startPos, endPos, varValue);\n+                                altered = true;\n+                                int change = substitute(buf, startPos, varLen, priorVariables);\n+                                change = change + (varLen - (endPos - startPos));\n+                                pos += change;\n+                                bufEnd += change;\n+                                lengthChange += change;\n+                                chars = buf.buffer;  // in case buffer was altered\n+                            }\n+                            \n+                            // remove variable from the cyclic stack\n+                            priorVariables.remove(priorVariables.size() - 1);\n+                            break;\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+        if (top) {\n+            return (altered ? 1 : 0);\n+        }\n+        return lengthChange;\n+    }\n+\n+    /**\n+     * Checks if the specified variable is already in the stack (list) of variables.\n+     *\n+     * @param varName  the variable name to check\n+     * @param priorVariables  the list of prior variables\n+     */\n+    private void checkCyclicSubstitution(String varName, List priorVariables) {\n+        if (priorVariables.contains(varName) == false) {\n+            return;\n+        }\n+        StrBuilder buf = new StrBuilder(256);\n+        buf.append(\"Infinite loop in property interpolation of \");\n+        buf.append(priorVariables.remove(0));\n+        buf.append(\": \");\n+        buf.appendWithSeparators(priorVariables, \"->\");\n+        throw new IllegalStateException(buf.toString());\n+    }\n+\n+    /**\n+     * Resolves the specified variable. This method is called whenever a variable\n+     * reference is detected in the source text. It is passed the variable's name\n+     * and must return the corresponding value. This implementation accesses the\n+     * value map using the variable's name as key. Derived classes may override\n+     * this method to implement a different strategy for resolving variables.\n+     *\n+     * @param varName  the name of the variable\n+     * @return the variable's value or <b>null</b> if the variable is unknown\n+     */\n+    protected String resolveVariable(String varName) {\n+        VariableResolver lookup = getVariableResolver();\n+        if (lookup == null) {\n+            return null;\n+        }\n+        return lookup.resolveVariable(varName);\n+    }\n+\n+    // Escape\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns the escape character.\n+     *\n+     * @return the character used for escaping variable references\n+     */\n+    public char getEscapeChar() {\n+        return this.escapeChar;\n+    }\n+\n+    /**\n+     * Sets the escape character.\n+     * If this character is placed before a variable reference in the source\n+     * text, this variable will be ignored.\n+     *\n+     * @param escapeCharacter  the escape character (0 for disabling escaping)\n+     */\n+    public void setEscapeChar(char escapeCharacter) {\n+        this.escapeChar = escapeCharacter;\n+    }\n+\n+    // Prefix\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the variable prefix matcher currently in use.\n+     * <p>\n+     * The variable prefix is the characer or characters that identify the\n+     * start of a variable. This prefix is expressed in terms of a matcher\n+     * allowing advanced prefix matches.\n+     *\n+     * @return the prefix matcher in use\n+     */\n+    public StrMatcher getVariablePrefixMatcher() {\n+        return prefixMatcher;\n+    }\n+\n+    /**\n+     * Sets the variable prefix matcher currently in use.\n+     * <p>\n+     * The variable prefix is the characer or characters that identify the\n+     * start of a variable. This prefix is expressed in terms of a matcher\n+     * allowing advanced prefix matches.\n+     *\n+     * @param prefixMatcher  the prefix matcher to use, null ignored\n+     * @return this, to enable chaining\n+     * @throws IllegalArgumentException if the prefix matcher is null\n+     */\n+    public StrSubstitutor setVariablePrefixMatcher(StrMatcher prefixMatcher) {\n+        if (prefixMatcher == null) {\n+            throw new IllegalArgumentException(\"Variable prefix matcher must not be null!\");\n+        }\n+        this.prefixMatcher = prefixMatcher;\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the variable prefix to use.\n+     * <p>\n+     * The variable prefix is the characer or characters that identify the\n+     * start of a variable. This method allows a single character prefix to\n+     * be easily set.\n+     *\n+     * @param prefix  the prefix character to use\n+     * @return this, to enable chaining\n+     */\n+    public StrSubstitutor setVariablePrefix(char prefix) {\n+        return setVariablePrefixMatcher(StrMatcher.charMatcher(prefix));\n+    }\n+\n+    /**\n+     * Sets the variable prefix to use.\n+     * <p>\n+     * The variable prefix is the characer or characters that identify the\n+     * start of a variable. This method allows a string prefix to be easily set.\n+     *\n+     * @param prefix  the prefix for variables, not null\n+     * @return this, to enable chaining\n+     * @throws IllegalArgumentException if the prefix is null\n+     */\n+    public StrSubstitutor setVariablePrefix(String prefix) {\n+       if (prefix == null) {\n+            throw new IllegalArgumentException(\"Variable prefix must not be null!\");\n+        }\n+        return setVariablePrefixMatcher(StrMatcher.stringMatcher(prefix));\n+    }\n+\n+    // Suffix\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the variable suffix matcher currently in use.\n+     * <p>\n+     * The variable suffix is the characer or characters that identify the\n+     * end of a variable. This suffix is expressed in terms of a matcher\n+     * allowing advanced suffix matches.\n+     *\n+     * @return the suffix matcher in use\n+     */\n+    public StrMatcher getVariableSuffixMatcher() {\n+        return suffixMatcher;\n+    }\n+\n+    /**\n+     * Sets the variable suffix matcher currently in use.\n+     * <p>\n+     * The variable suffix is the characer or characters that identify the\n+     * end of a variable. This suffix is expressed in terms of a matcher\n+     * allowing advanced suffix matches.\n+     *\n+     * @param suffixMatcher  the suffix matcher to use, null ignored\n+     * @return this, to enable chaining\n+     * @throws IllegalArgumentException if the suffix matcher is null\n+     */\n+    public StrSubstitutor setVariableSuffixMatcher(StrMatcher suffixMatcher) {\n+        if (suffixMatcher == null) {\n+            throw new IllegalArgumentException(\"Variable suffix matcher must not be null!\");\n+        }\n+        this.suffixMatcher = suffixMatcher;\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the variable suffix to use.\n+     * <p>\n+     * The variable suffix is the characer or characters that identify the\n+     * end of a variable. This method allows a single character suffix to\n+     * be easily set.\n+     *\n+     * @param suffix  the suffix character to use\n+     * @return this, to enable chaining\n+     */\n+    public StrSubstitutor setVariableSuffix(char suffix) {\n+        return setVariableSuffixMatcher(StrMatcher.charMatcher(suffix));\n+    }\n+\n+    /**\n+     * Sets the variable suffix to use.\n+     * <p>\n+     * The variable suffix is the characer or characters that identify the\n+     * end of a variable. This method allows a string suffix to be easily set.\n+     *\n+     * @param suffix  the suffix for variables, not null\n+     * @return this, to enable chaining\n+     * @throws IllegalArgumentException if the suffix is null\n+     */\n+    public StrSubstitutor setVariableSuffix(String suffix) {\n+       if (suffix == null) {\n+            throw new IllegalArgumentException(\"Variable suffix must not be null!\");\n+        }\n+        return setVariableSuffixMatcher(StrMatcher.stringMatcher(suffix));\n+    }\n+\n+    // Resolver\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the VariableResolver\n+     *\n+     * @return the VariableResolver\n+     */\n+    public VariableResolver getVariableResolver() {\n+        return this.variableResolver;\n+    }\n+\n+    /**\n+     * Sets the VariableResolver\n+     *\n+     * @param variableResolver  the VariableResolver\n+     */\n+    public void setVariableResolver(VariableResolver variableResolver) {\n+        this.variableResolver = variableResolver;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Looks up a string value by name.\n+     * This represents the simplest form of a map.\n+     */\n+    public static interface VariableResolver {\n+        /**\n+         * Resolves the variable name to a value.\n+         *\n+         * @param varName  the name to be looked up, may be null\n+         * @return the matching value, null if no match\n+         */\n+        String resolveVariable(String varName);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Looks up a string value by name using a {@link Map}.\n+     */\n+    static class MapVariableResolver implements VariableResolver {\n+        /**\n+         * Map keys are variable names and value\n+         */\n+        Map map;\n+\n+        /**\n+         * Creates a new resolver backed by a Map.\n+         *\n+         * @param map  the variable names and values\n+         */\n+        MapVariableResolver(Map map) {\n+            this.map = map;\n+        }\n+\n+        /**\n+         * Resolves the given variable name with the backing Map.\n+         *\n+         * @param varName  a variable name\n+         * @return a value or null if the variable name is not in Map\n+         */\n+        public String resolveVariable(String varName) {\n+            if (map == null) {\n+                return null;\n+            }\n+            Object obj = map.get(varName);\n+            if (obj == null) {\n+                return null;\n+            }\n+            return obj.toString();\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/lang/text/StrSubstitutorTest.java\n+/*\n+ * Copyright 2005-2006 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.lang.text;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+\n+import org.apache.commons.lang.text.StrSubstitutor.MapVariableResolver;\n+\n+/**\n+ * Test class for StrSubstitutor.\n+ * \n+ * @author Oliver Heger\n+ * @version $Id: StrSubstitutorTest.java 231316 2005-08-10 20:36:26Z ggregory $\n+ */\n+public class StrSubstitutorTest extends TestCase {\n+\n+    private Map values;\n+\n+    /**\n+     * Main method.\n+     * \n+     * @param args  command line arguments, ignored\n+     */\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+\n+    /**\n+     * Return a new test suite containing this test case.\n+     * \n+     * @return a new test suite containing this test case\n+     */\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(StrSubstitutorTest.class);\n+        suite.setName(\"StrSubstitutor Tests\");\n+        return suite;\n+    }\n+\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+        values = new HashMap();\n+        values.put(\"animal\", \"quick brown fox\");\n+        values.put(\"target\", \"lazy dog\");\n+    }\n+\n+    protected void tearDown() throws Exception {\n+        super.tearDown();\n+        values = null;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+//    /**\n+//     * Tests escaping variable references.\n+//     */\n+//    public void testEscape() {\n+//        assertEquals(\"${\", this.getFormat().replace(\"$${\"));\n+//        assertEquals(\"${animal}\", this.getFormat().replace(\"$${animal}\"));\n+//        this.getValueMap().put(\"var_name\", \"x\");\n+//        assertEquals(\"Many $$$$${target} $s\", this.getFormat().replace(\"Many $$$$$${target} $s\"));\n+//        assertEquals(\"Variable ${x} must be used!\", this.getFormat().replace(\"Variable $${${var_name}} must be used!\"));\n+//    }\n+//\n+//    /**\n+//     * Tests creating new <code>VariableFormat</code> objects.\n+//     */\n+//    public void testInitialize() {\n+//        assertNotNull(this.getFormat().getVariableResolver());\n+//        assertEquals(StrSubstitutor.DEFAULT_PREFIX, this.getFormat().getVariablePrefixMatcher());\n+//        assertEquals(StrSubstitutor.DEFAULT_SUFFIX, this.getFormat().getVariableSuffixMatcher());\n+//        assertEquals(StrSubstitutor.DEFAULT_ESCAPE, this.getFormat().getEscapeChar());\n+//\n+//        format = new StrSubstitutor(values, \"<<\", \">>\", '\\\\');\n+//        assertEquals(\"<<\", this.getFormat().getVariablePrefixMatcher());\n+//        assertEquals(\">>\", this.getFormat().getVariableSuffixMatcher());\n+//        assertEquals('\\\\', this.getFormat().getEscapeChar());\n+//\n+//        // new StrSubstitutor(null) should be OK IMO\n+//        // Gary Gregory - July 14 2005\n+//        // try {\n+//        // format = new StrSubstitutor(null);\n+//        // fail(\"Could create format object with null map!\");\n+//        // } catch (IllegalArgumentException iex) {\n+//        // // ok\n+//        // }\n+//\n+//        try {\n+//            format = new StrSubstitutor(values, \"${\", null);\n+//            fail(\"Could create format object with undefined suffix!\");\n+//        } catch (IllegalArgumentException iex) {\n+//            // ok\n+//        }\n+//\n+//        try {\n+//            format = new StrSubstitutor(values, null, \"]\");\n+//            fail(\"Could create format object with undefined prefix!\");\n+//        } catch (IllegalArgumentException iex) {\n+//            // ok\n+//        }\n+//    }\n+//\n+//    /**\n+//     * Tests chaning variable prefix and suffix and the escaping character.\n+//     */\n+//    public void testNonDefaultTokens() {\n+//        format = new StrSubstitutor(values, \"<<\", \">>\", '\\\\');\n+//        assertEquals(\"The quick brown fox jumps over the lazy dog.\", format\n+//                .replace(\"The <<animal>> jumps over the <<target>>.\"));\n+//        assertEquals(\"The quick brown fox jumps over the <<target>>.\", format\n+//                .replace(\"The <<animal>> jumps over the \\\\<<target>>.\"));\n+//    }\n+//\n+//    /**\n+//     * Tests invoking the static convenience methods.\n+//     */\n+//    public void testNonInstanceMethods() {\n+//        assertEquals(\"The quick brown fox jumps over the lazy dog.\",\n+//                StrSubstitutor.replace(REPLACE_TEMPLATE, values));\n+//        values.put(KEY_ANIMAL, \"cow\");\n+//        values.put(KEY_TARGET, \"moon\");\n+//        assertEquals(\"The cow jumps over the moon.\",\n+//                StrSubstitutor.replace(\"The &animal; jumps over the &target;.\", values, \"&\", \";\"));\n+//    }\n+//\n+//    public void testNoResolver() throws Exception {\n+//        this.testNoResolver(new StrSubstitutor());\n+//        this.testNoResolver(new StrSubstitutor(null));\n+//    }\n+//\n+//    void testNoResolver(StrSubstitutor formatter) throws Exception {\n+//        formatter.setVariableResolver(null);\n+//        this.validateNoReplace(formatter);\n+//    }\n+//\n+//    public void testNullMap() throws Exception {\n+//        StrSubstitutor formatter = new StrSubstitutor(null);\n+//        validateNoReplace(formatter);\n+//    }\n+//\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Tests simple key replace.\n+     */\n+    public void testReplaceSimple() {\n+        doTestReplace(\"The quick brown fox jumps over the lazy dog.\", \"The ${animal} jumps over the ${target}.\", true);\n+    }\n+\n+    /**\n+     * Tests simple key replace.\n+     */\n+    public void testReplaceSolo() {\n+        doTestReplace(\"quick brown fox\", \"${animal}\", false);\n+    }\n+\n+    /**\n+     * Tests replace with no variables.\n+     */\n+    public void testReplaceNoVariables() {\n+        doTestNoReplace(\"The balloon arrived.\");\n+    }\n+\n+    /**\n+     * Tests replace with null.\n+     */\n+    public void testReplaceNull() {\n+        doTestNoReplace(null);\n+    }\n+\n+    /**\n+     * Tests replace with null.\n+     */\n+    public void testReplaceEmpty() {\n+        doTestNoReplace(\"\");\n+    }\n+\n+    /**\n+     * Tests key replace changing map after initialization (not recommended).\n+     */\n+    public void testReplaceChangedMap() {\n+        StrSubstitutor sub = new StrSubstitutor(values);\n+        values.put(\"target\", \"moon\");\n+        assertEquals(\"The quick brown fox jumps over the moon.\", sub.replace(\"The ${animal} jumps over the ${target}.\"));\n+    }\n+\n+    /**\n+     * Tests unknown key replace.\n+     */\n+    public void testReplaceUnknownKey() {\n+        doTestReplace(\"The ${person} jumps over the lazy dog.\", \"The ${person} jumps over the ${target}.\", true);\n+    }\n+\n+    /**\n+     * Tests adjacent keys.\n+     */\n+    public void testReplaceAdjacentAtStart() {\n+        values.put(\"code\", \"GBP\");\n+        values.put(\"amount\", \"12.50\");\n+        StrSubstitutor sub = new StrSubstitutor(values);\n+        assertEquals(\"GBP12.50 charged\", sub.replace(\"${code}${amount} charged\"));\n+    }\n+\n+    /**\n+     * Tests adjacent keys.\n+     */\n+    public void testReplaceAdjacentAtEnd() {\n+        values.put(\"code\", \"GBP\");\n+        values.put(\"amount\", \"12.50\");\n+        StrSubstitutor sub = new StrSubstitutor(values);\n+        assertEquals(\"Amount is GBP12.50\", sub.replace(\"Amount is ${code}${amount}\"));\n+    }\n+\n+    /**\n+     * Tests simple recursive replace.\n+     */\n+    public void testReplaceRecursive() {\n+        values.put(\"animal\", \"${critter}\");\n+        values.put(\"target\", \"${pet}\");\n+        values.put(\"pet\", \"${petCharacteristic} dog\");\n+        values.put(\"petCharacteristic\", \"lazy\");\n+        values.put(\"critter\", \"${critterSpeed} ${critterColor} ${critterType}\");\n+        values.put(\"critterSpeed\", \"quick\");\n+        values.put(\"critterColor\", \"brown\");\n+        values.put(\"critterType\", \"fox\");\n+        doTestReplace(\"The quick brown fox jumps over the lazy dog.\", \"The ${animal} jumps over the ${target}.\", true);\n+    }\n+\n+    /**\n+     * Tests escaping.\n+     */\n+    public void testReplaceEscaping() {\n+        doTestReplace(\"The ${animal} jumps over the lazy dog.\", \"The $${animal} jumps over the ${target}.\", true);\n+    }\n+\n+    /**\n+     * Tests escaping.\n+     */\n+    public void testReplaceSoloEscaping() {\n+        doTestReplace(\"${animal}\", \"$${animal}\", false);\n+    }\n+\n+    /**\n+     * Tests complex escaping.\n+     */\n+    public void testReplaceComplexEscaping() {\n+        doTestReplace(\"The ${quick brown fox} jumps over the lazy dog.\", \"The $${${animal}} jumps over the ${target}.\", true);\n+    }\n+\n+    /**\n+     * Tests when no prefix or suffix.\n+     */\n+    public void testReplaceNoPefixNoSuffix() {\n+        doTestReplace(\"The animal jumps over the lazy dog.\", \"The animal jumps over the ${target}.\", true);\n+    }\n+\n+    /**\n+     * Tests when no incomplete prefix.\n+     */\n+    public void testReplaceIncompletePefix() {\n+        doTestReplace(\"The {animal} jumps over the lazy dog.\", \"The {animal} jumps over the ${target}.\", true);\n+    }\n+\n+    /**\n+     * Tests when prefix but no suffix.\n+     */\n+    public void testReplacePrefixNoSuffix() {\n+        doTestReplace(\"The ${animal jumps over the ${target} lazy dog.\", \"The ${animal jumps over the ${target} ${target}.\", true);\n+    }\n+\n+    /**\n+     * Tests when suffix but no prefix.\n+     */\n+    public void testReplaceNoPrefixSuffix() {\n+        doTestReplace(\"The animal} jumps over the lazy dog.\", \"The animal} jumps over the ${target}.\", true);\n+    }\n+\n+    /**\n+     * Tests when no variable name.\n+     */\n+    public void testReplaceEmptyKeys() {\n+        doTestReplace(\"The ${} jumps over the lazy dog.\", \"The ${} jumps over the ${target}.\", true);\n+    }\n+\n+    /**\n+     * Tests replace creates output same as input.\n+     */\n+    public void testReplaceToIdentical() {\n+        values.put(\"animal\", \"$${${thing}}\");\n+        values.put(\"thing\", \"animal\");\n+        doTestReplace(\"The ${animal} jumps.\", \"The ${animal} jumps.\", true);\n+    }\n+\n+    /**\n+     * Tests a cyclic replace operation.\n+     * The cycle should be detected and cause an exception to be thrown.\n+     */\n+    public void testCyclicReplacement() {\n+        Map map = new HashMap();\n+        map.put(\"animal\", \"${critter}\");\n+        map.put(\"target\", \"${pet}\");\n+        map.put(\"pet\", \"${petCharacteristic} dog\");\n+        map.put(\"petCharacteristic\", \"lazy\");\n+        map.put(\"critter\", \"${critterSpeed} ${critterColor} ${critterType}\");\n+        map.put(\"critterSpeed\", \"quick\");\n+        map.put(\"critterColor\", \"brown\");\n+        map.put(\"critterType\", \"${animal}\");\n+        StrSubstitutor sub = new StrSubstitutor(map);\n+        try {\n+            sub.replace(\"The ${animal} jumps over the ${target}.\");\n+            fail(\"Cyclic replacement was not detected!\");\n+        } catch (IllegalStateException ex) {\n+            // expected\n+        }\n+    }\n+\n+    /**\n+     * Tests interpolation with weird boundary patterns.\n+     */\n+    public void testReplaceWeirdPattens() {\n+        doTestNoReplace(\"\");\n+        doTestNoReplace(\"${}\");\n+        doTestNoReplace(\"${ }\");\n+        doTestNoReplace(\"${\\t}\");\n+        doTestNoReplace(\"${\\n}\");\n+        doTestNoReplace(\"${\\b}\");\n+        doTestNoReplace(\"${\");\n+        doTestNoReplace(\"$}\");\n+        doTestNoReplace(\"}\");\n+        doTestNoReplace(\"${}$\");\n+        doTestNoReplace(\"${${\");\n+        doTestNoReplace(\"${${}}\");\n+        doTestNoReplace(\"${$${}}\");\n+        doTestNoReplace(\"${$$${}}\");\n+        doTestNoReplace(\"${$$${$}}\");\n+        doTestNoReplace(\"${${}}\");\n+        doTestNoReplace(\"${${ }}\");\n+    }\n+\n+    //-----------------------------------------------------------------------\n+//    /**\n+//     * Tests source texts with nothing to replace.\n+//     */\n+//    public void testReplaceNothing() {\n+//        assertNull(this.getFormat().replace((char[]) null));\n+//        assertNull(this.getFormat().replace((String) null));\n+//        assertNull(this.getFormat().replace((Object) null));\n+//        assertEquals(\"Nothing to replace.\", this.getFormat().replace(\"Nothing to replace.\"));\n+//        assertEquals(\"42\", this.getFormat().replace(new Integer(42)));\n+//        assertEquals(0, this.getFormat().replace((StrBuilder) null));\n+//    }\n+//\n+////    /**\n+////     * Tests operating on objects.\n+////     */\n+////    public void testReplaceObject() {\n+////        this.getValueMap().put(\"value\", new Integer(42));\n+////        assertEquals(new Integer(42), this.getFormat().replaceObject(\"${value}\"));\n+////        assertEquals(\"The answer is 42.\", this.getFormat().replaceObject(\"The answer is ${value}.\"));\n+////    }\n+//\n+//    /**\n+//     * Tests interpolation with system properties.\n+//     */\n+//    public void testReplaceSystemProperties() {\n+//        StringBuffer buf = new StringBuffer();\n+//        buf.append(\"Hi \").append(System.getProperty(\"user.name\"));\n+//        buf.append(\", you are working with \");\n+//        buf.append(System.getProperty(\"os.name\"));\n+//        buf.append(\", your home directory is \");\n+//        buf.append(System.getProperty(\"user.home\")).append('.');\n+//        assertEquals(buf.toString(), StrSubstitutor.replaceSystemProperties(\"Hi ${user.name}, you are \"\n+//            + \"working with ${os.name}, your home \"\n+//            + \"directory is ${user.home}.\"));\n+//    }\n+//\n+    //-----------------------------------------------------------------------\n+    private void doTestReplace(String expectedResult, String replaceTemplate, boolean substring) {\n+        String expectedShortResult = expectedResult.substring(1, expectedResult.length() - 1);\n+        \n+        StrSubstitutor sub = new StrSubstitutor(values);\n+        assertEquals(expectedResult, sub.replace(replaceTemplate));\n+        if (substring) {\n+            assertEquals(expectedShortResult, sub.replace(replaceTemplate, 1, replaceTemplate.length() - 2));\n+        }\n+        \n+        char[] chars = replaceTemplate.toCharArray();\n+        assertEquals(expectedResult, sub.replace(chars));\n+        if (substring) {\n+            assertEquals(expectedShortResult, sub.replace(chars, 1, chars.length - 2));\n+        }\n+        \n+        StringBuffer buf = new StringBuffer(replaceTemplate);\n+        assertEquals(expectedResult, sub.replace(buf));\n+        \n+        StrBuilder bld = new StrBuilder(replaceTemplate);\n+        assertEquals(true, sub.replace(bld));\n+        assertEquals(expectedResult, bld.toString());\n+        \n+        if (substring) {\n+            bld = new StrBuilder(replaceTemplate);\n+            assertEquals(true, sub.replace(bld, 1, bld.length() - 2));\n+            assertEquals(expectedResult, bld.toString());  // expect full result as remainder is untouched\n+        }\n+    }\n+\n+    private void doTestNoReplace(String replaceTemplate) {\n+        StrSubstitutor sub = new StrSubstitutor(values);\n+        assertEquals(replaceTemplate, sub.replace(replaceTemplate));\n+        \n+        if (replaceTemplate == null) {\n+            assertEquals(null, sub.replace((char[]) null));\n+            assertEquals(null, sub.replace((Object) null));\n+            assertEquals(false, sub.replace((StrBuilder) null));\n+        } else {\n+            StrBuilder bld = new StrBuilder(replaceTemplate);\n+            assertEquals(false, sub.replace(bld));\n+            assertEquals(replaceTemplate, bld.toString());\n+        }\n+    }\n+\n+}", "timestamp": 1153702837, "metainfo": ""}