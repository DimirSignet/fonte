{"sha": "b788af2a1b42d19260eaf9ffb9c7aa87a9f8d43f", "log": "Testing converters   ", "commit": "\n--- a/JodaTime/src/java/org/joda/time/MutableInterval.java\n+++ b/JodaTime/src/java/org/joda/time/MutableInterval.java\n package org.joda.time;\n \n import java.io.Serializable;\n-import java.text.ParseException;\n \n /**\n  * MutableInterval is the standard implementation of a mutable time interval.\n public final class MutableInterval extends AbstractInterval\n         implements ReadWritableInterval, Serializable {\n \n-    static final long serialVersionUID = -5982824024992428470L;\n+    /** Serialization version */\n+    private static final long serialVersionUID = -5982824024992428470L;\n \n     /**\n      * Constructs a time interval as a copy of another.\n--- a/JodaTime/src/java/org/joda/time/convert/ReadableIntervalConverter.java\n+++ b/JodaTime/src/java/org/joda/time/convert/ReadableIntervalConverter.java\n  * @author Brian S O'Neill\n  * @since 1.0\n  */\n-class ReadableIntervalConverter implements IntervalConverter, DurationConverter {\n+class ReadableIntervalConverter extends AbstractConverter implements IntervalConverter, DurationConverter {\n \n     /**\n      * Singleton instance.\n      */\n     static final ReadableIntervalConverter INSTANCE = new ReadableIntervalConverter();\n-    \n+\n     /**\n      * Restricted constructor.\n      */\n \n     /**\n      * Returns true always.\n+     * \n+     * @param object  the interval\n      */\n     public boolean isPrecise(Object object) {\n         return true;\n     }\n \n+    /**\n+     * Gets the millisecond length of the interval.\n+     * \n+     * @param object  the interval\n+     */\n     public long getDurationMillis(Object object) {\n         return (((ReadableInterval) object)).getDurationMillis();\n-    }\n-\n-    public void setInto(ReadWritableDuration duration, Object object) {\n-        ReadableInterval interval = (ReadableInterval) object;\n-        duration.setTotalMillis(interval.getStartMillis(), interval.getEndMillis());\n     }\n \n     /**\n      * Selects a suitable duration type for the given object.\n      *\n-     * @param object  the object to examine, must not be null\n+     * @param object  the interval\n      * @return the duration type, never null\n-     * @throws ClassCastException if the object is invalid\n      */\n     public DurationType getDurationType(Object object) {\n         return ((ReadableInterval) object).getDuration().getDurationType();\n     }\n \n+    /**\n+     * Sets the values of the mutable duration from the specified interval.\n+     * \n+     * @param writableDuration  the duration to set\n+     * @param object  the interval to set from\n+     */\n+    public void setInto(ReadWritableDuration writableDuration, Object object) {\n+        ReadableInterval interval = (ReadableInterval) object;\n+        writableDuration.setTotalMillis(interval.getStartMillis(), interval.getEndMillis());\n+    }\n+\n+    /**\n+     * Sets the values of the mutable interval from the specified interval.\n+     * \n+     * @param writableInterval  the interval to set\n+     * @param object  the interval to set from\n+     */\n     public void setInto(ReadWritableInterval writableInterval, Object object) {\n         ReadableInterval interval = (ReadableInterval) object;\n         writableInterval.setStartMillis(interval.getStartMillis());\n     public Class getSupportedType() {\n         return ReadableInterval.class;\n     }\n+\n }\n--- a/JodaTime/src/java/org/joda/time/convert/StringConverter.java\n+++ b/JodaTime/src/java/org/joda/time/convert/StringConverter.java\n import org.joda.time.ReadableDuration;\n import org.joda.time.chrono.ISOChronology;\n import org.joda.time.format.DateTimeParser;\n+import org.joda.time.format.DurationFormatter;\n import org.joda.time.format.DurationParser;\n import org.joda.time.format.ISODateTimeFormat;\n import org.joda.time.format.ISODurationFormat;\n         return DurationType.getYearMonthType();\n     }\n \n+    /**\n+     * Sets the value of the mutable interval from the string.\n+     * \n+     * @param writableInterval  the interval to set\n+     * @param object  the string to set from\n+     */\n     public void setInto(ReadWritableInterval writableInterval, Object object) {\n         String str = (String) object;\n \n \n         String leftStr = str.substring(0, separator);\n         if (leftStr.length() <= 0) {\n-            throw new IllegalArgumentException();\n+            throw new IllegalArgumentException(\"Format invalid: \" + str);\n         }\n         String rightStr = str.substring(separator + 1);\n         if (rightStr.length() <= 0) {\n-            throw new IllegalArgumentException();\n-        }\n-\n+            throw new IllegalArgumentException(\"Format invalid: \" + str);\n+        }\n+\n+        DateTimeParser dateTimeParser = ISODateTimeFormat.getInstance().dateTimeParser();\n+        DurationFormatter durationParser = ISODurationFormat.getInstance().standard();\n         long startInstant;\n         ReadableDuration duration;\n \n         char c = leftStr.charAt(0);\n         if (c == 'P' || c == 'p') {\n             startInstant = 0;\n-            duration = ISODurationFormat.getInstance().standard()\n-                .parseDuration(getDurationType(leftStr), leftStr);\n+            duration = durationParser.parseDuration(getDurationType(leftStr), leftStr);\n         } else {\n-            startInstant = ISODateTimeFormat.getInstanceUTC().dateTimeParser().parseMillis(leftStr);\n+            startInstant = dateTimeParser.parseMillis(leftStr);\n             duration = null;\n         }\n \n             if (duration != null) {\n                 throw new IllegalArgumentException(\"Interval composed of two durations: \" + str);\n             }\n-            duration = ISODurationFormat.getInstance().standard()\n-                .parseDuration(getDurationType(rightStr), rightStr);\n+            duration = durationParser.parseDuration(getDurationType(rightStr), rightStr);\n             writableInterval.setStartMillis(startInstant);\n             writableInterval.setDurationAfterStart(duration);\n         } else {\n-            long endInstant = ISODateTimeFormat.getInstanceUTC().dateTimeParser().parseMillis(rightStr);\n+            long endInstant = dateTimeParser.parseMillis(rightStr);\n             writableInterval.setEndMillis(endInstant);\n             if (duration == null) {\n                 writableInterval.setStartMillis(startInstant);\n--- a/JodaTime/src/test/org/joda/time/convert/TestAll.java\n+++ b/JodaTime/src/test/org/joda/time/convert/TestAll.java\n         suite.addTest(TestLongConverter.suite());\n         suite.addTest(TestNullConverter.suite());\n         suite.addTest(TestReadableDurationConverter.suite());\n+        suite.addTest(TestReadableIntervalConverter.suite());\n         suite.addTest(TestReadableInstantConverter.suite());\n         suite.addTest(TestStringConverter.suite());\n         return suite;\n--- a/JodaTime/src/test/org/joda/time/convert/TestConverterSet.java\n+++ b/JodaTime/src/test/org/joda/time/convert/TestConverterSet.java\n import java.lang.reflect.Constructor;\n import java.lang.reflect.Modifier;\n import java.util.Calendar;\n-import java.util.Date;\n import java.util.GregorianCalendar;\n \n import junit.framework.TestCase;\n         set.select(Long.class);\n         set.select(Float.class);\n         set.select(Double.class);\n-        set.select(Date.class);\n+        set.select(null);\n         set.select(Calendar.class);\n         set.select(GregorianCalendar.class);\n         set.select(DateTime.class);\n         set.select(ReadableDateTime.class);\n         set.select(ReadWritableInstant.class);  // 16\n         set.select(ReadWritableDateTime.class);\n+        set.select(DateTime.class);\n         assertEquals(4, set.size());\n     }\n \n         };\n         ConverterSet set = new ConverterSet(array);\n         ConverterSet result = set.add(c4a, null);\n-        assertNotSame(set, result);\n+        assertTrue(set != result);\n         assertEquals(4, set.size());\n         assertEquals(4, result.size());\n     }\n         ConverterSet result = set.remove(c3, null);\n         assertEquals(4, set.size());\n         assertEquals(3, result.size());\n+    }\n+\n+    public void testRemoveNullRemoved2() {\n+        Converter[] array = new Converter[] {\n+            c1, c2, c3, c4,\n+        };\n+        ConverterSet set = new ConverterSet(array);\n+        ConverterSet result = set.remove(c5, null);\n+        assertSame(set, result);\n     }\n \n     //-----------------------------------------------------------------------\n--- a/JodaTime/src/test/org/joda/time/convert/TestReadableDurationConverter.java\n+++ b/JodaTime/src/test/org/joda/time/convert/TestReadableDurationConverter.java\n         try {\n             ReadableDurationConverter.INSTANCE.getDurationMillis(new Duration(DurationType.getYearMonthType(), 1, 2, 0, 1, 0, 0, 0, 0));\n             fail();\n-        } catch (Exception ex) {}\n+        } catch (IllegalStateException ex) {}\n     }\n \n     public void testGetDurationType_Object() throws Exception {\n--- /dev/null\n+++ b/JodaTime/src/test/org/joda/time/convert/TestReadableIntervalConverter.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.convert;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Modifier;\n+\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+import org.joda.time.Chronology;\n+import org.joda.time.DateTimeZone;\n+import org.joda.time.DurationType;\n+import org.joda.time.Interval;\n+import org.joda.time.MutableDuration;\n+import org.joda.time.MutableInterval;\n+import org.joda.time.ReadableInterval;\n+import org.joda.time.chrono.ISOChronology;\n+import org.joda.time.chrono.JulianChronology;\n+\n+/**\n+ * This class is a JUnit test for ReadableIntervalConverter.\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class TestReadableIntervalConverter extends TestCase {\n+\n+    private static final DateTimeZone UTC = DateTimeZone.UTC;\n+    private static final DateTimeZone PARIS = DateTimeZone.getInstance(\"Europe/Paris\");\n+    private static final Chronology ISO = ISOChronology.getInstance();\n+    private static final Chronology JULIAN = JulianChronology.getInstance();\n+    private static final Chronology ISO_PARIS = ISOChronology.getInstance(PARIS);\n+    \n+    private DateTimeZone zone = null;\n+\n+    public static void main(String[] args) {\n+        junit.textui.TestRunner.run(suite());\n+    }\n+\n+    public static TestSuite suite() {\n+        return new TestSuite(TestReadableIntervalConverter.class);\n+    }\n+\n+    public TestReadableIntervalConverter(String name) {\n+        super(name);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testSingleton() throws Exception {\n+        Class cls = ReadableIntervalConverter.class;\n+        assertEquals(false, Modifier.isPublic(cls.getModifiers()));\n+        assertEquals(false, Modifier.isProtected(cls.getModifiers()));\n+        assertEquals(false, Modifier.isPrivate(cls.getModifiers()));\n+        \n+        Constructor con = cls.getDeclaredConstructor(null);\n+        assertEquals(1, cls.getDeclaredConstructors().length);\n+        assertEquals(true, Modifier.isProtected(con.getModifiers()));\n+        \n+        Field fld = cls.getDeclaredField(\"INSTANCE\");\n+        assertEquals(false, Modifier.isPublic(fld.getModifiers()));\n+        assertEquals(false, Modifier.isProtected(fld.getModifiers()));\n+        assertEquals(false, Modifier.isPrivate(fld.getModifiers()));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testSupportedType() throws Exception {\n+        assertEquals(ReadableInterval.class, ReadableIntervalConverter.INSTANCE.getSupportedType());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testGetDurationMillis_Object() throws Exception {\n+        Interval i = new Interval(0L, 123L);\n+        assertEquals(123L, ReadableIntervalConverter.INSTANCE.getDurationMillis(i));\n+    }\n+\n+    public void testGetDurationType_Object() throws Exception {\n+        Interval i = new Interval(0L, 123L);\n+        assertEquals(DurationType.getMillisType(), ReadableIntervalConverter.INSTANCE.getDurationType(i));\n+    }\n+\n+    public void testIsPrecise_Object() throws Exception {\n+        Interval i = new Interval(0L, 123L);\n+        assertEquals(true, ReadableIntervalConverter.INSTANCE.isPrecise(i));\n+    }\n+\n+    public void testSetInto_Object() throws Exception {\n+        Interval i = new Interval(0L, 123L);\n+        MutableDuration m = new MutableDuration(DurationType.getMillisType());\n+        ReadableIntervalConverter.INSTANCE.setInto(m, i);\n+        assertEquals(0, m.getYears());\n+        assertEquals(0, m.getMonths());\n+        assertEquals(0, m.getWeeks());\n+        assertEquals(0, m.getDays());\n+        assertEquals(0, m.getHours());\n+        assertEquals(0, m.getMinutes());\n+        assertEquals(0, m.getSeconds());\n+        assertEquals(123, m.getMillis());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testSetIntoInterval_Object() throws Exception {\n+        Interval i = new Interval(0L, 123L);\n+        MutableInterval m = new MutableInterval(-1000L, 1000L);\n+        ReadableIntervalConverter.INSTANCE.setInto(m, i);\n+        assertEquals(0L, m.getStartMillis());\n+        assertEquals(123L, m.getEndMillis());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testToString() {\n+        assertEquals(\"Converter[org.joda.time.ReadableInterval]\", ReadableIntervalConverter.INSTANCE.toString());\n+    }\n+\n+}\n--- a/JodaTime/src/test/org/joda/time/convert/TestStringConverter.java\n+++ b/JodaTime/src/test/org/joda/time/convert/TestStringConverter.java\n import org.joda.time.DateTimeZone;\n import org.joda.time.DurationType;\n import org.joda.time.MutableDuration;\n+import org.joda.time.MutableInterval;\n import org.joda.time.chrono.ISOChronology;\n import org.joda.time.chrono.JulianChronology;\n \n         \n         dt = new DateTime(2004, 6, 9, 12, 24, 48, 500, ONE_HOUR);\n         assertEquals(dt.getMillis(), StringConverter.INSTANCE.getInstantMillis(\"2004-06-09T12:24:48.5+01:00\"));\n+        \n+        dt = new DateTime(2004, 6, 9, 12, 24, 48, 501);\n+        assertEquals(dt.getMillis(), StringConverter.INSTANCE.getInstantMillis(\"2004-06-09T12:24:48.501\"));\n     }\n \n     public void testGetInstantMillis_Object_Zone() throws Exception {\n     }\n \n     //-----------------------------------------------------------------------\n+    public void testSetIntoInterval_Object1() throws Exception {\n+        MutableInterval m = new MutableInterval(-1000L, 1000L);\n+        StringConverter.INSTANCE.setInto(m, \"2004-06-09/P1Y2M\");\n+        assertEquals(new DateTime(2004, 6, 9, 0, 0, 0, 0).toInstant(), m.getStartInstant());\n+        assertEquals(new DateTime(2005, 8, 9, 0, 0, 0, 0).toInstant(), m.getEndInstant());\n+    }\n+\n+    public void testSetIntoInterval_Object2() throws Exception {\n+        MutableInterval m = new MutableInterval(-1000L, 1000L);\n+        StringConverter.INSTANCE.setInto(m, \"P1Y2M/2004-06-09\");\n+        assertEquals(new DateTime(2003, 4, 9, 0, 0, 0, 0).toInstant(), m.getStartInstant());\n+        assertEquals(new DateTime(2004, 6, 9, 0, 0, 0, 0).toInstant(), m.getEndInstant());\n+    }\n+\n+    public void testSetIntoInterval_Object3() throws Exception {\n+        MutableInterval m = new MutableInterval(-1000L, 1000L);\n+        StringConverter.INSTANCE.setInto(m, \"2003-08-09/2004-06-09\");\n+        assertEquals(new DateTime(2003, 8, 9, 0, 0, 0, 0).toInstant(), m.getStartInstant());\n+        assertEquals(new DateTime(2004, 6, 9, 0, 0, 0, 0).toInstant(), m.getEndInstant());\n+    }\n+\n+    public void testSetIntoIntervalEx_Object1() throws Exception {\n+        MutableInterval m = new MutableInterval(-1000L, 1000L);\n+        try {\n+            StringConverter.INSTANCE.setInto(m, \"\");\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    public void testSetIntoIntervalEx_Object2() throws Exception {\n+        MutableInterval m = new MutableInterval(-1000L, 1000L);\n+        try {\n+            StringConverter.INSTANCE.setInto(m, \"/\");\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    public void testSetIntoIntervalEx_Object3() throws Exception {\n+        MutableInterval m = new MutableInterval(-1000L, 1000L);\n+        try {\n+            StringConverter.INSTANCE.setInto(m, \"P1Y/\");\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    public void testSetIntoIntervalEx_Object4() throws Exception {\n+        MutableInterval m = new MutableInterval(-1000L, 1000L);\n+        try {\n+            StringConverter.INSTANCE.setInto(m, \"/P1Y\");\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    public void testSetIntoIntervalEx_Object5() throws Exception {\n+        MutableInterval m = new MutableInterval(-1000L, 1000L);\n+        try {\n+            StringConverter.INSTANCE.setInto(m, \"P1Y/P2Y\");\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    //-----------------------------------------------------------------------\n     public void testToString() {\n         assertEquals(\"Converter[java.lang.String]\", StringConverter.INSTANCE.toString());\n     }", "timestamp": 1090272368, "metainfo": ""}