{"sha": "c7a581e55fc988bd90fa4bb1b0acece5181b7c5f", "log": "DateTimeZone.convertLocalToUTC [bugs 3102760,2182444,2553453] New method now retains the offset wherever possible during calculations This affects higher methods like withHourOfDay/withMinuteOfHour/withSecondOfMinute/withMillisOfSecond which now do not change offset when called within a DST overlap  ", "commit": "\n--- a/JodaTime/src/main/java/org/joda/time/DateTimeZone.java\n+++ b/JodaTime/src/main/java/org/joda/time/DateTimeZone.java\n \n     /**\n      * Converts a local instant to a standard UTC instant with the same\n+     * local time attempting to use the same offset as the original.\n+     * <p>\n+     * This conversion is used after performing a calculation\n+     * where the calculation was done using a simple local zone.\n+     * Whenever possible, the same offset as the original offset will be used.\n+     * This is most significant during a daylight savings overlap.\n+     *\n+     * @param instantLocal  the local instant to convert to UTC\n+     * @param strict  whether the conversion should reject non-existent local times\n+     * @param originalInstantUTC  the original instant that the calculation is based on\n+     * @return the UTC instant with the same local time, \n+     * @throws ArithmeticException if the result overflows a long\n+     * @throws IllegalArgumentException if the zone has no equivalent local time\n+     * @since 2.0\n+     */\n+    public long convertLocalToUTC(long instantLocal, boolean strict, long originalInstantUTC) {\n+        int offsetOriginal = getOffset(originalInstantUTC);\n+        long instantUTC = instantLocal - offsetOriginal;\n+        int offsetLocalFromOriginal = getOffset(instantUTC);\n+        if (offsetLocalFromOriginal == offsetOriginal) {\n+            return instantUTC;\n+        }\n+        return convertLocalToUTC(instantLocal, strict);\n+    }\n+\n+    /**\n+     * Converts a local instant to a standard UTC instant with the same\n      * local time. This conversion is used after performing a calculation\n      * where the calculation was done using a simple local zone.\n      *\n      * @param strict  whether the conversion should reject non-existent local times\n      * @return the UTC instant with the same local time, \n      * @throws ArithmeticException if the result overflows a long\n-     * @throws IllegalArgumentException if the zone has no eqivalent local time\n+     * @throws IllegalArgumentException if the zone has no equivalent local time\n      * @since 1.5\n      */\n     public long convertLocalToUTC(long instantLocal, boolean strict) {\n--- a/JodaTime/src/main/java/org/joda/time/chrono/ZonedChronology.java\n+++ b/JodaTime/src/main/java/org/joda/time/chrono/ZonedChronology.java\n             } else {\n                long localInstant = iZone.convertUTCToLocal(instant);\n                localInstant = iField.add(localInstant, value);\n-               return iZone.convertLocalToUTC(localInstant, false);\n+               return iZone.convertLocalToUTC(localInstant, false, instant);\n             }\n         }\n \n             } else {\n                long localInstant = iZone.convertUTCToLocal(instant);\n                localInstant = iField.add(localInstant, value);\n-               return iZone.convertLocalToUTC(localInstant, false);\n+               return iZone.convertLocalToUTC(localInstant, false, instant);\n             }\n         }\n \n             } else {\n                 long localInstant = iZone.convertUTCToLocal(instant);\n                 localInstant = iField.addWrapField(localInstant, value);\n-                return iZone.convertLocalToUTC(localInstant, false);\n+                return iZone.convertLocalToUTC(localInstant, false, instant);\n             }\n         }\n \n         public long set(long instant, int value) {\n             long localInstant = iZone.convertUTCToLocal(instant);\n             localInstant = iField.set(localInstant, value);\n-            long result = iZone.convertLocalToUTC(localInstant, false);\n+            long result = iZone.convertLocalToUTC(localInstant, false, instant);\n             if (get(result) != value) {\n                 throw new IllegalFieldValueException(iField.getType(), new Integer(value),\n                     \"Illegal instant due to time zone offset transition: \" +\n             // cannot verify that new value stuck because set may be lenient\n             long localInstant = iZone.convertUTCToLocal(instant);\n             localInstant = iField.set(localInstant, text, locale);\n-            return iZone.convertLocalToUTC(localInstant, false);\n+            return iZone.convertLocalToUTC(localInstant, false, instant);\n         }\n \n         public int getDifference(long minuendInstant, long subtrahendInstant) {\n             } else {\n                 long localInstant = iZone.convertUTCToLocal(instant);\n                 localInstant = iField.roundFloor(localInstant);\n-                return iZone.convertLocalToUTC(localInstant, false);\n+                return iZone.convertLocalToUTC(localInstant, false, instant);\n             }\n         }\n \n             } else {\n                 long localInstant = iZone.convertUTCToLocal(instant);\n                 localInstant = iField.roundCeiling(localInstant);\n-                return iZone.convertLocalToUTC(localInstant, false);\n+                return iZone.convertLocalToUTC(localInstant, false, instant);\n             }\n         }\n \n--- a/JodaTime/src/main/java/org/joda/time/field/LenientDateTimeField.java\n+++ b/JodaTime/src/main/java/org/joda/time/field/LenientDateTimeField.java\n         long localInstant = iBase.getZone().convertUTCToLocal(instant);\n         long difference = FieldUtils.safeSubtract(value, get(instant));\n         localInstant = getType().getField(iBase.withUTC()).add(localInstant, difference);\n-        return iBase.getZone().convertLocalToUTC(localInstant, false);\n+        return iBase.getZone().convertLocalToUTC(localInstant, false, instant);\n     }\n }\n--- a/JodaTime/src/test/java/org/joda/time/MockZone.java\n+++ b/JodaTime/src/test/java/org/joda/time/MockZone.java\n \n     long transition;\n     int winterOffset;\n+    int sizeMillis;\n \n-    public MockZone(long transition, int winterOffset) {\n+    public MockZone(long transition, int winterOffset, int sizeSecs) {\n         super(\"MockZone\");\n         this.transition = transition;\n         this.winterOffset = winterOffset;\n+        this.sizeMillis = sizeSecs * 1000;\n     }\n \n     public int getOffset(long instant) {\n-        return (instant < transition ? winterOffset : winterOffset + 3600000);\n+        return (instant < transition ? winterOffset : winterOffset + sizeMillis);\n     }\n \n     public int getStandardOffset(long instant) {\n--- a/JodaTime/src/test/java/org/joda/time/TestDateTimeZoneCutover.java\n+++ b/JodaTime/src/test/java/org/joda/time/TestDateTimeZoneCutover.java\n import junit.framework.TestCase;\n import junit.framework.TestSuite;\n \n+import org.joda.time.chrono.GregorianChronology;\n import org.joda.time.tz.DateTimeZoneBuilder;\n \n /**\n     /** Mock zone simulating Asia/Gaza cutover at midnight 2007-04-01 */\n     private static long CUTOVER_GAZA = 1175378400000L;\n     private static int OFFSET_GAZA = 7200000;  // +02:00\n-    private static final DateTimeZone MOCK_GAZA = new MockZone(CUTOVER_GAZA, OFFSET_GAZA);\n+    private static final DateTimeZone MOCK_GAZA = new MockZone(CUTOVER_GAZA, OFFSET_GAZA, 3600);\n \n     //-----------------------------------------------------------------------\n     public void test_MockGazaIsCorrect() {\n     /** Mock zone simulating America/Grand_Turk cutover at midnight 2007-04-01 */\n     private static long CUTOVER_TURK = 1175403600000L;\n     private static int OFFSET_TURK = -18000000;  // -05:00\n-    private static final DateTimeZone MOCK_TURK = new MockZone(CUTOVER_TURK, OFFSET_TURK);\n+    private static final DateTimeZone MOCK_TURK = new MockZone(CUTOVER_TURK, OFFSET_TURK, 3600);\n \n     //-----------------------------------------------------------------------\n     public void test_MockTurkIsCorrect() {\n         assertEquals(\"2008-08-10\", date.toString());\n         \n         DateTime dt = date.toDateTimeAtStartOfDay(zone);\n-        System.out.println(dt);\n         assertEquals(\"2008-08-10T00:00:00.000-03:00\", dt.toString());\n     }\n \n //    }\n \n     //-----------------------------------------------------------------------\n+    private static final DateTimeZone ZONE_PARIS = DateTimeZone.forID(\"Europe/Paris\");\n+\n+    public void testWithMinuteOfHourInDstChange_mockZone() {\n+        DateTime cutover = new DateTime(2010, 10, 31, 1, 15, DateTimeZone.forOffsetHoursMinutes(0, 30));\n+        assertEquals(\"2010-10-31T01:15:00.000+00:30\", cutover.toString());\n+        DateTimeZone halfHourZone = new MockZone(cutover.getMillis(), 3600000, -1800);\n+        DateTime pre = new DateTime(2010, 10, 31, 1, 0, halfHourZone);\n+        assertEquals(\"2010-10-31T01:00:00.000+01:00\", pre.toString());\n+        DateTime post = new DateTime(2010, 10, 31, 1, 59, halfHourZone);\n+        assertEquals(\"2010-10-31T01:59:00.000+00:30\", post.toString());\n+        \n+        DateTime testPre1 = pre.withMinuteOfHour(30);\n+        assertEquals(\"2010-10-31T01:30:00.000+01:00\", testPre1.toString());  // retain offset\n+        DateTime testPre2 = pre.withMinuteOfHour(50);\n+        assertEquals(\"2010-10-31T01:50:00.000+00:30\", testPre2.toString());\n+        \n+        DateTime testPost1 = post.withMinuteOfHour(30);\n+        assertEquals(\"2010-10-31T01:30:00.000+00:30\", testPost1.toString());  // retain offset\n+        DateTime testPost2 = post.withMinuteOfHour(10);\n+        assertEquals(\"2010-10-31T01:10:00.000+01:00\", testPost2.toString());\n+    }\n+\n+    public void testWithHourOfDayInDstChange() {\n+        DateTime dateTime = new DateTime(\"2010-10-31T02:30:10.123+02:00\", ZONE_PARIS);\n+        assertEquals(\"2010-10-31T02:30:10.123+02:00\", dateTime.toString());\n+        DateTime test = dateTime.withHourOfDay(2);\n+        assertEquals(\"2010-10-31T02:30:10.123+02:00\", test.toString());\n+    }\n+\n+    public void testWithMinuteOfHourInDstChange() {\n+        DateTime dateTime = new DateTime(\"2010-10-31T02:30:10.123+02:00\", ZONE_PARIS);\n+        assertEquals(\"2010-10-31T02:30:10.123+02:00\", dateTime.toString());\n+        DateTime test = dateTime.withMinuteOfHour(0);\n+        assertEquals(\"2010-10-31T02:00:10.123+02:00\", test.toString());\n+    }\n+\n+    public void testWithSecondOfMinuteInDstChange() {\n+        DateTime dateTime = new DateTime(\"2010-10-31T02:30:10.123+02:00\", ZONE_PARIS);\n+        assertEquals(\"2010-10-31T02:30:10.123+02:00\", dateTime.toString());\n+        DateTime test = dateTime.withSecondOfMinute(0);\n+        assertEquals(\"2010-10-31T02:30:00.123+02:00\", test.toString());\n+    }\n+\n+    public void testWithMillisOfSecondInDstChange_Paris_summer() {\n+        DateTime dateTime = new DateTime(\"2010-10-31T02:30:10.123+02:00\", ZONE_PARIS);\n+        assertEquals(\"2010-10-31T02:30:10.123+02:00\", dateTime.toString());\n+        DateTime test = dateTime.withMillisOfSecond(0);\n+        assertEquals(\"2010-10-31T02:30:10.000+02:00\", test.toString());\n+    }\n+\n+    public void testWithMillisOfSecondInDstChange_Paris_winter() {\n+        DateTime dateTime = new DateTime(\"2010-10-31T02:30:10.123+01:00\", ZONE_PARIS);\n+        assertEquals(\"2010-10-31T02:30:10.123+01:00\", dateTime.toString());\n+        DateTime test = dateTime.withMillisOfSecond(0);\n+        assertEquals(\"2010-10-31T02:30:10.000+01:00\", test.toString());\n+    }\n+\n+    public void testWithMillisOfSecondInDstChange_NewYork_summer() {\n+        DateTime dateTime = new DateTime(\"2007-11-04T01:30:00.123-04:00\", ZONE_NEW_YORK);\n+        assertEquals(\"2007-11-04T01:30:00.123-04:00\", dateTime.toString());\n+        DateTime test = dateTime.withMillisOfSecond(0);\n+        assertEquals(\"2007-11-04T01:30:00.000-04:00\", test.toString());\n+    }\n+\n+    public void testWithMillisOfSecondInDstChange_NewYork_winter() {\n+        DateTime dateTime = new DateTime(\"2007-11-04T01:30:00.123-05:00\", ZONE_NEW_YORK);\n+        assertEquals(\"2007-11-04T01:30:00.123-05:00\", dateTime.toString());\n+        DateTime test = dateTime.withMillisOfSecond(0);\n+        assertEquals(\"2007-11-04T01:30:00.000-05:00\", test.toString());\n+    }\n+\n+    public void testPlusMinutesInDstChange() {\n+        DateTime dateTime = new DateTime(\"2010-10-31T02:30:10.123+02:00\", ZONE_PARIS);\n+        assertEquals(\"2010-10-31T02:30:10.123+02:00\", dateTime.toString());\n+        DateTime test = dateTime.plusMinutes(1);\n+        assertEquals(\"2010-10-31T02:31:10.123+02:00\", test.toString());\n+    }\n+\n+    public void testPlusSecondsInDstChange() {\n+        DateTime dateTime = new DateTime(\"2010-10-31T02:30:10.123+02:00\", ZONE_PARIS);\n+        assertEquals(\"2010-10-31T02:30:10.123+02:00\", dateTime.toString());\n+        DateTime test = dateTime.plusSeconds(1);\n+        assertEquals(\"2010-10-31T02:30:11.123+02:00\", test.toString());\n+    }\n+\n+    public void testPlusMillisInDstChange() {\n+        DateTime dateTime = new DateTime(\"2010-10-31T02:30:10.123+02:00\", ZONE_PARIS);\n+        assertEquals(\"2010-10-31T02:30:10.123+02:00\", dateTime.toString());\n+        DateTime test = dateTime.plusMillis(1);\n+        assertEquals(\"2010-10-31T02:30:10.124+02:00\", test.toString());\n+    }\n+\n+    public void testBug2182444_usCentral() {\n+        Chronology chronUSCentral = GregorianChronology.getInstance(DateTimeZone.forID(\"US/Central\"));\n+        Chronology chronUTC = GregorianChronology.getInstance(DateTimeZone.UTC);\n+        DateTime usCentralStandardInUTC = new DateTime(2008, 11, 2, 7, 0, 0, 0, chronUTC);\n+        DateTime usCentralDaylightInUTC = new DateTime(2008, 11, 2, 6, 0, 0, 0, chronUTC);\n+        assertTrue(\"Should be standard time\", chronUSCentral.getZone().isStandardOffset(usCentralStandardInUTC.getMillis()));\n+        assertFalse(\"Should be daylight time\", chronUSCentral.getZone().isStandardOffset(usCentralDaylightInUTC.getMillis()));\n+        \n+        DateTime usCentralStandardInUSCentral = usCentralStandardInUTC.toDateTime(chronUSCentral);\n+        DateTime usCentralDaylightInUSCentral = usCentralDaylightInUTC.toDateTime(chronUSCentral);\n+        assertEquals(1, usCentralStandardInUSCentral.getHourOfDay());\n+        assertEquals(usCentralStandardInUSCentral.getHourOfDay(), usCentralDaylightInUSCentral.getHourOfDay());\n+        assertTrue(usCentralStandardInUSCentral.getMillis() != usCentralDaylightInUSCentral.getMillis());\n+        assertEquals(usCentralStandardInUSCentral, usCentralStandardInUSCentral.withHourOfDay(1));\n+        assertEquals(usCentralStandardInUSCentral.getMillis() + 3, usCentralStandardInUSCentral.withMillisOfSecond(3).getMillis());\n+        assertEquals(usCentralDaylightInUSCentral, usCentralDaylightInUSCentral.withHourOfDay(1));\n+        assertEquals(usCentralDaylightInUSCentral.getMillis() + 3, usCentralDaylightInUSCentral.withMillisOfSecond(3).getMillis());\n+    }\n+\n+    public void testBug2182444_ausNSW() {\n+        Chronology chronAusNSW = GregorianChronology.getInstance(DateTimeZone.forID(\"Australia/NSW\"));\n+        Chronology chronUTC = GregorianChronology.getInstance(DateTimeZone.UTC);\n+        DateTime australiaNSWStandardInUTC = new DateTime(2008, 4, 5, 16, 0, 0, 0, chronUTC);\n+        DateTime australiaNSWDaylightInUTC = new DateTime(2008, 4, 5, 15, 0, 0, 0, chronUTC);\n+        assertTrue(\"Should be standard time\", chronAusNSW.getZone().isStandardOffset(australiaNSWStandardInUTC.getMillis()));\n+        assertFalse(\"Should be daylight time\", chronAusNSW.getZone().isStandardOffset(australiaNSWDaylightInUTC.getMillis()));\n+        \n+        DateTime australiaNSWStandardInAustraliaNSW = australiaNSWStandardInUTC.toDateTime(chronAusNSW);\n+        DateTime australiaNSWDaylightInAusraliaNSW = australiaNSWDaylightInUTC.toDateTime(chronAusNSW);\n+        assertEquals(2, australiaNSWStandardInAustraliaNSW.getHourOfDay());\n+        assertEquals(australiaNSWStandardInAustraliaNSW.getHourOfDay(), australiaNSWDaylightInAusraliaNSW.getHourOfDay());\n+        assertTrue(australiaNSWStandardInAustraliaNSW.getMillis() != australiaNSWDaylightInAusraliaNSW.getMillis());\n+        assertEquals(australiaNSWStandardInAustraliaNSW, australiaNSWStandardInAustraliaNSW.withHourOfDay(2));\n+        assertEquals(australiaNSWStandardInAustraliaNSW.getMillis() + 3, australiaNSWStandardInAustraliaNSW.withMillisOfSecond(3).getMillis());\n+        assertEquals(australiaNSWDaylightInAusraliaNSW, australiaNSWDaylightInAusraliaNSW.withHourOfDay(2));\n+        assertEquals(australiaNSWDaylightInAusraliaNSW.getMillis() + 3, australiaNSWDaylightInAusraliaNSW.withMillisOfSecond(3).getMillis());\n+    }\n+\n+    //-----------------------------------------------------------------------\n     //-----------------------------------------------------------------------\n     //-----------------------------------------------------------------------\n     private void doTest_getOffsetFromLocal(int month, int day, int hour, int min,\n--- a/JodaTime/src/test/java/org/joda/time/TestLocalDate_Basics.java\n+++ b/JodaTime/src/test/java/org/joda/time/TestLocalDate_Basics.java\n     /** Mock zone simulating Asia/Gaza cutover at midnight 2007-04-01 */\n     private static long CUTOVER_GAZA = 1175378400000L;\n     private static int OFFSET_GAZA = 7200000;  // +02:00\n-    private static final DateTimeZone MOCK_GAZA = new MockZone(CUTOVER_GAZA, OFFSET_GAZA);\n+    private static final DateTimeZone MOCK_GAZA = new MockZone(CUTOVER_GAZA, OFFSET_GAZA, 3600);\n \n     private long TEST_TIME_NOW =\n             (31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;\n--- a/JodaTime/src/test/java/org/joda/time/chrono/TestLenientChronology.java\n+++ b/JodaTime/src/test/java/org/joda/time/chrono/TestLenientChronology.java\n     /** Mock zone simulating America/Grand_Turk cutover at midnight 2007-04-01 */\n     private static long CUTOVER_TURK = 1175403600000L;\n     private static int OFFSET_TURK = -18000000;  // -05:00\n-    private static final DateTimeZone MOCK_TURK = new MockZone(CUTOVER_TURK, OFFSET_TURK);\n+    private static final DateTimeZone MOCK_TURK = new MockZone(CUTOVER_TURK, OFFSET_TURK, 3600);\n \n     //-----------------------------------------------------------------------\n     public void test_MockTurkIsCorrect() {", "timestamp": 1291584456, "metainfo": ""}