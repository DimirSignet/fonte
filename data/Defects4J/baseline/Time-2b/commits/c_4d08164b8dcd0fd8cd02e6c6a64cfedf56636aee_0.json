{"sha": "4d08164b8dcd0fd8cd02e6c6a64cfedf56636aee", "log": "More performance improvements due to less object allocation.   ", "commit": "\n--- a/JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java\n+++ b/JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java\n         SavedField[] savedFields = iSavedFields;\n         int savedFieldsCount = iSavedFieldsCount;\n \n-        if (savedFieldsCount == savedFields.length) {\n-            SavedField[] newArray = new SavedField[savedFieldsCount * 2];\n+        if (savedFieldsCount == savedFields.length || iSavedFieldsShared) {\n+            // Expand capacity or merely copy if saved fields are shared.\n+            SavedField[] newArray = new SavedField\n+                [savedFieldsCount == savedFields.length ? savedFieldsCount * 2 : savedFields.length];\n             System.arraycopy(savedFields, 0, newArray, 0, savedFieldsCount);\n             iSavedFields = savedFields = newArray;\n-            iSavedFieldsShared = false;\n-        } else if (iSavedFieldsShared) {\n-            iSavedFields = savedFields = (SavedField[])savedFields.clone();\n             iSavedFieldsShared = false;\n         }\n \n     public long computeMillis() {\n         SavedField[] savedFields = iSavedFields;\n         int count = iSavedFieldsCount;\n-        Arrays.sort(savedFields, 0, count);\n+        sort(savedFields, count);\n \n         long millis = iMillis;\n         for (int i=0; i<count; i++) {\n         }\n \n         return millis;\n+    }\n+\n+    /**\n+     * Sorts elements [0,high). Calling java.util.Arrays isn't always the right\n+     * choice since it always creates an internal copy of the array, even if it\n+     * doesn't need to. If the array slice is small enough, an insertion sort\n+     * is chosen instead, but it doesn't need a copy!\n+     * <p>\n+     * This method has a modified version of that insertion sort, except it\n+     * doesn't create an unnecessary array copy. If high is over 10, then\n+     * java.util.Arrays is called, which will perform a merge sort, which is\n+     * faster than insertion sort on large lists.\n+     * <p>\n+     * The end result is much greater performace when computeMillis is called.\n+     * Since the amount of saved fields is small, the insertion sort is a\n+     * better choice. Additional performance is gained since there is no extra\n+     * array allocation and copying. Also, the insertion sort here does not\n+     * perform any casting operations. The version in java.util.Arrays performs\n+     * casts within the insertion sort loop.\n+     */\n+    private static void sort(Comparable[] array, int high) {\n+        if (high > 10) {\n+            Arrays.sort(array, 0, high);\n+        } else {\n+            for (int i=0; i<high; i++) {\n+                for (int j=i; j>0 && (array[j-1]).compareTo(array[j])>0; j--) {\n+                    Comparable t = array[j];\n+                    array[j] = array[j-1];\n+                    array[j-1] = t;\n+                }\n+            }\n+        }\n     }\n \n     private static class SavedField implements Comparable {\n             this.iOffset = DateTimeParserBucket.this.iOffset;\n             this.iSavedFields = DateTimeParserBucket.this.iSavedFields;\n             this.iSavedFieldsCount = DateTimeParserBucket.this.iSavedFieldsCount;\n-            DateTimeParserBucket.this.iSavedFieldsShared = true;\n         }\n \n         boolean revertState(DateTimeParserBucket enclosing) {\n             if (enclosing != DateTimeParserBucket.this) {\n                 return false;\n             }\n-            DateTimeParserBucket.this.iZone = this.iZone;\n-            DateTimeParserBucket.this.iOffset = this.iOffset;\n-            DateTimeParserBucket.this.iSavedFields = this.iSavedFields;\n-            DateTimeParserBucket.this.iSavedFieldsCount = this.iSavedFieldsCount;\n-            DateTimeParserBucket.this.iSavedFieldsShared = true;\n+            enclosing.iZone = this.iZone;\n+            enclosing.iOffset = this.iOffset;\n+            enclosing.iSavedFields = this.iSavedFields;\n+            if (this.iSavedFieldsCount < enclosing.iSavedFieldsCount) {\n+                // Since count is being restored to a lower count, the\n+                // potential exists for new saved fields to destroy data being\n+                // shared by another state. Set this flag such that the array\n+                // of saved fields is cloned prior to modification.\n+                enclosing.iSavedFieldsShared = true;\n+            }\n+            enclosing.iSavedFieldsCount = this.iSavedFieldsCount;\n             return true;\n         }\n     }", "timestamp": 1073285516, "metainfo": ""}