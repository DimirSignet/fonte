{"sha": "843d7b8f07f4899ad153ffabc25e09a6c0e897c7", "log": "Parse month-day in year 2000 instead of 1970 to parse Feb 29  ", "commit": "\n--- a/JodaTime/src/main/java/org/joda/time/format/DateTimeFormatter.java\n+++ b/JodaTime/src/main/java/org/joda/time/format/DateTimeFormatter.java\n     private final Chronology iChrono;\n     /** The zone to use as an override. */\n     private final DateTimeZone iZone;\n-    /* The pivot year to use for two-digit year parsing. */\n+    /** The pivot year to use for two-digit year parsing. */\n     private final Integer iPivotYear;\n+    /** The default year for parsing month/day without year. */\n+    private final int iDefaultYear;\n \n     /**\n      * Creates a new formatter, however you will normally use the factory\n         iChrono = null;\n         iZone = null;\n         iPivotYear = null;\n+        iDefaultYear = 2000;\n     }\n \n     /**\n             DateTimePrinter printer, DateTimeParser parser,\n             Locale locale, boolean offsetParsed,\n             Chronology chrono, DateTimeZone zone,\n-            Integer pivotYear) {\n+            Integer pivotYear, int defaultYear) {\n         super();\n         iPrinter = printer;\n         iParser = parser;\n         iChrono = chrono;\n         iZone = zone;\n         iPivotYear = pivotYear;\n+        iDefaultYear = defaultYear;\n     }\n \n     //-----------------------------------------------------------------------\n             return this;\n         }\n         return new DateTimeFormatter(iPrinter, iParser, locale,\n-                iOffsetParsed, iChrono, iZone, iPivotYear);\n+                iOffsetParsed, iChrono, iZone, iPivotYear, iDefaultYear);\n     }\n \n     /**\n             return this;\n         }\n         return new DateTimeFormatter(iPrinter, iParser, iLocale,\n-                true, iChrono, null, iPivotYear);\n+                true, iChrono, null, iPivotYear, iDefaultYear);\n     }\n \n     /**\n             return this;\n         }\n         return new DateTimeFormatter(iPrinter, iParser, iLocale,\n-                iOffsetParsed, chrono, iZone, iPivotYear);\n+                iOffsetParsed, chrono, iZone, iPivotYear, iDefaultYear);\n     }\n \n     /**\n             return this;\n         }\n         return new DateTimeFormatter(iPrinter, iParser, iLocale,\n-                false, iChrono, zone, iPivotYear);\n+                false, iChrono, zone, iPivotYear, iDefaultYear);\n     }\n \n     /**\n             return this;\n         }\n         return new DateTimeFormatter(iPrinter, iParser, iLocale,\n-                iOffsetParsed, iChrono, iZone, pivotYear);\n+                iOffsetParsed, iChrono, iZone, pivotYear, iDefaultYear);\n     }\n \n     /**\n      */\n     public Integer getPivotYear() {\n       return iPivotYear;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a new formatter that will use the specified default year.\n+     * <p>\n+     * The default year is used when parsing in the case where there is a\n+     * month or a day but not a year. Specifically, it is used if there is\n+     * a field parsed with a duration between the length of a month and the\n+     * length of a day inclusive.\n+     * <p>\n+     * This value is typically used to move the year from 1970 to a leap year\n+     * to enable February 29th to be parsed.\n+     * Unless customised, the year 2000 is used.\n+     * <p>\n+     * This setting has no effect when printing.\n+     *\n+     * @param defaultYear  the default year to use\n+     * @return the new formatter, not null\n+     * @since 2.0\n+     */\n+    public DateTimeFormatter withDefaultYear(int defaultYear) {\n+        return new DateTimeFormatter(iPrinter, iParser, iLocale,\n+                iOffsetParsed, iChrono, iZone, iPivotYear, defaultYear);\n+    }\n+\n+    /**\n+     * Gets the default year for parsing months and days.\n+     *\n+     * @return the default year for parsing months and days\n+     * @since 2.0\n+     */\n+    public int getDefaultYear() {\n+      return iDefaultYear;\n     }\n \n     //-----------------------------------------------------------------------\n         long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n         chrono = selectChronology(chrono);\n         \n-        DateTimeParserBucket bucket = new DateTimeParserBucket\n-            (instantLocal, chrono, iLocale, iPivotYear);\n+        DateTimeParserBucket bucket = new DateTimeParserBucket(\n+            instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);\n         int newPos = parser.parseInto(bucket, text, position);\n         instant.setMillis(bucket.computeMillis(false, text));\n         if (iOffsetParsed && bucket.getZone() == null) {\n         DateTimeParser parser = requireParser();\n         \n         Chronology chrono = selectChronology(iChrono);\n-        DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear);\n+        DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n         int newPos = parser.parseInto(bucket, text, 0);\n         if (newPos >= 0) {\n             if (newPos >= text.length()) {\n         DateTimeParser parser = requireParser();\n         \n         Chronology chrono = selectChronology(null).withUTC();  // always use UTC, avoiding DST gaps\n-        DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear);\n+        DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n         int newPos = parser.parseInto(bucket, text, 0);\n         if (newPos >= 0) {\n             if (newPos >= text.length()) {\n         DateTimeParser parser = requireParser();\n         \n         Chronology chrono = selectChronology(null);\n-        DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear);\n+        DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n         int newPos = parser.parseInto(bucket, text, 0);\n         if (newPos >= 0) {\n             if (newPos >= text.length()) {\n         DateTimeParser parser = requireParser();\n         \n         Chronology chrono = selectChronology(null);\n-        DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear);\n+        DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n         int newPos = parser.parseInto(bucket, text, 0);\n         if (newPos >= 0) {\n             if (newPos >= text.length()) {\n--- a/JodaTime/src/main/java/org/joda/time/format/DateTimeParserBucket.java\n+++ b/JodaTime/src/main/java/org/joda/time/format/DateTimeParserBucket.java\n import org.joda.time.DateTimeUtils;\n import org.joda.time.DateTimeZone;\n import org.joda.time.DurationField;\n+import org.joda.time.DurationFieldType;\n import org.joda.time.IllegalFieldValueException;\n \n /**\n     private Locale iLocale;\n     /** Used for parsing two-digit years. */\n     private Integer iPivotYear;\n+    /** Used for parsing month/day without year. */\n+    private int iDefaultYear;\n \n     private SavedField[] iSavedFields = new SavedField[8];\n     private int iSavedFieldsCount;\n     private Object iSavedState;\n \n     /**\n-     * Constucts a bucket.\n+     * Constructs a bucket.\n      * \n      * @param instantLocal  the initial millis from 1970-01-01T00:00:00, local time\n      * @param chrono  the chronology to use\n      * @param locale  the locale to use\n-     */\n+     * @deprecated Use longer constructor\n+     */\n+    @Deprecated\n     public DateTimeParserBucket(long instantLocal, Chronology chrono, Locale locale) {\n-        this(instantLocal, chrono, locale, null);\n-    }\n-\n-    /**\n-     * Constucts a bucket, with the option of specifying the pivot year for\n+        this(instantLocal, chrono, locale, null, 2000);\n+    }\n+\n+    /**\n+     * Constructs a bucket, with the option of specifying the pivot year for\n      * two-digit year parsing.\n      *\n      * @param instantLocal  the initial millis from 1970-01-01T00:00:00, local time\n      * @param locale  the locale to use\n      * @param pivotYear  the pivot year to use when parsing two-digit years\n      * @since 1.1\n-     */\n+     * @deprecated Use longer constructor\n+     */\n+    @Deprecated\n     public DateTimeParserBucket(long instantLocal, Chronology chrono, Locale locale, Integer pivotYear) {\n+        this(instantLocal, chrono, locale, pivotYear, 2000);\n+    }\n+\n+    /**\n+     * Constructs a bucket, with the option of specifying the pivot year for\n+     * two-digit year parsing.\n+     *\n+     * @param instantLocal  the initial millis from 1970-01-01T00:00:00, local time\n+     * @param chrono  the chronology to use\n+     * @param locale  the locale to use\n+     * @param pivotYear  the pivot year to use when parsing two-digit years\n+     * @since 2.0\n+     */\n+    public DateTimeParserBucket(long instantLocal, Chronology chrono,\n+            Locale locale, Integer pivotYear, int defaultYear) {\n         super();\n         chrono = DateTimeUtils.getChronology(chrono);\n         iMillis = instantLocal;\n         iLocale = (locale == null ? Locale.getDefault() : locale);\n         setZone(chrono.getZone());\n         iPivotYear = pivotYear;\n+        iDefaultYear = defaultYear;\n     }\n \n     //-----------------------------------------------------------------------\n \n     //-----------------------------------------------------------------------\n     /**\n-     * Returns the pivot year used for parsing two-digit years.\n+     * Returns the default year used when information is incomplete.\n      * <p>\n-     * If null is returned, this indicates default behaviour\n+     * This is used for two-digit years and when the largest parsed field is\n+     * months or days.\n+     * <p>\n+     * A null value for two-digit years means to use the value from DateTimeFormatterBuilder.\n+     * A null value for month/day only parsing will cause the default of 2000 to be used.\n      *\n      * @return Integer value of the pivot year, null if not set\n      * @since 1.1\n             iSavedFieldsShared = false;\n         }\n         sort(savedFields, count);\n+        if (count > 0) {\n+            // alter base year for parsing if first field is month or day\n+            DurationField months = DurationFieldType.months().getField(iChrono);\n+            DurationField days = DurationFieldType.days().getField(iChrono);\n+            DurationField first = savedFields[0].iField.getDurationField();\n+            if (compareReverse(first, months) >= 0 && compareReverse(first, days) <= 0) {\n+                saveField(DateTimeFieldType.year(), iDefaultYear);\n+                return computeMillis(resetFields, text);\n+            }\n+        }\n \n         long millis = iMillis;\n         try {\n             return compareReverse\n                 (iField.getDurationField(), other.getDurationField());\n         }\n-        \n-        private int compareReverse(DurationField a, DurationField b) {\n-            if (a == null || !a.isSupported()) {\n-                if (b == null || !b.isSupported()) {\n-                    return 0;\n-                }\n-                return -1;\n-            }\n+    }\n+\n+    static int compareReverse(DurationField a, DurationField b) {\n+        if (a == null || !a.isSupported()) {\n             if (b == null || !b.isSupported()) {\n-                return 1;\n-            }\n-            return -a.compareTo(b);\n-        }\n+                return 0;\n+            }\n+            return -1;\n+        }\n+        if (b == null || !b.isSupported()) {\n+            return 1;\n+        }\n+        return -a.compareTo(b);\n     }\n }\n--- a/JodaTime/src/test/java/org/joda/time/format/TestDateTimeFormat.java\n+++ b/JodaTime/src/test/java/org/joda/time/format/TestDateTimeFormat.java\n         String str = new DateTime(2007, 6, 23, 0, 0, 0, 0, UTC).toString(dateFormatter);\n         assertEquals(\"23 juin\", str);\n         DateTime date = dateFormatter.parseDateTime(str);\n-        check(date, 1970, 6, 23);\n+        check(date, 2000, 6, 23);\n+    }\n+\n+    public void testFormatParse_textMonthAtEnd_France_withSpecifiedDefault() {\n+        DateTimeFormatter dateFormatter = DateTimeFormat.forPattern(\"dd MMM\")\n+            .withLocale(Locale.FRANCE).withZoneUTC().withDefaultYear(1980);\n+        \n+        String str = new DateTime(2007, 6, 23, 0, 0, 0, 0, UTC).toString(dateFormatter);\n+        assertEquals(\"23 juin\", str);\n+        DateTime date = dateFormatter.parseDateTime(str);\n+        check(date, 1980, 6, 23);\n     }\n \n     public void testFormatParse_textMonthApr_Korean() {\n--- a/JodaTime/src/test/java/org/joda/time/format/TestDateTimeFormatter.java\n+++ b/JodaTime/src/test/java/org/joda/time/format/TestDateTimeFormatter.java\n import org.joda.time.MutableDateTime;\n import org.joda.time.ReadablePartial;\n import org.joda.time.chrono.BuddhistChronology;\n+import org.joda.time.chrono.GJChronology;\n import org.joda.time.chrono.ISOChronology;\n \n /**\n         } catch (IllegalArgumentException ex) {}\n     }\n \n+    public void testParseLocalDate_yearOfEra() {\n+        Chronology chrono = GJChronology.getInstanceUTC();\n+        DateTimeFormatter f = DateTimeFormat\n+            .forPattern(\"YYYY-MM GG\")\n+            .withChronology(chrono)\n+            .withLocale(Locale.UK);\n+        \n+        LocalDate date = new LocalDate(2005, 10, 1, chrono);\n+        assertEquals(date, f.parseLocalDate(\"2005-10 AD\"));\n+        assertEquals(date, f.parseLocalDate(\"2005-10 CE\"));\n+        \n+        date = new LocalDate(-2005, 10, 1, chrono);\n+        assertEquals(date, f.parseLocalDate(\"2005-10 BC\"));\n+        assertEquals(date, f.parseLocalDate(\"2005-10 BCE\"));\n+    }\n+\n+    public void testParseLocalDate_yearOfCentury() {\n+        Chronology chrono = GJChronology.getInstanceUTC();\n+        DateTimeFormatter f = DateTimeFormat\n+            .forPattern(\"yy M d\")\n+            .withChronology(chrono)\n+            .withLocale(Locale.UK)\n+            .withPivotYear(2050);\n+        \n+        LocalDate date = new LocalDate(2050, 8, 4, chrono);\n+        assertEquals(date, f.parseLocalDate(\"50 8 4\"));\n+    }\n+\n+    public void testParseLocalDate_monthDay_feb29() {\n+        Chronology chrono = GJChronology.getInstanceUTC();\n+        DateTimeFormatter f = DateTimeFormat\n+            .forPattern(\"M d\")\n+            .withChronology(chrono)\n+            .withLocale(Locale.UK);\n+        \n+        assertEquals(new LocalDate(2000, 2, 29, chrono), f.parseLocalDate(\"2 29\"));\n+    }\n+\n+    public void testParseLocalDate_monthDay_withDefaultYear_feb29() {\n+        Chronology chrono = GJChronology.getInstanceUTC();\n+        DateTimeFormatter f = DateTimeFormat\n+            .forPattern(\"M d\")\n+            .withChronology(chrono)\n+            .withLocale(Locale.UK)\n+            .withDefaultYear(2012);\n+        \n+        assertEquals(new LocalDate(2012, 2, 29, chrono), f.parseLocalDate(\"2 29\"));\n+    }\n+\n     //-----------------------------------------------------------------------\n     public void testParseLocalTime_simple() {\n         assertEquals(new LocalTime(10, 20, 30), g.parseLocalTime(\"2004-06-09T10:20:30Z\"));\n             g.parseDateTime(\"ABC\");\n             fail();\n         } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    public void testParseLocalDateTime_monthDay_feb29() {\n+        Chronology chrono = GJChronology.getInstanceUTC();\n+        DateTimeFormatter f = DateTimeFormat\n+            .forPattern(\"M d H m\")\n+            .withChronology(chrono)\n+            .withLocale(Locale.UK);\n+        \n+        assertEquals(new LocalDateTime(2000, 2, 29, 13, 40, 0, 0, chrono), f.parseLocalDateTime(\"2 29 13 40\"));\n+    }\n+\n+    public void testParseLocalDateTime_monthDay_withDefaultYear_feb29() {\n+        Chronology chrono = GJChronology.getInstanceUTC();\n+        DateTimeFormatter f = DateTimeFormat\n+            .forPattern(\"M d H m\")\n+            .withChronology(chrono)\n+            .withLocale(Locale.UK)\n+            .withDefaultYear(2012);\n+        \n+        assertEquals(new LocalDateTime(2012, 2, 29, 13, 40, 0, 0, chrono), f.parseLocalDateTime(\"2 29 13 40\"));\n     }\n \n     //-----------------------------------------------------------------------", "timestamp": 1290108366, "metainfo": ""}