{"sha": "eac6e8608dc93816b685f96a43b27cbd351e77c6", "log": "Test DateTimeFormat styles and patterns Add ability to print time zone ids   ", "commit": "\n--- a/JodaTime/src/java/org/joda/time/format/DateTimeFormat.java\n+++ b/JodaTime/src/java/org/joda/time/format/DateTimeFormat.java\n import java.util.Map;\n \n import org.joda.time.Chronology;\n-import org.joda.time.DateTimeField;\n+import org.joda.time.DateTime;\n import org.joda.time.DateTimeFieldType;\n import org.joda.time.DateTimeZone;\n-import org.joda.time.DurationFieldType;\n import org.joda.time.ReadablePartial;\n-import org.joda.time.field.RemainderDateTimeField;\n \n /**\n  * Factory that creates instances of DateTimeFormatter from patterns and styles.\n  * S       fraction of second           number        978\n  *\n  * z       time zone                    text          Pacific Standard Time; PST\n- * Z       time zone offset             text          -08:00; -0800\n+ * Z       time zone offset/id          text          -0800; -08:00; Asia/Tokyo\n  *\n  * '       escape for text              delimiter\n  * ''      single quote                 literal       '\n  * <p>\n  * <strong>Month</strong>: 3 or over, use text, otherwise use number.\n  * <p>\n+ * <strong>Zone</strong>: 'Z' outputs offset without a colon, 'ZZ' outputs\n+ * the offset with a colon, 'ZZZ' or more outputs the zone id.\n+ * <p>\n  * Any characters in the pattern that are not in the ranges of ['a'..'z']\n  * and ['A'..'Z'] will be treated as quoted text. For instance, characters\n- * like ':', '.', ' ', '#' and '@' will appear in the resulting time text\n+ * like ':', '.', ' ', '#' and '?' will appear in the resulting time text\n  * even they are not embraced within single quotes.\n  * <p>\n  * DateTimeFormat is thread-safe and immutable, and the formatters it returns\n     //-----------------------------------------------------------------------\n     /**\n      * Factory to create a formatter from a pattern string.\n-     * The pattern string is encoded as per SimpleDateFormat.\n+     * The pattern string is described above, and is similar to SimpleDateFormat.\n+     * <p>\n+     * The format may contain locale specific output, and this will change as\n+     * you change the locale of the formatter.\n+     * Call {@link DateTimeFormatter#withLocale(Locale)} to switch the locale.\n+     * For example:\n+     * <pre>\n+     * DateTimeFormat.forPattern(pattern).withLocale(Locale.FRANCE).print(dt);\n+     * </pre>\n      *\n      * @param pattern  pattern specification\n      * @return the formatter\n      * The returned formatter will dynamically adjust to the locale that\n      * the print/parse takes place in. Thus you just call\n      * {@link DateTimeFormatter#withLocale(Locale)} and the Short/Medium/Long/Full\n-     * style for that locale will be output.\n+     * style for that locale will be output. For example:\n+     * <pre>\n+     * DateTimeFormat.forStyle(style).withLocale(Locale.FRANCE).print(dt);\n+     * </pre>\n      *\n      * @param style  two characters from the set {\"S\", \"M\", \"L\", \"F\", \"-\"}\n      * @return the formatter\n     }\n \n     /**\n+     * Creates a format that outputs a short time format.\n+     * <p>\n+     * The format will change as you change the locale of the formatter.\n+     * Call {@link DateTimeFormatter#withLocale(Locale)} to switch the locale.\n+     * \n+     * @return the formatter\n+     */\n+    public static DateTimeFormatter shortTime() {\n+        return createFormatterForStyleIndex(NONE, SHORT);\n+    }\n+\n+    /**\n+     * Creates a format that outputs a short datetime format.\n+     * <p>\n+     * The format will change as you change the locale of the formatter.\n+     * Call {@link DateTimeFormatter#withLocale(Locale)} to switch the locale.\n+     * \n+     * @return the formatter\n+     */\n+    public static DateTimeFormatter shortDateTime() {\n+        return createFormatterForStyleIndex(SHORT, SHORT);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n      * Creates a format that outputs a medium date format.\n      * <p>\n      * The format will change as you change the locale of the formatter.\n     }\n \n     /**\n+     * Creates a format that outputs a medium time format.\n+     * <p>\n+     * The format will change as you change the locale of the formatter.\n+     * Call {@link DateTimeFormatter#withLocale(Locale)} to switch the locale.\n+     * \n+     * @return the formatter\n+     */\n+    public static DateTimeFormatter mediumTime() {\n+        return createFormatterForStyleIndex(NONE, MEDIUM);\n+    }\n+\n+    /**\n+     * Creates a format that outputs a medium datetime format.\n+     * <p>\n+     * The format will change as you change the locale of the formatter.\n+     * Call {@link DateTimeFormatter#withLocale(Locale)} to switch the locale.\n+     * \n+     * @return the formatter\n+     */\n+    public static DateTimeFormatter mediumDateTime() {\n+        return createFormatterForStyleIndex(MEDIUM, MEDIUM);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n      * Creates a format that outputs a long date format.\n      * <p>\n      * The format will change as you change the locale of the formatter.\n     }\n \n     /**\n+     * Creates a format that outputs a long time format.\n+     * <p>\n+     * The format will change as you change the locale of the formatter.\n+     * Call {@link DateTimeFormatter#withLocale(Locale)} to switch the locale.\n+     * \n+     * @return the formatter\n+     */\n+    public static DateTimeFormatter longTime() {\n+        return createFormatterForStyleIndex(NONE, LONG);\n+    }\n+\n+    /**\n+     * Creates a format that outputs a long datetime format.\n+     * <p>\n+     * The format will change as you change the locale of the formatter.\n+     * Call {@link DateTimeFormatter#withLocale(Locale)} to switch the locale.\n+     * \n+     * @return the formatter\n+     */\n+    public static DateTimeFormatter longDateTime() {\n+        return createFormatterForStyleIndex(LONG, LONG);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n      * Creates a format that outputs a full date format.\n      * <p>\n      * The format will change as you change the locale of the formatter.\n         return createFormatterForStyleIndex(FULL, NONE);\n     }\n \n-    //-----------------------------------------------------------------------\n-    /**\n-     * Creates a format that outputs a short time format.\n-     * <p>\n-     * The format will change as you change the locale of the formatter.\n-     * Call {@link DateTimeFormatter#withLocale(Locale)} to switch the locale.\n-     * \n-     * @return the formatter\n-     */\n-    public static DateTimeFormatter shortTime() {\n-        return createFormatterForStyleIndex(NONE, SHORT);\n-    }\n-\n-    /**\n-     * Creates a format that outputs a medium time format.\n-     * <p>\n-     * The format will change as you change the locale of the formatter.\n-     * Call {@link DateTimeFormatter#withLocale(Locale)} to switch the locale.\n-     * \n-     * @return the formatter\n-     */\n-    public static DateTimeFormatter mediumTime() {\n-        return createFormatterForStyleIndex(NONE, MEDIUM);\n-    }\n-\n-    /**\n-     * Creates a format that outputs a long time format.\n-     * <p>\n-     * The format will change as you change the locale of the formatter.\n-     * Call {@link DateTimeFormatter#withLocale(Locale)} to switch the locale.\n-     * \n-     * @return the formatter\n-     */\n-    public static DateTimeFormatter longTime() {\n-        return createFormatterForStyleIndex(NONE, LONG);\n-    }\n-\n     /**\n      * Creates a format that outputs a full time format.\n      * <p>\n      */\n     public static DateTimeFormatter fullTime() {\n         return createFormatterForStyleIndex(NONE, FULL);\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Creates a format that outputs a short datetime format.\n-     * <p>\n-     * The format will change as you change the locale of the formatter.\n-     * Call {@link DateTimeFormatter#withLocale(Locale)} to switch the locale.\n-     * \n-     * @return the formatter\n-     */\n-    public static DateTimeFormatter shortDateTime() {\n-        return createFormatterForStyleIndex(SHORT, SHORT);\n-    }\n-\n-    /**\n-     * Creates a format that outputs a medium datetime format.\n-     * <p>\n-     * The format will change as you change the locale of the formatter.\n-     * Call {@link DateTimeFormatter#withLocale(Locale)} to switch the locale.\n-     * \n-     * @return the formatter\n-     */\n-    public static DateTimeFormatter mediumDateTime() {\n-        return createFormatterForStyleIndex(MEDIUM, MEDIUM);\n-    }\n-\n-    /**\n-     * Creates a format that outputs a long datetime format.\n-     * <p>\n-     * The format will change as you change the locale of the formatter.\n-     * Call {@link DateTimeFormatter#withLocale(Locale)} to switch the locale.\n-     * \n-     * @return the formatter\n-     */\n-    public static DateTimeFormatter longDateTime() {\n-        return createFormatterForStyleIndex(LONG, LONG);\n     }\n \n     /**\n                     DateTimeFieldType type;\n                     switch (c) {\n                     case 'x':\n-                        type = new RemainderType(DateTimeFieldType.weekyear(),\n-                                                 DateTimeFieldType.weekyearOfCentury(), 100);\n+                        builder.appendTwoDigitWeekyear(new DateTime().getWeekyear() - 30);\n                         break;\n-                    case 'y': default:\n-                        type = new RemainderType(DateTimeFieldType.year(),\n-                                                 DateTimeFieldType.yearOfCentury(), 100);\n-                        break;\n+                    case 'y':\n                     case 'Y':\n-                        type = new RemainderType(DateTimeFieldType.yearOfEra(),\n-                                                 DateTimeFieldType.yearOfCentury(), 100);\n+                    default:\n+                        builder.appendTwoDigitYear(new DateTime().getYear() - 30);\n                         break;\n                     }\n-                    builder.appendDecimal(type, 2, 2);\n                 } else {\n                     // Try to support long year values.\n                     int maxDigits = 9;\n                 }\n                 break;\n             case 'Z': // time zone offset\n-                if (tokenLen >= 4) {\n+                if (tokenLen == 1) {\n+                    builder.appendTimeZoneOffset(null, false, 2, 2);\n+                } else if (tokenLen == 2) {\n                     builder.appendTimeZoneOffset(null, true, 2, 2);\n                 } else {\n-                    builder.appendTimeZoneOffset(null, false, 2, 2);\n+                    builder.appendTimeZoneId();\n                 }\n                 break;\n             case '\\'': // literal text\n      * @see #appendPatternTo\n      */\n     private static DateTimeFormatter createFormatterForPattern(String pattern) {\n-        if (pattern == null) {\n+        if (pattern == null || pattern.length() == 0) {\n             throw new IllegalArgumentException(\"Invalid pattern specification\");\n         }\n         DateTimeFormatter formatter = null;\n                 } else if (timeStyle == NONE) {\n                     type = DATE;\n                 }\n-                LengthLocaleFormatter llf = new LengthLocaleFormatter(\n+                StyleFormatter llf = new StyleFormatter(\n                         dateStyle, timeStyle, type);\n                 f = new DateTimeFormatter(llf, llf);\n                 cStyleCache[index] = f;\n     }\n \n     //-----------------------------------------------------------------------\n-    /**\n-     * Special field type which derives a new field as a remainder.\n-     */\n-    static class RemainderType extends DateTimeFieldType {\n-        private final DateTimeFieldType iWrappedType;\n-        private final DateTimeFieldType iType;\n-        private final int iDivisor;\n-\n-        private transient RemainderDateTimeField iRecent;\n-\n-        RemainderType(DateTimeFieldType wrappedType, DateTimeFieldType type, int divisor) {\n-            super(type.getName());\n-            iWrappedType = wrappedType;\n-            iType = type;\n-            iDivisor = divisor;\n-        }\n-\n-        public DurationFieldType getDurationType() {\n-            return iType.getDurationType();\n-        }\n-\n-        public DurationFieldType getRangeDurationType() {\n-            return iType.getRangeDurationType();\n-        }\n-\n-        public DateTimeField getField(Chronology chrono) {\n-            DateTimeField wrappedField = iWrappedType.getField(chrono);\n-            RemainderDateTimeField field = iRecent;\n-            if (field != null && field.getWrappedField() == wrappedField) {\n-                return field;\n-            }\n-            field = new RemainderDateTimeField(wrappedField, iType, iDivisor);\n-            iRecent = field;\n-            return field;\n-        }\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    static class LengthLocaleFormatter\n+    static class StyleFormatter\n             implements DateTimePrinter, DateTimeParser {\n \n         private static final Map cCache = new HashMap();  // manual sync\n         private final int iTimeStyle;\n         private final int iType;\n \n-        LengthLocaleFormatter(int dateStyle, int timeStyle, int type) {\n+        StyleFormatter(int dateStyle, int timeStyle, int type) {\n             super();\n             iDateStyle = dateStyle;\n             iTimeStyle = timeStyle;\n         }\n \n         private DateTimeFormatter getFormatter(Locale locale) {\n-            String key = Integer.toString(iType + iDateStyle << 4 + iTimeStyle << 8) + locale.toString();\n+            locale = (locale == null ? Locale.getDefault() : locale);\n+            String key = Integer.toString(iType + (iDateStyle << 4) + (iTimeStyle << 8)) + locale.toString();\n             DateTimeFormatter f = null;\n             synchronized (cCache) {\n                 f = (DateTimeFormatter) cCache.get(key);\n--- a/JodaTime/src/java/org/joda/time/format/DateTimeFormatterBuilder.java\n+++ b/JodaTime/src/java/org/joda/time/format/DateTimeFormatterBuilder.java\n      * 2050      2000..2099      2000    2020    2040    2060    2080\n      * </pre>\n      *\n-     * @param pivot pivot year to use when parsing\n+     * @param pivot  pivot year to use when parsing\n      * @return this DateTimeFormatterBuilder\n      */\n     public DateTimeFormatterBuilder appendTwoDigitYear(int pivot) {\n-        return append0(new TwoDigitYear(pivot));\n+        return append0(new TwoDigitYear(DateTimeFieldType.year(), pivot));\n+    }\n+\n+    /**\n+     * Instructs the printer to emit a numeric weekyear field which always prints\n+     * and parses two digits. A pivot year is used during parsing to determine\n+     * the range of supported years as <code>(pivot - 50) .. (pivot + 49)</code>.\n+     *\n+     * <pre>\n+     * pivot   supported range   00 is   20 is   40 is   60 is   80 is\n+     * ---------------------------------------------------------------\n+     * 1950      1900..1999      1900    1920    1940    1960    1980\n+     * 1975      1925..2024      2000    2020    1940    1960    1980\n+     * 2000      1950..2049      2000    2020    2040    1960    1980\n+     * 2025      1975..2074      2000    2020    2040    2060    1980\n+     * 2050      2000..2099      2000    2020    2040    2060    2080\n+     * </pre>\n+     *\n+     * @param pivot  pivot weekyear to use when parsing\n+     * @return this DateTimeFormatterBuilder\n+     */\n+    public DateTimeFormatterBuilder appendTwoDigitWeekyear(int pivot) {\n+        return append0(new TwoDigitYear(DateTimeFieldType.weekyear(), pivot));\n     }\n \n     /**\n      * @return this DateTimeFormatterBuilder\n      */\n     public DateTimeFormatterBuilder appendTimeZoneName() {\n-        return append0(new TimeZonePrinter(false), null);\n+        return append0(new TimeZoneName(TimeZoneName.LONG_NAME), null);\n     }\n \n     /**\n      * @return this DateTimeFormatterBuilder\n      */\n     public DateTimeFormatterBuilder appendTimeZoneShortName() {\n-        return append0(new TimeZonePrinter(true), null);\n+        return append0(new TimeZoneName(TimeZoneName.SHORT_NAME), null);\n+    }\n+\n+    /**\n+     * Instructs the printer to emit the identifier of the time zone.\n+     * This field cannot currently be parsed.\n+     *\n+     * @return this DateTimeFormatterBuilder\n+     */\n+    public DateTimeFormatterBuilder appendTimeZoneId() {\n+        return append0(new TimeZoneName(TimeZoneName.ID), null);\n     }\n \n     /**\n     static class TwoDigitYear\n             implements DateTimePrinter, DateTimeParser {\n \n+        private final DateTimeFieldType iType;\n         private final int iPivot;\n \n-        TwoDigitYear(int pivot) {\n+        TwoDigitYear(DateTimeFieldType type, int pivot) {\n             super();\n+            iType = type;\n             iPivot = pivot;\n         }\n \n \n             year += low + ((year < t) ? 100 : 0) - t;\n \n-            bucket.saveField(DateTimeFieldType.year(), year);\n+            bucket.saveField(iType, year);\n             return position + 2;\n         }\n         \n \n         private int getTwoDigitYear(long instant, Chronology chrono) {\n             try {\n-                int year = chrono.year().get(instant);\n+                int year = iType.getField(chrono).get(instant);\n                 if (year < 0) {\n                     year = -year;\n                 }\n         }\n \n         private int getTwoDigitYear(ReadablePartial partial) {\n-            if (partial.isSupported(DateTimeFieldType.year())) {\n+            if (partial.isSupported(iType)) {\n                 try {\n-                    int year = partial.get(DateTimeFieldType.year());\n+                    int year = partial.get(iType);\n                     if (year < 0) {\n                         year = -year;\n                     }\n     }\n \n     //-----------------------------------------------------------------------\n-    static class TimeZonePrinter\n+    static class TimeZoneName\n             implements DateTimePrinter {\n \n-        private final boolean iShortFormat;\n-\n-        TimeZonePrinter(boolean shortFormat) {\n+        static final int LONG_NAME = 0;\n+        static final int SHORT_NAME = 1;\n+        static final int ID = 2;\n+\n+        private final int iType;\n+\n+        TimeZoneName(int type) {\n             super();\n-            iShortFormat = shortFormat;\n+            iType = type;\n         }\n \n         public int estimatePrintedLength() {\n-            return iShortFormat ? 4 : 20;\n+            return (iType == SHORT_NAME ? 4 : 20);\n         }\n \n         public void printTo(\n             if (displayZone == null) {\n                 return \"\";  // no zone\n             }\n-            if (iShortFormat) {\n-                return displayZone.getShortName(instant, locale);\n-            } else {\n-                return displayZone.getName(instant, locale);\n-            }\n+            switch (iType) {\n+                case LONG_NAME:\n+                    return displayZone.getName(instant, locale);\n+                case SHORT_NAME:\n+                    return displayZone.getShortName(instant, locale);\n+                case ID:\n+                    return displayZone.getID();\n+            }\n+            return \"\";\n         }\n \n         public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) {\n--- a/JodaTime/src/test/org/joda/time/format/TestAll.java\n+++ b/JodaTime/src/test/org/joda/time/format/TestAll.java\n         \n         suite.addTest(TestDateTimeFormatter.suite());\n         suite.addTest(TestDateTimeFormat.suite());\n+        suite.addTest(TestDateTimeFormatStyle.suite());\n         suite.addTest(TestISODateTimeFormat.suite());\n         \n         suite.addTest(TestISOPeriodFormat.suite());\n--- a/JodaTime/src/test/org/joda/time/format/TestDateTimeFormat.java\n+++ b/JodaTime/src/test/org/joda/time/format/TestDateTimeFormat.java\n         \n         dt = dt.withZone(TOKYO);\n         assertEquals(dt.toString(), \"20\", f.print(dt));\n+        \n+        dt = new DateTime(-123, 6, 9, 10, 20, 30, 40, UTC);\n+        assertEquals(dt.toString(), \"1\", f.print(dt));\n     }\n \n     //-----------------------------------------------------------------------\n         \n         dt = dt.withZone(TOKYO);\n         assertEquals(dt.toString(), \"2004\", f.print(dt));\n+        \n+        dt = new DateTime(-123, 6, 9, 10, 20, 30, 40, UTC);\n+        assertEquals(dt.toString(), \"124\", f.print(dt));  // 124th year of BCE\n+    }        \n+\n+    public void testFormat_yearOfEra_twoDigit() {\n+        DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);\n+        DateTimeFormatter f = DateTimeFormat.forPattern(\"YY\").withLocale(Locale.UK);\n+        assertEquals(dt.toString(), \"04\", f.print(dt));\n+        \n+        dt = new DateTime(-123, 6, 9, 10, 20, 30, 40, UTC);\n+        assertEquals(dt.toString(), \"23\", f.print(dt));\n+        \n+        // current time set to 2002-06-09\n+        f = f.withZone(UTC);\n+        DateTime expect = null;\n+        expect = new DateTime(2004, 1, 1, 0, 0, 0, 0, UTC);\n+        assertEquals(expect, f.parseDateTime(\"04\"));\n+        \n+        expect = new DateTime(1922, 1, 1, 0, 0, 0, 0, UTC);\n+        assertEquals(expect, f.parseDateTime(\"22\"));\n+        \n+        expect = new DateTime(2021, 1, 1, 0, 0, 0, 0, UTC);\n+        assertEquals(expect, f.parseDateTime(\"21\"));\n     }\n \n     //-----------------------------------------------------------------------\n         \n         dt = dt.withZone(TOKYO);\n         assertEquals(dt.toString(), \"2004\", f.print(dt));\n+        \n+        dt = new DateTime(-123, 6, 9, 10, 20, 30, 40, UTC);\n+        assertEquals(dt.toString(), \"-123\", f.print(dt));\n+    }\n+\n+    public void testFormat_year_twoDigit() {\n+        DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);\n+        DateTimeFormatter f = DateTimeFormat.forPattern(\"yy\").withLocale(Locale.UK);\n+        assertEquals(dt.toString(), \"04\", f.print(dt));\n+        \n+        dt = new DateTime(-123, 6, 9, 10, 20, 30, 40, UTC);\n+        assertEquals(dt.toString(), \"23\", f.print(dt));\n+        \n+        // current time set to 2002-06-09\n+        f = f.withZone(UTC);\n+        DateTime expect = null;\n+        expect = new DateTime(2004, 1, 1, 0, 0, 0, 0, UTC);\n+        assertEquals(expect, f.parseDateTime(\"04\"));\n+        \n+        expect = new DateTime(1922, 1, 1, 0, 0, 0, 0, UTC);\n+        assertEquals(expect, f.parseDateTime(\"22\"));\n+        \n+        expect = new DateTime(2021, 1, 1, 0, 0, 0, 0, UTC);\n+        assertEquals(expect, f.parseDateTime(\"21\"));\n     }\n \n     //-----------------------------------------------------------------------\n         \n         dt = dt.withZone(TOKYO);\n         assertEquals(dt.toString(), \"2004\", f.print(dt));\n+        \n+        dt = new DateTime(-123, 6, 9, 10, 20, 30, 40, UTC);\n+        assertEquals(dt.toString(), \"-123\", f.print(dt));\n+    }\n+\n+    public void testFormat_weekyearOfEra_twoDigit() {\n+        DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);\n+        DateTimeFormatter f = DateTimeFormat.forPattern(\"xx\").withLocale(Locale.UK);\n+        assertEquals(dt.toString(), \"04\", f.print(dt));\n+        \n+        dt = new DateTime(-123, 6, 9, 10, 20, 30, 40, UTC);\n+        assertEquals(dt.toString(), \"23\", f.print(dt));\n+        \n+        // current time set to 2002-06-09\n+        f = f.withZone(UTC);\n+        DateTime expect = null;\n+        expect = new DateTime(2003, 12, 29, 0, 0, 0, 0, UTC);\n+        assertEquals(expect, f.parseDateTime(\"04\"));\n+        \n+        expect = new DateTime(1922, 1, 2, 0, 0, 0, 0, UTC);\n+        assertEquals(expect, f.parseDateTime(\"22\"));\n+        \n+        expect = new DateTime(2021, 1, 4, 0, 0, 0, 0, UTC);\n+        assertEquals(expect, f.parseDateTime(\"21\"));\n     }\n \n     //-----------------------------------------------------------------------\n         assertEquals(dt.toString(), \"JST\", f.print(dt));\n     }\n \n+    public void testFormat_zoneLongText() {\n+        DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);\n+        DateTimeFormatter f = DateTimeFormat.forPattern(\"zzzz\").withLocale(Locale.UK);\n+        assertEquals(dt.toString(), \"Coordinated Universal Time\", f.print(dt));\n+        \n+        dt = dt.withZone(NEWYORK);\n+        assertEquals(dt.toString(), \"Eastern Daylight Time\", f.print(dt));\n+        \n+        dt = dt.withZone(TOKYO);\n+        assertEquals(dt.toString(), \"Japan Standard Time\", f.print(dt));\n+    }\n+\n     //-----------------------------------------------------------------------\n     public void testFormat_zoneAmount() {\n         DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);\n         assertEquals(dt.toString(), \"+0900\", f.print(dt));\n     }\n \n+    public void testFormat_zoneAmountColon() {\n+        DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);\n+        DateTimeFormatter f = DateTimeFormat.forPattern(\"ZZ\").withLocale(Locale.UK);\n+        assertEquals(dt.toString(), \"+00:00\", f.print(dt));\n+        \n+        dt = dt.withZone(NEWYORK);\n+        assertEquals(dt.toString(), \"-04:00\", f.print(dt));\n+        \n+        dt = dt.withZone(TOKYO);\n+        assertEquals(dt.toString(), \"+09:00\", f.print(dt));\n+    }\n+\n+    public void testFormat_zoneAmountID() {\n+        DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);\n+        DateTimeFormatter f = DateTimeFormat.forPattern(\"ZZZ\").withLocale(Locale.UK);\n+        assertEquals(dt.toString(), \"UTC\", f.print(dt));\n+        \n+        dt = dt.withZone(NEWYORK);\n+        assertEquals(dt.toString(), \"America/New_York\", f.print(dt));\n+        \n+        dt = dt.withZone(TOKYO);\n+        assertEquals(dt.toString(), \"Asia/Tokyo\", f.print(dt));\n+    }\n+\n     //-----------------------------------------------------------------------\n     public void testFormat_other() {\n         DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);\n         assertEquals(\"Hello '\", f.print(dt));\n     }\n \n+    public void testFormat_invalid() {\n+        try {\n+            DateTimeFormat.forPattern(null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            DateTimeFormat.forPattern(\"\");\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            DateTimeFormat.forPattern(\"A\");\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            DateTimeFormat.forPattern(\"dd/mm/AA\");\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n }\n--- /dev/null\n+++ b/JodaTime/src/test/org/joda/time/format/TestDateTimeFormatStyle.java\n+/*\n+ *  Copyright 2001-2005 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time.format;\n+\n+import java.text.DateFormat;\n+import java.util.Locale;\n+import java.util.TimeZone;\n+\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+import org.joda.time.DateTime;\n+import org.joda.time.DateTimeConstants;\n+import org.joda.time.DateTimeUtils;\n+import org.joda.time.DateTimeZone;\n+\n+/**\n+ * This class is a Junit unit test for DateTimeFormat styles.\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class TestDateTimeFormatStyle extends TestCase {\n+\n+    private static final Locale UK = Locale.UK;\n+    private static final Locale US = Locale.US;\n+    private static final Locale FRANCE = Locale.FRANCE;\n+    private static final DateTimeZone UTC = DateTimeZone.UTC;\n+    private static final DateTimeZone PARIS = DateTimeZone.forID(\"Europe/Paris\");\n+    private static final DateTimeZone LONDON = DateTimeZone.forID(\"Europe/London\");\n+    private static final DateTimeZone TOKYO = DateTimeZone.forID(\"Asia/Tokyo\");\n+    private static final DateTimeZone NEWYORK = DateTimeZone.forID(\"America/New_York\");\n+\n+    long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + \n+                     366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + \n+                     365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +\n+                     366 + 365;\n+    // 2002-06-09\n+    private long TEST_TIME_NOW =\n+            (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;\n+\n+    private DateTimeZone originalDateTimeZone = null;\n+    private TimeZone originalTimeZone = null;\n+    private Locale originalLocale = null;\n+\n+    public static void main(String[] args) {\n+        junit.textui.TestRunner.run(suite());\n+    }\n+\n+    public static TestSuite suite() {\n+        return new TestSuite(TestDateTimeFormatStyle.class);\n+    }\n+\n+    public TestDateTimeFormatStyle(String name) {\n+        super(name);\n+    }\n+\n+    protected void setUp() throws Exception {\n+        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);\n+        originalDateTimeZone = DateTimeZone.getDefault();\n+        originalTimeZone = TimeZone.getDefault();\n+        originalLocale = Locale.getDefault();\n+        DateTimeZone.setDefault(LONDON);\n+        TimeZone.setDefault(TimeZone.getTimeZone(\"Europe/London\"));\n+        Locale.setDefault(UK);\n+    }\n+\n+    protected void tearDown() throws Exception {\n+        DateTimeUtils.setCurrentMillisSystem();\n+        DateTimeZone.setDefault(originalDateTimeZone);\n+        TimeZone.setDefault(originalTimeZone);\n+        Locale.setDefault(originalLocale);\n+        originalDateTimeZone = null;\n+        originalTimeZone = null;\n+        originalLocale = null;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testForStyle_stringLengths() {\n+        try {\n+            DateTimeFormat.forStyle(null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            DateTimeFormat.forStyle(\"\");\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            DateTimeFormat.forStyle(\"S\");\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            DateTimeFormat.forStyle(\"SSS\");\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    public void testForStyle_invalidStrings() {\n+        try {\n+            DateTimeFormat.forStyle(\"AA\");\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            DateTimeFormat.forStyle(\"--\");\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            DateTimeFormat.forStyle(\"ss\");\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testForStyle_shortDate() throws Exception {\n+        DateTimeFormatter f = DateTimeFormat.shortDate();\n+        DateTimeFormatter g = DateTimeFormat.forStyle(\"S-\");\n+        assertSame(g, f);\n+        DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 0);\n+        String expect = DateFormat.getDateInstance(DateFormat.SHORT, UK).format(dt.toDate());\n+        assertEquals(expect, f.print(dt));\n+        expect = DateFormat.getDateInstance(DateFormat.SHORT, US).format(dt.toDate());\n+        assertEquals(expect, f.withLocale(US).print(dt));\n+        expect = DateFormat.getDateInstance(DateFormat.SHORT, FRANCE).format(dt.toDate());\n+        assertEquals(expect, f.withLocale(FRANCE).print(dt));\n+        \n+        DateTime date = new DateTime(\n+                DateFormat.getDateInstance(DateFormat.SHORT, FRANCE).parse(expect));\n+        assertEquals(date, f.withLocale(FRANCE).parseDateTime(expect));\n+    }\n+\n+    public void testForStyle_shortTime() throws Exception {\n+        DateTimeFormatter f = DateTimeFormat.shortTime();\n+        DateTimeFormatter g = DateTimeFormat.forStyle(\"-S\");\n+        assertSame(g, f);\n+        DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 0);\n+        String expect = DateFormat.getTimeInstance(DateFormat.SHORT, UK).format(dt.toDate());\n+        assertEquals(expect, f.print(dt));\n+        expect = DateFormat.getTimeInstance(DateFormat.SHORT, US).format(dt.toDate());\n+        assertEquals(expect, f.withLocale(US).print(dt));\n+        expect = DateFormat.getTimeInstance(DateFormat.SHORT, FRANCE).format(dt.toDate());\n+        assertEquals(expect, f.withLocale(FRANCE).print(dt));\n+        \n+        DateTime date = new DateTime(\n+                DateFormat.getTimeInstance(DateFormat.SHORT, FRANCE).parse(expect));\n+        assertEquals(date, f.withLocale(FRANCE).parseDateTime(expect));\n+    }\n+\n+    public void testForStyle_shortDateTime() throws Exception {\n+        DateTimeFormatter f = DateTimeFormat.shortDateTime();\n+        DateTimeFormatter g = DateTimeFormat.forStyle(\"SS\");\n+        assertSame(g, f);\n+        DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 0);\n+        String expect = DateFormat.getDateTimeInstance(DateFormat.SHORT, DateFormat.SHORT, UK).format(dt.toDate());\n+        assertEquals(expect, f.print(dt));\n+        expect = DateFormat.getDateTimeInstance(DateFormat.SHORT, DateFormat.SHORT, US).format(dt.toDate());\n+        assertEquals(expect, f.withLocale(US).print(dt));\n+        expect = DateFormat.getDateTimeInstance(DateFormat.SHORT, DateFormat.SHORT, FRANCE).format(dt.toDate());\n+        assertEquals(expect, f.withLocale(FRANCE).print(dt));\n+        \n+        DateTime date = new DateTime(\n+                DateFormat.getDateTimeInstance(DateFormat.SHORT, DateFormat.SHORT, FRANCE).parse(expect));\n+        assertEquals(date, f.withLocale(FRANCE).parseDateTime(expect));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testForStyle_mediumDate() throws Exception {\n+        DateTimeFormatter f = DateTimeFormat.mediumDate();\n+        DateTimeFormatter g = DateTimeFormat.forStyle(\"M-\");\n+        assertSame(g, f);\n+        DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 0);\n+        String expect = DateFormat.getDateInstance(DateFormat.MEDIUM, UK).format(dt.toDate());\n+        assertEquals(expect, f.print(dt));\n+        expect = DateFormat.getDateInstance(DateFormat.MEDIUM, US).format(dt.toDate());\n+        assertEquals(expect, f.withLocale(US).print(dt));\n+        expect = DateFormat.getDateInstance(DateFormat.MEDIUM, FRANCE).format(dt.toDate());\n+        assertEquals(expect, f.withLocale(FRANCE).print(dt));\n+    }\n+\n+    public void testForStyle_mediumTime() throws Exception {\n+        DateTimeFormatter f = DateTimeFormat.mediumTime();\n+        DateTimeFormatter g = DateTimeFormat.forStyle(\"-M\");\n+        assertSame(g, f);\n+        DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 0);\n+        String expect = DateFormat.getTimeInstance(DateFormat.MEDIUM, UK).format(dt.toDate());\n+        assertEquals(expect, f.print(dt));\n+        expect = DateFormat.getTimeInstance(DateFormat.MEDIUM, US).format(dt.toDate());\n+        assertEquals(expect, f.withLocale(US).print(dt));\n+        expect = DateFormat.getTimeInstance(DateFormat.MEDIUM, FRANCE).format(dt.toDate());\n+        assertEquals(expect, f.withLocale(FRANCE).print(dt));\n+    }\n+\n+    public void testForStyle_mediumDateTime() throws Exception {\n+        DateTimeFormatter f = DateTimeFormat.mediumDateTime();\n+        DateTimeFormatter g = DateTimeFormat.forStyle(\"MM\");\n+        assertSame(g, f);\n+        DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 0);\n+        String expect = DateFormat.getDateTimeInstance(DateFormat.MEDIUM, DateFormat.MEDIUM, UK).format(dt.toDate());\n+        assertEquals(expect, f.print(dt));\n+        expect = DateFormat.getDateTimeInstance(DateFormat.MEDIUM, DateFormat.MEDIUM, US).format(dt.toDate());\n+        assertEquals(expect, f.withLocale(US).print(dt));\n+        expect = DateFormat.getDateTimeInstance(DateFormat.MEDIUM, DateFormat.MEDIUM, FRANCE).format(dt.toDate());\n+        assertEquals(expect, f.withLocale(FRANCE).print(dt));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testForStyle_longDate() throws Exception {\n+        DateTimeFormatter f = DateTimeFormat.longDate();\n+        DateTimeFormatter g = DateTimeFormat.forStyle(\"L-\");\n+        assertSame(g, f);\n+        DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 0);\n+        String expect = DateFormat.getDateInstance(DateFormat.LONG, UK).format(dt.toDate());\n+        assertEquals(expect, f.print(dt));\n+        expect = DateFormat.getDateInstance(DateFormat.LONG, US).format(dt.toDate());\n+        assertEquals(expect, f.withLocale(US).print(dt));\n+        expect = DateFormat.getDateInstance(DateFormat.LONG, FRANCE).format(dt.toDate());\n+        assertEquals(expect, f.withLocale(FRANCE).print(dt));\n+    }\n+\n+    public void testForStyle_longTime() throws Exception {\n+        DateTimeFormatter f = DateTimeFormat.longTime();\n+        DateTimeFormatter g = DateTimeFormat.forStyle(\"-L\");\n+        assertSame(g, f);\n+        DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 0);\n+        String expect = DateFormat.getTimeInstance(DateFormat.LONG, UK).format(dt.toDate());\n+        assertEquals(expect, f.print(dt));\n+        expect = DateFormat.getTimeInstance(DateFormat.LONG, US).format(dt.toDate());\n+        assertEquals(expect, f.withLocale(US).print(dt));\n+        expect = DateFormat.getTimeInstance(DateFormat.LONG, FRANCE).format(dt.toDate());\n+        assertEquals(expect, f.withLocale(FRANCE).print(dt));\n+    }\n+\n+    public void testForStyle_longDateTime() throws Exception {\n+        DateTimeFormatter f = DateTimeFormat.longDateTime();\n+        DateTimeFormatter g = DateTimeFormat.forStyle(\"LL\");\n+        assertSame(g, f);\n+        DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 0);\n+        String expect = DateFormat.getDateTimeInstance(DateFormat.LONG, DateFormat.LONG, UK).format(dt.toDate());\n+        assertEquals(expect, f.print(dt));\n+        expect = DateFormat.getDateTimeInstance(DateFormat.LONG, DateFormat.LONG, US).format(dt.toDate());\n+        assertEquals(expect, f.withLocale(US).print(dt));\n+        expect = DateFormat.getDateTimeInstance(DateFormat.LONG, DateFormat.LONG, FRANCE).format(dt.toDate());\n+        assertEquals(expect, f.withLocale(FRANCE).print(dt));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testForStyle_fullDate() throws Exception {\n+        DateTimeFormatter f = DateTimeFormat.fullDate();\n+        DateTimeFormatter g = DateTimeFormat.forStyle(\"F-\");\n+        assertSame(g, f);\n+        DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 0);\n+        String expect = DateFormat.getDateInstance(DateFormat.FULL, UK).format(dt.toDate());\n+        assertEquals(expect, f.print(dt));\n+        expect = DateFormat.getDateInstance(DateFormat.FULL, US).format(dt.toDate());\n+        assertEquals(expect, f.withLocale(US).print(dt));\n+        expect = DateFormat.getDateInstance(DateFormat.FULL, FRANCE).format(dt.toDate());\n+        assertEquals(expect, f.withLocale(FRANCE).print(dt));\n+    }\n+\n+    public void testForStyle_fullTime() throws Exception {\n+        DateTimeFormatter f = DateTimeFormat.fullTime();\n+        DateTimeFormatter g = DateTimeFormat.forStyle(\"-F\");\n+        assertSame(g, f);\n+        DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 0);\n+        String expect = DateFormat.getTimeInstance(DateFormat.FULL, UK).format(dt.toDate());\n+        assertEquals(expect, f.print(dt));\n+        expect = DateFormat.getTimeInstance(DateFormat.FULL, US).format(dt.toDate());\n+        assertEquals(expect, f.withLocale(US).print(dt));\n+        expect = DateFormat.getTimeInstance(DateFormat.FULL, FRANCE).format(dt.toDate());\n+        assertEquals(expect, f.withLocale(FRANCE).print(dt));\n+    }\n+\n+    public void testForStyle_fullDateTime() throws Exception {\n+        DateTimeFormatter f = DateTimeFormat.fullDateTime();\n+        DateTimeFormatter g = DateTimeFormat.forStyle(\"FF\");\n+        assertSame(g, f);\n+        DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 0);\n+        String expect = DateFormat.getDateTimeInstance(DateFormat.FULL, DateFormat.FULL, UK).format(dt.toDate());\n+        assertEquals(expect, f.print(dt));\n+        expect = DateFormat.getDateTimeInstance(DateFormat.FULL, DateFormat.FULL, US).format(dt.toDate());\n+        assertEquals(expect, f.withLocale(US).print(dt));\n+        expect = DateFormat.getDateTimeInstance(DateFormat.FULL, DateFormat.FULL, FRANCE).format(dt.toDate());\n+        assertEquals(expect, f.withLocale(FRANCE).print(dt));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testForStyle_shortMediumDateTime() throws Exception {\n+        DateTimeFormatter f = DateTimeFormat.forStyle(\"SM\");\n+        DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 0);\n+        String expect = DateFormat.getDateTimeInstance(DateFormat.SHORT, DateFormat.MEDIUM, UK).format(dt.toDate());\n+        assertEquals(expect, f.print(dt));\n+        expect = DateFormat.getDateTimeInstance(DateFormat.SHORT, DateFormat.MEDIUM, US).format(dt.toDate());\n+        assertEquals(expect, f.withLocale(US).print(dt));\n+        expect = DateFormat.getDateTimeInstance(DateFormat.SHORT, DateFormat.MEDIUM, FRANCE).format(dt.toDate());\n+        assertEquals(expect, f.withLocale(FRANCE).print(dt));\n+    }\n+\n+    public void testForStyle_shortLongDateTime() throws Exception {\n+        DateTimeFormatter f = DateTimeFormat.forStyle(\"SL\");\n+        DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 0);\n+        String expect = DateFormat.getDateTimeInstance(DateFormat.SHORT, DateFormat.LONG, UK).format(dt.toDate());\n+        assertEquals(expect, f.print(dt));\n+        expect = DateFormat.getDateTimeInstance(DateFormat.SHORT, DateFormat.LONG, US).format(dt.toDate());\n+        assertEquals(expect, f.withLocale(US).print(dt));\n+        expect = DateFormat.getDateTimeInstance(DateFormat.SHORT, DateFormat.LONG, FRANCE).format(dt.toDate());\n+        assertEquals(expect, f.withLocale(FRANCE).print(dt));\n+    }\n+\n+    public void testForStyle_shortFullDateTime() throws Exception {\n+        DateTimeFormatter f = DateTimeFormat.forStyle(\"SF\");\n+        DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 0);\n+        String expect = DateFormat.getDateTimeInstance(DateFormat.SHORT, DateFormat.FULL, UK).format(dt.toDate());\n+        assertEquals(expect, f.print(dt));\n+        expect = DateFormat.getDateTimeInstance(DateFormat.SHORT, DateFormat.FULL, US).format(dt.toDate());\n+        assertEquals(expect, f.withLocale(US).print(dt));\n+        expect = DateFormat.getDateTimeInstance(DateFormat.SHORT, DateFormat.FULL, FRANCE).format(dt.toDate());\n+        assertEquals(expect, f.withLocale(FRANCE).print(dt));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testForStyle_mediumShortDateTime() throws Exception {\n+        DateTimeFormatter f = DateTimeFormat.forStyle(\"MS\");\n+        DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 0);\n+        String expect = DateFormat.getDateTimeInstance(DateFormat.MEDIUM, DateFormat.SHORT, UK).format(dt.toDate());\n+        assertEquals(expect, f.print(dt));\n+        expect = DateFormat.getDateTimeInstance(DateFormat.MEDIUM, DateFormat.SHORT, US).format(dt.toDate());\n+        assertEquals(expect, f.withLocale(US).print(dt));\n+        expect = DateFormat.getDateTimeInstance(DateFormat.MEDIUM, DateFormat.SHORT, FRANCE).format(dt.toDate());\n+        assertEquals(expect, f.withLocale(FRANCE).print(dt));\n+    }\n+\n+    public void testForStyle_mediumLongDateTime() throws Exception {\n+        DateTimeFormatter f = DateTimeFormat.forStyle(\"ML\");\n+        DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 0);\n+        String expect = DateFormat.getDateTimeInstance(DateFormat.MEDIUM, DateFormat.LONG, UK).format(dt.toDate());\n+        assertEquals(expect, f.print(dt));\n+        expect = DateFormat.getDateTimeInstance(DateFormat.MEDIUM, DateFormat.LONG, US).format(dt.toDate());\n+        assertEquals(expect, f.withLocale(US).print(dt));\n+        expect = DateFormat.getDateTimeInstance(DateFormat.MEDIUM, DateFormat.LONG, FRANCE).format(dt.toDate());\n+        assertEquals(expect, f.withLocale(FRANCE).print(dt));\n+    }\n+\n+    public void testForStyle_mediumFullDateTime() throws Exception {\n+        DateTimeFormatter f = DateTimeFormat.forStyle(\"MF\");\n+        DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 0);\n+        String expect = DateFormat.getDateTimeInstance(DateFormat.MEDIUM, DateFormat.FULL, UK).format(dt.toDate());\n+        assertEquals(expect, f.print(dt));\n+        expect = DateFormat.getDateTimeInstance(DateFormat.MEDIUM, DateFormat.FULL, US).format(dt.toDate());\n+        assertEquals(expect, f.withLocale(US).print(dt));\n+        expect = DateFormat.getDateTimeInstance(DateFormat.MEDIUM, DateFormat.FULL, FRANCE).format(dt.toDate());\n+        assertEquals(expect, f.withLocale(FRANCE).print(dt));\n+    }\n+\n+}\n--- a/JodaTime/src/test/org/joda/time/format/TestDateTimeFormatter.java\n+++ b/JodaTime/src/test/org/joda/time/format/TestDateTimeFormatter.java\n         assertNotNull(f2.print(0L));\n         try {\n             f2.parseDateTime(\"Thu 1970-01-01T00:00:00Z\");\n+            fail();\n         } catch (UnsupportedOperationException ex) {}\n         \n         f2 = new DateTimeFormatter(null, f.getParser());\n         assertEquals(true, f2.isParser());\n         try {\n             f2.print(0L);\n+            fail();\n         } catch (UnsupportedOperationException ex) {}\n         assertNotNull(f2.parseDateTime(\"Thu 1970-01-01T00:00:00Z\"));\n     }\n         \n         try {\n             g.parseDateTime(\"ABC\");\n+            fail();\n         } catch (IllegalArgumentException ex) {}\n     }\n \n         \n         try {\n             g.parseMutableDateTime(\"ABC\");\n+            fail();\n         } catch (IllegalArgumentException ex) {}\n     }\n \n         \n         try {\n             g.parseInto(null, \"2004-06-09T10:20:30Z\", 0);\n+            fail();\n         } catch (IllegalArgumentException ex) {}\n-        try {\n-            g.parseInto(result, \"ABC\", 0);\n-        } catch (IllegalArgumentException ex) {}\n+        \n+        assertEquals(~0, g.parseInto(result, \"ABC\", 0));\n+        assertEquals(~10, g.parseInto(result, \"2004-06-09\", 0));\n+        assertEquals(~13, g.parseInto(result, \"XX2004-06-09T\", 2));\n     }\n \n     public void testParseInto_zone() {", "timestamp": 1108314756, "metainfo": ""}