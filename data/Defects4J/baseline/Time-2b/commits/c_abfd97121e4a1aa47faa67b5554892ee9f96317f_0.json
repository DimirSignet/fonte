{"sha": "abfd97121e4a1aa47faa67b5554892ee9f96317f", "log": "Support mutable forms.   ", "commit": "\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/MutableDateOnly.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-04 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time;\n+\n+import java.io.Serializable;\n+\n+import org.joda.time.chrono.iso.ISOChronology;\n+import org.joda.time.convert.ConverterManager;\n+import org.joda.time.convert.DurationConverter;\n+import org.joda.time.format.ISODateTimeFormat;\n+import org.joda.time.property.MutableDateTimeFieldProperty;\n+\n+/**\n+ * MutableDateOnly is the basic implementation of a modifiable date only class.\n+ * It holds the date as milliseconds from the Java epoch of 1970-01-01. The\n+ * time component and time zone is fixed at T00:00:00Z.\n+ * <p>\n+ * This class uses a Chronology internally. The Chronology determines how the\n+ * millisecond instant value is converted into the date time fields.\n+ * The default Chronology is <code>ISOChronology</code> which is the agreed\n+ * international standard and compatable with the modern Gregorian calendar.\n+ *\n+ * <p>\n+ * Each individual field can be accessed in two ways:\n+ * <ul>\n+ * <li><code>getYear()</code>\n+ * <li><code>year().get()</code>\n+ * </ul>\n+ * The second technique also provides access to other useful methods on the\n+ * field:\n+ * <ul>\n+ * <li>get numeric value\n+ * <li>set numeric value\n+ * <li>add to numeric value\n+ * <li>add to numeric value wrapping with the field\n+ * <li>get text vlaue\n+ * <li>get short text value\n+ * <li>set text value\n+ * <li>field maximum value\n+ * <li>field minimum value\n+ * </ul>\n+ *\n+ * <p>\n+ * MutableDateOnly is mutable and not thread-safe, unless concurrent threads\n+ * are not invoking mutator methods.\n+ *\n+ * @author Brian S O'Neill\n+ * @since 1.0\n+ * @see DateOnly\n+ */\n+public class MutableDateOnly extends AbstractPartialInstant\n+    implements ReadWritableInstant, Cloneable, Serializable {\n+\n+    static final long serialVersionUID = 7781405642158513308L;\n+\n+    // Constructors\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructs a MutableDateOnly to the current date in the default time zone.\n+     */\n+    public MutableDateOnly() {\n+        super();\n+    }\n+\n+    /**\n+     * Constructs a MutableDateOnly to the current date in the given time zone.\n+     *\n+     * @param zone  the time zone, null means default zone\n+     */\n+    public MutableDateOnly(DateTimeZone zone) {\n+        super(zone);\n+    }\n+\n+    /**\n+     * Constructs a MutableDateOnly to the current date in the time zone of the given\n+     * chronology.\n+     *\n+     * @param chronology  the chronology, null means ISOChronology in default zone\n+     */\n+    public MutableDateOnly(Chronology chronology) {\n+        super(chronology);\n+    }\n+\n+    /**\n+     * Constructs a MutableDateOnly set to the milliseconds from 1970-01-01T00:00:00Z.\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z\n+     */\n+    public MutableDateOnly(long instant) {\n+        super(instant);\n+    }\n+\n+    /**\n+     * Constructs a MutableDateOnly set to the milliseconds from\n+     * 1970-01-01T00:00:00Z. If the time zone of the given chronology is not\n+     * null or UTC, then the instant is converted to local time.\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z\n+     * @param chronology  the chronology, null means ISOChronology\n+     */\n+    public MutableDateOnly(long instant, Chronology chronology) {\n+        super(instant, chronology);\n+    }\n+\n+    /**\n+     * Constructs an instance from an Object that represents a date.\n+     * <p>\n+     * The recognised object types are defined in {@link ConverterManager} and\n+     * include ReadableInstant, String, Calendar and Date.\n+     *\n+     * @param instant  the datetime object, must not be null\n+     * @throws IllegalArgumentException if the date is null\n+     */\n+    public MutableDateOnly(Object instant) {\n+        super(instant);\n+    }\n+\n+    /**\n+     * Constructs an instance from an Object that represents a date, using the\n+     * specified chronology.\n+     * <p>\n+     * The recognised object types are defined in {@link ConverterManager} and\n+     * include ReadableInstant, String, Calendar and Date.\n+     *\n+     * @param instant  the datetime object, must not be null\n+     * @param chronology  the chronology, must not be null\n+     * @throws IllegalArgumentException if the date or chronology is null\n+     */\n+    public MutableDateOnly(Object instant, Chronology chronology) {\n+        super(instant, chronology);\n+    }\n+\n+    /**\n+     * Constructs an instance from date field values using\n+     * <code>ISOChronology</code>.\n+     *\n+     * @param year  the year\n+     * @param monthOfYear  the month of the year\n+     * @param dayOfMonth  the day of the month\n+     */\n+    public MutableDateOnly(\n+            final int year,\n+            final int monthOfYear,\n+            final int dayOfMonth) {\n+\n+        super(ISOChronology.getInstanceUTC()\n+              .getDateOnlyMillis(year, monthOfYear, dayOfMonth),\n+              ISOChronology.getInstanceUTC());\n+    }\n+\n+    /**\n+     * Constructs an instance from date field values\n+     * using the specified chronology.\n+     * <p>\n+     * If the chronology is null, <code>ISOChronology</code>\n+     * is used.\n+     *\n+     * @param year  the year\n+     * @param monthOfYear  the month of the year\n+     * @param dayOfMonth  the day of the month\n+     * @param chronology  the chronology, null means ISOChronology\n+     */\n+    public MutableDateOnly(\n+            final int year,\n+            final int monthOfYear,\n+            final int dayOfMonth,\n+            Chronology chronology) {\n+\n+        super((chronology == null ? (chronology = ISOChronology.getInstanceUTC()) : chronology)\n+              .getDateOnlyMillis(year, monthOfYear, dayOfMonth),\n+              chronology);\n+    }\n+\n+    /**\n+     * Gets a copy of this instant with different millis.\n+     * <p>\n+     * The returned object will be a new instance of the same implementation type.\n+     * Only the millis will change, the chronology is kept.\n+     *\n+     * @param newMillis  the new millis, from 1970-01-01T00:00:00Z\n+     * @return a copy of this instant with different millis\n+     */\n+    public ReadableInstant toCopy(long newMillis) {\n+        return new MutableDateOnly(newMillis, getChronology());\n+    }\n+    \n+    /**\n+     * Gets a copy of this instant with a different chronology.\n+     * <p>\n+     * The returned object will be a new instance of the same implementation type.\n+     * Only the chronology will change, the millis are kept.\n+     *\n+     * @param newChronology  the new chronology\n+     * @return a copy of this instant with a different chronology\n+     * @throws IllegalArgumentException if the chronology is null\n+     */\n+    public ReadableInstant toCopy(Chronology newChronology) {\n+        if (newChronology == null) {\n+            throw new IllegalArgumentException(\"The Chronology must not be null\");\n+        }\n+        return new MutableDateOnly(getMillis(), newChronology);\n+    }\n+\n+    /**\n+     * Returns the lower limiting field, dayOfYear.\n+     *\n+     * @return dayOfYear field\n+     */\n+    public final DateTimeField getLowerLimit() {\n+        return getChronology().dayOfYear();\n+    }\n+\n+    /**\n+     * Returns the upper limiting field, null.\n+     *\n+     * @return null\n+     */\n+    public final DateTimeField getUpperLimit() {\n+        return null;\n+    }\n+\n+    /**\n+     * Set the value as the number of milliseconds since the epoch,\n+     * 1970-01-01T00:00:00Z.\n+     *\n+     * @param instant  the milliseconds since 1970-01-01T00:00:00Z to set the\n+     * instant to\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public void setMillis(long instant) {\n+        super.setMillis(instant);\n+    }\n+\n+    /**\n+     * Set the value from an Object representing an instant.\n+     * <p>\n+     * The recognised object types are defined in {@link ConverterManager} and\n+     * include ReadableInstant, String, Calendar and Date.\n+     * \n+     * @param instant  an object representing an instant\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public void setMillis(Object instant) {\n+        super.setMillis(instant);\n+    }\n+\n+    /**\n+     * Set the chronology of the instant.\n+     * \n+     * @param chronology  the chronology to use, null means ISOChronology/UTC\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public void setChronology(Chronology chronology) {\n+        super.setChronology(chronology);\n+    }\n+    \n+    /**\n+     * Since time zones are ignored, this method does nothing.\n+     *\n+     * @param zone  ignored\n+     */\n+    public void setDateTimeZone(DateTimeZone zone) {\n+    }\n+\n+    /**\n+     * Since time zones are ignored, this method does nothing.\n+     *\n+     * @param zone  ignored\n+     */\n+    public void moveDateTimeZone(DateTimeZone zone) {\n+    }\n+\n+    // Add\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Add an amount of time to the date.\n+     * \n+     * @param duration  the millis to add\n+     */\n+    public void add(final long duration) {\n+        setMillis(getMillis() + duration);\n+    }\n+\n+    /**\n+     * Add an amount of time to the date.\n+     * \n+     * @param duration  duration to add.\n+     */\n+    public void add(final ReadableDuration duration) {\n+        duration.addInto(this, 1);\n+    }\n+\n+    /**\n+     * Add an amount of time to the date.\n+     * \n+     * @param duration  duration to add.\n+     * @param scalar  direction and amount to add, which may be negative\n+     */\n+    public void add(final ReadableDuration duration, final int scalar) {\n+        duration.addInto(this, scalar);\n+    }\n+\n+    /**\n+     * Add an amount of time to the date.\n+     * <p>\n+     * The recognised object types are defined in {@link ConverterManager} and\n+     * include ReadableDuration, and Long.\n+     * \n+     * @param duration  an object representing a duration\n+     */\n+    public void add(final Object duration) {\n+        if (duration instanceof ReadableDuration) {\n+            add((ReadableDuration) duration, 1);\n+        } else {\n+            DurationConverter converter = ConverterManager.getInstance().getDurationConverter(duration);\n+            add(converter.getDurationMillis(duration));\n+        }\n+    }\n+\n+    // Field based\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Set a value in the specified field.\n+     * This could be used to set a field using a different Chronology.\n+     * For example:\n+     * <pre>\n+     * MutableDateOnly date = new MutableDateOnly();\n+     * date.set(GJChronology.getInstance().year(), 2002);\n+     * </pre>\n+     * \n+     * @param field  the DateTimeField to use\n+     * @param value the value\n+     * @throws NullPointerException if the field is null\n+     */\n+    public void set(final DateTimeField field, final int value) {\n+        setMillis(field.set(getMillis(), value));\n+    }\n+\n+    /**\n+     * Add a value to the specified field.\n+     * This could be used to set a field using a different Chronology.\n+     * For example:\n+     * <pre>\n+     * MutableDateOnly date = new MutableDateOnly();\n+     * date.add(GJChronology.getInstance().year(), 2);\n+     * </pre>\n+     * \n+     * @param field  the DateTimeField to use\n+     * @param value the value\n+     * @throws NullPointerException if the field is null\n+     */\n+    public void add(final DateTimeField field, final int value) {\n+        setMillis(field.add(getMillis(), value));\n+    }\n+\n+    /**\n+     * Add a value to the specified field, wrapping within that field.\n+     * This could be used to set a field using a different Chronology.\n+     * For example:\n+     * <pre>\n+     * MutableDateOnly date = new MutableDateOnly();\n+     * date.addWrapped(GJChronology.getInstance().monthOfYear(), 6);\n+     * </pre>\n+     * \n+     * @param field  the DateTimeField to use\n+     * @param value the value\n+     * @throws NullPointerException if the field is null\n+     */\n+    public void addWrapped(final DateTimeField field, final int value) {\n+        setMillis(field.addWrapped(getMillis(), value));\n+    }\n+\n+    // Date methods\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Set the year to the specified value.\n+     *\n+     * @param year  the year\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public void setYear(final int year) {\n+        setMillis(getChronology().year().set(getMillis(), year));\n+    }\n+\n+    /**\n+     * Add a number of years to the date.\n+     *\n+     * @param years  the years to add\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public void addYears(final int years) {\n+        setMillis(getChronology().years().add(getMillis(), years));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Set the weekyear to the specified value.\n+     *\n+     * @param weekyear  the weekyear\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public void setWeekyear(final int weekyear) {\n+        setMillis(getChronology().weekyear().set(getMillis(), weekyear));\n+    }\n+\n+    /**\n+     * Add a number of weekyears to the date.\n+     *\n+     * @param weekyears  the weekyears to add\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public void addWeekyears(final int weekyears) {\n+        setMillis(getChronology().weekyears().add(getMillis(), weekyears));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Set the month of the year to the specified value.\n+     *\n+     * @param monthOfYear  the month of the year\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public void setMonthOfYear(final int monthOfYear) {\n+        setMillis(getChronology().monthOfYear().set(getMillis(), monthOfYear));\n+    }\n+\n+    /**\n+     * Add a number of months to the date.\n+     *\n+     * @param months  the months to add\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public void addMonths(final int months) {\n+        setMillis(getChronology().months().add(getMillis(), months));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Set the week of weekyear to the specified value.\n+     *\n+     * @param weekOfWeekyear the week of the weekyear\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public void setWeekOfWeekyear(final int weekOfWeekyear) {\n+        setMillis(getChronology().weekOfWeekyear().set(getMillis(), weekOfWeekyear));\n+    }\n+\n+    /**\n+     * Add a number of weeks to the date.\n+     *\n+     * @param weeks  the weeks to add\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public void addWeeks(final int weeks) {\n+        setMillis(getChronology().weeks().add(getMillis(), weeks));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Set the day of year to the specified value.\n+     *\n+     * @param dayOfYear the day of the year\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public void setDayOfYear(final int dayOfYear) {\n+        setMillis(getChronology().dayOfYear().set(getMillis(), dayOfYear));\n+    }\n+\n+    /**\n+     * Set the day of the month to the specified value.\n+     *\n+     * @param dayOfMonth  the day of the month\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public void setDayOfMonth(final int dayOfMonth) {\n+        setMillis(getChronology().dayOfMonth().set(getMillis(), dayOfMonth));\n+    }\n+\n+    /**\n+     * Set the day of week to the specified value.\n+     *\n+     * @param dayOfWeek  the day of the week\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public void setDayOfWeek(final int dayOfWeek) {\n+        setMillis(getChronology().dayOfWeek().set(getMillis(), dayOfWeek));\n+    }\n+\n+    /**\n+     * Add a number of days to the date.\n+     *\n+     * @param days  the days to add\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public void addDays(final int days) {\n+        setMillis(getChronology().days().add(getMillis(), days));\n+    }\n+\n+    // Date field access\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the era field value.\n+     * \n+     * @return the era\n+     */\n+    public final int getEra() {\n+        return getChronology().era().get(getMillis());\n+    }\n+\n+    /**\n+     * Get the year of era field value.\n+     * \n+     * @return the year of era\n+     */\n+    public final int getCenturyOfEra() {\n+        return getChronology().centuryOfEra().get(getMillis());\n+    }\n+\n+    /**\n+     * Get the year of era field value.\n+     * \n+     * @return the year of era\n+     */\n+    public final int getYearOfEra() {\n+        return getChronology().yearOfEra().get(getMillis());\n+    }\n+\n+    /**\n+     * Get the year of century field value.\n+     * \n+     * @return the year of century\n+     */\n+    public final int getYearOfCentury() {\n+        return getChronology().yearOfCentury().get(getMillis());\n+    }\n+\n+    /**\n+     * Get the year field value.\n+     * \n+     * @return the year\n+     */\n+    public final int getYear() {\n+        return getChronology().year().get(getMillis());\n+    }\n+\n+    /**\n+     * Get the weekyear field value.\n+     * \n+     * @return the year of a week based year\n+     */\n+    public final int getWeekyear() {\n+        return getChronology().weekyear().get(getMillis());\n+    }\n+\n+    /**\n+     * Get the month of year field value.\n+     * \n+     * @return the month of year\n+     */\n+    public final int getMonthOfYear() {\n+        return getChronology().monthOfYear().get(getMillis());\n+    }\n+\n+    /**\n+     * Get the week of weekyear field value.\n+     * \n+     * @return the week of a week based year\n+     */\n+    public final int getWeekOfWeekyear() {\n+        return getChronology().weekOfWeekyear().get(getMillis());\n+    }\n+\n+    /**\n+     * Get the day of year field value.\n+     * \n+     * @return the day of year\n+     */\n+    public final int getDayOfYear() {\n+        return getChronology().dayOfYear().get(getMillis());\n+    }\n+\n+    /**\n+     * Get the day of month field value.\n+     * <p>\n+     * The values for the day of month are defined in {@link DateTimeConstants}.\n+     * \n+     * @return the day of month\n+     */\n+    public final int getDayOfMonth() {\n+        return getChronology().dayOfMonth().get(getMillis());\n+    }\n+\n+    /**\n+     * Get the day of week field value.\n+     * <p>\n+     * The values for the day of week are defined in {@link DateTimeConstants}.\n+     * \n+     * @return the day of week\n+     */\n+    public final int getDayOfWeek() {\n+        return getChronology().dayOfWeek().get(getMillis());\n+    }\n+\n+    // Setters\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Set the date from milliseconds.\n+     *\n+     * @param instant  milliseconds from 1970-01-01T00:00:00Z, time part ignored\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public void setDate(final long instant) {\n+        setMillis(instant);\n+    }\n+\n+    /**\n+     * Set the date from an object representing an instant.\n+     * <p>\n+     * The recognised object types are defined in {@link ConverterManager} and\n+     * include ReadableInstant, String, Calendar and Date.\n+     *\n+     * @param instant  an object representing an instant, time part ignored\n+     * @throws IllegalArgumentException if the object is null or invalid\n+     */\n+    public void setDate(final Object instant) {\n+        setMillis(instant);\n+    }\n+\n+    /**\n+     * Set the date from fields.\n+     *\n+     * @param year  the year\n+     * @param monthOfYear  the month of the year\n+     * @param dayOfMonth  the day of the month\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public void setDate(\n+            final int year,\n+            final int monthOfYear,\n+            final int dayOfMonth) {\n+        setMillis(getChronology().getDateOnlyMillis(year, monthOfYear, dayOfMonth));\n+    }\n+\n+    // Properties\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the day of week property.\n+     * <p>\n+     * The values for day of week are defined in {@link DateTimeConstants}.\n+     * \n+     * @return the day of week property\n+     */\n+    public final MutableDateTimeFieldProperty dayOfWeek() {\n+        return new MutableDateTimeFieldProperty(this, getChronology().dayOfWeek());\n+    }\n+\n+    /**\n+     * Get the day of month property.\n+     * \n+     * @return the day of month property\n+     */\n+    public final MutableDateTimeFieldProperty dayOfMonth() {\n+        return new MutableDateTimeFieldProperty(this, getChronology().dayOfMonth());\n+    }\n+\n+    /**\n+     * Get the day of year property.\n+     * \n+     * @return the day of year property\n+     */\n+    public final MutableDateTimeFieldProperty dayOfYear() {\n+        return new MutableDateTimeFieldProperty(this, getChronology().dayOfYear());\n+    }\n+\n+    /**\n+     * Get the week of a week based year property.\n+     * \n+     * @return the week of a week based year property\n+     */\n+    public final MutableDateTimeFieldProperty weekOfWeekyear() {\n+        return new MutableDateTimeFieldProperty(this, getChronology().weekOfWeekyear());\n+    }\n+\n+    /**\n+     * Get the year of a week based year property.\n+     * \n+     * @return the year of a week based year property\n+     */\n+    public final MutableDateTimeFieldProperty weekyear() {\n+        return new MutableDateTimeFieldProperty(this, getChronology().weekyear());\n+    }\n+\n+    /**\n+     * Get the month of year property.\n+     * \n+     * @return the month of year property\n+     */\n+    public final MutableDateTimeFieldProperty monthOfYear() {\n+        return new MutableDateTimeFieldProperty(this, getChronology().monthOfYear());\n+    }\n+\n+    /**\n+     * Get the year property.\n+     * \n+     * @return the year property\n+     */\n+    public final MutableDateTimeFieldProperty year() {\n+        return new MutableDateTimeFieldProperty(this, getChronology().year());\n+    }\n+\n+    /**\n+     * Get the year of era property.\n+     * \n+     * @return the year of era property\n+     */\n+    public final MutableDateTimeFieldProperty yearOfEra() {\n+        return new MutableDateTimeFieldProperty(this, getChronology().yearOfEra());\n+    }\n+\n+    /**\n+     * Get the year of century property.\n+     * \n+     * @return the year of era property\n+     */\n+    public final MutableDateTimeFieldProperty yearOfCentury() {\n+        return new MutableDateTimeFieldProperty(this, getChronology().yearOfCentury());\n+    }\n+\n+    /**\n+     * Get the century of era property.\n+     * \n+     * @return the year of era property\n+     */\n+    public final MutableDateTimeFieldProperty centuryOfEra() {\n+        return new MutableDateTimeFieldProperty(this, getChronology().centuryOfEra());\n+    }\n+\n+    /**\n+     * Get the era property.\n+     * \n+     * @return the era property\n+     */\n+    public final MutableDateTimeFieldProperty era() {\n+        return new MutableDateTimeFieldProperty(this, getChronology().era());\n+    }\n+\n+    // Misc\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Clone this object without having to cast the returned object.\n+     *\n+     * @return a clone of the this object.\n+     */\n+    public MutableDateOnly copy() {\n+        return (MutableDateOnly)clone();\n+    }\n+\n+    /**\n+     * Clone this object.\n+     *\n+     * @return a clone of this object.\n+     */\n+    public Object clone() {\n+        try {\n+            return super.clone();\n+        } catch (CloneNotSupportedException ex) {\n+            throw new InternalError(\"Clone error\");\n+        }\n+    }\n+\n+    // Output\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Output the date in ISO8601 date only format (yyyy-MM-dd).\n+     * \n+     * @return ISO8601 date formatted string\n+     */\n+    public final String toString() {\n+        return ISODateTimeFormat.getInstance(getChronology()).date().print(getMillis());\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/MutableTimeOnly.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-04 Stephen Colebourne.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally\n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time;\n+\n+import java.io.Serializable;\n+\n+import org.joda.time.chrono.iso.ISOChronology;\n+import org.joda.time.convert.ConverterManager;\n+import org.joda.time.convert.DurationConverter;\n+import org.joda.time.format.ISODateTimeFormat;\n+import org.joda.time.property.MutableDateTimeFieldProperty;\n+\n+/**\n+ * MutableTimeOnly is the basic implementation of a modifiable time only class.\n+ * It holds the time as milliseconds from T00:00:00. The date component and\n+ * time zone is fixed at 1970-01-01TZ.\n+ * <p>\n+ * This class uses a Chronology internally. The Chronology determines how the\n+ * millisecond instant value is converted into the date time fields.\n+ * The default Chronology is <code>ISOChronology</code> which is the agreed\n+ * international standard and compatable with the modern Gregorian calendar.\n+ *\n+ * <p>\n+ * Each individual field can be accessed in two ways:\n+ * <ul>\n+ * <li><code>getHourOfDay()</code>\n+ * <li><code>hourOfDay().get()</code>\n+ * </ul>\n+ * The second technique also provides access to other useful methods on the\n+ * field:\n+ * <ul>\n+ * <li>get numeric value\n+ * <li>set numeric value\n+ * <li>add to numeric value\n+ * <li>add to numeric value wrapping with the field\n+ * <li>get text vlaue\n+ * <li>get short text value\n+ * <li>set text value\n+ * <li>field maximum value\n+ * <li>field minimum value\n+ * </ul>\n+ *\n+ * <p>\n+ * MutableTimeOnly is mutable and not thread-safe, unless concurrent threads\n+ * are not invoking mutator methods.\n+ *\n+ * @author Brian S O'Neill\n+ * @since 1.0\n+ * @see TimeOnly\n+ */\n+public class MutableTimeOnly extends AbstractPartialInstant\n+    implements ReadWritableInstant, Cloneable, Serializable {\n+\n+    static final long serialVersionUID = -1438532408790831231L;\n+\n+    // Constructors\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructs a MutableTimeOnly to the current time in the default time zone.\n+     */\n+    public MutableTimeOnly() {\n+        super();\n+    }\n+\n+    /**\n+     * Constructs a MutableTimeOnly to the current time in the given time zone.\n+     *\n+     * @param zone  the time zone, null means default zone\n+     */\n+    public MutableTimeOnly(DateTimeZone zone) {\n+        super(zone);\n+    }\n+\n+    /**\n+     * Constructs a MutableTimeOnly to the current time in the time zone of the given\n+     * chronology.\n+     *\n+     * @param chronology  the chronology, null means ISOChronology in default zone\n+     */\n+    public MutableTimeOnly(Chronology chronology) {\n+        super(chronology);\n+    }\n+\n+    /**\n+     * Constructs a MutableTimeOnly set to the milliseconds from 1970-01-01T00:00:00Z.\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z\n+     */\n+    public MutableTimeOnly(long instant) {\n+        super(instant);\n+    }\n+\n+    /**\n+     * Constructs a MutableTimeOnly set to the milliseconds from\n+     * 1970-01-01T00:00:00Z. If the time zone of the given chronology is not\n+     * null or UTC, then the instant is converted to local time.\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z\n+     * @param chronology  the chronology, null means ISOChronology\n+     */\n+    public MutableTimeOnly(long instant, Chronology chronology) {\n+        super(instant, chronology);\n+    }\n+\n+    /**\n+     * Constructs an instance from an Object that represents a time.\n+     * <p>\n+     * The recognised object types are defined in {@link ConverterManager} and\n+     * include ReadableInstant, String, Calendar and Date.\n+     *\n+     * @param instant  the datetime object, must not be null\n+     * @throws IllegalArgumentException if the date is null\n+     */\n+    public MutableTimeOnly(Object instant) {\n+        super(instant);\n+    }\n+\n+    /**\n+     * Constructs an instance from an Object that represents a time, using the\n+     * specified chronology.\n+     * <p>\n+     * The recognised object types are defined in {@link ConverterManager} and\n+     * include ReadableInstant, String, Calendar and Date.\n+     *\n+     * @param instant  the datetime object, must not be null\n+     * @param chronology  the chronology, must not be null\n+     * @throws IllegalArgumentException if the date or chronology is null\n+     */\n+    public MutableTimeOnly(Object instant, Chronology chronology) {\n+        super(instant, chronology);\n+    }\n+\n+    /**\n+     * Constructs an instance from time field values using\n+     * <code>ISOChronology</code>.\n+     *\n+     * @param hourOfDay  the hour of the day\n+     * @param minuteOfHour  the minute of the hour\n+     * @param secondOfMinute  the second of the minute\n+     * @param millisOfSecond  the millisecond of the second\n+     */\n+    public MutableTimeOnly(\n+            final int hourOfDay,\n+            final int minuteOfHour,\n+            final int secondOfMinute,\n+            final int millisOfSecond) {\n+\n+        super(ISOChronology.getInstanceUTC()\n+              .getTimeOnlyMillis(hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond),\n+              ISOChronology.getInstanceUTC());\n+    }\n+\n+    /**\n+     * Constructs an instance from time field values\n+     * using the specified chronology.\n+     * <p>\n+     * If the chronology is null, <code>ISOChronology</code>\n+     * is used.\n+     *\n+     * @param hourOfDay  the hour of the day\n+     * @param minuteOfHour  the minute of the hour\n+     * @param secondOfMinute  the second of the minute\n+     * @param millisOfSecond  the millisecond of the second\n+     * @param chronology  the chronology, null means ISOChronology\n+     */\n+    public MutableTimeOnly(\n+            final int hourOfDay,\n+            final int minuteOfHour,\n+            final int secondOfMinute,\n+            final int millisOfSecond,\n+            Chronology chronology) {\n+\n+        super((chronology == null ? (chronology = ISOChronology.getInstanceUTC()) : chronology)\n+              .getTimeOnlyMillis(hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond),\n+              chronology);\n+    }\n+\n+    /**\n+     * Gets a copy of this instant with different millis.\n+     * <p>\n+     * The returned object will be a new instance of the same implementation type.\n+     * Only the millis will change, the chronology is kept.\n+     * Immutable subclasses may return <code>this</code> if appropriate.\n+     *\n+     * @param newMillis  the new millis, from 1970-01-01T00:00:00Z\n+     * @return a copy of this instant with different millis\n+     */\n+    public ReadableInstant toCopy(long newMillis) {\n+        return new MutableTimeOnly(newMillis, getChronology());\n+    }\n+    \n+    /**\n+     * Gets a copy of this instant with a different chronology.\n+     * <p>\n+     * The returned object will be a new instance of the same implementation type.\n+     * Only the chronology will change, the millis are kept.\n+     * Immutable subclasses may return <code>this</code> if appropriate.\n+     *\n+     * @param newChronology  the new chronology\n+     * @return a copy of this instant with a different chronology\n+     * @throws IllegalArgumentException if the chronology is null\n+     */\n+    public ReadableInstant toCopy(Chronology newChronology) {\n+        if (newChronology == null) {\n+            throw new IllegalArgumentException(\"The Chronology must not be null\");\n+        }\n+        return new MutableTimeOnly(getMillis(), newChronology);\n+    }\n+\n+    /**\n+     * Returns the lower limiting field, null.\n+     *\n+     * @return null.\n+     */\n+    public final DateTimeField getLowerLimit() {\n+        return null;\n+    }\n+\n+    /**\n+     * Returns the upper limiting field, dayOfYear.\n+     *\n+     * @return dayOfYear field\n+     */\n+    public final DateTimeField getUpperLimit() {\n+        return getChronology().dayOfYear();\n+    }\n+\n+    /**\n+     * Set the value as the number of milliseconds since the epoch,\n+     * 1970-01-01T00:00:00Z.\n+     *\n+     * @param instant  the milliseconds since 1970-01-01T00:00:00Z to set the\n+     * instant to\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public void setMillis(long instant) {\n+        super.setMillis(instant);\n+    }\n+\n+    /**\n+     * Set the value from an Object representing an instant.\n+     * <p>\n+     * The recognised object types are defined in {@link ConverterManager} and\n+     * include ReadableInstant, String, Calendar and Date.\n+     * \n+     * @param instant  an object representing an instant\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public void setMillis(Object instant) {\n+        super.setMillis(instant);\n+    }\n+\n+    /**\n+     * Set the chronology of the instant.\n+     * \n+     * @param chronology  the chronology to use, null means ISOChronology/UTC\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public void setChronology(Chronology chronology) {\n+        super.setChronology(chronology);\n+    }\n+    \n+    /**\n+     * Since time zones are ignored, this method does nothing.\n+     *\n+     * @param zone  ignored\n+     */\n+    public void setDateTimeZone(DateTimeZone zone) {\n+    }\n+\n+    /**\n+     * Since time zones are ignored, this method does nothing.\n+     *\n+     * @param zone  ignored\n+     */\n+    public void moveDateTimeZone(DateTimeZone zone) {\n+    }\n+\n+    // Add\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Add an amount of time to the time.\n+     * \n+     * @param duration  the millis to add\n+     */\n+    public void add(final long duration) {\n+        setMillis(getMillis() + duration);\n+    }\n+\n+    /**\n+     * Add an amount of time to the time.\n+     * \n+     * @param duration  duration to add.\n+     */\n+    public void add(final ReadableDuration duration) {\n+        duration.addInto(this, 1);\n+    }\n+\n+    /**\n+     * Add an amount of time to the time.\n+     * \n+     * @param duration  duration to add.\n+     * @param scalar  direction and amount to add, which may be negative\n+     */\n+    public void add(final ReadableDuration duration, final int scalar) {\n+        duration.addInto(this, scalar);\n+    }\n+\n+    /**\n+     * Add an amount of time to the time.\n+     * <p>\n+     * The recognised object types are defined in {@link ConverterManager} and\n+     * include ReadableDuration, and Long.\n+     * \n+     * @param duration  an object representing a duration\n+     */\n+    public void add(final Object duration) {\n+        if (duration instanceof ReadableDuration) {\n+            add((ReadableDuration) duration, 1);\n+        } else {\n+            DurationConverter converter = ConverterManager.getInstance().getDurationConverter(duration);\n+            add(converter.getDurationMillis(duration));\n+        }\n+    }\n+\n+    // Field based\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Set a value in the specified field.\n+     * This could be used to set a field using a different Chronology.\n+     * For example:\n+     * <pre>\n+     * MutableTimeOnly time = new MutableTimeOnly();\n+     * time.set(GJChronology.getInstance().hourOfDay(), 12);\n+     * </pre>\n+     * \n+     * @param field  the DateTimeField to use\n+     * @param value the value\n+     * @throws NullPointerException if the field is null\n+     */\n+    public void set(final DateTimeField field, final int value) {\n+        setMillis(field.set(getMillis(), value));\n+    }\n+\n+    /**\n+     * Add a value to the specified field.\n+     * This could be used to set a field using a different Chronology.\n+     * For example:\n+     * <pre>\n+     * MutableTimeOnly time = new MutableTimeOnly();\n+     * time.add(GJChronology.getInstance().hourOfDay(), 2);\n+     * </pre>\n+     * \n+     * @param field  the DateTimeField to use\n+     * @param value the value\n+     * @throws NullPointerException if the field is null\n+     */\n+    public void add(final DateTimeField field, final int value) {\n+        setMillis(field.add(getMillis(), value));\n+    }\n+\n+    /**\n+     * Add a value to the specified field, wrapping within that field.\n+     * This could be used to set a field using a different Chronology.\n+     * For example:\n+     * <pre>\n+     * MutableTimeOnly time = new MutableTimeOnly();\n+     * time.addWrapped(GJChronology.getInstance().minuteOfHour(), 30);\n+     * </pre>\n+     * \n+     * @param field  the DateTimeField to use\n+     * @param value the value\n+     * @throws NullPointerException if the field is null\n+     */\n+    public void addWrapped(final DateTimeField field, final int value) {\n+        setMillis(field.addWrapped(getMillis(), value));\n+    }\n+\n+    // Time methods\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Set the hour of the day to the specified value.\n+     *\n+     * @param hourOfDay  the hour of day\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public void setHourOfDay(final int hourOfDay) {\n+        setMillis(getChronology().hourOfDay().set(getMillis(), hourOfDay));\n+    }\n+\n+    /**\n+     * Set the hour of day (offset to 1-24) to the specified value.\n+     * \n+     * @param clockhourOfDay  the clockhour of day\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public void setClockhourOfDay(final int clockhourOfDay) {\n+        setMillis(getChronology().clockhourOfDay().set(getMillis(), clockhourOfDay));\n+    }\n+\n+    /**\n+     * Set the hour of am/pm (0-11) to the specified value.\n+     * \n+     * @param hourOfHalfday  the hour of halfday\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public void setHourOfHalfday(final int hourOfHalfday) {\n+        setMillis(getChronology().hourOfHalfday().set(getMillis(), hourOfHalfday));\n+    }\n+\n+    /**\n+     * Set the hour of am/pm (offset to 1-12) to the specified value.\n+     * \n+     * @param clockhourOfHalfday  the clockhour of halfday\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public void setClockhourOfHalfday(final int clockhourOfHalfday) {\n+        setMillis(getChronology().clockhourOfHalfday().set(getMillis(), clockhourOfHalfday));\n+    }\n+\n+    /**\n+     * Set the AM(0) PM(1) field value.\n+     * \n+     * @param halfdayOfDay  the halfday of day\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public void setHalfdayOfDay(final int halfdayOfDay) {\n+        setMillis(getChronology().halfdayOfDay().set(getMillis(), halfdayOfDay));\n+    }\n+\n+    /**\n+     * Add a number of hours to the date.\n+     *\n+     * @param hours  the hours to add\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public void addHours(final int hours) {\n+        setMillis(getChronology().hours().add(getMillis(), hours));\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Set the minute of the day to the specified value.\n+     *\n+     * @param minuteOfDay  the minute of day\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public void setMinuteOfDay(final int minuteOfDay) {\n+        setMillis(getChronology().minuteOfDay().set(getMillis(), minuteOfDay));\n+    }\n+\n+    /**\n+     * Set the minute of the hour to the specified value.\n+     *\n+     * @param minuteOfHour  the minute of hour\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public void setMinuteOfHour(final int minuteOfHour) {\n+        setMillis(getChronology().minuteOfHour().set(getMillis(), minuteOfHour));\n+    }\n+\n+    /**\n+     * Add a number of minutes to the date.\n+     *\n+     * @param minutes  the minutes to add\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public void addMinutes(final int minutes) {\n+        setMillis(getChronology().minutes().add(getMillis(), minutes));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Set the second of the day to the specified value.\n+     *\n+     * @param secondOfDay  the second of day\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public void setSecondOfDay(final int secondOfDay) {\n+        setMillis(getChronology().secondOfDay().set(getMillis(), secondOfDay));\n+    }\n+\n+    /**\n+     * Set the second of the minute to the specified value.\n+     *\n+     * @param secondOfMinute  the second of minute\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public void setSecondOfMinute(final int secondOfMinute) {\n+        setMillis(getChronology().secondOfMinute().set(getMillis(), secondOfMinute));\n+    }\n+\n+    /**\n+     * Add a number of seconds to the date.\n+     *\n+     * @param seconds  the seconds to add\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public void addSeconds(final int seconds) {\n+        setMillis(getChronology().seconds().add(getMillis(), seconds));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Set the millis of the day to the specified value.\n+     *\n+     * @param millisOfDay  the millis of day\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public void setMillisOfDay(final int millisOfDay) {\n+        setMillis(getChronology().millisOfDay().set(getMillis(), millisOfDay));\n+    }\n+\n+    /**\n+     * Set the millis of the second to the specified value.\n+     *\n+     * @param millisOfSecond  the millis of second\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public void setMillisOfSecond(final int millisOfSecond) {\n+        setMillis(getChronology().millisOfSecond().set(getMillis(), millisOfSecond));\n+    }\n+\n+    /**\n+     * Add a number of milliseconds to the date. The implementation of this\n+     * method differs from the {@link #add(long)} method in that a\n+     * DateTimeField performs the addition.\n+     *\n+     * @param millis  the milliseconds to add\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public void addMillis(final int millis) {\n+        setMillis(getChronology().millis().add(getMillis(), millis));\n+    }\n+\n+    // Time field access\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the hour of day (0-23) field value.\n+     *\n+     * @return the hour of day\n+     */\n+    public final int getHourOfDay() {\n+        return getChronology().hourOfDay().get(getMillis());\n+    }\n+\n+    /**\n+     * Get the hour of day (offset to 1-24) field value.\n+     * \n+     * @return the clockhour of day\n+     */\n+    public final int getClockhourOfDay() {\n+        return getChronology().clockhourOfDay().get(getMillis());\n+    }\n+\n+    /**\n+     * Get the hour of am/pm (0-11) field value.\n+     * \n+     * @return the hour of halfday\n+     */\n+    public final int getHourOfHalfday() {\n+        return getChronology().hourOfHalfday().get(getMillis());\n+    }\n+\n+    /**\n+     * Get the hour of am/pm (offset to 1-12) field value.\n+     * \n+     * @return the clockhour of halfday\n+     */\n+    public final int getClockhourOfHalfday() {\n+        return getChronology().clockhourOfHalfday().get(getMillis());\n+    }\n+\n+    /**\n+     * Get the AM(0) PM(1) field value.\n+     * \n+     * @return the halfday of day\n+     */\n+    public final int getHalfdayOfDay() {\n+        return getChronology().halfdayOfDay().get(getMillis());\n+    }\n+\n+    /**\n+     * Get the minute of day field value.\n+     *\n+     * @return the minute of day\n+     */\n+    public final int getMinuteOfDay() {\n+        return getChronology().minuteOfDay().get(getMillis());\n+    }\n+\n+    /**\n+     * Get the minute of hour field value.\n+     *\n+     * @return the minute of hour\n+     */\n+    public final int getMinuteOfHour() {\n+        return getChronology().minuteOfHour().get(getMillis());\n+    }\n+\n+    /**\n+     * Get the second of day field value.\n+     *\n+     * @return the second of day\n+     */\n+    public final int getSecondOfDay() {\n+        return getChronology().secondOfDay().get(getMillis());\n+    }\n+\n+    /**\n+     * Get the second of minute field value.\n+     *\n+     * @return the second of minute\n+     */\n+    public final int getSecondOfMinute() {\n+        return getChronology().secondOfMinute().get(getMillis());\n+    }\n+\n+    /**\n+     * Get the millis of day field value.\n+     *\n+     * @return the millis of day\n+     */\n+    public final int getMillisOfDay() {\n+        return getChronology().millisOfDay().get(getMillis());\n+    }\n+\n+    /**\n+     * Get the millis of second field value.\n+     *\n+     * @return the millis of second\n+     */\n+    public final int getMillisOfSecond() {\n+        return getChronology().millisOfSecond().get(getMillis());\n+    }\n+\n+    // Setters\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Set the time from milliseconds.\n+     *\n+     * @param millis milliseconds from T00:00:00Z, date part ignored\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public void setTime(final long millis) {\n+        setMillis(millis);\n+    }\n+\n+    /**\n+     * Set the date from an object representing an instant.\n+     * <p>\n+     * The recognised object types are defined in {@link ConverterManager} and\n+     * include ReadableInstant, String, Calendar and Date.\n+     *\n+     * @param instant  an object representing an instant, date part ignored\n+     * @throws IllegalArgumentException if the object is null or invalid\n+     */\n+    public void setTime(final Object instant) {\n+        setMillis(instant);\n+    }\n+\n+    /**\n+     * Set the time from fields.\n+     *\n+     * @param hour  the hour\n+     * @param minuteOfHour  the minute of the hour\n+     * @param secondOfMinute  the second of the minute\n+     * @param millisOfSecond  the millisecond of the second\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public void setTime(\n+            final int hour,\n+            final int minuteOfHour,\n+            final int secondOfMinute,\n+            final int millisOfSecond) {\n+        setMillis(getChronology().getTimeOnlyMillis(hour, minuteOfHour, secondOfMinute, millisOfSecond));\n+    }\n+\n+    // Properties\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the hour of day (0-23) field property\n+     * \n+     * @return the hour of day property\n+     */\n+    public final MutableDateTimeFieldProperty hourOfDay() {\n+        return new MutableDateTimeFieldProperty(this, getChronology().hourOfDay());\n+    }\n+\n+    /**\n+     * Get the hour of day (offset to 1-24) field property\n+     * \n+     * @return the clockhour of day property\n+     */\n+    public final MutableDateTimeFieldProperty clockhourOfDay() {\n+        return new MutableDateTimeFieldProperty(this, getChronology().clockhourOfDay());\n+    }\n+\n+    /**\n+     * Get the hour of am/pm (0-11) field property\n+     * \n+     * @return the hour of halfday property\n+     */\n+    public final MutableDateTimeFieldProperty hourOfHalfday() {\n+        return new MutableDateTimeFieldProperty(this, getChronology().hourOfHalfday());\n+    }\n+\n+    /**\n+     * Get the hour of am/pm (offset to 1-12) field property\n+     * \n+     * @return the clockhour of halfday property\n+     */\n+    public final MutableDateTimeFieldProperty clockhourOfHalfday() {\n+        return new MutableDateTimeFieldProperty(this, getChronology().clockhourOfHalfday());\n+    }\n+\n+    /**\n+     * Get the AM(0) PM(1) field property\n+     * \n+     * @return the halfday of day property\n+     */\n+    public final MutableDateTimeFieldProperty halfdayOfDay() {\n+        return new MutableDateTimeFieldProperty(this, getChronology().halfdayOfDay());\n+    }\n+\n+    /**\n+     * Get the minute of day property\n+     * \n+     * @return the minute of day property\n+     */\n+    public final MutableDateTimeFieldProperty minuteOfDay() {\n+        return new MutableDateTimeFieldProperty(this, getChronology().minuteOfDay());\n+    }\n+\n+    /**\n+     * Get the minute of hour field property\n+     * \n+     * @return the minute of hour property\n+     */\n+    public final MutableDateTimeFieldProperty minuteOfHour() {\n+        return new MutableDateTimeFieldProperty(this, getChronology().minuteOfHour());\n+    }\n+\n+    /**\n+     * Get the second of day property\n+     * \n+     * @return the second of day property\n+     */\n+    public final MutableDateTimeFieldProperty secondOfDay() {\n+        return new MutableDateTimeFieldProperty(this, getChronology().secondOfDay());\n+    }\n+\n+    /**\n+     * Get the second of minute field property\n+     * \n+     * @return the second of minute property\n+     */\n+    public final MutableDateTimeFieldProperty secondOfMinute() {\n+        return new MutableDateTimeFieldProperty(this, getChronology().secondOfMinute());\n+    }\n+\n+    /**\n+     * Get the millis of day property\n+     * \n+     * @return the millis of day property\n+     */\n+    public final MutableDateTimeFieldProperty millisOfDay() {\n+        return new MutableDateTimeFieldProperty(this, getChronology().millisOfDay());\n+    }\n+\n+    /**\n+     * Get the millis of second property\n+     * \n+     * @return the millis of second property\n+     */\n+    public final MutableDateTimeFieldProperty millisOfSecond() {\n+        return new MutableDateTimeFieldProperty(this, getChronology().millisOfSecond());\n+    }\n+\n+    // Misc\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Clone this object without having to cast the returned object.\n+     *\n+     * @return a clone of the this object.\n+     */\n+    public MutableTimeOnly copy() {\n+        return (MutableTimeOnly)clone();\n+    }\n+\n+    /**\n+     * Clone this object.\n+     *\n+     * @return a clone of this object.\n+     */\n+    public Object clone() {\n+        try {\n+            return super.clone();\n+        } catch (CloneNotSupportedException ex) {\n+            throw new InternalError(\"Clone error\");\n+        }\n+    }\n+\n+    // Output\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Output the time in ISO8601 date only format (hh:mm:ss.SSS).\n+     * \n+     * @return ISO8601 date formatted string\n+     */\n+    public final String toString() {\n+        return ISODateTimeFormat.getInstance(getChronology())\n+            .hourMinuteSecondFraction().print(getMillis());\n+    }\n+\n+}", "timestamp": 1073096779, "metainfo": ""}