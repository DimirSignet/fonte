{"sha": "a14ace7f3ca5c8b9dba675d99db1b253eb7004c4", "log": "Fix Date and Calendar conversion (tests) on JDK1.3   ", "commit": "\n--- a/JodaTime/src/java/org/joda/time/TimeOfDay.java\n+++ b/JodaTime/src/java/org/joda/time/TimeOfDay.java\n      * The string format must begin with a 'T' to be recognised, such as 'T10:20'.\n      * <p>\n      * The chronology used will be derived from the object, defaulting to ISO.\n+     * <p>\n+     * Note that as from version 1.2, the default converters go to extra\n+     * effort to maintain the field values of the input Date or Calendar.\n+     * This means that the differences in timezone data between Joda-Time\n+     * and each JDK version are now handled correctly. If you just want to\n+     * use the milliseconds value without conversion you must use\n+     * {@link #TimeOfDay(long, Chronology)}.\n      *\n      * @param instant  the datetime object, null means now\n      * @throws IllegalArgumentException if the instant is invalid\n      * Once the constructor is complete, all further calculations are performed\n      * without reference to a timezone (by switching to UTC).\n      * The specified chronology overrides that of the object.\n+     * <p>\n+     * Note that as from version 1.2, the default converters go to extra\n+     * effort to maintain the field values of the input Date or Calendar.\n+     * This means that the differences in timezone data between Joda-Time\n+     * and each JDK version are now handled correctly. If you just want to\n+     * use the milliseconds value without conversion you must use\n+     * {@link #TimeOfDay(long, Chronology)}.\n      *\n      * @param instant  the datetime object, null means now\n      * @param chronology  the chronology, null means ISO default\n--- a/JodaTime/src/java/org/joda/time/base/AbstractDateTime.java\n+++ b/JodaTime/src/java/org/joda/time/base/AbstractDateTime.java\n     //-----------------------------------------------------------------------\n     /**\n      * Get the date time as a <code>java.util.Date</code>.\n-     * \n+     * <p>\n+     * Note that as from version 1.2, this method goes to extra effort to\n+     * maintain the field values on the created Date object.\n+     * This means that the differences in timezone data between Joda-Time\n+     * and each JDK version are now handled correctly.\n+     *\n      * @return a Date initialised with this datetime\n      */\n     public Date toDate() {\n      * Get the date time as a <code>java.util.Calendar</code>.\n      * The locale is passed in, enabling Calendar to select the correct\n      * localized subclass.\n+     * <p>\n+     * Note that as from version 1.2, this method goes to extra effort to\n+     * maintain the field values on the created Calendar object.\n+     * This means that the differences in timezone data between Joda-Time\n+     * and each JDK version are now handled correctly.\n      * \n      * @param locale  the locale to get the Calendar for, or default if null\n      * @return a localized Calendar initialised with this datetime\n \n     /**\n      * Get the date time as a <code>java.util.GregorianCalendar</code>.\n-     * \n+     * <p>\n+     * Note that as from version 1.2, this method goes to extra effort to\n+     * maintain the field values on the created Calendar object.\n+     * This means that the differences in timezone data between Joda-Time\n+     * and each JDK version are now handled correctly.\n+     *\n      * @return a GregorianCalendar initialised with this datetime\n      */\n     public GregorianCalendar toGregorianCalendar() {\n--- a/JodaTime/src/java/org/joda/time/base/BasePartial.java\n+++ b/JodaTime/src/java/org/joda/time/base/BasePartial.java\n      * The constructor uses the time zone of the chronology specified.\n      * Once the constructor is complete, all further calculations are performed\n      * without reference to a timezone (by switching to UTC).\n+     * <p>\n+     * Note that as from version 1.2, the default converters go to extra\n+     * effort to maintain the field values of the input Date or Calendar.\n+     * This means that the differences in timezone data between Joda-Time\n+     * and each JDK version are now handled correctly.\n      *\n      * @param instant  the datetime object\n      * @param chronology  the chronology, null means use converter\n--- a/JodaTime/src/test/org/joda/time/TestTimeOfDay_Constructors.java\n+++ b/JodaTime/src/test/org/joda/time/TestTimeOfDay_Constructors.java\n  */\n package org.joda.time;\n \n+import java.util.Calendar;\n import java.util.Date;\n+import java.util.GregorianCalendar;\n \n import junit.framework.TestCase;\n import junit.framework.TestSuite;\n \n import org.joda.time.chrono.CopticChronology;\n+import org.joda.time.chrono.GJChronology;\n import org.joda.time.chrono.ISOChronology;\n import org.joda.time.chrono.JulianChronology;\n \n     /**\n      * Test constructor (Object)\n      */\n-    public void testConstructor_Object() throws Throwable {\n+    public void testConstructor_Object1() throws Throwable {\n         Date date = new Date(TEST_TIME1);\n         TimeOfDay test = new TimeOfDay(date);\n         assertEquals(ISO_UTC, test.getChronology());\n-        assertEquals(1 + OFFSET, test.getHourOfDay());\n+        // JDK1.3 has no historical time zone, so hour differs from JDK1.4\n+        // This method is now defined to copy the fields from the Date\n+        assertEquals(date.getHours(), test.getHourOfDay());\n+        assertEquals(2, test.getMinuteOfHour());\n+        assertEquals(3, test.getSecondOfMinute());\n+        assertEquals(4, test.getMillisOfSecond());\n+    }\n+\n+    /**\n+     * Test constructor (Object)\n+     */\n+    public void testConstructor_Object2() throws Throwable {\n+        Calendar cal = new GregorianCalendar();\n+        cal.setTime(new Date(TEST_TIME1));\n+        TimeOfDay test = new TimeOfDay(cal);\n+        assertEquals(GJChronology.getInstanceUTC(), test.getChronology());\n+        // JDK1.3 has no historical time zone, so hour differs from JDK1.4\n+        // This method is now defined to copy the fields from the Date\n+        assertEquals(cal.get(Calendar.HOUR_OF_DAY), test.getHourOfDay());\n         assertEquals(2, test.getMinuteOfHour());\n         assertEquals(3, test.getSecondOfMinute());\n         assertEquals(4, test.getMillisOfSecond());\n         Date date = new Date(TEST_TIME1);\n         TimeOfDay test = new TimeOfDay(date, JulianChronology.getInstance());\n         assertEquals(JulianChronology.getInstanceUTC(), test.getChronology());\n-        assertEquals(1 + OFFSET, test.getHourOfDay());\n+        // JDK1.3 has no historical time zone, so hour differs from JDK1.4\n+        // This method is now defined to copy the fields from the Date\n+        assertEquals(date.getHours(), test.getHourOfDay());\n         assertEquals(2, test.getMinuteOfHour());\n         assertEquals(3, test.getSecondOfMinute());\n         assertEquals(4, test.getMillisOfSecond());\n         Date date = new Date(TEST_TIME1);\n         TimeOfDay test = new TimeOfDay(date, null);\n         assertEquals(ISO_UTC, test.getChronology());\n-        assertEquals(1 + OFFSET, test.getHourOfDay());\n+        // JDK1.3 has no historical time zone, so hour differs from JDK1.4\n+        // This method is now defined to copy the fields from the Date\n+        assertEquals(date.getHours(), test.getHourOfDay());\n         assertEquals(2, test.getMinuteOfHour());\n         assertEquals(3, test.getSecondOfMinute());\n         assertEquals(4, test.getMillisOfSecond());\n--- a/JodaTime/src/test/org/joda/time/convert/TestCalendarConverter.java\n+++ b/JodaTime/src/test/org/joda/time/convert/TestCalendarConverter.java\n import junit.framework.TestSuite;\n \n import org.joda.time.Chronology;\n+import org.joda.time.DateTime;\n import org.joda.time.DateTimeZone;\n import org.joda.time.TimeOfDay;\n import org.joda.time.chrono.BuddhistChronology;\n     public void testGetInstantMillis_Object_Chronology() throws Exception {\n         GregorianCalendar cal = new GregorianCalendar();\n         cal.setTime(new Date(123L));\n-        assertEquals(123L, CalendarConverter.INSTANCE.getInstantMillis(cal, JULIAN));\n+        long millis = CalendarConverter.INSTANCE.getInstantMillis(cal, JULIAN);\n+        long expected = 123L + cal.get(Calendar.DST_OFFSET) + cal.get(Calendar.ZONE_OFFSET);\n+        expected = expected - DateTimeZone.getDefault().getOffsetFromLocal(expected);\n+        assertEquals(expected, millis);\n+        assertEquals(cal.get(Calendar.DAY_OF_MONTH), new DateTime(millis).getDayOfMonth());\n+        assertEquals(cal.get(Calendar.HOUR_OF_DAY), new DateTime(millis).getHourOfDay());\n+        assertEquals(cal.get(Calendar.MINUTE), new DateTime(millis).getMinuteOfHour());\n+        \n         assertEquals(123L, cal.getTime().getTime());\n     }\n \n     //-----------------------------------------------------------------------\n     public void testGetPartialValues() throws Exception {\n         GregorianCalendar cal = new GregorianCalendar();\n-        cal.setTime(new Date(12345678L));\n+        cal.setTime(new Date(70, 2, 3, 4, 5, 6));\n         TimeOfDay tod = new TimeOfDay();\n-        int[] expected = ISOChronology.getInstance().get(tod, 12345678L);\n+        int[] expected = new int[] {4, 5, 6, 0};\n         int[] actual = CalendarConverter.INSTANCE.getPartialValues(tod, cal, ISOChronology.getInstance());\n         assertEquals(true, Arrays.equals(expected, actual));\n     }\n--- a/JodaTime/src/test/org/joda/time/convert/TestDateConverter.java\n+++ b/JodaTime/src/test/org/joda/time/convert/TestDateConverter.java\n import java.lang.reflect.Modifier;\n import java.util.Arrays;\n import java.util.Date;\n+import java.util.GregorianCalendar;\n \n import junit.framework.TestCase;\n import junit.framework.TestSuite;\n \n import org.joda.time.Chronology;\n+import org.joda.time.DateTime;\n import org.joda.time.DateTimeZone;\n import org.joda.time.TimeOfDay;\n import org.joda.time.chrono.CopticChronology;\n \n     //-----------------------------------------------------------------------\n     public void testGetInstantMillis_Object_Chronology() throws Exception {\n-        assertEquals(123L, DateConverter.INSTANCE.getInstantMillis(new Date(123L), JULIAN));\n-        assertEquals(123L, DateConverter.INSTANCE.getInstantMillis(new Date(123L), (Chronology) null));\n+        Date date = new Date(123L);\n+        long millis = DateConverter.INSTANCE.getInstantMillis(date, JULIAN);\n+        long expected = 123L - date.getTimezoneOffset() * 60000;\n+        expected = expected - DateTimeZone.getDefault().getOffsetFromLocal(expected);\n+        assertEquals(expected, millis);\n+        assertEquals(date.getDate(), new DateTime(millis).getDayOfMonth());\n+        assertEquals(date.getHours(), new DateTime(millis).getHourOfDay());\n+        assertEquals(date.getMinutes(), new DateTime(millis).getMinuteOfHour());\n+        \n+        assertEquals(expected, DateConverter.INSTANCE.getInstantMillis(date, (Chronology) null));\n     }\n \n     //-----------------------------------------------------------------------\n \n     //-----------------------------------------------------------------------\n     public void testGetPartialValues() throws Exception {\n+        Date date = new Date(70, 2, 3, 4, 5, 6);\n         TimeOfDay tod = new TimeOfDay();\n-        int[] expected = CopticChronology.getInstance().get(tod, 12345678L);\n-        int[] actual = DateConverter.INSTANCE.getPartialValues(tod, new Date(12345678L), CopticChronology.getInstance());\n+        int[] expected = new int[] {4, 5, 6, 0};\n+        int[] actual = DateConverter.INSTANCE.getPartialValues(tod, date, ISOChronology.getInstance());\n         assertEquals(true, Arrays.equals(expected, actual));\n     }\n ", "timestamp": 1133479521, "metainfo": ""}