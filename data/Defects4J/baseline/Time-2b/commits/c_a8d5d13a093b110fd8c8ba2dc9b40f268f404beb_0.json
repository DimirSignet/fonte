{"sha": "a8d5d13a093b110fd8c8ba2dc9b40f268f404beb", "log": "Merge branch 'master' of https://github.com/codematters/joda-time into codematters-master", "commit": "\n--- a/src/main/java/org/joda/time/LocalDateTime.java\n+++ b/src/main/java/org/joda/time/LocalDateTime.java\n         Date date = new Date(getYear() - 1900, getMonthOfYear() - 1, dom,\n                         getHourOfDay(), getMinuteOfHour(), getSecondOfMinute());\n         date.setTime(date.getTime() + getMillisOfSecond());\n-        LocalDateTime check = LocalDateTime.fromDateFields(date);\n-        if (check.isBefore(this)) {\n-            // DST gap\n-            // move forward in units of one minute until equal/after\n-            while (check.isBefore(this)) {\n-                date.setTime(date.getTime() + 60000);\n-                check = LocalDateTime.fromDateFields(date);\n-            }\n-            // move back in units of one second until date wrong\n-            while (check.isBefore(this) == false) {\n-                date.setTime(date.getTime() - 1000);\n-                check = LocalDateTime.fromDateFields(date);\n-            }\n-            date.setTime(date.getTime() + 1000);\n-        } else if (check.equals(this)) {\n-            // check for DST overlap\n-            Date earlier = new Date(date.getTime() - TimeZone.getDefault().getDSTSavings());\n-            check = LocalDateTime.fromDateFields(earlier);\n-            if (check.equals(this)) {\n-                date = earlier;\n-            }\n-        }\n-        return date;\n+\n+        return correctDstTransition(date, TimeZone.getDefault());\n+    }\n+\n+    /**\n+     * Get the date time as a <code>java.util.Date</code> using the specified time zone.\n+     * <p>\n+     * The <code>Date</code> object created has exactly the same fields as this\n+     * date-time, except when the time would be invalid due to a daylight savings\n+     * gap. In that case, the time will be set to the earliest valid time after the gap.\n+     * <p>\n+     * In the case of a daylight savings overlap, the earlier instant is selected.\n+     * <p>\n+     * Converting to a JDK Date is full of complications as the JDK Date constructor\n+     * doesn't behave as you might expect around DST transitions. This method works\n+     * by taking a first guess and then adjusting. This also handles the situation\n+     * where the JDK time zone data differs from the Joda-Time time zone data.\n+     * <p>\n+     * Unlike {@link #toDate()}, this implementation does not rely on Java's synchronized\n+     * time zone initialization logic, and should demonstrate better concurrent performance\n+     * characteristics.\n+     *\n+     * @return a Date initialised with this date-time, never null\n+     * @since 2.0\n+     */\n+    public Date toDate(final TimeZone timeZone) {\n+\tfinal Calendar calendar = Calendar.getInstance(timeZone);\n+\tcalendar.clear();\n+\tcalendar.set(getYear(), getMonthOfYear() - 1, getDayOfMonth(),\n+\t\tgetHourOfDay(), getMinuteOfHour(), getSecondOfMinute());\n+\tDate date = calendar.getTime();\n+\tdate.setTime(date.getTime() + getMillisOfSecond());\n+\n+\treturn correctDstTransition(date, timeZone);\n+    }\n+\n+\n+    /**\n+     * Correct <code>date</code> in case of DST overlap.\n+     * <p>\n+     * The <code>Date</code> object created has exactly the same fields as this\n+     * date-time, except when the time would be invalid due to a daylight savings\n+     * gap. In that case, the time will be set to the earliest valid time after the gap.\n+     * <p>\n+     * In the case of a daylight savings overlap, the earlier instant is selected.\n+     * <p>\n+     * Converting to a JDK Date is full of complications as the JDK Date constructor\n+     * doesn't behave as you might expect around DST transitions. This method works\n+     * by taking a first guess and then adjusting. This also handles the situation\n+     * where the JDK time zone data differs from the Joda-Time time zone data.\n+     * @see #toDate()\n+     */\n+    private Date correctDstTransition(Date date, final TimeZone timeZone) {\n+\tCalendar calendar = Calendar.getInstance(timeZone);\n+\tcalendar.setTime(date);\n+\tLocalDateTime check = LocalDateTime.fromCalendarFields(calendar);\n+\tif (check.isBefore(this)) {\n+\t    // DST gap\n+\t    // move forward in units of one minute until equal/after\n+\t    while (check.isBefore(this)) {\n+\t\tcalendar.setTimeInMillis(calendar.getTimeInMillis() + 60000);\n+\t\tcheck = LocalDateTime.fromCalendarFields(calendar);\n+\t    }\n+\t    // move back in units of one second until date wrong\n+\t    while (check.isBefore(this) == false) {\n+\t\tcalendar.setTimeInMillis(calendar.getTimeInMillis() - 1000);\n+\t\tcheck = LocalDateTime.fromCalendarFields(calendar);\n+\t    }\n+\t    calendar.setTimeInMillis(calendar.getTimeInMillis() + 1000);\n+\t} else if (check.equals(this)) {\n+\t    // check for DST overlap\n+\t    final Calendar earlier = Calendar.getInstance(timeZone);\n+\t    earlier.setTimeInMillis(calendar.getTimeInMillis() - timeZone.getDSTSavings());\n+\t    check = LocalDateTime.fromCalendarFields(earlier);\n+\t    if (check.equals(this)) {\n+\t\tcalendar = earlier;\n+\t    }\n+\t}\n+\treturn calendar.getTime();\n     }\n \n     //-----------------------------------------------------------------------\n--- a/src/test/java/org/joda/time/TestLocalDateTime_Basics.java\n+++ b/src/test/java/org/joda/time/TestLocalDateTime_Basics.java\n     }\n \n     //-----------------------------------------------------------------------\n+    public void testToDate_summer_Zone() {\n+        LocalDateTime base = new LocalDateTime(2005, 7, 9, 10, 20, 30, 40, COPTIC_PARIS);\n+        \n+        Date test = base.toDate(TimeZone.getDefault());\n+        check(base, 2005, 7, 9, 10, 20, 30, 40);\n+        \n+        GregorianCalendar gcal = new GregorianCalendar();\n+        gcal.clear();\n+        gcal.set(Calendar.YEAR, 2005);\n+        gcal.set(Calendar.MONTH, Calendar.JULY);\n+        gcal.set(Calendar.DAY_OF_MONTH, 9);\n+        gcal.set(Calendar.HOUR_OF_DAY, 10);\n+        gcal.set(Calendar.MINUTE, 20);\n+        gcal.set(Calendar.SECOND, 30);\n+        gcal.set(Calendar.MILLISECOND, 40);\n+        assertEquals(gcal.getTime(), test);\n+    }\n+\n+    public void testToDate_winter_Zone() {\n+        LocalDateTime base = new LocalDateTime(2005, 1, 9, 10, 20, 30, 40, COPTIC_PARIS);\n+        \n+        Date test = base.toDate(TimeZone.getDefault());\n+        check(base, 2005, 1, 9, 10, 20, 30, 40);\n+        \n+        GregorianCalendar gcal = new GregorianCalendar();\n+        gcal.clear();\n+        gcal.set(Calendar.YEAR, 2005);\n+        gcal.set(Calendar.MONTH, Calendar.JANUARY);\n+        gcal.set(Calendar.DAY_OF_MONTH, 9);\n+        gcal.set(Calendar.HOUR_OF_DAY, 10);\n+        gcal.set(Calendar.MINUTE, 20);\n+        gcal.set(Calendar.SECOND, 30);\n+        gcal.set(Calendar.MILLISECOND, 40);\n+        assertEquals(gcal.getTime(), test);\n+    }\n+\n+    public void testToDate_springDST_Zone() {\n+        LocalDateTime base = new LocalDateTime(2007, 4, 2, 0, 20, 0, 0);\n+        \n+        SimpleTimeZone testZone = new SimpleTimeZone(3600000, \"NoMidnight\",\n+                Calendar.APRIL, 2, 0, 0, Calendar.OCTOBER, 2, 0, 3600000);\n+        TimeZone currentZone = TimeZone.getDefault();\n+        try {\n+            TimeZone.setDefault(testZone);\n+            Date test = base.toDate(TimeZone.getDefault());\n+            check(base, 2007, 4, 2, 0, 20, 0, 0);\n+            assertEquals(\"Mon Apr 02 01:00:00 GMT+02:00 2007\", test.toString());\n+        } finally {\n+            TimeZone.setDefault(currentZone);\n+        }\n+    }\n+\n+    public void testToDate_springDST_2Hour40Savings_Zone() {\n+        LocalDateTime base = new LocalDateTime(2007, 4, 2, 0, 20, 0, 0);\n+        \n+        SimpleTimeZone testZone = new SimpleTimeZone(3600000, \"NoMidnight\",\n+                Calendar.APRIL, 2, 0, 0, Calendar.OCTOBER, 2, 0, 3600000, (3600000 / 6) * 16);\n+        TimeZone currentZone = TimeZone.getDefault();\n+        try {\n+            TimeZone.setDefault(testZone);\n+            Date test = base.toDate(TimeZone.getDefault());\n+            check(base, 2007, 4, 2, 0, 20, 0, 0);\n+            assertEquals(\"Mon Apr 02 02:40:00 GMT+03:40 2007\", test.toString());\n+        } finally {\n+            TimeZone.setDefault(currentZone);\n+        }\n+    }\n+\n+    public void testToDate_autumnDST_Zone() {\n+        LocalDateTime base = new LocalDateTime(2007, 10, 2, 0, 20, 30, 0);\n+        \n+        SimpleTimeZone testZone = new SimpleTimeZone(3600000, \"NoMidnight\",\n+                Calendar.APRIL, 2, 0, 0, Calendar.OCTOBER, 2, 0, 3600000);\n+        TimeZone currentZone = TimeZone.getDefault();\n+        try {\n+            TimeZone.setDefault(testZone);\n+            Date test = base.toDate(TimeZone.getDefault());\n+            check(base, 2007, 10, 2, 0, 20, 30, 0);\n+            assertEquals(\"Tue Oct 02 00:20:30 GMT+02:00 2007\", test.toString());\n+        } finally {\n+            TimeZone.setDefault(currentZone);\n+        }\n+    }\n+    \n+    \n+    //-----------------------------------------------------------------------\n     public void testProperty() {\n         LocalDateTime test = new LocalDateTime(2005, 6, 9, 10, 20, 30, 40, GJ_UTC);\n         assertEquals(test.year(), test.property(DateTimeFieldType.year()));\n--- a/src/main/java/org/joda/time/format/DateTimeFormat.java\n+++ b/src/main/java/org/joda/time/format/DateTimeFormat.java\n /*\n- *  Copyright 2001-2009 Stephen Colebourne\n+ *  Copyright 2001-2013 Stephen Colebourne\n  *\n  *  Licensed under the Apache License, Version 2.0 (the \"License\");\n  *  you may not use this file except in compliance with the License.\n import java.text.DateFormat;\n import java.text.SimpleDateFormat;\n import java.util.HashMap;\n+import java.util.LinkedHashMap;\n import java.util.Locale;\n import java.util.Map;\n \n     /** Type constant for DATETIME. */\n     static final int DATETIME = 2;\n \n+    /** Maximum size of the pattern cache. */\n+    private static final int PATTERN_CACHE_SIZE = 500;\n+\n+    /** Maps patterns to formatters via LRU, patterns don't vary by locale. */\n+    private static final Map<String, DateTimeFormatter> PATTERN_CACHE = new LinkedHashMap<String, DateTimeFormatter>(7) {\n+        private static final long serialVersionUID = 23L;\n+        @Override\n+        protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest) {\n+            return size() > PATTERN_CACHE_SIZE;\n+        };\n+    };\n+\n     /** Maps patterns to formatters, patterns don't vary by locale. */\n-    private static final Map<String, DateTimeFormatter> cPatternedCache = new HashMap<String, DateTimeFormatter>(7);\n-    /** Maps patterns to formatters, patterns don't vary by locale. */\n-    private static final DateTimeFormatter[] cStyleCache = new DateTimeFormatter[25];\n+    private static final DateTimeFormatter[] STYLE_CACHE = new DateTimeFormatter[25];\n \n     //-----------------------------------------------------------------------\n     /**\n             throw new IllegalArgumentException(\"Invalid pattern specification\");\n         }\n         DateTimeFormatter formatter = null;\n-        synchronized (cPatternedCache) {\n-            formatter = cPatternedCache.get(pattern);\n+        synchronized (PATTERN_CACHE) {\n+            formatter = PATTERN_CACHE.get(pattern);\n             if (formatter == null) {\n                 DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();\n                 parsePatternTo(builder, pattern);\n                 formatter = builder.toFormatter();\n \n-                cPatternedCache.put(pattern, formatter);\n+                PATTERN_CACHE.put(pattern, formatter);\n             }\n         }\n         return formatter;\n      */\n     private static DateTimeFormatter createFormatterForStyleIndex(int dateStyle, int timeStyle) {\n         int index = ((dateStyle << 2) + dateStyle) + timeStyle;\n+        // Should never happen but do a double check...\n+        if (index >= STYLE_CACHE.length) {\n+            return createDateTimeFormatter(dateStyle, timeStyle);\n+        }\n         DateTimeFormatter f = null;\n-        synchronized (cStyleCache) {\n-            f = cStyleCache[index];\n+        synchronized (STYLE_CACHE) {\n+            f = STYLE_CACHE[index];\n             if (f == null) {\n-                int type = DATETIME;\n-                if (dateStyle == NONE) {\n-                    type = TIME;\n-                } else if (timeStyle == NONE) {\n-                    type = DATE;\n-                }\n-                StyleFormatter llf = new StyleFormatter(\n-                        dateStyle, timeStyle, type);\n-                f = new DateTimeFormatter(llf, llf);\n-                cStyleCache[index] = f;\n+                f = createDateTimeFormatter(dateStyle, timeStyle);\n+                STYLE_CACHE[index] = f;\n             }\n         }\n         return f;\n+    }\n+    \n+    /**\n+     * Creates a formatter for the specified style.\n+     * @param dateStyle  the date style\n+     * @param timeStyle  the time style\n+     * @return the formatter\n+     */\n+    private static DateTimeFormatter createDateTimeFormatter(int dateStyle, int timeStyle){\n+        int type = DATETIME;\n+        if (dateStyle == NONE) {\n+            type = TIME;\n+        } else if (timeStyle == NONE) {\n+            type = DATE;\n+        }\n+        StyleFormatter llf = new StyleFormatter(dateStyle, timeStyle, type);\n+        return new DateTimeFormatter(llf, llf);\n     }\n \n     /**", "timestamp": 1375897725, "metainfo": ""}