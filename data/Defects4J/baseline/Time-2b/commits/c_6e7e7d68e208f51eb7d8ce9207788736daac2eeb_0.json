{"sha": "6e7e7d68e208f51eb7d8ce9207788736daac2eeb", "log": "add: PersistentTimeOfDay (might loose milliseconds part) add: PersistentTimeOfDayExact (use int to store the full time)   ", "commit": "\n--- /dev/null\n+++ b/JodaTimeContrib/hibernate/src/java/org/joda/time/contrib/hibernate/PersistentTimeOfDay.java\n+/*\n+ *  Copyright 2001-2005 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time.contrib.hibernate;\n+\n+import org.hibernate.Hibernate;\n+import org.hibernate.HibernateException;\n+import org.hibernate.usertype.EnhancedUserType;\n+import org.joda.time.YearMonthDay;\n+import org.joda.time.TimeOfDay;\n+import org.joda.time.DateTime;\n+\n+import java.io.Serializable;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Types;\n+import java.sql.Time;\n+\n+/**\n+ * Persist {@link org.joda.time.TimeOfDay} via hibernate. <br />\n+ * This uses java.sql.Time and the time datatype of your database. <br />\n+ * Notice: You might loose the milliseconds part.\n+ *\n+ * @author Mario Ivankovits (mario@ops.co.at)\n+ */\n+public class PersistentTimeOfDay implements EnhancedUserType\n+{\n+\tprivate final DateTime timeBase = new DateTime(1970, 1, 1, 0, 0, 0, 0);\n+\tpublic final static PersistentTimeOfDay INSTANCE = new PersistentTimeOfDay();\n+\n+\tprivate static final int[] SQL_TYPES = new int[]\n+\t{\n+\t\tTypes.TIME,\n+\t};\n+\n+\tpublic int[] sqlTypes()\n+\t{\n+\t\treturn SQL_TYPES;\n+\t}\n+\n+\tpublic Class returnedClass()\n+\t{\n+\t\treturn TimeOfDay.class;\n+\t}\n+\n+\tpublic boolean equals(Object x, Object y) throws HibernateException\n+\t{\n+\t\tif (x == y)\n+\t\t{\n+\t\t\treturn true;\n+\t\t}\n+\t\tif (x == null || y == null)\n+\t\t{\n+\t\t\treturn false;\n+\t\t}\n+\t\tTimeOfDay dtx = (TimeOfDay) x;\n+\t\tTimeOfDay dty = (TimeOfDay) y;\n+\n+\t\treturn dtx.equals(dty);\n+\t}\n+\n+\tpublic int hashCode(Object object) throws HibernateException\n+\t{\n+\t\treturn object.hashCode();\n+\t}\n+\n+\tpublic Object nullSafeGet(ResultSet resultSet, String[] strings, Object object) throws HibernateException, SQLException\n+\t{\n+\t\treturn nullSafeGet(resultSet, strings[0]);\n+\n+\t}\n+\n+\tpublic Object nullSafeGet(ResultSet resultSet, String string) throws SQLException\n+\t{\n+\t\tObject date = Hibernate.TIME.nullSafeGet(resultSet, string);\n+\t\tif (date == null)\n+\t\t{\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\treturn new TimeOfDay(date);\n+\t}\n+\n+\tpublic void nullSafeSet(PreparedStatement preparedStatement, Object value, int index) throws HibernateException, SQLException\n+\t{\n+\t\tif (value == null)\n+\t\t{\n+\t\t\tHibernate.TIME.nullSafeSet(preparedStatement, null, index);\n+\t\t}\n+\t\telse\n+\t\t{\n+\t\t\tHibernate.TIME.nullSafeSet(preparedStatement, new Time(((TimeOfDay) value).toDateTime(timeBase).getMillis()), index);\n+\t\t}\n+\t}\n+\n+\tpublic Object deepCopy(Object value) throws HibernateException\n+\t{\n+\t\tif (value == null)\n+\t\t{\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\treturn new TimeOfDay(value);\n+\t}\n+\n+\tpublic boolean isMutable()\n+\t{\n+\t\treturn false;\n+\t}\n+\n+\tpublic Serializable disassemble(Object value) throws HibernateException\n+\t{\n+\t\treturn (Serializable) value;\n+\t}\n+\n+\tpublic Object assemble(Serializable cached, Object value) throws HibernateException\n+\t{\n+\t\treturn cached;\n+\t}\n+\n+\tpublic Object replace(Object original, Object target, Object owner) throws HibernateException\n+\t{\n+\t\treturn original;\n+\t}\n+\n+\tpublic String objectToSQLString(Object object)\n+\t{\n+\t\tthrow new UnsupportedOperationException();\n+\t}\n+\n+\tpublic String toXMLString(Object object)\n+\t{\n+\t\treturn object.toString();\n+\t}\n+\n+\tpublic Object fromXMLString(String string)\n+\t{\n+\t\treturn new TimeOfDay(string);\n+\t}\n+}\n--- /dev/null\n+++ b/JodaTimeContrib/hibernate/src/java/org/joda/time/contrib/hibernate/PersistentTimeOfDayExact.java\n+/*\n+ *  Copyright 2001-2005 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time.contrib.hibernate;\n+\n+import org.hibernate.Hibernate;\n+import org.hibernate.HibernateException;\n+import org.hibernate.usertype.EnhancedUserType;\n+import org.joda.time.YearMonthDay;\n+import org.joda.time.TimeOfDay;\n+import org.joda.time.DateTime;\n+\n+import java.io.Serializable;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Types;\n+import java.sql.Time;\n+\n+/**\n+ * Persist {@link org.joda.time.TimeOfDay} via hibernate.<br />\n+ * This uses a simple integer to store the time as milliseconds since 1970-1-1. <br />\n+ * The milliseconds will survive.\n+ *\n+ * @author Mario Ivankovits (mario@ops.co.at)\n+ */\n+public class PersistentTimeOfDayExact implements EnhancedUserType\n+{\n+\tprivate final DateTime timeBase = new DateTime(1970, 1, 1, 0, 0, 0, 0);\n+\tpublic final static PersistentTimeOfDayExact INSTANCE = new PersistentTimeOfDayExact();\n+\n+\tprivate static final int[] SQL_TYPES = new int[]\n+\t{\n+\t\tTypes.INTEGER,\n+\t};\n+\n+\tpublic int[] sqlTypes()\n+\t{\n+\t\treturn SQL_TYPES;\n+\t}\n+\n+\tpublic Class returnedClass()\n+\t{\n+\t\treturn TimeOfDay.class;\n+\t}\n+\n+\tpublic boolean equals(Object x, Object y) throws HibernateException\n+\t{\n+\t\tif (x == y)\n+\t\t{\n+\t\t\treturn true;\n+\t\t}\n+\t\tif (x == null || y == null)\n+\t\t{\n+\t\t\treturn false;\n+\t\t}\n+\t\tTimeOfDay dtx = (TimeOfDay) x;\n+\t\tTimeOfDay dty = (TimeOfDay) y;\n+\n+\t\treturn dtx.equals(dty);\n+\t}\n+\n+\tpublic int hashCode(Object object) throws HibernateException\n+\t{\n+\t\treturn object.hashCode();\n+\t}\n+\n+\tpublic Object nullSafeGet(ResultSet resultSet, String[] strings, Object object) throws HibernateException, SQLException\n+\t{\n+\t\treturn nullSafeGet(resultSet, strings[0]);\n+\n+\t}\n+\n+\tpublic Object nullSafeGet(ResultSet resultSet, String string) throws SQLException\n+\t{\n+\t\tint value = resultSet.getInt(string);\n+\t\tif (resultSet.wasNull())\n+\t\t{\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\treturn new TimeOfDay(value);\n+\t}\n+\n+\tpublic void nullSafeSet(PreparedStatement preparedStatement, Object value, int index) throws HibernateException, SQLException\n+\t{\n+\t\tif (value == null)\n+\t\t{\n+\t\t\tpreparedStatement.setNull(index, SQL_TYPES[0]);\n+\t\t}\n+\t\telse\n+\t\t{\n+\t\t\tpreparedStatement.setInt(index, (int) ((TimeOfDay) value).toDateTime(timeBase).getMillis());\n+\t\t}\n+\t}\n+\n+\tpublic Object deepCopy(Object value) throws HibernateException\n+\t{\n+\t\tif (value == null)\n+\t\t{\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\treturn new TimeOfDay(value);\n+\t}\n+\n+\tpublic boolean isMutable()\n+\t{\n+\t\treturn false;\n+\t}\n+\n+\tpublic Serializable disassemble(Object value) throws HibernateException\n+\t{\n+\t\treturn (Serializable) value;\n+\t}\n+\n+\tpublic Object assemble(Serializable cached, Object value) throws HibernateException\n+\t{\n+\t\treturn cached;\n+\t}\n+\n+\tpublic Object replace(Object original, Object target, Object owner) throws HibernateException\n+\t{\n+\t\treturn original;\n+\t}\n+\n+\tpublic String objectToSQLString(Object object)\n+\t{\n+\t\tthrow new UnsupportedOperationException();\n+\t}\n+\n+\tpublic String toXMLString(Object object)\n+\t{\n+\t\treturn object.toString();\n+\t}\n+\n+\tpublic Object fromXMLString(String string)\n+\t{\n+\t\treturn new TimeOfDay(string);\n+\t}\n+}\n--- a/JodaTimeContrib/hibernate/src/test/org/joda/time/contrib/hibernate/HibernateTestCase.java\n+++ b/JodaTimeContrib/hibernate/src/test/org/joda/time/contrib/hibernate/HibernateTestCase.java\n \t\t\tsetupConfiguration(cfg);\n \n \t\t\tcfg.setProperty(\"hibernate.connection.driver_class\", \"org.hsqldb.jdbcDriver\");\n-\t\t\tcfg.setProperty(\"hibernate.connection.url\", \"jdbc:hsqldb:mem:hbmtest\");\n+\t\t\tcfg.setProperty(\"hibernate.connection.url\", \"jdbc:hsqldb:mem:hbmtest\" + getClass().getName());\n \t\t\tcfg.setProperty(\"hibernate.dialect\", HSQLDialect.class.getName());\n \n \t\t\tcfg.setProperty(\"hibernate.show_sql\", \"true\");\n \t\treturn factory;\n \t}\n \n+\tprotected void tearDown() throws Exception\n+\t{\n+\t\tthis.factory.close();\n+\t\tthis.factory = null;\n+\t}\n+\n \tprotected abstract void setupConfiguration(Configuration cfg);\n }\n--- a/JodaTimeContrib/hibernate/src/test/org/joda/time/contrib/hibernate/Schedule.java\n+++ b/JodaTimeContrib/hibernate/src/test/org/joda/time/contrib/hibernate/Schedule.java\n package org.joda.time.contrib.hibernate;\n \n import org.joda.time.YearMonthDay;\n+import org.joda.time.TimeOfDay;\n \n import java.io.Serializable;\n \n {\n     private int id;\n     private YearMonthDay startDate;\n+\tprivate TimeOfDay nextTime;\n+\tprivate TimeOfDay nextTimeMillis;\n \n-    public Schedule()\n+\tpublic Schedule()\n     {\n     }\n \n \t{\n \t\tthis.startDate = startDate;\n \t}\n+\n+\tpublic TimeOfDay getNextTime()\n+\t{\n+\t\treturn nextTime;\n+\t}\n+\n+\tpublic void setNextTime(TimeOfDay nextTime)\n+\t{\n+\t\tthis.nextTime = nextTime;\n+\t}\n+\n+\tpublic TimeOfDay getNextTimeMillis()\n+\t{\n+\t\treturn nextTimeMillis;\n+\t}\n+\n+\tpublic void setNextTimeMillis(TimeOfDay nextTimeMillis)\n+\t{\n+\t\tthis.nextTimeMillis = nextTimeMillis;\n+\t}\n }\n--- a/JodaTimeContrib/hibernate/src/test/org/joda/time/contrib/hibernate/TestPersistentDateTime.java\n+++ b/JodaTimeContrib/hibernate/src/test/org/joda/time/contrib/hibernate/TestPersistentDateTime.java\n \n             assertEquals(\"get failed - returned different time\",\n                 writeReadTime, eventReread.getDateTime());\n-\n-            session.close();\n         }\n+\t\t\n+\t\tsession.close();\n     }\n \n \tprotected void setupConfiguration(Configuration cfg)\n--- /dev/null\n+++ b/JodaTimeContrib/hibernate/src/test/org/joda/time/contrib/hibernate/TestPersistentTimeOfDay.java\n+package org.joda.time.contrib.hibernate;\n+\n+import org.hibernate.Session;\n+import org.hibernate.SessionFactory;\n+import org.hibernate.cfg.Configuration;\n+import org.joda.time.TimeOfDay;\n+\n+import java.io.File;\n+import java.sql.SQLException;\n+\n+public class TestPersistentTimeOfDay extends HibernateTestCase\n+{\n+    private TimeOfDay[] writeReadTimes = new TimeOfDay[]\n+    {\n+        new TimeOfDay(12, 10, 31),\n+        new TimeOfDay(23,  7, 43, 120)\n+    };\n+\n+    public void testSimpleStore() throws SQLException\n+    {\n+        SessionFactory factory = getSessionFactory();\n+\n+        Session session = factory.openSession();\n+\n+        for (int i = 0; i<writeReadTimes.length; i++)\n+        {\n+            TimeOfDay writeReadTime = writeReadTimes[i];\n+\n+            Schedule event = new Schedule();\n+            event.setId(i);\n+            event.setNextTime(writeReadTime);\n+\n+            session.save(event);\n+        }\n+\n+        session.flush();\n+        session.connection().commit();\n+        session.close();\n+\n+        for (int i = 0; i<writeReadTimes.length; i++)\n+        {\n+            TimeOfDay writeReadTime = writeReadTimes[i];\n+\n+            session = factory.openSession();\n+            Schedule eventReread = (Schedule) session.get(Schedule.class, new Integer(i));\n+\n+            assertNotNull(\"get failed - event#'\" + i + \"'not found\", eventReread);\n+            assertNotNull(\"get failed - returned null\", eventReread.getNextTime());\n+\n+\t\t\tTimeOfDay reReadTime = eventReread.getNextTime();\n+\t\t\tif (writeReadTime.getHourOfDay() != reReadTime.getHourOfDay() ||\n+\t\t\t\twriteReadTime.getMinuteOfHour() != reReadTime.getMinuteOfHour() ||\n+\t\t\t\twriteReadTime.getSecondOfMinute() != reReadTime.getSecondOfMinute())\n+\t\t\t{\n+\t\t\t\tfail(\"get failed - returned different date. expected \" + writeReadTime + \" was \" + eventReread.getNextTime());\n+\t\t\t}\n+\n+\t\t\tif (writeReadTime.getMillisOfSecond() != reReadTime.getMillisOfSecond())\n+\t\t\t{\n+\t\t\t\tSystem.out.println(\"millis different, might happen?\");\n+\t\t\t}\n+\t\t}\n+\n+\t\tsession.close();\n+    }\n+\n+\tprotected void setupConfiguration(Configuration cfg)\n+\t{\n+\t\tcfg.addFile(new File(\"src/test/org/joda/time/contrib/hibernate/schedule.hbm.xml\"));\n+\t}\n+}\n--- /dev/null\n+++ b/JodaTimeContrib/hibernate/src/test/org/joda/time/contrib/hibernate/TestPersistentTimeOfDayExact.java\n+package org.joda.time.contrib.hibernate;\n+\n+import org.hibernate.Session;\n+import org.hibernate.SessionFactory;\n+import org.hibernate.cfg.Configuration;\n+import org.joda.time.TimeOfDay;\n+\n+import java.io.File;\n+import java.sql.SQLException;\n+\n+public class TestPersistentTimeOfDayExact extends HibernateTestCase\n+{\n+    private TimeOfDay[] writeReadTimes = new TimeOfDay[]\n+    {\n+        new TimeOfDay(12, 10, 31),\n+        new TimeOfDay(23,  7, 43, 120)\n+    };\n+\n+    public void testSimpleStore() throws SQLException\n+    {\n+        SessionFactory factory = getSessionFactory();\n+\n+        Session session = factory.openSession();\n+\n+        for (int i = 0; i<writeReadTimes.length; i++)\n+        {\n+            TimeOfDay writeReadTime = writeReadTimes[i];\n+\n+            Schedule event = new Schedule();\n+            event.setId(i);\n+            event.setNextTimeMillis(writeReadTime);\n+\n+            session.save(event);\n+        }\n+\n+        session.flush();\n+        session.connection().commit();\n+        session.close();\n+\n+        for (int i = 0; i<writeReadTimes.length; i++)\n+        {\n+            TimeOfDay writeReadTime = writeReadTimes[i];\n+\n+            session = factory.openSession();\n+            Schedule eventReread = (Schedule) session.get(Schedule.class, new Integer(i));\n+\n+            assertNotNull(\"get failed - event#'\" + i + \"'not found\", eventReread);\n+            assertNotNull(\"get failed - returned null\", eventReread.getNextTimeMillis());\n+\n+\t\t\tassertEquals(\"get failed - returned different date.\", writeReadTime, eventReread.getNextTimeMillis());\n+\t\t}\n+\n+\t\tsession.close();\n+    }\n+\n+\tprotected void setupConfiguration(Configuration cfg)\n+\t{\n+\t\tcfg.addFile(new File(\"src/test/org/joda/time/contrib/hibernate/schedule.hbm.xml\"));\n+\t}\n+}\n--- a/JodaTimeContrib/hibernate/src/test/org/joda/time/contrib/hibernate/TestPersistentYearMonthDay.java\n+++ b/JodaTimeContrib/hibernate/src/test/org/joda/time/contrib/hibernate/TestPersistentYearMonthDay.java\n             assertNotNull(\"get failed - returned null\", eventReread.getStartDate());\n \n             assertEquals(\"get failed - returned different date\", writeReadTime, eventReread.getStartDate());\n-\n-            session.close();\n         }\n+\t\t\n+\t\tsession.close();\n     }\n \n \tprotected void setupConfiguration(Configuration cfg)", "timestamp": 1124310018, "metainfo": ""}