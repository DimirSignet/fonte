{"sha": "78e61bf69c5804b45a6cda006fc6780bbd9dd4d4", "log": "Fix parsing of fractional seconds.   ", "commit": "\n--- a/JodaTime/src/java/org/joda/time/format/PeriodFormatterBuilder.java\n+++ b/JodaTime/src/java/org/joda/time/format/PeriodFormatterBuilder.java\n             }\n \n             int sum = Math.max(FormatUtils.calculateDigitCount(valueLong), iMinPrintedDigits);\n-            if (iFieldType >= 8) {\n+            if (iFieldType >= SECONDS_MILLIS) {\n                 sum++; // decimal point\n                 if (iFieldType == SECONDS_OPTIONAL_MILLIS &&\n                     (Math.abs(valueLong) % DateTimeConstants.MILLIS_PER_SECOND) == 0) {\n                 return;\n             }\n             int value = (int) valueLong;\n-            if (iFieldType >= 8) {\n+            if (iFieldType >= SECONDS_MILLIS) {\n                 value = (int) (valueLong / DateTimeConstants.MILLIS_PER_SECOND);\n             }\n \n             } else {\n                 FormatUtils.appendPaddedInteger(buf, value, minDigits);\n             }\n-            if (iFieldType >= 8) {\n+            if (iFieldType >= SECONDS_MILLIS) {\n                 int dp = (int) (Math.abs(valueLong) % DateTimeConstants.MILLIS_PER_SECOND);\n                 if (iFieldType == SECONDS_MILLIS || dp > 0) {\n                     buf.append('.');\n                 return;\n             }\n             int value = (int) valueLong;\n-            if (iFieldType >= 8) {\n+            if (iFieldType >= SECONDS_MILLIS) {\n                 value = (int) (valueLong / DateTimeConstants.MILLIS_PER_SECOND);\n             }\n \n             } else {\n                 FormatUtils.writePaddedInteger(out, value, minDigits);\n             }\n-            if (iFieldType >= 8) {\n+            if (iFieldType >= SECONDS_MILLIS) {\n                 int dp = (int) (Math.abs(valueLong) % DateTimeConstants.MILLIS_PER_SECOND);\n                 if (iFieldType == SECONDS_MILLIS || dp > 0) {\n                     out.write('.');\n             }\n             \n             // validate input number\n-            boolean negative = false;\n             int length = 0;\n-            int dp = -1;\n+            int fractPos = -1;\n+            boolean hasDigits = false;\n             while (length < limit) {\n                 char c = text.charAt(position + length);\n                 // leading sign\n                 if (length == 0 && (c == '-' || c == '+') && !iRejectSignedValues) {\n-                    negative = (c == '-');\n-                    if (negative) {\n+                    if (c == '-') {\n                         length++;\n                     } else {\n                         // Skip the '+' for parseInt to succeed.\n                     continue;\n                 }\n                 // main number\n-                if (c < '0' || c > '9') {\n-                    if (c == '.' && (iFieldType == SECONDS_MILLIS || iFieldType == SECONDS_OPTIONAL_MILLIS)) {\n-                        if (dp >= 0) {\n+                if (c >= '0' && c <= '9') {\n+                    hasDigits = true;\n+                } else {\n+                    if ((c == '.' || c == ',')\n+                         && (iFieldType == SECONDS_MILLIS || iFieldType == SECONDS_OPTIONAL_MILLIS)) {\n+                        if (fractPos >= 0) {\n                             // can't have two decimals\n-                            return position + length;\n+                            break;\n                         }\n-                        dp = length;\n+                        fractPos = position + length + 1;\n+                        // Expand the limit to disregard the decimal point.\n+                        limit = Math.min(limit + 1, text.length() - position);\n                     } else {\n                         break;\n                     }\n                 }\n                 length++;\n             }\n-            if (length == 0 || (length == 1 && dp == 0) || (dp == -1 && iFieldType == SECONDS_MILLIS)) {\n+\n+            if (!hasDigits) {\n                 return ~position;\n             }\n \n                 // another parser can continue on.\n                 return position;\n             }\n-            \n-            if (iFieldType == SECONDS_MILLIS || iFieldType == SECONDS_OPTIONAL_MILLIS) {\n-                if (dp == -1) {\n-                    position = parseField(period, text, position, negative, length, SECONDS);\n-                    setFieldValue(period, MILLIS, 0);\n+\n+            if (iFieldType != SECONDS_MILLIS && iFieldType != SECONDS_OPTIONAL_MILLIS) {\n+                // Handle common case.\n+                setFieldValue(period, iFieldType, parseInt(text, position, length));\n+            } else if (fractPos < 0) {\n+                setFieldValue(period, SECONDS, parseInt(text, position, length));\n+                setFieldValue(period, MILLIS, 0);\n+            } else {\n+                int wholeValue = parseInt(text, position, fractPos - position - 1);\n+                setFieldValue(period, SECONDS, wholeValue);\n+\n+                int fractLen = position + length - fractPos;\n+                int fractValue;\n+                if (fractLen <= 0) {\n+                    fractValue = 0;\n                 } else {\n-                    if (dp > 0) {\n-                        position = parseField(period, text, position, negative, dp, SECONDS);\n+                    if (fractLen >= 3) {\n+                        fractValue = parseInt(text, fractPos, 3);\n                     } else {\n-                        setFieldValue(period, SECONDS, 0);\n+                        fractValue = parseInt(text, fractPos, fractLen);\n+                        if (fractLen == 1) {\n+                            fractValue *= 100;\n+                        } else {\n+                            fractValue *= 10;\n+                        }\n                     }\n-                    position++; // skip dp\n-                    int millisLength = length - 1 - dp;\n-                    if (millisLength > 3) {\n-                        position = parseField(period, text, position, false, 3, MILLIS);\n-                        position += (millisLength - 3);\n-                    } else if (millisLength == 0) {\n-                        setFieldValue(period, MILLIS, 0);\n-                    } else {\n-                        position = parseField(period, text, position, false, millisLength, MILLIS);\n+                    if (wholeValue < 0) {\n+                        fractValue = -fractValue;\n                     }\n                 }\n-            } else {\n-                position = parseField(period, text, position, negative, length, iFieldType);\n+\n+                setFieldValue(period, MILLIS, fractValue);\n             }\n                 \n+            position += length;\n+\n             if (position >= 0 && iSuffix != null) {\n                 position = iSuffix.parse(text, position);\n             }\n             return position;\n         }\n \n-        private int parseField(\n-                ReadWritablePeriod period, String text, int position,\n-                boolean negative, int length, int type) {\n-            \n-            int value;\n-            if (length >= 9) {\n-                // Since value may exceed max, use stock parser which checks\n-                // for this.\n-                value = Integer.parseInt\n-                    (text.substring(position, position += length));\n+        /**\n+         * @param text text to parse\n+         * @param position position in text\n+         * @param length exact count of characters to parse\n+         * @return parsed int value\n+         */\n+        private int parseInt(String text, int position, int length) {\n+            if (length >= 10) {\n+                // Since value may exceed max, use stock parser which checks for this.\n+                return Integer.parseInt(text.substring(position, position + length));\n+            }\n+            if (length <= 0) {\n+                return 0;\n+            }\n+            int value = text.charAt(position++);\n+            length--;\n+            boolean negative;\n+            if (value == '-') {\n+                if (--length < 0) {\n+                    return 0;\n+                }\n+                negative = true;\n+                value = text.charAt(position++);\n             } else {\n-                int i = position;\n-                if (negative) {\n-                    i++;\n-                }\n-                value = text.charAt(i++) - '0';\n-                position += length;\n-                while (i < position) {\n-                    value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0';\n-                }\n-                if (negative) {\n-                    value = -value;\n-                }\n-            }\n-            \n-            setFieldValue(period, type, value);\n-            return position;\n+                negative = false;\n+            }\n+            value -= '0';\n+            while (length-- > 0) {\n+                value = ((value << 3) + (value << 1)) + text.charAt(position++) - '0';\n+            }\n+            return negative ? -value : value;\n         }\n \n         /**\n                 return Long.MAX_VALUE;\n             }\n \n-            int value;\n+            long value;\n \n             switch (iFieldType) {\n             default:\n             case SECONDS_OPTIONAL_MILLIS:\n                 int seconds = period.get(DurationFieldType.seconds());\n                 int millis = period.get(DurationFieldType.millis());\n-                value = seconds * DateTimeConstants.MILLIS_PER_SECOND + millis;\n+                value = (seconds * (long) DateTimeConstants.MILLIS_PER_SECOND) + millis;\n                 break;\n             }\n ", "timestamp": 1100985415, "metainfo": ""}