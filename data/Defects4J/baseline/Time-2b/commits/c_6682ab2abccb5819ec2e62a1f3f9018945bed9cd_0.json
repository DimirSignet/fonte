{"sha": "6682ab2abccb5819ec2e62a1f3f9018945bed9cd", "log": "Test DateTimeZone   ", "commit": "\n--- a/JodaTime/src/java/org/joda/time/DateTimeZone.java\n+++ b/JodaTime/src/java/org/joda/time/DateTimeZone.java\n     /**\n      * Get the time zone by id.\n      * <p>\n-     * The time zone id may be one of those returned by getAvailableIDs. Short\n-     * ids, as accepted by {@link java.util.TimeZone}, are not accepted. All\n-     * IDs must be specified in the long format. The exception is UTC, which is\n-     * an acceptable id.\n+     * The time zone id may be one of those returned by getAvailableIDs.\n+     * Short ids, as accepted by {@link java.util.TimeZone}, are not accepted.\n+     * All IDs must be specified in the long format.\n+     * The exception is UTC, which is an acceptable id.\n      * <p>\n      * Alternatively a locale independent, fixed offset, datetime zone can\n      * be specified. The form <code>[+-]hh:mm</code> can be used.\n      * \n-     * @param id  the ID of the datetime zone\n+     * @param id  the ID of the datetime zone, null means default\n      * @return the DateTimeZone object for the ID\n-     * @throws IllegalArgumentException if the ID is null or not recognised\n+     * @throws IllegalArgumentException if the ID is not recognised\n      */\n     public static DateTimeZone getInstance(String id) throws IllegalArgumentException {\n         if (id == null) {\n-            throw new IllegalArgumentException(\"The datetime zone id must not be null\");\n+            return getDefault();\n         }\n         if (id.equals(\"UTC\")) {\n             return DateTimeZone.UTC;\n             return zone;\n         }\n         if (id.startsWith(\"+\") || id.startsWith(\"-\")) {\n-            int offset = -(int)offsetFormatter().parseMillis(id);\n-            // Canonicalize the id.\n-            id = offsetFormatter().print(0, UTC, offset);\n-            return new FixedDateTimeZone(id, null, offset, offset);\n+            int offset = -(int) offsetFormatter().parseMillis(id);\n+            if (offset == 0L) {\n+                return DateTimeZone.UTC;\n+            } else {\n+                id = offsetFormatter().print(0, UTC, offset);\n+                return new FixedDateTimeZone(id, null, offset, offset);\n+            }\n         }\n         throw new IllegalArgumentException(\"The datetime zone id is not recognised: \" + id);\n     }\n      * method will attempt to convert between time zones created using the\n      * short IDs and the full version.\n      * \n-     * @param zone the zone to convert\n+     * @param zone  the zone to convert, null means default\n      * @return the DateTimeZone object for the zone\n-     * @throws IllegalArgumentException if the zone is null or not recognised\n+     * @throws IllegalArgumentException if the zone is not recognised\n      */\n     public static DateTimeZone getInstance(java.util.TimeZone zone) {\n         if (zone == null) {\n-            throw new IllegalArgumentException(\"The TimeZone must not be null\");\n+            return getDefault();\n         }\n         final String id = zone.getID();\n         if (id.equals(\"UTC\")) {\n             return DateTimeZone.UTC;\n         }\n \n-        DateTimeZone dtz;\n         // Convert from old alias before consulting provider since they may differ.\n+        DateTimeZone dtz = null;\n         String convId = getConvertedId(id);\n-        if (convId == null || (dtz = cProvider.getZone(convId)) == null) {\n+        if (convId != null) {\n+            dtz = cProvider.getZone(convId);\n+        }\n+        if (dtz == null) {\n             dtz = cProvider.getZone(id);\n         }\n         if (dtz != null) {\n             if (convId.startsWith(\"GMT+\") || convId.startsWith(\"GMT-\")) {\n                 convId = convId.substring(3);\n                 int offset = -(int)offsetFormatter().parseMillis(convId);\n-                // Canonicalize the id.\n-                convId = offsetFormatter().print(0, UTC, offset);\n-                return new FixedDateTimeZone(convId, null, offset, offset);\n+                if (offset == 0L) {\n+                    return DateTimeZone.UTC;\n+                } else {\n+                    convId = offsetFormatter().print(0, UTC, offset);\n+                    return new FixedDateTimeZone(convId, null, offset, offset);\n+                }\n             }\n         }\n \n         return cAvailableIDs;\n     }\n \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the zone provider factory.\n+     * <p>\n+     * The zone provider is a pluggable instance factory that supplies the\n+     * actual instances of DateTimeZone.\n+     * \n+     * @return the provider\n+     */\n     public static Provider getProvider() {\n         return cProvider;\n     }\n \n     /**\n-     * @param provider provider to use, or null for default\n+     * Sets the zone provider factory.\n+     * <p>\n+     * The zone provider is a pluggable instance factory that supplies the\n+     * actual instances of DateTimeZone.\n+     * \n+     * @param provider  provider to use, or null for default\n+     * @throws SecurityException if you do not have the permission DateTimeZone.setProvider\n+     * @throws IllegalArgumentException if the provider is invalid\n      */\n     public static void setProvider(Provider provider) throws SecurityException {\n         SecurityManager sm = System.getSecurityManager();\n     }\n \n     /**\n-     * Doesn't perform a security check.\n+     * Sets the zone provider factory without performing the security check.\n+     * \n+     * @param provider  provider to use, or null for default\n+     * @throws IllegalArgumentException if the provider is invalid\n      */\n     private static void setProvider0(Provider provider) {\n         if (provider == null) {\n         cAvailableIDs = ids;\n     }\n \n+    /**\n+     * Gets the default zone provider.\n+     * <p>\n+     * Tries the system property <code>org.joda.time.DateTimeZone.Provider</code>.\n+     * Then tries a <code>ZoneInfoProvider</code> using the data in <code>org/joda/time/tz/data</code>.\n+     * Then uses <code>UTCProvider</code>.\n+     * \n+     * @return the default name provider\n+     */\n+    private static Provider getDefaultProvider() {\n+        Provider provider = null;\n+\n+        try {\n+            String providerClass =\n+                System.getProperty(\"org.joda.time.DateTimeZone.Provider\");\n+            if (providerClass != null) {\n+                try {\n+                    provider = (Provider)Class.forName(providerClass).newInstance();\n+                }\n+                catch (Exception ex) {\n+                    Thread thread = Thread.currentThread();\n+                    thread.getThreadGroup().uncaughtException(thread, ex);\n+                }\n+            }\n+        } catch (SecurityException ex) {\n+        }\n+\n+        if (provider == null) {\n+            try {\n+                provider = new ZoneInfoProvider(\"org/joda/time/tz/data\");\n+            } catch (Exception ex) {\n+                Thread thread = Thread.currentThread();\n+                thread.getThreadGroup().uncaughtException(thread, ex);\n+            }\n+        }\n+\n+        if (provider == null) {\n+            provider = new UTCProvider();\n+        }\n+\n+        return provider;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the name provider factory.\n+     * <p>\n+     * The name provider is a pluggable instance factory that supplies the\n+     * names of each DateTimeZone.\n+     * \n+     * @return the provider\n+     */\n     public static NameProvider getNameProvider() {\n         return cNameProvider;\n     }\n \n     /**\n-     * @param nameProvider provider to use, or null for default\n+     * Sets the name provider factory.\n+     * <p>\n+     * The name provider is a pluggable instance factory that supplies the\n+     * names of each DateTimeZone.\n+     * \n+     * @param nameProvider  provider to use, or null for default\n+     * @throws SecurityException if you do not have the permission DateTimeZone.setNameProvider\n+     * @throws IllegalArgumentException if the provider is invalid\n      */\n     public static void setNameProvider(NameProvider nameProvider) throws SecurityException {\n         SecurityManager sm = System.getSecurityManager();\n     }\n \n     /**\n-     * Doesn't perform a security check.\n+     * Sets the name provider factory without performing the security check.\n+     * \n+     * @param nameProvider  provider to use, or null for default\n+     * @throws IllegalArgumentException if the provider is invalid\n      */\n     private static void setNameProvider0(NameProvider nameProvider) {\n         if (nameProvider == null) {\n         cNameProvider = nameProvider;\n     }\n \n+    /**\n+     * Gets the default name provider.\n+     * <p>\n+     * Tries the system property <code>org.joda.time.DateTimeZone.NameProvider</code>.\n+     * Then uses <code>DefaultNameProvider</code>.\n+     * \n+     * @return the default name provider\n+     */\n+    private static NameProvider getDefaultNameProvider() {\n+        NameProvider nameProvider = null;\n+        try {\n+            String providerClass = System.getProperty(\"org.joda.time.DateTimeZone.NameProvider\");\n+            if (providerClass != null) {\n+                try {\n+                    nameProvider = (NameProvider) Class.forName(providerClass).newInstance();\n+                } catch (Exception ex) {\n+                    Thread thread = Thread.currentThread();\n+                    thread.getThreadGroup().uncaughtException(thread, ex);\n+                }\n+            }\n+        } catch (SecurityException ex) {\n+            // ignore\n+        }\n+\n+        if (nameProvider == null) {\n+            nameProvider = new DefaultNameProvider();\n+        }\n+\n+        return nameProvider;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Converts an old style id to a new style id.\n+     * \n+     * @param id  the old style id\n+     * @return the new style id, null if not found\n+     */\n     private static synchronized String getConvertedId(String id) {\n         Map map = cZoneIdConversion;\n         if (map == null) {\n             map.put(\"NST\", \"Pacific/Auckland\");\n             cZoneIdConversion = map;\n         }\n-        return (String)map.get(id);\n-    }\n-\n+        return (String) map.get(id);\n+    }\n+\n+    /**\n+     * Gets a printer/parser for managing the offset id formatting.\n+     * \n+     * @return the formatter\n+     */\n     private static synchronized DateTimeFormatter offsetFormatter() {\n         if (cOffsetFormatter == null) {\n             cOffsetFormatter = new DateTimeFormatterBuilder((Chronology)null, null)\n         return cOffsetFormatter;\n     }\n \n-    private static Provider getDefaultProvider() {\n-        Provider provider = null;\n-\n-        try {\n-            String providerClass =\n-                System.getProperty(\"org.joda.time.DateTimeZone.Provider\");\n-            if (providerClass != null) {\n-                try {\n-                    provider = (Provider)Class.forName(providerClass).newInstance();\n-                }\n-                catch (Exception e) {\n-                    Thread t = Thread.currentThread();\n-                    t.getThreadGroup().uncaughtException(t, e);\n-                }\n-            }\n-        } catch (SecurityException e) {\n-        }\n-\n-        if (provider == null) {\n-            try {\n-                provider = new ZoneInfoProvider(\"org/joda/time/tz/data\");\n-            } catch (Exception e) {\n-                Thread t = Thread.currentThread();\n-                t.getThreadGroup().uncaughtException(t, e);\n-            }\n-        }\n-\n-        if (provider == null) {\n-            provider = new UTCProvider();\n-        }\n-\n-        return provider;\n-    }\n-\n-    private static NameProvider getDefaultNameProvider() {\n-        NameProvider nameProvider = null;\n-\n-        try {\n-            String providerClass =\n-                System.getProperty(\"org.joda.time.DateTimeZone.NameProvider\");\n-            if (providerClass != null) {\n-                try {\n-                    nameProvider = (NameProvider)Class.forName(providerClass).newInstance();\n-                }\n-                catch (Exception e) {\n-                    Thread t = Thread.currentThread();\n-                    t.getThreadGroup().uncaughtException(t, e);\n-                }\n-            }\n-        } catch (SecurityException e) {\n-        }\n-\n-        if (nameProvider == null) {\n-            nameProvider = new DefaultNameProvider();\n-        }\n-\n-        return nameProvider;\n-    }\n-\n     // Instance fields and methods\n     //--------------------------------------------------------------------\n \n     private final String iID;\n \n-    public DateTimeZone(String id) {\n+    /**\n+     * Constructor.\n+     * \n+     * @param id  the id to use\n+     * @throws IllegalArgumentException if the id is null\n+     */\n+    protected DateTimeZone(String id) {\n         if (id == null) {\n             throw new IllegalArgumentException(\"Id must not be null\");\n         }\n      * Returns a non-localized name that is unique to this time zone. It can be\n      * combined with id to form a unique key for fetching localized names.\n      *\n-     * @param instant milliseconds from 1970-01-01T00:00:00Z to get the name for\n+     * @param instant  milliseconds from 1970-01-01T00:00:00Z to get the name for\n      * @return name key or null if id should be used for names\n      */\n     public abstract String getNameKey(long instant);\n      * If the name is not available for the locale, then this method returns a\n      * string in the format <code>[+-]hh:mm</code>.\n      * \n-     * @param instant milliseconds from 1970-01-01T00:00:00Z to get the name for\n+     * @param instant  milliseconds from 1970-01-01T00:00:00Z to get the name for\n      * @return the human-readable short name in the default locale\n      */\n     public final String getShortName(long instant) {\n      * If the name is not available for the locale, then this method returns a\n      * string in the format <code>[+-]hh:mm</code>.\n      * \n-     * @param instant milliseconds from 1970-01-01T00:00:00Z to get the name for\n+     * @param instant  milliseconds from 1970-01-01T00:00:00Z to get the name for\n      * @return the human-readable short name in the specified locale\n      */\n     public String getShortName(long instant, Locale locale) {\n      * If the name is not available for the locale, then this method returns a\n      * string in the format <code>[+-]hh:mm</code>.\n      * \n-     * @param instant milliseconds from 1970-01-01T00:00:00Z to get the name for\n+     * @param instant  milliseconds from 1970-01-01T00:00:00Z to get the name for\n      * @return the human-readable long name in the default locale\n      */\n     public final String getName(long instant) {\n      * If the name is not available for the locale, then this method returns a\n      * string in the format <code>[+-]hh:mm</code>.\n      * \n-     * @param instant milliseconds from 1970-01-01T00:00:00Z to get the name for\n+     * @param instant  milliseconds from 1970-01-01T00:00:00Z to get the name for\n      * @return the human-readable long name in the specified locale\n      */\n     public String getName(long instant, Locale locale) {\n     /**\n      * Gets the millisecond offset to add to UTC to get local time.\n      * \n-     * @param instant milliseconds from 1970-01-01T00:00:00Z to get the offset for\n+     * @param instant  milliseconds from 1970-01-01T00:00:00Z to get the offset for\n      * @return the millisecond offset to add to UTC to get local time\n      */\n     public abstract int getOffset(long instant);\n     /**\n      * Gets the millisecond offset to add to UTC to get local time.\n      * \n-     * @param instant instant to get the offset for\n+     * @param instant  instant to get the offset for, null means now\n      * @return the millisecond offset to add to UTC to get local time\n-     * @throws IllegalArgumentException if the instant is null\n      */\n     public final int getOffset(ReadableInstant instant) {\n         if (instant == null) {\n-            throw new IllegalArgumentException(\"The instant must not be null\");\n+            return getOffset(DateTimeUtils.currentTimeMillis());\n         }\n         return getOffset(instant.getMillis());\n     }\n      * Gets the standard millisecond offset to add to UTC to get local time,\n      * when standard time is in effect.\n      * \n-     * @param instant milliseconds from 1970-01-01T00:00:00Z to get the offset for\n+     * @param instant  milliseconds from 1970-01-01T00:00:00Z to get the offset for\n      * @return the millisecond offset to add to UTC to get local time\n      */\n     public abstract int getStandardOffset(long instant);\n      * offset transitions (due to DST or other historical changes), ranges of\n      * local times may map to different UTC times.\n      *\n-     * @param instantLocal the millisecond instant, relative to this time zone, to\n+     * @param instantLocal  the millisecond instant, relative to this time zone, to\n      * get the offset for\n      * @return the millisceond offset to subtract from local time to get UTC time.\n      */\n     public abstract boolean isFixed();\n \n     /**\n-     * Advances the given instant to where the time zone offset or name\n-     * changes. If the instant returned is exactly the same as passed in, then\n+     * Advances the given instant to where the time zone offset or name changes.\n+     * If the instant returned is exactly the same as passed in, then\n      * no changes occur after the given instant.\n      *\n-     * @param instant milliseconds from 1970-01-01T00:00:00Z\n+     * @param instant  milliseconds from 1970-01-01T00:00:00Z\n      * @return milliseconds from 1970-01-01T00:00:00Z\n      */\n     public abstract long nextTransition(long instant);\n \n     /**\n-     * Retreats the given instant to where the time zone offset or name\n-     * changes. If the instant returned is exactly the same as passed in, then\n+     * Retreats the given instant to where the time zone offset or name changes.\n+     * If the instant returned is exactly the same as passed in, then\n      * no changes occur before the given instant.\n      *\n-     * @param instant milliseconds from 1970-01-01T00:00:00Z\n+     * @param instant  milliseconds from 1970-01-01T00:00:00Z\n      * @return milliseconds from 1970-01-01T00:00:00Z\n      */\n     public abstract long previousTransition(long instant);\n--- a/JodaTime/src/test/org/joda/time/TestAll.java\n+++ b/JodaTime/src/test/org/joda/time/TestAll.java\n         \n         suite.addTest(TestDateTimeComparator.suite());\n         suite.addTest(TestDateTimeConstants.suite());\n+        suite.addTest(TestDateTimeZone.suite());\n //        suite.addTest(TestParseISO.suite());\n         return suite;\n     }\n--- /dev/null\n+++ b/JodaTime/src/test/org/joda/time/TestDateTimeZone.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.PrintStream;\n+import java.lang.reflect.Modifier;\n+import java.security.AllPermission;\n+import java.security.CodeSource;\n+import java.security.Permission;\n+import java.security.PermissionCollection;\n+import java.security.Permissions;\n+import java.security.Policy;\n+import java.security.ProtectionDomain;\n+import java.util.HashSet;\n+import java.util.Locale;\n+import java.util.Set;\n+import java.util.TimeZone;\n+\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+import org.joda.time.tz.DefaultNameProvider;\n+import org.joda.time.tz.NameProvider;\n+import org.joda.time.tz.Provider;\n+import org.joda.time.tz.UTCProvider;\n+import org.joda.time.tz.ZoneInfoProvider;\n+\n+/**\n+ * This class is a JUnit test for DateTimeZone.\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class TestDateTimeZone extends TestCase {\n+    // Test in 2002/03 as time zones are more well known\n+    // (before the late 90's they were all over the place)\n+\n+    private static final DateTimeZone PARIS = DateTimeZone.getInstance(\"Europe/Paris\");\n+    private static final DateTimeZone LONDON = DateTimeZone.getInstance(\"Europe/London\");\n+    \n+    long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + \n+                     366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + \n+                     365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +\n+                     366 + 365;\n+    long y2003days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + \n+                     366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + \n+                     365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +\n+                     366 + 365 + 365;\n+    \n+    // 2002-06-09\n+    private long TEST_TIME_SUMMER =\n+            (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;\n+            \n+    // 2002-01-09\n+    private long TEST_TIME_WINTER =\n+            (y2002days + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;\n+            \n+    // 2002-04-05 Fri\n+    private long TEST_TIME1 =\n+            (y2002days + 31L + 28L + 31L + 5L -1L) * DateTimeConstants.MILLIS_PER_DAY\n+            + 12L * DateTimeConstants.MILLIS_PER_HOUR\n+            + 24L * DateTimeConstants.MILLIS_PER_MINUTE;\n+        \n+    // 2003-05-06 Tue\n+    private long TEST_TIME2 =\n+            (y2003days + 31L + 28L + 31L + 30L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY\n+            + 14L * DateTimeConstants.MILLIS_PER_HOUR\n+            + 28L * DateTimeConstants.MILLIS_PER_MINUTE;\n+    \n+    private static final Policy RESTRICT;\n+    private static final Policy ALLOW;\n+    static {\n+        // don't call Policy.getPolicy()\n+        RESTRICT = new Policy() {\n+            public PermissionCollection getPermissions(CodeSource codesource) {\n+                Permissions p = new Permissions();\n+                p.add(new AllPermission());  // enable everything\n+                return p;\n+            }\n+            public void refresh() {\n+            }\n+            public boolean implies(ProtectionDomain domain, Permission permission) {\n+                if (permission instanceof JodaTimePermission) {\n+                    return false;\n+                }\n+                return super.implies(domain, permission);\n+            }\n+        };\n+        ALLOW = new Policy() {\n+            public PermissionCollection getPermissions(CodeSource codesource) {\n+                Permissions p = new Permissions();\n+                p.add(new AllPermission());  // enable everything\n+                return p;\n+            }\n+            public void refresh() {\n+            }\n+        };\n+    }\n+    \n+    private Locale locale = null;\n+\n+    public static void main(String[] args) {\n+        junit.textui.TestRunner.run(suite());\n+    }\n+\n+    public static TestSuite suite() {\n+        return new TestSuite(TestDateTimeZone.class);\n+    }\n+\n+    public TestDateTimeZone(String name) {\n+        super(name);\n+    }\n+\n+    protected void setUp() throws Exception {\n+        locale = Locale.getDefault();\n+        Locale.setDefault(Locale.UK);\n+    }\n+\n+    protected void tearDown() throws Exception {\n+        Locale.setDefault(locale);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testDefault() {\n+        assertNotNull(DateTimeZone.getDefault());\n+        \n+        DateTimeZone.setDefault(PARIS);\n+        assertSame(PARIS, DateTimeZone.getDefault());\n+        \n+        try {\n+            DateTimeZone.setDefault(null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+            \n+    public void testDefaultSecurity() {\n+        try {\n+            Policy.setPolicy(RESTRICT);\n+            System.setSecurityManager(new SecurityManager());\n+            DateTimeZone.setDefault(PARIS);\n+            fail();\n+        } catch (SecurityException ex) {\n+            // ok\n+        } finally {\n+            System.setSecurityManager(null);\n+            Policy.setPolicy(ALLOW);\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testGetInstance_String() {\n+        assertEquals(DateTimeZone.getDefault(), DateTimeZone.getInstance((String) null));\n+        \n+        DateTimeZone zone = DateTimeZone.getInstance(\"Europe/London\");\n+        assertEquals(\"Europe/London\", zone.getID());\n+        \n+        zone = DateTimeZone.getInstance(\"UTC\");\n+        assertSame(DateTimeZone.UTC, zone);\n+        \n+        zone = DateTimeZone.getInstance(\"+00:00\");\n+        assertSame(DateTimeZone.UTC, zone);\n+        \n+        zone = DateTimeZone.getInstance(\"+00\");\n+        assertSame(DateTimeZone.UTC, zone);\n+        \n+        zone = DateTimeZone.getInstance(\"+01:23\");\n+        assertEquals(\"+01:23\", zone.getID());\n+        assertEquals(DateTimeConstants.MILLIS_PER_HOUR + (23L * DateTimeConstants.MILLIS_PER_MINUTE),\n+                zone.getOffset(TEST_TIME_SUMMER));\n+        \n+        zone = DateTimeZone.getInstance(\"-02:00\");\n+        assertEquals(\"-02:00\", zone.getID());\n+        assertEquals((-2L * DateTimeConstants.MILLIS_PER_HOUR),\n+                zone.getOffset(TEST_TIME_SUMMER));\n+        \n+        try {\n+            DateTimeZone.getInstance(\"SST\");\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            DateTimeZone.getInstance(\"Europe/UK\");\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            DateTimeZone.getInstance(\"+\");\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            DateTimeZone.getInstance(\"+0\");\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testGetInstance_TimeZone() {\n+        assertEquals(DateTimeZone.getDefault(), DateTimeZone.getInstance((TimeZone) null));\n+        \n+        DateTimeZone zone = DateTimeZone.getInstance(TimeZone.getTimeZone(\"Europe/London\"));\n+        assertEquals(\"Europe/London\", zone.getID());\n+        assertSame(DateTimeZone.UTC, DateTimeZone.getInstance(TimeZone.getTimeZone(\"UTC\")));\n+        \n+        zone = DateTimeZone.getInstance(TimeZone.getTimeZone(\"+00:00\"));\n+        assertSame(DateTimeZone.UTC, zone);\n+        \n+        zone = DateTimeZone.getInstance(TimeZone.getTimeZone(\"GMT+00:00\"));\n+        assertSame(DateTimeZone.UTC, zone);\n+        \n+        zone = DateTimeZone.getInstance(TimeZone.getTimeZone(\"GMT+00:00\"));\n+        assertSame(DateTimeZone.UTC, zone);\n+        \n+        zone = DateTimeZone.getInstance(TimeZone.getTimeZone(\"GMT+00\"));\n+        assertSame(DateTimeZone.UTC, zone);\n+        \n+        zone = DateTimeZone.getInstance(TimeZone.getTimeZone(\"GMT+01:23\"));\n+        assertEquals(\"+01:23\", zone.getID());\n+        assertEquals(DateTimeConstants.MILLIS_PER_HOUR + (23L * DateTimeConstants.MILLIS_PER_MINUTE),\n+                zone.getOffset(TEST_TIME_SUMMER));\n+        \n+        zone = DateTimeZone.getInstance(TimeZone.getTimeZone(\"GMT-02:00\"));\n+        assertEquals(\"-02:00\", zone.getID());\n+        assertEquals((-2L * DateTimeConstants.MILLIS_PER_HOUR), zone.getOffset(TEST_TIME_SUMMER));\n+        \n+        zone = DateTimeZone.getInstance(TimeZone.getTimeZone(\"EST\"));\n+        assertEquals(\"America/New_York\", zone.getID());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testGetAvailableIDs() {\n+        assertTrue(DateTimeZone.getAvailableIDs().contains(\"UTC\"));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testProvider() {\n+        try {\n+            assertNotNull(DateTimeZone.getProvider());\n+        \n+            Provider provider = DateTimeZone.getProvider();\n+            DateTimeZone.setProvider(null);\n+            assertEquals(provider.getClass(), DateTimeZone.getProvider().getClass());\n+        \n+            try {\n+                DateTimeZone.setProvider(new MockNullIDSProvider());\n+                fail();\n+            } catch (IllegalArgumentException ex) {}\n+            try {\n+                DateTimeZone.setProvider(new MockEmptyIDSProvider());\n+                fail();\n+            } catch (IllegalArgumentException ex) {}\n+            try {\n+                DateTimeZone.setProvider(new MockNoUTCProvider());\n+                fail();\n+            } catch (IllegalArgumentException ex) {}\n+            try {\n+                DateTimeZone.setProvider(new MockBadUTCProvider());\n+                fail();\n+            } catch (IllegalArgumentException ex) {}\n+        \n+            Provider prov = new MockOKProvider();\n+            DateTimeZone.setProvider(prov);\n+            assertSame(prov, DateTimeZone.getProvider());\n+            assertEquals(2, DateTimeZone.getAvailableIDs().size());\n+            assertTrue(DateTimeZone.getAvailableIDs().contains(\"UTC\"));\n+            assertTrue(DateTimeZone.getAvailableIDs().contains(\"Europe/London\"));\n+        } finally {\n+            DateTimeZone.setProvider(null);\n+            assertEquals(ZoneInfoProvider.class, DateTimeZone.getProvider().getClass());\n+        }\n+        \n+        try {\n+            System.setProperty(\"org.joda.time.DateTimeZone.Provider\", \"org.joda.time.tz.UTCProvider\");\n+            DateTimeZone.setProvider(null);\n+            assertEquals(UTCProvider.class, DateTimeZone.getProvider().getClass());\n+        } finally {\n+            System.getProperties().remove(\"org.joda.time.DateTimeZone.Provider\");\n+            DateTimeZone.setProvider(null);\n+            assertEquals(ZoneInfoProvider.class, DateTimeZone.getProvider().getClass());\n+        }\n+        \n+        PrintStream syserr = System.err;\n+        try {\n+            System.setProperty(\"org.joda.time.DateTimeZone.Provider\", \"xxx\");\n+            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+            System.setErr(new PrintStream(baos));\n+            \n+            DateTimeZone.setProvider(null);\n+            \n+            assertEquals(ZoneInfoProvider.class, DateTimeZone.getProvider().getClass());\n+            String str = new String(baos.toByteArray());\n+            assertTrue(str.indexOf(\"java.lang.ClassNotFoundException\") >= 0);\n+        } finally {\n+            System.setErr(syserr);\n+            System.getProperties().remove(\"org.joda.time.DateTimeZone.Provider\");\n+            DateTimeZone.setProvider(null);\n+            assertEquals(ZoneInfoProvider.class, DateTimeZone.getProvider().getClass());\n+        }\n+    }\n+    \n+    public void testProviderSecurity() {\n+        try {\n+            Policy.setPolicy(RESTRICT);\n+            System.setSecurityManager(new SecurityManager());\n+            DateTimeZone.setProvider(new MockOKProvider());\n+            fail();\n+        } catch (SecurityException ex) {\n+            // ok\n+        } finally {\n+            System.setSecurityManager(null);\n+            Policy.setPolicy(ALLOW);\n+        }\n+    }\n+\n+    static class MockNullIDSProvider implements Provider {\n+        public Set getAvailableIDs() {\n+            return null;\n+        }\n+        public DateTimeZone getZone(String id) {\n+            return null;\n+        }\n+    }\n+    static class MockEmptyIDSProvider implements Provider {\n+        public Set getAvailableIDs() {\n+            return new HashSet();\n+        }\n+        public DateTimeZone getZone(String id) {\n+            return null;\n+        }\n+    }\n+    static class MockNoUTCProvider implements Provider {\n+        public Set getAvailableIDs() {\n+            Set set = new HashSet();\n+            set.add(\"Europe/London\");\n+            return set;\n+        }\n+        public DateTimeZone getZone(String id) {\n+            return null;\n+        }\n+    }\n+    static class MockBadUTCProvider implements Provider {\n+        public Set getAvailableIDs() {\n+            Set set = new HashSet();\n+            set.add(\"UTC\");\n+            set.add(\"Europe/London\");\n+            return set;\n+        }\n+        public DateTimeZone getZone(String id) {\n+            return null;\n+        }\n+    }\n+    static class MockOKProvider implements Provider {\n+        public Set getAvailableIDs() {\n+            Set set = new HashSet();\n+            set.add(\"UTC\");\n+            set.add(\"Europe/London\");\n+            return set;\n+        }\n+        public DateTimeZone getZone(String id) {\n+            return DateTimeZone.UTC;\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testNameProvider() {\n+        try {\n+            assertNotNull(DateTimeZone.getNameProvider());\n+        \n+            NameProvider provider = DateTimeZone.getNameProvider();\n+            DateTimeZone.setNameProvider(null);\n+            assertEquals(provider.getClass(), DateTimeZone.getNameProvider().getClass());\n+        \n+            provider = new MockOKButNullNameProvider();\n+            DateTimeZone.setNameProvider(provider);\n+            assertSame(provider, DateTimeZone.getNameProvider());\n+            \n+            assertEquals(\"+00:00\", DateTimeZone.UTC.getShortName(TEST_TIME_SUMMER));\n+            assertEquals(\"+00:00\", DateTimeZone.UTC.getName(TEST_TIME_SUMMER));\n+        } finally {\n+            DateTimeZone.setNameProvider(null);\n+        }\n+        \n+        try {\n+            System.setProperty(\"org.joda.time.DateTimeZone.NameProvider\", \"org.joda.time.tz.DefaultNameProvider\");\n+            DateTimeZone.setNameProvider(null);\n+            assertEquals(DefaultNameProvider.class, DateTimeZone.getNameProvider().getClass());\n+        } finally {\n+            System.getProperties().remove(\"org.joda.time.DateTimeZone.NameProvider\");\n+            DateTimeZone.setNameProvider(null);\n+            assertEquals(DefaultNameProvider.class, DateTimeZone.getNameProvider().getClass());\n+        }\n+        \n+        PrintStream syserr = System.err;\n+        try {\n+            System.setProperty(\"org.joda.time.DateTimeZone.NameProvider\", \"xxx\");\n+            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+            System.setErr(new PrintStream(baos));\n+            \n+            DateTimeZone.setNameProvider(null);\n+            \n+            assertEquals(DefaultNameProvider.class, DateTimeZone.getNameProvider().getClass());\n+            String str = new String(baos.toByteArray());\n+            assertTrue(str.indexOf(\"java.lang.ClassNotFoundException\") >= 0);\n+        } finally {\n+            System.setErr(syserr);\n+            System.getProperties().remove(\"org.joda.time.DateTimeZone.NameProvider\");\n+            DateTimeZone.setNameProvider(null);\n+            assertEquals(DefaultNameProvider.class, DateTimeZone.getNameProvider().getClass());\n+        }\n+    }        \n+    \n+    public void testNameProviderSecurity() {\n+        try {\n+            Policy.setPolicy(RESTRICT);\n+            System.setSecurityManager(new SecurityManager());\n+            DateTimeZone.setNameProvider(new MockOKButNullNameProvider());\n+            fail();\n+        } catch (SecurityException ex) {\n+            // ok\n+        } finally {\n+            System.setSecurityManager(null);\n+            Policy.setPolicy(ALLOW);\n+        }\n+    }\n+\n+    static class MockOKButNullNameProvider implements NameProvider {\n+        public String getShortName(Locale locale, String id, String nameKey) {\n+            return null;\n+        }\n+        public String getName(Locale locale, String id, String nameKey) {\n+            return null;\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testConstructor() {\n+        assertEquals(1, DateTimeZone.class.getDeclaredConstructors().length);\n+        assertTrue(Modifier.isProtected(DateTimeZone.class.getDeclaredConstructors()[0].getModifiers()));\n+        try {\n+            new DateTimeZone(null) {\n+                public String getNameKey(long instant) {\n+                    return null;\n+                }\n+                public int getOffset(long instant) {\n+                    return 0;\n+                }\n+                public int getStandardOffset(long instant) {\n+                    return 0;\n+                }\n+                public boolean isFixed() {\n+                    return false;\n+                }\n+                public long nextTransition(long instant) {\n+                    return 0;\n+                }\n+                public long previousTransition(long instant) {\n+                    return 0;\n+                }\n+                public boolean equals(Object object) {\n+                    return false;\n+                }\n+            };\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testGetID() {\n+        DateTimeZone zone = DateTimeZone.getInstance(\"Europe/Paris\");\n+        assertEquals(\"Europe/Paris\", zone.getID());\n+    }\n+\n+    public void testGetNameKey() {\n+        DateTimeZone zone = DateTimeZone.getInstance(\"Europe/London\");\n+        assertEquals(\"BST\", zone.getNameKey(TEST_TIME_SUMMER));\n+        assertEquals(\"GMT\", zone.getNameKey(TEST_TIME_WINTER));\n+    }\n+\n+    public void testGetShortName() {\n+        DateTimeZone zone = DateTimeZone.getInstance(\"Europe/London\");\n+        assertEquals(\"BST\", zone.getShortName(TEST_TIME_SUMMER));\n+        assertEquals(\"GMT\", zone.getShortName(TEST_TIME_WINTER));\n+        assertEquals(\"BST\", zone.getShortName(TEST_TIME_SUMMER, Locale.ENGLISH));\n+    }\n+            \n+    public void testGetShortNameProviderName() {\n+        assertEquals(null, DateTimeZone.getNameProvider().getShortName(null, \"Europe/London\", \"BST\"));\n+        assertEquals(null, DateTimeZone.getNameProvider().getShortName(Locale.ENGLISH, null, \"BST\"));\n+        assertEquals(null, DateTimeZone.getNameProvider().getShortName(Locale.ENGLISH, \"Europe/London\", null));\n+        assertEquals(null, DateTimeZone.getNameProvider().getShortName(null, null, null));\n+    }\n+    \n+    public void testGetShortNameNullKey() {\n+        DateTimeZone zone = new MockDateTimeZone(\"Europe/London\");\n+        assertEquals(\"Europe/London\", zone.getShortName(TEST_TIME_SUMMER, Locale.ENGLISH));\n+    }\n+    \n+    public void testGetName() {\n+        DateTimeZone zone = DateTimeZone.getInstance(\"Europe/London\");\n+        assertEquals(\"British Summer Time\", zone.getName(TEST_TIME_SUMMER));\n+        assertEquals(\"Greenwich Mean Time\", zone.getName(TEST_TIME_WINTER));\n+        assertEquals(\"British Summer Time\", zone.getName(TEST_TIME_SUMMER, Locale.ENGLISH));\n+        \n+    }\n+    \n+    public void testGetNameProviderName() {\n+        assertEquals(null, DateTimeZone.getNameProvider().getName(null, \"Europe/London\", \"BST\"));\n+        assertEquals(null, DateTimeZone.getNameProvider().getName(Locale.ENGLISH, null, \"BST\"));\n+        assertEquals(null, DateTimeZone.getNameProvider().getName(Locale.ENGLISH, \"Europe/London\", null));\n+        assertEquals(null, DateTimeZone.getNameProvider().getName(null, null, null));\n+    }\n+    \n+    public void testGetNameNullKey() {\n+        DateTimeZone zone = new MockDateTimeZone(\"Europe/London\");\n+        assertEquals(\"Europe/London\", zone.getName(TEST_TIME_SUMMER, Locale.ENGLISH));\n+    }\n+    \n+    static class MockDateTimeZone extends DateTimeZone {\n+        public MockDateTimeZone(String id) {\n+            super(id);\n+        }\n+        public String getNameKey(long instant) {\n+            return null;  // null\n+        }\n+        public int getOffset(long instant) {\n+            return 0;\n+        }\n+        public int getStandardOffset(long instant) {\n+            return 0;\n+        }\n+        public boolean isFixed() {\n+            return false;\n+        }\n+        public long nextTransition(long instant) {\n+            return 0;\n+        }\n+        public long previousTransition(long instant) {\n+            return 0;\n+        }\n+        public boolean equals(Object object) {\n+            return false;\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testGetOffset() {\n+        DateTimeZone zone = DateTimeZone.getInstance(\"Europe/Paris\");\n+        assertEquals(2L * DateTimeConstants.MILLIS_PER_HOUR, zone.getOffset(TEST_TIME_SUMMER));\n+        assertEquals(1L * DateTimeConstants.MILLIS_PER_HOUR, zone.getOffset(TEST_TIME_WINTER));\n+        \n+        assertEquals(2L * DateTimeConstants.MILLIS_PER_HOUR, zone.getOffset(new Instant(TEST_TIME_SUMMER)));\n+        assertEquals(1L * DateTimeConstants.MILLIS_PER_HOUR, zone.getOffset(new Instant(TEST_TIME_WINTER)));\n+        \n+        assertEquals(zone.getOffset(DateTimeUtils.currentTimeMillis()), zone.getOffset(null));\n+        \n+        assertEquals(1L * DateTimeConstants.MILLIS_PER_HOUR, zone.getStandardOffset(TEST_TIME_SUMMER));\n+        assertEquals(1L * DateTimeConstants.MILLIS_PER_HOUR, zone.getStandardOffset(TEST_TIME_WINTER));\n+        \n+        assertEquals(2L * DateTimeConstants.MILLIS_PER_HOUR, zone.getOffsetFromLocal(TEST_TIME_SUMMER));\n+        assertEquals(1L * DateTimeConstants.MILLIS_PER_HOUR, zone.getOffsetFromLocal(TEST_TIME_WINTER));\n+    }\n+\n+    public void testGetOffsetFixed() {\n+        DateTimeZone zone = DateTimeZone.getInstance(\"+01:00\");\n+        assertEquals(1L * DateTimeConstants.MILLIS_PER_HOUR, zone.getOffset(TEST_TIME_SUMMER));\n+        assertEquals(1L * DateTimeConstants.MILLIS_PER_HOUR, zone.getOffset(TEST_TIME_WINTER));\n+        \n+        assertEquals(1L * DateTimeConstants.MILLIS_PER_HOUR, zone.getOffset(new Instant(TEST_TIME_SUMMER)));\n+        assertEquals(1L * DateTimeConstants.MILLIS_PER_HOUR, zone.getOffset(new Instant(TEST_TIME_WINTER)));\n+        \n+        assertEquals(zone.getOffset(DateTimeUtils.currentTimeMillis()), zone.getOffset(null));\n+        \n+        assertEquals(1L * DateTimeConstants.MILLIS_PER_HOUR, zone.getStandardOffset(TEST_TIME_SUMMER));\n+        assertEquals(1L * DateTimeConstants.MILLIS_PER_HOUR, zone.getStandardOffset(TEST_TIME_WINTER));\n+        \n+        assertEquals(1L * DateTimeConstants.MILLIS_PER_HOUR, zone.getOffsetFromLocal(TEST_TIME_SUMMER));\n+        assertEquals(1L * DateTimeConstants.MILLIS_PER_HOUR, zone.getOffsetFromLocal(TEST_TIME_WINTER));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testIsFixed() {\n+        DateTimeZone zone = DateTimeZone.getInstance(\"Europe/Paris\");\n+        assertEquals(false, zone.isFixed());\n+        assertEquals(true, DateTimeZone.UTC.isFixed());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testTransitionFixed() {\n+        DateTimeZone zone = DateTimeZone.getInstance(\"+01:00\");\n+        assertEquals(TEST_TIME_SUMMER, zone.nextTransition(TEST_TIME_SUMMER));\n+        assertEquals(TEST_TIME_WINTER, zone.nextTransition(TEST_TIME_WINTER));\n+        assertEquals(TEST_TIME_SUMMER, zone.previousTransition(TEST_TIME_SUMMER));\n+        assertEquals(TEST_TIME_WINTER, zone.previousTransition(TEST_TIME_WINTER));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testToTimeZone() {\n+        DateTimeZone zone = DateTimeZone.getInstance(\"Europe/Paris\");\n+        TimeZone tz = zone.toTimeZone();\n+        assertEquals(\"Europe/Paris\", tz.getID());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testEqualsHashCode() {\n+        DateTimeZone zone1 = DateTimeZone.getInstance(\"Europe/Paris\");\n+        DateTimeZone zone2 = DateTimeZone.getInstance(\"Europe/Paris\");\n+        assertEquals(true, zone1.equals(zone1));\n+        assertEquals(true, zone1.equals(zone2));\n+        assertEquals(true, zone2.equals(zone1));\n+        assertEquals(true, zone2.equals(zone2));\n+        assertEquals(true, zone1.hashCode() == zone2.hashCode());\n+        \n+        DateTimeZone zone3 = DateTimeZone.getInstance(\"Europe/London\");\n+        assertEquals(true, zone3.equals(zone3));\n+        assertEquals(false, zone1.equals(zone3));\n+        assertEquals(false, zone2.equals(zone3));\n+        assertEquals(false, zone3.equals(zone1));\n+        assertEquals(false, zone3.equals(zone2));\n+        assertEquals(false, zone1.hashCode() == zone3.hashCode());\n+        assertEquals(true, zone3.hashCode() == zone3.hashCode());\n+        \n+        DateTimeZone zone4 = DateTimeZone.getInstance(\"+01:00\");\n+        assertEquals(true, zone4.equals(zone4));\n+        assertEquals(false, zone1.equals(zone4));\n+        assertEquals(false, zone2.equals(zone4));\n+        assertEquals(false, zone3.equals(zone4));\n+        assertEquals(false, zone4.equals(zone1));\n+        assertEquals(false, zone4.equals(zone2));\n+        assertEquals(false, zone4.equals(zone3));\n+        assertEquals(false, zone1.hashCode() == zone4.hashCode());\n+        assertEquals(true, zone4.hashCode() == zone4.hashCode());\n+        \n+        DateTimeZone zone5 = DateTimeZone.getInstance(\"+02:00\");\n+        assertEquals(true, zone5.equals(zone5));\n+        assertEquals(false, zone1.equals(zone5));\n+        assertEquals(false, zone2.equals(zone5));\n+        assertEquals(false, zone3.equals(zone5));\n+        assertEquals(false, zone4.equals(zone5));\n+        assertEquals(false, zone5.equals(zone1));\n+        assertEquals(false, zone5.equals(zone2));\n+        assertEquals(false, zone5.equals(zone3));\n+        assertEquals(false, zone5.equals(zone5));\n+        assertEquals(false, zone1.hashCode() == zone5.hashCode());\n+        assertEquals(true, zone5.hashCode() == zone5.hashCode());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testToString() {\n+        DateTimeZone zone = DateTimeZone.getInstance(\"Europe/Paris\");\n+        assertEquals(\"Europe/Paris\", zone.toString());\n+        assertEquals(\"UTC\", DateTimeZone.UTC.toString());\n+    }\n+\n+}", "timestamp": 1089847398, "metainfo": ""}