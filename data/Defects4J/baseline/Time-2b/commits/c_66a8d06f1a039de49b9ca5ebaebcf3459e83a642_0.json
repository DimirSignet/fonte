{"sha": "66a8d06f1a039de49b9ca5ebaebcf3459e83a642", "log": "Bug fix for parsing two digit year pattern with more or less than two digits.   ", "commit": "\n--- a/JodaTime/src/java/org/joda/time/format/DateTimeFormat.java\n+++ b/JodaTime/src/java/org/joda/time/format/DateTimeFormat.java\n                     DateTimeFieldType type;\n                     switch (c) {\n                     case 'x':\n-                        builder.appendTwoDigitWeekyear(new DateTime().getWeekyear() - 30);\n+                        builder.appendTwoDigitWeekyear(new DateTime().getWeekyear() - 30, true);\n                         break;\n                     case 'y':\n                     case 'Y':\n                     default:\n-                        builder.appendTwoDigitYear(new DateTime().getYear() - 30);\n+                        builder.appendTwoDigitYear(new DateTime().getYear() - 30, true);\n                         break;\n                     }\n                 } else {\n--- a/JodaTime/src/java/org/joda/time/format/DateTimeFormatterBuilder.java\n+++ b/JodaTime/src/java/org/joda/time/format/DateTimeFormatterBuilder.java\n      * @return this DateTimeFormatterBuilder\n      */\n     public DateTimeFormatterBuilder appendTwoDigitYear(int pivot) {\n-        return append0(new TwoDigitYear(DateTimeFieldType.year(), pivot));\n+        return appendTwoDigitYear(pivot, false);\n+    }\n+\n+    /**\n+     * Instructs the printer to emit a numeric year field which always prints\n+     * two digits. A pivot year is used during parsing to determine the range\n+     * of supported years as <code>(pivot - 50) .. (pivot + 49)</code>. If\n+     * parse is instructed to be lenient and the digit count is not two, it is\n+     * treated as an absolute year. With lenient parsing, specifying a positive\n+     * or negative sign before the year also makes it absolute.\n+     *\n+     * @param pivot  pivot year to use when parsing\n+     * @param lenientParse  when true, if digit count is not two, it is treated\n+     * as an absolute year\n+     * @return this DateTimeFormatterBuilder\n+     */\n+    public DateTimeFormatterBuilder appendTwoDigitYear(int pivot, boolean lenientParse) {\n+        return append0(new TwoDigitYear(DateTimeFieldType.year(), pivot, lenientParse));\n     }\n \n     /**\n      * @return this DateTimeFormatterBuilder\n      */\n     public DateTimeFormatterBuilder appendTwoDigitWeekyear(int pivot) {\n-        return append0(new TwoDigitYear(DateTimeFieldType.weekyear(), pivot));\n+        return appendTwoDigitWeekyear(pivot, false);\n+    }\n+\n+    /**\n+     * Instructs the printer to emit a numeric weekyear field which always prints\n+     * two digits. A pivot year is used during parsing to determine the range\n+     * of supported years as <code>(pivot - 50) .. (pivot + 49)</code>. If\n+     * parse is instructed to be lenient and the digit count is not two, it is\n+     * treated as an absolute weekyear. With lenient parsing, specifying a positive\n+     * or negative sign before the weekyear also makes it absolute.\n+     *\n+     * @param pivot  pivot weekyear to use when parsing\n+     * @param lenientParse  when true, if digit count is not two, it is treated\n+     * as an absolute weekyear\n+     * @return this DateTimeFormatterBuilder\n+     */\n+    public DateTimeFormatterBuilder appendTwoDigitWeekyear(int pivot, boolean lenientParse) {\n+        return append0(new TwoDigitYear(DateTimeFieldType.weekyear(), pivot, lenientParse));\n     }\n \n     /**\n             if (length >= 9) {\n                 // Since value may exceed integer limits, use stock parser\n                 // which checks for this.\n-                value = Integer.parseInt\n-                    (text.substring(position, position += length));\n+                value = Integer.parseInt(text.substring(position, position += length));\n             } else {\n                 int i = position;\n                 if (negative) {\n                     i++;\n                 }\n-                value = text.charAt(i++) - '0';\n+                try {\n+                    value = text.charAt(i++) - '0';\n+                } catch (StringIndexOutOfBoundsException e) {\n+                    return ~position;\n+                }\n                 position += length;\n                 while (i < position) {\n                     value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0';\n         private final DateTimeFieldType iType;\n         /** The pivot year. */\n         private final int iPivot;\n-\n-        TwoDigitYear(DateTimeFieldType type, int pivot) {\n+        private final boolean iLenientParse;\n+\n+        TwoDigitYear(DateTimeFieldType type, int pivot, boolean lenientParse) {\n             super();\n             iType = type;\n             iPivot = pivot;\n+            iLenientParse = lenientParse;\n         }\n \n         public int estimateParsedLength() {\n-            return 2;\n+            return iLenientParse ? 4 : 2;\n         }\n \n         public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n+            int limit = text.length() - position;\n+\n+            if (!iLenientParse) {\n+                limit = Math.min(2, limit);\n+                if (limit < 2) {\n+                    return ~position;\n+                }\n+            } else {\n+                boolean hasSignChar = false;\n+                boolean negative = false;\n+                int length = 0;\n+                while (length < limit) {\n+                    char c = text.charAt(position + length);\n+                    if (length == 0 && (c == '-' || c == '+')) {\n+                        hasSignChar = true;\n+                        negative = c == '-';\n+                        if (negative) {\n+                            length++;\n+                        } else {\n+                            // Skip the '+' for parseInt to succeed.\n+                            position++;\n+                            limit--;\n+                        }\n+                        continue;\n+                    }\n+                    if (c < '0' || c > '9') {\n+                        break;\n+                    }\n+                    length++;\n+                }\n+                \n+                if (length == 0) {\n+                    return ~position;\n+                }\n+\n+                if (hasSignChar || length != 2) {\n+                    int value;\n+                    if (length >= 9) {\n+                        // Since value may exceed integer limits, use stock\n+                        // parser which checks for this.\n+                        value = Integer.parseInt(text.substring(position, position += length));\n+                    } else {\n+                        int i = position;\n+                        if (negative) {\n+                            i++;\n+                        }\n+                        try {\n+                            value = text.charAt(i++) - '0';\n+                        } catch (StringIndexOutOfBoundsException e) {\n+                            return ~position;\n+                        }\n+                        position += length;\n+                        while (i < position) {\n+                            value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0';\n+                        }\n+                        if (negative) {\n+                            value = -value;\n+                        }\n+                    }\n+                    \n+                    bucket.saveField(iType, value);\n+                    return position;\n+                }\n+            }\n+\n+            int year;\n+            char c = text.charAt(position);\n+            if (c < '0' || c > '9') {\n+                return ~position;\n+            }\n+            year = c - '0';\n+            c = text.charAt(position + 1);\n+            if (c < '0' || c > '9') {\n+                return ~position;\n+            }\n+            year = ((year << 3) + (year << 1)) + c - '0';\n+\n             int pivot = iPivot;\n             // If the bucket pivot year is non-null, use that when parsing\n             if (bucket.getPivotYear() != null) {\n                 pivot = bucket.getPivotYear().intValue();\n             }\n-\n-            int limit = Math.min(2, text.length() - position);\n-            if (limit < 2) {\n-                return ~position;\n-            }\n-\n-            int year;\n-            char c = text.charAt(position);\n-            if (c < '0' || c > '9') {\n-                return ~position;\n-            }\n-            year = c - '0';\n-            c = text.charAt(position + 1);\n-            if (c < '0' || c > '9') {\n-                return ~position;\n-            }\n-            year = ((year << 3) + (year << 1)) + c - '0';\n \n             int low = pivot - 50;\n \n--- a/JodaTime/src/test/org/joda/time/format/TestDateTimeFormat.java\n+++ b/JodaTime/src/test/org/joda/time/format/TestDateTimeFormat.java\n         expect = new DateTime(2021, 1, 1, 0, 0, 0, 0, UTC);\n         assertEquals(expect, f.parseDateTime(\"21\"));\n \n-        /* Added tests for pivot year setting */\n+        // Added tests to ensure single sign digit parse fails properly\n+        try {\n+            f.parseDateTime(\"-\");\n+            fail();\n+        } catch (IllegalArgumentException e) { }\n+\n+        try {\n+            f.parseDateTime(\"+\");\n+            fail();\n+        } catch (IllegalArgumentException e) { }\n+\n+        // Added tests for pivot year setting\n         f = f.withPivotYear(new Integer(2050));\n         expect = new DateTime(2000, 1, 1, 0, 0, 0, 0, UTC);\n         assertEquals(expect, f.parseDateTime(\"00\"));\n         expect = new DateTime(2099, 1, 1, 0, 0, 0, 0, UTC);\n         assertEquals(expect, f.parseDateTime(\"99\"));\n \n+        // Added tests to ensure two digit parsing is lenient for DateTimeFormat\n+        f = DateTimeFormat.forPattern(\"YY\").withLocale(Locale.UK);\n+        f = f.withZone(UTC);\n+        f.parseDateTime(\"5\");\n+        f.parseDateTime(\"005\");\n+        f.parseDateTime(\"+50\");\n+        f.parseDateTime(\"-50\");\n     }\n \n     //-----------------------------------------------------------------------\n         \n         dt = new DateTime(-123, 6, 9, 10, 20, 30, 40, UTC);\n         assertEquals(dt.toString(), \"-123\", f.print(dt));\n+\n+        // Added tests to ensure single sign digit parse fails properly\n+        try {\n+            f.parseDateTime(\"-\");\n+            fail();\n+        } catch (IllegalArgumentException e) { }\n+\n+        try {\n+            f.parseDateTime(\"+\");\n+            fail();\n+        } catch (IllegalArgumentException e) { }\n     }\n \n     public void testFormat_year_twoDigit() {\n         expect = new DateTime(2021, 1, 1, 0, 0, 0, 0, UTC);\n         assertEquals(expect, f.parseDateTime(\"21\"));\n \n-        /* Added tests for pivot year setting */\n+        // Added tests to ensure single sign digit parse fails properly\n+        try {\n+            f.parseDateTime(\"-\");\n+            fail();\n+        } catch (IllegalArgumentException e) { }\n+\n+        try {\n+            f.parseDateTime(\"+\");\n+            fail();\n+        } catch (IllegalArgumentException e) { }\n+\n+        // Added tests for pivot year setting\n         f = f.withPivotYear(new Integer(2050));\n         expect = new DateTime(2000, 1, 1, 0, 0, 0, 0, UTC);\n         assertEquals(expect, f.parseDateTime(\"00\"));\n \n         expect = new DateTime(2099, 1, 1, 0, 0, 0, 0, UTC);\n         assertEquals(expect, f.parseDateTime(\"99\"));\n+\n+        // Added tests to ensure two digit parsing is strict by default for\n+        // DateTimeFormatterBuilder\n+        f = new DateTimeFormatterBuilder().appendTwoDigitYear(2000).toFormatter();\n+        f = f.withZone(UTC);\n+        try {\n+            f.parseDateTime(\"5\");\n+            fail();\n+        } catch (IllegalArgumentException e) { }\n+        try {\n+            f.parseDateTime(\"005\");\n+            fail();\n+        } catch (IllegalArgumentException e) { }\n+        try {\n+            f.parseDateTime(\"+50\");\n+            fail();\n+        } catch (IllegalArgumentException e) { }\n+        try {\n+            f.parseDateTime(\"-50\");\n+            fail();\n+        } catch (IllegalArgumentException e) { }\n+\n+        // Added tests to ensure two digit parsing is lenient for DateTimeFormat\n+        f = DateTimeFormat.forPattern(\"yy\").withLocale(Locale.UK);\n+        f = f.withZone(UTC);\n+        f.parseDateTime(\"5\");\n+        f.parseDateTime(\"005\");\n+        f.parseDateTime(\"+50\");\n+        f.parseDateTime(\"-50\");\n+\n+        // Added tests for lenient two digit parsing\n+        f = new DateTimeFormatterBuilder().appendTwoDigitYear(2000, true).toFormatter();\n+        f = f.withZone(UTC);\n+        expect = new DateTime(2004, 1, 1, 0, 0, 0, 0, UTC);\n+        assertEquals(expect, f.parseDateTime(\"04\"));\n+\n+        expect = new DateTime(4, 1, 1, 0, 0, 0, 0, UTC);\n+        assertEquals(expect, f.parseDateTime(\"+04\"));\n+\n+        expect = new DateTime(-4, 1, 1, 0, 0, 0, 0, UTC);\n+        assertEquals(expect, f.parseDateTime(\"-04\"));\n+\n+        expect = new DateTime(4, 1, 1, 0, 0, 0, 0, UTC);\n+        assertEquals(expect, f.parseDateTime(\"4\"));\n+\n+        expect = new DateTime(-4, 1, 1, 0, 0, 0, 0, UTC);\n+        assertEquals(expect, f.parseDateTime(\"-4\"));\n+\n+        expect = new DateTime(4, 1, 1, 0, 0, 0, 0, UTC);\n+        assertEquals(expect, f.parseDateTime(\"004\"));\n+\n+        expect = new DateTime(4, 1, 1, 0, 0, 0, 0, UTC);\n+        assertEquals(expect, f.parseDateTime(\"+004\"));\n+\n+        expect = new DateTime(-4, 1, 1, 0, 0, 0, 0, UTC);\n+        assertEquals(expect, f.parseDateTime(\"-004\"));\n+\n+        expect = new DateTime(3004, 1, 1, 0, 0, 0, 0, UTC);\n+        assertEquals(expect, f.parseDateTime(\"3004\"));\n+\n+        expect = new DateTime(3004, 1, 1, 0, 0, 0, 0, UTC);\n+        assertEquals(expect, f.parseDateTime(\"+3004\"));\n+\n+        expect = new DateTime(-3004, 1, 1, 0, 0, 0, 0, UTC);\n+        assertEquals(expect, f.parseDateTime(\"-3004\"));\n+\n+        try {\n+            f.parseDateTime(\"-\");\n+            fail();\n+        } catch (IllegalArgumentException e) { }\n+\n+        try {\n+            f.parseDateTime(\"+\");\n+            fail();\n+        } catch (IllegalArgumentException e) { }\n     }\n \n     public void testFormat_year_long() {\n         expect = new DateTime(2021, 1, 4, 0, 0, 0, 0, UTC);\n         assertEquals(expect, f.parseDateTime(\"21\"));\n \n-        /* Added tests for pivot year setting */\n+        // Added tests to ensure single sign digit parse fails properly\n+        try {\n+            f.parseDateTime(\"-\");\n+            fail();\n+        } catch (IllegalArgumentException e) { }\n+\n+        try {\n+            f.parseDateTime(\"+\");\n+            fail();\n+        } catch (IllegalArgumentException e) { }\n+\n+        // Added tests for pivot year setting\n         f = f.withPivotYear(new Integer(2050));\n         expect = new DateTime(2000, 1, 3, 0, 0, 0, 0, DateTimeZone.UTC);\n         assertEquals(expect, f.parseDateTime(\"00\"));\n \n         expect = new DateTime(2098, 12, 29, 0, 0, 0, 0, DateTimeZone.UTC);\n         assertEquals(expect, f.parseDateTime(\"99\"));\n+\n+        // Added tests to ensure two digit parsing is strict by default for\n+        // DateTimeFormatterBuilder\n+        f = new DateTimeFormatterBuilder().appendTwoDigitWeekyear(2000).toFormatter();\n+        f = f.withZone(UTC);\n+        try {\n+            f.parseDateTime(\"5\");\n+            fail();\n+        } catch (IllegalArgumentException e) { }\n+        try {\n+            f.parseDateTime(\"005\");\n+            fail();\n+        } catch (IllegalArgumentException e) { }\n+        try {\n+            f.parseDateTime(\"+50\");\n+            fail();\n+        } catch (IllegalArgumentException e) { }\n+        try {\n+            f.parseDateTime(\"-50\");\n+            fail();\n+        } catch (IllegalArgumentException e) { }\n+\n+        // Added tests to ensure two digit parsing is lenient for DateTimeFormat\n+        f = DateTimeFormat.forPattern(\"xx\").withLocale(Locale.UK);\n+        f = f.withZone(UTC);\n+        f.parseDateTime(\"5\");\n+        f.parseDateTime(\"005\");\n+        f.parseDateTime(\"+50\");\n+        f.parseDateTime(\"-50\");\n+\n+        // Added tests for lenient two digit parsing\n+        f = new DateTimeFormatterBuilder().appendTwoDigitWeekyear(2000, true).toFormatter();\n+        f = f.withZone(UTC);\n+        expect = new DateTime(2003, 12, 29, 0, 0, 0, 0, UTC);\n+        assertEquals(expect, f.parseDateTime(\"04\"));\n+\n+        expect = new DateTime(3, 12, 29, 0, 0, 0, 0, UTC);\n+        assertEquals(expect, f.parseDateTime(\"+04\"));\n+\n+        expect = new DateTime(-4, 1, 1, 0, 0, 0, 0, UTC);\n+        assertEquals(expect, f.parseDateTime(\"-04\"));\n+\n+        expect = new DateTime(3, 12, 29, 0, 0, 0, 0, UTC);\n+        assertEquals(expect, f.parseDateTime(\"4\"));\n+\n+        expect = new DateTime(-4, 1, 1, 0, 0, 0, 0, UTC);\n+        assertEquals(expect, f.parseDateTime(\"-4\"));\n+\n+        expect = new DateTime(3, 12, 29, 0, 0, 0, 0, UTC);\n+        assertEquals(expect, f.parseDateTime(\"004\"));\n+\n+        expect = new DateTime(3, 12, 29, 0, 0, 0, 0, UTC);\n+        assertEquals(expect, f.parseDateTime(\"+004\"));\n+\n+        expect = new DateTime(-4, 1, 1, 0, 0, 0, 0, UTC);\n+        assertEquals(expect, f.parseDateTime(\"-004\"));\n+\n+        expect = new DateTime(3004, 1, 2, 0, 0, 0, 0, UTC);\n+        assertEquals(expect, f.parseDateTime(\"3004\"));\n+\n+        expect = new DateTime(3004, 1, 2, 0, 0, 0, 0, UTC);\n+        assertEquals(expect, f.parseDateTime(\"+3004\"));\n+\n+        expect = new DateTime(-3004, 1, 4, 0, 0, 0, 0, UTC);\n+        assertEquals(expect, f.parseDateTime(\"-3004\"));\n+\n+        try {\n+            f.parseDateTime(\"-\");\n+            fail();\n+        } catch (IllegalArgumentException e) { }\n+\n+        try {\n+            f.parseDateTime(\"+\");\n+            fail();\n+        } catch (IllegalArgumentException e) { }\n     }\n \n     //-----------------------------------------------------------------------", "timestamp": 1113758847, "metainfo": ""}