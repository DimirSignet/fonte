{"sha": "043abebe138fcbacd6448c1664b0eab1e15184e8", "log": "Test and fix bugs in Buddhist Chronology   ", "commit": "\n--- a/JodaTime/src/java/org/joda/time/chrono/BuddhistChronology.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/BuddhistChronology.java\n import org.joda.time.DateTimeField;\n import org.joda.time.DateTimeFieldType;\n import org.joda.time.DateTimeZone;\n+import org.joda.time.field.DelegatedDateTimeField;\n import org.joda.time.field.DividedDateTimeField;\n import org.joda.time.field.OffsetDateTimeField;\n import org.joda.time.field.RemainderDateTimeField;\n+import org.joda.time.field.SkipUndoDateTimeField;\n \n /**\n- * Implements the Buddhist calendar system, which is similar to Gregorian/Julian,\n- * except with the year offset by 543.\n- * <p>\n- * The Buddhist calendar differs from the Gregorian/Julian calendar only \n- * in the year. This class is compatable with the BuddhistCalendar class \n- * supplied by Sun.\n+ * A chronology that matches the BuddhistCalendar class supplied by Sun.\n+ * <p>\n+ * The chronology is identical to the Gregorian/Julian, except that the\n+ * year is offset by +543 and the era is named 'BE' for Buddhist Era.\n+ * <p>\n+ * This class was intended by Sun to model the calendar used in Thailand.\n+ * However, the actual rules for Thailand are much more involved than\n+ * this class covers. (This class is accurate after 1941-01-01 ISO).\n+ * <p>\n+ * This chronlogy is being retained for those who want a same effect\n+ * replacement for the Sun class. It is hoped that community support will\n+ * enable a more accurate chronology for Thailand, to be developed.\n  * <p>\n  * BuddhistChronology is thread-safe and immutable.\n  *\n \n     protected void assemble(Fields fields) {\n         if (getParam() == null) {\n+            // julian chrono removed zero, but we need to put it back\n             DateTimeField field = fields.year;\n-            fields.year = new OffsetDateTimeField(field, BUDDHIST_OFFSET);\n-            \n+            fields.year = new OffsetDateTimeField(\n+                    new SkipUndoDateTimeField(this, field), BUDDHIST_OFFSET);\n+            \n+            // one era, so yearOfEra is the same\n             field = fields.yearOfEra;\n-            fields.yearOfEra = new OffsetDateTimeField(\n-                fields.year, DateTimeFieldType.yearOfEra(), BUDDHIST_OFFSET);\n-            \n+            fields.yearOfEra = new DelegatedDateTimeField(\n+                fields.year, DateTimeFieldType.yearOfEra());\n+            \n+            // julian chrono removed zero, but we need to put it back\n             field = fields.weekyear;\n-            fields.weekyear = new OffsetDateTimeField(field, BUDDHIST_OFFSET);\n+            fields.weekyear = new OffsetDateTimeField(\n+                    new SkipUndoDateTimeField(this, field), BUDDHIST_OFFSET);\n             \n             field = new OffsetDateTimeField(fields.yearOfEra, 99);\n             fields.centuryOfEra = new DividedDateTimeField(\n--- a/JodaTime/src/java/org/joda/time/field/DelegatedDateTimeField.java\n+++ b/JodaTime/src/java/org/joda/time/field/DelegatedDateTimeField.java\n      * \n      * @param field  the field being decorated\n      */\n-    protected DelegatedDateTimeField(DateTimeField field) {\n+    public DelegatedDateTimeField(DateTimeField field) {\n         this(field, null);\n     }\n \n      * @param field  the field being decorated\n      * @param type  the field type override\n      */\n-    protected DelegatedDateTimeField(DateTimeField field, DateTimeFieldType type) {\n+    public DelegatedDateTimeField(DateTimeField field, DateTimeFieldType type) {\n         super();\n         if (field == null) {\n             throw new IllegalArgumentException(\"The field must not be null\");\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/field/SkipUndoDateTimeField.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2005 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.field;\n+\n+import org.joda.time.Chronology;\n+import org.joda.time.DateTimeField;\n+\n+/**\n+ * Wraps another field such that a certain value is added back into\n+ * the sequence of numbers.\n+ * <p>\n+ * This reverses the effect of SkipDateTimeField. This isn't very\n+ * elegant.\n+ * <p>\n+ * SkipUndoDateTimeField is thread-safe and immutable.\n+ *\n+ * @author Brian S O'Neill\n+ * @author Stephen Colebourne\n+ * @since 1.0\n+ */\n+public final class SkipUndoDateTimeField extends DelegatedDateTimeField {\n+\n+    /** Serialization version. */\n+    private static final long serialVersionUID = -5875876968979L;\n+\n+    /** The chronology to wrap. */\n+    private final Chronology iChronology;\n+    /** The value to skip. */\n+    private final int iSkip;\n+    /** The calculated minimum value. */\n+    private transient int iMinValue;\n+\n+    /**\n+     * Constructor that reinserts zero.\n+     * \n+     * @param chronology  the chronoogy to use\n+     * @param field  the field to skip zero on\n+     */\n+    public SkipUndoDateTimeField(Chronology chronology, DateTimeField field) {\n+        this(chronology, field, 0);\n+    }\n+\n+    /**\n+     * Constructor.\n+     * \n+     * @param chronology  the chronoogy to use\n+     * @param field  the field to skip zero on\n+     * @param skip  the value to skip\n+     */\n+    public SkipUndoDateTimeField(Chronology chronology, DateTimeField field, int skip) {\n+        super(field);\n+        iChronology = chronology;\n+        int min = super.getMinimumValue();\n+        if (min < skip) {\n+            iMinValue = min + 1;\n+        } else if (min == skip + 1) {\n+            iMinValue = skip;\n+        } else {\n+            iMinValue = min;\n+        }\n+        iSkip = skip;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public int get(long millis) {\n+        int value = super.get(millis);\n+        if (value < iSkip) {\n+            value++;\n+        }\n+        return value;\n+    }\n+\n+    public long set(long millis, int value) {\n+        FieldUtils.verifyValueBounds(this, value, iMinValue, getMaximumValue());\n+        if (value <= iSkip) {\n+            value--;\n+        }\n+        return super.set(millis, value);\n+    }\n+\n+    public int getMinimumValue() {\n+        return iMinValue;\n+    }\n+\n+    private Object readResolve() {\n+        return getType().getField(iChronology);\n+    }\n+\n+}\n--- a/JodaTime/src/test/org/joda/time/chrono/TestBuddhistChronology.java\n+++ b/JodaTime/src/test/org/joda/time/chrono/TestBuddhistChronology.java\n  * Joda Software License, Version 1.0\n  *\n  *\n- * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * Copyright (c) 2001-2005 Stephen Colebourne.  \n  * All rights reserved.\n  *\n  * Redistribution and use in source and binary forms, with or without\n import junit.framework.TestCase;\n import junit.framework.TestSuite;\n \n+import org.joda.time.Chronology;\n+import org.joda.time.DateTime;\n import org.joda.time.DateTimeConstants;\n+import org.joda.time.DateTimeField;\n import org.joda.time.DateTimeUtils;\n import org.joda.time.DateTimeZone;\n+import org.joda.time.Period;\n \n /**\n  * This class is a Junit unit test for BuddhistChronology.\n     private static final DateTimeZone PARIS = DateTimeZone.getInstance(\"Europe/Paris\");\n     private static final DateTimeZone LONDON = DateTimeZone.getInstance(\"Europe/London\");\n     private static final DateTimeZone TOKYO = DateTimeZone.getInstance(\"Asia/Tokyo\");\n+    private static final Chronology BUDDHIST_UTC = Chronology.getBuddhistUTC();\n+    private static final Chronology COPTIC_UTC = Chronology.getCopticUTC();\n+    private static final Chronology JULIAN_UTC = Chronology.getJulianUTC();\n+    private static final Chronology GJ_UTC = Chronology.getGJUTC();\n+    private static final Chronology ISO_UTC = Chronology.getISOUTC();\n \n     long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + \n                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + \n         assertEquals(true, BuddhistChronology.getInstance().millisOfSecond().isSupported());\n     }\n \n+    //-----------------------------------------------------------------------\n+    public void testEpoch() {\n+        DateTime epoch = new DateTime(1, 1, 1, 0, 0, 0, 0, BUDDHIST_UTC);\n+        assertEquals(new DateTime(-543, 1, 1, 0, 0, 0, 0, JULIAN_UTC), epoch.withChronology(JULIAN_UTC));\n+    }\n+\n+    public void testEra() {\n+        assertEquals(1, BuddhistChronology.BE);\n+        try {\n+            new DateTime(-1, 13, 5, 0, 0, 0, 0, BUDDHIST_UTC);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    public void testKeyYears() {\n+        DateTime bd = new DateTime(2513, 1, 1, 0, 0, 0, 0, BUDDHIST_UTC);\n+        DateTime jd = new DateTime(1970, 1, 1, 0, 0, 0, 0, GJ_UTC);\n+        assertEquals(jd, bd.withChronology(GJ_UTC));\n+        assertEquals(2513, bd.getYear());\n+        assertEquals(2513, bd.getYearOfEra());\n+        assertEquals(2513, bd.plus(Period.weeks(1)).getWeekyear());\n+        \n+        bd = new DateTime(2126, 1, 1, 0, 0, 0, 0, BUDDHIST_UTC);\n+        jd = new DateTime(1583, 1, 1, 0, 0, 0, 0, GJ_UTC);\n+        assertEquals(jd, bd.withChronology(GJ_UTC));\n+        assertEquals(2126, bd.getYear());\n+        assertEquals(2126, bd.getYearOfEra());\n+        assertEquals(2126, bd.plus(Period.weeks(1)).getWeekyear());\n+        \n+        bd = new DateTime(2125, 1, 1, 0, 0, 0, 0, BUDDHIST_UTC);\n+        jd = new DateTime(1582, 1, 1, 0, 0, 0, 0, GJ_UTC);\n+        assertEquals(jd, bd.withChronology(GJ_UTC));\n+        assertEquals(2125, bd.getYear());\n+        assertEquals(2125, bd.getYearOfEra());\n+        assertEquals(2125, bd.plus(Period.weeks(1)).getWeekyear());\n+        \n+        bd = new DateTime(544, 1, 1, 0, 0, 0, 0, BUDDHIST_UTC);\n+        jd = new DateTime(1, 1, 1, 0, 0, 0, 0, GJ_UTC);\n+        assertEquals(jd, bd.withChronology(GJ_UTC));\n+        assertEquals(544, bd.getYear());\n+        assertEquals(544, bd.getYearOfEra());\n+        assertEquals(544, bd.plus(Period.weeks(1)).getWeekyear());\n+        \n+        bd = new DateTime(543, 1, 1, 0, 0, 0, 0, BUDDHIST_UTC);\n+        jd = new DateTime(-1, 1, 1, 0, 0, 0, 0, GJ_UTC);\n+        assertEquals(jd, bd.withChronology(GJ_UTC));\n+        assertEquals(543, bd.getYear());\n+        assertEquals(543, bd.getYearOfEra());\n+        assertEquals(543, bd.plus(Period.weeks(1)).getWeekyear());\n+        \n+        bd = new DateTime(1, 1, 1, 0, 0, 0, 0, BUDDHIST_UTC);\n+        jd = new DateTime(-543, 1, 1, 0, 0, 0, 0, GJ_UTC);\n+        assertEquals(jd, bd.withChronology(GJ_UTC));\n+        assertEquals(1, bd.getYear());\n+        assertEquals(1, bd.getYearOfEra());\n+        assertEquals(1, bd.plus(Period.weeks(1)).getWeekyear());\n+    }\n+\n+    public void testCalendar() {\n+        System.out.println(\"\\nTestBuddhistChronology.testCalendar\");\n+        DateTime epoch = new DateTime(1, 1, 1, 0, 0, 0, 0, BUDDHIST_UTC);\n+        long oneDay = DateTimeConstants.MILLIS_PER_DAY;\n+        long millis = epoch.getMillis();\n+        long end = new DateTime(3000, 1, 1, 0, 0, 0, 0, ISO_UTC).getMillis();\n+        DateTimeField dayOfWeek = BUDDHIST_UTC.dayOfWeek();\n+        DateTimeField weekOfWeekyear = GJ_UTC.weekOfWeekyear();\n+        DateTimeField dayOfYear = BUDDHIST_UTC.dayOfYear();\n+        DateTimeField dayOfMonth = BUDDHIST_UTC.dayOfMonth();\n+        DateTimeField monthOfYear = BUDDHIST_UTC.monthOfYear();\n+        DateTimeField year = BUDDHIST_UTC.year();\n+        DateTimeField yearOfEra = BUDDHIST_UTC.yearOfEra();\n+        DateTimeField era = BUDDHIST_UTC.era();\n+        DateTimeField gjDayOfWeek = GJ_UTC.dayOfWeek();\n+        DateTimeField gjWeekOfWeekyear = GJ_UTC.weekOfWeekyear();\n+        DateTimeField gjDayOfYear = GJ_UTC.dayOfYear();\n+        DateTimeField gjDayOfMonth = GJ_UTC.dayOfMonth();\n+        DateTimeField gjMonthOfYear = GJ_UTC.monthOfYear();\n+        DateTimeField gjYear = GJ_UTC.year();\n+        DateTimeField gjYearOfEra = GJ_UTC.yearOfEra();\n+        DateTimeField gjEra = GJ_UTC.era();\n+        while (millis < end) {\n+            assertEquals(gjDayOfWeek.get(millis), dayOfWeek.get(millis));\n+            assertEquals(gjDayOfYear.get(millis), dayOfYear.get(millis));\n+            assertEquals(gjDayOfMonth.get(millis), dayOfMonth.get(millis));\n+            assertEquals(gjMonthOfYear.get(millis), monthOfYear.get(millis));\n+            assertEquals(gjWeekOfWeekyear.get(millis), weekOfWeekyear.get(millis));\n+            assertEquals(1, era.get(millis));\n+            int yearValue = gjYear.get(millis);\n+            if (yearValue <= 0) {\n+                yearValue++;\n+            }\n+            yearValue += 543;\n+            assertEquals(yearValue, year.get(millis));\n+            assertEquals(yearValue, yearOfEra.get(millis));\n+            millis += oneDay;\n+        }\n+    }\n+\n }", "timestamp": 1107628998, "metainfo": ""}