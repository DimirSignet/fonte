{"sha": "fecb52131ddbfef462a71375fa1124f83c030668", "log": "Remove null restrictions, javadoc and tidy prior to testing   ", "commit": "\n--- a/JodaTime/src/java/org/joda/time/AbstractInterval.java\n+++ b/JodaTime/src/java/org/joda/time/AbstractInterval.java\n  * @since 1.0\n  */\n public abstract class AbstractInterval implements ReadableInterval {\n-    \n+\n     /** The start of the period */\n     private long iStartMillis;\n     /** The end of the period */\n     private transient Instant iStartInstant;\n     /** Cache the end instant */\n     private transient Instant iEndInstant;\n-    \n+\n     /**\n      * Constructs a time interval as a copy of another.\n      * \n-     * @param interval the time interval to copy\n-     * @throws IllegalArgumentException if the interval is null\n-     */\n-    public AbstractInterval(ReadableInterval interval) {\n-        super();\n-        if (interval == null) {\n-            throw new IllegalArgumentException(\"The interval must not be null\");\n-        }\n-        iStartMillis = interval.getStartMillis();\n-        iEndMillis = interval.getEndMillis();\n-        Duration duration = interval.getDuration();\n-        if (duration != null && duration.isPrecise()) {\n-            iDuration = duration;\n-        }\n-    }\n-    \n-    /**\n-     * Constructs a time interval as a copy of another.\n-     * \n      * @param interval the time interval to convert\n-     * @throws IllegalArgumentException if the interval is null\n+     * @throws IllegalArgumentException if the interval is null or invalid\n      */\n     public AbstractInterval(Object interval) {\n         super();\n         iStartMillis = startInstant;\n         iEndMillis = endInstant;\n     }\n-    \n+\n     /**\n      * Constructs an interval from a start and end instant.\n      * \n-     * @param start  start of this interval\n-     * @param end  end of this interval\n-     * @throws IllegalArgumentException if either instant is null\n+     * @param start  start of this interval, null means now\n+     * @param end  end of this interval, null means now\n      */\n     public AbstractInterval(ReadableInstant start, ReadableInstant end) {\n         super();\n-        if (start == null) {\n-            throw new IllegalArgumentException(\"The start instant must not be null\");\n-        }\n-        if (end == null) {\n-            throw new IllegalArgumentException(\"The end instant must not be null\");\n-        }\n-        iStartMillis = start.getMillis();\n-        if (start instanceof Instant) {\n-            iStartInstant = (Instant) start;\n-        }\n-        iEndMillis = end.getMillis();\n-        if (end instanceof Instant) {\n-            iEndInstant = (Instant) end;\n-        }\n-    }\n-    \n+        if (start == null && end == null) {\n+            iStartMillis = DateTimeUtils.currentTimeMillis();\n+            iEndMillis = iStartMillis;\n+        } else {\n+            if (start == null) {\n+                iStartMillis = DateTimeUtils.currentTimeMillis();\n+            } else {\n+                iStartMillis = start.getMillis();\n+                if (start instanceof Instant) {\n+                    iStartInstant = (Instant) start;\n+                }\n+            }\n+            if (end == null) {\n+                iEndMillis = DateTimeUtils.currentTimeMillis();\n+            } else {\n+                iEndMillis = end.getMillis();\n+                if (end instanceof Instant) {\n+                    iEndInstant = (Instant) end;\n+                }\n+            }\n+        }\n+    }\n+\n     /**\n      * Constructs an interval from a start instant and a duration.\n-     * \n-     * @param start  start of this interval\n-     * @param duration  duration of this interval\n-     * @throws IllegalArgumentException if start or duration is null\n+     * <p>\n+     * When forming the interval, the chronology from the instant is used\n+     * if present, otherwise the chronology of the duration is used.\n+     * \n+     * @param start  start of this interval, null means now\n+     * @param duration  duration of this interval, null means zero length\n      */\n     public AbstractInterval(ReadableInstant start, ReadableDuration duration) {\n         super();\n+        Chronology chrono = null;\n         if (start == null) {\n-            throw new IllegalArgumentException(\"The start instant must not be null\");\n+            iStartMillis = DateTimeUtils.currentTimeMillis();\n+        } else {\n+            iStartMillis = start.getMillis();\n+            chrono = start.getChronology();\n+            if (start instanceof Instant) {\n+                iStartInstant = (Instant) start;\n+            }\n         }\n         if (duration == null) {\n-            throw new IllegalArgumentException(\"The duration must not be null\");\n-        }\n-        iStartMillis = start.getMillis();\n-        if (start instanceof Instant) {\n-            iStartInstant = (Instant) start;\n-        }\n-        iEndMillis = duration.addTo((ReadableInstant) start, 1).getMillis();\n-        if (duration.isPrecise()) {\n-            iDuration = duration.toDuration();\n-        }\n-    }\n-    \n+            iEndMillis = iStartMillis;\n+        } else {\n+            iEndMillis = duration.addTo(iStartMillis, 1, chrono);\n+            if (duration.isPrecise()) {\n+                iDuration = duration.toDuration();\n+            }\n+        }\n+    }\n+\n     /**\n      * Constructs an interval from a duration and an end instant.\n-     * \n-     * @param duration duration of this interval\n-     * @param end end of this interval\n-     * @throws IllegalArgumentException if duration or end is null\n+     * <p>\n+     * When forming the interval, the chronology from the instant is used\n+     * if present, otherwise the chronology of the duration is used.\n+     * \n+     * @param duration  duration of this interval, null means zero length\n+     * @param end  end of this interval, null means now\n      */\n     public AbstractInterval(ReadableDuration duration, ReadableInstant end) {\n         super();\n+        Chronology chrono = null;\n+        if (end == null) {\n+            iEndMillis = DateTimeUtils.currentTimeMillis();\n+        } else {\n+            iEndMillis = end.getMillis();\n+            chrono = end.getChronology();\n+            if (end instanceof Instant) {\n+                iEndInstant = (Instant) end;\n+            }\n+        }\n         if (duration == null) {\n-            throw new IllegalArgumentException(\"The duration must not be null\");\n-        }\n-        if (end == null) {\n-            throw new IllegalArgumentException(\"The end instant must not be null\");\n-        }\n-        iEndMillis = end.getMillis();\n-        if (end instanceof Instant) {\n-            iEndInstant = (Instant) end;\n-        }\n-        iStartMillis = duration.addTo((ReadableInstant) end, -1).getMillis();\n-        if (duration.isPrecise()) {\n-            iDuration = duration.toDuration();\n+            iStartMillis = iEndMillis;\n+        } else {\n+            iStartMillis = duration.addTo(iEndMillis, 1, chrono);\n+            if (duration.isPrecise()) {\n+                iDuration = duration.toDuration();\n+            }\n         }\n     }\n \n     }\n \n     /**\n-     * Gets the duration of this time interval.\n-     * <p>\n-     * The duration returned will always be precise because it is relative to a\n-     * known date. If this interval was not specified with a precise duration\n-     * type, then the duration type defaults to ISO average-year-month type.\n-     *\n-     * @return the duration of the time interval\n+     * Gets the precise duration of this time interval.\n+     * <p>\n+     * If this interval was constructed using a precise duration then that object will\n+     * be returned. Otherwise a new Duration instance using the MillisType is returned.\n+     *\n+     * @return the precise duration of the time interval\n      */\n     public final Duration getDuration() {\n         if (iDuration == null) {\n         return iDuration;\n     }\n \n-    /** \n-     * Gets the duration of this time interval.\n-     *\n-     * @param type the requested type of the duration\n+    /**\n+     * Gets the duration of this time interval using the specified duration type.\n+     *\n+     * @param type  the requested type of the duration, null means MillisType\n      * @return the duration of the time interval\n      */\n     public final Duration getDuration(DurationType type) {\n         if (type == null) {\n-            type = DurationType.getAverageYearMonthType();\n+            type = DurationType.getMillisType();\n         }\n         Duration duration = iDuration;\n         if (duration == null) {\n             if (type.isPrecise()) {\n                 duration = new Duration(getEndMillis() - getStartMillis(), type);\n-                if (type.equals(DurationType.getAverageYearMonthType())) {\n+                if (type.equals(DurationType.getMillisType())) {\n                     iDuration = duration;\n                 }\n             } else {\n                 duration = new Duration(getStartInstant(), getEndInstant(), type);\n             }\n+        } else {\n+            duration = duration.withDurationType(type);\n         }\n         return duration;\n     }\n     /**\n      * Does this time interval contain the specified instant.\n      * \n-     * @param instant  the instant\n+     * @param instant  the instant, null means now\n      * @return true if this time interval contains the instant\n-     * @throws IllegalArgumentException if the instant is null\n      */\n     public final boolean contains(ReadableInstant instant) {\n         if (instant == null) {\n-            throw new IllegalArgumentException(\"The instant must not be null\");\n+            return contains(DateTimeUtils.currentTimeMillis());\n         }\n         return contains(instant.getMillis());\n     }\n     /**\n      * Is this time interval before the specified instant.\n      * \n-     * @param instant  the instant to compare to\n+     * @param instant  the instant to compare to, null means now\n      * @return true if this time interval is before the instant\n-     * @throws IllegalArgumentException if the instant is null\n      */\n     public final boolean isBefore(ReadableInstant instant) {\n         if (instant == null) {\n-            throw new IllegalArgumentException(\"The instant must not be null\");\n+            return isBefore(DateTimeUtils.currentTimeMillis());\n         }\n         return isBefore(instant.getMillis());\n     }\n     /**\n      * Is this time interval after the specified instant.\n      * \n-     * @param instant  the instant to compare to\n+     * @param instant  the instant to compare to, null means now\n      * @return true if this time interval is after the instant\n-     * @throws IllegalArgumentException if the instant is null\n      */\n     public final boolean isAfter(ReadableInstant instant) {\n         if (instant == null) {\n-            throw new IllegalArgumentException(\"The instant must not be null\");\n+            return isAfter(DateTimeUtils.currentTimeMillis());\n         }\n         return isAfter(instant.getMillis());\n     }\n     }\n \n     /**\n-     * Get the object as a MutableInterval.\n+     * Get the object as a MutableInterval always returning a new instance.\n      * \n      * @return a mutable interval object\n      */\n             return false;\n         }\n         ReadableInterval other = (ReadableInterval) readableInterval;\n-        return \n-            (getStartMillis() == other.getStartMillis() \n-            && getEndMillis() == other.getEndMillis());\n-    }\n-\n-    /**\n-     * Hashcode compatable with equals method.\n+        return (getStartMillis() == other.getStartMillis() &&\n+                getEndMillis() == other.getEndMillis());\n+    }\n+\n+    /**\n+     * Hashcode compatible with equals method.\n      *\n      * @return suitable hashcode\n      */\n--- a/JodaTime/src/java/org/joda/time/Interval.java\n+++ b/JodaTime/src/java/org/joda/time/Interval.java\n package org.joda.time;\n \n import java.io.Serializable;\n-import java.text.ParseException;\n \n /**\n  * Interval is the standard implementation of an immutable time interval\n public final class Interval extends AbstractInterval\n         implements ReadableInterval, Serializable {\n \n-    static final long serialVersionUID = 4922451897541386752L;\n-\n-    /**\n-     * Constructs a time interval as a copy of another.\n-     * \n-     * @param interval  the time interval to copy\n-     * @throws IllegalArgumentException if the interval is null\n-     */\n-    public Interval(ReadableInterval interval) {\n-        super(interval);\n-    }\n+    /** Serialization version */\n+    private static final long serialVersionUID = 4922451897541386752L;\n \n     /**\n      * Constructs a time interval as a copy of another.\n      * \n      * @param interval  the time interval to convert\n-     * @throws IllegalArgumentException if the interval is null\n+     * @throws IllegalArgumentException if the interval is null or invalid\n      */\n     public Interval(Object interval) {\n         super(interval);\n     /**\n      * Constructs an interval from a start and end instant.\n      * \n-     * @param start  start of this interval\n-     * @param end  end of this interval\n-     * @throws IllegalArgumentException if either instant is null\n+     * @param start  start of this interval, null means now\n+     * @param end  end of this interval, null means now\n      */\n     public Interval(ReadableInstant start, ReadableInstant end) {\n         super(start, end);\n     /**\n      * Constructs an interval from a start instant and a duration.\n      * \n-     * @param start  start of this interval\n-     * @param duration  duration of this interval\n-     * @throws IllegalArgumentException if start or duration is null\n+     * @param start  start of this interval, null means now\n+     * @param duration  duration of this interval, null means zero length\n      */\n     public Interval(ReadableInstant start, ReadableDuration duration) {\n         super(start, duration);\n     /**\n      * Constructs an interval from a duration and an end instant.\n      * \n-     * @param duration duration of this interval\n-     * @param end end of this interval\n-     * @throws IllegalArgumentException if duration or end is null\n+     * @param duration  duration of this interval, null means zero length\n+     * @param end  end of this interval, null means now\n      */\n     public Interval(ReadableDuration duration, ReadableInstant end) {\n         super(duration, end);\n     }\n \n     /**\n-     * Overridden to do nothing, ensuring this class and all subclasses are\n-     * immutable.\n+     * Overridden to do nothing, ensuring this class and all subclasses are immutable.\n      */\n     protected final void setStartMillis(long millisInstant) {\n     }\n \n     /**\n-     * Overridden to do nothing, ensuring this class and all subclasses are\n-     * immutable.\n+     * Overridden to do nothing, ensuring this class and all subclasses are immutable.\n      */\n     protected final void setEndMillis(long millisInstant) {\n     }\n \n     /**\n-     * Overridden to do nothing, ensuring this class and all subclasses are\n-     * immutable.\n+     * Overridden to do nothing, ensuring this class and all subclasses are immutable.\n      */\n     protected final void setDurationAfterStart(ReadableDuration duration) {\n     }\n \n     /**\n-     * Overridden to do nothing, ensuring this class and all subclasses are\n-     * immutable.\n+     * Overridden to do nothing, ensuring this class and all subclasses are immutable.\n      */\n     protected final void setDurationBeforeEnd(ReadableDuration duration) {\n     }\n+\n }\n--- a/JodaTime/src/java/org/joda/time/ReadableInterval.java\n+++ b/JodaTime/src/java/org/joda/time/ReadableInterval.java\n     long getDurationMillis();\n \n     /** \n-     * Gets the duration of this time interval.\n+     * Gets the duration of this time interval using the MillisType duration type.\n      * <p>\n      * The duration returned will always be precise because it is relative to\n      * a known date.\n     /** \n      * Gets the duration of this time interval.\n      *\n-     * @param type the requested type of the duration\n+     * @param type  the requested type of the duration, null means MillisType\n      * @return the duration of the time interval\n      */\n     Duration getDuration(DurationType type);\n     /**\n      * Does this time interval contain the specified instant.\n      * \n-     * @param instant  the instant\n+     * @param instant  the instant, null means now\n      * @return true if this time interval contains the instant\n-     * @throws IllegalArgumentException if the instant is null\n      */\n     public boolean contains(ReadableInstant instant);\n     \n     /**\n      * Is this time interval before the specified instant.\n      * \n-     * @param instant  the instant to compare to\n+     * @param instant  the instant to compare to, null means now\n      * @return true if this time interval is before the instant\n-     * @throws IllegalArgumentException if the instant is null\n      */\n     public boolean isBefore(ReadableInstant instant);\n     \n     /**\n      * Is this time interval after the specified instant.\n      * \n-     * @param instant  the instant to compare to\n+     * @param instant  the instant to compare to, null means now\n      * @return true if this time interval is after the instant\n-     * @throws IllegalArgumentException if the instant is null\n      */\n     public boolean isAfter(ReadableInstant instant);\n     ", "timestamp": 1090966643, "metainfo": ""}