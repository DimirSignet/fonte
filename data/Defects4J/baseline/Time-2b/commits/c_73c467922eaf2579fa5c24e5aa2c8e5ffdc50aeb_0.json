{"sha": "73c467922eaf2579fa5c24e5aa2c8e5ffdc50aeb", "log": "Refactor Periods - no longer have a chronology - period type is based around DurationFieldType - array structure internally - not convertable to durations   ", "commit": "\n--- a/JodaTime/src/java/org/joda/time/DateTime.java\n+++ b/JodaTime/src/java/org/joda/time/DateTime.java\n      * would be changed in the returned instance.\n      * If the partial is null, then <code>this</code> is returned.\n      *\n-     * @param partial  the partial set of fields to apply to this datetime\n+     * @param partial  the partial set of fields to apply to this datetime, null ignored\n      * @return a copy of this datetime with a different set of fields\n-     * @throws IllegalArgumentException if any value if invalid\n+     * @throws IllegalArgumentException if any value is invalid\n      */\n     public DateTime withFields(ReadablePartial partial) {\n         if (partial == null) {\n             return this;\n         }\n         return partial.resolveDateTime(this);\n+    }\n+\n+    /**\n+     * Gets a copy of this datetime with the specified field set to a new value.\n+     * <p>\n+     * For example, if the field type is <code>hourOfDay</code> then the hour of day\n+     * field would be changed in the returned instance.\n+     * If the field type is null, then <code>this</code> is returned.\n+     * <p>\n+     * An alternative to this method is to use the properties, for example:\n+     * <pre>\n+     * DateTime added = dt.hourOfDay().setCopy(6);\n+     * </pre>\n+     *\n+     * @param fieldType  the field type to set, null ignored\n+     * @param value  the value to set\n+     * @return a copy of this datetime with the field set\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public DateTime withField(DateTimeFieldType fieldType, int value) {\n+        if (fieldType == null) {\n+            return this;\n+        }\n+        long instant = fieldType.getField(getChronology()).set(getMillis(), value);\n+        return withMillis(instant);\n     }\n \n     //-----------------------------------------------------------------------\n     }\n \n     //-----------------------------------------------------------------------\n+    /**\n+     * Gets a copy of this datetime with the value of the specified field increased.\n+     * <p>\n+     * If the addition is zero or the field is null, then <code>this</code> is returned.\n+     * <p>\n+     * An alternative to this method is to use the properties, for example:\n+     * <pre>\n+     * DateTime added = dt.hourOfDay().addToCopy(6);\n+     * </pre>\n+     * \n+     * @param fieldType  the field type to add to, null ignored\n+     * @param amount  the amount to add\n+     * @return a copy of this datetime with the field updated\n+     * @throws ArithmeticException if the new datetime exceeds the capacity of a long\n+     */\n+    public DateTime withFieldAdded(DurationFieldType fieldType, int amount) {\n+        if (fieldType == null || amount == 0) {\n+            return this;\n+        }\n+        long instant = fieldType.getField(getChronology()).add(getMillis(), amount);\n+        return withMillis(instant);\n+    }\n+\n     /**\n      * Gets a copy of this datetime with the specified period added.\n      * <p>\n--- a/JodaTime/src/java/org/joda/time/DateTimeUtils.java\n+++ b/JodaTime/src/java/org/joda/time/DateTimeUtils.java\n     /**\n      * Gets the period type handling null.\n      * <p>\n-     * If the zone is <code>null</code>, {@link PeriodType#getAllType()}\n+     * If the zone is <code>null</code>, {@link PeriodType#standard()}\n      * will be returned. Otherwise, the type specified is returned.\n      * \n-     * @param type  the time zone to use, null means the All type\n+     * @param type  the time zone to use, null means the standard type\n      * @return the type to use, never null\n      */\n     public static final PeriodType getPeriodType(PeriodType type) {\n         if (type == null) {\n-            return PeriodType.getAllType();\n+            return PeriodType.standard();\n         }\n         return type;\n     }\n--- a/JodaTime/src/java/org/joda/time/MutableDateTime.java\n+++ b/JodaTime/src/java/org/joda/time/MutableDateTime.java\n      */\n     public void add(ReadablePeriod period, int scalar) {\n         if (period != null) {\n-            setMillis(period.addTo(getMillis(), scalar));  // set via this class not super\n+            setMillis(period.addTo(getMillis(), scalar, getChronology()));  // set via this class not super\n         }\n     }\n \n--- a/JodaTime/src/java/org/joda/time/MutableInterval.java\n+++ b/JodaTime/src/java/org/joda/time/MutableInterval.java\n \n     //-----------------------------------------------------------------------\n     /**\n+     * Sets the period of this time interval, preserving the start instant\n+     * and using the ISOChronology in the default zone for calculations.\n+     *\n+     * @param period  new period for interval, null means zero length\n+     * @throws IllegalArgumentException if the end is before the start\n+     * @throws ArithmeticException if the end instant exceeds the capacity of a long\n+     */\n+    public void setPeriodAfterStart(ReadablePeriod period) {\n+        setPeriodAfterStart(period, null);\n+    }\n+\n+    /**\n      * Sets the period of this time interval, preserving the start instant.\n      *\n      * @param period  new period for interval, null means zero length\n-     * @throws IllegalArgumentException if the end is before the start\n-     * @throws ArithmeticException if the end instant exceeds the capacity of a long\n-     */\n-    public void setPeriodAfterStart(ReadablePeriod period) {\n+     * @param chrono  the chronology to add using, null means ISO default\n+     * @throws IllegalArgumentException if the end is before the start\n+     * @throws ArithmeticException if the end instant exceeds the capacity of a long\n+     */\n+    public void setPeriodAfterStart(ReadablePeriod period, Chronology chrono) {\n         if (period == null) {\n             setEndMillis(getStartMillis());\n         } else {\n-            setEndMillis(period.addTo(getStartMillis(), 1));\n+            chrono = DateTimeUtils.getChronology(chrono);\n+            setEndMillis(period.addTo(getStartMillis(), 1, chrono));\n         }\n     }\n \n     /**\n+     * Sets the period of this time interval, preserving the end instant\n+     * and using the ISOChronology in the default zone for calculations.\n+     *\n+     * @param period  new period for interval, null means zero length\n+     * @throws IllegalArgumentException if the end is before the start\n+     * @throws ArithmeticException if the start instant exceeds the capacity of a long\n+     */\n+    public void setPeriodBeforeEnd(ReadablePeriod period) {\n+        setPeriodBeforeEnd(period, null);\n+    }\n+\n+    /**\n      * Sets the period of this time interval, preserving the end instant.\n      *\n      * @param period  new period for interval, null means zero length\n-     * @throws IllegalArgumentException if the end is before the start\n-     * @throws ArithmeticException if the start instant exceeds the capacity of a long\n-     */\n-    public void setPeriodBeforeEnd(ReadablePeriod period) {\n+     * @param chrono  the chronology to add using, null means ISO default\n+     * @throws IllegalArgumentException if the end is before the start\n+     * @throws ArithmeticException if the start instant exceeds the capacity of a long\n+     */\n+    public void setPeriodBeforeEnd(ReadablePeriod period, Chronology chrono) {\n         if (period == null) {\n             setStartMillis(getEndMillis());\n         } else {\n-            setStartMillis(period.addTo(getEndMillis(), -1));\n+            chrono = DateTimeUtils.getChronology(chrono);\n+            setStartMillis(period.addTo(getEndMillis(), -1, chrono));\n         }\n     }\n \n--- a/JodaTime/src/java/org/joda/time/MutablePeriod.java\n+++ b/JodaTime/src/java/org/joda/time/MutablePeriod.java\n     private static final long serialVersionUID = 3436451121567212165L;\n \n     /**\n-     * Creates a zero-length period using AllType.\n+     * Creates a zero-length period using the standard period type.\n      */\n     public MutablePeriod() {\n-        super(0L, null);\n+        super(0L, null, null);\n     }\n \n     /**\n      * @param type  which set of fields this period supports\n      */\n     public MutablePeriod(PeriodType type) {\n-        super(0L, type);\n-    }\n-\n-    /**\n-     * Creates a period from the given millisecond duration using AllType.\n-     * <p>\n-     * Only precise fields in the period type will be used.\n-     * For AllType, this is the time fields only.\n-     * The year, month, week and day fields will not be populated.\n-     * The period constructed will always be precise.\n-     * <p>\n-     * If the duration is small, less than one day, then this method will perform\n-     * as you might expect and split the fields evenly.\n-     * <p>\n-     * If the duration is larger than one day then all the remaining duration will\n-     * be stored in the largest available precise field, hours in this case.\n-     * <p>\n-     * For example, a duration equal to (365 + 60 + 5) days will be converted to\n-     * ((365 + 60 + 5) * 24) hours by this constructor.\n-     * <p>\n-     * For more control over the conversion process, you have two options:\n-     * <ul>\n-     * <li>convert the duration to an {@link Interval}, and from there obtain the period\n-     * <li>specify a period type that contains precise definitions of the day and larger\n-     * fields, such as the UTC or precise types.\n-     * </ul>\n-     *\n-     * @param duration  the duration, in milliseconds\n-     */\n-    public MutablePeriod(long duration) {\n-        super(duration, null);\n-    }\n-\n-    /**\n-     * Creates a period from the given millisecond duration.\n-     * <p>\n-     * Only precise fields in the period type will be used.\n-     * Imprecise fields will not be populated.\n-     * The period constructed will always be precise.\n-     * <p>\n-     * If the duration is small then this method will perform\n-     * as you might expect and split the fields evenly.\n-     * <p>\n-     * If the duration is large then all the remaining duration will\n-     * be stored in the largest available precise field.\n-     * For details as to which fields are precise, review the period type javadoc.\n-     *\n-     * @param duration  the duration, in milliseconds\n-     * @param type  which set of fields this duration supports\n-     */\n-    public MutablePeriod(long duration, PeriodType type) {\n-        super(duration, type);\n-    }\n-\n-    /**\n-     * Create a period from a set of field values using AllType.\n-     * This constructor creates a precise period.\n+        super(0L, type, null);\n+    }\n+\n+    /**\n+     * Create a period from a set of field values using the time set of fields.\n      *\n      * @param hours  amount of hours in this period\n      * @param minutes  amount of minutes in this period\n      * @param millis  amount of milliseconds in this period\n      */\n     public MutablePeriod(int hours, int minutes, int seconds, int millis) {\n-        super(0, 0, 0, 0, hours, minutes, seconds, millis, null);\n-    }\n-\n-    /**\n-     * Create a period from a set of field values using AllType.\n+        super(0, 0, 0, 0, hours, minutes, seconds, millis, PeriodType.time());\n+    }\n+\n+    /**\n+     * Create a period from a set of field values using the standard set of fields.\n      *\n      * @param years  amount of years in this period\n      * @param months  amount of months in this period\n      * @param millis  amount of milliseconds in this period\n      */\n     public MutablePeriod(int years, int months, int weeks, int days,\n-                    int hours, int minutes, int seconds, int millis) {\n-        super(years, months, weeks, days, hours, minutes, seconds, millis, null);\n+                  int hours, int minutes, int seconds, int millis) {\n+        super(years, months, weeks, days, hours, minutes, seconds, millis, PeriodType.standard());\n     }\n \n     /**\n     }\n \n     /**\n-     * Creates a period from the given interval endpoints using AllType.\n-     * This constructor creates a precise period.\n+     * Creates a period from the given millisecond duration using the standard\n+     * set of fields.\n+     * <p>\n+     * Only precise fields in the period type will be used.\n+     * For the standard period type this is the time fields only.\n+     * Thus the year, month, week and day fields will not be populated.\n+     * <p>\n+     * If the duration is small, less than one day, then this method will perform\n+     * as you might expect and split the fields evenly.\n+     * <p>\n+     * If the duration is larger than one day then all the remaining duration will\n+     * be stored in the largest available precise field, hours in this case.\n+     * <p>\n+     * For example, a duration equal to (365 + 60 + 5) days will be converted to\n+     * ((365 + 60 + 5) * 24) hours by this constructor.\n+     * <p>\n+     * For more control over the conversion process, you have two options:\n+     * <ul>\n+     * <li>convert the duration to an {@link Interval}, and from there obtain the period\n+     * <li>specify a period type that contains precise definitions of the day and larger\n+     * fields, such as the UTC or precise types.\n+     * </ul>\n+     *\n+     * @param duration  the duration, in milliseconds\n+     */\n+    public MutablePeriod(long duration) {\n+        super(duration, null, null);\n+    }\n+\n+    /**\n+     * Creates a period from the given millisecond duration.\n+     * <p>\n+     * Only precise fields in the period type will be used.\n+     * Imprecise fields will not be populated.\n+     * <p>\n+     * If the duration is small then this method will perform\n+     * as you might expect and split the fields evenly.\n+     * <p>\n+     * If the duration is large then all the remaining duration will\n+     * be stored in the largest available precise field.\n+     * For details as to which fields are precise, review the period type javadoc.\n+     *\n+     * @param duration  the duration, in milliseconds\n+     * @param type  which set of fields this period supports, null means standard\n+     */\n+    public MutablePeriod(long duration, PeriodType type) {\n+        super(duration, type, null);\n+    }\n+\n+    /**\n+     * Creates a period from the given millisecond duration using the standard\n+     * set of fields.\n+     * <p>\n+     * Only precise fields in the period type will be used.\n+     * Imprecise fields will not be populated.\n+     * <p>\n+     * If the duration is small then this method will perform\n+     * as you might expect and split the fields evenly.\n+     * <p>\n+     * If the duration is large then all the remaining duration will\n+     * be stored in the largest available precise field.\n+     * For details as to which fields are precise, review the period type javadoc.\n+     *\n+     * @param duration  the duration, in milliseconds\n+     * @param chronology  the chronology to use to split the duration, null means ISO default\n+     */\n+    public MutablePeriod(long duration, Chronology chronology) {\n+        super(duration, null, chronology);\n+    }\n+\n+    /**\n+     * Creates a period from the given millisecond duration.\n+     * <p>\n+     * Only precise fields in the period type will be used.\n+     * Imprecise fields will not be populated.\n+     * <p>\n+     * If the duration is small then this method will perform\n+     * as you might expect and split the fields evenly.\n+     * <p>\n+     * If the duration is large then all the remaining duration will\n+     * be stored in the largest available precise field.\n+     * For details as to which fields are precise, review the period type javadoc.\n+     *\n+     * @param duration  the duration, in milliseconds\n+     * @param type  which set of fields this period supports, null means standard\n+     * @param chronology  the chronology to use to split the duration, null means ISO default\n+     */\n+    public MutablePeriod(long duration, PeriodType type, Chronology chronology) {\n+        super(duration, type, chronology);\n+    }\n+\n+    /**\n+     * Creates a period from the given interval endpoints using the standard\n+     * set of fields.\n      *\n      * @param startInstant  interval start, in milliseconds\n      * @param endInstant  interval end, in milliseconds\n      */\n     public MutablePeriod(long startInstant, long endInstant) {\n-        super(startInstant, endInstant, null);\n+        super(startInstant, endInstant, null, null);\n     }\n \n     /**\n      * Creates a period from the given interval endpoints.\n-     * This constructor creates a precise period.\n      *\n      * @param startInstant  interval start, in milliseconds\n      * @param endInstant  interval end, in milliseconds\n-     * @param type  which set of fields this period supports, null means AllType\n+     * @param type  which set of fields this period supports, null means standard\n      */\n     public MutablePeriod(long startInstant, long endInstant, PeriodType type) {\n-        super(startInstant, endInstant, type);\n-    }\n-\n-    /**\n-     * Creates a period from the given interval endpoints using AllType.\n-     * This constructor creates a precise period.\n+        super(startInstant, endInstant, type, null);\n+    }\n+\n+    /**\n+     * Creates a period from the given interval endpoints using the standard\n+     * set of fields.\n+     *\n+     * @param startInstant  interval start, in milliseconds\n+     * @param endInstant  interval end, in milliseconds\n+     * @param chrono  the chronology to use, null means ISO in default zone\n+     */\n+    public MutablePeriod(long startInstant, long endInstant, Chronology chrono) {\n+        super(startInstant, endInstant, null, chrono);\n+    }\n+\n+    /**\n+     * Creates a period from the given interval endpoints.\n+     *\n+     * @param startInstant  interval start, in milliseconds\n+     * @param endInstant  interval end, in milliseconds\n+     * @param type  which set of fields this period supports, null means standard\n+     * @param chrono  the chronology to use, null means ISO in default zone\n+     */\n+    public MutablePeriod(long startInstant, long endInstant, PeriodType type, Chronology chrono) {\n+        super(startInstant, endInstant, type, chrono);\n+    }\n+\n+    /**\n+     * Creates a period from the given interval endpoints using the standard\n+     * set of fields.\n      *\n      * @param startInstant  interval start, null means now\n      * @param endInstant  interval end, null means now\n \n     /**\n      * Creates a period from the given interval endpoints.\n-     * This constructor creates a precise period.\n      *\n      * @param startInstant  interval start, null means now\n      * @param endInstant  interval end, null means now\n      * @throws UnsupportedOperationException if an unsupported field's value is non-zero\n      */\n     public MutablePeriod(Object period) {\n-        super(period, null);\n+        super(period, null, null);\n     }\n \n     /**\n      * @throws UnsupportedOperationException if an unsupported field's value is non-zero\n      */\n     public MutablePeriod(Object period, PeriodType type) {\n-        super(period, type);\n-    }\n-\n-    //-----------------------------------------------------------------------\n+        super(period, type, null);\n+    }\n+\n+    /**\n+     * Creates a period from the specified object using the\n+     * {@link org.joda.time.convert.ConverterManager ConverterManager}.\n+     *\n+     * @param period  period to convert\n+     * @param chrono  the chronology to use, null means ISO in default zone\n+     * @throws IllegalArgumentException if period is invalid\n+     * @throws UnsupportedOperationException if an unsupported field's value is non-zero\n+     */\n+    public MutablePeriod(Object period, Chronology chrono) {\n+        super(period, null, chrono);\n+    }\n+\n+    /**\n+     * Creates a period from the specified object using the\n+     * {@link org.joda.time.convert.ConverterManager ConverterManager}.\n+     *\n+     * @param period  period to convert\n+     * @param type  which set of fields this period supports, null means use converter\n+     * @param chrono  the chronology to use, null means ISO in default zone\n+     * @throws IllegalArgumentException if period is invalid\n+     * @throws UnsupportedOperationException if an unsupported field's value is non-zero\n+     */\n+    public MutablePeriod(Object period, PeriodType type, Chronology chrono) {\n+        super(period, type, chrono);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets the value of one of the fields.\n+     * <p>\n+     * The field type specified must be one of those that is supported by the period.\n+     *\n+     * @param field  a DurationFieldType instance that is supported by this period\n+     * @param value  the new value for the field\n+     * @throws IllegalArgumentException if the field is null or not supported\n+     */\n+    public void set(DurationFieldType field, int value) {\n+        super.setField(field, value);\n+    }\n+\n     /**\n      * Sets all the fields in one go from another ReadablePeriod.\n      * \n      * @throws IllegalArgumentException if an unsupported field's value is non-zero\n      */\n     public void setPeriod(ReadablePeriod period) {\n-        if (period == null) {\n-            setPeriod(0L);\n-        } else {\n-            setPeriod(\n-                period.getYears(), period.getMonths(),\n-                period.getWeeks(), period.getDays(),\n-                period.getHours(), period.getMinutes(),\n-                period.getSeconds(), period.getMillis());\n-        }\n+        super.setPeriod(period);\n     }\n \n     /**\n      * @throws IllegalArgumentException if an unsupported field's value is non-zero\n      */\n     public void setPeriod(int years, int months, int weeks, int days,\n-                            int hours, int minutes, int seconds, int millis) {\n-        super.setPeriod(years, months, weeks, days,\n-                          hours, minutes, seconds, millis);\n+                          int hours, int minutes, int seconds, int millis) {\n+        super.setPeriod(years, months, weeks, days, hours, minutes, seconds, millis);\n+    }\n+\n+    /**\n+     * Sets all the fields in one go from an interval using the ISO chronology\n+     * and dividing the fields using the period type.\n+     * \n+     * @param interval  the interval to set, null means zero length\n+     */\n+    public void setPeriod(ReadableInterval interval) {\n+        setPeriod(interval, null);\n     }\n \n     /**\n      * fields using the period type.\n      * \n      * @param interval  the interval to set, null means zero length\n-     */\n-    public void setPeriod(ReadableInterval interval) {\n+     * @param chrono  the chronology to use, null means ISO default\n+     */\n+    public void setPeriod(ReadableInterval interval, Chronology chrono) {\n         if (interval == null) {\n             setPeriod(0L);\n         } else {\n-            setPeriod(interval.getStartMillis(), interval.getEndMillis());\n-        }\n+            setPeriod(interval.getStartMillis(), interval.getEndMillis(), chrono);\n+        }\n+    }\n+\n+    /**\n+     * Sets all the fields in one go from a millisecond interval using ISOChronology\n+     * and dividing the fields using the period type.\n+     * \n+     * @param startInstant  interval start, in milliseconds\n+     * @param endInstant  interval end, in milliseconds\n+     */\n+    public void setPeriod(long startInstant, long endInstant) {\n+        setPeriod(startInstant, endInstant, null);\n     }\n \n     /**\n      * \n      * @param startInstant  interval start, in milliseconds\n      * @param endInstant  interval end, in milliseconds\n-     */\n-    public void setPeriod(long startInstant, long endInstant) {\n-        super.setPeriod(startInstant, endInstant);\n+     * @param chrono  the chronology to use, null means ISO default\n+     */\n+    public void setPeriod(long startInstant, long endInstant, Chronology chrono) {\n+        super.setPeriod(startInstant, endInstant, chrono);\n     }\n \n     /**\n      * @param duration  the duration to set, null means zero length\n      */\n     public void setPeriod(ReadableDuration duration) {\n-        long durationMillis = DateTimeUtils.getDurationMillis(duration);\n-        setPeriod(durationMillis);\n-    }\n-\n-    /**\n-     * Sets all the fields in one go from a millisecond duration dividing the\n+        setPeriod(duration, null);\n+    }\n+\n+    /**\n+     * Sets all the fields in one go from a duration dividing the\n      * fields using the period type.\n      * <p>\n      * When dividing the duration, only precise fields in the period type will be used.\n      * For large durations, all the remaining duration will be stored in the largest\n      * available precise field.\n      * \n+     * @param duration  the duration to set, null means zero length\n+     * @param chrono  the chronology to use, null means ISO default\n+     */\n+    public void setPeriod(ReadableDuration duration, Chronology chrono) {\n+        long durationMillis = DateTimeUtils.getDurationMillis(duration);\n+        setPeriod(durationMillis, chrono);\n+    }\n+\n+    /**\n+     * Sets all the fields in one go from a millisecond duration dividing the\n+     * fields using the period type.\n+     * <p>\n+     * When dividing the duration, only precise fields in the period type will be used.\n+     * For large durations, all the remaining duration will be stored in the largest\n+     * available precise field.\n+     * \n      * @param duration  the duration, in milliseconds\n      */\n     public void setPeriod(long duration) {\n-        super.setPeriod(duration);\n-    }\n-    \n-    //-----------------------------------------------------------------------\n+        setPeriod(duration, null);\n+    }\n+\n+    /**\n+     * Sets all the fields in one go from a millisecond duration dividing the\n+     * fields using the period type.\n+     * <p>\n+     * When dividing the duration, only precise fields in the period type will be used.\n+     * For large durations, all the remaining duration will be stored in the largest\n+     * available precise field.\n+     * \n+     * @param duration  the duration, in milliseconds\n+     * @param chrono  the chronology to use, null means ISO default\n+     */\n+    public void setPeriod(long duration, Chronology chrono) {\n+        super.setPeriod(duration, chrono);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Adds to the value of one of the fields.\n+     * <p>\n+     * The field type specified must be one of those that is supported by the period.\n+     *\n+     * @param field  a DurationFieldType instance that is supported by this period\n+     * @param value  the value to add to the field\n+     * @throws IllegalArgumentException if the field is null or not supported\n+     */\n+    public void add(DurationFieldType field, int value) {\n+        if (value != 0) {\n+            set(field, FieldUtils.safeAdd(get(field), value));\n+        }\n+    }\n+\n     /**\n      * Adds a period to this one by adding each field in turn.\n      * \n      */\n     public void add(ReadablePeriod period) {\n         if (period != null) {\n-            setPeriod(\n-                FieldUtils.safeAdd(getYears(), period.getYears()),\n-                FieldUtils.safeAdd(getMonths(), period.getMonths()),\n-                FieldUtils.safeAdd(getWeeks(), period.getWeeks()),\n-                FieldUtils.safeAdd(getDays(), period.getDays()),\n-                FieldUtils.safeAdd(getHours(), period.getHours()),\n-                FieldUtils.safeAdd(getMinutes(), period.getMinutes()),\n-                FieldUtils.safeAdd(getSeconds(), period.getSeconds()),\n-                FieldUtils.safeAdd(getMillis(), period.getMillis())\n-            );\n+            addPeriod(period);\n         }\n     }\n \n         add(new Period(duration, getPeriodType()));\n     }\n \n-    /**\n-     * Normalizes all the field values in this period.\n-     * <p>\n-     * This method converts to a milliecond duration and back again.\n-     *\n-     * @throws IllegalStateException if this period is imprecise\n-     */\n-    public void normalize() {\n-        setPeriod(toDurationMillis());\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the years field part of the period.\n+     * \n+     * @return the number of years in the period, zero if unsupported\n+     */\n+    public int getYears() {\n+        return getPeriodType().getYears(this);\n+    }\n+\n+    /**\n+     * Gets the months field part of the period.\n+     * \n+     * @return the number of months in the period, zero if unsupported\n+     */\n+    public int getMonths() {\n+        return getPeriodType().getMonths(this);\n+    }\n+\n+    /**\n+     * Gets the weeks field part of the period.\n+     * \n+     * @return the number of weeks in the period, zero if unsupported\n+     */\n+    public int getWeeks() {\n+        return getPeriodType().getWeeks(this);\n+    }\n+\n+    /**\n+     * Gets the days field part of the period.\n+     * \n+     * @return the number of days in the period, zero if unsupported\n+     */\n+    public int getDays() {\n+        return getPeriodType().getDays(this);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the hours field part of the period.\n+     * \n+     * @return the number of hours in the period, zero if unsupported\n+     */\n+    public int getHours() {\n+        return getPeriodType().getHours(this);\n+    }\n+\n+    /**\n+     * Gets the minutes field part of the period.\n+     * \n+     * @return the number of minutes in the period, zero if unsupported\n+     */\n+    public int getMinutes() {\n+        return getPeriodType().getMinutes(this);\n+    }\n+\n+    /**\n+     * Gets the seconds field part of the period.\n+     * \n+     * @return the number of seconds in the period, zero if unsupported\n+     */\n+    public int getSeconds() {\n+        return getPeriodType().getSeconds(this);\n+    }\n+\n+    /**\n+     * Gets the millis field part of the period.\n+     * \n+     * @return the number of millis in the period, zero if unsupported\n+     */\n+    public int getMillis() {\n+        return getPeriodType().getMillis(this);\n     }\n \n     //-----------------------------------------------------------------------\n      * @throws UnsupportedOperationException if field is not supported.\n      */\n     public void setYears(int years) {\n-        super.setYears(years);\n+        super.setField(DurationFieldType.years(), years);\n     }\n \n     /**\n      * @throws UnsupportedOperationException if field is not supported.\n      */\n     public void setMonths(int months) {\n-        super.setMonths(months);\n+        super.setField(DurationFieldType.months(), months);\n     }\n \n     /**\n      * @throws UnsupportedOperationException if field is not supported.\n      */\n     public void setWeeks(int weeks) {\n-        super.setWeeks(weeks);\n+        super.setField(DurationFieldType.weeks(), weeks);\n     }\n \n     /**\n      * @throws UnsupportedOperationException if field is not supported.\n      */\n     public void setDays(int days) {\n-        super.setDays(days);\n+        super.setField(DurationFieldType.days(), days);\n     }\n \n     /**\n      * @throws UnsupportedOperationException if field is not supported.\n      */\n     public void setHours(int hours) {\n-        super.setHours(hours);\n+        super.setField(DurationFieldType.hours(), hours);\n     }\n \n     /**\n      * @throws UnsupportedOperationException if field is not supported.\n      */\n     public void setMinutes(int minutes) {\n-        super.setMinutes(minutes);\n+        super.setField(DurationFieldType.minutes(), minutes);\n     }\n \n     /**\n      * @throws UnsupportedOperationException if field is not supported.\n      */\n     public void setSeconds(int seconds) {\n-        super.setSeconds(seconds);\n+        super.setField(DurationFieldType.seconds(), seconds);\n     }\n \n     /**\n      * @throws UnsupportedOperationException if field is not supported.\n      */\n     public void setMillis(int millis) {\n-        super.setMillis(millis);\n+        super.setField(DurationFieldType.millis(), millis);\n     }\n \n     /**\n--- a/JodaTime/src/java/org/joda/time/Period.java\n+++ b/JodaTime/src/java/org/joda/time/Period.java\n  * An immutable time period specifying a set of duration field values.\n  * <p>\n  * A time period is divided into a number of fields, such as hours and seconds.\n- * The way in which that divide occurs is controlled by the PeriodType class.\n- * <p>\n- * <code>Period</code> can use any period type to split the milliseconds into fields.\n- * The {@link PeriodType#getAllType() All} type is used by default.\n- * <code>All</code> uses the ISO chronology and divides a duration into years, months,\n- * weeks, days, hours, minutes, seconds and milliseconds as best it can.\n- * <p>\n- * This class performs calculations using the individual fields.\n- * It <i>may</i> be possible to convert a <code>Period</code> to a <code>Duration</code>.\n- * The conversion will succeed if the time period is precise.\n- * A time period is precise if all of the populated fields have a fixed known duration.\n+ * Which fields are supported is defined by the PeriodType class.\n  * <p>\n  * When this time period is added to an instant, the effect is of adding each field in turn.\n  * As a result, this takes into account daylight savings time.\n     private static final long serialVersionUID = 741052353876488155L;\n \n     /**\n-     * Creates a period from the given millisecond duration using AllType.\n-     * <p>\n-     * Only precise fields in the period type will be used.\n-     * For AllType, this is the time fields only.\n-     * The year, month, week and day fields will not be populated.\n-     * The period constructed will always be precise.\n-     * <p>\n-     * If the duration is small, less than one day, then this method will perform\n-     * as you might expect and split the fields evenly.\n-     * <p>\n-     * If the duration is larger than one day then all the remaining duration will\n-     * be stored in the largest available precise field, hours in this case.\n-     * <p>\n-     * For example, a duration equal to (365 + 60 + 5) days will be converted to\n-     * ((365 + 60 + 5) * 24) hours by this constructor.\n-     * <p>\n-     * For more control over the conversion process, you have two options:\n-     * <ul>\n-     * <li>convert the duration to an {@link Interval}, and from there obtain the period\n-     * <li>specify a period type that contains precise definitions of the day and larger\n-     * fields, such as the UTC or precise types.\n-     * </ul>\n-     *\n-     * @param duration  the duration, in milliseconds\n-     */\n-    public Period(long duration) {\n-        super(duration, null);\n-    }\n-\n-    /**\n-     * Creates a period from the given millisecond duration.\n-     * <p>\n-     * Only precise fields in the period type will be used.\n-     * Imprecise fields will not be populated.\n-     * The period constructed will always be precise.\n-     * <p>\n-     * If the duration is small then this method will perform\n-     * as you might expect and split the fields evenly.\n-     * <p>\n-     * If the duration is large then all the remaining duration will\n-     * be stored in the largest available precise field.\n-     * For details as to which fields are precise, review the period type javadoc.\n-     *\n-     * @param duration  the duration, in milliseconds\n-     * @param type  which set of fields this period supports\n-     */\n-    public Period(long duration, PeriodType type) {\n-        super(duration, type);\n-    }\n-\n-    /**\n-     * Create a period from a set of field values using AllType.\n-     * This constructor creates a precise period.\n+     * Create a period from a set of field values using the time set of fields.\n      *\n      * @param hours  amount of hours in this period\n      * @param minutes  amount of minutes in this period\n      * @param millis  amount of milliseconds in this period\n      */\n     public Period(int hours, int minutes, int seconds, int millis) {\n-        super(0, 0, 0, 0, hours, minutes, seconds, millis, null);\n-    }\n-\n-    /**\n-     * Create a period from a set of field values using AllType.\n+        super(0, 0, 0, 0, hours, minutes, seconds, millis, PeriodType.time());\n+    }\n+\n+    /**\n+     * Create a period from a set of field values using the standard set of fields.\n      *\n      * @param years  amount of years in this period\n      * @param months  amount of months in this period\n      * @param millis  amount of milliseconds in this period\n      */\n     public Period(int years, int months, int weeks, int days,\n-                    int hours, int minutes, int seconds, int millis) {\n-        super(years, months, weeks, days, hours, minutes, seconds, millis, null);\n+                  int hours, int minutes, int seconds, int millis) {\n+        super(years, months, weeks, days, hours, minutes, seconds, millis, PeriodType.standard());\n     }\n \n     /**\n     }\n \n     /**\n-     * Creates a period from the given interval endpoints using AllType.\n-     * This constructor creates a precise period.\n+     * Creates a period from the given millisecond duration using the standard\n+     * set of fields.\n+     * <p>\n+     * Only precise fields in the period type will be used.\n+     * For the standard period type this is the time fields only.\n+     * Thus the year, month, week and day fields will not be populated.\n+     * <p>\n+     * If the duration is small, less than one day, then this method will perform\n+     * as you might expect and split the fields evenly.\n+     * <p>\n+     * If the duration is larger than one day then all the remaining duration will\n+     * be stored in the largest available precise field, hours in this case.\n+     * <p>\n+     * For example, a duration equal to (365 + 60 + 5) days will be converted to\n+     * ((365 + 60 + 5) * 24) hours by this constructor.\n+     * <p>\n+     * For more control over the conversion process, you have two options:\n+     * <ul>\n+     * <li>convert the duration to an {@link Interval}, and from there obtain the period\n+     * <li>specify a period type that contains precise definitions of the day and larger\n+     * fields, such as the UTC or precise types.\n+     * </ul>\n+     *\n+     * @param duration  the duration, in milliseconds\n+     */\n+    public Period(long duration) {\n+        super(duration, null, null);\n+    }\n+\n+    /**\n+     * Creates a period from the given millisecond duration.\n+     * <p>\n+     * Only precise fields in the period type will be used.\n+     * Imprecise fields will not be populated.\n+     * <p>\n+     * If the duration is small then this method will perform\n+     * as you might expect and split the fields evenly.\n+     * <p>\n+     * If the duration is large then all the remaining duration will\n+     * be stored in the largest available precise field.\n+     * For details as to which fields are precise, review the period type javadoc.\n+     *\n+     * @param duration  the duration, in milliseconds\n+     * @param type  which set of fields this period supports, null means standard\n+     */\n+    public Period(long duration, PeriodType type) {\n+        super(duration, type, null);\n+    }\n+\n+    /**\n+     * Creates a period from the given millisecond duration using the standard\n+     * set of fields.\n+     * <p>\n+     * Only precise fields in the period type will be used.\n+     * Imprecise fields will not be populated.\n+     * <p>\n+     * If the duration is small then this method will perform\n+     * as you might expect and split the fields evenly.\n+     * <p>\n+     * If the duration is large then all the remaining duration will\n+     * be stored in the largest available precise field.\n+     * For details as to which fields are precise, review the period type javadoc.\n+     *\n+     * @param duration  the duration, in milliseconds\n+     * @param chronology  the chronology to use to split the duration, null means ISO default\n+     */\n+    public Period(long duration, Chronology chronology) {\n+        super(duration, null, chronology);\n+    }\n+\n+    /**\n+     * Creates a period from the given millisecond duration.\n+     * <p>\n+     * Only precise fields in the period type will be used.\n+     * Imprecise fields will not be populated.\n+     * <p>\n+     * If the duration is small then this method will perform\n+     * as you might expect and split the fields evenly.\n+     * <p>\n+     * If the duration is large then all the remaining duration will\n+     * be stored in the largest available precise field.\n+     * For details as to which fields are precise, review the period type javadoc.\n+     *\n+     * @param duration  the duration, in milliseconds\n+     * @param type  which set of fields this period supports, null means standard\n+     * @param chronology  the chronology to use to split the duration, null means ISO default\n+     */\n+    public Period(long duration, PeriodType type, Chronology chronology) {\n+        super(duration, type, chronology);\n+    }\n+\n+    /**\n+     * Creates a period from the given interval endpoints using the standard\n+     * set of fields.\n      *\n      * @param startInstant  interval start, in milliseconds\n      * @param endInstant  interval end, in milliseconds\n      */\n     public Period(long startInstant, long endInstant) {\n-        super(startInstant, endInstant, null);\n+        super(startInstant, endInstant, null, null);\n     }\n \n     /**\n      * Creates a period from the given interval endpoints.\n-     * This constructor creates a precise period.\n      *\n      * @param startInstant  interval start, in milliseconds\n      * @param endInstant  interval end, in milliseconds\n-     * @param type  which set of fields this period supports, null means AllType\n+     * @param type  which set of fields this period supports, null means standard\n      */\n     public Period(long startInstant, long endInstant, PeriodType type) {\n-        super(startInstant, endInstant, type);\n-    }\n-\n-    /**\n-     * Creates a period from the given interval endpoints using AllType.\n-     * This constructor creates a precise period.\n+        super(startInstant, endInstant, type, null);\n+    }\n+\n+    /**\n+     * Creates a period from the given interval endpoints using the standard\n+     * set of fields.\n+     *\n+     * @param startInstant  interval start, in milliseconds\n+     * @param endInstant  interval end, in milliseconds\n+     * @param chrono  the chronology to use, null means ISO in default zone\n+     */\n+    public Period(long startInstant, long endInstant, Chronology chrono) {\n+        super(startInstant, endInstant, null, chrono);\n+    }\n+\n+    /**\n+     * Creates a period from the given interval endpoints.\n+     *\n+     * @param startInstant  interval start, in milliseconds\n+     * @param endInstant  interval end, in milliseconds\n+     * @param type  which set of fields this period supports, null means standard\n+     * @param chrono  the chronology to use, null means ISO in default zone\n+     */\n+    public Period(long startInstant, long endInstant, PeriodType type, Chronology chrono) {\n+        super(startInstant, endInstant, type, chrono);\n+    }\n+\n+    /**\n+     * Creates a period from the given interval endpoints using the standard\n+     * set of fields.\n      *\n      * @param startInstant  interval start, null means now\n      * @param endInstant  interval end, null means now\n \n     /**\n      * Creates a period from the given interval endpoints.\n-     * This constructor creates a precise period.\n      *\n      * @param startInstant  interval start, null means now\n      * @param endInstant  interval end, null means now\n      * @throws UnsupportedOperationException if an unsupported field's value is non-zero\n      */\n     public Period(Object period) {\n-        super(period, null);\n+        super(period, null, null);\n     }\n \n     /**\n      * @throws UnsupportedOperationException if an unsupported field's value is non-zero\n      */\n     public Period(Object period, PeriodType type) {\n-        super(period, type);\n+        super(period, type, null);\n+    }\n+\n+    /**\n+     * Creates a period from the specified object using the\n+     * {@link org.joda.time.convert.ConverterManager ConverterManager}.\n+     *\n+     * @param period  period to convert\n+     * @param chrono  the chronology to use, null means ISO in default zone\n+     * @throws IllegalArgumentException if period is invalid\n+     * @throws UnsupportedOperationException if an unsupported field's value is non-zero\n+     */\n+    public Period(Object period, Chronology chrono) {\n+        super(period, null, chrono);\n+    }\n+\n+    /**\n+     * Creates a period from the specified object using the\n+     * {@link org.joda.time.convert.ConverterManager ConverterManager}.\n+     *\n+     * @param period  period to convert\n+     * @param type  which set of fields this period supports, null means use converter\n+     * @param chrono  the chronology to use, null means ISO in default zone\n+     * @throws IllegalArgumentException if period is invalid\n+     * @throws UnsupportedOperationException if an unsupported field's value is non-zero\n+     */\n+    public Period(Object period, PeriodType type, Chronology chrono) {\n+        super(period, type, chrono);\n     }\n \n     //-----------------------------------------------------------------------\n      */\n     public Period toPeriod() {\n         return this;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the years field part of the period.\n+     * \n+     * @return the number of years in the period, zero if unsupported\n+     */\n+    public int getYears() {\n+        return getPeriodType().getYears(this);\n+    }\n+\n+    /**\n+     * Gets the months field part of the period.\n+     * \n+     * @return the number of months in the period, zero if unsupported\n+     */\n+    public int getMonths() {\n+        return getPeriodType().getMonths(this);\n+    }\n+\n+    /**\n+     * Gets the weeks field part of the period.\n+     * \n+     * @return the number of weeks in the period, zero if unsupported\n+     */\n+    public int getWeeks() {\n+        return getPeriodType().getWeeks(this);\n+    }\n+\n+    /**\n+     * Gets the days field part of the period.\n+     * \n+     * @return the number of days in the period, zero if unsupported\n+     */\n+    public int getDays() {\n+        return getPeriodType().getDays(this);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the hours field part of the period.\n+     * \n+     * @return the number of hours in the period, zero if unsupported\n+     */\n+    public int getHours() {\n+        return getPeriodType().getHours(this);\n+    }\n+\n+    /**\n+     * Gets the minutes field part of the period.\n+     * \n+     * @return the number of minutes in the period, zero if unsupported\n+     */\n+    public int getMinutes() {\n+        return getPeriodType().getMinutes(this);\n+    }\n+\n+    /**\n+     * Gets the seconds field part of the period.\n+     * \n+     * @return the number of seconds in the period, zero if unsupported\n+     */\n+    public int getSeconds() {\n+        return getPeriodType().getSeconds(this);\n+    }\n+\n+    /**\n+     * Gets the millis field part of the period.\n+     * \n+     * @return the number of millis in the period, zero if unsupported\n+     */\n+    public int getMillis() {\n+        return getPeriodType().getMillis(this);\n     }\n \n     //-----------------------------------------------------------------------\n      * @throws IllegalArgumentException if the new period won't accept all of the current fields\n      */\n     public Period withPeriodType(PeriodType type) {\n-        if (type == null) {\n-            type = PeriodType.getAllType();\n-        }\n+        type = DateTimeUtils.getPeriodType(type);\n         if (type.equals(getPeriodType())) {\n             return this;\n         }\n-        return new Period(getYears(), getMonths(), getWeeks(), getDays(),\n-                    getHours(), getMinutes(), getSeconds(), getMillis(), type);\n-    }\n-\n-    /**\n-     * Creates a new Period instance with the same millisecond duration but\n-     * different PeriodType.\n-     * \n-     * @param type  the period type to use, null means AllType\n-     * @return the new period instance\n-     * @throws IllegalStateException if this period is imprecise\n-     */\n-    public Period withPeriodTypeRetainDuration(PeriodType type) {\n-        if (type == null) {\n-            type = PeriodType.getAllType();\n-        }\n-        if (type.equals(getPeriodType())) {\n-            return this;\n-        }\n-        return new Period(toDurationMillis(), type);\n-    }\n-\n-    /**\n-     * Creates a new Period instance with the same millisecond duration but\n-     * all the fields normalized to be within their standard ranges.\n-     * \n-     * @return the new period instance\n-     * @throws IllegalStateException if this period is imprecise\n-     */\n-    public Period withFieldsNormalized() {\n-        return new Period(toDurationMillis(), getPeriodType());\n+        return new Period(this, type);\n     }\n \n }\n--- a/JodaTime/src/java/org/joda/time/PeriodType.java\n+++ b/JodaTime/src/java/org/joda/time/PeriodType.java\n package org.joda.time;\n \n import java.io.Serializable;\n-\n-import org.joda.time.chrono.ISOChronology;\n-import org.joda.time.field.MillisDurationField;\n-import org.joda.time.field.ScaledDurationField;\n-import org.joda.time.field.UnsupportedDurationField;\n+import java.util.Arrays;\n \n /**\n- * Controls a duration implementation by specifying which duration fields are to be used.\n+ * Controls a period implementation by specifying which duration fields are to be used.\n  * <p>\n  * The following implementations are provided:\n  * <ul>\n- * <li>Millis - the duration is defined only in terms of milliseconds, other\n- *  fields are not used\n- * <li>All - the duration is defined to permit all fields to be used\n- * <li>DayHour - the duration is expressed in terms of days, hours, minutes, seconds\n- *  and milliseconds\n- * <li>YearMonth - the duration is expressed using all fields except weeks\n- * <li>YearWeek - the duration is expressed using all fields except months\n- * <li>AverageYearMonth - as YearMonth, but years and months have fixed average lengths\n- * <li>PreciseAll - defines years as 365 days, months as 30 days, weeks as 7 days,\n- * days as 24 hours and all the time fields\n- * <li>PreciseDayHour - defines days as 24 hours and all the time fields\n- * <li>PreciseYearDay - defines years as 365 days, days as 24 hours and all the time fields\n- * <li>PreciseYearWeek - defines years as 365 days, weeks as 7 days,\n- * days as 24 hours and all the time fields\n- * <li>PreciseYearMonth - defines years as 365 days, months as 30 days,\n- * days as 24 hours and all the time fields\n+ * <li>Standard - years, months, weeks, days, hours, minutes, seconds, millis\n+ * <li>YearMonthDayTime - years, months, days, hours, minutes, seconds, millis\n+ * <li>YearWeekDayTime - years, weeks, days, hours, minutes, seconds, millis\n+ * <li>YearDayTime - years, days, hours, minutes, seconds, millis\n+ * <li>DayTime - days, hours, minutes, seconds, millis\n+ * <li>Time - hours, minutes, seconds, millis\n+ * <li>plus one for each single type\n  * </ul>\n  *\n  * <p>\n  * @author Stephen Colebourne\n  * @since 1.0\n  */\n-public abstract class PeriodType implements Serializable {\n+public class PeriodType implements Serializable {\n+    /** Serialization version */\n     private static final long serialVersionUID = 2274324892792009998L;\n \n-    private static final PeriodType MILLIS;\n-    private static final PeriodType DAY_HOUR;\n-    private static final PeriodType YEAR_DAY;\n-    private static final PeriodType YEAR_WEEK;\n-    private static final PeriodType YEAR_MONTH;\n-    private static final PeriodType ALL;\n-    private static final PeriodType DAY_HOUR_UTC;\n-    private static final PeriodType YEAR_DAY_UTC;\n-    private static final PeriodType YEAR_WEEK_UTC;\n-    private static final PeriodType YEAR_MONTH_UTC;\n-    private static final PeriodType ALL_UTC;\n-    private static final PeriodType PRECISE_DAY_HOUR;\n-    private static final PeriodType PRECISE_YEAR_DAY;\n-    private static final PeriodType PRECISE_YEAR_WEEK;\n-    private static final PeriodType PRECISE_YEAR_MONTH;\n-    private static final PeriodType PRECISE_ALL;\n-\n-    static {\n-        MILLIS = new MillisType();\n-        DAY_HOUR = new DayHourType(ISOChronology.getInstance());\n-        YEAR_DAY = new YearDayType(ISOChronology.getInstance());\n-        YEAR_WEEK = new YearWeekType(ISOChronology.getInstance());\n-        YEAR_MONTH = new YearMonthType(ISOChronology.getInstance());\n-        ALL = new AllType(ISOChronology.getInstance());\n-        DAY_HOUR_UTC = new DayHourType(ISOChronology.getInstanceUTC());\n-        YEAR_DAY_UTC = new YearDayType(ISOChronology.getInstanceUTC());\n-        YEAR_WEEK_UTC = new YearWeekType(ISOChronology.getInstanceUTC());\n-        YEAR_MONTH_UTC = new YearMonthType(ISOChronology.getInstanceUTC());\n-        ALL_UTC = new AllType(ISOChronology.getInstanceUTC());\n-        PRECISE_DAY_HOUR = new PreciseDayHourType(ISOChronology.getInstanceUTC());\n-        PRECISE_YEAR_DAY = new PreciseYearDayType(ISOChronology.getInstanceUTC());\n-        PRECISE_YEAR_WEEK = new PreciseYearWeekType(ISOChronology.getInstanceUTC());\n-        PRECISE_YEAR_MONTH = new PreciseYearMonthType(ISOChronology.getInstanceUTC());\n-        PRECISE_ALL = new PreciseAllType(ISOChronology.getInstanceUTC());\n-    }\n-\n-    /**\n-     * Returns a PeriodType of only a milliseconds field using the ISOChronology.\n-     * When using this type, the maximum millisecond value that can be stored is\n-     * typically limited by a 32 bit int.\n-     */\n-    public static PeriodType getMillisType() {\n-        return MILLIS;\n-    }\n-\n-    /**\n-     * Returns a PeriodType using the ISOChronology in current time zone of:\n-     *\n-     * <ul>\n-     * <li>days\n-     * <li>hours (precise)\n-     * <li>minutes (precise)\n-     * <li>seconds (precise)\n-     * <li>milliseconds (precise)\n-     * </ul>\n-     */\n-    public static PeriodType getDayHourType() {\n-        return DAY_HOUR;\n-    }\n-\n-    /**\n-     * Returns a precise PeriodType using the ISOChronology in UTC of:\n-     *\n-     * <ul>\n-     * <li>days (precise, fixed at 24 hours)\n-     * <li>hours (precise)\n-     * <li>minutes (precise)\n-     * <li>seconds (precise)\n-     * <li>milliseconds (precise)\n-     * </ul>\n-     */\n-    public static PeriodType getDayHourTypeUTC() {\n-        return DAY_HOUR_UTC;\n-    }\n-\n-    /**\n-     * Returns a PeriodType of:\n-     *\n-     * <ul>\n-     * <li>days\n-     * <li>hours (precise)\n-     * <li>minutes (precise)\n-     * <li>seconds (precise)\n-     * <li>milliseconds (precise)\n-     * </ul>\n-     *\n-     * This factory method returns a PeriodType that calculates using any Chronology.\n-     *\n-     * @param chrono Chronology to use for calculations.\n-     */\n-    public static PeriodType getDayHourType(Chronology chrono) {\n-        if (chrono == null || chrono.equals(ISOChronology.getInstance())) {\n-            return getDayHourType();\n-        }\n-        if (chrono == null || chrono.equals(ISOChronology.getInstanceUTC())) {\n-            return getDayHourTypeUTC();\n-        }\n-        return new DayHourType(chrono);\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Returns a PeriodType using the ISOChronology in current time zone of:\n-     *\n-     * <ul>\n-     * <li>years\n-     * <li>days\n-     * <li>hours (precise)\n-     * <li>minutes (precise)\n-     * <li>seconds (precise)\n-     * <li>milliseconds (precise)\n-     * </ul>\n-     */\n-    public static PeriodType getYearDayType() {\n-        return YEAR_DAY;\n-    }\n-\n-    /**\n-     * Returns a PeriodType using the ISOChronology in UTC of:\n-     *\n-     * <ul>\n-     * <li>years\n-     * <li>days (precise, fixed at 24 hours)\n-     * <li>hours (precise)\n-     * <li>minutes (precise)\n-     * <li>seconds (precise)\n-     * <li>milliseconds (precise)\n-     * </ul>\n-     */\n-    public static PeriodType getYearDayTypeUTC() {\n-        return YEAR_DAY_UTC;\n-    }\n-\n-    /**\n-     * Returns a PeriodType of:\n-     *\n-     * <ul>\n-     * <li>years\n-     * <li>days\n-     * <li>hours (precise)\n-     * <li>minutes (precise)\n-     * <li>seconds (precise)\n-     * <li>milliseconds (precise)\n-     * </ul>\n-     *\n-     * This factory method returns a PeriodType that calculates using any Chronology.\n-     *\n-     * @param chrono Chronology to use for calculations.\n-     */\n-    public static PeriodType getYearDayType(Chronology chrono) {\n-        if (chrono == null || chrono.equals(ISOChronology.getInstance())) {\n-            return getYearDayType();\n-        }\n-        if (chrono == null || chrono.equals(ISOChronology.getInstanceUTC())) {\n-            return getYearDayTypeUTC();\n-        }\n-        return new YearDayType(chrono);\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Returns a PeriodType using the ISOChronology in current time zone of:\n-     *\n-     * <ul>\n-     * <li>years (weekyears)\n-     * <li>weeks\n-     * <li>days\n-     * <li>hours (precise)\n-     * <li>minutes (precise)\n-     * <li>seconds (precise)\n-     * <li>milliseconds (precise)\n-     * </ul>\n-     */\n-    public static PeriodType getYearWeekType() {\n-        return YEAR_WEEK;\n-    }\n-\n-    /**\n-     * Returns a PeriodType using the ISOChronology in UTC of:\n-     *\n-     * <ul>\n-     * <li>years\n-     * <li>weeks (precise, fixed at 7 days)\n-     * <li>days (precise, fixed at 24 hours)\n-     * <li>hours (precise)\n-     * <li>minutes (precise)\n-     * <li>seconds (precise)\n-     * <li>milliseconds (precise)\n-     * </ul>\n-     */\n-    public static PeriodType getYearWeekTypeUTC() {\n-        return YEAR_WEEK_UTC;\n-    }\n-\n-    /**\n-     * Returns a PeriodType of:\n-     *\n-     * <ul>\n-     * <li>years (weekyears)\n-     * <li>weeks\n-     * <li>days\n-     * <li>hours\n-     * <li>minutes\n-     * <li>seconds\n-     * <li>milliseconds\n-     * </ul>\n-     *\n-     * This factory method returns a PeriodType that calculates using any Chronology.\n-     *\n-     * @param chrono Chronology to use for calculations.\n-     */\n-    public static PeriodType getYearWeekType(Chronology chrono) {\n-        if (chrono == null || chrono.equals(ISOChronology.getInstance())) {\n-            return getYearWeekType();\n-        }\n-        if (chrono == null || chrono.equals(ISOChronology.getInstanceUTC())) {\n-            return getYearWeekTypeUTC();\n-        }\n-        return new YearWeekType(chrono);\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Returns a PeriodType using the ISOChronology in current time zone of:\n-     *\n-     * <ul>\n-     * <li>years\n-     * <li>months\n-     * <li>days\n-     * <li>hours (precise)\n-     * <li>minutes (precise)\n-     * <li>seconds (precise)\n-     * <li>milliseconds (precise)\n-     * </ul>\n-     */\n-    public static PeriodType getYearMonthType() {\n-        return YEAR_MONTH;\n-    }\n-\n-    /**\n-     * Returns a PeriodType using the ISOChronology in UTC of:\n-     *\n-     * <ul>\n-     * <li>years\n-     * <li>months\n-     * <li>days (precise, fixed at 24 hours)\n-     * <li>hours (precise)\n-     * <li>minutes (precise)\n-     * <li>seconds (precise)\n-     * <li>milliseconds (precise)\n-     * </ul>\n-     */\n-    public static PeriodType getYearMonthTypeUTC() {\n-        return YEAR_MONTH_UTC;\n-    }\n-\n-    /**\n-     * Returns a PeriodType of:\n-     *\n-     * <ul>\n-     * <li>years\n-     * <li>months\n-     * <li>days\n-     * <li>hours\n-     * <li>minutes\n-     * <li>seconds\n-     * <li>milliseconds\n-     * </ul>\n-     *\n-     * This factory method returns a PeriodType that calculates using any Chronology.\n-     *\n-     * @param chrono Chronology to use for calculations.\n-     */\n-    public static PeriodType getYearMonthType(Chronology chrono) {\n-        if (chrono == null || chrono.equals(ISOChronology.getInstance())) {\n-            return getYearMonthType();\n-        }\n-        if (chrono == null || chrono.equals(ISOChronology.getInstanceUTC())) {\n-            return getYearMonthTypeUTC();\n-        }\n-        return new YearMonthType(chrono);\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Returns a PeriodType using the ISOChronology in current time zone of:\n-     *\n-     * <ul>\n-     * <li>years\n-     * <li>months\n-     * <li>weeks\n-     * <li>days\n-     * <li>hours (precise)\n-     * <li>minutes (precise)\n-     * <li>seconds (precise)\n-     * <li>milliseconds (precise)\n-     * </ul>\n-     */\n-    public static PeriodType getAllType() {\n-        return ALL;\n-    }\n-\n-    /**\n-     * Returns a PeriodType using the ISOChronology in UTC of:\n-     *\n-     * <ul>\n-     * <li>years\n-     * <li>months\n-     * <li>weeks (precise, fixed at 7 days)\n-     * <li>days (precise, fixed at 24 hours)\n-     * <li>hours (precise)\n-     * <li>minutes (precise)\n-     * <li>seconds (precise)\n-     * <li>milliseconds (precise)\n-     * </ul>\n-     */\n-    public static PeriodType getAllTypeUTC() {\n-        return ALL_UTC;\n-    }\n-\n-    /**\n-     * Returns a PeriodType of:\n-     *\n+    private static PeriodType cStandard;\n+    private static PeriodType cYMDTime;\n+    private static PeriodType cYWDTime;\n+    private static PeriodType cYDTime;\n+    private static PeriodType cDTime;\n+    private static PeriodType cTime;\n+    \n+    private static PeriodType cYears;\n+    private static PeriodType cMonths;\n+    private static PeriodType cWeeks;\n+    private static PeriodType cDays;\n+    private static PeriodType cHours;\n+    private static PeriodType cMinutes;\n+    private static PeriodType cSeconds;\n+    private static PeriodType cMillis;\n+\n+    /**\n+     * Gets a type that defines all standard fields.\n      * <ul>\n      * <li>years\n      * <li>months\n      * <li>milliseconds\n      * </ul>\n      *\n-     * This factory method returns a PeriodType that calculates using any Chronology.\n-     *\n-     * @param chrono Chronology to use for calculations.\n-     */\n-    public static PeriodType getAllType(Chronology chrono) {\n-        if (chrono == null || chrono.equals(ISOChronology.getInstance())) {\n-            return getAllType();\n-        }\n-        if (chrono == null || chrono.equals(ISOChronology.getInstanceUTC())) {\n-            return getAllTypeUTC();\n-        }\n-        return new AllType(chrono);\n+     * @return the period type\n+     */\n+    public static PeriodType standard() {\n+        PeriodType type = cStandard;\n+        if (type == null) {\n+            type = new PeriodType(\n+                \"Standard\",\n+                new DurationFieldType[] {\n+                    DurationFieldType.years(), DurationFieldType.months(),\n+                    DurationFieldType.weeks(), DurationFieldType.days(),\n+                    DurationFieldType.hours(), DurationFieldType.minutes(),\n+                    DurationFieldType.seconds(), DurationFieldType.millis(),\n+                },\n+                new int[] { 0, 1, 2, 3, 4, 5, 6, 7, }\n+            );\n+            cStandard = type;\n+        }\n+        return type;\n+    }\n+\n+    /**\n+     * Gets a type that defines all standard fields except weeks.\n+     * <ul>\n+     * <li>years\n+     * <li>months\n+     * <li>days\n+     * <li>hours\n+     * <li>minutes\n+     * <li>seconds\n+     * <li>milliseconds\n+     * </ul>\n+     *\n+     * @return the period type\n+     */\n+    public static PeriodType yearMonthDayTime() {\n+        PeriodType type = cYMDTime;\n+        if (type == null) {\n+            type = new PeriodType(\n+                \"YearMonthDayTime\",\n+                new DurationFieldType[] {\n+                    DurationFieldType.years(), DurationFieldType.months(),\n+                    DurationFieldType.days(),\n+                    DurationFieldType.hours(), DurationFieldType.minutes(),\n+                    DurationFieldType.seconds(), DurationFieldType.millis(),\n+                },\n+                new int[] { 0, 1, -1, 2, 3, 4, 5, 6, }\n+            );\n+            cYMDTime = type;\n+        }\n+        return type;\n+    }\n+\n+    /**\n+     * Gets a type that defines all standard fields except months.\n+     * <ul>\n+     * <li>years\n+     * <li>weeks\n+     * <li>days\n+     * <li>hours\n+     * <li>minutes\n+     * <li>seconds\n+     * <li>milliseconds\n+     * </ul>\n+     *\n+     * @return the period type\n+     */\n+    public static PeriodType yearWeekDayTime() {\n+        PeriodType type = cYWDTime;\n+        if (type == null) {\n+            type = new PeriodType(\n+                \"YearWeekDayTime\",\n+                new DurationFieldType[] {\n+                    DurationFieldType.years(),\n+                    DurationFieldType.weeks(), DurationFieldType.days(),\n+                    DurationFieldType.hours(), DurationFieldType.minutes(),\n+                    DurationFieldType.seconds(), DurationFieldType.millis(),\n+                },\n+                new int[] { 0, -1, 1, 2, 3, 4, 5, 6, }\n+            );\n+            cYWDTime = type;\n+        }\n+        return type;\n+    }\n+\n+    /**\n+     * Gets a type that defines all standard fields except months and weeks.\n+     * <ul>\n+     * <li>years\n+     * <li>days\n+     * <li>hours\n+     * <li>minutes\n+     * <li>seconds\n+     * <li>milliseconds\n+     * </ul>\n+     *\n+     * @return the period type\n+     */\n+    public static PeriodType yearDayTime() {\n+        PeriodType type = cYDTime;\n+        if (type == null) {\n+            type = new PeriodType(\n+                \"YearDayTime\",\n+                new DurationFieldType[] {\n+                    DurationFieldType.years(), DurationFieldType.days(),\n+                    DurationFieldType.hours(), DurationFieldType.minutes(),\n+                    DurationFieldType.seconds(), DurationFieldType.millis(),\n+                },\n+                new int[] { 0, -1, -1, 1, 2, 3, 4, 5, }\n+            );\n+            cYDTime = type;\n+        }\n+        return type;\n+    }\n+\n+    /**\n+     * Gets a type that defines all standard fields from days downwards.\n+     * <ul>\n+     * <li>days\n+     * <li>hours\n+     * <li>minutes\n+     * <li>seconds\n+     * <li>milliseconds\n+     * </ul>\n+     *\n+     * @return the period type\n+     */\n+    public static PeriodType dayTime() {\n+        PeriodType type = cDTime;\n+        if (type == null) {\n+            type = new PeriodType(\n+                \"DayTime\",\n+                new DurationFieldType[] {\n+                    DurationFieldType.days(),\n+                    DurationFieldType.hours(), DurationFieldType.minutes(),\n+                    DurationFieldType.seconds(), DurationFieldType.millis(),\n+                },\n+                new int[] { -1, -1, -1, 0, 1, 2, 3, 4, }\n+            );\n+            cDTime = type;\n+        }\n+        return type;\n+    }\n+\n+    /**\n+     * Gets a type that defines all standard time fields.\n+     * <ul>\n+     * <li>hours\n+     * <li>minutes\n+     * <li>seconds\n+     * <li>milliseconds\n+     * </ul>\n+     *\n+     * @return the period type\n+     */\n+    public static PeriodType time() {\n+        PeriodType type = cTime;\n+        if (type == null) {\n+            type = new PeriodType(\n+                \"Time\",\n+                new DurationFieldType[] {\n+                    DurationFieldType.hours(), DurationFieldType.minutes(),\n+                    DurationFieldType.seconds(), DurationFieldType.millis(),\n+                },\n+                new int[] { -1, -1, -1, -1, 0, 1, 2, 3, }\n+            );\n+            cTime = type;\n+        }\n+        return type;\n+    }\n+\n+    /**\n+     * Gets a type that defines just the years field.\n+     *\n+     * @return the period type\n+     */\n+    public static PeriodType years() {\n+        PeriodType type = cYears;\n+        if (type == null) {\n+            type = new PeriodType(\n+                \"Years\",\n+                new DurationFieldType[] { DurationFieldType.years() },\n+                new int[] { 0, -1, -1, -1, -1, -1, -1, -1, }\n+            );\n+            cYears = type;\n+        }\n+        return type;\n+    }\n+\n+    /**\n+     * Gets a type that defines just the months field.\n+     *\n+     * @return the period type\n+     */\n+    public static PeriodType months() {\n+        PeriodType type = cMonths;\n+        if (type == null) {\n+            type = new PeriodType(\n+                \"Months\",\n+                new DurationFieldType[] { DurationFieldType.months() },\n+                new int[] { -1, 0, -1, -1, -1, -1, -1, -1, }\n+            );\n+            cMonths = type;\n+        }\n+        return type;\n+    }\n+\n+    /**\n+     * Gets a type that defines just the weeks field.\n+     *\n+     * @return the period type\n+     */\n+    public static PeriodType weeks() {\n+        PeriodType type = cWeeks;\n+        if (type == null) {\n+            type = new PeriodType(\n+                \"Weeks\",\n+                new DurationFieldType[] { DurationFieldType.weeks() },\n+                new int[] { -1, -1, 0, -1, -1, -1, -1, -1, }\n+            );\n+            cWeeks = type;\n+        }\n+        return type;\n+    }\n+\n+    /**\n+     * Gets a type that defines just the days field.\n+     *\n+     * @return the period type\n+     */\n+    public static PeriodType days() {\n+        PeriodType type = cDays;\n+        if (type == null) {\n+            type = new PeriodType(\n+                \"Days\",\n+                new DurationFieldType[] { DurationFieldType.days() },\n+                new int[] { -1, -1, -1, 0, -1, -1, -1, -1, }\n+            );\n+            cDays = type;\n+        }\n+        return type;\n+    }\n+\n+    /**\n+     * Gets a type that defines just the hours field.\n+     *\n+     * @return the period type\n+     */\n+    public static PeriodType hours() {\n+        PeriodType type = cHours;\n+        if (type == null) {\n+            type = new PeriodType(\n+                \"Hours\",\n+                new DurationFieldType[] { DurationFieldType.hours() },\n+                new int[] { -1, -1, -1, -1, 0, -1, -1, -1, }\n+            );\n+            cHours = type;\n+        }\n+        return type;\n+    }\n+\n+    /**\n+     * Gets a type that defines just the minutes field.\n+     *\n+     * @return the period type\n+     */\n+    public static PeriodType minutes() {\n+        PeriodType type = cMinutes;\n+        if (type == null) {\n+            type = new PeriodType(\n+                \"Minutes\",\n+                new DurationFieldType[] { DurationFieldType.minutes() },\n+                new int[] { -1, -1, -1, -1, -1, 0, -1, -1, }\n+            );\n+            cMinutes = type;\n+        }\n+        return type;\n+    }\n+\n+    /**\n+     * Gets a type that defines just the seconds field.\n+     *\n+     * @return the period type\n+     */\n+    public static PeriodType seconds() {\n+        PeriodType type = cSeconds;\n+        if (type == null) {\n+            type = new PeriodType(\n+                \"Seconds\",\n+                new DurationFieldType[] { DurationFieldType.seconds() },\n+                new int[] { -1, -1, -1, -1, -1, -1, 0, -1, }\n+            );\n+            cSeconds = type;\n+        }\n+        return type;\n+    }\n+\n+    /**\n+     * Gets a type that defines just the millis field.\n+     *\n+     * @return the period type\n+     */\n+    public static PeriodType millis() {\n+        PeriodType type = cMillis;\n+        if (type == null) {\n+            type = new PeriodType(\n+                \"Millis\",\n+                new DurationFieldType[] { DurationFieldType.millis() },\n+                new int[] { -1, -1, -1, -1, -1, -1, -1, 0, }\n+            );\n+            cMillis = type;\n+        }\n+        return type;\n+    }\n+\n+    //-----------------------------------------------------------------------    \n+    /** The name of the type */\n+    private final String iName;\n+    /** The array of types */\n+    private final DurationFieldType[] iTypes;\n+    /** The array of indices */\n+    private final int[] iIndices;\n+\n+    /**\n+     * Constructor.\n+     *\n+     * @param name  the name\n+     * @param types  the types\n+     * @param indices  the indices\n+     */\n+    protected PeriodType(String name, DurationFieldType[] types, int[] indices) {\n+        super();\n+        iName = name;\n+        iTypes = types;\n+        iIndices = indices;\n     }\n \n     //-----------------------------------------------------------------------\n     /**\n-     * Returns a precise PeriodType using the ISOChronology in UTC of:\n-     *\n-     * <ul>\n-     * <li>days (precise, fixed at 24 hours)\n-     * <li>hours (precise)\n-     * <li>minutes (precise)\n-     * <li>seconds (precise)\n-     * <li>milliseconds (precise)\n-     * </ul>\n-     */\n-    public static PeriodType getPreciseDayHourType() {\n-        return PRECISE_DAY_HOUR;\n-    }\n-\n-    /**\n-     * Returns a precise PeriodType using the ISOChronology in UTC of:\n-     *\n-     * <ul>\n-     * <li>years (precise, fixed at 365 days)\n-     * <li>days (precise, fixed at 24 hours)\n-     * <li>hours (precise)\n-     * <li>minutes (precise)\n-     * <li>seconds (precise)\n-     * <li>milliseconds (precise)\n-     * </ul>\n-     */\n-    public static PeriodType getPreciseYearDayType() {\n-        return PRECISE_YEAR_DAY;\n-    }\n-\n-    /**\n-     * Returns a precise PeriodType using the ISOChronology in UTC of:\n-     *\n-     * <ul>\n-     * <li>years (precise, fixed at 365 days)\n-     * <li>months (precise, fixed at 30 days)\n-     * <li>days (precise, fixed at 24 hours)\n-     * <li>hours (precise)\n-     * <li>minutes (precise)\n-     * <li>seconds (precise)\n-     * <li>milliseconds (precise)\n-     * </ul>\n-     */\n-    public static PeriodType getPreciseYearMonthType() {\n-        return PRECISE_YEAR_MONTH;\n-    }\n-\n-    /**\n-     * Returns a precise PeriodType using the ISOChronology in UTC of:\n-     *\n-     * <ul>\n-     * <li>years (precise, fixed at 365 days)\n-     * <li>weeks (precise, fixed at 7 days)\n-     * <li>days (precise, fixed at 24 hours)\n-     * <li>hours (precise)\n-     * <li>minutes (precise)\n-     * <li>seconds (precise)\n-     * <li>milliseconds (precise)\n-     * </ul>\n-     */\n-    public static PeriodType getPreciseYearWeekType() {\n-        return PRECISE_YEAR_WEEK;\n-    }\n-\n-    /**\n-     * Returns a precise PeriodType using the ISOChronology in UTC of:\n-     *\n-     * <ul>\n-     * <li>years (precise, fixed at 365 days)\n-     * <li>months (precise, fixed at 30 days)\n-     * <li>weeks (precise, fixed at 7 days)\n-     * <li>days (precise, fixed at 24 hours)\n-     * <li>hours (precise)\n-     * <li>minutes (precise)\n-     * <li>seconds (precise)\n-     * <li>milliseconds (precise)\n-     * </ul>\n-     */\n-    public static PeriodType getPreciseAllType() {\n-        return PRECISE_ALL;\n+     * Gets the name of the period type.\n+     * \n+     * @return the name\n+     */\n+    public String getName() {\n+        return iName;\n+    }\n+\n+    /**\n+     * Gets the number of fields in the period type.\n+     * \n+     * @return the number of fields\n+     */\n+    public int size() {\n+        return iTypes.length;\n+    }\n+\n+    /**\n+     * Gets the field type by index.\n+     * \n+     * @param index  the index to retrieve\n+     * @return the field type\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    public DurationFieldType getFieldType(int index) {\n+        return iTypes[index];\n+    }\n+\n+    /**\n+     * Checks whether the field specified is supported by this period.\n+     *\n+     * @param type  the type to check, may be null which returns false\n+     * @return true if the field is supported\n+     */\n+    public boolean isSupported(DurationFieldType type) {\n+        return (indexOf(type) >= 0);\n+    }\n+\n+    /**\n+     * Gets the index of the field in this period.\n+     *\n+     * @param type  the type to check, may be null which returns -1\n+     * @return the index of -1 if not supported\n+     */\n+    public int indexOf(DurationFieldType type) {\n+        for (int i = 0, isize = size(); i < isize; i++) {\n+            if (iTypes[i] == type) {\n+                return i;\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    /**\n+     * Gets a debugging to string.\n+     * \n+     * @return a string\n+     */\n+    public String toString() {\n+        String name = getName();\n+        return \"PeriodType[\" + getName() + \"]\";\n     }\n \n     //-----------------------------------------------------------------------\n     /**\n-     * Constructor.\n-     */\n-    protected PeriodType() {\n-    }\n-\n-    /**\n-     * Gets the name of the period type.\n-     * \n-     * @return the name\n-     */\n-    public abstract String getName();\n-\n-    /**\n-     * Returns the chronology used, or null if none.\n-     * \n-     * @return the chronology\n-     */\n-    public abstract Chronology getChronology();\n-\n-    /**\n-     * Returns a PeriodType that uses the given chronology.\n-     * \n-     * @param chrono  the new chronology, null means ISOChronology in UTC\n-     * @return a new period type with the specified chronology\n-     */\n-    public abstract PeriodType withChronology(Chronology chrono);\n-\n-    /**\n-     * Returns true if every supported field in this type is precise.\n-     * \n-     * @return true if precise\n-     */\n-    public abstract boolean isPrecise();\n+     * Gets the years field part of the period.\n+     * \n+     * @param period  the period to query\n+     * @return the number of years in the period, zero if unsupported\n+     */\n+    public int getYears(ReadablePeriod period) {\n+        int index = iIndices[0];\n+        return (index == -1 ? 0 : period.getValue(index));\n+    }\n+\n+    /**\n+     * Gets the months field part of the period.\n+     * \n+     * @param period  the period to query\n+     * @return the number of months in the period, zero if unsupported\n+     */\n+    public int getMonths(ReadablePeriod period) {\n+        int index = iIndices[1];\n+        return (index == -1 ? 0 : period.getValue(index));\n+    }\n+\n+    /**\n+     * Gets the weeks field part of the period.\n+     * \n+     * @param period  the period to query\n+     * @return the number of weeks in the period, zero if unsupported\n+     */\n+    public int getWeeks(ReadablePeriod period) {\n+        int index = iIndices[2];\n+        return (index == -1 ? 0 : period.getValue(index));\n+    }\n+\n+    /**\n+     * Gets the days field part of the period.\n+     * \n+     * @param period  the period to query\n+     * @return the number of days in the period, zero if unsupported\n+     */\n+    public int getDays(ReadablePeriod period) {\n+        int index = iIndices[3];\n+        return (index == -1 ? 0 : period.getValue(index));\n+    }\n \n     //-----------------------------------------------------------------------\n     /**\n-     * Returns a DurationField representing years.\n-     *\n-     * @return DurationField or UnsupportedDurationField if unsupported\n-     */\n-    public DurationField years() {\n-        return UnsupportedDurationField.getInstance(DurationFieldType.years());\n-    }\n-\n-    /**\n-     * Returns a DurationField representing months.\n-     *\n-     * @return DurationField or UnsupportedDurationField if unsupported\n-     */\n-    public DurationField months() {\n-        return UnsupportedDurationField.getInstance(DurationFieldType.months());\n-    }\n-\n-    /**\n-     * Returns a DurationField representing weeks.\n-     *\n-     * @return DurationField or UnsupportedDurationField if unsupported\n-     */\n-    public DurationField weeks() {\n-        return UnsupportedDurationField.getInstance(DurationFieldType.weeks());\n-    }\n-\n-    /**\n-     * Returns a DurationField representing days.\n-     *\n-     * @return DurationField or UnsupportedDurationField if unsupported\n-     */\n-    public DurationField days() {\n-        return UnsupportedDurationField.getInstance(DurationFieldType.days());\n-    }\n-\n-    /**\n-     * Returns a DurationField representing hours.\n-     *\n-     * @return DurationField or UnsupportedDurationField if unsupported\n-     */\n-    public DurationField hours() {\n-        return UnsupportedDurationField.getInstance(DurationFieldType.hours());\n-    }\n-\n-    /**\n-     * Returns a DurationField representing minutes.\n-     *\n-     * @return DurationField or UnsupportedDurationField if unsupported\n-     */\n-    public DurationField minutes() {\n-        return UnsupportedDurationField.getInstance(DurationFieldType.minutes());\n-    }\n-\n-    /**\n-     * Returns a DurationField representing seconds.\n-     *\n-     * @return DurationField or UnsupportedDurationField if unsupported\n-     */\n-    public DurationField seconds() {\n-        return UnsupportedDurationField.getInstance(DurationFieldType.seconds());\n-    }\n-\n-    /**\n-     * Returns a DurationField representing milliseconds.\n-     *\n-     * @return DurationField or UnsupportedDurationField if unsupported\n-     */\n-    public DurationField millis() {\n-        return UnsupportedDurationField.getInstance(DurationFieldType.millis());\n+     * Gets the hours field part of the period.\n+     * \n+     * @param period  the period to query\n+     * @return the number of hours in the period, zero if unsupported\n+     */\n+    public int getHours(ReadablePeriod period) {\n+        int index = iIndices[4];\n+        return (index == -1 ? 0 : period.getValue(index));\n+    }\n+\n+    /**\n+     * Gets the minutes field part of the period.\n+     * \n+     * @param period  the period to query\n+     * @return the number of minutes in the period, zero if unsupported\n+     */\n+    public int getMinutes(ReadablePeriod period) {\n+        int index = iIndices[5];\n+        return (index == -1 ? 0 : period.getValue(index));\n+    }\n+\n+    /**\n+     * Gets the seconds field part of the period.\n+     * \n+     * @param period  the period to query\n+     * @return the number of seconds in the period, zero if unsupported\n+     */\n+    public int getSeconds(ReadablePeriod period) {\n+        int index = iIndices[6];\n+        return (index == -1 ? 0 : period.getValue(index));\n+    }\n+\n+    /**\n+     * Gets the millis field part of the period.\n+     * \n+     * @param period  the period to query\n+     * @return the number of millis in the period, zero if unsupported\n+     */\n+    public int getMillis(ReadablePeriod period) {\n+        int index = iIndices[7];\n+        return (index == -1 ? 0 : period.getValue(index));\n     }\n \n     //-----------------------------------------------------------------------\n      * @return a new period type that supports the original set of fields except years\n      */\n     public PeriodType withYearsRemoved() {\n-        if (!years().isSupported()) {\n+        return withFieldRemoved(0, \"NoYears\");\n+    }\n+\n+    /**\n+     * Returns a version of this PeriodType instance that does not support months.\n+     * \n+     * @return a new period type that supports the original set of fields except months\n+     */\n+    public PeriodType withMonthsRemoved() {\n+        return withFieldRemoved(1, \"NoMonths\");\n+    }\n+\n+    /**\n+     * Returns a version of this PeriodType instance that does not support weeks.\n+     * \n+     * @return a new period type that supports the original set of fields except weeks\n+     */\n+    public PeriodType withWeeksRemoved() {\n+        return withFieldRemoved(2, \"NoWeeks\");\n+    }\n+\n+    /**\n+     * Returns a version of this PeriodType instance that does not support days.\n+     * \n+     * @return a new period type that supports the original set of fields except days\n+     */\n+    public PeriodType withDaysRemoved() {\n+        return withFieldRemoved(3, \"NoDays\");\n+    }\n+\n+    /**\n+     * Returns a version of this PeriodType instance that does not support hours.\n+     * \n+     * @return a new period type that supports the original set of fields except hours\n+     */\n+    public PeriodType withHoursRemoved() {\n+        return withFieldRemoved(4, \"NoHours\");\n+    }\n+\n+    /**\n+     * Returns a version of this PeriodType instance that does not support minutes.\n+     * \n+     * @return a new period type that supports the original set of fields except minutes\n+     */\n+    public PeriodType withMinutesRemoved() {\n+        return withFieldRemoved(5, \"NoMinutes\");\n+    }\n+\n+    /**\n+     * Returns a version of this PeriodType instance that does not support seconds.\n+     * \n+     * @return a new period type that supports the original set of fields except seconds\n+     */\n+    public PeriodType withSecondsRemoved() {\n+        return withFieldRemoved(6, \"NoSeconds\");\n+    }\n+\n+    /**\n+     * Returns a version of this PeriodType instance that does not support milliseconds.\n+     * \n+     * @return a new period type that supports the original set of fields except milliseconds\n+     */\n+    public PeriodType withMillisRemoved() {\n+        return withFieldRemoved(7, \"NoMillis\");\n+    }\n+\n+    /**\n+     * Removes the field specified by indices index.\n+     * \n+     * @param indicesIndex  the index to remove\n+     * @param name  the name addition\n+     * @return the new type\n+     */\n+    private PeriodType withFieldRemoved(int indicesIndex, String name) {\n+        int fieldIndex = iIndices[indicesIndex];\n+        if (fieldIndex == -1) {\n             return this;\n         }\n-        return MaskedType.mask(this, 1 << 0);\n-    }\n-\n-    /**\n-     * Returns a version of this PeriodType instance that does not support months.\n-     * \n-     * @return a new period type that supports the original set of fields except months\n-     */\n-    public PeriodType withMonthsRemoved() {\n-        if (!months().isSupported()) {\n-            return this;\n-        }\n-        return MaskedType.mask(this, 1 << 1);\n-    }\n-\n-    /**\n-     * Returns a version of this PeriodType instance that does not support weeks.\n-     * \n-     * @return a new period type that supports the original set of fields except weeks\n-     */\n-    public PeriodType withWeeksRemoved() {\n-        if (!weeks().isSupported()) {\n-            return this;\n-        }\n-        return MaskedType.mask(this, 1 << 2);\n-    }\n-\n-    /**\n-     * Returns a version of this PeriodType instance that does not support days.\n-     * \n-     * @return a new period type that supports the original set of fields except days\n-     */\n-    public PeriodType withDaysRemoved() {\n-        if (!days().isSupported()) {\n-            return this;\n-        }\n-        return MaskedType.mask(this, 1 << 3);\n-    }\n-\n-    /**\n-     * Returns a version of this PeriodType instance that does not support hours.\n-     * \n-     * @return a new period type that supports the original set of fields except hours\n-     */\n-    public PeriodType withHoursRemoved() {\n-        if (!hours().isSupported()) {\n-            return this;\n-        }\n-        return MaskedType.mask(this, 1 << 4);\n-    }\n-\n-    /**\n-     * Returns a version of this PeriodType instance that does not support minutes.\n-     * \n-     * @return a new period type that supports the original set of fields except minutes\n-     */\n-    public PeriodType withMinutesRemoved() {\n-        if (!minutes().isSupported()) {\n-            return this;\n-        }\n-        return MaskedType.mask(this, 1 << 5);\n-    }\n-\n-    /**\n-     * Returns a version of this PeriodType instance that does not support seconds.\n-     * \n-     * @return a new period type that supports the original set of fields except seconds\n-     */\n-    public PeriodType withSecondsRemoved() {\n-        if (!seconds().isSupported()) {\n-            return this;\n-        }\n-        return MaskedType.mask(this, 1 << 6);\n-    }\n-\n-    /**\n-     * Returns a version of this PeriodType instance that does not support milliseconds.\n-     * \n-     * @return a new period type that supports the original set of fields except milliseconds\n-     */\n-    public PeriodType withMillisRemoved() {\n-        if (!millis().isSupported()) {\n-            return this;\n-        }\n-        return MaskedType.mask(this, 1 << 7);\n+        \n+        DurationFieldType[] types = new DurationFieldType[size() - 1];\n+        for (int i = 0; i < iTypes.length; i++) {\n+            if (i < fieldIndex) {\n+                types[i] = iTypes[i];\n+            } else if (i > fieldIndex) {\n+                types[i - 1] = iTypes[i];\n+            }\n+        }\n+        \n+        int[] indices = new int[8];\n+        for (int i = 0; i < indices.length; i++) {\n+            if (i < indicesIndex) {\n+                indices[i] = iIndices[i];\n+            } else if (i > indicesIndex) {\n+                indices[i] = (iIndices[i] == -1 ? -1 : iIndices[i] - 1);\n+            } else {\n+                indices[i] = -1;\n+            }\n+        }\n+        return new PeriodType(getName() + name, types, indices);\n     }\n \n     //-----------------------------------------------------------------------\n     /**\n      * Compares this type to another object.\n-     * To be equal, the object must be a PeriodType with the same chronology\n-     * and same supported fields.\n+     * To be equal, the object must be a PeriodType with the same set of fields.\n      * \n      * @param obj  the object to compare to\n      * @return true if equal\n         if (this == obj) {\n             return true;\n         }\n-        if (!(obj instanceof PeriodType)) {\n+        if (obj instanceof PeriodType == false) {\n             return false;\n         }\n-        PeriodType other = (PeriodType)obj;\n-        Chronology chrono = getChronology();\n-        if (chrono == null) {\n-            if (other.getChronology() != null) {\n-                return false;\n-            }\n-        } else if (!chrono.equals(other.getChronology())) {\n-            return false;\n-        }\n-        return years().equals(other.years())\n-            && months().equals(other.months())\n-            && weeks().equals(other.weeks())\n-            && days().equals(other.days())\n-            && hours().equals(other.hours())\n-            && minutes().equals(other.minutes())\n-            && seconds().equals(other.seconds())\n-            && millis().equals(other.millis());\n-    }\n-\n-    /**\n-     * Returns a hashcode based on the chronology and supported fields.\n+        PeriodType other = (PeriodType) obj;\n+        return (Arrays.equals(iTypes, other.iTypes));\n+    }\n+\n+    /**\n+     * Returns a hashcode based on the field types.\n      * \n      * @return a suitable hashcode\n      */\n     public int hashCode() {\n         int hash = 0;\n-        Chronology chrono = getChronology();\n-        if (chrono != null) {\n-            hash += chrono.hashCode();\n-        }\n-        hash = hash\n-            + years().hashCode()\n-            + months().hashCode()\n-            + weeks().hashCode()\n-            + days().hashCode()\n-            + hours().hashCode()\n-            + minutes().hashCode()\n-            + seconds().hashCode()\n-            + millis().hashCode();\n+        for (int i = 0; i < iTypes.length; i++) {\n+            hash += iTypes[i].hashCode();\n+        }\n         return hash;\n     }\n-    \n-    public String toString() {\n-        String name = getName();\n-        return \"PeriodType[\" + (name == null ? \"\" : name) + \"]\";\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    private static class MillisType extends PeriodType {\n-        private static final long serialVersionUID = -4314867016852780422L;\n-\n-        MillisType() {\n-        }\n-\n-        public boolean isPrecise() {\n-            return true;\n-        }\n-\n-        public final DurationField millis() {\n-            return MillisDurationField.INSTANCE;\n-        }\n-\n-        public Chronology getChronology() {\n-            return ISOChronology.getInstanceUTC();\n-        }\n-\n-        public PeriodType withChronology(Chronology chrono) {\n-            return this;\n-        }\n-\n-        private Object readResolve() {\n-            return getMillisType();\n-        }\n-        \n-        public String getName() {\n-            return \"MillisType\";\n-        }\n-    }\n-\n-    private static class DayHourType extends PeriodType {\n-        private static final long serialVersionUID = 1115025839896760481L;\n-\n-        protected final Chronology iChronology;\n-\n-        DayHourType(Chronology chrono) {\n-            iChronology = chrono;\n-        }\n-\n-        public final Chronology getChronology() {\n-            return iChronology;\n-        }\n-\n-        public PeriodType withChronology(Chronology chrono) {\n-            if (chrono == iChronology) {\n-                return this;\n-            }\n-            return PeriodType.getDayHourType(chrono);\n-        }\n-\n-        public boolean isPrecise() {\n-            return days().isPrecise()\n-                && hours().isPrecise()\n-                && minutes().isPrecise()\n-                && seconds().isPrecise()\n-                && minutes().isPrecise();\n-        }\n-\n-        public final DurationField days() {\n-            return iChronology.days();\n-        }\n-\n-        public final DurationField hours() {\n-            return iChronology.hours();\n-        }\n-\n-        public final DurationField minutes() {\n-            return iChronology.minutes();\n-        }\n-\n-        public final DurationField seconds() {\n-            return iChronology.seconds();\n-        }\n-\n-        public final DurationField millis() {\n-            return iChronology.millis();\n-        }\n-\n-        private Object readResolve() {\n-            return getDayHourType(iChronology);\n-        }\n-        \n-        public String getName() {\n-            return \"DayHourType\";\n-        }\n-    }\n-\n-    private static class YearDayType extends DayHourType {\n-        private static final long serialVersionUID = 6567563546499L;\n-\n-        YearDayType(Chronology chrono) {\n-            super(chrono);\n-        }\n-\n-        public PeriodType withChronology(Chronology chrono) {\n-            if (chrono == iChronology) {\n-                return this;\n-            }\n-            return PeriodType.getYearDayType(chrono);\n-        }\n-\n-        public boolean isPrecise() {\n-            return years().isPrecise()\n-                && super.isPrecise();\n-        }\n-\n-        public DurationField years() {\n-            return iChronology.weekyears();\n-        }\n-\n-        private Object readResolve() {\n-            return getYearDayType(iChronology);\n-        }\n-        \n-        public String getName() {\n-            return \"YearDayType\";\n-        }\n-    }\n-\n-    private static class YearWeekType extends DayHourType {\n-        private static final long serialVersionUID = 1347170237843447098L;\n-\n-        YearWeekType(Chronology chrono) {\n-            super(chrono);\n-        }\n-\n-        public PeriodType withChronology(Chronology chrono) {\n-            if (chrono == iChronology) {\n-                return this;\n-            }\n-            return PeriodType.getYearWeekType(chrono);\n-        }\n-\n-        public boolean isPrecise() {\n-            return years().isPrecise()\n-                && weeks().isPrecise()\n-                && super.isPrecise();\n-        }\n-\n-        public DurationField years() {\n-            return iChronology.years();\n-        }\n-\n-        public DurationField weeks() {\n-            return iChronology.weeks();\n-        }\n-\n-        private Object readResolve() {\n-            return getYearWeekType(iChronology);\n-        }\n-        \n-        public String getName() {\n-            return \"YearWeekType\";\n-        }\n-    }\n-\n-    private static class YearMonthType extends DayHourType {\n-        private static final long serialVersionUID = -1336767257680877683L;\n-\n-        YearMonthType(Chronology chrono) {\n-            super(chrono);\n-        }\n-\n-        public PeriodType withChronology(Chronology chrono) {\n-            if (chrono == iChronology) {\n-                return this;\n-            }\n-            return PeriodType.getYearMonthType(chrono);\n-        }\n-\n-        public boolean isPrecise() {\n-            return years().isPrecise()\n-                && months().isPrecise()\n-                && super.isPrecise();\n-        }\n-\n-        public DurationField years() {\n-            return iChronology.years();\n-        }\n-\n-        public DurationField months() {\n-            return iChronology.months();\n-        }\n-\n-        private Object readResolve() {\n-            return getYearMonthType(iChronology);\n-        }\n-        \n-        public String getName() {\n-            return \"YearMonthType\";\n-        }\n-    }\n-\n-    private static class AllType extends DayHourType {\n-        private static final long serialVersionUID = -359769822629866L;\n-\n-        AllType(Chronology chrono) {\n-            super(chrono);\n-        }\n-\n-        public PeriodType withChronology(Chronology chrono) {\n-            if (chrono == iChronology) {\n-                return this;\n-            }\n-            return PeriodType.getAllType(chrono);\n-        }\n-\n-        public boolean isPrecise() {\n-            return years().isPrecise()\n-                && months().isPrecise()\n-                && weeks().isPrecise()\n-                && super.isPrecise();\n-        }\n-\n-        public DurationField years() {\n-            return iChronology.years();\n-        }\n-\n-        public DurationField months() {\n-            return iChronology.months();\n-        }\n-\n-        public DurationField weeks() {\n-            return iChronology.weeks();\n-        }\n-\n-        private Object readResolve() {\n-            return getAllType(iChronology);\n-        }\n-        \n-        public String getName() {\n-            return \"AllType\";\n-        }\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    private static class PreciseDayHourType extends PeriodType {\n-        private static final long serialVersionUID = 216528691637527857L;\n-\n-        protected final Chronology iChronology;\n-\n-        PreciseDayHourType(Chronology chrono) {\n-            iChronology = chrono;\n-        }\n-\n-        public final Chronology getChronology() {\n-            return iChronology;\n-        }\n-\n-        public PeriodType withChronology(Chronology chrono) {\n-            return this;\n-        }\n-\n-        public boolean isPrecise() {\n-            return true;\n-        }\n-\n-        public final DurationField days() {\n-            return iChronology.days();\n-        }\n-\n-        public final DurationField hours() {\n-            return iChronology.hours();\n-        }\n-\n-        public final DurationField minutes() {\n-            return iChronology.minutes();\n-        }\n-\n-        public final DurationField seconds() {\n-            return iChronology.seconds();\n-        }\n-\n-        public final DurationField millis() {\n-            return iChronology.millis();\n-        }\n-\n-        private Object readResolve() {\n-            return getPreciseDayHourType();\n-        }\n-        \n-        public String getName() {\n-            return \"PreciseDayHourType\";\n-        }\n-    }\n-\n-    private static class PreciseYearDayType extends PreciseDayHourType {\n-        private static final long serialVersionUID = -2553285612358L;\n-\n-        private final DurationField iYears;\n-        \n-        PreciseYearDayType(Chronology chrono) {\n-            super(chrono);\n-            iYears = new ScaledDurationField(chrono.days(), DurationFieldType.years(), 365);\n-            // rely on days/weeks to be precise because only ISO UTC used\n-        }\n-\n-        public PeriodType withChronology(Chronology chrono) {\n-            return this;\n-        }\n-\n-        public boolean isPrecise() {\n-            return years().isPrecise()\n-                && super.isPrecise();\n-        }\n-\n-        public DurationField years() {\n-            return iYears;\n-        }\n-\n-        private Object readResolve() {\n-            return getPreciseYearDayType();\n-        }\n-        \n-        public String getName() {\n-            return \"PreciseYearDayType\";\n-        }\n-    }\n-\n-    private static class PreciseYearWeekType extends PreciseYearDayType {\n-        private static final long serialVersionUID = -2040324323318740267L;\n-\n-        PreciseYearWeekType(Chronology chrono) {\n-            super(chrono);\n-        }\n-\n-        public PeriodType withChronology(Chronology chrono) {\n-            return this;\n-        }\n-\n-        public boolean isPrecise() {\n-            return weeks().isPrecise()\n-                && super.isPrecise();\n-        }\n-\n-        public DurationField weeks() {\n-            return iChronology.weeks();\n-        }\n-\n-        private Object readResolve() {\n-            return getPreciseYearWeekType();\n-        }\n-        \n-        public String getName() {\n-            return \"PreciseYearWeekType\";\n-        }\n-    }\n-\n-    private static class PreciseYearMonthType extends PreciseYearDayType {\n-        private static final long serialVersionUID = 1203161678926193794L;\n-\n-        private final DurationField iMonths;\n-        \n-        PreciseYearMonthType(Chronology chrono) {\n-            super(chrono);\n-            iMonths = new ScaledDurationField(chrono.days(), DurationFieldType.months(), 30);\n-        }\n-\n-        public PeriodType withChronology(Chronology chrono) {\n-            return this;\n-        }\n-\n-        public boolean isPrecise() {\n-            return months().isPrecise()\n-                && super.isPrecise();\n-        }\n-\n-        public DurationField months() {\n-            return iMonths;\n-        }\n-\n-        private Object readResolve() {\n-            return getPreciseYearMonthType();\n-        }\n-        \n-        public String getName() {\n-            return \"PreciseYearMonthType\";\n-        }\n-    }\n-\n-    private static class PreciseAllType extends PreciseYearMonthType {\n-        private static final long serialVersionUID = 43967269280186L;\n-\n-        PreciseAllType(Chronology chrono) {\n-            super(chrono);\n-        }\n-\n-        public PeriodType withChronology(Chronology chrono) {\n-            return this;\n-        }\n-\n-        public boolean isPrecise() {\n-            return weeks().isPrecise()\n-                && super.isPrecise();\n-        }\n-\n-        public DurationField weeks() {\n-            return iChronology.weeks();\n-        }\n-\n-        private Object readResolve() {\n-            return getPreciseAllType();\n-        }\n-        \n-        public String getName() {\n-            return \"PreciseAllType\";\n-        }\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    private static class MaskedType extends PeriodType {\n-        private static final long serialVersionUID = 940106774669244586L;\n-\n-        public static PeriodType mask(PeriodType type, int mask) {\n-            if (type instanceof MaskedType) {\n-                MaskedType masked = (MaskedType)type;\n-                mask |= masked.iMask;\n-                type = masked.iType;\n-            }\n-            return new MaskedType(type, mask);\n-        }\n-\n-        private final PeriodType iType;\n-\n-        // Bit 0: when set, years is unsupported\n-        // Bit 1: when set, months is unsupported\n-        // ...\n-        private final int iMask;\n-\n-        private MaskedType(PeriodType type, int mask) {\n-            iType = type;\n-            iMask = mask;\n-        }\n-\n-        public Chronology getChronology() {\n-            return iType.getChronology();\n-        }\n-\n-        public PeriodType withChronology(Chronology chrono) {\n-            if (chrono == getChronology()) {\n-                return this;\n-            }\n-            return MaskedType.mask(iType.withChronology(chrono), iMask);\n-        }\n-\n-        public boolean isPrecise() {\n-            return years().isPrecise()\n-                && months().isPrecise()\n-                && weeks().isPrecise()\n-                && days().isPrecise()\n-                && hours().isPrecise()\n-                && minutes().isPrecise()\n-                && seconds().isPrecise()\n-                && minutes().isPrecise();\n-        }\n-\n-        public DurationField years() {\n-            if ((iMask & (1 << 0)) != 0) {\n-                return UnsupportedDurationField.getInstance(DurationFieldType.years());\n-            }\n-            return iType.years();\n-        }\n-\n-        public DurationField months() {\n-            if ((iMask & (1 << 1)) != 0) {\n-                return UnsupportedDurationField.getInstance(DurationFieldType.months());\n-            }\n-            return iType.months();\n-        }\n-\n-        public DurationField weeks() {\n-            if ((iMask & (1 << 2)) != 0) {\n-                return UnsupportedDurationField.getInstance(DurationFieldType.weeks());\n-            }\n-            return iType.weeks();\n-        }\n-\n-        public DurationField days() {\n-            if ((iMask & (1 << 3)) != 0) {\n-                return UnsupportedDurationField.getInstance(DurationFieldType.days());\n-            }\n-            return iType.days();\n-        }\n-\n-        public DurationField hours() {\n-            if ((iMask & (1 << 4)) != 0) {\n-                return UnsupportedDurationField.getInstance(DurationFieldType.hours());\n-            }\n-            return iType.hours();\n-        }\n-\n-        public DurationField minutes() {\n-            if ((iMask & (1 << 5)) != 0) {\n-                return UnsupportedDurationField.getInstance(DurationFieldType.minutes());\n-            }\n-            return iType.minutes();\n-        }\n-\n-        public DurationField seconds() {\n-            if ((iMask & (1 << 6)) != 0) {\n-                return UnsupportedDurationField.getInstance(DurationFieldType.seconds());\n-            }\n-            return iType.seconds();\n-        }\n-\n-        public DurationField millis() {\n-            if ((iMask & (1 << 7)) != 0) {\n-                return UnsupportedDurationField.getInstance(DurationFieldType.millis());\n-            }\n-            return iType.millis();\n-        }\n-        \n-        public String getName() {\n-            String name = iType.getName();\n-            String maskStr = \"\";\n-            if ((iMask & (1 << 0)) != 0) {\n-                maskStr += \"Years\";\n-            }\n-            if ((iMask & (1 << 1)) != 0) {\n-                maskStr += \"Months\";\n-            }\n-            if ((iMask & (1 << 2)) != 0) {\n-                maskStr += \"Weeks\";\n-            }\n-            if ((iMask & (1 << 3)) != 0) {\n-                maskStr += \"Days\";\n-            }\n-            if ((iMask & (1 << 4)) != 0) {\n-                maskStr += \"Hours\";\n-            }\n-            if ((iMask & (1 << 5)) != 0) {\n-                maskStr += \"Minutes\";\n-            }\n-            if ((iMask & (1 << 6)) != 0) {\n-                maskStr += \"Seconds\";\n-            }\n-            if ((iMask & (1 << 7)) != 0) {\n-                maskStr += \"Millis\";\n-            }\n-            return \"Masked\" + maskStr + \"[\" + (name == null ? \"\" : name) + \"]\";\n-        }\n-    }\n \n }\n--- a/JodaTime/src/java/org/joda/time/ReadWritableInterval.java\n+++ b/JodaTime/src/java/org/joda/time/ReadWritableInterval.java\n      * Sets the period of this time interval, preserving the start instant.\n      *\n      * @param period  new period for interval, null means zero length\n+     * @param chrono  the chronology to add using, null means ISO default\n      * @throws IllegalArgumentException if the end is before the start\n      * @throws ArithmeticException if the end instant exceeds the capacity of a long\n      */\n-    void setPeriodAfterStart(ReadablePeriod period);\n+    void setPeriodAfterStart(ReadablePeriod period, Chronology chrono);\n \n     /**\n      * Sets the period of this time interval, preserving the end instant.\n      *\n      * @param period  new period for interval, null means zero length\n+     * @param chrono  the chronology to add using, null means ISO default\n      * @throws IllegalArgumentException if the end is before the start\n      * @throws ArithmeticException if the start instant exceeds the capacity of a long\n      */\n-    void setPeriodBeforeEnd(ReadablePeriod period);\n+    void setPeriodBeforeEnd(ReadablePeriod period, Chronology chrono);\n \n }\n--- a/JodaTime/src/java/org/joda/time/ReadWritablePeriod.java\n+++ b/JodaTime/src/java/org/joda/time/ReadWritablePeriod.java\n  */\n public interface ReadWritablePeriod extends ReadablePeriod {\n \n-    //-----------------------------------------------------------------------\n+    /**\n+     * Sets the value of one of the fields.\n+     * <p>\n+     * The field type specified must be one of those that is supported by the period.\n+     *\n+     * @param field  a DurationFieldType instance that is supported by this period\n+     * @param value  the new value for the field\n+     * @throws IllegalArgumentException if the field is null or not supported\n+     */\n+    void set(DurationFieldType field, int value);\n+\n     /**\n      * Sets all the fields in one go from another ReadablePeriod.\n      * \n      * fields using the period type.\n      * \n      * @param interval  the interval to set, null means zero length\n-     */\n-    void setPeriod(ReadableInterval interval);\n+     * @param chrono  the chronology to use, null means ISO default\n+     */\n+    void setPeriod(ReadableInterval interval, Chronology chrono);\n \n     /**\n      * Sets all the fields in one go from a millisecond interval dividing the\n      * \n      * @param startInstant  interval start, in milliseconds\n      * @param endInstant  interval end, in milliseconds\n-     */\n-    void setPeriod(long startInstant, long endInstant);\n+     * @param chrono  the chronology to use, null means ISO default\n+     */\n+    void setPeriod(long startInstant, long endInstant, Chronology chrono);\n \n     /**\n      * Sets all the fields in one go from a duration dividing the\n      * available precise field.\n      * \n      * @param duration  the duration to set, null means zero length\n-     */\n-    void setPeriod(ReadableDuration duration);\n+     * @param chrono  the chronology to use, null means ISO default\n+     */\n+    void setPeriod(ReadableDuration duration, Chronology chrono);\n \n     /**\n      * Sets all the fields in one go from a millisecond duration dividing the\n      * available precise field.\n      * \n      * @param duration  the duration, in milliseconds\n-     */\n-    void setPeriod(long duration);\n-\n-    //-----------------------------------------------------------------------\n+     * @param chrono  the chronology to use, null means ISO default\n+     */\n+    void setPeriod(long duration, Chronology chrono);\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Adds to the value of one of the fields.\n+     * <p>\n+     * The field type specified must be one of those that is supported by the period.\n+     *\n+     * @param field  a DurationFieldType instance that is supported by this period\n+     * @param value  the value to add to the field\n+     * @throws IllegalArgumentException if the field is null or not supported\n+     */\n+    void add(DurationFieldType field, int value);\n+\n     /**\n      * Adds a period to this one by adding each field in turn.\n      * \n      */\n     void add(long duration);\n \n-    /**\n-     * Normalizes all the field values in this period.\n-     * <p>\n-     * This method converts to a milliecond duration and back again.\n-     *\n-     * @throws IllegalStateException if this period is imprecise\n-     */\n-    void normalize();\n-\n     //-----------------------------------------------------------------------\n     /**\n      * Sets the number of years of the period.\n--- a/JodaTime/src/java/org/joda/time/ReadablePeriod.java\n+++ b/JodaTime/src/java/org/joda/time/ReadablePeriod.java\n  * Periods are split up into multiple fields, for example days and seconds.\n  * Implementations are not required to evenly distribute the values across the fields.\n  * The value for each field may be positive or negative.\n- * The {@link PeriodType} defines the rules for dividing the fields and which fields\n- * are supported. Unsupported fields always have a value of zero.\n  * <p>\n  * When a time period is added to an instant, the effect is to add each field in turn.\n  * For example, a time period could be defined as 3 months, 2 days and -1 hours.\n  * In most circumstances this would be the same as 3 months, 1 day, and 23 hours.\n  * However, when adding across a daylight savings boundary, a day may be 23 or 25 hours long.\n  * Thus, the time period is always added field by field to the datetime.\n+ * <p>\n+ * Periods are independent of chronology, and can only be treated as durations\n+ * when paired with a time.\n  *\n  * @see ReadableDuration\n  * @see ReadableInterval\n public interface ReadablePeriod {\n \n     /**\n-     * Returns the period type which defines which fields this period supports.\n-     * \n+     * Gets the period type that defines which fields are included in the period.\n+     *\n      * @return the period type\n      */\n     PeriodType getPeriodType();\n \n     /**\n-     * Is this period a precise length of time, or descriptive.\n-     * <p>\n-     * A precise period could include millis, seconds, minutes or hours.\n-     * However, days, weeks, months and years can vary in length, resulting in\n-     * an imprecise period.\n-     * <p>\n-     * An imprecise period can be made precise by pairing it with a\n-     * date in a {@link ReadableInterval}.\n-     *\n-     * @return true if the period is precise\n-     */\n-    boolean isPrecise();\n+     * Gets the number of fields that this period supports.\n+     *\n+     * @return the number of fields supported\n+     */\n+    int size();\n+\n+    /**\n+     * Gets the field type at the specified index.\n+     *\n+     * @param index  the index to retrieve\n+     * @return the field at the specified index\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    DurationFieldType getFieldType(int index);\n+\n+    /**\n+     * Gets the value at the specified index.\n+     *\n+     * @param index  the index to retrieve\n+     * @return the value of the field at the specified index\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    int getValue(int index);\n+\n+    /**\n+     * Gets the value of one of the fields.\n+     * <p>\n+     * If the field type specified is not supported by the period then zero\n+     * is returned.\n+     *\n+     * @param field  the field type to query, null returns zero\n+     * @return the value of that field, zero if field not supported\n+     */\n+    int get(DurationFieldType field);\n+\n+    /**\n+     * Checks whether the field type specified is supported by this period.\n+     *\n+     * @param field  the field to check, may be null which returns false\n+     * @return true if the field is supported\n+     */\n+    boolean isSupported(DurationFieldType field);\n \n     //-----------------------------------------------------------------------\n     /**\n      * Adds this period to the given instant, returning a new value.\n      * <p>\n-     * The addition uses the chronology of the PeriodType.\n+     * The addition uses the chronology specified, or ISOChronology\n+     * in the default zone if it is null.\n      * To add just once, pass in a scalar of one. To subtract once, pass\n      * in a scalar of minus one.\n      *\n-     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to add the\n-     * period to\n+     * @param instant  the millisecond instant to add the period to\n      * @param scalar  the number of times to add the period, negative to subtract\n-     * @return milliseconds value plus this period times scalar\n-     * @throws ArithmeticException if the result of the calculation is too large\n-     */\n-    long addTo(long instant, int scalar);\n-\n-    /**\n-     * Adds this period to the given instant, returning a new value.\n-     * <p>\n-     * The addition uses the chronology specified.\n-     * To add just once, pass in a scalar of one. To subtract once, pass\n-     * in a scalar of minus one.\n-     *\n-     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to add the\n-     * period to\n-     * @param scalar  the number of times to add the period, negative to subtract\n-     * @param chrono  override the chronology of the period type, unless null is passed in\n+     * @param chrono  the chronology to use, null means ISO in the default zone\n      * @return milliseconds value plus this period times scalar\n      * @throws ArithmeticException if the result of the calculation is too large\n      */\n \n     //-----------------------------------------------------------------------\n     /**\n-     * Gets the years field part of the period.\n-     * \n-     * @return the number of years in the period, zero if unsupported\n-     */\n-    int getYears();\n-\n-    /**\n-     * Gets the months field part of the period.\n-     * \n-     * @return the number of months in the period, zero if unsupported\n-     */\n-    int getMonths();\n-\n-    /**\n-     * Gets the weeks field part of the period.\n-     * \n-     * @return the number of weeks in the period, zero if unsupported\n-     */\n-    int getWeeks();\n-\n-    /**\n-     * Gets the days field part of the period.\n-     * \n-     * @return the number of days in the period, zero if unsupported\n-     */\n-    int getDays();\n-\n-    /**\n-     * Gets the hours field part of the period.\n-     * \n-     * @return the number of hours in the period, zero if unsupported\n-     */\n-    int getHours();\n-\n-    /**\n-     * Gets the minutes field part of the period.\n-     * \n-     * @return the number of minutes in the period, zero if unsupported\n-     */\n-    int getMinutes();\n-\n-    /**\n-     * Gets the seconds field part of the period.\n-     * \n-     * @return the number of seconds in the period, zero if unsupported\n-     */\n-    int getSeconds();\n-\n-    /**\n-     * Gets the millis field part of the period.\n-     * \n-     * @return the number of millis in the period, zero if unsupported\n-     */\n-    int getMillis();\n-\n-    //-----------------------------------------------------------------------\n-    /**\n      * Get this period as an immutable <code>Period</code> object.\n      * <p>\n      * This will either typecast this instance, or create a new <code>Period</code>.\n      */\n     MutablePeriod toMutablePeriod();\n \n-    /**\n-     * Gets the total length of this time period in milliseconds, \n-     * failing if the period is imprecise.\n-     *\n-     * @return the total length of the time period in milliseconds.\n-     * @throws IllegalStateException if this time period is imprecise\n-     */\n-    long toDurationMillis();\n-\n-    /**\n-     * Gets the total length of this time period,\n-     * failing if the period is imprecise.\n-     *\n-     * @return the total length of the time period in milliseconds.\n-     * @throws IllegalStateException if this time period is imprecise\n-     */\n-    Duration toDuration();\n-\n     //-----------------------------------------------------------------------\n     /**\n      * Compares this object with the specified object for equality based\n-     * on the value of each field. All ReadablePeriod instances are accepted.\n-     * <p>\n-     * To compare two periods for absolute duration (ie. millisecond duration\n-     * ignoring the fields), use {@link #toDurationMillis()} or {@link #toDuration()}.\n+     * on the value and type of each supported field.\n+     * All ReadablePeriod instances are accepted.\n      *\n      * @param readablePeriod  a readable period to check against\n-     * @return true if all the field values are equal, false if\n+     * @return true if all the field values and types are equal, false if\n      *  not or the period is null or of an incorrect type\n      */\n     boolean equals(Object readablePeriod);\n \n     /**\n-     * Gets a hash code for the period that is compatible with the \n-     * equals method. The hashcode is the period type hashcode plus\n-     * each period value from largest to smallest calculated as follows:\n+     * Gets a hash code for the period that is compatible with the equals method.\n+     * The hashcode is calculated as follows:\n      * <pre>\n-     *   int hash = getPeriodType().hashCode();\n-     *   hash = 53 * hash + getYears();\n-     *   hash = 53 * hash + getMonths();\n-     *   hash = 53 * hash + getWeeks();\n-     *   hash = 53 * hash + getDays();\n-     *   hash = 53 * hash + getHours();\n-     *   hash = 53 * hash + getMinutes();\n-     *   hash = 53 * hash + getSeconds();\n-     *   hash = 53 * hash + getMillis();\n-     *   return hash;\n+     *  int total = 17;\n+     *  for (int i = 0; i < fields.length; i++) {\n+     *      total = 27 * total + getValue(i);\n+     *      total = 27 * total + getFieldType(i).hashCode();\n+     *  }\n+     *  return total;\n      * </pre>\n      *\n      * @return a hash code\n--- a/JodaTime/src/java/org/joda/time/base/AbstractDuration.java\n+++ b/JodaTime/src/java/org/joda/time/base/AbstractDuration.java\n import org.joda.time.Period;\n import org.joda.time.PeriodType;\n import org.joda.time.ReadableDuration;\n-import org.joda.time.format.ISOPeriodFormat;\n+import org.joda.time.format.FormatUtils;\n \n /**\n  * AbstractDuration provides the common behaviour for duration classes.\n \n     //-----------------------------------------------------------------------\n     /**\n-     * Gets the value as a String in the ISO8601 duration format.\n-     * <p>\n-     * For example, \"P6H3M7S\" represents 6 hours, 3 minutes, 7 seconds.\n-     * The field values are determined using {@link #toPeriod()}.\n+     * Gets the value as a String in the ISO8601 duration format including\n+     * only seconds and milliseconds.\n+     * <p>\n+     * For example, \"PT72.345S\" represents 1 minute, 12 seconds and 345 milliseconds.\n      * <p>\n      * For more control over the output, see\n      * {@link org.joda.time.format.PeriodFormatterBuilder PeriodFormatterBuilder}.\n      * @return the value as an ISO8601 string\n      */\n     public String toString() {\n-        return ISOPeriodFormat.getInstance().standard().print(toPeriod());\n+        long millis = getMillis();\n+        StringBuffer buf = new StringBuffer();\n+        buf.append(\"PT\");\n+        FormatUtils.appendUnpaddedInteger(buf, millis / 1000);\n+        long part = Math.abs(millis % 1000);\n+        if (part > 0) {\n+            buf.append('.');\n+            FormatUtils.appendPaddedInteger(buf, part, 3);\n+        }\n+        buf.append('S');\n+        return buf.toString();\n     }\n \n }\n--- a/JodaTime/src/java/org/joda/time/base/AbstractPartial.java\n+++ b/JodaTime/src/java/org/joda/time/base/AbstractPartial.java\n      * @return true if fields and values are equal\n      */\n     public boolean equals(Object partial) {\n+        if (this == partial) {\n+            return true;\n+        }\n         if (partial instanceof ReadablePartial == false) {\n             return false;\n         }\n--- a/JodaTime/src/java/org/joda/time/base/AbstractPeriod.java\n+++ b/JodaTime/src/java/org/joda/time/base/AbstractPeriod.java\n import org.joda.time.DateTime;\n import org.joda.time.DateTimeUtils;\n import org.joda.time.Duration;\n+import org.joda.time.DurationFieldType;\n import org.joda.time.MutablePeriod;\n import org.joda.time.Period;\n-import org.joda.time.PeriodType;\n import org.joda.time.ReadWritableInstant;\n import org.joda.time.ReadableInstant;\n import org.joda.time.ReadablePeriod;\n \n     //-----------------------------------------------------------------------\n     /**\n-     * Adds this period to the given instant using the chronology of the period\n-     * which typically ignores time zones.\n-     * <p>\n+     * Gets an array of the field types that this period supports.\n+     * <p>\n+     * The fields are returned largest to smallest, for example Hours, Minutes, Seconds.\n+     *\n+     * @return the fields supported in an array that may be altered, largest to smallest\n+     */\n+    public DurationFieldType[] getFieldTypes() {\n+        DurationFieldType[] result = new DurationFieldType[size()];\n+        for (int i = 0; i < result.length; i++) {\n+            result[i] = getFieldType(i);\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Gets an array of the value of each of the fields that this period supports.\n+     * <p>\n+     * The fields are returned largest to smallest, for example Hours, Minutes, Seconds.\n+     * Each value corresponds to the same array index as <code>getFields()</code>\n+     *\n+     * @return the current values of each field in an array that may be altered, largest to smallest\n+     */\n+    public int[] getValues() {\n+        int[] result = new int[size()];\n+        for (int i = 0; i < result.length; i++) {\n+            result[i] = getValue(i);\n+        }\n+        return result;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the value of one of the fields.\n+     * <p>\n+     * If the field type specified is not supported by the period then zero\n+     * is returned.\n+     *\n+     * @param field  the field type to query, null returns zero\n+     * @return the value of that field, zero if field not supported\n+     */\n+    public int get(DurationFieldType type) {\n+        int index = indexOf(type);\n+        if (index == -1) {\n+            return 0;\n+        }\n+        return getValue(index);\n+    }\n+\n+    /**\n+     * Checks whether the field specified is supported by this period.\n+     *\n+     * @param type  the type to check, may be null which returns false\n+     * @return true if the field is supported\n+     */\n+    public boolean isSupported(DurationFieldType type) {\n+        return getPeriodType().isSupported(type);\n+    }\n+\n+    /**\n+     * Gets the index of the field in this period.\n+     *\n+     * @param type  the type to check, may be null which returns -1\n+     * @return the index of -1 if not supported\n+     */\n+    public int indexOf(DurationFieldType type) {\n+        return getPeriodType().indexOf(type);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Adds this period to the given instant, returning a new value.\n+     * <p>\n+     * The addition uses ISOChronology in the default zone.\n      * To add just once, pass in a scalar of one. To subtract once, pass\n      * in a scalar of minus one.\n      *\n-     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to add the\n-     * period to\n+     * @param instant  the millisecond instant to add the period to\n      * @param scalar  the number of times to add the period, negative to subtract\n      * @return milliseconds value plus this period times scalar\n      * @throws ArithmeticException if the result of the calculation is too large\n     }\n \n     /**\n-     * Adds this period to the given instant using a specific chronology.\n-     * <p>\n+     * Adds this period to the given instant, returning a new value.\n+     * <p>\n+     * The addition uses the chronology specified, or ISOChronology\n+     * in the default zone if it is null.\n      * To add just once, pass in a scalar of one. To subtract once, pass\n      * in a scalar of minus one.\n      *\n-     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to add the\n-     * period to\n+     * @param instant  the millisecond instant to add the period to\n      * @param scalar  the number of times to add the period, negative to subtract\n-     * @param chrono  override the period's chronology, unless null is passed in\n+     * @param chrono  the chronology to use, null means ISO in the default zone\n      * @return milliseconds value plus this period times scalar\n      * @throws ArithmeticException if the result of the calculation is too large\n      */\n     public long addTo(long instant, int scalar, Chronology chrono) {\n-        if (isPrecise()) {\n-            return FieldUtils.safeAdd(instant, toDurationMillis() * scalar);\n-        }\n-        \n-        PeriodType type = getPeriodType();\n-        if (chrono != null) {\n-            type = type.withChronology(chrono);\n-        }\n-        \n-        long value; // used to lock fields against threading issues\n-        value = scaleValue(getYears(), scalar);\n-        if (value != 0) {\n-            instant = type.years().add(instant, value);\n-        }\n-        value = scaleValue(getMonths(), scalar);\n-        if (value != 0) {\n-            instant = type.months().add(instant, value);\n-        }\n-        value = scaleValue(getWeeks(), scalar);\n-        if (value != 0) {\n-            instant = type.weeks().add(instant, value);\n-        }\n-        value = scaleValue(getDays(), scalar);\n-        if (value != 0) {\n-            instant = type.days().add(instant, value);\n-        }\n-        value = scaleValue(getHours(), scalar);\n-        if (value != 0) {\n-            instant = type.hours().add(instant, value);\n-        }\n-        value = scaleValue(getMinutes(), scalar);\n-        if (value != 0) {\n-            instant = type.minutes().add(instant, value);\n-        }\n-        value = scaleValue(getSeconds(), scalar);\n-        if (value != 0) {\n-            instant = type.seconds().add(instant, value);\n-        }\n-        value = scaleValue(getMillis(), scalar);\n-        if (value != 0) {\n-            instant = type.millis().add(instant, value);\n-        }\n-\n+        if (scalar != 0) {\n+            chrono = DateTimeUtils.getChronology(chrono);\n+            for (int i = 0, isize = size(); i < isize; i++) {\n+                long value = getValue(i); // use long to allow for multiplication (fits OK)\n+                if (value != 0) {\n+                    instant = getFieldType(i).getField(chrono).add(instant, value * scalar);\n+                }\n+            }\n+        }\n         return instant;\n-    }\n-\n-    /**\n-     * Convert the scalar to a multiple efficiently.\n-     * \n-     * @param value  the value\n-     * @param scalar  the scalar\n-     * @return the converted value\n-     */\n-    private static long scaleValue(int value, int scalar) {\n-        long val = value;  // use long to avoid truncation\n-        switch (scalar) {\n-        case -1:\n-            return -val;\n-        case 0:\n-            return 0;\n-        case 1:\n-            return val;\n-        default:\n-            return val * scalar;\n-        }\n     }\n \n     /**\n \n     //-----------------------------------------------------------------------\n     /**\n-     * Gets the total millisecond duration of this period,\n-     * failing if the period is imprecise.\n-     *\n-     * @return the total length of the period in milliseconds.\n-     * @throws IllegalStateException if the period is imprecise\n+     * Gets the total millisecond duration of this period relative to a start\n+     * instant and chronology.\n+     * <p>\n+     * This method adds the period to the specifed instant.\n+     * The difference between the start instant and the result of the add is the duration\n+     *\n+     * @param startInstant  the instant to add the period to, thus obtaining the duration\n+     * @param chrono  the chronology to use\n+     * @return the total length of the period in milliseconds relative to the start instant\n      * @throws ArithmeticException if the millis exceeds the capacity of the duration\n      */\n-    public Duration toDuration() {\n-        return new Duration(toDurationMillis());\n+    public long toDurationMillisFrom(long startInstant, Chronology chrono) {\n+        long endInstant = addTo(startInstant, 1, chrono);\n+        return FieldUtils.safeAdd(endInstant, -startInstant);\n+    }\n+\n+    /**\n+     * Gets the total millisecond duration of this period relative to a start\n+     * instant and chronology.\n+     * <p>\n+     * This method adds the period to the specifed instant.\n+     * The difference between the start instant and the result of the add is the duration\n+     *\n+     * @param startInstant  the instant to add the period to, thus obtaining the duration\n+     * @return the total length of the period in milliseconds relative to the start instant\n+     * @throws ArithmeticException if the millis exceeds the capacity of the duration\n+     */\n+    public Duration toDurationFrom(ReadableInstant startInstant) {\n+        long millis = DateTimeUtils.getInstantMillis(startInstant);\n+        Chronology chrono = DateTimeUtils.getInstantChronology(startInstant);\n+        return new Duration(toDurationMillisFrom(millis, chrono));\n     }\n \n     //-----------------------------------------------------------------------\n     /**\n      * Compares this object with the specified object for equality based\n      * on the value of each field. All ReadablePeriod instances are accepted.\n-     * <p>\n-     * To compare two periods for absolute duration (ie. millisecond duration\n-     * ignoring the fields), use {@link #toDurationMillis()} or {@link #toDuration()}.\n      *\n      * @param readablePeriod  a readable period to check against\n      * @return true if all the field values are equal, false if\n      *  not or the period is null or of an incorrect type\n      */\n-    public boolean equals(Object readablePeriod) {\n-        if (this == readablePeriod) {\n+    public boolean equals(Object period) {\n+        if (this == period) {\n             return true;\n         }\n-        if (readablePeriod instanceof ReadablePeriod == false) {\n+        if (period instanceof ReadablePeriod == false) {\n             return false;\n         }\n-        ReadablePeriod other = (ReadablePeriod) readablePeriod;\n-        PeriodType type = getPeriodType();\n-        if (type.equals(other.getPeriodType()) == false) {\n+        ReadablePeriod other = (ReadablePeriod) period;\n+        if (size() != other.size()) {\n             return false;\n         }\n-        return getYears() == other.getYears()\n-            && getMonths() == other.getMonths()\n-            && getWeeks() == other.getWeeks()\n-            && getDays() == other.getDays()\n-            && getHours() == other.getHours()\n-            && getMinutes() == other.getMinutes()\n-            && getSeconds() == other.getSeconds()\n-            && getMillis() == other.getMillis();\n-    }\n-\n-    /**\n-     * Gets a hash code for the period that is compatible with the \n-     * equals method. The hashcode is the period type hashcode plus\n-     * each period value from largest to smallest calculated as follows:\n+        for (int i = 0, isize = size(); i < isize; i++) {\n+            if (getValue(i) != other.getValue(i) || getFieldType(i) != other.getFieldType(i)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Gets a hash code for the period as defined by ReadablePeriod.\n      *\n      * @return a hash code\n      */\n     public int hashCode() {\n-        int hash = getPeriodType().hashCode();\n-        hash = 53 * hash + getYears();\n-        hash = 53 * hash + getMonths();\n-        hash = 53 * hash + getWeeks();\n-        hash = 53 * hash + getDays();\n-        hash = 53 * hash + getHours();\n-        hash = 53 * hash + getMinutes();\n-        hash = 53 * hash + getSeconds();\n-        hash = 53 * hash + getMillis();\n-        return hash;\n+        int total = 17;\n+        for (int i = 0, isize = size(); i < isize; i++) {\n+            total = 27 * total + getValue(i);\n+            total = 27 * total + getFieldType(i).hashCode();\n+        }\n+        return total;\n     }\n \n     //-----------------------------------------------------------------------\n--- a/JodaTime/src/java/org/joda/time/base/BasePeriod.java\n+++ b/JodaTime/src/java/org/joda/time/base/BasePeriod.java\n \n import java.io.Serializable;\n \n+import org.joda.time.Chronology;\n import org.joda.time.DateTimeUtils;\n import org.joda.time.DurationField;\n+import org.joda.time.DurationFieldType;\n import org.joda.time.MutablePeriod;\n import org.joda.time.PeriodType;\n import org.joda.time.ReadWritablePeriod;\n \n /**\n  * BasePeriod is an abstract implementation of ReadablePeriod that stores\n- * data in a <code>int</code> and <code>PeriodType</code> fields.\n+ * data in a <code>PeriodType</code> and an <code>int[]</code>.\n  * <p>\n  * This class should generally not be used directly by API users.\n  * The {@link ReadablePeriod} interface should be used when different \n     /** Serialization version */\n     private static final long serialVersionUID = -2110953284060001145L;\n \n-    /** Millis cache is currently unknown */\n-    private static final int STATE_UNKNOWN = 0;\n-    /** Millis cache is not calculable */\n-    private static final int STATE_NOT_CALCULABLE = 1;\n-    /** Millis cache has been calculated and is valid */\n-    private static final int STATE_CALCULATED = 2;\n-\n-    /** The period type that allocates the duration to fields */\n-    private final PeriodType iType;\n-    /** The object state */\n-    private transient int iState;\n-    /** The duration, if known */\n-    private transient long iDuration;\n-    /** Value for years */\n-    private int iYears;\n-    /** Value for months */\n-    private int iMonths;\n-    /** Value for weeks */\n-    private int iWeeks;\n-    /** Value for days */\n-    private int iDays;\n-    /** Value for hours */\n-    private int iHours;\n-    /** Value for minutes */\n-    private int iMinutes;\n-    /** Value for seconds */\n-    private int iSeconds;\n-    /** Value for millis */\n-    private int iMillis;\n+    /** The type of period */\n+    private PeriodType iType;\n+    /** The values */\n+    private int[] iValues;\n \n     //-----------------------------------------------------------------------\n     /**\n      * the period type.\n      *\n      * @param duration  the duration, in milliseconds\n-     * @param type  which set of fields this period supports\n+     * @param type  which set of fields this period supports, null means standard\n+     * @param chrono  the chronology to use, null means ISO default\n      * @throws IllegalArgumentException if period type is invalid\n      */\n-    protected BasePeriod(long duration, PeriodType type) {\n+    protected BasePeriod(long duration, PeriodType type, Chronology chrono) {\n         super();\n         type = checkPeriodType(type);\n         iType = type;\n-        // Only call a private method\n-        setPeriod(type, duration);\n+        setPeriodInternal(duration, chrono); // internal method\n     }\n \n     /**\n         super();\n         type = checkPeriodType(type);\n         iType = type;\n-        // Only call a private method\n-        setPeriod(type, years, months, weeks, days, hours, minutes, seconds, millis);\n+        setPeriodInternal(years, months, weeks, days, hours, minutes, seconds, millis); // internal method\n     }\n \n     /**\n      *\n      * @param startInstant  interval start, in milliseconds\n      * @param endInstant  interval end, in milliseconds\n-     * @param type  which set of fields this period supports\n+     * @param type  which set of fields this period supports, null means standard\n+     * @param chrono  the chronology to use, null means ISO default\n      * @throws IllegalArgumentException if period type is invalid\n      */\n-    protected BasePeriod(long startInstant, long endInstant, PeriodType type) {\n+    protected BasePeriod(long startInstant, long endInstant, PeriodType type, Chronology chrono) {\n         super();\n         type = checkPeriodType(type);\n         iType = type;\n-        // Only call a private method\n-        setPeriod(type, startInstant, endInstant);\n+        setPeriodInternal(startInstant, endInstant, chrono); // internal method\n     }\n \n     /**\n      *\n      * @param startInstant  interval start, null means now\n      * @param endInstant  interval end, null means now\n-     * @param type  which set of fields this period supports\n+     * @param type  which set of fields this period supports, null means standard\n      * @throws IllegalArgumentException if period type is invalid\n      */\n-    protected BasePeriod(\n-            ReadableInstant startInstant, ReadableInstant  endInstant, PeriodType type) {\n+    protected BasePeriod(ReadableInstant startInstant, ReadableInstant  endInstant, PeriodType type) {\n         super();\n         type = checkPeriodType(type);\n         if (startInstant == null && endInstant == null) {\n             iType = type;\n-        } else {\n-            long start = (startInstant == null ? DateTimeUtils.currentTimeMillis() : startInstant.getMillis());\n-            long end = (endInstant == null ? DateTimeUtils.currentTimeMillis() : endInstant.getMillis());\n+            iValues = new int[size()];\n+        } else {\n+            long start = DateTimeUtils.getInstantMillis(startInstant);\n+            long end = DateTimeUtils.getInstantMillis(endInstant);\n+            Chronology chrono = (startInstant != null ? startInstant.getChronology() : endInstant.getChronology());\n             iType = type;\n-            // Only call a private method\n-            setPeriod(type, start, end);\n+            setPeriodInternal(start, end, chrono); // internal method\n         }\n     }\n \n      *\n      * @param period  the period to convert\n      * @param type  which set of fields this period supports, null means use type from object\n+     * @param chrono  the chronology to use, null means ISO default\n      * @throws IllegalArgumentException if period is invalid\n      * @throws IllegalArgumentException if an unsupported field's value is non-zero\n      */\n-    protected BasePeriod(Object period, PeriodType type) {\n+    protected BasePeriod(Object period, PeriodType type, Chronology chrono) {\n         super();\n         PeriodConverter converter = ConverterManager.getInstance().getPeriodConverter(period);\n-        type = (type == null ? converter.getPeriodType(period, false) : type);\n+        type = (type == null ? converter.getPeriodType(period) : type);\n         type = checkPeriodType(type);\n         iType = type;\n         if (this instanceof ReadWritablePeriod) {\n-            converter.setInto((ReadWritablePeriod) this, period);\n-        } else {\n-            // Only call a private method\n-            setPeriod(type, new MutablePeriod(period, type));\n+            iValues = new int[size()];\n+            chrono = DateTimeUtils.getChronology(chrono);\n+            converter.setInto((ReadWritablePeriod) this, period, chrono);\n+        } else {\n+            setPeriodInternal(new MutablePeriod(period, type, chrono));\n         }\n     }\n \n \n     //-----------------------------------------------------------------------\n     /**\n-     * Returns the object which defines which fields this period supports.\n+     * Gets the period type.\n+     *\n+     * @return the period type\n      */\n     public PeriodType getPeriodType() {\n         return iType;\n     }\n \n-    /**\n-     * Is this period a precise length of time, or descriptive.\n-     * <p>\n-     * A typical precise period could include millis, seconds, minutes or hours,\n-     * but days, weeks, months and years usually vary in length, resulting in\n-     * an imprecise period.\n-     * <p>\n-     * An imprecise period can be made precise by pairing it with a\n-     * date in a {@link org.joda.time.ReadableInterval}.\n-     *\n-     * @return true if the period is precise\n-     */\n-    public boolean isPrecise() {\n-        int state = iState;\n-        if (state == STATE_UNKNOWN) {\n-            state = updateTotalMillis();\n-        }\n-        return (state == STATE_CALCULATED);\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Gets the years field part of the period.\n-     * \n-     * @return the number of years in the period, zero if unsupported\n-     */\n-    public int getYears() {\n-        return iYears;\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Gets the months field part of the period.\n-     * \n-     * @return the number of months in the period, zero if unsupported\n-     */\n-    public int getMonths() {\n-        return iMonths;\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Gets the weeks field part of the period.\n-     * \n-     * @return the number of weeks in the period, zero if unsupported\n-     */\n-    public int getWeeks() {\n-        return iWeeks;\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Gets the days field part of the period.\n-     * \n-     * @return the number of days in the period, zero if unsupported\n-     */\n-    public int getDays() {\n-        return iDays;\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Gets the hours field part of the period.\n-     * \n-     * @return the number of hours in the period, zero if unsupported\n-     */\n-    public int getHours() {\n-        return iHours;\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Gets the minutes field part of the period.\n-     * \n-     * @return the number of minutes in the period, zero if unsupported\n-     */\n-    public int getMinutes() {\n-        return iMinutes;\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Gets the seconds field part of the period.\n-     * \n-     * @return the number of seconds in the period, zero if unsupported\n-     */\n-    public int getSeconds() {\n-        return iSeconds;\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Gets the millis field part of the period.\n-     * \n-     * @return the number of millis in the period, zero if unsupported\n-     */\n-    public int getMillis() {\n-        return iMillis;\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Gets the total millisecond duration of this period,\n-     * failing if the period is imprecise.\n-     *\n-     * @return the total length of the period in milliseconds.\n-     * @throws IllegalStateException if the period is imprecise\n-     * @throws ArithmeticException if the millis exceeds the capacity of the duration\n-     */\n-    public long toDurationMillis() {\n-        int state = iState;\n-        if (state == STATE_UNKNOWN) {\n-            state = updateTotalMillis();\n-        }\n-        if (state != STATE_CALCULATED) {\n-            throw new IllegalStateException(\"Duration is imprecise\");\n-        }\n-        return iDuration;\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Checks whether the field is supported.\n-     */\n-    private static void checkArgument(DurationField field) {\n-        if (!field.isSupported()) {\n-            throw new IllegalArgumentException\n-                (\"Time period does not support field '\" + field.getName() + \"'\");\n-        }\n-    }\n-\n-    /**\n-     * Checks whether the field is supported.\n-     */\n-    private static void checkSupport(DurationField field) {\n-        if (!field.isSupported()) {\n-            throw new UnsupportedOperationException\n-                (\"Time period does not support field '\" + field.getName() + \"'\");\n-        }\n-    }\n-\n-    /**\n-     * This method is private to prevent subclasses from overriding.\n-     */\n-    private void setPeriod(PeriodType type, ReadablePeriod period) {\n-        setPeriod(type,\n-            period.getYears(), period.getMonths(),\n-            period.getWeeks(), period.getDays(),\n-            period.getHours(), period.getMinutes(),\n-            period.getSeconds(), period.getMillis());\n-    }\n-\n-    /**\n-     * Sets all the fields in one go.\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the number of fields that this period supports.\n+     *\n+     * @return the number of fields supported\n+     */\n+    public int size() {\n+        return iType.size();\n+    }\n+\n+    /**\n+     * Gets the field type at the specified index.\n+     *\n+     * @param index  the index to retrieve\n+     * @return the field at the specified index\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    public DurationFieldType getFieldType(int index) {\n+        return iType.getFieldType(index);\n+    }\n+\n+    /**\n+     * Gets the value at the specified index.\n+     *\n+     * @param index  the index to retrieve\n+     * @return the value of the field at the specified index\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    public int getValue(int index) {\n+        return iValues[index];\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Checks whether a field type is supported, and if so adds the new value\n+     * to the relevent index in the specified array.\n+     * \n+     * @param type  the field type\n+     * @param values  the array to update\n+     * @param newValue  the new value to store if successful\n+     */\n+    private void checkAndUpdate(DurationFieldType type, int[] values, int newValue) {\n+        int index = indexOf(type);\n+        if (index == -1) {\n+            if (newValue != 0) {\n+                throw new IllegalArgumentException(\n+                    \"Period does not support field '\" + type.getName() + \"'\");\n+            }\n+        } else {\n+            values[index] = newValue;\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets all the fields of this period from another.\n+     * \n+     * @param period  the period to copy from, not null\n+     * @throws IllegalArgumentException if an unsupported field's value is non-zero\n+     */\n+    protected void setPeriod(ReadablePeriod period) {\n+        if (period == null) {\n+            setPeriodInternal(0L, null);\n+        } else {\n+            setPeriodInternal(period);\n+        }\n+    }\n+\n+    /**\n+     * Private method called from constructor.\n+     */\n+    private void setPeriodInternal(ReadablePeriod period) {\n+        int[] newValues = new int[size()];\n+        for (int i = 0, isize = period.size(); i < isize; i++) {\n+            DurationFieldType type = period.getFieldType(i);\n+            int value = period.getValue(i);\n+            checkAndUpdate(type, newValues, value);\n+        }\n+        iValues = newValues;\n+    }\n+\n+    /**\n+     * Sets the eight standard the fields in one go.\n      * \n      * @param years  amount of years in this period, which must be zero if unsupported\n      * @param months  amount of months in this period, which must be zero if unsupported\n      * @throws IllegalArgumentException if an unsupported field's value is non-zero\n      */\n     protected void setPeriod(int years, int months, int weeks, int days,\n-                               int hours, int minutes, int seconds, int millis) {\n-        setPeriod(iType, years, months, weeks, days, hours, minutes, seconds, millis);\n-    }\n-\n-    /**\n-     * This method is private to prevent subclasses from overriding.\n-     */\n-    private void setPeriod(PeriodType type,\n-                             int years, int months, int weeks, int days,\n                              int hours, int minutes, int seconds, int millis) {\n-        if (years != 0) {\n-            checkArgument(type.years());\n-        }\n-        if (months != 0) {\n-            checkArgument(type.months());\n-        }\n-        if (weeks != 0) {\n-            checkArgument(type.weeks());\n-        }\n-        if (days != 0) {\n-            checkArgument(type.days());\n-        }\n-        if (hours != 0) {\n-            checkArgument(type.hours());\n-        }\n-        if (minutes != 0) {\n-            checkArgument(type.minutes());\n-        }\n-        if (seconds != 0) {\n-            checkArgument(type.seconds());\n-        }\n-        if (millis != 0) {\n-            checkArgument(type.millis());\n-        }\n-        \n-        // assign fields in one block to reduce threading issues\n-        iYears = years;\n-        iMonths = months;\n-        iWeeks = weeks;\n-        iDays = days;\n-        iHours = hours;\n-        iMinutes = minutes;\n-        iSeconds = seconds;\n-        iMillis = millis;\n-        iState = STATE_UNKNOWN;\n+        setPeriodInternal(years, months, weeks, days, hours, minutes, seconds, millis);\n+    }\n+\n+    /**\n+     * Private method called from constructor.\n+     */\n+    private void setPeriodInternal(int years, int months, int weeks, int days,\n+                                   int hours, int minutes, int seconds, int millis) {\n+        int[] newValues = new int[size()];\n+        checkAndUpdate(DurationFieldType.years(), newValues, years);\n+        checkAndUpdate(DurationFieldType.months(), newValues, months);\n+        checkAndUpdate(DurationFieldType.weeks(), newValues, weeks);\n+        checkAndUpdate(DurationFieldType.days(), newValues, days);\n+        checkAndUpdate(DurationFieldType.hours(), newValues, hours);\n+        checkAndUpdate(DurationFieldType.minutes(), newValues, minutes);\n+        checkAndUpdate(DurationFieldType.seconds(), newValues, seconds);\n+        checkAndUpdate(DurationFieldType.millis(), newValues, millis);\n+        iValues = newValues;\n     }\n \n     /**\n      * \n      * @param startInstant  interval start, in milliseconds\n      * @param endInstant  interval end, in milliseconds\n-     */\n-    protected void setPeriod(long startInstant, long endInstant) {\n-        setPeriod(iType, startInstant, endInstant);\n-    }\n-\n-    /**\n-     * This method is private to prevent subclasses from overriding.\n-     *\n-     * @param startInstant  interval start, in milliseconds\n-     * @param endInstant  interval end, in milliseconds\n-     */\n-    private void setPeriod(PeriodType type, long startInstant, long endInstant) {\n-        long baseTotalMillis = (endInstant - startInstant);\n-        int years = 0, months = 0, weeks = 0, days = 0;\n-        int hours = 0, minutes = 0, seconds = 0, millis = 0;\n-        DurationField field;\n-        field = type.years();\n-        if (field.isSupported()) {\n-            years = field.getDifference(endInstant, startInstant);\n-            startInstant = field.add(startInstant, years);\n-        }\n-        field = type.months();\n-        if (field.isSupported()) {\n-            months = field.getDifference(endInstant, startInstant);\n-            startInstant = field.add(startInstant, months);\n-        }\n-        field = type.weeks();\n-        if (field.isSupported()) {\n-            weeks = field.getDifference(endInstant, startInstant);\n-            startInstant = field.add(startInstant, weeks);\n-        }\n-        field = type.days();\n-        if (field.isSupported()) {\n-            days = field.getDifference(endInstant, startInstant);\n-            startInstant = field.add(startInstant, days);\n-        }\n-        field = type.hours();\n-        if (field.isSupported()) {\n-            hours = field.getDifference(endInstant, startInstant);\n-            startInstant = field.add(startInstant, hours);\n-        }\n-        field = type.minutes();\n-        if (field.isSupported()) {\n-            minutes = field.getDifference(endInstant, startInstant);\n-            startInstant = field.add(startInstant, minutes);\n-        }\n-        field = type.seconds();\n-        if (field.isSupported()) {\n-            seconds = field.getDifference(endInstant, startInstant);\n-            startInstant = field.add(startInstant, seconds);\n-        }\n-        field = type.millis();\n-        if (field.isSupported()) {\n-            millis = field.getDifference(endInstant, startInstant);\n-            startInstant = field.add(startInstant, millis);\n-        }\n-        \n-        // assign fields in one block to reduce threading issues\n-        iYears = years;\n-        iMonths = months;\n-        iWeeks = weeks;\n-        iDays = days;\n-        iHours = hours;\n-        iMinutes = minutes;\n-        iSeconds = seconds;\n-        iMillis = millis;\n-        iState = STATE_UNKNOWN;\n+     * @param chrono  the chronology to use, not null\n+     */\n+    protected void setPeriod(long startInstant, long endInstant, Chronology chrono) {\n+        setPeriodInternal(startInstant, endInstant, chrono);\n+    }\n+\n+    /**\n+     * Private method called from constructor.\n+     */\n+    private void setPeriodInternal(long startInstant, long endInstant, Chronology chrono) {\n+        int[] newValues = new int[size()];\n+        if (startInstant == endInstant) {\n+            iValues = newValues;\n+        } else {\n+            for (int i = 0, isize = size(); i < isize; i++) {\n+                DurationField field = getFieldType(i).getField(chrono);\n+                int value = field.getDifference(endInstant, startInstant);\n+                startInstant = field.add(startInstant, value);\n+                newValues[i] = value;\n+            }\n+            iValues = newValues;\n+        }\n     }\n \n     /**\n      * Sets all the fields in one go from a millisecond duration.\n+     * <p>\n+     * This calculates the period relative to 1970-01-01 but only sets those\n+     * fields which are precise.\n      * \n      * @param duration  the duration, in milliseconds\n      * @throws ArithmeticException if the set exceeds the capacity of the period\n-     */\n-    protected void setPeriod(long duration) {\n-        setPeriod(iType, duration);\n-    }\n-\n-    /**\n-     * This method is private to prevent subclasses from overriding.\n-     *\n-     * @param duration  the duration, in milliseconds\n-     */\n-    private void setPeriod(PeriodType type, long duration) {\n+     * @param chrono  the chronology to use, not null\n+     */\n+    protected void setPeriod(long duration, Chronology chrono) {\n+        setPeriodInternal(duration, chrono);\n+    }\n+\n+    /**\n+     * Private method called from constructor.\n+     */\n+    private void setPeriodInternal(long duration, Chronology chrono) {\n+        int[] newValues = new int[size()];\n         if (duration == 0) {\n-            iDuration = duration;\n-            iYears = 0;\n-            iMonths = 0;\n-            iWeeks = 0;\n-            iDays = 0;\n-            iHours = 0;\n-            iMinutes = 0;\n-            iSeconds = 0;\n-            iMillis = 0;\n-            iState = STATE_CALCULATED;\n-            return;\n-        }\n-        \n-        long startInstant = 0;\n-        int years = 0, months = 0, weeks = 0, days = 0;\n-        int hours = 0, minutes = 0, seconds = 0, millis = 0;\n-        DurationField field;\n-        \n-        field = type.years();\n-        if (field.isSupported() && field.isPrecise()) {\n-            years = field.getDifference(duration, startInstant);\n-            startInstant = field.add(startInstant, years);\n-        }\n-        field = type.months();\n-        if (field.isSupported() && field.isPrecise()) {\n-            months = field.getDifference(duration, startInstant);\n-            startInstant = field.add(startInstant, months);\n-        }\n-        field = type.weeks();\n-        if (field.isSupported() && field.isPrecise()) {\n-            weeks = field.getDifference(duration, startInstant);\n-            startInstant = field.add(startInstant, weeks);\n-        }\n-        field = type.days();\n-        if (field.isSupported() && field.isPrecise()) {\n-            days = field.getDifference(duration, startInstant);\n-            startInstant = field.add(startInstant, days);\n-        }\n-        field = type.hours();\n-        if (field.isSupported() && field.isPrecise()) {\n-            hours = field.getDifference(duration, startInstant);\n-            startInstant = field.add(startInstant, hours);\n-        }\n-        field = type.minutes();\n-        if (field.isSupported() && field.isPrecise()) {\n-            minutes = field.getDifference(duration, startInstant);\n-            startInstant = field.add(startInstant, minutes);\n-        }\n-        field = type.seconds();\n-        if (field.isSupported() && field.isPrecise()) {\n-            seconds = field.getDifference(duration, startInstant);\n-            startInstant = field.add(startInstant, seconds);\n-        }\n-        field = type.millis();\n-        if (field.isSupported() && field.isPrecise()) {\n-            millis = field.getDifference(duration, startInstant);\n-            startInstant = field.add(startInstant, millis);\n-        }\n-        \n-        // assign fields in one block to reduce threading issues\n-        iYears = years;\n-        iMonths = months;\n-        iWeeks = weeks;\n-        iDays = days;\n-        iHours = hours;\n-        iMinutes = minutes;\n-        iSeconds = seconds;\n-        iMillis = millis;\n-        iState = STATE_UNKNOWN;\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Walks through the field values, determining total millis and whether\n-     * this period is precise.\n-     *\n-     * @return new state\n-     * @throws ArithmeticException if the millis exceeds the capacity of the period\n-     */\n-    private int updateTotalMillis() {\n-        PeriodType type = iType;\n-\n-        boolean isPrecise = true;\n-        long totalMillis = 0;\n-\n-        DurationField field;\n-        int years = iYears, months = iMonths, weeks = iWeeks, days = iDays;\n-        int hours = iHours, minutes = iMinutes, seconds = iSeconds, millis = iMillis;\n-        if (years != 0) {\n-            field = type.years();\n-            if (isPrecise &= field.isPrecise()) {\n-                totalMillis = FieldUtils.safeAdd(totalMillis, field.getMillis(years));\n+            iValues = newValues;\n+        } else {\n+            long current = 0;\n+            for (int i = 0, isize = size(); i < isize; i++) {\n+                DurationField field = getFieldType(i).getField(chrono);\n+                if (field.isPrecise()) {\n+                    int value = field.getDifference(duration, current);\n+                    current = field.add(current, value);\n+                    newValues[i] = value;\n+                }\n             }\n-        }\n-        if (months != 0) {\n-            field = type.months();\n-            if (isPrecise &= field.isPrecise()) {\n-                totalMillis = FieldUtils.safeAdd(totalMillis, field.getMillis(months));\n+            iValues = newValues;\n+        }\n+    }\n+\n+    /**\n+     * Sets the value of a field in this period.\n+     * \n+     * @param field  the field to set\n+     * @param value  the value to set\n+     * @throws UnsupportedOperationException if field is not supported.\n+     */\n+    protected void setField(DurationFieldType field, int value) {\n+        int index = indexOf(field);\n+        if (index == -1) {\n+            if (value != 0) {\n+                throw new UnsupportedOperationException(\n+                    \"Period does not support field '\" + field.getName() + \"'\");\n             }\n-        }\n-        if (weeks != 0) {\n-            field = type.weeks();\n-            if (isPrecise &= field.isPrecise()) {\n-                totalMillis = FieldUtils.safeAdd(totalMillis, field.getMillis(weeks));\n-            }\n-        }\n-        if (days != 0) {\n-            field = type.days();\n-            if (isPrecise &= field.isPrecise()) {\n-                totalMillis = FieldUtils.safeAdd(totalMillis, field.getMillis(days));\n-            }\n-        }\n-        if (hours != 0) {\n-            field = type.hours();\n-            if (isPrecise &= field.isPrecise()) {\n-                totalMillis = FieldUtils.safeAdd(totalMillis, field.getMillis(hours));\n-            }\n-        }\n-        if (minutes != 0) {\n-            field = type.minutes();\n-            if (isPrecise &= field.isPrecise()) {\n-                totalMillis = FieldUtils.safeAdd(totalMillis, field.getMillis(minutes));\n-            }\n-        }\n-        if (seconds != 0) {\n-            field = type.seconds();\n-            if (isPrecise &= field.isPrecise()) {\n-                totalMillis = FieldUtils.safeAdd(totalMillis, field.getMillis(seconds));\n-            }\n-        }\n-        if (millis != 0) {\n-            field = type.millis();\n-            if (isPrecise &= field.isPrecise()) {\n-                totalMillis = FieldUtils.safeAdd(totalMillis, field.getMillis(millis));\n-            }\n-        }\n-        \n-        iDuration = totalMillis;\n-        if (isPrecise) {\n-            return iState = STATE_CALCULATED;\n-        } else {\n-            return iState = STATE_NOT_CALCULABLE;\n-        }\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Sets the number of years of the period.\n-     * \n-     * @param years  the number of years\n-     * @throws UnsupportedOperationException if field is not supported.\n-     */\n-    protected void setYears(int years) {\n-        if (years != iYears) {\n-            if (years != 0) {\n-                checkSupport(iType.years());\n-            }\n-            iYears = years;\n-            iState = STATE_UNKNOWN;\n-        }\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Sets the number of months of the period.\n-     * \n-     * @param months  the number of months\n-     * @throws UnsupportedOperationException if field is not supported\n-     */\n-    protected void setMonths(int months) {\n-        if (months != iMonths) {\n-            if (months != 0) {\n-                checkSupport(iType.months());\n-            }\n-            iMonths = months;\n-            iState = STATE_UNKNOWN;\n-        }\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Sets the number of weeks of the period.\n-     * \n-     * @param weeks  the number of weeks\n-     * @throws UnsupportedOperationException if field is not supported\n-     */\n-    protected void setWeeks(int weeks) {\n-        if (weeks != iWeeks) {\n-            if (weeks != 0) {\n-                checkSupport(iType.weeks());\n-            }\n-            iWeeks = weeks;\n-            iState = STATE_UNKNOWN;\n-        }\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Sets the number of days of the period.\n-     * \n-     * @param days  the number of days\n-     * @throws UnsupportedOperationException if field is not supported\n-     */\n-    protected void setDays(int days) {\n-        if (days != iDays) {\n-            if (days != 0) {\n-                checkSupport(iType.days());\n-            }\n-            iDays = days;\n-            iState = STATE_UNKNOWN;\n-        }\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Sets the number of hours of the period.\n-     * \n-     * @param hours  the number of hours\n-     * @throws UnsupportedOperationException if field is not supported\n-     */\n-    protected void setHours(int hours) {\n-        if (hours != iHours) {\n-            if (hours != 0) {\n-                checkSupport(iType.hours());\n-            }\n-            iHours = hours;\n-            iState = STATE_UNKNOWN;\n-        }\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Sets the number of minutes of the period.\n-     * \n-     * @param minutes  the number of minutes\n-     * @throws UnsupportedOperationException if field is not supported\n-     */\n-    protected void setMinutes(int minutes) {\n-        if (minutes != iMinutes) {\n-            if (minutes != 0) {\n-                checkSupport(iType.minutes());\n-            }\n-            iMinutes = minutes;\n-            iState = STATE_UNKNOWN;\n-        }\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Sets the number of seconds of the period.\n-     * \n-     * @param seconds  the number of seconds\n-     * @throws UnsupportedOperationException if field is not supported\n-     */\n-    protected void setSeconds(int seconds) {\n-        if (seconds != iSeconds) {\n-            if (seconds != 0) {\n-                checkSupport(iType.seconds());\n-            }\n-            iSeconds = seconds;\n-            iState = STATE_UNKNOWN;\n-        }\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Sets the number of millis of the period.\n-     * \n-     * @param millis  the number of millis\n-     * @throws UnsupportedOperationException if field is not supported\n-     */\n-    protected void setMillis(int millis) {\n-        if (millis != iMillis) {\n-            if (millis != 0) {\n-                checkSupport(iType.millis());\n-            }\n-            iMillis = millis;\n-            iState = STATE_UNKNOWN;\n-        }\n+        } else {\n+            setValue(index, value);\n+        }\n+    }\n+\n+    /**\n+     * Adds the fields from another period.\n+     * \n+     * @param period  the period to add from, not null\n+     * @throws IllegalArgumentException if an unsupported field's value is non-zero\n+     */\n+    protected void addPeriod(ReadablePeriod period) {\n+         int[] newValues = getValues(); // already cloned\n+         for (int i = 0, isize = period.size(); i < isize; i++) {\n+             DurationFieldType type = period.getFieldType(i);\n+             int value = period.getValue(i);\n+             int index = indexOf(type);\n+             if (index == -1) {\n+                 if (value != 0) {\n+                     throw new IllegalArgumentException(\n+                         \"Period does not support field '\" + type.getName() + \"'\");\n+                 }\n+             } else {\n+                 newValues[index] = FieldUtils.safeAdd(getValue(index), value);\n+             }\n+         }\n+         setValues(newValues);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets the value of the field at the specifed index.\n+     * \n+     * @param index  the index\n+     * @param value  the value to set\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    protected void setValue(int index, int value) {\n+        if (value != getValue(index)) {\n+            iValues[index] = value;\n+        }\n+    }\n+\n+    /**\n+     * Sets the values of all fields.\n+     * \n+     * @param values  the array of values\n+     */\n+    protected void setValues(int[] values) {\n+        iValues = values;\n     }\n \n }\n--- a/JodaTime/src/java/org/joda/time/convert/AbstractConverter.java\n+++ b/JodaTime/src/java/org/joda/time/convert/AbstractConverter.java\n      * Selects a suitable period type for the given object.\n      *\n      * @param object  the object to examine, must not be null\n-     * @param precise  true if a precise type is required\n      * @return the period type, never null\n      * @throws ClassCastException if the object is invalid\n      */\n-    public PeriodType getPeriodType(Object object, boolean precise) {\n-        if (precise) {\n-            return PeriodType.getPreciseAllType();\n-        }\n-        return PeriodType.getAllType();\n+    public PeriodType getPeriodType(Object object) {\n+        return PeriodType.standard();\n     }\n \n     //-----------------------------------------------------------------------\n--- a/JodaTime/src/java/org/joda/time/convert/ConverterManager.java\n+++ b/JodaTime/src/java/org/joda/time/convert/ConverterManager.java\n \n         iDurationConverters = new ConverterSet(new Converter[] {\n             ReadableDurationConverter.INSTANCE,\n-            ReadablePeriodConverter.INSTANCE,\n             ReadableIntervalConverter.INSTANCE,\n             StringConverter.INSTANCE,\n             LongConverter.INSTANCE,\n--- a/JodaTime/src/java/org/joda/time/convert/LongConverter.java\n+++ b/JodaTime/src/java/org/joda/time/convert/LongConverter.java\n  */\n package org.joda.time.convert;\n \n-import org.joda.time.ReadWritablePeriod;\n-\n /**\n  * LongConverter converts a Long to milliseconds in the ISOChronology.\n  *\n \n     //-----------------------------------------------------------------------\n     /**\n-     * Extracts duration values from an object of this converter's type, and\n-     * sets them into the given ReadWritableDuration.\n-     *\n-     * @param duration duration to get modified\n-     * @param object  the object to convert, must not be null\n-     * @throws NullPointerException if the duration or object is null\n-     * @throws ClassCastException if the object is an invalid type\n-     * @throws IllegalArgumentException if the object is invalid\n-     */\n-    public void setInto(ReadWritablePeriod duration, Object object) {\n-        duration.setPeriod(((Long) object).longValue());\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n      * Returns Long.class.\n      * \n      * @return Long.class\n--- a/JodaTime/src/java/org/joda/time/convert/NullConverter.java\n+++ b/JodaTime/src/java/org/joda/time/convert/NullConverter.java\n  */\n package org.joda.time.convert;\n \n+import org.joda.time.Chronology;\n import org.joda.time.DateTimeUtils;\n import org.joda.time.ReadWritablePeriod;\n \n      *\n      * @param duration duration to get modified\n      * @param object  the object to convert\n+     * @param chrono  the chronology to use\n      * @throws NullPointerException if the duration is null\n      */\n-    public void setInto(ReadWritablePeriod duration, Object object) {\n-        duration.setPeriod(0L);\n+    public void setInto(ReadWritablePeriod duration, Object object, Chronology chrono) {\n+        duration.setPeriod(0L, chrono);\n     }\n \n     //-----------------------------------------------------------------------\n--- a/JodaTime/src/java/org/joda/time/convert/PeriodConverter.java\n+++ b/JodaTime/src/java/org/joda/time/convert/PeriodConverter.java\n  */\n package org.joda.time.convert;\n \n+import org.joda.time.Chronology;\n import org.joda.time.PeriodType;\n import org.joda.time.ReadWritablePeriod;\n \n      *\n      * @param period  the period to modify\n      * @param object  the object to convert, must not be null\n+     * @param chrono  the chronology to use, must not be null\n      * @throws ClassCastException if the object is invalid\n      */\n-    void setInto(ReadWritablePeriod period, Object object);\n+    void setInto(ReadWritablePeriod period, Object object, Chronology chrono);\n \n     /**\n      * Selects a suitable period type for the given object.\n      *\n      * @param object  the object to examine, must not be null\n-     * @param precise  true if the period type must be precise\n      * @return the period type, never null\n      * @throws ClassCastException if the object is invalid\n      */\n-    PeriodType getPeriodType(Object object, boolean precise);\n+    PeriodType getPeriodType(Object object);\n \n }\n--- a/JodaTime/src/java/org/joda/time/convert/ReadableDurationConverter.java\n+++ b/JodaTime/src/java/org/joda/time/convert/ReadableDurationConverter.java\n  */\n package org.joda.time.convert;\n \n-import org.joda.time.PeriodType;\n+import org.joda.time.Chronology;\n import org.joda.time.ReadWritablePeriod;\n import org.joda.time.ReadableDuration;\n \n      *\n      * @param duration duration to get modified\n      * @param object  the object to convert, must not be null\n-     * @return the millisecond duration\n+     * @param chrono  the chronology to use, must not be null\n      * @throws NullPointerException if the duration or object is null\n      * @throws ClassCastException if the object is an invalid type\n      * @throws IllegalArgumentException if the object is invalid\n      */\n-    public void setInto(ReadWritablePeriod duration, Object object) {\n-        duration.setPeriod((ReadableDuration) object);\n-    }\n-\n-    /**\n-     * Selects a suitable period type for the given object.\n-     *\n-     * @param object  the object to examine, must not be null\n-     * @param precise  true if a precise type is required\n-     * @return the period type from the readable duration\n-     * @throws NullPointerException if the object is null\n-     * @throws ClassCastException if the object is an invalid type\n-     */\n-    public PeriodType getPeriodType(Object object, boolean precise) {\n-        return PeriodType.getPreciseAllType();\n+    public void setInto(ReadWritablePeriod duration, Object object, Chronology chrono) {\n+        duration.setPeriod((ReadableDuration) object, chrono);\n     }\n \n     //-----------------------------------------------------------------------\n--- a/JodaTime/src/java/org/joda/time/convert/ReadableIntervalConverter.java\n+++ b/JodaTime/src/java/org/joda/time/convert/ReadableIntervalConverter.java\n  */\n package org.joda.time.convert;\n \n+import org.joda.time.Chronology;\n+import org.joda.time.ReadWritableInterval;\n import org.joda.time.ReadWritablePeriod;\n-import org.joda.time.ReadWritableInterval;\n import org.joda.time.ReadableInterval;\n \n /**\n      * \n      * @param writablePeriod  the period to modify\n      * @param object  the interval to set from\n+     * @param chrono  the chronology to use\n      */\n-    public void setInto(ReadWritablePeriod writablePeriod, Object object) {\n-        ReadableInterval interval = (ReadableInterval) object;\n-        writablePeriod.setPeriod(interval.getStartMillis(), interval.getEndMillis());\n+    public void setInto(ReadWritablePeriod writablePeriod, Object object, Chronology chrono) {\n+        writablePeriod.setPeriod((ReadableInterval) object, chrono);\n     }\n \n     //-----------------------------------------------------------------------\n--- a/JodaTime/src/java/org/joda/time/convert/ReadablePeriodConverter.java\n+++ b/JodaTime/src/java/org/joda/time/convert/ReadablePeriodConverter.java\n  */\n package org.joda.time.convert;\n \n+import org.joda.time.Chronology;\n import org.joda.time.PeriodType;\n import org.joda.time.ReadWritablePeriod;\n import org.joda.time.ReadablePeriod;\n  * @since 1.0\n  */\n class ReadablePeriodConverter extends AbstractConverter\n-        implements PeriodConverter, DurationConverter {\n+        implements PeriodConverter {\n \n     /**\n      * Singleton instance.\n \n     //-----------------------------------------------------------------------\n     /**\n-     * Extracts the millis from an object of this convertor's type.\n-     * \n-     * @param object  the object to convert, must not be null\n-     * @return the millisecond value\n-     * @throws NullPointerException if the object is null\n-     * @throws ClassCastException if the object is an invalid type\n-     * @throws IllegalArgumentException if the object is invalid\n-     */\n-    public long getDurationMillis(Object object) {\n-        return ((ReadablePeriod) object).toDurationMillis();\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n      * Extracts duration values from an object of this converter's type, and\n      * sets them into the given ReadWritablePeriod.\n      *\n      * @param duration duration to get modified\n      * @param object  the object to convert, must not be null\n-     * @return the millisecond duration\n+     * @param chrono  the chronology to use\n      * @throws NullPointerException if the duration or object is null\n      * @throws ClassCastException if the object is an invalid type\n      * @throws IllegalArgumentException if the object is invalid\n      */\n-    public void setInto(ReadWritablePeriod duration, Object object) {\n+    public void setInto(ReadWritablePeriod duration, Object object, Chronology chrono) {\n         duration.setPeriod((ReadablePeriod) object);\n     }\n \n      * Selects a suitable period type for the given object.\n      *\n      * @param object  the object to examine, must not be null\n-     * @param precise  true if a precise type is required\n      * @return the period type from the readable duration\n      * @throws NullPointerException if the object is null\n      * @throws ClassCastException if the object is an invalid type\n      */\n-    public PeriodType getPeriodType(Object object, boolean precise) {\n+    public PeriodType getPeriodType(Object object) {\n         ReadablePeriod period = (ReadablePeriod) object;\n-        if (precise) {\n-            if (period.getPeriodType().isPrecise()) {\n-                return period.getPeriodType();\n-            } else {\n-                return PeriodType.getPreciseAllType();\n-            }\n-        }\n         return period.getPeriodType();\n     }\n \n--- a/JodaTime/src/java/org/joda/time/convert/StringConverter.java\n+++ b/JodaTime/src/java/org/joda/time/convert/StringConverter.java\n \n import org.joda.time.Chronology;\n import org.joda.time.DateTimeZone;\n-import org.joda.time.PeriodType;\n-import org.joda.time.MutablePeriod;\n+import org.joda.time.Period;\n import org.joda.time.ReadWritableInterval;\n import org.joda.time.ReadWritablePeriod;\n-import org.joda.time.Period;\n import org.joda.time.chrono.ISOChronology;\n+import org.joda.time.field.FieldUtils;\n import org.joda.time.format.DateTimeParser;\n import org.joda.time.format.ISODateTimeFormat;\n import org.joda.time.format.ISOPeriodFormat;\n \n     //-----------------------------------------------------------------------\n     /**\n-     * Gets the duration of the string using the PreciseAll type.\n+     * Gets the duration of the string using the standard type.\n      * This matches the toString() method of ReadableDuration.\n      * \n      * @param object  the object to convert, must not be null\n      * @throws ClassCastException if the object is invalid\n      */\n     public long getDurationMillis(Object object) {\n-        String str = (String) object;\n-        MutablePeriod period = new MutablePeriod(PeriodType.getPreciseAllType());\n-        PeriodParser parser = ISOPeriodFormat.getInstance().standard();\n-        int pos = parser.parseInto(period, str, 0);\n-        if (pos < str.length()) {\n-            if (pos < 0) {\n-                // Parse again to get a better exception thrown.\n-                parser.parseMutablePeriod(period.getPeriodType(), str);\n-            }\n-            throw new IllegalArgumentException(\"Invalid format: \\\"\" + str + '\"');\n-        }\n-        return period.toDurationMillis();\n+        // parse here because duration could be bigger than the int supported\n+        // by the period parser\n+        String original = (String) object;\n+        String str = original;\n+        int len = str.length();\n+        if (len >= 4 &&\n+            (str.charAt(0) == 'P' || str.charAt(0) == 'p') &&\n+            (str.charAt(1) == 'T' || str.charAt(1) == 't') &&\n+            (str.charAt(len - 1) == 'S' || str.charAt(len - 1) == 's')) {\n+            // ok\n+        } else {\n+            throw new IllegalArgumentException(\"Invalid format: \\\"\" + original + '\"');\n+        }\n+        str = str.substring(2, len - 1);\n+        int dot = -1;\n+        for (int i = 0; i < str.length(); i++) {\n+            if ((str.charAt(i) >= '0' && str.charAt(i) <= '9') ||\n+                (i == 0 && str.charAt(0) == '-')) {\n+                // ok\n+            } else if (i > 0 && str.charAt(i) == '.' && dot == -1) {\n+                // ok\n+                dot = i;\n+            } else {\n+                throw new IllegalArgumentException(\"Invalid format: \\\"\" + original + '\"');\n+            }\n+        }\n+        long millis = 0, seconds = 0;\n+        if (dot > 0) {\n+            seconds = Long.parseLong(str.substring(0, dot));\n+            str = str.substring(dot + 1);\n+            if (str.length() != 3) {\n+                str = (str + \"000\").substring(0, 3);\n+            }\n+            millis = Integer.parseInt(str);\n+        } else {\n+            seconds = Long.parseLong(str);\n+        }\n+        if (seconds < 0) {\n+            return FieldUtils.safeAdd(FieldUtils.safeMultiply(seconds, 1000), -millis);\n+        } else {\n+            return FieldUtils.safeAdd(FieldUtils.safeMultiply(seconds, 1000), millis);\n+        }\n     }\n \n     //-----------------------------------------------------------------------\n      *\n      * @param period  period to get modified\n      * @param object  the object to convert, must not be null\n+     * @param chrono  the chronology to use\n      * @return the millisecond duration\n      * @throws ClassCastException if the object is invalid\n      */\n-    public void setInto(ReadWritablePeriod period, Object object) {\n+    public void setInto(ReadWritablePeriod period, Object object, Chronology chrono) {\n         String str = (String) object;\n         PeriodParser parser = ISOPeriodFormat.getInstance().standard();\n         int pos = parser.parseInto(period, str, 0);\n         char c = leftStr.charAt(0);\n         if (c == 'P' || c == 'p') {\n             startInstant = 0;\n-            period = periodParser.parsePeriod(getPeriodType(leftStr, false), leftStr);\n+            period = periodParser.parsePeriod(getPeriodType(leftStr), leftStr);\n         } else {\n             startInstant = dateTimeParser.parseMillis(leftStr);\n             period = null;\n             if (period != null) {\n                 throw new IllegalArgumentException(\"Interval composed of two durations: \" + str);\n             }\n-            period = periodParser.parsePeriod(getPeriodType(rightStr, false), rightStr);\n+            period = periodParser.parsePeriod(getPeriodType(rightStr), rightStr);\n             endInstant = period.addTo(startInstant, 1);\n         } else {\n             endInstant = dateTimeParser.parseMillis(rightStr);\n--- a/JodaTime/src/java/org/joda/time/format/PeriodFormatterBuilder.java\n+++ b/JodaTime/src/java/org/joda/time/format/PeriodFormatterBuilder.java\n import java.util.List;\n \n import org.joda.time.DateTimeConstants;\n+import org.joda.time.DurationFieldType;\n import org.joda.time.PeriodType;\n import org.joda.time.ReadWritablePeriod;\n import org.joda.time.ReadablePeriod;\n             default:\n                 return Long.MAX_VALUE;\n             case YEARS:\n-                value = period.getYears();\n+                value = period.get(DurationFieldType.years());\n                 break;\n             case MONTHS:\n-                value = period.getMonths();\n+                value = period.get(DurationFieldType.months());\n                 break;\n             case WEEKS:\n-                value = period.getWeeks();\n+                value = period.get(DurationFieldType.weeks());\n                 break;\n             case DAYS:\n-                value = period.getDays();\n+                value = period.get(DurationFieldType.days());\n                 break;\n             case HOURS:\n-                value = period.getHours();\n+                value = period.get(DurationFieldType.hours());\n                 break;\n             case MINUTES:\n-                value = period.getMinutes();\n+                value = period.get(DurationFieldType.minutes());\n                 break;\n             case SECONDS:\n-                value = period.getSeconds();\n+                value = period.get(DurationFieldType.seconds());\n                 break;\n             case MILLIS:\n-                value = period.getMillis();\n+                value = period.get(DurationFieldType.millis());\n                 break;\n             case SECONDS_MILLIS: // drop through\n             case SECONDS_OPTIONAL_MILLIS:\n-                value = period.getSeconds() * DateTimeConstants.MILLIS_PER_SECOND + period.getMillis();\n+                int seconds = period.get(DurationFieldType.seconds());\n+                int millis = period.get(DurationFieldType.millis());\n+                value = seconds * DateTimeConstants.MILLIS_PER_SECOND + millis;\n                 break;\n             }\n \n         }\n \n         boolean isZero(ReadablePeriod period) {\n-            return (period.getYears() == 0 && period.getMonths() == 0 &&\n-                    period.getWeeks() == 0 && period.getDays() == 0 &&\n-                    period.getHours() == 0 && period.getMinutes() == 0 &&\n-                    period.getSeconds() == 0 && period.getMillis() == 0);\n+            for (int i = 0, isize = period.size(); i < isize; i++) {\n+                if (period.getValue(i) != 0) {\n+                    return false;\n+                }\n+            }\n+            return true;\n         }\n \n         boolean isSupported(PeriodType type, int field) {\n             default:\n                 return false;\n             case YEARS:\n-                return type.years().isSupported();\n+                return type.isSupported(DurationFieldType.years());\n             case MONTHS:\n-                return type.months().isSupported();\n+                return type.isSupported(DurationFieldType.months());\n             case WEEKS:\n-                return type.weeks().isSupported();\n+                return type.isSupported(DurationFieldType.weeks());\n             case DAYS:\n-                return type.days().isSupported();\n+                return type.isSupported(DurationFieldType.days());\n             case HOURS:\n-                return type.hours().isSupported();\n+                return type.isSupported(DurationFieldType.hours());\n             case MINUTES:\n-                return type.minutes().isSupported();\n+                return type.isSupported(DurationFieldType.minutes());\n             case SECONDS:\n-                return type.seconds().isSupported();\n+                return type.isSupported(DurationFieldType.seconds());\n             case MILLIS:\n-                return type.millis().isSupported();\n+                return type.isSupported(DurationFieldType.millis());\n             case SECONDS_MILLIS: // drop through\n             case SECONDS_OPTIONAL_MILLIS:\n-                return type.seconds().isSupported() ||  type.millis().isSupported();\n+                return type.isSupported(DurationFieldType.seconds()) ||\n+                       type.isSupported(DurationFieldType.millis());\n             }\n         }\n \n--- a/JodaTime/src/test/org/joda/time/TestDateTimeUtils.java\n+++ b/JodaTime/src/test/org/joda/time/TestDateTimeUtils.java\n \n     //-----------------------------------------------------------------------\n     public void testGetPeriodType_PeriodType() {\n-        assertEquals(PeriodType.getDayHourType(), DateTimeUtils.getPeriodType(PeriodType.getDayHourType()));\n-        assertEquals(PeriodType.getAllType(), DateTimeUtils.getPeriodType(null));\n+        assertEquals(PeriodType.dayTime(), DateTimeUtils.getPeriodType(PeriodType.dayTime()));\n+        assertEquals(PeriodType.standard(), DateTimeUtils.getPeriodType(null));\n     }\n \n     //-----------------------------------------------------------------------\n--- a/JodaTime/src/test/org/joda/time/TestDuration_Basics.java\n+++ b/JodaTime/src/test/org/joda/time/TestDuration_Basics.java\n         long length = (365L + 2L * 30L + 3L * 7L + 4L) * DateTimeConstants.MILLIS_PER_DAY +\n             5L * DateTimeConstants.MILLIS_PER_HOUR +\n             6L * DateTimeConstants.MILLIS_PER_MINUTE +\n-            7L * DateTimeConstants.MILLIS_PER_SECOND + 8L;\n-        int total = (365 + 2 * 30 + 3 * 7 + 4) * 24 + 5;\n+            7L * DateTimeConstants.MILLIS_PER_SECOND + 845L;\n         Duration test = new Duration(length);\n-        assertEquals(\"PT\" + total + \"H6M7.008S\", test.toString());\n+        assertEquals(\"PT\" + (length / 1000) + \".\" + (length % 1000) + \"S\", test.toString());\n         \n         test = new Duration(0L);\n         assertEquals(\"PT0S\", test.toString());\n         \n         test = new Duration(12345L);\n         assertEquals(\"PT12.345S\", test.toString());\n+        \n+        test = new Duration(-12345L);\n+        assertEquals(\"PT-12.345S\", test.toString());\n     }\n \n     //-----------------------------------------------------------------------\n             7L * DateTimeConstants.MILLIS_PER_SECOND + 8L;\n         Duration test = new Duration(length);\n         Period result = test.toPeriod();\n-        assertEquals(PeriodType.getAllType(), result.getPeriodType());\n+        assertEquals(PeriodType.standard(), result.getPeriodType());\n         // only time fields are precise in AllType\n         assertEquals(0, result.getYears());  // (4 + (3 * 7) + (2 * 30) + 365) == 450\n         assertEquals(0, result.getMonths());\n         assertEquals(6, result.getMinutes());\n         assertEquals(7, result.getSeconds());\n         assertEquals(8, result.getMillis());\n-        assertEquals(true, result.isPrecise());\n-        assertEquals(length, result.toDurationMillis());\n     }\n \n     public void testToPeriod_PeriodType1() {\n             7L * DateTimeConstants.MILLIS_PER_SECOND + 8L;\n         Duration test = new Duration(length);\n         Period result = test.toPeriod(null);\n-        assertEquals(PeriodType.getAllType(), result.getPeriodType());\n+        assertEquals(PeriodType.standard(), result.getPeriodType());\n         // only time fields are precise in AllType\n         assertEquals(0, result.getYears());  // (4 + (3 * 7) + (2 * 30) + 365) == 450\n         assertEquals(0, result.getMonths());\n         assertEquals(6, result.getMinutes());\n         assertEquals(7, result.getSeconds());\n         assertEquals(8, result.getMillis());\n-        assertEquals(true, result.isPrecise());\n-        assertEquals(length, result.toDurationMillis());\n-    }\n-\n-    public void testToPeriod_PeriodType2() {\n-        long length =\n-            (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY +\n-            5L * DateTimeConstants.MILLIS_PER_HOUR +\n-            6L * DateTimeConstants.MILLIS_PER_MINUTE +\n-            7L * DateTimeConstants.MILLIS_PER_SECOND + 8L;\n-        Duration test = new Duration(length);\n-        Period result = test.toPeriod(PeriodType.getPreciseAllType());\n-        assertEquals(PeriodType.getPreciseAllType(), result.getPeriodType());\n-        // only time fields are precise in AllType\n-        assertEquals(1, result.getYears());\n-        assertEquals(2, result.getMonths());\n-        assertEquals(3, result.getWeeks());\n-        assertEquals(4, result.getDays());\n-        assertEquals(5, result.getHours());\n-        assertEquals(6, result.getMinutes());\n-        assertEquals(7, result.getSeconds());\n-        assertEquals(8, result.getMillis());\n-        assertEquals(true, result.isPrecise());\n-        assertEquals(length, result.toDurationMillis());\n-    }\n+    }\n+\n+//    public void testToPeriod_PeriodType2() {\n+//        long length =\n+//            (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY +\n+//            5L * DateTimeConstants.MILLIS_PER_HOUR +\n+//            6L * DateTimeConstants.MILLIS_PER_MINUTE +\n+//            7L * DateTimeConstants.MILLIS_PER_SECOND + 8L;\n+//        Duration test = new Duration(length);\n+//        Period result = test.toPeriod(PeriodType.getPreciseAllType());\n+//        assertEquals(PeriodType.getPreciseAllType(), result.getPeriodType());\n+//        // only time fields are precise in AllType\n+//        assertEquals(1, result.getYears());\n+//        assertEquals(2, result.getMonths());\n+//        assertEquals(3, result.getWeeks());\n+//        assertEquals(4, result.getDays());\n+//        assertEquals(5, result.getHours());\n+//        assertEquals(6, result.getMinutes());\n+//        assertEquals(7, result.getSeconds());\n+//        assertEquals(8, result.getMillis());\n+//        assertEquals(true, result.isPrecise());\n+//        assertEquals(length, result.toDurationMillis());\n+//    }\n \n     //-----------------------------------------------------------------------\n     public void testWithMillis1() {\n--- a/JodaTime/src/test/org/joda/time/TestDuration_Constructors.java\n+++ b/JodaTime/src/test/org/joda/time/TestDuration_Constructors.java\n      * Test constructor (Object)\n      */\n     public void testConstructor_Object1() throws Throwable {\n-        Duration test = new Duration(\"P1Y2M3D\");\n-        assertEquals(\n-            (365L + 2L * 30L + 3L) * DateTimeConstants.MILLIS_PER_DAY, test.getMillis());\n+        Duration test = new Duration(\"P72.345S\");\n+        assertEquals(72345, test.getMillis());\n     }\n \n     public void testConstructor_Object2() throws Throwable {\n         assertEquals(dt2.getMillis() - dt1.getMillis(), test.getMillis());\n     }\n \n-    public void testConstructor_Object6() throws Throwable {\n-        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n-        DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);\n-        Period base = new Period(dt2.getMillis() - dt1.getMillis());  // precise\n-        Duration test = new Duration(base);\n-        assertEquals(dt2.getMillis() - dt1.getMillis(), test.getMillis());\n-    }\n-\n }\n--- a/JodaTime/src/test/org/joda/time/TestInterval_Basics.java\n+++ b/JodaTime/src/test/org/joda/time/TestInterval_Basics.java\n         Interval test = new Interval(dt1, dt2);\n         \n         Period result = test.toPeriod();\n-        assertEquals(PeriodType.getAllType(), result.getPeriodType());\n+        assertEquals(PeriodType.standard(), result.getPeriodType());\n         assertEquals(1, result.getYears());\n         assertEquals(2, result.getMonths());\n         assertEquals(0, result.getWeeks());\n         Interval test = new Interval(dt1, dt2);\n         \n         Period result = test.toPeriod(null);\n-        assertEquals(PeriodType.getAllType(), result.getPeriodType());\n+        assertEquals(PeriodType.standard(), result.getPeriodType());\n         assertEquals(1, result.getYears());\n         assertEquals(2, result.getMonths());\n         assertEquals(0, result.getWeeks());\n         DateTime dt2 = new DateTime(2005, 8, 13, 12, 14, 16, 18);\n         Interval test = new Interval(dt1, dt2);\n         \n-        Period result = test.toPeriod(PeriodType.getYearWeekType());\n-        assertEquals(PeriodType.getYearWeekType(), result.getPeriodType());\n+        Period result = test.toPeriod(PeriodType.yearWeekDayTime());\n+        assertEquals(PeriodType.yearWeekDayTime(), result.getPeriodType());\n         assertEquals(1, result.getYears());\n         assertEquals(0, result.getMonths());\n         assertEquals(9, result.getWeeks());\n         DateTime dt2 = new DateTime(2005, 6, 9, 12, 14, 16, 18);\n         Interval test = new Interval(dt1, dt2);\n         \n-        Period result = test.toPeriod(PeriodType.getYearWeekType());\n-        assertEquals(PeriodType.getYearWeekType(), result.getPeriodType());\n+        Period result = test.toPeriod(PeriodType.yearWeekDayTime());\n+        assertEquals(PeriodType.yearWeekDayTime(), result.getPeriodType());\n         assertEquals(1, result.getYears());\n         assertEquals(0, result.getMonths());\n         assertEquals(0, result.getWeeks());\n--- a/JodaTime/src/test/org/joda/time/TestInterval_Constructors.java\n+++ b/JodaTime/src/test/org/joda/time/TestInterval_Constructors.java\n \n     public void testConstructor_RI_RP3() throws Throwable {\n         Instant dt = new Instant(new DateTime(TEST_TIME_NOW));\n-        Period dur = new Period(0, 6, 0, 3, 1, 0, 0, 0, PeriodType.getAllTypeUTC());\n+        Period dur = new Period(0, 6, 0, 3, 1, 0, 0, 0, PeriodType.standard());\n         long result = TEST_TIME_NOW;\n         result = ISOChronology.getInstanceUTC().months().add(result, 6);\n         result = ISOChronology.getInstanceUTC().days().add(result, 3);\n \n     public void testConstructor_RP_RI3() throws Throwable {\n         Instant dt = new Instant(new DateTime(TEST_TIME_NOW));\n-        Period dur = new Period(0, 6, 0, 3, 1, 0, 0, 0, PeriodType.getAllTypeUTC());\n+        Period dur = new Period(0, 6, 0, 3, 1, 0, 0, 0, PeriodType.standard());\n         long result = TEST_TIME_NOW;\n         result = ISOChronology.getInstanceUTC().months().add(result, -6);\n         result = ISOChronology.getInstanceUTC().days().add(result, -3);\n--- a/JodaTime/src/test/org/joda/time/TestMutableInterval_Basics.java\n+++ b/JodaTime/src/test/org/joda/time/TestMutableInterval_Basics.java\n         MutableInterval test = new MutableInterval(dt1, dt2);\n         \n         Period result = test.toPeriod();\n-        assertEquals(PeriodType.getAllType(), result.getPeriodType());\n+        assertEquals(PeriodType.standard(), result.getPeriodType());\n         assertEquals(1, result.getYears());\n         assertEquals(2, result.getMonths());\n         assertEquals(0, result.getWeeks());\n         MutableInterval test = new MutableInterval(dt1, dt2);\n         \n         Period result = test.toPeriod(null);\n-        assertEquals(PeriodType.getAllType(), result.getPeriodType());\n+        assertEquals(PeriodType.standard(), result.getPeriodType());\n         assertEquals(1, result.getYears());\n         assertEquals(2, result.getMonths());\n         assertEquals(0, result.getWeeks());\n         DateTime dt2 = new DateTime(2005, 8, 13, 12, 14, 16, 18);\n         MutableInterval test = new MutableInterval(dt1, dt2);\n         \n-        Period result = test.toPeriod(PeriodType.getYearWeekType());\n-        assertEquals(PeriodType.getYearWeekType(), result.getPeriodType());\n+        Period result = test.toPeriod(PeriodType.yearWeekDayTime());\n+        assertEquals(PeriodType.yearWeekDayTime(), result.getPeriodType());\n         assertEquals(1, result.getYears());\n         assertEquals(0, result.getMonths());\n         assertEquals(9, result.getWeeks());\n         DateTime dt2 = new DateTime(2005, 6, 9, 12, 14, 16, 18);\n         MutableInterval test = new MutableInterval(dt1, dt2);\n         \n-        Period result = test.toPeriod(PeriodType.getYearWeekType());\n-        assertEquals(PeriodType.getYearWeekType(), result.getPeriodType());\n+        Period result = test.toPeriod(PeriodType.yearWeekDayTime());\n+        assertEquals(PeriodType.yearWeekDayTime(), result.getPeriodType());\n         assertEquals(1, result.getYears());\n         assertEquals(0, result.getMonths());\n         assertEquals(0, result.getWeeks());\n--- a/JodaTime/src/test/org/joda/time/TestMutableInterval_Constructors.java\n+++ b/JodaTime/src/test/org/joda/time/TestMutableInterval_Constructors.java\n \n     public void testConstructor_RI_RP3() throws Throwable {\n         Instant dt = new Instant(new DateTime(TEST_TIME_NOW));\n-        Period dur = new Period(0, 6, 0, 3, 1, 0, 0, 0, PeriodType.getAllTypeUTC());\n+        Period dur = new Period(0, 6, 0, 3, 1, 0, 0, 0, PeriodType.standard());\n         long result = TEST_TIME_NOW;\n         result = ISOChronology.getInstanceUTC().months().add(result, 6);\n         result = ISOChronology.getInstanceUTC().days().add(result, 3);\n \n     public void testConstructor_RP_RI3() throws Throwable {\n         Instant dt = new Instant(new DateTime(TEST_TIME_NOW));\n-        Period dur = new Period(0, 6, 0, 3, 1, 0, 0, 0, PeriodType.getAllTypeUTC());\n+        Period dur = new Period(0, 6, 0, 3, 1, 0, 0, 0, PeriodType.standard());\n         long result = TEST_TIME_NOW;\n         result = ISOChronology.getInstanceUTC().months().add(result, -6);\n         result = ISOChronology.getInstanceUTC().days().add(result, -3);\n--- a/JodaTime/src/test/org/joda/time/TestMutablePeriod_Basics.java\n+++ b/JodaTime/src/test/org/joda/time/TestMutablePeriod_Basics.java\n     //-----------------------------------------------------------------------\n     public void testGetPeriodType() {\n         MutablePeriod test = new MutablePeriod();\n-        assertEquals(PeriodType.getAllType(), test.getPeriodType());\n-    }\n-\n-    public void testGetIsPrecise() {\n-        MutablePeriod test = new MutablePeriod(123L);\n-        assertEquals(true, test.isPrecise());\n-        test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n-        assertEquals(false, test.isPrecise());\n+        assertEquals(PeriodType.standard(), test.getPeriodType());\n     }\n \n     public void testGetMethods() {\n         \n         assertEquals(false, test1.equals(\"Hello\"));\n         assertEquals(true, test1.equals(new MockMutablePeriod(123L)));\n-        assertEquals(false, test1.equals(new Period(123L, PeriodType.getDayHourType())));\n+        assertEquals(false, test1.equals(new Period(123L, PeriodType.dayTime())));\n     }\n     \n     class MockMutablePeriod extends BasePeriod {\n         public MockMutablePeriod(long value) {\n-            super(value, null);\n+            super(value, null, null);\n         }\n     }\n \n     \n     public void testAddTo3() {\n         long expected = TEST_TIME_NOW;\n+        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n+        long added = test.addTo(TEST_TIME_NOW, 0);\n+        assertEquals(expected, added);\n+    }\n+    \n+    public void testAddTo4() {\n+        long expected = TEST_TIME_NOW + 100L;\n+        MutablePeriod test = new MutablePeriod(100L);\n+        long added = test.addTo(TEST_TIME_NOW, 1);\n+        assertEquals(expected, added);\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testAddToWithChronology1() {\n+        long expected = TEST_TIME_NOW;\n+        expected = ISOChronology.getInstance().years().add(expected, 1);\n+        expected = ISOChronology.getInstance().months().add(expected, 2);\n+        expected = ISOChronology.getInstance().weeks().add(expected, 3);\n+        expected = ISOChronology.getInstance().days().add(expected, 4);\n+        expected = ISOChronology.getInstance().hours().add(expected, 5);\n+        expected = ISOChronology.getInstance().minutes().add(expected, 6);\n+        expected = ISOChronology.getInstance().seconds().add(expected, 7);\n+        expected = ISOChronology.getInstance().millis().add(expected, 8);\n+        \n+        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n+        long added = test.addTo(TEST_TIME_NOW, 1, ISOChronology.getInstance());\n+        assertEquals(expected, added);\n+    }\n+    \n+    public void testAddToWithChronology2() {\n+        long expected = TEST_TIME_NOW;\n         expected = ISOChronology.getInstanceUTC().years().add(expected, -2);\n         expected = ISOChronology.getInstanceUTC().months().add(expected, -4);\n         expected = ISOChronology.getInstanceUTC().weeks().add(expected, -6);\n         expected = ISOChronology.getInstanceUTC().seconds().add(expected, -14);\n         expected = ISOChronology.getInstanceUTC().millis().add(expected, -16);\n         \n-        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.getAllType(ISOChronology.getInstanceUTC()));\n-        long added = test.addTo(TEST_TIME_NOW, -2);\n-        assertEquals(expected, added);\n-    }\n-    \n-    public void testAddTo4() {\n-        long expected = TEST_TIME_NOW;\n-        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n-        long added = test.addTo(TEST_TIME_NOW, 0);\n-        assertEquals(expected, added);\n-    }\n-    \n-    public void testAddTo5() {\n-        long expected = TEST_TIME_NOW + 100L;\n-        MutablePeriod test = new MutablePeriod(100L);\n-        long added = test.addTo(TEST_TIME_NOW, 1);\n-        assertEquals(expected, added);\n-    }\n-    \n-    //-----------------------------------------------------------------------\n-    public void testAddToWithChronology1() {\n+        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.standard());\n+        long added = test.addTo(TEST_TIME_NOW, -2, ISOChronology.getInstanceUTC());  // chrono specified so use it\n+        assertEquals(expected, added);\n+    }\n+    \n+    public void testAddToWithChronology3() {\n+        long expected = TEST_TIME_NOW;\n+        expected = ISOChronology.getInstance().years().add(expected, -2);\n+        expected = ISOChronology.getInstance().months().add(expected, -4);\n+        expected = ISOChronology.getInstance().weeks().add(expected, -6);\n+        expected = ISOChronology.getInstance().days().add(expected, -8);\n+        expected = ISOChronology.getInstance().hours().add(expected, -10);\n+        expected = ISOChronology.getInstance().minutes().add(expected, -12);\n+        expected = ISOChronology.getInstance().seconds().add(expected, -14);\n+        expected = ISOChronology.getInstance().millis().add(expected, -16);\n+        \n+        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.standard());\n+        long added = test.addTo(TEST_TIME_NOW, -2, null);  // no chrono so use default\n+        assertEquals(expected, added);\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testAddToRI1() {\n         long expected = TEST_TIME_NOW;\n         expected = ISOChronology.getInstance().years().add(expected, 1);\n         expected = ISOChronology.getInstance().months().add(expected, 2);\n         expected = ISOChronology.getInstance().millis().add(expected, 8);\n         \n         MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n-        long added = test.addTo(TEST_TIME_NOW, 1, ISOChronology.getInstance());\n-        assertEquals(expected, added);\n-    }\n-    \n-    public void testAddToWithChronology2() {\n+        DateTime added = test.addTo(new Instant(), 1);  // Instant has no time zone, use default\n+        assertEquals(expected, added.getMillis());\n+        assertEquals(ISOChronology.getInstance(), added.getChronology());\n+    }\n+    \n+    public void testAddToRI2() {\n         long expected = TEST_TIME_NOW;\n         expected = ISOChronology.getInstance().years().add(expected, -2);\n         expected = ISOChronology.getInstance().months().add(expected, -4);\n         expected = ISOChronology.getInstance().seconds().add(expected, -14);\n         expected = ISOChronology.getInstance().millis().add(expected, -16);\n         \n-        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.getAllType(ISOChronology.getInstanceUTC()));\n-        long added = test.addTo(TEST_TIME_NOW, -2, ISOChronology.getInstance());  // local specified so use it\n-        assertEquals(expected, added);\n-    }\n-    \n-    public void testAddToWithChronology3() {\n+        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.standard());\n+        DateTime added = test.addTo(new Instant(), -2);  // Instant has no time zone, use default\n+        assertEquals(expected, added.getMillis());\n+        assertEquals(ISOChronology.getInstance(), added.getChronology());\n+    }\n+    \n+    public void testAddToRI3() {\n         long expected = TEST_TIME_NOW;\n         expected = ISOChronology.getInstanceUTC().years().add(expected, -2);\n         expected = ISOChronology.getInstanceUTC().months().add(expected, -4);\n         expected = ISOChronology.getInstanceUTC().seconds().add(expected, -14);\n         expected = ISOChronology.getInstanceUTC().millis().add(expected, -16);\n         \n-        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.getAllType(ISOChronology.getInstanceUTC()));\n-        long added = test.addTo(TEST_TIME_NOW, -2, null);  // no chrono specified so drop back to duration (UTC)\n-        assertEquals(expected, added);\n-    }\n-    \n-    //-----------------------------------------------------------------------\n-    public void testAddToRI1() {\n+        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.standard());\n+        DateTime added = test.addTo(new DateTime(ISOChronology.getInstanceUTC()), -2);  // DateTime has UTC time zone\n+        assertEquals(expected, added.getMillis());\n+        assertEquals(ISOChronology.getInstanceUTC(), added.getChronology());\n+    }\n+    \n+    public void testAddToRI4() {\n+        long expected = TEST_TIME_NOW;\n+        expected = ISOChronology.getInstance(PARIS).years().add(expected, -2);\n+        expected = ISOChronology.getInstance(PARIS).months().add(expected, -4);\n+        expected = ISOChronology.getInstance(PARIS).weeks().add(expected, -6);\n+        expected = ISOChronology.getInstance(PARIS).days().add(expected, -8);\n+        expected = ISOChronology.getInstance(PARIS).hours().add(expected, -10);\n+        expected = ISOChronology.getInstance(PARIS).minutes().add(expected, -12);\n+        expected = ISOChronology.getInstance(PARIS).seconds().add(expected, -14);\n+        expected = ISOChronology.getInstance(PARIS).millis().add(expected, -16);\n+        \n+        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.standard());\n+        DateTime added = test.addTo(new DateTime(PARIS), -2);  // DateTime has PARIS time zone\n+        assertEquals(expected, added.getMillis());\n+        assertEquals(ISOChronology.getInstance(PARIS), added.getChronology());\n+    }\n+    \n+    public void testAddToRI5() {\n+        long expected = TEST_TIME_NOW;\n+        expected = ISOChronology.getInstance().years().add(expected, -2);\n+        expected = ISOChronology.getInstance().months().add(expected, -4);\n+        expected = ISOChronology.getInstance().weeks().add(expected, -6);\n+        expected = ISOChronology.getInstance().days().add(expected, -8);\n+        expected = ISOChronology.getInstance().hours().add(expected, -10);\n+        expected = ISOChronology.getInstance().minutes().add(expected, -12);\n+        expected = ISOChronology.getInstance().seconds().add(expected, -14);\n+        expected = ISOChronology.getInstance().millis().add(expected, -16);\n+        \n+        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.standard());\n+        DateTime added = test.addTo(null, -2);  // null has no time zone, use default\n+        assertEquals(expected, added.getMillis());\n+        assertEquals(ISOChronology.getInstance(), added.getChronology());\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testAddIntoRWI1() {\n         long expected = TEST_TIME_NOW;\n         expected = ISOChronology.getInstance().years().add(expected, 1);\n         expected = ISOChronology.getInstance().months().add(expected, 2);\n         expected = ISOChronology.getInstance().millis().add(expected, 8);\n         \n         MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n-        DateTime added = test.addTo(new Instant(), 1);  // Instant has no time zone, uses duration's zone (local)\n-        assertEquals(expected, added.getMillis());\n-        assertEquals(ISOChronology.getInstance(), added.getChronology());\n-    }\n-    \n-    public void testAddToRI2() {\n-        long expected = TEST_TIME_NOW;\n-        expected = ISOChronology.getInstanceUTC().years().add(expected, -2);\n-        expected = ISOChronology.getInstanceUTC().months().add(expected, -4);\n-        expected = ISOChronology.getInstanceUTC().weeks().add(expected, -6);\n-        expected = ISOChronology.getInstanceUTC().days().add(expected, -8);\n-        expected = ISOChronology.getInstanceUTC().hours().add(expected, -10);\n-        expected = ISOChronology.getInstanceUTC().minutes().add(expected, -12);\n-        expected = ISOChronology.getInstanceUTC().seconds().add(expected, -14);\n-        expected = ISOChronology.getInstanceUTC().millis().add(expected, -16);\n-        \n-        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.getAllType(ISOChronology.getInstanceUTC()));\n-        DateTime added = test.addTo(new Instant(), -2);  // Instant has no time zone, uses duration's zone (UTC)\n-        assertEquals(expected, added.getMillis());\n-        assertEquals(ISOChronology.getInstance(), added.getChronology());\n-    }\n-    \n-    public void testAddToRI3() {\n+        MutableDateTime mdt = new MutableDateTime();\n+        test.addInto(mdt, 1);\n+        assertEquals(expected, mdt.getMillis());\n+    }\n+    \n+    public void testAddIntoRWI2() {\n         long expected = TEST_TIME_NOW;\n         expected = ISOChronology.getInstance().years().add(expected, -2);\n         expected = ISOChronology.getInstance().months().add(expected, -4);\n         expected = ISOChronology.getInstance().seconds().add(expected, -14);\n         expected = ISOChronology.getInstance().millis().add(expected, -16);\n         \n-        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.getAllType(ISOChronology.getInstanceUTC()));\n-        DateTime added = test.addTo(new DateTime(), -2);  // DateTime has local time zone\n-        assertEquals(expected, added.getMillis());\n-        assertEquals(ISOChronology.getInstance(), added.getChronology());\n-    }\n-    \n-    public void testAddToRI4() {\n-        long expected = TEST_TIME_NOW;\n-        expected = ISOChronology.getInstance(PARIS).years().add(expected, -2);\n-        expected = ISOChronology.getInstance(PARIS).months().add(expected, -4);\n-        expected = ISOChronology.getInstance(PARIS).weeks().add(expected, -6);\n-        expected = ISOChronology.getInstance(PARIS).days().add(expected, -8);\n-        expected = ISOChronology.getInstance(PARIS).hours().add(expected, -10);\n-        expected = ISOChronology.getInstance(PARIS).minutes().add(expected, -12);\n-        expected = ISOChronology.getInstance(PARIS).seconds().add(expected, -14);\n-        expected = ISOChronology.getInstance(PARIS).millis().add(expected, -16);\n-        \n-        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.getAllType(ISOChronology.getInstanceUTC()));\n-        DateTime added = test.addTo(new DateTime(PARIS), -2);  // DateTime has PARIS time zone\n-        assertEquals(expected, added.getMillis());\n-        assertEquals(ISOChronology.getInstance(PARIS), added.getChronology());\n-    }\n-    \n-    public void testAddToRI5() {\n-        long expected = TEST_TIME_NOW;\n-        expected = ISOChronology.getInstanceUTC().years().add(expected, -2);\n-        expected = ISOChronology.getInstanceUTC().months().add(expected, -4);\n-        expected = ISOChronology.getInstanceUTC().weeks().add(expected, -6);\n-        expected = ISOChronology.getInstanceUTC().days().add(expected, -8);\n-        expected = ISOChronology.getInstanceUTC().hours().add(expected, -10);\n-        expected = ISOChronology.getInstanceUTC().minutes().add(expected, -12);\n-        expected = ISOChronology.getInstanceUTC().seconds().add(expected, -14);\n-        expected = ISOChronology.getInstanceUTC().millis().add(expected, -16);\n-        \n-        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.getAllType(ISOChronology.getInstanceUTC()));\n-        DateTime added = test.addTo(null, -2);  // null has no time zone, uses duration's zone (UTC)\n-        assertEquals(expected, added.getMillis());\n-        assertEquals(ISOChronology.getInstance(), added.getChronology());\n-    }\n-    \n-    //-----------------------------------------------------------------------\n-    public void testAddIntoRWI1() {\n-        long expected = TEST_TIME_NOW;\n-        expected = ISOChronology.getInstance().years().add(expected, 1);\n-        expected = ISOChronology.getInstance().months().add(expected, 2);\n-        expected = ISOChronology.getInstance().weeks().add(expected, 3);\n-        expected = ISOChronology.getInstance().days().add(expected, 4);\n-        expected = ISOChronology.getInstance().hours().add(expected, 5);\n-        expected = ISOChronology.getInstance().minutes().add(expected, 6);\n-        expected = ISOChronology.getInstance().seconds().add(expected, 7);\n-        expected = ISOChronology.getInstance().millis().add(expected, 8);\n-        \n-        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n-        MutableDateTime mdt = new MutableDateTime();\n-        test.addInto(mdt, 1);\n-        assertEquals(expected, mdt.getMillis());\n-    }\n-    \n-    public void testAddIntoRWI2() {\n-        long expected = TEST_TIME_NOW;\n-        expected = ISOChronology.getInstance().years().add(expected, -2);\n-        expected = ISOChronology.getInstance().months().add(expected, -4);\n-        expected = ISOChronology.getInstance().weeks().add(expected, -6);\n-        expected = ISOChronology.getInstance().days().add(expected, -8);\n-        expected = ISOChronology.getInstance().hours().add(expected, -10);\n-        expected = ISOChronology.getInstance().minutes().add(expected, -12);\n-        expected = ISOChronology.getInstance().seconds().add(expected, -14);\n-        expected = ISOChronology.getInstance().millis().add(expected, -16);\n-        \n-        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.getAllType(ISOChronology.getInstanceUTC()));\n+        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.standard());\n         MutableDateTime mdt = new MutableDateTime();\n         test.addInto(mdt, -2);  // MutableDateTime has a chronology, use it\n         assertEquals(expected, mdt.getMillis());\n     }\n \n     //-----------------------------------------------------------------------\n-    public void testToDurationMillis() {\n-        MutablePeriod test = new MutablePeriod(123L);\n-        assertEquals(123L, test.toDurationMillis());\n-        \n-        test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n-        try {\n-            test.toDurationMillis();\n-            fail();\n-        } catch (IllegalStateException ex) {}\n-    }\n-\n-    public void testToDuration() {\n-        MutablePeriod test = new MutablePeriod(123L);\n-        assertEquals(new Duration(123L), test.toDuration());\n-        \n-        test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n-        try {\n-            test.toDuration();\n-            fail();\n-        } catch (IllegalStateException ex) {}\n+    public void testToDurationMillisFrom() {\n+        MutablePeriod test = new MutablePeriod(123L);\n+        assertEquals(123L, test.toDurationMillisFrom(0L, null));\n+    }\n+\n+    public void testToDurationFrom() {\n+        MutablePeriod test = new MutablePeriod(123L);\n+        assertEquals(new Duration(123L), test.toDurationFrom(new Instant(0L)));\n     }\n \n     //-----------------------------------------------------------------------\n         MutablePeriod test = new MutablePeriod(123L);\n         MutablePeriod copy = test.copy();\n         assertEquals(test.getPeriodType(), copy.getPeriodType());\n-        assertEquals(test.isPrecise(), copy.isPrecise());\n-        assertEquals(test.toDurationMillis(), copy.toDurationMillis());\n+        assertEquals(test, copy);\n     }\n \n     //-----------------------------------------------------------------------\n         MutablePeriod test = new MutablePeriod(123L);\n         MutablePeriod copy = (MutablePeriod) test.clone();\n         assertEquals(test.getPeriodType(), copy.getPeriodType());\n-        assertEquals(test.isPrecise(), copy.isPrecise());\n-        assertEquals(test.toDurationMillis(), copy.toDurationMillis());\n+        assertEquals(test, copy);\n     }\n     \n }\n--- a/JodaTime/src/test/org/joda/time/TestMutablePeriod_Constructors.java\n+++ b/JodaTime/src/test/org/joda/time/TestMutablePeriod_Constructors.java\n      */\n     public void testConstructor1() throws Throwable {\n         MutablePeriod test = new MutablePeriod();\n-        assertEquals(PeriodType.getAllType(), test.getPeriodType());\n-        assertEquals(0, test.getYears());\n-        assertEquals(0, test.getMonths());\n-        assertEquals(0, test.getWeeks());\n-        assertEquals(0, test.getDays());\n-        assertEquals(0, test.getHours());\n-        assertEquals(0, test.getMinutes());\n-        assertEquals(0, test.getSeconds());\n-        assertEquals(0, test.getMillis());\n-        assertEquals(true, test.isPrecise());\n-        assertEquals(0, test.toDurationMillis());\n+        assertEquals(PeriodType.standard(), test.getPeriodType());\n+        assertEquals(0, test.getYears());\n+        assertEquals(0, test.getMonths());\n+        assertEquals(0, test.getWeeks());\n+        assertEquals(0, test.getDays());\n+        assertEquals(0, test.getHours());\n+        assertEquals(0, test.getMinutes());\n+        assertEquals(0, test.getSeconds());\n+        assertEquals(0, test.getMillis());\n     }\n \n     //-----------------------------------------------------------------------\n      * Test constructor (PeriodType)\n      */\n     public void testConstructor_PeriodType1() throws Throwable {\n-        MutablePeriod test = new MutablePeriod(PeriodType.getYearMonthType());\n-        assertEquals(PeriodType.getYearMonthType(), test.getPeriodType());\n-        assertEquals(0, test.getYears());\n-        assertEquals(0, test.getMonths());\n-        assertEquals(0, test.getWeeks());\n-        assertEquals(0, test.getDays());\n-        assertEquals(0, test.getHours());\n-        assertEquals(0, test.getMinutes());\n-        assertEquals(0, test.getSeconds());\n-        assertEquals(0, test.getMillis());\n-        assertEquals(true, test.isPrecise());\n-        assertEquals(0, test.toDurationMillis());\n+        MutablePeriod test = new MutablePeriod(PeriodType.yearMonthDayTime());\n+        assertEquals(PeriodType.yearMonthDayTime(), test.getPeriodType());\n+        assertEquals(0, test.getYears());\n+        assertEquals(0, test.getMonths());\n+        assertEquals(0, test.getWeeks());\n+        assertEquals(0, test.getDays());\n+        assertEquals(0, test.getHours());\n+        assertEquals(0, test.getMinutes());\n+        assertEquals(0, test.getSeconds());\n+        assertEquals(0, test.getMillis());\n     }\n \n     public void testConstructor_PeriodType2() throws Throwable {\n         MutablePeriod test = new MutablePeriod((PeriodType) null);\n-        assertEquals(PeriodType.getAllType(), test.getPeriodType());\n-        assertEquals(0, test.getYears());\n-        assertEquals(0, test.getMonths());\n-        assertEquals(0, test.getWeeks());\n-        assertEquals(0, test.getDays());\n-        assertEquals(0, test.getHours());\n-        assertEquals(0, test.getMinutes());\n-        assertEquals(0, test.getSeconds());\n-        assertEquals(0, test.getMillis());\n-        assertEquals(true, test.isPrecise());\n-        assertEquals(0, test.toDurationMillis());\n+        assertEquals(PeriodType.standard(), test.getPeriodType());\n+        assertEquals(0, test.getYears());\n+        assertEquals(0, test.getMonths());\n+        assertEquals(0, test.getWeeks());\n+        assertEquals(0, test.getDays());\n+        assertEquals(0, test.getHours());\n+        assertEquals(0, test.getMinutes());\n+        assertEquals(0, test.getSeconds());\n+        assertEquals(0, test.getMillis());\n     }\n \n     //-----------------------------------------------------------------------\n                 6 * DateTimeConstants.MILLIS_PER_MINUTE +\n                 7 * DateTimeConstants.MILLIS_PER_SECOND + 8;\n         MutablePeriod test = new MutablePeriod(length);\n-        assertEquals(PeriodType.getAllType(), test.getPeriodType());\n+        assertEquals(PeriodType.standard(), test.getPeriodType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n         assertEquals(0, test.getWeeks());\n         assertEquals(6, test.getMinutes());\n         assertEquals(7, test.getSeconds());\n         assertEquals(8, test.getMillis());\n-        assertEquals(true, test.isPrecise());\n-        assertEquals(length, test.toDurationMillis());\n     }\n \n     public void testConstructor_long2() throws Throwable {\n                 6 * DateTimeConstants.MILLIS_PER_MINUTE +\n                 7 * DateTimeConstants.MILLIS_PER_SECOND + 8;\n         MutablePeriod test = new MutablePeriod(length);\n-        assertEquals(PeriodType.getAllType(), test.getPeriodType());\n+        assertEquals(PeriodType.standard(), test.getPeriodType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n         assertEquals(0, test.getWeeks());\n         assertEquals(6, test.getMinutes());\n         assertEquals(7, test.getSeconds());\n         assertEquals(8, test.getMillis());\n-        assertEquals(true, test.isPrecise());\n-        assertEquals(length, test.toDurationMillis());\n     }\n \n     public void testConstructor_long3() throws Throwable {\n             6L * DateTimeConstants.MILLIS_PER_MINUTE +\n             7L * DateTimeConstants.MILLIS_PER_SECOND + 8L;\n         MutablePeriod test = new MutablePeriod(length);\n-        assertEquals(PeriodType.getAllType(), test.getPeriodType());\n+        assertEquals(PeriodType.standard(), test.getPeriodType());\n         // only time fields are precise in AllType\n         assertEquals(0, test.getYears());  // (4 + (3 * 7) + (2 * 30) + 365) == 450\n         assertEquals(0, test.getMonths());\n         assertEquals(6, test.getMinutes());\n         assertEquals(7, test.getSeconds());\n         assertEquals(8, test.getMillis());\n-        assertEquals(true, test.isPrecise());\n-        assertEquals(length, test.toDurationMillis());\n     }\n \n     //-----------------------------------------------------------------------\n                 5 * DateTimeConstants.MILLIS_PER_HOUR +\n                 6 * DateTimeConstants.MILLIS_PER_MINUTE +\n                 7 * DateTimeConstants.MILLIS_PER_SECOND + 8;\n-        MutablePeriod test = new MutablePeriod(length, null);\n-        assertEquals(PeriodType.getAllType(), test.getPeriodType());\n+        MutablePeriod test = new MutablePeriod(length, (PeriodType) null);\n+        assertEquals(PeriodType.standard(), test.getPeriodType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n         assertEquals(0, test.getWeeks());\n         assertEquals(6, test.getMinutes());\n         assertEquals(7, test.getSeconds());\n         assertEquals(8, test.getMillis());\n-        assertEquals(true, test.isPrecise());\n-        assertEquals(length, test.toDurationMillis());\n     }\n \n     public void testConstructor_long_PeriodType2() throws Throwable {\n                 5 * DateTimeConstants.MILLIS_PER_HOUR +\n                 6 * DateTimeConstants.MILLIS_PER_MINUTE +\n                 7 * DateTimeConstants.MILLIS_PER_SECOND + 8;\n-        MutablePeriod test = new MutablePeriod(length, PeriodType.getMillisType());\n-        assertEquals(PeriodType.getMillisType(), test.getPeriodType());\n+        MutablePeriod test = new MutablePeriod(length, PeriodType.millis());\n+        assertEquals(PeriodType.millis(), test.getPeriodType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n         assertEquals(0, test.getWeeks());\n         assertEquals(0, test.getMinutes());\n         assertEquals(0, test.getSeconds());\n         assertEquals(length, test.getMillis());\n-        assertEquals(true, test.isPrecise());\n-        assertEquals(length, test.toDurationMillis());\n     }\n \n     public void testConstructor_long_PeriodType3() throws Throwable {\n                 5 * DateTimeConstants.MILLIS_PER_HOUR +\n                 6 * DateTimeConstants.MILLIS_PER_MINUTE +\n                 7 * DateTimeConstants.MILLIS_PER_SECOND + 8;\n-        MutablePeriod test = new MutablePeriod(length, PeriodType.getAllType());\n-        assertEquals(PeriodType.getAllType(), test.getPeriodType());\n+        MutablePeriod test = new MutablePeriod(length, PeriodType.standard());\n+        assertEquals(PeriodType.standard(), test.getPeriodType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n         assertEquals(0, test.getWeeks());\n         assertEquals(6, test.getMinutes());\n         assertEquals(7, test.getSeconds());\n         assertEquals(8, test.getMillis());\n-        assertEquals(true, test.isPrecise());\n-        assertEquals(length, test.toDurationMillis());\n     }\n \n     public void testConstructor_long_PeriodType4() throws Throwable {\n                 5 * DateTimeConstants.MILLIS_PER_HOUR +\n                 6 * DateTimeConstants.MILLIS_PER_MINUTE +\n                 7 * DateTimeConstants.MILLIS_PER_SECOND + 8;\n-        MutablePeriod test = new MutablePeriod(length, PeriodType.getAllType().withMillisRemoved());\n-        assertEquals(PeriodType.getAllType().withMillisRemoved(), test.getPeriodType());\n+        MutablePeriod test = new MutablePeriod(length, PeriodType.standard().withMillisRemoved());\n+        assertEquals(PeriodType.standard().withMillisRemoved(), test.getPeriodType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n         assertEquals(0, test.getWeeks());\n         assertEquals(6, test.getMinutes());\n         assertEquals(7, test.getSeconds());\n         assertEquals(0, test.getMillis());\n-        assertEquals(true, test.isPrecise());\n-        assertEquals(length - 8, test.toDurationMillis());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testConstructor_long_Chronology1() throws Throwable {\n+        long length = 4 * DateTimeConstants.MILLIS_PER_DAY +\n+                5 * DateTimeConstants.MILLIS_PER_HOUR +\n+                6 * DateTimeConstants.MILLIS_PER_MINUTE +\n+                7 * DateTimeConstants.MILLIS_PER_SECOND + 8;\n+        MutablePeriod test = new MutablePeriod(length, Chronology.getISO());\n+        assertEquals(PeriodType.standard(), test.getPeriodType());\n+        assertEquals(0, test.getYears());\n+        assertEquals(0, test.getMonths());\n+        assertEquals(0, test.getWeeks());\n+        assertEquals(0, test.getDays());\n+        assertEquals((4 * 24) + 5, test.getHours());\n+        assertEquals(6, test.getMinutes());\n+        assertEquals(7, test.getSeconds());\n+        assertEquals(8, test.getMillis());\n+    }\n+\n+    public void testConstructor_long_Chronology2() throws Throwable {\n+        long length = 4 * DateTimeConstants.MILLIS_PER_DAY +\n+                5 * DateTimeConstants.MILLIS_PER_HOUR +\n+                6 * DateTimeConstants.MILLIS_PER_MINUTE +\n+                7 * DateTimeConstants.MILLIS_PER_SECOND + 8;\n+        MutablePeriod test = new MutablePeriod(length, Chronology.getISOUTC());\n+        assertEquals(PeriodType.standard(), test.getPeriodType());\n+        assertEquals(0, test.getYears());\n+        assertEquals(0, test.getMonths());\n+        assertEquals(0, test.getWeeks());\n+        assertEquals(4, test.getDays());\n+        assertEquals(5, test.getHours());\n+        assertEquals(6, test.getMinutes());\n+        assertEquals(7, test.getSeconds());\n+        assertEquals(8, test.getMillis());\n+    }\n+\n+    public void testConstructor_long_Chronology3() throws Throwable {\n+        long length = 4 * DateTimeConstants.MILLIS_PER_DAY +\n+                5 * DateTimeConstants.MILLIS_PER_HOUR +\n+                6 * DateTimeConstants.MILLIS_PER_MINUTE +\n+                7 * DateTimeConstants.MILLIS_PER_SECOND + 8;\n+        MutablePeriod test = new MutablePeriod(length, (Chronology) null);\n+        assertEquals(PeriodType.standard(), test.getPeriodType());\n+        assertEquals(0, test.getYears());\n+        assertEquals(0, test.getMonths());\n+        assertEquals(0, test.getWeeks());\n+        assertEquals(0, test.getDays());\n+        assertEquals((4 * 24) + 5, test.getHours());\n+        assertEquals(6, test.getMinutes());\n+        assertEquals(7, test.getSeconds());\n+        assertEquals(8, test.getMillis());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testConstructor_long_PeriodType_Chronology1() throws Throwable {\n+        long length = 4 * DateTimeConstants.MILLIS_PER_DAY +\n+                5 * DateTimeConstants.MILLIS_PER_HOUR +\n+                6 * DateTimeConstants.MILLIS_PER_MINUTE +\n+                7 * DateTimeConstants.MILLIS_PER_SECOND + 8;\n+        MutablePeriod test = new MutablePeriod(length, PeriodType.time().withMillisRemoved(), Chronology.getISO());\n+        assertEquals(PeriodType.time().withMillisRemoved(), test.getPeriodType());\n+        assertEquals(0, test.getYears());\n+        assertEquals(0, test.getMonths());\n+        assertEquals(0, test.getWeeks());\n+        assertEquals(0, test.getDays());\n+        assertEquals((4 * 24) + 5, test.getHours());\n+        assertEquals(6, test.getMinutes());\n+        assertEquals(7, test.getSeconds());\n+        assertEquals(0, test.getMillis());\n+    }\n+\n+    public void testConstructor_long_PeriodType_Chronology2() throws Throwable {\n+        long length = 4 * DateTimeConstants.MILLIS_PER_DAY +\n+                5 * DateTimeConstants.MILLIS_PER_HOUR +\n+                6 * DateTimeConstants.MILLIS_PER_MINUTE +\n+                7 * DateTimeConstants.MILLIS_PER_SECOND + 8;\n+        MutablePeriod test = new MutablePeriod(length, PeriodType.standard(), Chronology.getISOUTC());\n+        assertEquals(PeriodType.standard(), test.getPeriodType());\n+        assertEquals(0, test.getYears());\n+        assertEquals(0, test.getMonths());\n+        assertEquals(0, test.getWeeks());\n+        assertEquals(4, test.getDays());\n+        assertEquals(5, test.getHours());\n+        assertEquals(6, test.getMinutes());\n+        assertEquals(7, test.getSeconds());\n+        assertEquals(8, test.getMillis());\n+    }\n+\n+    public void testConstructor_long_PeriodType_Chronology3() throws Throwable {\n+        long length = 4 * DateTimeConstants.MILLIS_PER_DAY +\n+                5 * DateTimeConstants.MILLIS_PER_HOUR +\n+                6 * DateTimeConstants.MILLIS_PER_MINUTE +\n+                7 * DateTimeConstants.MILLIS_PER_SECOND + 8;\n+        MutablePeriod test = new MutablePeriod(length, PeriodType.standard(), (Chronology) null);\n+        assertEquals(PeriodType.standard(), test.getPeriodType());\n+        assertEquals(0, test.getYears());\n+        assertEquals(0, test.getMonths());\n+        assertEquals(0, test.getWeeks());\n+        assertEquals(0, test.getDays());\n+        assertEquals((4 * 24) + 5, test.getHours());\n+        assertEquals(6, test.getMinutes());\n+        assertEquals(7, test.getSeconds());\n+        assertEquals(8, test.getMillis());\n+    }\n+\n+    public void testConstructor_long_PeriodType_Chronology4() throws Throwable {\n+        long length = 4 * DateTimeConstants.MILLIS_PER_DAY +\n+                5 * DateTimeConstants.MILLIS_PER_HOUR +\n+                6 * DateTimeConstants.MILLIS_PER_MINUTE +\n+                7 * DateTimeConstants.MILLIS_PER_SECOND + 8;\n+        MutablePeriod test = new MutablePeriod(length, (PeriodType) null, (Chronology) null);\n+        assertEquals(PeriodType.standard(), test.getPeriodType());\n+        assertEquals(0, test.getYears());\n+        assertEquals(0, test.getMonths());\n+        assertEquals(0, test.getWeeks());\n+        assertEquals(0, test.getDays());\n+        assertEquals((4 * 24) + 5, test.getHours());\n+        assertEquals(6, test.getMinutes());\n+        assertEquals(7, test.getSeconds());\n+        assertEquals(8, test.getMillis());\n     }\n \n     //-----------------------------------------------------------------------\n      */\n     public void testConstructor_4int1() throws Throwable {\n         MutablePeriod test = new MutablePeriod(5, 6, 7, 8);\n-        assertEquals(PeriodType.getAllType(), test.getPeriodType());\n+        assertEquals(PeriodType.time(), test.getPeriodType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n         assertEquals(0, test.getWeeks());\n         assertEquals(6, test.getMinutes());\n         assertEquals(7, test.getSeconds());\n         assertEquals(8, test.getMillis());\n-        assertEquals(true, test.isPrecise());\n-        assertEquals(\n-            5 * DateTimeConstants.MILLIS_PER_HOUR + 6 * DateTimeConstants.MILLIS_PER_MINUTE +\n-            7 * DateTimeConstants.MILLIS_PER_SECOND + 8, test.toDurationMillis());\n     }\n \n     //-----------------------------------------------------------------------\n      */\n     public void testConstructor_8int1() throws Throwable {\n         MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n-        assertEquals(PeriodType.getAllType(), test.getPeriodType());\n+        assertEquals(PeriodType.standard(), test.getPeriodType());\n         assertEquals(1, test.getYears());\n         assertEquals(2, test.getMonths());\n         assertEquals(3, test.getWeeks());\n         assertEquals(6, test.getMinutes());\n         assertEquals(7, test.getSeconds());\n         assertEquals(8, test.getMillis());\n-        assertEquals(false, test.isPrecise());\n-        try {\n-            test.toDurationMillis();\n-            fail();\n-        } catch (IllegalStateException ex) {}\n     }\n \n     //-----------------------------------------------------------------------\n      */\n     public void testConstructor_8int__PeriodType1() throws Throwable {\n         MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8, null);\n-        assertEquals(PeriodType.getAllType(), test.getPeriodType());\n+        assertEquals(PeriodType.standard(), test.getPeriodType());\n         assertEquals(1, test.getYears());\n         assertEquals(2, test.getMonths());\n         assertEquals(3, test.getWeeks());\n         assertEquals(6, test.getMinutes());\n         assertEquals(7, test.getSeconds());\n         assertEquals(8, test.getMillis());\n-        assertEquals(false, test.isPrecise());\n-        try {\n-            test.toDurationMillis();\n-            fail();\n-        } catch (IllegalStateException ex) {}\n     }\n \n     public void testConstructor_8int__PeriodType2() throws Throwable {\n-        MutablePeriod test = new MutablePeriod(0, 0, 0, 0, 5, 6, 7, 8, PeriodType.getDayHourType());\n-        assertEquals(PeriodType.getDayHourType(), test.getPeriodType());\n+        MutablePeriod test = new MutablePeriod(0, 0, 0, 0, 5, 6, 7, 8, PeriodType.dayTime());\n+        assertEquals(PeriodType.dayTime(), test.getPeriodType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n         assertEquals(0, test.getWeeks());\n         assertEquals(6, test.getMinutes());\n         assertEquals(7, test.getSeconds());\n         assertEquals(8, test.getMillis());\n-        assertEquals(true, test.isPrecise());\n-        assertEquals(\n-            5 * DateTimeConstants.MILLIS_PER_HOUR + 6 * DateTimeConstants.MILLIS_PER_MINUTE +\n-            7 * DateTimeConstants.MILLIS_PER_SECOND + 8, test.toDurationMillis());\n     }\n \n     public void testConstructor_8int__PeriodType3() throws Throwable {\n         try {\n-            new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.getDayHourType());\n+            new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.dayTime());\n             fail();\n         } catch (IllegalArgumentException ex) {}\n     }\n         DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n         DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);\n         MutablePeriod test = new MutablePeriod(dt1.getMillis(), dt2.getMillis());\n-        assertEquals(PeriodType.getAllType(), test.getPeriodType());\n+        assertEquals(PeriodType.standard(), test.getPeriodType());\n         assertEquals(1, test.getYears());\n         assertEquals(1, test.getMonths());\n         assertEquals(0, test.getWeeks());\n         assertEquals(1, test.getMinutes());\n         assertEquals(1, test.getSeconds());\n         assertEquals(1, test.getMillis());\n-        assertEquals(false, test.isPrecise());\n-        try {\n-            test.toDurationMillis();\n-            fail();\n-        } catch (IllegalStateException ex) {}\n     }\n \n     public void testConstructor_long_long2() throws Throwable {\n         DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n         DateTime dt2 = new DateTime(2005, 7, 17, 1, 1, 1, 1);\n         MutablePeriod test = new MutablePeriod(dt1.getMillis(), dt2.getMillis());\n-        assertEquals(PeriodType.getAllType(), test.getPeriodType());\n+        assertEquals(PeriodType.standard(), test.getPeriodType());\n         assertEquals(1, test.getYears());\n         assertEquals(1, test.getMonths());\n         assertEquals(1, test.getWeeks());\n         assertEquals(1, test.getMinutes());\n         assertEquals(1, test.getSeconds());\n         assertEquals(1, test.getMillis());\n-        assertEquals(false, test.isPrecise());\n-        try {\n-            test.toDurationMillis();\n-            fail();\n-        } catch (IllegalStateException ex) {}\n     }\n \n     //-----------------------------------------------------------------------\n     public void testConstructor_long_long_PeriodType1() throws Throwable {\n         DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n         DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);\n-        MutablePeriod test = new MutablePeriod(dt1.getMillis(), dt2.getMillis(), null);\n-        assertEquals(PeriodType.getAllType(), test.getPeriodType());\n+        MutablePeriod test = new MutablePeriod(dt1.getMillis(), dt2.getMillis(), (PeriodType) null);\n+        assertEquals(PeriodType.standard(), test.getPeriodType());\n         assertEquals(1, test.getYears());\n         assertEquals(1, test.getMonths());\n         assertEquals(0, test.getWeeks());\n         assertEquals(1, test.getMinutes());\n         assertEquals(1, test.getSeconds());\n         assertEquals(1, test.getMillis());\n-        assertEquals(false, test.isPrecise());\n-        try {\n-            test.toDurationMillis();\n-            fail();\n-        } catch (IllegalStateException ex) {}\n     }\n \n     public void testConstructor_long_long_PeriodType2() throws Throwable {\n         DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n         DateTime dt2 = new DateTime(2004, 7, 10, 1, 1, 1, 1);\n-        MutablePeriod test = new MutablePeriod(dt1.getMillis(), dt2.getMillis(), PeriodType.getDayHourType());\n-        assertEquals(PeriodType.getDayHourType(), test.getPeriodType());\n+        MutablePeriod test = new MutablePeriod(dt1.getMillis(), dt2.getMillis(), PeriodType.dayTime());\n+        assertEquals(PeriodType.dayTime(), test.getPeriodType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n         assertEquals(0, test.getWeeks());\n         assertEquals(1, test.getMinutes());\n         assertEquals(1, test.getSeconds());\n         assertEquals(1, test.getMillis());\n-        assertEquals(false, test.isPrecise());\n-        try {\n-            test.toDurationMillis();\n-            fail();\n-        } catch (IllegalStateException ex) {}\n     }\n \n     public void testConstructor_long_long_PeriodType3() throws Throwable {\n         DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n         DateTime dt2 = new DateTime(2004, 6, 9, 1, 1, 1, 1);\n-        MutablePeriod test = new MutablePeriod(dt1.getMillis(), dt2.getMillis(), PeriodType.getAllType().withMillisRemoved());\n-        assertEquals(PeriodType.getAllType().withMillisRemoved(), test.getPeriodType());\n-        assertEquals(0, test.getYears());\n-        assertEquals(0, test.getMonths());\n-        assertEquals(0, test.getWeeks());\n-        assertEquals(0, test.getDays());\n-        assertEquals(1, test.getHours());\n-        assertEquals(1, test.getMinutes());\n-        assertEquals(1, test.getSeconds());\n-        assertEquals(0, test.getMillis());\n-        assertEquals(true, test.isPrecise());\n-        assertEquals(dt2.getMillis() - dt1.getMillis() - 1, test.toDurationMillis());\n+        MutablePeriod test = new MutablePeriod(dt1.getMillis(), dt2.getMillis(), PeriodType.standard().withMillisRemoved());\n+        assertEquals(PeriodType.standard().withMillisRemoved(), test.getPeriodType());\n+        assertEquals(0, test.getYears());\n+        assertEquals(0, test.getMonths());\n+        assertEquals(0, test.getWeeks());\n+        assertEquals(0, test.getDays());\n+        assertEquals(1, test.getHours());\n+        assertEquals(1, test.getMinutes());\n+        assertEquals(1, test.getSeconds());\n+        assertEquals(0, test.getMillis());\n     }\n \n     //-----------------------------------------------------------------------\n         DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n         DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);\n         MutablePeriod test = new MutablePeriod(dt1, dt2);\n-        assertEquals(PeriodType.getAllType(), test.getPeriodType());\n+        assertEquals(PeriodType.standard(), test.getPeriodType());\n         assertEquals(1, test.getYears());\n         assertEquals(1, test.getMonths());\n         assertEquals(0, test.getWeeks());\n         assertEquals(1, test.getMinutes());\n         assertEquals(1, test.getSeconds());\n         assertEquals(1, test.getMillis());\n-        assertEquals(false, test.isPrecise());\n-        try {\n-            test.toDurationMillis();\n-            fail();\n-        } catch (IllegalStateException ex) {}\n     }\n \n     public void testConstructor_RI_RI2() throws Throwable {\n         DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n         DateTime dt2 = new DateTime(2005, 7, 17, 1, 1, 1, 1);\n         MutablePeriod test = new MutablePeriod(dt1, dt2);\n-        assertEquals(PeriodType.getAllType(), test.getPeriodType());\n+        assertEquals(PeriodType.standard(), test.getPeriodType());\n         assertEquals(1, test.getYears());\n         assertEquals(1, test.getMonths());\n         assertEquals(1, test.getWeeks());\n         assertEquals(1, test.getMinutes());\n         assertEquals(1, test.getSeconds());\n         assertEquals(1, test.getMillis());\n-        assertEquals(false, test.isPrecise());\n-        try {\n-            test.toDurationMillis();\n-            fail();\n-        } catch (IllegalStateException ex) {}\n     }\n \n     public void testConstructor_RI_RI3() throws Throwable {\n         DateTime dt1 = null;  // 2002-06-09T01:00+01:00\n         DateTime dt2 = new DateTime(2005, 7, 17, 1, 1, 1, 1);\n         MutablePeriod test = new MutablePeriod(dt1, dt2);\n-        assertEquals(PeriodType.getAllType(), test.getPeriodType());\n+        assertEquals(PeriodType.standard(), test.getPeriodType());\n         assertEquals(3, test.getYears());\n         assertEquals(1, test.getMonths());\n         assertEquals(1, test.getWeeks());\n         assertEquals(1, test.getMinutes());\n         assertEquals(1, test.getSeconds());\n         assertEquals(1, test.getMillis());\n-        assertEquals(false, test.isPrecise());\n-        try {\n-            test.toDurationMillis();\n-            fail();\n-        } catch (IllegalStateException ex) {}\n     }\n \n     public void testConstructor_RI_RI4() throws Throwable {\n         DateTime dt1 = new DateTime(2005, 7, 17, 1, 1, 1, 1);\n         DateTime dt2 = null;  // 2002-06-09T01:00+01:00\n         MutablePeriod test = new MutablePeriod(dt1, dt2);\n-        assertEquals(PeriodType.getAllType(), test.getPeriodType());\n+        assertEquals(PeriodType.standard(), test.getPeriodType());\n         assertEquals(-3, test.getYears());\n         assertEquals(-1, test.getMonths());\n         assertEquals(-1, test.getWeeks());\n         assertEquals(-1, test.getMinutes());\n         assertEquals(-1, test.getSeconds());\n         assertEquals(-1, test.getMillis());\n-        assertEquals(false, test.isPrecise());\n-        try {\n-            test.toDurationMillis();\n-            fail();\n-        } catch (IllegalStateException ex) {}\n     }\n \n     public void testConstructor_RI_RI5() throws Throwable {\n         DateTime dt1 = null;  // 2002-06-09T01:00+01:00\n         DateTime dt2 = null;  // 2002-06-09T01:00+01:00\n         MutablePeriod test = new MutablePeriod(dt1, dt2);\n-        assertEquals(PeriodType.getAllType(), test.getPeriodType());\n-        assertEquals(0, test.getYears());\n-        assertEquals(0, test.getMonths());\n-        assertEquals(0, test.getWeeks());\n-        assertEquals(0, test.getDays());\n-        assertEquals(0, test.getHours());\n-        assertEquals(0, test.getMinutes());\n-        assertEquals(0, test.getSeconds());\n-        assertEquals(0, test.getMillis());\n-        assertEquals(true, test.isPrecise());\n-        assertEquals(0L, test.toDurationMillis());\n+        assertEquals(PeriodType.standard(), test.getPeriodType());\n+        assertEquals(0, test.getYears());\n+        assertEquals(0, test.getMonths());\n+        assertEquals(0, test.getWeeks());\n+        assertEquals(0, test.getDays());\n+        assertEquals(0, test.getHours());\n+        assertEquals(0, test.getMinutes());\n+        assertEquals(0, test.getSeconds());\n+        assertEquals(0, test.getMillis());\n     }\n \n     //-----------------------------------------------------------------------\n         DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n         DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);\n         MutablePeriod test = new MutablePeriod(dt1, dt2, null);\n-        assertEquals(PeriodType.getAllType(), test.getPeriodType());\n+        assertEquals(PeriodType.standard(), test.getPeriodType());\n         assertEquals(1, test.getYears());\n         assertEquals(1, test.getMonths());\n         assertEquals(0, test.getWeeks());\n         assertEquals(1, test.getMinutes());\n         assertEquals(1, test.getSeconds());\n         assertEquals(1, test.getMillis());\n-        assertEquals(false, test.isPrecise());\n-        try {\n-            test.toDurationMillis();\n-            fail();\n-        } catch (IllegalStateException ex) {}\n     }\n \n     public void testConstructor_RI_RI_PeriodType2() throws Throwable {\n         DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n         DateTime dt2 = new DateTime(2004, 7, 10, 1, 1, 1, 1);\n-        MutablePeriod test = new MutablePeriod(dt1, dt2, PeriodType.getDayHourType());\n-        assertEquals(PeriodType.getDayHourType(), test.getPeriodType());\n+        MutablePeriod test = new MutablePeriod(dt1, dt2, PeriodType.dayTime());\n+        assertEquals(PeriodType.dayTime(), test.getPeriodType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n         assertEquals(0, test.getWeeks());\n         assertEquals(1, test.getMinutes());\n         assertEquals(1, test.getSeconds());\n         assertEquals(1, test.getMillis());\n-        assertEquals(false, test.isPrecise());\n-        try {\n-            test.toDurationMillis();\n-            fail();\n-        } catch (IllegalStateException ex) {}\n     }\n \n     public void testConstructor_RI_RI_PeriodType3() throws Throwable {\n         DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n         DateTime dt2 = new DateTime(2004, 6, 9, 1, 1, 1, 1);\n-        MutablePeriod test = new MutablePeriod(dt1, dt2, PeriodType.getAllType().withMillisRemoved());\n-        assertEquals(PeriodType.getAllType().withMillisRemoved(), test.getPeriodType());\n-        assertEquals(0, test.getYears());\n-        assertEquals(0, test.getMonths());\n-        assertEquals(0, test.getWeeks());\n-        assertEquals(0, test.getDays());\n-        assertEquals(1, test.getHours());\n-        assertEquals(1, test.getMinutes());\n-        assertEquals(1, test.getSeconds());\n-        assertEquals(0, test.getMillis());\n-        assertEquals(true, test.isPrecise());\n-        assertEquals(dt2.getMillis() - dt1.getMillis() - 1, test.toDurationMillis());\n+        MutablePeriod test = new MutablePeriod(dt1, dt2, PeriodType.standard().withMillisRemoved());\n+        assertEquals(PeriodType.standard().withMillisRemoved(), test.getPeriodType());\n+        assertEquals(0, test.getYears());\n+        assertEquals(0, test.getMonths());\n+        assertEquals(0, test.getWeeks());\n+        assertEquals(0, test.getDays());\n+        assertEquals(1, test.getHours());\n+        assertEquals(1, test.getMinutes());\n+        assertEquals(1, test.getSeconds());\n+        assertEquals(0, test.getMillis());\n     }\n \n     public void testConstructor_RI_RI_PeriodType4() throws Throwable {\n         DateTime dt1 = null;  // 2002-06-09T01:00+01:00\n         DateTime dt2 = new DateTime(2005, 7, 17, 1, 1, 1, 1);\n-        MutablePeriod test = new MutablePeriod(dt1, dt2, PeriodType.getAllType());\n-        assertEquals(PeriodType.getAllType(), test.getPeriodType());\n+        MutablePeriod test = new MutablePeriod(dt1, dt2, PeriodType.standard());\n+        assertEquals(PeriodType.standard(), test.getPeriodType());\n         assertEquals(3, test.getYears());\n         assertEquals(1, test.getMonths());\n         assertEquals(1, test.getWeeks());\n         assertEquals(1, test.getMinutes());\n         assertEquals(1, test.getSeconds());\n         assertEquals(1, test.getMillis());\n-        assertEquals(false, test.isPrecise());\n-        try {\n-            test.toDurationMillis();\n-            fail();\n-        } catch (IllegalStateException ex) {}\n     }\n \n     public void testConstructor_RI_RI_PeriodType5() throws Throwable {\n         DateTime dt1 = null;  // 2002-06-09T01:00+01:00\n         DateTime dt2 = null;  // 2002-06-09T01:00+01:00\n-        MutablePeriod test = new MutablePeriod(dt1, dt2, PeriodType.getAllType());\n-        assertEquals(PeriodType.getAllType(), test.getPeriodType());\n-        assertEquals(0, test.getYears());\n-        assertEquals(0, test.getMonths());\n-        assertEquals(0, test.getWeeks());\n-        assertEquals(0, test.getDays());\n-        assertEquals(0, test.getHours());\n-        assertEquals(0, test.getMinutes());\n-        assertEquals(0, test.getSeconds());\n-        assertEquals(0, test.getMillis());\n-        assertEquals(true, test.isPrecise());\n-        assertEquals(0L, test.toDurationMillis());\n+        MutablePeriod test = new MutablePeriod(dt1, dt2, PeriodType.standard());\n+        assertEquals(PeriodType.standard(), test.getPeriodType());\n+        assertEquals(0, test.getYears());\n+        assertEquals(0, test.getMonths());\n+        assertEquals(0, test.getWeeks());\n+        assertEquals(0, test.getDays());\n+        assertEquals(0, test.getHours());\n+        assertEquals(0, test.getMinutes());\n+        assertEquals(0, test.getSeconds());\n+        assertEquals(0, test.getMillis());\n     }\n \n     //-----------------------------------------------------------------------\n      */\n     public void testConstructor_Object1() throws Throwable {\n         MutablePeriod test = new MutablePeriod(\"P1Y2M3D\");\n-        assertEquals(PeriodType.getAllType(), test.getPeriodType());\n+        assertEquals(PeriodType.standard(), test.getPeriodType());\n         assertEquals(1, test.getYears());\n         assertEquals(2, test.getMonths());\n         assertEquals(0, test.getWeeks());\n         assertEquals(0, test.getMinutes());\n         assertEquals(0, test.getSeconds());\n         assertEquals(0, test.getMillis());\n-        assertEquals(false, test.isPrecise());\n-        try {\n-            test.toDurationMillis();\n-            fail();\n-        } catch (IllegalStateException ex) {}\n     }\n \n     public void testConstructor_Object2() throws Throwable {\n         MutablePeriod test = new MutablePeriod((Object) null);\n-        assertEquals(PeriodType.getAllType(), test.getPeriodType());\n-        assertEquals(0, test.getYears());\n-        assertEquals(0, test.getMonths());\n-        assertEquals(0, test.getWeeks());\n-        assertEquals(0, test.getDays());\n-        assertEquals(0, test.getHours());\n-        assertEquals(0, test.getMinutes());\n-        assertEquals(0, test.getSeconds());\n-        assertEquals(0, test.getMillis());\n-        assertEquals(true, test.isPrecise());\n-        assertEquals(0, test.toDurationMillis());\n+        assertEquals(PeriodType.standard(), test.getPeriodType());\n+        assertEquals(0, test.getYears());\n+        assertEquals(0, test.getMonths());\n+        assertEquals(0, test.getWeeks());\n+        assertEquals(0, test.getDays());\n+        assertEquals(0, test.getHours());\n+        assertEquals(0, test.getMinutes());\n+        assertEquals(0, test.getSeconds());\n+        assertEquals(0, test.getMillis());\n     }\n \n     public void testConstructor_Object3() throws Throwable {\n-        MutablePeriod test = new MutablePeriod(new Period(0, 0, 0, 0, 1, 2, 3, 4, PeriodType.getDayHourType()));\n-        assertEquals(PeriodType.getDayHourType(), test.getPeriodType());\n+        MutablePeriod test = new MutablePeriod(new Period(0, 0, 0, 0, 1, 2, 3, 4, PeriodType.dayTime()));\n+        assertEquals(PeriodType.dayTime(), test.getPeriodType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n         assertEquals(0, test.getWeeks());\n         assertEquals(2, test.getMinutes());\n         assertEquals(3, test.getSeconds());\n         assertEquals(4, test.getMillis());\n-        assertEquals(true, test.isPrecise());\n-        assertEquals(DateTimeConstants.MILLIS_PER_HOUR + 2 * DateTimeConstants.MILLIS_PER_MINUTE +\n-            3 * DateTimeConstants.MILLIS_PER_SECOND + 4, test.toDurationMillis());\n     }\n \n     public void testConstructor_Object4() throws Throwable {\n-        Period base = new Period(1, 1, 0, 1, 1, 1, 1, 1, PeriodType.getAllType());\n+        Period base = new Period(1, 1, 0, 1, 1, 1, 1, 1, PeriodType.standard());\n         MutablePeriod test = new MutablePeriod(base);\n-        assertEquals(PeriodType.getAllType(), test.getPeriodType());\n+        assertEquals(PeriodType.standard(), test.getPeriodType());\n         assertEquals(1, test.getYears());\n         assertEquals(1, test.getMonths());\n         assertEquals(0, test.getWeeks());\n         assertEquals(1, test.getMinutes());\n         assertEquals(1, test.getSeconds());\n         assertEquals(1, test.getMillis());\n-        assertEquals(false, test.isPrecise());\n-        try {\n-            test.toDurationMillis();\n-            fail();\n-        } catch (IllegalStateException ex) {}\n     }\n \n     //-----------------------------------------------------------------------\n      * Test constructor (Object,PeriodType)\n      */\n     public void testConstructor_Object_PeriodType1() throws Throwable {\n-        MutablePeriod test = new MutablePeriod(\"P1Y2M3D\", PeriodType.getYearMonthType());\n-        assertEquals(PeriodType.getYearMonthType(), test.getPeriodType());\n+        MutablePeriod test = new MutablePeriod(\"P1Y2M3D\", PeriodType.yearMonthDayTime());\n+        assertEquals(PeriodType.yearMonthDayTime(), test.getPeriodType());\n         assertEquals(1, test.getYears());\n         assertEquals(2, test.getMonths());\n         assertEquals(0, test.getWeeks());\n         assertEquals(0, test.getMinutes());\n         assertEquals(0, test.getSeconds());\n         assertEquals(0, test.getMillis());\n-        assertEquals(false, test.isPrecise());\n-        try {\n-            test.toDurationMillis();\n-            fail();\n-        } catch (IllegalStateException ex) {}\n     }\n \n     public void testConstructor_Object_PeriodType2() throws Throwable {\n-        MutablePeriod test = new MutablePeriod((Object) null, PeriodType.getYearMonthType());\n-        assertEquals(PeriodType.getYearMonthType(), test.getPeriodType());\n-        assertEquals(0, test.getYears());\n-        assertEquals(0, test.getMonths());\n-        assertEquals(0, test.getWeeks());\n-        assertEquals(0, test.getDays());\n-        assertEquals(0, test.getHours());\n-        assertEquals(0, test.getMinutes());\n-        assertEquals(0, test.getSeconds());\n-        assertEquals(0, test.getMillis());\n-        assertEquals(true, test.isPrecise());\n-        assertEquals(0, test.toDurationMillis());\n+        MutablePeriod test = new MutablePeriod((Object) null, PeriodType.yearMonthDayTime());\n+        assertEquals(PeriodType.yearMonthDayTime(), test.getPeriodType());\n+        assertEquals(0, test.getYears());\n+        assertEquals(0, test.getMonths());\n+        assertEquals(0, test.getWeeks());\n+        assertEquals(0, test.getDays());\n+        assertEquals(0, test.getHours());\n+        assertEquals(0, test.getMinutes());\n+        assertEquals(0, test.getSeconds());\n+        assertEquals(0, test.getMillis());\n     }\n \n     public void testConstructor_Object_PeriodType3() throws Throwable {\n-        MutablePeriod test = new MutablePeriod(new Period(0, 0, 0, 0, 1, 2, 3, 4, PeriodType.getDayHourType()), PeriodType.getYearMonthType());\n-        assertEquals(PeriodType.getYearMonthType(), test.getPeriodType());\n+        MutablePeriod test = new MutablePeriod(new Period(0, 0, 0, 0, 1, 2, 3, 4, PeriodType.dayTime()), PeriodType.yearMonthDayTime());\n+        assertEquals(PeriodType.yearMonthDayTime(), test.getPeriodType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n         assertEquals(0, test.getWeeks());\n         assertEquals(2, test.getMinutes());\n         assertEquals(3, test.getSeconds());\n         assertEquals(4, test.getMillis());\n-        assertEquals(true, test.isPrecise());\n-        assertEquals(DateTimeConstants.MILLIS_PER_HOUR + 2 * DateTimeConstants.MILLIS_PER_MINUTE +\n-            3 * DateTimeConstants.MILLIS_PER_SECOND + 4, test.toDurationMillis());\n     }\n \n     public void testConstructor_Object_PeriodType4() throws Throwable {\n-        MutablePeriod test = new MutablePeriod(new Period(0, 0, 0, 0, 1, 2, 3, 4, PeriodType.getDayHourType()), null);\n-        assertEquals(PeriodType.getDayHourType(), test.getPeriodType());\n+        MutablePeriod test = new MutablePeriod(new Period(0, 0, 0, 0, 1, 2, 3, 4, PeriodType.dayTime()), (PeriodType) null);\n+        assertEquals(PeriodType.dayTime(), test.getPeriodType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n         assertEquals(0, test.getWeeks());\n         assertEquals(2, test.getMinutes());\n         assertEquals(3, test.getSeconds());\n         assertEquals(4, test.getMillis());\n-        assertEquals(true, test.isPrecise());\n-        assertEquals(DateTimeConstants.MILLIS_PER_HOUR + 2 * DateTimeConstants.MILLIS_PER_MINUTE +\n-            3 * DateTimeConstants.MILLIS_PER_SECOND + 4, test.toDurationMillis());\n     }\n \n }\n--- a/JodaTime/src/test/org/joda/time/TestMutablePeriod_Updates.java\n+++ b/JodaTime/src/test/org/joda/time/TestMutablePeriod_Updates.java\n         test.setYears(1);\n         assertEquals(1, test.getYears());\n         \n-        test = new MutablePeriod(0, 0, 0, 0, 0, 0, 0, 1, PeriodType.getMillisType());\n+        test = new MutablePeriod(0, 0, 0, 0, 0, 0, 0, 1, PeriodType.millis());\n         try {\n             test.setYears(1);\n             fail();\n     }\n \n     public void testSetPeriod_8ints2() {\n-        MutablePeriod test = new MutablePeriod(100L, PeriodType.getMillisType());\n+        MutablePeriod test = new MutablePeriod(100L, PeriodType.millis());\n         try {\n             test.setPeriod(11, 12, 13, 14, 15, 16, 17, 18);\n             fail();\n         assertEquals(0, test.getMinutes());\n         assertEquals(0, test.getSeconds());\n         assertEquals(100, test.getMillis());\n-        assertEquals(100, test.toDurationMillis());\n     }\n \n     public void testSetPeriod_8ints3() {\n-        MutablePeriod test = new MutablePeriod(100L, PeriodType.getMillisType());\n+        MutablePeriod test = new MutablePeriod(100L, PeriodType.millis());\n         test.setPeriod(0, 0, 0, 0, 0, 0, 0, 18);\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n         assertEquals(0, test.getMinutes());\n         assertEquals(0, test.getSeconds());\n         assertEquals(18, test.getMillis());\n-        assertEquals(18, test.toDurationMillis());\n     }\n \n     public void testSetPeriod_8ints4() {\n         MutablePeriod test = new MutablePeriod(0, 0, 0, 0, 5, 6, 7, 8);\n-        assertEquals(true, test.isPrecise());\n         test.setPeriod(11, 12, 13, 14, 15, 16, 17, 18);\n-        assertEquals(false, test.isPrecise());\n         assertEquals(11, test.getYears());\n         assertEquals(12, test.getMonths());\n         assertEquals(13, test.getWeeks());\n     }\n \n     public void testSetPeriod_RP2() {\n-        MutablePeriod test = new MutablePeriod(100L, PeriodType.getMillisType());\n+        MutablePeriod test = new MutablePeriod(100L, PeriodType.millis());\n         try {\n             test.setPeriod(new MutablePeriod(11, 12, 13, 14, 15, 16, 17, 18));\n             fail();\n         assertEquals(0, test.getMinutes());\n         assertEquals(0, test.getSeconds());\n         assertEquals(100, test.getMillis());\n-        assertEquals(100, test.toDurationMillis());\n     }\n \n     public void testSetPeriod_RP3() {\n-        MutablePeriod test = new MutablePeriod(100L, PeriodType.getMillisType());\n+        MutablePeriod test = new MutablePeriod(100L, PeriodType.millis());\n         test.setPeriod(new MutablePeriod(0, 0, 0, 0, 0, 0, 0, 18));\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n         assertEquals(0, test.getMinutes());\n         assertEquals(0, test.getSeconds());\n         assertEquals(18, test.getMillis());\n-        assertEquals(18, test.toDurationMillis());\n     }\n \n     public void testSetPeriod_RP4() {\n         MutablePeriod test = new MutablePeriod(0, 0, 0, 0, 5, 6, 7, 8);\n-        assertEquals(true, test.isPrecise());\n         test.setPeriod(new MutablePeriod(11, 12, 13, 14, 15, 16, 17, 18));\n-        assertEquals(false, test.isPrecise());\n         assertEquals(11, test.getYears());\n         assertEquals(12, test.getMonths());\n         assertEquals(13, test.getWeeks());\n     }\n \n     public void testSetPeriod_long_long_NoYears() {\n-        MutablePeriod test = new MutablePeriod(PeriodType.getAllType().withYearsRemoved());\n+        MutablePeriod test = new MutablePeriod(PeriodType.standard().withYearsRemoved());\n         DateTime dt1 = new DateTime(2002, 6, 9, 13, 15, 17, 19);\n         DateTime dt2 = new DateTime(2003, 7, 17, 14, 16, 18, 20);\n         test.setPeriod(dt1.getMillis(), dt2.getMillis());\n     }\n \n     public void testSetPeriod_long_long_NoMonths() {\n-        MutablePeriod test = new MutablePeriod(PeriodType.getAllType().withMonthsRemoved());\n+        MutablePeriod test = new MutablePeriod(PeriodType.standard().withMonthsRemoved());\n         DateTime dt1 = new DateTime(2002, 6, 9, 13, 15, 17, 19);\n         DateTime dt2 = new DateTime(2003, 7, 17, 14, 16, 18, 20);\n         test.setPeriod(dt1.getMillis(), dt2.getMillis());\n     }\n \n     public void testSetPeriod_long_long_NoWeeks() {\n-        MutablePeriod test = new MutablePeriod(PeriodType.getAllType().withWeeksRemoved());\n+        MutablePeriod test = new MutablePeriod(PeriodType.standard().withWeeksRemoved());\n         DateTime dt1 = new DateTime(2002, 6, 9, 13, 15, 17, 19);\n         DateTime dt2 = new DateTime(2003, 7, 17, 14, 16, 18, 20);\n         test.setPeriod(dt1.getMillis(), dt2.getMillis());\n     }\n \n     public void testSetPeriod_long_long_NoDays() {\n-        MutablePeriod test = new MutablePeriod(PeriodType.getAllType().withDaysRemoved());\n+        MutablePeriod test = new MutablePeriod(PeriodType.standard().withDaysRemoved());\n         DateTime dt1 = new DateTime(2002, 6, 9, 13, 15, 17, 19);\n         DateTime dt2 = new DateTime(2003, 7, 17, 14, 16, 18, 20);\n         test.setPeriod(dt1.getMillis(), dt2.getMillis());\n     }\n \n     public void testSetPeriod_long_long_NoHours() {\n-        MutablePeriod test = new MutablePeriod(PeriodType.getAllType().withHoursRemoved());\n+        MutablePeriod test = new MutablePeriod(PeriodType.standard().withHoursRemoved());\n         DateTime dt1 = new DateTime(2002, 6, 9, 13, 15, 17, 19);\n         DateTime dt2 = new DateTime(2003, 7, 17, 14, 16, 18, 20);\n         test.setPeriod(dt1.getMillis(), dt2.getMillis());\n     }\n \n     public void testSetPeriod_long_long_NoMinutes() {\n-        MutablePeriod test = new MutablePeriod(PeriodType.getAllType().withMinutesRemoved());\n+        MutablePeriod test = new MutablePeriod(PeriodType.standard().withMinutesRemoved());\n         DateTime dt1 = new DateTime(2002, 6, 9, 13, 15, 17, 19);\n         DateTime dt2 = new DateTime(2003, 7, 17, 14, 16, 18, 20);\n         test.setPeriod(dt1.getMillis(), dt2.getMillis());\n     }\n \n     public void testSetPeriod_long_long_NoSeconds() {\n-        MutablePeriod test = new MutablePeriod(PeriodType.getAllType().withSecondsRemoved());\n+        MutablePeriod test = new MutablePeriod(PeriodType.standard().withSecondsRemoved());\n         DateTime dt1 = new DateTime(2002, 6, 9, 13, 15, 17, 19);\n         DateTime dt2 = new DateTime(2003, 7, 17, 14, 16, 18, 20);\n         test.setPeriod(dt1.getMillis(), dt2.getMillis());\n     }\n \n     public void testSetPeriod_long_long_NoMillis() {\n-        MutablePeriod test = new MutablePeriod(PeriodType.getAllType().withMillisRemoved());\n+        MutablePeriod test = new MutablePeriod(PeriodType.standard().withMillisRemoved());\n         DateTime dt1 = new DateTime(2002, 6, 9, 13, 15, 17, 19);\n         DateTime dt2 = new DateTime(2003, 7, 17, 14, 16, 18, 20);\n         test.setPeriod(dt1.getMillis(), dt2.getMillis());\n         assertEquals(8, test.getMillis());\n     }\n \n-    public void testSetPeriod_long3() {\n-        MutablePeriod test = new MutablePeriod(PeriodType.getPreciseYearMonthType());\n-        test.setPeriod(\n-            (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY +\n-            5L * DateTimeConstants.MILLIS_PER_HOUR +\n-            6L * DateTimeConstants.MILLIS_PER_MINUTE +\n-            7L * DateTimeConstants.MILLIS_PER_SECOND + 8L);\n-        assertEquals(1, test.getYears());\n-        assertEquals(2, test.getMonths());\n-        assertEquals(0, test.getWeeks());\n-        assertEquals(25, test.getDays());\n-        assertEquals(5, test.getHours());\n-        assertEquals(6, test.getMinutes());\n-        assertEquals(7, test.getSeconds());\n-        assertEquals(8, test.getMillis());\n-    }\n-\n-    public void testSetPeriod_long4() {\n-        MutablePeriod test = new MutablePeriod(PeriodType.getPreciseYearWeekType());\n-        test.setPeriod(\n-            (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY +\n-            5L * DateTimeConstants.MILLIS_PER_HOUR +\n-            6L * DateTimeConstants.MILLIS_PER_MINUTE +\n-            7L * DateTimeConstants.MILLIS_PER_SECOND + 8L);\n-        assertEquals(1, test.getYears());\n-        assertEquals(0, test.getMonths());\n-        assertEquals(12, test.getWeeks());\n-        assertEquals(1, test.getDays());\n-        assertEquals(5, test.getHours());\n-        assertEquals(6, test.getMinutes());\n-        assertEquals(7, test.getSeconds());\n-        assertEquals(8, test.getMillis());\n-    }\n-\n-    public void testSetPeriod_long_NoYears() {\n-        long ms =\n-            (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY +\n-            5L * DateTimeConstants.MILLIS_PER_HOUR +\n-            6L * DateTimeConstants.MILLIS_PER_MINUTE +\n-            7L * DateTimeConstants.MILLIS_PER_SECOND + 8L;\n-        MutablePeriod test = new MutablePeriod(PeriodType.getPreciseYearMonthType().withYearsRemoved());\n-        test.setPeriod(ms);\n-        assertEquals(0, test.getYears());\n-        assertEquals(15, test.getMonths()); // totalDays=365+85=450=15*30\n-        assertEquals(0, test.getWeeks());\n-        assertEquals(0, test.getDays());\n-        assertEquals(5, test.getHours());\n-        assertEquals(6, test.getMinutes());\n-        assertEquals(7, test.getSeconds());\n-        assertEquals(8, test.getMillis());\n-        assertEquals(ms, test.toDurationMillis());\n-    }\n-\n-    public void testSetPeriod_long_NoMonths() {\n-        long ms =\n-            (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY +\n-            5L * DateTimeConstants.MILLIS_PER_HOUR +\n-            6L * DateTimeConstants.MILLIS_PER_MINUTE +\n-            7L * DateTimeConstants.MILLIS_PER_SECOND + 8L;\n-        MutablePeriod test = new MutablePeriod(PeriodType.getPreciseYearMonthType().withMonthsRemoved());\n-        test.setPeriod(ms);\n-        assertEquals(1, test.getYears());\n-        assertEquals(0, test.getMonths());\n-        assertEquals(0, test.getWeeks());\n-        assertEquals(85, test.getDays());\n-        assertEquals(5, test.getHours());\n-        assertEquals(6, test.getMinutes());\n-        assertEquals(7, test.getSeconds());\n-        assertEquals(8, test.getMillis());\n-        assertEquals(ms, test.toDurationMillis());\n-    }\n-\n-    public void testSetPeriod_long_NoWeeks() {\n-        long ms =\n-            (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY +\n-            5L * DateTimeConstants.MILLIS_PER_HOUR +\n-            6L * DateTimeConstants.MILLIS_PER_MINUTE +\n-            7L * DateTimeConstants.MILLIS_PER_SECOND + 8L;\n-        MutablePeriod test = new MutablePeriod(PeriodType.getPreciseYearWeekType().withWeeksRemoved());\n-        test.setPeriod(ms);\n-        assertEquals(1, test.getYears());\n-        assertEquals(0, test.getMonths());\n-        assertEquals(0, test.getWeeks());\n-        assertEquals(85, test.getDays());\n-        assertEquals(5, test.getHours());\n-        assertEquals(6, test.getMinutes());\n-        assertEquals(7, test.getSeconds());\n-        assertEquals(8, test.getMillis());\n-        assertEquals(ms, test.toDurationMillis());\n-    }\n-\n-    public void testSetPeriod_long_NoDays() {\n-        long ms =\n-            (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY +\n-            5L * DateTimeConstants.MILLIS_PER_HOUR +\n-            6L * DateTimeConstants.MILLIS_PER_MINUTE +\n-            7L * DateTimeConstants.MILLIS_PER_SECOND + 8L;\n-        MutablePeriod test = new MutablePeriod(PeriodType.getPreciseYearMonthType().withDaysRemoved());\n-        test.setPeriod(ms);\n-        assertEquals(1, test.getYears());\n-        assertEquals(2, test.getMonths());\n-        assertEquals(0, test.getWeeks());\n-        assertEquals(0, test.getDays());\n-        assertEquals(5 + 25 * 24, test.getHours());\n-        assertEquals(6, test.getMinutes());\n-        assertEquals(7, test.getSeconds());\n-        assertEquals(8, test.getMillis());\n-        assertEquals(ms, test.toDurationMillis());\n-    }\n-\n-    public void testSetPeriod_long_NoHours() {\n-        long ms =\n-            (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY +\n-            5L * DateTimeConstants.MILLIS_PER_HOUR +\n-            6L * DateTimeConstants.MILLIS_PER_MINUTE +\n-            7L * DateTimeConstants.MILLIS_PER_SECOND + 8L;\n-        MutablePeriod test = new MutablePeriod(PeriodType.getPreciseYearMonthType().withHoursRemoved());\n-        test.setPeriod(ms);\n-        assertEquals(1, test.getYears());\n-        assertEquals(2, test.getMonths());\n-        assertEquals(0, test.getWeeks());\n-        assertEquals(25, test.getDays());\n-        assertEquals(0, test.getHours());\n-        assertEquals(6 + 5 * 60, test.getMinutes());\n-        assertEquals(7, test.getSeconds());\n-        assertEquals(8, test.getMillis());\n-        assertEquals(ms, test.toDurationMillis());\n-    }\n-\n-    public void testSetPeriod_long_NoMinutes() {\n-        long ms =\n-            (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY +\n-            5L * DateTimeConstants.MILLIS_PER_HOUR +\n-            6L * DateTimeConstants.MILLIS_PER_MINUTE +\n-            7L * DateTimeConstants.MILLIS_PER_SECOND + 8L;\n-        MutablePeriod test = new MutablePeriod(PeriodType.getPreciseYearMonthType().withMinutesRemoved());\n-        test.setPeriod(ms);\n-        assertEquals(1, test.getYears());\n-        assertEquals(2, test.getMonths());\n-        assertEquals(0, test.getWeeks());\n-        assertEquals(25, test.getDays());\n-        assertEquals(5, test.getHours());\n-        assertEquals(0, test.getMinutes());\n-        assertEquals(7 + 6 * 60, test.getSeconds());\n-        assertEquals(8, test.getMillis());\n-        assertEquals(ms, test.toDurationMillis());\n-    }\n-\n-    public void testSetPeriod_long_NoSeconds() {\n-        long ms =\n-            (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY +\n-            5L * DateTimeConstants.MILLIS_PER_HOUR +\n-            6L * DateTimeConstants.MILLIS_PER_MINUTE +\n-            7L * DateTimeConstants.MILLIS_PER_SECOND + 8L;\n-        MutablePeriod test = new MutablePeriod(PeriodType.getPreciseYearMonthType().withSecondsRemoved());\n-        test.setPeriod(ms);\n-        assertEquals(1, test.getYears());\n-        assertEquals(2, test.getMonths());\n-        assertEquals(0, test.getWeeks());\n-        assertEquals(25, test.getDays());\n-        assertEquals(5, test.getHours());\n-        assertEquals(6, test.getMinutes());\n-        assertEquals(0, test.getSeconds());\n-        assertEquals(8 + 7 * 1000, test.getMillis());\n-        assertEquals(ms, test.toDurationMillis());\n-    }\n-\n-    public void testSetPeriod_long_NoMillis() {\n-        long ms =\n-            (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY +\n-            5L * DateTimeConstants.MILLIS_PER_HOUR +\n-            6L * DateTimeConstants.MILLIS_PER_MINUTE +\n-            7L * DateTimeConstants.MILLIS_PER_SECOND + 8L;\n-        MutablePeriod test = new MutablePeriod(PeriodType.getPreciseYearMonthType().withMillisRemoved());\n-        test.setPeriod(ms);\n-        assertEquals(1, test.getYears());\n-        assertEquals(2, test.getMonths());\n-        assertEquals(0, test.getWeeks());\n-        assertEquals(25, test.getDays());\n-        assertEquals(5, test.getHours());\n-        assertEquals(6, test.getMinutes());\n-        assertEquals(7, test.getSeconds());\n-        assertEquals(0, test.getMillis());\n-        assertEquals(ms - 8, test.toDurationMillis());\n-    }\n+//    public void testSetPeriod_long3() {\n+//        MutablePeriod test = new MutablePeriod(PeriodType.getPreciseYearMonthType());\n+//        test.setPeriod(\n+//            (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY +\n+//            5L * DateTimeConstants.MILLIS_PER_HOUR +\n+//            6L * DateTimeConstants.MILLIS_PER_MINUTE +\n+//            7L * DateTimeConstants.MILLIS_PER_SECOND + 8L);\n+//        assertEquals(1, test.getYears());\n+//        assertEquals(2, test.getMonths());\n+//        assertEquals(0, test.getWeeks());\n+//        assertEquals(25, test.getDays());\n+//        assertEquals(5, test.getHours());\n+//        assertEquals(6, test.getMinutes());\n+//        assertEquals(7, test.getSeconds());\n+//        assertEquals(8, test.getMillis());\n+//    }\n+//\n+//    public void testSetPeriod_long4() {\n+//        MutablePeriod test = new MutablePeriod(PeriodType.getPreciseYearWeekType());\n+//        test.setPeriod(\n+//            (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY +\n+//            5L * DateTimeConstants.MILLIS_PER_HOUR +\n+//            6L * DateTimeConstants.MILLIS_PER_MINUTE +\n+//            7L * DateTimeConstants.MILLIS_PER_SECOND + 8L);\n+//        assertEquals(1, test.getYears());\n+//        assertEquals(0, test.getMonths());\n+//        assertEquals(12, test.getWeeks());\n+//        assertEquals(1, test.getDays());\n+//        assertEquals(5, test.getHours());\n+//        assertEquals(6, test.getMinutes());\n+//        assertEquals(7, test.getSeconds());\n+//        assertEquals(8, test.getMillis());\n+//    }\n+//\n+//    public void testSetPeriod_long_NoYears() {\n+//        long ms =\n+//            (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY +\n+//            5L * DateTimeConstants.MILLIS_PER_HOUR +\n+//            6L * DateTimeConstants.MILLIS_PER_MINUTE +\n+//            7L * DateTimeConstants.MILLIS_PER_SECOND + 8L;\n+//        MutablePeriod test = new MutablePeriod(PeriodType.getPreciseYearMonthType().withYearsRemoved());\n+//        test.setPeriod(ms);\n+//        assertEquals(0, test.getYears());\n+//        assertEquals(15, test.getMonths()); // totalDays=365+85=450=15*30\n+//        assertEquals(0, test.getWeeks());\n+//        assertEquals(0, test.getDays());\n+//        assertEquals(5, test.getHours());\n+//        assertEquals(6, test.getMinutes());\n+//        assertEquals(7, test.getSeconds());\n+//        assertEquals(8, test.getMillis());\n+//        assertEquals(ms, test.toDurationMillis());\n+//    }\n+//\n+//    public void testSetPeriod_long_NoMonths() {\n+//        long ms =\n+//            (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY +\n+//            5L * DateTimeConstants.MILLIS_PER_HOUR +\n+//            6L * DateTimeConstants.MILLIS_PER_MINUTE +\n+//            7L * DateTimeConstants.MILLIS_PER_SECOND + 8L;\n+//        MutablePeriod test = new MutablePeriod(PeriodType.getPreciseYearMonthType().withMonthsRemoved());\n+//        test.setPeriod(ms);\n+//        assertEquals(1, test.getYears());\n+//        assertEquals(0, test.getMonths());\n+//        assertEquals(0, test.getWeeks());\n+//        assertEquals(85, test.getDays());\n+//        assertEquals(5, test.getHours());\n+//        assertEquals(6, test.getMinutes());\n+//        assertEquals(7, test.getSeconds());\n+//        assertEquals(8, test.getMillis());\n+//        assertEquals(ms, test.toDurationMillis());\n+//    }\n+//\n+//    public void testSetPeriod_long_NoWeeks() {\n+//        long ms =\n+//            (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY +\n+//            5L * DateTimeConstants.MILLIS_PER_HOUR +\n+//            6L * DateTimeConstants.MILLIS_PER_MINUTE +\n+//            7L * DateTimeConstants.MILLIS_PER_SECOND + 8L;\n+//        MutablePeriod test = new MutablePeriod(PeriodType.getPreciseYearWeekType().withWeeksRemoved());\n+//        test.setPeriod(ms);\n+//        assertEquals(1, test.getYears());\n+//        assertEquals(0, test.getMonths());\n+//        assertEquals(0, test.getWeeks());\n+//        assertEquals(85, test.getDays());\n+//        assertEquals(5, test.getHours());\n+//        assertEquals(6, test.getMinutes());\n+//        assertEquals(7, test.getSeconds());\n+//        assertEquals(8, test.getMillis());\n+//        assertEquals(ms, test.toDurationMillis());\n+//    }\n+//\n+//    public void testSetPeriod_long_NoDays() {\n+//        long ms =\n+//            (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY +\n+//            5L * DateTimeConstants.MILLIS_PER_HOUR +\n+//            6L * DateTimeConstants.MILLIS_PER_MINUTE +\n+//            7L * DateTimeConstants.MILLIS_PER_SECOND + 8L;\n+//        MutablePeriod test = new MutablePeriod(PeriodType.getPreciseYearMonthType().withDaysRemoved());\n+//        test.setPeriod(ms);\n+//        assertEquals(1, test.getYears());\n+//        assertEquals(2, test.getMonths());\n+//        assertEquals(0, test.getWeeks());\n+//        assertEquals(0, test.getDays());\n+//        assertEquals(5 + 25 * 24, test.getHours());\n+//        assertEquals(6, test.getMinutes());\n+//        assertEquals(7, test.getSeconds());\n+//        assertEquals(8, test.getMillis());\n+//        assertEquals(ms, test.toDurationMillis());\n+//    }\n+//\n+//    public void testSetPeriod_long_NoHours() {\n+//        long ms =\n+//            (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY +\n+//            5L * DateTimeConstants.MILLIS_PER_HOUR +\n+//            6L * DateTimeConstants.MILLIS_PER_MINUTE +\n+//            7L * DateTimeConstants.MILLIS_PER_SECOND + 8L;\n+//        MutablePeriod test = new MutablePeriod(PeriodType.getPreciseYearMonthType().withHoursRemoved());\n+//        test.setPeriod(ms);\n+//        assertEquals(1, test.getYears());\n+//        assertEquals(2, test.getMonths());\n+//        assertEquals(0, test.getWeeks());\n+//        assertEquals(25, test.getDays());\n+//        assertEquals(0, test.getHours());\n+//        assertEquals(6 + 5 * 60, test.getMinutes());\n+//        assertEquals(7, test.getSeconds());\n+//        assertEquals(8, test.getMillis());\n+//        assertEquals(ms, test.toDurationMillis());\n+//    }\n+//\n+//    public void testSetPeriod_long_NoMinutes() {\n+//        long ms =\n+//            (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY +\n+//            5L * DateTimeConstants.MILLIS_PER_HOUR +\n+//            6L * DateTimeConstants.MILLIS_PER_MINUTE +\n+//            7L * DateTimeConstants.MILLIS_PER_SECOND + 8L;\n+//        MutablePeriod test = new MutablePeriod(PeriodType.getPreciseYearMonthType().withMinutesRemoved());\n+//        test.setPeriod(ms);\n+//        assertEquals(1, test.getYears());\n+//        assertEquals(2, test.getMonths());\n+//        assertEquals(0, test.getWeeks());\n+//        assertEquals(25, test.getDays());\n+//        assertEquals(5, test.getHours());\n+//        assertEquals(0, test.getMinutes());\n+//        assertEquals(7 + 6 * 60, test.getSeconds());\n+//        assertEquals(8, test.getMillis());\n+//        assertEquals(ms, test.toDurationMillis());\n+//    }\n+//\n+//    public void testSetPeriod_long_NoSeconds() {\n+//        long ms =\n+//            (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY +\n+//            5L * DateTimeConstants.MILLIS_PER_HOUR +\n+//            6L * DateTimeConstants.MILLIS_PER_MINUTE +\n+//            7L * DateTimeConstants.MILLIS_PER_SECOND + 8L;\n+//        MutablePeriod test = new MutablePeriod(PeriodType.getPreciseYearMonthType().withSecondsRemoved());\n+//        test.setPeriod(ms);\n+//        assertEquals(1, test.getYears());\n+//        assertEquals(2, test.getMonths());\n+//        assertEquals(0, test.getWeeks());\n+//        assertEquals(25, test.getDays());\n+//        assertEquals(5, test.getHours());\n+//        assertEquals(6, test.getMinutes());\n+//        assertEquals(0, test.getSeconds());\n+//        assertEquals(8 + 7 * 1000, test.getMillis());\n+//        assertEquals(ms, test.toDurationMillis());\n+//    }\n+//\n+//    public void testSetPeriod_long_NoMillis() {\n+//        long ms =\n+//            (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY +\n+//            5L * DateTimeConstants.MILLIS_PER_HOUR +\n+//            6L * DateTimeConstants.MILLIS_PER_MINUTE +\n+//            7L * DateTimeConstants.MILLIS_PER_SECOND + 8L;\n+//        MutablePeriod test = new MutablePeriod(PeriodType.getPreciseYearMonthType().withMillisRemoved());\n+//        test.setPeriod(ms);\n+//        assertEquals(1, test.getYears());\n+//        assertEquals(2, test.getMonths());\n+//        assertEquals(0, test.getWeeks());\n+//        assertEquals(25, test.getDays());\n+//        assertEquals(5, test.getHours());\n+//        assertEquals(6, test.getMinutes());\n+//        assertEquals(7, test.getSeconds());\n+//        assertEquals(0, test.getMillis());\n+//        assertEquals(ms - 8, test.toDurationMillis());\n+//    }\n \n     //-----------------------------------------------------------------------\n     public void testSetPeriod_RD1() {\n     }\n \n     public void testAdd_8ints2() {\n-        MutablePeriod test = new MutablePeriod(100L, PeriodType.getYearMonthType());\n+        MutablePeriod test = new MutablePeriod(100L, PeriodType.yearMonthDayTime());\n         try {\n             test.add(1, 2, 3, 4, 5, 6, 7, 8);\n             fail();\n         assertEquals(0, test.getMinutes());\n         assertEquals(0, test.getSeconds());\n         assertEquals(200, test.getMillis());\n-        assertEquals(200L, test.toDurationMillis());\n     }\n \n     public void testAdd_long2() {\n-        MutablePeriod test = new MutablePeriod(100L, PeriodType.getAllType());\n+        MutablePeriod test = new MutablePeriod(100L, PeriodType.standard());\n         long ms =\n             (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY +\n             5L * DateTimeConstants.MILLIS_PER_HOUR +\n         assertEquals(108, test.getMillis());\n     }\n \n-    public void testAdd_long3() {\n-        MutablePeriod test = new MutablePeriod(100L, PeriodType.getPreciseYearMonthType());\n-        long ms =\n-            (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY +\n-            5L * DateTimeConstants.MILLIS_PER_HOUR +\n-            6L * DateTimeConstants.MILLIS_PER_MINUTE +\n-            7L * DateTimeConstants.MILLIS_PER_SECOND + 8L;\n-        test.add(ms);\n-        assertEquals(1, test.getYears());\n-        assertEquals(2, test.getMonths());\n-        assertEquals(0, test.getWeeks());  // checks that YearMonth type is used in conversion\n-        assertEquals(25, test.getDays());\n-        assertEquals(5, test.getHours());\n-        assertEquals(6, test.getMinutes());\n-        assertEquals(7, test.getSeconds());\n-        assertEquals(108, test.getMillis());\n-        assertEquals(ms + 100L, test.toDurationMillis());\n-    }\n-\n-    public void testAdd_long4() {\n-        MutablePeriod test = new MutablePeriod(100L, PeriodType.getPreciseYearMonthType());\n-        long ms =0L;\n-        test.add(ms);\n-        assertEquals(0, test.getYears());\n-        assertEquals(0, test.getMonths());\n-        assertEquals(0, test.getWeeks());\n-        assertEquals(0, test.getDays());\n-        assertEquals(0, test.getHours());\n-        assertEquals(0, test.getMinutes());\n-        assertEquals(0, test.getSeconds());\n-        assertEquals(100, test.getMillis());\n-        assertEquals(100L, test.toDurationMillis());\n-    }\n+//    public void testAdd_long3() {\n+//        MutablePeriod test = new MutablePeriod(100L, PeriodType.getPreciseYearMonthType());\n+//        long ms =\n+//            (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY +\n+//            5L * DateTimeConstants.MILLIS_PER_HOUR +\n+//            6L * DateTimeConstants.MILLIS_PER_MINUTE +\n+//            7L * DateTimeConstants.MILLIS_PER_SECOND + 8L;\n+//        test.add(ms);\n+//        assertEquals(1, test.getYears());\n+//        assertEquals(2, test.getMonths());\n+//        assertEquals(0, test.getWeeks());  // checks that YearMonth type is used in conversion\n+//        assertEquals(25, test.getDays());\n+//        assertEquals(5, test.getHours());\n+//        assertEquals(6, test.getMinutes());\n+//        assertEquals(7, test.getSeconds());\n+//        assertEquals(108, test.getMillis());\n+//    }\n+//\n+//    public void testAdd_long4() {\n+//        MutablePeriod test = new MutablePeriod(100L, PeriodType.getPreciseYearMonthType());\n+//        long ms =0L;\n+//        test.add(ms);\n+//        assertEquals(0, test.getYears());\n+//        assertEquals(0, test.getMonths());\n+//        assertEquals(0, test.getWeeks());\n+//        assertEquals(0, test.getDays());\n+//        assertEquals(0, test.getHours());\n+//        assertEquals(0, test.getMinutes());\n+//        assertEquals(0, test.getSeconds());\n+//        assertEquals(100, test.getMillis());\n+//    }\n \n     public void testAdd_long5() {\n         MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n         assertEquals(0, test.getMinutes());\n         assertEquals(0, test.getSeconds());\n         assertEquals(200, test.getMillis());\n-        assertEquals(200L, test.toDurationMillis());\n     }\n \n     public void testAdd_RD2() {\n-        MutablePeriod test = new MutablePeriod(100L, PeriodType.getPreciseYearMonthType());\n+        MutablePeriod test = new MutablePeriod(100L, PeriodType.yearMonthDayTime());\n         long ms =\n-            (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY +\n+            (4L + (3L * 7L)) * DateTimeConstants.MILLIS_PER_DAY +\n             5L * DateTimeConstants.MILLIS_PER_HOUR +\n             6L * DateTimeConstants.MILLIS_PER_MINUTE +\n             7L * DateTimeConstants.MILLIS_PER_SECOND + 8L;\n         test.add(new Duration(ms));\n-        assertEquals(1, test.getYears());\n-        assertEquals(2, test.getMonths());\n-        assertEquals(0, test.getWeeks());  // checks that YearMonth type is used in conversion\n-        assertEquals(25, test.getDays());\n-        assertEquals(5, test.getHours());\n+        assertEquals(0, test.getYears());\n+        assertEquals(0, test.getMonths());\n+        assertEquals(0, test.getWeeks());\n+        assertEquals(0, test.getDays());\n+        assertEquals((4 + (3 * 7)) * 24 + 5, test.getHours());\n         assertEquals(6, test.getMinutes());\n         assertEquals(7, test.getSeconds());\n         assertEquals(108, test.getMillis());\n-        assertEquals(ms + 100L, test.toDurationMillis());\n-    }\n-\n-    public void testAdd_RD3() {\n-        MutablePeriod test = new MutablePeriod(100L, PeriodType.getPreciseYearMonthType());\n-        long ms =0L;\n-        test.add(new Duration(ms));\n-        assertEquals(0, test.getYears());\n-        assertEquals(0, test.getMonths());\n-        assertEquals(0, test.getWeeks());\n-        assertEquals(0, test.getDays());\n-        assertEquals(0, test.getHours());\n-        assertEquals(0, test.getMinutes());\n-        assertEquals(0, test.getSeconds());\n-        assertEquals(100, test.getMillis());\n-        assertEquals(100L, test.toDurationMillis());\n-    }\n-\n-    public void testAdd_RD4() {\n-        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n-        test.add(new Duration(2100L));\n+    }\n+\n+//    public void testAdd_RD3() {\n+//        MutablePeriod test = new MutablePeriod(100L, PeriodType.getPreciseYearMonthType());\n+//        long ms =0L;\n+//        test.add(new Duration(ms));\n+//        assertEquals(0, test.getYears());\n+//        assertEquals(0, test.getMonths());\n+//        assertEquals(0, test.getWeeks());\n+//        assertEquals(0, test.getDays());\n+//        assertEquals(0, test.getHours());\n+//        assertEquals(0, test.getMinutes());\n+//        assertEquals(0, test.getSeconds());\n+//        assertEquals(100, test.getMillis());\n+//        assertEquals(100L, test.toDurationMillis());\n+//    }\n+//\n+//    public void testAdd_RD4() {\n+//        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n+//        test.add(new Duration(2100L));\n+//        assertEquals(1, test.getYears());\n+//        assertEquals(2, test.getMonths());\n+//        assertEquals(3, test.getWeeks());\n+//        assertEquals(4, test.getDays());\n+//        assertEquals(5, test.getHours());\n+//        assertEquals(6, test.getMinutes());\n+//        assertEquals(9, test.getSeconds());\n+//        assertEquals(108, test.getMillis());\n+//    }\n+//\n+//    public void testAdd_RD5() {\n+//        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n+//        test.add((ReadableDuration) null);\n+//        assertEquals(1, test.getYears());\n+//        assertEquals(2, test.getMonths());\n+//        assertEquals(3, test.getWeeks());\n+//        assertEquals(4, test.getDays());\n+//        assertEquals(5, test.getHours());\n+//        assertEquals(6, test.getMinutes());\n+//        assertEquals(7, test.getSeconds());\n+//        assertEquals(8, test.getMillis());\n+//    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testAdd_RP1() {\n+        MutablePeriod test = new MutablePeriod(100L);\n+        test.add(new Period(100L));\n+        assertEquals(0, test.getYears());\n+        assertEquals(0, test.getMonths());\n+        assertEquals(0, test.getWeeks());\n+        assertEquals(0, test.getDays());\n+        assertEquals(0, test.getHours());\n+        assertEquals(0, test.getMinutes());\n+        assertEquals(0, test.getSeconds());\n+        assertEquals(200, test.getMillis());\n+    }\n+\n+    public void testAdd_RP2() {\n+        MutablePeriod test = new MutablePeriod(100L, PeriodType.standard());  // All type\n+        test.add(new Period(1, 2, 3, 4, 5, 6, 7, 0, PeriodType.standard().withMillisRemoved()));\n+        // add field value, ignore different types\n         assertEquals(1, test.getYears());\n         assertEquals(2, test.getMonths());\n         assertEquals(3, test.getWeeks());\n         assertEquals(4, test.getDays());\n         assertEquals(5, test.getHours());\n         assertEquals(6, test.getMinutes());\n-        assertEquals(9, test.getSeconds());\n-        assertEquals(108, test.getMillis());\n-    }\n-\n-    public void testAdd_RD5() {\n-        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n-        test.add((ReadableDuration) null);\n+        assertEquals(7, test.getSeconds());\n+        assertEquals(100, test.getMillis());\n+    }\n+\n+    public void testAdd_RP3() {\n+        MutablePeriod test = new MutablePeriod(100L, PeriodType.standard());\n+        test.add(new Period(0L));\n+        assertEquals(0, test.getYears());\n+        assertEquals(0, test.getMonths());\n+        assertEquals(0, test.getWeeks());\n+        assertEquals(0, test.getDays());\n+        assertEquals(0, test.getHours());\n+        assertEquals(0, test.getMinutes());\n+        assertEquals(0, test.getSeconds());\n+        assertEquals(100, test.getMillis());\n+    }\n+\n+    public void testAdd_RP4() {\n+        MutablePeriod test = new MutablePeriod(1, 2, 0, 4, 5, 6, 7, 8, PeriodType.yearMonthDayTime());\n+        try {\n+            test.add(new Period(1, 2, 3, 4, 5, 6, 7, 8));  // cannot set weeks\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        assertEquals(1, test.getYears());\n+        assertEquals(2, test.getMonths());\n+        assertEquals(0, test.getWeeks());\n+        assertEquals(4, test.getDays());\n+        assertEquals(5, test.getHours());\n+        assertEquals(6, test.getMinutes());\n+        assertEquals(7, test.getSeconds());\n+        assertEquals(8, test.getMillis());\n+    }\n+\n+    public void testAdd_RP5() {\n+        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n+        test.add((ReadablePeriod) null);\n         assertEquals(1, test.getYears());\n         assertEquals(2, test.getMonths());\n         assertEquals(3, test.getWeeks());\n     }\n \n     //-----------------------------------------------------------------------\n-    public void testAdd_RP1() {\n-        MutablePeriod test = new MutablePeriod(100L);\n-        test.add(new Period(100L));\n-        assertEquals(0, test.getYears());\n-        assertEquals(0, test.getMonths());\n-        assertEquals(0, test.getWeeks());\n-        assertEquals(0, test.getDays());\n-        assertEquals(0, test.getHours());\n-        assertEquals(0, test.getMinutes());\n-        assertEquals(0, test.getSeconds());\n-        assertEquals(200, test.getMillis());\n-        assertEquals(200L, test.toDurationMillis());\n-    }\n-\n-    public void testAdd_RP2() {\n-        MutablePeriod test = new MutablePeriod(100L);  // All type\n-        test.add(new Period(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.getPreciseAllType()));\n-        assertEquals(1, test.getYears());  // add field value, ignore different types\n-        assertEquals(2, test.getMonths());  // add field value, ignore different types\n-        assertEquals(3, test.getWeeks());  // add field value, ignore different types\n-        assertEquals(4, test.getDays());  // add field value, ignore different types\n-        assertEquals(5, test.getHours());\n-        assertEquals(6, test.getMinutes());\n-        assertEquals(7, test.getSeconds());\n-        assertEquals(108, test.getMillis());\n-    }\n-\n-    public void testAdd_RP3() {\n-        MutablePeriod test = new MutablePeriod(100L, PeriodType.getPreciseYearMonthType());\n-        test.add(new Period(0L));\n-        assertEquals(0, test.getYears());\n-        assertEquals(0, test.getMonths());\n-        assertEquals(0, test.getWeeks());\n-        assertEquals(0, test.getDays());\n-        assertEquals(0, test.getHours());\n-        assertEquals(0, test.getMinutes());\n-        assertEquals(0, test.getSeconds());\n-        assertEquals(100, test.getMillis());\n-        assertEquals(100L, test.toDurationMillis());\n-    }\n-\n-    public void testAdd_RP4() {\n-        MutablePeriod test = new MutablePeriod(1, 2, 0, 4, 5, 6, 7, 8, PeriodType.getYearMonthType());\n-        try {\n-            test.add(new Period(1, 2, 3, 4, 5, 6, 7, 8));  // cannot set weeks\n-            fail();\n-        } catch (IllegalArgumentException ex) {}\n-        assertEquals(1, test.getYears());\n-        assertEquals(2, test.getMonths());\n-        assertEquals(0, test.getWeeks());\n-        assertEquals(4, test.getDays());\n-        assertEquals(5, test.getHours());\n-        assertEquals(6, test.getMinutes());\n-        assertEquals(7, test.getSeconds());\n-        assertEquals(8, test.getMillis());\n-    }\n-\n-    public void testAdd_RP5() {\n-        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n-        test.add((ReadablePeriod) null);\n-        assertEquals(1, test.getYears());\n-        assertEquals(2, test.getMonths());\n-        assertEquals(3, test.getWeeks());\n-        assertEquals(4, test.getDays());\n-        assertEquals(5, test.getHours());\n-        assertEquals(6, test.getMinutes());\n-        assertEquals(7, test.getSeconds());\n-        assertEquals(8, test.getMillis());\n-    }\n-\n-    //-----------------------------------------------------------------------\n     public void testAdd_RInterval1() {\n         MutablePeriod test = new MutablePeriod(100L);\n         test.add(new Interval(100L, 200L));\n         assertEquals(0, test.getMinutes());\n         assertEquals(0, test.getSeconds());\n         assertEquals(200, test.getMillis());\n-        assertEquals(200L, test.toDurationMillis());\n     }\n \n     public void testAdd_RInterval2() {\n     }\n \n     public void testAdd_RInterval3() {\n-        MutablePeriod test = new MutablePeriod(100L, PeriodType.getPreciseYearMonthType());\n+        MutablePeriod test = new MutablePeriod(100L, PeriodType.yearMonthDayTime());\n         test.add(new Interval(0L, 0L));\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n     public void testAdd_RInterval4() {\n         DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n         DateTime dt2 = new DateTime(2005, 7, 17, 0, 0, 0, 8);\n-        MutablePeriod test = new MutablePeriod(100L, PeriodType.getYearMonthType());\n+        MutablePeriod test = new MutablePeriod(100L, PeriodType.yearMonthDayTime());\n         test.add(new Interval(dt1, dt2));\n         assertEquals(1, test.getYears());\n         assertEquals(1, test.getMonths());\n         assertEquals(8, test.getMillis());\n     }\n \n-    //-----------------------------------------------------------------------\n-    public void testNormalize1() {\n-        MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n-        try {\n-            test.normalize();\n-            fail();\n-        } catch (IllegalStateException ex) {}\n-    }\n-\n-    public void testNormalize2() {\n-        MutablePeriod test = new MutablePeriod(1, 14, 0, 36, 29, 66, 67, 1008, PeriodType.getPreciseYearMonthType());\n-        //   365 + 14*30 + 6 days\n-        // extra year created from 12 months of 30 days plus 5 extra days\n-        // 2*365 +  2*30 + 1 day\n-        test.normalize();\n-        assertEquals(2, test.getYears());\n-        assertEquals(3, test.getMonths());\n-        assertEquals(0, test.getWeeks());\n-        assertEquals(2, test.getDays());\n-        assertEquals(6, test.getHours());\n-        assertEquals(7, test.getMinutes());\n-        assertEquals(8, test.getSeconds());\n-        assertEquals(8, test.getMillis());\n-    }\n-\n }\n--- a/JodaTime/src/test/org/joda/time/TestPeriodType.java\n+++ b/JodaTime/src/test/org/joda/time/TestPeriodType.java\n import java.io.ByteArrayOutputStream;\n import java.io.ObjectInputStream;\n import java.io.ObjectOutputStream;\n-import java.lang.reflect.Modifier;\n import java.util.Locale;\n import java.util.TimeZone;\n \n import junit.framework.TestCase;\n import junit.framework.TestSuite;\n-\n-import org.joda.time.chrono.BuddhistChronology;\n-import org.joda.time.chrono.CopticChronology;\n-import org.joda.time.chrono.ISOChronology;\n \n /**\n  * This class is a JUnit test for PeriodType.\n         PeriodType result = (PeriodType) ois.readObject();\n         ois.close();\n         \n-        assertSame(type, result);\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    public void testMillisType() throws Exception {\n-        PeriodType type = PeriodType.getMillisType();\n-        assertEquals(false, type.years().isSupported());\n-        assertEquals(false, type.months().isSupported());\n-        assertEquals(false, type.weeks().isSupported());\n-        assertEquals(false, type.days().isSupported());\n-        assertEquals(false, type.hours().isSupported());\n-        assertEquals(false, type.minutes().isSupported());\n-        assertEquals(false, type.seconds().isSupported());\n-        assertEquals(true, type.millis().isSupported());\n-        assertEquals(true, type.isPrecise());\n-        assertEquals(ISOChronology.getInstanceUTC(), type.getChronology());\n-        assertEquals(true, type.equals(type));\n-        assertEquals(true, type == PeriodType.getMillisType());\n-        assertEquals(false, type.equals(PeriodType.getAllType()));\n-        assertEquals(true, type.hashCode() == type.hashCode());\n-        assertEquals(true, type.hashCode() == PeriodType.getMillisType().hashCode());\n-        assertEquals(false, type.hashCode() == PeriodType.getAllType().hashCode());\n-        assertEquals(\"MillisType\", type.getName());\n-        assertEquals(\"PeriodType[MillisType]\", type.toString());\n-        assertSameAfterSerialization(type);\n-        assertSame(type, type.withChronology(null));\n-        assertSame(type, type.withChronology(CopticChronology.getInstanceUTC()));\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    public void testDayHourType() throws Exception {\n-        PeriodType type = PeriodType.getDayHourType();\n-        assertEquals(false, type.years().isSupported());\n-        assertEquals(false, type.months().isSupported());\n-        assertEquals(false, type.weeks().isSupported());\n-        assertEquals(true, type.days().isSupported());\n-        assertEquals(true, type.hours().isSupported());\n-        assertEquals(true, type.minutes().isSupported());\n-        assertEquals(true, type.seconds().isSupported());\n-        assertEquals(true, type.millis().isSupported());\n-        assertEquals(false, type.isPrecise());\n-        assertEquals(ISOChronology.getInstance(), type.getChronology());\n-        assertEquals(true, type.equals(type));\n-        assertEquals(true, type == PeriodType.getDayHourType());\n-        assertEquals(false, type.equals(PeriodType.getAllType()));\n-        assertEquals(true, type.hashCode() == type.hashCode());\n-        assertEquals(true, type.hashCode() == PeriodType.getDayHourType().hashCode());\n-        assertEquals(false, type.hashCode() == PeriodType.getAllType().hashCode());\n-        assertEquals(\"DayHourType\", type.getName());\n-        assertEquals(\"PeriodType[DayHourType]\", type.toString());\n-        assertSameAfterSerialization(type);\n-        assertSame(type, type.withChronology(null));\n-        assertSame(type, type.withChronology(ISOChronology.getInstance()));\n-        assertEquals(CopticChronology.getInstanceUTC(), type.withChronology(CopticChronology.getInstanceUTC()).getChronology());\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    public void testDayHourType_Chronology() throws Exception {\n-        PeriodType type = PeriodType.getDayHourType(BuddhistChronology.getInstanceUTC());\n-        assertEquals(false, type.years().isSupported());\n-        assertEquals(false, type.months().isSupported());\n-        assertEquals(false, type.weeks().isSupported());\n-        assertEquals(true, type.days().isSupported());\n-        assertEquals(true, type.hours().isSupported());\n-        assertEquals(true, type.minutes().isSupported());\n-        assertEquals(true, type.seconds().isSupported());\n-        assertEquals(true, type.millis().isSupported());\n-        assertEquals(true, type.isPrecise());\n-        assertEquals(BuddhistChronology.getInstanceUTC(), type.getChronology());\n-        assertEquals(true, type.equals(type));\n-        assertEquals(true, PeriodType.getDayHourType() == PeriodType.getDayHourType(null));\n-        assertEquals(true, PeriodType.getDayHourType() == PeriodType.getDayHourType(ISOChronology.getInstance()));\n-        assertEquals(true, type.equals(PeriodType.getDayHourType(BuddhistChronology.getInstanceUTC())));\n-        assertEquals(false, type.equals(PeriodType.getDayHourType()));\n-        assertEquals(false, type.equals(PeriodType.getAllType()));\n-        assertEquals(true, type.hashCode() == type.hashCode());\n-        assertEquals(false, type.hashCode() == PeriodType.getDayHourType().hashCode());\n-        assertEquals(false, type.hashCode() == PeriodType.getAllType().hashCode());\n-        assertEquals(\"DayHourType\", type.getName());\n-        assertEquals(\"PeriodType[DayHourType]\", type.toString());\n-        assertEqualsAfterSerialization(type);\n-        assertSame(PeriodType.getDayHourType(), type.withChronology(null));\n-        assertSame(PeriodType.getDayHourType(), type.withChronology(ISOChronology.getInstance()));\n-        assertEquals(CopticChronology.getInstanceUTC(), type.withChronology(CopticChronology.getInstanceUTC()).getChronology());\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    public void testYearDayType() throws Exception {\n-        PeriodType type = PeriodType.getYearDayType();\n-        assertEquals(true, type.years().isSupported());\n-        assertEquals(false, type.months().isSupported());\n-        assertEquals(false, type.weeks().isSupported());\n-        assertEquals(true, type.days().isSupported());\n-        assertEquals(true, type.hours().isSupported());\n-        assertEquals(true, type.minutes().isSupported());\n-        assertEquals(true, type.seconds().isSupported());\n-        assertEquals(true, type.millis().isSupported());\n-        assertEquals(false, type.isPrecise());\n-        assertEquals(ISOChronology.getInstance(), type.getChronology());\n-        assertEquals(true, type.equals(type));\n-        assertEquals(true, type == PeriodType.getYearDayType());\n-        assertEquals(false, type.equals(PeriodType.getAllType()));\n-        assertEquals(true, type.hashCode() == type.hashCode());\n-        assertEquals(true, type.hashCode() == PeriodType.getYearDayType().hashCode());\n-        assertEquals(false, type.hashCode() == PeriodType.getAllType().hashCode());\n-        assertEquals(\"YearDayType\", type.getName());\n-        assertEquals(\"PeriodType[YearDayType]\", type.toString());\n-        assertSameAfterSerialization(type);\n-        assertSame(type, type.withChronology(null));\n-        assertSame(type, type.withChronology(ISOChronology.getInstance()));\n-        assertEquals(CopticChronology.getInstanceUTC(), type.withChronology(CopticChronology.getInstanceUTC()).getChronology());\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    public void testYearWeekType() throws Exception {\n-        PeriodType type = PeriodType.getYearWeekType();\n-        assertEquals(true, type.years().isSupported());\n-        assertEquals(false, type.months().isSupported());\n-        assertEquals(true, type.weeks().isSupported());\n-        assertEquals(true, type.days().isSupported());\n-        assertEquals(true, type.hours().isSupported());\n-        assertEquals(true, type.minutes().isSupported());\n-        assertEquals(true, type.seconds().isSupported());\n-        assertEquals(true, type.millis().isSupported());\n-        assertEquals(false, type.isPrecise());\n-        assertEquals(ISOChronology.getInstance(), type.getChronology());\n-        assertEquals(true, type.equals(type));\n-        assertEquals(true, type == PeriodType.getYearWeekType());\n-        assertEquals(false, type.equals(PeriodType.getAllType()));\n-        assertEquals(true, type.hashCode() == type.hashCode());\n-        assertEquals(true, type.hashCode() == PeriodType.getYearWeekType().hashCode());\n-        assertEquals(false, type.hashCode() == PeriodType.getAllType().hashCode());\n-        assertEquals(\"YearWeekType\", type.getName());\n-        assertEquals(\"PeriodType[YearWeekType]\", type.toString());\n-        assertSameAfterSerialization(type);\n-        assertSame(type, type.withChronology(null));\n-        assertSame(type, type.withChronology(ISOChronology.getInstance()));\n-        assertEquals(CopticChronology.getInstanceUTC(), type.withChronology(CopticChronology.getInstanceUTC()).getChronology());\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    public void testYearWeekType_Chronology() throws Exception {\n-        PeriodType type = PeriodType.getYearWeekType(BuddhistChronology.getInstanceUTC());\n-        assertEquals(true, type.years().isSupported());\n-        assertEquals(false, type.months().isSupported());\n-        assertEquals(true, type.weeks().isSupported());\n-        assertEquals(true, type.days().isSupported());\n-        assertEquals(true, type.hours().isSupported());\n-        assertEquals(true, type.minutes().isSupported());\n-        assertEquals(true, type.seconds().isSupported());\n-        assertEquals(true, type.millis().isSupported());\n-        assertEquals(false, type.isPrecise());\n-        assertEquals(BuddhistChronology.getInstanceUTC(), type.getChronology());\n-        assertEquals(true, type.equals(type));\n-        assertEquals(true, PeriodType.getYearWeekType() == PeriodType.getYearWeekType(null));\n-        assertEquals(true, PeriodType.getYearWeekType() == PeriodType.getYearWeekType(ISOChronology.getInstance()));\n-        assertEquals(true, type.equals(PeriodType.getYearWeekType(BuddhistChronology.getInstanceUTC())));\n-        assertEquals(false, type.equals(PeriodType.getYearWeekType()));\n-        assertEquals(false, type.equals(PeriodType.getAllType()));\n-        assertEquals(true, type.hashCode() == type.hashCode());\n-        assertEquals(false, type.hashCode() == PeriodType.getYearWeekType().hashCode());\n-        assertEquals(false, type.hashCode() == PeriodType.getAllType().hashCode());\n-        assertEquals(\"YearWeekType\", type.getName());\n-        assertEquals(\"PeriodType[YearWeekType]\", type.toString());\n-        assertEqualsAfterSerialization(type);\n-        assertSame(PeriodType.getYearWeekType(), type.withChronology(null));\n-        assertSame(PeriodType.getYearWeekType(), type.withChronology(ISOChronology.getInstance()));\n-        assertEquals(CopticChronology.getInstanceUTC(), type.withChronology(CopticChronology.getInstanceUTC()).getChronology());\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    public void testYearMonthType() throws Exception {\n-        PeriodType type = PeriodType.getYearMonthType();\n-        assertEquals(true, type.years().isSupported());\n-        assertEquals(true, type.months().isSupported());\n-        assertEquals(false, type.weeks().isSupported());\n-        assertEquals(true, type.days().isSupported());\n-        assertEquals(true, type.hours().isSupported());\n-        assertEquals(true, type.minutes().isSupported());\n-        assertEquals(true, type.seconds().isSupported());\n-        assertEquals(true, type.millis().isSupported());\n-        assertEquals(false, type.isPrecise());\n-        assertEquals(ISOChronology.getInstance(), type.getChronology());\n-        assertEquals(true, type.equals(type));\n-        assertEquals(true, type == PeriodType.getYearMonthType());\n-        assertEquals(false, type.equals(PeriodType.getAllType()));\n-        assertEquals(true, type.hashCode() == type.hashCode());\n-        assertEquals(true, type.hashCode() == PeriodType.getYearMonthType().hashCode());\n-        assertEquals(false, type.hashCode() == PeriodType.getAllType().hashCode());\n-        assertEquals(\"YearMonthType\", type.getName());\n-        assertEquals(\"PeriodType[YearMonthType]\", type.toString());\n-        assertSameAfterSerialization(type);\n-        assertSame(type, type.withChronology(null));\n-        assertSame(type, type.withChronology(ISOChronology.getInstance()));\n-        assertEquals(CopticChronology.getInstanceUTC(), type.withChronology(CopticChronology.getInstanceUTC()).getChronology());\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    public void testYearMonthType_Chronology() throws Exception {\n-        PeriodType type = PeriodType.getYearMonthType(BuddhistChronology.getInstanceUTC());\n-        assertEquals(true, type.years().isSupported());\n-        assertEquals(true, type.months().isSupported());\n-        assertEquals(false, type.weeks().isSupported());\n-        assertEquals(true, type.days().isSupported());\n-        assertEquals(true, type.hours().isSupported());\n-        assertEquals(true, type.minutes().isSupported());\n-        assertEquals(true, type.seconds().isSupported());\n-        assertEquals(true, type.millis().isSupported());\n-        assertEquals(false, type.isPrecise());\n-        assertEquals(BuddhistChronology.getInstanceUTC(), type.getChronology());\n-        assertEquals(true, type.equals(type));\n-        assertEquals(true, PeriodType.getYearMonthType() == PeriodType.getYearMonthType(null));\n-        assertEquals(true, PeriodType.getYearMonthType() == PeriodType.getYearMonthType(ISOChronology.getInstance()));\n-        assertEquals(true, type.equals(PeriodType.getYearMonthType(BuddhistChronology.getInstanceUTC())));\n-        assertEquals(false, type.equals(PeriodType.getYearMonthType()));\n-        assertEquals(false, type.equals(PeriodType.getAllType()));\n-        assertEquals(true, type.hashCode() == type.hashCode());\n-        assertEquals(false, type.hashCode() == PeriodType.getYearMonthType().hashCode());\n-        assertEquals(false, type.hashCode() == PeriodType.getAllType().hashCode());\n-        assertEquals(\"YearMonthType\", type.getName());\n-        assertEquals(\"PeriodType[YearMonthType]\", type.toString());\n-        assertEqualsAfterSerialization(type);\n-        assertSame(PeriodType.getYearMonthType(), type.withChronology(null));\n-        assertSame(PeriodType.getYearMonthType(), type.withChronology(ISOChronology.getInstance()));\n-        assertEquals(CopticChronology.getInstanceUTC(), type.withChronology(CopticChronology.getInstanceUTC()).getChronology());\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    public void testAllType() throws Exception {\n-        PeriodType type = PeriodType.getAllType();\n-        assertEquals(true, type.years().isSupported());\n-        assertEquals(true, type.months().isSupported());\n-        assertEquals(true, type.weeks().isSupported());\n-        assertEquals(true, type.days().isSupported());\n-        assertEquals(true, type.hours().isSupported());\n-        assertEquals(true, type.minutes().isSupported());\n-        assertEquals(true, type.seconds().isSupported());\n-        assertEquals(true, type.millis().isSupported());\n-        assertEquals(false, type.isPrecise());\n-        assertEquals(ISOChronology.getInstance(), type.getChronology());\n-        assertEquals(true, type.equals(type));\n-        assertEquals(true, type == PeriodType.getAllType());\n-        assertEquals(false, type.equals(PeriodType.getMillisType()));\n-        assertEquals(true, type.hashCode() == type.hashCode());\n-        assertEquals(true, type.hashCode() == PeriodType.getAllType().hashCode());\n-        assertEquals(false, type.hashCode() == PeriodType.getMillisType().hashCode());\n-        assertEquals(\"AllType\", type.getName());\n-        assertEquals(\"PeriodType[AllType]\", type.toString());\n-        assertSameAfterSerialization(type);\n-        assertSame(type, type.withChronology(null));\n-        assertSame(type, type.withChronology(ISOChronology.getInstance()));\n-        assertEquals(CopticChronology.getInstanceUTC(), type.withChronology(CopticChronology.getInstanceUTC()).getChronology());\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    public void testAllType_Chronology() throws Exception {\n-        PeriodType type = PeriodType.getAllType(BuddhistChronology.getInstanceUTC());\n-        assertEquals(true, type.years().isSupported());\n-        assertEquals(true, type.months().isSupported());\n-        assertEquals(true, type.weeks().isSupported());\n-        assertEquals(true, type.days().isSupported());\n-        assertEquals(true, type.hours().isSupported());\n-        assertEquals(true, type.minutes().isSupported());\n-        assertEquals(true, type.seconds().isSupported());\n-        assertEquals(true, type.millis().isSupported());\n-        assertEquals(false, type.isPrecise());\n-        assertEquals(BuddhistChronology.getInstanceUTC(), type.getChronology());\n-        assertEquals(true, type.equals(type));\n-        assertEquals(true, PeriodType.getAllType() == PeriodType.getAllType(null));\n-        assertEquals(true, PeriodType.getAllType() == PeriodType.getAllType(ISOChronology.getInstance()));\n-        assertEquals(true, type.equals(PeriodType.getAllType(BuddhistChronology.getInstanceUTC())));\n-        assertEquals(false, type.equals(PeriodType.getAllType()));\n-        assertEquals(false, type.equals(PeriodType.getMillisType()));\n-        assertEquals(true, type.hashCode() == type.hashCode());\n-        assertEquals(false, type.hashCode() == PeriodType.getAllType().hashCode());\n-        assertEquals(false, type.hashCode() == PeriodType.getMillisType().hashCode());\n-        assertEquals(\"AllType\", type.getName());\n-        assertEquals(\"PeriodType[AllType]\", type.toString());\n-        assertEqualsAfterSerialization(type);\n-        assertSame(PeriodType.getAllType(), type.withChronology(null));\n-        assertSame(PeriodType.getAllType(), type.withChronology(ISOChronology.getInstance()));\n-        assertEquals(CopticChronology.getInstanceUTC(), type.withChronology(CopticChronology.getInstanceUTC()).getChronology());\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    public void testDayHourTypeUTC() throws Exception {\n-        PeriodType type = PeriodType.getDayHourTypeUTC();\n-        assertEquals(false, type.years().isSupported());\n-        assertEquals(false, type.months().isSupported());\n-        assertEquals(false, type.weeks().isSupported());\n-        assertEquals(true, type.days().isSupported());\n-        assertEquals(true, type.hours().isSupported());\n-        assertEquals(true, type.minutes().isSupported());\n-        assertEquals(true, type.seconds().isSupported());\n-        assertEquals(true, type.millis().isSupported());\n-        assertEquals(true, type.isPrecise());\n-        assertEquals(ISOChronology.getInstanceUTC(), type.getChronology());\n-        assertEquals(true, type.equals(type));\n-        assertEquals(true, type == PeriodType.getDayHourTypeUTC());\n-        assertEquals(false, type.equals(PeriodType.getAllType()));\n-        assertEquals(true, type.hashCode() == type.hashCode());\n-        assertEquals(true, type.hashCode() == PeriodType.getDayHourTypeUTC().hashCode());\n-        assertEquals(false, type.hashCode() == PeriodType.getAllType().hashCode());\n-        assertEquals(\"DayHourType\", type.getName());\n-        assertEquals(\"PeriodType[DayHourType]\", type.toString());\n-        assertSameAfterSerialization(type);\n-        assertSame(PeriodType.getDayHourType(), type.withChronology(null));\n-        assertSame(type, type.withChronology(ISOChronology.getInstanceUTC()));\n-        assertEquals(PeriodType.getDayHourType(CopticChronology.getInstanceUTC()), type.withChronology(CopticChronology.getInstanceUTC()));\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    public void testYearDayTypeUTC() throws Exception {\n-        PeriodType type = PeriodType.getYearDayTypeUTC();\n-        assertEquals(true, type.years().isSupported());\n-        assertEquals(false, type.months().isSupported());\n-        assertEquals(false, type.weeks().isSupported());\n-        assertEquals(true, type.days().isSupported());\n-        assertEquals(true, type.hours().isSupported());\n-        assertEquals(true, type.minutes().isSupported());\n-        assertEquals(true, type.seconds().isSupported());\n-        assertEquals(true, type.millis().isSupported());\n-        assertEquals(false, type.isPrecise());\n-        assertEquals(ISOChronology.getInstanceUTC(), type.getChronology());\n-        assertEquals(true, type.equals(type));\n-        assertEquals(true, type == PeriodType.getYearDayTypeUTC());\n-        assertEquals(false, type.equals(PeriodType.getAllType()));\n-        assertEquals(true, type.hashCode() == type.hashCode());\n-        assertEquals(true, type.hashCode() == PeriodType.getYearDayTypeUTC().hashCode());\n-        assertEquals(false, type.hashCode() == PeriodType.getAllType().hashCode());\n-        assertEquals(\"YearDayType\", type.getName());\n-        assertEquals(\"PeriodType[YearDayType]\", type.toString());\n-        assertSameAfterSerialization(type);\n-        assertSame(PeriodType.getYearDayType(), type.withChronology(null));\n-        assertSame(type, type.withChronology(ISOChronology.getInstanceUTC()));\n-        assertEquals(PeriodType.getYearDayType(CopticChronology.getInstanceUTC()), type.withChronology(CopticChronology.getInstanceUTC()));\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    public void testYearWeekTypeUTC() throws Exception {\n-        PeriodType type = PeriodType.getYearWeekTypeUTC();\n-        assertEquals(true, type.years().isSupported());\n-        assertEquals(false, type.months().isSupported());\n-        assertEquals(true, type.weeks().isSupported());\n-        assertEquals(true, type.days().isSupported());\n-        assertEquals(true, type.hours().isSupported());\n-        assertEquals(true, type.minutes().isSupported());\n-        assertEquals(true, type.seconds().isSupported());\n-        assertEquals(true, type.millis().isSupported());\n-        assertEquals(false, type.isPrecise());\n-        assertEquals(ISOChronology.getInstanceUTC(), type.getChronology());\n-        assertEquals(true, type.equals(type));\n-        assertEquals(true, type == PeriodType.getYearWeekTypeUTC());\n-        assertEquals(false, type.equals(PeriodType.getAllType()));\n-        assertEquals(true, type.hashCode() == type.hashCode());\n-        assertEquals(true, type.hashCode() == PeriodType.getYearWeekTypeUTC().hashCode());\n-        assertEquals(false, type.hashCode() == PeriodType.getAllType().hashCode());\n-        assertEquals(\"YearWeekType\", type.getName());\n-        assertEquals(\"PeriodType[YearWeekType]\", type.toString());\n-        assertSameAfterSerialization(type);\n-        assertSame(PeriodType.getYearWeekType(), type.withChronology(null));\n-        assertSame(type, type.withChronology(ISOChronology.getInstanceUTC()));\n-        assertEquals(PeriodType.getYearWeekType(CopticChronology.getInstanceUTC()), type.withChronology(CopticChronology.getInstanceUTC()));\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    public void testYearMonthTypeUTC() throws Exception {\n-        PeriodType type = PeriodType.getYearMonthTypeUTC();\n-        assertEquals(true, type.years().isSupported());\n-        assertEquals(true, type.months().isSupported());\n-        assertEquals(false, type.weeks().isSupported());\n-        assertEquals(true, type.days().isSupported());\n-        assertEquals(true, type.hours().isSupported());\n-        assertEquals(true, type.minutes().isSupported());\n-        assertEquals(true, type.seconds().isSupported());\n-        assertEquals(true, type.millis().isSupported());\n-        assertEquals(false, type.isPrecise());\n-        assertEquals(ISOChronology.getInstanceUTC(), type.getChronology());\n-        assertEquals(true, type.equals(type));\n-        assertEquals(true, type == PeriodType.getYearMonthTypeUTC());\n-        assertEquals(false, type.equals(PeriodType.getAllType()));\n-        assertEquals(true, type.hashCode() == type.hashCode());\n-        assertEquals(true, type.hashCode() == PeriodType.getYearMonthTypeUTC().hashCode());\n-        assertEquals(false, type.hashCode() == PeriodType.getAllType().hashCode());\n-        assertEquals(\"YearMonthType\", type.getName());\n-        assertEquals(\"PeriodType[YearMonthType]\", type.toString());\n-        assertSameAfterSerialization(type);\n-        assertSame(PeriodType.getYearMonthType(), type.withChronology(null));\n-        assertSame(type, type.withChronology(ISOChronology.getInstanceUTC()));\n-        assertEquals(PeriodType.getYearMonthType(CopticChronology.getInstanceUTC()), type.withChronology(CopticChronology.getInstanceUTC()));\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    public void testAllTypeUTC() throws Exception {\n-        PeriodType type = PeriodType.getAllTypeUTC();\n-        assertEquals(true, type.years().isSupported());\n-        assertEquals(true, type.months().isSupported());\n-        assertEquals(true, type.weeks().isSupported());\n-        assertEquals(true, type.days().isSupported());\n-        assertEquals(true, type.hours().isSupported());\n-        assertEquals(true, type.minutes().isSupported());\n-        assertEquals(true, type.seconds().isSupported());\n-        assertEquals(true, type.millis().isSupported());\n-        assertEquals(false, type.isPrecise());\n-        assertEquals(ISOChronology.getInstanceUTC(), type.getChronology());\n-        assertEquals(true, type.equals(type));\n-        assertEquals(true, type == PeriodType.getAllTypeUTC());\n-        assertEquals(false, type.equals(PeriodType.getMillisType()));\n-        assertEquals(true, type.hashCode() == type.hashCode());\n-        assertEquals(true, type.hashCode() == PeriodType.getAllTypeUTC().hashCode());\n-        assertEquals(false, type.hashCode() == PeriodType.getMillisType().hashCode());\n-        assertEquals(\"AllType\", type.getName());\n-        assertEquals(\"PeriodType[AllType]\", type.toString());\n-        assertSameAfterSerialization(type);\n-        assertSame(PeriodType.getAllType(), type.withChronology(null));\n-        assertSame(type, type.withChronology(ISOChronology.getInstanceUTC()));\n-        assertEquals(PeriodType.getAllType(CopticChronology.getInstanceUTC()), type.withChronology(CopticChronology.getInstanceUTC()));\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    public void testPreciseDayHourType() throws Exception {\n-        PeriodType type = PeriodType.getPreciseDayHourType();\n-        assertEquals(false, type.years().isSupported());\n-        assertEquals(false, type.months().isSupported());\n-        assertEquals(false, type.weeks().isSupported());\n-        assertEquals(true, type.days().isSupported());\n-        assertEquals(true, type.hours().isSupported());\n-        assertEquals(true, type.minutes().isSupported());\n-        assertEquals(true, type.seconds().isSupported());\n-        assertEquals(true, type.millis().isSupported());\n-        assertEquals(true, type.isPrecise());\n-        assertEquals(ISOChronology.getInstanceUTC(), type.getChronology());\n-        assertEquals(true, type.equals(type));\n-        assertEquals(true, type == PeriodType.getPreciseDayHourType());\n-        assertEquals(false, type.equals(PeriodType.getAllType()));\n-        assertEquals(true, type.hashCode() == type.hashCode());\n-        assertEquals(true, type.hashCode() == PeriodType.getPreciseDayHourType().hashCode());\n-        assertEquals(false, type.hashCode() == PeriodType.getAllType().hashCode());\n-        assertEquals(\"PreciseDayHourType\", type.getName());\n-        assertEquals(\"PeriodType[PreciseDayHourType]\", type.toString());\n-        assertSameAfterSerialization(type);\n-        assertSame(type, type.withChronology(null));\n-        assertSame(type, type.withChronology(ISOChronology.getInstanceUTC()));\n-        assertSame(type, type.withChronology(CopticChronology.getInstanceUTC()));\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    public void testPreciseYearDayType() throws Exception {\n-        PeriodType type = PeriodType.getPreciseYearDayType();\n-        assertEquals(true, type.years().isSupported());\n-        assertEquals(false, type.months().isSupported());\n-        assertEquals(false, type.weeks().isSupported());\n-        assertEquals(true, type.days().isSupported());\n-        assertEquals(true, type.hours().isSupported());\n-        assertEquals(true, type.minutes().isSupported());\n-        assertEquals(true, type.seconds().isSupported());\n-        assertEquals(true, type.millis().isSupported());\n-        assertEquals(true, type.isPrecise());\n-        assertEquals(ISOChronology.getInstanceUTC(), type.getChronology());\n-        assertEquals(true, type.equals(type));\n-        assertEquals(true, type == PeriodType.getPreciseYearDayType());\n-        assertEquals(false, type.equals(PeriodType.getAllType()));\n-        assertEquals(true, type.hashCode() == type.hashCode());\n-        assertEquals(true, type.hashCode() == PeriodType.getPreciseYearDayType().hashCode());\n-        assertEquals(false, type.hashCode() == PeriodType.getAllType().hashCode());\n-        assertEquals(\"PreciseYearDayType\", type.getName());\n-        assertEquals(\"PeriodType[PreciseYearDayType]\", type.toString());\n-        assertSameAfterSerialization(type);\n-        assertSame(type, type.withChronology(null));\n-        assertSame(type, type.withChronology(ISOChronology.getInstanceUTC()));\n-        assertSame(type, type.withChronology(CopticChronology.getInstanceUTC()));\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    public void testPreciseYearWeekType() throws Exception {\n-        PeriodType type = PeriodType.getPreciseYearWeekType();\n-        assertEquals(true, type.years().isSupported());\n-        assertEquals(false, type.months().isSupported());\n-        assertEquals(true, type.weeks().isSupported());\n-        assertEquals(true, type.days().isSupported());\n-        assertEquals(true, type.hours().isSupported());\n-        assertEquals(true, type.minutes().isSupported());\n-        assertEquals(true, type.seconds().isSupported());\n-        assertEquals(true, type.millis().isSupported());\n-        assertEquals(true, type.isPrecise());\n-        assertEquals(ISOChronology.getInstanceUTC(), type.getChronology());\n-        assertEquals(true, type.equals(type));\n-        assertEquals(true, type == PeriodType.getPreciseYearWeekType());\n-        assertEquals(false, type.equals(PeriodType.getAllType()));\n-        assertEquals(true, type.hashCode() == type.hashCode());\n-        assertEquals(true, type.hashCode() == PeriodType.getPreciseYearWeekType().hashCode());\n-        assertEquals(false, type.hashCode() == PeriodType.getAllType().hashCode());\n-        assertEquals(\"PreciseYearWeekType\", type.getName());\n-        assertEquals(\"PeriodType[PreciseYearWeekType]\", type.toString());\n-        assertSameAfterSerialization(type);\n-        assertSame(type, type.withChronology(null));\n-        assertSame(type, type.withChronology(ISOChronology.getInstanceUTC()));\n-        assertSame(type, type.withChronology(CopticChronology.getInstanceUTC()));\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    public void testPreciseYearMonthType() throws Exception {\n-        PeriodType type = PeriodType.getPreciseYearMonthType();\n-        assertEquals(true, type.years().isSupported());\n-        assertEquals(true, type.months().isSupported());\n-        assertEquals(false, type.weeks().isSupported());\n-        assertEquals(true, type.days().isSupported());\n-        assertEquals(true, type.hours().isSupported());\n-        assertEquals(true, type.minutes().isSupported());\n-        assertEquals(true, type.seconds().isSupported());\n-        assertEquals(true, type.millis().isSupported());\n-        assertEquals(true, type.isPrecise());\n-        assertEquals(ISOChronology.getInstanceUTC(), type.getChronology());\n-        assertEquals(true, type.equals(type));\n-        assertEquals(true, type == PeriodType.getPreciseYearMonthType());\n-        assertEquals(false, type.equals(PeriodType.getAllType()));\n-        assertEquals(true, type.hashCode() == type.hashCode());\n-        assertEquals(true, type.hashCode() == PeriodType.getPreciseYearMonthType().hashCode());\n-        assertEquals(false, type.hashCode() == PeriodType.getAllType().hashCode());\n-        assertEquals(\"PreciseYearMonthType\", type.getName());\n-        assertEquals(\"PeriodType[PreciseYearMonthType]\", type.toString());\n-        assertSameAfterSerialization(type);\n-        assertSame(type, type.withChronology(null));\n-        assertSame(type, type.withChronology(ISOChronology.getInstanceUTC()));\n-        assertSame(type, type.withChronology(CopticChronology.getInstanceUTC()));\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    public void testPreciseAllType() throws Exception {\n-        PeriodType type = PeriodType.getPreciseAllType();\n-        assertEquals(true, type.years().isSupported());\n-        assertEquals(true, type.months().isSupported());\n-        assertEquals(true, type.weeks().isSupported());\n-        assertEquals(true, type.days().isSupported());\n-        assertEquals(true, type.hours().isSupported());\n-        assertEquals(true, type.minutes().isSupported());\n-        assertEquals(true, type.seconds().isSupported());\n-        assertEquals(true, type.millis().isSupported());\n-        assertEquals(true, type.isPrecise());\n-        assertEquals(ISOChronology.getInstanceUTC(), type.getChronology());\n-        assertEquals(true, type.equals(type));\n-        assertEquals(true, type == PeriodType.getPreciseAllType());\n-        assertEquals(false, type.equals(PeriodType.getMillisType()));\n-        assertEquals(true, type.hashCode() == type.hashCode());\n-        assertEquals(true, type.hashCode() == PeriodType.getPreciseAllType().hashCode());\n-        assertEquals(false, type.hashCode() == PeriodType.getMillisType().hashCode());\n-        assertEquals(\"PreciseAllType\", type.getName());\n-        assertEquals(\"PeriodType[PreciseAllType]\", type.toString());\n-        assertSameAfterSerialization(type);\n-        assertSame(type, type.withChronology(null));\n-        assertSame(type, type.withChronology(ISOChronology.getInstanceUTC()));\n-        assertSame(type, type.withChronology(CopticChronology.getInstanceUTC()));\n+        assertEquals(type, result);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testStandard() throws Exception {\n+        PeriodType type = PeriodType.standard();\n+        assertEquals(8, type.size());\n+        assertEquals(DurationFieldType.years(), type.getFieldType(0));\n+        assertEquals(DurationFieldType.months(), type.getFieldType(1));\n+        assertEquals(DurationFieldType.weeks(), type.getFieldType(2));\n+        assertEquals(DurationFieldType.days(), type.getFieldType(3));\n+        assertEquals(DurationFieldType.hours(), type.getFieldType(4));\n+        assertEquals(DurationFieldType.minutes(), type.getFieldType(5));\n+        assertEquals(DurationFieldType.seconds(), type.getFieldType(6));\n+        assertEquals(DurationFieldType.millis(), type.getFieldType(7));\n+        assertEquals(\"Standard\", type.getName());\n+        assertEquals(\"PeriodType[Standard]\", type.toString());\n+        assertEquals(true, type.equals(type));\n+        assertEquals(true, type == PeriodType.standard());\n+        assertEquals(false, type.equals(PeriodType.millis()));\n+        assertEquals(true, type.hashCode() == type.hashCode());\n+        assertEquals(true, type.hashCode() == PeriodType.standard().hashCode());\n+        assertEquals(false, type.hashCode() == PeriodType.millis().hashCode());\n+        assertSameAfterSerialization(type);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testYearMonthDayTime() throws Exception {\n+        PeriodType type = PeriodType.yearMonthDayTime();\n+        assertEquals(7, type.size());\n+        assertEquals(DurationFieldType.years(), type.getFieldType(0));\n+        assertEquals(DurationFieldType.months(), type.getFieldType(1));\n+        assertEquals(DurationFieldType.days(), type.getFieldType(2));\n+        assertEquals(DurationFieldType.hours(), type.getFieldType(3));\n+        assertEquals(DurationFieldType.minutes(), type.getFieldType(4));\n+        assertEquals(DurationFieldType.seconds(), type.getFieldType(5));\n+        assertEquals(DurationFieldType.millis(), type.getFieldType(6));\n+        assertEquals(\"YearMonthDayTime\", type.getName());\n+        assertEquals(\"PeriodType[YearMonthDayTime]\", type.toString());\n+        assertEquals(true, type.equals(type));\n+        assertEquals(true, type == PeriodType.yearMonthDayTime());\n+        assertEquals(false, type.equals(PeriodType.millis()));\n+        assertEquals(true, type.hashCode() == type.hashCode());\n+        assertEquals(true, type.hashCode() == PeriodType.yearMonthDayTime().hashCode());\n+        assertEquals(false, type.hashCode() == PeriodType.millis().hashCode());\n+        assertSameAfterSerialization(type);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testYearWeekDayTime() throws Exception {\n+        PeriodType type = PeriodType.yearWeekDayTime();\n+        assertEquals(7, type.size());\n+        assertEquals(DurationFieldType.years(), type.getFieldType(0));\n+        assertEquals(DurationFieldType.weeks(), type.getFieldType(1));\n+        assertEquals(DurationFieldType.days(), type.getFieldType(2));\n+        assertEquals(DurationFieldType.hours(), type.getFieldType(3));\n+        assertEquals(DurationFieldType.minutes(), type.getFieldType(4));\n+        assertEquals(DurationFieldType.seconds(), type.getFieldType(5));\n+        assertEquals(DurationFieldType.millis(), type.getFieldType(6));\n+        assertEquals(\"YearWeekDayTime\", type.getName());\n+        assertEquals(\"PeriodType[YearWeekDayTime]\", type.toString());\n+        assertEquals(true, type.equals(type));\n+        assertEquals(true, type == PeriodType.yearWeekDayTime());\n+        assertEquals(false, type.equals(PeriodType.millis()));\n+        assertEquals(true, type.hashCode() == type.hashCode());\n+        assertEquals(true, type.hashCode() == PeriodType.yearWeekDayTime().hashCode());\n+        assertEquals(false, type.hashCode() == PeriodType.millis().hashCode());\n+        assertSameAfterSerialization(type);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testYearDayTime() throws Exception {\n+        PeriodType type = PeriodType.yearDayTime();\n+        assertEquals(6, type.size());\n+        assertEquals(DurationFieldType.years(), type.getFieldType(0));\n+        assertEquals(DurationFieldType.days(), type.getFieldType(1));\n+        assertEquals(DurationFieldType.hours(), type.getFieldType(2));\n+        assertEquals(DurationFieldType.minutes(), type.getFieldType(3));\n+        assertEquals(DurationFieldType.seconds(), type.getFieldType(4));\n+        assertEquals(DurationFieldType.millis(), type.getFieldType(5));\n+        assertEquals(\"YearDayTime\", type.getName());\n+        assertEquals(\"PeriodType[YearDayTime]\", type.toString());\n+        assertEquals(true, type.equals(type));\n+        assertEquals(true, type == PeriodType.yearDayTime());\n+        assertEquals(false, type.equals(PeriodType.millis()));\n+        assertEquals(true, type.hashCode() == type.hashCode());\n+        assertEquals(true, type.hashCode() == PeriodType.yearDayTime().hashCode());\n+        assertEquals(false, type.hashCode() == PeriodType.millis().hashCode());\n+        assertSameAfterSerialization(type);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testDayTime() throws Exception {\n+        PeriodType type = PeriodType.dayTime();\n+        assertEquals(5, type.size());\n+        assertEquals(DurationFieldType.days(), type.getFieldType(0));\n+        assertEquals(DurationFieldType.hours(), type.getFieldType(1));\n+        assertEquals(DurationFieldType.minutes(), type.getFieldType(2));\n+        assertEquals(DurationFieldType.seconds(), type.getFieldType(3));\n+        assertEquals(DurationFieldType.millis(), type.getFieldType(4));\n+        assertEquals(\"DayTime\", type.getName());\n+        assertEquals(\"PeriodType[DayTime]\", type.toString());\n+        assertEquals(true, type.equals(type));\n+        assertEquals(true, type == PeriodType.dayTime());\n+        assertEquals(false, type.equals(PeriodType.millis()));\n+        assertEquals(true, type.hashCode() == type.hashCode());\n+        assertEquals(true, type.hashCode() == PeriodType.dayTime().hashCode());\n+        assertEquals(false, type.hashCode() == PeriodType.millis().hashCode());\n+        assertSameAfterSerialization(type);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testTime() throws Exception {\n+        PeriodType type = PeriodType.time();\n+        assertEquals(4, type.size());\n+        assertEquals(DurationFieldType.hours(), type.getFieldType(0));\n+        assertEquals(DurationFieldType.minutes(), type.getFieldType(1));\n+        assertEquals(DurationFieldType.seconds(), type.getFieldType(2));\n+        assertEquals(DurationFieldType.millis(), type.getFieldType(3));\n+        assertEquals(\"Time\", type.getName());\n+        assertEquals(\"PeriodType[Time]\", type.toString());\n+        assertEquals(true, type.equals(type));\n+        assertEquals(true, type == PeriodType.time());\n+        assertEquals(false, type.equals(PeriodType.millis()));\n+        assertEquals(true, type.hashCode() == type.hashCode());\n+        assertEquals(true, type.hashCode() == PeriodType.time().hashCode());\n+        assertEquals(false, type.hashCode() == PeriodType.millis().hashCode());\n+        assertSameAfterSerialization(type);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testYears() throws Exception {\n+        PeriodType type = PeriodType.years();\n+        assertEquals(1, type.size());\n+        assertEquals(DurationFieldType.years(), type.getFieldType(0));\n+        assertEquals(\"Years\", type.getName());\n+        assertEquals(\"PeriodType[Years]\", type.toString());\n+        assertEquals(true, type.equals(type));\n+        assertEquals(true, type == PeriodType.years());\n+        assertEquals(false, type.equals(PeriodType.standard()));\n+        assertEquals(true, type.hashCode() == type.hashCode());\n+        assertEquals(true, type.hashCode() == PeriodType.years().hashCode());\n+        assertEquals(false, type.hashCode() == PeriodType.standard().hashCode());\n+        assertSameAfterSerialization(type);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testMonths() throws Exception {\n+        PeriodType type = PeriodType.months();\n+        assertEquals(1, type.size());\n+        assertEquals(DurationFieldType.months(), type.getFieldType(0));\n+        assertEquals(\"Months\", type.getName());\n+        assertEquals(\"PeriodType[Months]\", type.toString());\n+        assertEquals(true, type.equals(type));\n+        assertEquals(true, type == PeriodType.months());\n+        assertEquals(false, type.equals(PeriodType.standard()));\n+        assertEquals(true, type.hashCode() == type.hashCode());\n+        assertEquals(true, type.hashCode() == PeriodType.months().hashCode());\n+        assertEquals(false, type.hashCode() == PeriodType.standard().hashCode());\n+        assertSameAfterSerialization(type);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testWeeks() throws Exception {\n+        PeriodType type = PeriodType.weeks();\n+        assertEquals(1, type.size());\n+        assertEquals(DurationFieldType.weeks(), type.getFieldType(0));\n+        assertEquals(\"Weeks\", type.getName());\n+        assertEquals(\"PeriodType[Weeks]\", type.toString());\n+        assertEquals(true, type.equals(type));\n+        assertEquals(true, type == PeriodType.weeks());\n+        assertEquals(false, type.equals(PeriodType.standard()));\n+        assertEquals(true, type.hashCode() == type.hashCode());\n+        assertEquals(true, type.hashCode() == PeriodType.weeks().hashCode());\n+        assertEquals(false, type.hashCode() == PeriodType.standard().hashCode());\n+        assertSameAfterSerialization(type);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testDays() throws Exception {\n+        PeriodType type = PeriodType.days();\n+        assertEquals(1, type.size());\n+        assertEquals(DurationFieldType.days(), type.getFieldType(0));\n+        assertEquals(\"Days\", type.getName());\n+        assertEquals(\"PeriodType[Days]\", type.toString());\n+        assertEquals(true, type.equals(type));\n+        assertEquals(true, type == PeriodType.days());\n+        assertEquals(false, type.equals(PeriodType.standard()));\n+        assertEquals(true, type.hashCode() == type.hashCode());\n+        assertEquals(true, type.hashCode() == PeriodType.days().hashCode());\n+        assertEquals(false, type.hashCode() == PeriodType.standard().hashCode());\n+        assertSameAfterSerialization(type);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testHours() throws Exception {\n+        PeriodType type = PeriodType.hours();\n+        assertEquals(1, type.size());\n+        assertEquals(DurationFieldType.hours(), type.getFieldType(0));\n+        assertEquals(\"Hours\", type.getName());\n+        assertEquals(\"PeriodType[Hours]\", type.toString());\n+        assertEquals(true, type.equals(type));\n+        assertEquals(true, type == PeriodType.hours());\n+        assertEquals(false, type.equals(PeriodType.standard()));\n+        assertEquals(true, type.hashCode() == type.hashCode());\n+        assertEquals(true, type.hashCode() == PeriodType.hours().hashCode());\n+        assertEquals(false, type.hashCode() == PeriodType.standard().hashCode());\n+        assertSameAfterSerialization(type);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testMinutes() throws Exception {\n+        PeriodType type = PeriodType.minutes();\n+        assertEquals(1, type.size());\n+        assertEquals(DurationFieldType.minutes(), type.getFieldType(0));\n+        assertEquals(\"Minutes\", type.getName());\n+        assertEquals(\"PeriodType[Minutes]\", type.toString());\n+        assertEquals(true, type.equals(type));\n+        assertEquals(true, type == PeriodType.minutes());\n+        assertEquals(false, type.equals(PeriodType.standard()));\n+        assertEquals(true, type.hashCode() == type.hashCode());\n+        assertEquals(true, type.hashCode() == PeriodType.minutes().hashCode());\n+        assertEquals(false, type.hashCode() == PeriodType.standard().hashCode());\n+        assertSameAfterSerialization(type);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testSeconds() throws Exception {\n+        PeriodType type = PeriodType.seconds();\n+        assertEquals(1, type.size());\n+        assertEquals(DurationFieldType.seconds(), type.getFieldType(0));\n+        assertEquals(\"Seconds\", type.getName());\n+        assertEquals(\"PeriodType[Seconds]\", type.toString());\n+        assertEquals(true, type.equals(type));\n+        assertEquals(true, type == PeriodType.seconds());\n+        assertEquals(false, type.equals(PeriodType.standard()));\n+        assertEquals(true, type.hashCode() == type.hashCode());\n+        assertEquals(true, type.hashCode() == PeriodType.seconds().hashCode());\n+        assertEquals(false, type.hashCode() == PeriodType.standard().hashCode());\n+        assertSameAfterSerialization(type);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testMillis() throws Exception {\n+        PeriodType type = PeriodType.millis();\n+        assertEquals(1, type.size());\n+        assertEquals(DurationFieldType.millis(), type.getFieldType(0));\n+        assertEquals(\"Millis\", type.getName());\n+        assertEquals(\"PeriodType[Millis]\", type.toString());\n+        assertEquals(true, type.equals(type));\n+        assertEquals(true, type == PeriodType.millis());\n+        assertEquals(false, type.equals(PeriodType.standard()));\n+        assertEquals(true, type.hashCode() == type.hashCode());\n+        assertEquals(true, type.hashCode() == PeriodType.millis().hashCode());\n+        assertEquals(false, type.hashCode() == PeriodType.standard().hashCode());\n+        assertSameAfterSerialization(type);\n     }\n \n     //-----------------------------------------------------------------------\n     public void testMaskYears() throws Exception {\n-        PeriodType type = PeriodType.getPreciseAllType().withYearsRemoved();\n-        assertEquals(false, type.years().isSupported());\n-        assertEquals(true, type.months().isSupported());\n-        assertEquals(true, type.weeks().isSupported());\n-        assertEquals(true, type.days().isSupported());\n-        assertEquals(true, type.hours().isSupported());\n-        assertEquals(true, type.minutes().isSupported());\n-        assertEquals(true, type.seconds().isSupported());\n-        assertEquals(true, type.millis().isSupported());\n-        assertEquals(true, type.isPrecise());\n-        assertEquals(ISOChronology.getInstanceUTC(), type.getChronology());\n-        assertEquals(true, type.equals(type));\n-        assertEquals(true, type.equals(PeriodType.getPreciseAllType().withYearsRemoved()));\n-        assertEquals(false, type.equals(PeriodType.getMillisType()));\n-        assertEquals(true, type.hashCode() == type.hashCode());\n-        assertEquals(true, type.hashCode() == PeriodType.getPreciseAllType().withYearsRemoved().hashCode());\n-        assertEquals(false, type.hashCode() == PeriodType.getMillisType().hashCode());\n-        assertEquals(\"MaskedYears[PreciseAllType]\", type.getName());\n-        assertEquals(\"PeriodType[MaskedYears[PreciseAllType]]\", type.toString());\n+        PeriodType type = PeriodType.standard().withYearsRemoved();\n+        assertEquals(7, type.size());\n+        assertEquals(DurationFieldType.months(), type.getFieldType(0));\n+        assertEquals(DurationFieldType.weeks(), type.getFieldType(1));\n+        assertEquals(DurationFieldType.days(), type.getFieldType(2));\n+        assertEquals(DurationFieldType.hours(), type.getFieldType(3));\n+        assertEquals(DurationFieldType.minutes(), type.getFieldType(4));\n+        assertEquals(DurationFieldType.seconds(), type.getFieldType(5));\n+        assertEquals(DurationFieldType.millis(), type.getFieldType(6));\n+        assertEquals(true, type.equals(type));\n+        assertEquals(true, type.equals(PeriodType.standard().withYearsRemoved()));\n+        assertEquals(false, type.equals(PeriodType.millis()));\n+        assertEquals(true, type.hashCode() == type.hashCode());\n+        assertEquals(true, type.hashCode() == PeriodType.standard().withYearsRemoved().hashCode());\n+        assertEquals(false, type.hashCode() == PeriodType.millis().hashCode());\n+        assertEquals(\"StandardNoYears\", type.getName());\n+        assertEquals(\"PeriodType[StandardNoYears]\", type.toString());\n         assertEqualsAfterSerialization(type);\n     }\n \n     //-----------------------------------------------------------------------\n     public void testMaskMonths() throws Exception {\n-        PeriodType type = PeriodType.getPreciseAllType().withMonthsRemoved();\n-        assertEquals(true, type.years().isSupported());\n-        assertEquals(false, type.months().isSupported());\n-        assertEquals(true, type.weeks().isSupported());\n-        assertEquals(true, type.days().isSupported());\n-        assertEquals(true, type.hours().isSupported());\n-        assertEquals(true, type.minutes().isSupported());\n-        assertEquals(true, type.seconds().isSupported());\n-        assertEquals(true, type.millis().isSupported());\n-        assertEquals(true, type.isPrecise());\n-        assertEquals(ISOChronology.getInstanceUTC(), type.getChronology());\n-        assertEquals(true, type.equals(type));\n-        assertEquals(true, type.equals(PeriodType.getPreciseAllType().withMonthsRemoved()));\n-        assertEquals(false, type.equals(PeriodType.getMillisType()));\n-        assertEquals(true, type.hashCode() == type.hashCode());\n-        assertEquals(true, type.hashCode() == PeriodType.getPreciseAllType().withMonthsRemoved().hashCode());\n-        assertEquals(false, type.hashCode() == PeriodType.getMillisType().hashCode());\n-        assertEquals(\"MaskedMonths[PreciseAllType]\", type.getName());\n-        assertEquals(\"PeriodType[MaskedMonths[PreciseAllType]]\", type.toString());\n+        PeriodType type = PeriodType.standard().withMonthsRemoved();\n+        assertEquals(7, type.size());\n+        assertEquals(DurationFieldType.years(), type.getFieldType(0));\n+        assertEquals(DurationFieldType.weeks(), type.getFieldType(1));\n+        assertEquals(DurationFieldType.days(), type.getFieldType(2));\n+        assertEquals(DurationFieldType.hours(), type.getFieldType(3));\n+        assertEquals(DurationFieldType.minutes(), type.getFieldType(4));\n+        assertEquals(DurationFieldType.seconds(), type.getFieldType(5));\n+        assertEquals(DurationFieldType.millis(), type.getFieldType(6));\n+        assertEquals(true, type.equals(type));\n+        assertEquals(true, type.equals(PeriodType.standard().withMonthsRemoved()));\n+        assertEquals(false, type.equals(PeriodType.millis()));\n+        assertEquals(true, type.hashCode() == type.hashCode());\n+        assertEquals(true, type.hashCode() == PeriodType.standard().withMonthsRemoved().hashCode());\n+        assertEquals(false, type.hashCode() == PeriodType.millis().hashCode());\n+        assertEquals(\"StandardNoMonths\", type.getName());\n+        assertEquals(\"PeriodType[StandardNoMonths]\", type.toString());\n         assertEqualsAfterSerialization(type);\n     }\n \n     //-----------------------------------------------------------------------\n     public void testMaskWeeks() throws Exception {\n-        PeriodType type = PeriodType.getPreciseAllType().withWeeksRemoved();\n-        assertEquals(true, type.years().isSupported());\n-        assertEquals(true, type.months().isSupported());\n-        assertEquals(false, type.weeks().isSupported());\n-        assertEquals(true, type.days().isSupported());\n-        assertEquals(true, type.hours().isSupported());\n-        assertEquals(true, type.minutes().isSupported());\n-        assertEquals(true, type.seconds().isSupported());\n-        assertEquals(true, type.millis().isSupported());\n-        assertEquals(true, type.isPrecise());\n-        assertEquals(ISOChronology.getInstanceUTC(), type.getChronology());\n-        assertEquals(true, type.equals(type));\n-        assertEquals(true, type.equals(PeriodType.getPreciseAllType().withWeeksRemoved()));\n-        assertEquals(false, type.equals(PeriodType.getMillisType()));\n-        assertEquals(true, type.hashCode() == type.hashCode());\n-        assertEquals(true, type.hashCode() == PeriodType.getPreciseAllType().withWeeksRemoved().hashCode());\n-        assertEquals(false, type.hashCode() == PeriodType.getMillisType().hashCode());\n-        assertEquals(\"MaskedWeeks[PreciseAllType]\", type.getName());\n-        assertEquals(\"PeriodType[MaskedWeeks[PreciseAllType]]\", type.toString());\n+        PeriodType type = PeriodType.standard().withWeeksRemoved();\n+        assertEquals(7, type.size());\n+        assertEquals(DurationFieldType.years(), type.getFieldType(0));\n+        assertEquals(DurationFieldType.months(), type.getFieldType(1));\n+        assertEquals(DurationFieldType.days(), type.getFieldType(2));\n+        assertEquals(DurationFieldType.hours(), type.getFieldType(3));\n+        assertEquals(DurationFieldType.minutes(), type.getFieldType(4));\n+        assertEquals(DurationFieldType.seconds(), type.getFieldType(5));\n+        assertEquals(DurationFieldType.millis(), type.getFieldType(6));\n+        assertEquals(true, type.equals(type));\n+        assertEquals(true, type.equals(PeriodType.standard().withWeeksRemoved()));\n+        assertEquals(false, type.equals(PeriodType.millis()));\n+        assertEquals(true, type.hashCode() == type.hashCode());\n+        assertEquals(true, type.hashCode() == PeriodType.standard().withWeeksRemoved().hashCode());\n+        assertEquals(false, type.hashCode() == PeriodType.millis().hashCode());\n+        assertEquals(\"StandardNoWeeks\", type.getName());\n+        assertEquals(\"PeriodType[StandardNoWeeks]\", type.toString());\n         assertEqualsAfterSerialization(type);\n     }\n \n     //-----------------------------------------------------------------------\n     public void testMaskDays() throws Exception {\n-        PeriodType type = PeriodType.getPreciseAllType().withDaysRemoved();\n-        assertEquals(true, type.years().isSupported());\n-        assertEquals(true, type.months().isSupported());\n-        assertEquals(true, type.weeks().isSupported());\n-        assertEquals(false, type.days().isSupported());\n-        assertEquals(true, type.hours().isSupported());\n-        assertEquals(true, type.minutes().isSupported());\n-        assertEquals(true, type.seconds().isSupported());\n-        assertEquals(true, type.millis().isSupported());\n-        assertEquals(true, type.isPrecise());\n-        assertEquals(ISOChronology.getInstanceUTC(), type.getChronology());\n-        assertEquals(true, type.equals(type));\n-        assertEquals(true, type.equals(PeriodType.getPreciseAllType().withDaysRemoved()));\n-        assertEquals(false, type.equals(PeriodType.getMillisType()));\n-        assertEquals(true, type.hashCode() == type.hashCode());\n-        assertEquals(true, type.hashCode() == PeriodType.getPreciseAllType().withDaysRemoved().hashCode());\n-        assertEquals(false, type.hashCode() == PeriodType.getMillisType().hashCode());\n-        assertEquals(\"MaskedDays[PreciseAllType]\", type.getName());\n-        assertEquals(\"PeriodType[MaskedDays[PreciseAllType]]\", type.toString());\n+        PeriodType type = PeriodType.standard().withDaysRemoved();\n+        assertEquals(7, type.size());\n+        assertEquals(DurationFieldType.years(), type.getFieldType(0));\n+        assertEquals(DurationFieldType.months(), type.getFieldType(1));\n+        assertEquals(DurationFieldType.weeks(), type.getFieldType(2));\n+        assertEquals(DurationFieldType.hours(), type.getFieldType(3));\n+        assertEquals(DurationFieldType.minutes(), type.getFieldType(4));\n+        assertEquals(DurationFieldType.seconds(), type.getFieldType(5));\n+        assertEquals(DurationFieldType.millis(), type.getFieldType(6));\n+        assertEquals(true, type.equals(type));\n+        assertEquals(true, type.equals(PeriodType.standard().withDaysRemoved()));\n+        assertEquals(false, type.equals(PeriodType.millis()));\n+        assertEquals(true, type.hashCode() == type.hashCode());\n+        assertEquals(true, type.hashCode() == PeriodType.standard().withDaysRemoved().hashCode());\n+        assertEquals(false, type.hashCode() == PeriodType.millis().hashCode());\n+        assertEquals(\"StandardNoDays\", type.getName());\n+        assertEquals(\"PeriodType[StandardNoDays]\", type.toString());\n         assertEqualsAfterSerialization(type);\n     }\n \n     //-----------------------------------------------------------------------\n     public void testMaskHours() throws Exception {\n-        PeriodType type = PeriodType.getPreciseAllType().withHoursRemoved();\n-        assertEquals(true, type.years().isSupported());\n-        assertEquals(true, type.months().isSupported());\n-        assertEquals(true, type.weeks().isSupported());\n-        assertEquals(true, type.days().isSupported());\n-        assertEquals(false, type.hours().isSupported());\n-        assertEquals(true, type.minutes().isSupported());\n-        assertEquals(true, type.seconds().isSupported());\n-        assertEquals(true, type.millis().isSupported());\n-        assertEquals(true, type.isPrecise());\n-        assertEquals(ISOChronology.getInstanceUTC(), type.getChronology());\n-        assertEquals(true, type.equals(type));\n-        assertEquals(true, type.equals(PeriodType.getPreciseAllType().withHoursRemoved()));\n-        assertEquals(false, type.equals(PeriodType.getMillisType()));\n-        assertEquals(true, type.hashCode() == type.hashCode());\n-        assertEquals(true, type.hashCode() == PeriodType.getPreciseAllType().withHoursRemoved().hashCode());\n-        assertEquals(false, type.hashCode() == PeriodType.getMillisType().hashCode());\n-        assertEquals(\"MaskedHours[PreciseAllType]\", type.getName());\n-        assertEquals(\"PeriodType[MaskedHours[PreciseAllType]]\", type.toString());\n+        PeriodType type = PeriodType.standard().withHoursRemoved();\n+        assertEquals(7, type.size());\n+        assertEquals(DurationFieldType.years(), type.getFieldType(0));\n+        assertEquals(DurationFieldType.months(), type.getFieldType(1));\n+        assertEquals(DurationFieldType.weeks(), type.getFieldType(2));\n+        assertEquals(DurationFieldType.days(), type.getFieldType(3));\n+        assertEquals(DurationFieldType.minutes(), type.getFieldType(4));\n+        assertEquals(DurationFieldType.seconds(), type.getFieldType(5));\n+        assertEquals(DurationFieldType.millis(), type.getFieldType(6));\n+        assertEquals(true, type.equals(type));\n+        assertEquals(true, type.equals(PeriodType.standard().withHoursRemoved()));\n+        assertEquals(false, type.equals(PeriodType.millis()));\n+        assertEquals(true, type.hashCode() == type.hashCode());\n+        assertEquals(true, type.hashCode() == PeriodType.standard().withHoursRemoved().hashCode());\n+        assertEquals(false, type.hashCode() == PeriodType.millis().hashCode());\n+        assertEquals(\"StandardNoHours\", type.getName());\n+        assertEquals(\"PeriodType[StandardNoHours]\", type.toString());\n         assertEqualsAfterSerialization(type);\n     }\n \n     //-----------------------------------------------------------------------\n     public void testMaskMinutes() throws Exception {\n-        PeriodType type = PeriodType.getPreciseAllType().withMinutesRemoved();\n-        assertEquals(true, type.years().isSupported());\n-        assertEquals(true, type.months().isSupported());\n-        assertEquals(true, type.weeks().isSupported());\n-        assertEquals(true, type.days().isSupported());\n-        assertEquals(true, type.hours().isSupported());\n-        assertEquals(false, type.minutes().isSupported());\n-        assertEquals(true, type.seconds().isSupported());\n-        assertEquals(true, type.millis().isSupported());\n-        assertEquals(true, type.isPrecise());\n-        assertEquals(ISOChronology.getInstanceUTC(), type.getChronology());\n-        assertEquals(true, type.equals(type));\n-        assertEquals(true, type.equals(PeriodType.getPreciseAllType().withMinutesRemoved()));\n-        assertEquals(false, type.equals(PeriodType.getMillisType()));\n-        assertEquals(true, type.hashCode() == type.hashCode());\n-        assertEquals(true, type.hashCode() == PeriodType.getPreciseAllType().withMinutesRemoved().hashCode());\n-        assertEquals(false, type.hashCode() == PeriodType.getMillisType().hashCode());\n-        assertEquals(\"MaskedMinutes[PreciseAllType]\", type.getName());\n-        assertEquals(\"PeriodType[MaskedMinutes[PreciseAllType]]\", type.toString());\n+        PeriodType type = PeriodType.standard().withMinutesRemoved();\n+        assertEquals(7, type.size());\n+        assertEquals(DurationFieldType.years(), type.getFieldType(0));\n+        assertEquals(DurationFieldType.months(), type.getFieldType(1));\n+        assertEquals(DurationFieldType.weeks(), type.getFieldType(2));\n+        assertEquals(DurationFieldType.days(), type.getFieldType(3));\n+        assertEquals(DurationFieldType.hours(), type.getFieldType(4));\n+        assertEquals(DurationFieldType.seconds(), type.getFieldType(5));\n+        assertEquals(DurationFieldType.millis(), type.getFieldType(6));\n+        assertEquals(true, type.equals(type));\n+        assertEquals(true, type.equals(PeriodType.standard().withMinutesRemoved()));\n+        assertEquals(false, type.equals(PeriodType.millis()));\n+        assertEquals(true, type.hashCode() == type.hashCode());\n+        assertEquals(true, type.hashCode() == PeriodType.standard().withMinutesRemoved().hashCode());\n+        assertEquals(false, type.hashCode() == PeriodType.millis().hashCode());\n+        assertEquals(\"StandardNoMinutes\", type.getName());\n+        assertEquals(\"PeriodType[StandardNoMinutes]\", type.toString());\n         assertEqualsAfterSerialization(type);\n     }\n \n     //-----------------------------------------------------------------------\n     public void testMaskSeconds() throws Exception {\n-        PeriodType type = PeriodType.getPreciseAllType().withSecondsRemoved();\n-        assertEquals(true, type.years().isSupported());\n-        assertEquals(true, type.months().isSupported());\n-        assertEquals(true, type.weeks().isSupported());\n-        assertEquals(true, type.days().isSupported());\n-        assertEquals(true, type.hours().isSupported());\n-        assertEquals(true, type.minutes().isSupported());\n-        assertEquals(false, type.seconds().isSupported());\n-        assertEquals(true, type.millis().isSupported());\n-        assertEquals(true, type.isPrecise());\n-        assertEquals(ISOChronology.getInstanceUTC(), type.getChronology());\n-        assertEquals(true, type.equals(type));\n-        assertEquals(true, type.equals(PeriodType.getPreciseAllType().withSecondsRemoved()));\n-        assertEquals(false, type.equals(PeriodType.getMillisType()));\n-        assertEquals(true, type.hashCode() == type.hashCode());\n-        assertEquals(true, type.hashCode() == PeriodType.getPreciseAllType().withSecondsRemoved().hashCode());\n-        assertEquals(false, type.hashCode() == PeriodType.getMillisType().hashCode());\n-        assertEquals(\"MaskedSeconds[PreciseAllType]\", type.getName());\n-        assertEquals(\"PeriodType[MaskedSeconds[PreciseAllType]]\", type.toString());\n+        PeriodType type = PeriodType.standard().withSecondsRemoved();\n+        assertEquals(7, type.size());\n+        assertEquals(DurationFieldType.years(), type.getFieldType(0));\n+        assertEquals(DurationFieldType.months(), type.getFieldType(1));\n+        assertEquals(DurationFieldType.weeks(), type.getFieldType(2));\n+        assertEquals(DurationFieldType.days(), type.getFieldType(3));\n+        assertEquals(DurationFieldType.hours(), type.getFieldType(4));\n+        assertEquals(DurationFieldType.minutes(), type.getFieldType(5));\n+        assertEquals(DurationFieldType.millis(), type.getFieldType(6));\n+        assertEquals(true, type.equals(type));\n+        assertEquals(true, type.equals(PeriodType.standard().withSecondsRemoved()));\n+        assertEquals(false, type.equals(PeriodType.millis()));\n+        assertEquals(true, type.hashCode() == type.hashCode());\n+        assertEquals(true, type.hashCode() == PeriodType.standard().withSecondsRemoved().hashCode());\n+        assertEquals(false, type.hashCode() == PeriodType.millis().hashCode());\n+        assertEquals(\"StandardNoSeconds\", type.getName());\n+        assertEquals(\"PeriodType[StandardNoSeconds]\", type.toString());\n         assertEqualsAfterSerialization(type);\n     }\n \n     //-----------------------------------------------------------------------\n     public void testMaskMillis() throws Exception {\n-        PeriodType type = PeriodType.getPreciseAllType().withMillisRemoved();\n-        assertEquals(true, type.years().isSupported());\n-        assertEquals(true, type.months().isSupported());\n-        assertEquals(true, type.weeks().isSupported());\n-        assertEquals(true, type.days().isSupported());\n-        assertEquals(true, type.hours().isSupported());\n-        assertEquals(true, type.minutes().isSupported());\n-        assertEquals(true, type.seconds().isSupported());\n-        assertEquals(false, type.millis().isSupported());\n-        assertEquals(true, type.isPrecise());\n-        assertEquals(ISOChronology.getInstanceUTC(), type.getChronology());\n-        assertEquals(true, type.equals(type));\n-        assertEquals(true, type.equals(PeriodType.getPreciseAllType().withMillisRemoved()));\n-        assertEquals(false, type.equals(PeriodType.getMillisType()));\n-        assertEquals(true, type.hashCode() == type.hashCode());\n-        assertEquals(true, type.hashCode() == PeriodType.getPreciseAllType().withMillisRemoved().hashCode());\n-        assertEquals(false, type.hashCode() == PeriodType.getMillisType().hashCode());\n-        assertEquals(\"MaskedMillis[PreciseAllType]\", type.getName());\n-        assertEquals(\"PeriodType[MaskedMillis[PreciseAllType]]\", type.toString());\n+        PeriodType type = PeriodType.standard().withMillisRemoved();\n+        assertEquals(7, type.size());\n+        assertEquals(DurationFieldType.years(), type.getFieldType(0));\n+        assertEquals(DurationFieldType.months(), type.getFieldType(1));\n+        assertEquals(DurationFieldType.weeks(), type.getFieldType(2));\n+        assertEquals(DurationFieldType.days(), type.getFieldType(3));\n+        assertEquals(DurationFieldType.hours(), type.getFieldType(4));\n+        assertEquals(DurationFieldType.minutes(), type.getFieldType(5));\n+        assertEquals(DurationFieldType.seconds(), type.getFieldType(6));\n+        assertEquals(true, type.equals(type));\n+        assertEquals(true, type.equals(PeriodType.standard().withMillisRemoved()));\n+        assertEquals(false, type.equals(PeriodType.millis()));\n+        assertEquals(true, type.hashCode() == type.hashCode());\n+        assertEquals(true, type.hashCode() == PeriodType.standard().withMillisRemoved().hashCode());\n+        assertEquals(false, type.hashCode() == PeriodType.millis().hashCode());\n+        assertEquals(\"StandardNoMillis\", type.getName());\n+        assertEquals(\"PeriodType[StandardNoMillis]\", type.toString());\n         assertEqualsAfterSerialization(type);\n     }\n \n     //-----------------------------------------------------------------------\n     public void testMaskHoursMinutesSeconds() throws Exception {\n-        PeriodType type = PeriodType.getPreciseAllType().withHoursRemoved().withMinutesRemoved().withSecondsRemoved();\n-        assertEquals(true, type.years().isSupported());\n-        assertEquals(true, type.months().isSupported());\n-        assertEquals(true, type.weeks().isSupported());\n-        assertEquals(true, type.days().isSupported());\n-        assertEquals(false, type.hours().isSupported());\n-        assertEquals(false, type.minutes().isSupported());\n-        assertEquals(false, type.seconds().isSupported());\n-        assertEquals(true, type.millis().isSupported());\n-        assertEquals(true, type.isPrecise());\n-        assertEquals(ISOChronology.getInstanceUTC(), type.getChronology());\n-        assertEquals(true, type.equals(type));\n-        assertEquals(true, type.equals(PeriodType.getPreciseAllType().withHoursRemoved().withMinutesRemoved().withSecondsRemoved()));\n-        assertEquals(false, type.equals(PeriodType.getMillisType()));\n-        assertEquals(true, type.hashCode() == type.hashCode());\n-        assertEquals(true, type.hashCode() == PeriodType.getPreciseAllType().withHoursRemoved().withMinutesRemoved().withSecondsRemoved().hashCode());\n-        assertEquals(false, type.hashCode() == PeriodType.getMillisType().hashCode());\n-        assertEquals(\"MaskedHoursMinutesSeconds[PreciseAllType]\", type.getName());\n-        assertEquals(\"PeriodType[MaskedHoursMinutesSeconds[PreciseAllType]]\", type.toString());\n-        assertEqualsAfterSerialization(type);\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    public void testMaskWithChronology() throws Exception {\n-        PeriodType type = PeriodType.getAllType().withYearsRemoved();\n-        assertEquals(type, type.withChronology(null));\n-        assertEquals(type, type.withChronology(ISOChronology.getInstance()));\n-        \n-        PeriodType type2 = type.withChronology(CopticChronology.getInstanceUTC());\n-        assertEquals(CopticChronology.getInstanceUTC(), type2.getChronology());\n-        assertEquals(false, type2.years().isSupported());\n-        assertEquals(true, type2.months().isSupported());\n-        assertEquals(true, type2.weeks().isSupported());\n-        assertEquals(true, type2.days().isSupported());\n-        assertEquals(true, type2.hours().isSupported());\n-        assertEquals(true, type2.minutes().isSupported());\n-        assertEquals(true, type2.seconds().isSupported());\n-        assertEquals(true, type2.millis().isSupported());\n+        PeriodType type = PeriodType.standard().withHoursRemoved().withMinutesRemoved().withSecondsRemoved();\n+        assertEquals(5, type.size());\n+        assertEquals(DurationFieldType.years(), type.getFieldType(0));\n+        assertEquals(DurationFieldType.months(), type.getFieldType(1));\n+        assertEquals(DurationFieldType.weeks(), type.getFieldType(2));\n+        assertEquals(DurationFieldType.days(), type.getFieldType(3));\n+        assertEquals(DurationFieldType.millis(), type.getFieldType(4));\n+        assertEquals(true, type.equals(type));\n+        assertEquals(true, type.equals(PeriodType.standard().withHoursRemoved().withMinutesRemoved().withSecondsRemoved()));\n+        assertEquals(false, type.equals(PeriodType.millis()));\n+        assertEquals(true, type.hashCode() == type.hashCode());\n+        assertEquals(true, type.hashCode() == PeriodType.standard().withHoursRemoved().withMinutesRemoved().withSecondsRemoved().hashCode());\n+        assertEquals(false, type.hashCode() == PeriodType.millis().hashCode());\n+        assertEquals(\"StandardNoHoursNoMinutesNoSeconds\", type.getName());\n+        assertEquals(\"PeriodType[StandardNoHoursNoMinutesNoSeconds]\", type.toString());\n+        assertEqualsAfterSerialization(type);\n     }\n \n     //-----------------------------------------------------------------------\n     public void testMaskTwice1() throws Exception {\n-        PeriodType type = PeriodType.getPreciseAllType().withYearsRemoved();\n+        PeriodType type = PeriodType.standard().withYearsRemoved();\n         PeriodType type2 = type.withYearsRemoved();\n         assertEquals(true, type == type2);\n         \n-        type = PeriodType.getPreciseAllType().withMonthsRemoved();\n+        type = PeriodType.standard().withMonthsRemoved();\n         type2 = type.withMonthsRemoved();\n         assertEquals(true, type == type2);\n         \n-        type = PeriodType.getPreciseAllType().withWeeksRemoved();\n+        type = PeriodType.standard().withWeeksRemoved();\n         type2 = type.withWeeksRemoved();\n         assertEquals(true, type == type2);\n         \n-        type = PeriodType.getPreciseAllType().withDaysRemoved();\n+        type = PeriodType.standard().withDaysRemoved();\n         type2 = type.withDaysRemoved();\n         assertEquals(true, type == type2);\n         \n-        type = PeriodType.getPreciseAllType().withHoursRemoved();\n+        type = PeriodType.standard().withHoursRemoved();\n         type2 = type.withHoursRemoved();\n         assertEquals(true, type == type2);\n         \n-        type = PeriodType.getPreciseAllType().withMinutesRemoved();\n+        type = PeriodType.standard().withMinutesRemoved();\n         type2 = type.withMinutesRemoved();\n         assertEquals(true, type == type2);\n         \n-        type = PeriodType.getPreciseAllType().withSecondsRemoved();\n+        type = PeriodType.standard().withSecondsRemoved();\n         type2 = type.withSecondsRemoved();\n         assertEquals(true, type == type2);\n         \n-        type = PeriodType.getPreciseAllType().withMillisRemoved();\n+        type = PeriodType.standard().withMillisRemoved();\n         type2 = type.withMillisRemoved();\n         assertEquals(true, type == type2);\n     }\n \n     //-----------------------------------------------------------------------\n     public void testMaskTwice2() throws Exception {\n-        PeriodType type = PeriodType.getDayHourType();\n+        PeriodType type = PeriodType.dayTime();\n         PeriodType type2 = type.withYearsRemoved();\n         assertEquals(true, type == type2);\n         \n-        type = PeriodType.getDayHourType();\n+        type = PeriodType.dayTime();\n         type2 = type.withMonthsRemoved();\n         assertEquals(true, type == type2);\n         \n-        type = PeriodType.getDayHourType();\n+        type = PeriodType.dayTime();\n         type2 = type.withWeeksRemoved();\n         assertEquals(true, type == type2);\n         \n-        type = PeriodType.getMillisType();\n+        type = PeriodType.millis();\n         type2 = type.withDaysRemoved();\n         assertEquals(true, type == type2);\n         \n-        type = PeriodType.getMillisType();\n+        type = PeriodType.millis();\n         type2 = type.withHoursRemoved();\n         assertEquals(true, type == type2);\n         \n-        type = PeriodType.getMillisType();\n+        type = PeriodType.millis();\n         type2 = type.withMinutesRemoved();\n         assertEquals(true, type == type2);\n         \n-        type = PeriodType.getMillisType();\n+        type = PeriodType.millis();\n         type2 = type.withSecondsRemoved();\n         assertEquals(true, type == type2);\n     }\n \n     //-----------------------------------------------------------------------\n-    public void testMaskNullName() throws Exception {\n-        PeriodType type = new MockPeriodTypeWithFields().withYearsRemoved();\n-        assertEquals(\"MaskedYears[]\", type.getName());\n-        assertEquals(\"PeriodType[MaskedYears[]]\", type.toString());\n-    }        \n-\n-    //-----------------------------------------------------------------------\n     public void testHashCode() throws Exception {\n-        PeriodType type = new MockPeriodType();\n+        PeriodType type = PeriodType.dayTime().withMillisRemoved();\n         assertEquals(type.hashCode(), type.hashCode());\n     }\n \n     //-----------------------------------------------------------------------\n-    public void testAbstract() throws Exception {\n-        assertEquals(true, Modifier.isPublic(PeriodType.class.getModifiers()));\n-        assertEquals(true, Modifier.isAbstract(PeriodType.class.getModifiers()));\n-        \n-        PeriodType type = new MockPeriodType();\n-        assertEquals(false, type.years().isSupported());\n-        assertEquals(false, type.months().isSupported());\n-        assertEquals(false, type.weeks().isSupported());\n-        assertEquals(false, type.days().isSupported());\n-        assertEquals(false, type.hours().isSupported());\n-        assertEquals(false, type.minutes().isSupported());\n-        assertEquals(false, type.seconds().isSupported());\n-        assertEquals(false, type.millis().isSupported());\n-        assertEquals(false, type.isPrecise());\n-        assertEquals(null, type.getChronology());\n-        assertEquals(true, type.equals(type));\n-        assertEquals(true, type.equals(new MockPeriodType()));\n-        assertEquals(false, type.equals(PeriodType.getAllType()));\n-        assertEquals(false, type.equals(null));\n-        assertEquals(false, type.equals(\"six\"));\n-        assertEquals(null, type.getName());\n-        assertEquals(\"PeriodType[]\", type.toString());\n-    }\n-\n-    static class MockPeriodType extends PeriodType {\n-        public String getName() {\n-            return null;\n-        }\n-        public Chronology getChronology() {\n-            return null;\n-        }\n-        public PeriodType withChronology(Chronology chrono) {\n-            return null;\n-        }\n-        public boolean isPrecise() {\n-            return false;\n-        }\n-    }\n-\n-    static class MockPeriodTypeWithFields extends PeriodType {\n-        public String getName() {\n-            return null;\n-        }\n-        public Chronology getChronology() {\n-            return null;\n-        }\n-        public DurationField years() {\n-            return ISOChronology.getInstanceUTC().years();\n-        }\n-        public DurationField months() {\n-            return ISOChronology.getInstanceUTC().months();\n-        }\n-        public PeriodType withChronology(Chronology chrono) {\n-            return null;\n-        }\n-        public boolean isPrecise() {\n-            return false;\n-        }\n+    public void testIsSupported() throws Exception {\n+        PeriodType type = PeriodType.dayTime().withMillisRemoved();\n+        assertEquals(false, type.isSupported(DurationFieldType.years()));\n+        assertEquals(false, type.isSupported(DurationFieldType.months()));\n+        assertEquals(false, type.isSupported(DurationFieldType.weeks()));\n+        assertEquals(true, type.isSupported(DurationFieldType.days()));\n+        assertEquals(true, type.isSupported(DurationFieldType.hours()));\n+        assertEquals(true, type.isSupported(DurationFieldType.minutes()));\n+        assertEquals(true, type.isSupported(DurationFieldType.seconds()));\n+        assertEquals(false, type.isSupported(DurationFieldType.millis()));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testIndexOf() throws Exception {\n+        PeriodType type = PeriodType.dayTime().withMillisRemoved();\n+        assertEquals(-1, type.indexOf(DurationFieldType.years()));\n+        assertEquals(-1, type.indexOf(DurationFieldType.months()));\n+        assertEquals(-1, type.indexOf(DurationFieldType.weeks()));\n+        assertEquals(0, type.indexOf(DurationFieldType.days()));\n+        assertEquals(1, type.indexOf(DurationFieldType.hours()));\n+        assertEquals(2, type.indexOf(DurationFieldType.minutes()));\n+        assertEquals(3, type.indexOf(DurationFieldType.seconds()));\n+        assertEquals(-1, type.indexOf(DurationFieldType.millis()));\n     }\n \n }\n--- a/JodaTime/src/test/org/joda/time/TestPeriod_Basics.java\n+++ b/JodaTime/src/test/org/joda/time/TestPeriod_Basics.java\n     //-----------------------------------------------------------------------\n     public void testGetPeriodType() {\n         Period test = new Period(0L);\n-        assertEquals(PeriodType.getAllType(), test.getPeriodType());\n-    }\n-\n-    public void testGetIsPrecise() {\n-        Period test = new Period(123L);\n-        assertEquals(true, test.isPrecise());\n-        test = new Period(1, 2, 3, 4, 5, 6, 7, 8);\n-        assertEquals(false, test.isPrecise());\n+        assertEquals(PeriodType.standard(), test.getPeriodType());\n     }\n \n     public void testGetMethods() {\n         \n         assertEquals(false, test1.equals(\"Hello\"));\n         assertEquals(true, test1.equals(new MockPeriod(123L)));\n-        assertEquals(false, test1.equals(new Period(123L, PeriodType.getDayHourType())));\n+        assertEquals(false, test1.equals(new Period(123L, PeriodType.dayTime())));\n     }\n     \n     class MockPeriod extends BasePeriod {\n         public MockPeriod(long value) {\n-            super(value, null);\n+            super(value, null, null);\n         }\n     }\n \n     \n     public void testAddTo3() {\n         long expected = TEST_TIME_NOW;\n+        Period test = new Period(1, 2, 3, 4, 5, 6, 7, 8);\n+        long added = test.addTo(TEST_TIME_NOW, 0);\n+        assertEquals(expected, added);\n+    }\n+    \n+    public void testAddTo4() {\n+        long expected = TEST_TIME_NOW + 100L;\n+        Period test = new Period(100L);\n+        long added = test.addTo(TEST_TIME_NOW, 1);\n+        assertEquals(expected, added);\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testAddToWithChronology1() {\n+        long expected = TEST_TIME_NOW;\n+        expected = ISOChronology.getInstance().years().add(expected, 1);\n+        expected = ISOChronology.getInstance().months().add(expected, 2);\n+        expected = ISOChronology.getInstance().weeks().add(expected, 3);\n+        expected = ISOChronology.getInstance().days().add(expected, 4);\n+        expected = ISOChronology.getInstance().hours().add(expected, 5);\n+        expected = ISOChronology.getInstance().minutes().add(expected, 6);\n+        expected = ISOChronology.getInstance().seconds().add(expected, 7);\n+        expected = ISOChronology.getInstance().millis().add(expected, 8);\n+        \n+        Period test = new Period(1, 2, 3, 4, 5, 6, 7, 8);\n+        long added = test.addTo(TEST_TIME_NOW, 1, ISOChronology.getInstance());\n+        assertEquals(expected, added);\n+    }\n+    \n+    public void testAddToWithChronology2() {\n+        long expected = TEST_TIME_NOW;\n         expected = ISOChronology.getInstanceUTC().years().add(expected, -2);\n         expected = ISOChronology.getInstanceUTC().months().add(expected, -4);\n         expected = ISOChronology.getInstanceUTC().weeks().add(expected, -6);\n         expected = ISOChronology.getInstanceUTC().seconds().add(expected, -14);\n         expected = ISOChronology.getInstanceUTC().millis().add(expected, -16);\n         \n-        Period test = new Period(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.getAllType(ISOChronology.getInstanceUTC()));\n-        long added = test.addTo(TEST_TIME_NOW, -2);\n-        assertEquals(expected, added);\n-    }\n-    \n-    public void testAddTo4() {\n-        long expected = TEST_TIME_NOW;\n-        Period test = new Period(1, 2, 3, 4, 5, 6, 7, 8);\n-        long added = test.addTo(TEST_TIME_NOW, 0);\n-        assertEquals(expected, added);\n-    }\n-    \n-    public void testAddTo5() {\n-        long expected = TEST_TIME_NOW + 100L;\n-        Period test = new Period(100L);\n-        long added = test.addTo(TEST_TIME_NOW, 1);\n-        assertEquals(expected, added);\n-    }\n-    \n-    //-----------------------------------------------------------------------\n-    public void testAddToWithChronology1() {\n+        Period test = new Period(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.standard());\n+        long added = test.addTo(TEST_TIME_NOW, -2, ISOChronology.getInstanceUTC());  // local specified so use it\n+        assertEquals(expected, added);\n+    }\n+    \n+    public void testAddToWithChronology3() {\n+        long expected = TEST_TIME_NOW;\n+        expected = ISOChronology.getInstance().years().add(expected, -2);\n+        expected = ISOChronology.getInstance().months().add(expected, -4);\n+        expected = ISOChronology.getInstance().weeks().add(expected, -6);\n+        expected = ISOChronology.getInstance().days().add(expected, -8);\n+        expected = ISOChronology.getInstance().hours().add(expected, -10);\n+        expected = ISOChronology.getInstance().minutes().add(expected, -12);\n+        expected = ISOChronology.getInstance().seconds().add(expected, -14);\n+        expected = ISOChronology.getInstance().millis().add(expected, -16);\n+        \n+        Period test = new Period(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.standard());\n+        long added = test.addTo(TEST_TIME_NOW, -2, null);  // no chrono specified so use default\n+        assertEquals(expected, added);\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testAddToRI1() {\n         long expected = TEST_TIME_NOW;\n         expected = ISOChronology.getInstance().years().add(expected, 1);\n         expected = ISOChronology.getInstance().months().add(expected, 2);\n         expected = ISOChronology.getInstance().millis().add(expected, 8);\n         \n         Period test = new Period(1, 2, 3, 4, 5, 6, 7, 8);\n-        long added = test.addTo(TEST_TIME_NOW, 1, ISOChronology.getInstance());\n-        assertEquals(expected, added);\n-    }\n-    \n-    public void testAddToWithChronology2() {\n+        DateTime added = test.addTo(new Instant(), 1);  // Instant has no time zone, use default\n+        assertEquals(expected, added.getMillis());\n+        assertEquals(ISOChronology.getInstance(), added.getChronology());\n+    }\n+    \n+    public void testAddToRI2() {\n         long expected = TEST_TIME_NOW;\n         expected = ISOChronology.getInstance().years().add(expected, -2);\n         expected = ISOChronology.getInstance().months().add(expected, -4);\n         expected = ISOChronology.getInstance().seconds().add(expected, -14);\n         expected = ISOChronology.getInstance().millis().add(expected, -16);\n         \n-        Period test = new Period(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.getAllType(ISOChronology.getInstanceUTC()));\n-        long added = test.addTo(TEST_TIME_NOW, -2, ISOChronology.getInstance());  // local specified so use it\n-        assertEquals(expected, added);\n-    }\n-    \n-    public void testAddToWithChronology3() {\n+        Period test = new Period(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.standard());\n+        DateTime added = test.addTo(new Instant(), -2);  // Instant has no time zone, use default\n+        assertEquals(expected, added.getMillis());\n+        assertEquals(ISOChronology.getInstance(), added.getChronology());\n+    }\n+    \n+    public void testAddToRI3() {\n         long expected = TEST_TIME_NOW;\n         expected = ISOChronology.getInstanceUTC().years().add(expected, -2);\n         expected = ISOChronology.getInstanceUTC().months().add(expected, -4);\n         expected = ISOChronology.getInstanceUTC().seconds().add(expected, -14);\n         expected = ISOChronology.getInstanceUTC().millis().add(expected, -16);\n         \n-        Period test = new Period(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.getAllType(ISOChronology.getInstanceUTC()));\n-        long added = test.addTo(TEST_TIME_NOW, -2, null);  // no chrono specified so drop back to duration (UTC)\n-        assertEquals(expected, added);\n-    }\n-    \n-    //-----------------------------------------------------------------------\n-    public void testAddToRI1() {\n+        Period test = new Period(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.standard());\n+        DateTime added = test.addTo(new DateTime(ISOChronology.getInstanceUTC()), -2);  // DateTime has UTC time zone\n+        assertEquals(expected, added.getMillis());\n+        assertEquals(ISOChronology.getInstanceUTC(), added.getChronology());\n+    }\n+    \n+    public void testAddToRI4() {\n+        long expected = TEST_TIME_NOW;\n+        expected = ISOChronology.getInstance(PARIS).years().add(expected, -2);\n+        expected = ISOChronology.getInstance(PARIS).months().add(expected, -4);\n+        expected = ISOChronology.getInstance(PARIS).weeks().add(expected, -6);\n+        expected = ISOChronology.getInstance(PARIS).days().add(expected, -8);\n+        expected = ISOChronology.getInstance(PARIS).hours().add(expected, -10);\n+        expected = ISOChronology.getInstance(PARIS).minutes().add(expected, -12);\n+        expected = ISOChronology.getInstance(PARIS).seconds().add(expected, -14);\n+        expected = ISOChronology.getInstance(PARIS).millis().add(expected, -16);\n+        \n+        Period test = new Period(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.standard());\n+        DateTime added = test.addTo(new DateTime(PARIS), -2);  // DateTime has PARIS time zone\n+        assertEquals(expected, added.getMillis());\n+        assertEquals(ISOChronology.getInstance(PARIS), added.getChronology());\n+    }\n+    \n+    public void testAddToRI5() {\n+        long expected = TEST_TIME_NOW;\n+        expected = ISOChronology.getInstance().years().add(expected, -2);\n+        expected = ISOChronology.getInstance().months().add(expected, -4);\n+        expected = ISOChronology.getInstance().weeks().add(expected, -6);\n+        expected = ISOChronology.getInstance().days().add(expected, -8);\n+        expected = ISOChronology.getInstance().hours().add(expected, -10);\n+        expected = ISOChronology.getInstance().minutes().add(expected, -12);\n+        expected = ISOChronology.getInstance().seconds().add(expected, -14);\n+        expected = ISOChronology.getInstance().millis().add(expected, -16);\n+        \n+        Period test = new Period(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.standard());\n+        DateTime added = test.addTo(null, -2);  // null has no time zone, use default\n+        assertEquals(expected, added.getMillis());\n+        assertEquals(ISOChronology.getInstance(), added.getChronology());\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testAddIntoRWI1() {\n         long expected = TEST_TIME_NOW;\n         expected = ISOChronology.getInstance().years().add(expected, 1);\n         expected = ISOChronology.getInstance().months().add(expected, 2);\n         expected = ISOChronology.getInstance().millis().add(expected, 8);\n         \n         Period test = new Period(1, 2, 3, 4, 5, 6, 7, 8);\n-        DateTime added = test.addTo(new Instant(), 1);  // Instant has no time zone, uses duration's zone (local)\n-        assertEquals(expected, added.getMillis());\n-        assertEquals(ISOChronology.getInstance(), added.getChronology());\n-    }\n-    \n-    public void testAddToRI2() {\n-        long expected = TEST_TIME_NOW;\n-        expected = ISOChronology.getInstanceUTC().years().add(expected, -2);\n-        expected = ISOChronology.getInstanceUTC().months().add(expected, -4);\n-        expected = ISOChronology.getInstanceUTC().weeks().add(expected, -6);\n-        expected = ISOChronology.getInstanceUTC().days().add(expected, -8);\n-        expected = ISOChronology.getInstanceUTC().hours().add(expected, -10);\n-        expected = ISOChronology.getInstanceUTC().minutes().add(expected, -12);\n-        expected = ISOChronology.getInstanceUTC().seconds().add(expected, -14);\n-        expected = ISOChronology.getInstanceUTC().millis().add(expected, -16);\n-        \n-        Period test = new Period(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.getAllType(ISOChronology.getInstanceUTC()));\n-        DateTime added = test.addTo(new Instant(), -2);  // Instant has no time zone, uses duration's zone (UTC)\n-        assertEquals(expected, added.getMillis());\n-        assertEquals(ISOChronology.getInstance(), added.getChronology());\n-    }\n-    \n-    public void testAddToRI3() {\n+        MutableDateTime mdt = new MutableDateTime();\n+        test.addInto(mdt, 1);\n+        assertEquals(expected, mdt.getMillis());\n+    }\n+    \n+    public void testAddIntoRWI2() {\n         long expected = TEST_TIME_NOW;\n         expected = ISOChronology.getInstance().years().add(expected, -2);\n         expected = ISOChronology.getInstance().months().add(expected, -4);\n         expected = ISOChronology.getInstance().seconds().add(expected, -14);\n         expected = ISOChronology.getInstance().millis().add(expected, -16);\n         \n-        Period test = new Period(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.getAllType(ISOChronology.getInstanceUTC()));\n-        DateTime added = test.addTo(new DateTime(), -2);  // DateTime has local time zone\n-        assertEquals(expected, added.getMillis());\n-        assertEquals(ISOChronology.getInstance(), added.getChronology());\n-    }\n-    \n-    public void testAddToRI4() {\n-        long expected = TEST_TIME_NOW;\n-        expected = ISOChronology.getInstance(PARIS).years().add(expected, -2);\n-        expected = ISOChronology.getInstance(PARIS).months().add(expected, -4);\n-        expected = ISOChronology.getInstance(PARIS).weeks().add(expected, -6);\n-        expected = ISOChronology.getInstance(PARIS).days().add(expected, -8);\n-        expected = ISOChronology.getInstance(PARIS).hours().add(expected, -10);\n-        expected = ISOChronology.getInstance(PARIS).minutes().add(expected, -12);\n-        expected = ISOChronology.getInstance(PARIS).seconds().add(expected, -14);\n-        expected = ISOChronology.getInstance(PARIS).millis().add(expected, -16);\n-        \n-        Period test = new Period(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.getAllType(ISOChronology.getInstanceUTC()));\n-        DateTime added = test.addTo(new DateTime(PARIS), -2);  // DateTime has PARIS time zone\n-        assertEquals(expected, added.getMillis());\n-        assertEquals(ISOChronology.getInstance(PARIS), added.getChronology());\n-    }\n-    \n-    public void testAddToRI5() {\n-        long expected = TEST_TIME_NOW;\n-        expected = ISOChronology.getInstanceUTC().years().add(expected, -2);\n-        expected = ISOChronology.getInstanceUTC().months().add(expected, -4);\n-        expected = ISOChronology.getInstanceUTC().weeks().add(expected, -6);\n-        expected = ISOChronology.getInstanceUTC().days().add(expected, -8);\n-        expected = ISOChronology.getInstanceUTC().hours().add(expected, -10);\n-        expected = ISOChronology.getInstanceUTC().minutes().add(expected, -12);\n-        expected = ISOChronology.getInstanceUTC().seconds().add(expected, -14);\n-        expected = ISOChronology.getInstanceUTC().millis().add(expected, -16);\n-        \n-        Period test = new Period(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.getAllType(ISOChronology.getInstanceUTC()));\n-        DateTime added = test.addTo(null, -2);  // null has no time zone, uses duration's zone (UTC)\n-        assertEquals(expected, added.getMillis());\n-        assertEquals(ISOChronology.getInstance(), added.getChronology());\n-    }\n-    \n-    //-----------------------------------------------------------------------\n-    public void testAddIntoRWI1() {\n-        long expected = TEST_TIME_NOW;\n-        expected = ISOChronology.getInstance().years().add(expected, 1);\n-        expected = ISOChronology.getInstance().months().add(expected, 2);\n-        expected = ISOChronology.getInstance().weeks().add(expected, 3);\n-        expected = ISOChronology.getInstance().days().add(expected, 4);\n-        expected = ISOChronology.getInstance().hours().add(expected, 5);\n-        expected = ISOChronology.getInstance().minutes().add(expected, 6);\n-        expected = ISOChronology.getInstance().seconds().add(expected, 7);\n-        expected = ISOChronology.getInstance().millis().add(expected, 8);\n-        \n-        Period test = new Period(1, 2, 3, 4, 5, 6, 7, 8);\n-        MutableDateTime mdt = new MutableDateTime();\n-        test.addInto(mdt, 1);\n-        assertEquals(expected, mdt.getMillis());\n-    }\n-    \n-    public void testAddIntoRWI2() {\n-        long expected = TEST_TIME_NOW;\n-        expected = ISOChronology.getInstance().years().add(expected, -2);\n-        expected = ISOChronology.getInstance().months().add(expected, -4);\n-        expected = ISOChronology.getInstance().weeks().add(expected, -6);\n-        expected = ISOChronology.getInstance().days().add(expected, -8);\n-        expected = ISOChronology.getInstance().hours().add(expected, -10);\n-        expected = ISOChronology.getInstance().minutes().add(expected, -12);\n-        expected = ISOChronology.getInstance().seconds().add(expected, -14);\n-        expected = ISOChronology.getInstance().millis().add(expected, -16);\n-        \n-        Period test = new Period(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.getAllType(ISOChronology.getInstanceUTC()));\n+        Period test = new Period(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.standard());\n         MutableDateTime mdt = new MutableDateTime();\n         test.addInto(mdt, -2);  // MutableDateTime has a chronology, use it\n         assertEquals(expected, mdt.getMillis());\n     }\n \n     //-----------------------------------------------------------------------\n-    public void testToDurationMillis() {\n+    public void testToDurationMillisFrom() {\n         Period test = new Period(123L);\n-        assertEquals(123L, test.toDurationMillis());\n-        \n-        test = new Period(1, 2, 3, 4, 5, 6, 7, 8);\n-        try {\n-            test.toDurationMillis();\n-            fail();\n-        } catch (IllegalStateException ex) {}\n+        assertEquals(123L, test.toDurationMillisFrom(0L, null));\n     }\n \n     public void testToDuration() {\n         Period test = new Period(123L);\n-        assertEquals(new Duration(123L), test.toDuration());\n-        \n-        test = new Period(1, 2, 3, 4, 5, 6, 7, 8);\n-        try {\n-            test.toDuration();\n-            fail();\n-        } catch (IllegalStateException ex) {}\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    public void testWithPeriodTypeRetainDuration1() {\n+        assertEquals(new Duration(123L), test.toDurationFrom(new Instant(0L)));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testWithPeriodType1() {\n         Period test = new Period(123L);\n-        Period result = test.withPeriodTypeRetainDuration(PeriodType.getAllType());\n+        Period result = test.withPeriodType(PeriodType.standard());\n         assertSame(test, result);\n     }\n \n-    public void testWithPeriodTypeRetainDuration2() {\n+    public void testWithPeriodType2() {\n         Period test = new Period(3123L);\n-        Period result = test.withPeriodTypeRetainDuration(PeriodType.getDayHourType());\n+        Period result = test.withPeriodType(PeriodType.dayTime());\n         assertEquals(3, result.getSeconds());\n         assertEquals(123, result.getMillis());\n-        assertEquals(3123L, result.toDurationMillis());\n-        assertEquals(PeriodType.getDayHourType(), result.getPeriodType());\n-    }\n-\n-    public void testWithPeriodTypeRetainDuration3() {\n-        Period test = new Period(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.getAllType());\n+        assertEquals(PeriodType.dayTime(), result.getPeriodType());\n+    }\n+\n+    public void testWithPeriodType3() {\n+        Period test = new Period(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.standard());\n         try {\n-            test.withPeriodTypeRetainDuration(PeriodType.getDayHourType());\n-            fail();\n-        } catch (IllegalStateException ex) {}\n-    }\n-\n-    public void testWithPeriodTypeRetainDuration4() {\n-        Period test = new Period(3123L);\n-        Period result = test.withPeriodTypeRetainDuration(null);\n-        assertEquals(3, result.getSeconds());\n-        assertEquals(123, result.getMillis());\n-        assertEquals(3123L, result.toDurationMillis());\n-        assertEquals(PeriodType.getAllType(), result.getPeriodType());\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    public void testWithPeriodType1() {\n-        Period test = new Period(123L);\n-        Period result = test.withPeriodType(PeriodType.getAllType());\n-        assertSame(test, result);\n-    }\n-\n-    public void testWithPeriodType2() {\n-        Period test = new Period(3123L);\n-        Period result = test.withPeriodType(PeriodType.getDayHourType());\n-        assertEquals(3, result.getSeconds());\n-        assertEquals(123, result.getMillis());\n-        assertEquals(3123L, result.toDurationMillis());\n-        assertEquals(PeriodType.getDayHourType(), result.getPeriodType());\n-    }\n-\n-    public void testWithPeriodType3() {\n-        Period test = new Period(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.getAllType());\n-        try {\n-            test.withPeriodType(PeriodType.getDayHourType());\n+            test.withPeriodType(PeriodType.dayTime());\n             fail();\n         } catch (IllegalArgumentException ex) {}\n     }\n         Period result = test.withPeriodType(null);\n         assertEquals(3, result.getSeconds());\n         assertEquals(123, result.getMillis());\n-        assertEquals(3123L, result.toDurationMillis());\n-        assertEquals(PeriodType.getAllType(), result.getPeriodType());\n+        assertEquals(PeriodType.standard(), result.getPeriodType());\n     }\n \n     public void testWithPeriodType5() {\n-        Period test = new Period(1, 2, 0, 4, 5, 6, 7, 8, PeriodType.getAllType());\n-        Period result = test.withPeriodType(PeriodType.getYearMonthType());\n-        assertEquals(PeriodType.getYearMonthType(), result.getPeriodType());\n+        Period test = new Period(1, 2, 0, 4, 5, 6, 7, 8, PeriodType.standard());\n+        Period result = test.withPeriodType(PeriodType.yearMonthDayTime());\n+        assertEquals(PeriodType.yearMonthDayTime(), result.getPeriodType());\n         assertEquals(1, result.getYears());\n         assertEquals(2, result.getMonths());\n         assertEquals(0, result.getWeeks());\n         assertEquals(8, result.getMillis());\n     }\n \n-    //-----------------------------------------------------------------------\n-    public void testWithFieldsNormalized1() {\n-        Period test = new Period(1, 2, 3, 4, 5, 6, 61, 8, PeriodType.getPreciseAllType());\n-        Period result = test.withFieldsNormalized();\n-        assertEquals(1, result.getYears());\n-        assertEquals(2, result.getMonths());\n-        assertEquals(3, result.getWeeks());\n-        assertEquals(4, result.getDays());\n-        assertEquals(5, result.getHours());\n-        assertEquals(7, result.getMinutes());\n-        assertEquals(1, result.getSeconds());\n-        assertEquals(8, result.getMillis());\n-    }\n-\n-    public void testWithFieldsNormalized2() {\n-        Period test = new Period(1, 2, 3, 4, 5, 6, 61, 8, PeriodType.getAllType());\n-        try {\n-            test.withFieldsNormalized();\n-            fail();\n-        } catch (IllegalStateException ex) {}\n-    }\n-\n }\n--- a/JodaTime/src/test/org/joda/time/TestPeriod_Constructors.java\n+++ b/JodaTime/src/test/org/joda/time/TestPeriod_Constructors.java\n                 6 * DateTimeConstants.MILLIS_PER_MINUTE +\n                 7 * DateTimeConstants.MILLIS_PER_SECOND + 8;\n         Period test = new Period(length);\n-        assertEquals(PeriodType.getAllType(), test.getPeriodType());\n+        assertEquals(PeriodType.standard(), test.getPeriodType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n         assertEquals(0, test.getWeeks());\n         assertEquals(6, test.getMinutes());\n         assertEquals(7, test.getSeconds());\n         assertEquals(8, test.getMillis());\n-        assertEquals(true, test.isPrecise());\n-        assertEquals(length, test.toDurationMillis());\n     }\n \n     public void testConstructor_long2() throws Throwable {\n                 6 * DateTimeConstants.MILLIS_PER_MINUTE +\n                 7 * DateTimeConstants.MILLIS_PER_SECOND + 8;\n         Period test = new Period(length);\n-        assertEquals(PeriodType.getAllType(), test.getPeriodType());\n+        assertEquals(PeriodType.standard(), test.getPeriodType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n         assertEquals(0, test.getWeeks());\n         assertEquals(6, test.getMinutes());\n         assertEquals(7, test.getSeconds());\n         assertEquals(8, test.getMillis());\n-        assertEquals(true, test.isPrecise());\n-        assertEquals(length, test.toDurationMillis());\n     }\n \n     public void testConstructor_long3() throws Throwable {\n             6L * DateTimeConstants.MILLIS_PER_MINUTE +\n             7L * DateTimeConstants.MILLIS_PER_SECOND + 8L;\n         Period test = new Period(length);\n-        assertEquals(PeriodType.getAllType(), test.getPeriodType());\n+        assertEquals(PeriodType.standard(), test.getPeriodType());\n         // only time fields are precise in AllType\n         assertEquals(0, test.getYears());  // (4 + (3 * 7) + (2 * 30) + 365) == 450\n         assertEquals(0, test.getMonths());\n         assertEquals(6, test.getMinutes());\n         assertEquals(7, test.getSeconds());\n         assertEquals(8, test.getMillis());\n-        assertEquals(true, test.isPrecise());\n-        assertEquals(length, test.toDurationMillis());\n     }\n \n     //-----------------------------------------------------------------------\n                 5 * DateTimeConstants.MILLIS_PER_HOUR +\n                 6 * DateTimeConstants.MILLIS_PER_MINUTE +\n                 7 * DateTimeConstants.MILLIS_PER_SECOND + 8;\n-        Period test = new Period(length, null);\n-        assertEquals(PeriodType.getAllType(), test.getPeriodType());\n+        Period test = new Period(length, (PeriodType) null);\n+        assertEquals(PeriodType.standard(), test.getPeriodType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n         assertEquals(0, test.getWeeks());\n         assertEquals(6, test.getMinutes());\n         assertEquals(7, test.getSeconds());\n         assertEquals(8, test.getMillis());\n-        assertEquals(true, test.isPrecise());\n-        assertEquals(length, test.toDurationMillis());\n     }\n \n     public void testConstructor_long_PeriodType2() throws Throwable {\n                 5 * DateTimeConstants.MILLIS_PER_HOUR +\n                 6 * DateTimeConstants.MILLIS_PER_MINUTE +\n                 7 * DateTimeConstants.MILLIS_PER_SECOND + 8;\n-        Period test = new Period(length, PeriodType.getMillisType());\n-        assertEquals(PeriodType.getMillisType(), test.getPeriodType());\n+        Period test = new Period(length, PeriodType.millis());\n+        assertEquals(PeriodType.millis(), test.getPeriodType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n         assertEquals(0, test.getWeeks());\n         assertEquals(0, test.getMinutes());\n         assertEquals(0, test.getSeconds());\n         assertEquals(length, test.getMillis());\n-        assertEquals(true, test.isPrecise());\n-        assertEquals(length, test.toDurationMillis());\n     }\n \n     public void testConstructor_long_PeriodType3() throws Throwable {\n                 5 * DateTimeConstants.MILLIS_PER_HOUR +\n                 6 * DateTimeConstants.MILLIS_PER_MINUTE +\n                 7 * DateTimeConstants.MILLIS_PER_SECOND + 8;\n-        Period test = new Period(length, PeriodType.getDayHourType());\n-        assertEquals(PeriodType.getDayHourType(), test.getPeriodType());\n+        Period test = new Period(length, PeriodType.dayTime());\n+        assertEquals(PeriodType.dayTime(), test.getPeriodType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n         assertEquals(0, test.getWeeks());\n         assertEquals(6, test.getMinutes());\n         assertEquals(7, test.getSeconds());\n         assertEquals(8, test.getMillis());\n-        assertEquals(true, test.isPrecise());\n-        assertEquals(length, test.toDurationMillis());\n     }\n \n     public void testConstructor_long_PeriodType4() throws Throwable {\n                 5 * DateTimeConstants.MILLIS_PER_HOUR +\n                 6 * DateTimeConstants.MILLIS_PER_MINUTE +\n                 7 * DateTimeConstants.MILLIS_PER_SECOND + 8;\n-        Period test = new Period(length, PeriodType.getAllType().withMillisRemoved());\n-        assertEquals(PeriodType.getAllType().withMillisRemoved(), test.getPeriodType());\n+        Period test = new Period(length, PeriodType.standard().withMillisRemoved());\n+        assertEquals(PeriodType.standard().withMillisRemoved(), test.getPeriodType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n         assertEquals(0, test.getWeeks());\n         assertEquals(6, test.getMinutes());\n         assertEquals(7, test.getSeconds());\n         assertEquals(0, test.getMillis());\n-        assertEquals(true, test.isPrecise());\n-        assertEquals(length - 8, test.toDurationMillis());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testConstructor_long_Chronology1() throws Throwable {\n+        long length = 4 * DateTimeConstants.MILLIS_PER_DAY +\n+                5 * DateTimeConstants.MILLIS_PER_HOUR +\n+                6 * DateTimeConstants.MILLIS_PER_MINUTE +\n+                7 * DateTimeConstants.MILLIS_PER_SECOND + 8;\n+        Period test = new Period(length, Chronology.getISO());\n+        assertEquals(PeriodType.standard(), test.getPeriodType());\n+        assertEquals(0, test.getYears());\n+        assertEquals(0, test.getMonths());\n+        assertEquals(0, test.getWeeks());\n+        assertEquals(0, test.getDays());\n+        assertEquals((4 * 24) + 5, test.getHours());\n+        assertEquals(6, test.getMinutes());\n+        assertEquals(7, test.getSeconds());\n+        assertEquals(8, test.getMillis());\n+    }\n+\n+    public void testConstructor_long_Chronology2() throws Throwable {\n+        long length = 4 * DateTimeConstants.MILLIS_PER_DAY +\n+                5 * DateTimeConstants.MILLIS_PER_HOUR +\n+                6 * DateTimeConstants.MILLIS_PER_MINUTE +\n+                7 * DateTimeConstants.MILLIS_PER_SECOND + 8;\n+        Period test = new Period(length, Chronology.getISOUTC());\n+        assertEquals(PeriodType.standard(), test.getPeriodType());\n+        assertEquals(0, test.getYears());\n+        assertEquals(0, test.getMonths());\n+        assertEquals(0, test.getWeeks());\n+        assertEquals(4, test.getDays());\n+        assertEquals(5, test.getHours());\n+        assertEquals(6, test.getMinutes());\n+        assertEquals(7, test.getSeconds());\n+        assertEquals(8, test.getMillis());\n+    }\n+\n+    public void testConstructor_long_Chronology3() throws Throwable {\n+        long length = 4 * DateTimeConstants.MILLIS_PER_DAY +\n+                5 * DateTimeConstants.MILLIS_PER_HOUR +\n+                6 * DateTimeConstants.MILLIS_PER_MINUTE +\n+                7 * DateTimeConstants.MILLIS_PER_SECOND + 8;\n+        Period test = new Period(length, (Chronology) null);\n+        assertEquals(PeriodType.standard(), test.getPeriodType());\n+        assertEquals(0, test.getYears());\n+        assertEquals(0, test.getMonths());\n+        assertEquals(0, test.getWeeks());\n+        assertEquals(0, test.getDays());\n+        assertEquals((4 * 24) + 5, test.getHours());\n+        assertEquals(6, test.getMinutes());\n+        assertEquals(7, test.getSeconds());\n+        assertEquals(8, test.getMillis());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testConstructor_long_PeriodType_Chronology1() throws Throwable {\n+        long length = 4 * DateTimeConstants.MILLIS_PER_DAY +\n+                5 * DateTimeConstants.MILLIS_PER_HOUR +\n+                6 * DateTimeConstants.MILLIS_PER_MINUTE +\n+                7 * DateTimeConstants.MILLIS_PER_SECOND + 8;\n+        Period test = new Period(length, PeriodType.time().withMillisRemoved(), Chronology.getISO());\n+        assertEquals(PeriodType.time().withMillisRemoved(), test.getPeriodType());\n+        assertEquals(0, test.getYears());\n+        assertEquals(0, test.getMonths());\n+        assertEquals(0, test.getWeeks());\n+        assertEquals(0, test.getDays());\n+        assertEquals((4 * 24) + 5, test.getHours());\n+        assertEquals(6, test.getMinutes());\n+        assertEquals(7, test.getSeconds());\n+        assertEquals(0, test.getMillis());\n+    }\n+\n+    public void testConstructor_long_PeriodType_Chronology2() throws Throwable {\n+        long length = 4 * DateTimeConstants.MILLIS_PER_DAY +\n+                5 * DateTimeConstants.MILLIS_PER_HOUR +\n+                6 * DateTimeConstants.MILLIS_PER_MINUTE +\n+                7 * DateTimeConstants.MILLIS_PER_SECOND + 8;\n+        Period test = new Period(length, PeriodType.standard(), Chronology.getISOUTC());\n+        assertEquals(PeriodType.standard(), test.getPeriodType());\n+        assertEquals(0, test.getYears());\n+        assertEquals(0, test.getMonths());\n+        assertEquals(0, test.getWeeks());\n+        assertEquals(4, test.getDays());\n+        assertEquals(5, test.getHours());\n+        assertEquals(6, test.getMinutes());\n+        assertEquals(7, test.getSeconds());\n+        assertEquals(8, test.getMillis());\n+    }\n+\n+    public void testConstructor_long_PeriodType_Chronology3() throws Throwable {\n+        long length = 4 * DateTimeConstants.MILLIS_PER_DAY +\n+                5 * DateTimeConstants.MILLIS_PER_HOUR +\n+                6 * DateTimeConstants.MILLIS_PER_MINUTE +\n+                7 * DateTimeConstants.MILLIS_PER_SECOND + 8;\n+        Period test = new Period(length, PeriodType.standard(), (Chronology) null);\n+        assertEquals(PeriodType.standard(), test.getPeriodType());\n+        assertEquals(0, test.getYears());\n+        assertEquals(0, test.getMonths());\n+        assertEquals(0, test.getWeeks());\n+        assertEquals(0, test.getDays());\n+        assertEquals((4 * 24) + 5, test.getHours());\n+        assertEquals(6, test.getMinutes());\n+        assertEquals(7, test.getSeconds());\n+        assertEquals(8, test.getMillis());\n+    }\n+\n+    public void testConstructor_long_PeriodType_Chronology4() throws Throwable {\n+        long length = 4 * DateTimeConstants.MILLIS_PER_DAY +\n+                5 * DateTimeConstants.MILLIS_PER_HOUR +\n+                6 * DateTimeConstants.MILLIS_PER_MINUTE +\n+                7 * DateTimeConstants.MILLIS_PER_SECOND + 8;\n+        Period test = new Period(length, (PeriodType) null, (Chronology) null);\n+        assertEquals(PeriodType.standard(), test.getPeriodType());\n+        assertEquals(0, test.getYears());\n+        assertEquals(0, test.getMonths());\n+        assertEquals(0, test.getWeeks());\n+        assertEquals(0, test.getDays());\n+        assertEquals((4 * 24) + 5, test.getHours());\n+        assertEquals(6, test.getMinutes());\n+        assertEquals(7, test.getSeconds());\n+        assertEquals(8, test.getMillis());\n     }\n \n     //-----------------------------------------------------------------------\n      */\n     public void testConstructor_4int1() throws Throwable {\n         Period test = new Period(5, 6, 7, 8);\n-        assertEquals(PeriodType.getAllType(), test.getPeriodType());\n+        assertEquals(PeriodType.time(), test.getPeriodType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n         assertEquals(0, test.getWeeks());\n         assertEquals(6, test.getMinutes());\n         assertEquals(7, test.getSeconds());\n         assertEquals(8, test.getMillis());\n-        assertEquals(true, test.isPrecise());\n-        assertEquals(\n-            5 * DateTimeConstants.MILLIS_PER_HOUR + 6 * DateTimeConstants.MILLIS_PER_MINUTE +\n-            7 * DateTimeConstants.MILLIS_PER_SECOND + 8, test.toDurationMillis());\n     }\n \n     //-----------------------------------------------------------------------\n      */\n     public void testConstructor_8int1() throws Throwable {\n         Period test = new Period(1, 2, 3, 4, 5, 6, 7, 8);\n-        assertEquals(PeriodType.getAllType(), test.getPeriodType());\n+        assertEquals(PeriodType.standard(), test.getPeriodType());\n         assertEquals(1, test.getYears());\n         assertEquals(2, test.getMonths());\n         assertEquals(3, test.getWeeks());\n         assertEquals(6, test.getMinutes());\n         assertEquals(7, test.getSeconds());\n         assertEquals(8, test.getMillis());\n-        assertEquals(false, test.isPrecise());\n-        try {\n-            test.toDurationMillis();\n-            fail();\n-        } catch (IllegalStateException ex) {}\n     }\n \n     //-----------------------------------------------------------------------\n      */\n     public void testConstructor_8int__PeriodType1() throws Throwable {\n         Period test = new Period(1, 2, 3, 4, 5, 6, 7, 8, null);\n-        assertEquals(PeriodType.getAllType(), test.getPeriodType());\n+        assertEquals(PeriodType.standard(), test.getPeriodType());\n         assertEquals(1, test.getYears());\n         assertEquals(2, test.getMonths());\n         assertEquals(3, test.getWeeks());\n         assertEquals(6, test.getMinutes());\n         assertEquals(7, test.getSeconds());\n         assertEquals(8, test.getMillis());\n-        assertEquals(false, test.isPrecise());\n-        try {\n-            test.toDurationMillis();\n-            fail();\n-        } catch (IllegalStateException ex) {}\n     }\n \n     public void testConstructor_8int__PeriodType2() throws Throwable {\n-        Period test = new Period(0, 0, 0, 0, 5, 6, 7, 8, PeriodType.getDayHourType());\n-        assertEquals(PeriodType.getDayHourType(), test.getPeriodType());\n+        Period test = new Period(0, 0, 0, 0, 5, 6, 7, 8, PeriodType.dayTime());\n+        assertEquals(PeriodType.dayTime(), test.getPeriodType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n         assertEquals(0, test.getWeeks());\n         assertEquals(6, test.getMinutes());\n         assertEquals(7, test.getSeconds());\n         assertEquals(8, test.getMillis());\n-        assertEquals(true, test.isPrecise());\n-        assertEquals(\n-            5 * DateTimeConstants.MILLIS_PER_HOUR + 6 * DateTimeConstants.MILLIS_PER_MINUTE +\n-            7 * DateTimeConstants.MILLIS_PER_SECOND + 8, test.toDurationMillis());\n     }\n \n     public void testConstructor_8int__PeriodType3() throws Throwable {\n         try {\n-            new Period(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.getDayHourType());\n+            new Period(1, 2, 3, 4, 5, 6, 7, 8, PeriodType.dayTime());\n             fail();\n         } catch (IllegalArgumentException ex) {}\n     }\n         DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n         DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);\n         Period test = new Period(dt1.getMillis(), dt2.getMillis());\n-        assertEquals(PeriodType.getAllType(), test.getPeriodType());\n+        assertEquals(PeriodType.standard(), test.getPeriodType());\n         assertEquals(1, test.getYears());\n         assertEquals(1, test.getMonths());\n         assertEquals(0, test.getWeeks());\n         assertEquals(1, test.getMinutes());\n         assertEquals(1, test.getSeconds());\n         assertEquals(1, test.getMillis());\n-        assertEquals(false, test.isPrecise());\n-        try {\n-            test.toDurationMillis();\n-            fail();\n-        } catch (IllegalStateException ex) {}\n     }\n \n     public void testConstructor_long_long2() throws Throwable {\n         DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n         DateTime dt2 = new DateTime(2005, 7, 17, 1, 1, 1, 1);\n         Period test = new Period(dt1.getMillis(), dt2.getMillis());\n-        assertEquals(PeriodType.getAllType(), test.getPeriodType());\n+        assertEquals(PeriodType.standard(), test.getPeriodType());\n         assertEquals(1, test.getYears());\n         assertEquals(1, test.getMonths());\n         assertEquals(1, test.getWeeks());\n         assertEquals(1, test.getMinutes());\n         assertEquals(1, test.getSeconds());\n         assertEquals(1, test.getMillis());\n-        assertEquals(false, test.isPrecise());\n-        try {\n-            test.toDurationMillis();\n-            fail();\n-        } catch (IllegalStateException ex) {}\n     }\n \n     //-----------------------------------------------------------------------\n     public void testConstructor_long_long_PeriodType1() throws Throwable {\n         DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n         DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);\n-        Period test = new Period(dt1.getMillis(), dt2.getMillis(), null);\n-        assertEquals(PeriodType.getAllType(), test.getPeriodType());\n+        Period test = new Period(dt1.getMillis(), dt2.getMillis(), (PeriodType) null);\n+        assertEquals(PeriodType.standard(), test.getPeriodType());\n         assertEquals(1, test.getYears());\n         assertEquals(1, test.getMonths());\n         assertEquals(0, test.getWeeks());\n         assertEquals(1, test.getMinutes());\n         assertEquals(1, test.getSeconds());\n         assertEquals(1, test.getMillis());\n-        assertEquals(false, test.isPrecise());\n-        try {\n-            test.toDurationMillis();\n-            fail();\n-        } catch (IllegalStateException ex) {}\n     }\n \n     public void testConstructor_long_long_PeriodType2() throws Throwable {\n         DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n         DateTime dt2 = new DateTime(2004, 7, 10, 1, 1, 1, 1);\n-        Period test = new Period(dt1.getMillis(), dt2.getMillis(), PeriodType.getDayHourType());\n-        assertEquals(PeriodType.getDayHourType(), test.getPeriodType());\n+        Period test = new Period(dt1.getMillis(), dt2.getMillis(), PeriodType.dayTime());\n+        assertEquals(PeriodType.dayTime(), test.getPeriodType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n         assertEquals(0, test.getWeeks());\n         assertEquals(1, test.getMinutes());\n         assertEquals(1, test.getSeconds());\n         assertEquals(1, test.getMillis());\n-        assertEquals(false, test.isPrecise());\n-        try {\n-            test.toDurationMillis();\n-            fail();\n-        } catch (IllegalStateException ex) {}\n     }\n \n     public void testConstructor_long_long_PeriodType3() throws Throwable {\n         DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n         DateTime dt2 = new DateTime(2004, 6, 9, 1, 1, 1, 1);\n-        Period test = new Period(dt1.getMillis(), dt2.getMillis(), PeriodType.getAllType().withMillisRemoved());\n-        assertEquals(PeriodType.getAllType().withMillisRemoved(), test.getPeriodType());\n-        assertEquals(0, test.getYears());\n-        assertEquals(0, test.getMonths());\n-        assertEquals(0, test.getWeeks());\n-        assertEquals(0, test.getDays());\n-        assertEquals(1, test.getHours());\n-        assertEquals(1, test.getMinutes());\n-        assertEquals(1, test.getSeconds());\n-        assertEquals(0, test.getMillis());\n-        assertEquals(true, test.isPrecise());\n-        assertEquals(dt2.getMillis() - dt1.getMillis() - 1, test.toDurationMillis());\n+        Period test = new Period(dt1.getMillis(), dt2.getMillis(), PeriodType.standard().withMillisRemoved());\n+        assertEquals(PeriodType.standard().withMillisRemoved(), test.getPeriodType());\n+        assertEquals(0, test.getYears());\n+        assertEquals(0, test.getMonths());\n+        assertEquals(0, test.getWeeks());\n+        assertEquals(0, test.getDays());\n+        assertEquals(1, test.getHours());\n+        assertEquals(1, test.getMinutes());\n+        assertEquals(1, test.getSeconds());\n+        assertEquals(0, test.getMillis());\n     }\n \n     public void testToPeriod_PeriodType3() {\n         DateTime dt1 = new DateTime(2004, 6, 9, 7, 8, 9, 10);\n         DateTime dt2 = new DateTime(2005, 6, 9, 12, 14, 16, 18);\n-        Period test = new Period(dt1.getMillis(), dt2.getMillis(), PeriodType.getYearWeekType());\n+        Period test = new Period(dt1.getMillis(), dt2.getMillis(), PeriodType.yearWeekDayTime());\n         \n-        assertEquals(PeriodType.getYearWeekType(), test.getPeriodType());\n+        assertEquals(PeriodType.yearWeekDayTime(), test.getPeriodType());\n         assertEquals(1, test.getYears());  // tests using years and not weekyears\n         assertEquals(0, test.getMonths());\n         assertEquals(0, test.getWeeks());\n         DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n         DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);\n         Period test = new Period(dt1, dt2);\n-        assertEquals(PeriodType.getAllType(), test.getPeriodType());\n+        assertEquals(PeriodType.standard(), test.getPeriodType());\n         assertEquals(1, test.getYears());\n         assertEquals(1, test.getMonths());\n         assertEquals(0, test.getWeeks());\n         assertEquals(1, test.getMinutes());\n         assertEquals(1, test.getSeconds());\n         assertEquals(1, test.getMillis());\n-        assertEquals(false, test.isPrecise());\n-        try {\n-            test.toDurationMillis();\n-            fail();\n-        } catch (IllegalStateException ex) {}\n     }\n \n     public void testConstructor_RI_RI2() throws Throwable {\n         DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n         DateTime dt2 = new DateTime(2005, 7, 17, 1, 1, 1, 1);\n         Period test = new Period(dt1, dt2);\n-        assertEquals(PeriodType.getAllType(), test.getPeriodType());\n+        assertEquals(PeriodType.standard(), test.getPeriodType());\n         assertEquals(1, test.getYears());\n         assertEquals(1, test.getMonths());\n         assertEquals(1, test.getWeeks());\n         assertEquals(1, test.getMinutes());\n         assertEquals(1, test.getSeconds());\n         assertEquals(1, test.getMillis());\n-        assertEquals(false, test.isPrecise());\n-        try {\n-            test.toDurationMillis();\n-            fail();\n-        } catch (IllegalStateException ex) {}\n     }\n \n     public void testConstructor_RI_RI3() throws Throwable {\n         DateTime dt1 = null;  // 2002-06-09T01:00+01:00\n         DateTime dt2 = new DateTime(2005, 7, 17, 1, 1, 1, 1);\n         Period test = new Period(dt1, dt2);\n-        assertEquals(PeriodType.getAllType(), test.getPeriodType());\n+        assertEquals(PeriodType.standard(), test.getPeriodType());\n         assertEquals(3, test.getYears());\n         assertEquals(1, test.getMonths());\n         assertEquals(1, test.getWeeks());\n         assertEquals(1, test.getMinutes());\n         assertEquals(1, test.getSeconds());\n         assertEquals(1, test.getMillis());\n-        assertEquals(false, test.isPrecise());\n-        try {\n-            test.toDurationMillis();\n-            fail();\n-        } catch (IllegalStateException ex) {}\n     }\n \n     public void testConstructor_RI_RI4() throws Throwable {\n         DateTime dt1 = new DateTime(2005, 7, 17, 1, 1, 1, 1);\n         DateTime dt2 = null;  // 2002-06-09T01:00+01:00\n         Period test = new Period(dt1, dt2);\n-        assertEquals(PeriodType.getAllType(), test.getPeriodType());\n+        assertEquals(PeriodType.standard(), test.getPeriodType());\n         assertEquals(-3, test.getYears());\n         assertEquals(-1, test.getMonths());\n         assertEquals(-1, test.getWeeks());\n         assertEquals(-1, test.getMinutes());\n         assertEquals(-1, test.getSeconds());\n         assertEquals(-1, test.getMillis());\n-        assertEquals(false, test.isPrecise());\n-        try {\n-            test.toDurationMillis();\n-            fail();\n-        } catch (IllegalStateException ex) {}\n     }\n \n     public void testConstructor_RI_RI5() throws Throwable {\n         DateTime dt1 = null;  // 2002-06-09T01:00+01:00\n         DateTime dt2 = null;  // 2002-06-09T01:00+01:00\n         Period test = new Period(dt1, dt2);\n-        assertEquals(PeriodType.getAllType(), test.getPeriodType());\n+        assertEquals(PeriodType.standard(), test.getPeriodType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n         assertEquals(0, test.getWeeks());\n         assertEquals(0, test.getMinutes());\n         assertEquals(0, test.getSeconds());\n         assertEquals(0, test.getMillis());\n-        assertEquals(true, test.isPrecise());\n-        assertEquals(0L, test.toDurationMillis());\n     }\n \n     //-----------------------------------------------------------------------\n         DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n         DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);\n         Period test = new Period(dt1, dt2, null);\n-        assertEquals(PeriodType.getAllType(), test.getPeriodType());\n+        assertEquals(PeriodType.standard(), test.getPeriodType());\n         assertEquals(1, test.getYears());\n         assertEquals(1, test.getMonths());\n         assertEquals(0, test.getWeeks());\n         assertEquals(1, test.getMinutes());\n         assertEquals(1, test.getSeconds());\n         assertEquals(1, test.getMillis());\n-        assertEquals(false, test.isPrecise());\n-        try {\n-            test.toDurationMillis();\n-            fail();\n-        } catch (IllegalStateException ex) {}\n     }\n \n     public void testConstructor_RI_RI_PeriodType2() throws Throwable {\n         DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n         DateTime dt2 = new DateTime(2004, 7, 10, 1, 1, 1, 1);\n-        Period test = new Period(dt1, dt2, PeriodType.getDayHourType());\n-        assertEquals(PeriodType.getDayHourType(), test.getPeriodType());\n+        Period test = new Period(dt1, dt2, PeriodType.dayTime());\n+        assertEquals(PeriodType.dayTime(), test.getPeriodType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n         assertEquals(0, test.getWeeks());\n         assertEquals(1, test.getMinutes());\n         assertEquals(1, test.getSeconds());\n         assertEquals(1, test.getMillis());\n-        assertEquals(false, test.isPrecise());\n-        try {\n-            test.toDurationMillis();\n-            fail();\n-        } catch (IllegalStateException ex) {}\n     }\n \n     public void testConstructor_RI_RI_PeriodType3() throws Throwable {\n         DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n         DateTime dt2 = new DateTime(2004, 6, 9, 1, 1, 1, 1);\n-        Period test = new Period(dt1, dt2, PeriodType.getAllType().withMillisRemoved());\n-        assertEquals(PeriodType.getAllType().withMillisRemoved(), test.getPeriodType());\n-        assertEquals(0, test.getYears());\n-        assertEquals(0, test.getMonths());\n-        assertEquals(0, test.getWeeks());\n-        assertEquals(0, test.getDays());\n-        assertEquals(1, test.getHours());\n-        assertEquals(1, test.getMinutes());\n-        assertEquals(1, test.getSeconds());\n-        assertEquals(0, test.getMillis());\n-        assertEquals(true, test.isPrecise());\n-        assertEquals(dt2.getMillis() - dt1.getMillis() - 1, test.toDurationMillis());\n+        Period test = new Period(dt1, dt2, PeriodType.standard().withMillisRemoved());\n+        assertEquals(PeriodType.standard().withMillisRemoved(), test.getPeriodType());\n+        assertEquals(0, test.getYears());\n+        assertEquals(0, test.getMonths());\n+        assertEquals(0, test.getWeeks());\n+        assertEquals(0, test.getDays());\n+        assertEquals(1, test.getHours());\n+        assertEquals(1, test.getMinutes());\n+        assertEquals(1, test.getSeconds());\n+        assertEquals(0, test.getMillis());\n     }\n \n     public void testConstructor_RI_RI_PeriodType4() throws Throwable {\n         DateTime dt1 = null;  // 2002-06-09T01:00+01:00\n         DateTime dt2 = new DateTime(2005, 7, 17, 1, 1, 1, 1);\n-        Period test = new Period(dt1, dt2, PeriodType.getAllType());\n-        assertEquals(PeriodType.getAllType(), test.getPeriodType());\n+        Period test = new Period(dt1, dt2, PeriodType.standard());\n+        assertEquals(PeriodType.standard(), test.getPeriodType());\n         assertEquals(3, test.getYears());\n         assertEquals(1, test.getMonths());\n         assertEquals(1, test.getWeeks());\n         assertEquals(1, test.getMinutes());\n         assertEquals(1, test.getSeconds());\n         assertEquals(1, test.getMillis());\n-        assertEquals(false, test.isPrecise());\n-        try {\n-            test.toDurationMillis();\n-            fail();\n-        } catch (IllegalStateException ex) {}\n     }\n \n     public void testConstructor_RI_RI_PeriodType5() throws Throwable {\n         DateTime dt1 = null;  // 2002-06-09T01:00+01:00\n         DateTime dt2 = null;  // 2002-06-09T01:00+01:00\n-        Period test = new Period(dt1, dt2, PeriodType.getAllType());\n-        assertEquals(PeriodType.getAllType(), test.getPeriodType());\n+        Period test = new Period(dt1, dt2, PeriodType.standard());\n+        assertEquals(PeriodType.standard(), test.getPeriodType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n         assertEquals(0, test.getWeeks());\n         assertEquals(0, test.getMinutes());\n         assertEquals(0, test.getSeconds());\n         assertEquals(0, test.getMillis());\n-        assertEquals(true, test.isPrecise());\n-        assertEquals(0L, test.toDurationMillis());\n     }\n \n     //-----------------------------------------------------------------------\n      */\n     public void testConstructor_Object1() throws Throwable {\n         Period test = new Period(\"P1Y2M3D\");\n-        assertEquals(PeriodType.getAllType(), test.getPeriodType());\n+        assertEquals(PeriodType.standard(), test.getPeriodType());\n         assertEquals(1, test.getYears());\n         assertEquals(2, test.getMonths());\n         assertEquals(0, test.getWeeks());\n         assertEquals(0, test.getMinutes());\n         assertEquals(0, test.getSeconds());\n         assertEquals(0, test.getMillis());\n-        assertEquals(false, test.isPrecise());\n-        try {\n-            test.toDurationMillis();\n-            fail();\n-        } catch (IllegalStateException ex) {}\n     }\n \n     public void testConstructor_Object2() throws Throwable {\n         Period test = new Period((Object) null);\n-        assertEquals(PeriodType.getAllType(), test.getPeriodType());\n+        assertEquals(PeriodType.standard(), test.getPeriodType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n         assertEquals(0, test.getWeeks());\n         assertEquals(0, test.getMinutes());\n         assertEquals(0, test.getSeconds());\n         assertEquals(0, test.getMillis());\n-        assertEquals(true, test.isPrecise());\n-        assertEquals(0, test.toDurationMillis());\n     }\n \n     public void testConstructor_Object3() throws Throwable {\n-        Period test = new Period(new Period(0, 0, 0, 0, 1, 2, 3, 4, PeriodType.getDayHourType()));\n-        assertEquals(PeriodType.getDayHourType(), test.getPeriodType());\n+        Period test = new Period(new Period(0, 0, 0, 0, 1, 2, 3, 4, PeriodType.dayTime()));\n+        assertEquals(PeriodType.dayTime(), test.getPeriodType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n         assertEquals(0, test.getWeeks());\n         assertEquals(2, test.getMinutes());\n         assertEquals(3, test.getSeconds());\n         assertEquals(4, test.getMillis());\n-        assertEquals(true, test.isPrecise());\n-        assertEquals(DateTimeConstants.MILLIS_PER_HOUR + 2 * DateTimeConstants.MILLIS_PER_MINUTE +\n-            3 * DateTimeConstants.MILLIS_PER_SECOND + 4, test.toDurationMillis());\n     }\n \n     public void testConstructor_Object4() throws Throwable {\n-        Period base = new Period(1, 1, 0, 1, 1, 1, 1, 1, PeriodType.getAllType());\n+        Period base = new Period(1, 1, 0, 1, 1, 1, 1, 1, PeriodType.standard());\n         Period test = new Period(base);\n-        assertEquals(PeriodType.getAllType(), test.getPeriodType());\n+        assertEquals(PeriodType.standard(), test.getPeriodType());\n         assertEquals(1, test.getYears());\n         assertEquals(1, test.getMonths());\n         assertEquals(0, test.getWeeks());\n         assertEquals(1, test.getMinutes());\n         assertEquals(1, test.getSeconds());\n         assertEquals(1, test.getMillis());\n-        assertEquals(false, test.isPrecise());\n-        try {\n-            test.toDurationMillis();\n-            fail();\n-        } catch (IllegalStateException ex) {}\n     }\n \n     //-----------------------------------------------------------------------\n      * Test constructor (Object)\n      */\n     public void testConstructor_Object_PeriodType1() throws Throwable {\n-        Period test = new Period(\"P1Y2M3D\", PeriodType.getYearMonthType());\n-        assertEquals(PeriodType.getYearMonthType(), test.getPeriodType());\n+        Period test = new Period(\"P1Y2M3D\", PeriodType.yearMonthDayTime());\n+        assertEquals(PeriodType.yearMonthDayTime(), test.getPeriodType());\n         assertEquals(1, test.getYears());\n         assertEquals(2, test.getMonths());\n         assertEquals(0, test.getWeeks());\n         assertEquals(0, test.getMinutes());\n         assertEquals(0, test.getSeconds());\n         assertEquals(0, test.getMillis());\n-        assertEquals(false, test.isPrecise());\n-        try {\n-            test.toDurationMillis();\n-            fail();\n-        } catch (IllegalStateException ex) {}\n     }\n \n     public void testConstructor_Object_PeriodType2() throws Throwable {\n-        Period test = new Period((Object) null, PeriodType.getYearMonthType());\n-        assertEquals(PeriodType.getYearMonthType(), test.getPeriodType());\n+        Period test = new Period((Object) null, PeriodType.yearMonthDayTime());\n+        assertEquals(PeriodType.yearMonthDayTime(), test.getPeriodType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n         assertEquals(0, test.getWeeks());\n         assertEquals(0, test.getMinutes());\n         assertEquals(0, test.getSeconds());\n         assertEquals(0, test.getMillis());\n-        assertEquals(true, test.isPrecise());\n-        assertEquals(0, test.toDurationMillis());\n     }\n \n     public void testConstructor_Object_PeriodType3() throws Throwable {\n-        Period test = new Period(new Period(0, 0, 0, 0, 1, 2, 3, 4, PeriodType.getDayHourType()), PeriodType.getYearMonthType());\n-        assertEquals(PeriodType.getYearMonthType(), test.getPeriodType());\n+        Period test = new Period(new Period(0, 0, 0, 0, 1, 2, 3, 4, PeriodType.dayTime()), PeriodType.yearMonthDayTime());\n+        assertEquals(PeriodType.yearMonthDayTime(), test.getPeriodType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n         assertEquals(0, test.getWeeks());\n         assertEquals(2, test.getMinutes());\n         assertEquals(3, test.getSeconds());\n         assertEquals(4, test.getMillis());\n-        assertEquals(true, test.isPrecise());\n-        assertEquals(DateTimeConstants.MILLIS_PER_HOUR + 2 * DateTimeConstants.MILLIS_PER_MINUTE +\n-            3 * DateTimeConstants.MILLIS_PER_SECOND + 4, test.toDurationMillis());\n     }\n \n     public void testConstructor_Object_PeriodType4() throws Throwable {\n-        Period test = new Period(new Period(0, 0, 0, 0, 1, 2, 3, 4, PeriodType.getDayHourType()), null);\n-        assertEquals(PeriodType.getDayHourType(), test.getPeriodType());\n+        Period test = new Period(new Period(0, 0, 0, 0, 1, 2, 3, 4, PeriodType.dayTime()), (PeriodType) null);\n+        assertEquals(PeriodType.dayTime(), test.getPeriodType());\n         assertEquals(0, test.getYears());\n         assertEquals(0, test.getMonths());\n         assertEquals(0, test.getWeeks());\n         assertEquals(2, test.getMinutes());\n         assertEquals(3, test.getSeconds());\n         assertEquals(4, test.getMillis());\n-        assertEquals(true, test.isPrecise());\n-        assertEquals(DateTimeConstants.MILLIS_PER_HOUR + 2 * DateTimeConstants.MILLIS_PER_MINUTE +\n-            3 * DateTimeConstants.MILLIS_PER_SECOND + 4, test.toDurationMillis());\n     }\n \n }\n--- a/JodaTime/src/test/org/joda/time/convert/TestConverterManager.java\n+++ b/JodaTime/src/test/org/joda/time/convert/TestConverterManager.java\n \n     //-----------------------------------------------------------------------\n     //-----------------------------------------------------------------------\n-    private static int DURATION_SIZE = 6;\n+    private static int DURATION_SIZE = 5;\n     \n     public void testGetDurationConverter() {\n         DurationConverter c = ConverterManager.getInstance().getDurationConverter(new Long(0L));\n         \n         c = ConverterManager.getInstance().getDurationConverter(new Duration(123L));\n         assertEquals(ReadableDuration.class, c.getSupportedType());\n-        \n-        c = ConverterManager.getInstance().getDurationConverter(new Period(1, 2, 3, 4, 5, 6, 7, 8));\n-        assertEquals(ReadablePeriod.class, c.getSupportedType());\n         \n         c = ConverterManager.getInstance().getDurationConverter(new Interval(0L, 1000L));\n         assertEquals(ReadableInterval.class, c.getSupportedType());\n     //-----------------------------------------------------------------------\n     public void testAddPeriodConverter1() {\n         PeriodConverter c = new PeriodConverter() {\n-            public void setInto(ReadWritablePeriod duration, Object object) {}\n-            public PeriodType getPeriodType(Object object, boolean tmm) {return null;}\n+            public void setInto(ReadWritablePeriod duration, Object object, Chronology c) {}\n+            public PeriodType getPeriodType(Object object) {return null;}\n             public Class getSupportedType() {return Boolean.class;}\n         };\n         try {\n \n     public void testAddPeriodConverter2() {\n         PeriodConverter c = new PeriodConverter() {\n-            public void setInto(ReadWritablePeriod duration, Object object) {}\n-            public PeriodType getPeriodType(Object object, boolean tmm) {return null;}\n+            public void setInto(ReadWritablePeriod duration, Object object, Chronology c) {}\n+            public PeriodType getPeriodType(Object object) {return null;}\n             public Class getSupportedType() {return String.class;}\n         };\n         try {\n \n     public void testRemovePeriodConverter2() {\n         PeriodConverter c = new PeriodConverter() {\n-            public void setInto(ReadWritablePeriod duration, Object object) {}\n-            public PeriodType getPeriodType(Object object, boolean tmm) {return null;}\n+            public void setInto(ReadWritablePeriod duration, Object object, Chronology c) {}\n+            public PeriodType getPeriodType(Object object) {return null;}\n             public Class getSupportedType() {return Boolean.class;}\n         };\n         PeriodConverter removed = ConverterManager.getInstance().removePeriodConverter(c);\n \n     //-----------------------------------------------------------------------\n     public void testToString() {\n-        assertEquals(\"ConverterManager[6 instant,6 duration,5 period,2 interval]\", ConverterManager.getInstance().toString());\n+        assertEquals(\"ConverterManager[6 instant,5 duration,5 period,2 interval]\", ConverterManager.getInstance().toString());\n     }\n \n }\n--- a/JodaTime/src/test/org/joda/time/convert/TestLongConverter.java\n+++ b/JodaTime/src/test/org/joda/time/convert/TestLongConverter.java\n \n import org.joda.time.Chronology;\n import org.joda.time.DateTimeZone;\n-import org.joda.time.PeriodType;\n-import org.joda.time.MutablePeriod;\n import org.joda.time.chrono.ISOChronology;\n import org.joda.time.chrono.JulianChronology;\n \n     }\n \n     //-----------------------------------------------------------------------\n-    public void testGetPeriodType_Object() throws Exception {\n-        assertEquals(PeriodType.getAllType(),\n-            LongConverter.INSTANCE.getPeriodType(new Long(123L), false));\n-        assertEquals(PeriodType.getPreciseAllType(),\n-            LongConverter.INSTANCE.getPeriodType(new Long(123L), true));\n-    }\n-\n-    public void testSetInto_Object() throws Exception {\n-        MutablePeriod m = new MutablePeriod(PeriodType.getMillisType());\n-        LongConverter.INSTANCE.setInto(m, new Long(123L));\n-        assertEquals(123L, m.toDurationMillis());\n-    }\n-\n-    //-----------------------------------------------------------------------\n     public void testToString() {\n         assertEquals(\"Converter[java.lang.Long]\", LongConverter.INSTANCE.toString());\n     }\n--- a/JodaTime/src/test/org/joda/time/convert/TestNullConverter.java\n+++ b/JodaTime/src/test/org/joda/time/convert/TestNullConverter.java\n \n     //-----------------------------------------------------------------------\n     public void testGetPeriodType_Object() throws Exception {\n-        assertEquals(PeriodType.getAllType(),\n-            NullConverter.INSTANCE.getPeriodType(null, false));\n-        assertEquals(PeriodType.getPreciseAllType(),\n-            NullConverter.INSTANCE.getPeriodType(null, true));\n+        assertEquals(PeriodType.standard(),\n+            NullConverter.INSTANCE.getPeriodType(null));\n     }\n \n     public void testSetInto_Object() throws Exception {\n-        MutablePeriod m = new MutablePeriod(PeriodType.getMillisType());\n-        NullConverter.INSTANCE.setInto(m, null);\n-        assertEquals(0L, m.toDurationMillis());\n+        MutablePeriod m = new MutablePeriod(PeriodType.millis());\n+        NullConverter.INSTANCE.setInto(m, null, null);\n+        assertEquals(0L, m.getMillis());\n     }\n \n     //-----------------------------------------------------------------------\n--- a/JodaTime/src/test/org/joda/time/convert/TestReadableDurationConverter.java\n+++ b/JodaTime/src/test/org/joda/time/convert/TestReadableDurationConverter.java\n \n     //-----------------------------------------------------------------------\n     public void testGetPeriodType_Object() throws Exception {\n-        assertEquals(PeriodType.getPreciseAllType(),\n-            ReadableDurationConverter.INSTANCE.getPeriodType(new Duration(123L), false));\n-        assertEquals(PeriodType.getPreciseAllType(),\n-            ReadableDurationConverter.INSTANCE.getPeriodType(new Duration(123L), true));\n+        assertEquals(PeriodType.standard(),\n+            ReadableDurationConverter.INSTANCE.getPeriodType(new Duration(123L)));\n     }\n \n     public void testSetInto_Object() throws Exception {\n-        MutablePeriod m = new MutablePeriod(PeriodType.getYearMonthType());\n+        MutablePeriod m = new MutablePeriod(PeriodType.yearMonthDayTime());\n         ReadableDurationConverter.INSTANCE.setInto(m, new Duration(\n             3L * DateTimeConstants.MILLIS_PER_DAY +\n             4L * DateTimeConstants.MILLIS_PER_MINUTE + 5L\n-        ));\n+        ), null);\n         assertEquals(0, m.getYears());\n         assertEquals(0, m.getMonths());\n         assertEquals(0, m.getWeeks());\n--- a/JodaTime/src/test/org/joda/time/convert/TestReadableIntervalConverter.java\n+++ b/JodaTime/src/test/org/joda/time/convert/TestReadableIntervalConverter.java\n     //-----------------------------------------------------------------------\n     public void testGetPeriodType_Object() throws Exception {\n         Interval i = new Interval(100L, 223L);\n-        assertEquals(PeriodType.getAllType(),\n-            ReadableIntervalConverter.INSTANCE.getPeriodType(i, false));\n-        assertEquals(PeriodType.getPreciseAllType(),\n-            ReadableIntervalConverter.INSTANCE.getPeriodType(i, true));\n+        assertEquals(PeriodType.standard(),\n+            ReadableIntervalConverter.INSTANCE.getPeriodType(i));\n     }\n \n     public void testSetIntoPeriod_Object() throws Exception {\n         Interval i = new Interval(100L, 223L);\n-        MutablePeriod m = new MutablePeriod(PeriodType.getMillisType());\n-        ReadableIntervalConverter.INSTANCE.setInto(m, i);\n+        MutablePeriod m = new MutablePeriod(PeriodType.millis());\n+        ReadableIntervalConverter.INSTANCE.setInto(m, i, null);\n         assertEquals(0, m.getYears());\n         assertEquals(0, m.getMonths());\n         assertEquals(0, m.getWeeks());\n--- a/JodaTime/src/test/org/joda/time/convert/TestReadablePeriodConverter.java\n+++ b/JodaTime/src/test/org/joda/time/convert/TestReadablePeriodConverter.java\n     }\n \n     //-----------------------------------------------------------------------\n-    public void testGetPeriodMillis_Object() throws Exception {\n-        assertEquals(123L, ReadablePeriodConverter.INSTANCE.getDurationMillis(new Period(123L)));\n-    }\n-\n-    //-----------------------------------------------------------------------\n     public void testGetPeriodType_Object() throws Exception {\n-        assertEquals(PeriodType.getAllType(),\n-            ReadablePeriodConverter.INSTANCE.getPeriodType(new Period(123L), false));\n-        assertEquals(PeriodType.getPreciseAllType(),\n-            ReadablePeriodConverter.INSTANCE.getPeriodType(new Period(123L), true));\n-        assertEquals(PeriodType.getPreciseAllType(),\n-            ReadablePeriodConverter.INSTANCE.getPeriodType(new Period(123L, PeriodType.getAllType()), true));\n-        assertEquals(PeriodType.getPreciseYearDayType(),\n-            ReadablePeriodConverter.INSTANCE.getPeriodType(new Period(123L, PeriodType.getPreciseYearDayType()), true));\n+        assertEquals(PeriodType.standard(),\n+            ReadablePeriodConverter.INSTANCE.getPeriodType(new Period(123L, PeriodType.standard())));\n+        assertEquals(PeriodType.yearMonthDayTime(),\n+            ReadablePeriodConverter.INSTANCE.getPeriodType(new Period(123L, PeriodType.yearMonthDayTime())));\n     }\n \n     public void testSetInto_Object() throws Exception {\n-        MutablePeriod m = new MutablePeriod(PeriodType.getYearMonthType());\n-        ReadablePeriodConverter.INSTANCE.setInto(m, new Period(0, 0, 0, 3, 0, 4, 0, 5));\n+        MutablePeriod m = new MutablePeriod(PeriodType.yearMonthDayTime());\n+        ReadablePeriodConverter.INSTANCE.setInto(m, new Period(0, 0, 0, 3, 0, 4, 0, 5), null);\n         assertEquals(0, m.getYears());\n         assertEquals(0, m.getMonths());\n         assertEquals(0, m.getWeeks());\n--- a/JodaTime/src/test/org/joda/time/convert/TestStringConverter.java\n+++ b/JodaTime/src/test/org/joda/time/convert/TestStringConverter.java\n \n import org.joda.time.Chronology;\n import org.joda.time.DateTime;\n-import org.joda.time.DateTimeConstants;\n import org.joda.time.DateTimeZone;\n import org.joda.time.MutableInterval;\n import org.joda.time.MutablePeriod;\n \n     //-----------------------------------------------------------------------\n     public void testGetDurationMillis_Object1() throws Exception {\n-        long millis = StringConverter.INSTANCE.getDurationMillis(\"P2Y6M9D\");\n-        long len = (2L * 365L + 6L * 30L + 9L) * DateTimeConstants.MILLIS_PER_DAY;\n-        assertEquals(len, millis);\n+        long millis = StringConverter.INSTANCE.getDurationMillis(\"PT12.345S\");\n+        assertEquals(12345, millis);\n+        \n+        millis = StringConverter.INSTANCE.getDurationMillis(\"pt12.345s\");\n+        assertEquals(12345, millis);\n+        \n+        millis = StringConverter.INSTANCE.getDurationMillis(\"pt12s\");\n+        assertEquals(12000, millis);\n+        \n+        millis = StringConverter.INSTANCE.getDurationMillis(\"pt12.s\");\n+        assertEquals(12000, millis);\n+        \n+        millis = StringConverter.INSTANCE.getDurationMillis(\"pt-12.32s\");\n+        assertEquals(-12320, millis);\n+        \n+        millis = StringConverter.INSTANCE.getDurationMillis(\"pt12.3456s\");\n+        assertEquals(12345, millis);\n     }\n \n     public void testGetDurationMillis_Object2() throws Exception {\n             StringConverter.INSTANCE.getDurationMillis(\"P2Y6M9DXYZ\");\n             fail();\n         } catch (IllegalArgumentException ex) {}\n+        try {\n+            StringConverter.INSTANCE.getDurationMillis(\"PTS\");\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            StringConverter.INSTANCE.getDurationMillis(\"XT0S\");\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            StringConverter.INSTANCE.getDurationMillis(\"PX0S\");\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            StringConverter.INSTANCE.getDurationMillis(\"PT0X\");\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            StringConverter.INSTANCE.getDurationMillis(\"PTXS\");\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            StringConverter.INSTANCE.getDurationMillis(\"PT0.0.0S\");\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            StringConverter.INSTANCE.getDurationMillis(\"PT0-00S\");\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n     }\n \n     //-----------------------------------------------------------------------\n     public void testGetPeriodType_Object() throws Exception {\n-        assertEquals(PeriodType.getAllType(),\n-            StringConverter.INSTANCE.getPeriodType(\"P2Y6M9D\", false));\n-        assertEquals(PeriodType.getPreciseAllType(),\n-            StringConverter.INSTANCE.getPeriodType(\"P2Y6M9D\", true));\n+        assertEquals(PeriodType.standard(),\n+            StringConverter.INSTANCE.getPeriodType(\"P2Y6M9D\"));\n     }\n \n     public void testSetIntoPeriod_Object1() throws Exception {\n-        MutablePeriod m = new MutablePeriod(PeriodType.getYearMonthType());\n-        StringConverter.INSTANCE.setInto(m, \"P2Y6M9DT12H24M48S\");\n+        MutablePeriod m = new MutablePeriod(PeriodType.yearMonthDayTime());\n+        StringConverter.INSTANCE.setInto(m, \"P2Y6M9DT12H24M48S\", null);\n         assertEquals(2, m.getYears());\n         assertEquals(6, m.getMonths());\n         assertEquals(9, m.getDays());\n     }\n \n     public void testSetIntoPeriod_Object2() throws Exception {\n-        MutablePeriod m = new MutablePeriod(PeriodType.getYearWeekType());\n-        StringConverter.INSTANCE.setInto(m, \"P2Y4W3DT12H24M48S\");\n+        MutablePeriod m = new MutablePeriod(PeriodType.yearWeekDayTime());\n+        StringConverter.INSTANCE.setInto(m, \"P2Y4W3DT12H24M48S\", null);\n         assertEquals(2, m.getYears());\n         assertEquals(4, m.getWeeks());\n         assertEquals(3, m.getDays());\n     }        \n \n     public void testSetIntoPeriod_Object3() throws Exception {\n-        MutablePeriod m = new MutablePeriod(1, 0, 1, 1, 1, 1, 1, 1, PeriodType.getYearWeekType());\n-        StringConverter.INSTANCE.setInto(m, \"P2Y4W3D\");\n+        MutablePeriod m = new MutablePeriod(1, 0, 1, 1, 1, 1, 1, 1, PeriodType.yearWeekDayTime());\n+        StringConverter.INSTANCE.setInto(m, \"P2Y4W3D\", null);\n         assertEquals(2, m.getYears());\n         assertEquals(4, m.getWeeks());\n         assertEquals(3, m.getDays());\n     public void testSetIntoPeriod_Object4() throws Exception {\n         MutablePeriod m = new MutablePeriod();\n         try {\n-            StringConverter.INSTANCE.setInto(m, \"\");\n-            fail();\n-        } catch (IllegalArgumentException ex) {}\n-        \n-        try {\n-            StringConverter.INSTANCE.setInto(m, \"PXY\");\n-            fail();\n-        } catch (IllegalArgumentException ex) {}\n-        \n-        try {\n-            StringConverter.INSTANCE.setInto(m, \"PT0SXY\");\n+            StringConverter.INSTANCE.setInto(m, \"\", null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        \n+        try {\n+            StringConverter.INSTANCE.setInto(m, \"PXY\", null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        \n+        try {\n+            StringConverter.INSTANCE.setInto(m, \"PT0SXY\", null);\n             fail();\n         } catch (IllegalArgumentException ex) {}\n     }\n--- a/JodaTime/src/test/org/joda/time/format/TestISOPeriodFormat.java\n+++ b/JodaTime/src/test/org/joda/time/format/TestISOPeriodFormat.java\n     \n     private static final Period PERIOD = new Period(1, 2, 3, 4, 5, 6, 7, 8);\n     private static final Period EMPTY_PERIOD = new Period(0, 0, 0, 0, 0, 0, 0, 0);\n-    private static final Period YEAR_DAY_PERIOD = new Period(1, 0, 0, 4, 5, 6, 7, 8, PeriodType.getYearDayType());\n-    private static final Period EMPTY_YEAR_DAY_PERIOD = new Period(0, 0, 0, 0, 0, 0, 0, 0, PeriodType.getYearDayType());\n+    private static final Period YEAR_DAY_PERIOD = new Period(1, 0, 0, 4, 5, 6, 7, 8, PeriodType.yearDayTime());\n+    private static final Period EMPTY_YEAR_DAY_PERIOD = new Period(0, 0, 0, 0, 0, 0, 0, 0, PeriodType.yearDayTime());\n     private static final Period TIME_PERIOD = new Period(0, 0, 0, 0, 5, 6, 7, 8);\n     private static final Period DATE_PERIOD = new Period(1, 2, 3, 4, 0, 0, 0, 0);\n \n         \n         p = new Period(0);\n         assertEquals(\"PT0S\", ISOPeriodFormat.getInstance().standard().print(p));\n-        p = new Period(0, PeriodType.getAllType().withMillisRemoved().withSecondsRemoved());\n+        p = new Period(0, PeriodType.standard().withMillisRemoved().withSecondsRemoved());\n         assertEquals(\"PT0M\", ISOPeriodFormat.getInstance().standard().print(p));\n         \n         assertEquals(\"P1Y4DT5H6M7.008S\", ISOPeriodFormat.getInstance().standard().print(YEAR_DAY_PERIOD));\n         \n         p = new Period(0);\n         assertEquals(\"P00000000T000000\", ISOPeriodFormat.getInstance().alternate().print(p));\n-        p = new Period(0, PeriodType.getAllType().withMillisRemoved().withSecondsRemoved());\n+        p = new Period(0, PeriodType.standard().withMillisRemoved().withSecondsRemoved());\n         assertEquals(\"P00000000T000000\", ISOPeriodFormat.getInstance().alternate().print(p));\n         \n         assertEquals(\"P00010004T050607.008\", ISOPeriodFormat.getInstance().alternate().print(YEAR_DAY_PERIOD));\n         \n         p = new Period(0);\n         assertEquals(\"P0000-00-00T00:00:00\", ISOPeriodFormat.getInstance().alternateExtended().print(p));\n-        p = new Period(0, PeriodType.getAllType().withMillisRemoved().withSecondsRemoved());\n+        p = new Period(0, PeriodType.standard().withMillisRemoved().withSecondsRemoved());\n         assertEquals(\"P0000-00-00T00:00:00\", ISOPeriodFormat.getInstance().alternateExtended().print(p));\n         \n         assertEquals(\"P0001-00-04T05:06:07.008\", ISOPeriodFormat.getInstance().alternateExtended().print(YEAR_DAY_PERIOD));\n         \n         p = new Period(0);\n         assertEquals(\"P0000W0000T000000\", ISOPeriodFormat.getInstance().alternateWithWeeks().print(p));\n-        p = new Period(0, PeriodType.getAllType().withMillisRemoved().withSecondsRemoved());\n+        p = new Period(0, PeriodType.standard().withMillisRemoved().withSecondsRemoved());\n         assertEquals(\"P0000W0000T000000\", ISOPeriodFormat.getInstance().alternateWithWeeks().print(p));\n         \n         assertEquals(\"P0001W0004T050607.008\", ISOPeriodFormat.getInstance().alternateWithWeeks().print(YEAR_DAY_PERIOD));\n         \n         p = new Period(0);\n         assertEquals(\"P0000-W00-00T00:00:00\", ISOPeriodFormat.getInstance().alternateExtendedWithWeeks().print(p));\n-        p = new Period(0, PeriodType.getAllType().withMillisRemoved().withSecondsRemoved());\n+        p = new Period(0, PeriodType.standard().withMillisRemoved().withSecondsRemoved());\n         assertEquals(\"P0000-W00-00T00:00:00\", ISOPeriodFormat.getInstance().alternateExtendedWithWeeks().print(p));\n         \n         assertEquals(\"P0001-W00-04T05:06:07.008\", ISOPeriodFormat.getInstance().alternateExtendedWithWeeks().print(YEAR_DAY_PERIOD));\n--- a/JodaTime/src/test/org/joda/time/format/TestPeriodFormatterBuilder.java\n+++ b/JodaTime/src/test/org/joda/time/format/TestPeriodFormatterBuilder.java\n     \n     private static final Period PERIOD = new Period(1, 2, 3, 4, 5, 6, 7, 8);\n     private static final Period EMPTY_PERIOD = new Period(0, 0, 0, 0, 0, 0, 0, 0);\n-    private static final Period YEAR_DAY_PERIOD = new Period(1, 0, 0, 4, 5, 6, 7, 8, PeriodType.getYearDayType());\n-    private static final Period EMPTY_YEAR_DAY_PERIOD = new Period(0, 0, 0, 0, 0, 0, 0, 0, PeriodType.getYearDayType());\n+    private static final Period YEAR_DAY_PERIOD = new Period(1, 0, 0, 4, 5, 6, 7, 8, PeriodType.yearDayTime());\n+    private static final Period EMPTY_YEAR_DAY_PERIOD = new Period(0, 0, 0, 0, 0, 0, 0, 0, PeriodType.yearDayTime());\n     private static final Period TIME_PERIOD = new Period(0, 0, 0, 0, 5, 6, 7, 8);\n     private static final Period DATE_PERIOD = new Period(1, 2, 3, 4, 0, 0, 0, 0);\n ", "timestamp": 1094341706, "metainfo": ""}