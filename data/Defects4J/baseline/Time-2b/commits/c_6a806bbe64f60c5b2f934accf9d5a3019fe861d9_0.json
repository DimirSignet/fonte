{"sha": "6a806bbe64f60c5b2f934accf9d5a3019fe861d9", "log": "Test DurationType   ", "commit": "\n--- a/JodaTime/src/java/org/joda/time/DurationType.java\n+++ b/JodaTime/src/java/org/joda/time/DurationType.java\n  * <li>YearMonth - the duration is expressed using all fields except weeks\n  * <li>YearWeek - the duration is expressed using all fields except months\n  * <li>AverageYearMonth - as YearMonth, but years and months have fixed average lengths\n- * <li>PreciseYearMonth - as YearMonth, but years are fixed at 365 days,\n+ * <li>PreciseAll - as All, but years are fixed at 365 days\n+ *  and months are fixed at 30 days\n+ * <li>PreciseYearMonth - as YearMonth, but years are fixed at 365 days\n  *  and months are fixed at 30 days\n  * <li>PreciseYearWeek - as YearWeek, but years are fixed at 365 days\n  * </ul>\n  *\n  * <p>\n- * DurationType is thread-safe and immutable, and all subclasses must be as\n- * well.\n+ * DurationType is thread-safe and immutable, and all subclasses must be as well.\n  *\n  * @author Brian S O'Neill\n+ * @author Stephen Colebourne\n+ * @since 1.0\n  */\n public abstract class DurationType implements Serializable {\n-    static final long serialVersionUID = 2274324892792009998L;\n+    private static final long serialVersionUID = 2274324892792009998L;\n \n     private static final DurationType MILLIS_TYPE;\n+    private static final DurationType DAY_HOUR_TYPE;\n+    private static final DurationType ALL_TYPE;\n+    private static final DurationType YEAR_MONTH_TYPE;\n+    private static final DurationType YEAR_WEEK_TYPE;\n     private static final DurationType AVERAGE_YEAR_MONTH_TYPE;\n+    private static final DurationType PRECISE_ALL_TYPE;\n     private static final DurationType PRECISE_YEAR_MONTH_TYPE;\n+    private static final DurationType PRECISE_YEAR_WEEK_TYPE;\n \n     static {\n         MILLIS_TYPE = new MillisType();\n+        DAY_HOUR_TYPE = new DayHourType(ISOChronology.getInstanceUTC());\n+        ALL_TYPE = new AllType(ISOChronology.getInstanceUTC());\n+        YEAR_MONTH_TYPE = new YearMonthType(ISOChronology.getInstanceUTC());\n+        YEAR_WEEK_TYPE = new YearWeekType(ISOChronology.getInstanceUTC());\n         AVERAGE_YEAR_MONTH_TYPE = new AverageYearMonthType(ISOChronology.getInstanceUTC());\n+        PRECISE_ALL_TYPE = new PreciseAllType(ISOChronology.getInstanceUTC());\n         PRECISE_YEAR_MONTH_TYPE = new PreciseYearMonthType(ISOChronology.getInstanceUTC());\n-    }\n-\n-    // TODO: Many more caching opportunities\n-\n-    /**\n-     * Returns a DurationType of only a milliseconds field.\n+        PRECISE_YEAR_WEEK_TYPE = new PreciseYearWeekType(ISOChronology.getInstanceUTC());\n+    }\n+\n+    /**\n+     * Returns a DurationType of only a milliseconds field using the ISOChronology.\n      */\n     public static DurationType getMillisType() {\n         return MILLIS_TYPE;\n     }\n \n     /**\n-     * Returns a DurationType of:\n+     * Returns a DurationType using the ISOChronology of:\n      *\n      * <ul>\n      * <li>days\n      * </ul>\n      */\n     public static DurationType getDayHourType() {\n-        return getDayHourType(null);\n+        return DAY_HOUR_TYPE;\n     }\n \n     /**\n      * @param chrono Chronology to use for calculations.\n      */\n     public static DurationType getDayHourType(Chronology chrono) {\n-        if (chrono == null) {\n-            chrono = ISOChronology.getInstanceUTC();\n+        if (chrono == null || chrono.equals(ISOChronology.getInstanceUTC())) {\n+            return getDayHourType();\n         }\n         return new DayHourType(chrono);\n     }\n \n     /**\n-     * Returns a DurationType of:\n+     * Returns a DurationType using the ISOChronology of:\n      *\n      * <ul>\n      * <li>years\n      * </ul>\n      */\n     public static DurationType getAllType() {\n-        return getAllType(null);\n+        return ALL_TYPE;\n     }\n \n     /**\n      * @param chrono Chronology to use for calculations.\n      */\n     public static DurationType getAllType(Chronology chrono) {\n-        if (chrono == null) {\n-            chrono = ISOChronology.getInstanceUTC();\n+        if (chrono == null || chrono.equals(ISOChronology.getInstanceUTC())) {\n+            return getAllType();\n         }\n         return new AllType(chrono);\n     }\n \n     /**\n-     * Returns a DurationType of:\n+     * Returns a DurationType using the ISOChronology of:\n      *\n      * <ul>\n      * <li>years\n      * </ul>\n      */\n     public static DurationType getYearMonthType() {\n-        return getYearMonthType(null);\n+        return YEAR_MONTH_TYPE;\n     }\n \n     /**\n      * @param chrono Chronology to use for calculations.\n      */\n     public static DurationType getYearMonthType(Chronology chrono) {\n-        if (chrono == null) {\n-            chrono = ISOChronology.getInstanceUTC();\n+        if (chrono == null || chrono.equals(ISOChronology.getInstanceUTC())) {\n+            return getYearMonthType();\n         }\n         return new YearMonthType(chrono);\n     }\n \n     /**\n-     * Returns a DurationType of:\n+     * Returns a DurationType using the ISOChronology of:\n      *\n      * <ul>\n      * <li>years (weekyears)\n      * </ul>\n      */\n     public static DurationType getYearWeekType() {\n-        return getYearWeekType(null);\n+        return YEAR_WEEK_TYPE;\n     }\n \n     /**\n      * @param chrono Chronology to use for calculations.\n      */\n     public static DurationType getYearWeekType(Chronology chrono) {\n-        if (chrono == null) {\n-            chrono = ISOChronology.getInstanceUTC();\n+        if (chrono == null || chrono.equals(ISOChronology.getInstanceUTC())) {\n+            return getYearWeekType();\n         }\n         return new YearWeekType(chrono);\n     }\n \n     /**\n-     * Returns a precise DurationType of:\n+     * Returns a precise DurationType using the ISOChronology of:\n      *\n      * <ul>\n      * <li>years (fixed at 365.2425 days)\n     }\n \n     /**\n-     * Returns a precise DurationType of:\n+     * Returns a DurationType, normally precise, of:\n      *\n      * <ul>\n      * <li>years (fixed to chronology's average year)\n      * be UTC or have fixed offsets.\n      *\n      * @param chrono Chronology to use for calculations.\n-     * @throws IllegalArgumentException if chronology produces an imprecise duration type\n      */\n     public static DurationType getAverageYearMonthType(Chronology chrono) {\n         if (chrono == null || chrono.equals(ISOChronology.getInstanceUTC())) {\n             return getAverageYearMonthType();\n         }\n-        DurationType type = new AverageYearMonthType(chrono);\n-        if (!type.isPrecise()) {\n-            throw new IllegalArgumentException\n-                (\"Chronology produced an imprecise duration type\");\n-        }\n-        return type;\n-    }\n-\n-    /**\n-     * Returns a precise DurationType of:\n+        return new AverageYearMonthType(chrono);\n+    }\n+\n+    /**\n+     * Returns a precise DurationType using the ISOChronology of:\n      *\n      * <ul>\n      * <li>years (fixed at 365 days)\n      * <li>months (fixed at 30 days)\n+     * <li>weeks\n+     * <li>days\n+     * <li>hours\n+     * <li>minutes\n+     * <li>seconds\n+     * <li>milliseconds\n+     * </ul>\n+     */\n+    public static DurationType getPreciseAllType() {\n+        return PRECISE_ALL_TYPE;\n+    }\n+\n+    /**\n+     * Returns a precise DurationType using the ISOChronology of:\n+     *\n+     * <ul>\n+     * <li>years (fixed at 365 days)\n+     * <li>months (fixed at 30 days)\n      * <li>days\n      * <li>hours\n      * <li>minutes\n     }\n \n     /**\n-     * Returns a precise DurationType of:\n+     * Returns a precise DurationType using the ISOChronology of:\n      *\n      * <ul>\n      * <li>years (fixed at 365 days)\n      * </ul>\n      */\n     public static DurationType getPreciseYearWeekType() {\n-        return new PreciseYearWeekType(ISOChronology.getInstanceUTC());\n-    }\n-\n+        return PRECISE_YEAR_WEEK_TYPE;\n+    }\n+\n+    //-----------------------------------------------------------------------\n     /**\n      * Constructor.\n      */\n     /**\n      * Returns a DurationType that uses the given chronology.\n      * \n-     * @param chrono  the new chronology\n+     * @param chrono  the new chronology, null means ISOChronology in UTC\n      * @return a new duration type with the specified chronology\n      */\n     public abstract DurationType withChronology(Chronology chrono);\n      */\n     public abstract boolean isPrecise();\n \n+    //-----------------------------------------------------------------------\n     /**\n      * Returns a DurationField representing years.\n      *\n         return UnsupportedDurationField.getInstance(\"millis\");\n     }\n \n-    /**\n-     * Returns a version of this DurationType instance that does not support\n-     * years.\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a version of this DurationType instance that does not support years.\n+     * \n+     * @return a new duration type that supports the original set of fields except years\n      */\n     public DurationType withYearsRemoved() {\n         if (!years().isSupported()) {\n     }\n \n     /**\n-     * Returns a version of this DurationType instance that does not support\n-     * months.\n+     * Returns a version of this DurationType instance that does not support months.\n+     * \n+     * @return a new duration type that supports the original set of fields except months\n      */\n     public DurationType withMonthsRemoved() {\n         if (!months().isSupported()) {\n     }\n \n     /**\n-     * Returns a version of this DurationType instance that does not support\n-     * weeks.\n+     * Returns a version of this DurationType instance that does not support weeks.\n+     * \n+     * @return a new duration type that supports the original set of fields except weeks\n      */\n     public DurationType withWeeksRemoved() {\n         if (!weeks().isSupported()) {\n     }\n \n     /**\n-     * Returns a version of this DurationType instance that does not support\n-     * days.\n+     * Returns a version of this DurationType instance that does not support days.\n+     * \n+     * @return a new duration type that supports the original set of fields except days\n      */\n     public DurationType withDaysRemoved() {\n         if (!days().isSupported()) {\n     }\n \n     /**\n-     * Returns a version of this DurationType instance that does not support\n-     * hours.\n+     * Returns a version of this DurationType instance that does not support hours.\n+     * \n+     * @return a new duration type that supports the original set of fields except hours\n      */\n     public DurationType withHoursRemoved() {\n         if (!hours().isSupported()) {\n     }\n \n     /**\n-     * Returns a version of this DurationType instance that does not support\n-     * minutes.\n+     * Returns a version of this DurationType instance that does not support minutes.\n+     * \n+     * @return a new duration type that supports the original set of fields except minutes\n      */\n     public DurationType withMinutesRemoved() {\n         if (!minutes().isSupported()) {\n     }\n \n     /**\n-     * Returns a version of this DurationType instance that does not support\n-     * seconds.\n+     * Returns a version of this DurationType instance that does not support seconds.\n+     * \n+     * @return a new duration type that supports the original set of fields except seconds\n      */\n     public DurationType withSecondsRemoved() {\n         if (!seconds().isSupported()) {\n     }\n \n     /**\n-     * Returns a version of this DurationType instance that does not support\n-     * milliseconds.\n+     * Returns a version of this DurationType instance that does not support milliseconds.\n+     * \n+     * @return a new duration type that supports the original set of fields except milliseconds\n      */\n     public DurationType withMillisRemoved() {\n         if (!millis().isSupported()) {\n         return MaskedType.mask(this, 1 << 7);\n     }\n \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Compares this type to another object.\n+     * To be equal, the object must be a DurationType with the same chronology\n+     * and same supported fields.\n+     * \n+     * @param obj  the object to compare to\n+     * @return true if equal\n+     */\n     public boolean equals(Object obj) {\n         if (this == obj) {\n             return true;\n             && millis().equals(other.millis());\n     }\n \n+    /**\n+     * Returns a hashcode based on the chronology and supported fields.\n+     * \n+     * @return a suitable hashcode\n+     */\n     public int hashCode() {\n         int hash = 0;\n         Chronology chrono = getChronology();\n \n     //-----------------------------------------------------------------------\n     private static final class MillisType extends DurationType {\n-        static final long serialVersionUID = -4314867016852780422L;\n+        private static final long serialVersionUID = -4314867016852780422L;\n \n         public MillisType() {\n         }\n     }\n \n     private static class DayHourType extends DurationType {\n-        static final long serialVersionUID = 1115025839896760481L;\n+        private static final long serialVersionUID = 1115025839896760481L;\n \n         protected final Chronology iChronology;\n \n             if (chrono == iChronology) {\n                 return this;\n             }\n-            return new DayHourType(iChronology);\n+            return DurationType.getDayHourType(chrono);\n         }\n \n         public boolean isPrecise() {\n     }\n \n     private static final class AllType extends DayHourType {\n-        static final long serialVersionUID = -1336767257680877683L;\n+        private static final long serialVersionUID = -359769822629866L;\n \n         public AllType(Chronology chrono) {\n             super(chrono);\n             if (chrono == iChronology) {\n                 return this;\n             }\n-            return new AllType(iChronology);\n+            return DurationType.getAllType(chrono);\n         }\n \n         public boolean isPrecise() {\n     }\n \n     private static final class YearMonthType extends DayHourType {\n-        static final long serialVersionUID = -1336767257680877683L;\n+        private static final long serialVersionUID = -1336767257680877683L;\n \n         public YearMonthType(Chronology chrono) {\n             super(chrono);\n             if (chrono == iChronology) {\n                 return this;\n             }\n-            return new YearMonthType(iChronology);\n+            return DurationType.getYearMonthType(chrono);\n         }\n \n         public boolean isPrecise() {\n     }\n \n     private static final class YearWeekType extends DayHourType {\n-        static final long serialVersionUID = 1347170237843447098L;\n+        private static final long serialVersionUID = 1347170237843447098L;\n \n         public YearWeekType(Chronology chrono) {\n             super(chrono);\n             if (chrono == iChronology) {\n                 return this;\n             }\n-            return new YearWeekType(iChronology);\n+            return DurationType.getYearWeekType(chrono);\n         }\n \n         public boolean isPrecise() {\n     }\n \n     private static final class AverageYearMonthType extends DayHourType {\n-        static final long serialVersionUID = -1629017135050918461L;\n+        private static final long serialVersionUID = -1629017135050918461L;\n \n         private final DurationField iYears;\n         private final DurationField iMonths;\n             if (chrono == iChronology) {\n                 return this;\n             }\n-            return getAverageYearMonthType(chrono);\n+            return DurationType.getAverageYearMonthType(chrono);\n         }\n \n         public DurationField years() {\n         }\n     }\n \n+    private static final class PreciseAllType extends DayHourType {\n+        private static final long serialVersionUID = 43967269280186L;\n+\n+        private final DurationField iYears;\n+        private final DurationField iMonths;\n+        \n+        public PreciseAllType(Chronology chrono) {\n+            super(chrono);\n+            iYears = new ScaledDurationField(chrono.days(), \"PreciseYears\", 365);\n+            iMonths = new ScaledDurationField(chrono.days(), \"PreciseMonths\", 30);\n+        }\n+\n+        public DurationType withChronology(Chronology chrono) {\n+            return this;\n+        }\n+\n+        public boolean isPrecise() {\n+            return years().isPrecise()\n+                && months().isPrecise()\n+                && weeks().isPrecise()\n+                && super.isPrecise();\n+        }\n+\n+        public DurationField years() {\n+            return iYears;\n+        }\n+\n+        public DurationField months() {\n+            return iMonths;\n+        }\n+\n+        public DurationField weeks() {\n+            return iChronology.weeks();\n+        }\n+\n+        private Object readResolve() {\n+            return getPreciseAllType();\n+        }\n+        \n+        public String getName() {\n+            return \"PreciseAllType\";\n+        }\n+    }\n+\n     private static final class PreciseYearMonthType extends DayHourType {\n-        static final long serialVersionUID = 1203161678926193794L;\n+        private static final long serialVersionUID = 1203161678926193794L;\n \n         private final DurationField iYears;\n         private final DurationField iMonths;\n     }\n \n     private static final class PreciseYearWeekType extends DayHourType {\n-        static final long serialVersionUID = -2040324323318740267L;\n+        private static final long serialVersionUID = -2040324323318740267L;\n \n         private final DurationField iYears;\n         \n     }\n \n     private static final class MaskedType extends DurationType {\n-        static final long serialVersionUID = 940106774669244586L;\n+        private static final long serialVersionUID = 940106774669244586L;\n \n         public static DurationType mask(DurationType type, int mask) {\n             if (type instanceof MaskedType) {\n                 MaskedType masked = (MaskedType)type;\n-                if ((mask |= masked.iMask) == masked.iMask) {\n-                    // No additional fields removed, so return original.\n-                    return masked;\n-                }\n+                mask |= masked.iMask;\n                 type = masked.iType;\n             }\n             return new MaskedType(type, mask);\n             if (chrono == getChronology()) {\n                 return this;\n             }\n-            return mask(iType.withChronology(chrono), iMask);\n+            return MaskedType.mask(iType.withChronology(chrono), iMask);\n         }\n \n         public boolean isPrecise() {\n         \n         public String getName() {\n             String name = iType.getName();\n-            return \"Masked[\" + (name == null ? \"\" : name) + \"]\";\n+            String maskStr = \"\";\n+            if ((iMask & (1 << 0)) != 0) {\n+                maskStr += \"Years\";\n+            }\n+            if ((iMask & (1 << 1)) != 0) {\n+                maskStr += \"Months\";\n+            }\n+            if ((iMask & (1 << 2)) != 0) {\n+                maskStr += \"Weeks\";\n+            }\n+            if ((iMask & (1 << 3)) != 0) {\n+                maskStr += \"Days\";\n+            }\n+            if ((iMask & (1 << 4)) != 0) {\n+                maskStr += \"Hours\";\n+            }\n+            if ((iMask & (1 << 5)) != 0) {\n+                maskStr += \"Minutes\";\n+            }\n+            if ((iMask & (1 << 6)) != 0) {\n+                maskStr += \"Seconds\";\n+            }\n+            if ((iMask & (1 << 7)) != 0) {\n+                maskStr += \"Millis\";\n+            }\n+            return \"Masked\" + maskStr + \"[\" + (name == null ? \"\" : name) + \"]\";\n         }\n     }\n \n--- a/JodaTime/src/test/org/joda/time/TestAll.java\n+++ b/JodaTime/src/test/org/joda/time/TestAll.java\n         suite.addTest(TestDateTimeConstants.suite());\n         suite.addTest(TestDateTimeUtils.suite());\n         suite.addTest(TestDateTimeZone.suite());\n+        suite.addTest(TestDurationType.suite());\n //        suite.addTest(TestParseISO.suite());\n         return suite;\n     }\n--- /dev/null\n+++ b/JodaTime/src/test/org/joda/time/TestDurationType.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.lang.reflect.Modifier;\n+import java.util.Locale;\n+import java.util.TimeZone;\n+\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+import org.joda.time.chrono.BuddhistChronology;\n+import org.joda.time.chrono.CopticChronology;\n+import org.joda.time.chrono.ISOChronology;\n+\n+/**\n+ * This class is a JUnit test for DurationType.\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class TestDurationType extends TestCase {\n+    // Test in 2002/03 as time zones are more well known\n+    // (before the late 90's they were all over the place)\n+\n+    private static final DateTimeZone PARIS = DateTimeZone.getInstance(\"Europe/Paris\");\n+    private static final DateTimeZone LONDON = DateTimeZone.getInstance(\"Europe/London\");\n+    \n+    long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + \n+                     366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + \n+                     365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +\n+                     366 + 365;\n+    long y2003days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + \n+                     366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + \n+                     365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +\n+                     366 + 365 + 365;\n+    \n+    // 2002-06-09\n+    private long TEST_TIME_NOW =\n+            (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;\n+            \n+    // 2002-04-05\n+    private long TEST_TIME1 =\n+            (y2002days + 31L + 28L + 31L + 5L -1L) * DateTimeConstants.MILLIS_PER_DAY\n+            + 12L * DateTimeConstants.MILLIS_PER_HOUR\n+            + 24L * DateTimeConstants.MILLIS_PER_MINUTE;\n+        \n+    // 2003-05-06\n+    private long TEST_TIME2 =\n+            (y2003days + 31L + 28L + 31L + 30L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY\n+            + 14L * DateTimeConstants.MILLIS_PER_HOUR\n+            + 28L * DateTimeConstants.MILLIS_PER_MINUTE;\n+    \n+    private DateTimeZone originalDateTimeZone = null;\n+    private TimeZone originalTimeZone = null;\n+    private Locale originalLocale = null;\n+\n+    public static void main(String[] args) {\n+        junit.textui.TestRunner.run(suite());\n+    }\n+\n+    public static TestSuite suite() {\n+        return new TestSuite(TestDurationType.class);\n+    }\n+\n+    public TestDurationType(String name) {\n+        super(name);\n+    }\n+\n+    protected void setUp() throws Exception {\n+        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);\n+        originalDateTimeZone = DateTimeZone.getDefault();\n+        originalTimeZone = TimeZone.getDefault();\n+        originalLocale = Locale.getDefault();\n+        DateTimeZone.setDefault(LONDON);\n+        TimeZone.setDefault(TimeZone.getTimeZone(\"Europe/London\"));\n+        Locale.setDefault(Locale.UK);\n+    }\n+\n+    protected void tearDown() throws Exception {\n+        DateTimeUtils.setCurrentMillisSystem();\n+        DateTimeZone.setDefault(originalDateTimeZone);\n+        TimeZone.setDefault(originalTimeZone);\n+        Locale.setDefault(originalLocale);\n+        originalDateTimeZone = null;\n+        originalTimeZone = null;\n+        originalLocale = null;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testTest() {\n+        assertEquals(\"2002-06-09T00:00:00.000Z\", new Instant(TEST_TIME_NOW).toString());\n+        assertEquals(\"2002-04-05T12:24:00.000Z\", new Instant(TEST_TIME1).toString());\n+        assertEquals(\"2003-05-06T14:28:00.000Z\", new Instant(TEST_TIME2).toString());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    private void assertEqualsAfterSerialization(DurationType type) throws Exception {\n+        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+        ObjectOutputStream oos = new ObjectOutputStream(baos);\n+        oos.writeObject(type);\n+        byte[] bytes = baos.toByteArray();\n+        oos.close();\n+        \n+        ByteArrayInputStream bais = new ByteArrayInputStream(bytes);\n+        ObjectInputStream ois = new ObjectInputStream(bais);\n+        DurationType result = (DurationType) ois.readObject();\n+        ois.close();\n+        \n+        assertEquals(type, result);\n+    }\n+\n+    private void assertSameAfterSerialization(DurationType type) throws Exception {\n+        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+        ObjectOutputStream oos = new ObjectOutputStream(baos);\n+        oos.writeObject(type);\n+        byte[] bytes = baos.toByteArray();\n+        oos.close();\n+        \n+        ByteArrayInputStream bais = new ByteArrayInputStream(bytes);\n+        ObjectInputStream ois = new ObjectInputStream(bais);\n+        DurationType result = (DurationType) ois.readObject();\n+        ois.close();\n+        \n+        assertSame(type, result);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testMillisType() throws Exception {\n+        DurationType type = DurationType.getMillisType();\n+        assertEquals(false, type.years().isSupported());\n+        assertEquals(false, type.months().isSupported());\n+        assertEquals(false, type.weeks().isSupported());\n+        assertEquals(false, type.days().isSupported());\n+        assertEquals(false, type.hours().isSupported());\n+        assertEquals(false, type.minutes().isSupported());\n+        assertEquals(false, type.seconds().isSupported());\n+        assertEquals(true, type.millis().isSupported());\n+        assertEquals(true, type.isPrecise());\n+        assertEquals(null, type.getChronology());\n+        assertEquals(true, type.equals(type));\n+        assertEquals(true, type == DurationType.getMillisType());\n+        assertEquals(false, type.equals(DurationType.getAllType()));\n+        assertEquals(true, type.hashCode() == type.hashCode());\n+        assertEquals(true, type.hashCode() == DurationType.getMillisType().hashCode());\n+        assertEquals(false, type.hashCode() == DurationType.getAllType().hashCode());\n+        assertEquals(\"MillisType\", type.getName());\n+        assertEquals(\"DurationType[MillisType]\", type.toString());\n+        assertSameAfterSerialization(type);\n+        assertSame(type, type.withChronology(null));\n+        assertSame(type, type.withChronology(CopticChronology.getInstanceUTC()));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testDayHourType() throws Exception {\n+        DurationType type = DurationType.getDayHourType();\n+        assertEquals(false, type.years().isSupported());\n+        assertEquals(false, type.months().isSupported());\n+        assertEquals(false, type.weeks().isSupported());\n+        assertEquals(true, type.days().isSupported());\n+        assertEquals(true, type.hours().isSupported());\n+        assertEquals(true, type.minutes().isSupported());\n+        assertEquals(true, type.seconds().isSupported());\n+        assertEquals(true, type.millis().isSupported());\n+        assertEquals(true, type.isPrecise());\n+        assertEquals(ISOChronology.getInstanceUTC(), type.getChronology());\n+        assertEquals(true, type.equals(type));\n+        assertEquals(true, type == DurationType.getDayHourType());\n+        assertEquals(false, type.equals(DurationType.getAllType()));\n+        assertEquals(true, type.hashCode() == type.hashCode());\n+        assertEquals(true, type.hashCode() == DurationType.getDayHourType().hashCode());\n+        assertEquals(false, type.hashCode() == DurationType.getAllType().hashCode());\n+        assertEquals(\"DayHourType\", type.getName());\n+        assertEquals(\"DurationType[DayHourType]\", type.toString());\n+        assertSameAfterSerialization(type);\n+        assertSame(type, type.withChronology(null));\n+        assertSame(type, type.withChronology(ISOChronology.getInstanceUTC()));\n+        assertEquals(CopticChronology.getInstanceUTC(), type.withChronology(CopticChronology.getInstanceUTC()).getChronology());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testDayHourType_Chronology() throws Exception {\n+        DurationType type = DurationType.getDayHourType(BuddhistChronology.getInstanceUTC());\n+        assertEquals(false, type.years().isSupported());\n+        assertEquals(false, type.months().isSupported());\n+        assertEquals(false, type.weeks().isSupported());\n+        assertEquals(true, type.days().isSupported());\n+        assertEquals(true, type.hours().isSupported());\n+        assertEquals(true, type.minutes().isSupported());\n+        assertEquals(true, type.seconds().isSupported());\n+        assertEquals(true, type.millis().isSupported());\n+        assertEquals(true, type.isPrecise());\n+        assertEquals(BuddhistChronology.getInstanceUTC(), type.getChronology());\n+        assertEquals(true, type.equals(type));\n+        assertEquals(true, DurationType.getDayHourType() == DurationType.getDayHourType(null));\n+        assertEquals(true, DurationType.getDayHourType() == DurationType.getDayHourType(ISOChronology.getInstanceUTC()));\n+        assertEquals(true, type.equals(DurationType.getDayHourType(BuddhistChronology.getInstanceUTC())));\n+        assertEquals(false, type.equals(DurationType.getDayHourType()));\n+        assertEquals(false, type.equals(DurationType.getAllType()));\n+        assertEquals(true, type.hashCode() == type.hashCode());\n+        assertEquals(false, type.hashCode() == DurationType.getDayHourType().hashCode());\n+        assertEquals(false, type.hashCode() == DurationType.getAllType().hashCode());\n+        assertEquals(\"DayHourType\", type.getName());\n+        assertEquals(\"DurationType[DayHourType]\", type.toString());\n+        assertEqualsAfterSerialization(type);\n+        assertSame(DurationType.getDayHourType(), type.withChronology(null));\n+        assertSame(DurationType.getDayHourType(), type.withChronology(ISOChronology.getInstanceUTC()));\n+        assertEquals(CopticChronology.getInstanceUTC(), type.withChronology(CopticChronology.getInstanceUTC()).getChronology());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testYearWeekType() throws Exception {\n+        DurationType type = DurationType.getYearWeekType();\n+        assertEquals(true, type.years().isSupported());\n+        assertEquals(false, type.months().isSupported());\n+        assertEquals(true, type.weeks().isSupported());\n+        assertEquals(true, type.days().isSupported());\n+        assertEquals(true, type.hours().isSupported());\n+        assertEquals(true, type.minutes().isSupported());\n+        assertEquals(true, type.seconds().isSupported());\n+        assertEquals(true, type.millis().isSupported());\n+        assertEquals(false, type.isPrecise());\n+        assertEquals(ISOChronology.getInstanceUTC(), type.getChronology());\n+        assertEquals(true, type.equals(type));\n+        assertEquals(true, type == DurationType.getYearWeekType());\n+        assertEquals(false, type.equals(DurationType.getAllType()));\n+        assertEquals(true, type.hashCode() == type.hashCode());\n+        assertEquals(true, type.hashCode() == DurationType.getYearWeekType().hashCode());\n+        assertEquals(false, type.hashCode() == DurationType.getAllType().hashCode());\n+        assertEquals(\"YearWeekType\", type.getName());\n+        assertEquals(\"DurationType[YearWeekType]\", type.toString());\n+        assertSameAfterSerialization(type);\n+        assertSame(type, type.withChronology(null));\n+        assertSame(type, type.withChronology(ISOChronology.getInstanceUTC()));\n+        assertEquals(CopticChronology.getInstanceUTC(), type.withChronology(CopticChronology.getInstanceUTC()).getChronology());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testYearWeekType_Chronology() throws Exception {\n+        DurationType type = DurationType.getYearWeekType(BuddhistChronology.getInstanceUTC());\n+        assertEquals(true, type.years().isSupported());\n+        assertEquals(false, type.months().isSupported());\n+        assertEquals(true, type.weeks().isSupported());\n+        assertEquals(true, type.days().isSupported());\n+        assertEquals(true, type.hours().isSupported());\n+        assertEquals(true, type.minutes().isSupported());\n+        assertEquals(true, type.seconds().isSupported());\n+        assertEquals(true, type.millis().isSupported());\n+        assertEquals(false, type.isPrecise());\n+        assertEquals(BuddhistChronology.getInstanceUTC(), type.getChronology());\n+        assertEquals(true, type.equals(type));\n+        assertEquals(true, DurationType.getYearWeekType() == DurationType.getYearWeekType(null));\n+        assertEquals(true, DurationType.getYearWeekType() == DurationType.getYearWeekType(ISOChronology.getInstanceUTC()));\n+        assertEquals(true, type.equals(DurationType.getYearWeekType(BuddhistChronology.getInstanceUTC())));\n+        assertEquals(false, type.equals(DurationType.getYearWeekType()));\n+        assertEquals(false, type.equals(DurationType.getAllType()));\n+        assertEquals(true, type.hashCode() == type.hashCode());\n+        assertEquals(false, type.hashCode() == DurationType.getYearWeekType().hashCode());\n+        assertEquals(false, type.hashCode() == DurationType.getAllType().hashCode());\n+        assertEquals(\"YearWeekType\", type.getName());\n+        assertEquals(\"DurationType[YearWeekType]\", type.toString());\n+        assertEqualsAfterSerialization(type);\n+        assertSame(DurationType.getYearWeekType(), type.withChronology(null));\n+        assertSame(DurationType.getYearWeekType(), type.withChronology(ISOChronology.getInstanceUTC()));\n+        assertEquals(CopticChronology.getInstanceUTC(), type.withChronology(CopticChronology.getInstanceUTC()).getChronology());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testYearMonthType() throws Exception {\n+        DurationType type = DurationType.getYearMonthType();\n+        assertEquals(true, type.years().isSupported());\n+        assertEquals(true, type.months().isSupported());\n+        assertEquals(false, type.weeks().isSupported());\n+        assertEquals(true, type.days().isSupported());\n+        assertEquals(true, type.hours().isSupported());\n+        assertEquals(true, type.minutes().isSupported());\n+        assertEquals(true, type.seconds().isSupported());\n+        assertEquals(true, type.millis().isSupported());\n+        assertEquals(false, type.isPrecise());\n+        assertEquals(ISOChronology.getInstanceUTC(), type.getChronology());\n+        assertEquals(true, type.equals(type));\n+        assertEquals(true, type == DurationType.getYearMonthType());\n+        assertEquals(false, type.equals(DurationType.getAllType()));\n+        assertEquals(true, type.hashCode() == type.hashCode());\n+        assertEquals(true, type.hashCode() == DurationType.getYearMonthType().hashCode());\n+        assertEquals(false, type.hashCode() == DurationType.getAllType().hashCode());\n+        assertEquals(\"YearMonthType\", type.getName());\n+        assertEquals(\"DurationType[YearMonthType]\", type.toString());\n+        assertSameAfterSerialization(type);\n+        assertSame(type, type.withChronology(null));\n+        assertSame(type, type.withChronology(ISOChronology.getInstanceUTC()));\n+        assertEquals(CopticChronology.getInstanceUTC(), type.withChronology(CopticChronology.getInstanceUTC()).getChronology());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testYearMonthType_Chronology() throws Exception {\n+        DurationType type = DurationType.getYearMonthType(BuddhistChronology.getInstanceUTC());\n+        assertEquals(true, type.years().isSupported());\n+        assertEquals(true, type.months().isSupported());\n+        assertEquals(false, type.weeks().isSupported());\n+        assertEquals(true, type.days().isSupported());\n+        assertEquals(true, type.hours().isSupported());\n+        assertEquals(true, type.minutes().isSupported());\n+        assertEquals(true, type.seconds().isSupported());\n+        assertEquals(true, type.millis().isSupported());\n+        assertEquals(false, type.isPrecise());\n+        assertEquals(BuddhistChronology.getInstanceUTC(), type.getChronology());\n+        assertEquals(true, type.equals(type));\n+        assertEquals(true, DurationType.getYearMonthType() == DurationType.getYearMonthType(null));\n+        assertEquals(true, DurationType.getYearMonthType() == DurationType.getYearMonthType(ISOChronology.getInstanceUTC()));\n+        assertEquals(true, type.equals(DurationType.getYearMonthType(BuddhistChronology.getInstanceUTC())));\n+        assertEquals(false, type.equals(DurationType.getYearMonthType()));\n+        assertEquals(false, type.equals(DurationType.getAllType()));\n+        assertEquals(true, type.hashCode() == type.hashCode());\n+        assertEquals(false, type.hashCode() == DurationType.getYearMonthType().hashCode());\n+        assertEquals(false, type.hashCode() == DurationType.getAllType().hashCode());\n+        assertEquals(\"YearMonthType\", type.getName());\n+        assertEquals(\"DurationType[YearMonthType]\", type.toString());\n+        assertEqualsAfterSerialization(type);\n+        assertSame(DurationType.getYearMonthType(), type.withChronology(null));\n+        assertSame(DurationType.getYearMonthType(), type.withChronology(ISOChronology.getInstanceUTC()));\n+        assertEquals(CopticChronology.getInstanceUTC(), type.withChronology(CopticChronology.getInstanceUTC()).getChronology());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testAllType() throws Exception {\n+        DurationType type = DurationType.getAllType();\n+        assertEquals(true, type.years().isSupported());\n+        assertEquals(true, type.months().isSupported());\n+        assertEquals(true, type.weeks().isSupported());\n+        assertEquals(true, type.days().isSupported());\n+        assertEquals(true, type.hours().isSupported());\n+        assertEquals(true, type.minutes().isSupported());\n+        assertEquals(true, type.seconds().isSupported());\n+        assertEquals(true, type.millis().isSupported());\n+        assertEquals(false, type.isPrecise());\n+        assertEquals(ISOChronology.getInstanceUTC(), type.getChronology());\n+        assertEquals(true, type.equals(type));\n+        assertEquals(true, type == DurationType.getAllType());\n+        assertEquals(false, type.equals(DurationType.getMillisType()));\n+        assertEquals(true, type.hashCode() == type.hashCode());\n+        assertEquals(true, type.hashCode() == DurationType.getAllType().hashCode());\n+        assertEquals(false, type.hashCode() == DurationType.getMillisType().hashCode());\n+        assertEquals(\"AllType\", type.getName());\n+        assertEquals(\"DurationType[AllType]\", type.toString());\n+        assertSameAfterSerialization(type);\n+        assertSame(type, type.withChronology(null));\n+        assertSame(type, type.withChronology(ISOChronology.getInstanceUTC()));\n+        assertEquals(CopticChronology.getInstanceUTC(), type.withChronology(CopticChronology.getInstanceUTC()).getChronology());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testAllType_Chronology() throws Exception {\n+        DurationType type = DurationType.getAllType(BuddhistChronology.getInstanceUTC());\n+        assertEquals(true, type.years().isSupported());\n+        assertEquals(true, type.months().isSupported());\n+        assertEquals(true, type.weeks().isSupported());\n+        assertEquals(true, type.days().isSupported());\n+        assertEquals(true, type.hours().isSupported());\n+        assertEquals(true, type.minutes().isSupported());\n+        assertEquals(true, type.seconds().isSupported());\n+        assertEquals(true, type.millis().isSupported());\n+        assertEquals(false, type.isPrecise());\n+        assertEquals(BuddhistChronology.getInstanceUTC(), type.getChronology());\n+        assertEquals(true, type.equals(type));\n+        assertEquals(true, DurationType.getAllType() == DurationType.getAllType(null));\n+        assertEquals(true, DurationType.getAllType() == DurationType.getAllType(ISOChronology.getInstanceUTC()));\n+        assertEquals(true, type.equals(DurationType.getAllType(BuddhistChronology.getInstanceUTC())));\n+        assertEquals(false, type.equals(DurationType.getAllType()));\n+        assertEquals(false, type.equals(DurationType.getMillisType()));\n+        assertEquals(true, type.hashCode() == type.hashCode());\n+        assertEquals(false, type.hashCode() == DurationType.getAllType().hashCode());\n+        assertEquals(false, type.hashCode() == DurationType.getMillisType().hashCode());\n+        assertEquals(\"AllType\", type.getName());\n+        assertEquals(\"DurationType[AllType]\", type.toString());\n+        assertEqualsAfterSerialization(type);\n+        assertSame(DurationType.getAllType(), type.withChronology(null));\n+        assertSame(DurationType.getAllType(), type.withChronology(ISOChronology.getInstanceUTC()));\n+        assertEquals(CopticChronology.getInstanceUTC(), type.withChronology(CopticChronology.getInstanceUTC()).getChronology());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testAverageYearMonthType() throws Exception {\n+        DurationType type = DurationType.getAverageYearMonthType();\n+        assertEquals(true, type.years().isSupported());\n+        assertEquals(true, type.months().isSupported());\n+        assertEquals(false, type.weeks().isSupported());\n+        assertEquals(true, type.days().isSupported());\n+        assertEquals(true, type.hours().isSupported());\n+        assertEquals(true, type.minutes().isSupported());\n+        assertEquals(true, type.seconds().isSupported());\n+        assertEquals(true, type.millis().isSupported());\n+        assertEquals(true, type.isPrecise());\n+        assertEquals(ISOChronology.getInstanceUTC(), type.getChronology());\n+        assertEquals(true, type.equals(type));\n+        assertEquals(true, type == DurationType.getAverageYearMonthType());\n+        assertEquals(false, type.equals(DurationType.getAllType()));\n+        assertEquals(true, type.hashCode() == type.hashCode());\n+        assertEquals(true, type.hashCode() == DurationType.getAverageYearMonthType().hashCode());\n+        assertEquals(false, type.hashCode() == DurationType.getAllType().hashCode());\n+        assertEquals(\"AverageYearMonthType\", type.getName());\n+        assertEquals(\"DurationType[AverageYearMonthType]\", type.toString());\n+        assertSameAfterSerialization(type);\n+        assertSame(type, type.withChronology(null));\n+        assertSame(type, type.withChronology(ISOChronology.getInstanceUTC()));\n+        assertEquals(CopticChronology.getInstanceUTC(), type.withChronology(CopticChronology.getInstanceUTC()).getChronology());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testAverageYearMonthType_Chronology() throws Exception {\n+        DurationType type = DurationType.getAverageYearMonthType(BuddhistChronology.getInstanceUTC());\n+        assertEquals(true, type.years().isSupported());\n+        assertEquals(true, type.months().isSupported());\n+        assertEquals(false, type.weeks().isSupported());\n+        assertEquals(true, type.days().isSupported());\n+        assertEquals(true, type.hours().isSupported());\n+        assertEquals(true, type.minutes().isSupported());\n+        assertEquals(true, type.seconds().isSupported());\n+        assertEquals(true, type.millis().isSupported());\n+        assertEquals(true, type.isPrecise());\n+        assertEquals(BuddhistChronology.getInstanceUTC(), type.getChronology());\n+        assertEquals(true, type.equals(type));\n+        assertEquals(true, DurationType.getAverageYearMonthType() == DurationType.getAverageYearMonthType(null));\n+        assertEquals(true, DurationType.getAverageYearMonthType() == DurationType.getAverageYearMonthType(ISOChronology.getInstanceUTC()));\n+        assertEquals(true, type.equals(DurationType.getAverageYearMonthType(BuddhistChronology.getInstanceUTC())));\n+        assertEquals(false, type.equals(DurationType.getAverageYearMonthType()));\n+        assertEquals(false, type.equals(DurationType.getAllType()));\n+        assertEquals(true, type.hashCode() == type.hashCode());\n+        assertEquals(false, type.hashCode() == DurationType.getAverageYearMonthType().hashCode());\n+        assertEquals(false, type.hashCode() == DurationType.getAllType().hashCode());\n+        assertEquals(\"AverageYearMonthType\", type.getName());\n+        assertEquals(\"DurationType[AverageYearMonthType]\", type.toString());\n+        assertEqualsAfterSerialization(type);\n+        assertSame(DurationType.getAverageYearMonthType(), type.withChronology(null));\n+        assertSame(DurationType.getAverageYearMonthType(), type.withChronology(ISOChronology.getInstanceUTC()));\n+        assertEquals(CopticChronology.getInstanceUTC(), type.withChronology(CopticChronology.getInstanceUTC()).getChronology());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testPreciseYearWeekType() throws Exception {\n+        DurationType type = DurationType.getPreciseYearWeekType();\n+        assertEquals(true, type.years().isSupported());\n+        assertEquals(false, type.months().isSupported());\n+        assertEquals(true, type.weeks().isSupported());\n+        assertEquals(true, type.days().isSupported());\n+        assertEquals(true, type.hours().isSupported());\n+        assertEquals(true, type.minutes().isSupported());\n+        assertEquals(true, type.seconds().isSupported());\n+        assertEquals(true, type.millis().isSupported());\n+        assertEquals(true, type.isPrecise());\n+        assertEquals(ISOChronology.getInstanceUTC(), type.getChronology());\n+        assertEquals(true, type.equals(type));\n+        assertEquals(true, type == DurationType.getPreciseYearWeekType());\n+        assertEquals(false, type.equals(DurationType.getAllType()));\n+        assertEquals(true, type.hashCode() == type.hashCode());\n+        assertEquals(true, type.hashCode() == DurationType.getPreciseYearWeekType().hashCode());\n+        assertEquals(false, type.hashCode() == DurationType.getAllType().hashCode());\n+        assertEquals(\"PreciseYearWeekType\", type.getName());\n+        assertEquals(\"DurationType[PreciseYearWeekType]\", type.toString());\n+        assertSameAfterSerialization(type);\n+        assertSame(type, type.withChronology(null));\n+        assertSame(type, type.withChronology(ISOChronology.getInstanceUTC()));\n+        assertSame(type, type.withChronology(CopticChronology.getInstanceUTC()));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testPreciseYearMonthType() throws Exception {\n+        DurationType type = DurationType.getPreciseYearMonthType();\n+        assertEquals(true, type.years().isSupported());\n+        assertEquals(true, type.months().isSupported());\n+        assertEquals(false, type.weeks().isSupported());\n+        assertEquals(true, type.days().isSupported());\n+        assertEquals(true, type.hours().isSupported());\n+        assertEquals(true, type.minutes().isSupported());\n+        assertEquals(true, type.seconds().isSupported());\n+        assertEquals(true, type.millis().isSupported());\n+        assertEquals(true, type.isPrecise());\n+        assertEquals(ISOChronology.getInstanceUTC(), type.getChronology());\n+        assertEquals(true, type.equals(type));\n+        assertEquals(true, type == DurationType.getPreciseYearMonthType());\n+        assertEquals(false, type.equals(DurationType.getAllType()));\n+        assertEquals(true, type.hashCode() == type.hashCode());\n+        assertEquals(true, type.hashCode() == DurationType.getPreciseYearMonthType().hashCode());\n+        assertEquals(false, type.hashCode() == DurationType.getAllType().hashCode());\n+        assertEquals(\"PreciseYearMonthType\", type.getName());\n+        assertEquals(\"DurationType[PreciseYearMonthType]\", type.toString());\n+        assertSameAfterSerialization(type);\n+        assertSame(type, type.withChronology(null));\n+        assertSame(type, type.withChronology(ISOChronology.getInstanceUTC()));\n+        assertSame(type, type.withChronology(CopticChronology.getInstanceUTC()));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testPreciseAllType() throws Exception {\n+        DurationType type = DurationType.getPreciseAllType();\n+        assertEquals(true, type.years().isSupported());\n+        assertEquals(true, type.months().isSupported());\n+        assertEquals(true, type.weeks().isSupported());\n+        assertEquals(true, type.days().isSupported());\n+        assertEquals(true, type.hours().isSupported());\n+        assertEquals(true, type.minutes().isSupported());\n+        assertEquals(true, type.seconds().isSupported());\n+        assertEquals(true, type.millis().isSupported());\n+        assertEquals(true, type.isPrecise());\n+        assertEquals(ISOChronology.getInstanceUTC(), type.getChronology());\n+        assertEquals(true, type.equals(type));\n+        assertEquals(true, type == DurationType.getPreciseAllType());\n+        assertEquals(false, type.equals(DurationType.getMillisType()));\n+        assertEquals(true, type.hashCode() == type.hashCode());\n+        assertEquals(true, type.hashCode() == DurationType.getPreciseAllType().hashCode());\n+        assertEquals(false, type.hashCode() == DurationType.getMillisType().hashCode());\n+        assertEquals(\"PreciseAllType\", type.getName());\n+        assertEquals(\"DurationType[PreciseAllType]\", type.toString());\n+        assertSameAfterSerialization(type);\n+        assertSame(type, type.withChronology(null));\n+        assertSame(type, type.withChronology(ISOChronology.getInstanceUTC()));\n+        assertSame(type, type.withChronology(CopticChronology.getInstanceUTC()));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testMaskYears() throws Exception {\n+        DurationType type = DurationType.getPreciseAllType().withYearsRemoved();\n+        assertEquals(false, type.years().isSupported());\n+        assertEquals(true, type.months().isSupported());\n+        assertEquals(true, type.weeks().isSupported());\n+        assertEquals(true, type.days().isSupported());\n+        assertEquals(true, type.hours().isSupported());\n+        assertEquals(true, type.minutes().isSupported());\n+        assertEquals(true, type.seconds().isSupported());\n+        assertEquals(true, type.millis().isSupported());\n+        assertEquals(true, type.isPrecise());\n+        assertEquals(ISOChronology.getInstanceUTC(), type.getChronology());\n+        assertEquals(true, type.equals(type));\n+        assertEquals(true, type.equals(DurationType.getPreciseAllType().withYearsRemoved()));\n+        assertEquals(false, type.equals(DurationType.getMillisType()));\n+        assertEquals(true, type.hashCode() == type.hashCode());\n+        assertEquals(true, type.hashCode() == DurationType.getPreciseAllType().withYearsRemoved().hashCode());\n+        assertEquals(false, type.hashCode() == DurationType.getMillisType().hashCode());\n+        assertEquals(\"MaskedYears[PreciseAllType]\", type.getName());\n+        assertEquals(\"DurationType[MaskedYears[PreciseAllType]]\", type.toString());\n+        assertEqualsAfterSerialization(type);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testMaskMonths() throws Exception {\n+        DurationType type = DurationType.getPreciseAllType().withMonthsRemoved();\n+        assertEquals(true, type.years().isSupported());\n+        assertEquals(false, type.months().isSupported());\n+        assertEquals(true, type.weeks().isSupported());\n+        assertEquals(true, type.days().isSupported());\n+        assertEquals(true, type.hours().isSupported());\n+        assertEquals(true, type.minutes().isSupported());\n+        assertEquals(true, type.seconds().isSupported());\n+        assertEquals(true, type.millis().isSupported());\n+        assertEquals(true, type.isPrecise());\n+        assertEquals(ISOChronology.getInstanceUTC(), type.getChronology());\n+        assertEquals(true, type.equals(type));\n+        assertEquals(true, type.equals(DurationType.getPreciseAllType().withMonthsRemoved()));\n+        assertEquals(false, type.equals(DurationType.getMillisType()));\n+        assertEquals(true, type.hashCode() == type.hashCode());\n+        assertEquals(true, type.hashCode() == DurationType.getPreciseAllType().withMonthsRemoved().hashCode());\n+        assertEquals(false, type.hashCode() == DurationType.getMillisType().hashCode());\n+        assertEquals(\"MaskedMonths[PreciseAllType]\", type.getName());\n+        assertEquals(\"DurationType[MaskedMonths[PreciseAllType]]\", type.toString());\n+        assertEqualsAfterSerialization(type);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testMaskWeeks() throws Exception {\n+        DurationType type = DurationType.getPreciseAllType().withWeeksRemoved();\n+        assertEquals(true, type.years().isSupported());\n+        assertEquals(true, type.months().isSupported());\n+        assertEquals(false, type.weeks().isSupported());\n+        assertEquals(true, type.days().isSupported());\n+        assertEquals(true, type.hours().isSupported());\n+        assertEquals(true, type.minutes().isSupported());\n+        assertEquals(true, type.seconds().isSupported());\n+        assertEquals(true, type.millis().isSupported());\n+        assertEquals(true, type.isPrecise());\n+        assertEquals(ISOChronology.getInstanceUTC(), type.getChronology());\n+        assertEquals(true, type.equals(type));\n+        assertEquals(true, type.equals(DurationType.getPreciseAllType().withWeeksRemoved()));\n+        assertEquals(false, type.equals(DurationType.getMillisType()));\n+        assertEquals(true, type.hashCode() == type.hashCode());\n+        assertEquals(true, type.hashCode() == DurationType.getPreciseAllType().withWeeksRemoved().hashCode());\n+        assertEquals(false, type.hashCode() == DurationType.getMillisType().hashCode());\n+        assertEquals(\"MaskedWeeks[PreciseAllType]\", type.getName());\n+        assertEquals(\"DurationType[MaskedWeeks[PreciseAllType]]\", type.toString());\n+        assertEqualsAfterSerialization(type);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testMaskDays() throws Exception {\n+        DurationType type = DurationType.getPreciseAllType().withDaysRemoved();\n+        assertEquals(true, type.years().isSupported());\n+        assertEquals(true, type.months().isSupported());\n+        assertEquals(true, type.weeks().isSupported());\n+        assertEquals(false, type.days().isSupported());\n+        assertEquals(true, type.hours().isSupported());\n+        assertEquals(true, type.minutes().isSupported());\n+        assertEquals(true, type.seconds().isSupported());\n+        assertEquals(true, type.millis().isSupported());\n+        assertEquals(true, type.isPrecise());\n+        assertEquals(ISOChronology.getInstanceUTC(), type.getChronology());\n+        assertEquals(true, type.equals(type));\n+        assertEquals(true, type.equals(DurationType.getPreciseAllType().withDaysRemoved()));\n+        assertEquals(false, type.equals(DurationType.getMillisType()));\n+        assertEquals(true, type.hashCode() == type.hashCode());\n+        assertEquals(true, type.hashCode() == DurationType.getPreciseAllType().withDaysRemoved().hashCode());\n+        assertEquals(false, type.hashCode() == DurationType.getMillisType().hashCode());\n+        assertEquals(\"MaskedDays[PreciseAllType]\", type.getName());\n+        assertEquals(\"DurationType[MaskedDays[PreciseAllType]]\", type.toString());\n+        assertEqualsAfterSerialization(type);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testMaskHours() throws Exception {\n+        DurationType type = DurationType.getPreciseAllType().withHoursRemoved();\n+        assertEquals(true, type.years().isSupported());\n+        assertEquals(true, type.months().isSupported());\n+        assertEquals(true, type.weeks().isSupported());\n+        assertEquals(true, type.days().isSupported());\n+        assertEquals(false, type.hours().isSupported());\n+        assertEquals(true, type.minutes().isSupported());\n+        assertEquals(true, type.seconds().isSupported());\n+        assertEquals(true, type.millis().isSupported());\n+        assertEquals(true, type.isPrecise());\n+        assertEquals(ISOChronology.getInstanceUTC(), type.getChronology());\n+        assertEquals(true, type.equals(type));\n+        assertEquals(true, type.equals(DurationType.getPreciseAllType().withHoursRemoved()));\n+        assertEquals(false, type.equals(DurationType.getMillisType()));\n+        assertEquals(true, type.hashCode() == type.hashCode());\n+        assertEquals(true, type.hashCode() == DurationType.getPreciseAllType().withHoursRemoved().hashCode());\n+        assertEquals(false, type.hashCode() == DurationType.getMillisType().hashCode());\n+        assertEquals(\"MaskedHours[PreciseAllType]\", type.getName());\n+        assertEquals(\"DurationType[MaskedHours[PreciseAllType]]\", type.toString());\n+        assertEqualsAfterSerialization(type);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testMaskMinutes() throws Exception {\n+        DurationType type = DurationType.getPreciseAllType().withMinutesRemoved();\n+        assertEquals(true, type.years().isSupported());\n+        assertEquals(true, type.months().isSupported());\n+        assertEquals(true, type.weeks().isSupported());\n+        assertEquals(true, type.days().isSupported());\n+        assertEquals(true, type.hours().isSupported());\n+        assertEquals(false, type.minutes().isSupported());\n+        assertEquals(true, type.seconds().isSupported());\n+        assertEquals(true, type.millis().isSupported());\n+        assertEquals(true, type.isPrecise());\n+        assertEquals(ISOChronology.getInstanceUTC(), type.getChronology());\n+        assertEquals(true, type.equals(type));\n+        assertEquals(true, type.equals(DurationType.getPreciseAllType().withMinutesRemoved()));\n+        assertEquals(false, type.equals(DurationType.getMillisType()));\n+        assertEquals(true, type.hashCode() == type.hashCode());\n+        assertEquals(true, type.hashCode() == DurationType.getPreciseAllType().withMinutesRemoved().hashCode());\n+        assertEquals(false, type.hashCode() == DurationType.getMillisType().hashCode());\n+        assertEquals(\"MaskedMinutes[PreciseAllType]\", type.getName());\n+        assertEquals(\"DurationType[MaskedMinutes[PreciseAllType]]\", type.toString());\n+        assertEqualsAfterSerialization(type);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testMaskSeconds() throws Exception {\n+        DurationType type = DurationType.getPreciseAllType().withSecondsRemoved();\n+        assertEquals(true, type.years().isSupported());\n+        assertEquals(true, type.months().isSupported());\n+        assertEquals(true, type.weeks().isSupported());\n+        assertEquals(true, type.days().isSupported());\n+        assertEquals(true, type.hours().isSupported());\n+        assertEquals(true, type.minutes().isSupported());\n+        assertEquals(false, type.seconds().isSupported());\n+        assertEquals(true, type.millis().isSupported());\n+        assertEquals(true, type.isPrecise());\n+        assertEquals(ISOChronology.getInstanceUTC(), type.getChronology());\n+        assertEquals(true, type.equals(type));\n+        assertEquals(true, type.equals(DurationType.getPreciseAllType().withSecondsRemoved()));\n+        assertEquals(false, type.equals(DurationType.getMillisType()));\n+        assertEquals(true, type.hashCode() == type.hashCode());\n+        assertEquals(true, type.hashCode() == DurationType.getPreciseAllType().withSecondsRemoved().hashCode());\n+        assertEquals(false, type.hashCode() == DurationType.getMillisType().hashCode());\n+        assertEquals(\"MaskedSeconds[PreciseAllType]\", type.getName());\n+        assertEquals(\"DurationType[MaskedSeconds[PreciseAllType]]\", type.toString());\n+        assertEqualsAfterSerialization(type);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testMaskMillis() throws Exception {\n+        DurationType type = DurationType.getPreciseAllType().withMillisRemoved();\n+        assertEquals(true, type.years().isSupported());\n+        assertEquals(true, type.months().isSupported());\n+        assertEquals(true, type.weeks().isSupported());\n+        assertEquals(true, type.days().isSupported());\n+        assertEquals(true, type.hours().isSupported());\n+        assertEquals(true, type.minutes().isSupported());\n+        assertEquals(true, type.seconds().isSupported());\n+        assertEquals(false, type.millis().isSupported());\n+        assertEquals(true, type.isPrecise());\n+        assertEquals(ISOChronology.getInstanceUTC(), type.getChronology());\n+        assertEquals(true, type.equals(type));\n+        assertEquals(true, type.equals(DurationType.getPreciseAllType().withMillisRemoved()));\n+        assertEquals(false, type.equals(DurationType.getMillisType()));\n+        assertEquals(true, type.hashCode() == type.hashCode());\n+        assertEquals(true, type.hashCode() == DurationType.getPreciseAllType().withMillisRemoved().hashCode());\n+        assertEquals(false, type.hashCode() == DurationType.getMillisType().hashCode());\n+        assertEquals(\"MaskedMillis[PreciseAllType]\", type.getName());\n+        assertEquals(\"DurationType[MaskedMillis[PreciseAllType]]\", type.toString());\n+        assertEqualsAfterSerialization(type);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testMaskHoursMinutesSeconds() throws Exception {\n+        DurationType type = DurationType.getPreciseAllType().withHoursRemoved().withMinutesRemoved().withSecondsRemoved();\n+        assertEquals(true, type.years().isSupported());\n+        assertEquals(true, type.months().isSupported());\n+        assertEquals(true, type.weeks().isSupported());\n+        assertEquals(true, type.days().isSupported());\n+        assertEquals(false, type.hours().isSupported());\n+        assertEquals(false, type.minutes().isSupported());\n+        assertEquals(false, type.seconds().isSupported());\n+        assertEquals(true, type.millis().isSupported());\n+        assertEquals(true, type.isPrecise());\n+        assertEquals(ISOChronology.getInstanceUTC(), type.getChronology());\n+        assertEquals(true, type.equals(type));\n+        assertEquals(true, type.equals(DurationType.getPreciseAllType().withHoursRemoved().withMinutesRemoved().withSecondsRemoved()));\n+        assertEquals(false, type.equals(DurationType.getMillisType()));\n+        assertEquals(true, type.hashCode() == type.hashCode());\n+        assertEquals(true, type.hashCode() == DurationType.getPreciseAllType().withHoursRemoved().withMinutesRemoved().withSecondsRemoved().hashCode());\n+        assertEquals(false, type.hashCode() == DurationType.getMillisType().hashCode());\n+        assertEquals(\"MaskedHoursMinutesSeconds[PreciseAllType]\", type.getName());\n+        assertEquals(\"DurationType[MaskedHoursMinutesSeconds[PreciseAllType]]\", type.toString());\n+        assertEqualsAfterSerialization(type);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testMaskWithChronology() throws Exception {\n+        DurationType type = DurationType.getAllType().withYearsRemoved();\n+        assertEquals(type, type.withChronology(null));\n+        assertEquals(type, type.withChronology(ISOChronology.getInstanceUTC()));\n+        \n+        DurationType type2 = type.withChronology(CopticChronology.getInstanceUTC());\n+        assertEquals(CopticChronology.getInstanceUTC(), type2.getChronology());\n+        assertEquals(false, type2.years().isSupported());\n+        assertEquals(true, type2.months().isSupported());\n+        assertEquals(true, type2.weeks().isSupported());\n+        assertEquals(true, type2.days().isSupported());\n+        assertEquals(true, type2.hours().isSupported());\n+        assertEquals(true, type2.minutes().isSupported());\n+        assertEquals(true, type2.seconds().isSupported());\n+        assertEquals(true, type2.millis().isSupported());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testMaskTwice1() throws Exception {\n+        DurationType type = DurationType.getPreciseAllType().withYearsRemoved();\n+        DurationType type2 = type.withYearsRemoved();\n+        assertEquals(true, type == type2);\n+        \n+        type = DurationType.getPreciseAllType().withMonthsRemoved();\n+        type2 = type.withMonthsRemoved();\n+        assertEquals(true, type == type2);\n+        \n+        type = DurationType.getPreciseAllType().withWeeksRemoved();\n+        type2 = type.withWeeksRemoved();\n+        assertEquals(true, type == type2);\n+        \n+        type = DurationType.getPreciseAllType().withDaysRemoved();\n+        type2 = type.withDaysRemoved();\n+        assertEquals(true, type == type2);\n+        \n+        type = DurationType.getPreciseAllType().withHoursRemoved();\n+        type2 = type.withHoursRemoved();\n+        assertEquals(true, type == type2);\n+        \n+        type = DurationType.getPreciseAllType().withMinutesRemoved();\n+        type2 = type.withMinutesRemoved();\n+        assertEquals(true, type == type2);\n+        \n+        type = DurationType.getPreciseAllType().withSecondsRemoved();\n+        type2 = type.withSecondsRemoved();\n+        assertEquals(true, type == type2);\n+        \n+        type = DurationType.getPreciseAllType().withMillisRemoved();\n+        type2 = type.withMillisRemoved();\n+        assertEquals(true, type == type2);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testMaskTwice2() throws Exception {\n+        DurationType type = DurationType.getDayHourType();\n+        DurationType type2 = type.withYearsRemoved();\n+        assertEquals(true, type == type2);\n+        \n+        type = DurationType.getDayHourType();\n+        type2 = type.withMonthsRemoved();\n+        assertEquals(true, type == type2);\n+        \n+        type = DurationType.getDayHourType();\n+        type2 = type.withWeeksRemoved();\n+        assertEquals(true, type == type2);\n+        \n+        type = DurationType.getMillisType();\n+        type2 = type.withDaysRemoved();\n+        assertEquals(true, type == type2);\n+        \n+        type = DurationType.getMillisType();\n+        type2 = type.withHoursRemoved();\n+        assertEquals(true, type == type2);\n+        \n+        type = DurationType.getMillisType();\n+        type2 = type.withMinutesRemoved();\n+        assertEquals(true, type == type2);\n+        \n+        type = DurationType.getMillisType();\n+        type2 = type.withSecondsRemoved();\n+        assertEquals(true, type == type2);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testMaskNullName() throws Exception {\n+        DurationType type = new MockDurationTypeWithFields().withYearsRemoved();\n+        assertEquals(\"MaskedYears[]\", type.getName());\n+        assertEquals(\"DurationType[MaskedYears[]]\", type.toString());\n+    }        \n+\n+    //-----------------------------------------------------------------------\n+    public void testAbstract() throws Exception {\n+        assertEquals(true, Modifier.isPublic(DurationType.class.getModifiers()));\n+        assertEquals(true, Modifier.isAbstract(DurationType.class.getModifiers()));\n+        \n+        DurationType type = new MockDurationType();\n+        assertEquals(false, type.years().isSupported());\n+        assertEquals(false, type.months().isSupported());\n+        assertEquals(false, type.weeks().isSupported());\n+        assertEquals(false, type.days().isSupported());\n+        assertEquals(false, type.hours().isSupported());\n+        assertEquals(false, type.minutes().isSupported());\n+        assertEquals(false, type.seconds().isSupported());\n+        assertEquals(false, type.millis().isSupported());\n+        assertEquals(false, type.isPrecise());\n+        assertEquals(null, type.getChronology());\n+        assertEquals(true, type.equals(type));\n+        assertEquals(true, type.equals(new MockDurationType()));\n+        assertEquals(false, type.equals(DurationType.getAllType()));\n+        assertEquals(false, type.equals(null));\n+        assertEquals(false, type.equals(\"six\"));\n+        assertEquals(null, type.getName());\n+        assertEquals(\"DurationType[]\", type.toString());\n+    }\n+\n+    static class MockDurationType extends DurationType {\n+        public String getName() {\n+            return null;\n+        }\n+        public Chronology getChronology() {\n+            return null;\n+        }\n+        public DurationType withChronology(Chronology chrono) {\n+            return null;\n+        }\n+        public boolean isPrecise() {\n+            return false;\n+        }\n+    }\n+\n+    static class MockDurationTypeWithFields extends DurationType {\n+        public String getName() {\n+            return null;\n+        }\n+        public Chronology getChronology() {\n+            return null;\n+        }\n+        public DurationField years() {\n+            return ISOChronology.getInstanceUTC().years();\n+        }\n+        public DurationField months() {\n+            return ISOChronology.getInstanceUTC().months();\n+        }\n+        public DurationType withChronology(Chronology chrono) {\n+            return null;\n+        }\n+        public boolean isPrecise() {\n+            return false;\n+        }\n+    }\n+\n+}", "timestamp": 1090781399, "metainfo": ""}