{"sha": "14863a51230b3d44201646dbc1ce5d7f6bb97a33", "log": "Parsing of US short time-zone names", "commit": "\n--- a/src/main/java/org/joda/time/DateTimeUtils.java\n+++ b/src/main/java/org/joda/time/DateTimeUtils.java\n \n import java.lang.reflect.Method;\n import java.text.DateFormatSymbols;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n import java.util.Locale;\n+import java.util.Map;\n \n import org.joda.time.chrono.ISOChronology;\n \n     private static final SystemMillisProvider SYSTEM_MILLIS_PROVIDER = new SystemMillisProvider();\n     /** The millisecond provider currently in use. */\n     private static volatile MillisProvider cMillisProvider = SYSTEM_MILLIS_PROVIDER;\n+    /** The millisecond provider currently in use. */\n+    private static volatile Map<String, DateTimeZone> cZoneNames;\n+    static {\n+        // names from RFC-822 / JDK\n+        // this is all very US-centric and dubious, but perhaps it will help some\n+        Map<String, DateTimeZone> map = new LinkedHashMap<String, DateTimeZone>();\n+        map.put(\"UT\", DateTimeZone.UTC);\n+        map.put(\"UTC\", DateTimeZone.UTC);\n+        map.put(\"GMT\", DateTimeZone.UTC);\n+        put(map, \"EST\", \"America/New_York\");\n+        put(map, \"EDT\", \"America/New_York\");\n+        put(map, \"CST\", \"America/Chigaco\");\n+        put(map, \"CDT\", \"America/Chigaco\");\n+        put(map, \"MST\", \"America/Denver\");\n+        put(map, \"MDT\", \"America/Denver\");\n+        put(map, \"PST\", \"America/Los_Angeles\");\n+        put(map, \"PDT\", \"America/Los_Angeles\");\n+        cZoneNames = Collections.unmodifiableMap(map);\n+    }\n+    private static void put(Map<String, DateTimeZone> map, String name, String id) {\n+        try {\n+            map.put(name, DateTimeZone.forID(id));\n+        } catch (RuntimeException ex) {\n+            // ignore\n+        }\n+    }\n \n     /**\n      * Restrictive constructor\n         } catch (Exception ex) {\n             return new DateFormatSymbols(locale);\n         }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the default map of time zone names.\n+     * <p>\n+     * This can be changed by {@link #setDefaultTimeZoneNames}.\n+     * \n+     * @return the unmodifiable map of abbreviations to zones, not null\n+     * @since 2.2\n+     */\n+    public static final Map<String, DateTimeZone> getDefaultTimeZoneNames() {\n+        return cZoneNames;\n+    }\n+\n+    /**\n+     * Sets the default map of time zone names.\n+     * <p>\n+     * The map is copied before storage.\n+     * \n+     * @param names  the map of abbreviations to zones, not null\n+     * @since 2.2\n+     */\n+    public static final void setDefaultTimeZoneNames(Map<String, DateTimeZone> names) {\n+        cZoneNames = Collections.unmodifiableMap(new HashMap<String, DateTimeZone>(names));\n     }\n \n     //-----------------------------------------------------------------------\n--- a/src/main/java/org/joda/time/format/DateTimeFormat.java\n+++ b/src/main/java/org/joda/time/format/DateTimeFormat.java\n                 if (tokenLen >= 4) {\n                     builder.appendTimeZoneName();\n                 } else {\n-                    builder.appendTimeZoneShortName();\n+                    builder.appendTimeZoneShortName(null);\n                 }\n                 break;\n             case 'Z': // time zone offset\n--- a/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java\n+++ b/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java\n import org.joda.time.DateTimeConstants;\n import org.joda.time.DateTimeField;\n import org.joda.time.DateTimeFieldType;\n+import org.joda.time.DateTimeUtils;\n import org.joda.time.DateTimeZone;\n import org.joda.time.MutableDateTime;\n import org.joda.time.ReadablePartial;\n      * The names are searched in the order of the map, thus it is strongly recommended\n      * to use a {@code LinkedHashMap} or similar.\n      *\n-     * @param parseLookup  the table of names, not null\n+     * @param parseLookup  the table of names, null to use the {@link DateTimeUtils#getDefaultTimeZoneNames() default names}\n      * @return this DateTimeFormatterBuilder, for chaining\n      */\n     public DateTimeFormatterBuilder appendTimeZoneShortName(Map<String, DateTimeZone> parseLookup) {\n         }\n \n         public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n+            Map<String, DateTimeZone> parseLookup = iParseLookup;\n+            parseLookup = (parseLookup != null ? parseLookup : DateTimeUtils.getDefaultTimeZoneNames());\n             String str = text.substring(position);\n-            for (String name : iParseLookup.keySet()) {\n+            for (String name : parseLookup.keySet()) {\n                 if (str.startsWith(name)) {\n-                    bucket.setZone(iParseLookup.get(name));\n+                    bucket.setZone(parseLookup.get(name));\n                     return position + name.length();\n                 }\n             }\n--- a/src/test/java/org/joda/time/format/TestDateTimeFormatterBuilder.java\n+++ b/src/test/java/org/joda/time/format/TestDateTimeFormatterBuilder.java\n     private static final DateTimeZone LONDON = DateTimeZone.forID(\"Europe/London\");\n     private static final DateTimeZone PARIS = DateTimeZone.forID(\"Europe/Paris\");\n     private static final DateTimeZone TOKYO = DateTimeZone.forID(\"Asia/Tokyo\");\n+    private static final DateTimeZone NEW_YORK = DateTimeZone.forID(\"America/New_York\");\n+    private static final DateTimeZone LOS_ANGELES = DateTimeZone.forID(\"America/Los_Angeles\");\n \n     public static void main(String[] args) {\n         junit.textui.TestRunner.run(suite());\n         }\n     }\n \n+    public void test_printParseShortNameWithAutoLookup() {\n+        DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder()\n+            .appendPattern(\"yyyy-MM-dd HH:mm \").appendTimeZoneShortName(null);\n+        DateTimeFormatter f = bld.toFormatter().withLocale(Locale.ENGLISH);\n+        \n+        assertEquals(true, f.isPrinter());\n+        assertEquals(true, f.isParser());\n+        DateTime dt1 = new DateTime(2011, 1, 4, 12, 30, 0, NEW_YORK);\n+        assertEquals(\"2011-01-04 12:30 EST\", f.print(dt1));\n+        DateTime dt2 = new DateTime(2011, 7, 4, 12, 30, 0, NEW_YORK);\n+        assertEquals(\"2011-07-04 12:30 EDT\", f.print(dt2));\n+        DateTime dt3 = new DateTime(2011, 1, 4, 12, 30, 0, LOS_ANGELES);\n+        assertEquals(\"2011-01-04 12:30 PST\", f.print(dt3));\n+        DateTime dt4 = new DateTime(2011, 7, 4, 12, 30, 0, LOS_ANGELES);\n+        assertEquals(\"2011-07-04 12:30 PDT\", f.print(dt4));\n+        \n+        assertEquals(dt1.getZone() + \" \" + f.parseDateTime(\"2011-01-04 12:30 EST\").getZone(), dt1, f.parseDateTime(\"2011-01-04 12:30 EST\"));\n+        assertEquals(dt2, f.parseDateTime(\"2011-07-04 12:30 EDT\"));\n+        assertEquals(dt3, f.parseDateTime(\"2011-01-04 12:30 PST\"));\n+        assertEquals(dt4, f.parseDateTime(\"2011-07-04 12:30 PDT\"));\n+        try {\n+            f.parseDateTime(\"2007-03-04 12:30 PPP\");\n+            fail();\n+        } catch (IllegalArgumentException e) {\n+        }\n+    }\n+\n     //-----------------------------------------------------------------------\n     public void test_printParseLongName() {\n         DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder()", "timestamp": 1344873712, "metainfo": ""}