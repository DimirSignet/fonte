{"sha": "26dc14b0c91afee273ccfb885d6cd3431e2b2bb3", "log": "Eliminate redundant checks.  ", "commit": "\n--- a/JodaTime/src/java/org/joda/time/format/DateTimeFormatter.java\n+++ b/JodaTime/src/java/org/joda/time/format/DateTimeFormatter.java\n     /**\n      * Gets the internal printer object that performs the real printing work.\n      * \n-     * @return the internal printer\n+     * @return the internal printer; is null if printing not supported\n      */\n     public DateTimePrinter getPrinter() {\n         return iPrinter;\n     /**\n      * Gets the internal parser object that performs the real parsing work.\n      * \n-     * @return the internal parser\n+     * @return the internal parser; is null if parsing not supported\n      */\n     public DateTimeParser getParser() {\n         return iParser;\n      * A DateTimeFormatter is immutable, so a new instance is returned,\n      * and the original is unaltered and still usable.\n      * \n-     * @param locale  the locale to use\n+     * @param locale the locale to use; if null, formatter uses default locale\n+     * at invocation time\n      * @return the new formatter\n      */\n     public DateTimeFormatter withLocale(Locale locale) {\n     /**\n      * Gets the locale that will be used for printing and parsing.\n      * \n-     * @return the locale to use\n+     * @return the locale to use; if null, formatter uses default locale at\n+     * invocation time\n      */\n     public Locale getLocale() {\n         return iLocale;\n      * @param instant  instant to format, null means now\n      */\n     public void printTo(StringBuffer buf, ReadableInstant instant) {\n-        checkPrinter();\n-        \n         long millis = DateTimeUtils.getInstantMillis(instant);\n         Chronology chrono = DateTimeUtils.getInstantChronology(instant);\n         printTo(buf, millis, chrono);\n      * @param instant  instant to format, null means now\n      */\n     public void printTo(Writer out, ReadableInstant instant) throws IOException {\n-        checkPrinter();\n-        \n         long millis = DateTimeUtils.getInstantMillis(instant);\n         Chronology chrono = DateTimeUtils.getInstantChronology(instant);\n         printTo(out, millis, chrono);\n      * @param instant  millis since 1970-01-01T00:00:00Z\n      */\n     public void printTo(StringBuffer buf, long instant) {\n-        checkPrinter();\n-        \n         printTo(buf, instant, null);\n     }\n \n      * @param instant  millis since 1970-01-01T00:00:00Z\n      */\n     public void printTo(Writer out, long instant) throws IOException {\n-        checkPrinter();\n-        \n         printTo(out, instant, null);\n     }\n \n      * @param partial  partial to format\n      */\n     public void printTo(StringBuffer buf, ReadablePartial partial) {\n-        checkPrinter();\n+        DateTimePrinter printer = requirePrinter();\n         if (partial == null) {\n             throw new IllegalArgumentException(\"The partial must not be null\");\n         }\n-        \n-        iPrinter.printTo(buf, partial, iLocale);\n+        printer.printTo(buf, partial, iLocale);\n     }\n \n     /**\n      * @param partial  partial to format\n      */\n     public void printTo(Writer out, ReadablePartial partial) throws IOException {\n-        checkPrinter();\n+        DateTimePrinter printer = requirePrinter();\n         if (partial == null) {\n             throw new IllegalArgumentException(\"The partial must not be null\");\n         }\n-        \n-        iPrinter.printTo(out, partial, iLocale);\n+        printer.printTo(out, partial, iLocale);\n     }\n \n     //-----------------------------------------------------------------------\n      * @return the printed result\n      */\n     public String print(ReadableInstant instant) {\n-        checkPrinter();\n-        \n-        StringBuffer buf = new StringBuffer(iPrinter.estimatePrintedLength());\n+        StringBuffer buf = new StringBuffer(requirePrinter().estimatePrintedLength());\n         printTo(buf, instant);\n         return buf.toString();\n     }\n      * @return the printed result\n      */\n     public String print(long instant) {\n-        checkPrinter();\n-        \n-        StringBuffer buf = new StringBuffer(iPrinter.estimatePrintedLength());\n+        StringBuffer buf = new StringBuffer(requirePrinter().estimatePrintedLength());\n         printTo(buf, instant);\n         return buf.toString();\n     }\n      * @return the printed result\n      */\n     public String print(ReadablePartial partial) {\n-        checkPrinter();\n-        \n-        StringBuffer buf = new StringBuffer(iPrinter.estimatePrintedLength());\n+        StringBuffer buf = new StringBuffer(requirePrinter().estimatePrintedLength());\n         printTo(buf, partial);\n         return buf.toString();\n     }\n \n     private void printTo(StringBuffer buf, long instant, Chronology chrono) {\n+        DateTimePrinter printer = requirePrinter();\n         chrono = selectChronology(chrono);\n         // Shift instant into local time (UTC) to avoid excessive offset\n         // calculations when printing multiple fields in a composite printer.\n             offset = 0;\n             adjustedInstant = instant;\n         }\n-        iPrinter.printTo(buf, adjustedInstant, chrono.withUTC(), offset, zone, iLocale);\n+        printer.printTo(buf, adjustedInstant, chrono.withUTC(), offset, zone, iLocale);\n     }\n \n     private void printTo(Writer buf, long instant, Chronology chrono) throws IOException {\n+        DateTimePrinter printer = requirePrinter();\n         chrono = selectChronology(chrono);\n         // Shift instant into local time (UTC) to avoid excessive offset\n         // calculations when printing multiple fields in a composite printer.\n             offset = 0;\n             adjustedInstant = instant;\n         }\n-        iPrinter.printTo(buf, adjustedInstant, chrono.withUTC(), offset, zone, iLocale);\n+        printer.printTo(buf, adjustedInstant, chrono.withUTC(), offset, zone, iLocale);\n     }\n \n     /**\n      * \n      * @throws UnsupportedOperationException if printing is not supported\n      */\n-    private void checkPrinter() {\n-        if (iPrinter == null) {\n+    private DateTimePrinter requirePrinter() {\n+        DateTimePrinter printer = iPrinter;\n+        if (printer == null) {\n             throw new UnsupportedOperationException(\"Printing not supported\");\n         }\n+        return printer;\n     }\n \n     //-----------------------------------------------------------------------\n      * @throws IllegalArgumentException if any field is out of range\n      */\n     public int parseInto(ReadWritableInstant instant, String text, int position) {\n-        checkParser();\n+        DateTimeParser parser = requireParser();\n         if (instant == null) {\n             throw new IllegalArgumentException(\"Instant must not be null\");\n         }\n         \n         DateTimeParserBucket bucket = new DateTimeParserBucket\n             (instantLocal, chrono, iLocale, iPivotYear);\n-        int newPos = iParser.parseInto(bucket, text, position);\n+        int newPos = parser.parseInto(bucket, text, position);\n         instant.setMillis(bucket.computeMillis(false, text));\n         if (iOffsetParsed && bucket.getZone() == null) {\n             int parsedOffset = bucket.getOffset();\n      * @throws IllegalArgumentException if the text to parse is invalid\n      */\n     public long parseMillis(String text) {\n-        checkParser();\n+        DateTimeParser parser = requireParser();\n         \n         Chronology chrono = selectChronology(iChrono);\n         DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear);\n-        int newPos = iParser.parseInto(bucket, text, 0);\n+        int newPos = parser.parseInto(bucket, text, 0);\n         if (newPos >= 0) {\n             if (newPos >= text.length()) {\n                 return bucket.computeMillis(true, text);\n      * @throws IllegalArgumentException if the text to parse is invalid\n      */\n     public DateTime parseDateTime(String text) {\n-        checkParser();\n+        DateTimeParser parser = requireParser();\n         \n         Chronology chrono = selectChronology(null);\n         DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear);\n-        int newPos = iParser.parseInto(bucket, text, 0);\n+        int newPos = parser.parseInto(bucket, text, 0);\n         if (newPos >= 0) {\n             if (newPos >= text.length()) {\n                 long millis = bucket.computeMillis(true, text);\n      * @throws IllegalArgumentException if the text to parse is invalid\n      */\n     public MutableDateTime parseMutableDateTime(String text) {\n-        checkParser();\n+        DateTimeParser parser = requireParser();\n         \n         Chronology chrono = selectChronology(null);\n         DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear);\n-        int newPos = iParser.parseInto(bucket, text, 0);\n+        int newPos = parser.parseInto(bucket, text, 0);\n         if (newPos >= 0) {\n             if (newPos >= text.length()) {\n                 long millis = bucket.computeMillis(true, text);\n      * \n      * @throws UnsupportedOperationException if parsing is not supported\n      */\n-    private void checkParser() {\n-        if (iParser == null) {\n+    private DateTimeParser requireParser() {\n+        DateTimeParser parser = iParser;\n+        if (parser == null) {\n             throw new UnsupportedOperationException(\"Parsing not supported\");\n         }\n+        return parser;\n     }\n \n     //-----------------------------------------------------------------------", "timestamp": 1189360189, "metainfo": ""}