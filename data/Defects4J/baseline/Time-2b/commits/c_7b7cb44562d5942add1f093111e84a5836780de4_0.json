{"sha": "7b7cb44562d5942add1f093111e84a5836780de4", "log": "Refactor chronology classes to avoid dupication in code   ", "commit": "\n--- a/JodaTime/src/java/org/joda/time/chrono/BaseGJChronology.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/BaseGJChronology.java\n \n     static final long MILLIS_1970_TO_2000 = 946684800000L;\n \n-    // These arrays are NOT public. We trust ourselves not to alter the array.\n-    // They use zero-based array indexes so the that valid range of months is\n-    // automatically checked.\n-\n-    private static final int[] MIN_DAYS_PER_MONTH_ARRAY = {\n-        31,28,31,30,31,30,31,31,30,31,30,31\n-    };\n-\n-    private static final int[] MAX_DAYS_PER_MONTH_ARRAY = {\n-        31,29,31,30,31,30,31,31,30,31,30,31\n-    };\n-\n-    private static final long[] MIN_TOTAL_MILLIS_BY_MONTH_ARRAY;\n-    private static final long[] MAX_TOTAL_MILLIS_BY_MONTH_ARRAY;\n-\n     private static final DurationField cMillisField;\n     private static final DurationField cSecondsField;\n     private static final DurationField cMinutesField;\n     private static final DateTimeField cHalfdayOfDayField;\n \n     static {\n-        MIN_TOTAL_MILLIS_BY_MONTH_ARRAY = new long[12];\n-        MAX_TOTAL_MILLIS_BY_MONTH_ARRAY = new long[12];\n-\n-        long minSum = 0;\n-        long maxSum = 0;\n-        for (int i=0; i<12; i++) {\n-            long millis = MIN_DAYS_PER_MONTH_ARRAY[i]\n-                * (long)DateTimeConstants.MILLIS_PER_DAY;\n-            minSum += millis;\n-            MIN_TOTAL_MILLIS_BY_MONTH_ARRAY[i] = minSum;\n-\n-            millis = MAX_DAYS_PER_MONTH_ARRAY[i]\n-                * (long)DateTimeConstants.MILLIS_PER_DAY;\n-            maxSum += millis;\n-            MAX_TOTAL_MILLIS_BY_MONTH_ARRAY[i] = maxSum;\n-        }\n-\n         cMillisField = MillisDurationField.INSTANCE;\n         cSecondsField = new PreciseDurationField\n             (DurationFieldType.seconds(), DateTimeConstants.MILLIS_PER_SECOND);\n         return DateTimeZone.UTC;\n     }\n \n-    public final long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,\n-                                        int millisOfDay)\n-        throws IllegalArgumentException\n-    {\n+    public long getDateTimeMillis(\n+            int year, int monthOfYear, int dayOfMonth, int millisOfDay)\n+            throws IllegalArgumentException {\n         Chronology base;\n         if ((base = getBase()) != null) {\n             return base.getDateTimeMillis(year, monthOfYear, dayOfMonth, millisOfDay);\n         return getDateMidnightMillis(year, monthOfYear, dayOfMonth) + millisOfDay;\n     }\n \n-    public final long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,\n-                                        int hourOfDay, int minuteOfHour,\n-                                        int secondOfMinute, int millisOfSecond)\n-        throws IllegalArgumentException\n-    {\n+    public long getDateTimeMillis(\n+            int year, int monthOfYear, int dayOfMonth,\n+            int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond)\n+            throws IllegalArgumentException {\n         Chronology base;\n         if ((base = getBase()) != null) {\n             return base.getDateTimeMillis(year, monthOfYear, dayOfMonth,\n             + millisOfSecond;\n     }\n \n-    public final int getMinimumDaysInFirstWeek() {\n+    public int getMinimumDaysInFirstWeek() {\n         return iMinDaysInFirstWeek;\n     }\n \n         // Now create fields that have unique behavior for Gregorian and Julian\n         // chronologies.\n \n-        fields.year = new GJYearDateTimeField(this);\n+        fields.year = new BasicYearDateTimeField(this);\n         fields.yearOfEra = new GJYearOfEraDateTimeField(fields.year, this);\n \n         // Define one-based centuryOfEra and yearOfCentury.\n \n         fields.era = new GJEraDateTimeField(this);\n         fields.dayOfWeek = new GJDayOfWeekDateTimeField(this, fields.days);\n-        fields.dayOfMonth = new GJDayOfMonthDateTimeField(this, fields.days);\n+        fields.dayOfMonth = new BasicDayOfMonthDateTimeField(this, fields.days);\n         fields.dayOfYear = new GJDayOfYearDateTimeField(this, fields.days);\n         fields.monthOfYear = new GJMonthOfYearDateTimeField(this);\n         fields.weekyear = new GJWeekyearDateTimeField(this);\n      * @param year The year to use.\n      * @return 366 if a leap year, otherwise 365.\n      */\n-    final int getDaysInYear(int year) {\n+    int getDaysInYear(int year) {\n         return isLeapYear(year) ? 366 : 365;\n-    }\n-\n-    final int getDaysInYearMonth(int year, int month) {\n-        if (isLeapYear(year)) {\n-            return MAX_DAYS_PER_MONTH_ARRAY[month - 1];\n-        } else {\n-            return MIN_DAYS_PER_MONTH_ARRAY[month - 1];\n-        }\n-    }\n-\n-    /**\n-     * Gets the maximum days in the specified month.\n-     * \n-     * @param month  the month\n-     * @return the max days\n-     */\n-    final int getDaysInMonthMax(int month) {\n-        return MAX_DAYS_PER_MONTH_ARRAY[month - 1];\n-    }\n-\n-    /**\n-     * Returns the total number of milliseconds elapsed in the year, by the end\n-     * of the month.\n-     */\n-    final long getTotalMillisByYearMonth(int year, int month) {\n-        if (isLeapYear(year)) {\n-            return MAX_TOTAL_MILLIS_BY_MONTH_ARRAY[month - 1];\n-        } else {\n-            return MIN_TOTAL_MILLIS_BY_MONTH_ARRAY[month - 1];\n-        }\n     }\n \n     /**\n      * @param year  the year to use.\n      * @return number of weeks in the year.\n      */\n-    final int getWeeksInYear(int year) {\n+    int getWeeksInYear(int year) {\n         long firstWeekMillis1 = getFirstWeekOfYearMillis(year);\n         long firstWeekMillis2 = getFirstWeekOfYearMillis(year + 1);\n         return (int) ((firstWeekMillis2 - firstWeekMillis1) / DateTimeConstants.MILLIS_PER_WEEK);\n      * @param year  the year to use.\n      * @return millis\n      */\n-    final long getFirstWeekOfYearMillis(int year) {\n+    long getFirstWeekOfYearMillis(int year) {\n         long jan1millis = getYearMillis(year);\n         int jan1dayOfWeek = getDayOfWeek(jan1millis);\n         \n      * @param year The year to use.\n      * @return millis from 1970-01-01T00:00:00Z\n      */\n-    final long getYearMillis(int year) {\n+    long getYearMillis(int year) {\n         return getYearInfo(year).iFirstDayMillis;\n-        //return calculateFirstDayOfYearMillis(year);\n     }\n \n     /**\n      * @param month The month to use\n      * @return millis from 1970-01-01T00:00:00Z\n      */\n-    final long getYearMonthMillis(int year, int month) {\n+    long getYearMonthMillis(int year, int month) {\n         long millis = getYearMillis(year);\n         // month\n         if (month > 1) {\n      * @param dayOfMonth The day of the month to use\n      * @return millis from 1970-01-01T00:00:00Z\n      */\n-    final long getYearMonthDayMillis(int year, int month, int dayOfMonth) {\n+    long getYearMonthDayMillis(int year, int month, int dayOfMonth) {\n         long millis = getYearMillis(year);\n         // month\n         if (month > 1) {\n     /**\n      * @param instant millis from 1970-01-01T00:00:00Z\n      */\n-    final int getYear(long instant) {\n+    int getYear(long instant) {\n         // Get an initial estimate of the year, and the millis value that\n         // represents the start of that year. Then verify estimate and fix if\n         // necessary.\n         return year;\n     }\n \n-    private final int getYearOverflow(long instant) {\n+    private int getYearOverflow(long instant) {\n         if (instant > 0) {\n             int year = getMaxYear();\n             long yearStartMillis = getYearMillis(year);\n     }\n \n     /**\n-     * @param instant millis from 1970-01-01T00:00:00Z\n-     */\n-    final long setYear(long instant, int year) {\n-        int thisYear = getYear(instant);\n-        int dayOfYear = getDayOfYear(instant, thisYear);\n-        int millisOfDay = getMillisOfDay(instant);\n-\n-        if (dayOfYear > (31 + 28)) { // after Feb 28\n-            if (isLeapYear(thisYear)) {\n-                // Current date is Feb 29 or later.\n-                if (!isLeapYear(year)) {\n-                    // Moving to a non-leap year, Feb 29 does not exist.\n-                    dayOfYear--;\n-                }\n-            } else {\n-                // Current date is Mar 01 or later.\n-                if (isLeapYear(year)) {\n-                    // Moving to a leap year, account for Feb 29.\n-                    dayOfYear++;\n-                }\n-            }\n-        }\n-\n-        instant = getYearMonthDayMillis(year, 1, dayOfYear);\n-        instant += millisOfDay;\n-\n-        return instant;\n-    }\n-\n-    /**\n      * @param millis from 1970-01-01T00:00:00Z\n      */\n-    final int getMonthOfYear(long millis) {\n+    int getMonthOfYear(long millis) {\n         return getMonthOfYear(millis, getYear(millis));\n     }\n \n      * @param millis from 1970-01-01T00:00:00Z\n      * @param year precalculated year of millis\n      */\n-    final int getMonthOfYear(long millis, int year) {\n-        // Perform a binary search to get the month. To make it go even faster,\n-        // compare using ints instead of longs. The number of milliseconds per\n-        // year exceeds the limit of a 32-bit int's capacity, so divide by\n-        // 1024. No precision is lost (except time of day) since the number of\n-        // milliseconds per day contains 1024 as a factor. After the division,\n-        // the instant isn't measured in milliseconds, but in units of\n-        // (128/125)seconds.\n-\n-        int i = (int)((millis - getYearMillis(year)) >> 10);\n-\n-        // There are 86400000 milliseconds per day, but divided by 1024 is\n-        // 84375. There are 84375 (128/125)seconds per day.\n-\n-        return\n-            (isLeapYear(year))\n-            ? ((i < 182 * 84375)\n-               ? ((i < 91 * 84375)\n-                  ? ((i < 31 * 84375) ? 1 : (i < 60 * 84375) ? 2 : 3)\n-                  : ((i < 121 * 84375) ? 4 : (i < 152 * 84375) ? 5 : 6))\n-               : ((i < 274 * 84375)\n-                  ? ((i < 213 * 84375) ? 7 : (i < 244 * 84375) ? 8 : 9)\n-                  : ((i < 305 * 84375) ? 10 : (i < 335 * 84375) ? 11 : 12)))\n-            : ((i < 181 * 84375)\n-               ? ((i < 90 * 84375)\n-                  ? ((i < 31 * 84375) ? 1 : (i < 59 * 84375) ? 2 : 3)\n-                  : ((i < 120 * 84375) ? 4 : (i < 151 * 84375) ? 5 : 6))\n-               : ((i < 273 * 84375)\n-                  ? ((i < 212 * 84375) ? 7 : (i < 243 * 84375) ? 8 : 9)\n-                  : ((i < 304 * 84375) ? 10 : (i < 334 * 84375) ? 11 : 12)));\n-    }\n+    abstract int getMonthOfYear(long millis, int year);\n \n     /**\n      * @param millis from 1970-01-01T00:00:00Z\n      */\n-    final int getDayOfMonth(long millis) {\n+    int getDayOfMonth(long millis) {\n         int year = getYear(millis);\n         int month = getMonthOfYear(millis, year);\n         return getDayOfMonth(millis, year, month);\n      * @param millis from 1970-01-01T00:00:00Z\n      * @param year precalculated year of millis\n      */\n-    final int getDayOfMonth(long millis, int year) {\n+    int getDayOfMonth(long millis, int year) {\n         int month = getMonthOfYear(millis, year);\n         return getDayOfMonth(millis, year, month);\n     }\n      * @param year precalculated year of millis\n      * @param month precalculated month of millis\n      */\n-    final int getDayOfMonth(long millis, int year, int month) {\n+    int getDayOfMonth(long millis, int year, int month) {\n         long dateMillis = getYearMillis(year);\n         if (month > 1) {\n             dateMillis += getTotalMillisByYearMonth(year, month - 1);\n     /**\n      * @param instant millis from 1970-01-01T00:00:00Z\n      */\n-    final int getDayOfYear(long instant) {\n+    int getDayOfYear(long instant) {\n         return getDayOfYear(instant, getYear(instant));\n     }\n \n      * @param instant millis from 1970-01-01T00:00:00Z\n      * @param year precalculated year of millis\n      */\n-    final int getDayOfYear(long instant, int year) {\n+    int getDayOfYear(long instant, int year) {\n         long yearStart = getYearMillis(year);\n         return (int) ((instant - yearStart) / DateTimeConstants.MILLIS_PER_DAY) + 1;\n     }\n     /**\n      * @param instant millis from 1970-01-01T00:00:00Z\n      */\n-    final int getWeekyear(long instant) {\n+    int getWeekyear(long instant) {\n         int year = getYear(instant);\n         int week = getWeekOfWeekyear(instant, year);\n         if (week == 1) {\n     /**\n      * @param instant millis from 1970-01-01T00:00:00Z\n      */\n-    final int getWeekOfWeekyear(long instant) {\n+    int getWeekOfWeekyear(long instant) {\n         return getWeekOfWeekyear(instant, getYear(instant));\n     }\n \n      * @param instant millis from 1970-01-01T00:00:00Z\n      * @param year precalculated year of millis\n      */\n-    final int getWeekOfWeekyear(long instant, int year) {\n+    int getWeekOfWeekyear(long instant, int year) {\n         long firstWeekMillis1 = getFirstWeekOfYearMillis(year);\n         if (instant < firstWeekMillis1) {\n             return getWeeksInYear(year - 1);\n     /**\n      * @param instant millis from 1970-01-01T00:00:00Z\n      */\n-    final int getDayOfWeek(long instant) {\n+    int getDayOfWeek(long instant) {\n         // 1970-01-01 is day of week 4, Thursday.\n \n         long daysSince19700101;\n     /**\n      * @param instant millis from 1970-01-01T00:00:00Z\n      */\n-    final int getMillisOfDay(long instant) {\n+    int getMillisOfDay(long instant) {\n         if (instant >= 0) {\n             return (int) (instant % DateTimeConstants.MILLIS_PER_DAY);\n         } else {\n         }\n     }\n \n-    long getDateMidnightMillis(int year, int monthOfYear, int dayOfMonth)\n-        throws IllegalArgumentException\n-    {\n-        FieldUtils.verifyValueBounds(DateTimeFieldType.year(), year, getMinYear(), getMaxYear());\n-        FieldUtils.verifyValueBounds(DateTimeFieldType.monthOfYear(), monthOfYear, 1, 12);\n-\n-        boolean isLeap = isLeapYear(year);\n-\n-        FieldUtils.verifyValueBounds(DateTimeFieldType.dayOfMonth(), dayOfMonth, 1,\n-                                     (isLeap ? MAX_DAYS_PER_MONTH_ARRAY : MIN_DAYS_PER_MONTH_ARRAY)\n-                                     [monthOfYear - 1]);\n-\n-        long instant = getYearMillis(year);\n-\n-        if (monthOfYear > 1) {\n-            instant += \n-                (isLeap ? MAX_TOTAL_MILLIS_BY_MONTH_ARRAY : MIN_TOTAL_MILLIS_BY_MONTH_ARRAY)\n-                [monthOfYear - 2];\n-        }\n-\n-        if (dayOfMonth != 1) {\n-            instant += (dayOfMonth - 1) * (long)DateTimeConstants.MILLIS_PER_DAY;\n-        }\n-\n-        return instant;\n-    }\n-\n+    /**\n+     * Gets the maximum number of days in any month.\n+     * \n+     * @return 31\n+     */\n+    int getDaysInMonthMax() {\n+        return 31;\n+    }\n+\n+    /**\n+     * Gets the maximum number of days in the month specified by the instant.\n+     * \n+     * @param instant  millis from 1970-01-01T00:00:00Z\n+     * @return the maximum number of days in the month\n+     */\n+    int getDaysInMonthMax(long instant) {\n+        int thisYear = getYear(instant);\n+        int thisMonth = getMonthOfYear(instant, thisYear);\n+        return getDaysInYearMonth(thisYear, thisMonth);\n+    }\n+\n+    /**\n+     * Gets the maximum number of days in the month specified by the instant.\n+     * The value represents what the user is trying to set, and can be\n+     * used to optimise this method.\n+     * \n+     * @param instant  millis from 1970-01-01T00:00:00Z\n+     * @param value  the value being set\n+     * @return the maximum number of days in the month\n+     */\n+    int getDaysInMonthMaxForSet(long instant, int value) {\n+        return getDaysInMonthMax(instant);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the milliseconds for a date at midnight.\n+     * \n+     * @param year  the year\n+     * @param monthOfYear  the month\n+     * @param dayOfMonth  the day\n+     * @return the milliseconds\n+     */\n+    abstract long getDateMidnightMillis(int year, int monthOfYear, int dayOfMonth);\n+\n+    /**\n+     * Gets the difference between the two instants in years.\n+     * \n+     * @param minuendInstant  the first instant\n+     * @param subtrahendInstant  the second instant\n+     * @return the difference\n+     */\n+    abstract long getYearDifference(long minuendInstant, long subtrahendInstant);\n+\n+    /**\n+     * Is the specified year a leap year?\n+     * \n+     * @param year  the year to test\n+     * @return true if leap\n+     */\n     abstract boolean isLeapYear(int year);\n+\n+    /**\n+     * Gets the number of days in the specified month and year.\n+     * \n+     * @param year  the year\n+     * @param month  the month\n+     * @return the number of days\n+     */\n+    abstract int getDaysInYearMonth(int year, int month);\n+\n+    /**\n+     * Gets the maximum days in the specified month.\n+     * \n+     * @param month  the month\n+     * @return the max days\n+     */\n+    abstract int getDaysInMonthMax(int month);\n+\n+    /**\n+     * Gets the total number of millis elapsed in this year at the end\n+     * of the specified month.\n+     * \n+     * @param year  the year\n+     * @param month  the month\n+     * @return the elapsed millis\n+     */\n+    abstract long getTotalMillisByYearMonth(int year, int month);\n \n     abstract long calculateFirstDayOfYearMillis(int year);\n \n      */\n     abstract long getApproxMillisAtEpoch();\n \n+    /**\n+     * Sets the year from an instant and year.\n+     * \n+     * @param instant  millis from 1970-01-01T00:00:00Z\n+     * @param year  the year to set\n+     * @return the updated millis\n+     */\n+    abstract long setYear(long instant, int year);\n+\n+    //-----------------------------------------------------------------------\n     // Although accessed by multiple threads, this method doesn't need to be synchronized.\n     private YearInfo getYearInfo(int year) {\n         YearInfo[] cache = iYearInfoCache;\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/chrono/BasicDayOfMonthDateTimeField.java\n+/*\n+ *  Copyright 2001-2005 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time.chrono;\n+\n+import org.joda.time.DateTimeFieldType;\n+import org.joda.time.DurationField;\n+import org.joda.time.ReadablePartial;\n+import org.joda.time.field.PreciseDurationDateTimeField;\n+\n+/**\n+ * Provides time calculations for the day of the month component of time.\n+ *\n+ * @author Guy Allard\n+ * @author Stephen Colebourne\n+ * @author Brian S O'Neill\n+ * @since 1.0\n+ */\n+final class BasicDayOfMonthDateTimeField extends PreciseDurationDateTimeField {\n+\n+    private static final long serialVersionUID = -4677223814028011723L;\n+\n+    private final BaseGJChronology iChronology;\n+\n+    /**\n+     * Restricted constructor.\n+     */\n+    BasicDayOfMonthDateTimeField(BaseGJChronology chronology, DurationField days) {\n+        super(DateTimeFieldType.dayOfMonth(), days);\n+        iChronology = chronology;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public int get(long instant) {\n+        return iChronology.getDayOfMonth(instant);\n+    }\n+\n+    public DurationField getRangeDurationField() {\n+        return iChronology.months();\n+    }\n+\n+    public int getMinimumValue() {\n+        return 1;\n+    }\n+\n+    public int getMaximumValue() {\n+        return iChronology.getDaysInMonthMax();\n+    }\n+\n+    public int getMaximumValue(long instant) {\n+        return iChronology.getDaysInMonthMax(instant);\n+    }\n+\n+    public int getMaximumValue(ReadablePartial partial) {\n+        if (partial.isSupported(DateTimeFieldType.monthOfYear())) {\n+            int month = partial.get(DateTimeFieldType.monthOfYear());\n+            if (partial.isSupported(DateTimeFieldType.year())) {\n+                int year = partial.get(DateTimeFieldType.year());\n+                return iChronology.getDaysInYearMonth(year, month);\n+            }\n+            return iChronology.getDaysInMonthMax(month);\n+        }\n+        return getMaximumValue();\n+    }\n+\n+    public int getMaximumValue(ReadablePartial partial, int[] values) {\n+        int size = partial.size();\n+        for (int i = 0; i < size; i++) {\n+            if (partial.getFieldType(i) == DateTimeFieldType.monthOfYear()) {\n+                int month = values[i];\n+                for (int j = 0; j < size; j++) {\n+                    if (partial.getFieldType(j) == DateTimeFieldType.year()) {\n+                        int year = values[j];\n+                        return iChronology.getDaysInYearMonth(year, month);\n+                    }\n+                }\n+                return iChronology.getDaysInMonthMax(month);\n+            }\n+        }\n+        return getMaximumValue();\n+    }\n+\n+    protected int getMaximumValueForSet(long instant, int value) {\n+        return iChronology.getDaysInMonthMaxForSet(instant, value);\n+    }\n+\n+    /**\n+     * Serialization singleton\n+     */\n+    private Object readResolve() {\n+        return iChronology.dayOfMonth();\n+    }\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/chrono/BasicYearDateTimeField.java\n+/*\n+ *  Copyright 2001-2005 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time.chrono;\n+\n+import org.joda.time.DateTimeFieldType;\n+import org.joda.time.DurationField;\n+import org.joda.time.field.FieldUtils;\n+import org.joda.time.field.ImpreciseDateTimeField;\n+\n+/**\n+ * A year field suitable for many calendars.\n+ *\n+ * @author Guy Allard\n+ * @author Stephen Colebourne\n+ * @author Brian S O'Neill\n+ * @since 1.0\n+ */\n+class BasicYearDateTimeField extends ImpreciseDateTimeField {\n+\n+    /** Serialization version. */\n+    private static final long serialVersionUID = -98628754872287L;\n+\n+    /** The underlying basic chronology. */\n+    protected final BaseGJChronology iChronology;\n+\n+    /**\n+     * Restricted constructor.\n+     * \n+     * @param chronology  the chronology this field belogs to\n+     */\n+    BasicYearDateTimeField(BaseGJChronology chronology) {\n+        super(DateTimeFieldType.year(), chronology.getAverageMillisPerYear());\n+        iChronology = chronology;\n+    }\n+\n+    public boolean isLenient() {\n+        return false;\n+    }\n+\n+    public int get(long instant) {\n+        return iChronology.getYear(instant);\n+    }\n+\n+    public long add(long instant, int years) {\n+        if (years == 0) {\n+            return instant;\n+        }\n+        int thisYear = get(instant);\n+        int newYear = FieldUtils.safeAdd(thisYear, years);\n+        return set(instant, newYear);\n+    }\n+\n+    public long add(long instant, long years) {\n+        return add(instant, FieldUtils.safeToInt(years));\n+    }\n+\n+    public long addWrapField(long instant, int years) {\n+        if (years == 0) {\n+            return instant;\n+        }\n+        // Return newly calculated millis value\n+        int thisYear = iChronology.getYear(instant);\n+        int wrappedYear = FieldUtils.getWrappedValue\n+            (thisYear, years, iChronology.getMinYear(), iChronology.getMaxYear());\n+        return set(instant, wrappedYear);\n+    }\n+\n+    public long set(long instant, int year) {\n+        FieldUtils.verifyValueBounds\n+            (this, year, iChronology.getMinYear(), iChronology.getMaxYear());\n+        return iChronology.setYear(instant, year);\n+    }\n+\n+    public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {\n+        if (minuendInstant < subtrahendInstant) {\n+            return -iChronology.getYearDifference(subtrahendInstant, minuendInstant);\n+        }\n+        return iChronology.getYearDifference(minuendInstant, subtrahendInstant);\n+    }\n+\n+    public DurationField getRangeDurationField() {\n+        return null;\n+    }\n+\n+    public boolean isLeap(long instant) {\n+        return iChronology.isLeapYear(get(instant));\n+    }\n+\n+    public int getLeapAmount(long instant) {\n+        if (iChronology.isLeapYear(get(instant))) {\n+            return 1;\n+        } else {\n+            return 0;\n+        }\n+    }\n+\n+    public DurationField getLeapDurationField() {\n+        return iChronology.days();\n+    }\n+\n+    public int getMinimumValue() {\n+        return iChronology.getMinYear();\n+    }\n+\n+    public int getMaximumValue() {\n+        return iChronology.getMaxYear();\n+    }\n+\n+    public long roundFloor(long instant) {\n+        return iChronology.getYearMillis(get(instant));\n+    }\n+\n+    public long roundCeiling(long instant) {\n+        int year = get(instant);\n+        long yearStartMillis = iChronology.getYearMillis(year);\n+        if (instant != yearStartMillis) {\n+            // Bump up to start of next year.\n+            instant = iChronology.getYearMillis(year + 1);\n+        }\n+        return instant;\n+    }\n+\n+    public long remainder(long instant) {\n+        return instant - roundFloor(instant);\n+    }\n+\n+    /**\n+     * Serialization singleton\n+     */\n+    private Object readResolve() {\n+        return iChronology.year();\n+    }\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/chrono/CommonGJChronology.java\n+/*\n+ *  Copyright 2001-2005 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time.chrono;\n+\n+import org.joda.time.Chronology;\n+import org.joda.time.DateTimeConstants;\n+import org.joda.time.DateTimeFieldType;\n+import org.joda.time.field.FieldUtils;\n+\n+/**\n+ * Abstract Chronology for implementing chronologies based on Gregorian/Julian formulae.\n+ * Most of the utility methods required by subclasses are package-private,\n+ * reflecting the intention that they be defined in the same package.\n+ * <p>\n+ * CommonGJChronology is thread-safe and immutable, and all subclasses must\n+ * be as well.\n+ *\n+ * @author Stephen Colebourne\n+ * @author Brian S O'Neill\n+ * @author Guy Allard\n+ * @since 1.0\n+ */\n+public abstract class CommonGJChronology extends BaseGJChronology {\n+\n+    /** Serialization lock */\n+    private static final long serialVersionUID = 538276888268L;\n+\n+    // These arrays are NOT public. We trust ourselves not to alter the array.\n+    // They use zero-based array indexes so the that valid range of months is\n+    // automatically checked.\n+    private static final int[] MIN_DAYS_PER_MONTH_ARRAY = {\n+        31,28,31,30,31,30,31,31,30,31,30,31\n+    };\n+    private static final int[] MAX_DAYS_PER_MONTH_ARRAY = {\n+        31,29,31,30,31,30,31,31,30,31,30,31\n+    };\n+    private static final long[] MIN_TOTAL_MILLIS_BY_MONTH_ARRAY;\n+    private static final long[] MAX_TOTAL_MILLIS_BY_MONTH_ARRAY;\n+    private static final long FEB_29 = (31L + 29 - 1) * DateTimeConstants.MILLIS_PER_DAY;\n+\n+    static {\n+        MIN_TOTAL_MILLIS_BY_MONTH_ARRAY = new long[12];\n+        MAX_TOTAL_MILLIS_BY_MONTH_ARRAY = new long[12];\n+\n+        long minSum = 0;\n+        long maxSum = 0;\n+        for (int i=0; i<12; i++) {\n+            long millis = MIN_DAYS_PER_MONTH_ARRAY[i]\n+                * (long)DateTimeConstants.MILLIS_PER_DAY;\n+            minSum += millis;\n+            MIN_TOTAL_MILLIS_BY_MONTH_ARRAY[i] = minSum;\n+\n+            millis = MAX_DAYS_PER_MONTH_ARRAY[i]\n+                * (long)DateTimeConstants.MILLIS_PER_DAY;\n+            maxSum += millis;\n+            MAX_TOTAL_MILLIS_BY_MONTH_ARRAY[i] = maxSum;\n+        }\n+    }\n+\n+    /**\n+     * Constructor.\n+     */\n+    CommonGJChronology(Chronology base, Object param, int minDaysInFirstWeek) {\n+        super(base, param, minDaysInFirstWeek);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    int getMonthOfYear(long millis, int year) {\n+        // Perform a binary search to get the month. To make it go even faster,\n+        // compare using ints instead of longs. The number of milliseconds per\n+        // year exceeds the limit of a 32-bit int's capacity, so divide by\n+        // 1024. No precision is lost (except time of day) since the number of\n+        // milliseconds per day contains 1024 as a factor. After the division,\n+        // the instant isn't measured in milliseconds, but in units of\n+        // (128/125)seconds.\n+\n+        int i = (int)((millis - getYearMillis(year)) >> 10);\n+\n+        // There are 86400000 milliseconds per day, but divided by 1024 is\n+        // 84375. There are 84375 (128/125)seconds per day.\n+\n+        return\n+            (isLeapYear(year))\n+            ? ((i < 182 * 84375)\n+               ? ((i < 91 * 84375)\n+                  ? ((i < 31 * 84375) ? 1 : (i < 60 * 84375) ? 2 : 3)\n+                  : ((i < 121 * 84375) ? 4 : (i < 152 * 84375) ? 5 : 6))\n+               : ((i < 274 * 84375)\n+                  ? ((i < 213 * 84375) ? 7 : (i < 244 * 84375) ? 8 : 9)\n+                  : ((i < 305 * 84375) ? 10 : (i < 335 * 84375) ? 11 : 12)))\n+            : ((i < 181 * 84375)\n+               ? ((i < 90 * 84375)\n+                  ? ((i < 31 * 84375) ? 1 : (i < 59 * 84375) ? 2 : 3)\n+                  : ((i < 120 * 84375) ? 4 : (i < 151 * 84375) ? 5 : 6))\n+               : ((i < 273 * 84375)\n+                  ? ((i < 212 * 84375) ? 7 : (i < 243 * 84375) ? 8 : 9)\n+                  : ((i < 304 * 84375) ? 10 : (i < 334 * 84375) ? 11 : 12)));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the number of days in the specified month and year.\n+     * \n+     * @param year  the year\n+     * @param month  the month\n+     * @return the number of days\n+     */\n+    int getDaysInYearMonth(int year, int month) {\n+        if (isLeapYear(year)) {\n+            return MAX_DAYS_PER_MONTH_ARRAY[month - 1];\n+        } else {\n+            return MIN_DAYS_PER_MONTH_ARRAY[month - 1];\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    int getDaysInMonthMax(int month) {\n+        return MAX_DAYS_PER_MONTH_ARRAY[month - 1];\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    int getDaysInMonthMaxForSet(long instant, int value) {\n+        return (value > 28 ? getDaysInMonthMax(instant) : 28);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    long getDateMidnightMillis(int year, int monthOfYear, int dayOfMonth) {\n+        FieldUtils.verifyValueBounds(DateTimeFieldType.year(), year, getMinYear(), getMaxYear());\n+        FieldUtils.verifyValueBounds(DateTimeFieldType.monthOfYear(), monthOfYear, 1, 12);\n+        FieldUtils.verifyValueBounds(DateTimeFieldType.dayOfMonth(), dayOfMonth, 1, getDaysInYearMonth(year, monthOfYear));\n+        return getYearMonthDayMillis(year, monthOfYear, dayOfMonth);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    long getTotalMillisByYearMonth(int year, int month) {\n+        if (isLeapYear(year)) {\n+            return MAX_TOTAL_MILLIS_BY_MONTH_ARRAY[month - 1];\n+        } else {\n+            return MIN_TOTAL_MILLIS_BY_MONTH_ARRAY[month - 1];\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    long getYearDifference(long minuendInstant, long subtrahendInstant) {\n+        int minuendYear = getYear(minuendInstant);\n+        int subtrahendYear = getYear(subtrahendInstant);\n+    \n+        // Inlined remainder method to avoid duplicate calls to get.\n+        long minuendRem = minuendInstant - getYearMillis(minuendYear);\n+        long subtrahendRem = subtrahendInstant - getYearMillis(subtrahendYear);\n+    \n+        // Balance leap year differences on remainders.\n+        if (subtrahendRem >= FEB_29) {\n+            if (isLeapYear(subtrahendYear)) {\n+                if (!isLeapYear(minuendYear)) {\n+                    subtrahendRem -= DateTimeConstants.MILLIS_PER_DAY;\n+                }\n+            } else if (minuendRem >= FEB_29 && isLeapYear(minuendYear)) {\n+                minuendRem -= DateTimeConstants.MILLIS_PER_DAY;\n+            }\n+        }\n+    \n+        int difference = minuendYear - subtrahendYear;\n+        if (minuendRem < subtrahendRem) {\n+            difference--;\n+        }\n+        return difference;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    long setYear(long instant, int year) {\n+        int thisYear = getYear(instant);\n+        int dayOfYear = getDayOfYear(instant, thisYear);\n+        int millisOfDay = getMillisOfDay(instant);\n+\n+        if (dayOfYear > (31 + 28)) { // after Feb 28\n+            if (isLeapYear(thisYear)) {\n+                // Current date is Feb 29 or later.\n+                if (!isLeapYear(year)) {\n+                    // Moving to a non-leap year, Feb 29 does not exist.\n+                    dayOfYear--;\n+                }\n+            } else {\n+                // Current date is Mar 01 or later.\n+                if (isLeapYear(year)) {\n+                    // Moving to a leap year, account for Feb 29.\n+                    dayOfYear++;\n+                }\n+            }\n+        }\n+\n+        instant = getYearMonthDayMillis(year, 1, dayOfYear);\n+        instant += millisOfDay;\n+\n+        return instant;\n+    }\n+\n+}\n--- a/JodaTime/src/java/org/joda/time/chrono/CopticChronology.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/CopticChronology.java\n         return getInstance(zone);\n     }\n \n-    long getDateMidnightMillis(int year, int monthOfYear, int dayOfMonth)\n-        throws IllegalArgumentException\n-    {\n+    //-----------------------------------------------------------------------\n+    long setYear(long instant, int year) {\n+        // optimsed implementation of set, due to 30 day months\n+        int thisYear = getYear(instant);\n+        int dayOfYear = getDayOfYear(instant, thisYear);\n+        int millisOfDay = getMillisOfDay(instant);\n+\n+        if (dayOfYear > 365) {\n+            // Current year is leap, and day is leap.\n+            if (!isLeapYear(year)) {\n+                // Moving to a non-leap year, leap day doesn't exist.\n+                dayOfYear--;\n+            }\n+        }\n+\n+        instant = getYearMonthDayMillis(year, 1, dayOfYear);\n+        instant += millisOfDay;\n+        return instant;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    long getYearDifference(long minuendInstant, long subtrahendInstant) {\n+        // optimsed implementation of getDifference, due to 30 day months\n+        int minuendYear = getYear(minuendInstant);\n+        int subtrahendYear = getYear(subtrahendInstant);\n+\n+        // Inlined remainder method to avoid duplicate calls to get.\n+        long minuendRem = minuendInstant - getYearMillis(minuendYear);\n+        long subtrahendRem = subtrahendInstant - getYearMillis(subtrahendYear);\n+\n+        int difference = minuendYear - subtrahendYear;\n+        if (minuendRem < subtrahendRem) {\n+            difference--;\n+        }\n+        return difference;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    long getDateMidnightMillis(int year, int monthOfYear, int dayOfMonth) {\n         FieldUtils.verifyValueBounds(DateTimeFieldType.year(), year, getMinYear(), getMaxYear());\n         FieldUtils.verifyValueBounds(DateTimeFieldType.monthOfYear(), monthOfYear, 1, 13);\n-\n-        int dayLimit = (monthOfYear != 13) ? 30 : (isLeapYear(year) ? 6 : 5);\n-        FieldUtils.verifyValueBounds(DateTimeFieldType.dayOfMonth(), dayOfMonth, 1, dayLimit);\n-\n-        long instant = getYearMillis(year);\n-\n-        if (monthOfYear > 1) {\n-            instant += (monthOfYear - 1) * 30L * DateTimeConstants.MILLIS_PER_DAY;\n-        }\n-\n-        if (dayOfMonth != 1) {\n-            instant += (dayOfMonth - 1) * (long)DateTimeConstants.MILLIS_PER_DAY;\n-        }\n-\n-        return instant;\n-    }\n-\n+        FieldUtils.verifyValueBounds(DateTimeFieldType.dayOfMonth(), dayOfMonth, 1, getDaysInYearMonth(year, monthOfYear));\n+        return getYearMonthDayMillis(year, monthOfYear, dayOfMonth);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    long getTotalMillisByYearMonth(int year, int month) {\n+        return (month * 30L * DateTimeConstants.MILLIS_PER_DAY);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    int getDayOfMonth(long millis) {\n+        // optimised for 30 day months\n+        return (getDayOfYear(millis) - 1) % 30 + 1;\n+    }\n+\n+    //-----------------------------------------------------------------------\n     boolean isLeapYear(int year) {\n         return (year & 3) == 3;\n     }\n \n+    //-----------------------------------------------------------------------\n+    int getDaysInYearMonth(int year, int month) {\n+        return (month != 13) ? 30 : (isLeapYear(year) ? 6 : 5);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    int getDaysInMonthMax() {\n+        return 30;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    int getDaysInMonthMax(int month) {\n+        return (month != 13 ? 30 : 6);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    int getMonthOfYear(long millis, int year) {\n+        return ((int) ((millis - getYearMillis(year)) / 30)) + 1;\n+    }\n+    \n+    //-----------------------------------------------------------------------\n     long calculateFirstDayOfYearMillis(int year) {\n         // Java epoch is 1970-01-01 Gregorian which is 1686-04-23 Coptic.\n         // Calculate relative to the nearest leap year and account for the\n         return millis + (365L - 112) * DateTimeConstants.MILLIS_PER_DAY;\n     }\n \n+    //-----------------------------------------------------------------------\n     int getMinYear() {\n         // The lowest year that can be fully supported.\n         return -292269337;\n     }\n \n+    //-----------------------------------------------------------------------\n     int getMaxYear() {\n         // The highest year that can be fully supported.\n         return 292271022;\n     }\n \n+    //-----------------------------------------------------------------------\n     long getAverageMillisPerYear() {\n         return MILLIS_PER_YEAR;\n     }\n \n+    //-----------------------------------------------------------------------\n     long getAverageMillisPerMonth() {\n         return MILLIS_PER_MONTH;\n     }\n \n+    //-----------------------------------------------------------------------\n     long getApproxMillisAtEpoch() {\n         return 1686L * MILLIS_PER_YEAR + 112L * DateTimeConstants.MILLIS_PER_DAY;\n     }\n \n+    //-----------------------------------------------------------------------\n     protected void assemble(Fields fields) {\n         if (getBase() == null) {\n             super.assemble(fields);\n \n-            fields.year = new CopticYearDateTimeField(this);\n+            fields.year = new BasicYearDateTimeField(this);\n             fields.years = fields.year.getDurationField();\n \n             // Coptic, like Julian, has no year zero.\n             fields.era = CopticEraDateTimeField.INSTANCE;\n             fields.months = cMonthsField;\n             fields.monthOfYear = new CopticMonthOfYearDateTimeField(this, cMonthsField);\n-            fields.dayOfMonth = new CopticDayOfMonthDateTimeField(this, fields.days);\n+            fields.dayOfMonth = new BasicDayOfMonthDateTimeField(this, fields.days);\n         }\n     }\n \n--- a/JodaTime/src/java/org/joda/time/chrono/GregorianChronology.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/GregorianChronology.java\n  * @author Brian S O'Neill\n  * @since 1.0\n  */\n-public final class GregorianChronology extends BaseGJChronology {\n+public final class GregorianChronology extends CommonGJChronology {\n \n     /** Serialization lock */\n     private static final long serialVersionUID = -861407383323710522L;\n--- a/JodaTime/src/java/org/joda/time/chrono/JulianChronology.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/JulianChronology.java\n  * @author Stephen Colebourne\n  * @since 1.0\n  */\n-public final class JulianChronology extends BaseGJChronology {\n+public final class JulianChronology extends CommonGJChronology {\n \n     /** Serialization lock */\n     private static final long serialVersionUID = -8731039522547897247L;", "timestamp": 1118271423, "metainfo": ""}