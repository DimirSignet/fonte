{"sha": "157fe66cee9dfb4fde894ad1015fa16f7a54bed9", "log": "Improve javadoc   ", "commit": "\n--- a/JodaTime/src/java/org/joda/time/DateTimeComparator.java\n+++ b/JodaTime/src/java/org/joda/time/DateTimeComparator.java\n \n import java.io.Serializable;\n import java.util.Comparator;\n+\n import org.joda.time.convert.ConverterManager;\n \n /**\n- * DateTimeComparator is the standard implementation of the Comparator\n- * interface for various Joda and Java objects. The following types\n- * are supported for comparison:\n+ * DateTimeComparator provides comparators to compare one date with another.\n+ * <p>\n+ * Dates may be specified using any object recognised by the\n+ * {@link org.joda.time.convert.ConverterManager ConverterManager} class.\n+ * <p>\n+ * The default objects recognised by the comparator are:\n  * <ul>\n  * <li>ReadableInstant\n- * <li>java.util.Date\n- * <li>java.util.Calendar\n- * <li>java.util.Long (milliseconds)\n+ * <li>PartialInstant\n+ * <li>String\n+ * <li>Calendar\n+ * <li>Date\n+ * <li>Long (milliseconds)\n  * </ul>\n  *\n  * <p>\n  */\n public class DateTimeComparator implements Comparator, Serializable {\n \n-    static final long serialVersionUID = -6097339773320178364L;\n-\n+    /** Serialization lock */\n+    private static final long serialVersionUID = -6097339773320178364L;\n+\n+    /** Singleton instance */\n     private static final DateTimeComparator INSTANCE = new DateTimeComparator(null, null);\n \n+    /** The lower limit of fields to compare, null if no limit */\n+    private final DateTimeField iLowerLimit;\n+    /** The upper limit of fields to compare, null if no limit */\n+    private final DateTimeField iUpperLimit;\n+\n+    //-----------------------------------------------------------------------\n     /**\n      * Returns a DateTimeComparator the compares the entire date time value.\n      */\n         return getInstance(null, chrono.dayOfYear());\n     }\n \n-    private final DateTimeField iLowerLimit;\n-    private final DateTimeField iUpperLimit;\n-\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Restricted constructor.\n+     */\n     private DateTimeComparator(DateTimeField lowerLimit, DateTimeField upperLimit) {\n+        super();\n         iLowerLimit = lowerLimit;\n         iUpperLimit = upperLimit;\n     }\n \n     /**\n-     * @return null if no lower limit\n+     * Gets the field that represents the lower limit of comparison.\n+     * \n+     * @return the field, null if no upper limit\n      */\n     public DateTimeField getLowerLimit() {\n         return iLowerLimit;\n     }\n \n     /**\n-     * @return null if no upper limit\n+     * Gets the field that represents the upper limit of comparison.\n+     * \n+     * @return the field, null if no upper limit\n      */\n     public DateTimeField getUpperLimit() {\n         return iUpperLimit;\n      * Compare two objects against only the range of date time fields as\n      * specified in the constructor.\n      * \n-     * @param lhsObj The first object, logically on the left of a &lt;\n-     * comparison\n-     * @param rhsObj The second object, logically on the right of a &lt;\n-     * comparison\n+     * @param lhsObj The first object, logically on the left of a &lt; comparison\n+     * @param rhsObj The second object, logically on the right of a &lt; comparison\n      * @return zero if order does not matter, negative value if lhsObj &lt;\n-     * rhsObj, positive value otherwise.\n+     *  rhsObj, positive value otherwise.\n      * @throws IllegalArgumentException if either argument is not supported\n      */\n     public int compare(Object lhsObj, Object rhsObj) {\n     }\n \n     /**\n-     * Support serialization singletons\n+     * Gets the millisecond value from an object using the converter system.\n+     * \n+     * @param obj  the object to convert\n+     * @return millis since the epoch\n+     */\n+    private static long getMillisFromObject(Object obj) {\n+        return ConverterManager.getInstance().getInstantConverter(obj).getInstantMillis(obj);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Support serialization singletons.\n      */\n     private Object readResolve() {\n         return getInstance(iLowerLimit, iUpperLimit);\n     }\n \n-    /*\n-     * Developer's note: The 'equals' method specified by the interface is not\n-     * overridden here. It does not make sense to do so, since 'this' is a\n-     * DateTimeComparator, and 'that' would (presumably) be one of the\n-     * supported object types described elsewhere. The '==' logic provided by\n-     * java.lang.Object for a DateTimeComparator object suffices.\n-     */\n-\n-    /*\n-     * @param obj\n-     * @return millis since the epoch\n-     */\n-    private static long getMillisFromObject(Object obj) {\n-        return ConverterManager.getInstance().getInstantConverter(obj).getInstantMillis(obj);\n+    /**\n+     * Gets a debugging string.\n+     * \n+     * @return a debugging string\n+     */\n+    public String toString() {\n+        return \"DateTimeComparator[lowerLimit:\"\n+            + (iLowerLimit == null ? \"none\" : iLowerLimit.getName())\n+            + \",upperLimit:\"\n+            + (iUpperLimit == null ? \"none\" : iUpperLimit.getName())\n+            + \"]\";\n     }\n \n }\n--- a/JodaTime/src/java/org/joda/time/DateTimeConstants.java\n+++ b/JodaTime/src/java/org/joda/time/DateTimeConstants.java\n public final class DateTimeConstants {\n \n     // These are ints not enumerations as they represent genuine int values\n-    /** Constant (1) representing January, the first month */\n+    /** Constant (1) representing January, the first month (ISO) */\n     public static final int JANUARY = 1;\n \n-    /** Constant (2) representing February, the second month */\n+    /** Constant (2) representing February, the second month (ISO) */\n     public static final int FEBRUARY = 2;\n \n-    /** Constant (3) representing March, the third month */\n+    /** Constant (3) representing March, the third month (ISO) */\n     public static final int MARCH = 3;\n \n-    /** Constant (4) representing April, the fourth month */\n+    /** Constant (4) representing April, the fourth month (ISO) */\n     public static final int APRIL = 4;\n \n-    /** Constant (5) representing May, the fifth month */\n+    /** Constant (5) representing May, the fifth month (ISO) */\n     public static final int MAY = 5;\n \n-    /** Constant (6) representing June, the sixth month */\n+    /** Constant (6) representing June, the sixth month (ISO) */\n     public static final int JUNE = 6;\n \n-    /** Constant (7) representing July, the seventh month */\n+    /** Constant (7) representing July, the seventh month (ISO) */\n     public static final int JULY = 7;\n \n-    /** Constant (8) representing August, the eighth month */\n+    /** Constant (8) representing August, the eighth month (ISO) */\n     public static final int AUGUST = 8;\n \n-    /** Constant (9) representing September, the nineth month */\n+    /** Constant (9) representing September, the nineth month (ISO) */\n     public static final int SEPTEMBER = 9;\n \n-    /** Constant (10) representing October, the tenth month */\n+    /** Constant (10) representing October, the tenth month (ISO) */\n     public static final int OCTOBER = 10;\n \n-    /** Constant (11) representing November, the eleventh month */\n+    /** Constant (11) representing November, the eleventh month (ISO) */\n     public static final int NOVEMBER = 11;\n \n-    /** Constant (12) representing December, the twelfth month */\n+    /** Constant (12) representing December, the twelfth month (ISO) */\n     public static final int DECEMBER = 12;\n \n     // These are ints not enumerations as they represent genuine int values\n     public static final int CE = 1;\n \n \n-    /** Milliseconds in one second (1000) */\n+    /** Milliseconds in one second (1000) (ISO) */\n     public static final int MILLIS_PER_SECOND = 1000;\n \n-    /** Seconds in one minute (60) */\n+    /** Seconds in one minute (60) (ISO) */\n     public static final int SECONDS_PER_MINUTE = 60;\n+    /** Milliseconds in one minute (ISO) */\n     public static final int MILLIS_PER_MINUTE = MILLIS_PER_SECOND * SECONDS_PER_MINUTE;\n \n-    /** Minutes in one hour (60) */\n+    /** Minutes in one hour (ISO) */\n     public static final int MINUTES_PER_HOUR = 60;\n+    /** Milliseconds in one hour (ISO) */\n     public static final int SECONDS_PER_HOUR = SECONDS_PER_MINUTE * MINUTES_PER_HOUR;\n+    /** Minutes in one hour (60) (ISO) */\n     public static final int MILLIS_PER_HOUR = MILLIS_PER_MINUTE * MINUTES_PER_HOUR;\n \n-    /** Hours in a typical day (24). Due to time zone offset changes, the\n+    /** Hours in a typical day (24) (ISO). Due to time zone offset changes, the\n      * number of hours per day can vary. */\n     public static final int HOURS_PER_DAY = 24;\n-    /** Minutes in a typical day. Due to time zone offset changes, the number\n+    /** Minutes in a typical day (ISO). Due to time zone offset changes, the number\n      * of minutes per day can vary. */\n     public static final int MINUTES_PER_DAY = MINUTES_PER_HOUR * HOURS_PER_DAY;\n-    /** Seconds in a typical day. Due to time zone offset changes, the number\n+    /** Seconds in a typical day (ISO). Due to time zone offset changes, the number\n      * of seconds per day can vary. */\n     public static final int SECONDS_PER_DAY = SECONDS_PER_HOUR * HOURS_PER_DAY;\n-    /** Milliseconds in a typical day. Due to time zone offset changes, the\n+    /** Milliseconds in a typical day (ISO). Due to time zone offset changes, the\n      * number of milliseconds per day can vary. */\n     public static final int MILLIS_PER_DAY = MILLIS_PER_HOUR * HOURS_PER_DAY;\n \n-    /** Days in one week (7) */\n+    /** Days in one week (7) (ISO) */\n     public static final int DAYS_PER_WEEK = 7;\n     /** Hours in a typical week. Due to time zone offset changes, the number of\n      * hours per week can vary. */\n     public static final int HOURS_PER_WEEK = HOURS_PER_DAY * DAYS_PER_WEEK;\n-    /** Minutes in a typical week. Due to time zone offset changes, the number\n+    /** Minutes in a typical week (ISO). Due to time zone offset changes, the number\n      * of minutes per week can vary. */\n     public static final int MINUTES_PER_WEEK = MINUTES_PER_DAY * DAYS_PER_WEEK;\n-    /** Seconds in a typical week. Due to time zone offset changes, the number\n+    /** Seconds in a typical week (ISO). Due to time zone offset changes, the number\n      * of seconds per week can vary. */\n     public static final int SECONDS_PER_WEEK = SECONDS_PER_DAY * DAYS_PER_WEEK;\n-    /** Milliseconds in a typical week. Due to time zone offset changes, the\n+    /** Milliseconds in a typical week (ISO). Due to time zone offset changes, the\n      * number of milliseconds per week can vary. */\n     public static final int MILLIS_PER_WEEK = MILLIS_PER_DAY * DAYS_PER_WEEK;\n \n--- a/JodaTime/src/java/org/joda/time/chrono/AbstractGJChronology.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/AbstractGJChronology.java\n import org.joda.time.field.RemainderDateTimeField;\n \n /**\n- * Base class for implementing chronologies based on Gregorian/Julian formulas.\n+ * Abstract Chronology for implementing chronologies based on Gregorian/Julian formulae.\n  * Most of the utility methods required by subclasses are package-private,\n  * reflecting the intention that they be defined in the same package.\n  * <p>\n  */\n public abstract class AbstractGJChronology extends AssembledChronology {\n \n-    static final long serialVersionUID = 8283225332206808863L;\n+    /** Serialization lock */\n+    private static final long serialVersionUID = 8283225332206808863L;\n \n     static final long MILLIS_1970_TO_2000 = 946684800000L;\n \n--- a/JodaTime/src/java/org/joda/time/chrono/AssembledChronology.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/AssembledChronology.java\n import org.joda.time.DurationField;\n \n /**\n- * Allows chronologies to be assembled from a container of fields.\n+ * Abstract Chronology that enables chronologies to be assembled from\n+ * a container of fields.\n  * <p>\n  * AssembledChronology is thread-safe and immutable.\n  *\n  * @author Brian S O'Neill\n+ * @since 1.0\n  */\n public abstract class AssembledChronology extends AbstractChronology {\n \n--- a/JodaTime/src/java/org/joda/time/chrono/BuddhistChronology.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/BuddhistChronology.java\n import org.joda.time.DateTimeConstants;\n import org.joda.time.DateTimeField;\n import org.joda.time.DateTimeZone;\n-import org.joda.time.DurationField;\n import org.joda.time.field.DividedDateTimeField;\n import org.joda.time.field.OffsetDateTimeField;\n import org.joda.time.field.RemainderDateTimeField;\n \n /**\n- * <code>BuddhistChronology</code> provides access to the individual date\n- * time fields for the Buddhist chronological calendar system.\n+ * Implements the Buddhist calendar system, which is similar to Gregorian/Julian,\n+ * except with the year offset by 543.\n  * <p>\n- * The Buddhist calendar differs from the GregorianJulian calendar only \n+ * The Buddhist calendar differs from the Gregorian/Julian calendar only \n  * in the year. This class is compatable with the BuddhistCalendar class \n  * supplied by Sun.\n  * <p>\n  */\n public final class BuddhistChronology extends AssembledChronology {\n     \n-    static final long serialVersionUID = -3474595157769370126L;\n+    /** Serialization lock */\n+    private static final long serialVersionUID = -3474595157769370126L;\n \n     /**\n      * Constant value for 'Buddhist Era', equivalent to the value returned\n--- a/JodaTime/src/java/org/joda/time/chrono/CopticChronology.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/CopticChronology.java\n import org.joda.time.field.PreciseDurationField;\n \n /**\n- * Implements a Coptic calendar system, which defines every fourth year as\n+ * Implements the Coptic calendar system, which defines every fourth year as\n  * leap, much like the Julian calendar. The year is broken down into 12 months,\n  * each 30 days in length. An extra period at the end of the year is either 5\n  * or 6 days in length. In this implementation, it is considered a 13th month.\n  * @see JulianChronology\n  *\n  * @author Brian S O'Neill\n+ * @since 1.0\n  */\n public final class CopticChronology extends AbstractGJChronology {\n \n-    static final long serialVersionUID = -5972804258688333942L;\n+    /** Serialization lock */\n+    private static final long serialVersionUID = -5972804258688333942L;\n \n     /**\n      * Constant value for 'Anno Martyrum' or 'Era of the Martyrs', equivalent\n--- a/JodaTime/src/java/org/joda/time/chrono/GJChronology.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/GJChronology.java\n import org.joda.time.format.ISODateTimeFormat;\n \n /**\n- * GJChronology provides access to the individual date time fields for the\n- * Gregorian/Julian defined chronological calendar system.\n+ * Implements the Gregorian/Julian calendar system which is the calendar system\n+ * used in most of the world. Wherever possible, it is recommended to use the\n+ * {@link ISOChronology} instead.\n  * <p>\n  * The Gregorian calendar replaced the Julian calendar, and the point in time\n  * when this chronology switches can be controlled using the second parameter\n  * However before 8 CE, Julian leap years were irregular, and before 45 BCE\n  * there was no Julian calendar.\n  * <p>\n- * This chronology differs from {@link java.util.GregorianCalendar\n- * java.util.GregorianCalendar} in that years in BCE are returned\n- * correctly. Thus year 1 BCE is returned as -1 instead of 1. The yearOfEra\n- * field produces results compatible with GregorianCalendar.\n+ * This chronology differs from\n+ * {@link java.util.GregorianCalendar GregorianCalendar} in that years\n+ * in BCE are returned correctly. Thus year 1 BCE is returned as -1 instead of 1.\n+ * The yearOfEra field produces results compatible with GregorianCalendar.\n  * <p>\n  * The Julian calendar does not have a year zero, and so year -1 is followed by\n  * year 1. If the Gregorian cutover date is specified at or before year -1\n  */\n public final class GJChronology extends AssembledChronology {\n \n-    static final long serialVersionUID = -2545574827706931671L;\n+    /** Serialization lock */\n+    private static final long serialVersionUID = -2545574827706931671L;\n \n     /**\n      * Convert a datetime from one chronology to another.\n--- a/JodaTime/src/java/org/joda/time/chrono/GregorianChronology.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/GregorianChronology.java\n \n import org.joda.time.Chronology;\n import org.joda.time.DateTimeConstants;\n-import org.joda.time.DateTimeField;\n import org.joda.time.DateTimeZone;\n-import org.joda.time.field.DividedDateTimeField;\n-import org.joda.time.field.OffsetDateTimeField;\n-import org.joda.time.field.RemainderDateTimeField;\n \n /**\n  * Implements a pure proleptic Gregorian calendar system, which defines every\n  * @author Guy Allard\n  * @author Stephen Colebourne\n  * @author Brian S O'Neill\n+ * @since 1.0\n  */\n public final class GregorianChronology extends AbstractGJChronology {\n \n-    static final long serialVersionUID = -861407383323710522L;\n+    /** Serialization lock */\n+    private static final long serialVersionUID = -861407383323710522L;\n \n     private static final long MILLIS_PER_YEAR =\n         (long) (365.2425 * DateTimeConstants.MILLIS_PER_DAY);\n--- a/JodaTime/src/java/org/joda/time/chrono/JulianChronology.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/JulianChronology.java\n  * @author Guy Allard\n  * @author Brian S O'Neill\n  * @author Stephen Colebourne\n+ * @since 1.0\n  */\n public final class JulianChronology extends AbstractGJChronology {\n \n-    static final long serialVersionUID = -8731039522547897247L;\n+    /** Serialization lock */\n+    private static final long serialVersionUID = -8731039522547897247L;\n \n     private static final long MILLIS_PER_YEAR =\n         (long) (365.25 * DateTimeConstants.MILLIS_PER_DAY);\n--- a/JodaTime/src/java/org/joda/time/chrono/LenientChronology.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/LenientChronology.java\n import org.joda.time.field.LenientDateTimeField;\n \n /**\n- * Wraps another chronology, ensuring all the fields are lenient.\n+ * Wraps another Chronology, ensuring all the fields are lenient.\n  * <p>\n  * LenientChronology is thread-safe and immutable.\n  *\n  * @author Brian S O'Neill\n+ * @since 1.0\n  * @see LenientDateTimeField\n  * @see StrictChronology\n  */\n public final class LenientChronology extends AssembledChronology {\n \n-    static final long serialVersionUID = -3148237568046877177L;\n+    /** Serialization lock */\n+    private static final long serialVersionUID = -3148237568046877177L;\n \n     /**\n      * Create a LenientChronology for any chronology.\n--- a/JodaTime/src/java/org/joda/time/chrono/LimitChronology.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/LimitChronology.java\n  */\n package org.joda.time.chrono;\n \n-import java.io.IOException;\n-import java.io.ObjectInputStream;\n-import java.io.Serializable;\n-\n import java.util.HashMap;\n import java.util.Locale;\n \n import org.joda.time.format.ISODateTimeFormat;\n \n /**\n- * Imposes limits on the range of instants that the fields within a Chronology\n- * may support. The limits are applied to both DateTimeFields and\n- * DurationFields.\n+ * Wraps another Chronology to impose limits on the range of instants that\n+ * the fields within a Chronology may support. The limits are applied to both\n+ * DateTimeFields and DurationFields.\n  * <p>\n  * Methods in DateTimeField and DurationField throw an IllegalArgumentException\n  * whenever given an input instant that is outside the limits or when an\n  */\n public final class LimitChronology extends AssembledChronology {\n \n-    static final long serialVersionUID = 7670866536893052522L;\n+    /** Serialization lock */\n+    private static final long serialVersionUID = 7670866536893052522L;\n \n     /**\n      * Wraps another chronology, with datetime limits. When withUTC or\n      * withDateTimeZone is called, the returned LimitChronology instance has\n      * the same limits, except they are time zone adjusted.\n      *\n-     * @param base base chronology to wrap\n+     * @param base  base chronology to wrap\n      * @param lowerLimit  inclusive lower limit, or null if none\n      * @param upperLimit  exclusive upper limit, or null if none\n      * @throws IllegalArgumentException if chronology is null or limits are invalid\n--- a/JodaTime/src/java/org/joda/time/chrono/StrictChronology.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/StrictChronology.java\n import org.joda.time.field.StrictDateTimeField;\n \n /**\n- * Wraps another chronology, ensuring all the fields are strict.\n+ * Wraps another Chronology, ensuring all the fields are strict.\n  * <p>\n  * StrictChronology is thread-safe and immutable.\n  *\n  * @author Brian S O'Neill\n+ * @since 1.0\n  * @see StrictDateTimeField\n  * @see LenientChronology\n  */\n public final class StrictChronology extends AssembledChronology {\n \n-    static final long serialVersionUID = 6633006628097111960L;\n+    /** Serialization lock */\n+    private static final long serialVersionUID = 6633006628097111960L;\n \n     /**\n      * Create a StrictChronology for any chronology.\n--- a/JodaTime/src/java/org/joda/time/chrono/ZonedChronology.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/ZonedChronology.java\n import org.joda.time.field.AbstractDurationField;\n \n /**\n- * Wraps another Chronology for supporting time zones.\n+ * Wraps another Chronology to add support for time zones.\n  * <p>\n  * ZonedChronology is thread-safe and immutable.\n  *\n  * @since 1.0\n  */\n public final class ZonedChronology extends AssembledChronology {\n+\n+    /** Serialization lock */\n+    private static final long serialVersionUID = -1079258847191166848L;\n \n     /**\n      * Create a ZonedChronology for any chronology, overriding any time zone it\n         }\n         return new ZonedChronology(base, zone);\n     }\n-\n-    static final long serialVersionUID = -1079258847191166848L;\n \n     static boolean useTimeArithmetic(DurationField field) {\n         // Use time of day arithmetic rules for unit durations less than\n--- a/JodaTime/src/java/org/joda/time/convert/ConverterManager.java\n+++ b/JodaTime/src/java/org/joda/time/convert/ConverterManager.java\n  * <li>String\n  * <li>Calendar\n  * <li>Date\n- * <li>Long\n+ * <li>Long (milliseconds)\n  * </ul>\n  * The default duration converters are:\n  * <ul>\n  * <li>ReadableDuration\n  * <li>ReadableInterval\n  * <li>String\n- * <li>Long\n+ * <li>Long (milliseconds)\n  * </ul>\n  *\n  * The default interval converters are:", "timestamp": 1076870104, "metainfo": ""}