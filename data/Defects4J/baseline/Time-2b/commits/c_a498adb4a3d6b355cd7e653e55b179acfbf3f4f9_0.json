{"sha": "a498adb4a3d6b355cd7e653e55b179acfbf3f4f9", "log": "Overflowed calculations involving year throw ArithmeticException rather than produce a bogus result.   ", "commit": "\n--- a/JodaTime/src/java/org/joda/time/chrono/BaseGJChronology.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/BaseGJChronology.java\n     /** Serialization lock */\n     private static final long serialVersionUID = 8283225332206808863L;\n \n-    static final long MILLIS_1970_TO_2000 = 946684800000L;\n-\n     private static final DurationField cMillisField;\n     private static final DurationField cSecondsField;\n     private static final DurationField cMinutesField;\n         }\n         int year = (int) (i2 / unitMillis);\n \n-        long yearStart = getYearMillis(year);\n+        long yearStart;\n+        try {\n+            yearStart = getYearMillis(year);\n+        } catch (ArithmeticException e) {\n+            if (instant > 0) {\n+                throw new ArithmeticException(\"Instant too large: \" + instant);\n+            } else {\n+                throw new ArithmeticException(\"Instant too small: \" + instant);\n+            }\n+        }\n+\n         long diff = instant - yearStart;\n \n         if (diff < 0) {\n-            if (diff < -DateTimeConstants.MILLIS_PER_DAY * 2L) {\n-                // Too much error, assume operation overflowed.\n-                return getYearOverflow(instant);\n-            }\n             year--;\n         } else if (diff >= DateTimeConstants.MILLIS_PER_DAY * 365L) {\n-            if (diff >= DateTimeConstants.MILLIS_PER_DAY * 367L) {\n-                // Too much error, assume operation overflowed.\n-                return getYearOverflow(instant);\n-            }\n             // One year may need to be added to fix estimate.\n             long oneYear;\n             if (isLeapYear(year)) {\n \n             yearStart += oneYear;\n \n-            if ((yearStart ^ instant) < 0) {\n-                // Sign mismatch, operation may have overflowed.\n-                if ((yearStart <  0 && (yearStart - oneYear) >= 0) ||\n-                    (yearStart >= 0 && (yearStart - oneYear) <  0)   ) {\n-                    // It overflowed.\n-                    return getYearOverflow(instant);\n-                }\n-            }\n-\n             if (yearStart <= instant) {\n                 // Didn't go too far, so actually add one year.\n                 year++;\n         }\n \n         return year;\n-    }\n-\n-    private int getYearOverflow(long instant) {\n-        if (instant > 0) {\n-            int year = getMaxYear();\n-            long yearStartMillis = getYearMillis(year);\n-            if (isLeapYear(year)) {\n-                yearStartMillis += DateTimeConstants.MILLIS_PER_DAY * 366L;\n-            } else {\n-                yearStartMillis += DateTimeConstants.MILLIS_PER_DAY * 365L;\n-            }\n-            long yearEndMillis = yearStartMillis - 1;\n-\n-            if (instant <= yearEndMillis) {\n-                return year;\n-            }\n-\n-            throw new IllegalArgumentException\n-                (\"Instant too large: \" + instant + \" > \" + yearEndMillis);\n-        } else {\n-            int year = getMinYear();\n-            long yearStartMillis = getYearMillis(year);\n-            if (instant >= yearStartMillis) {\n-                return year;\n-            }\n-\n-            throw new IllegalArgumentException\n-                (\"Instant too small: \" + instant + \" < \" + yearStartMillis);\n-        }\n     }\n \n     /**\n--- a/JodaTime/src/java/org/joda/time/chrono/CopticChronology.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/CopticChronology.java\n     private static final long MILLIS_PER_MONTH =\n         (long) (365.25 * DateTimeConstants.MILLIS_PER_DAY / 12);\n \n+    // The lowest year that can be fully supported.\n+    private static final int MIN_YEAR = -292269337;\n+\n+    // The highest year that can be fully supported. Although\n+    // calculateFirstDayOfYearMillis can go higher without overflowing, the\n+    // getYear method overflows when it adds the approximate millis at the\n+    // epoch.\n+    private static final int MAX_YEAR = 292271022;\n+\n     private static final DurationField cMonthsField;\n \n     /** Singleton instance of a UTC CopticChronology */\n     \n     //-----------------------------------------------------------------------\n     long calculateFirstDayOfYearMillis(int year) {\n+        if (year > MAX_YEAR) {\n+            throw new ArithmeticException(\"Year is too large: \" + year + \" > \" + MAX_YEAR);\n+        }\n+        if (year < MIN_YEAR) {\n+            throw new ArithmeticException(\"Year is too small: \" + year + \" < \" + MIN_YEAR);\n+        }\n+\n         // Java epoch is 1970-01-01 Gregorian which is 1686-04-23 Coptic.\n         // Calculate relative to the nearest leap year and account for the\n         // difference later.\n \n     //-----------------------------------------------------------------------\n     int getMinYear() {\n-        // The lowest year that can be fully supported.\n-        return -292269337;\n+        return MIN_YEAR;\n     }\n \n     //-----------------------------------------------------------------------\n     int getMaxYear() {\n-        // The highest year that can be fully supported.\n-        return 292271022;\n+        return MAX_YEAR;\n     }\n \n     //-----------------------------------------------------------------------\n--- a/JodaTime/src/java/org/joda/time/chrono/GregorianChronology.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/GregorianChronology.java\n     private static final long MILLIS_PER_MONTH =\n         (long) (365.2425 * DateTimeConstants.MILLIS_PER_DAY / 12);\n \n+    private static final int DAYS_0000_TO_1970 = 719527;\n+\n+    // The lowest year that can be fully supported.\n+    private static final int MIN_YEAR = -292275054;\n+\n+    // The highest year that can be fully supported. Although\n+    // calculateFirstDayOfYearMillis can operate on years up to 292278994\n+    // without overflowing, the getYear method overflows when it adds the\n+    // approximate millis at the epoch.\n+    private static final int MAX_YEAR = 292277023;\n+\n     /** Singleton instance of a UTC GregorianChronology */\n     private static final GregorianChronology INSTANCE_UTC;\n \n     }\n \n     long calculateFirstDayOfYearMillis(int year) {\n-        // Calculate relative to 2000 as that is on a 400 year boundary\n-        // and that makes the sum easier\n-        int relativeYear = year - 2000;\n+        if (year > MAX_YEAR) {\n+            throw new ArithmeticException(\"Year is too large: \" + year + \" > \" + MAX_YEAR);\n+        }\n+        if (year < MIN_YEAR) {\n+            throw new ArithmeticException(\"Year is too small: \" + year + \" < \" + MIN_YEAR);\n+        }\n+\n         // Initial value is just temporary.\n-        int leapYears = relativeYear / 100;\n-        if (relativeYear <= 0) {\n+        int leapYears = year / 100;\n+        if (year < 0) {\n             // Add 3 before shifting right since /4 and >>2 behave differently\n             // on negative numbers. When the expression is written as\n-            // (relativeYear / 4) - (relativeYear / 100) + (relativeYear / 400),\n+            // (year / 4) - (year / 100) + (year / 400),\n             // it works for both positive and negative values, except this optimization\n             // eliminates two divisions.\n-            leapYears = ((relativeYear + 3) >> 2) - leapYears + ((leapYears + 3) >> 2);\n+            leapYears = ((year + 3) >> 2) - leapYears + ((leapYears + 3) >> 2) - 1;\n         } else {\n-            leapYears = (relativeYear >> 2) - leapYears + (leapYears >> 2);\n-            // For post 2000 an adjustment is needed as jan1st is before leap day\n-            if (!isLeapYear(year)) {\n-                leapYears++;\n-            }\n-        }\n-        \n-        long millis = (relativeYear * 365L + leapYears)\n-            * (long)DateTimeConstants.MILLIS_PER_DAY;\n-        \n-        // Previous line was reduced from this to eliminate a multiplication.\n-        // millis = ((relativeYear - leapYears) * 365L + leapYears * 366) * MILLIS_PER_DAY;\n-        // (x - y)*c + y*(c + 1) => x*c - y*c + y*c + y => x*c + y\n-        \n-        return millis + MILLIS_1970_TO_2000;\n+            leapYears = (year >> 2) - leapYears + (leapYears >> 2);\n+            if (isLeapYear(year)) {\n+                leapYears--;\n+            }\n+        }\n+\n+        return (year * 365L + (leapYears - DAYS_0000_TO_1970)) * DateTimeConstants.MILLIS_PER_DAY;\n     }\n \n     int getMinYear() {\n-        // The lowest year that can be fully supported.\n-        return -292275054;\n+        return MIN_YEAR;\n     }\n \n     int getMaxYear() {\n-        // The highest year that can be fully supported.\n-        return 292277023;\n+        return MAX_YEAR;\n     }\n \n     long getAverageMillisPerYear() {\n--- a/JodaTime/src/java/org/joda/time/chrono/JulianChronology.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/JulianChronology.java\n     private static final long MILLIS_PER_MONTH =\n         (long) (365.25 * DateTimeConstants.MILLIS_PER_DAY / 12);\n \n+    // The lowest year that can be fully supported.\n+    private static final int MIN_YEAR = -292269054;\n+\n+    // The highest year that can be fully supported. Although\n+    // calculateFirstDayOfYearMillis can go higher without overflowing, the\n+    // getYear method overflows when it adds the approximate millis at the\n+    // epoch.\n+    private static final int MAX_YEAR = 292271022;\n+\n     /** Singleton instance of a UTC JulianChronology */\n     private static final JulianChronology INSTANCE_UTC;\n \n     }\n \n     long calculateFirstDayOfYearMillis(int year) {\n+        if (year > MAX_YEAR) {\n+            throw new ArithmeticException(\"Year is too large: \" + year + \" > \" + MAX_YEAR);\n+        }\n+        if (year < MIN_YEAR) {\n+            throw new ArithmeticException(\"Year is too small: \" + year + \" < \" + MIN_YEAR);\n+        }\n+\n         // Java epoch is 1970-01-01 Gregorian which is 1969-12-19 Julian.\n         // Calculate relative to the nearest leap year and account for the\n         // difference later.\n             }\n         }\n         \n-        long millis = (relativeYear * 365L + leapYears)\n-            * (long)DateTimeConstants.MILLIS_PER_DAY;\n+        long millis = (relativeYear * 365L + leapYears) * (long)DateTimeConstants.MILLIS_PER_DAY;\n \n         // Adjust to account for difference between 1968-01-01 and 1969-12-19.\n \n     }\n \n     int getMinYear() {\n-        // The lowest year that can be fully supported.\n-        return -292269054;\n+        return MIN_YEAR;\n     }\n \n     int getMaxYear() {\n-        // The highest year that can be fully supported.\n-        return 292271022;\n+        return MAX_YEAR;\n     }\n \n     long getAverageMillisPerYear() {\n--- a/JodaTime/src/test/org/joda/time/chrono/TestISOChronology.java\n+++ b/JodaTime/src/test/org/joda/time/chrono/TestISOChronology.java\n import junit.framework.TestCase;\n import junit.framework.TestSuite;\n \n+import org.joda.time.DateTime;\n import org.joda.time.DateTimeConstants;\n import org.joda.time.DateTimeUtils;\n import org.joda.time.DateTimeZone;\n+import org.joda.time.IllegalFieldValueException;\n \n /**\n  * This class is a Junit unit test for ISOChronology.\n         assertEquals(true, ISOChronology.getInstance().millisOfSecond().isSupported());\n     }\n \n+    public void testMaxYear() {\n+        final ISOChronology chrono = ISOChronology.getInstanceUTC();\n+        final int maxYear = chrono.year().getMaximumValue();\n+\n+        DateTime start = new DateTime(maxYear, 1, 1, 0, 0, 0, 0, chrono);\n+        DateTime end = new DateTime(maxYear, 12, 31, 23, 59, 59, 999, chrono);\n+        assertTrue(start.getMillis() > 0);\n+        assertTrue(end.getMillis() > start.getMillis());\n+        assertEquals(maxYear, start.getYear());\n+        assertEquals(maxYear, end.getYear());\n+        long delta = end.getMillis() - start.getMillis();\n+        long expectedDelta = \n+            (start.year().isLeap() ? 366L : 365L) * DateTimeConstants.MILLIS_PER_DAY - 1;\n+        assertEquals(expectedDelta, delta);\n+\n+        assertEquals(start, new DateTime(maxYear + \"-01-01T00:00:00.000Z\", chrono));\n+        assertEquals(end, new DateTime(maxYear + \"-12-31T23:59:59.999Z\", chrono));\n+\n+        try {\n+            start.plusYears(1);\n+            fail();\n+        } catch (IllegalFieldValueException e) {\n+        }\n+\n+        try {\n+            end.plusYears(1);\n+            fail();\n+        } catch (IllegalFieldValueException e) {\n+        }\n+\n+        try {\n+            chrono.year().get(Long.MAX_VALUE);\n+            fail();\n+        } catch (ArithmeticException e) {\n+        }\n+    }\n+\n+    public void testMinYear() {\n+        final ISOChronology chrono = ISOChronology.getInstanceUTC();\n+        final int minYear = chrono.year().getMinimumValue();\n+\n+        DateTime start = new DateTime(minYear, 1, 1, 0, 0, 0, 0, chrono);\n+        DateTime end = new DateTime(minYear, 12, 31, 23, 59, 59, 999, chrono);\n+        assertTrue(start.getMillis() < 0);\n+        assertTrue(end.getMillis() > start.getMillis());\n+        assertEquals(minYear, start.getYear());\n+        assertEquals(minYear, end.getYear());\n+        long delta = end.getMillis() - start.getMillis();\n+        long expectedDelta = \n+            (start.year().isLeap() ? 366L : 365L) * DateTimeConstants.MILLIS_PER_DAY - 1;\n+        assertEquals(expectedDelta, delta);\n+\n+        assertEquals(start, new DateTime(minYear + \"-01-01T00:00:00.000Z\", chrono));\n+        assertEquals(end, new DateTime(minYear + \"-12-31T23:59:59.999Z\", chrono));\n+\n+        try {\n+            start.minusYears(1);\n+            fail();\n+        } catch (IllegalFieldValueException e) {\n+        }\n+\n+        try {\n+            end.minusYears(1);\n+            fail();\n+        } catch (IllegalFieldValueException e) {\n+        }\n+\n+        try {\n+            chrono.year().get(Long.MIN_VALUE);\n+            fail();\n+        } catch (ArithmeticException e) {\n+        }\n+    }\n+\n }", "timestamp": 1119242901, "metainfo": ""}