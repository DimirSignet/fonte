{"sha": "82cf7fe2bd1a9e8eebda02b1e183ccf50fbdea13", "log": "Refactoring in advance of Islamic Chronology   ", "commit": "\n--- a/JodaTime/src/java/org/joda/time/chrono/BaseGJChronology.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/BaseGJChronology.java\n         fields.weekyears = fields.weekyear.getDurationField();\n     }\n \n+    //-----------------------------------------------------------------------\n     /**\n      * Get the number of days in the year.\n-     * @param year The year to use.\n-     * @return 366 if a leap year, otherwise 365.\n+     *\n+     * @return 366\n+     */\n+    int getDaysInYearMax() {\n+        return 366;\n+    }\n+\n+    /**\n+     * Get the number of days in the year.\n+     *\n+     * @param year  the year to use\n+     * @return 366 if a leap year, otherwise 365\n      */\n     int getDaysInYear(int year) {\n         return isLeapYear(year) ? 366 : 365;\n \n     /**\n      * Get the number of weeks in the year.\n-     * @param year  the year to use.\n-     * @return number of weeks in the year.\n+     *\n+     * @param year  the year to use\n+     * @return number of weeks in the year\n      */\n     int getWeeksInYear(int year) {\n         long firstWeekMillis1 = getFirstWeekOfYearMillis(year);\n \n     /**\n      * Get the millis for the first week of a year.\n-     * @param year  the year to use.\n+     *\n+     * @param year  the year to use\n      * @return millis\n      */\n     long getFirstWeekOfYearMillis(int year) {\n      */\n     long getYearMonthMillis(int year, int month) {\n         long millis = getYearMillis(year);\n-        // month\n-        if (month > 1) {\n-            millis += getTotalMillisByYearMonth(year, month - 1);\n-        }\n+        millis += getTotalMillisByYearMonth(year, month);\n         return millis;\n     }\n \n      */\n     long getYearMonthDayMillis(int year, int month, int dayOfMonth) {\n         long millis = getYearMillis(year);\n-        // month\n-        if (month > 1) {\n-            millis += getTotalMillisByYearMonth(year, month - 1);\n-        }\n-        // day\n+        millis += getTotalMillisByYearMonth(year, month);\n         return millis + (dayOfMonth - 1) * (long)DateTimeConstants.MILLIS_PER_DAY;\n     }\n     \n      */\n     int getDayOfMonth(long millis, int year, int month) {\n         long dateMillis = getYearMillis(year);\n-        if (month > 1) {\n-            dateMillis += getTotalMillisByYearMonth(year, month - 1);\n-        }\n+        dateMillis += getTotalMillisByYearMonth(year, month);\n         return (int) ((millis - dateMillis) / DateTimeConstants.MILLIS_PER_DAY) + 1;\n     }\n \n     abstract int getDaysInMonthMax(int month);\n \n     /**\n-     * Gets the total number of millis elapsed in this year at the end\n-     * of the specified month.\n+     * Gets the total number of millis elapsed in this year at the start\n+     * of the specified month, such as zero for month 1.\n      * \n      * @param year  the year\n      * @param month  the month\n-     * @return the elapsed millis\n+     * @return the elapsed millis at the start of the month\n      */\n     abstract long getTotalMillisByYearMonth(int year, int month);\n \n--- a/JodaTime/src/java/org/joda/time/chrono/BasicDayOfYearDateTimeField.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/BasicDayOfYearDateTimeField.java\n     }\n \n     public int getMaximumValue() {\n-        return 366;\n+        return iChronology.getDaysInYearMax();\n     }\n \n     public int getMaximumValue(long instant) {\n             int year = partial.get(DateTimeFieldType.year());\n             return iChronology.getDaysInYear(year);\n         }\n-        return 366;\n+        return iChronology.getDaysInYearMax();\n     }\n \n     public int getMaximumValue(ReadablePartial partial, int[] values) {\n                 return iChronology.getDaysInYear(year);\n             }\n         }\n-        return 366;\n+        return iChronology.getDaysInYearMax();\n     }\n \n     protected int getMaximumValueForSet(long instant, int value) {\n-        return value > 365 ? getMaximumValue(instant) : 365;\n+        int maxLessOne = iChronology.getDaysInYearMax() - 1;\n+        return value > maxLessOne ? getMaximumValue(instant) : maxLessOne;\n     }\n \n     /**\n--- a/JodaTime/src/java/org/joda/time/chrono/BasicFixedMonthChronology.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/BasicFixedMonthChronology.java\n \n     //-----------------------------------------------------------------------\n     long getTotalMillisByYearMonth(int year, int month) {\n-        return (month * MILLIS_PER_MONTH);\n+        return ((month - 1) * MILLIS_PER_MONTH);\n     }\n \n     //-----------------------------------------------------------------------\n--- a/JodaTime/src/java/org/joda/time/chrono/BasicGJChronology.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/BasicGJChronology.java\n \n import org.joda.time.Chronology;\n import org.joda.time.DateTimeConstants;\n-import org.joda.time.DateTimeFieldType;\n-import org.joda.time.field.FieldUtils;\n \n /**\n  * Abstract Chronology for implementing chronologies based on Gregorian/Julian formulae.\n \n         long minSum = 0;\n         long maxSum = 0;\n-        for (int i=0; i<12; i++) {\n+        for (int i = 0; i < 11; i++) {\n             long millis = MIN_DAYS_PER_MONTH_ARRAY[i]\n                 * (long)DateTimeConstants.MILLIS_PER_DAY;\n             minSum += millis;\n-            MIN_TOTAL_MILLIS_BY_MONTH_ARRAY[i] = minSum;\n+            MIN_TOTAL_MILLIS_BY_MONTH_ARRAY[i + 1] = minSum;\n \n             millis = MAX_DAYS_PER_MONTH_ARRAY[i]\n                 * (long)DateTimeConstants.MILLIS_PER_DAY;\n             maxSum += millis;\n-            MAX_TOTAL_MILLIS_BY_MONTH_ARRAY[i] = maxSum;\n+            MAX_TOTAL_MILLIS_BY_MONTH_ARRAY[i + 1] = maxSum;\n         }\n     }\n \n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/chrono/BasicMonthOfYearDateTimeField.java\n+/*\n+ *  Copyright 2001-2005 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time.chrono;\n+\n+import org.joda.time.DateTimeConstants;\n+import org.joda.time.DateTimeFieldType;\n+import org.joda.time.DurationField;\n+import org.joda.time.field.FieldUtils;\n+import org.joda.time.field.ImpreciseDateTimeField;\n+\n+/**\n+ * Provides time calculations for the month of the year component of time.\n+ * <p>\n+ * This implementation assumes 12 months at present.\n+ *\n+ * @author Guy Allard\n+ * @author Stephen Colebourne\n+ * @author Brian S O'Neill\n+ * @since 1.0\n+ */\n+class BasicMonthOfYearDateTimeField extends ImpreciseDateTimeField {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = -8258715387168736L;\n+\n+    private static final int MIN = DateTimeConstants.JANUARY;\n+    private static final int MAX = DateTimeConstants.DECEMBER;\n+\n+    private final BaseGJChronology iChronology;\n+    private final int iLeapMonth;\n+\n+    /**\n+     * Restricted constructor.\n+     * \n+     * @param the dayOfYear that is the leap day\n+     */\n+    BasicMonthOfYearDateTimeField(BaseGJChronology chronology, int leapMonth) {\n+        super(DateTimeFieldType.monthOfYear(), chronology.getAverageMillisPerMonth());\n+        iChronology = chronology;\n+        iLeapMonth = leapMonth;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public boolean isLenient() {\n+        return false;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the Month component of the specified time instant.\n+     *\n+     * @see org.joda.time.DateTimeField#get(long)\n+     * @see org.joda.time.ReadableDateTime#getMonthOfYear()\n+     * @param instant  the time instant in millis to query.\n+     * @return the month extracted from the input.\n+     */\n+    public int get(long instant) {\n+        return iChronology.getMonthOfYear(instant);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Add the specified month to the specified time instant.\n+     * The amount added may be negative.<p>\n+     * If the new month has less total days than the specified\n+     * day of the month, this value is coerced to the nearest\n+     * sane value. e.g.<p>\n+     * 07-31 - (1 month) = 06-30<p>\n+     * 03-31 - (1 month) = 02-28 or 02-29 depending<p>\n+     * \n+     * @see org.joda.time.DateTimeField#add\n+     * @see org.joda.time.ReadWritableDateTime#addMonths(int)\n+     * @param instant  the time instant in millis to update.\n+     * @param months  the months to add (can be negative).\n+     * @return the updated time instant.\n+     */\n+    public long add(long instant, int months) {\n+        if (months == 0) {\n+            return instant; // the easy case\n+        }\n+        //\n+        // Save time part first.\n+        //\n+        long timePart = iChronology.getMillisOfDay(instant);\n+        //\n+        //\n+        // Get this year and month.\n+        //\n+        int thisYear = iChronology.getYear(instant);\n+        int thisMonth = iChronology.getMonthOfYear(instant, thisYear);\n+        // ----------------------------------------------------------\n+        //\n+        // Do not refactor without careful consideration.\n+        // Order of calculation is important.\n+        //\n+        int yearToUse;\n+        // Initially, monthToUse is zero-based\n+        int monthToUse = thisMonth - 1 + months;\n+        if (monthToUse >= 0) {\n+            yearToUse = thisYear + (monthToUse / MAX);\n+            monthToUse = (monthToUse % MAX) + 1;\n+        } else {\n+            yearToUse = thisYear + (monthToUse / MAX) - 1;\n+            monthToUse = Math.abs(monthToUse);\n+            int remMonthToUse = monthToUse % MAX;\n+            // Take care of the boundary condition\n+            if (remMonthToUse == 0) {\n+                remMonthToUse = MAX;\n+            }\n+            monthToUse = MAX - remMonthToUse + 1;\n+            // Take care of the boundary condition\n+            if (monthToUse == 1) {\n+                yearToUse += 1;\n+            }\n+        }\n+        // End of do not refactor.\n+        // ----------------------------------------------------------\n+\n+        //\n+        // Quietly force DOM to nearest sane value.\n+        //\n+        int dayToUse = iChronology.getDayOfMonth(instant, thisYear, thisMonth);\n+        int maxDay = iChronology.getDaysInYearMonth(yearToUse, monthToUse);\n+        if (dayToUse > maxDay) {\n+            dayToUse = maxDay;\n+        }\n+        //\n+        // get proper date part, and return result\n+        //\n+        long datePart =\n+            iChronology.getYearMonthDayMillis(yearToUse, monthToUse, dayToUse);\n+        return datePart + timePart;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public long add(long instant, long months) {\n+        int i_months = (int)months;\n+        if (i_months == months) {\n+            return add(instant, i_months);\n+        }\n+\n+        // Copied from add(long, int) and modified slightly:\n+\n+        long timePart = iChronology.getMillisOfDay(instant);\n+\n+        int thisYear = iChronology.getYear(instant);\n+        int thisMonth = iChronology.getMonthOfYear(instant, thisYear);\n+\n+        long yearToUse;\n+        long monthToUse = thisMonth - 1 + months;\n+        if (monthToUse >= 0) {\n+            yearToUse = thisYear + (monthToUse / MAX);\n+            monthToUse = (monthToUse % MAX) + 1;\n+        } else {\n+            yearToUse = thisYear + (monthToUse / MAX) - 1;\n+            monthToUse = Math.abs(monthToUse);\n+            int remMonthToUse = (int)(monthToUse % MAX);\n+            if (remMonthToUse == 0) {\n+                remMonthToUse = MAX;\n+            }\n+            monthToUse = MAX - remMonthToUse + 1;\n+            if (monthToUse == 1) {\n+                yearToUse += 1;\n+            }\n+        }\n+\n+        if (yearToUse < iChronology.getMinYear() ||\n+            yearToUse > iChronology.getMaxYear()) {\n+\n+            throw new IllegalArgumentException\n+                (\"Magnitude of add amount is too large: \" + months);\n+        }\n+\n+        int i_yearToUse = (int)yearToUse;\n+        int i_monthToUse = (int)monthToUse;\n+\n+        int dayToUse = iChronology.getDayOfMonth(instant, thisYear, thisMonth);\n+        int maxDay = iChronology.getDaysInYearMonth(i_yearToUse, i_monthToUse);\n+        if (dayToUse > maxDay) {\n+            dayToUse = maxDay;\n+        }\n+\n+        long datePart =\n+            iChronology.getYearMonthDayMillis(i_yearToUse, i_monthToUse, dayToUse);\n+        return datePart + timePart;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Add to the Month component of the specified time instant\n+     * wrapping around within that component if necessary.\n+     * \n+     * @see org.joda.time.DateTimeField#addWrapField\n+     * @param instant  the time instant in millis to update.\n+     * @param months  the months to add (can be negative).\n+     * @return the updated time instant.\n+     */\n+    public long addWrapField(long instant, int months) {\n+        return set(instant, FieldUtils.getWrappedValue(get(instant), months, MIN, MAX));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {\n+        if (minuendInstant < subtrahendInstant) {\n+            return -getDifference(subtrahendInstant, minuendInstant);\n+        }\n+\n+        int minuendYear = iChronology.getYear(minuendInstant);\n+        int minuendMonth = iChronology.getMonthOfYear(minuendInstant, minuendYear);\n+        int subtrahendYear = iChronology.getYear(subtrahendInstant);\n+        int subtrahendMonth = iChronology.getMonthOfYear(subtrahendInstant, subtrahendYear);\n+\n+        long difference = (minuendYear - subtrahendYear) * 12L + minuendMonth - subtrahendMonth;\n+\n+        // Before adjusting for remainder, account for special case of add\n+        // where the day-of-month is forced to the nearest sane value.\n+        int minuendDom = iChronology.getDayOfMonth\n+            (minuendInstant, minuendYear, minuendMonth);\n+        if (minuendDom == iChronology.getDaysInYearMonth(minuendYear, minuendMonth)) {\n+            // Last day of the minuend month...\n+            int subtrahendDom = iChronology.getDayOfMonth\n+                (subtrahendInstant, subtrahendYear, subtrahendMonth);\n+            if (subtrahendDom > minuendDom) {\n+                // ...and day of subtrahend month is larger.\n+                // Note: This works fine, but it ideally shouldn't invoke other\n+                // fields from within a field.\n+                subtrahendInstant = iChronology.dayOfMonth().set(subtrahendInstant, minuendDom);\n+            }\n+        }\n+\n+        // Inlined remainder method to avoid duplicate calls.\n+        long minuendRem = minuendInstant\n+            - iChronology.getYearMonthMillis(minuendYear, minuendMonth);\n+        long subtrahendRem = subtrahendInstant\n+            - iChronology.getYearMonthMillis(subtrahendYear, subtrahendMonth);\n+\n+        if (minuendRem < subtrahendRem) {\n+            difference--;\n+        }\n+\n+        return difference;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Set the Month component of the specified time instant.<p>\n+     * If the new month has less total days than the specified\n+     * day of the month, this value is coerced to the nearest\n+     * sane value. e.g.<p>\n+     * 07-31 to month 6 = 06-30<p>\n+     * 03-31 to month 2 = 02-28 or 02-29 depending<p>\n+     * \n+     * @param instant  the time instant in millis to update.\n+     * @param month  the month (1,12) to update the time to.\n+     * @return the updated time instant.\n+     * @throws IllegalArgumentException  if month is invalid\n+     */\n+    public long set(long instant, int month) {\n+        FieldUtils.verifyValueBounds(this, month, MIN, MAX);\n+        //\n+        int thisYear = iChronology.getYear(instant);\n+        //\n+        int thisDom = iChronology.getDayOfMonth(instant, thisYear);\n+        int maxDom = iChronology.getDaysInYearMonth(thisYear, month);\n+        if (thisDom > maxDom) {\n+            // Quietly force DOM to nearest sane value.\n+            thisDom = maxDom;\n+        }\n+        // Return newly calculated millis value\n+        return iChronology.getYearMonthDayMillis(thisYear, month, thisDom) +\n+            iChronology.getMillisOfDay(instant);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public DurationField getRangeDurationField() {\n+        return iChronology.years();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public boolean isLeap(long instant) {\n+        int thisYear = iChronology.getYear(instant);\n+        if (iChronology.isLeapYear(thisYear)) {\n+            return (iChronology.getMonthOfYear(instant, thisYear) == iLeapMonth);\n+        }\n+        return false;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public int getLeapAmount(long instant) {\n+        return isLeap(instant) ? 1 : 0;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public DurationField getLeapDurationField() {\n+        return iChronology.days();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public int getMinimumValue() {\n+        return MIN;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public int getMaximumValue() {\n+        return MAX;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public long roundFloor(long instant) {\n+        int year = iChronology.getYear(instant);\n+        int month = iChronology.getMonthOfYear(instant, year);\n+        return iChronology.getYearMonthMillis(year, month);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public long remainder(long instant) {\n+        return instant - roundFloor(instant);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Serialization singleton\n+     */\n+    private Object readResolve() {\n+        return iChronology.monthOfYear();\n+    }\n+}\n--- a/JodaTime/src/java/org/joda/time/chrono/GJMonthOfYearDateTimeField.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/GJMonthOfYearDateTimeField.java\n \n import java.util.Locale;\n \n-import org.joda.time.DateTimeConstants;\n-import org.joda.time.DateTimeFieldType;\n-import org.joda.time.DurationField;\n-import org.joda.time.field.FieldUtils;\n-import org.joda.time.field.ImpreciseDateTimeField;\n-\n /**\n  * Provides time calculations for the month of the year component of time.\n  *\n  * @author Brian S O'Neill\n  * @since 1.0\n  */\n-final class GJMonthOfYearDateTimeField extends ImpreciseDateTimeField {\n+final class GJMonthOfYearDateTimeField extends BasicMonthOfYearDateTimeField {\n \n     /** Serialization version */\n     private static final long serialVersionUID = -4748157875845286249L;\n-\n-    private static final int MIN = DateTimeConstants.JANUARY;\n-    private static final int MAX = DateTimeConstants.DECEMBER;\n-\n-    private final BaseGJChronology iChronology;\n \n     /**\n      * Restricted constructor\n      */\n     GJMonthOfYearDateTimeField(BaseGJChronology chronology) {\n-        super(DateTimeFieldType.monthOfYear(), chronology.getAverageMillisPerMonth());\n-        iChronology = chronology;\n+        super(chronology, 2);\n     }\n \n-    public boolean isLenient() {\n-        return false;\n-    }\n-\n-    /**\n-     * Get the Month component of the specified time instant.\n-     *\n-     * @see org.joda.time.DateTimeField#get(long)\n-     * @see org.joda.time.ReadableDateTime#getMonthOfYear()\n-     * @param instant  the time instant in millis to query.\n-     * @return the month extracted from the input.\n-     */\n-    public int get(long instant) {\n-        return iChronology.getMonthOfYear(instant);\n-    }\n-\n+    //-----------------------------------------------------------------------\n     public String getAsText(int fieldValue, Locale locale) {\n         return GJLocaleSymbols.forLocale(locale).monthOfYearValueToText(fieldValue);\n     }\n \n+    //-----------------------------------------------------------------------\n     public String getAsShortText(int fieldValue, Locale locale) {\n         return GJLocaleSymbols.forLocale(locale).monthOfYearValueToShortText(fieldValue);\n     }\n \n-    /**\n-     * Add the specified month to the specified time instant.\n-     * The amount added may be negative.<p>\n-     * If the new month has less total days than the specified\n-     * day of the month, this value is coerced to the nearest\n-     * sane value. e.g.<p>\n-     * 07-31 - (1 month) = 06-30<p>\n-     * 03-31 - (1 month) = 02-28 or 02-29 depending<p>\n-     * \n-     * @see org.joda.time.DateTimeField#add\n-     * @see org.joda.time.ReadWritableDateTime#addMonths(int)\n-     * @param instant  the time instant in millis to update.\n-     * @param months  the months to add (can be negative).\n-     * @return the updated time instant.\n-     */\n-    public long add(long instant, int months) {\n-        if (months == 0) {\n-            return instant; // the easy case\n-        }\n-        //\n-        // Save time part first.\n-        //\n-        long timePart = iChronology.getMillisOfDay(instant);\n-        //\n-        //\n-        // Get this year and month.\n-        //\n-        int thisYear = iChronology.getYear(instant);\n-        int thisMonth = iChronology.getMonthOfYear(instant, thisYear);\n-        // ----------------------------------------------------------\n-        //\n-        // Do not refactor without careful consideration.\n-        // Order of calculation is important.\n-        //\n-        int yearToUse;\n-        // Initially, monthToUse is zero-based\n-        int monthToUse = thisMonth - 1 + months;\n-        if (monthToUse >= 0) {\n-            yearToUse = thisYear + (monthToUse / MAX);\n-            monthToUse = (monthToUse % MAX) + 1;\n-        } else {\n-            yearToUse = thisYear + (monthToUse / MAX) - 1;\n-            monthToUse = Math.abs(monthToUse);\n-            int remMonthToUse = monthToUse % MAX;\n-            // Take care of the boundary condition\n-            if (remMonthToUse == 0) {\n-                remMonthToUse = MAX;\n-            }\n-            monthToUse = MAX - remMonthToUse + 1;\n-            // Take care of the boundary condition\n-            if (monthToUse == 1) {\n-                yearToUse += 1;\n-            }\n-        }\n-        // End of do not refactor.\n-        // ----------------------------------------------------------\n-\n-        //\n-        // Quietly force DOM to nearest sane value.\n-        //\n-        int dayToUse = iChronology.getDayOfMonth(instant, thisYear, thisMonth);\n-        int maxDay = iChronology.getDaysInYearMonth(yearToUse, monthToUse);\n-        if (dayToUse > maxDay) {\n-            dayToUse = maxDay;\n-        }\n-        //\n-        // get proper date part, and return result\n-        //\n-        long datePart =\n-            iChronology.getYearMonthDayMillis(yearToUse, monthToUse, dayToUse);\n-        return datePart + timePart;\n-    }\n-\n-    public long add(long instant, long months) {\n-        int i_months = (int)months;\n-        if (i_months == months) {\n-            return add(instant, i_months);\n-        }\n-\n-        // Copied from add(long, int) and modified slightly:\n-\n-        long timePart = iChronology.getMillisOfDay(instant);\n-\n-        int thisYear = iChronology.getYear(instant);\n-        int thisMonth = iChronology.getMonthOfYear(instant, thisYear);\n-\n-        long yearToUse;\n-        long monthToUse = thisMonth - 1 + months;\n-        if (monthToUse >= 0) {\n-            yearToUse = thisYear + (monthToUse / MAX);\n-            monthToUse = (monthToUse % MAX) + 1;\n-        } else {\n-            yearToUse = thisYear + (monthToUse / MAX) - 1;\n-            monthToUse = Math.abs(monthToUse);\n-            int remMonthToUse = (int)(monthToUse % MAX);\n-            if (remMonthToUse == 0) {\n-                remMonthToUse = MAX;\n-            }\n-            monthToUse = MAX - remMonthToUse + 1;\n-            if (monthToUse == 1) {\n-                yearToUse += 1;\n-            }\n-        }\n-\n-        if (yearToUse < iChronology.getMinYear() ||\n-            yearToUse > iChronology.getMaxYear()) {\n-\n-            throw new IllegalArgumentException\n-                (\"Magnitude of add amount is too large: \" + months);\n-        }\n-\n-        int i_yearToUse = (int)yearToUse;\n-        int i_monthToUse = (int)monthToUse;\n-\n-        int dayToUse = iChronology.getDayOfMonth(instant, thisYear, thisMonth);\n-        int maxDay = iChronology.getDaysInYearMonth(i_yearToUse, i_monthToUse);\n-        if (dayToUse > maxDay) {\n-            dayToUse = maxDay;\n-        }\n-\n-        long datePart =\n-            iChronology.getYearMonthDayMillis(i_yearToUse, i_monthToUse, dayToUse);\n-        return datePart + timePart;\n-    }\n-\n-    /**\n-     * Add to the Month component of the specified time instant\n-     * wrapping around within that component if necessary.\n-     * \n-     * @see org.joda.time.DateTimeField#addWrapField\n-     * @param instant  the time instant in millis to update.\n-     * @param months  the months to add (can be negative).\n-     * @return the updated time instant.\n-     */\n-    public long addWrapField(long instant, int months) {\n-        return set(instant, FieldUtils.getWrappedValue(get(instant), months, MIN, MAX));\n-    }\n-\n-    public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {\n-        if (minuendInstant < subtrahendInstant) {\n-            return -getDifference(subtrahendInstant, minuendInstant);\n-        }\n-\n-        int minuendYear = iChronology.getYear(minuendInstant);\n-        int minuendMonth = iChronology.getMonthOfYear(minuendInstant, minuendYear);\n-        int subtrahendYear = iChronology.getYear(subtrahendInstant);\n-        int subtrahendMonth = iChronology.getMonthOfYear(subtrahendInstant, subtrahendYear);\n-\n-        long difference = (minuendYear - subtrahendYear) * 12L + minuendMonth - subtrahendMonth;\n-\n-        // Before adjusting for remainder, account for special case of add\n-        // where the day-of-month is forced to the nearest sane value.\n-        int minuendDom = iChronology.getDayOfMonth\n-            (minuendInstant, minuendYear, minuendMonth);\n-        if (minuendDom == iChronology.getDaysInYearMonth(minuendYear, minuendMonth)) {\n-            // Last day of the minuend month...\n-            int subtrahendDom = iChronology.getDayOfMonth\n-                (subtrahendInstant, subtrahendYear, subtrahendMonth);\n-            if (subtrahendDom > minuendDom) {\n-                // ...and day of subtrahend month is larger.\n-                // Note: This works fine, but it ideally shouldn't invoke other\n-                // fields from within a field.\n-                subtrahendInstant = iChronology.dayOfMonth().set(subtrahendInstant, minuendDom);\n-            }\n-        }\n-\n-        // Inlined remainder method to avoid duplicate calls.\n-        long minuendRem = minuendInstant\n-            - iChronology.getYearMonthMillis(minuendYear, minuendMonth);\n-        long subtrahendRem = subtrahendInstant\n-            - iChronology.getYearMonthMillis(subtrahendYear, subtrahendMonth);\n-\n-        if (minuendRem < subtrahendRem) {\n-            difference--;\n-        }\n-\n-        return difference;\n-    }\n-\n-    /**\n-     * Set the Month component of the specified time instant.<p>\n-     * If the new month has less total days than the specified\n-     * day of the month, this value is coerced to the nearest\n-     * sane value. e.g.<p>\n-     * 07-31 to month 6 = 06-30<p>\n-     * 03-31 to month 2 = 02-28 or 02-29 depending<p>\n-     * \n-     * @param instant  the time instant in millis to update.\n-     * @param month  the month (1,12) to update the time to.\n-     * @return the updated time instant.\n-     * @throws IllegalArgumentException  if month is invalid\n-     */\n-    public long set(long instant, int month) {\n-        FieldUtils.verifyValueBounds(this, month, MIN, MAX);\n-        //\n-        int thisYear = iChronology.getYear(instant);\n-        //\n-        int thisDom = iChronology.getDayOfMonth(instant, thisYear);\n-        int maxDom = iChronology.getDaysInYearMonth(thisYear, month);\n-        if (thisDom > maxDom) {\n-            // Quietly force DOM to nearest sane value.\n-            thisDom = maxDom;\n-        }\n-        // Return newly calculated millis value\n-        return iChronology.getYearMonthDayMillis(thisYear, month, thisDom) +\n-            iChronology.getMillisOfDay(instant);\n-    }\n-\n-    /**\n-     * Convert the specified text and locale into a value.\n-     * \n-     * @param text  the text to convert\n-     * @param locale  the locale to convert using\n-     * @return the value extracted from the text\n-     * @throws IllegalArgumentException if the text is invalid\n-     */\n+    //-----------------------------------------------------------------------\n     protected int convertText(String text, Locale locale) {\n         return GJLocaleSymbols.forLocale(locale).monthOfYearTextToValue(text);\n     }\n \n-    public DurationField getRangeDurationField() {\n-        return iChronology.years();\n-    }\n-\n-    public boolean isLeap(long instant) {\n-        int thisYear = iChronology.getYear(instant);\n-        int thisMonth = iChronology.getMonthOfYear(instant, thisYear);\n-        if (thisMonth != 2) {\n-            return false;\n-        } else {\n-            return 29 == iChronology.getDaysInYearMonth(thisYear, thisMonth);\n-        }\n-    }\n-\n-    public int getLeapAmount(long instant) {\n-        return isLeap(instant) ? 1 : 0;\n-    }\n-\n-    public DurationField getLeapDurationField() {\n-        return iChronology.days();\n-    }\n-\n-    public int getMinimumValue() {\n-        return MIN;\n-    }\n-\n-    public int getMaximumValue() {\n-        return MAX;\n-    }\n-\n+    //-----------------------------------------------------------------------\n     public int getMaximumTextLength(Locale locale) {\n         return GJLocaleSymbols.forLocale(locale).getMonthMaxTextLength();\n     }\n \n+    //-----------------------------------------------------------------------\n     public int getMaximumShortTextLength(Locale locale) {\n         return GJLocaleSymbols.forLocale(locale).getMonthMaxShortTextLength();\n     }\n \n-    public long roundFloor(long instant) {\n-        int year = iChronology.getYear(instant);\n-        int month = iChronology.getMonthOfYear(instant, year);\n-        return iChronology.getYearMonthMillis(year, month);\n-    }\n-\n-    public long remainder(long instant) {\n-        return instant - roundFloor(instant);\n-    }\n-\n-    /**\n-     * Serialization singleton\n-     */\n-    private Object readResolve() {\n-        return iChronology.monthOfYear();\n-    }\n }", "timestamp": 1133044676, "metainfo": ""}