{"sha": "d0b82920da5501a1481644f6f285bcef45268af2", "log": "Refactor partials adding getField(int,chrono)   ", "commit": "\n--- a/JodaTime/src/java/org/joda/time/TimeOfDay.java\n+++ b/JodaTime/src/java/org/joda/time/TimeOfDay.java\n import java.io.Serializable;\n import java.util.Locale;\n \n-import org.joda.time.base.*;\n+import org.joda.time.base.BasePartial;\n import org.joda.time.field.AbstractPartialFieldProperty;\n import org.joda.time.format.ISODateTimeFormat;\n \n \n     //-----------------------------------------------------------------------\n     /**\n-     * Initialize the array of fields.\n-     * \n+     * Gets the number of fields in this partial.\n+     * \n+     * @return the field count\n+     */\n+    public int getFieldSize() {\n+        return 4;\n+    }\n+\n+    /**\n+     * Gets the field for a specific index in the chronology specified.\n+     * <p>\n+     * This method must not use any instance variables.\n+     * \n+     * @param index  the index to retrieve\n      * @param chrono  the chronology to use\n-     */\n-    protected DateTimeField[] initFields(Chronology chrono) {\n-        return new DateTimeField[] {\n-            chrono.hourOfDay(),\n-            chrono.minuteOfHour(),\n-            chrono.secondOfMinute(),\n-            chrono.millisOfSecond(),\n-        };\n-    }\n-\n-    /**\n-     * Initialize the array of values.\n-     * \n-     * @param instant  the instant to use\n-     * @param chrono  the chronology to use\n-     */\n-    protected int[] initValues(long instant, Chronology chrono) {\n-        return new int[] {\n-            chrono.hourOfDay().get(instant),\n-            chrono.minuteOfHour().get(instant),\n-            chrono.secondOfMinute().get(instant),\n-            chrono.millisOfSecond().get(instant),\n-        };\n+     * @return the field\n+     */\n+    protected DateTimeField getField(int index, Chronology chrono) {\n+        switch (index) {\n+            case HOUR_OF_DAY:\n+                return chrono.hourOfDay();\n+            case MINUTE_OF_HOUR:\n+                return chrono.minuteOfHour();\n+            case SECOND_OF_MINUTE:\n+                return chrono.secondOfMinute();\n+            case MILLIS_OF_SECOND:\n+                return chrono.millisOfSecond();\n+            default:\n+                throw new IndexOutOfBoundsException(\"Invalid index: \" + index);\n+        }\n     }\n \n     //-----------------------------------------------------------------------\n--- a/JodaTime/src/java/org/joda/time/YearMonthDay.java\n+++ b/JodaTime/src/java/org/joda/time/YearMonthDay.java\n \n     //-----------------------------------------------------------------------\n     /**\n-     * Initialize the array of fields.\n-     * \n+     * Gets the number of fields in this partial.\n+     * \n+     * @return the field count\n+     */\n+    public int getFieldSize() {\n+        return 3;\n+    }\n+\n+    /**\n+     * Gets the field for a specific index in the chronology specified.\n+     * <p>\n+     * This method must not use any instance variables.\n+     * \n+     * @param index  the index to retrieve\n      * @param chrono  the chronology to use\n-     */\n-    protected DateTimeField[] initFields(Chronology chrono) {\n-        return new DateTimeField[] {\n-            chrono.year(),\n-            chrono.monthOfYear(),\n-            chrono.dayOfMonth(),\n-        };\n-    }\n-\n-    /**\n-     * Initialize the array of values.\n-     * \n-     * @param instant  the instant to use\n-     * @param chrono  the chronology to use\n-     */\n-    protected int[] initValues(long instant, Chronology chrono) {\n-        return new int[] {\n-            chrono.year().get(instant),\n-            chrono.monthOfYear().get(instant),\n-            chrono.dayOfMonth().get(instant),\n-        };\n+     * @return the field\n+     */\n+    protected DateTimeField getField(int index, Chronology chrono) {\n+        switch (index) {\n+            case YEAR:\n+                return chrono.year();\n+            case MONTH_OF_YEAR:\n+                return chrono.monthOfYear();\n+            case DAY_OF_MONTH:\n+                return chrono.dayOfMonth();\n+            default:\n+                throw new IndexOutOfBoundsException(\"Invalid index: \" + index);\n+        }\n     }\n \n     //-----------------------------------------------------------------------\n--- a/JodaTime/src/java/org/joda/time/base/AbstractPartial.java\n+++ b/JodaTime/src/java/org/joda/time/base/AbstractPartial.java\n \n     //-----------------------------------------------------------------------\n     /**\n+     * Gets the field for a specific index in the chronology specified.\n+     * <p>\n+     * This method must not use any instance variables.\n+     * \n+     * @param index  the index to retrieve\n+     * @param chrono  the chronology to use\n+     * @return the field\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    protected abstract DateTimeField getField(int index, Chronology chrono);\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the field at the specifed index.\n+     * \n+     * @param index  the index\n+     * @return the field\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    public DateTimeField getField(int index) {\n+        return getField(index, getChronology());\n+    }\n+\n+    /**\n      * Gets an array of the fields that this partial supports.\n      * <p>\n      * The fields are returned largest to smallest, for example Hour, Minute, Second.\n     protected long resolve(long baseInstant, Chronology chrono) {\n         long millis = baseInstant;\n         for (int i = 0, isize = getFieldSize(); i < isize; i++) {\n-            millis = getField(i).set(millis, getValue(i));\n+            millis = getField(i, chrono).set(millis, getValue(i));\n         }\n         return millis;\n     }\n--- a/JodaTime/src/java/org/joda/time/base/BasePartial.java\n+++ b/JodaTime/src/java/org/joda/time/base/BasePartial.java\n  */\n package org.joda.time.base;\n \n-import java.io.IOException;\n-import java.io.ObjectInputStream;\n import java.io.Serializable;\n \n import org.joda.time.Chronology;\n     private Chronology iChronology;\n     /** The values of each field in this partial */\n     private int[] iValues;\n-    /** The values of each field in this partial */\n+    /** A cached array of fields. */\n     private transient DateTimeField[] iFields;\n \n     //-----------------------------------------------------------------------\n         super();\n         chronology = DateTimeUtils.getChronology(chronology);\n         iChronology = chronology.withUTC();\n-        iFields = initFields(iChronology);\n         iValues = initValues(instant, chronology);\n     }\n \n         Chronology chronology = converter.getChronology(instant);\n         chronology = DateTimeUtils.getChronology(chronology);\n         iChronology = chronology.withUTC();\n-        iFields = initFields(iChronology);\n         iValues = initValues(millis, chronology);\n     }\n \n         chronology = converter.getChronology(instant, chronology);\n         chronology = DateTimeUtils.getChronology(chronology);\n         iChronology = chronology.withUTC();\n-        iFields = initFields(iChronology);\n         iValues = initValues(millis, chronology);\n     }\n \n         super();\n         chronology = DateTimeUtils.getChronology(chronology);\n         iChronology = chronology.withUTC();\n-        iFields = initFields(iChronology);\n         chronology.validate(this, values);\n         iValues = (int[]) values.clone();\n     }\n      */\n     protected BasePartial(BasePartial other, int[] values) {\n         super();\n+        iChronology = other.iChronology;\n+        iValues = values;\n         iFields = other.iFields;\n-        iValues = values;\n-        iChronology = other.iChronology;\n     }\n \n     //-----------------------------------------------------------------------\n-    /**\n-     * Recreates the state of this object after deserialization.\n-     * \n-     * @param in  the input stream\n-     */\n-    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n-        in.defaultReadObject();\n-        iFields = initFields(iChronology);\n-    }\n-\n-    /**\n-     * Initialize the array of fields.\n-     * The field and value arrays must match.\n-     * \n-     * @param chrono  the chronology to use\n-     */\n-    protected abstract DateTimeField[] initFields(Chronology chrono);\n-\n     /**\n      * Initialize the array of values.\n      * The field and value arrays must match.\n      * @param instant  the instant to use\n      * @param chrono  the chronology to use\n      */\n-    protected abstract int[] initValues(long instant, Chronology chrono);\n+    protected int[] initValues(long instant, Chronology chrono) {\n+        int[] values = new int[getFieldSize()];\n+        for (int i = 0; i < values.length; i++) {\n+            values[i] = getField(i, chrono).get(instant);\n+        }\n+        return values;\n+    }\n \n     //-----------------------------------------------------------------------\n-    /**\n-     * Gets the number of fields in this partial.\n-     * \n-     * @return the field count\n-     */\n-    public int getFieldSize() {\n-        return iFields.length;\n-    }\n-\n     /**\n      * Gets the field at the specifed index.\n      * \n      * @throws IndexOutOfBoundsException if the index is invalid\n      */\n     public DateTimeField getField(int index) {\n-        return iFields[index];\n+        DateTimeField[] fields = iFields;\n+        if (fields != null) {\n+            return fields[index];\n+        } else {\n+            return getField(index, getChronology());\n+        }\n+    }\n+\n+    /**\n+     * Gets an array of the fields that this partial supports.\n+     * <p>\n+     * The fields are returned largest to smallest, for example Hour, Minute, Second.\n+     *\n+     * @return the fields supported in an array that may be altered, largest to smallest\n+     */\n+    public DateTimeField[] getFields() {\n+        DateTimeField[] fields = iFields;\n+        if (fields == null) {\n+            fields = super.getFields();\n+            iFields = fields;\n+        }\n+        return (DateTimeField[]) fields.clone();\n     }\n \n     /**\n         return iValues[index];\n     }\n \n-    //-----------------------------------------------------------------------\n-    /**\n-     * Gets an array of the fields that this partial supports.\n-     * <p>\n-     * The fields are returned largest to smallest, for example Hour, Minute, Second.\n-     *\n-     * @return the fields supported (cloned), largest to smallest\n-     */\n-    public DateTimeField[] getFields() {\n-        return (DateTimeField[]) iFields.clone();\n-    }\n-\n     /**\n      * Gets an array of the value of each of the fields that this partial supports.\n      * <p>", "timestamp": 1093302662, "metainfo": ""}