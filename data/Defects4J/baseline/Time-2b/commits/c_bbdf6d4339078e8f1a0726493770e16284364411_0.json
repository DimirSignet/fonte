{"sha": "bbdf6d4339078e8f1a0726493770e16284364411", "log": "Add methods to the partial classes   ", "commit": "\n--- a/JodaTime/src/java/org/joda/time/TimeOfDay.java\n+++ b/JodaTime/src/java/org/joda/time/TimeOfDay.java\n \n import org.joda.time.base.BasePartial;\n import org.joda.time.field.AbstractPartialFieldProperty;\n+import org.joda.time.field.FieldUtils;\n import org.joda.time.format.ISODateTimeFormat;\n \n /**\n     }\n \n     /**\n+     * Gets a copy of this date with the specified field set to a new value.\n+     * <p>\n+     * For example, if the field type is <code>minuteOfHour</code> then the day\n+     * would be changed in the returned instance.\n+     * <p>\n+     * These three lines are equivalent:\n+     * <pre>\n+     * TimeOfDay updated = tod.withField(DateTimeFieldType.minuteOfHour(), 6);\n+     * TimeOfDay updated = tod.minuteOfHour().setCopy(6);\n+     * TimeOfDay updated = tod.property(DateTimeFieldType.minuteOfHour()).setCopy(6);\n+     * </pre>\n+     *\n+     * @param fieldType  the field type to set, not null\n+     * @param value  the value to set\n+     * @return a copy of this instance with the field set\n+     * @throws IllegalArgumentException if the value is null or invalid\n+     */\n+    public TimeOfDay withField(DateTimeFieldType fieldType, int value) {\n+        if (value == 0) {\n+            return this;\n+        }\n+        int index = indexOfSupported(fieldType);\n+        int[] newValues = getValues();\n+        newValues = getField(index).set(this, index, newValues, value);\n+        return new TimeOfDay(this, newValues);\n+    }\n+\n+    /**\n+     * Gets a copy of this date with the value of the specified field increased.\n+     * <p>\n+     * If the addition is zero, then <code>this</code> is returned.\n+     * <p>\n+     * These three lines are equivalent:\n+     * <pre>\n+     * TimeOfDay added = tod.withField(DateTimeFieldType.minuteOfHour(), 6);\n+     * TimeOfDay added = tod.minuteOfHour().addToCopy(6);\n+     * TimeOfDay added = tod.property(DateTimeFieldType.minuteOfHour()).addToCopy(6);\n+     * </pre>\n+     * \n+     * @param fieldType  the field type to add to, not null\n+     * @param amount  the amount to add\n+     * @return a copy of this instance with the field updated\n+     * @throws IllegalArgumentException if the value is null or invalid\n+     * @throws ArithmeticException if the new datetime exceeds the capacity\n+     */\n+    public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount) {\n+        if (amount == 0) {\n+            return this;\n+        }\n+        int index = indexOfSupported(fieldType);\n+        int[] newValues = getValues();\n+        newValues = getField(index).add(this, index, newValues, amount);\n+        return new TimeOfDay(this, newValues);\n+    }\n+\n+    /**\n+     * Gets a copy of this date with the specified period added.\n+     * <p>\n+     * If the addition is zero, then <code>this</code> is returned.\n+     * Fields in the period that aren't present in the partial are ignored.\n+     * <p>\n+     * To add or subtract on a single field see\n+     * {@link #withFieldAdded(DurationFieldType, int)}.\n+     * \n+     * @param period  the period to add to this one, null means zero\n+     * @param scalar  the amount of times to add, such as -1 to subtract once\n+     * @return a copy of this instance with the period added\n+     * @throws ArithmeticException if the new datetime exceeds the capacity\n+     */\n+    public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar) {\n+        if (period == null || scalar == 0) {\n+            return this;\n+        }\n+        int[] newValues = getValues();\n+        for (int i = 0; i < period.size(); i++) {\n+            DurationFieldType fieldType = period.getFieldType(i);\n+            int index = indexOf(fieldType);\n+            if (index >= 0) {\n+                newValues = getField(index).add(this, index, newValues,\n+                        FieldUtils.safeMultiplyToInt(period.getValue(i), scalar));\n+            }\n+        }\n+        return new TimeOfDay(this, newValues);\n+    }\n+\n+    /**\n+     * Gets a copy of this instance with the specified period added.\n+     * <p>\n+     * If the amount is zero or null, then <code>this</code> is returned.\n+     * <p>\n+     * The following two lines are identical in effect:\n+     * <pre>\n+     * TimeOfDay added = tod.minuteOfHour().addToCopy(6);\n+     * TimeOfDay added = tod.plus(Period.days(6));\n+     * </pre>\n+     * \n+     * @param period  the duration to add to this one, null means zero\n+     * @return a copy of this instance with the period added\n+     * @throws ArithmeticException if the new datetime exceeds the capacity of a long\n+     */\n+    public TimeOfDay plus(ReadablePeriod period) {\n+        return withPeriodAdded(period, 1);\n+    }\n+\n+    /**\n+     * Gets a copy of this instance with the specified period take away.\n+     * <p>\n+     * If the amount is zero or null, then <code>this</code> is returned.\n+     * <p>\n+     * The following lines are identical in effect:\n+     * <pre>\n+     * TimeOfDay added = tod.minuteOfHour().addToCopy(-6);\n+     * TimeOfDay added = tod.minus(Period.days(6));\n+     * TimeOfDay added = tod.plus(Period.days(-6));\n+     * </pre>\n+     * \n+     * @param period  the period to reduce this instant by\n+     * @return a copy of this instance with the period taken away\n+     * @throws ArithmeticException if the new datetime exceeds the capacity of a long\n+     */\n+    public TimeOfDay minus(ReadablePeriod period) {\n+        return withPeriodAdded(period, -1);\n+    }\n+\n+    /**\n      * Gets the property object for the specified type, which contains many useful methods.\n      *\n      * @param type  the field type to get the chronology for\n      */\n     public Property property(DateTimeFieldType type) {\n         return new Property(this, indexOfSupported(type));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Converts this partial to a full datetime using the default time zone\n+     * setting the time fields from this instance and the date fields from\n+     * the current time.\n+     *\n+     * @return this date as a datetime with the time as the current time\n+     */\n+    public DateTime toDateTimeToday() {\n+        return toDateTimeToday(null);\n+    }\n+\n+    /**\n+     * Converts this partial to a full datetime using the specified time zone\n+     * setting the time fields from this instance and the date fields from\n+     * the current time.\n+     * <p>\n+     * This method uses the chronology from this instance plus the time zone\n+     * specified.\n+     *\n+     * @param zone  the zone to use, null means default\n+     * @return this date as a datetime with the time as the current time\n+     */\n+    public DateTime toDateTimeToday(DateTimeZone zone) {\n+        Chronology chrono = getChronology().withZone(zone);\n+        long instantMillis = DateTimeUtils.currentTimeMillis();\n+        long resolved = chrono.set(this, instantMillis);\n+        return new DateTime(resolved, chrono);\n     }\n \n     //-----------------------------------------------------------------------\n          * \n          * @return the partial\n          */\n-        public ReadablePartial getReadablePartial() {\n+        protected ReadablePartial getReadablePartial() {\n             return iTimeOfDay;\n         }\n \n--- a/JodaTime/src/java/org/joda/time/YearMonthDay.java\n+++ b/JodaTime/src/java/org/joda/time/YearMonthDay.java\n \n import org.joda.time.base.BasePartial;\n import org.joda.time.field.AbstractPartialFieldProperty;\n+import org.joda.time.field.FieldUtils;\n import org.joda.time.format.ISODateTimeFormat;\n \n /**\n     }\n \n     /**\n+     * Gets a copy of this date with the specified field set to a new value.\n+     * <p>\n+     * For example, if the field type is <code>dayOfMonth</code> then the day\n+     * would be changed in the returned instance.\n+     * <p>\n+     * These three lines are equivalent:\n+     * <pre>\n+     * YearMonthDay updated = ymd.withField(DateTimeFieldType.dayOfMonth(), 6);\n+     * YearMonthDay updated = ymd.dayOfMonth().setCopy(6);\n+     * YearMonthDay updated = ymd.property(DateTimeFieldType.dayOfMonth()).setCopy(6);\n+     * </pre>\n+     *\n+     * @param fieldType  the field type to set, not null\n+     * @param value  the value to set\n+     * @return a copy of this instance with the field set\n+     * @throws IllegalArgumentException if the value is null or invalid\n+     */\n+    public YearMonthDay withField(DateTimeFieldType fieldType, int value) {\n+        if (value == 0) {\n+            return this;\n+        }\n+        int index = indexOfSupported(fieldType);\n+        int[] newValues = getValues();\n+        newValues = getField(index).set(this, index, newValues, value);\n+        return new YearMonthDay(this, newValues);\n+    }\n+\n+    /**\n+     * Gets a copy of this date with the value of the specified field increased.\n+     * <p>\n+     * If the addition is zero, then <code>this</code> is returned.\n+     * <p>\n+     * These three lines are equivalent:\n+     * <pre>\n+     * YearMonthDay added = ymd.withField(DateTimeFieldType.dayOfMonth(), 6);\n+     * YearMonthDay added = ymd.dayOfMonth().addToCopy(6);\n+     * YearMonthDay added = ymd.property(DateTimeFieldType.dayOfMonth()).addToCopy(6);\n+     * </pre>\n+     * \n+     * @param fieldType  the field type to add to, not null\n+     * @param amount  the amount to add\n+     * @return a copy of this instance with the field updated\n+     * @throws IllegalArgumentException if the value is null or invalid\n+     * @throws ArithmeticException if the new datetime exceeds the capacity\n+     */\n+    public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount) {\n+        if (amount == 0) {\n+            return this;\n+        }\n+        int index = indexOfSupported(fieldType);\n+        int[] newValues = getValues();\n+        newValues = getField(index).add(this, index, newValues, amount);\n+        return new YearMonthDay(this, newValues);\n+    }\n+\n+    /**\n+     * Gets a copy of this date with the specified period added.\n+     * <p>\n+     * If the addition is zero, then <code>this</code> is returned.\n+     * Fields in the period that aren't present in the partial are ignored.\n+     * <p>\n+     * To add or subtract on a single field see\n+     * {@link #withFieldAdded(DurationFieldType, int)}.\n+     * \n+     * @param period  the period to add to this one, null means zero\n+     * @param scalar  the amount of times to add, such as -1 to subtract once\n+     * @return a copy of this instance with the period added\n+     * @throws ArithmeticException if the new datetime exceeds the capacity\n+     */\n+    public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar) {\n+        if (period == null || scalar == 0) {\n+            return this;\n+        }\n+        int[] newValues = getValues();\n+        for (int i = 0; i < period.size(); i++) {\n+            DurationFieldType fieldType = period.getFieldType(i);\n+            int index = indexOf(fieldType);\n+            if (index >= 0) {\n+                newValues = getField(index).add(this, index, newValues,\n+                        FieldUtils.safeMultiplyToInt(period.getValue(i), scalar));\n+            }\n+        }\n+        return new YearMonthDay(this, newValues);\n+    }\n+\n+    /**\n+     * Gets a copy of this instance with the specified period added.\n+     * <p>\n+     * If the amount is zero or null, then <code>this</code> is returned.\n+     * <p>\n+     * The following two lines are identical in effect:\n+     * <pre>\n+     * YearMonthDay added = ymd.dayOfMonth().addToCopy(6);\n+     * YearMonthDay added = ymd.plus(Period.days(6));\n+     * </pre>\n+     * \n+     * @param period  the duration to add to this one, null means zero\n+     * @return a copy of this instance with the period added\n+     * @throws ArithmeticException if the new datetime exceeds the capacity of a long\n+     */\n+    public YearMonthDay plus(ReadablePeriod period) {\n+        return withPeriodAdded(period, 1);\n+    }\n+\n+    /**\n+     * Gets a copy of this instance with the specified period take away.\n+     * <p>\n+     * If the amount is zero or null, then <code>this</code> is returned.\n+     * <p>\n+     * The following lines are identical in effect:\n+     * <pre>\n+     * YearMonthDay added = ymd.dayOfMonth().addToCopy(-6);\n+     * YearMonthDay added = ymd.minus(Period.days(6));\n+     * YearMonthDay added = ymd.plus(Period.days(-6));\n+     * </pre>\n+     * \n+     * @param period  the period to reduce this instant by\n+     * @return a copy of this instance with the period taken away\n+     * @throws ArithmeticException if the new datetime exceeds the capacity of a long\n+     */\n+    public YearMonthDay minus(ReadablePeriod period) {\n+        return withPeriodAdded(period, -1);\n+    }\n+\n+    /**\n      * Gets the property object for the specified type, which contains many useful methods.\n      *\n      * @param type  the field type to get the chronology for\n      */\n     public Property property(DateTimeFieldType type) {\n         return new Property(this, indexOfSupported(type));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Converts this YearMonthDay to a full datetime at midnight using the\n+     * default time zone.\n+     *\n+     * @return this date as a datetime at midnight\n+     */\n+    public DateTime toDateTimeAtMidnight() {\n+        return toDateTimeAtMidnight(null);\n+    }\n+\n+    /**\n+     * Converts this YearMonthDay to a full datetime at midnight using the\n+     * specified time zone.\n+     * <p>\n+     * This method uses the chronology from this instance plus the time zone\n+     * specified.\n+     *\n+     * @param zone  the zone to use, null means default\n+     * @return this date as a datetime at midnight\n+     */\n+    public DateTime toDateTimeAtMidnight(DateTimeZone zone) {\n+        Chronology chrono = getChronology().withZone(zone);\n+        return new DateTime(getYear(), getMonthOfYear(), getDayOfMonth(), 0, 0, 0, 0, chrono);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Converts this partial to a full datetime using the default time zone\n+     * setting the date fields from this instance and the time fields from\n+     * the current time.\n+     *\n+     * @return this date as a datetime with the time as the current time\n+     */\n+    public DateTime toDateTimeAtCurrentTime() {\n+        return toDateTimeAtCurrentTime(null);\n+    }\n+\n+    /**\n+     * Converts this partial to a full datetime using the specified time zone\n+     * setting the date fields from this instance and the time fields from\n+     * the current time.\n+     * <p>\n+     * This method uses the chronology from this instance plus the time zone\n+     * specified.\n+     *\n+     * @param zone  the zone to use, null means default\n+     * @return this date as a datetime with the time as the current time\n+     */\n+    public DateTime toDateTimeAtCurrentTime(DateTimeZone zone) {\n+        Chronology chrono = getChronology().withZone(zone);\n+        long instantMillis = DateTimeUtils.currentTimeMillis();\n+        long resolved = chrono.set(this, instantMillis);\n+        return new DateTime(resolved, chrono);\n     }\n \n     //-----------------------------------------------------------------------\n \n     //-----------------------------------------------------------------------\n     /**\n-     * Output the time in the ISO8601 format YYYY-MM-DD.\n+     * Output the date in the ISO8601 format YYYY-MM-DD.\n      * \n      * @return ISO8601 formatted string\n      */\n          * \n          * @return the partial\n          */\n-        public ReadablePartial getReadablePartial() {\n+        protected ReadablePartial getReadablePartial() {\n             return iYearMonthDay;\n         }\n \n--- a/JodaTime/src/java/org/joda/time/base/AbstractPartial.java\n+++ b/JodaTime/src/java/org/joda/time/base/AbstractPartial.java\n import org.joda.time.DateTimeField;\n import org.joda.time.DateTimeFieldType;\n import org.joda.time.DateTimeUtils;\n-import org.joda.time.DateTimeZone;\n+import org.joda.time.DurationFieldType;\n import org.joda.time.ReadableInstant;\n import org.joda.time.ReadablePartial;\n \n      * Gets the index of the specified field, throwing an exception if the\n      * field is unsupported.\n      *\n-     * @param type  the type to check, may be null which returns -1\n-     * @return the index of the field, -1 if unsupported\n+     * @param type  the type to check, not null\n+     * @return the index of the field\n      * @throws IllegalArgumentException if the field is null or not supported\n      */\n     protected int indexOfSupported(DateTimeFieldType type) {\n         return index;\n     }\n \n-    //-----------------------------------------------------------------------\n-    /**\n-     * Converts this partial to a full datetime using the specified time zone and\n-     * filing in any gaps using the current datetime.\n-     * <p>\n-     * This method obtains the current datetime, creates a chronology from that\n-     * on this instance plus the time zone specified, and then sets the fields\n-     * from this instant on top.\n-     * <p>\n-     * For example, if this partial represents a time, then the result of this\n-     * method will be the datetime from the specified base instant plus the\n-     * time from this partial.\n-     *\n-     * @param zone  the zone to use, null means default\n-     * @return the combined datetime\n-     */\n-    public DateTime toDateTime(DateTimeZone zone) {\n-        Chronology chrono = getChronology().withZone(zone);\n-        long instantMillis = DateTimeUtils.currentTimeMillis();\n-        long resolved = chrono.set(this, instantMillis);\n-        return new DateTime(resolved, chrono);\n-    }\n-\n+    /**\n+     * Gets the index of the first fields to have the specified duration,\n+     * or -1 if the field is unsupported.\n+     *\n+     * @param type  the type to check, may be null which returns -1\n+     * @return the index of the field, -1 if unsupported\n+     */\n+    protected int indexOf(DurationFieldType type) {\n+        for (int i = 0, isize = size(); i < isize; i++) {\n+            if (getFieldType(i).getDurationType() == type) {\n+                return i;\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    /**\n+     * Gets the index of the first fields to have the specified duration,\n+     * throwing an exception if the field is unsupported.\n+     *\n+     * @param type  the type to check, not null\n+     * @return the index of the field\n+     * @throws IllegalArgumentException if the field is null or not supported\n+     */\n+    protected int indexOfSupported(DurationFieldType type) {\n+        int index = indexOf(type);\n+        if (index == -1) {\n+            throw new IllegalArgumentException(\"Field '\" + type + \"' is not supported\");\n+        }\n+        return index;\n+    }\n+\n+    //-----------------------------------------------------------------------\n     /**\n      * Resolves this partial against another complete instant to create a new\n      * full instant. The combination is performed using the chronology of the\n--- a/JodaTime/src/java/org/joda/time/base/BasePartial.java\n+++ b/JodaTime/src/java/org/joda/time/base/BasePartial.java\n package org.joda.time.base;\n \n import java.io.Serializable;\n+import java.util.Locale;\n \n import org.joda.time.Chronology;\n-import org.joda.time.DateTime;\n import org.joda.time.DateTimeField;\n import org.joda.time.DateTimeUtils;\n-import org.joda.time.DateTimeZone;\n import org.joda.time.ReadablePartial;\n import org.joda.time.convert.ConverterManager;\n import org.joda.time.convert.PartialConverter;\n+import org.joda.time.format.DateTimeFormat;\n \n /**\n  * BasePartial is an abstract implementation of ReadablePartial that stores\n \n     //-----------------------------------------------------------------------\n     /**\n-     * Converts this object to a DateTime using the current date to fill in the\n-     * missing fields and using the default time zone.\n-     *\n-     * @return the DateTime instance\n-     */\n-    public DateTime toDateTime() {\n-        return toDateTime((DateTimeZone) null);\n+     * Output the date using the specified format pattern.\n+     *\n+     * @param pattern  the pattern specification, null means use <code>toString</code>\n+     * @see org.joda.time.format.DateTimeFormat\n+     */\n+    public String toString(String pattern) {\n+        if (pattern == null) {\n+            return toString();\n+        }\n+        return DateTimeFormat.getInstance().forPattern(pattern).print(this);\n+    }\n+\n+    /**\n+     * Output the date using the specified format pattern.\n+     *\n+     * @param pattern  the pattern specification, null means use <code>toString</code>\n+     * @param locale  Locale to use, null means default\n+     * @see org.joda.time.format.DateTimeFormat\n+     */\n+    public String toString(String pattern, Locale locale) throws IllegalArgumentException {\n+        if (pattern == null) {\n+            return toString();\n+        }\n+        return DateTimeFormat.getInstance(locale).forPattern(pattern).print(this);\n     }\n \n }\n--- a/JodaTime/src/java/org/joda/time/field/AbstractPartialFieldProperty.java\n+++ b/JodaTime/src/java/org/joda/time/field/AbstractPartialFieldProperty.java\n      * \n      * @return the partial instant\n      */\n-    public abstract ReadablePartial getReadablePartial();\n+    protected abstract ReadablePartial getReadablePartial();\n \n     //-----------------------------------------------------------------------\n     /**\n--- a/JodaTime/src/test/org/joda/time/TestMutableDateTime_Properties.java\n+++ b/JodaTime/src/test/org/joda/time/TestMutableDateTime_Properties.java\n         assertSame(test.getChronology().era(), test.era().getField());\n         assertEquals(\"era\", test.era().getName());\n         assertEquals(\"Property[era]\", test.era().toString());\n-        assertSame(test, test.era().getReadableInstant());\n         assertSame(test, test.era().getMutableDateTime());\n         assertEquals(1, test.era().get());\n         assertEquals(\"AD\", test.era().getAsText());\n         assertSame(test.getChronology().yearOfEra(), test.yearOfEra().getField());\n         assertEquals(\"yearOfEra\", test.yearOfEra().getName());\n         assertEquals(\"Property[yearOfEra]\", test.yearOfEra().toString());\n-        assertSame(test, test.yearOfEra().getReadableInstant());\n         assertEquals(2004, test.yearOfEra().get());\n         assertEquals(\"2004\", test.yearOfEra().getAsText());\n         assertEquals(\"2004\", test.yearOfEra().getAsText(Locale.FRENCH));\n         assertSame(test.getChronology().centuryOfEra(), test.centuryOfEra().getField());\n         assertEquals(\"centuryOfEra\", test.centuryOfEra().getName());\n         assertEquals(\"Property[centuryOfEra]\", test.centuryOfEra().toString());\n-        assertSame(test, test.centuryOfEra().getReadableInstant());\n         assertEquals(20, test.centuryOfEra().get());\n         assertEquals(\"20\", test.centuryOfEra().getAsText());\n         assertEquals(\"20\", test.centuryOfEra().getAsText(Locale.FRENCH));\n         assertSame(test.getChronology().yearOfCentury(), test.yearOfCentury().getField());\n         assertEquals(\"yearOfCentury\", test.yearOfCentury().getName());\n         assertEquals(\"Property[yearOfCentury]\", test.yearOfCentury().toString());\n-        assertSame(test, test.yearOfCentury().getReadableInstant());\n         assertEquals(4, test.yearOfCentury().get());\n         assertEquals(\"4\", test.yearOfCentury().getAsText());\n         assertEquals(\"4\", test.yearOfCentury().getAsText(Locale.FRENCH));\n         assertSame(test.getChronology().weekyear(), test.weekyear().getField());\n         assertEquals(\"weekyear\", test.weekyear().getName());\n         assertEquals(\"Property[weekyear]\", test.weekyear().toString());\n-        assertSame(test, test.weekyear().getReadableInstant());\n         assertEquals(2004, test.weekyear().get());\n         assertEquals(\"2004\", test.weekyear().getAsText());\n         assertEquals(\"2004\", test.weekyear().getAsText(Locale.FRENCH));\n         assertSame(test.getChronology().year(), test.year().getField());\n         assertEquals(\"year\", test.year().getName());\n         assertEquals(\"Property[year]\", test.year().toString());\n-        assertSame(test, test.year().getReadableInstant());\n         assertEquals(2004, test.year().get());\n         assertEquals(\"2004\", test.year().getAsText());\n         assertEquals(\"2004\", test.year().getAsText(Locale.FRENCH));\n         assertSame(test.getChronology().monthOfYear(), test.monthOfYear().getField());\n         assertEquals(\"monthOfYear\", test.monthOfYear().getName());\n         assertEquals(\"Property[monthOfYear]\", test.monthOfYear().toString());\n-        assertSame(test, test.monthOfYear().getReadableInstant());\n         assertEquals(6, test.monthOfYear().get());\n         assertEquals(\"June\", test.monthOfYear().getAsText());\n         assertEquals(\"juin\", test.monthOfYear().getAsText(Locale.FRENCH));\n         assertSame(test.getChronology().dayOfMonth(), test.dayOfMonth().getField());\n         assertEquals(\"dayOfMonth\", test.dayOfMonth().getName());\n         assertEquals(\"Property[dayOfMonth]\", test.dayOfMonth().toString());\n-        assertSame(test, test.dayOfMonth().getReadableInstant());\n         assertEquals(9, test.dayOfMonth().get());\n         assertEquals(\"9\", test.dayOfMonth().getAsText());\n         assertEquals(\"9\", test.dayOfMonth().getAsText(Locale.FRENCH));\n         assertSame(test.getChronology().dayOfYear(), test.dayOfYear().getField());\n         assertEquals(\"dayOfYear\", test.dayOfYear().getName());\n         assertEquals(\"Property[dayOfYear]\", test.dayOfYear().toString());\n-        assertSame(test, test.dayOfYear().getReadableInstant());\n         assertEquals(161, test.dayOfYear().get());\n         assertEquals(\"161\", test.dayOfYear().getAsText());\n         assertEquals(\"161\", test.dayOfYear().getAsText(Locale.FRENCH));\n         assertSame(test.getChronology().weekOfWeekyear(), test.weekOfWeekyear().getField());\n         assertEquals(\"weekOfWeekyear\", test.weekOfWeekyear().getName());\n         assertEquals(\"Property[weekOfWeekyear]\", test.weekOfWeekyear().toString());\n-        assertSame(test, test.weekOfWeekyear().getReadableInstant());\n         assertEquals(24, test.weekOfWeekyear().get());\n         assertEquals(\"24\", test.weekOfWeekyear().getAsText());\n         assertEquals(\"24\", test.weekOfWeekyear().getAsText(Locale.FRENCH));\n         assertSame(test.getChronology().dayOfWeek(), test.dayOfWeek().getField());\n         assertEquals(\"dayOfWeek\", test.dayOfWeek().getName());\n         assertEquals(\"Property[dayOfWeek]\", test.dayOfWeek().toString());\n-        assertSame(test, test.dayOfWeek().getReadableInstant());\n         assertEquals(3, test.dayOfWeek().get());\n         assertEquals(\"Wednesday\", test.dayOfWeek().getAsText());\n         assertEquals(\"mercredi\", test.dayOfWeek().getAsText(Locale.FRENCH));\n         assertSame(test.getChronology().hourOfDay(), test.hourOfDay().getField());\n         assertEquals(\"hourOfDay\", test.hourOfDay().getName());\n         assertEquals(\"Property[hourOfDay]\", test.hourOfDay().toString());\n-        assertSame(test, test.hourOfDay().getReadableInstant());\n         assertEquals(13, test.hourOfDay().get());\n         assertEquals(\"13\", test.hourOfDay().getAsText());\n         assertEquals(\"13\", test.hourOfDay().getAsText(Locale.FRENCH));\n         assertSame(test.getChronology().minuteOfHour(), test.minuteOfHour().getField());\n         assertEquals(\"minuteOfHour\", test.minuteOfHour().getName());\n         assertEquals(\"Property[minuteOfHour]\", test.minuteOfHour().toString());\n-        assertSame(test, test.minuteOfHour().getReadableInstant());\n         assertEquals(23, test.minuteOfHour().get());\n         assertEquals(\"23\", test.minuteOfHour().getAsText());\n         assertEquals(\"23\", test.minuteOfHour().getAsText(Locale.FRENCH));\n         assertSame(test.getChronology().minuteOfDay(), test.minuteOfDay().getField());\n         assertEquals(\"minuteOfDay\", test.minuteOfDay().getName());\n         assertEquals(\"Property[minuteOfDay]\", test.minuteOfDay().toString());\n-        assertSame(test, test.minuteOfDay().getReadableInstant());\n         assertEquals(803, test.minuteOfDay().get());\n         assertEquals(\"803\", test.minuteOfDay().getAsText());\n         assertEquals(\"803\", test.minuteOfDay().getAsText(Locale.FRENCH));\n         assertSame(test.getChronology().secondOfMinute(), test.secondOfMinute().getField());\n         assertEquals(\"secondOfMinute\", test.secondOfMinute().getName());\n         assertEquals(\"Property[secondOfMinute]\", test.secondOfMinute().toString());\n-        assertSame(test, test.secondOfMinute().getReadableInstant());\n         assertEquals(43, test.secondOfMinute().get());\n         assertEquals(\"43\", test.secondOfMinute().getAsText());\n         assertEquals(\"43\", test.secondOfMinute().getAsText(Locale.FRENCH));\n         assertSame(test.getChronology().secondOfDay(), test.secondOfDay().getField());\n         assertEquals(\"secondOfDay\", test.secondOfDay().getName());\n         assertEquals(\"Property[secondOfDay]\", test.secondOfDay().toString());\n-        assertSame(test, test.secondOfDay().getReadableInstant());\n         assertEquals(48223, test.secondOfDay().get());\n         assertEquals(\"48223\", test.secondOfDay().getAsText());\n         assertEquals(\"48223\", test.secondOfDay().getAsText(Locale.FRENCH));\n         assertSame(test.getChronology().millisOfSecond(), test.millisOfSecond().getField());\n         assertEquals(\"millisOfSecond\", test.millisOfSecond().getName());\n         assertEquals(\"Property[millisOfSecond]\", test.millisOfSecond().toString());\n-        assertSame(test, test.millisOfSecond().getReadableInstant());\n         assertEquals(53, test.millisOfSecond().get());\n         assertEquals(\"53\", test.millisOfSecond().getAsText());\n         assertEquals(\"53\", test.millisOfSecond().getAsText(Locale.FRENCH));\n         assertSame(test.getChronology().millisOfDay(), test.millisOfDay().getField());\n         assertEquals(\"millisOfDay\", test.millisOfDay().getName());\n         assertEquals(\"Property[millisOfDay]\", test.millisOfDay().toString());\n-        assertSame(test, test.millisOfDay().getReadableInstant());\n         assertEquals(48223053, test.millisOfDay().get());\n         assertEquals(\"48223053\", test.millisOfDay().getAsText());\n         assertEquals(\"48223053\", test.millisOfDay().getAsText(Locale.FRENCH));\n--- a/JodaTime/src/test/org/joda/time/TestTimeOfDay_Basics.java\n+++ b/JodaTime/src/test/org/joda/time/TestTimeOfDay_Basics.java\n import java.io.ObjectInputStream;\n import java.io.ObjectOutputStream;\n import java.util.Arrays;\n+import java.util.Locale;\n \n import junit.framework.TestCase;\n import junit.framework.TestSuite;\n     }\n \n     //-----------------------------------------------------------------------\n-    public void testToDateTime() {\n+    public void testToDateTimeToday() {\n         TimeOfDay base = new TimeOfDay(10, 20, 30, 40, COPTIC_PARIS); // PARIS irrelevant\n         DateTime dt = new DateTime(2004, 6, 9, 6, 7, 8, 9);\n         DateTimeUtils.setCurrentMillisFixed(dt.getMillis());\n         \n-        DateTime test = base.toDateTime();\n+        DateTime test = base.toDateTimeToday();\n         check(base, 10, 20, 30, 40);\n         DateTime expected = new DateTime(dt.getMillis(), COPTIC_LONDON);\n         expected = expected.hourOfDay().setCopy(10);\n     }\n \n     //-----------------------------------------------------------------------\n-    public void testToDateTime_Zone() {\n+    public void testToDateTimeToday_Zone() {\n         TimeOfDay base = new TimeOfDay(10, 20, 30, 40, COPTIC_PARIS); // PARIS irrelevant\n         DateTime dt = new DateTime(2004, 6, 9, 6, 7, 8, 9);\n         DateTimeUtils.setCurrentMillisFixed(dt.getMillis());\n         \n-        DateTime test = base.toDateTime(TOKYO);\n+        DateTime test = base.toDateTimeToday(TOKYO);\n         check(base, 10, 20, 30, 40);\n         DateTime expected = new DateTime(dt.getMillis(), COPTIC_TOKYO);\n         expected = expected.hourOfDay().setCopy(10);\n         assertEquals(expected, test);\n     }\n \n-    public void testToDateTime_nullZone() {\n+    public void testToDateTimeToday_nullZone() {\n         TimeOfDay base = new TimeOfDay(10, 20, 30, 40, COPTIC_PARIS); // PARIS irrelevant\n         DateTime dt = new DateTime(2004, 6, 9, 6, 7, 8, 9);\n         DateTimeUtils.setCurrentMillisFixed(dt.getMillis());\n         \n-        DateTime test = base.toDateTime((DateTimeZone) null);\n+        DateTime test = base.toDateTimeToday((DateTimeZone) null);\n         check(base, 10, 20, 30, 40);\n         DateTime expected = new DateTime(dt.getMillis(), COPTIC_LONDON);\n         expected = expected.hourOfDay().setCopy(10);\n     }\n \n     //-----------------------------------------------------------------------\n+    public void testToString_String() {\n+        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);\n+        assertEquals(\" 10\", test.toString(\"yyyy HH\"));\n+        assertEquals(\"T10:20:30.040\", test.toString(null));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testToString_String_Locale() {\n+        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);\n+        assertEquals(\"10 20\", test.toString(\"H m\", Locale.ENGLISH));\n+        assertEquals(\"T10:20:30.040\", test.toString(null, Locale.ENGLISH));\n+        assertEquals(\"10 20\", test.toString(\"H m\", null));\n+        assertEquals(\"T10:20:30.040\", test.toString(null, null));\n+    }\n+\n+    //-----------------------------------------------------------------------\n     private void check(TimeOfDay test, int hour, int min, int sec, int milli) {\n         assertEquals(hour, test.getHourOfDay());\n         assertEquals(min, test.getMinuteOfHour());\n--- a/JodaTime/src/test/org/joda/time/TestYearMonthDay_Basics.java\n+++ b/JodaTime/src/test/org/joda/time/TestYearMonthDay_Basics.java\n import java.io.ObjectInputStream;\n import java.io.ObjectOutputStream;\n import java.util.Arrays;\n+import java.util.Locale;\n \n import junit.framework.TestCase;\n import junit.framework.TestSuite;\n     }\n \n     //-----------------------------------------------------------------------\n-    public void testToDateTime() {\n+    public void testToDateTimeAtMidnight() {\n+        YearMonthDay base = new YearMonthDay(2005, 6, 9, COPTIC_PARIS);\n+        \n+        DateTime test = base.toDateTimeAtMidnight();\n+        check(base, 2005, 6, 9);\n+        assertEquals(new DateTime(2005, 6, 9, 0, 0, 0, 0, COPTIC_LONDON), test);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testToDateTimeAtMidnight_Zone() {\n+        YearMonthDay base = new YearMonthDay(2005, 6, 9, COPTIC_PARIS);\n+        \n+        DateTime test = base.toDateTimeAtMidnight(TOKYO);\n+        check(base, 2005, 6, 9);\n+        assertEquals(new DateTime(2005, 6, 9, 0, 0, 0, 0, COPTIC_TOKYO), test);\n+    }\n+\n+    public void testToDateTimeAtMidnight_nullZone() {\n+        YearMonthDay base = new YearMonthDay(2005, 6, 9, COPTIC_PARIS);\n+        \n+        DateTime test = base.toDateTimeAtMidnight((DateTimeZone) null);\n+        check(base, 2005, 6, 9);\n+        assertEquals(new DateTime(2005, 6, 9, 0, 0, 0, 0, COPTIC_LONDON), test);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testToDateTimeAtCurrentTime() {\n         YearMonthDay base = new YearMonthDay(2005, 6, 9, COPTIC_PARIS); // PARIS irrelevant\n         DateTime dt = new DateTime(2004, 6, 9, 6, 7, 8, 9);\n         DateTimeUtils.setCurrentMillisFixed(dt.getMillis());\n         \n-        DateTime test = base.toDateTime();\n+        DateTime test = base.toDateTimeAtCurrentTime();\n         check(base, 2005, 6, 9);\n         DateTime expected = new DateTime(dt.getMillis(), COPTIC_LONDON);\n         expected = expected.year().setCopy(2005);\n     }\n \n     //-----------------------------------------------------------------------\n-    public void testToDateTime_Zone() {\n+    public void testToDateTimeAtCurrentTime_Zone() {\n         YearMonthDay base = new YearMonthDay(2005, 6, 9, COPTIC_PARIS); // PARIS irrelevant\n         DateTime dt = new DateTime(2004, 6, 9, 6, 7, 8, 9);\n         DateTimeUtils.setCurrentMillisFixed(dt.getMillis());\n         \n-        DateTime test = base.toDateTime(TOKYO);\n+        DateTime test = base.toDateTimeAtCurrentTime(TOKYO);\n         check(base, 2005, 6, 9);\n         DateTime expected = new DateTime(dt.getMillis(), COPTIC_TOKYO);\n         expected = expected.year().setCopy(2005);\n         assertEquals(expected, test);\n     }\n \n-    public void testToDateTime_nullZone() {\n+    public void testToDateTimeAtCurrentTime_nullZone() {\n         YearMonthDay base = new YearMonthDay(2005, 6, 9, COPTIC_PARIS); // PARIS irrelevant\n         DateTime dt = new DateTime(2004, 6, 9, 6, 7, 8, 9);\n         DateTimeUtils.setCurrentMillisFixed(dt.getMillis());\n         \n-        DateTime test = base.toDateTime((DateTimeZone) null);\n+        DateTime test = base.toDateTimeAtCurrentTime((DateTimeZone) null);\n         check(base, 2005, 6, 9);\n         DateTime expected = new DateTime(dt.getMillis(), COPTIC_LONDON);\n         expected = expected.year().setCopy(2005);\n \n     //-----------------------------------------------------------------------\n     public void testToString() {\n-        YearMonthDay test = new YearMonthDay(1972, 6, 9);\n-        assertEquals(\"1972-06-09\", test.toString());\n+        YearMonthDay test = new YearMonthDay(2002, 6, 9);\n+        assertEquals(\"2002-06-09\", test.toString());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testToString_String() {\n+        YearMonthDay test = new YearMonthDay(2002, 6, 9);\n+        assertEquals(\"2002 \", test.toString(\"yyyy HH\"));\n+        assertEquals(\"2002-06-09\", test.toString(null));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testToString_String_Locale() {\n+        YearMonthDay test = new YearMonthDay(2002, 6, 9);\n+        assertEquals(\"Sun 9/6\", test.toString(\"EEE d/M\", Locale.ENGLISH));\n+        assertEquals(\"dim. 9/6\", test.toString(\"EEE d/M\", Locale.FRENCH));\n+        assertEquals(\"2002-06-09\", test.toString(null, Locale.ENGLISH));\n+        assertEquals(\"Sun 9/6\", test.toString(\"EEE d/M\", null));\n+        assertEquals(\"2002-06-09\", test.toString(null, null));\n     }\n \n     //-----------------------------------------------------------------------", "timestamp": 1106498405, "metainfo": ""}