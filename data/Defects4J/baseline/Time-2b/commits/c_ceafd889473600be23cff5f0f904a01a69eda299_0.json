{"sha": "ceafd889473600be23cff5f0f904a01a69eda299", "log": "Add Ethipoic Chronology   ", "commit": "\n--- a/JodaTime/src/java/org/joda/time/ChronologyType.java\n+++ b/JodaTime/src/java/org/joda/time/ChronologyType.java\n \n import org.joda.time.chrono.BuddhistChronology;\n import org.joda.time.chrono.CopticChronology;\n+import org.joda.time.chrono.EthiopicChronology;\n import org.joda.time.chrono.GJChronology;\n import org.joda.time.chrono.GregorianChronology;\n import org.joda.time.chrono.ISOChronology;\n  * <li>Julian - The Julian calendar system used for all time (proleptic)\n  * <li>Buddhist - The Buddhist calendar system which is an offset in years from GJ\n  * <li>Coptic - The Coptic calendar system which defines 30 day months\n+ * <li>Ethiopic - The Ethiopic calendar system which defines 30 day months\n  * </ul>\n  * Hopefully future releases will contain more chronologies.\n  *\n  * @see org.joda.time.chrono.GJChronology\n  * @see org.joda.time.chrono.GregorianChronology\n  * @see org.joda.time.chrono.JulianChronology\n+ * @see org.joda.time.chrono.BuddhistChronology\n  * @see org.joda.time.chrono.CopticChronology\n- * @see org.joda.time.chrono.BuddhistChronology\n+ * @see org.joda.time.chrono.EthiopicChronology\n  *\n  * @author Stephen Colebourne\n  * @since 1.2\n         GREGORIAN = 3,\n         JULIAN = 4,\n         BUDDHIST = 5,\n-        COPTIC = 6;\n+        COPTIC = 6,\n+        ETHIOPIC = 7;\n \n     /** The iso chronology type. */\n     private static final ChronologyType ISO_TYPE = new StandardChronologyType(\"ISO\", ISO);\n     private static final ChronologyType BUDDHIST_TYPE = new StandardChronologyType(\"Buddhist\", BUDDHIST);\n     /** The iso chronology type. */\n     private static final ChronologyType COPTIC_TYPE = new StandardChronologyType(\"Coptic\", COPTIC);\n+    /** The iso chronology type. */\n+    private static final ChronologyType ETHIOPIC_TYPE = new StandardChronologyType(\"Ethiopic\", ETHIOPIC);\n \n     /** The id of the field. */\n     private final String iID;\n      */\n     public static ChronologyType coptic() {\n         return COPTIC_TYPE;\n+    }\n+\n+    /**\n+     * Get the Ethiopic chronology type.\n+     * <p>\n+     * {@link EthiopicChronology} defines fields sensibly for the Ethiopic calendar system.\n+     * The Ethiopic calendar system defines every fourth year as leap.\n+     * The year is broken down into 12 months, each 30 days in length.\n+     * An extra period at the end of the year is either 5 or 6 days in length\n+     * and is returned as a 13th month.\n+     * Year 1 in the Coptic calendar began on August 29, 8 CE (Julian).\n+     * The chronology cannot be used before the first Ethiopic year.\n+     *\n+     * @return the ChronologyType constant\n+     */\n+    public static ChronologyType ethiopic() {\n+        return ETHIOPIC_TYPE;\n     }\n \n     //-----------------------------------------------------------------------\n                     return BuddhistChronology.getInstance(zone);\n                 case COPTIC:\n                     return CopticChronology.getInstance(zone);\n+                case ETHIOPIC:\n+                    return EthiopicChronology.getInstance(zone);\n                 default:\n                     // Shouldn't happen.\n                     throw new InternalError();\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/chrono/BasicFixedMonthOfYearDateTimeField.java\n+/*\n+ *  Copyright 2001-2005 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time.chrono;\n+\n+import org.joda.time.DateTimeConstants;\n+import org.joda.time.DateTimeFieldType;\n+import org.joda.time.DurationField;\n+import org.joda.time.field.PreciseDurationDateTimeField;\n+\n+/**\n+ * Month of year implementation where the month length is fixed.\n+ *\n+ * @author Brian S O'Neill\n+ * @author Stephen Colebourne\n+ * @since 1.2, refactored from CopticMonthOfYearDateTimeField\n+ */\n+final class BasicFixedMonthOfYearDateTimeField extends PreciseDurationDateTimeField {\n+\n+    /** Serialization version. */\n+    private static final long serialVersionUID = 7741038885247700323L;\n+\n+    /** The base chronology. */\n+    private final BaseGJChronology iChronology;\n+\n+    /** The fixed month length. */\n+    private static final int MONTH_LENGTH = 30;\n+\n+    /**\n+     * Restricted constructor.\n+     *\n+     * @param chronology  the base chronology\n+     * @param months  the months duration field\n+     */\n+    BasicFixedMonthOfYearDateTimeField(BaseGJChronology chronology, DurationField months) {\n+        super(DateTimeFieldType.monthOfYear(), months);\n+        iChronology = chronology;\n+    }\n+\n+    public int get(long instant) {\n+        return (iChronology.getDayOfYear(instant) - 1) / MONTH_LENGTH + 1;\n+    }\n+\n+    public long set(long instant, int value) {\n+        instant = super.set(instant, value);\n+        if (value == 13) {\n+            int day = iChronology.getDayOfYear(instant);\n+            if (day < MONTH_LENGTH) {\n+                // Move back a few days to the end of the 13th \"month\".\n+                instant -= (long)DateTimeConstants.MILLIS_PER_DAY * day;\n+            }\n+        }\n+        return instant;\n+    }\n+\n+    public DurationField getRangeDurationField() {\n+        return iChronology.years();\n+    }\n+\n+    public boolean isLeap(long instant) {\n+        return get(instant) > 12 && iChronology.isLeapYear(iChronology.getYear(instant));\n+    }\n+\n+    public int getLeapAmount(long instant) {\n+        return isLeap(instant) ? 1 : 0;\n+    }\n+\n+    public DurationField getLeapDurationField() {\n+        return iChronology.days();\n+    }\n+\n+    public int getMinimumValue() {\n+        return 1;\n+    }\n+\n+    public int getMaximumValue() {\n+        return 13;\n+    }\n+\n+    /**\n+     * Serialization singleton\n+     */\n+    private Object readResolve() {\n+        return iChronology.monthOfYear();\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/chrono/CommonFixedMonthChronology.java\n+/*\n+ *  Copyright 2001-2005 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time.chrono;\n+\n+import org.joda.time.Chronology;\n+import org.joda.time.DateTimeConstants;\n+import org.joda.time.DateTimeFieldType;\n+import org.joda.time.DurationField;\n+import org.joda.time.DurationFieldType;\n+import org.joda.time.field.FieldUtils;\n+import org.joda.time.field.PreciseDurationField;\n+\n+/**\n+ * Abstract implementation of a calendar system based around fixed length months.\n+ * <p>\n+ * As the month length is fixed various calculations can be optimised.\n+ * This implementation assumes any additional days after twelve\n+ * months fall into a thirteenth month.\n+ * <p>\n+ * CommonFixedMonthChronology is thread-safe and immutable, and all\n+ * subclasses must be as well.\n+ *\n+ * @author Brian S O'Neill\n+ * @author Stephen Colebourne\n+ * @since 1.2, refactored from CopticChronology\n+ */\n+public abstract class CommonFixedMonthChronology extends BaseGJChronology {\n+\n+    /** Serialization lock */\n+    private static final long serialVersionUID = 261387371998L;\n+\n+    /** The length of the month. */\n+    static final int MONTH_LENGTH = 30;\n+\n+    /** The typical millis per year. */\n+    static final long MILLIS_PER_YEAR =\n+        (long) (365.25 * DateTimeConstants.MILLIS_PER_DAY);\n+\n+    /** The length of the month in millis. */\n+    static final long MILLIS_PER_MONTH = ((long) MONTH_LENGTH) * DateTimeConstants.MILLIS_PER_DAY;\n+\n+    /** Singleton fixed length month field used to build the monthOfYear field. */\n+    static final DurationField MONTH_DURATION_FIELD;\n+    static {\n+        // init after other static fields\n+        MONTH_DURATION_FIELD =  new PreciseDurationField\n+            (DurationFieldType.months(), MILLIS_PER_MONTH);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Restricted constructor.\n+     *\n+     * @param base  the base chronology\n+     * @param param  the init parameter\n+     * @param minDaysInFirstWeek  the minimum days in the first week\n+     */\n+    CommonFixedMonthChronology(Chronology base, Object param, int minDaysInFirstWeek) {\n+        super(base, param, minDaysInFirstWeek);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    long setYear(long instant, int year) {\n+        // optimsed implementation of set, due to fixed months\n+        int thisYear = getYear(instant);\n+        int dayOfYear = getDayOfYear(instant, thisYear);\n+        int millisOfDay = getMillisOfDay(instant);\n+\n+        if (dayOfYear > 365) {\n+            // Current year is leap, and day is leap.\n+            if (!isLeapYear(year)) {\n+                // Moving to a non-leap year, leap day doesn't exist.\n+                dayOfYear--;\n+            }\n+        }\n+\n+        instant = getYearMonthDayMillis(year, 1, dayOfYear);\n+        instant += millisOfDay;\n+        return instant;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    long getYearDifference(long minuendInstant, long subtrahendInstant) {\n+        // optimsed implementation of getDifference, due to fixed months\n+        int minuendYear = getYear(minuendInstant);\n+        int subtrahendYear = getYear(subtrahendInstant);\n+\n+        // Inlined remainder method to avoid duplicate calls to get.\n+        long minuendRem = minuendInstant - getYearMillis(minuendYear);\n+        long subtrahendRem = subtrahendInstant - getYearMillis(subtrahendYear);\n+\n+        int difference = minuendYear - subtrahendYear;\n+        if (minuendRem < subtrahendRem) {\n+            difference--;\n+        }\n+        return difference;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    long getDateMidnightMillis(int year, int monthOfYear, int dayOfMonth) {\n+        FieldUtils.verifyValueBounds(DateTimeFieldType.year(), year, getMinYear(), getMaxYear());\n+        FieldUtils.verifyValueBounds(DateTimeFieldType.monthOfYear(), monthOfYear, 1, 13);\n+        FieldUtils.verifyValueBounds(DateTimeFieldType.dayOfMonth(), dayOfMonth, 1, getDaysInYearMonth(year, monthOfYear));\n+        return getYearMonthDayMillis(year, monthOfYear, dayOfMonth);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    long getTotalMillisByYearMonth(int year, int month) {\n+        return (month * MILLIS_PER_MONTH);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    int getDayOfMonth(long millis) {\n+        // optimised for fixed months\n+        return (getDayOfYear(millis) - 1) % MONTH_LENGTH + 1;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    boolean isLeapYear(int year) {\n+        return (year & 3) == 3;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    int getDaysInYearMonth(int year, int month) {\n+        return (month != 13) ? MONTH_LENGTH : (isLeapYear(year) ? 6 : 5);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    int getDaysInMonthMax() {\n+        return MONTH_LENGTH;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    int getDaysInMonthMax(int month) {\n+        return (month != 13 ? MONTH_LENGTH : 6);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    int getMonthOfYear(long millis, int year) {\n+        long monthZeroBased = (millis - getYearMillis(year)) / MILLIS_PER_MONTH;\n+        return ((int) monthZeroBased) + 1;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    long getAverageMillisPerYear() {\n+        return MILLIS_PER_YEAR;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    long getAverageMillisPerMonth() {\n+        return MILLIS_PER_MONTH;\n+    }\n+\n+}\n--- a/JodaTime/src/java/org/joda/time/chrono/CopticChronology.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/CopticChronology.java\n import org.joda.time.DateTime;\n import org.joda.time.DateTimeConstants;\n import org.joda.time.DateTimeField;\n-import org.joda.time.DateTimeFieldType;\n import org.joda.time.DateTimeZone;\n-import org.joda.time.DurationField;\n-import org.joda.time.DurationFieldType;\n-import org.joda.time.field.FieldUtils;\n-import org.joda.time.field.PreciseDurationField;\n import org.joda.time.field.SkipDateTimeField;\n \n /**\n  * @author Brian S O'Neill\n  * @since 1.0\n  */\n-public final class CopticChronology extends BaseGJChronology {\n+public final class CopticChronology extends CommonFixedMonthChronology {\n \n     /** Serialization lock */\n     private static final long serialVersionUID = -5972804258688333942L;\n \n     /** A singleton era field. */\n     private static final DateTimeField ERA_FIELD = new BasicSingleEraDateTimeField(\"AM\");\n-\n-    private static final long MILLIS_PER_YEAR =\n-        (long) (365.25 * DateTimeConstants.MILLIS_PER_DAY);\n-\n-    private static final long MILLIS_PER_MONTH =\n-        (long) (365.25 * DateTimeConstants.MILLIS_PER_DAY / 12);\n \n     /** The lowest year that can be fully supported. */\n     private static final int MIN_YEAR = -292269337;\n      */\n     private static final int MAX_YEAR = 292271022;\n \n-    /** Singleton 30 day month field used to build the monthOfYear field. */\n-    private static final DurationField cMonthsField;\n+    /** Cache of zone to chronology arrays */\n+    private static final Map cCache = new HashMap();\n \n     /** Singleton instance of a UTC CopticChronology */\n     private static final CopticChronology INSTANCE_UTC;\n-\n-    /** Cache of zone to chronology arrays */\n-    private static final Map cCache = new HashMap();\n-\n     static {\n-        cMonthsField =  new PreciseDurationField\n-            (DurationFieldType.months(), 30L * DateTimeConstants.MILLIS_PER_DAY);\n+        // init after static fields\n         INSTANCE_UTC = getInstance(DateTimeZone.UTC);\n     }\n \n+    //-----------------------------------------------------------------------\n     /**\n      * Gets an instance of the CopticChronology.\n      * The time zone of the returned instance is UTC.\n \n     // Constructors and instance variables\n     //-----------------------------------------------------------------------\n-\n-    /**\n-     * Restricted constructor\n+    /**\n+     * Restricted constructor.\n      */\n     CopticChronology(Chronology base, Object param, int minDaysInFirstWeek) {\n         super(base, param, minDaysInFirstWeek);\n     }\n \n     /**\n-     * Serialization singleton\n+     * Serialization singleton.\n      */\n     private Object readResolve() {\n         Chronology base = getBase();\n         return getInstance(zone);\n     }\n \n-    //-----------------------------------------------------------------------\n-    long setYear(long instant, int year) {\n-        // optimsed implementation of set, due to 30 day months\n-        int thisYear = getYear(instant);\n-        int dayOfYear = getDayOfYear(instant, thisYear);\n-        int millisOfDay = getMillisOfDay(instant);\n-\n-        if (dayOfYear > 365) {\n-            // Current year is leap, and day is leap.\n-            if (!isLeapYear(year)) {\n-                // Moving to a non-leap year, leap day doesn't exist.\n-                dayOfYear--;\n-            }\n-        }\n-\n-        instant = getYearMonthDayMillis(year, 1, dayOfYear);\n-        instant += millisOfDay;\n-        return instant;\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    long getYearDifference(long minuendInstant, long subtrahendInstant) {\n-        // optimsed implementation of getDifference, due to 30 day months\n-        int minuendYear = getYear(minuendInstant);\n-        int subtrahendYear = getYear(subtrahendInstant);\n-\n-        // Inlined remainder method to avoid duplicate calls to get.\n-        long minuendRem = minuendInstant - getYearMillis(minuendYear);\n-        long subtrahendRem = subtrahendInstant - getYearMillis(subtrahendYear);\n-\n-        int difference = minuendYear - subtrahendYear;\n-        if (minuendRem < subtrahendRem) {\n-            difference--;\n-        }\n-        return difference;\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    long getDateMidnightMillis(int year, int monthOfYear, int dayOfMonth) {\n-        FieldUtils.verifyValueBounds(DateTimeFieldType.year(), year, getMinYear(), getMaxYear());\n-        FieldUtils.verifyValueBounds(DateTimeFieldType.monthOfYear(), monthOfYear, 1, 13);\n-        FieldUtils.verifyValueBounds(DateTimeFieldType.dayOfMonth(), dayOfMonth, 1, getDaysInYearMonth(year, monthOfYear));\n-        return getYearMonthDayMillis(year, monthOfYear, dayOfMonth);\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    long getTotalMillisByYearMonth(int year, int month) {\n-        return (month * 30L * DateTimeConstants.MILLIS_PER_DAY);\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    int getDayOfMonth(long millis) {\n-        // optimised for 30 day months\n-        return (getDayOfYear(millis) - 1) % 30 + 1;\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    boolean isLeapYear(int year) {\n-        return (year & 3) == 3;\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    int getDaysInYearMonth(int year, int month) {\n-        return (month != 13) ? 30 : (isLeapYear(year) ? 6 : 5);\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    int getDaysInMonthMax() {\n-        return 30;\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    int getDaysInMonthMax(int month) {\n-        return (month != 13 ? 30 : 6);\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    int getMonthOfYear(long millis, int year) {\n-        return ((int) ((millis - getYearMillis(year))\n-                       / (30L * DateTimeConstants.MILLIS_PER_DAY))) + 1;\n-    }\n-    \n     //-----------------------------------------------------------------------\n     long calculateFirstDayOfYearMillis(int year) {\n         if (year > MAX_YEAR) {\n     }\n \n     //-----------------------------------------------------------------------\n-    long getAverageMillisPerYear() {\n-        return MILLIS_PER_YEAR;\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    long getAverageMillisPerMonth() {\n-        return MILLIS_PER_MONTH;\n-    }\n-\n-    //-----------------------------------------------------------------------\n     long getApproxMillisAtEpoch() {\n         return 1686L * MILLIS_PER_YEAR + 112L * DateTimeConstants.MILLIS_PER_DAY;\n     }\n             fields.weekyear = new SkipDateTimeField(this, fields.weekyear);\n             \n             fields.era = ERA_FIELD;\n-            fields.months = cMonthsField;\n-            fields.monthOfYear = new CopticMonthOfYearDateTimeField(this, cMonthsField);\n+            fields.months = MONTH_DURATION_FIELD;\n+            fields.monthOfYear = new BasicFixedMonthOfYearDateTimeField(this, MONTH_DURATION_FIELD);\n             fields.dayOfMonth = new BasicDayOfMonthDateTimeField(this, fields.days);\n         }\n     }\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/chrono/EthiopicChronology.java\n+/*\n+ *  Copyright 2001-2005 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time.chrono;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.joda.time.Chronology;\n+import org.joda.time.ChronologyType;\n+import org.joda.time.DateTime;\n+import org.joda.time.DateTimeConstants;\n+import org.joda.time.DateTimeField;\n+import org.joda.time.DateTimeZone;\n+import org.joda.time.field.SkipDateTimeField;\n+\n+/**\n+ * Implements the Ethiopic calendar system, which defines every fourth year as\n+ * leap, much like the Julian calendar. The year is broken down into 12 months,\n+ * each 30 days in length. An extra period at the end of the year is either 5\n+ * or 6 days in length. In this implementation, it is considered a 13th month.\n+ * <p>\n+ * Year 1 in the Ethiopic calendar began on August 29, 8 CE (Julian), thus\n+ * Ethiopic years do not begin at the same time as Julian years. This chronology\n+ * is not proleptic, as it does not allow dates before the first Ethiopic year.\n+ * <p>\n+ * This implementation defines a day as midnight to midnight exactly as per\n+ * the ISO chronology. Some references indicate that a coptic day starts at\n+ * sunset on the previous ISO day, but this has not been confirmed and is not\n+ * implemented.\n+ * <p>\n+ * EthiopicChronology is thread-safe and immutable.\n+ *\n+ * @see <a href=\"http://en.wikipedia.org/wiki/Ethiopian_calendar\">Wikipedia</a>\n+ *\n+ * @author Brian S O'Neill\n+ * @author Stephen Colebourne\n+ * @since 1.2\n+ */\n+public final class EthiopicChronology extends CommonFixedMonthChronology {\n+\n+    /** Serialization lock */\n+    private static final long serialVersionUID = -5972804258688333942L;\n+\n+    /**\n+     * Constant value for 'Ethiopean Era', equivalent\n+     * to the value returned for AD/CE.\n+     */\n+    public static final int EE = DateTimeConstants.CE;\n+\n+    /** A singleton era field. */\n+    private static final DateTimeField ERA_FIELD = new BasicSingleEraDateTimeField(\"EE\");\n+\n+    /** The lowest year that can be fully supported. */\n+    private static final int MIN_YEAR = -292269337;\n+\n+    /**\n+     * The highest year that can be fully supported.\n+     * Although calculateFirstDayOfYearMillis can go higher without\n+     * overflowing, the getYear method overflows when it adds the\n+     * approximate millis at the epoch.\n+     */\n+    private static final int MAX_YEAR = 292271022;\n+\n+    /** Cache of zone to chronology arrays */\n+    private static final Map cCache = new HashMap();\n+\n+    /** Singleton instance of a UTC EthiopicChronology */\n+    private static final EthiopicChronology INSTANCE_UTC;\n+    static {\n+        // init after static fields\n+        INSTANCE_UTC = getInstance(DateTimeZone.UTC);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets an instance of the EthiopicChronology.\n+     * The time zone of the returned instance is UTC.\n+     * \n+     * @return a singleton UTC instance of the chronology\n+     */\n+    public static EthiopicChronology getInstanceUTC() {\n+        return INSTANCE_UTC;\n+    }\n+\n+    /**\n+     * Gets an instance of the EthiopicChronology in the default time zone.\n+     * \n+     * @return a chronology in the default time zone\n+     */\n+    public static EthiopicChronology getInstance() {\n+        return getInstance(DateTimeZone.getDefault(), 4);\n+    }\n+\n+    /**\n+     * Gets an instance of the EthiopicChronology in the given time zone.\n+     * \n+     * @param zone  the time zone to get the chronology in, null is default\n+     * @return a chronology in the specified time zone\n+     */\n+    public static EthiopicChronology getInstance(DateTimeZone zone) {\n+        return getInstance(zone, 4);\n+    }\n+\n+    /**\n+     * Gets an instance of the EthiopicChronology in the given time zone.\n+     * \n+     * @param zone  the time zone to get the chronology in, null is default\n+     * @param minDaysInFirstWeek  minimum number of days in first week of the year; default is 4\n+     * @return a chronology in the specified time zone\n+     */\n+    public static EthiopicChronology getInstance(DateTimeZone zone, int minDaysInFirstWeek) {\n+        if (zone == null) {\n+            zone = DateTimeZone.getDefault();\n+        }\n+        EthiopicChronology chrono;\n+        synchronized (cCache) {\n+            EthiopicChronology[] chronos = (EthiopicChronology[]) cCache.get(zone);\n+            if (chronos == null) {\n+                chronos = new EthiopicChronology[7];\n+                cCache.put(zone, chronos);\n+            }\n+            try {\n+                chrono = chronos[minDaysInFirstWeek - 1];\n+            } catch (ArrayIndexOutOfBoundsException e) {\n+                throw new IllegalArgumentException\n+                    (\"Invalid min days in first week: \" + minDaysInFirstWeek);\n+            }\n+            if (chrono == null) {\n+                if (zone == DateTimeZone.UTC) {\n+                    // First create without a lower limit.\n+                    chrono = new EthiopicChronology(null, null, minDaysInFirstWeek);\n+                    // Impose lower limit and make another EthiopicChronology.\n+                    DateTime lowerLimit = new DateTime(1, 1, 1, 0, 0, 0, 0, chrono);\n+                    chrono = new EthiopicChronology\n+                        (LimitChronology.getInstance(chrono, lowerLimit, null),\n+                         null, minDaysInFirstWeek);\n+                } else {\n+                    chrono = getInstance(DateTimeZone.UTC, minDaysInFirstWeek);\n+                    chrono = new EthiopicChronology\n+                        (ZonedChronology.getInstance(chrono, zone), null, minDaysInFirstWeek);\n+                }\n+                chronos[minDaysInFirstWeek - 1] = chrono;\n+            }\n+        }\n+        return chrono;\n+    }\n+\n+    // Constructors and instance variables\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Restricted constructor.\n+     */\n+    EthiopicChronology(Chronology base, Object param, int minDaysInFirstWeek) {\n+        super(base, param, minDaysInFirstWeek);\n+    }\n+\n+    /**\n+     * Serialization singleton.\n+     */\n+    private Object readResolve() {\n+        Chronology base = getBase();\n+        return base == null ? getInstanceUTC() : getInstance(base.getZone());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns the ChronologyType constant for this Chronology.\n+     *\n+     * @return the chronology type\n+     */\n+    public ChronologyType getType() {\n+        return ChronologyType.ethiopic();\n+    }\n+\n+    // Conversion\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the Chronology in the UTC time zone.\n+     * \n+     * @return the chronology in UTC\n+     */\n+    public Chronology withUTC() {\n+        return INSTANCE_UTC;\n+    }\n+\n+    /**\n+     * Gets the Chronology in a specific time zone.\n+     * \n+     * @param zone  the zone to get the chronology in, null is default\n+     * @return the chronology\n+     */\n+    public Chronology withZone(DateTimeZone zone) {\n+        if (zone == null) {\n+            zone = DateTimeZone.getDefault();\n+        }\n+        if (zone == getZone()) {\n+            return this;\n+        }\n+        return getInstance(zone);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    long calculateFirstDayOfYearMillis(int year) {\n+        if (year > MAX_YEAR) {\n+            throw new ArithmeticException(\"Year is too large: \" + year + \" > \" + MAX_YEAR);\n+        }\n+        if (year < MIN_YEAR) {\n+            throw new ArithmeticException(\"Year is too small: \" + year + \" < \" + MIN_YEAR);\n+        }\n+\n+        // Java epoch is 1970-01-01 Gregorian which is 1962-04-23 Ethiopic.\n+        // Calculate relative to the nearest leap year and account for the\n+        // difference later.\n+\n+        int relativeYear = year - 1963;\n+        int leapYears;\n+        if (relativeYear <= 0) {\n+            // Add 3 before shifting right since /4 and >>2 behave differently\n+            // on negative numbers.\n+            leapYears = (relativeYear + 3) >> 2;\n+        } else {\n+            leapYears = relativeYear >> 2;\n+            // For post 1963 an adjustment is needed as jan1st is before leap day\n+            if (!isLeapYear(year)) {\n+                leapYears++;\n+            }\n+        }\n+        \n+        long millis = (relativeYear * 365L + leapYears)\n+            * (long)DateTimeConstants.MILLIS_PER_DAY;\n+\n+        // Adjust to account for difference between 1963-01-01 and 1962-04-23.\n+\n+        return millis + (365L - 112) * DateTimeConstants.MILLIS_PER_DAY;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    int getMinYear() {\n+        return MIN_YEAR;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    int getMaxYear() {\n+        return MAX_YEAR;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    long getApproxMillisAtEpoch() {\n+        return 1962L * MILLIS_PER_YEAR + 112L * DateTimeConstants.MILLIS_PER_DAY;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    protected void assemble(Fields fields) {\n+        if (getBase() == null) {\n+            super.assemble(fields);\n+\n+            // Ethiopic, like Julian, has no year zero.\n+            fields.year = new SkipDateTimeField(this, fields.year);\n+            fields.weekyear = new SkipDateTimeField(this, fields.weekyear);\n+            \n+            fields.era = ERA_FIELD;\n+            fields.months = MONTH_DURATION_FIELD;\n+            fields.monthOfYear = new BasicFixedMonthOfYearDateTimeField(this, MONTH_DURATION_FIELD);\n+            fields.dayOfMonth = new BasicDayOfMonthDateTimeField(this, fields.days);\n+        }\n+    }\n+\n+}\n--- a/JodaTime/src/test/org/joda/time/TestChronologyType.java\n+++ b/JodaTime/src/test/org/joda/time/TestChronologyType.java\n \n import org.joda.time.chrono.BuddhistChronology;\n import org.joda.time.chrono.CopticChronology;\n+import org.joda.time.chrono.EthiopicChronology;\n import org.joda.time.chrono.GJChronology;\n import org.joda.time.chrono.GregorianChronology;\n import org.joda.time.chrono.ISOChronology;\n     //-----------------------------------------------------------------------\n     public void test_getAvailableIDs() throws Exception {\n         Set set = ChronologyType.getAvailableIDs();\n-        assertEquals(6, set.size());\n+        assertEquals(7, set.size());\n         assertEquals(true, set.contains(\"ISO\"));\n         assertEquals(true, set.contains(\"GJ\"));\n         assertEquals(true, set.contains(\"Gregorian\"));\n         assertEquals(true, set.contains(\"Julian\"));\n         assertEquals(true, set.contains(\"Buddhist\"));\n         assertEquals(true, set.contains(\"Coptic\"));\n+        assertEquals(true, set.contains(\"Ethiopic\"));\n     }\n \n     //-----------------------------------------------------------------------\n         assertSerialization(ChronologyType.coptic());\n     }\n \n+    public void test_ethiopic() throws Exception {\n+        assertEquals(ChronologyType.ethiopic(), ChronologyType.ethiopic());\n+        assertEquals(\"Ethiopic\", ChronologyType.ethiopic().getID());\n+        assertEquals(EthiopicChronology.getInstance(), ChronologyType.ethiopic().getChronology());\n+        assertEquals(EthiopicChronology.getInstanceUTC(), ChronologyType.ethiopic().getChronologyUTC());\n+        assertEquals(EthiopicChronology.getInstance(PARIS), ChronologyType.ethiopic().getChronology(PARIS));\n+        assertEquals(\"Ethiopic\", ChronologyType.ethiopic().toString());\n+        assertSerialization(ChronologyType.ethiopic());\n+    }\n+\n     public void test_other() throws Exception {\n         assertEquals(1, ChronologyType.class.getDeclaredClasses().length);\n         Class cls = ChronologyType.class.getDeclaredClasses()[0];\n--- a/JodaTime/src/test/org/joda/time/chrono/TestAll.java\n+++ b/JodaTime/src/test/org/joda/time/chrono/TestAll.java\n  */\n public class TestAll extends TestCase {\n \n-    public static boolean FAST = true;\n+    public static boolean FAST = false;\n \n     public TestAll(String testName) {\n         super(testName);\n         \n         suite.addTest(TestBuddhistChronology.suite());\n         suite.addTest(TestCopticChronology.suite());\n+        suite.addTest(TestEthiopicChronology.suite());\n         suite.addTest(TestGJChronology.suite());\n         suite.addTest(TestGregorianChronology.suite());\n         suite.addTest(TestJulianChronology.suite());\n--- a/JodaTime/src/test/org/joda/time/chrono/TestCopticChronology.java\n+++ b/JodaTime/src/test/org/joda/time/chrono/TestCopticChronology.java\n  */\n public class TestCopticChronology extends TestCase {\n \n-    private static int SKIP = 1 * DateTimeConstants.MILLIS_PER_DAY;\n+    private static long SKIP = 1 * DateTimeConstants.MILLIS_PER_DAY;\n \n     private static final DateTimeZone PARIS = DateTimeZone.forID(\"Europe/Paris\");\n     private static final DateTimeZone LONDON = DateTimeZone.forID(\"Europe/London\");\n         DateTimeField year = COPTIC_UTC.year();\n         DateTimeField yearOfEra = COPTIC_UTC.yearOfEra();\n         DateTimeField era = COPTIC_UTC.era();\n-        int expectedDOW = 5;\n+        int expectedDOW = new DateTime(284, 8, 29, 0, 0, 0, 0, JULIAN_UTC).getDayOfWeek();\n         int expectedDOY = 1;\n         int expectedDay = 1;\n         int expectedMonth = 1;\n             int monthValue = monthOfYear.get(millis);\n             int yearValue = year.get(millis);\n             int yearOfEraValue = yearOfEra.get(millis);\n-            int eraValue = era.get(millis);\n             int monthLen = dayOfMonth.getMaximumValue(millis);\n             if (monthValue < 1 || monthValue > 13) {\n                 fail(\"Bad month: \" + millis);\n--- /dev/null\n+++ b/JodaTime/src/test/org/joda/time/chrono/TestEthiopicChronology.java\n+/*\n+ *  Copyright 2001-2005 Stephen Colebourne\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.joda.time.chrono;\n+\n+import java.util.Locale;\n+import java.util.TimeZone;\n+\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+import org.joda.time.Chronology;\n+import org.joda.time.DateTime;\n+import org.joda.time.DateTimeConstants;\n+import org.joda.time.DateTimeField;\n+import org.joda.time.DateTimeUtils;\n+import org.joda.time.DateTimeZone;\n+\n+/**\n+ * This class is a Junit unit test for EthiopicChronology.\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class TestEthiopicChronology extends TestCase {\n+\n+    private static long SKIP = 1 * DateTimeConstants.MILLIS_PER_DAY;\n+\n+    private static final DateTimeZone PARIS = DateTimeZone.forID(\"Europe/Paris\");\n+    private static final DateTimeZone LONDON = DateTimeZone.forID(\"Europe/London\");\n+    private static final DateTimeZone TOKYO = DateTimeZone.forID(\"Asia/Tokyo\");\n+    private static final Chronology ETHIOPIC_UTC = EthiopicChronology.getInstanceUTC();\n+    private static final Chronology JULIAN_UTC = JulianChronology.getInstanceUTC();\n+    private static final Chronology ISO_UTC = ISOChronology.getInstanceUTC();\n+\n+    long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + \n+                     366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + \n+                     365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +\n+                     366 + 365;\n+    // 2002-06-09\n+    private long TEST_TIME_NOW =\n+            (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;\n+\n+    private DateTimeZone originalDateTimeZone = null;\n+    private TimeZone originalTimeZone = null;\n+    private Locale originalLocale = null;\n+\n+    public static void main(String[] args) {\n+        junit.textui.TestRunner.run(suite());\n+    }\n+\n+    public static TestSuite suite() {\n+        SKIP = 1 * DateTimeConstants.MILLIS_PER_DAY;\n+        return new TestSuite(TestEthiopicChronology.class);\n+    }\n+\n+    public TestEthiopicChronology(String name) {\n+        super(name);\n+    }\n+\n+    protected void setUp() throws Exception {\n+        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);\n+        originalDateTimeZone = DateTimeZone.getDefault();\n+        originalTimeZone = TimeZone.getDefault();\n+        originalLocale = Locale.getDefault();\n+        DateTimeZone.setDefault(LONDON);\n+        TimeZone.setDefault(TimeZone.getTimeZone(\"Europe/London\"));\n+        Locale.setDefault(Locale.UK);\n+    }\n+\n+    protected void tearDown() throws Exception {\n+        DateTimeUtils.setCurrentMillisSystem();\n+        DateTimeZone.setDefault(originalDateTimeZone);\n+        TimeZone.setDefault(originalTimeZone);\n+        Locale.setDefault(originalLocale);\n+        originalDateTimeZone = null;\n+        originalTimeZone = null;\n+        originalLocale = null;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testFactoryUTC() {\n+        assertEquals(DateTimeZone.UTC, EthiopicChronology.getInstanceUTC().getZone());\n+        assertSame(EthiopicChronology.class, EthiopicChronology.getInstanceUTC().getClass());\n+    }\n+\n+    public void testFactory() {\n+        assertEquals(LONDON, EthiopicChronology.getInstance().getZone());\n+        assertSame(EthiopicChronology.class, EthiopicChronology.getInstance().getClass());\n+    }\n+\n+    public void testFactory_Zone() {\n+        assertEquals(TOKYO, EthiopicChronology.getInstance(TOKYO).getZone());\n+        assertEquals(PARIS, EthiopicChronology.getInstance(PARIS).getZone());\n+        assertEquals(LONDON, EthiopicChronology.getInstance(null).getZone());\n+        assertSame(EthiopicChronology.class, EthiopicChronology.getInstance(TOKYO).getClass());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testEquality() {\n+        assertSame(EthiopicChronology.getInstance(TOKYO), EthiopicChronology.getInstance(TOKYO));\n+        assertSame(EthiopicChronology.getInstance(LONDON), EthiopicChronology.getInstance(LONDON));\n+        assertSame(EthiopicChronology.getInstance(PARIS), EthiopicChronology.getInstance(PARIS));\n+        assertSame(EthiopicChronology.getInstanceUTC(), EthiopicChronology.getInstanceUTC());\n+        assertSame(EthiopicChronology.getInstance(), EthiopicChronology.getInstance(LONDON));\n+    }\n+\n+    public void testWithUTC() {\n+        assertSame(EthiopicChronology.getInstanceUTC(), EthiopicChronology.getInstance(LONDON).withUTC());\n+        assertSame(EthiopicChronology.getInstanceUTC(), EthiopicChronology.getInstance(TOKYO).withUTC());\n+        assertSame(EthiopicChronology.getInstanceUTC(), EthiopicChronology.getInstanceUTC().withUTC());\n+        assertSame(EthiopicChronology.getInstanceUTC(), EthiopicChronology.getInstance().withUTC());\n+    }\n+\n+    public void testWithZone() {\n+        assertSame(EthiopicChronology.getInstance(TOKYO), EthiopicChronology.getInstance(TOKYO).withZone(TOKYO));\n+        assertSame(EthiopicChronology.getInstance(LONDON), EthiopicChronology.getInstance(TOKYO).withZone(LONDON));\n+        assertSame(EthiopicChronology.getInstance(PARIS), EthiopicChronology.getInstance(TOKYO).withZone(PARIS));\n+        assertSame(EthiopicChronology.getInstance(LONDON), EthiopicChronology.getInstance(TOKYO).withZone(null));\n+        assertSame(EthiopicChronology.getInstance(PARIS), EthiopicChronology.getInstance().withZone(PARIS));\n+        assertSame(EthiopicChronology.getInstance(PARIS), EthiopicChronology.getInstanceUTC().withZone(PARIS));\n+    }\n+\n+    public void testToString() {\n+        assertEquals(\"EthiopicChronology[Europe/London]\", EthiopicChronology.getInstance(LONDON).toString());\n+        assertEquals(\"EthiopicChronology[Asia/Tokyo]\", EthiopicChronology.getInstance(TOKYO).toString());\n+        assertEquals(\"EthiopicChronology[Europe/London]\", EthiopicChronology.getInstance().toString());\n+        assertEquals(\"EthiopicChronology[UTC]\", EthiopicChronology.getInstanceUTC().toString());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testDurationFields() {\n+        assertEquals(\"eras\", EthiopicChronology.getInstance().eras().getName());\n+        assertEquals(\"centuries\", EthiopicChronology.getInstance().centuries().getName());\n+        assertEquals(\"years\", EthiopicChronology.getInstance().years().getName());\n+        assertEquals(\"weekyears\", EthiopicChronology.getInstance().weekyears().getName());\n+        assertEquals(\"months\", EthiopicChronology.getInstance().months().getName());\n+        assertEquals(\"weeks\", EthiopicChronology.getInstance().weeks().getName());\n+        assertEquals(\"days\", EthiopicChronology.getInstance().days().getName());\n+        assertEquals(\"halfdays\", EthiopicChronology.getInstance().halfdays().getName());\n+        assertEquals(\"hours\", EthiopicChronology.getInstance().hours().getName());\n+        assertEquals(\"minutes\", EthiopicChronology.getInstance().minutes().getName());\n+        assertEquals(\"seconds\", EthiopicChronology.getInstance().seconds().getName());\n+        assertEquals(\"millis\", EthiopicChronology.getInstance().millis().getName());\n+        \n+        assertEquals(false, EthiopicChronology.getInstance().eras().isSupported());\n+        assertEquals(true, EthiopicChronology.getInstance().centuries().isSupported());\n+        assertEquals(true, EthiopicChronology.getInstance().years().isSupported());\n+        assertEquals(true, EthiopicChronology.getInstance().weekyears().isSupported());\n+        assertEquals(true, EthiopicChronology.getInstance().months().isSupported());\n+        assertEquals(true, EthiopicChronology.getInstance().weeks().isSupported());\n+        assertEquals(true, EthiopicChronology.getInstance().days().isSupported());\n+        assertEquals(true, EthiopicChronology.getInstance().halfdays().isSupported());\n+        assertEquals(true, EthiopicChronology.getInstance().hours().isSupported());\n+        assertEquals(true, EthiopicChronology.getInstance().minutes().isSupported());\n+        assertEquals(true, EthiopicChronology.getInstance().seconds().isSupported());\n+        assertEquals(true, EthiopicChronology.getInstance().millis().isSupported());\n+        \n+        assertEquals(false, EthiopicChronology.getInstance().centuries().isPrecise());\n+        assertEquals(false, EthiopicChronology.getInstance().years().isPrecise());\n+        assertEquals(false, EthiopicChronology.getInstance().weekyears().isPrecise());\n+        assertEquals(false, EthiopicChronology.getInstance().months().isPrecise());\n+        assertEquals(false, EthiopicChronology.getInstance().weeks().isPrecise());\n+        assertEquals(false, EthiopicChronology.getInstance().days().isPrecise());\n+        assertEquals(false, EthiopicChronology.getInstance().halfdays().isPrecise());\n+        assertEquals(true, EthiopicChronology.getInstance().hours().isPrecise());\n+        assertEquals(true, EthiopicChronology.getInstance().minutes().isPrecise());\n+        assertEquals(true, EthiopicChronology.getInstance().seconds().isPrecise());\n+        assertEquals(true, EthiopicChronology.getInstance().millis().isPrecise());\n+        \n+        assertEquals(false, EthiopicChronology.getInstanceUTC().centuries().isPrecise());\n+        assertEquals(false, EthiopicChronology.getInstanceUTC().years().isPrecise());\n+        assertEquals(false, EthiopicChronology.getInstanceUTC().weekyears().isPrecise());\n+        assertEquals(true, EthiopicChronology.getInstanceUTC().months().isPrecise());\n+        assertEquals(true, EthiopicChronology.getInstanceUTC().weeks().isPrecise());\n+        assertEquals(true, EthiopicChronology.getInstanceUTC().days().isPrecise());\n+        assertEquals(true, EthiopicChronology.getInstanceUTC().halfdays().isPrecise());\n+        assertEquals(true, EthiopicChronology.getInstanceUTC().hours().isPrecise());\n+        assertEquals(true, EthiopicChronology.getInstanceUTC().minutes().isPrecise());\n+        assertEquals(true, EthiopicChronology.getInstanceUTC().seconds().isPrecise());\n+        assertEquals(true, EthiopicChronology.getInstanceUTC().millis().isPrecise());\n+    }\n+\n+    public void testDateFields() {\n+        assertEquals(\"era\", EthiopicChronology.getInstance().era().getName());\n+        assertEquals(\"centuryOfEra\", EthiopicChronology.getInstance().centuryOfEra().getName());\n+        assertEquals(\"yearOfCentury\", EthiopicChronology.getInstance().yearOfCentury().getName());\n+        assertEquals(\"yearOfEra\", EthiopicChronology.getInstance().yearOfEra().getName());\n+        assertEquals(\"year\", EthiopicChronology.getInstance().year().getName());\n+        assertEquals(\"monthOfYear\", EthiopicChronology.getInstance().monthOfYear().getName());\n+        assertEquals(\"weekyearOfCentury\", EthiopicChronology.getInstance().weekyearOfCentury().getName());\n+        assertEquals(\"weekyear\", EthiopicChronology.getInstance().weekyear().getName());\n+        assertEquals(\"weekOfWeekyear\", EthiopicChronology.getInstance().weekOfWeekyear().getName());\n+        assertEquals(\"dayOfYear\", EthiopicChronology.getInstance().dayOfYear().getName());\n+        assertEquals(\"dayOfMonth\", EthiopicChronology.getInstance().dayOfMonth().getName());\n+        assertEquals(\"dayOfWeek\", EthiopicChronology.getInstance().dayOfWeek().getName());\n+        \n+        assertEquals(true, EthiopicChronology.getInstance().era().isSupported());\n+        assertEquals(true, EthiopicChronology.getInstance().centuryOfEra().isSupported());\n+        assertEquals(true, EthiopicChronology.getInstance().yearOfCentury().isSupported());\n+        assertEquals(true, EthiopicChronology.getInstance().yearOfEra().isSupported());\n+        assertEquals(true, EthiopicChronology.getInstance().year().isSupported());\n+        assertEquals(true, EthiopicChronology.getInstance().monthOfYear().isSupported());\n+        assertEquals(true, EthiopicChronology.getInstance().weekyearOfCentury().isSupported());\n+        assertEquals(true, EthiopicChronology.getInstance().weekyear().isSupported());\n+        assertEquals(true, EthiopicChronology.getInstance().weekOfWeekyear().isSupported());\n+        assertEquals(true, EthiopicChronology.getInstance().dayOfYear().isSupported());\n+        assertEquals(true, EthiopicChronology.getInstance().dayOfMonth().isSupported());\n+        assertEquals(true, EthiopicChronology.getInstance().dayOfWeek().isSupported());\n+    }\n+\n+    public void testTimeFields() {\n+        assertEquals(\"halfdayOfDay\", EthiopicChronology.getInstance().halfdayOfDay().getName());\n+        assertEquals(\"clockhourOfHalfday\", EthiopicChronology.getInstance().clockhourOfHalfday().getName());\n+        assertEquals(\"hourOfHalfday\", EthiopicChronology.getInstance().hourOfHalfday().getName());\n+        assertEquals(\"clockhourOfDay\", EthiopicChronology.getInstance().clockhourOfDay().getName());\n+        assertEquals(\"hourOfDay\", EthiopicChronology.getInstance().hourOfDay().getName());\n+        assertEquals(\"minuteOfDay\", EthiopicChronology.getInstance().minuteOfDay().getName());\n+        assertEquals(\"minuteOfHour\", EthiopicChronology.getInstance().minuteOfHour().getName());\n+        assertEquals(\"secondOfDay\", EthiopicChronology.getInstance().secondOfDay().getName());\n+        assertEquals(\"secondOfMinute\", EthiopicChronology.getInstance().secondOfMinute().getName());\n+        assertEquals(\"millisOfDay\", EthiopicChronology.getInstance().millisOfDay().getName());\n+        assertEquals(\"millisOfSecond\", EthiopicChronology.getInstance().millisOfSecond().getName());\n+        \n+        assertEquals(true, EthiopicChronology.getInstance().halfdayOfDay().isSupported());\n+        assertEquals(true, EthiopicChronology.getInstance().clockhourOfHalfday().isSupported());\n+        assertEquals(true, EthiopicChronology.getInstance().hourOfHalfday().isSupported());\n+        assertEquals(true, EthiopicChronology.getInstance().clockhourOfDay().isSupported());\n+        assertEquals(true, EthiopicChronology.getInstance().hourOfDay().isSupported());\n+        assertEquals(true, EthiopicChronology.getInstance().minuteOfDay().isSupported());\n+        assertEquals(true, EthiopicChronology.getInstance().minuteOfHour().isSupported());\n+        assertEquals(true, EthiopicChronology.getInstance().secondOfDay().isSupported());\n+        assertEquals(true, EthiopicChronology.getInstance().secondOfMinute().isSupported());\n+        assertEquals(true, EthiopicChronology.getInstance().millisOfDay().isSupported());\n+        assertEquals(true, EthiopicChronology.getInstance().millisOfSecond().isSupported());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testEpoch() {\n+        DateTime epoch = new DateTime(1, 1, 1, 0, 0, 0, 0, ETHIOPIC_UTC);\n+        assertEquals(new DateTime(8, 8, 29, 0, 0, 0, 0, JULIAN_UTC), epoch.withChronology(JULIAN_UTC));\n+    }\n+\n+    public void testEra() {\n+        assertEquals(1, EthiopicChronology.EE);\n+        try {\n+            new DateTime(-1, 13, 5, 0, 0, 0, 0, ETHIOPIC_UTC);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Tests era, year, monthOfYear, dayOfMonth and dayOfWeek.\n+     */\n+    public void testCalendar() {\n+        if (TestAll.FAST) {\n+            return;\n+        }\n+        System.out.println(\"\\nTestEthiopicChronology.testCalendar\");\n+        DateTime epoch = new DateTime(1, 1, 1, 0, 0, 0, 0, ETHIOPIC_UTC);\n+        long millis = epoch.getMillis();\n+        long end = new DateTime(3000, 1, 1, 0, 0, 0, 0, ISO_UTC).getMillis();\n+        DateTimeField dayOfWeek = ETHIOPIC_UTC.dayOfWeek();\n+        DateTimeField dayOfYear = ETHIOPIC_UTC.dayOfYear();\n+        DateTimeField dayOfMonth = ETHIOPIC_UTC.dayOfMonth();\n+        DateTimeField monthOfYear = ETHIOPIC_UTC.monthOfYear();\n+        DateTimeField year = ETHIOPIC_UTC.year();\n+        DateTimeField yearOfEra = ETHIOPIC_UTC.yearOfEra();\n+        DateTimeField era = ETHIOPIC_UTC.era();\n+        int expectedDOW = new DateTime(8, 8, 29, 0, 0, 0, 0, JULIAN_UTC).getDayOfWeek();\n+        int expectedDOY = 1;\n+        int expectedDay = 1;\n+        int expectedMonth = 1;\n+        int expectedYear = 1;\n+        while (millis < end) {\n+            int dowValue = dayOfWeek.get(millis);\n+            int doyValue = dayOfYear.get(millis);\n+            int dayValue = dayOfMonth.get(millis);\n+            int monthValue = monthOfYear.get(millis);\n+            int yearValue = year.get(millis);\n+            int yearOfEraValue = yearOfEra.get(millis);\n+            int monthLen = dayOfMonth.getMaximumValue(millis);\n+            if (monthValue < 1 || monthValue > 13) {\n+                fail(\"Bad month: \" + millis);\n+            }\n+            \n+            // test era\n+            assertEquals(1, era.get(millis));\n+            assertEquals(\"EE\", era.getAsText(millis));\n+            assertEquals(\"EE\", era.getAsShortText(millis));\n+            \n+            // test date\n+            assertEquals(expectedYear, yearValue);\n+            assertEquals(expectedYear, yearOfEraValue);\n+            assertEquals(expectedMonth, monthValue);\n+            assertEquals(expectedDay, dayValue);\n+            assertEquals(expectedDOW, dowValue);\n+            assertEquals(expectedDOY, doyValue);\n+            \n+            // test leap year\n+            assertEquals(yearValue % 4 == 3, year.isLeap(millis));\n+            \n+            // test month length\n+            if (monthValue == 13) {\n+                assertEquals(yearValue % 4 == 3, monthOfYear.isLeap(millis));\n+                if (yearValue % 4 == 3) {\n+                    assertEquals(6, monthLen);\n+                } else {\n+                    assertEquals(5, monthLen);\n+                }\n+            } else {\n+                assertEquals(30, monthLen);\n+            }\n+            \n+            // recalculate date\n+            expectedDOW = (((expectedDOW + 1) - 1) % 7) + 1;\n+            expectedDay++;\n+            expectedDOY++;\n+            if (expectedDay == 31 && expectedMonth < 13) {\n+                expectedDay = 1;\n+                expectedMonth++;\n+            } else if (expectedMonth == 13) {\n+                if (expectedYear % 4 == 3 && expectedDay == 7) {\n+                    expectedDay = 1;\n+                    expectedMonth = 1;\n+                    expectedYear++;\n+                    expectedDOY = 1;\n+                } else if (expectedYear % 4 != 3 && expectedDay == 6) {\n+                    expectedDay = 1;\n+                    expectedMonth = 1;\n+                    expectedYear++;\n+                    expectedDOY = 1;\n+                }\n+            }\n+            millis += SKIP;\n+        }\n+    }\n+\n+    public void testSampleDate() {\n+        DateTime dt = new DateTime(2004, 6, 9, 0, 0, 0, 0, ISO_UTC).withChronology(ETHIOPIC_UTC);\n+        System.out.println(dt);\n+        assertEquals(EthiopicChronology.EE, dt.getEra());\n+        assertEquals(20, dt.getCenturyOfEra());  // TODO confirm\n+        assertEquals(96, dt.getYearOfCentury());\n+        assertEquals(1996, dt.getYear());\n+        assertEquals(1996, dt.getYearOfEra());\n+        assertEquals(10, dt.getMonthOfYear());\n+        assertEquals(2, dt.getDayOfMonth());\n+        assertEquals(DateTimeConstants.WEDNESDAY, dt.getDayOfWeek());\n+        assertEquals(9 * 30 + 2, dt.getDayOfYear());\n+        assertEquals(0, dt.getHourOfDay());\n+        assertEquals(0, dt.getMinuteOfHour());\n+        assertEquals(0, dt.getSecondOfMinute());\n+        assertEquals(0, dt.getMillisOfSecond());\n+    }\n+\n+    public void testSampleDateWithZone() {\n+        DateTime dt = new DateTime(2004, 6, 9, 12, 0, 0, 0, PARIS).withChronology(ETHIOPIC_UTC);\n+        assertEquals(EthiopicChronology.EE, dt.getEra());\n+        assertEquals(1996, dt.getYear());\n+        assertEquals(1996, dt.getYearOfEra());\n+        assertEquals(10, dt.getMonthOfYear());\n+        assertEquals(2, dt.getDayOfMonth());\n+        assertEquals(10, dt.getHourOfDay());  // PARIS is UTC+2 in summer (12-2=10)\n+        assertEquals(0, dt.getMinuteOfHour());\n+        assertEquals(0, dt.getSecondOfMinute());\n+        assertEquals(0, dt.getMillisOfSecond());\n+    }\n+\n+}", "timestamp": 1128813187, "metainfo": ""}