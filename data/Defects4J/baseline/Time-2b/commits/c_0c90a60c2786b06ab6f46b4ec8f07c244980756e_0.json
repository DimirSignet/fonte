{"sha": "0c90a60c2786b06ab6f46b4ec8f07c244980756e", "log": "Bug fix Interval overlap/gap methods so they return intervals with the correct chronology Spotted by Jozsef Hontvari  ", "commit": "\n--- a/JodaTime/src/java/org/joda/time/Interval.java\n+++ b/JodaTime/src/java/org/joda/time/Interval.java\n /*\n- *  Copyright 2001-2005 Stephen Colebourne\n+ *  Copyright 2001-2006 Stephen Colebourne\n  *\n  *  Licensed under the Apache License, Version 2.0 (the \"License\");\n  *  you may not use this file except in compliance with the License.\n \n     //-----------------------------------------------------------------------\n     /**\n-     * Gets the overlap where this interval and that specified.\n+     * Gets the overlap between this interval and another interval.\n      * <p>\n      * Any two intervals can overlap, abut, or have a gap between them.\n      * This method returns the amount of the overlap, only if the\n      * intervals do overlap.\n      * If the intervals do not overlap, then null is returned.\n+     * <p>\n+     * The chronology of the returned interval is the same as that of\n+     * this interval (the chronology of the interval parameter is not used).\n+     * Note that the use of the chronology was only correctly implemented\n+     * in version 1.3.\n      *\n      * @param interval  the interval to examine, null means now\n      * @return the overlap interval, null if no overlap\n         }\n         long start = Math.max(getStartMillis(), interval.getStartMillis());\n         long end = Math.min(getEndMillis(), interval.getEndMillis());\n-        return new Interval(start, end);\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Gets the gap between this interval and that specified.\n+        return new Interval(start, end, getChronology());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the gap between this interval and another interval.\n+     * The other interval can be either before or after this interval.\n      * <p>\n      * Any two intervals can overlap, abut, or have a gap between them.\n      * This method returns the amount of the gap only if the\n      * intervals do actually have a gap between them.\n      * If the intervals overlap or abut, then null is returned.\n+     * <p>\n+     * The chronology of the returned interval is the same as that of\n+     * this interval (the chronology of the interval parameter is not used).\n+     * Note that the use of the chronology was only correctly implemented\n+     * in version 1.3.\n      *\n      * @param interval  the interval to examine, null means now\n      * @return the gap interval, null if no gap\n         long thisStart = getStartMillis();\n         long thisEnd = getEndMillis();\n         if (thisStart >= otherEnd) {\n-            return new Interval(otherEnd, thisStart);\n+            return new Interval(otherEnd, thisStart, getChronology());\n         } else {\n-            return new Interval(thisEnd, otherStart);\n+            return new Interval(thisEnd, otherStart, getChronology());\n         }\n     }\n \n--- a/JodaTime/src/test/org/joda/time/TestInterval_Basics.java\n+++ b/JodaTime/src/test/org/joda/time/TestInterval_Basics.java\n     // Test in 2002/03 as time zones are more well known\n     // (before the late 90's they were all over the place)\n \n+    private static final DateTimeZone MOSCOW = DateTimeZone.forID(\"Europe/Moscow\");\n     private static final DateTimeZone PARIS = DateTimeZone.forID(\"Europe/Paris\");\n     private static final DateTimeZone LONDON = DateTimeZone.forID(\"Europe/London\");\n     private static final Chronology COPTIC_PARIS = CopticChronology.getInstance(PARIS);\n         originalDateTimeZone = DateTimeZone.getDefault();\n         originalTimeZone = TimeZone.getDefault();\n         originalLocale = Locale.getDefault();\n-        DateTimeZone.setDefault(LONDON);\n-        TimeZone.setDefault(TimeZone.getTimeZone(\"Europe/London\"));\n-        Locale.setDefault(Locale.UK);\n+        DateTimeZone.setDefault(PARIS);\n+        TimeZone.setDefault(PARIS.toTimeZone());\n+        Locale.setDefault(Locale.FRANCE);\n     }\n \n     protected void tearDown() throws Exception {\n         assertEquals(true, test.contains((ReadableInterval) null));\n     }\n \n+    //-----------------------------------------------------------------------\n     public void testOverlaps_RInterval() {\n         Interval test = new Interval(TEST_TIME1, TEST_TIME2);\n         \n                 test.overlap((ReadableInterval) null));\n     }\n \n+    public void testOverlap_RInterval_zone() {\n+        Interval testA = new Interval(new DateTime(TEST_TIME1, LONDON), new DateTime(TEST_TIME2, LONDON));\n+        assertEquals(ISOChronology.getInstance(LONDON), testA.getChronology());\n+        \n+        Interval testB = new Interval(new DateTime(TEST_TIME1 + 1, MOSCOW), new DateTime(TEST_TIME2 + 1, MOSCOW));\n+        assertEquals(ISOChronology.getInstance(MOSCOW), testB.getChronology());\n+        \n+        Interval resultAB = testA.overlap(testB);\n+        assertEquals(ISOChronology.getInstance(LONDON), resultAB.getChronology());\n+        \n+        Interval resultBA = testB.overlap(testA);\n+        assertEquals(ISOChronology.getInstance(MOSCOW), resultBA.getChronology());\n+    }\n+\n+    public void testOverlap_RInterval_zoneUTC() {\n+        Interval testA = new Interval(new Instant(TEST_TIME1), new Instant(TEST_TIME2));\n+        assertEquals(ISOChronology.getInstanceUTC(), testA.getChronology());\n+        \n+        Interval testB = new Interval(new Instant(TEST_TIME1 + 1), new Instant(TEST_TIME2 + 1));\n+        assertEquals(ISOChronology.getInstanceUTC(), testB.getChronology());\n+        \n+        Interval result = testA.overlap(testB);\n+        assertEquals(ISOChronology.getInstanceUTC(), result.getChronology());\n+    }\n+\n     //-----------------------------------------------------------------------\n     public void testGap_RInterval() {\n         Interval test = new Interval(TEST_TIME1, TEST_TIME2);\n         assertEquals(\n                 null,\n                 test.gap(new Interval(TEST_TIME1 + 1, TEST_TIME2 - 1)));\n+    }\n+\n+    public void testGap_RInterval_zone() {\n+        Interval testA = new Interval(new DateTime(TEST_TIME1, LONDON), new DateTime(TEST_TIME2, LONDON));\n+        assertEquals(ISOChronology.getInstance(LONDON), testA.getChronology());\n+        \n+        Interval testB = new Interval(new DateTime(TEST_TIME1 - 100, MOSCOW), new DateTime(TEST_TIME1 - 50, MOSCOW));\n+        assertEquals(ISOChronology.getInstance(MOSCOW), testB.getChronology());\n+        \n+        Interval resultAB = testA.gap(testB);\n+        assertEquals(ISOChronology.getInstance(LONDON), resultAB.getChronology());\n+        \n+        Interval resultBA = testB.gap(testA);\n+        assertEquals(ISOChronology.getInstance(MOSCOW), resultBA.getChronology());\n+    }\n+\n+    public void testGap_RInterval_zoneUTC() {\n+        Interval testA = new Interval(new Instant(TEST_TIME1), new Instant(TEST_TIME2));\n+        assertEquals(ISOChronology.getInstanceUTC(), testA.getChronology());\n+        \n+        Interval testB = new Interval(new Instant(TEST_TIME1 - 100), new Instant(TEST_TIME1 - 50));\n+        assertEquals(ISOChronology.getInstanceUTC(), testB.getChronology());\n+        \n+        Interval result = testA.gap(testB);\n+        assertEquals(ISOChronology.getInstanceUTC(), result.getChronology());\n     }\n \n     //-----------------------------------------------------------------------", "timestamp": 1151751815, "metainfo": ""}