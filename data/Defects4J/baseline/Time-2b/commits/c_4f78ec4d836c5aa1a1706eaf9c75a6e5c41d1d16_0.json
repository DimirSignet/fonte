{"sha": "4f78ec4d836c5aa1a1706eaf9c75a6e5c41d1d16", "log": "Use DateTimeFieldType in DateTimeField   ", "commit": "\n--- a/JodaTime/src/java/org/joda/time/DateTimeField.java\n+++ b/JodaTime/src/java/org/joda/time/DateTimeField.java\n public abstract class DateTimeField {\n \n     /**\n+     * Get the type of the field.\n+     * \n+     * @return field type\n+     */\n+    public abstract DateTimeFieldType getType();\n+\n+    /**\n      * Get the name of the field, intended for debugging purposes only. By\n      * convention, names follow a pattern of \"dddOfRrr\", where \"ddd\" represents\n      * the (singular) duration field name and \"Rrr\" represents the (singular)\n--- a/JodaTime/src/java/org/joda/time/DateTimeFieldType.java\n+++ b/JodaTime/src/java/org/joda/time/DateTimeFieldType.java\n     private static final DateTimeFieldType MONTH_OF_YEAR = new DateTimeFieldType(\"monthOfYear\");\n     /** The dayOfMonth field. */\n     private static final DateTimeFieldType DAY_OF_MONTH = new DateTimeFieldType(\"dayOfMonth\");\n+    /** The weekyearOfCentury field. */\n+    private static final DateTimeFieldType WEEKYEAR_OF_CENTURY = new DateTimeFieldType(\"weekyearOfCentury\");\n     /** The weekyear field. */\n     private static final DateTimeFieldType WEEKYEAR = new DateTimeFieldType(\"weekyear\");\n     /** The weekOfWeekyear field. */\n     }\n \n     /**\n+     * Get the year of a week based year within a century field type.\n+     * \n+     * @return the DateTimeFieldType constant\n+     */\n+    public static DateTimeFieldType weekyearOfCentury() {\n+        return WEEKYEAR_OF_CENTURY;\n+    }\n+\n+    /**\n      * Get the month of year field type.\n      * \n      * @return the DateTimeFieldType constant\n--- a/JodaTime/src/java/org/joda/time/chrono/BaseChronology.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/BaseChronology.java\n      * @return DateTimeField or UnsupportedDateTimeField if unsupported\n      */\n     public DateTimeField millisOfSecond() {\n-        return UnsupportedDateTimeField.getInstance(\"millisOfSecond\", millis());\n+        return UnsupportedDateTimeField.getInstance(DateTimeFieldType.millisOfSecond(), millis());\n     }\n \n     /**\n      * @return DateTimeField or UnsupportedDateTimeField if unsupported\n      */\n     public DateTimeField millisOfDay() {\n-        return UnsupportedDateTimeField.getInstance(\"millisOfDay\", millis());\n+        return UnsupportedDateTimeField.getInstance(DateTimeFieldType.millisOfDay(), millis());\n     }\n \n     // Second\n      * @return DateTimeField or UnsupportedDateTimeField if unsupported\n      */\n     public DateTimeField secondOfMinute() {\n-        return UnsupportedDateTimeField.getInstance(\"secondOfMinute\", seconds());\n+        return UnsupportedDateTimeField.getInstance(DateTimeFieldType.secondOfMinute(), seconds());\n     }\n \n     /**\n      * @return DateTimeField or UnsupportedDateTimeField if unsupported\n      */\n     public DateTimeField secondOfDay() {\n-        return UnsupportedDateTimeField.getInstance(\"secondOfDay\", seconds());\n+        return UnsupportedDateTimeField.getInstance(DateTimeFieldType.secondOfDay(), seconds());\n     }\n \n     // Minute\n      * @return DateTimeField or UnsupportedDateTimeField if unsupported\n      */\n     public DateTimeField minuteOfHour() {\n-        return UnsupportedDateTimeField.getInstance(\"minuteOfHour\", minutes());\n+        return UnsupportedDateTimeField.getInstance(DateTimeFieldType.minuteOfHour(), minutes());\n     }\n \n     /**\n      * @return DateTimeField or UnsupportedDateTimeField if unsupported\n      */\n     public DateTimeField minuteOfDay() {\n-        return UnsupportedDateTimeField.getInstance(\"minuteOfDay\", minutes());\n+        return UnsupportedDateTimeField.getInstance(DateTimeFieldType.minuteOfDay(), minutes());\n     }\n \n     // Hour\n      * @return DateTimeField or UnsupportedDateTimeField if unsupported\n      */\n     public DateTimeField hourOfDay() {\n-        return UnsupportedDateTimeField.getInstance(\"hourOfDay\", hours());\n+        return UnsupportedDateTimeField.getInstance(DateTimeFieldType.hourOfDay(), hours());\n     }\n \n     /**\n      * @return DateTimeField or UnsupportedDateTimeField if unsupported\n      */\n     public DateTimeField clockhourOfDay() {\n-        return UnsupportedDateTimeField.getInstance(\"clockhourOfDay\", hours());\n+        return UnsupportedDateTimeField.getInstance(DateTimeFieldType.clockhourOfDay(), hours());\n     }\n \n     /**\n      * @return DateTimeField or UnsupportedDateTimeField if unsupported\n      */\n     public DateTimeField hourOfHalfday() {\n-        return UnsupportedDateTimeField.getInstance(\"hourOfHalfday\", hours());\n+        return UnsupportedDateTimeField.getInstance(DateTimeFieldType.hourOfHalfday(), hours());\n     }\n \n     /**\n      * @return DateTimeField or UnsupportedDateTimeField if unsupported\n      */\n     public DateTimeField clockhourOfHalfday() {\n-        return UnsupportedDateTimeField.getInstance(\"clockhourOfHalfday\", hours());\n+        return UnsupportedDateTimeField.getInstance(DateTimeFieldType.clockhourOfHalfday(), hours());\n     }\n \n     /**\n      */\n     public DateTimeField halfdayOfDay() {\n         return UnsupportedDateTimeField.getInstance\n-            (\"halfdayOfDay\", UnsupportedDurationField.getInstance(\"halfdays\"));\n+            (DateTimeFieldType.halfdayOfDay(), UnsupportedDurationField.getInstance(\"halfdays\"));\n     }\n \n     // Day\n      * @return DateTimeField or UnsupportedDateTimeField if unsupported\n      */\n     public DateTimeField dayOfWeek() {\n-        return UnsupportedDateTimeField.getInstance(\"dayOfWeek\", days());\n+        return UnsupportedDateTimeField.getInstance(DateTimeFieldType.dayOfWeek(), days());\n     }\n \n     /**\n      * @return DateTimeField or UnsupportedDateTimeField if unsupported\n      */\n     public DateTimeField dayOfMonth() {\n-        return UnsupportedDateTimeField.getInstance(\"dayOfMonth\", days());\n+        return UnsupportedDateTimeField.getInstance(DateTimeFieldType.dayOfMonth(), days());\n     }\n \n     /**\n      * @return DateTimeField or UnsupportedDateTimeField if unsupported\n      */\n     public DateTimeField dayOfYear() {\n-        return UnsupportedDateTimeField.getInstance(\"dayOfYear\", days());\n+        return UnsupportedDateTimeField.getInstance(DateTimeFieldType.dayOfYear(), days());\n     }\n \n     // Week\n      * @return DateTimeField or UnsupportedDateTimeField if unsupported\n      */\n     public DateTimeField weekOfWeekyear() {\n-        return UnsupportedDateTimeField.getInstance(\"weekOfWeekyear\", weeks());\n+        return UnsupportedDateTimeField.getInstance(DateTimeFieldType.weekOfWeekyear(), weeks());\n     }\n \n     /**\n      * @return DateTimeField or UnsupportedDateTimeField if unsupported\n      */\n     public DateTimeField weekyear() {\n-        return UnsupportedDateTimeField.getInstance(\"weekyear\", weekyears());\n+        return UnsupportedDateTimeField.getInstance(DateTimeFieldType.weekyear(), weekyears());\n     }\n \n     // Month\n      * @return DateTimeField or UnsupportedDateTimeField if unsupported\n      */\n     public DateTimeField monthOfYear() {\n-        return UnsupportedDateTimeField.getInstance(\"monthOfYear\", months());\n+        return UnsupportedDateTimeField.getInstance(DateTimeFieldType.monthOfYear(), months());\n     }\n \n     // Year\n      * @return DateTimeField or UnsupportedDateTimeField if unsupported\n      */\n     public DateTimeField year() {\n-        return UnsupportedDateTimeField.getInstance(\"year\", years());\n+        return UnsupportedDateTimeField.getInstance(DateTimeFieldType.year(), years());\n     }\n \n     /**\n      * @return DateTimeField or UnsupportedDateTimeField if unsupported\n      */\n     public DateTimeField yearOfEra() {\n-        return UnsupportedDateTimeField.getInstance(\"yearOfEra\", years());\n+        return UnsupportedDateTimeField.getInstance(DateTimeFieldType.yearOfEra(), years());\n     }\n \n     /**\n      * @return DateTimeField or UnsupportedDateTimeField if unsupported\n      */\n     public DateTimeField yearOfCentury() {\n-        return UnsupportedDateTimeField.getInstance(\"yearOfCentury\", years());\n+        return UnsupportedDateTimeField.getInstance(DateTimeFieldType.yearOfCentury(), years());\n     }\n \n     /**\n      * @return DateTimeField or UnsupportedDateTimeField if unsupported\n      */\n     public DateTimeField centuryOfEra() {\n-        return UnsupportedDateTimeField.getInstance(\"centuryOfEra\", centuries());\n+        return UnsupportedDateTimeField.getInstance(DateTimeFieldType.centuryOfEra(), centuries());\n     }\n \n     /**\n      * @return DateTimeField or UnsupportedDateTimeField if unsupported\n      */\n     public DateTimeField era() {\n-        return UnsupportedDateTimeField.getInstance(\"era\", eras());\n+        return UnsupportedDateTimeField.getInstance(DateTimeFieldType.era(), eras());\n     }\n \n     /**\n--- a/JodaTime/src/java/org/joda/time/chrono/BaseGJChronology.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/BaseGJChronology.java\n import org.joda.time.Chronology;\n import org.joda.time.DateTimeConstants;\n import org.joda.time.DateTimeField;\n+import org.joda.time.DateTimeFieldType;\n import org.joda.time.DateTimeZone;\n import org.joda.time.DurationField;\n import org.joda.time.field.DividedDateTimeField;\n             (\"weeks\", DateTimeConstants.MILLIS_PER_WEEK);\n \n         cMillisOfSecondField = new PreciseDateTimeField\n-            (\"millisOfSecond\", cMillisField, cSecondsField);\n+            (DateTimeFieldType.millisOfSecond(), cMillisField, cSecondsField);\n \n         cMillisOfDayField = new PreciseDateTimeField\n-            (\"millisOfDay\", cMillisField, cDaysField);\n+            (DateTimeFieldType.millisOfDay(), cMillisField, cDaysField);\n              \n         cSecondOfMinuteField = new PreciseDateTimeField\n-            (\"secondOfMinute\", cSecondsField, cMinutesField);\n+            (DateTimeFieldType.secondOfMinute(), cSecondsField, cMinutesField);\n \n         cSecondOfDayField = new PreciseDateTimeField\n-            (\"secondOfDay\", cSecondsField, cDaysField);\n+            (DateTimeFieldType.secondOfDay(), cSecondsField, cDaysField);\n \n         cMinuteOfHourField = new PreciseDateTimeField\n-            (\"minuteOfHour\", cMinutesField, cHoursField);\n+            (DateTimeFieldType.minuteOfHour(), cMinutesField, cHoursField);\n \n         cMinuteOfDayField = new PreciseDateTimeField\n-            (\"minuteOfDay\", cMinutesField, cDaysField);\n+            (DateTimeFieldType.minuteOfDay(), cMinutesField, cDaysField);\n \n         cHourOfDayField = new PreciseDateTimeField\n-            (\"hourOfDay\", cHoursField, cDaysField);\n+            (DateTimeFieldType.hourOfDay(), cHoursField, cDaysField);\n \n         cHourOfHalfdayField = new PreciseDateTimeField\n-            (\"hourOfHalfday\", cHoursField, cHalfdaysField);\n+            (DateTimeFieldType.hourOfHalfday(), cHoursField, cHalfdaysField);\n \n         cClockhourOfDayField = new NonZeroDateTimeField\n-            (cHourOfDayField, \"clockhourOfDay\");\n+            (cHourOfDayField, DateTimeFieldType.clockhourOfDay());\n \n         cClockhourOfHalfdayField = new NonZeroDateTimeField\n-            (cHourOfHalfdayField, \"clockhourOfHalfday\");\n+            (cHourOfHalfdayField, DateTimeFieldType.clockhourOfHalfday());\n \n         cHalfdayOfDayField = new HalfdayField();\n     }\n         fields.yearOfEra = new GJYearOfEraDateTimeField(fields.year, this);\n \n         // Define one-based centuryOfEra and yearOfCentury.\n-        DateTimeField field = new OffsetDateTimeField(fields.yearOfEra, \"\", 99);\n-        fields.centuryOfEra = new DividedDateTimeField\n-            (field, \"centuryOfEra\", \"centuries\", 100);\n+        DateTimeField field = new OffsetDateTimeField(\n+            fields.yearOfEra, 99);\n+        fields.centuryOfEra = new DividedDateTimeField(\n+            field, DateTimeFieldType.centuryOfEra(), \"centuries\", 100);\n         \n-        field = new RemainderDateTimeField\n-            ((DividedDateTimeField)fields.centuryOfEra, \"\");\n-        fields.yearOfCentury = new OffsetDateTimeField(field, \"yearOfCentury\", 1);\n+        field = new RemainderDateTimeField(\n+            (DividedDateTimeField) fields.centuryOfEra);\n+        fields.yearOfCentury = new OffsetDateTimeField(\n+            field, DateTimeFieldType.yearOfCentury(), 1);\n \n         fields.era = new GJEraDateTimeField(this);\n         fields.dayOfWeek = new GJDayOfWeekDateTimeField(this, fields.days);\n         private static final long serialVersionUID = 581601443656929254L;\n \n         HalfdayField() {\n-            super(\"halfdayOfDay\", cHalfdaysField, cDaysField);\n+            super(DateTimeFieldType.halfdayOfDay(), cHalfdaysField, cDaysField);\n         }\n \n         protected String getAsText(int fieldValue, Locale locale) {\n--- a/JodaTime/src/java/org/joda/time/chrono/BuddhistChronology.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/BuddhistChronology.java\n import org.joda.time.DateTime;\n import org.joda.time.DateTimeConstants;\n import org.joda.time.DateTimeField;\n+import org.joda.time.DateTimeFieldType;\n import org.joda.time.DateTimeZone;\n import org.joda.time.field.DividedDateTimeField;\n import org.joda.time.field.OffsetDateTimeField;\n     protected void assemble(Fields fields) {\n         if (getParam() == null) {\n             DateTimeField field = fields.year;\n-            fields.year = new OffsetDateTimeField(field, field.getName(), BUDDHIST_OFFSET);\n+            fields.year = new OffsetDateTimeField(field, BUDDHIST_OFFSET);\n             \n             field = fields.yearOfEra;\n-            fields.yearOfEra = new OffsetDateTimeField(fields.year, field.getName(), BUDDHIST_OFFSET);\n+            fields.yearOfEra = new OffsetDateTimeField(\n+                fields.year, DateTimeFieldType.yearOfEra(), BUDDHIST_OFFSET);\n             \n             field = fields.weekyear;\n-            fields.weekyear = new OffsetDateTimeField(field, field.getName(), BUDDHIST_OFFSET);\n-            \n-            field = new OffsetDateTimeField(fields.yearOfEra, \"\", 99);\n-            fields.centuryOfEra = new DividedDateTimeField(field, \"centuryOfEra\", \"centuries\", 100);\n-            \n-            field = new RemainderDateTimeField\n-                ((DividedDateTimeField)fields.centuryOfEra, \"\");\n-            fields.yearOfCentury = new OffsetDateTimeField(field, \"yearOfCentury\", 1);\n+            fields.weekyear = new OffsetDateTimeField(field, BUDDHIST_OFFSET);\n+            \n+            field = new OffsetDateTimeField(fields.yearOfEra, 99);\n+            fields.centuryOfEra = new DividedDateTimeField(\n+                field, DateTimeFieldType.centuryOfEra(), \"centuries\", 100);\n+            \n+            field = new RemainderDateTimeField(\n+                (DividedDateTimeField) fields.centuryOfEra);\n+            fields.yearOfCentury = new OffsetDateTimeField(\n+                field, DateTimeFieldType.yearOfCentury(), 1);\n             \n             fields.era = BuddhistEraDateTimeField.INSTANCE;\n         }\n--- a/JodaTime/src/java/org/joda/time/chrono/BuddhistEraDateTimeField.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/BuddhistEraDateTimeField.java\n import java.util.Locale;\n \n import org.joda.time.DateTimeField;\n+import org.joda.time.DateTimeFieldType;\n import org.joda.time.DurationField;\n import org.joda.time.field.BaseDateTimeField;\n import org.joda.time.field.UnsupportedDurationField;\n      * Restricted constructor\n      */\n     private BuddhistEraDateTimeField() {\n-        super(\"era\");\n+        super(DateTimeFieldType.era());\n     }\n \n     /**\n--- a/JodaTime/src/java/org/joda/time/chrono/CopticDayOfMonthDateTimeField.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/CopticDayOfMonthDateTimeField.java\n package org.joda.time.chrono;\n \n import org.joda.time.DateTimeField;\n+import org.joda.time.DateTimeFieldType;\n import org.joda.time.DurationField;\n import org.joda.time.ReadablePartial;\n import org.joda.time.field.PreciseDurationDateTimeField;\n      * Restricted constructor.\n      */\n     CopticDayOfMonthDateTimeField(BaseGJChronology chronology, DurationField days) {\n-        super(\"dayOfMonth\", days);\n+        super(DateTimeFieldType.dayOfMonth(), days);\n         iChronology = chronology;\n     }\n \n--- a/JodaTime/src/java/org/joda/time/chrono/CopticEraDateTimeField.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/CopticEraDateTimeField.java\n import java.util.Locale;\n \n import org.joda.time.DateTimeField;\n+import org.joda.time.DateTimeFieldType;\n import org.joda.time.DurationField;\n import org.joda.time.field.BaseDateTimeField;\n import org.joda.time.field.UnsupportedDurationField;\n      * Restricted constructor\n      */\n     private CopticEraDateTimeField() {\n-        super(\"era\");\n+        super(DateTimeFieldType.era());\n     }\n \n     /**\n--- a/JodaTime/src/java/org/joda/time/chrono/CopticMonthOfYearDateTimeField.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/CopticMonthOfYearDateTimeField.java\n package org.joda.time.chrono;\n \n import org.joda.time.DateTimeConstants;\n+import org.joda.time.DateTimeFieldType;\n import org.joda.time.DurationField;\n import org.joda.time.field.PreciseDurationDateTimeField;\n \n      * Restricted constructor.\n      */\n     CopticMonthOfYearDateTimeField(BaseGJChronology chronology, DurationField months) {\n-        super(\"monthOfYear\", months);\n+        super(DateTimeFieldType.monthOfYear(), months);\n         iChronology = chronology;\n     }\n \n--- a/JodaTime/src/java/org/joda/time/chrono/CopticYearDateTimeField.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/CopticYearDateTimeField.java\n  */\n package org.joda.time.chrono;\n \n-import org.joda.time.DateTimeConstants;\n+import org.joda.time.DateTimeFieldType;\n import org.joda.time.DurationField;\n+import org.joda.time.field.FieldUtils;\n import org.joda.time.field.ImpreciseDateTimeField;\n-import org.joda.time.field.FieldUtils;\n \n /**\n  *\n      * Restricted constructor\n      */\n     CopticYearDateTimeField(BaseGJChronology chronology) {\n-        super(\"year\", \"years\", chronology.getAverageMillisPerYear());\n+        super(DateTimeFieldType.year(), \"years\", chronology.getAverageMillisPerYear());\n         iChronology = chronology;\n     }\n \n--- a/JodaTime/src/java/org/joda/time/chrono/GJChronology.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/GJChronology.java\n \n         CutoverField(DateTimeField julianField, DateTimeField gregorianField,\n                      long cutoverMillis, boolean convertByWeekyear) {\n-            super(gregorianField.getName());\n+            super(gregorianField.getType());\n             iJulianField = julianField;\n             iGregorianField = gregorianField;\n             iCutover = cutoverMillis;\n--- a/JodaTime/src/java/org/joda/time/chrono/GJDayOfMonthDateTimeField.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/GJDayOfMonthDateTimeField.java\n package org.joda.time.chrono;\n \n import org.joda.time.DateTimeField;\n+import org.joda.time.DateTimeFieldType;\n import org.joda.time.DurationField;\n import org.joda.time.ReadablePartial;\n import org.joda.time.field.PreciseDurationDateTimeField;\n      * Restricted constructor.\n      */\n     GJDayOfMonthDateTimeField(BaseGJChronology chronology, DurationField days) {\n-        super(\"dayOfMonth\", days);\n+        super(DateTimeFieldType.dayOfMonth(), days);\n         iChronology = chronology;\n     }\n \n--- a/JodaTime/src/java/org/joda/time/chrono/GJDayOfWeekDateTimeField.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/GJDayOfWeekDateTimeField.java\n import java.util.Locale;\n \n import org.joda.time.DateTimeConstants;\n+import org.joda.time.DateTimeFieldType;\n import org.joda.time.DurationField;\n import org.joda.time.field.PreciseDurationDateTimeField;\n \n      * Restricted constructor.\n      */\n     GJDayOfWeekDateTimeField(BaseGJChronology chronology, DurationField days) {\n-        super(\"dayOfWeek\", days);\n+        super(DateTimeFieldType.dayOfWeek(), days);\n         iChronology = chronology;\n     }\n \n--- a/JodaTime/src/java/org/joda/time/chrono/GJDayOfYearDateTimeField.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/GJDayOfYearDateTimeField.java\n package org.joda.time.chrono;\n \n import org.joda.time.DateTimeField;\n+import org.joda.time.DateTimeFieldType;\n import org.joda.time.DurationField;\n import org.joda.time.ReadablePartial;\n import org.joda.time.field.PreciseDurationDateTimeField;\n      * Restricted constructor\n      */\n     GJDayOfYearDateTimeField(BaseGJChronology chronology, DurationField days) {\n-        super(\"dayOfYear\", days);\n+        super(DateTimeFieldType.dayOfYear(), days);\n         iChronology = chronology;\n     }\n \n--- a/JodaTime/src/java/org/joda/time/chrono/GJEraDateTimeField.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/GJEraDateTimeField.java\n import java.util.Locale;\n \n import org.joda.time.DateTimeConstants;\n+import org.joda.time.DateTimeFieldType;\n import org.joda.time.DurationField;\n import org.joda.time.field.BaseDateTimeField;\n import org.joda.time.field.UnsupportedDurationField;\n      * Restricted constructor\n      */\n     GJEraDateTimeField(BaseGJChronology chronology) {\n-        super(\"era\");\n+        super(DateTimeFieldType.era());\n         iChronology = chronology;\n     }\n \n--- a/JodaTime/src/java/org/joda/time/chrono/GJMonthOfYearDateTimeField.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/GJMonthOfYearDateTimeField.java\n import java.util.Locale;\n \n import org.joda.time.DateTimeConstants;\n+import org.joda.time.DateTimeFieldType;\n import org.joda.time.DurationField;\n import org.joda.time.field.FieldUtils;\n import org.joda.time.field.ImpreciseDateTimeField;\n      * Restricted constructor\n      */\n     GJMonthOfYearDateTimeField(BaseGJChronology chronology) {\n-        super(\"monthOfYear\", \"months\", chronology.getAverageMillisPerMonth());\n+        super(DateTimeFieldType.monthOfYear(), \"months\", chronology.getAverageMillisPerMonth());\n         iChronology = chronology;\n     }\n \n--- a/JodaTime/src/java/org/joda/time/chrono/GJWeekOfWeekyearDateTimeField.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/GJWeekOfWeekyearDateTimeField.java\n \n import org.joda.time.DateTimeConstants;\n import org.joda.time.DateTimeField;\n+import org.joda.time.DateTimeFieldType;\n import org.joda.time.DurationField;\n import org.joda.time.ReadablePartial;\n import org.joda.time.field.PreciseDurationDateTimeField;\n      * Restricted constructor\n      */\n     GJWeekOfWeekyearDateTimeField(BaseGJChronology chronology, DurationField weeks) {\n-        super(\"weekOfWeekyear\", weeks);\n+        super(DateTimeFieldType.weekOfWeekyear(), weeks);\n         iChronology = chronology;\n     }\n \n--- a/JodaTime/src/java/org/joda/time/chrono/GJWeekyearDateTimeField.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/GJWeekyearDateTimeField.java\n package org.joda.time.chrono;\n \n import org.joda.time.DateTimeConstants;\n-import org.joda.time.DateTimeField;\n+import org.joda.time.DateTimeFieldType;\n import org.joda.time.DurationField;\n+import org.joda.time.field.FieldUtils;\n import org.joda.time.field.ImpreciseDateTimeField;\n-import org.joda.time.field.FieldUtils;\n \n /**\n  * Provides time calculations for the week of the weekyear component of time.\n      * Restricted constructor\n      */\n     GJWeekyearDateTimeField(BaseGJChronology chronology) {\n-        super(\"weekyear\", \"weekyears\", chronology.getAverageMillisPerYear());\n+        super(DateTimeFieldType.weekyear(), \"weekyears\", chronology.getAverageMillisPerYear());\n         iChronology = chronology;\n     }\n \n--- a/JodaTime/src/java/org/joda/time/chrono/GJYearDateTimeField.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/GJYearDateTimeField.java\n package org.joda.time.chrono;\n \n import org.joda.time.DateTimeConstants;\n+import org.joda.time.DateTimeFieldType;\n import org.joda.time.DurationField;\n+import org.joda.time.field.FieldUtils;\n import org.joda.time.field.ImpreciseDateTimeField;\n-import org.joda.time.field.FieldUtils;\n \n /**\n  * Provides time calculations for the year component of time.\n      * Restricted constructor\n      */\n     GJYearDateTimeField(BaseGJChronology chronology) {\n-        super(\"year\", \"years\", chronology.getAverageMillisPerYear());\n+        super(DateTimeFieldType.year(), \"years\", chronology.getAverageMillisPerYear());\n         iChronology = chronology;\n     }\n \n--- a/JodaTime/src/java/org/joda/time/chrono/GJYearOfEraDateTimeField.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/GJYearOfEraDateTimeField.java\n package org.joda.time.chrono;\n \n import org.joda.time.DateTimeField;\n+import org.joda.time.DateTimeFieldType;\n import org.joda.time.ReadablePartial;\n import org.joda.time.field.DecoratedDateTimeField;\n import org.joda.time.field.FieldUtils;\n      * Restricted constructor.\n      */\n     GJYearOfEraDateTimeField(DateTimeField yearField, BaseGJChronology chronology) {\n-        super(yearField, \"yearOfEra\");\n+        super(yearField, DateTimeFieldType.yearOfEra());\n         iChronology = chronology;\n     }\n \n--- a/JodaTime/src/java/org/joda/time/chrono/ISOChronology.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/ISOChronology.java\n import java.util.Map;\n \n import org.joda.time.Chronology;\n+import org.joda.time.DateTimeFieldType;\n import org.joda.time.DateTimeZone;\n import org.joda.time.field.DividedDateTimeField;\n import org.joda.time.field.RemainderDateTimeField;\n     protected void assemble(Fields fields) {\n         if (getBase().getZone() == DateTimeZone.UTC) {\n             // Use zero based century and year of century.\n-            fields.centuryOfEra = new DividedDateTimeField\n-                (ISOYearOfEraDateTimeField.INSTANCE, \"centuryOfEra\", \"centuries\", 100);\n-            fields.yearOfCentury = new RemainderDateTimeField\n-                ((DividedDateTimeField)fields.centuryOfEra, \"yearOfCentury\");\n+            fields.centuryOfEra = new DividedDateTimeField(\n+                ISOYearOfEraDateTimeField.INSTANCE, DateTimeFieldType.centuryOfEra(), \"centuries\", 100);\n+            fields.yearOfCentury = new RemainderDateTimeField(\n+                (DividedDateTimeField) fields.centuryOfEra, DateTimeFieldType.yearOfCentury());\n \n             fields.centuries = fields.centuryOfEra.getDurationField();\n         }\n--- a/JodaTime/src/java/org/joda/time/chrono/ISOYearOfEraDateTimeField.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/ISOYearOfEraDateTimeField.java\n package org.joda.time.chrono;\n \n import org.joda.time.DateTimeField;\n+import org.joda.time.DateTimeFieldType;\n import org.joda.time.ReadablePartial;\n import org.joda.time.field.DecoratedDateTimeField;\n import org.joda.time.field.FieldUtils;\n      * Restricted constructor.\n      */\n     private ISOYearOfEraDateTimeField() {\n-        super(GregorianChronology.getInstanceUTC().year(), \"yearOfEra\");\n+        super(GregorianChronology.getInstanceUTC().year(), DateTimeFieldType.yearOfEra());\n     }\n \n     public int get(long instant) {\n--- a/JodaTime/src/java/org/joda/time/chrono/LimitChronology.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/LimitChronology.java\n                            DurationField durationField,\n                            DurationField rangeDurationField,\n                            DurationField leapDurationField) {\n-            super(field, field.getName());\n+            super(field, field.getType());\n             iDurationField = durationField;\n             iRangeDurationField = rangeDurationField;\n             iLeapDurationField = leapDurationField;\n--- a/JodaTime/src/java/org/joda/time/chrono/ZonedChronology.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/ZonedChronology.java\n                            DurationField durationField,\n                            DurationField rangeDurationField,\n                            DurationField leapDurationField) {\n-            super(field.getName());\n+            super(field.getType());\n             if (!field.isSupported()) {\n                 throw new IllegalArgumentException();\n             }\n--- a/JodaTime/src/java/org/joda/time/field/BaseDateTimeField.java\n+++ b/JodaTime/src/java/org/joda/time/field/BaseDateTimeField.java\n  */\n package org.joda.time.field;\n \n-import java.io.Serializable;\n import java.util.Locale;\n \n import org.joda.time.DateTimeField;\n+import org.joda.time.DateTimeFieldType;\n import org.joda.time.DurationField;\n import org.joda.time.ReadablePartial;\n \n  * @since 1.0\n  * @see DecoratedDateTimeField\n  */\n-public abstract class BaseDateTimeField extends DateTimeField implements Serializable {\n-\n-    /** Serialization version */\n-    private static final long serialVersionUID = -4388055220581798589L;\n-\n-    /** A desriptive name for the field */\n-    private final String iName;\n+public abstract class BaseDateTimeField extends DateTimeField {\n+\n+    /** The field type. */\n+    private final DateTimeFieldType iType;\n \n     /**\n      * Constructor.\n      */\n-    protected BaseDateTimeField(String name) {\n+    protected BaseDateTimeField(DateTimeFieldType type) {\n         super();\n-        if (name == null) {\n-            throw new IllegalArgumentException(\"The name must not be null\");\n-        }\n-        iName = name;\n+        if (type == null) {\n+            throw new IllegalArgumentException(\"The type must not be null\");\n+        }\n+        iType = type;\n     }\n     \n+    public final DateTimeFieldType getType() {\n+        return iType;\n+    }\n+\n     public final String getName() {\n-        return iName;\n+        return iType.getName();\n     }\n \n     /**\n--- a/JodaTime/src/java/org/joda/time/field/DecoratedDateTimeField.java\n+++ b/JodaTime/src/java/org/joda/time/field/DecoratedDateTimeField.java\n package org.joda.time.field;\n \n import org.joda.time.DateTimeField;\n+import org.joda.time.DateTimeFieldType;\n import org.joda.time.DurationField;\n \n /**\n      * Constructor.\n      * \n      * @param field  the field being decorated\n-     * @param name  allow name to be overridden\n+     * @param type  allow type to be overridden\n      */\n-    protected DecoratedDateTimeField(DateTimeField field, String name) {\n-        super(name);\n+    protected DecoratedDateTimeField(DateTimeField field, DateTimeFieldType type) {\n+        super(type);\n         if (field == null) {\n             throw new IllegalArgumentException(\"The field must not be null\");\n         }\n--- a/JodaTime/src/java/org/joda/time/field/DelegatedDateTimeField.java\n+++ b/JodaTime/src/java/org/joda/time/field/DelegatedDateTimeField.java\n import java.io.Serializable;\n import java.util.Locale;\n import org.joda.time.DateTimeField;\n+import org.joda.time.DateTimeFieldType;\n import org.joda.time.DurationField;\n import org.joda.time.ReadablePartial;\n \n \n     /** The DateTimeField being wrapped */\n     private final DateTimeField iField;\n-    /** A desriptive name for the field */\n-    private final String iName;\n+    /** The override field type */\n+    private final DateTimeFieldType iType;\n \n     /**\n      * Constructor.\n      * Constructor.\n      * \n      * @param field  the field being decorated\n-     * @param name  the name of the field\n+     * @param type  the field type override\n      */\n-    protected DelegatedDateTimeField(DateTimeField field, String name) {\n+    protected DelegatedDateTimeField(DateTimeField field, DateTimeFieldType type) {\n         super();\n         if (field == null) {\n             throw new IllegalArgumentException(\"The field must not be null\");\n         }\n         iField = field;\n-        iName = name;\n+        iType = (type == null ? field.getType() : type);\n     }\n \n     /**\n         return iField;\n     }\n \n+    public DateTimeFieldType getType() {\n+        return iType;\n+    }\n+\n     public String getName() {\n-        return (iName == null) ? iField.getName() : iName;\n+        return iType.getName();\n     }\n \n     public boolean isSupported() {\n     }\n \n     public String toString() {\n-        return (iName == null) ? iField.toString() :\n-            (\"DateTimeField[\" + iName + ']');\n+        return (\"DateTimeField[\" + getName() + ']');\n     }\n \n }\n--- a/JodaTime/src/java/org/joda/time/field/DividedDateTimeField.java\n+++ b/JodaTime/src/java/org/joda/time/field/DividedDateTimeField.java\n package org.joda.time.field;\n \n import org.joda.time.DateTimeField;\n+import org.joda.time.DateTimeFieldType;\n import org.joda.time.DurationField;\n \n /**\n      * Constructor.\n      * \n      * @param field  the field to wrap, like \"year()\".\n-     * @param name  short, descriptive name, like \"century\".\n+     * @param type  the field type this field will actually use\n      * @param durationName  short, descriptive name, like \"centuries\".\n      * @param divisor  divisor, such as 100 years in a century\n      * @throws IllegalArgumentException if divisor is less than two\n      */\n     public DividedDateTimeField(DateTimeField field,\n-                                String name, String durationName, int divisor) {\n-        super(field, name);\n+                                DateTimeFieldType type, String durationName, int divisor) {\n+        super(field, type);\n                 \n         if (divisor < 2) {\n             throw new IllegalArgumentException(\"The divisor must be at least 2\");\n      * RemainderDateTimeField.\n      *\n      * @param remainderField  complimentary remainder field, like \"yearOfCentury()\".\n-     * @param name  short, descriptive name, like \"century\".\n-     */\n-    public DividedDateTimeField(RemainderDateTimeField remainderField, String name) {\n-        super(remainderField.getWrappedField(), name);\n+     * @param type  the field type this field will actually use\n+     */\n+    public DividedDateTimeField(RemainderDateTimeField remainderField, DateTimeFieldType type) {\n+        super(remainderField.getWrappedField(), type);\n         int divisor = iDivisor = remainderField.iDivisor;\n         iDurationField = remainderField.iRangeField;\n \n--- a/JodaTime/src/java/org/joda/time/field/ImpreciseDateTimeField.java\n+++ b/JodaTime/src/java/org/joda/time/field/ImpreciseDateTimeField.java\n  */\n package org.joda.time.field;\n \n+import org.joda.time.DateTimeFieldType;\n import org.joda.time.DurationField;\n \n /**\n     /**\n      * Constructor.\n      * \n-     * @param name  short, descriptive name, like \"monthOfYear\".\n+     * @param type  the field type\n      * @param durationName  short, descriptive name, like \"months\".\n      * @param unitMillis  the average duration unit milliseconds\n      */\n-    public ImpreciseDateTimeField(String name, String durationName, long unitMillis) {\n-        super(name);\n+    public ImpreciseDateTimeField(DateTimeFieldType type, String durationName, long unitMillis) {\n+        super(type);\n         iUnitMillis = unitMillis;\n         iDurationField = new LinkedDurationField(durationName);\n     }\n--- a/JodaTime/src/java/org/joda/time/field/NonZeroDateTimeField.java\n+++ b/JodaTime/src/java/org/joda/time/field/NonZeroDateTimeField.java\n package org.joda.time.field;\n \n import org.joda.time.DateTimeField;\n+import org.joda.time.DateTimeFieldType;\n import org.joda.time.DurationField;\n import org.joda.time.ReadablePartial;\n \n     private static final long serialVersionUID = 961749798233026866L;\n \n     /**\n-     * @param name  short, descriptive name, like \"clockhourOfDay\".\n+     * Constructor.\n+     * \n+     * @param field  the base field\n+     * @param type  the field type this field will actually use\n      * @throws IllegalArgumentException if wrapped field's minimum value is not zero\n      */\n-    public NonZeroDateTimeField(DateTimeField field, String name) {\n-        super(field, name);\n+    public NonZeroDateTimeField(DateTimeField field, DateTimeFieldType type) {\n+        super(field, type);\n         if (field.getMinimumValue() != 0) {\n             throw new IllegalArgumentException(\"Wrapped field's minumum value must be zero\");\n         }\n--- a/JodaTime/src/java/org/joda/time/field/OffsetDateTimeField.java\n+++ b/JodaTime/src/java/org/joda/time/field/OffsetDateTimeField.java\n package org.joda.time.field;\n \n import org.joda.time.DateTimeField;\n+import org.joda.time.DateTimeFieldType;\n import org.joda.time.DurationField;\n \n /**\n     private final int iMax;\n \n     /**\n-     * Constructor\n+     * Constructor.\n      * \n      * @param field  the field to wrap, like \"year()\".\n-     * @param name  short, descriptive name, like \"offsetYear\".\n      * @param offset  offset to add to field values\n      * @throws IllegalArgumentException if offset is zero\n      */\n-    public OffsetDateTimeField(DateTimeField field, String name, int offset) {\n-        this(field, name, offset, Integer.MIN_VALUE, Integer.MAX_VALUE);\n-    }\n-\n-    /**\n-     * Constructor\n+    public OffsetDateTimeField(DateTimeField field, int offset) {\n+        this(field, field.getType(), offset, Integer.MIN_VALUE, Integer.MAX_VALUE);\n+    }\n+\n+    /**\n+     * Constructor.\n      * \n      * @param field  the field to wrap, like \"year()\".\n-     * @param name  short, descriptive name, like \"offsetYear\".\n+     * @param type  the field type this field actually uses\n+     * @param offset  offset to add to field values\n+     * @throws IllegalArgumentException if offset is zero\n+     */\n+    public OffsetDateTimeField(DateTimeField field, DateTimeFieldType type, int offset) {\n+        this(field, type, offset, Integer.MIN_VALUE, Integer.MAX_VALUE);\n+    }\n+\n+    /**\n+     * Constructor.\n+     * \n+     * @param field  the field to wrap, like \"year()\".\n+     * @param type  the field type this field actually uses\n      * @param offset  offset to add to field values\n      * @param minValue  minimum allowed value\n      * @param maxValue  maximum allowed value\n      * @throws IllegalArgumentException if offset is zero\n      */\n-    public OffsetDateTimeField(DateTimeField field, String name, int offset,\n+    public OffsetDateTimeField(DateTimeField field, DateTimeFieldType type, int offset,\n                                int minValue, int maxValue) {\n-        super(field, name);\n+        super(field, type);\n                 \n         if (offset == 0) {\n             throw new IllegalArgumentException(\"The offset cannot be zero\");\n--- a/JodaTime/src/java/org/joda/time/field/PreciseDateTimeField.java\n+++ b/JodaTime/src/java/org/joda/time/field/PreciseDateTimeField.java\n  */\n package org.joda.time.field;\n \n+import org.joda.time.DateTimeFieldType;\n import org.joda.time.DurationField;\n \n /**\n     /**\n      * Constructor.\n      * \n-     * @param name  short, descriptive name, like \"secondOfMinute\".\n+     * @param type  the field type this field uses\n      * @param unit  precise unit duration, like \"seconds()\".\n      * @param range precise range duration, preferably a multiple of the unit,\n      * like \"minutes()\".\n      * @throws IllegalArgumentException if unit milliseconds is less than one\n      * or effective value range is less than two.\n      */\n-    public PreciseDateTimeField(String name,\n+    public PreciseDateTimeField(DateTimeFieldType type,\n                                 DurationField unit, DurationField range) {\n-        super(name, unit);\n+        super(type, unit);\n \n         if (!range.isPrecise()) {\n             throw new IllegalArgumentException(\"Range duration field must be precise\");\n--- a/JodaTime/src/java/org/joda/time/field/PreciseDurationDateTimeField.java\n+++ b/JodaTime/src/java/org/joda/time/field/PreciseDurationDateTimeField.java\n  */\n package org.joda.time.field;\n \n+import org.joda.time.DateTimeFieldType;\n import org.joda.time.DurationField;\n \n /**\n     /**\n      * Constructor.\n      * \n-     * @param name  short, descriptive name, like \"dayOfMonth\".\n+     * @param type  the field type\n      * @param unit  precise unit duration, like \"days()\".\n      * @throws IllegalArgumentException if duration field is imprecise\n      * @throws IllegalArgumentException if unit milliseconds is less than one\n      */\n-    public PreciseDurationDateTimeField(String name, DurationField unit) {\n-        super(name);\n+    public PreciseDurationDateTimeField(DateTimeFieldType type, DurationField unit) {\n+        super(type);\n \n         if (!unit.isPrecise()) {\n             throw new IllegalArgumentException(\"Unit duration field must be precise\");\n--- a/JodaTime/src/java/org/joda/time/field/RemainderDateTimeField.java\n+++ b/JodaTime/src/java/org/joda/time/field/RemainderDateTimeField.java\n package org.joda.time.field;\n \n import org.joda.time.DateTimeField;\n+import org.joda.time.DateTimeFieldType;\n import org.joda.time.DurationField;\n \n /**\n      * Constructor.\n      * \n      * @param field  the field to wrap, like \"year()\".\n-     * @param name  short, descriptive name, like \"yearOfCentury\".\n+     * @param type  the field type this field actually uses\n      * @param rangeName  short, descriptive name, like \"centuries\".\n      * @param divisor  divisor, such as 100 years in a century\n      * @throws IllegalArgumentException if divisor is less than two\n      */\n     public RemainderDateTimeField(DateTimeField field,\n-                                  String name, String rangeName, int divisor) {\n-        super(field, name);\n+                                  DateTimeFieldType type, String rangeName, int divisor) {\n+        super(field, type);\n \n         if (divisor < 2) {\n             throw new IllegalArgumentException(\"The divisor must be at least 2\");\n      * DividedDateTimeField.\n      *\n      * @param dividedField  complimentary divided field, like \"century()\".\n-     * @param name  short, descriptive name, like \"yearOfCentury\".\n-     */\n-    public RemainderDateTimeField(DividedDateTimeField dividedField, String name) {\n-        super(dividedField.getWrappedField(), name);\n+     */\n+    public RemainderDateTimeField(DividedDateTimeField dividedField) {\n+        this(dividedField, dividedField.getType());\n+    }\n+\n+    /**\n+     * Construct a RemainderDateTimeField that compliments the given\n+     * DividedDateTimeField.\n+     *\n+     * @param dividedField  complimentary divided field, like \"century()\".\n+     * @param type  the field type this field actually uses\n+     */\n+    public RemainderDateTimeField(DividedDateTimeField dividedField, DateTimeFieldType type) {\n+        super(dividedField.getWrappedField(), type);\n         iDivisor = dividedField.iDivisor;\n         iRangeField = dividedField.iDurationField;\n     }\n \n+    //-----------------------------------------------------------------------\n     /**\n      * Get the remainder from the specified time instant.\n      * \n--- a/JodaTime/src/java/org/joda/time/field/UnsupportedDateTimeField.java\n+++ b/JodaTime/src/java/org/joda/time/field/UnsupportedDateTimeField.java\n import java.util.HashMap;\n import java.util.Locale;\n import org.joda.time.DateTimeField;\n+import org.joda.time.DateTimeFieldType;\n import org.joda.time.DurationField;\n import org.joda.time.ReadablePartial;\n \n      * @throws IllegalArgumentException if durationField is null\n      */\n     public static synchronized UnsupportedDateTimeField getInstance(\n-            String name, DurationField durationField) {\n+            DateTimeFieldType type, DurationField durationField) {\n \n         UnsupportedDateTimeField field;\n         if (cCache == null) {\n             cCache = new HashMap(7);\n             field = null;\n         } else {\n-            field = (UnsupportedDateTimeField)cCache.get(name);\n+            field = (UnsupportedDateTimeField)cCache.get(type);\n             if (field != null && field.getDurationField() != durationField) {\n                 field = null;\n             }\n         }\n         if (field == null) {\n-            field = new UnsupportedDateTimeField(name, durationField);\n-            cCache.put(name, field);\n+            field = new UnsupportedDateTimeField(type, durationField);\n+            cCache.put(type, field);\n         }\n         return field;\n     }\n \n-    /** The name of the datetime field */\n-    private final String iName;\n+    /** The field type */\n+    private final DateTimeFieldType iType;\n     /** The duration of the datetime field */\n     private final DurationField iDurationField;\n \n     /**\n      * Constructor.\n      * \n-     * @param name  the name to use\n+     * @param type  the field type\n      * @param durationField  the duration to use\n      */\n-    private UnsupportedDateTimeField(String name, DurationField durationField) {\n-        if (durationField == null) {\n+    private UnsupportedDateTimeField(DateTimeFieldType type, DurationField durationField) {\n+        if (type == null || durationField == null) {\n             throw new IllegalArgumentException();\n         }\n-        iName = name;\n+        iType = type;\n         iDurationField = durationField;\n     }\n \n     // Design note: Simple accessors return a suitable value, but methods\n     // intended to perform calculations throw an UnsupportedOperationException.\n \n+    public DateTimeFieldType getType() {\n+        return iType;\n+    }\n+\n     public String getName() {\n-        return iName;\n+        return iType.getName();\n     }\n \n     /**\n      * Ensure proper singleton serialization\n      */\n     private Object readResolve() {\n-        return getInstance(iName, iDurationField);\n+        return getInstance(iType, iDurationField);\n     }\n \n     private UnsupportedOperationException unsupported() {\n-        return new UnsupportedOperationException(iName + \" field is unsupported\");\n+        return new UnsupportedOperationException(iType + \" field is unsupported\");\n     }\n \n }\n--- a/JodaTime/src/java/org/joda/time/format/DateTimeFormat.java\n+++ b/JodaTime/src/java/org/joda/time/format/DateTimeFormat.java\n import org.joda.time.Chronology;\n import org.joda.time.DateTime;\n import org.joda.time.DateTimeField;\n+import org.joda.time.DateTimeFieldType;\n import org.joda.time.DateTimeZone;\n import org.joda.time.MutableDateTime;\n import org.joda.time.ReadWritableInstant;\n                     switch (c) {\n                     case 'x':\n                         field = new RemainderDateTimeField\n-                            (chronoUTC.weekyear(), \"weekyearOfCentury\", \"centuries\", 100);\n+                            (chronoUTC.weekyear(), DateTimeFieldType.weekyearOfCentury(), \"centuries\", 100);\n                         break;\n                     case 'y': default:\n                         field = new RemainderDateTimeField\n-                            (chronoUTC.year(), \"yearOfCentury\", \"centuries\", 100);\n+                            (chronoUTC.year(), DateTimeFieldType.yearOfCentury(), \"centuries\", 100);\n                         break;\n                     case 'Y':\n                         field = new RemainderDateTimeField\n-                            (chronoUTC.yearOfEra(), \"yearOfCentury\", \"centuries\", 100);\n+                            (chronoUTC.yearOfEra(), DateTimeFieldType.yearOfCentury(), \"centuries\", 100);\n                         break;\n                     }\n                     builder.appendDecimal(field, 2, 2);\n--- a/JodaTime/src/java/org/joda/time/format/DateTimeFormatterBuilder.java\n+++ b/JodaTime/src/java/org/joda/time/format/DateTimeFormatterBuilder.java\n import org.joda.time.Chronology;\n import org.joda.time.DateTimeConstants;\n import org.joda.time.DateTimeField;\n+import org.joda.time.DateTimeFieldType;\n import org.joda.time.DateTimeZone;\n import org.joda.time.ReadablePartial;\n import org.joda.time.field.MillisDurationField;\n \n             if (iParseField == null) {\n                 iParseField = new PreciseDateTimeField\n-                    (\"\", MillisDurationField.INSTANCE, iField.getDurationField());\n+                    (DateTimeFieldType.millisOfSecond(), MillisDurationField.INSTANCE, iField.getDurationField());\n             }\n \n             bucket.saveField(iParseField, (int)value);\n--- a/JodaTime/src/test/org/joda/time/chrono/gj/TestGJDateTimeField.java\n+++ b/JodaTime/src/test/org/joda/time/chrono/gj/TestGJDateTimeField.java\n  */\n package org.joda.time.chrono.gj;\n \n+import org.joda.time.DateTimeFieldType;\n import org.joda.time.field.ImpreciseDateTimeField;\n \n /**\n abstract class TestGJDateTimeField extends ImpreciseDateTimeField {\n     protected final TestGJChronology iChronology;\n \n-    public TestGJDateTimeField(String name, String duratioName,\n+    public TestGJDateTimeField(DateTimeFieldType type, String duratioName,\n                                long unitMillis, TestGJChronology chrono) {\n-        super(name, duratioName, unitMillis);\n+        super(type, duratioName, unitMillis);\n         iChronology = chrono;\n     }\n \n--- a/JodaTime/src/test/org/joda/time/chrono/gj/TestGJDayOfMonthField.java\n+++ b/JodaTime/src/test/org/joda/time/chrono/gj/TestGJDayOfMonthField.java\n  */\n package org.joda.time.chrono.gj;\n \n+import org.joda.time.DateTimeFieldType;\n import org.joda.time.DurationField;\n \n /**\n  */\n class TestGJDayOfMonthField extends TestGJDateTimeField {\n     public TestGJDayOfMonthField(TestGJChronology chrono) {\n-        super(\"dayOfMonth\", \"days\", chrono.MILLIS_PER_DAY, chrono);\n+        super(DateTimeFieldType.dayOfMonth(), \"days\", chrono.MILLIS_PER_DAY, chrono);\n     }\n \n     public int get(long millis) {\n--- a/JodaTime/src/test/org/joda/time/chrono/gj/TestGJDayOfWeekField.java\n+++ b/JodaTime/src/test/org/joda/time/chrono/gj/TestGJDayOfWeekField.java\n  */\n package org.joda.time.chrono.gj;\n \n+import org.joda.time.DateTimeFieldType;\n import org.joda.time.DurationField;\n \n /**\n  */\n class TestGJDayOfWeekField extends TestGJDateTimeField {\n     public TestGJDayOfWeekField(TestGJChronology chrono) {\n-        super(\"dayOfWeek\", \"days\", chrono.MILLIS_PER_DAY, chrono);\n+        super(DateTimeFieldType.dayOfWeek(), \"days\", chrono.MILLIS_PER_DAY, chrono);\n     }\n \n     public int get(long millis) {\n--- a/JodaTime/src/test/org/joda/time/chrono/gj/TestGJDayOfYearField.java\n+++ b/JodaTime/src/test/org/joda/time/chrono/gj/TestGJDayOfYearField.java\n  */\n package org.joda.time.chrono.gj;\n \n+import org.joda.time.DateTimeFieldType;\n import org.joda.time.DurationField;\n \n /**\n  */\n class TestGJDayOfYearField extends TestGJDateTimeField {\n     public TestGJDayOfYearField(TestGJChronology chrono) {\n-        super(\"dayOfYear\", \"days\", chrono.MILLIS_PER_DAY, chrono);\n+        super(DateTimeFieldType.dayOfYear(), \"days\", chrono.MILLIS_PER_DAY, chrono);\n     }\n \n     public int get(long millis) {\n--- a/JodaTime/src/test/org/joda/time/chrono/gj/TestGJMonthOfYearField.java\n+++ b/JodaTime/src/test/org/joda/time/chrono/gj/TestGJMonthOfYearField.java\n  */\n package org.joda.time.chrono.gj;\n \n+import org.joda.time.DateTimeFieldType;\n import org.joda.time.DurationField;\n \n /**\n  */\n class TestGJMonthOfYearField extends TestGJDateTimeField {\n     public TestGJMonthOfYearField(TestGJChronology chrono) {\n-        super(\"monthOfYear\", \"months\", chrono.millisPerMonth(), chrono);\n+        super(DateTimeFieldType.monthOfYear(), \"months\", chrono.millisPerMonth(), chrono);\n     }\n \n     public int get(long millis) {\n--- a/JodaTime/src/test/org/joda/time/chrono/gj/TestGJWeekOfWeekyearField.java\n+++ b/JodaTime/src/test/org/joda/time/chrono/gj/TestGJWeekOfWeekyearField.java\n  */\n package org.joda.time.chrono.gj;\n \n+import org.joda.time.DateTimeFieldType;\n import org.joda.time.DurationField;\n \n /**\n  */\n class TestGJWeekOfWeekyearField extends TestGJDateTimeField {\n     public TestGJWeekOfWeekyearField(TestGJChronology chrono) {\n-        super(\"weekOfWeekyear\", \"weeks\",\n+        super(DateTimeFieldType.weekOfWeekyear(), \"weeks\",\n               (long)(chrono.MILLIS_PER_DAY * 7), chrono);\n     }\n \n--- a/JodaTime/src/test/org/joda/time/chrono/gj/TestGJWeekyearField.java\n+++ b/JodaTime/src/test/org/joda/time/chrono/gj/TestGJWeekyearField.java\n  */\n package org.joda.time.chrono.gj;\n \n+import org.joda.time.DateTimeFieldType;\n import org.joda.time.DurationField;\n \n /**\n  */\n class TestGJWeekyearField extends TestGJDateTimeField {\n     public TestGJWeekyearField(TestGJChronology chrono) {\n-        super(\"weekyear\", \"weekyears\", chrono.millisPerYear(), chrono);\n+        super(DateTimeFieldType.weekyear(), \"weekyears\", chrono.millisPerYear(), chrono);\n     }\n \n     public int get(long millis) {\n--- a/JodaTime/src/test/org/joda/time/chrono/gj/TestGJYearField.java\n+++ b/JodaTime/src/test/org/joda/time/chrono/gj/TestGJYearField.java\n  */\n package org.joda.time.chrono.gj;\n \n+import org.joda.time.DateTimeFieldType;\n import org.joda.time.DurationField;\n \n /**\n  */\n class TestGJYearField extends TestGJDateTimeField {\n     public TestGJYearField(TestGJChronology chrono) {\n-        super(\"year\", \"years\", chrono.millisPerYear(), chrono);\n+        super(DateTimeFieldType.year(), \"years\", chrono.millisPerYear(), chrono);\n     }\n \n     public int get(long millis) {", "timestamp": 1094161251, "metainfo": ""}