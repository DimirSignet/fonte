{"sha": "ff3b9827639c59940312d50919b5c2484b4ee16f", "log": "Removed old code to support partials. ReadWritableInstant supports rounding.   ", "commit": "\n--- a/JodaTime/src/java/org/joda/time/AbstractDateTime.java\n+++ b/JodaTime/src/java/org/joda/time/AbstractDateTime.java\n      * @return the number of milliseconds since 1970-01-01T00:00:00Z\n      */\n     public final long getMillis() {\n-        return iMillis;\n-    }\n-\n-    /**\n-     * Gets the milliseconds of the datetime instant from the Java epoch\n-     * of 1970-01-01T00:00:00Z.\n-     * \n-     * @param base ignored\n-     * @return the number of milliseconds since 1970-01-01T00:00:00Z\n-     */\n-    public final long getMillis(ReadableInstant base) {\n-        return iMillis;\n-    }\n-\n-    /**\n-     * Gets the milliseconds of the datetime instant from the Java epoch\n-     * of 1970-01-01T00:00:00Z.\n-     * \n-     * @param base ignored\n-     * @param zone ignored\n-     * @return the number of milliseconds since 1970-01-01T00:00:00Z\n-     */\n-    public final long getMillis(ReadableInstant base, DateTimeZone zone) {\n         return iMillis;\n     }\n \n--- a/JodaTime/src/java/org/joda/time/AbstractInstant.java\n+++ b/JodaTime/src/java/org/joda/time/AbstractInstant.java\n     /**\n      * Get this object as an Instant.\n      * \n-     * @return an Instant using the same millis, unless partially specified\n+     * @return an Instant using the same millis\n      */\n     public final Instant toInstant() {\n         if (this instanceof Instant) {\n     }\n \n     /**\n-     * Get this object as an Instant, using the given base instant to supply\n-     * missing field values.\n-     * \n-     * @param base source of missing fields\n-     * @return a new Instant\n-     */\n-    public final Instant toInstant(ReadableInstant base) {\n-        return new Instant(getMillis(base, null));\n-    }\n-\n-    /**\n      * Get this object as a DateTime.\n      * \n-     * @return a DateTime using the same millis, unless partially specified\n+     * @return a DateTime using the same millis\n      */\n     public final DateTime toDateTime() {\n         if (this instanceof DateTime) {\n      * Get this object as a DateTime.\n      * \n      * @param zone time zone to apply, or default if null\n-     * @return a DateTime using the same millis, unless partially specified\n+     * @return a DateTime using the same millis\n      */\n     public final DateTime toDateTime(DateTimeZone zone) {\n         if (zone == null) {\n      * Get this object as a DateTime.\n      * \n      * @param chronology chronology to apply, or ISOChronology if null\n-     * @return a DateTime using the same millis, unless partially specified\n+     * @return a DateTime using the same millis\n      */\n     public final DateTime toDateTime(Chronology chronology) {\n         if (chronology == null) {\n             return (DateTime) this;\n         }\n         return new DateTime(this, chronology);\n-    }\n-\n-    /**\n-     * Convert this object into a DateTime, using the given base instant to\n-     * supply missing field values and time zone.\n-     * \n-     * @param base source of missing fields\n-     * @return a new DateTime\n-     */\n-    public final DateTime toDateTime(ReadableInstant base) {\n-        if (base == null) {\n-            return new DateTime(this);\n-        }\n-        DateTimeZone zone = base.getZone();\n-        if (zone == null) {\n-            zone = DateTimeZone.getDefault();\n-        }\n-        return new DateTime(getMillis(base), getChronology().withZone(zone));\n-    }\n-\n-    /**\n-     * Convert this object into a DateTime, using the given base instant to\n-     * supply missing field values.\n-     * \n-     * @param base source of missing fields\n-     * @param zone  time zone to apply, or default if null\n-     * @return a new DateTime\n-     */\n-    public final DateTime toDateTime(ReadableInstant base, DateTimeZone zone) {\n-        if (base == null) {\n-            return new DateTime(this, zone);\n-        }\n-        if (zone == null) {\n-            zone = DateTimeZone.getDefault();\n-        }\n-        return new DateTime(getMillis(base, zone), getChronology().withZone(zone));\n-    }\n-\n-    /**\n-     * Convert this object into a DateTime, using the given base instant to\n-     * supply missing field values.\n-     * \n-     * @param base source of missing fields\n-     * @param chronology  chronology to apply, or ISOChronology if null\n-     * @return a new DateTime\n-     */\n-    public final DateTime toDateTime(ReadableInstant base, Chronology chronology) {\n-        if (base == null) {\n-            return new DateTime(this, chronology);\n-        }\n-        if (chronology == null) {\n-            chronology = ISOChronology.getInstance();\n-        }\n-        return new DateTime(getMillis(base, chronology.getZone()), chronology);\n     }\n \n     /**\n      * {@link org.joda.time.tz.Provider provider}, then this object is cast to\n      * a DateTime and returned. Otherwise, a new trusted DateTime is returned.\n      * \n-     * @return a trusted ISO DateTime using the same millis, unless partially specified\n+     * @return a trusted ISO DateTime using the same millis\n      * @throws IllegalArgumentException if the time zone is not trusted, and\n      * no matching trusted time zone can be found.\n      */\n     /**\n      * Get this object as a MutableDateTime.\n      * \n-     * @return a MutableDateTime using the same millis, unless partially specified\n+     * @return a MutableDateTime using the same millis\n      */\n     public final MutableDateTime toMutableDateTime() {\n         return new MutableDateTime(this);\n      * Get this object as a MutableDateTime.\n      * \n      * @param zone time zone to apply, or default if null\n-     * @return a MutableDateTime using the same millis, unless partially specified\n+     * @return a MutableDateTime using the same millis\n      */\n     public final MutableDateTime toMutableDateTime(DateTimeZone zone) {\n         if (zone == null) {\n      * Get this object as a MutableDateTime.\n      * \n      * @param chronology chronology to apply, or ISOChronology if null\n-     * @return a MutableDateTime using the same millis, unless partially specified\n+     * @return a MutableDateTime using the same millis\n      */\n     public final MutableDateTime toMutableDateTime(Chronology chronology) {\n         if (chronology == null) {\n             chronology = ISOChronology.getInstance();\n         }\n         return new MutableDateTime(this, chronology);\n-    }\n-\n-    /**\n-     * Convert this object into a MutableDateTime, using the given base instant\n-     * to supply missing field values and time zone.\n-     * \n-     * @param base source of missing fields\n-     * @return a new MutableDateTime\n-     */\n-    public final MutableDateTime toMutableDateTime(ReadableInstant base) {\n-        if (base == null) {\n-            return new MutableDateTime(this);\n-        }\n-        DateTimeZone zone = base.getZone();\n-        if (zone == null) {\n-            zone = DateTimeZone.getDefault();\n-        }\n-        return new MutableDateTime(getMillis(base), getChronology().withZone(zone));\n-    }\n-\n-    /**\n-     * Convert this object into a MutableDateTime, using the given base instant\n-     * to supply missing field values.\n-     * \n-     * @param base source of missing fields\n-     * @param zone  time zone to apply, or default if null\n-     * @return a new MutableDateTime\n-     */\n-    public final MutableDateTime toMutableDateTime(ReadableInstant base, DateTimeZone zone) {\n-        if (base == null) {\n-            return new MutableDateTime(this, zone);\n-        }\n-        if (zone == null) {\n-            zone = DateTimeZone.getDefault();\n-        }\n-        return new MutableDateTime(getMillis(base, zone), getChronology().withZone(zone));\n-    }\n-\n-    /**\n-     * Convert this object into a MutableDateTime, using the given base instant\n-     * to supply missing field values.\n-     * \n-     * @param base source of missing fields\n-     * @param chronology  chronology to apply, or ISOChronology if null\n-     * @return a new MutableDateTime\n-     */\n-    public final MutableDateTime toMutableDateTime(ReadableInstant base, Chronology chronology) {\n-        if (base == null) {\n-            return new MutableDateTime(this, chronology);\n-        }\n-        if (chronology == null) {\n-            chronology = ISOChronology.getInstance();\n-        }\n-        return new MutableDateTime(getMillis(base, chronology.getZone()), chronology);\n-    }\n-\n-    /**\n-     * Get this object as a DateOnly.\n-     * \n-     * @return a DateOnly using the same millis, unless partially specified\n-     */\n-    public final DateOnly toDateOnly() {\n-        if (this instanceof DateOnly) {\n-            return (DateOnly) this;\n-        }\n-        return new DateOnly(this);\n-    }\n-\n-    /**\n-     * Get this object as a DateOnly.\n-     * \n-     * @param chronology chronology to apply, or ISOChronology if null\n-     * @return a DateOnly using the same millis, unless partially specified\n-     */\n-    public final DateOnly toDateOnly(Chronology chronology) {\n-        if (chronology == null) {\n-            chronology = ISOChronology.getInstance();\n-        }\n-        if (this instanceof DateOnly) {\n-            DateOnly d = (DateOnly) this;\n-            if (d.getChronology() == chronology.withUTC()) {\n-                return d;\n-            }\n-        }\n-        return new DateOnly(this, chronology);\n-    }\n-\n-    /**\n-     * Get this object as a TimeOnly.\n-     * \n-     * @return a TimeOnly using the same millis, unless partially specified\n-     */\n-    public final TimeOnly toTimeOnly() {\n-        if (this instanceof TimeOnly) {\n-            return (TimeOnly) this;\n-        }\n-        return new TimeOnly(this);\n-    }\n-\n-    /**\n-     * Get this object as a TimeOnly.\n-     * \n-     * @param chronology chronology to apply, or ISOChronology if null\n-     * @return a TimeOnly using the same millis, unless partially specified\n-     */\n-    public final TimeOnly toTimeOnly(Chronology chronology) {\n-        if (chronology == null) {\n-            chronology = ISOChronology.getInstance();\n-        }\n-        if (this instanceof TimeOnly) {\n-            TimeOnly t = (TimeOnly) this;\n-            if (t.getChronology() == chronology.withUTC()) {\n-                return t;\n-            }\n-        }\n-        return new TimeOnly(this, chronology);\n     }\n \n     /**\n \n         ReadableInstant otherInstant = (ReadableInstant) readableInstant;\n \n-        // If instants are partial, then they can use each other to fill in\n-        // missing fields.\n-        long otherMillis = otherInstant.getMillis(this);\n-        long thisMillis = getMillis(otherInstant);\n+        long otherMillis = otherInstant.getMillis();\n+        long thisMillis = getMillis();\n \n         // cannot do (thisMillis - otherMillis) as can overflow\n         if (thisMillis == otherMillis) {\n         if (readableInstant == null) {\n             throw new IllegalArgumentException(\"The instant must not be null\");\n         }\n-        // If instants are partial, then they can use each other to fill in\n-        // missing fields.\n-        return (getMillis(readableInstant) > readableInstant.getMillis(this));\n+        return (getMillis() > readableInstant.getMillis());\n     }\n \n     /**\n         if (readableInstant == null) {\n             throw new IllegalArgumentException(\"The instant must not be null\");\n         }\n-        // If instants are partial, then they can use each other to fill in\n-        // missing fields.\n-        return (getMillis(readableInstant) < readableInstant.getMillis(this));\n+        return (getMillis() < readableInstant.getMillis());\n     }\n \n     /**\n         if (readableInstant == null) {\n             throw new IllegalArgumentException(\"The instant must not be null\");\n         }\n-        // If instants are partial, then they can use each other to fill in\n-        // missing fields.\n-        return (getMillis(readableInstant) == readableInstant.getMillis(this));\n+        return (getMillis() == readableInstant.getMillis());\n     }\n \n     // Output    \n--- a/JodaTime/src/java/org/joda/time/DateTime.java\n+++ b/JodaTime/src/java/org/joda/time/DateTime.java\n  * @author Brian S O'Neill\n  * @since 1.0\n  * @see MutableDateTime\n- * @see DateOnly\n- * @see TimeOnly\n  */\n public class DateTime extends AbstractDateTime\n         implements ReadableDateTime, Serializable {\n      * the result from this method with Europe/Paris would be 12:30 (ie. 11:30Z).\n      * <p>\n      * The returned object will be a new instance of the same implementation type.\n-     * This method changes alters the time zone and the millisecond instant to keep\n+     * This method alters the time zone and the millisecond instant to keep\n      * the field values the same.\n      * The returned object will be either be a new instance or <code>this</code>.\n      *\n--- a/JodaTime/src/java/org/joda/time/DateTimeComparator.java\n+++ b/JodaTime/src/java/org/joda/time/DateTimeComparator.java\n  * The default objects recognised by the comparator are:\n  * <ul>\n  * <li>ReadableInstant\n- * <li>PartialInstant\n  * <li>String\n  * <li>Calendar\n  * <li>Date\n         long lhsMillis, rhsMillis;\n \n         if (lhsObj instanceof ReadableInstant) {\n-            ReadableInstant lhsInstant = (ReadableInstant) lhsObj;\n-\n-            if (rhsObj instanceof ReadableInstant) {\n-                ReadableInstant rhsInstant = (ReadableInstant) rhsObj;\n-\n-                // If instants are partial, then they can use each other to\n-                // fill in missing fields.\n-                lhsMillis = lhsInstant.getMillis(rhsInstant);\n-                rhsMillis = rhsInstant.getMillis(lhsInstant);\n-            } else {\n-                lhsMillis = lhsInstant.getMillis();\n-                rhsMillis = getMillisFromObject(rhsObj);\n-            }\n+            lhsMillis = ((ReadableInstant) lhsObj).getMillis();\n         } else {\n             lhsMillis = getMillisFromObject(lhsObj);\n-\n-            if (rhsObj instanceof ReadableInstant) {\n-                rhsMillis = ((ReadableInstant) rhsObj).getMillis();\n-            } else {\n-                rhsMillis = getMillisFromObject(rhsObj);\n-            }\n+        }\n+\n+        if (rhsObj instanceof ReadableInstant) {\n+            rhsMillis = ((ReadableInstant) rhsObj).getMillis();\n+        } else {\n+            rhsMillis = getMillisFromObject(rhsObj);\n         }\n \n         DateTimeField field;\n--- a/JodaTime/src/java/org/joda/time/Instant.java\n+++ b/JodaTime/src/java/org/joda/time/Instant.java\n         implements ReadableInstant, Serializable {\n \n     /** Serialization lock */\n-\tprivate static final long serialVersionUID = 3299096530934209741L;\n+    private static final long serialVersionUID = 3299096530934209741L;\n \n     /** The millis from 1970-01-01T00:00:00Z */\n     private final long iMillis;\n     }\n \n     /**\n-     * Gets the milliseconds of the instant.\n-     *\n-     * @param base ignored\n-     * @return the number of milliseconds since 1970-01-01T00:00:00Z\n-     */\n-    public long getMillis(ReadableInstant base) {\n-        return iMillis;\n-    }\n-\n-    /**\n-     * Gets the milliseconds of the instant.\n-     *\n-     * @param base ignored\n-     * @param zone ignored\n-     * @return the number of milliseconds since 1970-01-01T00:00:00Z\n-     */\n-    public long getMillis(ReadableInstant base, DateTimeZone zone) {\n-        return iMillis;\n-    }\n-\n-    /**\n      * Gets the chronology of the instant, which is null.\n      * <p>\n      * The {@link Chronology} provides conversion from the millisecond\n--- a/JodaTime/src/java/org/joda/time/MutableDateTime.java\n+++ b/JodaTime/src/java/org/joda/time/MutableDateTime.java\n     \n     static final long serialVersionUID = 2852608688135209575L;\n \n+    private DateTimeField iRoundingField;\n+    private int iRoundingMode;\n+\n     // Constructors\n     //-----------------------------------------------------------------------\n     /**\n         super(year, monthOfYear, dayOfMonth,\n               hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond, chronology);\n     }\n-\n     \n+    public DateTimeField getRoundingField() {\n+        return iRoundingField;\n+    }\n+\n+    public int getRoundingMode() {\n+        return iRoundingMode;\n+    }\n+\n+    public void setRoundingField(DateTimeField field) {\n+        iRoundingField = field;\n+        if (field != null) {\n+            if (iRoundingMode == ROUND_NONE) {\n+                iRoundingMode = ROUND_FLOOR;\n+            }\n+            setMillis(getMillis());\n+        }\n+    }\n+\n+    public void setRoundingField(DateTimeField field, int mode) {\n+        if (mode < ROUND_NONE || mode > ROUND_HALF_EVEN) {\n+            throw new IllegalArgumentException(\"Illegal rounding mode: \" + mode);\n+        }\n+        iRoundingField = field;\n+        iRoundingMode = mode;\n+        if (field != null && mode != ROUND_NONE) {\n+            setMillis(getMillis());\n+        }\n+    }\n+\n     // Millis\n     //-----------------------------------------------------------------------\n     /**\n      * @see #setDateTime(long)\n      */\n     public void setMillis(long instant) {\n+        switch (iRoundingMode) {\n+        case ROUND_NONE:\n+            break;\n+        case ROUND_FLOOR:\n+            instant = iRoundingField.roundFloor(instant);\n+            break;\n+        case ROUND_CEILING:\n+            instant = iRoundingField.roundCeiling(instant);\n+            break;\n+        case ROUND_HALF_FLOOR:\n+            instant = iRoundingField.roundHalfFloor(instant);\n+            break;\n+        case ROUND_HALF_CEILING:\n+            instant = iRoundingField.roundHalfCeiling(instant);\n+            break;\n+        case ROUND_HALF_EVEN:\n+            instant = iRoundingField.roundHalfEven(instant);\n+            break;\n+        }\n+\n         super.setMillis(instant);\n     }\n \n         return (MutableDateTime)clone();\n     }\n \n+    // Basics\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Compares this object with the specified object for equality based on the\n+     * millisecond instant, the Chronology, and known rounding behavior.\n+     * <p>\n+     * All ReadableInstant instances are accepted.\n+     * <p>\n+     * See {@link #isEqual(ReadableInstant)} for an equals method that\n+     * ignores the Chronology and rounding behavior.\n+     *\n+     * @param readableInstant  a readable instant to check against\n+     * @return true if millisecond, Chronology, and known rounding behavior are\n+     * equal, false if not or the instant is null or of an incorrect type\n+     */\n+    public boolean equals(Object readableInstant) {\n+        if (this == readableInstant) {\n+            return true;\n+        }\n+        if (super.equals(readableInstant)) {\n+            if (readableInstant instanceof ReadWritableInstant) {\n+                ReadWritableInstant other = (ReadWritableInstant) readableInstant;\n+                if (getRoundingMode() == other.getRoundingMode()) {\n+                    DateTimeField field = getRoundingField();\n+                    if (field == other.getRoundingField() ||\n+                        field != null && field.equals(other.getRoundingField())) {\n+                        \n+                        return true;\n+                    }\n+                }\n+            } else {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n     /**\n      * Clone this object.\n      *\n--- a/JodaTime/src/java/org/joda/time/ReadWritableInstant.java\n+++ b/JodaTime/src/java/org/joda/time/ReadWritableInstant.java\n  */\n public interface ReadWritableInstant extends ReadableInstant {\n \n+    /** Rounding is disabled */\n+    public static final int ROUND_NONE = 0;\n+    /** Rounding mode as described by {@link DateTimeField#roundFloor} */\n+    public static final int ROUND_FLOOR = 1;\n+    /** Rounding mode as described by {@link DateTimeField#roundCeiling} */\n+    public static final int ROUND_CEILING = 2;\n+    /** Rounding mode as described by {@link DateTimeField#roundHalfFloor} */\n+    public static final int ROUND_HALF_FLOOR = 3;\n+    /** Rounding mode as described by {@link DateTimeField#roundHalfCeiling} */\n+    public static final int ROUND_HALF_CEILING = 4;\n+    /** Rounding mode as described by {@link DateTimeField#roundHalfEven} */\n+    public static final int ROUND_HALF_EVEN = 5;\n+\n+    /**\n+     * Returns the field used for rounding, which is ignored if rounding mode\n+     * is ROUND_NONE or field is null.\n+     */\n+    DateTimeField getRoundingField();\n+\n+    /**\n+     * Returns the rounding mode for this instant, or ROUND_NONE if rounding\n+     * is not enabled.\n+     */\n+    int getRoundingMode();\n+\n+    /**\n+     * Sets the field to use for rounding, or null to disable rounding. If the\n+     * rounding field is non-null, and the rounding mode was ROUND_NONE, it is\n+     * switched to ROUND_FLOOR. The instant is then rounded using the new field\n+     * and mode.\n+     *\n+     * @param field rounding field or null to disable\n+     */\n+    void setRoundingField(DateTimeField field);\n+\n+    /**\n+     * Sets the field to use for rounding, or null to disable rounding. The\n+     * instant is then rounded using the new field and mode.\n+     *\n+     * @param field rounding field or null to disable\n+     * @param mode rounding mode or ROUND_NONE to disable\n+     * @throws IllegalArgumentException if mode is unknown\n+     */\n+    void setRoundingField(DateTimeField field, int mode);\n+\n     /**\n      * Set the value as the number of milliseconds since\n      * the epoch, 1970-01-01T00:00:00Z.\n--- a/JodaTime/src/java/org/joda/time/ReadableDateTime.java\n+++ b/JodaTime/src/java/org/joda/time/ReadableDateTime.java\n      * <p>\n      * If the implementation of the interface is a DateTime, it is returned directly.\n      * \n-     * @return a DateTime using the same millis, unless partially specified\n+     * @return a DateTime using the same millis\n      */\n     DateTime toDateTime();\n \n      * it is returned directly.\n      * \n      * @param zone  time zone to apply\n-     * @return a DateTime using the same millis, unless partially specified\n+     * @return a DateTime using the same millis\n      * @throws IllegalArgumentException if the time zone is null\n      */\n     DateTime toDateTime(DateTimeZone zone);\n      * it is returned directly.\n      * \n      * @param chronology  chronology to apply\n-     * @return a DateTime using the same millis, unless partially specified\n+     * @return a DateTime using the same millis\n      * @throws IllegalArgumentException if the chronology is null\n      */\n     DateTime toDateTime(Chronology chronology);\n     /**\n      * Get this object as a MutableDateTime, always returning a new instance.\n      * \n-     * @return a MutableDateTime using the same millis, unless partially specified\n+     * @return a MutableDateTime using the same millis\n      */\n     MutableDateTime toMutableDateTime();\n \n      * Get this object as a MutableDateTime, always returning a new instance.\n      * \n      * @param zone  time zone to apply\n-     * @return a MutableDateTime using the same millis, unless partially specified\n+     * @return a MutableDateTime using the same millis\n      * @throws IllegalArgumentException if the time zone is null\n      */\n     MutableDateTime toMutableDateTime(DateTimeZone zone);\n      * Get this object as a MutableDateTime, always returning a new instance.\n      * \n      * @param chronology  chronology to apply\n-     * @return a MutableDateTime using the same millis, unless partially specified\n+     * @return a MutableDateTime using the same millis\n      * @throws IllegalArgumentException if the chronology is null\n      */\n     MutableDateTime toMutableDateTime(Chronology chronology);\n-\n-    /**\n-     * Get this object as a DateOnly.\n-     * \n-     * @return a DateOnly using the same millis, unless partially specified\n-     */\n-    DateOnly toDateOnly();\n-\n-    /**\n-     * Get this object as a DateOnly.\n-     * \n-     * @param chronology chronology to apply\n-     * @return a DateOnly using the same millis, unless partially specified\n-     * @throws IllegalArgumentException if the chronology is null\n-     */\n-    DateOnly toDateOnly(Chronology chronology);\n-\n-    /**\n-     * Get this object as a TimeOnly.\n-     * \n-     * @return a TimeOnly using the same millis, unless partially specified\n-     */\n-    TimeOnly toTimeOnly();\n-\n-    /**\n-     * Get this object as a TimeOnly.\n-     * \n-     * @param chronology chronology to apply\n-     * @return a TimeOnly using the same millis, unless partially specified\n-     * @throws IllegalArgumentException if the chronology is null\n-     */\n-    TimeOnly toTimeOnly(Chronology chronology);\n \n     /**\n      * Output the instant using the specified format pattern.\n--- a/JodaTime/src/java/org/joda/time/ReadableInstant.java\n+++ b/JodaTime/src/java/org/joda/time/ReadableInstant.java\n     long getMillis();\n \n     /**\n-     * Get the value as the number of milliseconds since the epoch,\n-     * 1970-01-01T00:00:00Z, with unsupported field values filled in by the\n-     * given base instant.\n-     * <p>\n-     * This method is useful for ReadableInstants that only partially describe\n-     * the instant. The base supplies missing information, including time\n-     * zone. Instants that are complete simply return the same value as for\n-     * getMillis(), ignoring the given base.\n-     *\n-     * @param base optional source of missing fields\n-     * @return the value as milliseconds\n-     */\n-    long getMillis(ReadableInstant base);\n-\n-    /**\n-     * Get the value as the number of milliseconds since the epoch,\n-     * 1970-01-01T00:00:00Z, with unsupported field values filled in by the\n-     * given base instant.\n-     * <p>\n-     * This method is useful for ReadableInstants that only partially describe\n-     * the instant. The base supplies missing information, excluding time\n-     * zone. Instants that are complete simply return the same value as for\n-     * getMillis(), ignoring the given base.\n-     *\n-     * @param base source of missing fields\n-     * @param zone override the base time zone, null implies override with no\n-     * time zone\n-     * @return the value as milliseconds\n-     */\n-    long getMillis(ReadableInstant base, DateTimeZone zone);\n-\n-    /**\n      * Gets the chronology of the instant, null if not applicable.\n      * <p>\n      * The {@link Chronology} provides conversion from the millisecond\n--- a/JodaTime/src/java/org/joda/time/convert/ConverterManager.java\n+++ b/JodaTime/src/java/org/joda/time/convert/ConverterManager.java\n  * The default instant converters are:\n  * <ul>\n  * <li>ReadableInstant\n- * <li>PartialInstant\n  * <li>String\n  * <li>Calendar\n  * <li>Date\n \n         iInstantConverters = new ConverterSet(new Converter[] {\n             ReadableInstantConverter.INSTANCE,\n-            PartialInstantConverter.INSTANCE,\n             StringConverter.INSTANCE,\n             CalendarConverter.INSTANCE,\n             DateConverter.INSTANCE,", "timestamp": 1088325479, "metainfo": ""}