{"sha": "8c5d6902ca81488fc8c9ffce33bfc0774afc2194", "log": "Remove methods to handle time zone differences   ", "commit": "\n--- a/JodaTime/src/java/org/joda/time/DateTimeUtils.java\n+++ b/JodaTime/src/java/org/joda/time/DateTimeUtils.java\n  */\n package org.joda.time;\n \n-import java.util.Calendar;\n-import java.util.Date;\n-import java.util.GregorianCalendar;\n-import java.util.TimeZone;\n-\n import org.joda.time.chrono.ISOChronology;\n \n /**\n \n     //-----------------------------------------------------------------------\n     /**\n-     * Converts the instant value to a <code>GregorianCalendar</code>\n-     * adjusting to take into account the different time zone rules.\n-     * <p>\n-     * This method is the equivalent of creating a calendar object and\n-     * calling set using each field in turn. The result is a calendar that\n-     * reflects the fields of the instant, rather than millisecond value.\n-     * <p>\n-     * This method can 'lose' data depending on the date and zone rules.\n-     * If a datetime exists in the specified instant that cannot be\n-     * represented in a calendar (due to differences in the time zone rules)\n-     * the JDK chooses to move the hour backwards. For example, 1972-03-26\n-     * 01:30  in Europe/London cannot be represented in <code>Calendar</code>\n-     * in JDK1.3 due to an incorrect time zone definition in the JDK.\n-     * Instead, the JDK sets the time to 00:30.\n-     *\n-     * @param instant  the instant to convert\n-     * @return the offset to add to UTC\n-     * @throws IllegalArgumentException if the instant is null\n-     * @since 1.2\n-     */\n-    public static GregorianCalendar toGregorianCalendar(ReadableInstant instant) {\n-        if (instant == null) {\n-            throw new IllegalArgumentException(\"The zone must not be null\");\n-        }\n-        Chronology chrono = instant.getChronology();\n-        DateTimeZone zone = instant.getZone();\n-        long millis = instant.getMillis();\n-        TimeZone jdkZone = zone.toTimeZone();\n-        GregorianCalendar cal = new GregorianCalendar(jdkZone);\n-        cal.clear();\n-        cal.set(Calendar.YEAR, chrono.year().get(millis));\n-        cal.set(Calendar.DAY_OF_YEAR, chrono.dayOfYear().get(millis));\n-        cal.set(Calendar.MILLISECOND, chrono.millisOfDay().get(millis));\n-        cal.get(Calendar.ERA);  // force calculation\n-        return cal;\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Converts a <code>Calendar</code> to a <code>DateTime</code> adjusting\n-     * the millisecond value to preserve the local time.\n-     * <p>\n-     * <code>DateTimeZone</code> and JDK <code>TimeZone</code> have\n-     * different time zone rules. When converting to and from the JDK this\n-     * can cause unexpected and undesired consequences. This method seeks\n-     * to adjust for the differences in the rules by maintaining the same\n-     * field values in the resultant <code>DateTime</code>.\n-     * <p>\n-     * Note that this method may not be reversible if the zone rules differ\n-     * around a daylight savings, or other, change.\n-     *\n-     * @param calendar  the JDK calendar to convert\n-     * @return the converted datetime\n-     * @throws IllegalArgumentException if the calendar is null\n-     * @since 1.2\n-     */\n-    public static DateTime toDateTime(Calendar calendar) {\n-        if (calendar == null) {\n-            throw new IllegalArgumentException(\"The calendar must not be null\");\n-        }\n-        long millisLocal = calendar.getTime().getTime() +\n-            calendar.get(Calendar.ZONE_OFFSET) + calendar.get(Calendar.DST_OFFSET);\n-        DateTimeZone zone = DateTimeZone.forTimeZone(calendar.getTimeZone());\n-        long millis = millisLocal - zone.getOffsetFromLocal(millisLocal);\n-        return new DateTime(millis, zone);\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Converts a <code>Date</code> to a <code>DateTime</code> adjusting\n-     * the millisecond value to preserve the local time.\n-     * <p>\n-     * <code>DateTimeZone</code> and JDK <code>TimeZone</code> have\n-     * different time zone rules. When converting to and from the JDK this\n-     * can cause unexpected and undesired consequences. This method seeks\n-     * to adjust for the differences in the rules by maintaining the same\n-     * field values in the resultant <code>DateTime</code>.\n-     * <p>\n-     * Note that this method may not be reversible if the zone rules differ\n-     * around a daylight savings, or other, change.\n-     *\n-     * @param date  the JDK date to convert\n-     * @return the converted datetime\n-     * @throws IllegalArgumentException if the calendar is null\n-     * @since 1.2\n-     */\n-    public static DateTime toDateTime(Date date) {\n-        if (date == null) {\n-            throw new IllegalArgumentException(\"The date must not be null\");\n-        }\n-        long millisLocal = date.getTime() - date.getTimezoneOffset() * 60000;\n-        DateTimeZone zone = DateTimeZone.forTimeZone(TimeZone.getDefault());\n-        long millis = millisLocal - zone.getOffsetFromLocal(millisLocal);\n-        return new DateTime(millis, zone);\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n      * Base class defining a millisecond provider.\n      */\n     abstract static class MillisProvider {\n--- a/JodaTime/src/java/org/joda/time/DateTimeZone.java\n+++ b/JodaTime/src/java/org/joda/time/DateTimeZone.java\n import java.io.Serializable;\n import java.lang.ref.Reference;\n import java.lang.ref.SoftReference;\n-import java.lang.reflect.InvocationTargetException;\n-import java.lang.reflect.Method;\n-import java.util.Date;\n import java.util.HashMap;\n import java.util.Locale;\n import java.util.Map;\n import java.util.Set;\n-import java.util.SimpleTimeZone;\n import java.util.TimeZone;\n \n import org.joda.time.chrono.BaseChronology;\n         }\n     }\n \n-    /** The method to call as TimeZone.getOffset is only from JDK 1.4. */\n-    private static final Method OFFSET_METHOD;\n-    static {\n-        Method m = null;\n-        try {\n-            m = TimeZone.class.getDeclaredMethod(\"getOffset\", new Class[] {Long.TYPE});\n-        } catch (SecurityException ex) {\n-            // ignore\n-        } catch (NoSuchMethodException ex) {\n-            // ignore\n-        }\n-        OFFSET_METHOD = m;\n-    }\n-\n     //-----------------------------------------------------------------------\n     /**\n      * Gets the default time zone.\n     }\n \n     /**\n-     * Gets the millisecond instant in the equivalent JDK <code>TimeZone</code>\n-     * keeping the same local time.\n-     * <p>\n-     * This method adjusts for time zone difference between the JDK and\n-     * Joda-Time zone rules. The aim of this method is to keep the same\n-     * local time but using the JDK time zone class. The result of this\n-     * method should be used to pass into a <code>Date</code>,\n-     * <code>Calendar</code> or other JDK class.\n-     * See the <a href=\"http://joda-time.sourceforge.net/jdk_conversion.html\">JDK conversion reference</a> for details.\n-     *\n-     * @param instant  the Joda-Time millisecond instant to convert\n-     * @return the JDK millisecond instant with the same local time\n-     * @since 1.2\n-     */\n-    public long getMillisJDKKeepLocal(long instant) {\n-        return getMillisJDKKeepLocal(toTimeZone(), instant);\n-    }\n-\n-    /**\n-     * Gets the millisecond instant in the specified JDK <code>TimeZone</code>\n-     * keeping the same local time. You should typically pass in the\n-     * JDK zone that is returned by {@link #toTimeZone()}.\n-     * <p>\n-     * This method adjusts for time zone difference between the JDK and\n-     * Joda-Time zone rules. The aim of this method is to keep the same\n-     * local time but using the JDK time zone class. The result of this\n-     * method should be used to pass into a <code>Date</code>,\n-     * <code>Calendar</code> or other JDK class.\n-     * See the <a href=\"http://joda-time.sourceforge.net/jdk_conversion.html\">JDK conversion reference</a> for details.\n-     *\n-     * @param jdkZone  the JDK zone to convert to, normally as per toTimezone()\n-     * @param instant  the Joda-Time millisecond instant to convert\n-     * @return the JDK millisecond instant with the same local time\n-     * @since 1.2\n-     */\n-    public long getMillisJDKKeepLocal(TimeZone jdkZone, long instant) {\n-        if (jdkZone == null) {\n-            jdkZone = toTimeZone();\n-        }\n-        Integer val;\n-        if (OFFSET_METHOD == null) {\n-            if (jdkZone instanceof SimpleTimeZone) {\n-                SimpleTimeZone zone = (SimpleTimeZone) jdkZone;\n-                long millisLocal = instant + getOffset(instant);\n-                long jdkOffset = getJDKOffset(zone, millisLocal - getJDKOffset(zone, millisLocal));\n-                return millisLocal - jdkOffset;\n-            }\n-            return instant;\n-        } else {\n-            try {\n-                val = (Integer) OFFSET_METHOD.invoke(\n-                        jdkZone, new Object[] {new Long(instant)});\n-            } catch (IllegalAccessException ex) {\n-                return instant;\n-            } catch (InvocationTargetException ex) {\n-                return instant;\n-            }\n-        }\n-        // TODO: this conversion is wrong\n-        long millisLocal = instant - val.intValue();\n-        return millisLocal + getOffsetFromLocal(millisLocal);\n-    }\n-\n-    /**\n-     * @param zone\n-     * @param instant\n-     * @return\n-     */\n-    private long getJDKOffset(SimpleTimeZone zone, long instant) {\n-        long offset = zone.getRawOffset();\n-        if (zone.inDaylightTime(new Date(instant)))  {\n-            offset += zone.getDSTSavings();\n-        }\n-        return offset;\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n      * Returns true if this time zone has no transitions.\n      *\n      * @return true if no transitions\n--- a/JodaTime/src/test/org/joda/time/TestDateTimeUtils.java\n+++ b/JodaTime/src/test/org/joda/time/TestDateTimeUtils.java\n import java.security.Permissions;\n import java.security.Policy;\n import java.security.ProtectionDomain;\n-import java.util.Calendar;\n-import java.util.Date;\n-import java.util.GregorianCalendar;\n-import java.util.TimeZone;\n \n import junit.framework.TestCase;\n import junit.framework.TestSuite;\n import org.joda.time.chrono.BuddhistChronology;\n import org.joda.time.chrono.CopticChronology;\n import org.joda.time.chrono.ISOChronology;\n-import org.joda.time.chrono.LenientChronology;\n \n /**\n  * This class is a Junit unit test for Instant.\n         } catch (IllegalArgumentException ex) {}\n     }\n \n-    //-----------------------------------------------------------------------\n-    public void testToGregorianCalendar() {\n-        TimeZone jdkZone = TimeZone.getDefault();\n-        try {\n-            TimeZone.setDefault(TimeZone.getTimeZone(\"Europe/Paris\"));\n-            DateTime dt = new DateTime(1970, 1, 1, 2, 30, 0, 0, PARIS);\n-            Calendar cal = new GregorianCalendar(1970, 0, 1, 2, 30);  // same field values\n-            \n-            assertEquals(cal, DateTimeUtils.toGregorianCalendar(dt));\n-            \n-            TimeZone.setDefault(TimeZone.getTimeZone(\"Europe/London\"));\n-            dt = new DateTime(1970, 1, 1, 2, 30, 0, 0, LONDON);\n-            cal = new GregorianCalendar(1970, 0, 1, 2, 30);  // same field values\n-            \n-            assertEquals(cal, DateTimeUtils.toGregorianCalendar(dt));\n-            \n-            dt = new DateTime(1800, 1, 1, 0, 30, 0, 0, LONDON);\n-            int year = dt.getYear();\n-            while (year < 2000) {\n-                dt = dt.plusHours(1);\n-                int hourOfDay = dt.getHourOfDay();\n-                if (hourOfDay == 4) {\n-                    dt = dt.plusHours(18);  // speed up test\n-                } else {\n-                    year = dt.getYear();\n-                    cal.clear();\n-                    cal.set(year, dt.getMonthOfYear() - 1, dt.getDayOfMonth(),\n-                        hourOfDay, dt.getMinuteOfHour(), dt.getSecondOfMinute());\n-                    //cal.get(Calendar.ERA);\n-                    assertEquals(cal, DateTimeUtils.toGregorianCalendar(dt));\n-                }\n-            }\n-            \n-        } finally {\n-            TimeZone.setDefault(jdkZone);\n-        }\n-        try {\n-            DateTimeUtils.toGregorianCalendar(null);\n-            fail();\n-        } catch (IllegalArgumentException ex) {}\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    public void testToDateTime_Calendar() {\n-        TimeZone jdkZone = TimeZone.getDefault();\n-        try {\n-            TimeZone.setDefault(TimeZone.getTimeZone(\"Europe/London\"));\n-            GregorianCalendar cal = new GregorianCalendar(1800, 0, 1, 0, 30, 0);\n-            int year = cal.get(Calendar.YEAR);\n-            while (year < 2000) {\n-                cal.add(Calendar.HOUR_OF_DAY, 1);\n-                int hourOfDay = cal.get(Calendar.HOUR_OF_DAY);\n-                if (hourOfDay == 4) {\n-                    cal.add(Calendar.HOUR_OF_DAY, 18);  // speed up test\n-                } else {\n-                    year = cal.get(Calendar.YEAR);\n-                    DateTime dt = new DateTime(\n-                        year, cal.get(Calendar.MONTH) + 1, cal.get(Calendar.DAY_OF_MONTH),\n-                        cal.get(Calendar.HOUR_OF_DAY), cal.get(Calendar.MINUTE),\n-                        cal.get(Calendar.SECOND), 0,\n-                        LenientChronology.getInstance(ISOChronology.getInstance(LONDON)))\n-                        .withChronology(ISOChronology.getInstance(LONDON));\n-                    assertEquals(dt, DateTimeUtils.toDateTime(cal));\n-                }\n-            }\n-            \n-        } finally {\n-            TimeZone.setDefault(jdkZone);\n-        }\n-        try {\n-            DateTimeUtils.toDateTime((Calendar) null);\n-            fail();\n-        } catch (IllegalArgumentException ex) {}\n-    }\n-\n }\n--- a/JodaTime/src/test/org/joda/time/TestDateTimeZone.java\n+++ b/JodaTime/src/test/org/joda/time/TestDateTimeZone.java\n import java.security.Permissions;\n import java.security.Policy;\n import java.security.ProtectionDomain;\n-import java.util.Date;\n import java.util.HashSet;\n import java.util.Locale;\n import java.util.Set;\n     }\n \n     //-----------------------------------------------------------------------\n-    public void testGetMillisJDKKeepLocal() {\n-        TimeZone jdkZone = TimeZone.getDefault();\n-        try {\n-            TimeZone.setDefault(TimeZone.getTimeZone(\"Europe/Paris\"));\n-            DateTime dt = new DateTime(1970, 1, 1, 2, 30, 0, 0, PARIS);\n-            Date date = new Date(70, 0, 1, 2, 30, 0);  // same field values\n-            \n-            assertEquals(date.getTime(), PARIS.getMillisJDKKeepLocal(dt.getMillis()));\n-            assertEquals(date.getTime(), PARIS.getMillisJDKKeepLocal(PARIS.toTimeZone(), dt.getMillis()));\n-            assertEquals(date.getTime(), PARIS.getMillisJDKKeepLocal(null, dt.getMillis()));\n-            \n-            TimeZone.setDefault(TimeZone.getTimeZone(\"Europe/London\"));\n-            dt = new DateTime(1970, 1, 1, 2, 30, 0, 0, LONDON);\n-            date = new Date(70, 0, 1, 2, 30, 0);  // same field values\n-            \n-            assertEquals(date.getTime(), LONDON.getMillisJDKKeepLocal(dt.getMillis()));\n-            assertEquals(date.getTime(), LONDON.getMillisJDKKeepLocal(LONDON.toTimeZone(), dt.getMillis()));\n-            assertEquals(date.getTime(), LONDON.getMillisJDKKeepLocal(null, dt.getMillis()));\n-            \n-        } finally {\n-            TimeZone.setDefault(jdkZone);\n-        }\n-    }\n-\n-    //-----------------------------------------------------------------------\n     public void testIsFixed() {\n         DateTimeZone zone = DateTimeZone.forID(\"Europe/Paris\");\n         assertEquals(false, zone.isFixed());", "timestamp": 1133733728, "metainfo": ""}