{"sha": "b030ae5c1137496f8cef9cc1579f93e968194c35", "log": "Update and test durations   ", "commit": "\n--- a/JodaTime/src/java/org/joda/time/AbstractDuration.java\n+++ b/JodaTime/src/java/org/joda/time/AbstractDuration.java\n  */\n public abstract class AbstractDuration implements ReadableDuration, Serializable {\n \n-    static final long serialVersionUID = -2110953284060001145L;\n-\n+    /** Serialization version */\n+    private static final long serialVersionUID = -2110953284060001145L;\n+\n+    /**\n+     * Checks whether the field is supported.\n+     */\n+    private static void checkArgument(DurationField field, String name) {\n+        if (!field.isSupported()) {\n+            throw new IllegalArgumentException\n+                (\"Duration does not support field \\\"\" + name + '\"');\n+        }\n+    }\n+\n+    /**\n+     * Checks whether the field is supported.\n+     */\n     private static void checkSupport(DurationField field, String name) {\n         if (!field.isSupported()) {\n             throw new UnsupportedOperationException\n         }\n     }\n \n+    /**\n+     * Checks whether the field is precise.\n+     */\n     private static void checkPrecise(DurationField field, String name) {\n         if (!field.isPrecise()) {\n             throw new UnsupportedOperationException\n     private int iMillis;\n \n     /**\n-     * Copies another duration to this one.\n-     *\n-     * @param duration duration to copy\n-     * @throws IllegalArgumentException if duration is null\n-     * @throws UnsupportedOperationException if an unsupported field's value is\n-     * non-zero\n-     */\n-    public AbstractDuration(ReadableDuration duration) {\n-        super();\n-        // Only call a private method\n-        setDuration(iType = duration.getDurationType(), duration);\n-    }\n-\n-    /**\n-     * Copies another duration to this one.\n-     *\n-     * @param duration duration to convert\n-     * @throws IllegalArgumentException if duration is null\n-     * @throws UnsupportedOperationException if an unsupported field's value is\n-     * non-zero\n-     */\n-    public AbstractDuration(Object duration) {\n-        super();\n-        if (duration instanceof ReadableDuration) {\n-            // Only call a private method\n-            ReadableDuration rd = (ReadableDuration) duration;\n-            setDuration(iType = rd.getDurationType(), rd);\n-        } else {\n-            DurationConverter converter = ConverterManager.getInstance().getDurationConverter(duration);\n-            DurationType type = converter.getDurationType(duration);\n-            if (type.isPrecise() && converter.isPrecise(duration)) {\n-                // Only call a private method\n-                setTotalMillis(iType = type, converter.getDurationMillis(duration));\n-            } else if (this instanceof ReadWritableDuration) {\n-                iType = type;\n-                converter.setInto((ReadWritableDuration) this, duration);\n-            } else {\n-                // Only call a private method\n-                setDuration(iType = type, new MutableDuration(type, duration));\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Creates a zero length duration.\n-     *\n-     * @param type determines which set of fields this duration supports\n-     * @throws IllegalArgumentException if type is null\n+     * Creates a zero length duration of the specified type.\n+     *\n+     * @param type  which set of fields this duration supports, null means millis type\n      */\n     public AbstractDuration(DurationType type) {\n         super();\n+        type = (type == null ? DurationType.getMillisType() : type);\n+        iType = type;\n         // Only call a private method\n-        setTotalMillis(iType = type, 0);\n-    }\n-\n-    /**\n-     * Copies another duration to this one.\n-     *\n-     * @param type use a different DurationType\n-     * @param duration duration to copy\n-     * @throws IllegalArgumentException if type or duration is null\n-     * @throws UnsupportedOperationException if an unsupported field's value is\n-     * non-zero\n-     */\n-    public AbstractDuration(DurationType type, ReadableDuration duration) {\n+        setTotalMillis(type, 0L);\n+    }\n+\n+    /**\n+     * Creates a new duration based on another using the {@link ConverterManager}.\n+     *\n+     * @param duration  duration to convert\n+     * @param type  which set of fields this duration supports, null means use type from object\n+     * @throws IllegalArgumentException if duration is invalid\n+     * @throws IllegalArgumentException if an unsupported field's value is non-zero\n+     */\n+    public AbstractDuration(Object duration, DurationType type) {\n         super();\n+        DurationConverter converter = ConverterManager.getInstance().getDurationConverter(duration);\n+        type = (type == null ? converter.getDurationType(duration) : type);\n+        iType = type;\n+        if (type.isPrecise() && converter.isPrecise(duration)) {\n+            // Only call a private method\n+            setTotalMillis(type, converter.getDurationMillis(duration));\n+        } else if (this instanceof ReadWritableDuration) {\n+            converter.setInto((ReadWritableDuration) this, duration);\n+        } else {\n+            // Only call a private method\n+            setDuration(type, new MutableDuration(duration, type));\n+        }\n+    }\n+\n+    /**\n+     * Creates a duration from a set of field values.\n+     *\n+     * @param years  amount of years in this duration, which must be zero if unsupported\n+     * @param months  amount of months in this duration, which must be zero if unsupported\n+     * @param weeks  amount of weeks in this duration, which must be zero if unsupported\n+     * @param days  amount of days in this duration, which must be zero if unsupported\n+     * @param hours  amount of hours in this duration, which must be zero if unsupported\n+     * @param minutes  amount of minutes in this duration, which must be zero if unsupported\n+     * @param seconds  amount of seconds in this duration, which must be zero if unsupported\n+     * @param millis  amount of milliseconds in this duration, which must be zero if unsupported\n+     * @param type  which set of fields this duration supports, null means AllType\n+     * @throws IllegalArgumentException if an unsupported field's value is non-zero\n+     */\n+    public AbstractDuration(int years, int months, int weeks, int days,\n+                            int hours, int minutes, int seconds, int millis,\n+                            DurationType type) {\n+        super();\n+        type = (type == null ? DurationType.getAllType() : type);\n+        iType = type;\n         // Only call a private method\n-        setDuration(iType = type, duration);\n-    }\n-\n-    /**\n-     * Copies another duration to this one.\n-     *\n-     * @param type use a different DurationType\n-     * @param duration duration to convert\n-     * @throws IllegalArgumentException if type or duration is null\n-     * @throws UnsupportedOperationException if an unsupported field's value is\n-     * non-zero\n-     */\n-    public AbstractDuration(DurationType type, Object duration) {\n+        setDuration(type, years, months, weeks, days, hours, minutes, seconds, millis);\n+    }\n+\n+    /**\n+     * Creates a duration from the given interval endpoints.\n+     *\n+     * @param startInstant  interval start, in milliseconds\n+     * @param endInstant  interval end, in milliseconds\n+     * @param type  which set of fields this duration supports, null means AllType\n+     */\n+    public AbstractDuration(long startInstant, long endInstant, DurationType type) {\n         super();\n-        if (duration instanceof ReadableDuration) {\n+        type = (type == null ? DurationType.getAllType() : type);\n+        iType = type;\n+        // Only call a private method\n+        setTotalMillis(type, startInstant, endInstant);\n+    }\n+\n+    /**\n+     * Creates a duration from the given interval endpoints.\n+     *\n+     * @param startInstant  interval start, null means now\n+     * @param endInstant  interval end, null means now\n+     * @param type  which set of fields this duration supports, null means AllType\n+     */\n+    public AbstractDuration(\n+            ReadableInstant startInstant, ReadableInstant  endInstant, DurationType type) {\n+        super();\n+        type = (type == null ? DurationType.getAllType() : type);\n+        if (startInstant == null && endInstant == null) {\n+            iType = type;\n+        } else {\n+            long start = (startInstant == null ? DateTimeUtils.currentTimeMillis() : startInstant.getMillis());\n+            long end = (endInstant == null ? DateTimeUtils.currentTimeMillis() : endInstant.getMillis());\n+            iType = type;\n             // Only call a private method\n-            setDuration(iType = type, (ReadableDuration) duration);\n-        } else {\n-            DurationConverter converter = ConverterManager.getInstance().getDurationConverter(duration);\n-            if (type.isPrecise() && converter.isPrecise(duration)) {\n-                // Only call a private method\n-                setTotalMillis(iType = type, converter.getDurationMillis(duration));\n-            } else if (this instanceof ReadWritableDuration) {\n-                iType = type;\n-                converter.setInto((ReadWritableDuration) this, duration);\n-            } else {\n-                // Only call a private method\n-                setDuration(iType = type, new MutableDuration(type, duration));\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Create a duration from a set of field values.\n-     *\n-     * @param type determines which set of fields this duration supports\n-     * @param years amount of years in this duration, which must be zero if\n-     * unsupported.\n-     * @param months amount of months in this duration, which must be zero if\n-     * unsupported.\n-     * @param weeks amount of weeks in this duration, which must be zero if\n-     * unsupported.\n-     * @param days amount of days in this duration, which must be zero if\n-     * unsupported.\n-     * @param hours amount of hours in this duration, which must be zero if\n-     * unsupported.\n-     * @param minutes amount of minutes in this duration, which must be zero if\n-     * unsupported.\n-     * @param seconds amount of seconds in this duration, which must be zero if\n-     * unsupported.\n-     * @param millis amount of milliseconds in this duration, which must be\n-     * zero if unsupported.\n-     * @throws IllegalArgumentException if type is null\n-     * @throws UnsupportedOperationException if an unsupported field's value is\n-     * non-zero\n-     */\n-    public AbstractDuration(DurationType type,\n-                            int years, int months, int weeks, int days,\n-                            int hours, int minutes, int seconds, int millis) {\n-        super();\n-        // Only call a private method\n-        setDuration(iType = type, years, months, weeks, days, hours, minutes, seconds, millis);\n-    }\n-\n-    /**\n-     * Creates a duration from the given interval endpoints.\n-     *\n-     * @param type determines which set of fields this duration supports\n-     * @param startInstant interval start, in milliseconds\n-     * @param endInstant interval end, in milliseconds\n-     * @throws IllegalArgumentException if type is null\n-     */\n-    public AbstractDuration(DurationType type, long startInstant, long endInstant) {\n-        super();\n-        // Only call a private method\n-        setTotalMillis(iType = type, startInstant, endInstant);\n-    }\n-\n-    /**\n-     * Creates a duration from the given interval endpoints.\n-     *\n-     * @param type determines which set of fields this duration supports\n-     * @param startInstant interval start\n-     * @param endInstant interval end\n-     * @throws IllegalArgumentException if type is null\n-     */\n-    public AbstractDuration(DurationType type,\n-                            ReadableInstant startInstant, ReadableInstant  endInstant) {\n-        super();\n-        // Only call a private method\n-        setTotalMillis(iType = type, startInstant.getMillis(), endInstant.getMillis());\n+            setTotalMillis(type, start, end);\n+        }\n     }\n \n     /**\n      * fields are imprecise, an UnsupportedOperationException is thrown. The\n      * exception to this is when the specified duration is zero.\n      *\n-     * @param type determines which set of fields this duration supports\n      * @param duration  the duration, in milliseconds\n-     * @throws IllegalArgumentException if type is null\n-     * @throws UnsupportedOperationException if any fields are imprecise\n-     */\n-    public AbstractDuration(DurationType type, long duration) {\n+     * @param type  which set of fields this duration supports, null means MillisType\n+     */\n+    public AbstractDuration(long duration, DurationType type) {\n         super();\n-        // Only call a private method\n-        setTotalMillis(iType = type, duration);\n-    }\n-\n+        type = (type == null ? DurationType.getMillisType() : type);\n+        iType = type;\n+        setTotalMillis(type, duration); // Only call a private method\n+    }\n+\n+    //-----------------------------------------------------------------------\n     /**\n      * Returns the object which defines which fields this duration supports.\n      */\n      * @throws IllegalStateException if either duration is imprecise\n      */\n     public int compareTo(Object obj) {\n+        // Comparable contract means we cannot handle null or other types gracefully\n         ReadableDuration thisDuration = (ReadableDuration) this;\n         ReadableDuration otherDuration = (ReadableDuration) obj;\n-\n+        \n         long thisMillis = thisDuration.getTotalMillis();\n         long otherMillis = otherDuration.getTotalMillis();\n         \n      * Is the length of this duration equal to the duration passed in.\n      * Both durations must be precise.\n      *\n-     * @param duration  another duration to compare to\n+     * @param duration  another duration to compare to, null means zero milliseconds\n      * @return true if this duration is equal to than the duration passed in\n-     * @throws IllegalArgumentException if the duration is null\n      * @throws IllegalStateException if either duration is imprecise\n      */\n     public boolean isEqual(ReadableDuration duration) {\n         if (duration == null) {\n-            throw new IllegalArgumentException(\"The duration must not be null\");\n+            duration = Duration.ZERO;\n         }\n         return compareTo(duration) == 0;\n     }\n      * Is the length of this duration longer than the duration passed in.\n      * Both durations must be precise.\n      *\n-     * @param duration  another duration to compare to\n+     * @param duration  another duration to compare to, null means zero milliseconds\n      * @return true if this duration is equal to than the duration passed in\n-     * @throws IllegalArgumentException if the duration is null\n      * @throws IllegalStateException if either duration is imprecise\n      */\n     public boolean isLongerThan(ReadableDuration duration) {\n         if (duration == null) {\n-            throw new IllegalArgumentException(\"The duration must not be null\");\n+            duration = Duration.ZERO;\n         }\n         return compareTo(duration) > 0;\n     }\n      * Is the length of this duration shorter than the duration passed in.\n      * Both durations must be precise.\n      *\n-     * @param duration  another duration to compare to\n+     * @param duration  another duration to compare to, null means zero milliseconds\n      * @return true if this duration is equal to than the duration passed in\n-     * @throws IllegalArgumentException if the duration is null\n      * @throws IllegalStateException if either duration is imprecise\n      */\n     public boolean isShorterThan(ReadableDuration duration) {\n         if (duration == null) {\n-            throw new IllegalArgumentException(\"The duration must not be null\");\n+            duration = Duration.ZERO;\n         }\n         return compareTo(duration) < 0;\n     }\n      * all lower subclasses are also immutable.\n      * \n      * @param duration  the duration to set\n-     * @throws IllegalArgumentException if duration is null\n-     * @throws UnsupportedOperationException if an unsupported field's value is\n-     * non-zero\n+     * @throws IllegalArgumentException if duration is invalid\n+     * @throws IllegalArgumentException if an unsupported field's value is non-zero\n      */\n     protected void setDuration(ReadableDuration duration) {\n         setDuration(iType, duration);\n                     duration.getWeeks(), duration.getDays(),\n                     duration.getHours(), duration.getMinutes(),\n                     duration.getSeconds(), duration.getMillis());\n+        if (type.equals(duration.getDurationType()) && duration.isPrecise()) {\n+            iTotalMillis = duration.getTotalMillis();\n+            iTotalMillisState = 2;\n+        }\n     }\n \n     /**\n      * empty implementation that is protected and final. This also ensures that\n      * all lower subclasses are also immutable.\n      * \n-     * @param years amount of years in this duration, which must be zero if\n-     * unsupported.\n-     * @param months amount of months in this duration, which must be zero if\n-     * unsupported.\n-     * @param weeks amount of weeks in this duration, which must be zero if\n-     * unsupported.\n-     * @param days amount of days in this duration, which must be zero if\n-     * unsupported.\n-     * @param hours amount of hours in this duration, which must be zero if\n-     * unsupported.\n-     * @param minutes amount of minutes in this duration, which must be zero if\n-     * unsupported.\n-     * @param seconds amount of seconds in this duration, which must be zero if\n-     * unsupported.\n-     * @param millis amount of milliseconds in this duration, which must be\n-     * zero if unsupported.\n-     * @throws UnsupportedOperationException if an unsupported field's value is\n-     * non-zero\n+     * @param years  amount of years in this duration, which must be zero if unsupported\n+     * @param months  amount of months in this duration, which must be zero if unsupported\n+     * @param weeks  amount of weeks in this duration, which must be zero if unsupported\n+     * @param days  amount of days in this duration, which must be zero if unsupported\n+     * @param hours  amount of hours in this duration, which must be zero if unsupported\n+     * @param minutes  amount of minutes in this duration, which must be zero if unsupported\n+     * @param seconds  amount of seconds in this duration, which must be zero if unsupported\n+     * @param millis  amount of milliseconds in this duration, which must be zero if unsupported\n+     * @throws IllegalArgumentException if an unsupported field's value is non-zero\n      */\n     protected void setDuration(int years, int months, int weeks, int days,\n                                int hours, int minutes, int seconds, int millis) {\n         }\n \n         if (years != 0) {\n-            checkSupport(type.years(), \"years\");\n+            checkArgument(type.years(), \"years\");\n         }\n         if (months != 0) {\n-            checkSupport(type.months(), \"months\");\n+            checkArgument(type.months(), \"months\");\n         }\n         if (weeks != 0) {\n-            checkSupport(type.weeks(), \"weeks\");\n+            checkArgument(type.weeks(), \"weeks\");\n         }\n         if (days != 0) {\n-            checkSupport(type.days(), \"days\");\n+            checkArgument(type.days(), \"days\");\n         }\n         if (hours != 0) {\n-            checkSupport(type.hours(), \"hours\");\n+            checkArgument(type.hours(), \"hours\");\n         }\n         if (minutes != 0) {\n-            checkSupport(type.minutes(), \"minutes\");\n+            checkArgument(type.minutes(), \"minutes\");\n         }\n         if (seconds != 0) {\n-            checkSupport(type.seconds(), \"seconds\");\n+            checkArgument(type.seconds(), \"seconds\");\n         }\n         if (millis != 0) {\n-            checkSupport(type.millis(), \"millis\");\n+            checkArgument(type.millis(), \"millis\");\n         }\n \n         iYears = years;\n      * empty implementation that is protected and final. This also ensures that\n      * all lower subclasses are also immutable.\n      * \n-     * @param startInstant interval start, in milliseconds\n-     * @param endInstant interval end, in milliseconds\n+     * @param startInstant  interval start, in milliseconds\n+     * @param endInstant  interval end, in milliseconds\n+     * @throws IllegalArgumentException if the type is null\n      */\n     protected void setTotalMillis(long startInstant, long endInstant) {\n         setTotalMillis(iType, startInstant, endInstant);\n     /**\n      * This method is private to prevent subclasses from overriding.\n      *\n-     * @param startInstant interval start, in milliseconds\n-     * @param endInstant interval end, in milliseconds\n+     * @param startInstant  interval start, in milliseconds\n+     * @param endInstant  interval end, in milliseconds\n+     * @throws IllegalArgumentException if the type is null\n      */\n     private void setTotalMillis(DurationType type, long startInstant, long endInstant) {\n         if (type == null) {\n             throw new IllegalArgumentException(\"The type must not be null\");\n         }\n-\n-        iTotalMillis = endInstant - startInstant;\n-\n-        boolean isPrecise = true;\n-\n+        \n+        long baseTotalMillis = (endInstant - startInstant);\n+        int years = 0, months = 0, weeks = 0, days = 0;\n+        int hours = 0, minutes = 0, seconds = 0, millis = 0;\n         DurationField field;\n-\n-        if (!(field = type.years()).isSupported()) {\n-            iYears = 0;\n-        } else if ((iYears = field.getDifference(endInstant, startInstant)) != 0) {\n-            isPrecise &= field.isPrecise();\n-            startInstant = field.add(startInstant, iYears);\n-        }\n-\n-        if (!(field = type.months()).isSupported()) {\n-            iMonths = 0;\n-        } else if ((iMonths = field.getDifference(endInstant, startInstant)) != 0) {\n-            isPrecise &= field.isPrecise();\n-            startInstant = field.add(startInstant, iMonths);\n-        }\n-    \n-        if (!(field = type.weeks()).isSupported()) {\n-            iWeeks = 0;\n-        } else if ((iWeeks = field.getDifference(endInstant, startInstant)) != 0) {\n-            isPrecise &= field.isPrecise();\n-            startInstant = field.add(startInstant, iWeeks);\n-        }\n-\n-        if (!(field = type.days()).isSupported()) {\n-            iDays = 0;\n-        } else if ((iDays = field.getDifference(endInstant, startInstant)) != 0) {\n-            isPrecise &= field.isPrecise();\n-            startInstant = field.add(startInstant, iDays);\n-        }\n-\n-        if (!(field = type.hours()).isSupported()) {\n-            iHours = 0;\n-        } else if ((iHours = field.getDifference(endInstant, startInstant)) != 0) {\n-            isPrecise &= field.isPrecise();\n-            startInstant = field.add(startInstant, iHours);\n+        field = type.years();\n+        if (field.isSupported()) {\n+            years = field.getDifference(endInstant, startInstant);\n+            startInstant = field.add(startInstant, years);\n+        }\n+        field = type.months();\n+        if (field.isSupported()) {\n+            months = field.getDifference(endInstant, startInstant);\n+            startInstant = field.add(startInstant, months);\n+        }\n+        field = type.weeks();\n+        if (field.isSupported()) {\n+            weeks = field.getDifference(endInstant, startInstant);\n+            startInstant = field.add(startInstant, weeks);\n+        }\n+        field = type.days();\n+        if (field.isSupported()) {\n+            days = field.getDifference(endInstant, startInstant);\n+            startInstant = field.add(startInstant, days);\n+        }\n+        field = type.hours();\n+        if (field.isSupported()) {\n+            hours = field.getDifference(endInstant, startInstant);\n+            startInstant = field.add(startInstant, hours);\n+        }\n+        field = type.minutes();\n+        if (field.isSupported()) {\n+            minutes = field.getDifference(endInstant, startInstant);\n+            startInstant = field.add(startInstant, minutes);\n+        }\n+        field = type.seconds();\n+        if (field.isSupported()) {\n+            seconds = field.getDifference(endInstant, startInstant);\n+            startInstant = field.add(startInstant, seconds);\n+        }\n+        field = type.millis();\n+        if (field.isSupported()) {\n+            millis = field.getDifference(endInstant, startInstant);\n+            startInstant = field.add(startInstant, millis);\n         }\n         \n-        if (!(field = type.minutes()).isSupported()) {\n-            iMinutes = 0;\n-        } else if ((iMinutes = field.getDifference(endInstant, startInstant)) != 0) {\n-            isPrecise &= field.isPrecise();\n-            startInstant = field.add(startInstant, iMinutes);\n-        }\n+        // (end - start) is excess to be discarded\n+        iTotalMillis = baseTotalMillis - (endInstant - startInstant);\n+        iTotalMillisState = 2;\n         \n-        if (!(field = type.seconds()).isSupported()) {\n-            iSeconds = 0;\n-        } else if ((iSeconds = field.getDifference(endInstant, startInstant)) != 0) {\n-            isPrecise &= field.isPrecise();\n-            startInstant = field.add(startInstant, iSeconds);\n-        }\n-\n-        if (!(field = type.millis()).isSupported()) {\n-            iMillis = 0;\n-        } else if ((iMillis = field.getDifference(endInstant, startInstant)) != 0) {\n-            isPrecise &= field.isPrecise();\n-            startInstant = field.add(startInstant, iMillis);\n-        }\n-\n-        iTotalMillisState = isPrecise ? 2 : 1;\n+        iYears = years;\n+        iMonths = months;\n+        iWeeks = weeks;\n+        iDays = days;\n+        iHours = hours;\n+        iMinutes = minutes;\n+        iSeconds = seconds;\n+        iMillis = millis;\n     }\n \n     /**\n      * all lower subclasses are also immutable.\n      * \n      * @param duration  the duration, in milliseconds\n-     * @throws UnsupportedOperationException if any fields are imprecise\n+     * @throws IllegalArgumentException if the type is null\n      */\n     protected void setTotalMillis(long duration) {\n         setTotalMillis(iType, duration);\n      * This method is private to prevent subclasses from overriding.\n      *\n      * @param duration  the duration, in milliseconds\n-     * @throws UnsupportedOperationException if any fields are imprecise\n+     * @throws IllegalArgumentException if the type is null\n      */\n     private void setTotalMillis(DurationType type, final long duration) {\n         if (type == null) {\n             throw new IllegalArgumentException(\"The type must not be null\");\n         }\n-\n+        \n         if (duration == 0) {\n             iTotalMillis = duration;\n             iTotalMillisState = 2;\n \n             return;\n         }\n-\n+        \n         long startInstant = 0;\n-\n-        int years, months, weeks, days, hours, minutes, seconds, millis;\n+        int years = 0, months = 0, weeks = 0, days = 0;\n+        int hours = 0, minutes = 0, seconds = 0, millis = 0;\n         DurationField field;\n-\n-        if (!(field = type.years()).isSupported()) {\n-            years = 0;\n-        } else {\n-            checkPrecise(field, \"years\");\n+        \n+        field = type.years();\n+        if (field.isSupported() && field.isPrecise()) {\n             years = field.getDifference(duration, startInstant);\n             startInstant = field.add(startInstant, years);\n         }\n-\n-        if (!(field = type.months()).isSupported()) {\n-            months = 0;\n-        } else {\n-            checkPrecise(field, \"months\");\n+        field = type.months();\n+        if (field.isSupported() && field.isPrecise()) {\n             months = field.getDifference(duration, startInstant);\n             startInstant = field.add(startInstant, months);\n         }\n-\n-        if (!(field = type.weeks()).isSupported()) {\n-            weeks = 0;\n-        } else {\n-            checkPrecise(field, \"weeks\");\n+        field = type.weeks();\n+        if (field.isSupported() && field.isPrecise()) {\n             weeks = field.getDifference(duration, startInstant);\n             startInstant = field.add(startInstant, weeks);\n         }\n-\n-        if (!(field = type.days()).isSupported()) {\n-            days = 0;\n-        } else {\n-            checkPrecise(field, \"days\");\n+        field = type.days();\n+        if (field.isSupported() && field.isPrecise()) {\n             days = field.getDifference(duration, startInstant);\n             startInstant = field.add(startInstant, days);\n         }\n-\n-        if (!(field = type.hours()).isSupported()) {\n-            hours = 0;\n-        } else {\n-            checkPrecise(field, \"hours\");\n+        field = type.hours();\n+        if (field.isSupported() && field.isPrecise()) {\n             hours = field.getDifference(duration, startInstant);\n             startInstant = field.add(startInstant, hours);\n         }\n-\n-        if (!(field = type.minutes()).isSupported()) {\n-            minutes = 0;\n-        } else {\n-            checkPrecise(field, \"minutes\");\n+        field = type.minutes();\n+        if (field.isSupported() && field.isPrecise()) {\n             minutes = field.getDifference(duration, startInstant);\n             startInstant = field.add(startInstant, minutes);\n         }\n-\n-        if (!(field = type.seconds()).isSupported()) {\n-            seconds = 0;\n-        } else {\n-            checkPrecise(field, \"seconds\");\n+        field = type.seconds();\n+        if (field.isSupported() && field.isPrecise()) {\n             seconds = field.getDifference(duration, startInstant);\n             startInstant = field.add(startInstant, seconds);\n         }\n-\n-        if (!(field = type.millis()).isSupported()) {\n-            millis = 0;\n-        } else {\n-            checkPrecise(field, \"millis\");\n+        field = type.millis();\n+        if (field.isSupported() && field.isPrecise()) {\n             millis = field.getDifference(duration, startInstant);\n             startInstant = field.add(startInstant, millis);\n         }\n-\n-        iTotalMillis = duration;\n+        \n+        // (end - start) is excess to be discarded\n+        iTotalMillis = duration - (duration - startInstant);\n         iTotalMillisState = 2;\n-\n+        \n         iYears = years;\n         iMonths = months;\n         iWeeks = weeks;\n         iSeconds = seconds;\n         iMillis = millis;\n     }\n-    \n+\n     //-----------------------------------------------------------------------\n     /**\n      * Adds a millisecond duration to this one. As a side-effect, all field\n--- a/JodaTime/src/java/org/joda/time/AbstractInterval.java\n+++ b/JodaTime/src/java/org/joda/time/AbstractInterval.java\n         Duration duration = iDuration;\n         if (duration == null) {\n             if (type.isPrecise()) {\n-                duration = new Duration(type, getEndMillis() - getStartMillis());\n+                duration = new Duration(getEndMillis() - getStartMillis(), type);\n                 if (type.equals(DurationType.getAverageYearMonthType())) {\n                     iDuration = duration;\n                 }\n             } else {\n-                duration = new Duration(type, getStartInstant(), getEndInstant());\n+                duration = new Duration(getStartInstant(), getEndInstant(), type);\n             }\n         }\n         return duration;\n--- a/JodaTime/src/java/org/joda/time/Duration.java\n+++ b/JodaTime/src/java/org/joda/time/Duration.java\n  * <p>\n  * A duration can be divided into a number of fields, such as hours and seconds.\n  * The way in which that divide occurs is controlled by the DurationType class.\n+ * Commonly use types are MillisType, which assigns all values to the millis field,\n+ * and AllType, which spreads values across all fields.\n+ * <p>\n+ * A duration has a concept of being <i>precise</i>.\n+ * A precise duration is a fixed number of milliseconds long.\n+ * Whether a particular duration instance is precise depends on the constructor\n+ * used and the duration type specified.\n  * <p>\n  * Duration is thread-safe and immutable, provided that the DurationType is\n  * as well. All standard DurationType classes supplied are thread-safe and\n  */\n public class Duration extends AbstractDuration implements ReadableDuration, Serializable {\n \n-    static final long serialVersionUID = 741052353876488155L;\n-\n-    /**\n-     * Copies another duration to this one.\n-     *\n-     * @param duration duration to copy\n-     * @throws IllegalArgumentException if duration is null\n-     * @throws UnsupportedOperationException if an unsupported field's value is\n-     * non-zero\n-     */\n-    public Duration(ReadableDuration duration) {\n-        super(duration);\n-    }\n-\n-    /**\n-     * Copies another duration to this one.\n-     *\n-     * @param duration duration to convert\n-     * @throws IllegalArgumentException if duration is null\n-     * @throws UnsupportedOperationException if an unsupported field's value is\n-     * non-zero\n-     */\n-    public Duration(Object duration) {\n-        super(duration);\n+    /** Constant representing zero millisecond duration */\n+    public static final Duration ZERO = new Duration();\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = 741052353876488155L;\n+\n+    /**\n+     * Creates a zero length millisecond duration using MillisType.\n+     * This constructor creates a precise duration because\n+     * MillisType in ISOChronology UTC is precise.\n+     */\n+    public Duration() {\n+        super((DurationType) null);\n     }\n \n     /**\n      * Creates a zero length duration.\n-     *\n-     * @param type determines which set of fields this duration supports\n-     * @throws IllegalArgumentException if type is null\n+     * This constructor creates a precise duration.\n+     *\n+     * @param type  which set of fields this duration supports, null means millis type\n      */\n     public Duration(DurationType type) {\n         super(type);\n     }\n \n     /**\n-     * Copies another duration to this one.\n-     *\n-     * @param type use a different DurationType\n-     * @param duration duration to copy\n-     * @throws IllegalArgumentException if type or duration is null\n-     * @throws UnsupportedOperationException if an unsupported field's value is\n-     * non-zero\n-     */\n-    public Duration(DurationType type, ReadableDuration duration) {\n-        super(type, duration);\n-    }\n-\n-    /**\n-     * Copies another duration to this one.\n-     *\n-     * @param type use a different DurationType\n-     * @param duration duration to convert\n-     * @throws IllegalArgumentException if type or duration is null\n-     * @throws UnsupportedOperationException if an unsupported field's value is\n-     * non-zero\n-     */\n-    public Duration(DurationType type, Object duration) {\n-        super(type, duration);\n+     * Creates a duration from the specified object using the\n+     * {@link org.joda.time.convert.ConverterManager ConverterManager}.\n+     *\n+     * @param duration  duration to convert\n+     * @throws IllegalArgumentException if duration is invalid\n+     * @throws UnsupportedOperationException if an unsupported field's value is non-zero\n+     */\n+    public Duration(Object duration) {\n+        super(duration, null);\n+    }\n+\n+    /**\n+     * Creates a duration from the specified object using the\n+     * {@link org.joda.time.convert.ConverterManager ConverterManager}.\n+     *\n+     * @param duration  duration to convert\n+     * @param type  which set of fields this duration supports, null means use converter\n+     * @throws IllegalArgumentException if duration is invalid\n+     * @throws UnsupportedOperationException if an unsupported field's value is non-zero\n+     */\n+    public Duration(Object duration, DurationType type) {\n+        super(duration, type);\n+    }\n+\n+    /**\n+     * Create a duration from a set of field values using DayHourType.\n+     * This constructor creates a precise duration because\n+     * DayHourType in ISOChronology UTC is precise.\n+     *\n+     * @param days  amount of days in this duration\n+     * @param hours  amount of hours in this duration\n+     * @param minutes  amount of minutes in this duration\n+     * @param seconds  amount of seconds in this duration\n+     * @param millis  amount of milliseconds in this duration\n+     */\n+    public Duration(int days, int hours, int minutes, int seconds, int millis) {\n+        super(0, 0, 0, days, hours, minutes, seconds, millis, DurationType.getDayHourType());\n+    }\n+\n+    /**\n+     * Create a duration from a set of field values using AllType.\n+     * AllType using ISOChronology in UTC is an imprecise duration type\n+     * unless the year, month and week fields are zero.\n+     *\n+     * @param years  amount of years in this duration\n+     * @param months  amount of months in this duration\n+     * @param weeks  amount of weeks in this duration\n+     * @param days  amount of days in this duration\n+     * @param hours  amount of hours in this duration\n+     * @param minutes  amount of minutes in this duration\n+     * @param seconds  amount of seconds in this duration\n+     * @param millis  amount of milliseconds in this duration\n+     */\n+    public Duration(int years, int months, int weeks, int days,\n+                    int hours, int minutes, int seconds, int millis) {\n+        super(years, months, weeks, days, hours, minutes, seconds, millis, null);\n     }\n \n     /**\n      * Create a duration from a set of field values.\n      *\n-     * @param type determines which set of fields this duration supports\n-     * @param years amount of years in this duration, which must be zero if\n-     * unsupported.\n-     * @param months amount of months in this duration, which must be zero if\n-     * unsupported.\n-     * @param weeks amount of weeks in this duration, which must be zero if\n-     * unsupported.\n-     * @param days amount of days in this duration, which must be zero if\n-     * unsupported.\n-     * @param hours amount of hours in this duration, which must be zero if\n-     * unsupported.\n-     * @param minutes amount of minutes in this duration, which must be zero if\n-     * unsupported.\n-     * @param seconds amount of seconds in this duration, which must be zero if\n-     * unsupported.\n-     * @param millis amount of milliseconds in this duration, which must be\n-     * zero if unsupported.\n-     * @throws IllegalArgumentException if type is null\n-     * @throws UnsupportedOperationException if an unsupported field's value is\n-     * non-zero\n-     */\n-    public Duration(DurationType type,\n-                    int years, int months, int weeks, int days,\n-                    int hours, int minutes, int seconds, int millis) {\n-        super(type, years, months, weeks, days, hours, minutes, seconds, millis);\n+     * @param years  amount of years in this duration, which must be zero if unsupported\n+     * @param months  amount of months in this duration, which must be zero if unsupported\n+     * @param weeks  amount of weeks in this duration, which must be zero if unsupported\n+     * @param days  amount of days in this duration, which must be zero if unsupported\n+     * @param hours  amount of hours in this duration, which must be zero if unsupported\n+     * @param minutes  amount of minutes in this duration, which must be zero if unsupported\n+     * @param seconds  amount of seconds in this duration, which must be zero if unsupported\n+     * @param millis  amount of milliseconds in this duration, which must be zero if unsupported\n+     * @param type  which set of fields this duration supports, null means AllType\n+     * @throws UnsupportedOperationException if an unsupported field's value is non-zero\n+     */\n+    public Duration(int years, int months, int weeks, int days,\n+                    int hours, int minutes, int seconds, int millis, DurationType type) {\n+        super(years, months, weeks, days, hours, minutes, seconds, millis, type);\n+    }\n+\n+    /**\n+     * Creates a duration from the given interval endpoints using AllType.\n+     * This constructor creates a precise duration.\n+     *\n+     * @param startInstant  interval start, in milliseconds\n+     * @param endInstant  interval end, in milliseconds\n+     */\n+    public Duration(long startInstant, long endInstant) {\n+        super(startInstant, endInstant, null);\n     }\n \n     /**\n      * Creates a duration from the given interval endpoints.\n-     *\n-     * @param type determines which set of fields this duration supports\n-     * @param startInstant interval start, in milliseconds\n-     * @param endInstant interval end, in milliseconds\n-     * @throws IllegalArgumentException if type is null\n-     */\n-    public Duration(DurationType type, long startInstant, long endInstant) {\n-        super(type, startInstant, endInstant);\n+     * This constructor creates a precise duration.\n+     *\n+     * @param startInstant  interval start, in milliseconds\n+     * @param endInstant  interval end, in milliseconds\n+     * @param type  which set of fields this duration supports, null means AllType\n+     */\n+    public Duration(long startInstant, long endInstant, DurationType type) {\n+        super(startInstant, endInstant, type);\n+    }\n+\n+    /**\n+     * Creates a duration from the given interval endpoints using AllType.\n+     * This constructor creates a precise duration.\n+     *\n+     * @param startInstant  interval start, null means now\n+     * @param endInstant  interval end, null means now\n+     */\n+    public Duration(ReadableInstant startInstant, ReadableInstant endInstant) {\n+        super(startInstant, endInstant, null);\n     }\n \n     /**\n      * Creates a duration from the given interval endpoints.\n-     *\n-     * @param type determines which set of fields this duration supports\n-     * @param startInstant interval start\n-     * @param endInstant interval end\n-     * @throws IllegalArgumentException if type is null\n-     */\n-    public Duration(DurationType type,\n-                    ReadableInstant startInstant, ReadableInstant endInstant) {\n-        super(type, startInstant, endInstant);\n-    }\n-\n-    /**\n-     * Creates a duration from the given millisecond duration. If any supported\n-     * fields are imprecise, an UnsupportedOperationException is thrown. The\n-     * exception to this is when the specified duration is zero.\n-     *\n-     * @param type determines which set of fields this duration supports\n+     * This constructor creates a precise duration.\n+     *\n+     * @param startInstant  interval start, null means now\n+     * @param endInstant  interval end, null means now\n+     * @param type  which set of fields this duration supports, null means AllType\n+     */\n+    public Duration(ReadableInstant startInstant, ReadableInstant endInstant, DurationType type) {\n+        super(startInstant, endInstant, type);\n+    }\n+\n+    /**\n+     * Creates a duration from the given millisecond duration using MillisType.\n+     * This constructor creates a precise duration because\n+     * MillisType in ISOChronology UTC is precise.\n+     *\n      * @param duration  the duration, in milliseconds\n-     * @throws IllegalArgumentException if type is null\n+     */\n+    public Duration(long duration) {\n+        super(duration, null);\n+    }\n+\n+    /**\n+     * Creates a duration from the given millisecond duration.\n+     * This constructor creates a precise duration.\n+     *\n+     * @param duration  the duration, in milliseconds\n+     * @param type  which set of fields this duration supports\n      * @throws UnsupportedOperationException if any fields are imprecise\n      */\n-    public Duration(DurationType type, long duration) {\n-        super(type, duration);\n-    }\n-\n-    /**\n-     * Overridden to do nothing, ensuring this class and all subclasses are\n-     * immutable.\n+    public Duration(long duration, DurationType type) {\n+        super(duration, type);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Overridden to do nothing, ensuring this class and all subclasses are immutable.\n      */\n     protected final void setDuration(ReadableDuration duration) {\n     }\n \n     /**\n-     * Overridden to do nothing, ensuring this class and all subclasses are\n-     * immutable.\n+     * Overridden to do nothing, ensuring this class and all subclasses are immutable.\n      */\n     protected final void setDuration(int years, int months, int weeks, int days,\n                                      int hours, int minutes, int seconds, int millis) {\n     }\n \n     /**\n-     * Overridden to do nothing, ensuring this class and all subclasses are\n-     * immutable.\n+     * Overridden to do nothing, ensuring this class and all subclasses are immutable.\n      */\n     protected final void setTotalMillis(long startInstant, long endInstant) {\n     }\n \n     /**\n-     * Overridden to do nothing, ensuring this class and all subclasses are\n-     * immutable.\n+     * Overridden to do nothing, ensuring this class and all subclasses are immutable.\n      */\n     protected final void setTotalMillis(long duration) {\n     }\n \n     /**\n-     * Overridden to do nothing, ensuring this class and all subclasses are\n-     * immutable.\n+     * Overridden to do nothing, ensuring this class and all subclasses are immutable.\n      */\n     protected final void normalize() {\n     }\n \n     /**\n-     * Overridden to do nothing, ensuring this class and all subclasses are\n-     * immutable.\n+     * Overridden to do nothing, ensuring this class and all subclasses are immutable.\n      */\n     protected final void setYears(int years) {\n     }\n \n     /**\n-     * Overridden to do nothing, ensuring this class and all subclasses are\n-     * immutable.\n+     * Overridden to do nothing, ensuring this class and all subclasses are immutable.\n      */\n     protected final void setMonths(int months) {\n     }\n \n     /**\n-     * Overridden to do nothing, ensuring this class and all subclasses are\n-     * immutable.\n+     * Overridden to do nothing, ensuring this class and all subclasses are immutable.\n      */\n     protected final void setWeeks(int weeks) {\n     }\n \n     /**\n-     * Overridden to do nothing, ensuring this class and all subclasses are\n-     * immutable.\n+     * Overridden to do nothing, ensuring this class and all subclasses are immutable.\n      */\n     protected final void setDays(int days) {\n     }\n \n     /**\n-     * Overridden to do nothing, ensuring this class and all subclasses are\n-     * immutable.\n+     * Overridden to do nothing, ensuring this class and all subclasses are immutable.\n      */\n     protected final void setHours(int hours) {\n     }\n \n     /**\n-     * Overridden to do nothing, ensuring this class and all subclasses are\n-     * immutable.\n+     * Overridden to do nothing, ensuring this class and all subclasses are immutable.\n      */\n     protected final void setMinutes(int minutes) {\n     }\n \n     /**\n-     * Overridden to do nothing, ensuring this class and all subclasses are\n-     * immutable.\n+     * Overridden to do nothing, ensuring this class and all subclasses are immutable.\n      */\n     protected final void setSeconds(int seconds) {\n     }\n \n     /**\n-     * Overridden to do nothing, ensuring this class and all subclasses are\n-     * immutable.\n+     * Overridden to do nothing, ensuring this class and all subclasses are immutable.\n      */\n     protected final void setMillis(int millis) {\n     }\n--- a/JodaTime/src/java/org/joda/time/DurationType.java\n+++ b/JodaTime/src/java/org/joda/time/DurationType.java\n  * <ul>\n  * <li>Millis - the duration is defined only in terms of milliseconds, other\n  *  fields are not used\n+ * <li>All - the duration is defined to permit all fields to be used\n  * <li>DayHour - the duration is expressed in terms of days, hours, minutes, seconds\n  *  and milliseconds\n  * <li>YearMonth - the duration is expressed using all fields except weeks\n      * <ul>\n      * <li>years\n      * <li>months\n+     * <li>weeks\n+     * <li>days\n+     * <li>hours\n+     * <li>minutes\n+     * <li>seconds\n+     * <li>milliseconds\n+     * </ul>\n+     */\n+    public static DurationType getAllType() {\n+        return getAllType(null);\n+    }\n+\n+    /**\n+     * Returns a DurationType of:\n+     *\n+     * <ul>\n+     * <li>years\n+     * <li>months\n+     * <li>weeks\n+     * <li>days\n+     * <li>hours\n+     * <li>minutes\n+     * <li>seconds\n+     * <li>milliseconds\n+     * </ul>\n+     *\n+     * This factory method returns a DurationType that calculates using any\n+     * Chronology. For best results, the Chronology's time zone should\n+     * be UTC or have fixed offsets.\n+     *\n+     * @param chrono Chronology to use for calculations.\n+     */\n+    public static DurationType getAllType(Chronology chrono) {\n+        if (chrono == null) {\n+            chrono = ISOChronology.getInstanceUTC();\n+        }\n+        return new AllType(chrono);\n+    }\n+\n+    /**\n+     * Returns a DurationType of:\n+     *\n+     * <ul>\n+     * <li>years\n+     * <li>months\n      * <li>days\n      * <li>hours\n      * <li>minutes\n         return new PreciseYearWeekType(ISOChronology.getInstanceUTC());\n     }\n \n+    /**\n+     * Constructor.\n+     */\n     protected DurationType() {\n     }\n \n     /**\n+     * Gets the name of the duration type.\n+     * \n+     * @return the name\n+     */\n+    public abstract String getName();\n+\n+    /**\n      * Returns the chronology used, or null if none.\n+     * \n+     * @return the chronology\n      */\n     public abstract Chronology getChronology();\n \n     /**\n      * Returns a DurationType that uses the given chronology.\n+     * \n+     * @param chrono  the new chronology\n+     * @return a new duration type with the specified chronology\n      */\n     public abstract DurationType withChronology(Chronology chrono);\n \n     /**\n      * Returns true if every supported field in this type is precise.\n+     * \n+     * @return true if precise\n      */\n     public abstract boolean isPrecise();\n \n             + millis().hashCode();\n         return hash;\n     }\n-\n+    \n+    public String toString() {\n+        String name = getName();\n+        return \"DurationType[\" + (name == null ? \"\" : name) + \"]\";\n+    }\n+\n+    //-----------------------------------------------------------------------\n     private static final class MillisType extends DurationType {\n         static final long serialVersionUID = -4314867016852780422L;\n \n \n         private Object readResolve() {\n             return getMillisType();\n+        }\n+        \n+        public String getName() {\n+            return \"MillisType\";\n         }\n     }\n \n         private Object readResolve() {\n             return getDayHourType(iChronology);\n         }\n+        \n+        public String getName() {\n+            return \"DayHourType\";\n+        }\n+    }\n+\n+    private static final class AllType extends DayHourType {\n+        static final long serialVersionUID = -1336767257680877683L;\n+\n+        public AllType(Chronology chrono) {\n+            super(chrono);\n+        }\n+\n+        public DurationType withChronology(Chronology chrono) {\n+            if (chrono == iChronology) {\n+                return this;\n+            }\n+            return new AllType(iChronology);\n+        }\n+\n+        public boolean isPrecise() {\n+            return years().isPrecise()\n+                && months().isPrecise()\n+                && weeks().isPrecise()\n+                && super.isPrecise();\n+        }\n+\n+        public DurationField years() {\n+            return iChronology.years();\n+        }\n+\n+        public DurationField months() {\n+            return iChronology.months();\n+        }\n+\n+        public DurationField weeks() {\n+            return iChronology.weeks();\n+        }\n+\n+        private Object readResolve() {\n+            return getAllType(iChronology);\n+        }\n+        \n+        public String getName() {\n+            return \"AllType\";\n+        }\n     }\n \n     private static final class YearMonthType extends DayHourType {\n         private Object readResolve() {\n             return getYearMonthType(iChronology);\n         }\n+        \n+        public String getName() {\n+            return \"YearMonthType\";\n+        }\n     }\n \n     private static final class YearWeekType extends DayHourType {\n         private Object readResolve() {\n             return getYearWeekType(iChronology);\n         }\n+        \n+        public String getName() {\n+            return \"YearWeekType\";\n+        }\n     }\n \n     private static final class AverageYearMonthType extends DayHourType {\n         private Object readResolve() {\n             return getAverageYearMonthType(iChronology);\n         }\n+        \n+        public String getName() {\n+            return \"AverageYearMonthType\";\n+        }\n     }\n \n     private static final class PreciseYearMonthType extends DayHourType {\n         private Object readResolve() {\n             return getPreciseYearMonthType();\n         }\n+        \n+        public String getName() {\n+            return \"PreciseYearMonthType\";\n+        }\n     }\n \n     private static final class PreciseYearWeekType extends DayHourType {\n \n         private Object readResolve() {\n             return getPreciseYearWeekType();\n+        }\n+        \n+        public String getName() {\n+            return \"PreciseYearWeekType\";\n         }\n     }\n \n             }\n             return iType.millis();\n         }\n+        \n+        public String getName() {\n+            String name = iType.getName();\n+            return \"Masked[\" + (name == null ? \"\" : name) + \"]\";\n+        }\n     }\n \n }\n--- a/JodaTime/src/java/org/joda/time/MutableDuration.java\n+++ b/JodaTime/src/java/org/joda/time/MutableDuration.java\n \n import java.io.Serializable;\n \n-import org.joda.time.convert.DurationConverter;\n-import org.joda.time.convert.ConverterManager;\n-\n /**\n  * Standard mutable duration implementation.\n  * <p>\n     static final long serialVersionUID = 3436451121567212165L;\n \n     /**\n-     * Copies another duration to this one.\n-     *\n-     * @param duration duration to copy\n-     * @throws IllegalArgumentException if duration is null\n-     * @throws UnsupportedOperationException if an unsupported field's value is\n-     * non-zero\n-     */\n-    public MutableDuration(ReadableDuration duration) {\n-        super(duration);\n-    }\n-\n-    /**\n-     * Copies another duration to this one.\n-     *\n-     * @param duration duration to convert\n-     * @throws IllegalArgumentException if duration is null\n-     * @throws UnsupportedOperationException if an unsupported field's value is\n-     * non-zero\n-     */\n-    public MutableDuration(Object duration) {\n-        super(duration);\n+     * Creates a zero length millisecond duration using MillisType.\n+     * MillisType using ISOChronology in UTC is a precise duration type.\n+     */\n+    public MutableDuration() {\n+        super((DurationType) null);\n     }\n \n     /**\n      * Creates a zero length duration.\n      *\n-     * @param type determines which set of fields this duration supports\n-     * @throws IllegalArgumentException if type is null\n+     * @param type  which set of fields this duration supports, null means MillisType\n      */\n     public MutableDuration(DurationType type) {\n         super(type);\n     }\n \n     /**\n-     * Copies another duration to this one.\n-     *\n-     * @param type use a different DurationType\n-     * @param duration duration to copy\n-     * @throws IllegalArgumentException if type or duration is null\n-     * @throws UnsupportedOperationException if an unsupported field's value is\n-     * non-zero\n-     */\n-    public MutableDuration(DurationType type, ReadableDuration duration) {\n-        super(type, duration);\n-    }\n-\n-    /**\n-     * Copies another duration to this one.\n-     *\n-     * @param type use a different DurationType\n-     * @param duration duration to convert\n-     * @throws IllegalArgumentException if type or duration is null\n-     * @throws UnsupportedOperationException if an unsupported field's value is\n-     * non-zero\n-     */\n-    public MutableDuration(DurationType type, Object duration) {\n-        super(type, duration);\n+     * Creates a duration from the specified object using the\n+     * {@link org.joda.time.convert.ConverterManager ConverterManager}.\n+     *\n+     * @param duration  duration to convert\n+     * @throws IllegalArgumentException if duration is invalid\n+     * @throws UnsupportedOperationException if an unsupported field's value is non-zero\n+     */\n+    public MutableDuration(Object duration) {\n+        super(duration, null);\n+    }\n+\n+    /**\n+     * Creates a duration from the specified object using the\n+     * {@link org.joda.time.convert.ConverterManager ConverterManager}.\n+     *\n+     * @param duration  duration to convert\n+     * @param type  which set of fields this duration supports, null means use converter\n+     * @throws IllegalArgumentException if duration is invalid\n+     * @throws UnsupportedOperationException if an unsupported field's value is non-zero\n+     */\n+    public MutableDuration(Object duration, DurationType type) {\n+        super(duration, type);\n+    }\n+\n+    /**\n+     * Create a duration from a set of field values using DayHourType.\n+     * DayHourType using ISOChronology in UTC is a precise duration type.\n+     *\n+     * @param days  amount of days in this duration\n+     * @param hours  amount of hours in this duration\n+     * @param minutes  amount of minutes in this duration\n+     * @param seconds  amount of seconds in this duration\n+     * @param millis  amount of milliseconds in this duration\n+     */\n+    public MutableDuration(int days, int hours, int minutes, int seconds, int millis) {\n+        super(0, 0, 0, days, hours, minutes, seconds, millis, DurationType.getDayHourType());\n+    }\n+\n+    /**\n+     * Create a duration from a set of field values using AllType.\n+     * AllType using ISOChronology in UTC is an imprecise duration type\n+     * unless the year, month and week fields are zero.\n+     *\n+     * @param years  amount of years in this duration, which must be zero if unsupported\n+     * @param months  amount of months in this duration, which must be zero if unsupported\n+     * @param weeks  amount of weeks in this duration, which must be zero if unsupported\n+     * @param days  amount of days in this duration, which must be zero if unsupported\n+     * @param hours  amount of hours in this duration, which must be zero if unsupported\n+     * @param minutes  amount of minutes in this duration, which must be zero if unsupported\n+     * @param seconds  amount of seconds in this duration, which must be zero if unsupported\n+     * @param millis  amount of milliseconds in this duration, which must be zero if unsupported\n+     * @throws UnsupportedOperationException if an unsupported field's value is non-zero\n+     */\n+    public MutableDuration(int years, int months, int weeks, int days,\n+                    int hours, int minutes, int seconds, int millis) {\n+        super(years, months, weeks, days, hours, minutes, seconds, millis, null);\n     }\n \n     /**\n      * Create a duration from a set of field values.\n      *\n-     * @param type determines which set of fields this duration supports\n-     * @param years amount of years in this duration, which must be zero if\n-     * unsupported.\n-     * @param months amount of months in this duration, which must be zero if\n-     * unsupported.\n-     * @param weeks amount of weeks in this duration, which must be zero if\n-     * unsupported.\n-     * @param days amount of days in this duration, which must be zero if\n-     * unsupported.\n-     * @param hours amount of hours in this duration, which must be zero if\n-     * unsupported.\n-     * @param minutes amount of minutes in this duration, which must be zero if\n-     * unsupported.\n-     * @param seconds amount of seconds in this duration, which must be zero if\n-     * unsupported.\n-     * @param millis amount of milliseconds in this duration, which must be\n-     * zero if unsupported.\n-     * @throws IllegalArgumentException if type is null\n-     * @throws UnsupportedOperationException if an unsupported field's value is\n-     * non-zero\n-     */\n-    public MutableDuration(DurationType type,\n-                           int years, int months, int weeks, int days,\n-                           int hours, int minutes, int seconds, int millis) {\n-        super(type, years, months, weeks, days, hours, minutes, seconds, millis);\n+     * @param years  amount of years in this duration, which must be zero if unsupported\n+     * @param months  amount of months in this duration, which must be zero if unsupported\n+     * @param weeks  amount of weeks in this duration, which must be zero if unsupported\n+     * @param days  amount of days in this duration, which must be zero if unsupported\n+     * @param hours  amount of hours in this duration, which must be zero if unsupported\n+     * @param minutes  amount of minutes in this duration, which must be zero if unsupported\n+     * @param seconds  amount of seconds in this duration, which must be zero if unsupported\n+     * @param millis  amount of milliseconds in this duration, which must be zero if unsupported\n+     * @param type  which set of fields this duration supports, null means AllType\n+     * @throws UnsupportedOperationException if an unsupported field's value is non-zero\n+     */\n+    public MutableDuration(int years, int months, int weeks, int days,\n+                    int hours, int minutes, int seconds, int millis, DurationType type) {\n+        super(years, months, weeks, days, hours, minutes, seconds, millis, type);\n+    }\n+\n+    /**\n+     * Creates a duration from the given interval endpoints using AllType.\n+     * AllType using ISOChronology in UTC is an imprecise duration type\n+     * unless the year, month and week fields are zero.\n+     *\n+     * @param startInstant  interval start, in milliseconds\n+     * @param endInstant  interval end, in milliseconds\n+     */\n+    public MutableDuration(long startInstant, long endInstant) {\n+        super(startInstant, endInstant, null);\n     }\n \n     /**\n      * Creates a duration from the given interval endpoints.\n      *\n-     * @param type determines which set of fields this duration supports\n-     * @param startInstant interval start, in milliseconds\n-     * @param endInstant interval end, in milliseconds\n-     * @throws IllegalArgumentException if type is null\n-     */\n-    public MutableDuration(DurationType type, long startInstant, long endInstant) {\n-        super(type, startInstant, endInstant);\n+     * @param startInstant  interval start, in milliseconds\n+     * @param endInstant  interval end, in milliseconds\n+     * @param type  which set of fields this duration supports, null means AllType\n+     */\n+    public MutableDuration(long startInstant, long endInstant, DurationType type) {\n+        super(startInstant, endInstant, type);\n+    }\n+\n+    /**\n+     * Creates a duration from the given interval endpoints using AllType.\n+     * AllType using ISOChronology in UTC is an imprecise duration type\n+     * unless the year, month and week fields are zero.\n+     *\n+     * @param startInstant  interval start, null means now\n+     * @param endInstant  interval end, null means now\n+     */\n+    public MutableDuration(ReadableInstant startInstant, ReadableInstant endInstant) {\n+        super(startInstant, endInstant, null);\n     }\n \n     /**\n      * Creates a duration from the given interval endpoints.\n      *\n-     * @param type determines which set of fields this duration supports\n-     * @param startInstant interval start\n-     * @param endInstant interval end\n-     * @throws IllegalArgumentException if type is null\n-     */\n-    public MutableDuration(DurationType type,\n-                           ReadableInstant startInstant, ReadableInstant endInstant) {\n-        super(type, startInstant, endInstant);\n-    }\n-\n-    /**\n-     * Creates a duration from the given millisecond duration. If any supported\n-     * fields are imprecise, an UnsupportedOperationException is thrown. The\n-     * exception to this is when the specified duration is zero.\n-     *\n-     * @param type determines which set of fields this duration supports\n+     * @param startInstant  interval start, null means now\n+     * @param endInstant  interval end, null means now\n+     * @param type  which set of fields this duration supports, null means AllType\n+     */\n+    public MutableDuration(\n+            ReadableInstant startInstant, ReadableInstant endInstant, DurationType type) {\n+        super(startInstant, endInstant, type);\n+    }\n+\n+    /**\n+     * Creates a duration from the given millisecond duration using MillisType.\n+     * MillisType using ISOChronology in UTC is a precise duration type.\n+     *\n      * @param duration  the duration, in milliseconds\n-     * @throws IllegalArgumentException if type or duration is null\n+     */\n+    public MutableDuration(long duration) {\n+        super(duration, null);\n+    }\n+\n+    /**\n+     * Creates a duration from the given millisecond duration.\n+     *\n+     * @param duration  the duration, in milliseconds\n+     * @param type  which set of fields this duration supports\n      * @throws UnsupportedOperationException if any fields are imprecise\n      */\n-    public MutableDuration(DurationType type, long duration) {\n-        super(type, duration);\n-    }\n-\n+    public MutableDuration(long duration, DurationType type) {\n+        super(duration, type);\n+    }\n+\n+    //-----------------------------------------------------------------------\n     /**\n      * Sets all the fields in one go from another ReadableDuration.\n      * \n     /**\n      * Sets all the fields in one go.\n      * \n-     * @param years amount of years in this duration, which must be zero if\n-     * unsupported.\n-     * @param months amount of months in this duration, which must be zero if\n-     * unsupported.\n-     * @param weeks amount of weeks in this duration, which must be zero if\n-     * unsupported.\n-     * @param days amount of days in this duration, which must be zero if\n-     * unsupported.\n-     * @param hours amount of hours in this duration, which must be zero if\n-     * unsupported.\n-     * @param minutes amount of minutes in this duration, which must be zero if\n-     * unsupported.\n-     * @param seconds amount of seconds in this duration, which must be zero if\n-     * unsupported.\n-     * @param millis amount of milliseconds in this duration, which must be\n-     * zero if unsupported.\n+     * @param years  amount of years in this duration, which must be zero if unsupported\n+     * @param months  amount of months in this duration, which must be zero if unsupported\n+     * @param weeks  amount of weeks in this duration, which must be zero if unsupported\n+     * @param days  amount of days in this duration, which must be zero if unsupported\n+     * @param hours  amount of hours in this duration, which must be zero if unsupported\n+     * @param minutes  amount of minutes in this duration, which must be zero if unsupported\n+     * @param seconds  amount of seconds in this duration, which must be zero if unsupported\n+     * @param millis  amount of milliseconds in this duration, which must be zero if unsupported\n      * @throws UnsupportedOperationException if an unsupported field's value is\n      * non-zero\n      */\n--- a/JodaTime/src/java/org/joda/time/convert/StringConverter.java\n+++ b/JodaTime/src/java/org/joda/time/convert/StringConverter.java\n      * @throws ClassCastException if the object is invalid\n      */\n     public DurationType getDurationType(Object object) {\n-        String str = (String) object;\n-        if (str.indexOf('W') >= 0) {\n-            return DurationType.getYearWeekType();\n-        }\n-        return DurationType.getYearMonthType();\n+        return DurationType.getAllType();\n     }\n \n     /**\n--- a/JodaTime/src/java/org/joda/time/format/AbstractDurationFormatter.java\n+++ b/JodaTime/src/java/org/joda/time/format/AbstractDurationFormatter.java\n \n     public MutableDuration parseMutableDuration(DurationType type, String text) {\n         DurationParser p = (DurationParser) this;\n-        MutableDuration duration = new MutableDuration(type, 0);\n+        MutableDuration duration = new MutableDuration(0, type);\n \n         int newPos = p.parseInto(duration, text, 0);\n         if (newPos >= 0) {\n--- a/JodaTime/src/java/org/joda/time/format/DurationFormatterBuilder.java\n+++ b/JodaTime/src/java/org/joda/time/format/DurationFormatterBuilder.java\n import java.util.ArrayList;\n import java.util.List;\n \n-import org.joda.time.DurationField;\n import org.joda.time.DurationType;\n+import org.joda.time.ReadWritableDuration;\n import org.joda.time.ReadableDuration;\n-import org.joda.time.ReadWritableDuration;\n \n /**\n  * DurationFormatterBuilder is used for constructing {@link DurationFormatter}s.\n     }\n \n     /**\n-     * Instruct the printer to emit a decimal years field, if supported.\n+     * Instruct the printer to emit an integer years field, if supported.\n      *\n      * @return this DurationFormatterBuilder\n      */\n     }\n \n     /**\n-     * Instruct the printer to emit a decimal years field, if supported.\n+     * Instruct the printer to emit an integer years field, if supported.\n      *\n      * @return this DurationFormatterBuilder\n      */\n     }\n \n     /**\n-     * Instruct the printer to emit a decimal weeks field, if supported.\n+     * Instruct the printer to emit an integer weeks field, if supported.\n      *\n      * @return this DurationFormatterBuilder\n      */\n     }\n \n     /**\n-     * Instruct the printer to emit a decimal days field, if supported.\n+     * Instruct the printer to emit an integer days field, if supported.\n      *\n      * @return this DurationFormatterBuilder\n      */\n     }\n \n     /**\n-     * Instruct the printer to emit a decimal hours field, if supported.\n+     * Instruct the printer to emit an integer hours field, if supported.\n      *\n      * @return this DurationFormatterBuilder\n      */\n     }\n \n     /**\n-     * Instruct the printer to emit a decimal minutes field, if supported.\n+     * Instruct the printer to emit an integer minutes field, if supported.\n      *\n      * @return this DurationFormatterBuilder\n      */\n     }\n \n     /**\n-     * Instruct the printer to emit a decimal seconds field, if supported.\n+     * Instruct the printer to emit an integer seconds field, if supported.\n      *\n      * @return this DurationFormatterBuilder\n      */\n     }\n \n     /**\n-     * Instruct the printer to emit a decimal millis field, if supported.\n+     * Instruct the printer to emit an integer millis field, if supported.\n      *\n      * @return this DurationFormatterBuilder\n      */\n         return this;\n     }\n \n+    /**\n+     * Instruct the printer to emit an integer millis field, if supported.\n+     *\n+     * @return this DurationFormatterBuilder\n+     */\n+    public DurationFormatterBuilder appendMillis3Digit() {\n+        appendField(8, 3);\n+        return this;\n+    }\n+\n     private void appendField(int type) {\n-        FieldFormatter field = new FieldFormatter\n-            (iMinPrintedDigits, iPrintZeroSetting,\n-             iMaxParsedDigits, iRejectSignedValues,\n-             type, iPrefix, null);\n+        appendField(type, iMinPrintedDigits);\n+    }\n+\n+    private void appendField(int type, int minPrinted) {\n+        FieldFormatter field = new FieldFormatter(minPrinted, iPrintZeroSetting,\n+            iMaxParsedDigits, iRejectSignedValues, type, iPrefix, null);\n         iFormatters.add(field);\n         if (iPrintZeroSetting == PRINT_ZERO_RARELY) {\n             iAlternateFormatters.add(field);\n--- a/JodaTime/src/java/org/joda/time/format/ISODurationFormat.java\n+++ b/JodaTime/src/java/org/joda/time/format/ISODurationFormat.java\n     }\n \n     /**\n-     * PyYmMwWdDThHmMsS\n+     * The standard ISO format - PyYmMwWdDThHmMsS.\n+     * Milliseconds are not output.\n      */\n     public DurationFormatter standard() {\n         if (iStandard == null) {\n             iStandard = new DurationFormatterBuilder()\n                 .appendLiteral(\"P\")\n-                .printZeroIfSupported()\n+                .printZeroRarely()\n                 .appendYears()\n                 .appendSuffix(\"Y\")\n                 .appendMonths()\n--- a/JodaTime/src/test/org/joda/time/TestAll.java\n+++ b/JodaTime/src/test/org/joda/time/TestAll.java\n         suite.addTest(TestDateMidnight_Basics.suite());\n         suite.addTest(TestDateMidnight_Properties.suite());\n         \n+        suite.addTest(TestDuration_Constructors.suite());\n+        \n         suite.addTest(TestTimeOfDay.suite());\n         suite.addTest(TestYearMonthDay.suite());\n         \n--- /dev/null\n+++ b/JodaTime/src/test/org/joda/time/TestDuration_Basics.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.util.Locale;\n+import java.util.TimeZone;\n+\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+/**\n+ * This class is a Junit unit test for DateTime.\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class TestDuration_Basics extends TestCase {\n+    // Test in 2002/03 as time zones are more well known\n+    // (before the late 90's they were all over the place)\n+\n+    private static final DateTimeZone PARIS = DateTimeZone.getInstance(\"Europe/Paris\");\n+    private static final DateTimeZone LONDON = DateTimeZone.getInstance(\"Europe/London\");\n+    \n+    long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + \n+                     366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + \n+                     365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +\n+                     366 + 365;\n+    long y2003days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + \n+                     366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + \n+                     365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +\n+                     366 + 365 + 365;\n+    \n+    // 2002-06-09\n+    private long TEST_TIME_NOW =\n+            (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;\n+            \n+    // 2002-04-05\n+    private long TEST_TIME1 =\n+            (y2002days + 31L + 28L + 31L + 5L -1L) * DateTimeConstants.MILLIS_PER_DAY\n+            + 12L * DateTimeConstants.MILLIS_PER_HOUR\n+            + 24L * DateTimeConstants.MILLIS_PER_MINUTE;\n+        \n+    // 2003-05-06\n+    private long TEST_TIME2 =\n+            (y2003days + 31L + 28L + 31L + 30L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY\n+            + 14L * DateTimeConstants.MILLIS_PER_HOUR\n+            + 28L * DateTimeConstants.MILLIS_PER_MINUTE;\n+    \n+    private DateTimeZone originalDateTimeZone = null;\n+    private TimeZone originalTimeZone = null;\n+    private Locale originalLocale = null;\n+\n+    public static void main(String[] args) {\n+        junit.textui.TestRunner.run(suite());\n+    }\n+\n+    public static TestSuite suite() {\n+        return new TestSuite(TestDuration_Basics.class);\n+    }\n+\n+    public TestDuration_Basics(String name) {\n+        super(name);\n+    }\n+\n+    protected void setUp() throws Exception {\n+        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);\n+        originalDateTimeZone = DateTimeZone.getDefault();\n+        originalTimeZone = TimeZone.getDefault();\n+        originalLocale = Locale.getDefault();\n+        DateTimeZone.setDefault(LONDON);\n+        TimeZone.setDefault(TimeZone.getTimeZone(\"Europe/London\"));\n+        Locale.setDefault(Locale.UK);\n+    }\n+\n+    protected void tearDown() throws Exception {\n+        DateTimeUtils.setCurrentMillisSystem();\n+        DateTimeZone.setDefault(originalDateTimeZone);\n+        TimeZone.setDefault(originalTimeZone);\n+        Locale.setDefault(originalLocale);\n+        originalDateTimeZone = null;\n+        originalTimeZone = null;\n+        originalLocale = null;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testTest() {\n+        assertEquals(\"2002-06-09T00:00:00.000Z\", new Instant(TEST_TIME_NOW).toString());\n+        assertEquals(\"2002-04-05T12:24:00.000Z\", new Instant(TEST_TIME1).toString());\n+        assertEquals(\"2003-05-06T14:28:00.000Z\", new Instant(TEST_TIME2).toString());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testGetDurationType() {\n+        Duration test = new Duration();\n+        assertEquals(DurationType.getMillisType(), test.getDurationType());\n+    }\n+\n+    public void testGetTotalMillis() {\n+        Duration test = new Duration(123L);\n+        assertEquals(123L, test.getTotalMillis());\n+    }\n+\n+    public void testGetIsPrecise() {\n+        Duration test = new Duration(123L);\n+        assertEquals(true, test.isPrecise());\n+        test = new Duration(1, 2, 3, 4, 5, 6, 7, 8);\n+        assertEquals(false, test.isPrecise());\n+    }\n+\n+    public void testGetMethods() {\n+        Duration test = new Duration();\n+        assertEquals(0, test.getYears());\n+        assertEquals(0, test.getMonths());\n+        assertEquals(0, test.getDays());\n+        assertEquals(0, test.getWeeks());\n+        assertEquals(0, test.getDays());\n+        assertEquals(0, test.getHours());\n+        assertEquals(0, test.getMinutes());\n+        assertEquals(0, test.getSeconds());\n+        assertEquals(0, test.getMillis());\n+    }\n+\n+    public void testEqualsHashCode() {\n+        Duration test1 = new Duration(123L);\n+        Duration test2 = new Duration(123L);\n+        assertEquals(true, test1.equals(test2));\n+        assertEquals(true, test2.equals(test1));\n+        assertEquals(true, test1.equals(test1));\n+        assertEquals(true, test2.equals(test2));\n+        assertEquals(true, test1.hashCode() == test2.hashCode());\n+        assertEquals(true, test1.hashCode() == test1.hashCode());\n+        assertEquals(true, test2.hashCode() == test2.hashCode());\n+        \n+        Duration test3 = new Duration(321L);\n+        assertEquals(false, test1.equals(test3));\n+        assertEquals(false, test2.equals(test3));\n+        assertEquals(false, test3.equals(test1));\n+        assertEquals(false, test3.equals(test2));\n+        assertEquals(false, test1.hashCode() == test3.hashCode());\n+        assertEquals(false, test2.hashCode() == test3.hashCode());\n+        \n+        assertEquals(false, test1.equals(\"Hello\"));\n+        assertEquals(true, test1.equals(new MockDuration(123L)));\n+        assertEquals(false, test1.equals(new Duration(123L, DurationType.getAverageYearMonthType())));\n+    }\n+    \n+    class MockDuration extends AbstractDuration {\n+        public MockDuration(long value) {\n+            super(value, null);\n+        }\n+    }\n+\n+    public void testCompareTo() {\n+        Duration test1 = new Duration(123L);\n+        Duration test1a = new Duration(123L);\n+        assertEquals(0, test1.compareTo(test1a));\n+        assertEquals(0, test1a.compareTo(test1));\n+        assertEquals(0, test1.compareTo(test1));\n+        assertEquals(0, test1a.compareTo(test1a));\n+        \n+        Duration test2 = new Duration(321L);\n+        assertEquals(-1, test1.compareTo(test2));\n+        assertEquals(+1, test2.compareTo(test1));\n+        \n+        Duration test3 = new Duration(321L, DurationType.getAllType());\n+        assertEquals(-1, test1.compareTo(test3));\n+        assertEquals(+1, test3.compareTo(test1));\n+        assertEquals(0, test3.compareTo(test2));\n+        \n+        assertEquals(+1, test2.compareTo(new MockDuration(123L)));\n+        assertEquals(0, test1.compareTo(new MockDuration(123L)));\n+        \n+        try {\n+            test1.compareTo(null);\n+            fail();\n+        } catch (NullPointerException ex) {}\n+        try {\n+            test1.compareTo(new Long(123L));\n+            fail();\n+        } catch (ClassCastException ex) {}\n+        try {\n+            test1.compareTo(new Duration(1, 2, 3, 4, 5, 6, 7, 8));\n+            fail();\n+        } catch (IllegalStateException ex) {}\n+    }\n+\n+    public void testIsEqual() {\n+        Duration test1 = new Duration(123L);\n+        Duration test1a = new Duration(123L);\n+        assertEquals(true, test1.isEqual(test1a));\n+        assertEquals(true, test1a.isEqual(test1));\n+        assertEquals(true, test1.isEqual(test1));\n+        assertEquals(true, test1a.isEqual(test1a));\n+        \n+        Duration test2 = new Duration(321L);\n+        assertEquals(false, test1.isEqual(test2));\n+        assertEquals(false, test2.isEqual(test1));\n+        \n+        Duration test3 = new Duration(321L, DurationType.getAllType());\n+        assertEquals(false, test1.isEqual(test3));\n+        assertEquals(false, test3.isEqual(test1));\n+        assertEquals(true, test3.isEqual(test2));\n+        \n+        assertEquals(false, test2.isEqual(new MockDuration(123L)));\n+        assertEquals(true, test1.isEqual(new MockDuration(123L)));\n+        assertEquals(false, test1.isEqual(null));\n+        assertEquals(true, new Duration(0L).isEqual(null));\n+    }\n+    \n+    public void testIsBefore() {\n+        Duration test1 = new Duration(123L);\n+        Duration test1a = new Duration(123L);\n+        assertEquals(false, test1.isShorterThan(test1a));\n+        assertEquals(false, test1a.isShorterThan(test1));\n+        assertEquals(false, test1.isShorterThan(test1));\n+        assertEquals(false, test1a.isShorterThan(test1a));\n+        \n+        Duration test2 = new Duration(321L);\n+        assertEquals(true, test1.isShorterThan(test2));\n+        assertEquals(false, test2.isShorterThan(test1));\n+        \n+        Duration test3 = new Duration(321L, DurationType.getAllType());\n+        assertEquals(true, test1.isShorterThan(test3));\n+        assertEquals(false, test3.isShorterThan(test1));\n+        assertEquals(false, test3.isShorterThan(test2));\n+        \n+        assertEquals(false, test2.isShorterThan(new MockDuration(123L)));\n+        assertEquals(false, test1.isShorterThan(new MockDuration(123L)));\n+        assertEquals(false, test1.isShorterThan(null));\n+        assertEquals(false, new Duration(0L).isShorterThan(null));\n+    }\n+    \n+    public void testIsAfter() {\n+        Duration test1 = new Duration(123L);\n+        Duration test1a = new Duration(123L);\n+        assertEquals(false, test1.isLongerThan(test1a));\n+        assertEquals(false, test1a.isLongerThan(test1));\n+        assertEquals(false, test1.isLongerThan(test1));\n+        assertEquals(false, test1a.isLongerThan(test1a));\n+        \n+        Duration test2 = new Duration(321L);\n+        assertEquals(false, test1.isLongerThan(test2));\n+        assertEquals(true, test2.isLongerThan(test1));\n+        \n+        Duration test3 = new Duration(321L, DurationType.getAllType());\n+        assertEquals(false, test1.isLongerThan(test3));\n+        assertEquals(true, test3.isLongerThan(test1));\n+        assertEquals(false, test3.isLongerThan(test2));\n+        \n+        assertEquals(true, test2.isLongerThan(new MockDuration(123L)));\n+        assertEquals(false, test1.isLongerThan(new MockDuration(123L)));\n+        assertEquals(true, test1.isLongerThan(null));\n+        assertEquals(false, new Duration(0L).isLongerThan(null));\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testSerialization() throws Exception {\n+        Duration test = new Duration(123L);\n+        \n+        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+        ObjectOutputStream oos = new ObjectOutputStream(baos);\n+        oos.writeObject(test);\n+        byte[] bytes = baos.toByteArray();\n+        oos.close();\n+        \n+        ByteArrayInputStream bais = new ByteArrayInputStream(bytes);\n+        ObjectInputStream ois = new ObjectInputStream(bais);\n+        Duration result = (Duration) ois.readObject();\n+        ois.close();\n+        \n+        assertEquals(test, result);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    // TODO: Adds\n+    \n+    //-----------------------------------------------------------------------\n+    public void testToString() {\n+        Duration test = new Duration(1, 2, 3, 4, 5, 6, 7, 8);\n+        assertEquals(\"P1Y2M3W4DT5H6M7.008S\", test.toString());\n+        \n+        test = new Duration(0, 0, 0, 0, 0, 0, 0, 0);\n+        assertEquals(\"PT0S\", test.toString());\n+        \n+        test = new Duration(12345L);\n+        assertEquals(\"PT12.345S\", test.toString());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testToDuration() {\n+        Duration test = new Duration(123L);\n+        Duration result = test.toDuration();\n+        assertSame(test, result);\n+    }\n+\n+    public void testToMutableDuration() {\n+        Duration test = new Duration(123L);\n+        MutableDuration result = test.toMutableDuration();\n+        assertEquals(test.getDurationType(), result.getDurationType());\n+        assertEquals(test.isPrecise(), result.isPrecise());\n+        assertEquals(test.getTotalMillis(), result.getTotalMillis());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testConstant() {\n+        assertEquals(0L, Duration.ZERO.getTotalMillis());\n+        assertEquals(DurationType.getMillisType(), Duration.ZERO.getDurationType());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testImmutable() {\n+        MockChangeDuration test = new MockChangeDuration(111L);\n+        test.testSetDuration_RD();\n+        assertEquals(111L, test.getTotalMillis());\n+        \n+        test = new MockChangeDuration(111L);\n+        test.testSetDuration_ints();\n+        assertEquals(111L, test.getTotalMillis());\n+        \n+        test = new MockChangeDuration(111L);\n+        test.testSetTotalMillis_1();\n+        assertEquals(111L, test.getTotalMillis());\n+        \n+        test = new MockChangeDuration(111L);\n+        test.testSetTotalMillis_2();\n+        assertEquals(111L, test.getTotalMillis());\n+        \n+        test = new MockChangeDuration(111L);\n+        test.testSetYears();\n+        assertEquals(111L, test.getTotalMillis());\n+        \n+        test = new MockChangeDuration(111L);\n+        test.testSetMonths();\n+        assertEquals(111L, test.getTotalMillis());\n+        \n+        test = new MockChangeDuration(111L);\n+        test.testSetWeeks();\n+        assertEquals(111L, test.getTotalMillis());\n+        \n+        test = new MockChangeDuration(111L);\n+        test.testSetDays();\n+        assertEquals(111L, test.getTotalMillis());\n+        \n+        test = new MockChangeDuration(111L);\n+        test.testSetHours();\n+        assertEquals(111L, test.getTotalMillis());\n+        \n+        test = new MockChangeDuration(111L);\n+        test.testSetMinutes();\n+        assertEquals(111L, test.getTotalMillis());\n+        \n+        test = new MockChangeDuration(111L);\n+        test.testSetSeconds();\n+        assertEquals(111L, test.getTotalMillis());\n+        \n+        test = new MockChangeDuration(111L);\n+        test.testSetMillis();\n+        assertEquals(111L, test.getTotalMillis());\n+    }\n+    \n+    static class MockChangeDuration extends Duration {\n+        MockChangeDuration(long duration) {\n+            super(duration);\n+        }\n+        public void testSetDuration_RD() {\n+            setDuration(null);\n+        }\n+        public void testSetDuration_ints() {\n+            setDuration(1, 2, 3, 4, 5, 6, 7, 8);\n+        }\n+        public void testSetTotalMillis_1() {\n+            setTotalMillis(123L);\n+        }\n+        public void testSetTotalMillis_2() {\n+            setTotalMillis(123L, 321L);\n+        }\n+        public void testSetYears() {\n+            setYears(1);\n+        }\n+        public void testSetMonths() {\n+            setMonths(1);\n+        }\n+        public void testSetWeeks() {\n+            setWeeks(1);\n+        }\n+        public void testSetDays() {\n+            setDays(1);\n+        }\n+        public void testSetHours() {\n+            setHours(1);\n+        }\n+        public void testSetMinutes() {\n+            setMinutes(1);\n+        }\n+        public void testSetSeconds() {\n+            setSeconds(1);\n+        }\n+        public void testSetMillis() {\n+            setMillis(1);\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/JodaTime/src/test/org/joda/time/TestDuration_Constructors.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time;\n+\n+import java.util.Locale;\n+import java.util.TimeZone;\n+\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+/**\n+ * This class is a JUnit test for Duration.\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class TestDuration_Constructors extends TestCase {\n+    // Test in 2002/03 as time zones are more well known\n+    // (before the late 90's they were all over the place)\n+\n+    private static final DateTimeZone PARIS = DateTimeZone.getInstance(\"Europe/Paris\");\n+    private static final DateTimeZone LONDON = DateTimeZone.getInstance(\"Europe/London\");\n+    \n+    long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + \n+                     366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + \n+                     365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +\n+                     366 + 365;\n+    long y2003days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + \n+                     366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + \n+                     365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 +\n+                     366 + 365 + 365;\n+    \n+    // 2002-06-09\n+    private long TEST_TIME_NOW =\n+            (y2002days + 31L + 28L + 31L + 30L + 31L + 9L -1L) * DateTimeConstants.MILLIS_PER_DAY;\n+            \n+    // 2002-04-05\n+    private long TEST_TIME1 =\n+            (y2002days + 31L + 28L + 31L + 5L -1L) * DateTimeConstants.MILLIS_PER_DAY\n+            + 12L * DateTimeConstants.MILLIS_PER_HOUR\n+            + 24L * DateTimeConstants.MILLIS_PER_MINUTE;\n+        \n+    // 2003-05-06\n+    private long TEST_TIME2 =\n+            (y2003days + 31L + 28L + 31L + 30L + 6L -1L) * DateTimeConstants.MILLIS_PER_DAY\n+            + 14L * DateTimeConstants.MILLIS_PER_HOUR\n+            + 28L * DateTimeConstants.MILLIS_PER_MINUTE;\n+    \n+    private DateTimeZone originalDateTimeZone = null;\n+    private TimeZone originalTimeZone = null;\n+    private Locale originalLocale = null;\n+\n+    public static void main(String[] args) {\n+        junit.textui.TestRunner.run(suite());\n+    }\n+\n+    public static TestSuite suite() {\n+        return new TestSuite(TestDuration_Constructors.class);\n+    }\n+\n+    public TestDuration_Constructors(String name) {\n+        super(name);\n+    }\n+\n+    protected void setUp() throws Exception {\n+        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);\n+        originalDateTimeZone = DateTimeZone.getDefault();\n+        originalTimeZone = TimeZone.getDefault();\n+        originalLocale = Locale.getDefault();\n+        DateTimeZone.setDefault(LONDON);\n+        TimeZone.setDefault(TimeZone.getTimeZone(\"Europe/London\"));\n+        Locale.setDefault(Locale.UK);\n+    }\n+\n+    protected void tearDown() throws Exception {\n+        DateTimeUtils.setCurrentMillisSystem();\n+        DateTimeZone.setDefault(originalDateTimeZone);\n+        TimeZone.setDefault(originalTimeZone);\n+        Locale.setDefault(originalLocale);\n+        originalDateTimeZone = null;\n+        originalTimeZone = null;\n+        originalLocale = null;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Test constructor ()\n+     */\n+    public void testConstructor1() throws Throwable {\n+        Duration test = new Duration();\n+        assertEquals(DurationType.getMillisType(), test.getDurationType());\n+        assertEquals(0, test.getYears());\n+        assertEquals(0, test.getMonths());\n+        assertEquals(0, test.getWeeks());\n+        assertEquals(0, test.getDays());\n+        assertEquals(0, test.getHours());\n+        assertEquals(0, test.getMinutes());\n+        assertEquals(0, test.getSeconds());\n+        assertEquals(0, test.getMillis());\n+        assertEquals(true, test.isPrecise());\n+        assertEquals(0, test.getTotalMillis());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Test constructor (DurationType)\n+     */\n+    public void testConstructor_DurationType1() throws Throwable {\n+        Duration test = new Duration(DurationType.getYearMonthType());\n+        assertEquals(DurationType.getYearMonthType(), test.getDurationType());\n+        assertEquals(0, test.getYears());\n+        assertEquals(0, test.getMonths());\n+        assertEquals(0, test.getWeeks());\n+        assertEquals(0, test.getDays());\n+        assertEquals(0, test.getHours());\n+        assertEquals(0, test.getMinutes());\n+        assertEquals(0, test.getSeconds());\n+        assertEquals(0, test.getMillis());\n+        assertEquals(true, test.isPrecise());\n+        assertEquals(0, test.getTotalMillis());\n+    }\n+\n+    public void testConstructor_DurationType2() throws Throwable {\n+        Duration test = new Duration((DurationType) null);\n+        assertEquals(DurationType.getMillisType(), test.getDurationType());\n+        assertEquals(0, test.getYears());\n+        assertEquals(0, test.getMonths());\n+        assertEquals(0, test.getWeeks());\n+        assertEquals(0, test.getDays());\n+        assertEquals(0, test.getHours());\n+        assertEquals(0, test.getMinutes());\n+        assertEquals(0, test.getSeconds());\n+        assertEquals(0, test.getMillis());\n+        assertEquals(true, test.isPrecise());\n+        assertEquals(0, test.getTotalMillis());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Test constructor (Object)\n+     */\n+    public void testConstructor_Object1() throws Throwable {\n+        Duration test = new Duration(\"P1Y2M3D\");\n+        assertEquals(DurationType.getAllType(), test.getDurationType());\n+        assertEquals(1, test.getYears());\n+        assertEquals(2, test.getMonths());\n+        assertEquals(0, test.getWeeks());\n+        assertEquals(3, test.getDays());\n+        assertEquals(0, test.getHours());\n+        assertEquals(0, test.getMinutes());\n+        assertEquals(0, test.getSeconds());\n+        assertEquals(0, test.getMillis());\n+        assertEquals(false, test.isPrecise());\n+        try {\n+            test.getTotalMillis();\n+            fail();\n+        } catch (IllegalStateException ex) {}\n+    }\n+\n+    public void testConstructor_Object2() throws Throwable {\n+        Duration test = new Duration((Object) null);\n+        assertEquals(DurationType.getMillisType(), test.getDurationType());\n+        assertEquals(0, test.getYears());\n+        assertEquals(0, test.getMonths());\n+        assertEquals(0, test.getWeeks());\n+        assertEquals(0, test.getDays());\n+        assertEquals(0, test.getHours());\n+        assertEquals(0, test.getMinutes());\n+        assertEquals(0, test.getSeconds());\n+        assertEquals(0, test.getMillis());\n+        assertEquals(true, test.isPrecise());\n+        assertEquals(0, test.getTotalMillis());\n+    }\n+\n+    public void testConstructor_Object3() throws Throwable {\n+        Duration test = new Duration(new Duration(0, 0, 0, 0, 1, 2, 3, 4, DurationType.getDayHourType()));\n+        assertEquals(DurationType.getDayHourType(), test.getDurationType());\n+        assertEquals(0, test.getYears());\n+        assertEquals(0, test.getMonths());\n+        assertEquals(0, test.getWeeks());\n+        assertEquals(0, test.getDays());\n+        assertEquals(1, test.getHours());\n+        assertEquals(2, test.getMinutes());\n+        assertEquals(3, test.getSeconds());\n+        assertEquals(4, test.getMillis());\n+        assertEquals(true, test.isPrecise());\n+        assertEquals(DateTimeConstants.MILLIS_PER_HOUR + 2 * DateTimeConstants.MILLIS_PER_MINUTE +\n+            3 * DateTimeConstants.MILLIS_PER_SECOND + 4, test.getTotalMillis());\n+    }\n+\n+    public void testConstructor_Object4() throws Throwable {\n+        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n+        DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);\n+        Duration base = new Duration(dt1, dt2);  // AllType and precise\n+        Duration test = new Duration(base);\n+        assertEquals(DurationType.getAllType(), test.getDurationType());\n+        assertEquals(1, test.getYears());\n+        assertEquals(1, test.getMonths());\n+        assertEquals(0, test.getWeeks());\n+        assertEquals(1, test.getDays());\n+        assertEquals(1, test.getHours());\n+        assertEquals(1, test.getMinutes());\n+        assertEquals(1, test.getSeconds());\n+        assertEquals(1, test.getMillis());\n+        assertEquals(true, test.isPrecise());\n+        assertEquals(dt2.getMillis() - dt1.getMillis(), test.getTotalMillis());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Test constructor (Object)\n+     */\n+    public void testConstructor_Object_DurationType1() throws Throwable {\n+        Duration test = new Duration(\"P1Y2M3D\", DurationType.getYearMonthType());\n+        assertEquals(DurationType.getYearMonthType(), test.getDurationType());\n+        assertEquals(1, test.getYears());\n+        assertEquals(2, test.getMonths());\n+        assertEquals(0, test.getWeeks());\n+        assertEquals(3, test.getDays());\n+        assertEquals(0, test.getHours());\n+        assertEquals(0, test.getMinutes());\n+        assertEquals(0, test.getSeconds());\n+        assertEquals(0, test.getMillis());\n+        assertEquals(false, test.isPrecise());\n+        try {\n+            test.getTotalMillis();\n+            fail();\n+        } catch (IllegalStateException ex) {}\n+    }\n+\n+    public void testConstructor_Object_DurationType2() throws Throwable {\n+        Duration test = new Duration((Object) null, DurationType.getYearMonthType());\n+        assertEquals(DurationType.getYearMonthType(), test.getDurationType());\n+        assertEquals(0, test.getYears());\n+        assertEquals(0, test.getMonths());\n+        assertEquals(0, test.getWeeks());\n+        assertEquals(0, test.getDays());\n+        assertEquals(0, test.getHours());\n+        assertEquals(0, test.getMinutes());\n+        assertEquals(0, test.getSeconds());\n+        assertEquals(0, test.getMillis());\n+        assertEquals(true, test.isPrecise());\n+        assertEquals(0, test.getTotalMillis());\n+    }\n+\n+    public void testConstructor_Object_DurationType3() throws Throwable {\n+        Duration test = new Duration(new Duration(0, 0, 0, 0, 1, 2, 3, 4, DurationType.getDayHourType()), DurationType.getYearMonthType());\n+        assertEquals(DurationType.getYearMonthType(), test.getDurationType());\n+        assertEquals(0, test.getYears());\n+        assertEquals(0, test.getMonths());\n+        assertEquals(0, test.getWeeks());\n+        assertEquals(0, test.getDays());\n+        assertEquals(1, test.getHours());\n+        assertEquals(2, test.getMinutes());\n+        assertEquals(3, test.getSeconds());\n+        assertEquals(4, test.getMillis());\n+        assertEquals(true, test.isPrecise());\n+        assertEquals(DateTimeConstants.MILLIS_PER_HOUR + 2 * DateTimeConstants.MILLIS_PER_MINUTE +\n+            3 * DateTimeConstants.MILLIS_PER_SECOND + 4, test.getTotalMillis());\n+    }\n+\n+    public void testConstructor_Object_DurationType4() throws Throwable {\n+        Duration test = new Duration(new Duration(0, 0, 0, 0, 1, 2, 3, 4, DurationType.getDayHourType()), null);\n+        assertEquals(DurationType.getDayHourType(), test.getDurationType());\n+        assertEquals(0, test.getYears());\n+        assertEquals(0, test.getMonths());\n+        assertEquals(0, test.getWeeks());\n+        assertEquals(0, test.getDays());\n+        assertEquals(1, test.getHours());\n+        assertEquals(2, test.getMinutes());\n+        assertEquals(3, test.getSeconds());\n+        assertEquals(4, test.getMillis());\n+        assertEquals(true, test.isPrecise());\n+        assertEquals(DateTimeConstants.MILLIS_PER_HOUR + 2 * DateTimeConstants.MILLIS_PER_MINUTE +\n+            3 * DateTimeConstants.MILLIS_PER_SECOND + 4, test.getTotalMillis());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Test constructor (5ints)\n+     */\n+    public void testConstructor_5int1() throws Throwable {\n+        Duration test = new Duration(4, 5, 6, 7, 8);\n+        assertEquals(DurationType.getDayHourType(), test.getDurationType());\n+        assertEquals(0, test.getYears());\n+        assertEquals(0, test.getMonths());\n+        assertEquals(0, test.getWeeks());\n+        assertEquals(4, test.getDays());\n+        assertEquals(5, test.getHours());\n+        assertEquals(6, test.getMinutes());\n+        assertEquals(7, test.getSeconds());\n+        assertEquals(8, test.getMillis());\n+        assertEquals(true, test.isPrecise());\n+        assertEquals(4 * DateTimeConstants.MILLIS_PER_DAY +\n+            5 * DateTimeConstants.MILLIS_PER_HOUR + 6 * DateTimeConstants.MILLIS_PER_MINUTE +\n+            7 * DateTimeConstants.MILLIS_PER_SECOND + 8, test.getTotalMillis());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Test constructor (8ints)\n+     */\n+    public void testConstructor_8int1() throws Throwable {\n+        Duration test = new Duration(1, 2, 3, 4, 5, 6, 7, 8);\n+        assertEquals(DurationType.getAllType(), test.getDurationType());\n+        assertEquals(1, test.getYears());\n+        assertEquals(2, test.getMonths());\n+        assertEquals(3, test.getWeeks());\n+        assertEquals(4, test.getDays());\n+        assertEquals(5, test.getHours());\n+        assertEquals(6, test.getMinutes());\n+        assertEquals(7, test.getSeconds());\n+        assertEquals(8, test.getMillis());\n+        assertEquals(false, test.isPrecise());\n+        try {\n+            test.getTotalMillis();\n+            fail();\n+        } catch (IllegalStateException ex) {}\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Test constructor (8ints)\n+     */\n+    public void testConstructor_8int__DurationType1() throws Throwable {\n+        Duration test = new Duration(1, 2, 3, 4, 5, 6, 7, 8, null);\n+        assertEquals(DurationType.getAllType(), test.getDurationType());\n+        assertEquals(1, test.getYears());\n+        assertEquals(2, test.getMonths());\n+        assertEquals(3, test.getWeeks());\n+        assertEquals(4, test.getDays());\n+        assertEquals(5, test.getHours());\n+        assertEquals(6, test.getMinutes());\n+        assertEquals(7, test.getSeconds());\n+        assertEquals(8, test.getMillis());\n+        assertEquals(false, test.isPrecise());\n+        try {\n+            test.getTotalMillis();\n+            fail();\n+        } catch (IllegalStateException ex) {}\n+    }\n+\n+    public void testConstructor_8int__DurationType2() throws Throwable {\n+        Duration test = new Duration(0, 0, 0, 4, 5, 6, 7, 8, DurationType.getDayHourType());\n+        assertEquals(DurationType.getDayHourType(), test.getDurationType());\n+        assertEquals(0, test.getYears());\n+        assertEquals(0, test.getMonths());\n+        assertEquals(0, test.getWeeks());\n+        assertEquals(4, test.getDays());\n+        assertEquals(5, test.getHours());\n+        assertEquals(6, test.getMinutes());\n+        assertEquals(7, test.getSeconds());\n+        assertEquals(8, test.getMillis());\n+        assertEquals(true, test.isPrecise());\n+        assertEquals(4 * DateTimeConstants.MILLIS_PER_DAY +\n+            5 * DateTimeConstants.MILLIS_PER_HOUR + 6 * DateTimeConstants.MILLIS_PER_MINUTE +\n+            7 * DateTimeConstants.MILLIS_PER_SECOND + 8, test.getTotalMillis());\n+    }\n+\n+    public void testConstructor_8int__DurationType3() throws Throwable {\n+        try {\n+            new Duration(1, 2, 3, 4, 5, 6, 7, 8, DurationType.getDayHourType());\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testConstructor_long_long1() throws Throwable {\n+        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n+        DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);\n+        Duration test = new Duration(dt1.getMillis(), dt2.getMillis());\n+        assertEquals(DurationType.getAllType(), test.getDurationType());\n+        assertEquals(1, test.getYears());\n+        assertEquals(1, test.getMonths());\n+        assertEquals(0, test.getWeeks());\n+        assertEquals(1, test.getDays());\n+        assertEquals(1, test.getHours());\n+        assertEquals(1, test.getMinutes());\n+        assertEquals(1, test.getSeconds());\n+        assertEquals(1, test.getMillis());\n+        assertEquals(true, test.isPrecise());\n+        assertEquals(dt2.getMillis() - dt1.getMillis(), test.getTotalMillis());\n+    }\n+\n+    public void testConstructor_long_long2() throws Throwable {\n+        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n+        DateTime dt2 = new DateTime(2005, 7, 17, 1, 1, 1, 1);\n+        Duration test = new Duration(dt1.getMillis(), dt2.getMillis());\n+        assertEquals(DurationType.getAllType(), test.getDurationType());\n+        assertEquals(1, test.getYears());\n+        assertEquals(1, test.getMonths());\n+        assertEquals(1, test.getWeeks());\n+        assertEquals(1, test.getDays());\n+        assertEquals(1, test.getHours());\n+        assertEquals(1, test.getMinutes());\n+        assertEquals(1, test.getSeconds());\n+        assertEquals(1, test.getMillis());\n+        assertEquals(true, test.isPrecise());\n+        assertEquals(dt2.getMillis() - dt1.getMillis(), test.getTotalMillis());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testConstructor_long_long_DurationType1() throws Throwable {\n+        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n+        DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);\n+        Duration test = new Duration(dt1.getMillis(), dt2.getMillis(), null);\n+        assertEquals(DurationType.getAllType(), test.getDurationType());\n+        assertEquals(1, test.getYears());\n+        assertEquals(1, test.getMonths());\n+        assertEquals(0, test.getWeeks());\n+        assertEquals(1, test.getDays());\n+        assertEquals(1, test.getHours());\n+        assertEquals(1, test.getMinutes());\n+        assertEquals(1, test.getSeconds());\n+        assertEquals(1, test.getMillis());\n+        assertEquals(true, test.isPrecise());\n+        assertEquals(dt2.getMillis() - dt1.getMillis(), test.getTotalMillis());\n+    }\n+\n+    public void testConstructor_long_long_DurationType2() throws Throwable {\n+        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n+        DateTime dt2 = new DateTime(2004, 7, 10, 1, 1, 1, 1);\n+        Duration test = new Duration(dt1.getMillis(), dt2.getMillis(), DurationType.getDayHourType());\n+        assertEquals(DurationType.getDayHourType(), test.getDurationType());\n+        assertEquals(0, test.getYears());\n+        assertEquals(0, test.getMonths());\n+        assertEquals(0, test.getWeeks());\n+        assertEquals(31, test.getDays());\n+        assertEquals(1, test.getHours());\n+        assertEquals(1, test.getMinutes());\n+        assertEquals(1, test.getSeconds());\n+        assertEquals(1, test.getMillis());\n+        assertEquals(true, test.isPrecise());\n+        assertEquals(dt2.getMillis() - dt1.getMillis(), test.getTotalMillis());\n+    }\n+\n+    public void testConstructor_long_long_DurationType3() throws Throwable {\n+        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n+        DateTime dt2 = new DateTime(2005, 7, 17, 1, 1, 1, 1);\n+        Duration test = new Duration(dt1.getMillis(), dt2.getMillis(), DurationType.getAllType().withMillisRemoved());\n+        assertEquals(DurationType.getAllType().withMillisRemoved(), test.getDurationType());\n+        assertEquals(1, test.getYears());\n+        assertEquals(1, test.getMonths());\n+        assertEquals(1, test.getWeeks());\n+        assertEquals(1, test.getDays());\n+        assertEquals(1, test.getHours());\n+        assertEquals(1, test.getMinutes());\n+        assertEquals(1, test.getSeconds());\n+        assertEquals(0, test.getMillis());\n+        assertEquals(true, test.isPrecise());\n+        assertEquals(dt2.getMillis() - dt1.getMillis() - 1, test.getTotalMillis());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testConstructor_RI_RI1() throws Throwable {\n+        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n+        DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);\n+        Duration test = new Duration(dt1, dt2);\n+        assertEquals(DurationType.getAllType(), test.getDurationType());\n+        assertEquals(1, test.getYears());\n+        assertEquals(1, test.getMonths());\n+        assertEquals(0, test.getWeeks());\n+        assertEquals(1, test.getDays());\n+        assertEquals(1, test.getHours());\n+        assertEquals(1, test.getMinutes());\n+        assertEquals(1, test.getSeconds());\n+        assertEquals(1, test.getMillis());\n+        assertEquals(true, test.isPrecise());\n+        assertEquals(dt2.getMillis() - dt1.getMillis(), test.getTotalMillis());\n+    }\n+\n+    public void testConstructor_RI_RI2() throws Throwable {\n+        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n+        DateTime dt2 = new DateTime(2005, 7, 17, 1, 1, 1, 1);\n+        Duration test = new Duration(dt1, dt2);\n+        assertEquals(DurationType.getAllType(), test.getDurationType());\n+        assertEquals(1, test.getYears());\n+        assertEquals(1, test.getMonths());\n+        assertEquals(1, test.getWeeks());\n+        assertEquals(1, test.getDays());\n+        assertEquals(1, test.getHours());\n+        assertEquals(1, test.getMinutes());\n+        assertEquals(1, test.getSeconds());\n+        assertEquals(1, test.getMillis());\n+        assertEquals(true, test.isPrecise());\n+        assertEquals(dt2.getMillis() - dt1.getMillis(), test.getTotalMillis());\n+    }\n+\n+    public void testConstructor_RI_RI3() throws Throwable {\n+        DateTime dt1 = null;  // 2002-06-09T01:00+01:00\n+        DateTime dt2 = new DateTime(2005, 7, 17, 1, 1, 1, 1);\n+        Duration test = new Duration(dt1, dt2);\n+        assertEquals(DurationType.getAllType(), test.getDurationType());\n+        assertEquals(3, test.getYears());\n+        assertEquals(1, test.getMonths());\n+        assertEquals(1, test.getWeeks());\n+        assertEquals(1, test.getDays());\n+        assertEquals(0, test.getHours());\n+        assertEquals(1, test.getMinutes());\n+        assertEquals(1, test.getSeconds());\n+        assertEquals(1, test.getMillis());\n+        assertEquals(true, test.isPrecise());\n+        assertEquals(dt2.getMillis() - TEST_TIME_NOW, test.getTotalMillis());\n+    }\n+\n+    public void testConstructor_RI_RI4() throws Throwable {\n+        DateTime dt1 = null;  // 2002-06-09T01:00+01:00\n+        DateTime dt2 = null;  // 2002-06-09T01:00+01:00\n+        Duration test = new Duration(dt1, dt2);\n+        assertEquals(DurationType.getAllType(), test.getDurationType());\n+        assertEquals(0, test.getYears());\n+        assertEquals(0, test.getMonths());\n+        assertEquals(0, test.getWeeks());\n+        assertEquals(0, test.getDays());\n+        assertEquals(0, test.getHours());\n+        assertEquals(0, test.getMinutes());\n+        assertEquals(0, test.getSeconds());\n+        assertEquals(0, test.getMillis());\n+        assertEquals(true, test.isPrecise());\n+        assertEquals(0L, test.getTotalMillis());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testConstructor_RI_RI_DurationType1() throws Throwable {\n+        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n+        DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);\n+        Duration test = new Duration(dt1, dt2, null);\n+        assertEquals(DurationType.getAllType(), test.getDurationType());\n+        assertEquals(1, test.getYears());\n+        assertEquals(1, test.getMonths());\n+        assertEquals(0, test.getWeeks());\n+        assertEquals(1, test.getDays());\n+        assertEquals(1, test.getHours());\n+        assertEquals(1, test.getMinutes());\n+        assertEquals(1, test.getSeconds());\n+        assertEquals(1, test.getMillis());\n+        assertEquals(true, test.isPrecise());\n+        assertEquals(dt2.getMillis() - dt1.getMillis(), test.getTotalMillis());\n+    }\n+\n+    public void testConstructor_RI_RI_DurationType2() throws Throwable {\n+        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n+        DateTime dt2 = new DateTime(2004, 7, 10, 1, 1, 1, 1);\n+        Duration test = new Duration(dt1, dt2, DurationType.getDayHourType());\n+        assertEquals(DurationType.getDayHourType(), test.getDurationType());\n+        assertEquals(0, test.getYears());\n+        assertEquals(0, test.getMonths());\n+        assertEquals(0, test.getWeeks());\n+        assertEquals(31, test.getDays());\n+        assertEquals(1, test.getHours());\n+        assertEquals(1, test.getMinutes());\n+        assertEquals(1, test.getSeconds());\n+        assertEquals(1, test.getMillis());\n+        assertEquals(true, test.isPrecise());\n+        assertEquals(dt2.getMillis() - dt1.getMillis(), test.getTotalMillis());\n+    }\n+\n+    public void testConstructor_RI_RI_DurationType3() throws Throwable {\n+        DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n+        DateTime dt2 = new DateTime(2005, 7, 17, 1, 1, 1, 1);\n+        Duration test = new Duration(dt1, dt2, DurationType.getAllType().withMillisRemoved());\n+        assertEquals(DurationType.getAllType().withMillisRemoved(), test.getDurationType());\n+        assertEquals(1, test.getYears());\n+        assertEquals(1, test.getMonths());\n+        assertEquals(1, test.getWeeks());\n+        assertEquals(1, test.getDays());\n+        assertEquals(1, test.getHours());\n+        assertEquals(1, test.getMinutes());\n+        assertEquals(1, test.getSeconds());\n+        assertEquals(0, test.getMillis());\n+        assertEquals(true, test.isPrecise());\n+        assertEquals(dt2.getMillis() - dt1.getMillis() - 1, test.getTotalMillis());\n+    }\n+\n+    public void testConstructor_RI_RI_DurationType4() throws Throwable {\n+        DateTime dt1 = null;  // 2002-06-09T01:00+01:00\n+        DateTime dt2 = new DateTime(2005, 7, 17, 1, 1, 1, 1);\n+        Duration test = new Duration(dt1, dt2, DurationType.getAllType());\n+        assertEquals(DurationType.getAllType(), test.getDurationType());\n+        assertEquals(3, test.getYears());\n+        assertEquals(1, test.getMonths());\n+        assertEquals(1, test.getWeeks());\n+        assertEquals(1, test.getDays());\n+        assertEquals(0, test.getHours());\n+        assertEquals(1, test.getMinutes());\n+        assertEquals(1, test.getSeconds());\n+        assertEquals(1, test.getMillis());\n+        assertEquals(true, test.isPrecise());\n+        assertEquals(dt2.getMillis() - TEST_TIME_NOW, test.getTotalMillis());\n+    }\n+\n+    public void testConstructor_RI_RI_DurationType5() throws Throwable {\n+        DateTime dt1 = null;  // 2002-06-09T01:00+01:00\n+        DateTime dt2 = null;  // 2002-06-09T01:00+01:00\n+        Duration test = new Duration(dt1, dt2, DurationType.getAllType());\n+        assertEquals(DurationType.getAllType(), test.getDurationType());\n+        assertEquals(0, test.getYears());\n+        assertEquals(0, test.getMonths());\n+        assertEquals(0, test.getWeeks());\n+        assertEquals(0, test.getDays());\n+        assertEquals(0, test.getHours());\n+        assertEquals(0, test.getMinutes());\n+        assertEquals(0, test.getSeconds());\n+        assertEquals(0, test.getMillis());\n+        assertEquals(true, test.isPrecise());\n+        assertEquals(0L, test.getTotalMillis());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testConstructor_long1() throws Throwable {\n+        long length = 4 * DateTimeConstants.MILLIS_PER_DAY +\n+                5 * DateTimeConstants.MILLIS_PER_HOUR +\n+                6 * DateTimeConstants.MILLIS_PER_MINUTE +\n+                7 * DateTimeConstants.MILLIS_PER_SECOND + 8;\n+        Duration test = new Duration(length);\n+        assertEquals(DurationType.getMillisType(), test.getDurationType());\n+        assertEquals(0, test.getYears());\n+        assertEquals(0, test.getMonths());\n+        assertEquals(0, test.getWeeks());\n+        assertEquals(0, test.getDays());\n+        assertEquals(0, test.getHours());\n+        assertEquals(0, test.getMinutes());\n+        assertEquals(0, test.getSeconds());\n+        assertEquals(length, test.getMillis());\n+        assertEquals(true, test.isPrecise());\n+        assertEquals(length, test.getTotalMillis());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testConstructor_long_DurationType1() throws Throwable {\n+        long length = 4 * DateTimeConstants.MILLIS_PER_DAY +\n+                5 * DateTimeConstants.MILLIS_PER_HOUR +\n+                6 * DateTimeConstants.MILLIS_PER_MINUTE +\n+                7 * DateTimeConstants.MILLIS_PER_SECOND + 8;\n+        Duration test = new Duration(length, null);\n+        assertEquals(DurationType.getMillisType(), test.getDurationType());\n+        assertEquals(0, test.getYears());\n+        assertEquals(0, test.getMonths());\n+        assertEquals(0, test.getWeeks());\n+        assertEquals(0, test.getDays());\n+        assertEquals(0, test.getHours());\n+        assertEquals(0, test.getMinutes());\n+        assertEquals(0, test.getSeconds());\n+        assertEquals(length, test.getMillis());\n+        assertEquals(true, test.isPrecise());\n+        assertEquals(length, test.getTotalMillis());\n+    }\n+\n+    public void testConstructor_long_DurationType2() throws Throwable {\n+        long length = 4 * DateTimeConstants.MILLIS_PER_DAY +\n+                5 * DateTimeConstants.MILLIS_PER_HOUR +\n+                6 * DateTimeConstants.MILLIS_PER_MINUTE +\n+                7 * DateTimeConstants.MILLIS_PER_SECOND + 8;\n+        Duration test = new Duration(length, DurationType.getMillisType());\n+        assertEquals(DurationType.getMillisType(), test.getDurationType());\n+        assertEquals(0, test.getYears());\n+        assertEquals(0, test.getMonths());\n+        assertEquals(0, test.getWeeks());\n+        assertEquals(0, test.getDays());\n+        assertEquals(0, test.getHours());\n+        assertEquals(0, test.getMinutes());\n+        assertEquals(0, test.getSeconds());\n+        assertEquals(length, test.getMillis());\n+        assertEquals(true, test.isPrecise());\n+        assertEquals(length, test.getTotalMillis());\n+    }\n+\n+    public void testConstructor_long_DurationType3() throws Throwable {\n+        long length = 4 * DateTimeConstants.MILLIS_PER_DAY +\n+                5 * DateTimeConstants.MILLIS_PER_HOUR +\n+                6 * DateTimeConstants.MILLIS_PER_MINUTE +\n+                7 * DateTimeConstants.MILLIS_PER_SECOND + 8;\n+        Duration test = new Duration(length, DurationType.getAllType());\n+        assertEquals(DurationType.getAllType(), test.getDurationType());\n+        assertEquals(0, test.getYears());\n+        assertEquals(0, test.getMonths());\n+        assertEquals(0, test.getWeeks());\n+        assertEquals(4, test.getDays());\n+        assertEquals(5, test.getHours());\n+        assertEquals(6, test.getMinutes());\n+        assertEquals(7, test.getSeconds());\n+        assertEquals(8, test.getMillis());\n+        assertEquals(true, test.isPrecise());\n+        assertEquals(length, test.getTotalMillis());\n+    }\n+\n+    public void testConstructor_long_DurationType4() throws Throwable {\n+        long length = 4 * DateTimeConstants.MILLIS_PER_DAY +\n+                5 * DateTimeConstants.MILLIS_PER_HOUR +\n+                6 * DateTimeConstants.MILLIS_PER_MINUTE +\n+                7 * DateTimeConstants.MILLIS_PER_SECOND + 8;\n+        Duration test = new Duration(length, DurationType.getAllType().withMillisRemoved());\n+        assertEquals(DurationType.getAllType().withMillisRemoved(), test.getDurationType());\n+        assertEquals(0, test.getYears());\n+        assertEquals(0, test.getMonths());\n+        assertEquals(0, test.getWeeks());\n+        assertEquals(4, test.getDays());\n+        assertEquals(5, test.getHours());\n+        assertEquals(6, test.getMinutes());\n+        assertEquals(7, test.getSeconds());\n+        assertEquals(0, test.getMillis());\n+        assertEquals(true, test.isPrecise());\n+        assertEquals(length - 8, test.getTotalMillis());\n+    }\n+\n+}\n--- a/JodaTime/src/test/org/joda/time/TestMutableDateTime_Adds.java\n+++ b/JodaTime/src/test/org/joda/time/TestMutableDateTime_Adds.java\n     }\n \n     public void testAdd_Object3() {\n-        Duration d = new Duration(DurationType.getYearMonthType(), 1, 1, 0, 1, 1, 1, 1, 1);\n+        Duration d = new Duration(1, 1, 0, 1, 1, 1, 1, 1);\n         MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);\n         assertEquals(\"2002-06-09T05:06:07.008+01:00\", test.toString());\n         test.add(d);\n     }\n \n     public void testAdd_Object_int3() {\n-        Duration d = new Duration(DurationType.getYearMonthType(), 1, 1, 0, 1, 1, 1, 1, 1);\n+        Duration d = new Duration(1, 1, 0, 1, 1, 1, 1, 1);\n         MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);\n         assertEquals(\"2002-06-09T05:06:07.008+01:00\", test.toString());\n         test.add(d, -2);\n--- a/JodaTime/src/test/org/joda/time/convert/TestReadableDurationConverter.java\n+++ b/JodaTime/src/test/org/joda/time/convert/TestReadableDurationConverter.java\n \n     //-----------------------------------------------------------------------\n     public void testGetDurationMillis_Object() throws Exception {\n-        assertEquals(123L, ReadableDurationConverter.INSTANCE.getDurationMillis(new Duration(DurationType.getMillisType(), 123L)));\n+        assertEquals(123L, ReadableDurationConverter.INSTANCE.getDurationMillis(new Duration(123L)));\n         try {\n-            ReadableDurationConverter.INSTANCE.getDurationMillis(new Duration(DurationType.getYearMonthType(), 1, 2, 0, 1, 0, 0, 0, 0));\n+            ReadableDurationConverter.INSTANCE.getDurationMillis(new Duration(1, 2, 0, 1, 0, 0, 0, 0));\n             fail();\n         } catch (IllegalStateException ex) {}\n     }\n \n     public void testGetDurationType_Object() throws Exception {\n-        assertEquals(DurationType.getMillisType(), ReadableDurationConverter.INSTANCE.getDurationType(new Duration(DurationType.getMillisType(), 123L)));\n-        assertEquals(DurationType.getYearMonthType(), ReadableDurationConverter.INSTANCE.getDurationType(new Duration(DurationType.getYearMonthType(), 1, 2, 0, 1, 0, 0, 0, 0)));\n+        assertEquals(DurationType.getMillisType(), ReadableDurationConverter.INSTANCE.getDurationType(new Duration(123L)));\n+        assertEquals(DurationType.getAllType(), ReadableDurationConverter.INSTANCE.getDurationType(new Duration(1, 2, 0, 1, 0, 0, 0, 0)));\n     }\n \n     public void testIsPrecise_Object() throws Exception {\n-        assertEquals(true, ReadableDurationConverter.INSTANCE.isPrecise(new Duration(DurationType.getMillisType(), 123L)));\n-        assertEquals(false, ReadableDurationConverter.INSTANCE.isPrecise(new Duration(DurationType.getYearMonthType(), 1, 2, 0, 1, 0, 0, 0, 0)));\n+        assertEquals(true, ReadableDurationConverter.INSTANCE.isPrecise(new Duration(123L)));\n+        assertEquals(false, ReadableDurationConverter.INSTANCE.isPrecise(new Duration(1, 2, 0, 1, 0, 0, 0, 0)));\n     }\n \n     public void testSetInto_Object() throws Exception {\n         MutableDuration m = new MutableDuration(DurationType.getYearMonthType());\n-        ReadableDurationConverter.INSTANCE.setInto(m, new Duration(DurationType.getYearMonthType(), 1, 2, 0, 3, 0, 0, 0, 0));\n+        ReadableDurationConverter.INSTANCE.setInto(m, new Duration(1, 2, 0, 3, 0, 0, 0, 0));\n         assertEquals(1, m.getYears());\n         assertEquals(2, m.getMonths());\n         assertEquals(0, m.getWeeks());\n--- a/JodaTime/src/test/org/joda/time/convert/TestStringConverter.java\n+++ b/JodaTime/src/test/org/joda/time/convert/TestStringConverter.java\n     }\n \n     public void testGetDurationType_Object() throws Exception {\n-        assertEquals(DurationType.getYearMonthType(), StringConverter.INSTANCE.getDurationType(\"P2Y6M9D\"));\n-        assertEquals(DurationType.getYearWeekType(), StringConverter.INSTANCE.getDurationType(\"P2Y6W4D\"));\n+        assertEquals(DurationType.getAllType(), StringConverter.INSTANCE.getDurationType(\"P2Y6M9D\"));\n+        assertEquals(DurationType.getAllType(), StringConverter.INSTANCE.getDurationType(\"P2Y6W4D\"));\n     }\n \n     public void testIsPrecise_Object() throws Exception {\n         assertEquals(48, m.getSeconds());\n         assertEquals(0, m.getMillis());\n         \n-        m = new MutableDuration(DurationType.getYearWeekType(), 1, 0, 1, 1, 1, 1, 1, 1);\n+        m = new MutableDuration(1, 0, 1, 1, 1, 1, 1, 1, DurationType.getYearWeekType());\n         StringConverter.INSTANCE.setInto(m, \"P2Y4W3D\");\n         assertEquals(2, m.getYears());\n         assertEquals(4, m.getWeeks());", "timestamp": 1090453044, "metainfo": ""}