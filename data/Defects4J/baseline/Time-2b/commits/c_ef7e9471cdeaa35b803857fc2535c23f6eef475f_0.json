{"sha": "ef7e9471cdeaa35b803857fc2535c23f6eef475f", "log": "Update resolve() and add equals/hashCode   ", "commit": "\n--- a/JodaTime/src/java/org/joda/time/partial/PartialInstant.java\n+++ b/JodaTime/src/java/org/joda/time/partial/PartialInstant.java\n import org.joda.time.Chronology;\n import org.joda.time.DateTime;\n import org.joda.time.DateTimeField;\n+import org.joda.time.DateTimeZone;\n import org.joda.time.ReadableInstant;\n \n /**\n     boolean isSupported(DateTimeField field);\n \n     /**\n-     * Resolves this partial against another complete instant to create a new\n-     * full instant specifying values as milliseconds since 1970-01-01T00:00:00Z.\n+     * Resolves this partial against another complete millisecond instant to\n+     * create a new full instant specifying the time zone to resolve with.\n      * <p>\n      * For example, if this partial represents a time, then the result of this method\n-     * will be the date from the specified base plus the time from this instant.\n+     * will be the datetime from the specified base plus the time from this instant\n+     * set using the time zone specified.\n      *\n      * @param baseMillis  source of missing fields\n      * @return the combined instant in milliseconds\n      */\n-    long resolve(long baseMillis);\n+    long resolve(long baseMillis, DateTimeZone zone);\n \n     /**\n      * Resolves this partial against another complete instant to create a new\n      */\n     DateTime resolveDateTime(ReadableInstant base);\n \n-//    /**\n-//     * Compares this object with the specified object for equality based\n-//     * on the millisecond instant, the Chronology, and the limiting fields.\n-//     * <p>\n-//     * To compare two instants for absolute time (ie. UTC milliseconds ignoring\n-//     * the chronology), use {@link #isEqual(ReadableInstant)} or\n-//     * {@link #compareTo(Object)}.\n-//     *\n-//     * @param readableInstant  a readable instant to check against\n-//     * @return true if millisecond and chronology are equal, false if\n-//     *  not or the instant is null or of an incorrect type\n-//     */\n-//    boolean equals(Object readableInstant);\n-//\n-//    /**\n-//     * Gets a hash code for the instant that is compatable with the \n-//     * equals method.\n-//     *\n-//     * @return a suitable hash code\n-//     */\n-//    int hashCode();\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Compares this partial with the specified object for equality based\n+     * on the implementation class, supported fields, chronology and values.\n+     * <p>\n+     * Instances of PartialInstant are not generally comparable to one another\n+     * as the comparison is based on the implementation class.\n+     *\n+     * @param object  the object to compare to\n+     * @return true if equal\n+     */\n+    boolean equals(Object object);\n+\n+    /**\n+     * Gets a hash code for the instant that is compatible with the \n+     * equals method.\n+     *\n+     * @return a suitable hash code\n+     */\n+    int hashCode();\n \n     //-----------------------------------------------------------------------\n     /**", "timestamp": 1083540322, "metainfo": ""}