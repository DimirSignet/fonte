{"sha": "0d7b62128ccbbab4dcc955c8fe26f59b9cb24f50", "log": "Add addInField to PartialInstant   ", "commit": "\n--- a/JodaTime/src/java/org/joda/time/DateTimeField.java\n+++ b/JodaTime/src/java/org/joda/time/DateTimeField.java\n     public abstract long addWrapped(long instant, int value) ;\n \n     /**\n+     * Adds a value (which may be negative) to the partial instant,\n+     * wrapping within this field.\n+     * <p>\n+     * The value will be added to this field. If the value is too large to be\n+     * added solely to this field then it wraps. Larger fields are always\n+     * unaffected. Smaller fields should be unaffected, except where the\n+     * result would be an invalid value for a smaller field. In this case the\n+     * smaller field is adjusted to be in range.\n+     * <p>\n+     * For example, in the ISO chronology:<br>\n+     * 2000-08-20 addInField six months is 2000-02-20<br>\n+     * 2000-08-20 addInField twenty months is 2000-04-20<br>\n+     * 2000-08-20 addInField minus nine months is 2000-11-20<br>\n+     * 2001-01-31 addInField one month  is 2001-02-28<br>\n+     * 2001-01-31 addInField two months is 2001-03-31<br>\n+     * \n+     * @param instant  the partial instant\n+     * @param fieldIndex  the index of this field in the instant\n+     * @param values  the values of the partial instant which should be updated\n+     * @param valueToAdd  the value to add, in the units of the field\n+     * @return the passed in values\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public abstract int[] addInField(PartialInstant instant, int fieldIndex, int[] values, int valueToAdd);\n+\n+    /**\n      * Computes the difference between two instants, as measured in the units\n      * of this field. Any fractional units are dropped from the result. Calling\n      * getDifference reverses the effect of calling add. In the following code:\n--- a/JodaTime/src/java/org/joda/time/chrono/GJYearOfEraDateTimeField.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/GJYearOfEraDateTimeField.java\n import org.joda.time.DateTimeField;\n import org.joda.time.field.DecoratedDateTimeField;\n import org.joda.time.field.FieldUtils;\n+import org.joda.time.partial.PartialInstant;\n \n /**\n  * Provides time calculations for the year of era component of time.\n         iChronology = chronology;\n     }\n \n-    /**\n-     * Get the year of era component of the specified time instant.\n-     * \n-     * @param instant  the time instant in millis to query.\n-     * @return the year of era extracted from the input.\n-     */\n     public int get(long instant) {\n         int year = getWrappedField().get(instant);\n         if (year <= 0) {\n         return year;\n     }\n \n-    /**\n-     * Add the specified year to the specified time instant.\n-     * The amount added may be negative.\n-     * \n-     * @param instant  the time instant in millis to update.\n-     * @param years  the years to add (can be negative).\n-     * @return the updated time instant.\n-     */\n     public long add(long instant, int years) {\n         return getWrappedField().add(instant, years);\n     }\n         return getWrappedField().add(instant, years);\n     }\n \n-    /**\n-     * Add to the year component of the specified time instant\n-     * wrapping around within that component if necessary.\n-     * \n-     * @param instant  the time instant in millis to update.\n-     * @param years  the years to add (can be negative).\n-     * @return the updated time instant.\n-     */\n     public long addWrapped(long instant, int years) {\n         return getWrappedField().addWrapped(instant, years);\n+    }\n+\n+    public int[] addInField(PartialInstant instant, int fieldIndex, int[] values, int years) {\n+        return getWrappedField().addInField(instant, fieldIndex, values, years);\n     }\n \n     public int getDifference(long minuendInstant, long subtrahendInstant) {\n--- a/JodaTime/src/java/org/joda/time/chrono/ISOYearOfEraDateTimeField.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/ISOYearOfEraDateTimeField.java\n import org.joda.time.DateTimeField;\n import org.joda.time.field.DecoratedDateTimeField;\n import org.joda.time.field.FieldUtils;\n+import org.joda.time.partial.PartialInstant;\n \n /**\n  * This field is not publicy exposed by ISOChronology, but rather it is used to\n \n     public long addWrapped(long instant, int years) {\n         return getWrappedField().addWrapped(instant, years);\n+    }\n+\n+    public int[] addInField(PartialInstant instant, int fieldIndex, int[] values, int years) {\n+        return getWrappedField().addInField(instant, fieldIndex, values, years);\n     }\n \n     public int getDifference(long minuendInstant, long subtrahendInstant) {\n--- a/JodaTime/src/java/org/joda/time/field/BaseDateTimeField.java\n+++ b/JodaTime/src/java/org/joda/time/field/BaseDateTimeField.java\n         int wrapped = FieldUtils.getWrappedValue\n             (current, value, getMinimumValue(instant), getMaximumValue(instant));\n         return set(instant, wrapped);\n+    }\n+\n+    /**\n+     * Adds a value (which may be negative) to the partial instant,\n+     * wrapping within this field.\n+     * <p>\n+     * The value will be added to this field. If the value is too large to be\n+     * added solely to this field then it wraps. Larger fields are always\n+     * unaffected. Smaller fields should be unaffected, except where the\n+     * result would be an invalid value for a smaller field. In this case the\n+     * smaller field is adjusted to be in range.\n+     * <p>\n+     * For example, in the ISO chronology:<br>\n+     * 2000-08-20 addInField six months is 2000-02-20<br>\n+     * 2000-08-20 addInField twenty months is 2000-04-20<br>\n+     * 2000-08-20 addInField minus nine months is 2000-11-20<br>\n+     * 2001-01-31 addInField one month  is 2001-02-28<br>\n+     * 2001-01-31 addInField two months is 2001-03-31<br>\n+     * <p>\n+     * The default implementation internally calls set. Subclasses are\n+     * encouraged to provide a more efficient implementation.\n+     * \n+     * @param instant  the partial instant\n+     * @param fieldIndex  the index of this field in the instant\n+     * @param values  the values of the partial instant which should be updated\n+     * @param valueToAdd  the value to add, in the units of the field\n+     * @return the passed in values\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public int[] addInField(PartialInstant instant, int fieldIndex, int[] values, int valueToAdd) {\n+        int current = values[fieldIndex];\n+        int wrapped = FieldUtils.getWrappedValue\n+            (current, valueToAdd, getMinimumValue(instant), getMaximumValue(instant));\n+        return set(instant, fieldIndex, values, wrapped);\n     }\n \n     //-----------------------------------------------------------------------\n--- a/JodaTime/src/java/org/joda/time/field/DelegatedDateTimeField.java\n+++ b/JodaTime/src/java/org/joda/time/field/DelegatedDateTimeField.java\n         return iField.addWrapped(instant, value);\n     }\n \n+    public int[] addInField(PartialInstant instant, int fieldIndex, int[] values, int valueToAdd) {\n+        return iField.addInField(instant, fieldIndex, values, valueToAdd);\n+    }\n+\n     public int getDifference(long minuendInstant, long subtrahendInstant) {\n         return iField.getDifference(minuendInstant, subtrahendInstant);\n     }\n--- a/JodaTime/src/java/org/joda/time/field/NonZeroDateTimeField.java\n+++ b/JodaTime/src/java/org/joda/time/field/NonZeroDateTimeField.java\n         return getWrappedField().addWrapped(instant, value);\n     }\n \n+    public int[] addInField(PartialInstant instant, int fieldIndex, int[] values, int valueToAdd) {\n+        return getWrappedField().addInField(instant, fieldIndex, values, valueToAdd);\n+    }\n+\n     public int getDifference(long minuendInstant, long subtrahendInstant) {\n         return getWrappedField().getDifference(minuendInstant, subtrahendInstant);\n     }\n--- a/JodaTime/src/java/org/joda/time/field/UnsupportedDateTimeField.java\n+++ b/JodaTime/src/java/org/joda/time/field/UnsupportedDateTimeField.java\n     }\n \n     /**\n+     * Always throws UnsupportedOperationException\n+     *\n+     * @throws UnsupportedOperationException\n+     */\n+    public int[] addInField(PartialInstant instant, int fieldIndex, int[] values, int valueToAdd) {\n+        throw unsupported();\n+    }\n+\n+    /**\n      * Delegates to the duration field.\n      *\n      * @throws UnsupportedOperationException if the duration is unsupported\n--- a/JodaTime/src/java/org/joda/time/partial/TimeOfDay.java\n+++ b/JodaTime/src/java/org/joda/time/partial/TimeOfDay.java\n  * The second technique also provides access to other useful methods on the\n  * field:\n  * <ul>\n- * <li>numeric value\n- * <li>text value\n- * <li>short text value\n- * <li>maximum/minimum values\n- * <li>add/subtract\n- * <li>set\n- * <li>rounding\n+ * <li>numeric value - <code>hourOfDay().get()</code>\n+ * <li>text value - <code>hourOfDay().getAsText()</code>\n+ * <li>short text value - <code>hourOfDay().getAsShortText()</code>\n+ * <li>maximum/minimum values - <code>hourOfDay().getMaximumValue()</code>\n+ * <li>add/subtract - <code>hourOfDay().addToCopy()</code>\n+ * <li>set - <code>hourOfDay().setCopy()</code>\n  * </ul>\n  * <p>\n  * TimeOfDay is thread-safe and immutable, provided that the Chronology is as well.\n //         * Adds to this field in a copy of this TimeOfDay.\n //         * <p>\n //         * The TimeOnly attached to this property is unchanged by this call.\n+//        * Instead, a new instance is returned.\n //         * \n //         * @param value  the value to add to the field in the copy\n //         * @return a copy of the TimeOnly with the field value changed\n //            return new TimeOfDay(getInstant(), newValues);\n //        }\n //\n-//        /**\n-//         * Adds to this field, possibly wrapped, in a copy of this TimeOfDay.\n-//         * A wrapped operation only changes this field.\n-//         * Thus 12:59:00 addWrapped one minute goes to 12:00:00.\n-//         * <p>\n-//         * The TimeOfDay attached to this property is unchanged by this call.\n-//         * \n-//         * @param value  the value to add to the field in the copy\n-//         * @return a copy of the TimeOfDay with the field value changed\n-//         * @throws IllegalArgumentException if the value isn't valid\n-//         */\n-//        public TimeOfDay addWrappedToCopy(int value) {\n-//            int[] newValues = getField().addWrapped(getInstant(), value);\n-//            return new TimeOfDay(getInstant(), newValues);\n-//        }\n-//\n+        /**\n+         * Adds to the value of this field in a copy of this TimeOfDay wrapping\n+         * within this field if the maximum value is reached.\n+         * <p>\n+         * The value will be added to this field. If the value is too large to be\n+         * added solely to this field then it wraps. Larger fields are always\n+         * unaffected. Smaller fields should be unaffected, except where the\n+         * result would be an invalid value for a smaller field. In this case the\n+         * smaller field is adjusted to be in range.\n+         * <p>\n+         * For example,\n+         * <code>12:59:37</code> addInField one minute returns <code>12:00:37</code>.\n+         * <p>\n+         * The TimeOfDay attached to this property is unchanged by this call.\n+         * Instead, a new instance is returned.\n+         * \n+         * @param valueToAdd  the value to add to the field in the copy\n+         * @return a copy of the TimeOfDay with the field value changed\n+         * @throws IllegalArgumentException if the value isn't valid\n+         */\n+        public TimeOfDay addInFieldCopy(int valueToAdd) {\n+            int[] newValues = iInstant.getValues();\n+            getField().addInField(iInstant, iFieldIndex, newValues, valueToAdd);\n+            return new TimeOfDay(iInstant, newValues);\n+        }\n+\n         //-----------------------------------------------------------------------\n         /**\n          * Sets this field in a copy of the TimeOfDay.\n          * <p>\n          * The TimeOfDay attached to this property is unchanged by this call.\n+         * Instead, a new instance is returned.\n          * \n          * @param value  the value to set the field in the copy to\n          * @return a copy of the TimeOfDay with the field value changed\n          * Sets this field in a copy of the TimeOfDay to a parsed text value.\n          * <p>\n          * The TimeOfDay attached to this property is unchanged by this call.\n+         * Instead, a new instance is returned.\n          * \n          * @param text  the text value to set\n          * @param locale  optional locale to use for selecting a text symbol\n          * Sets this field in a copy of the TimeOfDay to a parsed text value.\n          * <p>\n          * The TimeOfDay attached to this property is unchanged by this call.\n+         * Instead, a new instance is returned.\n          * \n          * @param text  the text value to set\n          * @return a copy of the TimeOfDay with the field value changed\n--- a/JodaTime/src/test/org/joda/test/time/partial/TestTimeOfDay.java\n+++ b/JodaTime/src/test/org/joda/test/time/partial/TestTimeOfDay.java\n         assertEquals(23, test.hourOfDay().getMaximumValueOverall());\n     }\n \n+    public void testPropertyAddInField() {\n+        TimeOfDay test = new TimeOfDay(10, 20, 30, 40);\n+        TimeOfDay updated = test.hourOfDay().addInFieldCopy(9);\n+        assertEquals(19, updated.getHourOfDay());\n+        assertEquals(20, updated.getMinuteOfHour());\n+        assertEquals(30, updated.getSecondOfMinute());\n+        assertEquals(40, updated.getMillisOfSecond());\n+        updated = updated.hourOfDay().addInFieldCopy(9);\n+        assertEquals(4, updated.getHourOfDay());\n+        assertEquals(20, updated.getMinuteOfHour());\n+        assertEquals(30, updated.getSecondOfMinute());\n+        assertEquals(40, updated.getMillisOfSecond());\n+    }\n+\n     public void testPropertySet() {\n         TimeOfDay test = new TimeOfDay(10, 20, 30, 40);\n         TimeOfDay set = test.hourOfDay().setCopy(12);", "timestamp": 1086734965, "metainfo": ""}