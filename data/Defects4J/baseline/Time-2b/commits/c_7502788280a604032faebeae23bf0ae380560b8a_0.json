{"sha": "7502788280a604032faebeae23bf0ae380560b8a", "log": "Rename AbstractDateTimeField to BaseDateTimeField   ", "commit": "\n--- a/JodaTime/src/java/org/joda/time/chrono/BuddhistEraDateTimeField.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/BuddhistEraDateTimeField.java\n \n import org.joda.time.DateTimeField;\n import org.joda.time.DurationField;\n-import org.joda.time.field.AbstractDateTimeField;\n+import org.joda.time.field.BaseDateTimeField;\n import org.joda.time.field.UnsupportedDurationField;\n import org.joda.time.field.FieldUtils;\n \n  * @author Brian S O'Neill\n  * @since 1.0\n  */\n-final class BuddhistEraDateTimeField extends AbstractDateTimeField {\n+final class BuddhistEraDateTimeField extends BaseDateTimeField {\n     \n     /** Serialization version */\n     private static final long serialVersionUID = -9175876774456816364L;\n--- a/JodaTime/src/java/org/joda/time/chrono/CopticEraDateTimeField.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/CopticEraDateTimeField.java\n \n import org.joda.time.DateTimeField;\n import org.joda.time.DurationField;\n-import org.joda.time.field.AbstractDateTimeField;\n+import org.joda.time.field.BaseDateTimeField;\n import org.joda.time.field.UnsupportedDurationField;\n import org.joda.time.field.FieldUtils;\n \n  * @author Brian S O'Neill\n  * @since 1.0\n  */\n-final class CopticEraDateTimeField extends AbstractDateTimeField {\n+final class CopticEraDateTimeField extends BaseDateTimeField {\n     \n     /** Serialization version */\n     private static final long serialVersionUID = 4090856468123006167L;\n--- a/JodaTime/src/java/org/joda/time/chrono/GJChronology.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/GJChronology.java\n import org.joda.time.DurationField;\n import org.joda.time.Instant;\n import org.joda.time.ReadableInstant;\n-import org.joda.time.field.AbstractDateTimeField;\n+import org.joda.time.field.BaseDateTimeField;\n import org.joda.time.field.DecoratedDurationField;\n import org.joda.time.format.DateTimePrinter;\n import org.joda.time.format.ISODateTimeFormat;\n      * This basic cutover field adjusts calls to 'get' and 'set' methods, and\n      * assumes that calls to add and addWrapped are unaffected by the cutover.\n      */\n-    private class CutoverField extends AbstractDateTimeField {\n+    private class CutoverField extends BaseDateTimeField {\n         static final long serialVersionUID = 3528501219481026402L;\n \n         final DateTimeField iJulianField;\n--- a/JodaTime/src/java/org/joda/time/chrono/GJEraDateTimeField.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/GJEraDateTimeField.java\n \n import org.joda.time.DateTimeConstants;\n import org.joda.time.DurationField;\n-import org.joda.time.field.AbstractDateTimeField;\n+import org.joda.time.field.BaseDateTimeField;\n import org.joda.time.field.UnsupportedDurationField;\n import org.joda.time.field.FieldUtils;\n \n  * @version 1.0\n  * @since 1.0\n  */\n-final class GJEraDateTimeField extends AbstractDateTimeField {\n+final class GJEraDateTimeField extends BaseDateTimeField {\n     \n     /** Serialization version */\n     private static final long serialVersionUID = 4240986525305515528L;\n--- a/JodaTime/src/java/org/joda/time/chrono/ZonedChronology.java\n+++ b/JodaTime/src/java/org/joda/time/chrono/ZonedChronology.java\n import org.joda.time.DateTimeField;\n import org.joda.time.DateTimeZone;\n import org.joda.time.DurationField;\n-import org.joda.time.field.AbstractDateTimeField;\n+import org.joda.time.field.BaseDateTimeField;\n import org.joda.time.field.AbstractDurationField;\n \n /**\n      * This class converts passed in instants to local wall time, and vice\n      * versa on output.\n      */\n-    static final class ZonedDateTimeField extends AbstractDateTimeField {\n+    static final class ZonedDateTimeField extends BaseDateTimeField {\n         static final long serialVersionUID = -3968986277775529794L;\n \n         final DateTimeField iField;\n--- /dev/null\n+++ b/JodaTime/src/java/org/joda/time/field/BaseDateTimeField.java\n+/*\n+ * Joda Software License, Version 1.0\n+ *\n+ *\n+ * Copyright (c) 2001-2004 Stephen Colebourne.  \n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer. \n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:  \n+ *       \"This product includes software developed by the\n+ *        Joda project (http://www.joda.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The name \"Joda\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact licence@joda.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Joda\",\n+ *    nor may \"Joda\" appear in their name, without prior written\n+ *    permission of the Joda project.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Joda project and was originally \n+ * created by Stephen Colebourne <scolebourne@joda.org>. For more\n+ * information on the Joda project, please see <http://www.joda.org/>.\n+ */\n+package org.joda.time.field;\n+\n+import java.io.Serializable;\n+import java.util.Locale;\n+\n+import org.joda.time.DateTimeField;\n+import org.joda.time.DurationField;\n+import org.joda.time.partial.PartialInstant;\n+\n+/**\n+ * BaseDateTimeField provides the common behaviour for DateTimeField\n+ * implementations. \n+ * <p>\n+ * This class should generally not be used directly by API users. The\n+ * DateTimeField interface should be used when different kinds of DateTimeField\n+ * objects are to be referenced.\n+ * <p>\n+ * BaseDateTimeField is thread-safe and immutable, and its subclasses must\n+ * be as well.\n+ *\n+ * @author Brian S O'Neill\n+ * @since 1.0\n+ * @see DecoratedDateTimeField\n+ */\n+public abstract class BaseDateTimeField extends DateTimeField implements Serializable {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = -4388055220581798589L;\n+\n+    /** A desriptive name for the field */\n+    private final String iName;\n+\n+    /**\n+     * Constructor.\n+     */\n+    protected BaseDateTimeField(String name) {\n+        super();\n+        if (name == null) {\n+            throw new IllegalArgumentException(\"The name must not be null\");\n+        }\n+        iName = name;\n+    }\n+    \n+    public final String getName() {\n+        return iName;\n+    }\n+\n+    /**\n+     * @return true always\n+     */\n+    public final boolean isSupported() {\n+        return true;\n+    }\n+\n+    // Main access API\n+    //------------------------------------------------------------------------\n+    /**\n+     * Get the value of this field from the milliseconds.\n+     * \n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to query\n+     * @return the value of the field, in the units of the field\n+     */\n+    public abstract int get(long instant);\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the human-readable, text value of this field from the milliseconds.\n+     * If the specified locale is null, the default locale is used.\n+     * <p>\n+     * The default implementation returns getAsText(get(instant), locale).\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to query\n+     * @param locale the locale to use for selecting a text symbol, null for\n+     * default\n+     * @return the text value of the field\n+     */\n+    public String getAsText(long instant, Locale locale) {\n+        return getAsText(get(instant), locale);\n+    }\n+\n+    /**\n+     * Get the human-readable, text value of this field from a partial instant.\n+     * If the specified locale is null, the default locale is used.\n+     * <p>\n+     * The default implementation returns getAsText(fieldValue, locale).\n+     *\n+     * @param partial  the partial instant to query\n+     * @param fieldValue  the field value of this field, provided for performance\n+     * @param locale  the locale to use for selecting a text symbol, null for default\n+     * @return the text value of the field\n+     */\n+    public String getAsText(PartialInstant partial, int fieldValue, Locale locale) {\n+        return getAsText(fieldValue, locale);\n+    }\n+\n+    /**\n+     * Get the human-readable, text value of this field from the field value.\n+     * If the specified locale is null, the default locale is used.\n+     * <p>\n+     * The default implementation returns Integer.toString(get(instant)).\n+     * <p>\n+     * Note: subclasses that override this method should also override\n+     * getMaximumTextLength.\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to query\n+     * @param locale the locale to use for selecting a text symbol, null for default\n+     * @return the text value of the field\n+     */\n+    protected String getAsText(int fieldValue, Locale locale) {\n+        return Integer.toString(fieldValue);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the human-readable, short text value of this field from the milliseconds.\n+     * If the specified locale is null, the default locale is used.\n+     * <p>\n+     * The default implementation returns getAsShortText(get(instant), locale).\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to query\n+     * @param locale the locale to use for selecting a text symbol, null for default\n+     * @return the text value of the field\n+     */\n+    public String getAsShortText(long instant, Locale locale) {\n+        return getAsShortText(get(instant), locale);\n+    }\n+\n+    /**\n+     * Get the human-readable, short text value of this field from a partial instant.\n+     * If the specified locale is null, the default locale is used.\n+     * <p>\n+     * The default implementation returns getAsShortText(fieldValue, locale).\n+     *\n+     * @param partial  the partial instant to query\n+     * @param fieldValue  the field value of this field, provided for performance\n+     * @param locale  the locale to use for selecting a text symbol, null for default\n+     * @return the text value of the field\n+     */\n+    public String getAsShortText(PartialInstant partial, int fieldValue, Locale locale) {\n+        return getAsShortText(fieldValue, locale);\n+    }\n+\n+    /**\n+     * Get the human-readable, short text value of this field from the field value.\n+     * If the specified locale is null, the default locale is used.\n+     * <p>\n+     * The default implementation returns getAsText(fieldValue, locale).\n+     * <p>\n+     * Note: subclasses that override this method should also override\n+     * getMaximumShortTextLength.\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to query\n+     * @param locale the locale to use for selecting a text symbol, null for default\n+     * @return the text value of the field\n+     */\n+    protected String getAsShortText(int fieldValue, Locale locale) {\n+        return getAsText(fieldValue, locale);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Adds a value (which may be negative) to the instant value,\n+     * overflowing into larger fields if necessary.\n+     * <p>\n+     * The value will be added to this field. If the value is too large to be\n+     * added solely to this field, larger fields will increase as required.\n+     * Smaller fields should be unaffected, except where the result would be\n+     * an invalid value for a smaller field. In this case the smaller field is\n+     * adjusted to be in range.\n+     * <p>\n+     * For example, in the ISO chronology:<br>\n+     * 2000-08-20 add six months is 2001-02-20<br>\n+     * 2000-08-20 add twenty months is 2002-04-20<br>\n+     * 2000-08-20 add minus nine months is 1999-11-20<br>\n+     * 2001-01-31 add one month  is 2001-02-28<br>\n+     * 2001-01-31 add two months is 2001-03-31<br>\n+     * \n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to add to\n+     * @param value  the value to add, in the units of the field\n+     * @return the updated milliseconds\n+     */\n+    public long add(long instant, int value) {\n+        return getDurationField().add(instant, value);\n+    }\n+\n+    /**\n+     * Adds a value (which may be negative) to the instant value,\n+     * overflowing into larger fields if necessary.\n+     * \n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to add to\n+     * @param value  the long value to add, in the units of the field\n+     * @return the updated milliseconds\n+     * @throws IllegalArgumentException if value is too large\n+     * @see #add(long,int)\n+     */\n+    public long add(long instant, long value) {\n+        return getDurationField().add(instant, value);\n+    }\n+\n+    /**\n+     * Adds a value (which may be negative) to the instant value,\n+     * wrapping within this field.\n+     * <p>\n+     * The value will be added to this field. If the value is too large to be\n+     * added solely to this field then it wraps. Larger fields are always\n+     * unaffected. Smaller fields should be unaffected, except where the\n+     * result would be an invalid value for a smaller field. In this case the\n+     * smaller field is adjusted to be in range.\n+     * <p>\n+     * For example, in the ISO chronology:<br>\n+     * 2000-08-20 addWrapped six months is 2000-02-20<br>\n+     * 2000-08-20 addWrapped twenty months is 2000-04-20<br>\n+     * 2000-08-20 addWrapped minus nine months is 2000-11-20<br>\n+     * 2001-01-31 addWrapped one month  is 2001-02-28<br>\n+     * 2001-01-31 addWrapped two months is 2001-03-31<br>\n+     * <p>\n+     * The default implementation internally calls set. Subclasses are\n+     * encouraged to provide a more efficient implementation.\n+     * \n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to add to\n+     * @param value  the value to add, in the units of the field\n+     * @return the updated milliseconds\n+     */\n+    public long addWrapped(long instant, int value) {\n+        int current = get(instant);\n+        int wrapped = FieldUtils.getWrappedValue\n+            (current, value, getMinimumValue(instant), getMaximumValue(instant));\n+        return set(instant, wrapped);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Computes the difference between two instants, as measured in the units\n+     * of this field. Any fractional units are dropped from the result. Calling\n+     * getDifference reverses the effect of calling add. In the following code:\n+     *\n+     * <pre>\n+     * long instant = ...\n+     * int v = ...\n+     * int age = getDifference(add(instant, v), instant);\n+     * </pre>\n+     *\n+     * The value 'age' is the same as the value 'v'.\n+     *\n+     * @param minuendInstant the milliseconds from 1970-01-01T00:00:00Z to\n+     * subtract from\n+     * @param subtrahendInstant the milliseconds from 1970-01-01T00:00:00Z to\n+     * subtract off the minuend\n+     * @return the difference in the units of this field\n+     */\n+    public int getDifference(long minuendInstant, long subtrahendInstant) {\n+        return getDurationField().getDifference(minuendInstant, subtrahendInstant);\n+    }\n+\n+    /**\n+     * Computes the difference between two instants, as measured in the units\n+     * of this field. Any fractional units are dropped from the result. Calling\n+     * getDifference reverses the effect of calling add. In the following code:\n+     *\n+     * <pre>\n+     * long instant = ...\n+     * long v = ...\n+     * long age = getDifferenceAsLong(add(instant, v), instant);\n+     * </pre>\n+     *\n+     * The value 'age' is the same as the value 'v'.\n+     *\n+     * @param minuendInstant the milliseconds from 1970-01-01T00:00:00Z to\n+     * subtract from\n+     * @param subtrahendInstant the milliseconds from 1970-01-01T00:00:00Z to\n+     * subtract off the minuend\n+     * @return the difference in the units of this field\n+     */\n+    public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {\n+        return getDurationField().getDifferenceAsLong(minuendInstant, subtrahendInstant);\n+    }\n+\n+    /**\n+     * Sets a value in the milliseconds supplied.\n+     * <p>\n+     * The value of this field will be set. If the value is invalid, an\n+     * exception if thrown. Other fields are always unaffected.\n+     * \n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to set in\n+     * @param value  the value to set, in the units of the field\n+     * @return the updated milliseconds\n+     * @throws IllegalArgumentException if the value is invalid\n+     */\n+    public abstract long set(long instant, int value);\n+\n+    /**\n+     * Sets a value in the milliseconds supplied from a human-readable, text\n+     * value. If the specified locale is null, the default locale is used.\n+     * <p>\n+     * The default implementation returns set(instant,\n+     * Integer.parseInt(instant)).\n+     * <p>\n+     * Note: subclasses that override this method should also override\n+     * getAsText.\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to set in\n+     * @param text  the text value to set\n+     * @param locale the locale to use for selecting a text symbol, null for\n+     * default\n+     * @return the updated milliseconds\n+     * @throws IllegalArgumentException if the text value is invalid\n+     */\n+    public long set(long instant, String text, Locale locale) {\n+        try {\n+            return set(instant, Integer.parseInt(text));\n+        } catch (NumberFormatException ex) {\n+            throw new IllegalArgumentException(\"Invalid \" + getName() + \" text: \" + text);\n+        }\n+    }\n+\n+    // Extra information API\n+    //------------------------------------------------------------------------\n+    /**\n+     * Returns the duration per unit value of this field. For example, if this\n+     * field represents \"hour of day\", then the unit duration is an hour.\n+     *\n+     * @return the duration of this field, or UnsupportedDurationField if field\n+     * has no duration\n+     */\n+    public abstract DurationField getDurationField();\n+\n+    /**\n+     * Returns the range duration of this field. For example, if this field\n+     * represents \"hour of day\", then the range duration is a day.\n+     *\n+     * @return the range duration of this field, or null if field has no range\n+     */\n+    public abstract DurationField getRangeDurationField();\n+\n+    /**\n+     * Returns whether this field is 'leap' for the specified instant.\n+     * <p>\n+     * For example, a leap year would return true, a non leap year would return\n+     * false.\n+     * <p>\n+     * This implementation returns false.\n+     * \n+     * @return true if the field is 'leap'\n+     */\n+    public boolean isLeap(long instant) {\n+        return false;\n+    }\n+\n+    /**\n+     * Gets the amount by which this field is 'leap' for the specified instant.\n+     * <p>\n+     * For example, a leap year would return one, a non leap year would return\n+     * zero.\n+     * <p>\n+     * This implementation returns zero.\n+     */\n+    public int getLeapAmount(long instant) {\n+        return 0;\n+    }\n+\n+    /**\n+     * If this field were to leap, then it would be in units described by the\n+     * returned duration. If this field doesn't ever leap, null is returned.\n+     * <p>\n+     * This implementation returns null.\n+     */\n+    public DurationField getLeapDurationField() {\n+        return null;\n+    }\n+\n+    /**\n+     * Get the minimum allowable value for this field.\n+     * \n+     * @return the minimum valid value for this field, in the units of the\n+     * field\n+     */\n+    public abstract int getMinimumValue();\n+\n+    /**\n+     * Get the minimum value for this field evaluated at the specified time.\n+     * <p>\n+     * This implementation returns the same as {@link #getMinimumValue()}.\n+     * \n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to query\n+     * @return the minimum value for this field, in the units of the field\n+     */\n+    public int getMinimumValue(long instant) {\n+        return getMinimumValue();\n+    }\n+\n+    /**\n+     * Get the maximum allowable value for this field.\n+     * \n+     * @return the maximum valid value for this field, in the units of the\n+     * field\n+     */\n+    public abstract int getMaximumValue();\n+\n+    /**\n+     * Get the maximum value for this field evaluated at the specified time.\n+     * <p>\n+     * This implementation returns the same as {@link #getMaximumValue()}.\n+     * \n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to query\n+     * @return the maximum value for this field, in the units of the field\n+     */\n+    public int getMaximumValue(long instant) {\n+        return getMaximumValue();\n+    }\n+\n+    /**\n+     * Get the maximum text value for this field. The default implementation\n+     * returns the equivalent of Integer.toString(getMaximumValue()).length().\n+     * \n+     * @param locale  the locale to use for selecting a text symbol\n+     * @return the maximum text length\n+     */\n+    public int getMaximumTextLength(Locale locale) {\n+        int max = getMaximumValue();\n+        if (max >= 0) {\n+            if (max < 10) {\n+                return 1;\n+            } else if (max < 100) {\n+                return 2;\n+            } else if (max < 1000) {\n+                return 3;\n+            }\n+        }\n+        return Integer.toString(max).length();\n+    }\n+\n+    /**\n+     * Get the maximum short text value for this field. The default\n+     * implementation returns getMaximumTextLength().\n+     * \n+     * @param locale  the locale to use for selecting a text symbol\n+     * @return the maximum short text length\n+     */\n+    public int getMaximumShortTextLength(Locale locale) {\n+        return getMaximumTextLength(locale);\n+    }\n+\n+    // Calculation API\n+    //------------------------------------------------------------------------\n+    /**\n+     * Round to the lowest whole unit of this field. After rounding, the value\n+     * of this field and all fields of a higher magnitude are retained. The\n+     * fractional millis that cannot be expressed in whole increments of this\n+     * field are set to minimum.\n+     * <p>\n+     * For example, a datetime of 2002-11-02T23:34:56.789, rounded to the\n+     * lowest whole hour is 2002-11-02T23:00:00.000.\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to round\n+     * @return rounded milliseconds\n+     */\n+    public abstract long roundFloor(long instant);\n+\n+    /**\n+     * Round to the highest whole unit of this field. The value of this field\n+     * and all fields of a higher magnitude may be incremented in order to\n+     * achieve this result. The fractional millis that cannot be expressed in\n+     * whole increments of this field are set to minimum.\n+     * <p>\n+     * For example, a datetime of 2002-11-02T23:34:56.789, rounded to the\n+     * highest whole hour is 2002-11-03T00:00:00.000.\n+     * <p>\n+     * The default implementation calls roundFloor, and if the instant is\n+     * modified as a result, adds one field unit. Subclasses are encouraged to\n+     * provide a more efficient implementation.\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to round\n+     * @return rounded milliseconds\n+     */\n+    public long roundCeiling(long instant) {\n+        long newInstant = roundFloor(instant);\n+        if (newInstant != instant) {\n+            instant = add(newInstant, 1);\n+        }\n+        return instant;\n+    }\n+\n+    /**\n+     * Round to the nearest whole unit of this field. If the given millisecond\n+     * value is closer to the floor or is exactly halfway, this function\n+     * behaves like roundFloor. If the millisecond value is closer to the\n+     * ceiling, this function behaves like roundCeiling.\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to round\n+     * @return rounded milliseconds\n+     */\n+    public long roundHalfFloor(long instant) {\n+        long floor = roundFloor(instant);\n+        long ceiling = roundCeiling(instant);\n+\n+        long diffFromFloor = instant - floor;\n+        long diffToCeiling = ceiling - instant;\n+\n+        if (diffFromFloor <= diffToCeiling) {\n+            // Closer to the floor, or halfway - round floor\n+            return floor;\n+        } else {\n+            return ceiling;\n+        }\n+    }\n+\n+    /**\n+     * Round to the nearest whole unit of this field. If the given millisecond\n+     * value is closer to the floor, this function behaves like roundFloor. If\n+     * the millisecond value is closer to the ceiling or is exactly halfway,\n+     * this function behaves like roundCeiling.\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to round\n+     * @return rounded milliseconds\n+     */\n+    public long roundHalfCeiling(long instant) {\n+        long floor = roundFloor(instant);\n+        long ceiling = roundCeiling(instant);\n+\n+        long diffFromFloor = instant - floor;\n+        long diffToCeiling = ceiling - instant;\n+\n+        if (diffToCeiling <= diffFromFloor) {\n+            // Closer to the ceiling, or halfway - round ceiling\n+            return ceiling;\n+        } else {\n+            return floor;\n+        }\n+    }\n+\n+    /**\n+     * Round to the nearest whole unit of this field. If the given millisecond\n+     * value is closer to the floor, this function behaves like roundFloor. If\n+     * the millisecond value is closer to the ceiling, this function behaves\n+     * like roundCeiling.\n+     * <p>\n+     * If the millisecond value is exactly halfway between the floor and\n+     * ceiling, the ceiling is chosen over the floor only if it makes this\n+     * field's value even.\n+     *\n+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to round\n+     * @return rounded milliseconds\n+     */\n+    public long roundHalfEven(long instant) {\n+        long floor = roundFloor(instant);\n+        long ceiling = roundCeiling(instant);\n+\n+        long diffFromFloor = instant - floor;\n+        long diffToCeiling = ceiling - instant;\n+\n+        if (diffFromFloor < diffToCeiling) {\n+            // Closer to the floor - round floor\n+            return floor;\n+        } else if (diffToCeiling < diffFromFloor) {\n+            // Closer to the ceiling - round ceiling\n+            return ceiling;\n+        } else {\n+            // Round to the instant that makes this field even. If both values\n+            // make this field even (unlikely), favor the ceiling.\n+            if ((get(ceiling) & 1) == 0) {\n+                return ceiling;\n+            }\n+            return floor;\n+        }\n+    }\n+\n+    /**\n+     * Returns the fractional duration milliseconds of this field. In other\n+     * words, calling remainder returns the duration that roundFloor would\n+     * subtract.\n+     * <p>\n+     * For example, on a datetime of 2002-11-02T23:34:56.789, the remainder by\n+     * hour is 34 minutes and 56.789 seconds.\n+     * <p>\n+     * The default implementation computes\n+     * <code>instant - roundFloor(instant)</code>. Subclasses are encouraged to\n+     * provide a more efficient implementation.\n+     *\n+     * @param instant the milliseconds from 1970-01-01T00:00:00Z to get the\n+     * remainder\n+     * @return remainder duration, in milliseconds\n+     */\n+    public long remainder(long instant) {\n+        return instant - roundFloor(instant);\n+    }\n+\n+    /**\n+     * Get a suitable debug string.\n+     * \n+     * @return debug string\n+     */\n+    public String toString() {\n+        return \"DateTimeField[\" + getName() + ']';\n+    }\n+\n+}\n--- a/JodaTime/src/java/org/joda/time/field/DecoratedDateTimeField.java\n+++ b/JodaTime/src/java/org/joda/time/field/DecoratedDateTimeField.java\n import org.joda.time.DurationField;\n \n /**\n- * <code>DecoratedDateTimeField</code> extends {@link AbstractDateTimeField},\n+ * <code>DecoratedDateTimeField</code> extends {@link BaseDateTimeField},\n  * implementing only the minimum required set of methods. These implemented\n  * methods delegate to a wrapped field.\n  * <p>\n  * This design allows new DateTimeField types to be defined that piggyback on\n  * top of another, inheriting all the safe method implementations from\n- * AbstractDateTimeField. Should any method require pure delegation to the\n+ * BaseDateTimeField. Should any method require pure delegation to the\n  * wrapped field, simply override and use the provided getWrappedField method.\n  * <p>\n  * DecoratedDateTimeField is thread-safe and immutable, and its subclasses must\n  * @since 1.0\n  * @see DelegatedDateTimeField\n  */\n-public abstract class DecoratedDateTimeField extends AbstractDateTimeField {\n+public abstract class DecoratedDateTimeField extends BaseDateTimeField {\n \n     /** Serialization version */\n     private static final long serialVersionUID = 203115783733757597L;\n--- a/JodaTime/src/java/org/joda/time/field/ImpreciseDateTimeField.java\n+++ b/JodaTime/src/java/org/joda/time/field/ImpreciseDateTimeField.java\n  * {@link PreciseDateTimeField} should be used instead.\n  * <p>\n  * When defining imprecise DateTimeFields where a matching DurationField is\n- * already available, just extend AbstractDateTimeField directly so as not to\n+ * already available, just extend BaseDateTimeField directly so as not to\n  * create redundant DurationField instances.\n  * <p>\n  * ImpreciseDateTimeField is thread-safe and immutable, and its subclasses must\n  * @author Brian S O'Neill\n  * @see PreciseDateTimeField\n  */\n-public abstract class ImpreciseDateTimeField extends AbstractDateTimeField {\n+public abstract class ImpreciseDateTimeField extends BaseDateTimeField {\n \n     static final long serialVersionUID = 7190739608550251860L;\n \n--- a/JodaTime/src/java/org/joda/time/field/PreciseDurationDateTimeField.java\n+++ b/JodaTime/src/java/org/joda/time/field/PreciseDurationDateTimeField.java\n  *\n  * @author Brian S O'Neill\n  */\n-public abstract class PreciseDurationDateTimeField extends AbstractDateTimeField {\n+public abstract class PreciseDurationDateTimeField extends BaseDateTimeField {\n \n     static final long serialVersionUID = 5004523158306266035L;\n ", "timestamp": 1084711187, "metainfo": ""}