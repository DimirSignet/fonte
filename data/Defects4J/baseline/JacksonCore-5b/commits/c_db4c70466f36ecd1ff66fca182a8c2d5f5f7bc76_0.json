{"sha": "db4c70466f36ecd1ff66fca182a8c2d5f5f7bc76", "log": "Combine BaseReader and UTF32Reader, to reduce jar size", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/core/io/JsonStringEncoder.java\n+++ b/src/main/java/com/fasterxml/jackson/core/io/JsonStringEncoder.java\n     private final static int SURR2_FIRST = 0xDC00;\n     private final static int SURR2_LAST = 0xDFFF;\n \n-    private final static int INT_BACKSLASH = '\\\\';\n-    private final static int INT_U = 'u';\n-    private final static int INT_0 = '0';\n+//    private final static int INT_BACKSLASH = '\\\\';\n+//    private final static int INT_U = 'u';\n+//    private final static int INT_0 = '0';\n     \n     /**\n      * This <code>ThreadLocal</code> contains a {@link java.lang.ref.SoftReference}\n     /**********************************************************\n      */\n     \n-    public JsonStringEncoder()\n-    {\n+    public JsonStringEncoder() {\n         _quoteBuffer = new char[6];\n         _quoteBuffer[0] = '\\\\';\n         _quoteBuffer[2] = '0';\n      * Factory method for getting an instance; this is either recycled per-thread instance,\n      * or a newly constructed one.\n      */\n-    public static JsonStringEncoder getInstance()\n-    {\n+    public static JsonStringEncoder getInstance() {\n         SoftReference<JsonStringEncoder> ref = _threadEncoder.get();\n         JsonStringEncoder enc = (ref == null) ? null : ref.get();\n \n     /**********************************************************\n      */\n \n-    private int _appendNumericEscape(int value, char[] quoteBuffer)\n-    {\n+    private int _appendNumericEscape(int value, char[] quoteBuffer) {\n         quoteBuffer[1] = 'u';\n         // We know it's a control char, so only the last 2 chars are non-0\n         quoteBuffer[4] = HEX_CHARS[value >> 4];\n         return 6;\n     }\n \n-    private int _appendNamedEscape(int escCode, char[] quoteBuffer)\n-    {\n+    private int _appendNamedEscape(int escCode, char[] quoteBuffer) {\n         quoteBuffer[1] = (char) escCode;\n         return 2;\n     }\n     private int _appendByteEscape(int ch, int escCode, ByteArrayBuilder byteBuilder, int ptr)\n     {\n         byteBuilder.setCurrentSegmentLength(ptr);\n-        byteBuilder.append(INT_BACKSLASH);\n+        byteBuilder.append('\\\\');\n         if (escCode < 0) { // standard escape\n-            byteBuilder.append(INT_U);\n+            byteBuilder.append('u');\n             if (ch > 0xFF) {\n                 int hi = (ch >> 8);\n                 byteBuilder.append(HEX_BYTES[hi >> 4]);\n                 byteBuilder.append(HEX_BYTES[hi & 0xF]);\n                 ch &= 0xFF;\n             } else {\n-                byteBuilder.append(INT_0);\n-                byteBuilder.append(INT_0);\n+                byteBuilder.append('0');\n+                byteBuilder.append('0');\n             }\n             byteBuilder.append(HEX_BYTES[ch >> 4]);\n             byteBuilder.append(HEX_BYTES[ch & 0xF]);\n         return byteBuilder.getCurrentSegmentLength();\n     }\n \n-    protected static int _convertSurrogate(int firstPart, int secondPart)\n-    {\n+    protected static int _convertSurrogate(int firstPart, int secondPart) {\n         // Ok, then, is the second part valid?\n         if (secondPart < SURR2_FIRST || secondPart > SURR2_LAST) {\n             throw new IllegalArgumentException(\"Broken surrogate pair: first char 0x\"+Integer.toHexString(firstPart)+\", second 0x\"+Integer.toHexString(secondPart)+\"; illegal combination\");\n--- a/src/main/java/com/fasterxml/jackson/core/io/UTF32Reader.java\n+++ b/src/main/java/com/fasterxml/jackson/core/io/UTF32Reader.java\n  * Since JDK does not come with UTF-32/UCS-4, let's implement a simple\n  * decoder to use.\n  */\n-public class UTF32Reader extends BaseReader\n+public class UTF32Reader extends Reader\n {\n+    /**\n+     * JSON actually limits available Unicode range in the high end\n+     * to the same as xml (to basically limit UTF-8 max byte sequence\n+     * length to 4)\n+     */\n+    final protected static int LAST_VALID_UNICODE_CHAR = 0x10FFFF;\n+\n+    final protected static char NC = (char) 0;\n+\n+    final protected IOContext _context;\n+\n+    protected InputStream _in;\n+\n+    protected byte[] _buffer;\n+\n+    protected int _ptr;\n+    protected int _length;\n+\n     protected final boolean _bigEndian;\n \n     /**\n      * 16-bit chars, so we may have to split high-order chars into\n      * surrogate pairs.\n      */\n-    protected char _surrogate = NULL_CHAR;\n+    protected char _surrogate = NC;\n \n     /**\n      * Total read character count; used for error reporting purposes\n      */\n \n     public UTF32Reader(IOContext ctxt, InputStream in, byte[] buf, int ptr, int len, boolean isBigEndian) {\n-        super(ctxt, in, buf, ptr, len);\n+        _context = ctxt;\n+        _in = in;\n+        _buffer = buf;\n+        _ptr = ptr;\n+        _length = len;\n         _bigEndian = isBigEndian;\n         _managedBuffers = (in != null);\n     }\n     /**********************************************************\n      */\n \n+    @Override\n+    public void close() throws IOException {\n+        InputStream in = _in;\n+\n+        if (in != null) {\n+            _in = null;\n+            freeBuffers();\n+            in.close();\n+        }\n+    }\n+\n+    protected char[] _tmpBuf = null;\n+\n+    /**\n+     * Although this method is implemented by the base class, AND it should\n+     * never be called by main code, let's still implement it bit more\n+     * efficiently just in case\n+     */\n+    @Override\n+    public int read() throws IOException {\n+        if (_tmpBuf == null) {\n+            _tmpBuf = new char[1];\n+        }\n+        if (read(_tmpBuf, 0, 1) < 1) {\n+            return -1;\n+        }\n+        return _tmpBuf[0];\n+    }\n+    \n     @Override\n     public int read(char[] cbuf, int start, int len) throws IOException {\n         // Already EOF?\n         int outPtr = start;\n \n         // Ok, first; do we have a surrogate from last round?\n-        if (_surrogate != NULL_CHAR) {\n+        if (_surrogate != NC) {\n             cbuf[outPtr++] = _surrogate;\n-            _surrogate = NULL_CHAR;\n+            _surrogate = NC;\n             // No need to load more, already got one char\n         } else {\n             /* Note: we'll try to avoid blocking as much as possible. As a\n         }\n         return true;\n     }\n+\n+    /**\n+     * This method should be called along with (or instead of) normal\n+     * close. After calling this method, no further reads should be tried.\n+     * Method will try to recycle read buffers (if any).\n+     */\n+    private void freeBuffers() {\n+        byte[] buf = _buffer;\n+        if (buf != null) {\n+            _buffer = null;\n+            _context.releaseReadIOBuffer(buf);\n+        }\n+    }\n+\n+    private void reportBounds(char[] cbuf, int start, int len) throws IOException {\n+        throw new ArrayIndexOutOfBoundsException(\"read(buf,\"+start+\",\"+len+\"), cbuf[\"+cbuf.length+\"]\");\n+    }\n+\n+    private void reportStrangeStream() throws IOException {\n+        throw new IOException(\"Strange I/O stream, returned 0 bytes on read\");\n+    }\n }", "timestamp": 1387002576, "metainfo": ""}