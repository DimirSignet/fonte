{"sha": "e6dfc69f34511e2d30e7c4924e4defc730c02bdb", "log": "Implemented [Issue#26], ability to change root-value separator; usually to change it to linefeed (from single space)", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/core/JsonFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/core/JsonFactory.java\n import com.fasterxml.jackson.core.sym.BytesToNameCanonicalizer;\n import com.fasterxml.jackson.core.sym.CharsToNameCanonicalizer;\n import com.fasterxml.jackson.core.util.BufferRecycler;\n+import com.fasterxml.jackson.core.util.DefaultPrettyPrinter;\n \n /**\n  * The main factory class of Jackson package, used to configure and\n      */\n     protected final static int DEFAULT_GENERATOR_FEATURE_FLAGS = JsonGenerator.Feature.collectDefaults();\n \n+    private final static SerializableString DEFAULT_ROOT_VALUE_SEPARATOR = DefaultPrettyPrinter.DEFAULT_ROOT_VALUE_SEPARATOR;\n+    \n     /**\n      * Enumeration that defines all on/off features that can only be\n      * changed for {@link JsonFactory}.\n      * additional processing on output during content generation.\n      */\n     protected OutputDecorator _outputDecorator;\n+\n+    /**\n+     * Separator used between root-level values, if any; null indicates\n+     * \"do not add separator\".\n+     * Default separator is a single space character.\n+     * \n+     * @since 2.1\n+     */\n+    protected SerializableString _rootValueSeparator = DEFAULT_ROOT_VALUE_SEPARATOR;\n     \n     /*\n     /**********************************************************\n     public JsonFactory setOutputDecorator(OutputDecorator d) {\n         _outputDecorator = d;\n         return this;\n+    }\n+\n+    /**\n+     * Method that allows overriding String used for separating root-level\n+     * JSON values (default is single space character)\n+     * \n+     * @param sep Separator to use, if any; null means that no separator is\n+     *   automatically added\n+     * \n+     * @since 2.1\n+     */\n+    public JsonFactory setRootValueSeparator(String sep) {\n+        _rootValueSeparator = (sep == null) ? null : new SerializedString(sep);\n+        return this;\n+    }\n+\n+    /**\n+     * @since 2.1\n+     */\n+    public String getRootValueSeparator() {\n+        return (_rootValueSeparator == null) ? null : _rootValueSeparator.getValue();\n     }\n     \n     /*\n     protected JsonGenerator _createJsonGenerator(Writer out, IOContext ctxt)\n         throws IOException\n     {\n-        WriterBasedJsonGenerator gen = new WriterBasedJsonGenerator(ctxt, _generatorFeatures, _objectCodec, out);\n+        WriterBasedJsonGenerator gen = new WriterBasedJsonGenerator(ctxt,\n+                _generatorFeatures, _objectCodec, out);\n         if (_characterEscapes != null) {\n             gen.setCharacterEscapes(_characterEscapes);\n+        }\n+        SerializableString rootSep = _rootValueSeparator;\n+        if (rootSep != DEFAULT_ROOT_VALUE_SEPARATOR) {\n+            gen.setRootValueSeparator(rootSep);\n         }\n         return gen;\n     }\n     protected JsonGenerator _createUTF8JsonGenerator(OutputStream out, IOContext ctxt)\n         throws IOException\n     {\n-        UTF8JsonGenerator gen = new UTF8JsonGenerator(ctxt, _generatorFeatures, _objectCodec, out);\n+        UTF8JsonGenerator gen = new UTF8JsonGenerator(ctxt,\n+                _generatorFeatures, _objectCodec, out);\n         if (_characterEscapes != null) {\n             gen.setCharacterEscapes(_characterEscapes);\n+        }\n+        SerializableString rootSep = _rootValueSeparator;\n+        if (rootSep != DEFAULT_ROOT_VALUE_SEPARATOR) {\n+            gen.setRootValueSeparator(rootSep);\n         }\n         return gen;\n     }\n--- a/src/main/java/com/fasterxml/jackson/core/JsonGenerator.java\n+++ b/src/main/java/com/fasterxml/jackson/core/JsonGenerator.java\n     public Object getOutputTarget() {\n         return null;\n     }\n+\n+    /**\n+     * Method that allows overriding String used for separating root-level\n+     * JSON values (default is single space character)\n+     * \n+     * @param sep Separator to use, if any; null means that no separator is\n+     *   automatically added\n+     * \n+     * @since 2.1\n+     */\n+    public JsonGenerator setRootValueSeparator(SerializableString sep) {\n+        throw new UnsupportedOperationException();\n+    }\n     \n     /*\n     /**********************************************************\n     public abstract void writeRaw(char c)\n         throws IOException, JsonGenerationException;\n \n+    /**\n+     * Method that will force generator to copy\n+     * input text verbatim with <b>no</b> modifications (including\n+     * that no escaping is done and no separators are added even\n+     * if context [array, object] would otherwise require such).\n+     * If such separators are desired, use\n+     * {@link #writeRawValue(String)} instead.\n+     *<p>\n+     * Note that not all generator implementations necessarily support\n+     * such by-pass methods: those that do not will throw\n+     * {@link UnsupportedOperationException}.\n+     *<p>\n+     * The default implementation delegates to {@link #writeRaw(String)};\n+     * other backends that support raw inclusion of text are encouraged\n+     * to implement it in more efficient manner (especially if they\n+     * use UTF-8 encoding).\n+     * \n+     * @since 2.1\n+     */\n+    public void writeRaw(SerializableString raw)\n+        throws IOException, JsonGenerationException {\n+        writeRaw(raw.getValue());\n+    }\n+    \n     /**\n      * Method that will force generator to copy\n      * input text verbatim without any modifications, but assuming\n      *   and also the underlying alphabet to use.\n      */\n     public abstract void writeBinary(Base64Variant b64variant,\n-                                     byte[] data, int offset, int len)\n+            byte[] data, int offset, int len)\n         throws IOException, JsonGenerationException;\n \n     /**\n--- a/src/main/java/com/fasterxml/jackson/core/SerializableString.java\n+++ b/src/main/java/com/fasterxml/jackson/core/SerializableString.java\n      *</pre>\n      * \n      * @return Number of bytes appended, if successful, otherwise -1\n-     * \n-     * @since 2.0\n      */\n     public int appendQuotedUTF8(byte[] buffer, int offset);\n \n      *</pre>\n      * \n      * @return Number of characters appended, if successful, otherwise -1\n-     * \n-     * @since 2.0\n      */\n     public int appendQuoted(char[] buffer, int offset);\n     \n      *</pre>\n      * \n      * @return Number of bytes appended, if successful, otherwise -1\n-     * \n-     * @since 2.0\n      */\n     public int appendUnquotedUTF8(byte[] buffer, int offset);\n \n      *</pre>\n      * \n      * @return Number of characters appended, if successful, otherwise -1\n-     * \n-     * @since 2.0\n      */\n     public int appendUnquoted(char[] buffer, int offset);\n \n \n     /**\n      * @return Number of bytes written\n-     * \n-     * @since 2.0\n      */\n     public int writeQuotedUTF8(OutputStream out) throws IOException;\n \n     /**\n      * @return Number of bytes written\n-     * \n-     * @since 2.0\n      */\n     public int writeUnquotedUTF8(OutputStream out) throws IOException;\n \n     /**\n      * @return Number of bytes put, if successful, otherwise -1\n-     * \n-     * @since 2.0\n      */\n     public int putQuotedUTF8(ByteBuffer buffer) throws IOException;\n \n     /**\n      * @return Number of bytes put, if successful, otherwise -1\n-     * \n-     * @since 2.0\n      */\n     public int putUnquotedUTF8(ByteBuffer out) throws IOException;\n }\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/core/json/JsonGeneratorImpl.java\n+package com.fasterxml.jackson.core.json;\n+\n+import java.io.IOException;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.core.base.GeneratorBase;\n+import com.fasterxml.jackson.core.io.CharTypes;\n+import com.fasterxml.jackson.core.io.CharacterEscapes;\n+import com.fasterxml.jackson.core.io.IOContext;\n+import com.fasterxml.jackson.core.util.DefaultPrettyPrinter;\n+import com.fasterxml.jackson.core.util.VersionUtil;\n+\n+/**\n+ * Intermediate base class shared by JSON-backed generators\n+ * like {@link UTF8JsonGenerator} and {@link WriterBasedJsonGenerator}.\n+ * \n+ * @since 2.1\n+ */\n+public abstract class JsonGeneratorImpl extends GeneratorBase\n+{\n+    /*\n+    /**********************************************************\n+    /* Constants\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * This is the default set of escape codes, over 7-bit ASCII range\n+     * (first 128 character codes), used for single-byte UTF-8 characters.\n+     */\n+    protected final static int[] sOutputEscapes = CharTypes.get7BitOutputEscapes();\n+    \n+    /*\n+    /**********************************************************\n+    /* Configuration, basic I/O\n+    /**********************************************************\n+     */\n+\n+    final protected IOContext _ioContext;\n+\n+    /*\n+    /**********************************************************\n+    /* Configuration, output escaping\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Currently active set of output escape code definitions (whether\n+     * and how to escape or not) for 7-bit ASCII range (first 128\n+     * character codes). Defined separately to make potentially\n+     * customizable\n+     */\n+    protected int[] _outputEscapes = sOutputEscapes;\n+\n+    /**\n+     * Value between 128 (0x80) and 65535 (0xFFFF) that indicates highest\n+     * Unicode code point that will not need escaping; or 0 to indicate\n+     * that all characters can be represented without escaping.\n+     * Typically used to force escaping of some portion of character set;\n+     * for example to always escape non-ASCII characters (if value was 127).\n+     *<p>\n+     * NOTE: not all sub-classes make use of this setting.\n+     */\n+    protected int _maximumNonEscapedChar;\n+\n+    /**\n+     * Definition of custom character escapes to use for generators created\n+     * by this factory, if any. If null, standard data format specific\n+     * escapes are used.\n+     */\n+    protected CharacterEscapes _characterEscapes;\n+    \n+    /*\n+    /**********************************************************\n+    /* Configuration, other\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Separator to use, if any, between root-level values.\n+     * \n+     * @since 2.1\n+     */\n+    protected SerializableString _rootValueSeparator\n+        = DefaultPrettyPrinter.DEFAULT_ROOT_VALUE_SEPARATOR;\n+\n+    /*\n+    /**********************************************************\n+    /* Life-cycle\n+    /**********************************************************\n+     */\n+\n+    public JsonGeneratorImpl(IOContext ctxt, int features, ObjectCodec codec)\n+    {\n+        super(features, codec);\n+        _ioContext = ctxt;\n+        if (isEnabled(Feature.ESCAPE_NON_ASCII)) {\n+            setHighestNonEscapedChar(127);\n+        }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Overridden configuration methods\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public JsonGenerator setHighestNonEscapedChar(int charCode) {\n+        _maximumNonEscapedChar = (charCode < 0) ? 0 : charCode;\n+        return this;\n+    }\n+\n+    @Override\n+    public int getHighestEscapedChar() {\n+        return _maximumNonEscapedChar;\n+    }\n+\n+    @Override\n+    public JsonGenerator setCharacterEscapes(CharacterEscapes esc)\n+    {\n+        _characterEscapes = esc;\n+        if (esc == null) { // revert to standard escapes\n+            _outputEscapes = sOutputEscapes;\n+        } else {\n+            _outputEscapes = esc.getEscapeCodesForAscii();\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Method for accessing custom escapes factory uses for {@link JsonGenerator}s\n+     * it creates.\n+     */\n+    @Override\n+    public CharacterEscapes getCharacterEscapes() {\n+        return _characterEscapes;\n+    }\n+    \n+    @Override\n+    public JsonGenerator setRootValueSeparator(SerializableString sep) {\n+        _rootValueSeparator = sep;\n+        return this;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Versioned\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public Version version() {\n+        return VersionUtil.versionFor(getClass());\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Partial API\n+    /**********************************************************\n+     */\n+\n+    // // Overrides just to make things final, to possibly help with inlining\n+    \n+    @Override\n+    public final void writeStringField(String fieldName, String value)\n+        throws IOException, JsonGenerationException\n+    {\n+        writeFieldName(fieldName);\n+        writeString(value);\n+    }\n+    \n+}\n--- a/src/main/java/com/fasterxml/jackson/core/json/UTF8JsonGenerator.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/UTF8JsonGenerator.java\n import java.math.BigInteger;\n \n import com.fasterxml.jackson.core.*;\n-import com.fasterxml.jackson.core.base.GeneratorBase;\n import com.fasterxml.jackson.core.io.*;\n-import com.fasterxml.jackson.core.util.VersionUtil;\n \n public class UTF8JsonGenerator\n-    extends GeneratorBase\n+    extends JsonGeneratorImpl\n {\n     private final static byte BYTE_u = (byte) 'u';\n \n     private final static byte BYTE_RCURLY = (byte) '}';\n  \n     private final static byte BYTE_BACKSLASH = (byte) '\\\\';\n-    private final static byte BYTE_SPACE = (byte) ' ';\n     private final static byte BYTE_COMMA = (byte) ',';\n     private final static byte BYTE_COLON = (byte) ':';\n     private final static byte BYTE_QUOTE = (byte) '\"';\n     private final static byte[] TRUE_BYTES = { 't', 'r', 'u', 'e' };\n     private final static byte[] FALSE_BYTES = { 'f', 'a', 'l', 's', 'e' };\n \n-    /**\n-     * This is the default set of escape codes, over 7-bit ASCII range\n-     * (first 128 character codes), used for single-byte UTF-8 characters.\n-     */\n-    protected final static int[] sOutputEscapes = CharTypes.get7BitOutputEscapes();\n-    \n     /*\n     /**********************************************************\n-    /* Configuration, basic I/O\n-    /**********************************************************\n-     */\n-\n-    final protected IOContext _ioContext;\n-\n+    /* Output buffering\n+    /**********************************************************\n+     */\n+    \n     /**\n      * Underlying output stream used for writing JSON content.\n      */\n     final protected OutputStream _outputStream;\n-\n-    /*\n-    /**********************************************************\n-    /* Configuration, output escaping\n-    /**********************************************************\n-     */\n-\n-    /**\n-     * Currently active set of output escape code definitions (whether\n-     * and how to escape or not) for 7-bit ASCII range (first 128\n-     * character codes). Defined separately to make potentially\n-     * customizable\n-     */\n-    protected int[] _outputEscapes = sOutputEscapes;\n-\n-    /**\n-     * Value between 128 (0x80) and 65535 (0xFFFF) that indicates highest\n-     * Unicode code point that will not need escaping; or 0 to indicate\n-     * that all characters can be represented without escaping.\n-     * Typically used to force escaping of some portion of character set;\n-     * for example to always escape non-ASCII characters (if value was 127).\n-     *<p>\n-     * NOTE: not all sub-classes make use of this setting.\n-     */\n-    protected int _maximumNonEscapedChar;\n-\n-    /**\n-     * Definition of custom character escapes to use for generators created\n-     * by this factory, if any. If null, standard data format specific\n-     * escapes are used.\n-     */\n-    protected CharacterEscapes _characterEscapes;\n-    \n-    /*\n-    /**********************************************************\n-    /* Output buffering\n-    /**********************************************************\n-     */\n \n     /**\n      * Intermediate buffer in which contents are buffered before\n     public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec,\n             OutputStream out)\n     {\n-        \n-        super(features, codec);\n-        _ioContext = ctxt;\n+        super(ctxt, features, codec);\n         _outputStream = out;\n         _bufferRecyclable = true;\n         _outputBuffer = ctxt.allocWriteEncodingBuffer();\n         _outputEnd = _outputBuffer.length;\n+\n         /* To be exact, each char can take up to 6 bytes when escaped (Unicode\n          * escape with backslash, 'u' and 4 hex digits); but to avoid fluctuation,\n          * we will actually round down to only do up to 1/8 number of chars\n             setHighestNonEscapedChar(127);\n         }\n     }\n-\n+    \n     public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec,\n-            OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable)\n+            OutputStream out,\n+            byte[] outputBuffer, int outputOffset, boolean bufferRecyclable)\n     {\n         \n-        super(features, codec);\n-        _ioContext = ctxt;\n+        super(ctxt, features, codec);\n         _outputStream = out;\n         _bufferRecyclable = bufferRecyclable;\n         _outputTail = outputOffset;\n         _outputMaxContiguous = _outputEnd >> 3;\n         _charBuffer = ctxt.allocConcatBuffer();\n         _charBufferLength = _charBuffer.length;\n-\n-        if (isEnabled(Feature.ESCAPE_NON_ASCII)) {\n-            setHighestNonEscapedChar(127);\n-        }\n-    }\n-\n-    @Override\n-    public Version version() {\n-        return VersionUtil.versionFor(getClass());\n-    }\n-    \n+    }\n+\n     /*\n     /**********************************************************\n     /* Overridden configuration methods\n     /**********************************************************\n      */\n     \n-    @Override\n-    public JsonGenerator setHighestNonEscapedChar(int charCode) {\n-        _maximumNonEscapedChar = (charCode < 0) ? 0 : charCode;\n-        return this;\n-    }\n-\n-    @Override\n-    public int getHighestEscapedChar() {\n-        return _maximumNonEscapedChar;\n-    }\n-\n-    @Override\n-    public JsonGenerator setCharacterEscapes(CharacterEscapes esc)\n-    {\n-        _characterEscapes = esc;\n-        if (esc == null) { // revert to standard escapes\n-            _outputEscapes = sOutputEscapes;\n-        } else {\n-            _outputEscapes = esc.getEscapeCodesForAscii();\n-        }\n-        return this;\n-    }\n-\n-    /**\n-     * Method for accessing custom escapes factory uses for {@link JsonGenerator}s\n-     * it creates.\n-     */\n-    @Override\n-    public CharacterEscapes getCharacterEscapes() {\n-        return _characterEscapes;\n-    }\n-\n     @Override\n     public Object getOutputTarget() {\n         return _outputStream;\n     }\n-    \n+\n     /*\n     /**********************************************************\n     /* Overridden methods\n     /**********************************************************\n      */\n-\n-    /* Most overrides in this section are just to make methods final,\n-     * to allow better inlining...\n-     */\n-    @Override\n-    public final void writeStringField(String fieldName, String value)\n-        throws IOException, JsonGenerationException\n-    {\n-        writeFieldName(fieldName);\n-        writeString(value);\n-    }\n \n     @Override\n     public final void writeFieldName(String name)  throws IOException, JsonGenerationException\n         }\n     }\n \n+    @Override\n+    public void writeRaw(SerializableString text) throws IOException, JsonGenerationException\n+    {\n+        byte[] raw = text.asUnquotedUTF8();\n+        if (raw.length > 0) {\n+            _writeBytes(raw);\n+        }\n+    }\n+    \n     // @TODO: rewrite for speed...\n     @Override\n     public final void writeRaw(char[] cbuf, int offset, int len)\n             case JsonWriteContext.STATUS_OK_AFTER_COLON:\n                 b = BYTE_COLON;\n                 break;\n-            case JsonWriteContext.STATUS_OK_AFTER_SPACE:\n-                b = BYTE_SPACE;\n-                break;\n+            case JsonWriteContext.STATUS_OK_AFTER_SPACE: // root-value separator\n+                if (_rootValueSeparator != null) {\n+                    byte[] raw = _rootValueSeparator.asUnquotedUTF8();\n+                    if (raw.length > 0) {\n+                        _writeBytes(raw);\n+                    }\n+                }\n+                return;\n             case JsonWriteContext.STATUS_OK_AS_IS:\n             default:\n                 return;\n--- a/src/main/java/com/fasterxml/jackson/core/json/WriterBasedJsonGenerator.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/WriterBasedJsonGenerator.java\n import java.math.BigInteger;\n \n import com.fasterxml.jackson.core.*;\n-import com.fasterxml.jackson.core.base.GeneratorBase;\n import com.fasterxml.jackson.core.io.*;\n-import com.fasterxml.jackson.core.util.VersionUtil;\n \n /**\n  * {@link JsonGenerator} that outputs JSON content using a {@link java.io.Writer}\n  * which handles character encoding.\n  */\n public final class WriterBasedJsonGenerator\n-    extends GeneratorBase\n+    extends JsonGeneratorImpl\n {\n     final protected static int SHORT_WRITE = 32;\n \n     final protected static char[] HEX_CHARS = CharTypes.copyHexChars();\n-\n-    /**\n-     * This is the default set of escape codes, over 7-bit ASCII range\n-     * (first 128 character codes), used for single-byte UTF-8 characters.\n-     */\n-    protected final static int[] sOutputEscapes = CharTypes.get7BitOutputEscapes();\n     \n     /*\n     /**********************************************************\n-    /* Configuration\n-    /**********************************************************\n-     */\n-\n-    final protected IOContext _ioContext;\n+    /* Output buffering\n+    /**********************************************************\n+     */\n \n     final protected Writer _writer;\n     \n-    /*\n-    /**********************************************************\n-    /* Configuration, output escaping\n-    /**********************************************************\n-     */\n-\n-    /**\n-     * Currently active set of output escape code definitions (whether\n-     * and how to escape or not) for 7-bit ASCII range (first 128\n-     * character codes). Defined separately to make potentially\n-     * customizable\n-     */\n-    protected int[] _outputEscapes = sOutputEscapes;\n-\n-    /**\n-     * Value between 128 (0x80) and 65535 (0xFFFF) that indicates highest\n-     * Unicode code point that will not need escaping; or 0 to indicate\n-     * that all characters can be represented without escaping.\n-     * Typically used to force escaping of some portion of character set;\n-     * for example to always escape non-ASCII characters (if value was 127).\n-     *<p>\n-     * NOTE: not all sub-classes make use of this setting.\n-     */\n-    protected int _maximumNonEscapedChar;\n-\n-    /**\n-     * Definition of custom character escapes to use for generators created\n-     * by this factory, if any. If null, standard data format specific\n-     * escapes are used.\n-     */\n-    protected CharacterEscapes _characterEscapes;\n-\n-    /**\n-     * When custom escapes are used, this member variable can be used to\n-     * store escape to use\n-     */\n-    protected SerializableString _currentEscape;\n-\n-    /*\n-    /**********************************************************\n-    /* Output buffering\n-    /**********************************************************\n-     */\n-\n     /**\n      * Intermediate buffer in which contents are buffered before\n      * being written using {@link #_writer}.\n      */\n     protected char[] _entityBuffer;\n \n+    /**\n+     * When custom escapes are used, this member variable is used\n+     * internally to hold a reference to currently used escape\n+     */\n+    protected SerializableString _currentEscape;\n+    \n+    \n     /*\n     /**********************************************************\n     /* Life-cycle\n     /**********************************************************\n      */\n \n-    public WriterBasedJsonGenerator(IOContext ctxt, int features, ObjectCodec codec,\n-            Writer w)\n-    {\n-        super(features, codec);\n-        _ioContext = ctxt;\n+    public WriterBasedJsonGenerator(IOContext ctxt, int features,\n+            ObjectCodec codec, Writer w)\n+    {\n+        super(ctxt, features, codec);\n         _writer = w;\n         _outputBuffer = ctxt.allocConcatBuffer();\n         _outputEnd = _outputBuffer.length;\n-\n-        if (isEnabled(Feature.ESCAPE_NON_ASCII)) {\n-            setHighestNonEscapedChar(127);\n-        }\n-    }\n-\n-    @Override\n-    public Version version() {\n-        return VersionUtil.versionFor(getClass());\n     }\n     \n     /*\n     /**********************************************************\n      */\n     \n-    @Override\n-    public JsonGenerator setHighestNonEscapedChar(int charCode) {\n-        _maximumNonEscapedChar = (charCode < 0) ? 0 : charCode;\n-        return this;\n-    }\n-\n-    @Override\n-    public int getHighestEscapedChar() {\n-        return _maximumNonEscapedChar;\n-    }\n-\n-    @Override\n-    public JsonGenerator setCharacterEscapes(CharacterEscapes esc)\n-    {\n-        _characterEscapes = esc;\n-        if (esc == null) { // revert to standard escapes\n-            _outputEscapes = sOutputEscapes;\n-        } else {\n-            _outputEscapes = esc.getEscapeCodesForAscii();\n-        }\n-        return this;\n-    }\n-\n-    /**\n-     * Method for accessing custom escapes factory uses for {@link JsonGenerator}s\n-     * it creates.\n-     */\n-    @Override\n-    public CharacterEscapes getCharacterEscapes() {\n-        return _characterEscapes;\n-    }\n-\n     @Override\n     public Object getOutputTarget() {\n         return _writer;\n     /**********************************************************\n     /* Overridden methods\n     /**********************************************************\n-     */\n-\n-    /* Most overrides in this section are just to make methods final,\n-     * to allow better inlining...\n      */\n \n     @Override\n             _reportError(\"Can not write a field name, expecting a value\");\n         }\n         _writeFieldName(name, (status == JsonWriteContext.STATUS_OK_AFTER_COMMA));\n-    }\n-\n-    @Override\n-    public final void writeStringField(String fieldName, String value)\n-        throws IOException, JsonGenerationException\n-    {\n-        writeFieldName(fieldName);\n-        writeString(value);\n     }\n \n     @Override\n         }\n     }\n \n+    // @since 2.1\n+    @Override\n+    public void writeRaw(SerializableString text) throws IOException, JsonGenerationException {\n+        writeRaw(text.getValue());\n+    }\n+    \n     @Override\n     public void writeRaw(char[] text, int offset, int len)\n         throws IOException, JsonGenerationException\n             case JsonWriteContext.STATUS_OK_AFTER_COLON:\n                 c = ':';\n                 break;\n-            case JsonWriteContext.STATUS_OK_AFTER_SPACE:\n-                c = ' ';\n-                break;\n+            case JsonWriteContext.STATUS_OK_AFTER_SPACE: // root-value separator\n+                if (_rootValueSeparator != null) {\n+                    writeRaw(_rootValueSeparator.getValue());\n+                }\n+                return;\n             case JsonWriteContext.STATUS_OK_AS_IS:\n             default:\n                 return;\n--- a/src/main/java/com/fasterxml/jackson/core/util/DefaultPrettyPrinter.java\n+++ b/src/main/java/com/fasterxml/jackson/core/util/DefaultPrettyPrinter.java\n import java.util.Arrays;\n \n import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.core.io.SerializedString;\n \n /**\n  * Default {@link PrettyPrinter} implementation that uses 2-space\n     implements PrettyPrinter, Instantiatable<DefaultPrettyPrinter>\n {\n     /**\n+     * Constant that specifies default \"root-level\" separator to use between\n+     * root values: a single space character.\n+     * \n+     * @since 2.1\n+     */\n+    public final static SerializedString DEFAULT_ROOT_VALUE_SEPARATOR = new SerializedString(\" \");\n+    \n+    /**\n      * Interface that defines objects that can produce indentation used\n      * to separate object entries and array values. Indentation in this\n      * context just means insertion of white space, independent of whether\n      */\n     protected Indenter _objectIndenter = new Lf2SpacesIndenter();\n \n+    /**\n+     * String printed between root-level values, if any.\n+     */\n+    protected final SerializableString _rootSeparator;\n+    \n     // // // Config, other white space configuration\n \n     /**\n     /**********************************************************\n     */\n \n-    public DefaultPrettyPrinter() { }\n-\n-    public DefaultPrettyPrinter(DefaultPrettyPrinter base)\n+    public DefaultPrettyPrinter() {\n+        this(DEFAULT_ROOT_VALUE_SEPARATOR);\n+    }\n+\n+    /**\n+     * Constructor that specifies separator String to use between root values;\n+     * if null, no separator is printed.\n+     *<p>\n+     * Note: simply constructs a {@link SerializedString} out of parameter,\n+     * calls {@link #DefaultPrettyPrinter(SerializableString)}\n+     * \n+     * @param rootSeparator\n+     * \n+     * @since 2.1\n+     */\n+    public DefaultPrettyPrinter(String rootSeparator) {\n+        this((rootSeparator == null) ? null : new SerializedString(rootSeparator));\n+    }\n+\n+    /**\n+     * Constructor that specifies separator String to use between root values;\n+     * if null, no separator is printed.\n+     * \n+     * @param rootSeparator\n+     * \n+     * @since 2.1\n+     */\n+    public DefaultPrettyPrinter(SerializableString rootSeparator) {\n+        _rootSeparator = rootSeparator;\n+    }\n+    \n+    public DefaultPrettyPrinter(DefaultPrettyPrinter base) {\n+        this(base, base._rootSeparator);\n+    }\n+\n+    public DefaultPrettyPrinter(DefaultPrettyPrinter base,\n+            SerializableString rootSeparator)\n     {\n         _arrayIndenter = base._arrayIndenter;\n         _objectIndenter = base._objectIndenter;\n         _spacesInObjectEntries = base._spacesInObjectEntries;\n         _nesting = base._nesting;\n+\n+        _rootSeparator = rootSeparator;\n+    }\n+\n+    public DefaultPrettyPrinter withRootSeparator(SerializableString rootSeparator)\n+    {\n+        if (_rootSeparator == rootSeparator ||\n+                (rootSeparator != null && rootSeparator.equals(_rootSeparator))) {\n+            return this;\n+        }\n+        return new DefaultPrettyPrinter(this, rootSeparator);\n     }\n     \n     public void indentArraysWith(Indenter i)\n     public void writeRootValueSeparator(JsonGenerator jg)\n         throws IOException, JsonGenerationException\n     {\n-        jg.writeRaw(' ');\n+        if (_rootSeparator != null) {\n+            jg.writeRaw(_rootSeparator);\n+        }\n     }\n \n //  @Override\n--- a/src/main/java/com/fasterxml/jackson/core/util/JsonGeneratorDelegate.java\n+++ b/src/main/java/com/fasterxml/jackson/core/util/JsonGeneratorDelegate.java\n \n     @Override\n     public JsonGenerator disable(Feature f) {\n-        return delegate.disable(f);\n+        delegate.disable(f);\n+        return this;\n     }\n \n     @Override\n     public JsonGenerator enable(Feature f) {\n-        return delegate.enable(f);\n+        delegate.enable(f);\n+        return this;\n     }\n \n     @Override\n     @Override\n     public Object getOutputTarget() {\n         return delegate.getOutputTarget();\n+    }\n+\n+    @Override\n+    public JsonGenerator setRootValueSeparator(SerializableString sep) {\n+        delegate.setRootValueSeparator(sep);\n+        return this;\n     }\n     \n     @Override\n     }\n \n     @Override\n+    public void writeRaw(SerializableString raw)\n+        throws IOException, JsonGenerationException {\n+        delegate.writeRaw(raw);\n+    }\n+    \n+    @Override\n     public void writeRaw(char[] text, int offset, int len) throws IOException, JsonGenerationException {\n         delegate.writeRaw(text, offset, len);\n     }\n--- a/src/test/java/com/fasterxml/jackson/core/main/TestPrettyPrinter.java\n+++ b/src/test/java/com/fasterxml/jackson/core/main/TestPrettyPrinter.java\n package com.fasterxml.jackson.core.main;\n \n import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.core.util.DefaultPrettyPrinter;\n import com.fasterxml.jackson.core.util.MinimalPrettyPrinter;\n \n import java.io.*;\n             jg.writeRaw(\"(\"+nrOfValues+\")]\");\n         }\n     }\n+\n+    /*\n+    /**********************************************************\n+    /* Test methods\n+    /**********************************************************\n+     */\n     \n     public void testObjectCount() throws Exception\n     {\n         }\n     }\n     \n-    /*\n-    /**********************************************************\n-    /* Test methods\n-    /**********************************************************\n-     */\n-    \n     public void testSimpleDocWithDefault() throws Exception\n     {\n         StringWriter sw = new StringWriter();\n         assertTrue(docStr.indexOf('\\t') >= 0);\n     }\n \n+    // [Issue#26]\n+    public void testCustomRootSeparatorWithPP() throws Exception\n+    {\n+        JsonFactory jf = new JsonFactory();\n+        // first, no pretty-printing (will still separate root values with a space!)\n+        assertEquals(\"{} {} []\", _generateRoot(jf, null));\n+        // First with default pretty printer, default configs:\n+        assertEquals(\"{ } { } [ ]\", _generateRoot(jf, new DefaultPrettyPrinter()));\n+        // then custom:\n+        assertEquals(\"{ }|{ }|[ ]\", _generateRoot(jf, new DefaultPrettyPrinter(\"|\")));\n+    }\n+\n+    // Alternative solution for [Issue#26]\n+    public void testCustomRootSeparatorWithFactory() throws Exception\n+    {\n+        JsonFactory jf = new JsonFactory();\n+        jf.setRootValueSeparator(\"##\");\n+        StringWriter sw = new StringWriter();\n+        JsonGenerator gen = jf.createJsonGenerator(sw);\n+        gen.writeNumber(13);\n+        gen.writeBoolean(false);\n+        gen.writeNull();\n+        gen.close();\n+        assertEquals(\"13##false##null\", sw.toString());\n+    }\n+    \n     /*\n     /**********************************************************\n     /* Helper methods\n \n         return docStr;\n     }\n+\n+    protected String _generateRoot(JsonFactory jf, PrettyPrinter pp) throws IOException\n+    {\n+        StringWriter sw = new StringWriter();\n+        JsonGenerator gen = new JsonFactory().createJsonGenerator(sw);\n+        gen.setPrettyPrinter(pp);\n+        gen.writeStartObject();\n+        gen.writeEndObject();\n+        gen.writeStartObject();\n+        gen.writeEndObject();\n+        gen.writeStartArray();\n+        gen.writeEndArray();\n+        gen.close();\n+        return sw.toString();\n+    }\n }", "timestamp": 1348871645, "metainfo": ""}