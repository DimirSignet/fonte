{"sha": "6e0ae14d5037242adb3096821315c45a41f7b900", "log": "Consider changing hash value to use; add tests.", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java\n+++ b/src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java\n {\n     /* If we use \"multiply-add\" based hash algorithm, this is the multiplier\n      * we use.\n-     */\n-    public final static int HASH_MULT = 33;\n+     *<p>\n+     * Note that with versions 2.3 and before used value of 33; but 2.4\n+     * changed it to 31 to align with default hash code, to more easily\n+     * detect attempted DoS attacks (since HashMap would fall into it\n+     * if we used different hash multiplier).\n+     */\n+    public final static int HASH_MULT = 31;\n     \n     /**\n      * Default initial table size. Shouldn't be miniscule (as there's\n--- a/src/test/java/com/fasterxml/jackson/core/sym/TestSymbolTables.java\n+++ b/src/test/java/com/fasterxml/jackson/core/sym/TestSymbolTables.java\n         \n         // holy guacamoley... there are way too many. 31 gives 3567 (!), 33 gives 2747\n         // ... at least before shuffling. Shuffling helps quite a lot, so:\n-        assertEquals(1401, symbols.collisionCount());\n-        // esp. with collisions; first got about 30\n-        assertEquals(4, symbols.maxCollisionLength());\n+\n+        /* 22-May-2014, tatu: With 33 we now should get 1401; but with\n+         *   31 bit more, 1858.\n+         */\n+//        assertEquals(1401, symbols.collisionCount());\n+        assertEquals(1858, symbols.collisionCount());\n+\n+        // esp. with collisions; first got about 30;\n+        // with fixes 4 (for 33), 5 (for 31)\n+\n+//        assertEquals(4, symbols.maxCollisionLength());\n+        assertEquals(5, symbols.maxCollisionLength());\n     }\n \n     // Test for verifying stability of hashCode, wrt collisions, using\n--- a/src/test/java/failing/TestHashCollision.java\n+++ b/src/test/java/failing/TestHashCollision.java\n     // // // And then a nastier variant; collisions generated using\n     // // // CollisionGenerator\n \n-    final static String[] MULT_33_COLLISION_FRAGMENTS = new String[] {\n-        // Ones generated for 65536...\n+    /*\n+    // for 33\n+    final static String[] MULT_COLLISION_FRAGMENTS = new String[] {\n+        // Ones generated for 33/65536...\n         \"9fa\", \"9g@\", \":Ea\", \":F@\", \";$a\", \";%@\"\n     };\n+    */\n \n+    // for 31\n+    final static String[] MULT_COLLISION_FRAGMENTS = new String[] {\n+        // Ones generated for 31/65536...\n+        \"@~~\", \"A_~\", \"A`_\", \"Aa@\", \"Ab!\", \"B@~\", // \"BA_\", \"BB@\", \"BC!\", \"C!~\"\n+    };\n+    \n     public void testReaderCollisions() throws Exception\n     {\n         StringBuilder sb = new StringBuilder();\n-        for (String field : collisions()) {\n+        List<String> coll = collisions();\n+\n+        // First just verify we got collisions for JDK too\n+        int hash = coll.get(0).hashCode();\n+        for (int i = 1, end = coll.size(); i < end; ++i) {\n+            if (coll.get(i).hashCode() != hash) {\n+                fail(\"String #\"+i+\" has different hash (0x\"+Integer.toHexString(coll.get(i).hashCode())\n+                        +\"), expected 0x\"+Integer.toHexString(hash));\n+            }\n+        }\n+        \n+        for (String field : coll) {\n             if (sb.length() == 0) {\n                 sb.append(\"{\");\n             } else {\n             ;\n         }\n         // and if we got here, fine\n+        jp.close();\n     }\n \n     /*\n     static List<String> collisions() {\n         // we'll get 6^4, which is bit over 1k\n         ArrayList<String> result = new ArrayList<String>(36 * 36);\n-        for (String str1 : MULT_33_COLLISION_FRAGMENTS) {\n-            for (String str2 : MULT_33_COLLISION_FRAGMENTS) {\n-                for (String str3 : MULT_33_COLLISION_FRAGMENTS) {\n-                    for (String str4 : MULT_33_COLLISION_FRAGMENTS) {\n+        \n+        final String[] FRAGMENTS = MULT_COLLISION_FRAGMENTS;\n+        \n+        for (String str1 : FRAGMENTS) {\n+            for (String str2 : FRAGMENTS) {\n+                for (String str3 : FRAGMENTS) {\n+                    for (String str4 : FRAGMENTS) {\n                         result.add(str1+str2+str3+str4);\n                     }\n                 }\n         /* JDK uses 31, but Jackson `CharsToNameCanonicalizer.HASH_MULT`,\n          * which for 2.3 is 33.\n          */\n-        \n         final static int MULT = CharsToNameCanonicalizer.HASH_MULT;\n \n         public void generate3(int h0) {\n         return result.toString();\n       }\n \n-      public static void main(String[] args) {\n-          System.out.println(\"<stuff>\");\n-//          new CollisionGenerator().generate3(1 << 20);\n-          new CollisionGenerator().generate3(1 << 16);\n-\n-          System.out.println();\n-          System.out.println(\"</stuff>\");\n-      }\n     }\n \n+    public static void main(String[] args) {\n+        System.out.println(\"<stuff>\");\n+//        new CollisionGenerator().generate3(1 << 20);\n+        new CollisionGenerator().generate3(1 << 16);\n \n+        System.out.println();\n+        System.out.println(\"</stuff>\");\n+    }\n }", "timestamp": 1400860709, "metainfo": ""}