{"sha": "8475c8b28353a795d9dd4e7857480898b0e5677d", "log": "Minor improvement for InternCache", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/core/util/InternCache.java\n+++ b/src/main/java/com/fasterxml/jackson/core/util/InternCache.java\n package com.fasterxml.jackson.core.util;\n \n-import java.util.Map;\n import java.util.LinkedHashMap;\n+import java.util.concurrent.ConcurrentHashMap;\n \n /**\n  * Singleton class that adds a simple first-level cache in front of\n  */\n @SuppressWarnings(\"serial\")\n public final class InternCache\n-    extends LinkedHashMap<String,String>\n+    extends ConcurrentHashMap<String,String> // since 2.3\n {\n     /**\n      * Size to use is somewhat arbitrary, so let's choose something that's\n      * neither too small (low hit ratio) nor too large (waste of memory).\n      *<p>\n-     * 11-Jul-2012, tatu: Also, consider the nasty case of String hashCode()\n-     *    collisions; size needs to be small enough to survive linear list\n-     *    lookup... so let's go down a notch (from 192 to 100)\n+     * One consideration is possible attack via colliding {@link String#hashCode};\n+     * because of this, limit to reasonably low setting.\n      */\n-    private final static int MAX_ENTRIES = 100;\n+    private final static int MAX_ENTRIES = 180;\n \n     public final static InternCache instance = new InternCache();\n \n+    /**\n+     * As minor optimization let's try to avoid \"flush storms\",\n+     * cases where multiple threads might try to concurrently\n+     * flush the map.\n+     */\n+    private final static Object _flushLock = new Object();\n+    \n     private InternCache() {\n-        super(MAX_ENTRIES, 0.8f, true);\n+        super(MAX_ENTRIES, 0.8f, 4);\n     }\n \n-    @Override\n-    protected boolean removeEldestEntry(Map.Entry<String,String> eldest)\n-    {\n-        return size() > MAX_ENTRIES;\n-    }\n-\n-    public synchronized String intern(String input)\n+    public String intern(String input)\n     {\n         String result = get(input);\n-        if (result == null) {\n-            result = input.intern();\n-            put(result, result);\n+        if (result != null) {\n+            return result;\n         }\n+\n+        /* 18-Sep-2013, tatu: We used to use LinkedHashMap, which has simple LRU\n+         *   method. No such functionality exists with CHM; and let's use simplest\n+         *   possible limitation: just clear all contents. This because otherwise\n+         *   we are simply likely to keep on clearing same, commonly used entries.\n+         */\n+        if (size() >= MAX_ENTRIES) {\n+            /* Not incorrect wrt well-known double-locking anti-pattern because underlying\n+             * storage gives close enough answer to real one here; and we are\n+             * more concerned with flooding than starvation.\n+             */\n+            synchronized (_flushLock) {\n+                if (size() >= MAX_ENTRIES) {\n+                    clear();\n+                }\n+            }\n+        }\n+        result = input.intern();\n+        put(result, result);\n         return result;\n     }\n-\n-\n }\n ", "timestamp": 1379546482, "metainfo": ""}