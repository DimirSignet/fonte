{"sha": "87cba322475fdbd57024938e98940aaa4c8c70d4", "log": "and bit more clean up", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/core/sym/Name1.java\n+++ b/src/main/java/com/fasterxml/jackson/core/sym/Name1.java\n  * and to a lesser degree performance. Both are achieved for short\n  * Strings by avoiding another level of indirection (via quad arrays)\n  */\n-public final class Name1\n-    extends Name\n+public final class Name1 extends Name\n {\n-    final static Name1 sEmptyName = new Name1(\"\", 0, 0);\n+    private final static Name1 EMPTY = new Name1(\"\", 0, 0);\n+    private final int q;\n \n-    final int mQuad;\n-\n-    Name1(String name, int hash, int quad)\n-    {\n+    Name1(String name, int hash, int quad) {\n         super(name, hash);\n-        mQuad = quad;\n+        q = quad;\n     }\n \n-    static Name1 getEmptyName() { return sEmptyName; }\n+    static Name1 getEmptyName() { return EMPTY; }\n \n-    @Override\n-    public boolean equals(int quad)\n-    {\n-        return (quad == mQuad);\n-    }\n-\n-    @Override\n-    public boolean equals(int quad1, int quad2)\n-    {\n-        return (quad1 == mQuad) && (quad2 == 0);\n-    }\n-\n-    @Override\n-    public boolean equals(int[] quads, int qlen)\n-    {\n-        return (qlen == 1 && quads[0] == mQuad);\n-    }\n+    @Override public boolean equals(int quad) { return (quad == q); }\n+    @Override public boolean equals(int quad1, int quad2) { return (quad1 == q) && (quad2 == 0); }\n+    @Override public boolean equals(int[] quads, int qlen) { return (qlen == 1 && quads[0] == q); }\n }\n--- a/src/main/java/com/fasterxml/jackson/core/sym/Name2.java\n+++ b/src/main/java/com/fasterxml/jackson/core/sym/Name2.java\n  * and to a lesser degree performance. Both are achieved for short\n  * Strings by avoiding another level of indirection (via quad arrays)\n  */\n-public final class Name2\n-    extends Name\n+public final class Name2 extends Name\n {\n-    final int mQuad1;\n+    private final int q1,  q2;\n \n-    final int mQuad2;\n-\n-    Name2(String name, int hash, int quad1, int quad2)\n-    {\n+    Name2(String name, int hash, int quad1, int quad2) {\n         super(name, hash);\n-        mQuad1 = quad1;\n-        mQuad2 = quad2;\n+        q1 = quad1;\n+        q2 = quad2;\n     }\n \n     @Override\n     public boolean equals(int quad) { return false; }\n \n     @Override\n-    public boolean equals(int quad1, int quad2)\n-    {\n-        return (quad1 == mQuad1) && (quad2 == mQuad2);\n-    }\n+    public boolean equals(int quad1, int quad2) { return (quad1 == q1) && (quad2 == q2); }\n \n     @Override\n-    public boolean equals(int[] quads, int qlen)\n-    {\n-        return (qlen == 2 && quads[0] == mQuad1 && quads[1] == mQuad2);\n-    }\n+    public boolean equals(int[] quads, int qlen) { return (qlen == 2 && quads[0] == q1 && quads[1] == q2); }\n }\n--- a/src/main/java/com/fasterxml/jackson/core/sym/Name3.java\n+++ b/src/main/java/com/fasterxml/jackson/core/sym/Name3.java\n  * that consists of 9 to 12 bytes. It's the longest special purpose\n  * implementaion; longer ones are expressed using {@link NameN}.\n  */\n-public final class Name3\n-    extends Name\n+public final class Name3 extends Name\n {\n-    final int mQuad1;\n-    final int mQuad2;\n-    final int mQuad3;\n+    private final int q1,  q2, q3;\n \n-    Name3(String name, int hash, int q1, int q2, int q3)\n-    {\n+    Name3(String name, int hash, int i1, int i2, int i3) {\n         super(name, hash);\n-        mQuad1 = q1;\n-        mQuad2 = q2;\n-        mQuad3 = q3;\n+        q1 = i1;\n+        q2 = i2;\n+        q3 = i3;\n     }\n \n     // Implies quad length == 1, never matches\n     public boolean equals(int quad1, int quad2) { return false; }\n \n     @Override\n-    public boolean equals(int[] quads, int qlen)\n-    {\n-        return (qlen == 3)\n-            && (quads[0] == mQuad1)\n-            && (quads[1] == mQuad2)\n-            && (quads[2] == mQuad3);\n+    public boolean equals(int[] quads, int qlen) {\n+        return (qlen == 3) && (quads[0] == q1) && (quads[1] == q2) && (quads[2] == q3);\n     }\n }\n--- a/src/main/java/com/fasterxml/jackson/core/sym/NameN.java\n+++ b/src/main/java/com/fasterxml/jackson/core/sym/NameN.java\n  * Generic implementation of PName used for \"long\" names, where long\n  * means that its byte (UTF-8) representation is 13 bytes or more.\n  */\n-public final class NameN\n-    extends Name\n+public final class NameN extends Name\n {\n-    final int[] mQuads;\n-    final int mQuadLen;\n+    private final int[] q;\n+    private final int qlen;\n \n-    NameN(String name, int hash, int[] quads, int quadLen)\n-    {\n+    NameN(String name, int hash, int[] quads, int quadLen) {\n         super(name, hash);\n         /* We have specialized implementations for shorter\n          * names, so let's not allow runt instances here\n         if (quadLen < 3) {\n             throw new IllegalArgumentException(\"Qlen must >= 3\");\n         }\n-        mQuads = quads;\n-        mQuadLen = quadLen;\n+        q = quads;\n+        qlen = quadLen;\n     }\n \n     // Implies quad length == 1, never matches\n     @Override\n-\tpublic boolean equals(int quad) { return false; }\n+    public boolean equals(int quad) { return false; }\n \n     // Implies quad length == 2, never matches\n     @Override\n-\tpublic boolean equals(int quad1, int quad2) { return false; }\n+    public boolean equals(int quad1, int quad2) { return false; }\n \n     @Override\n-\tpublic boolean equals(int[] quads, int qlen)\n-    {\n-        if (qlen != mQuadLen) {\n-            return false;\n-        }\n+    public boolean equals(int[] quads, int len) {\n+        if (len != qlen) { return false; }\n \n         /* 26-Nov-2008, tatus: Strange, but it does look like\n          *   unrolling here is counter-productive, reducing\n \n         // or simpler way without unrolling:\n         for (int i = 0; i < qlen; ++i) {\n-            if (quads[i] != mQuads[i]) {\n+            if (quads[i] != q[i]) {\n                 return false;\n             }\n         }\n--- a/src/main/java/com/fasterxml/jackson/core/type/TypeReference.java\n+++ b/src/main/java/com/fasterxml/jackson/core/type/TypeReference.java\n  * which can be passed to methods that accept TypeReference, or resolved\n  * using <code>TypeFactory</code> to obtain {@link ResolvedType}.\n  */\n-public abstract class TypeReference<T>\n-    implements Comparable<TypeReference<T>>\n+public abstract class TypeReference<T> implements Comparable<TypeReference<T>>\n {\n     protected final Type _type;\n     \n      * reference without type information.\n      */\n     @Override\n-    public int compareTo(TypeReference<T> o) {\n-        // just need an implementation, not a good one... hence:\n-        return 0;\n-    }\n+    public int compareTo(TypeReference<T> o) { return 0; }\n+    // just need an implementation, not a good one... hence ^^^\n }\n \n--- a/src/main/java/com/fasterxml/jackson/core/util/JsonGeneratorDelegate.java\n+++ b/src/main/java/com/fasterxml/jackson/core/util/JsonGeneratorDelegate.java\n     }\n \n     @Override\n-    public PrettyPrinter getPrettyPrinter() {\n-        return delegate.getPrettyPrinter();\n-    }\n-    \n-    @Override\n-    public JsonGenerator useDefaultPrettyPrinter() {\n-        delegate.useDefaultPrettyPrinter();\n-        return this;\n-    }\n-\n-    @Override\n-    public JsonGenerator setHighestNonEscapedChar(int charCode) {\n-        delegate.setHighestNonEscapedChar(charCode);\n-        return this;\n-    }\n+    public PrettyPrinter getPrettyPrinter() { return delegate.getPrettyPrinter(); }\n+    \n+    @Override\n+    public JsonGenerator useDefaultPrettyPrinter() { delegate.useDefaultPrettyPrinter();\n+        return this; }\n+\n+    @Override\n+    public JsonGenerator setHighestNonEscapedChar(int charCode) { delegate.setHighestNonEscapedChar(charCode);\n+        return this; }\n \n     @Override\n     public int getHighestEscapedChar() { return delegate.getHighestEscapedChar(); }\n     public CharacterEscapes getCharacterEscapes() {  return delegate.getCharacterEscapes(); }\n \n     @Override\n-    public JsonGenerator setCharacterEscapes(CharacterEscapes esc) {\n-        delegate.setCharacterEscapes(esc);\n-        return this;\n-    }\n-\n-    @Override\n-    public JsonGenerator setRootValueSeparator(SerializableString sep) {\n-        delegate.setRootValueSeparator(sep);\n-        return this;\n-    }\n+    public JsonGenerator setCharacterEscapes(CharacterEscapes esc) { delegate.setCharacterEscapes(esc);\n+        return this; }\n+\n+    @Override\n+    public JsonGenerator setRootValueSeparator(SerializableString sep) { delegate.setRootValueSeparator(sep);\n+        return this; }\n \n     /*\n     /**********************************************************\n     public void writeString(SerializableString text) throws IOException, JsonGenerationException { delegate.writeString(text); }\n \n     @Override\n-    public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException {\n-        delegate.writeRawUTF8String(text, offset, length);\n-    }\n-\n-    @Override\n-    public void writeUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException {\n-        delegate.writeUTF8String(text, offset, length);\n-    }\n+    public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException { delegate.writeRawUTF8String(text, offset, length); }\n+\n+    @Override\n+    public void writeUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException { delegate.writeUTF8String(text, offset, length); }\n \n     /*\n     /**********************************************************\n     public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException { delegate.writeRaw(text, offset, len); }\n \n     @Override\n-    public void writeRaw(SerializableString raw) throws IOException, JsonGenerationException {\n-        delegate.writeRaw(raw);\n-    }\n-    \n-    @Override\n-    public void writeRaw(char[] text, int offset, int len) throws IOException, JsonGenerationException {\n-        delegate.writeRaw(text, offset, len);\n-    }\n-\n-    @Override\n-    public void writeRaw(char c) throws IOException, JsonGenerationException {\n-        delegate.writeRaw(c);\n-    }\n-\n-    @Override\n-    public void writeRawValue(String text) throws IOException, JsonGenerationException {\n-        delegate.writeRawValue(text);\n-    }\n-\n-    @Override\n-    public void writeRawValue(String text, int offset, int len) throws IOException, JsonGenerationException {\n-         delegate.writeRawValue(text, offset, len);\n-    }\n-\n-    @Override\n-    public void writeRawValue(char[] text, int offset, int len) throws IOException, JsonGenerationException {\n-         delegate.writeRawValue(text, offset, len);\n-    }\n-\n-    @Override\n-    public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException\n-    {\n-        delegate.writeBinary(b64variant, data, offset, len);\n-    }\n-\n-    @Override\n-    public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException {\n-        return delegate.writeBinary(b64variant, data, dataLength);\n-    }\n+    public void writeRaw(SerializableString raw) throws IOException, JsonGenerationException { delegate.writeRaw(raw); }\n+    \n+    @Override\n+    public void writeRaw(char[] text, int offset, int len) throws IOException, JsonGenerationException { delegate.writeRaw(text, offset, len); }\n+\n+    @Override\n+    public void writeRaw(char c) throws IOException, JsonGenerationException { delegate.writeRaw(c); }\n+\n+    @Override\n+    public void writeRawValue(String text) throws IOException, JsonGenerationException { delegate.writeRawValue(text); }\n+\n+    @Override\n+    public void writeRawValue(String text, int offset, int len) throws IOException, JsonGenerationException { delegate.writeRawValue(text, offset, len); }\n+\n+    @Override\n+    public void writeRawValue(char[] text, int offset, int len) throws IOException, JsonGenerationException { delegate.writeRawValue(text, offset, len); }\n+\n+    @Override\n+    public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException { delegate.writeBinary(b64variant, data, offset, len); }\n+\n+    @Override\n+    public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException { return delegate.writeBinary(b64variant, data, dataLength); }\n     \n     /*\n     /**********************************************************\n      */\n \n     @Override\n-    public void writeNumber(short v) throws IOException, JsonGenerationException {\n-        delegate.writeNumber(v);\n-    }\n-\n-    @Override\n-    public void writeNumber(int v) throws IOException, JsonGenerationException {\n-        delegate.writeNumber(v);\n-    }\n-\n-    @Override\n-    public void writeNumber(long v) throws IOException, JsonGenerationException {\n-        delegate.writeNumber(v);\n-    }\n-\n-    @Override\n-    public void writeNumber(BigInteger v) throws IOException, JsonGenerationException {\n-        delegate.writeNumber(v);\n-    }\n-\n-    @Override\n-    public void writeNumber(double v) throws IOException, JsonGenerationException {\n-        delegate.writeNumber(v);\n-    }\n-\n-    @Override\n-    public void writeNumber(float v) throws IOException, JsonGenerationException {\n-        delegate.writeNumber(v);\n-    }\n-\n-    @Override\n-    public void writeNumber(BigDecimal v) throws IOException, JsonGenerationException {\n-        delegate.writeNumber(v);\n-    }\n-\n-    @Override\n-    public void writeNumber(String encodedValue) throws IOException, JsonGenerationException, UnsupportedOperationException {\n-        delegate.writeNumber(encodedValue);\n-    }\n-\n-    @Override\n-    public void writeBoolean(boolean state) throws IOException, JsonGenerationException {\n-        delegate.writeBoolean(state);\n-    }\n-    \n-    @Override\n-    public void writeNull() throws IOException, JsonGenerationException {\n-        delegate.writeNull();\n-    }\n+    public void writeNumber(short v) throws IOException, JsonGenerationException { delegate.writeNumber(v); }\n+\n+    @Override\n+    public void writeNumber(int v) throws IOException, JsonGenerationException { delegate.writeNumber(v); }\n+\n+    @Override\n+    public void writeNumber(long v) throws IOException, JsonGenerationException { delegate.writeNumber(v); }\n+\n+    @Override\n+    public void writeNumber(BigInteger v) throws IOException, JsonGenerationException { delegate.writeNumber(v); }\n+\n+    @Override\n+    public void writeNumber(double v) throws IOException, JsonGenerationException { delegate.writeNumber(v); }\n+\n+    @Override\n+    public void writeNumber(float v) throws IOException, JsonGenerationException { delegate.writeNumber(v); }\n+\n+    @Override\n+    public void writeNumber(BigDecimal v) throws IOException, JsonGenerationException { delegate.writeNumber(v); }\n+\n+    @Override\n+    public void writeNumber(String encodedValue) throws IOException, JsonGenerationException, UnsupportedOperationException { delegate.writeNumber(encodedValue); }\n+\n+    @Override\n+    public void writeBoolean(boolean state) throws IOException, JsonGenerationException { delegate.writeBoolean(state); }\n+    \n+    @Override\n+    public void writeNull() throws IOException, JsonGenerationException { delegate.writeNull(); }\n \n     /*\n     /**********************************************************\n      */\n \n     @Override\n-    public void writeOmittedField(String fieldName)\n-        throws IOException, JsonGenerationException\n-    {\n-        delegate.writeOmittedField(fieldName);\n-    }\n+    public void writeOmittedField(String fieldName) throws IOException, JsonGenerationException { delegate.writeOmittedField(fieldName); }\n     \n     /*\n     /**********************************************************\n      */\n     \n     @Override\n-    public void writeObjectId(Object id)\n-        throws IOException, JsonGenerationException {\n-        delegate.writeObjectId(id);\n-    }\n-\n-    @Override\n-    public void writeObjectRef(Object id)\n-            throws IOException, JsonGenerationException {\n-        delegate.writeObjectRef(id);\n-    }\n-    \n-    @Override\n-    public void writeTypeId(Object id)\n-        throws IOException, JsonGenerationException {\n-        delegate.writeTypeId(id);\n-    }\n+    public void writeObjectId(Object id) throws IOException, JsonGenerationException { delegate.writeObjectId(id); }\n+\n+    @Override\n+    public void writeObjectRef(Object id) throws IOException, JsonGenerationException { delegate.writeObjectRef(id); }\n+    \n+    @Override\n+    public void writeTypeId(Object id) throws IOException, JsonGenerationException { delegate.writeTypeId(id); }\n     \n     /*\n     /**********************************************************\n \n     @Override\n     public void copyCurrentEvent(JsonParser jp) throws IOException, JsonProcessingException {\n-        if (delegateCopyMethods) {\n-            delegate.copyCurrentEvent(jp);\n-        } else {\n-            super.copyCurrentEvent(jp);\n-        }\n-    }\n-\n-    @Override\n-    public void copyCurrentStructure(JsonParser jp) throws IOException, JsonProcessingException\n-    {\n-        if (delegateCopyMethods) {\n-            delegate.copyCurrentStructure(jp);\n-        } else {\n-            super.copyCurrentStructure(jp);\n-        }\n+        if (delegateCopyMethods) delegate.copyCurrentEvent(jp);\n+        else super.copyCurrentEvent(jp);\n+    }\n+\n+    @Override\n+    public void copyCurrentStructure(JsonParser jp) throws IOException, JsonProcessingException {\n+        if (delegateCopyMethods) delegate.copyCurrentStructure(jp);\n+        else super.copyCurrentStructure(jp);\n     }\n \n     /*", "timestamp": 1386998855, "metainfo": ""}