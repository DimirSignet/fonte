{"sha": "d8616575146a9d2fa15c71b2cbb5d27dbca5aa3b", "log": "Working on [JACKSON-770], [JACKSON-707]", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/core/JsonNode.java\n+++ b/src/main/java/com/fasterxml/jackson/core/JsonNode.java\n     protected final static List<JsonNode> NO_NODES = Collections.emptyList();\n     protected final static List<String> NO_STRINGS = Collections.emptyList();\n \n+    /*\n+    /**********************************************************\n+    /* Construction, related\n+    /**********************************************************\n+     */\n+    \n     protected JsonNode() { }\n \n+    /**\n+     * Method that can be called to get a node that is guaranteed\n+     * not to allow changing of this node through mutators on\n+     * this node or any of its children.\n+     * This means it can either make a copy of this node (and all\n+     * mutable children and grand children nodes), or node itself\n+     * if it is immutable.\n+     *<p>\n+     * Note: return type is guaranteed to have same type as the\n+     * node method is called on; which is why method is declared\n+     * with local generic type.\n+     * \n+     * @since 2.0\n+     * \n+     * @return Node that is either a copy of this node (and all non-leaf\n+     *    children); or, for immutable leaf nodes, node itself.\n+     */\n+    public abstract <T extends JsonNode> T deepCopy();\n+    \n     /*\n     /**********************************************************\n     /* Public API, type introspection\n \n     /**\n      * If this node is a numeric type (as per {@link #isNumber}),\n-     * returns native type that node uses to store the numeric\n-     * value.\n-     */\n-    public abstract JsonParser.NumberType getNumberType();\n+     * returns native type that node uses to store the numeric value;\n+     * otherwise returns null.\n+     * \n+     * @return Type of number contained, if any; or null if node does not\n+     *  contain numeric value.\n+     */\n+    public abstract JsonParser.NumberType numberType();\n \n     /**\n      * Method that can be used to check whether this node is a numeric\n      * @return Textual value this node contains, iff it is a textual\n      *   JSON node (comes from JSON String value entry)\n      */\n-    public String getTextValue() { return null; }\n+    public String textValue() { return null; }\n \n     /**\n      * Method to use for accessing binary content of binary nodes (nodes\n      * @return Binary data this node contains, iff it is a binary\n      *   node; null otherwise\n      */\n-    public byte[] getBinaryValue() throws IOException\n+    public byte[] binaryValue() throws IOException\n     {\n         return null;\n     }\n      * @return Textual value this node contains, iff it is a textual\n      *   json node (comes from JSON String value entry)\n      */\n-    public boolean getBooleanValue() { return false; }\n+    public boolean booleanValue() { return false; }\n \n     /**\n      * Returns numeric value for this node, <b>if and only if</b>\n      * @return Number value this node contains, if any (null for non-number\n      *   nodes).\n      */\n-    public Number getNumberValue() { return null; }\n+    public Number numberValue() { return null; }\n \n     /**\n      * Returns integer value for this node, <b>if and only if</b>\n      * @return Integer value this node contains, if any; 0 for non-number\n      *   nodes.\n      */\n-    public int getIntValue() { return 0; }\n-\n-    public long getLongValue() { return 0L; }\n-    public double getDoubleValue() { return 0.0; }\n-    public BigDecimal getDecimalValue() { return BigDecimal.ZERO; }\n-    public BigInteger getBigIntegerValue() { return BigInteger.ZERO; }\n+    public int intValue() { return 0; }\n+\n+    public long longValue() { return 0L; }\n+    public double doubleValue() { return 0.0; }\n+    public BigDecimal decimalValue() { return BigDecimal.ZERO; }\n+    public BigInteger bigIntegerValue() { return BigInteger.ZERO; }\n \n     /**\n      * Method for accessing value of the specified element of\n      * of JSON Array constructs.\n      */\n     @Override\n-    public final Iterator<JsonNode> iterator() { return getElements(); }\n+    public final Iterator<JsonNode> iterator() { return elements(); }\n \n     /**\n      * Method for accessing all value nodes of this Node, iff\n      * field names (keys) are not included, only values.\n      * For other types of nodes, returns empty iterator.\n      */\n-    public Iterator<JsonNode> getElements() { return NO_NODES.iterator(); }\n+    public Iterator<JsonNode> elements() { return NO_NODES.iterator(); }\n \n     /**\n      * Method for accessing names of all fields for this Node, iff\n      * this node is a JSON Object node.\n      */\n-    public Iterator<String> getFieldNames() { return NO_STRINGS.iterator(); }\n+    public Iterator<String> fieldNames() { return NO_STRINGS.iterator(); }\n \n     /**\n      * @return Iterator that can be used to traverse all key/value pairs for\n      *   object nodes; empty iterator (no contents) for other types\n      */\n-    public Iterator<Map.Entry<String, JsonNode>> getFields() {\n+    public Iterator<Map.Entry<String, JsonNode>> fields() {\n         Collection<Map.Entry<String, JsonNode>> coll = Collections.emptyList();\n         return coll.iterator();\n     }\n--- a/src/main/java/com/fasterxml/jackson/core/ObjectCodec.java\n+++ b/src/main/java/com/fasterxml/jackson/core/ObjectCodec.java\n      */\n     public abstract <T> T treeToValue(JsonNode n, Class<T> valueType)\n         throws JsonProcessingException;\n+\n+    /*\n+    /**********************************************************\n+    /* Basic accessors\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Accessor for finding {@link JsonFactory} codec will use.\n+     * \n+     * @since 2.0\n+     */\n+    public abstract JsonFactory getJsonFactory();\n }", "timestamp": 1327820870, "metainfo": ""}