{"sha": "0e10fd5df63e3ad3b4d3b030ad4388b5a8a42d99", "log": "Refactor a bit to help reduce redunancy from #110", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/core/JsonGenerator.java\n+++ b/src/main/java/com/fasterxml/jackson/core/JsonGenerator.java\n import java.io.*;\n import java.math.BigDecimal;\n import java.math.BigInteger;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n \n import com.fasterxml.jackson.core.io.CharacterEscapes;\n+import com.fasterxml.jackson.core.util.VersionUtil;\n \n /**\n  * Base class that defines public API for writing JSON content.\n      */\n     @Override\n     public abstract void close() throws IOException;\n+\n+    /*\n+    /**********************************************************\n+    /* Helper methods for sub-classes\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Helper method used for constructing and throwing\n+     * {@link JsonGenerationException} with given base message.\n+     *<p>\n+     * Note that sub-classes may override this method to add more detail\n+     * or use a {@link JsonGenerationException} sub-class.\n+     */\n+    protected void _reportError(String msg)\n+        throws JsonGenerationException\n+    {\n+        throw new JsonGenerationException(msg);\n+    }\n+\n+    protected final void _throwInternal() {\n+        VersionUtil.throwInternal();\n+    }\n+\n+    protected void _reportUnsupportedOperation() {\n+        throw new UnsupportedOperationException(\"Operation not supported by generator of type \"+getClass().getName());\n+    }\n+    \n+    /**\n+     * Helper method to try to call appropriate write method for given\n+     * untyped Object. At this point, no structural conversions should be done,\n+     * only simple basic types are to be coerced as necessary.\n+     *\n+     * @param value Non-null value to write\n+     */\n+    protected void _writeSimpleObject(Object value) \n+        throws IOException, JsonGenerationException\n+    {\n+        /* 31-Dec-2009, tatu: Actually, we could just handle some basic\n+         *    types even without codec. This can improve interoperability,\n+         *    and specifically help with TokenBuffer.\n+         */\n+        if (value == null) {\n+            writeNull();\n+            return;\n+        }\n+        if (value instanceof String) {\n+            writeString((String) value);\n+            return;\n+        }\n+        if (value instanceof Number) {\n+            Number n = (Number) value;\n+            if (n instanceof Integer) {\n+                writeNumber(n.intValue());\n+                return;\n+            } else if (n instanceof Long) {\n+                writeNumber(n.longValue());\n+                return;\n+            } else if (n instanceof Double) {\n+                writeNumber(n.doubleValue());\n+                return;\n+            } else if (n instanceof Float) {\n+                writeNumber(n.floatValue());\n+                return;\n+            } else if (n instanceof Short) {\n+                writeNumber(n.shortValue());\n+                return;\n+            } else if (n instanceof Byte) {\n+                writeNumber(n.byteValue());\n+                return;\n+            } else if (n instanceof BigInteger) {\n+                writeNumber((BigInteger) n);\n+                return;\n+            } else if (n instanceof BigDecimal) {\n+                writeNumber((BigDecimal) n);\n+                return;\n+                \n+            // then Atomic types\n+                \n+            } else if (n instanceof AtomicInteger) {\n+                writeNumber(((AtomicInteger) n).get());\n+                return;\n+            } else if (n instanceof AtomicLong) {\n+                writeNumber(((AtomicLong) n).get());\n+                return;\n+            }\n+        } else if (value instanceof byte[]) {\n+            writeBinary((byte[]) value);\n+            return;\n+        } else if (value instanceof Boolean) {\n+            writeBoolean((Boolean) value);\n+            return;\n+        } else if (value instanceof AtomicBoolean) {\n+            writeBoolean(((AtomicBoolean) value).get());\n+            return;\n+        }\n+        throw new IllegalStateException(\"No ObjectCodec defined for the generator, can only serialize simple wrapper types (type passed \"\n+                +value.getClass().getName()+\")\");\n+    }    \n+\n }\n--- a/src/main/java/com/fasterxml/jackson/core/base/GeneratorBase.java\n+++ b/src/main/java/com/fasterxml/jackson/core/base/GeneratorBase.java\n package com.fasterxml.jackson.core.base;\n \n import java.io.*;\n-import java.math.BigDecimal;\n-import java.math.BigInteger;\n-import java.util.concurrent.atomic.AtomicBoolean;\n-import java.util.concurrent.atomic.AtomicInteger;\n-import java.util.concurrent.atomic.AtomicLong;\n \n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.core.JsonParser.NumberType;\n     protected abstract void _verifyValueWrite(String typeMsg)\n         throws IOException, JsonGenerationException;\n \n-    /**\n-     * Helper method used for constructing and throwing\n-     * {@link JsonGenerationException} with given base message.\n-     *<p>\n-     * Note that sub-classes may override this method to add more detail\n-     * or use a {@link JsonGenerationException} sub-class.\n-     */\n-    protected void _reportError(String msg)\n-        throws JsonGenerationException\n-    {\n-        throw new JsonGenerationException(msg);\n-    }\n-\n-    /**\n-     * Helper method to try to call appropriate write method for given\n-     * untyped Object. At this point, no structural conversions should be done,\n-     * only simple basic types are to be coerced as necessary.\n-     *\n-     * @param value Non-null value to write\n-     */\n+    // @Deprecated in 2.3 -- now defined in super-class; remove in 2.4\n+    @Override \n     protected void _writeSimpleObject(Object value) \n         throws IOException, JsonGenerationException\n     {\n-        /* 31-Dec-2009, tatu: Actually, we could just handle some basic\n-         *    types even without codec. This can improve interoperability,\n-         *    and specifically help with TokenBuffer.\n-         */\n-        if (value == null) {\n-            writeNull();\n-            return;\n-        }\n-        if (value instanceof String) {\n-            writeString((String) value);\n-            return;\n-        }\n-        if (value instanceof Number) {\n-            Number n = (Number) value;\n-            if (n instanceof Integer) {\n-                writeNumber(n.intValue());\n-                return;\n-            } else if (n instanceof Long) {\n-                writeNumber(n.longValue());\n-                return;\n-            } else if (n instanceof Double) {\n-                writeNumber(n.doubleValue());\n-                return;\n-            } else if (n instanceof Float) {\n-                writeNumber(n.floatValue());\n-                return;\n-            } else if (n instanceof Short) {\n-                writeNumber(n.shortValue());\n-                return;\n-            } else if (n instanceof Byte) {\n-                writeNumber(n.byteValue());\n-                return;\n-            } else if (n instanceof BigInteger) {\n-                writeNumber((BigInteger) n);\n-                return;\n-            } else if (n instanceof BigDecimal) {\n-                writeNumber((BigDecimal) n);\n-                return;\n-                \n-            // then Atomic types\n-                \n-            } else if (n instanceof AtomicInteger) {\n-                writeNumber(((AtomicInteger) n).get());\n-                return;\n-            } else if (n instanceof AtomicLong) {\n-                writeNumber(((AtomicLong) n).get());\n-                return;\n-            }\n-        } else if (value instanceof byte[]) {\n-            writeBinary((byte[]) value);\n-            return;\n-        } else if (value instanceof Boolean) {\n-            writeBoolean((Boolean) value);\n-            return;\n-        } else if (value instanceof AtomicBoolean) {\n-            writeBoolean(((AtomicBoolean) value).get());\n-            return;\n-        }\n-        throw new IllegalStateException(\"No ObjectCodec defined for the generator, can only serialize simple wrapper types (type passed \"\n-                +value.getClass().getName()+\")\");\n-    }    \n-\n-    protected final void _throwInternal() {\n-        VersionUtil.throwInternal();\n-    }\n-\n-    protected void _reportUnsupportedOperation() {\n-        throw new UnsupportedOperationException(\"Operation not supported by generator of type \"+getClass().getName());\n+        // TODO: \n+        super._writeSimpleObject(value);\n     }\n }\n--- a/src/main/java/com/fasterxml/jackson/core/util/JsonGeneratorDelegate.java\n+++ b/src/main/java/com/fasterxml/jackson/core/util/JsonGeneratorDelegate.java\n import java.io.InputStream;\n import java.math.BigDecimal;\n import java.math.BigInteger;\n-import java.util.concurrent.atomic.AtomicBoolean;\n-import java.util.concurrent.atomic.AtomicInteger;\n-import java.util.concurrent.atomic.AtomicLong;\n \n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.core.JsonParser.NumberType;\n     protected JsonGenerator delegate;\n \n     /**\n-     * Delegate copy methods.  Defaults to true.\n+     * Whether copy methods\n+     * ({@link #copyCurrentEvent}, {@link #copyCurrentStructure}, {@link #writeTree} and {@link #writeObject})\n+     * are to be called (true), or handled by this object (false).\n      */\n     protected boolean delegateCopyMethods;\n \n     public JsonGeneratorDelegate(JsonGenerator d) {\n         this(d, true);\n     }\n-    \n+\n+    /**\n+     * @param delegateCopyMethods Flag assigned to <code>delagateCopyMethod</code>\n+     *   and which defines whether copy methods are handled locally (false), or\n+     *   delegated to configured \n+     */\n     public JsonGeneratorDelegate(JsonGenerator d, boolean delegateCopyMethods) {\n         delegate = d;\n         this.delegateCopyMethods = delegateCopyMethods;\n     }\n \n+    /*\n+    /**********************************************************\n+    /* Extended API\n+    /**********************************************************\n+     */\n+\n+    public JsonGenerator getDelegate() {\n+        return delegate;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Public API, metadata\n+    /**********************************************************\n+     */\n+    \n     @Override\n     public ObjectCodec getCodec() {\n         return delegate.getCodec();\n     public void writeObject(Object pojo) throws IOException,JsonProcessingException {\n         if (delegateCopyMethods) {\n             delegate.writeObject(pojo);\n+            return;\n+        }\n+        // NOTE: copied from \n+        if (pojo == null) {\n+            writeNull();\n         } else {\n-            if (pojo == null) {\n-                // important: call method that does check value write:\n-                writeNull();\n-            } else {\n-                /* 02-Mar-2009, tatu: we are NOT to call _verifyValueWrite here,\n-                 *   because that will be done when codec actually serializes\n-                 *   contained POJO. If we did call it it would advance state\n-                 *   causing exception later on\n-                 */\n-                if (getCodec() != null) {\n-                    getCodec().writeValue(this, pojo);\n-                    return;\n-                }\n-                _writeSimpleObject(pojo);\n+            if (getCodec() != null) {\n+                getCodec().writeValue(this, pojo);\n+                return;\n             }\n+            _writeSimpleObject(pojo);\n         }\n     }\n     \n     public void writeTree(TreeNode rootNode) throws IOException, JsonProcessingException {\n         if (delegateCopyMethods) {\n             delegate.writeTree(rootNode);\n+            return;\n+        }\n+        // As with 'writeObject()', we are not check if write would work\n+        if (rootNode == null) {\n+            writeNull();\n         } else {\n-            // As with 'writeObject()', we are not check if write would work\n-            if (rootNode == null) {\n-                writeNull();\n-            } else {\n-                if (getCodec() == null) {\n-                    throw new IllegalStateException(\"No ObjectCodec defined\");\n-                }\n-                getCodec().writeValue(this, rootNode);\n+            if (getCodec() == null) {\n+                throw new IllegalStateException(\"No ObjectCodec defined\");\n             }\n+            getCodec().writeValue(this, rootNode);\n         }\n     }\n \n     public void copyCurrentEvent(JsonParser jp) throws IOException, JsonProcessingException {\n         if (delegateCopyMethods) {\n             delegate.copyCurrentEvent(jp);\n-        } else {\n-            JsonToken t = jp.getCurrentToken();\n-            // sanity check; what to do?\n-            if (t == null) {\n-                _reportError(\"No current event to copy\");\n+            return;\n+        }\n+        JsonToken t = jp.getCurrentToken();\n+        // sanity check; what to do?\n+        if (t == null) {\n+            _reportError(\"No current event to copy\");\n+        }\n+        switch (t.id()) {\n+        case ID_NOT_AVAILABLE:\n+            _reportError(\"No current event to copy\");\n+        case ID_START_OBJECT:\n+            writeStartObject();\n+            break;\n+        case ID_END_OBJECT:\n+            writeEndObject();\n+            break;\n+        case ID_START_ARRAY:\n+            writeStartArray();\n+            break;\n+        case ID_END_ARRAY:\n+            writeEndArray();\n+            break;\n+        case ID_FIELD_NAME:\n+            writeFieldName(jp.getCurrentName());\n+            break;\n+        case ID_STRING:\n+            if (jp.hasTextCharacters()) {\n+                writeString(jp.getTextCharacters(), jp.getTextOffset(), jp.getTextLength());\n+            } else {\n+                writeString(jp.getText());\n             }\n-            switch (t.id()) {\n-            case ID_NOT_AVAILABLE:\n-                _reportError(\"No current event to copy\");\n-            case ID_START_OBJECT:\n-                writeStartObject();\n-                break;\n-            case ID_END_OBJECT:\n-                writeEndObject();\n-                break;\n-            case ID_START_ARRAY:\n-                writeStartArray();\n-                break;\n-            case ID_END_ARRAY:\n-                writeEndArray();\n-                break;\n-            case ID_FIELD_NAME:\n-                writeFieldName(jp.getCurrentName());\n-                break;\n-            case ID_STRING:\n-                if (jp.hasTextCharacters()) {\n-                    writeString(jp.getTextCharacters(), jp.getTextOffset(), jp.getTextLength());\n-                } else {\n-                    writeString(jp.getText());\n-                }\n-                break;\n-            case ID_NUMBER_INT:\n-            {\n-                NumberType n = jp.getNumberType();\n-                if (n == NumberType.INT) {\n-                    writeNumber(jp.getIntValue());\n-                } else if (n == NumberType.BIG_INTEGER) {\n-                    writeNumber(jp.getBigIntegerValue());\n-                } else {\n-                    writeNumber(jp.getLongValue());\n-                }\n-                break;\n+            break;\n+        case ID_NUMBER_INT:\n+        {\n+            NumberType n = jp.getNumberType();\n+            if (n == NumberType.INT) {\n+                writeNumber(jp.getIntValue());\n+            } else if (n == NumberType.BIG_INTEGER) {\n+                writeNumber(jp.getBigIntegerValue());\n+            } else {\n+                writeNumber(jp.getLongValue());\n             }\n-            case ID_NUMBER_FLOAT:\n-            {\n-                NumberType n = jp.getNumberType();\n-                if (n == NumberType.BIG_DECIMAL) {\n-                    writeNumber(jp.getDecimalValue());\n-                } else if (n == NumberType.FLOAT) {\n-                    writeNumber(jp.getFloatValue());\n-                } else {\n-                    writeNumber(jp.getDoubleValue());\n-                }\n-                break;\n+            break;\n+        }\n+        case ID_NUMBER_FLOAT:\n+        {\n+            NumberType n = jp.getNumberType();\n+            if (n == NumberType.BIG_DECIMAL) {\n+                writeNumber(jp.getDecimalValue());\n+            } else if (n == NumberType.FLOAT) {\n+                writeNumber(jp.getFloatValue());\n+            } else {\n+                writeNumber(jp.getDoubleValue());\n             }\n-            case ID_TRUE:\n-                writeBoolean(true);\n-                break;\n-            case ID_FALSE:\n-                writeBoolean(false);\n-                break;\n-            case ID_NULL:\n-                writeNull();\n-                break;\n-            case ID_EMBEDDED_OBJECT:\n-                writeObject(jp.getEmbeddedObject());\n-                break;\n-            default:\n-                _throwInternal();\n-            }\n-        }\n-    }\n-\n-    @Override\n-    public void copyCurrentStructure(JsonParser jp) throws IOException, JsonProcessingException {\n+            break;\n+        }\n+        case ID_TRUE:\n+            writeBoolean(true);\n+            break;\n+        case ID_FALSE:\n+            writeBoolean(false);\n+            break;\n+        case ID_NULL:\n+            writeNull();\n+            break;\n+        case ID_EMBEDDED_OBJECT:\n+            writeObject(jp.getEmbeddedObject());\n+            break;\n+        default:\n+            _throwInternal();\n+        }\n+    }\n+\n+    @Override\n+    public void copyCurrentStructure(JsonParser jp) throws IOException, JsonProcessingException\n+    {\n         if (delegateCopyMethods) {\n             delegate.copyCurrentStructure(jp);\n-        } else {\n-            JsonToken t = jp.getCurrentToken();\n-            if (t == null) {\n-                _reportError(\"No current event to copy\");\n+            return;\n+        }\n+        JsonToken t = jp.getCurrentToken();\n+        if (t == null) {\n+            _reportError(\"No current event to copy\");\n+        }\n+        // Let's handle field-name separately first\n+        int id = t.id();\n+        if (id == ID_FIELD_NAME) {\n+            writeFieldName(jp.getCurrentName());\n+            t = jp.nextToken();\n+            id = t.id();\n+            // fall-through to copy the associated value\n+        }\n+        switch (id) {\n+        case ID_START_OBJECT:\n+            writeStartObject();\n+            while (jp.nextToken() != JsonToken.END_OBJECT) {\n+                copyCurrentStructure(jp);\n             }\n-            // Let's handle field-name separately first\n-            int id = t.id();\n-            if (id == ID_FIELD_NAME) {\n-                writeFieldName(jp.getCurrentName());\n-                t = jp.nextToken();\n-                id = t.id();\n-                // fall-through to copy the associated value\n+            writeEndObject();\n+            break;\n+        case ID_START_ARRAY:\n+            writeStartArray();\n+            while (jp.nextToken() != JsonToken.END_ARRAY) {\n+                copyCurrentStructure(jp);\n             }\n-            switch (id) {\n-            case ID_START_OBJECT:\n-                writeStartObject();\n-                while (jp.nextToken() != JsonToken.END_OBJECT) {\n-                    copyCurrentStructure(jp);\n-                }\n-                writeEndObject();\n-                break;\n-            case ID_START_ARRAY:\n-                writeStartArray();\n-                while (jp.nextToken() != JsonToken.END_ARRAY) {\n-                    copyCurrentStructure(jp);\n-                }\n-                writeEndArray();\n-                break;\n-            default:\n-                copyCurrentEvent(jp);\n-            }\n+            writeEndArray();\n+            break;\n+        default:\n+            copyCurrentEvent(jp);\n         }\n     }\n \n     public boolean isClosed() {\n         return delegate.isClosed();\n     }\n-\n-    /**\n-     * Helper method used for constructing and throwing\n-     * {@link JsonGenerationException} with given base message.\n-     *<p>\n-     * Note that sub-classes may override this method to add more detail\n-     * or use a {@link JsonGenerationException} sub-class.\n-     */\n-    protected void _reportError(String msg)\n-        throws JsonGenerationException\n-    {\n-        throw new JsonGenerationException(msg);\n-    }\n-\n-    /**\n-     * Helper method to try to call appropriate write method for given\n-     * untyped Object. At this point, no structural conversions should be done,\n-     * only simple basic types are to be coerced as necessary.\n-     *\n-     * @param value Non-null value to write\n-     */\n-    protected void _writeSimpleObject(Object value) \n-        throws IOException, JsonGenerationException\n-    {\n-        /* 31-Dec-2009, tatu: Actually, we could just handle some basic\n-         *    types even without codec. This can improve interoperability,\n-         *    and specifically help with TokenBuffer.\n-         */\n-        if (value == null) {\n-            writeNull();\n-            return;\n-        }\n-        if (value instanceof String) {\n-            writeString((String) value);\n-            return;\n-        }\n-        if (value instanceof Number) {\n-            Number n = (Number) value;\n-            if (n instanceof Integer) {\n-                writeNumber(n.intValue());\n-                return;\n-            } else if (n instanceof Long) {\n-                writeNumber(n.longValue());\n-                return;\n-            } else if (n instanceof Double) {\n-                writeNumber(n.doubleValue());\n-                return;\n-            } else if (n instanceof Float) {\n-                writeNumber(n.floatValue());\n-                return;\n-            } else if (n instanceof Short) {\n-                writeNumber(n.shortValue());\n-                return;\n-            } else if (n instanceof Byte) {\n-                writeNumber(n.byteValue());\n-                return;\n-            } else if (n instanceof BigInteger) {\n-                writeNumber((BigInteger) n);\n-                return;\n-            } else if (n instanceof BigDecimal) {\n-                writeNumber((BigDecimal) n);\n-                return;\n-                \n-            // then Atomic types\n-                \n-            } else if (n instanceof AtomicInteger) {\n-                writeNumber(((AtomicInteger) n).get());\n-                return;\n-            } else if (n instanceof AtomicLong) {\n-                writeNumber(((AtomicLong) n).get());\n-                return;\n-            }\n-        } else if (value instanceof byte[]) {\n-            writeBinary((byte[]) value);\n-            return;\n-        } else if (value instanceof Boolean) {\n-            writeBoolean((Boolean) value);\n-            return;\n-        } else if (value instanceof AtomicBoolean) {\n-            writeBoolean(((AtomicBoolean) value).get());\n-            return;\n-        }\n-        throw new IllegalStateException(\"No ObjectCodec defined for the generator, can only serialize simple wrapper types (type passed \"\n-                +value.getClass().getName()+\")\");\n-    }    \n-\n-    protected final void _throwInternal() {\n-        VersionUtil.throwInternal();\n-    }\n }", "timestamp": 1383451969, "metainfo": ""}