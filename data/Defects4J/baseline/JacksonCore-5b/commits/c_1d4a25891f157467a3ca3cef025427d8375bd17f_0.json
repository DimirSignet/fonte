{"sha": "1d4a25891f157467a3ca3cef025427d8375bd17f", "log": "trying to improve on symbol parsing", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java\n         }\n         _quadBuffer[0] = _quad1;\n         _quadBuffer[1] = q2;\n-        return parseLongName(i);\n-    }\n-\n-    protected Name parseLongName(int q) throws IOException\n+        return parseLongName(i, codes);\n+    }\n+\n+    protected Name parseLongName(int q, final int[] codes) throws IOException\n     {\n         // As explained above, will ignore UTF-8 encoding at this point\n-        final int[] codes = _icLatin1;\n+        final byte[] buf = _inputBuffer;\n         int qlen = 2;\n \n-        while (true) {\n-            /* Let's offline if we hit buffer boundary (otherwise would\n-             * need to [try to] align input, which is bit complicated\n-             * and may not always be possible)\n-             */\n-            if ((_inputEnd - _inputPtr) < 4) {\n-                return parseEscapedName(_quadBuffer, qlen, 0, q, 0);\n-            }\n-            // Otherwise can skip boundary checks for 4 bytes in loop\n-\n-            int i = _inputBuffer[_inputPtr++] & 0xFF;\n+        while ((_inputPtr + 4) <= _inputEnd) {\n+            int i = buf[_inputPtr++] & 0xFF;\n             if (codes[i] != 0) {\n                 if (i == INT_QUOTE) {\n                     return findName(_quadBuffer, qlen, q, 1);\n             }\n \n             q = (q << 8) | i;\n-            i = _inputBuffer[_inputPtr++] & 0xFF;\n+            i = buf[_inputPtr++] & 0xFF;\n             if (codes[i] != 0) {\n                 if (i == INT_QUOTE) {\n                     return findName(_quadBuffer, qlen, q, 2);\n             }\n \n             q = (q << 8) | i;\n-            i = _inputBuffer[_inputPtr++] & 0xFF;\n+            i = buf[_inputPtr++] & 0xFF;\n             if (codes[i] != 0) {\n                 if (i == INT_QUOTE) {\n                     return findName(_quadBuffer, qlen, q, 3);\n             }\n \n             q = (q << 8) | i;\n-            i = _inputBuffer[_inputPtr++] & 0xFF;\n+            i = buf[_inputPtr++] & 0xFF;\n             if (codes[i] != 0) {\n                 if (i == INT_QUOTE) {\n                     return findName(_quadBuffer, qlen, q, 4);\n             _quadBuffer[qlen++] = q;\n             q = i;\n         }\n+\n+        /* Let's offline if we hit buffer boundary (otherwise would\n+         * need to [try to] align input, which is bit complicated\n+         * and may not always be possible)\n+         */\n+        return parseEscapedName(_quadBuffer, qlen, 0, q, 0);\n     }\n \n     /**\n--- a/src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java\n+++ b/src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java\n             default:\n             }\n         }\n-        // Otherwise, need to copy the incoming buffer\n-        int[] buf = new int[qlen];\n-        System.arraycopy(quads, 0, buf, 0, qlen);\n-        return new NameN(name, hash, buf, qlen);\n+        return NameN.construct(name, hash, quads, qlen);\n     }\n \n     /*\n--- a/src/main/java/com/fasterxml/jackson/core/sym/NameN.java\n+++ b/src/main/java/com/fasterxml/jackson/core/sym/NameN.java\n package com.fasterxml.jackson.core.sym;\n+\n+import java.util.Arrays;\n \n /**\n  * Generic implementation of PName used for \"long\" names, where long\n  */\n public final class NameN extends Name\n {\n+    private final int q1, q2, q3, q4; // first four quads\n+    private final int qlen; // total number of quads (4 + q.length)\n     private final int[] q;\n-    private final int qlen;\n \n-    NameN(String name, int hash, int[] quads, int quadLen) {\n+    NameN(String name, int hash, int q1, int q2, int q3, int q4,\n+            int[] quads, int quadLen) {\n         super(name, hash);\n-        /* We have specialized implementations for shorter\n-         * names, so let's not allow runt instances here\n-         */\n-        if (quadLen < 3) {\n-            throw new IllegalArgumentException(\"Qlen must >= 3\");\n-        }\n+        this.q1 = q1;\n+        this.q2 = q2;\n+        this.q3 = q3;\n+        this.q4 = q4;\n         q = quads;\n         qlen = quadLen;\n     }\n \n+    public static NameN construct(String name, int hash, int[] q, int qlen)\n+    {\n+        /* We have specialized implementations for shorter\n+         * names, so let's not allow runt instances here\n+         */\n+        if (qlen < 4) {\n+            throw new IllegalArgumentException();\n+        }\n+        int q1 = q[0];\n+        int q2 = q[1];\n+        int q3 = q[2];\n+        int q4 = q[3];\n+\n+        int rem = qlen - 4;\n+\n+        int[] buf;\n+        \n+        if (rem > 0) {\n+            buf = Arrays.copyOfRange(q, 4, qlen);\n+        } else {\n+            buf = null;\n+        }\n+        return new NameN(name, hash, q1, q2, q3, q4, buf, qlen);\n+        \n+    }\n+    \n     // Implies quad length == 1, never matches\n     @Override\n     public boolean equals(int quad) { return false; }\n     public boolean equals(int[] quads, int len) {\n         if (len != qlen) { return false; }\n \n-        /* 26-Nov-2008, tatus: Strange, but it does look like\n-         *   unrolling here is counter-productive, reducing\n-         *   speed. Perhaps it prevents inlining by HotSpot or\n-         *   something...\n-         */\n-        // Will always have >= 3 quads, can unroll\n-        /*\n-        if (quads[0] == mQuads[0]\n-            && quads[1] == mQuads[1]\n-            && quads[2] == mQuads[2]) {\n-            for (int i = 3; i < qlen; ++i) {\n-                if (quads[i] != mQuads[i]) {\n-                    return false;\n-                }\n-            }\n-            return true;\n+        // Will always have >= 4 quads, can unroll\n+        if (quads[0] != q1) return false;\n+        if (quads[1] != q2) return false;\n+        if (quads[2] != q3) return false;\n+        if (quads[3] != q4) return false;\n+\n+        switch (len) {\n+        default:\n+            return _equals2(quads);\n+        case 8:\n+            if (quads[7] != q[3]) return false;\n+        case 7:\n+            if (quads[6] != q[2]) return false;\n+        case 6:\n+            if (quads[5] != q[1]) return false;\n+        case 5:\n+            if (quads[4] != q[0]) return false;\n+        case 4:\n         }\n-        */\n+        return true;\n+    }\n \n-        // or simpler way without unrolling:\n-        for (int i = 0; i < qlen; ++i) {\n-            if (quads[i] != q[i]) {\n+    private final boolean _equals2(int[] quads)\n+    {\n+        final int end = qlen-4;\n+        for (int i = 0; i < end; ++i) {\n+            if (quads[i+4] != q[i]) {\n                 return false;\n             }\n         }", "timestamp": 1398314027, "metainfo": ""}