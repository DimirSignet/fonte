{"sha": "64aa9d2a66f2ac36a172a0d580ece3de339dea9e", "log": "Implemented #138", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/core/JsonFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/core/JsonFactory.java\n         java.io.Serializable // since 2.1 (for Android, mostly)\n {\n     /**\n-     * Computed for Jackson 2.3.0 release\n-     */\n-    private static final long serialVersionUID = 3194418244231611666L;\n+     * Computed for Jackson 2.4.0 release\n+     */\n+    private static final long serialVersionUID = 3306684576057132431L;\n \n     /*\n     /**********************************************************\n      * @since 2.1\n      */\n     public JsonParser createParser(String content) throws IOException, JsonParseException {\n-        Reader r = new StringReader(content);\n-        // true -> we own the Reader (and must close); not a big deal\n-        IOContext ctxt = _createContext(r, true);\n-        // [JACKSON-512]: allow wrapping with InputDecorator\n-        if (_inputDecorator != null) {\n-            r = _inputDecorator.decorate(ctxt, r);\n-        }\n-        return _createParser(r, ctxt);\n+        final int strLen = content.length();\n+        // Actually, let's use this for medium-sized content, up to 64kB chunk (32kb char)\n+        if (_inputDecorator != null || strLen > 0x8000) {\n+            // easier to just wrap in a Reader than extend InputDecorator; or, if content\n+            // is too long for us to copy it over\n+            return createParser(new StringReader(content));\n+        }\n+        IOContext ctxt = _createContext(content, true);\n+        char[] buf = ctxt.allocTokenBuffer();\n+        if (buf.length < strLen) { // sanity check; should never occur\n+            buf = new char[strLen];\n+        }\n+        content.getChars(0, strLen, buf, 0);\n+        return _createParser(buf, 0, strLen, ctxt, true);\n+    }\n+\n+    /**\n+     * Method for constructing parser for parsing\n+     * contents of given char array.\n+     * \n+     * @since 2.4\n+     */\n+    public JsonParser createParser(char[] content) throws IOException {\n+        return createParser(content, 0, content.length);\n+    }\n+    \n+    /**\n+     * Method for constructing parser for parsing\n+     * contents of given char array.\n+     * \n+     * @since 2.4\n+     */\n+    public JsonParser createParser(char[] content, int offset, int len) throws IOException {\n+        if (_inputDecorator != null) { // easier to just wrap in a Reader than extend InputDecorator\n+            return createParser(new CharArrayReader(content, offset, len));\n+        }\n+        return _createParser(content, offset, len, _createContext(content, true), false);\n     }\n \n     /*\n \n     /**\n      * Overridable factory method that actually instantiates parser\n+     * using given <code>char[]</code> object for accessing content.\n+     * \n+     * @since 2.4\n+     */\n+    protected JsonParser _createParser(char[] data, int offset, int len, IOContext ctxt,\n+            boolean recyclable) throws IOException {\n+        return new ReaderBasedJsonParser(ctxt, _parserFeatures, null, _objectCodec,\n+                _rootCharSymbols.makeChild(isEnabled(JsonFactory.Feature.CANONICALIZE_FIELD_NAMES),\n+                        isEnabled(JsonFactory.Feature.INTERN_FIELD_NAMES)),\n+                        data, offset, offset+len,\n+                        // false -> caller-provided, not handled by BufferRecycler\n+                        recyclable);\n+    }\n+\n+    /**\n+     * Overridable factory method that actually instantiates parser\n      * using given {@link Reader} object for reading content\n      * passed as raw byte array.\n      *<p>\n      * interface from sub-class perspective, although not a public\n      * method available to users of factory implementations.\n      */\n-    protected JsonParser _createParser(byte[] data, int offset, int len, IOContext ctxt) throws IOException, JsonParseException\n+    protected JsonParser _createParser(byte[] data, int offset, int len, IOContext ctxt) throws IOException\n     {\n         return new ByteSourceJsonBootstrapper(ctxt, data, offset, len).constructParser(_parserFeatures,\n                 _objectCodec, _rootByteSymbols, _rootCharSymbols,\n--- a/src/main/java/com/fasterxml/jackson/core/json/ByteSourceJsonBootstrapper.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/ByteSourceJsonBootstrapper.java\n              */\n             if (canonicalize) {\n                 BytesToNameCanonicalizer can = rootByteSymbols.makeChild(canonicalize, intern);\n-                return new UTF8StreamJsonParser(_context, parserFeatures, _in, codec, can, _inputBuffer, _inputPtr, _inputEnd, _bufferRecyclable);\n+                return new UTF8StreamJsonParser(_context, parserFeatures, _in, codec, can,\n+                        _inputBuffer, _inputPtr, _inputEnd, _bufferRecyclable);\n             }\n         }\n         return new ReaderBasedJsonParser(_context, parserFeatures, constructReader(), codec,\n--- a/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java\n      */\n     protected char[] _inputBuffer;\n \n+    /**\n+     * Flag that indicates whether the input buffer is recycable (and\n+     * needs to be returned to recycler once we are done) or not.\n+     *<p>\n+     * If it is not, it also means that parser can NOT modify underlying\n+     * buffer.\n+     */\n+    protected boolean _bufferRecyclable;\n+    \n     /*\n     /**********************************************************\n     /* Configuration\n      * some access (or skipped to obtain the next token)\n      */\n     protected boolean _tokenIncomplete = false;\n-    \n+\n     /*\n     /**********************************************************\n     /* Life-cycle\n     /**********************************************************\n      */\n \n+    /**\n+     * Method called when caller wants to provide input buffer directly,\n+     * and it may or may not be recyclable use standard recycle context.\n+     * \n+     * @since 2.4\n+     */\n     public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r,\n-            ObjectCodec codec, CharsToNameCanonicalizer st)\n+            ObjectCodec codec, CharsToNameCanonicalizer st,\n+            char[] inputBuffer, int start, int end,\n+            boolean bufferRecyclable)\n+    {\n+        super(ctxt, features);\n+        _reader = r;\n+        _inputBuffer = inputBuffer;\n+        _inputPtr = start;\n+        _inputEnd = end;\n+        _objectCodec = codec;\n+        _symbols = st;\n+        _hashSeed = st.hashSeed();\n+        _bufferRecyclable = bufferRecyclable;\n+    }\n+\n+    /**\n+     * Method called when input comes as a {@link java.io.Reader}, and buffer allocation\n+     * can be done using default mechanism.\n+     */\n+    public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r,\n+        ObjectCodec codec, CharsToNameCanonicalizer st)\n     {\n         super(ctxt, features);\n         _reader = r;\n         _inputBuffer = ctxt.allocTokenBuffer();\n+        _inputPtr = 0;\n+        _inputEnd = 0;\n         _objectCodec = codec;\n         _symbols = st;\n         _hashSeed = st.hashSeed();\n-    }\n-    \n+        _bufferRecyclable = false;\n+    }\n+\n     /*\n     /**********************************************************\n     /* Base method defs, overrides\n         super._releaseBuffers();\n         // merge new symbols, if any\n         _symbols.release();\n-        char[] buf = _inputBuffer;\n-        if (buf != null) {\n-            _inputBuffer = null;\n-            _ioContext.releaseTokenBuffer(buf);\n+        // and release buffers, if they are recyclable ones\n+        if (_bufferRecyclable) {\n+            char[] buf = _inputBuffer;\n+            if (buf != null) {\n+                _inputBuffer = null;\n+                _ioContext.releaseTokenBuffer(buf);\n+            }\n         }\n     }\n     \n--- a/src/test/java/com/fasterxml/jackson/core/TestVersions.java\n+++ b/src/test/java/com/fasterxml/jackson/core/TestVersions.java\n     public void testCoreVersions() throws Exception\n     {\n         assertVersion(new JsonFactory().version());\n-        JsonParser jp = new ReaderBasedJsonParser(getIOContext(), 0, null, null,\n+        ReaderBasedJsonParser jp = new ReaderBasedJsonParser(getIOContext(), 0, null, null,\n                 CharsToNameCanonicalizer.createRoot());\n         assertVersion(jp.version());\n         jp.close();\n--- a/src/test/java/com/fasterxml/jackson/core/json/TestJsonParser.java\n+++ b/src/test/java/com/fasterxml/jackson/core/json/TestJsonParser.java\n      * correctly; mostly to stress-test underlying segment-based\n      * text buffer(s).\n      */\n+    public void testLongText() throws Exception\n+    {\n+        JsonFactory jf = new JsonFactory();\n+        // lengths chosen to tease out problems with buffer allocation...\n+        _testLongText(jf, 7700);\n+        _testLongText(jf, 49000);\n+        _testLongText(jf, 96000);\n+    }\n+\n     @SuppressWarnings(\"resource\")\n-    public void testLongText() throws Exception\n-    {\n-        final int LEN = 96000;\n+    private void _testLongText(JsonFactory jf, int LEN) throws Exception\n+    {\n         StringBuilder sb = new StringBuilder(LEN + 100);\n         Random r = new Random(99);\n         while (sb.length() < LEN) {\n             }\n         }\n         final String VALUE = sb.toString();\n-\n-        JsonFactory jf = new JsonFactory();\n         \n-        // Let's use real generator to get json done right\n+        // Let's use real generator to get JSON done right\n         StringWriter sw = new StringWriter(LEN + (LEN >> 2));\n         JsonGenerator jg = jf.createGenerator(sw);\n         jg.writeStartObject();\n--- a/src/test/java/perf/ManualReadPerfWithMedia.java\n+++ b/src/test/java/perf/ManualReadPerfWithMedia.java\n         final String jsonStr = input.asJsonString(f);\n         final byte[] json = jsonStr.getBytes(\"UTF-8\");\n \n-        new ManualReadPerfWithMedia(f, jsonStr).test(\"Reader\", \"char[]\", json.length);\n+        new ManualReadPerfWithMedia(f, jsonStr).test(\"String\", \"char[]\", json.length);\n     }\n \n     protected void testRead1(int reps) throws Exception\n     {\n-        final String input = _json;\n         while (--reps >= 0) {\n-            JsonParser p = _factory.createParser(input);\n+            JsonParser p = _factory.createParser(_json);\n             _stream(p);\n             p.close();\n         }\n \n     protected void testRead2(int reps) throws Exception\n     {\n-        final String input = _json;\n+        final char[] ch = _json.toCharArray();\n         while (--reps >= 0) {\n-            /*\n-            final char[] ch = input.toCharArray();\n             JsonParser p = _factory.createParser(ch, 0, ch.length);\n-            */\n-            JsonParser p = _factory.createParser(input);\n             _stream(p);\n             p.close();\n         }", "timestamp": 1397855258, "metainfo": ""}