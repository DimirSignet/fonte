{"sha": "93402046dc3928c8060a00a8d817c2c7353e904d", "log": "Fixed Long-case of [JACKSON-832]", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/core/base/ParserBase.java\n+++ b/src/main/java/com/fasterxml/jackson/core/base/ParserBase.java\n \n     // Also, we need some numeric constants\n \n-    final static BigDecimal BD_MIN_LONG = new BigDecimal(Long.MIN_VALUE);\n-    final static BigDecimal BD_MAX_LONG = new BigDecimal(Long.MAX_VALUE);\n-\n-    final static BigDecimal BD_MIN_INT = new BigDecimal(Long.MIN_VALUE);\n-    final static BigDecimal BD_MAX_INT = new BigDecimal(Long.MAX_VALUE);\n+    final static BigInteger BI_MIN_INT = BigInteger.valueOf(Integer.MIN_VALUE);\n+    final static BigInteger BI_MAX_INT = BigInteger.valueOf(Integer.MAX_VALUE);\n+\n+    final static BigInteger BI_MIN_LONG = BigInteger.valueOf(Long.MIN_VALUE);\n+    final static BigInteger BI_MAX_LONG = BigInteger.valueOf(Long.MAX_VALUE);\n+    \n+    final static BigDecimal BD_MIN_LONG = new BigDecimal(BI_MIN_LONG);\n+    final static BigDecimal BD_MAX_LONG = new BigDecimal(BI_MAX_LONG);\n+\n+    final static BigDecimal BD_MIN_INT = new BigDecimal(BI_MIN_INT);\n+    final static BigDecimal BD_MAX_INT = new BigDecimal(BI_MAX_INT);\n \n     final static long MIN_INT_L = (long) Integer.MIN_VALUE;\n     final static long MAX_INT_L = (long) Integer.MAX_VALUE;\n             }\n             _numberInt = result;\n         } else if ((_numTypesValid & NR_BIGINT) != 0) {\n-            // !!! Should check for range...\n+            if (BI_MIN_INT.compareTo(_numberBigInt) > 0 \n+                    || BI_MAX_INT.compareTo(_numberBigInt) < 0) {\n+                reportOverflowInt();\n+            }\n             _numberInt = _numberBigInt.intValue();\n         } else if ((_numTypesValid & NR_DOUBLE) != 0) {\n             // Need to check boundaries\n         if ((_numTypesValid & NR_INT) != 0) {\n             _numberLong = (long) _numberInt;\n         } else if ((_numTypesValid & NR_BIGINT) != 0) {\n-            // !!! Should check for range...\n+            if (BI_MIN_LONG.compareTo(_numberBigInt) > 0 \n+                    || BI_MAX_LONG.compareTo(_numberBigInt) < 0) {\n+                reportOverflowLong();\n+            }\n             _numberLong = _numberBigInt.longValue();\n         } else if ((_numTypesValid & NR_DOUBLE) != 0) {\n             // Need to check boundaries\n--- a/src/main/java/com/fasterxml/jackson/core/io/JsonStringEncoder.java\n+++ b/src/main/java/com/fasterxml/jackson/core/io/JsonStringEncoder.java\n         while (inputPtr < inputEnd) {\n             final int[] escCodes = CharTypes.get7BitOutputEscapes();\n \n-            inner_loop: // ascii and escapes\n+            inner_loop: // ASCII and escapes\n             while (true) {\n                 int ch = text.charAt(inputPtr);\n                 if (ch > 0x7F || escCodes[ch] != 0) {\n         // should we ever get this?\n         throw new IllegalArgumentException(\"Illegal character point (0x\"+Integer.toHexString(code)+\") to output\");\n     }\n-\n }\n--- a/src/test/java/com/fasterxml/jackson/core/main/TestNumericValues.java\n+++ b/src/test/java/com/fasterxml/jackson/core/main/TestNumericValues.java\n         }\n     }\n \n-    public void testNumbers()\n-        throws Exception\n+    public void testNumbers() throws Exception\n     {\n         final String DOC = \"[ -13, 8100200300, 13.5, 0.00010, -2.033 ]\";\n \n                 /*int x =*/ jp.getIntValue();\n                 fail(\"Expected an exception for overflow\");\n             } catch (Exception e) {\n-                verifyException(e, \"out of range\");\n+                verifyException(e, \"out of range of int\");\n             }\n             assertEquals(8100200300., jp.getDoubleValue());\n             assertEquals(\"8100200300\", jp.getText());\n         }\n     }\n \n+    public void testLongOverflow() throws Exception\n+    {\n+        BigInteger below = BigInteger.valueOf(Long.MIN_VALUE);\n+        below = below.subtract(BigInteger.ONE);\n+        BigInteger above = BigInteger.valueOf(Long.MAX_VALUE);\n+        above = above.add(BigInteger.ONE);\n+\n+        String DOC_BELOW = below.toString() + \" \";\n+        String DOC_ABOVE = below.toString() + \" \";\n+        for (int input = 0; input < 2; ++input) {\n+            JsonParser jp;\n+\n+            if (input == 0) {\n+                jp = createParserUsingStream(DOC_BELOW, \"UTF-8\");\n+            } else {\n+                jp = createParserUsingReader(DOC_BELOW);\n+            }\n+            jp.nextToken();\n+            try {\n+                long x = jp.getLongValue();\n+                fail(\"Expected an exception for underflow (input \"+jp.getText()+\"): instead, got long value: \"+x);\n+            } catch (JsonParseException e) {\n+                verifyException(e, \"out of range of long\");\n+            }\n+            jp.close();\n+\n+            if (input == 0) {\n+                jp = createParserUsingStream(DOC_ABOVE, \"UTF-8\");\n+            } else {\n+                jp = createParserUsingReader(DOC_ABOVE);\n+            }\n+            jp.nextToken();\n+            try {\n+                long x = jp.getLongValue();\n+                fail(\"Expected an exception for underflow (input \"+jp.getText()+\"): instead, got long value: \"+x);\n+            } catch (JsonParseException e) {\n+                verifyException(e, \"out of range of long\");\n+            }\n+            jp.close();\n+            \n+        }\n+    }\n+    \n     /**\n      * Method that tries to test that number parsing works in cases where\n      * input is split between buffer boundaries.", "timestamp": 1335836477, "metainfo": ""}