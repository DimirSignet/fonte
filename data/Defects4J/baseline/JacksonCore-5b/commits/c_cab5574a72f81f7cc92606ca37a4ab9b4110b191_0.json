{"sha": "cab5574a72f81f7cc92606ca37a4ab9b4110b191", "log": "Merge pull request #82 from githubaff0/master  Test and bug fix for Issue #81: CharTypers.appendQuoted misencodes first 32 Unicode values as '\\0000'.", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/core/io/CharTypes.java\n+++ b/src/main/java/com/fasterxml/jackson/core/io/CharTypes.java\n \n public final class CharTypes\n {\n+    /**\n+     * Utility class - not for instantiation\n+     */\n+    private CharTypes() {}\n+\n     private final static char[] HEX_CHARS = \"0123456789ABCDEF\".toCharArray();\n     private final static byte[] HEX_BYTES;\n     static {\n     final static int[] sInputCodesUtf8JsNames;\n     static {\n         int[] table = new int[256];\n-        // start with 8-bit JS names \n+        // start with 8-bit JS names\n         System.arraycopy(sInputCodesJsNames, 0, table, 0, sInputCodesJsNames.length);\n         Arrays.fill(table, 128, 128, 0);\n         sInputCodesUtf8JsNames = table;\n     static {\n         // but first: let's start with UTF-8 multi-byte markers:\n         System.arraycopy(sInputCodesUtf8, 128, sInputCodesComment, 128, 128);\n-    \n+\n         // default (0) means \"ok\" (skip); -1 invalid, others marked by char itself\n         Arrays.fill(sInputCodesComment, 0, 32, -1); // invalid white space\n         sInputCodesComment['\\t'] = 0; // tab is still fine\n     }\n \n     /**\n-     * Lookup table used for determining which output characters in \n+     * Lookup table used for determining which output characters in\n      * 7-bit ASCII range need to be quoted.\n      */\n     final static int[] sOutputEscapes128;\n     public static int[] getInputCodeUtf8JsNames() { return sInputCodesUtf8JsNames; }\n \n     public static int[] getInputCodeComment() { return sInputCodesComment; }\n-    \n+\n     /**\n      * Accessor for getting a read-only encoding table for first 128 Unicode\n      * code points (single-byte UTF-8 characters).\n             sb.append('\\\\');\n             int escCode = escCodes[c];\n             if (escCode < 0) { // generic quoting (hex value)\n+                assert escCode == CharacterEscapes.ESCAPE_STANDARD :\n+                        \"Unexpected/unsupported ESCAPE_XXX sentinel value\";\n+                // The only negative value sOutputEscapes128 returns\n+                // is CharacterEscapes.ESCAPE_STANDARD, which mean\n+                // appendQuotes should encode using the Unicode encoding;\n+                // not sure if this is the right way to encode for\n+                // CharacterEscapes.ESCAPE_CUSTOM or other (future)\n+                // CharacterEscapes.ESCAPE_XXX values.\n+\n                 // We know that it has to fit in just 2 hex chars\n                 sb.append('u');\n                 sb.append('0');\n                 sb.append('0');\n-                int value = -(escCode + 1);\n+                int value = c;  // widening\n                 sb.append(HEX_CHARS[value >> 4]);\n                 sb.append(HEX_CHARS[value & 0xF]);\n             } else { // \"named\", i.e. prepend with slash\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/core/io/TestCharTypes.java\n+package com.fasterxml.jackson.core.io;\n+\n+import static junit.framework.Assert.assertEquals;\n+\n+public class TestCharTypes\n+    extends com.fasterxml.jackson.test.BaseTest\n+{\n+    public void testAppendQuoted0_31 ()\n+    {\n+        final String[] inputs =    { \"\\u0000\",  \"\\u001F\",  \"abcd\", \"\\u0001ABCD\\u0002\",   \"WX\\u000F\\u0010YZ\"   };\n+        final String[] expecteds = { \"\\\\u0000\", \"\\\\u001F\", \"abcd\", \"\\\\u0001ABCD\\\\u0002\", \"WX\\\\u000F\\\\u0010YZ\" };\n+        assert inputs.length == expecteds.length;\n+\n+        for (int i = 0; i < inputs.length; i++) {\n+            final String input = inputs[i];\n+            final String expected = expecteds[i];\n+\n+            final StringBuilder sb = new StringBuilder();\n+            CharTypes.appendQuoted(sb, input);\n+            final String actual = sb.toString();\n+\n+            assertEquals(expected, actual);\n+        }\n+    }\n+}\n--- a/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java\n             }\n             _reportError(\"Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n             break;\n+        case 'I':\n+            _matchToken(\"Infinity\", 1);\n+            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n+                return resetAsNaN(\"Infinity\", Double.POSITIVE_INFINITY);\n+            }\n+            _reportError(\"Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n+            break;\n         case '+': // note: '-' is taken as number\n             if (_inputPtr >= _inputEnd) {\n                 if (!loadMore()) {\n--- a/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java\n             }\n             _reportError(\"Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n             break;\n+        case 'I':\n+            _matchToken(\"Infinity\", 1);\n+            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n+                return resetAsNaN(\"Infinity\", Double.POSITIVE_INFINITY);\n+            }\n+            _reportError(\"Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n+            break;\n         case '+': // note: '-' is taken as number\n             if (_inputPtr >= _inputEnd) {\n                 if (!loadMore()) {\n--- a/src/test/java/com/fasterxml/jackson/core/json/TestParserNonStandard.java\n+++ b/src/test/java/com/fasterxml/jackson/core/json/TestParserNonStandard.java\n \n     private void _testAllowInf(boolean useStream) throws Exception\n     {\n-        final String JSON = \"[ -INF, +INF, +Infinity,-Infinity ]\";\n+        final String JSON = \"[ -INF, +INF, +Infinity, Infinity, -Infinity ]\";\n         JsonFactory f = new JsonFactory();\n         assertFalse(f.isEnabled(JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS));\n \n         f.configure(JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS, true);\n         jp = useStream ? createParserUsingStream(f, JSON, \"UTF-8\")\n                 : createParserUsingReader(f, JSON);\n-        \n+\n         assertToken(JsonToken.START_ARRAY, jp.nextToken());\n \n         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken());\n         assertEquals(\"+Infinity\", jp.getText());\n         assertTrue(Double.isInfinite(d));\n         assertTrue(d == Double.POSITIVE_INFINITY);\n-        \n+\n+        assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken());\n+        d = jp.getDoubleValue();\n+        assertEquals(\"Infinity\", jp.getText());\n+        assertTrue(Double.isInfinite(d));\n+        assertTrue(d == Double.POSITIVE_INFINITY);\n+\n         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken());\n         d = jp.getDoubleValue();\n         assertEquals(\"-Infinity\", jp.getText());\n         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken());\n         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken());\n         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken());\n+        assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken());\n         assertToken(JsonToken.END_ARRAY, jp.nextToken());\n         \n         jp.close();", "timestamp": 1372302990, "metainfo": ""}