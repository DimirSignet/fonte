{"sha": "31ae9ce736e64dcc1577f0e5caa719104cb561f6", "log": "Merge branch 'master' of github.com:FasterXML/jackson-core", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/core/FormatSchema.java\n+++ b/src/main/java/com/fasterxml/jackson/core/FormatSchema.java\n  * to cast to schema implementations they use. This marker interface is mostly\n  * used for tagging \"some kind of schema\" -- instead of passing opaque\n  * {@link java.lang.Object} -- for documentation purposes.\n- * \n- * @since 1.8\n  */\n public interface FormatSchema\n {\n--- a/src/main/java/com/fasterxml/jackson/core/JsonFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/core/JsonFactory.java\n import com.fasterxml.jackson.core.format.InputAccessor;\n import com.fasterxml.jackson.core.format.MatchStrength;\n import com.fasterxml.jackson.core.io.*;\n-import com.fasterxml.jackson.core.json.ByteSourceJsonBootstrapper;\n-import com.fasterxml.jackson.core.json.CoreVersion;\n-import com.fasterxml.jackson.core.json.ReaderBasedJsonParser;\n-import com.fasterxml.jackson.core.json.UTF8JsonGenerator;\n-import com.fasterxml.jackson.core.json.WriterBasedJsonGenerator;\n+import com.fasterxml.jackson.core.json.*;\n import com.fasterxml.jackson.core.sym.BytesToNameCanonicalizer;\n import com.fasterxml.jackson.core.sym.CharsToNameCanonicalizer;\n import com.fasterxml.jackson.core.util.BufferRecycler;\n     public final static String FORMAT_NAME_JSON = \"JSON\";\n     \n     /**\n+     * Bitfield (set of flags) of all factory features that are enabled by default.\n+     */\n+    protected final static int DEFAULT_FACTORY_FEATURE_FLAGS = JsonFactory.Feature.collectDefaults();\n+\n+    /**\n      * Bitfield (set of flags) of all parser features that are enabled\n      * by default.\n      */\n-    final static int DEFAULT_PARSER_FEATURE_FLAGS = JsonParser.Feature.collectDefaults();\n-\n+    protected final static int DEFAULT_PARSER_FEATURE_FLAGS = JsonParser.Feature.collectDefaults();\n+    \n     /**\n      * Bitfield (set of flags) of all generator features that are enabled\n      * by default.\n      */\n-    final static int DEFAULT_GENERATOR_FEATURE_FLAGS = JsonGenerator.Feature.collectDefaults();\n-\n+    protected final static int DEFAULT_GENERATOR_FEATURE_FLAGS = JsonGenerator.Feature.collectDefaults();\n+\n+    /**\n+     * Enumeration that defines all on/off features that can only be\n+     * changed for {@link JsonFactory}.\n+     */\n+    public enum Feature {\n+        \n+        // // // Symbol handling (interning etc)\n+        \n+        /**\n+         * Feature that determines whether JSON object field names are\n+         * to be canonicalized using {@link String#intern} or not:\n+         * if enabled, all field names will be intern()ed (and caller\n+         * can count on this being true for all such names); if disabled,\n+         * no intern()ing is done. There may still be basic\n+         * canonicalization (that is, same String will be used to represent\n+         * all identical object property names for a single document).\n+         *<p>\n+         * Note: this setting only has effect if\n+         * {@link #CANONICALIZE_FIELD_NAMES} is true -- otherwise no\n+         * canonicalization of any sort is done.\n+         *<p>\n+         * This setting is enabled by default.\n+         */\n+        INTERN_FIELD_NAMES(true),\n+\n+        /**\n+         * Feature that determines whether JSON object field names are\n+         * to be canonicalized (details of how canonicalization is done\n+         * then further specified by\n+         * {@link #INTERN_FIELD_NAMES}).\n+         *<p>\n+         * This setting is enabled by default.\n+         */\n+        CANONICALIZE_FIELD_NAMES(true)\n+\n+        ;\n+\n+        /**\n+         * Whether feature is enabled or disabled by default.\n+         */\n+        private final boolean _defaultState;\n+        \n+        /**\n+         * Method that calculates bit set (flags) of all features that\n+         * are enabled by default.\n+         */\n+        public static int collectDefaults()\n+        {\n+            int flags = 0;\n+            for (Feature f : values()) {\n+                if (f.enabledByDefault()) {\n+                    flags |= f.getMask();\n+                }\n+            }\n+            return flags;\n+        }\n+        \n+        private Feature(boolean defaultState)\n+        {\n+            _defaultState = defaultState;\n+        }\n+        \n+        public boolean enabledByDefault() { return _defaultState; }\n+\n+        public boolean enabledIn(int flags) { return (flags & getMask()) != 0; }\n+        \n+        public int getMask() { return (1 << ordinal()); }\n+    }    \n     /*\n     /**********************************************************\n     /* Buffer, symbol table management\n      */\n     protected ObjectCodec _objectCodec;\n \n+    /**\n+     * Currently enabled factory features.\n+     */\n+    protected int _factoryFeatures = DEFAULT_FACTORY_FEATURE_FLAGS;\n+    \n     /**\n      * Currently enabled parser features.\n      */\n \n     /*\n     /**********************************************************\n-    /* Configuration, parser settings\n+    /* Configuration, factory features\n     /**********************************************************\n      */\n \n      * Method for enabling or disabling specified parser feature\n      * (check {@link JsonParser.Feature} for list of features)\n      */\n-    public final JsonFactory configure(JsonParser.Feature f, boolean state)\n-    {\n-        if (state) {\n-            enable(f);\n-        } else {\n-            disable(f);\n-        }\n+    public final JsonFactory configure(JsonFactory.Feature f, boolean state) {\n+        return state ? enable(f) : disable(f);\n+    }\n+\n+    /**\n+     * Method for enabling specified parser feature\n+     * (check {@link JsonFactory.Feature} for list of features)\n+     */\n+    public JsonFactory enable(JsonFactory.Feature f) {\n+        _factoryFeatures |= f.getMask();\n         return this;\n+    }\n+\n+    /**\n+     * Method for disabling specified parser features\n+     * (check {@link JsonFactory.Feature} for list of features)\n+     */\n+    public JsonFactory disable(JsonFactory.Feature f) {\n+        _factoryFeatures &= ~f.getMask();\n+        return this;\n+    }\n+\n+    /**\n+     * Checked whether specified parser feature is enabled.\n+     */\n+    public final boolean isEnabled(JsonFactory.Feature f) {\n+        return (_factoryFeatures & f.getMask()) != 0;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Configuration, parser configuration\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Method for enabling or disabling specified parser feature\n+     * (check {@link JsonParser.Feature} for list of features)\n+     */\n+    public final JsonFactory configure(JsonParser.Feature f, boolean state) {\n+        return state ? enable(f) : disable(f);\n     }\n \n     /**\n      * (check {@link JsonGenerator.Feature} for list of features)\n      */\n     public final JsonFactory configure(JsonGenerator.Feature f, boolean state) {\n-        if (state) {\n-            enable(f);\n-        } else {\n-            disable(f);\n-        }\n-        return this;\n+        return state ? enable(f) : disable(f);\n     }\n \n \n     protected JsonParser _createJsonParser(InputStream in, IOContext ctxt)\n         throws IOException, JsonParseException\n     {\n+        // As per [JACKSON-259], may want to fully disable canonicalization:\n         return new ByteSourceJsonBootstrapper(ctxt, in).constructParser(_parserFeatures,\n-                _objectCodec, _rootByteSymbols, _rootCharSymbols);\n+                _objectCodec, _rootByteSymbols, _rootCharSymbols,\n+                isEnabled(JsonFactory.Feature.CANONICALIZE_FIELD_NAMES),\n+                isEnabled(JsonFactory.Feature.INTERN_FIELD_NAMES));\n     }\n \n     /**\n \tthrows IOException, JsonParseException\n     {\n         return new ReaderBasedJsonParser(ctxt, _parserFeatures, r, _objectCodec,\n-                _rootCharSymbols.makeChild(isEnabled(JsonParser.Feature.CANONICALIZE_FIELD_NAMES),\n-                    isEnabled(JsonParser.Feature.INTERN_FIELD_NAMES)));\n+                _rootCharSymbols.makeChild(isEnabled(JsonFactory.Feature.CANONICALIZE_FIELD_NAMES),\n+                    isEnabled(JsonFactory.Feature.INTERN_FIELD_NAMES)));\n     }\n \n     /**\n         throws IOException, JsonParseException\n     {\n         return new ByteSourceJsonBootstrapper(ctxt, data, offset, len).constructParser(_parserFeatures,\n-                _objectCodec, _rootByteSymbols, _rootCharSymbols);\n+                _objectCodec, _rootByteSymbols, _rootCharSymbols,\n+                isEnabled(JsonFactory.Feature.CANONICALIZE_FIELD_NAMES),\n+                isEnabled(JsonFactory.Feature.INTERN_FIELD_NAMES));\n     }\n \n     /*\n--- a/src/main/java/com/fasterxml/jackson/core/JsonGenerator.java\n+++ b/src/main/java/com/fasterxml/jackson/core/JsonGenerator.java\n {\n     /**\n      * Enumeration that defines all togglable features for generators.\n-     * \n-     * Note that some features can only be set for\n-     * {@link JsonFactory} (as defaults for generators), while others\n-     * can also be changed for generator instances:\n-     * ones that can be used with instances return <code>true</code>\n-     * from {@link #canUseForInstance}.\n-     * Trying enable/disable factory-only feature will result in\n-     * an {@link IllegalArgumentException}.\n      */\n     public enum Feature {\n         /**\n          * this happens when end-of-input is encountered, or generator\n          * is closed by a call to {@link JsonGenerator#close}.\n          *<p>\n-         * Feature is enabled by default,\n-         * and it can be changed for generator instances.\n+         * Feature is enabled by default.\n          */\n-        AUTO_CLOSE_TARGET(true, true),\n+        AUTO_CLOSE_TARGET(true),\n \n         /**\n          * Feature that determines what happens when the generator is\n          * Object(s) are automatically closed; if disabled, nothing\n          * specific is done.\n          *<p>\n-         * Feature is enabled by default,\n-         * and it can be changed for generator instances.\n+         * Feature is enabled by default.\n          */\n-        AUTO_CLOSE_JSON_CONTENT(true, true),\n+        AUTO_CLOSE_JSON_CONTENT(true),\n \n         /**\n          * Feature that determines whether JSON Object field names are\n          * cases where they are not usually expected, which most commonly\n          * occurs when used straight from Javascript.\n          *<p>\n-         * Feature is enabled by default (since it is required by JSON specification),\n-         * and it can be changed for generator instances.\n+         * Feature is enabled by default (since it is required by JSON specification).\n          */\n-        QUOTE_FIELD_NAMES(true, true),\n+        QUOTE_FIELD_NAMES(true),\n \n         /**\n          * Feature that determines whether \"exceptional\" (not real number)\n          * associated literal values, resulting in non-conformant\n          * output.\n          *<p>\n-         * Feature is enabled by default,\n-         * and it can be changed for generator instances.\n+         * Feature is enabled by default.\n          */\n-        QUOTE_NON_NUMERIC_NUMBERS(true, true),\n+        QUOTE_NON_NUMERIC_NUMBERS(true),\n \n         /**\n          * Feature that forces all Java numbers to be written as JSON strings.\n          * result being that some 64-bit integer values can not be\n          * accurately represent (as mantissa is only 51 bit wide).\n          *<p>\n-         * Feature is disabled by default,\n-         * and it can be changed for generator instances.\n+         * Feature is disabled by default.\n          */\n-        WRITE_NUMBERS_AS_STRINGS(false, true),\n+        WRITE_NUMBERS_AS_STRINGS(false),\n \n         /**\n          * Feature that specifies that calls to {@link #flush} will cause\n          * called by other code (like <code>ObjectMapper</code> or third\n          * party libraries).\n          *<p>\n-         * Feature is enabled by default,\n-         * and it can be changed for generator instances.\n+         * Feature is enabled by default.\n          */\n-        FLUSH_PASSED_TO_STREAM(true, true),\n+        FLUSH_PASSED_TO_STREAM(true),\n         \n         /**\n          * Feature that specifies that all characters beyond 7-bit ASCII\n          * if format uses escaping mechanisms (which is generally true\n          * for textual formats but not for binary formats).\n          *<p>\n-         * Feature is disabled by default,\n-         * and it can be changed for generator instances.\n+         * Feature is disabled by default.\n          */\n-        ESCAPE_NON_ASCII(false, true),\n+        ESCAPE_NON_ASCII(false),\n         \n             ;\n \n         private final boolean _defaultState;\n-\n-        /**\n-         * Whether feature can be used for instances (true), or\n-         * just for factory (false).\n-         */\n-        private final boolean _canUseForInstance;\n         \n         private final int _mask;\n         \n             return flags;\n         }\n         \n-        private Feature(boolean defaultState, boolean canUseForInstance)\n-        {\n+        private Feature(boolean defaultState) {\n             _mask = (1 << ordinal());\n             _defaultState = defaultState;\n-            _canUseForInstance = canUseForInstance;\n         }\n         \n         public boolean enabledByDefault() { return _defaultState; }\n-        public boolean canUseForInstance() { return _canUseForInstance; }\n-\n         public int getMask() { return _mask; }\n     }\n \n      * @param charCode Either -1 to indicate that no additional escaping\n      *   is to be done; or highest code point not to escape (meaning higher\n      *   ones will be), if positive value.\n-     * \n-     * @since 1.8\n      */\n     public JsonGenerator setHighestNonEscapedChar(int charCode) {\n         return this;\n     /**\n      * Method for accessing custom escapes factory uses for {@link JsonGenerator}s\n      * it creates.\n-     * \n-     * @since 1.8\n      */\n     public CharacterEscapes getCharacterEscapes() {\n         return null;\n     /**\n      * Method for defining custom escapes factory uses for {@link JsonGenerator}s\n      * it creates.\n-     * \n-     * @since 1.8\n      */\n     public JsonGenerator setCharacterEscapes(CharacterEscapes esc) {\n         return this;\n      * generator implementation may instead choose to throw a\n      * {@link UnsupportedOperationException} due to ineffectiveness\n      * of having to decode input.\n-     * \n-     * @since 1.7\n      */\n     public abstract void writeUTF8String(byte[] text, int offset, int length)\n         throws IOException, JsonGenerationException;\n--- a/src/main/java/com/fasterxml/jackson/core/JsonParser.java\n+++ b/src/main/java/com/fasterxml/jackson/core/JsonParser.java\n \n     /**\n      * Enumeration that defines all on/off features for parsers.\n-     * \n-     * Note that some features can only be set for\n-     * {@link JsonFactory} (as defaults for parsers), while others\n-     * can also be changed directly for parser instances:\n-     * ones that can be used with instances return <code>true</code>\n-     * from {@link #canUseForInstance}.\n-     * Trying enable/disable factory-only feature will result in\n-     * an {@link IllegalArgumentException}.\n      */\n     public enum Feature {\n         \n          * this happens when end-of-input is encountered, or parser\n          * is closed by a call to {@link JsonParser#close}.\n          *<p>\n-         * Feature is enabled by default;\n-         * and it can be changed for parser instances.\n+         * Feature is enabled by default.\n          */\n-        AUTO_CLOSE_SOURCE(true, true),\n+        AUTO_CLOSE_SOURCE(true),\n             \n         // // // Support for non-standard data format constructs\n \n          * this is extensively used. As such, feature is\n          * <b>disabled by default</b> for parsers and must be\n          * explicitly enabled.\n-         * Feature can be changed for parser instances.\n          */\n-        ALLOW_COMMENTS(false, true),\n+        ALLOW_COMMENTS(false),\n \n         /**\n          * Feature that determines whether parser will allow use\n          * Since JSON specification requires use of double quotes for\n          * field names,\n          * this is a non-standard feature, and as such disabled by default.\n-         * Feature can be changed for parser instances.\n          */\n-        ALLOW_UNQUOTED_FIELD_NAMES(false, true),\n+        ALLOW_UNQUOTED_FIELD_NAMES(false),\n \n         /**\n          * Feature that determines whether parser will allow use\n          * Since JSON specification requires use of double quotes for\n          * field names,\n          * this is a non-standard feature, and as such disabled by default.\n-         * Feature can be changed for parser instances.\n          */\n-        ALLOW_SINGLE_QUOTES(false, true),\n+        ALLOW_SINGLE_QUOTES(false),\n \n         /**\n          * Feature that determines whether parser will allow\n          *<p>\n          * Since JSON specification requires quoting for all control characters,\n          * this is a non-standard feature, and as such disabled by default.\n-         * Feature can be changed for parser instances.\n          */\n-        ALLOW_UNQUOTED_CONTROL_CHARS(false, true),\n+        ALLOW_UNQUOTED_CONTROL_CHARS(false),\n \n         /**\n          * Feature that can be enabled to accept quoting of all character\n          *<p>\n          * Since JSON specification requires quoting for all control characters,\n          * this is a non-standard feature, and as such disabled by default.\n-         * Feature can be changed for parser instances.\n          */\n-        ALLOW_BACKSLASH_ESCAPING_ANY_CHARACTER(false, true),\n+        ALLOW_BACKSLASH_ESCAPING_ANY_CHARACTER(false),\n \n         /**\n          * Feature that determines whether parser will allow\n          *<p>\n          * Since JSON specification does not allow leading zeroes,\n          * this is a non-standard feature, and as such disabled by default.\n-         * Feature can be changed for parser instances.\n          */\n-        ALLOW_NUMERIC_LEADING_ZEROS(false, true),\n+        ALLOW_NUMERIC_LEADING_ZEROS(false),\n         \n         /**\n          * Feature that allows parser to recognize set of\n          *<p>\n          * Since JSON specification does not allow use of such values,\n          * this is a non-standard feature, and as such disabled by default.\n-         * Feature can be changed for parser instances.\n          */\n-         ALLOW_NON_NUMERIC_NUMBERS(false, true),\n+         ALLOW_NON_NUMERIC_NUMBERS(false),\n         \n-        // // // Controlling canonicalization (interning etc)\n-        \n-        /**\n-         * Feature that determines whether JSON object field names are\n-         * to be canonicalized using {@link String#intern} or not:\n-         * if enabled, all field names will be intern()ed (and caller\n-         * can count on this being true for all such names); if disabled,\n-         * no intern()ing is done. There may still be basic\n-         * canonicalization (that is, same String will be used to represent\n-         * all identical object property names for a single document).\n-         *<p>\n-         * Note: this setting only has effect if\n-         * {@link #CANONICALIZE_FIELD_NAMES} is true -- otherwise no\n-         * canonicalization of any sort is done.\n-         *<p>\n-         * This feature <b>can not</b> be changed for parser instances;\n-         * it <b>must</b> be defined for {@link JsonFactory} before\n-         * constructing parser.\n-         */\n-        INTERN_FIELD_NAMES(true, false),\n-\n-        /**\n-         * Feature that determines whether JSON object field names are\n-         * to be canonicalized (details of how canonicalization is done\n-         * then further specified by\n-         * {@link #INTERN_FIELD_NAMES}).\n-         *<p>\n-         * This feature <b>can not</b> be changed for parser instances;\n-         * it <b>must</b> be defined for {@link JsonFactory} before\n-         * constructing parser.\n-         */\n-        CANONICALIZE_FIELD_NAMES(true, false),\n             ;\n \n         /**\n          * Whether feature is enabled or disabled by default.\n          */\n         private final boolean _defaultState;\n-\n-        /**\n-         * Whether feature can be used for instances (true), or\n-         * just for factory (false).\n-         */\n-        private final boolean _canUseForInstance;\n         \n         /**\n          * Method that calculates bit set (flags) of all features that\n             return flags;\n         }\n         \n-        private Feature(boolean defaultState, boolean canUseForInstance)\n-        {\n+        private Feature(boolean defaultState) {\n             _defaultState = defaultState;\n-            _canUseForInstance = canUseForInstance;\n         }\n         \n         public boolean enabledByDefault() { return _defaultState; }\n-        public boolean canUseForInstance() { return _canUseForInstance; }\n-\n-        public boolean enabledIn(int flags) { return (flags & getMask()) != 0; }\n-        \n+//        public boolean enabledIn(int flags) { return (flags & getMask()) != 0; }\n         public int getMask() { return (1 << ordinal()); }\n     }\n \n      */\n     public JsonParser enable(Feature f)\n     {\n-        _checkFeature(f, true);\n         _features |= f.getMask();\n         return this;\n     }\n      */\n     public JsonParser disable(Feature f)\n     {\n-        _checkFeature(f, false);\n         _features &= ~f.getMask();\n         return this;\n     }\n      */\n     public JsonParser configure(Feature f, boolean state)\n     {\n-        _checkFeature(f, state);\n         if (state) {\n             enable(f);\n         } else {\n      */\n     public boolean isEnabled(Feature f) {\n         return (_features & f.getMask()) != 0;\n-    }\n-\n-    /**\n-     * Helper method called to verify that given feature can be\n-     * modified for parser instances.\n-     * \n-     * @since 2.0\n-     */\n-    protected void _checkFeature(Feature f, boolean state) {\n-        if (!f.canUseForInstance()) {\n-            throw new IllegalArgumentException(\"Can not change Feature \"+f.name()+\" for JsonParser instance\");\n-        }\n     }\n     \n     /*\n--- a/src/main/java/com/fasterxml/jackson/core/JsonToken.java\n+++ b/src/main/java/com/fasterxml/jackson/core/JsonToken.java\n      * future. This is the case with non-blocking parsers --\n      * they can not block to wait for more data to parse and\n      * must return something.\n-     *\n-     * @since 0.9.7\n      */\n     NOT_AVAILABLE(null),\n \n      * Note: this token is never returned by regular JSON readers, but\n      * only by readers that expose other kinds of source (like\n      * {@link JsonNode}-based JSON trees, Maps, Lists and such).\n-     *\n-     * @since 1.1\n      */\n     VALUE_EMBEDDED_OBJECT(null),\n \n--- a/src/main/java/com/fasterxml/jackson/core/Versioned.java\n+++ b/src/main/java/com/fasterxml/jackson/core/Versioned.java\n  * This may be useful for example for ensuring that proper Jackson version is deployed\n  * (beyond mechanisms that deployment system may have), as well as for possible\n  * workarounds.\n- * \n- * @since 1.6\n  */\n public interface Versioned {\n     /**\n--- a/src/main/java/com/fasterxml/jackson/core/base/GeneratorBase.java\n+++ b/src/main/java/com/fasterxml/jackson/core/base/GeneratorBase.java\n \n     @Override\n     public JsonGenerator enable(Feature f) {\n-        _checkFeature(f, true);\n         _features |= f.getMask();\n         if (f == Feature.WRITE_NUMBERS_AS_STRINGS) {\n             _cfgNumbersAsStrings = true;\n \n     @Override\n     public JsonGenerator disable(Feature f) {\n-        _checkFeature(f, false);\n         _features &= ~f.getMask();\n         if (f == Feature.WRITE_NUMBERS_AS_STRINGS) {\n             _cfgNumbersAsStrings = false;\n     @Override\n     public final boolean isEnabled(Feature f) {\n         return (_features & f.getMask()) != 0;\n-    }\n-\n-    /**\n-     * Helper method called to verify that given feature can be\n-     * modified for parser instances.\n-     * \n-     * @since 2.0\n-     */\n-    protected void _checkFeature(Feature f, boolean state) {\n-        if (!f.canUseForInstance()) {\n-            throw new IllegalArgumentException(\"Can not change Feature \"+f.name()+\" for JsonParser instance\");\n-        }\n     }\n     \n     @Override\n--- a/src/main/java/com/fasterxml/jackson/core/base/ParserMinimalBase.java\n+++ b/src/main/java/com/fasterxml/jackson/core/base/ParserMinimalBase.java\n     /**\n      * Helper method that can be used for base64 decoding in cases where\n      * encoded content has already been read as a String.\n-     * \n-     * @since 1.9.3\n      */\n     protected void _decodeBase64(String str, ByteArrayBuilder builder, Base64Variant b64variant)\n         throws IOException, JsonParseException\n--- a/src/main/java/com/fasterxml/jackson/core/format/DataFormatDetector.java\n+++ b/src/main/java/com/fasterxml/jackson/core/format/DataFormatDetector.java\n  * Simple helper class that allows data format (content type) auto-detection,\n  * given an ordered set of {@link JsonFactory} instances to use for actual low-level\n  * detection.\n- *\n- * @since 1.7\n  */\n public class DataFormatDetector\n {\n--- a/src/main/java/com/fasterxml/jackson/core/format/InputAccessor.java\n+++ b/src/main/java/com/fasterxml/jackson/core/format/InputAccessor.java\n /**\n  * Interface used to expose beginning of a data file to data format\n  * detection code.\n- * \n- * @since 1.8\n  */\n public interface InputAccessor\n {\n--- a/src/main/java/com/fasterxml/jackson/core/format/MatchStrength.java\n+++ b/src/main/java/com/fasterxml/jackson/core/format/MatchStrength.java\n  * Values are in increasing match strength; and detectors should return\n  * \"strongest\" value: that is, it should start with strongest match\n  * criteria, and downgrading if criteria is not fulfilled.\n- * \n- * @since 1.8\n  */\n public enum MatchStrength\n {\n--- a/src/main/java/com/fasterxml/jackson/core/format/package-info.java\n+++ b/src/main/java/com/fasterxml/jackson/core/format/package-info.java\n  * Package that contains interfaces needed for dynamic, pluggable\n  * format (auto)detection; as well as basic utility classes for\n  * simple format detection functionality.\n- * \n- * @since 1.8\n  */\n package com.fasterxml.jackson.core.format;\n--- a/src/main/java/com/fasterxml/jackson/core/io/CharTypes.java\n+++ b/src/main/java/com/fasterxml/jackson/core/io/CharTypes.java\n      * need to have alternate checking.\n      * Basically this is list of 8-bit ASCII characters that are legal\n      * as part of Javascript identifier\n-     *\n-     * @since 1.2\n      */\n     final static int[] sInputCodesJsNames;\n     static {\n         }\n     }\n \n-    /**\n-     * @since 1.6\n-     */\n     public static char[] copyHexChars()\n     {\n         return (char[]) HEX_CHARS.clone();\n     }\n \n-    /**\n-     * @since 1.6\n-     */\n     public static byte[] copyHexBytes()\n     {\n         return (byte[]) HEX_BYTES.clone();\n--- a/src/main/java/com/fasterxml/jackson/core/io/CharacterEscapes.java\n+++ b/src/main/java/com/fasterxml/jackson/core/io/CharacterEscapes.java\n  * Abstract base class that defines interface for customizing character\n  * escaping aspects for String values, for formats that use escaping.\n  * For JSON this applies to both property names and String values.\n- *\n- * @since 1.8\n  */\n public abstract class CharacterEscapes\n {\n--- a/src/main/java/com/fasterxml/jackson/core/io/InputDecorator.java\n+++ b/src/main/java/com/fasterxml/jackson/core/io/InputDecorator.java\n  * Typical use is to use a filter abstraction (filtered stream,\n  * reader) around original input source, and apply additional\n  * processing during read operations.\n- * \n- * @since 1.8\n  */\n public abstract class InputDecorator\n {\n--- a/src/main/java/com/fasterxml/jackson/core/io/JsonStringEncoder.java\n+++ b/src/main/java/com/fasterxml/jackson/core/io/JsonStringEncoder.java\n  * Note that methods in here are somewhat optimized, but not ridiculously so.\n  * Reason is that conversion method results are expected to be cached so that\n  * these methods will not be hot spots during normal operation.\n- *\n- * @since 1.6\n  */\n public final class JsonStringEncoder\n {\n--- a/src/main/java/com/fasterxml/jackson/core/io/NumberInput.java\n+++ b/src/main/java/com/fasterxml/jackson/core/io/NumberInput.java\n     /**\n      * Helper method to (more) efficiently parse integer numbers from\n      * String values.\n-     * \n-     * @since 1.7\n      */\n     public final static int parseInt(String str)\n     {\n      *\n      * @param negative Whether original number had a minus sign (which is\n      *    NOT passed to this method) or not\n-     *\n-     * @since 1.5.0\n      */\n     public final static boolean inLongRange(String numberStr, boolean negative)\n     {\n         return true;\n     }\n \n-    /**\n-     * @since 1.6\n-     */\n     public static int parseAsInt(String input, int defaultValue)\n     {\n         if (input == null) {\n         return defaultValue;\n     }\n \n-    /**\n-     * @since 1.6\n-     */\n     public static long parseAsLong(String input, long defaultValue)\n     {\n         if (input == null) {\n         return defaultValue;\n     }\n     \n-    /**\n-     * @since 1.6\n-     */\n     public static double parseAsDouble(String input, double defaultValue)\n     {\n         if (input == null) {\n         return defaultValue;\n     }\n     \n-    /**\n-     * @since 1.8\n-     */\n     public final static double parseDouble(String numStr) throws NumberFormatException\n     {\n         // [JACKSON-486]: avoid some nasty float representations... but should it be MIN_NORMAL or MIN_VALUE?\n--- a/src/main/java/com/fasterxml/jackson/core/io/OutputDecorator.java\n+++ b/src/main/java/com/fasterxml/jackson/core/io/OutputDecorator.java\n  * Typical use is to use a filter abstraction (filtered output stream,\n  * writer) around original output destination, and apply additional\n  * processing during write operations.\n- * \n- * @since 1.8\n  */\n public abstract class OutputDecorator\n {\n--- a/src/main/java/com/fasterxml/jackson/core/io/SegmentedStringWriter.java\n+++ b/src/main/java/com/fasterxml/jackson/core/io/SegmentedStringWriter.java\n  * This class is most useful when serializing JSON content as a String:\n  * if so, instance of this class can be given as the writer to\n  * <code>JsonGenerator</code>.\n- *\n- * @since 1.3\n  */\n public final class SegmentedStringWriter\n     extends Writer\n--- a/src/main/java/com/fasterxml/jackson/core/json/ByteSourceJsonBootstrapper.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/ByteSourceJsonBootstrapper.java\n         throw new RuntimeException(\"Internal error\"); // should never get here\n     }\n \n-    public JsonParser constructParser(int features, ObjectCodec codec, BytesToNameCanonicalizer rootByteSymbols, CharsToNameCanonicalizer rootCharSymbols)\n+    public JsonParser constructParser(int parserFeatures, ObjectCodec codec,\n+            BytesToNameCanonicalizer rootByteSymbols, CharsToNameCanonicalizer rootCharSymbols,\n+            boolean canonicalize, boolean intern)\n         throws IOException, JsonParseException\n     {\n         JsonEncoding enc = detectEncoding();\n \n-        // As per [JACKSON-259], may want to fully disable canonicalization:\n-        boolean canonicalize = JsonParser.Feature.CANONICALIZE_FIELD_NAMES.enabledIn(features);\n-        boolean intern = JsonParser.Feature.INTERN_FIELD_NAMES.enabledIn(features);\n         if (enc == JsonEncoding.UTF8) {\n             /* and without canonicalization, byte-based approach is not performance; just use std UTF-8 reader\n              * (which is ok for larger input; not so hot for smaller; but this is not a common case)\n              */\n             if (canonicalize) {\n                 BytesToNameCanonicalizer can = rootByteSymbols.makeChild(canonicalize, intern);\n-                return new UTF8StreamJsonParser(_context, features, _in, codec, can, _inputBuffer, _inputPtr, _inputEnd, _bufferRecyclable);\n-            }\n-        }\n-        return new ReaderBasedJsonParser(_context, features, constructReader(), codec, rootCharSymbols.makeChild(canonicalize, intern));\n+                return new UTF8StreamJsonParser(_context, parserFeatures, _in, codec, can, _inputBuffer, _inputPtr, _inputEnd, _bufferRecyclable);\n+            }\n+        }\n+        return new ReaderBasedJsonParser(_context, parserFeatures, constructReader(), codec,\n+                rootCharSymbols.makeChild(canonicalize, intern));\n     }\n \n     /*\n      * ({@link com.fasterxml.jackson.core.json.ByteSourceJsonBootstrapper}); \n      * supports UTF-8, for example. But it should work, for now, and can\n      * be improved as necessary.\n-     * \n-     * @since 1.8\n      */\n     public static MatchStrength hasJSONFormat(InputAccessor acc) throws IOException\n     {\n--- a/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java\n      * than double quote, when expecting a field name.\n      * In standard mode will just throw an expection; but\n      * in non-standard modes may be able to parse name.\n-     *\n-     * @since 1.2\n      */\n     protected final String _handleUnusualFieldName(int i)\n         throws IOException, JsonParseException\n     /**\n      * Method for handling cases where first non-space character\n      * of an expected value token is not legal for standard JSON content.\n-     *\n-     * @since 1.3\n      */\n     protected final JsonToken _handleUnexpectedValue(int i)\n         throws IOException, JsonParseException\n         return null;\n     }\n     \n-    /**\n-     * @since 1.8\n-     */\n     protected final JsonToken _handleApostropheValue()\n         throws IOException, JsonParseException\n     {\n         return JsonToken.VALUE_STRING;\n     }\n     \n-    /**\n-     * @since 1.2\n-     */\n     private String _parseUnusualFieldName2(int startPtr, int hash, int[] codes)\n         throws IOException, JsonParseException\n     {\n     \n     /**\n      * Helper method for checking whether input matches expected token\n-     * \n-     * @since 1.8\n      */\n     protected final void _matchToken(String matchStr, int i)\n         throws IOException, JsonParseException\n--- a/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java\n         _inputPtr = start;\n         _inputEnd = end;\n         _bufferRecyclable = bufferRecyclable;\n-        // 12-Mar-2010, tatus: Sanity check, related to [JACKSON-259]:\n-        if (!JsonParser.Feature.CANONICALIZE_FIELD_NAMES.enabledIn(features)) {\n-            // should never construct non-canonical UTF-8/byte parser (instead, use Reader)\n-            _throwInternal();\n-        }\n     }\n \n     @Override\n     /**\n      * Helper method that will try to load at least specified number bytes in\n      * input buffer, possible moving existing data around if necessary\n-     * \n-     * @since 1.6\n      */\n     protected final boolean _loadToHaveAtLeast(int minAvailable)\n         throws IOException\n     /**\n      * Method for handling cases where first non-space character\n      * of an expected value token is not legal for standard JSON content.\n-     *\n-     * @since 1.3\n      */\n     protected JsonToken _handleUnexpectedValue(int c)\n         throws IOException, JsonParseException\n     /**\n      * Helper method for matching and skipping a colon character,\n      * optionally surrounded by white space\n-     * \n-     * @since 1.9\n      */\n     private final int _skipColon()\n         throws IOException, JsonParseException\n--- a/src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java\n+++ b/src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java\n      * Let's not expand symbol tables past some maximum size;\n      * this should protected against OOMEs caused by large documents\n      * with uniquer (~= random) names.\n-     * \n-     * @since 1.5\n      */\n     protected static final int MAX_TABLE_SIZE = 0x10000; // 64k entries == 256k mem\n     \n     /**********************************************************\n      */\n \n-    /**\n-     * @since 1.6.0\n-     */\n     public Name addName(String symbolStr, int q1, int q2)\n     {\n         if (_intern) {\n--- a/src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java\n+++ b/src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java\n      * Let's not expand symbol tables past some maximum size;\n      * this should protected against OOMEs caused by large documents\n      * with uniquer (~= random) names.\n-     * \n-     * @since 1.5\n      */\n     protected static final int MAX_TABLE_SIZE = 0x10000; // 64k entries == 256k mem\n \n--- a/src/main/java/com/fasterxml/jackson/core/util/ByteArrayBuilder.java\n+++ b/src/main/java/com/fasterxml/jackson/core/util/ByteArrayBuilder.java\n     /**\n      * Optional buffer recycler instance that we can use for allocating\n      * the first block.\n-     * \n-     * @since 1.5\n      */\n     private final BufferRecycler _bufferRecycler;\n     \n     /**\n      * Method called when starting \"manual\" output: will clear out\n      * current state and return the first segment buffer to fill\n-     * \n-     * @since 1.6\n      */\n     public byte[] resetAndGetFirstSegment() {\n         reset();\n      * Method called when the current segment buffer is full; will\n      * append to current contents, allocate a new segment buffer\n      * and return it\n-     * \n-     * @since 1.6\n      */\n     public byte[] finishCurrentSegment() {\n         _allocMore();\n--- a/src/main/java/com/fasterxml/jackson/core/util/JsonParserSequence.java\n+++ b/src/main/java/com/fasterxml/jackson/core/util/JsonParserSequence.java\n  *<p>\n  * Fairly simple use of {@link JsonParserDelegate}: only need\n  * to override {@link #nextToken} to handle transition\n- * \n- * @author tatu\n- * @since 1.5\n  */\n public class JsonParserSequence extends JsonParserDelegate\n {\n--- a/src/main/java/com/fasterxml/jackson/core/util/MinimalPrettyPrinter.java\n+++ b/src/main/java/com/fasterxml/jackson/core/util/MinimalPrettyPrinter.java\n  * configurability which may be useful for actual use: for example,\n  * it is possible to redefine separator used between root-level\n  * values (default is single space; can be changed to line-feed).\n- * \n- * @since 1.6\n  */\n public class MinimalPrettyPrinter\n     implements PrettyPrinter\n         this(DEFAULT_ROOT_VALUE_SEPARATOR);\n     }\n \n-    /**\n-     * @since 1.9\n-     */\n     public MinimalPrettyPrinter(String rootValueSeparator) {\n         _rootValueSeparator = rootValueSeparator;\n     }\n--- a/src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java\n+++ b/src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java\n     /**\n      * Method that can be used to check whether textual contents can\n      * be efficiently accessed using {@link #getTextBuffer}.\n-     * \n-     * @since 1.9\n      */\n     public boolean hasTextAsCharacters()\n     {\n--- a/src/test/java/com/fasterxml/jackson/core/json/TestJsonParser.java\n+++ b/src/test/java/com/fasterxml/jackson/core/json/TestJsonParser.java\n         assertTrue(jp.isEnabled(JsonParser.Feature.AUTO_CLOSE_SOURCE));\n         jp.configure(JsonParser.Feature.AUTO_CLOSE_SOURCE, false);\n         assertFalse(jp.isEnabled(JsonParser.Feature.AUTO_CLOSE_SOURCE));\n-\n-        // note: can NOT change interning on parser instance, only factory\n-        // but it defaults to true anyway\n-        assertTrue(jp.isEnabled(JsonParser.Feature.INTERN_FIELD_NAMES));\n     }\n \n     public void testInterningWithStreams() throws Exception\n     private void _testIntern(boolean useStream, boolean enableIntern, String expName) throws IOException\n     {\n         JsonFactory f = new JsonFactory();\n-        f.configure(JsonParser.Feature.INTERN_FIELD_NAMES, enableIntern);\n-        assertEquals(enableIntern, f.isEnabled(JsonParser.Feature.INTERN_FIELD_NAMES));\n+        f.configure(JsonFactory.Feature.INTERN_FIELD_NAMES, enableIntern);\n+        assertEquals(enableIntern, f.isEnabled(JsonFactory.Feature.INTERN_FIELD_NAMES));\n         final String JSON = \"{ \\\"\"+expName+\"\\\" : 1}\";\n         JsonParser jp = useStream ?\n             createParserUsingStream(f, JSON, \"UTF-8\") : createParserUsingReader(f, JSON);\n-\n-        assertEquals(enableIntern, jp.isEnabled(JsonParser.Feature.INTERN_FIELD_NAMES));\n             \n         assertToken(JsonToken.START_OBJECT, jp.nextToken());\n         assertToken(JsonToken.FIELD_NAME, jp.nextToken());\n--- a/src/test/java/com/fasterxml/jackson/core/main/TestJsonFactory.java\n+++ b/src/test/java/com/fasterxml/jackson/core/main/TestJsonFactory.java\n         JsonFactory f = new JsonFactory();\n         assertNull(f.getCodec());\n \n-        f.configure(JsonParser.Feature.INTERN_FIELD_NAMES, true);\n-        assertTrue(f.isEnabled(JsonParser.Feature.INTERN_FIELD_NAMES));\n-        f.configure(JsonParser.Feature.INTERN_FIELD_NAMES, false);\n-        assertFalse(f.isEnabled(JsonParser.Feature.INTERN_FIELD_NAMES));\n+        f.configure(JsonFactory.Feature.INTERN_FIELD_NAMES, true);\n+        assertTrue(f.isEnabled(JsonFactory.Feature.INTERN_FIELD_NAMES));\n+        f.configure(JsonFactory.Feature.INTERN_FIELD_NAMES, false);\n+        assertFalse(f.isEnabled(JsonFactory.Feature.INTERN_FIELD_NAMES));\n     }\n     \n     public void testJsonWithFiles() throws Exception\n--- a/src/test/java/com/fasterxml/jackson/core/main/TestParserFeatures.java\n+++ b/src/test/java/com/fasterxml/jackson/core/main/TestParserFeatures.java\n     {\n         _testTabsEnabled(false);\n         _testTabsEnabled(true);\n-    }\n-\n-    // [JACKSON-730]\n-    public void testFactoryOnlyFeatures() throws Exception\n-    {\n-        JsonFactory f = new JsonFactory();\n-        JsonParser jp = f.createJsonParser(\"{ }\");\n-\n-        // should be ok to enable/disable most settings:\n-        jp.enable(JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS);\n-\n-        // but not ones dealing with interning, canonicalization\n-        try {\n-            jp.enable(JsonParser.Feature.CANONICALIZE_FIELD_NAMES);\n-            fail(\"Should have failed with exception\");\n-        } catch (IllegalArgumentException e) {\n-            verifyException(e, \"Can not change Feature\");\n-        }\n     }\n     \n     /*", "timestamp": 1327107909, "metainfo": ""}