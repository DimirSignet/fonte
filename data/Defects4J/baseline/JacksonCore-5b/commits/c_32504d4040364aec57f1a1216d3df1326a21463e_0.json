{"sha": "32504d4040364aec57f1a1216d3df1326a21463e", "log": "test refactoring", "commit": "\n--- a/src/test/java/com/fasterxml/jackson/core/TestJsonFactory.java\n+++ b/src/test/java/com/fasterxml/jackson/core/TestJsonFactory.java\n \n public class TestJsonFactory extends BaseTest\n {\n-    // #72\n-    public void testCopy() throws Exception\n-    {\n-        JsonFactory jf = new JsonFactory();\n-        // first, verify defaults\n-        assertTrue(jf.isEnabled(JsonFactory.Feature.INTERN_FIELD_NAMES));\n-        assertFalse(jf.isEnabled(JsonParser.Feature.ALLOW_COMMENTS));\n-        assertFalse(jf.isEnabled(JsonGenerator.Feature.ESCAPE_NON_ASCII));\n-        jf.disable(JsonFactory.Feature.INTERN_FIELD_NAMES);\n-        jf.enable(JsonParser.Feature.ALLOW_COMMENTS);\n-        jf.enable(JsonGenerator.Feature.ESCAPE_NON_ASCII);\n-        // then change, verify that changes \"stick\"\n-        assertFalse(jf.isEnabled(JsonFactory.Feature.INTERN_FIELD_NAMES));\n-        assertTrue(jf.isEnabled(JsonParser.Feature.ALLOW_COMMENTS));\n-        assertTrue(jf.isEnabled(JsonGenerator.Feature.ESCAPE_NON_ASCII));\n \n-        JsonFactory jf2 = jf.copy();\n-        assertFalse(jf2.isEnabled(JsonFactory.Feature.INTERN_FIELD_NAMES));\n-        assertTrue(jf.isEnabled(JsonParser.Feature.ALLOW_COMMENTS));\n-        assertTrue(jf.isEnabled(JsonGenerator.Feature.ESCAPE_NON_ASCII));\n-    }\n }\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/core/json/TestJsonFactory.java\n+package com.fasterxml.jackson.core.json;\n+\n+import java.io.*;\n+\n+import com.fasterxml.jackson.core.*;\n+\n+public class TestJsonFactory\n+    extends com.fasterxml.jackson.test.BaseTest\n+{\n+    public void testGeneratorFeatures() throws Exception\n+    {\n+        JsonFactory f = new JsonFactory();\n+        assertNull(f.getCodec());\n+\n+        f.configure(JsonGenerator.Feature.QUOTE_FIELD_NAMES, true);\n+        assertTrue(f.isEnabled(JsonGenerator.Feature.QUOTE_FIELD_NAMES));\n+        f.configure(JsonGenerator.Feature.QUOTE_FIELD_NAMES, false);\n+        assertFalse(f.isEnabled(JsonGenerator.Feature.QUOTE_FIELD_NAMES));\n+    }\n+\n+    public void testParserFeatures() throws Exception\n+    {\n+        JsonFactory f = new JsonFactory();\n+        assertNull(f.getCodec());\n+\n+        f.configure(JsonFactory.Feature.INTERN_FIELD_NAMES, true);\n+        assertTrue(f.isEnabled(JsonFactory.Feature.INTERN_FIELD_NAMES));\n+        f.configure(JsonFactory.Feature.INTERN_FIELD_NAMES, false);\n+        assertFalse(f.isEnabled(JsonFactory.Feature.INTERN_FIELD_NAMES));\n+    }\n+    \n+    public void testJsonWithFiles() throws Exception\n+    {\n+        File file = File.createTempFile(\"jackson-test\", null);\n+        file.deleteOnExit();\n+        \n+        JsonFactory f = new JsonFactory();\n+\n+        // First: create file via generator.. and use an odd encoding\n+        JsonGenerator jg = f.createGenerator(file, JsonEncoding.UTF16_LE);\n+        jg.writeStartObject();\n+        jg.writeRaw(\"   \");\n+        jg.writeEndObject();\n+        jg.close();\n+\n+        // Ok: first read file directly\n+        JsonParser jp = f.createParser(file);\n+        assertToken(JsonToken.START_OBJECT, jp.nextToken());\n+        assertToken(JsonToken.END_OBJECT, jp.nextToken());\n+        assertNull(jp.nextToken());\n+        jp.close();\n+\n+        // Then via URL:\n+        jp = f.createParser(file.toURI().toURL());\n+        assertToken(JsonToken.START_OBJECT, jp.nextToken());\n+        assertToken(JsonToken.END_OBJECT, jp.nextToken());\n+        assertNull(jp.nextToken());\n+        jp.close();\n+\n+        // ok, delete once we are done\n+        file.delete();\n+    }\n+\n+    // #72\n+    public void testCopy() throws Exception\n+    {\n+        JsonFactory jf = new JsonFactory();\n+        // first, verify defaults\n+        assertTrue(jf.isEnabled(JsonFactory.Feature.INTERN_FIELD_NAMES));\n+        assertFalse(jf.isEnabled(JsonParser.Feature.ALLOW_COMMENTS));\n+        assertFalse(jf.isEnabled(JsonGenerator.Feature.ESCAPE_NON_ASCII));\n+        jf.disable(JsonFactory.Feature.INTERN_FIELD_NAMES);\n+        jf.enable(JsonParser.Feature.ALLOW_COMMENTS);\n+        jf.enable(JsonGenerator.Feature.ESCAPE_NON_ASCII);\n+        // then change, verify that changes \"stick\"\n+        assertFalse(jf.isEnabled(JsonFactory.Feature.INTERN_FIELD_NAMES));\n+        assertTrue(jf.isEnabled(JsonParser.Feature.ALLOW_COMMENTS));\n+        assertTrue(jf.isEnabled(JsonGenerator.Feature.ESCAPE_NON_ASCII));\n+\n+        JsonFactory jf2 = jf.copy();\n+        assertFalse(jf2.isEnabled(JsonFactory.Feature.INTERN_FIELD_NAMES));\n+        assertTrue(jf.isEnabled(JsonParser.Feature.ALLOW_COMMENTS));\n+        assertTrue(jf.isEnabled(JsonGenerator.Feature.ESCAPE_NON_ASCII));\n+    }\n+}\n+\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/core/json/TestJsonGenerator.java\n+package com.fasterxml.jackson.core.json;\n+\n+import com.fasterxml.jackson.core.*;\n+\n+import java.io.*;\n+\n+/**\n+ * Set of basic unit tests for verifying that the basic generator\n+ * functionality works as expected.\n+ */\n+public class TestJsonGenerator\n+    extends com.fasterxml.jackson.test.BaseTest\n+{\n+    // // // First, tests for primitive (non-structured) values\n+\n+    public void testStringWrite()\n+        throws Exception\n+    {\n+        JsonFactory jf = new JsonFactory();\n+        String[] inputStrings = new String[] { \"\", \"X\", \"1234567890\" };\n+        for (int useReader = 0; useReader < 2; ++useReader) {\n+            for (int writeString = 0; writeString < 2; ++writeString) {\n+                for (int strIx = 0; strIx < inputStrings.length; ++strIx) {\n+                    String input = inputStrings[strIx];\n+                    JsonGenerator gen;\n+                    ByteArrayOutputStream bout = new ByteArrayOutputStream();\n+                    if (useReader != 0) {\n+                        gen = jf.createGenerator(new OutputStreamWriter(bout, \"UTF-8\"));\n+                    } else {\n+                        gen = jf.createGenerator(bout, JsonEncoding.UTF8);\n+                    }\n+                    if (writeString > 0) {\n+                        gen.writeString(input);\n+                    } else {\n+                        int len = input.length();\n+                        char[] buffer = new char[len + 20];\n+                        // Let's use non-zero base offset too...\n+                        input.getChars(0, len, buffer, strIx);\n+                        gen.writeString(buffer, strIx, len);\n+                    }\n+                    gen.flush();\n+                    gen.close();\n+                    JsonParser jp = jf.createParser(new ByteArrayInputStream(bout.toByteArray()));\n+                \n+                    JsonToken t = jp.nextToken();\n+                    assertNotNull(\"Document \\\"\"+bout.toString(\"UTF-8\")+\"\\\" yielded no tokens\", t);\n+                    assertEquals(JsonToken.VALUE_STRING, t);\n+                    assertEquals(input, jp.getText());\n+                    assertEquals(null, jp.nextToken());\n+                    jp.close();\n+                }\n+            }\n+        }\n+    }\n+\n+    public void testIntWrite()\n+        throws Exception\n+    {\n+        doTestIntWrite(false);\n+        doTestIntWrite(true);\n+    }\n+\n+    public void testLongWrite()\n+        throws Exception\n+    {\n+        doTestLongWrite(false);\n+        doTestLongWrite(true);\n+    }\n+\n+    public void testBooleanWrite()\n+        throws Exception\n+    {\n+        for (int i = 0; i < 4; ++i) {\n+            boolean state = (i & 1) == 0;\n+            boolean pad = (i & 2) == 0;\n+            StringWriter sw = new StringWriter();\n+            JsonGenerator gen = new JsonFactory().createGenerator(sw);\n+            gen.writeBoolean(state);\n+            if (pad) {\n+                gen.writeRaw(\" \");\n+            }\n+            gen.close();\n+            String docStr = sw.toString();\n+            JsonParser jp = createParserUsingReader(docStr);\n+            JsonToken t = jp.nextToken();\n+            String exp = Boolean.valueOf(state).toString();\n+            if (!exp.equals(jp.getText())) {\n+                fail(\"Expected '\"+exp+\"', got '\"+jp.getText());\n+            }\n+            assertEquals(state ? JsonToken.VALUE_TRUE : JsonToken.VALUE_FALSE, t);\n+            assertEquals(null, jp.nextToken());\n+            jp.close();\n+        }\n+    }\n+\n+    public void testNullWrite()\n+        throws Exception\n+    {\n+        for (int i = 0; i < 2; ++i) {\n+            boolean pad = (i & 1) == 0;\n+            StringWriter sw = new StringWriter();\n+            JsonGenerator gen = new JsonFactory().createGenerator(sw);\n+            gen.writeNull();\n+            if (pad) {\n+                gen.writeRaw(\" \");\n+            }\n+            gen.close();\n+            String docStr = sw.toString();\n+            JsonParser jp = createParserUsingReader(docStr);\n+            JsonToken t = jp.nextToken();\n+            String exp = \"null\";\n+            if (!exp.equals(jp.getText())) {\n+                fail(\"Expected '\"+exp+\"', got '\"+jp.getText());\n+            }\n+            assertEquals(JsonToken.VALUE_NULL, t);\n+            assertEquals(null, jp.nextToken());\n+            jp.close();\n+        }\n+    }\n+    \n+    // // Then root-level output testing\n+\n+     public void testRootIntsWrite()\n+         throws Exception\n+     {\n+         StringWriter sw = new StringWriter();\n+         JsonGenerator gen = new JsonFactory().createGenerator(sw);\n+         gen.writeNumber(1);\n+         gen.writeNumber(2);\n+         gen.writeNumber(-13);\n+         gen.close();\n+\n+         String docStr = sw.toString();\n+\n+         JsonParser jp = createParserUsingReader(docStr);\n+         assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n+         assertEquals(1, jp.getIntValue());\n+         assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n+         assertEquals(2, jp.getIntValue());\n+         assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n+         assertEquals(-13, jp.getIntValue());\n+         jp.close();\n+     }\n+    \n+    // Convenience methods\n+    \n+    public void testFieldValueWrites()\n+         throws Exception\n+     {\n+         StringWriter sw = new StringWriter();\n+         JsonGenerator gen = new JsonFactory().createGenerator(sw);\n+         gen.writeStartObject();\n+         gen.writeNumberField(\"long\", 3L);\n+         gen.writeNumberField(\"double\", 0.25);\n+         gen.writeNumberField(\"float\", -0.25f);\n+         gen.writeEndObject();\n+         gen.close();\n+\n+         assertEquals(\"{\\\"long\\\":3,\\\"double\\\":0.25,\\\"float\\\":-0.25}\", sw.toString().trim());\n+     }\n+\n+    /*\n+    /**********************************************************\n+    /* Internal methods\n+    /**********************************************************\n+     */\n+    \n+    private void doTestIntWrite(boolean pad)\n+        throws Exception\n+    {\n+        int[] VALUES = new int[] {\n+            0, 1, -9, 32, -32, 57, 13240, -9999, Integer.MAX_VALUE, Integer.MAX_VALUE\n+        };\n+        for (int i = 0; i < VALUES.length; ++i) {\n+            int VALUE = VALUES[i];\n+            StringWriter sw = new StringWriter();\n+            JsonGenerator gen = new JsonFactory().createGenerator(sw);\n+            gen.writeNumber(VALUE);\n+            if (pad) {\n+                gen.writeRaw(\" \");\n+            }\n+            gen.close();\n+            String docStr = sw.toString();\n+            JsonParser jp = createParserUsingReader(docStr);\n+            JsonToken t = jp.nextToken();\n+            assertNotNull(\"Document \\\"\"+docStr+\"\\\" yielded no tokens\", t);\n+            // Number are always available as lexical representation too\n+            String exp = \"\"+VALUE;\n+            if (!exp.equals(jp.getText())) {\n+                fail(\"Expected '\"+exp+\"', got '\"+jp.getText());\n+            }\n+            assertEquals(JsonToken.VALUE_NUMBER_INT, t);\n+            assertEquals(VALUE, jp.getIntValue());\n+            assertEquals(null, jp.nextToken());\n+            jp.close();\n+        }\n+    }\n+\n+    private void doTestLongWrite(boolean pad)\n+        throws Exception\n+    {\n+        long[] VALUES = new long[] {\n+            0L, 1L, -1L, -12005002294L, Long.MIN_VALUE, Long.MAX_VALUE\n+        };\n+        for (int i = 0; i < VALUES.length; ++i) {\n+            long VALUE = VALUES[i];\n+            StringWriter sw = new StringWriter();\n+            JsonGenerator gen = new JsonFactory().createGenerator(sw);\n+            gen.writeNumber(VALUE);\n+            if (pad) {\n+                gen.writeRaw(\" \");\n+            }\n+            gen.close();\n+            String docStr = sw.toString();\n+            JsonParser jp = createParserUsingReader(docStr);\n+            JsonToken t = jp.nextToken();\n+            assertNotNull(\"Document \\\"\"+docStr+\"\\\" yielded no tokens\", t);\n+            String exp = \"\"+VALUE;\n+            if (!exp.equals(jp.getText())) {\n+                fail(\"Expected '\"+exp+\"', got '\"+jp.getText());\n+            }\n+            assertEquals(JsonToken.VALUE_NUMBER_INT, t);\n+            assertEquals(VALUE, jp.getLongValue());\n+            assertEquals(null, jp.nextToken());\n+            jp.close();\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/core/json/TestJsonGeneratorFeatures.java\n+package com.fasterxml.jackson.core.json;\n+\n+import java.io.*;\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+\n+import com.fasterxml.jackson.core.*;\n+\n+/**\n+ * Set of basic unit tests for verifying that the basic generator\n+ * functionality works as expected.\n+ */\n+public class TestJsonGeneratorFeatures\n+    extends com.fasterxml.jackson.test.BaseTest\n+{\n+    public void testConfigDefaults() throws IOException\n+    {\n+        JsonFactory jf = new JsonFactory();\n+        JsonGenerator jg = jf.createGenerator(new StringWriter());\n+        assertFalse(jg.isEnabled(JsonGenerator.Feature.WRITE_NUMBERS_AS_STRINGS));\n+    }\n+\n+    public void testFieldNameQuoting() throws IOException\n+    {\n+        JsonFactory jf = new JsonFactory();\n+        // by default, quoting should be enabled\n+        _testFieldNameQuoting(jf, true);\n+        // can disable it\n+        jf.disable(JsonGenerator.Feature.QUOTE_FIELD_NAMES);\n+        _testFieldNameQuoting(jf, false);\n+        // and (re)enable:\n+        jf.enable(JsonGenerator.Feature.QUOTE_FIELD_NAMES);\n+        _testFieldNameQuoting(jf, true);\n+    }\n+\n+    public void testNonNumericQuoting()\n+        throws IOException\n+    {\n+        JsonFactory jf = new JsonFactory();\n+        // by default, quoting should be enabled\n+        _testNonNumericQuoting(jf, true);\n+        // can disable it\n+        jf.disable(JsonGenerator.Feature.QUOTE_NON_NUMERIC_NUMBERS);\n+        _testNonNumericQuoting(jf, false);\n+        // and (re)enable:\n+        jf.enable(JsonGenerator.Feature.QUOTE_NON_NUMERIC_NUMBERS);\n+        _testNonNumericQuoting(jf, true);\n+    }\n+\n+    /**\n+     * Testing for [JACKSON-176], ability to force serializing numbers\n+     * as JSON Strings.\n+     */\n+    public void testNumbersAsJSONStrings() throws IOException\n+    {\n+        JsonFactory jf = new JsonFactory();\n+        // by default should output numbers as-is:\n+        assertEquals(\"[1,2,1.25,2.25,3001,0.5,-1]\", _writeNumbers(jf));        \n+\n+        // but if overridden, quotes as Strings\n+        jf.configure(JsonGenerator.Feature.WRITE_NUMBERS_AS_STRINGS, true);\n+        assertEquals(\"[\\\"1\\\",\\\"2\\\",\\\"1.25\\\",\\\"2.25\\\",\\\"3001\\\",\\\"0.5\\\",\\\"-1\\\"]\",\n+                     _writeNumbers(jf));\n+    }\n+\n+    private String _writeNumbers(JsonFactory jf) throws IOException\n+    {\n+        StringWriter sw = new StringWriter();\n+        JsonGenerator jg = jf.createGenerator(sw);\n+    \n+        jg.writeStartArray();\n+        jg.writeNumber(1);\n+        jg.writeNumber(2L);\n+        jg.writeNumber(1.25);\n+        jg.writeNumber(2.25f);\n+        jg.writeNumber(BigInteger.valueOf(3001));\n+        jg.writeNumber(BigDecimal.valueOf(0.5));\n+        jg.writeNumber(\"-1\");\n+        jg.writeEndArray();\n+        jg.close();\n+\n+        return sw.toString();\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Helper methods\n+    /**********************************************************\n+     */\n+\n+    private void _testFieldNameQuoting(JsonFactory jf, boolean quoted)\n+        throws IOException\n+    {\n+        StringWriter sw = new StringWriter();\n+        JsonGenerator jg = jf.createGenerator(sw);\n+        jg.writeStartObject();\n+        jg.writeFieldName(\"foo\");\n+        jg.writeNumber(1);\n+        jg.writeEndObject();\n+        jg.close();\n+\n+        String result = sw.toString();\n+        if (quoted) {\n+            assertEquals(\"{\\\"foo\\\":1}\", result);\n+        } else {\n+            assertEquals(\"{foo:1}\", result);\n+        }\n+    }\n+    private void _testNonNumericQuoting(JsonFactory jf, boolean quoted)\n+        throws IOException\n+    {\n+        StringWriter sw = new StringWriter();\n+        JsonGenerator jg = jf.createGenerator(sw);\n+        jg.writeStartObject();\n+        jg.writeFieldName(\"double\");\n+        jg.writeNumber(Double.NaN);\n+        jg.writeEndObject();\n+        jg.writeStartObject();\n+        jg.writeFieldName(\"float\");\n+        jg.writeNumber(Float.NaN);\n+        jg.writeEndObject();\n+        jg.close();\n+\t\n+        String result = sw.toString();\n+        if (quoted) {\n+            assertEquals(\"{\\\"double\\\":\\\"NaN\\\"} {\\\"float\\\":\\\"NaN\\\"}\", result);\n+        } else {\n+            assertEquals(\"{\\\"double\\\":NaN} {\\\"float\\\":NaN}\", result);\n+        }\n+    }\n+}", "timestamp": 1370549470, "metainfo": ""}