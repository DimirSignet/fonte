{"sha": "48b57265f6344ccb3ca5b4c57bee2d8db9817a95", "log": "minor optimization of nextFieldName()", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java\n             // when doing literal match, must consider escaping:\n             byte[] nameBytes = str.asQuotedUTF8();\n             final int len = nameBytes.length;\n-            if ((_inputPtr + len) < _inputEnd) { // maybe...\n+            // 22-May-2014, tatu: Actually, let's require 4 more bytes for faster skipping\n+            //    of colon that follows name\n+            if ((_inputPtr + len + 4) < _inputEnd) { // maybe...\n                 // first check length match by\n                 final int end = _inputPtr+len;\n                 if (_inputBuffer[end] == INT_QUOTE) {\n                     while (true) {\n                         if (offset == len) { // yes, match!\n                             _inputPtr = end+1; // skip current value first\n-                            // First part is simple; setting of name\n                             _parsingContext.setCurrentName(str.getValue());\n-                            _currToken = JsonToken.FIELD_NAME;\n-                            // But then we also must handle following value etc\n-                            _isNextTokenNameYes();\n+                            _isNextTokenNameYes(_skipColonFast());\n                             return true;\n                         }\n                         if (nameBytes[offset] != _inputBuffer[ptr+offset]) {\n         return _isNextTokenNameMaybe(i, str);\n     }\n \n-    private final void _isNextTokenNameYes() throws IOException\n-    {\n-        // very first thing: common case, colon, value, no white space\n-        int i = _skipColon();\n+    private final void _isNextTokenNameYes(int i) throws IOException\n+    {\n+        _currToken = JsonToken.FIELD_NAME;\n+\n         switch (i) {\n         case '\"':\n             _tokenIncomplete = true;\n         }\n         _nextToken = _handleUnexpectedValue(i);\n     }\n+\n+    // Variant called when we know there's at least 4 more bytes available\n+    private final int _skipColonFast() throws IOException\n+    {\n+        int i = _inputBuffer[_inputPtr++];\n+        if (i == INT_COLON) { // common case, no leading space\n+            i = _inputBuffer[_inputPtr++];\n+            if (i > INT_SPACE) { // nor trailing\n+                if (i != INT_SLASH && i != INT_HASH) {\n+                    return i;\n+                }\n+            } else if (i == INT_SPACE || i == INT_TAB) {\n+                i = (int) _inputBuffer[_inputPtr++];\n+                if (i > INT_SPACE) {\n+                    if (i != INT_SLASH && i != INT_HASH) {\n+                        return i;\n+                    }\n+                }\n+            }\n+            --_inputPtr;\n+            return _skipColon2(true); // true -> skipped colon\n+        }\n+        if (i == INT_SPACE || i == INT_TAB) {\n+            i = _inputBuffer[_inputPtr++];\n+        }\n+        if (i == INT_COLON) {\n+            i = _inputBuffer[_inputPtr++];\n+            if (i > INT_SPACE) {\n+                if (i != INT_SLASH && i != INT_HASH) {\n+                    return i;\n+                }\n+            } else if (i == INT_SPACE || i == INT_TAB) {\n+                i = (int) _inputBuffer[_inputPtr++];\n+                if (i > INT_SPACE) {\n+                    if (i != INT_SLASH && i != INT_HASH) {\n+                        return i;\n+                    }\n+                }\n+            }\n+        }\n+        --_inputPtr;\n+        return _skipColon2(false);\n+    }\n+    \n     \n     private final boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException\n     {\n         // We ran out of input...\n         return _eofAsNextChar();\n     }\n-    \n+\n     private final int _skipColon() throws IOException\n     {\n         if ((_inputPtr + 4) >= _inputEnd) {", "timestamp": 1400812961, "metainfo": ""}