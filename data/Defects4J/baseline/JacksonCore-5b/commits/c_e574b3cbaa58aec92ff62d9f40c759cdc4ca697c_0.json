{"sha": "e574b3cbaa58aec92ff62d9f40c759cdc4ca697c", "log": "Merge pull request #110 from qpliu/master  Add FilterJsonGenerator.", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/core/util/JsonGeneratorDelegate.java\n+++ b/src/main/java/com/fasterxml/jackson/core/util/JsonGeneratorDelegate.java\n import java.io.InputStream;\n import java.math.BigDecimal;\n import java.math.BigInteger;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n \n import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.core.JsonParser.NumberType;\n import com.fasterxml.jackson.core.io.CharacterEscapes;\n+\n+import static com.fasterxml.jackson.core.JsonTokenId.*;\n \n public class JsonGeneratorDelegate extends JsonGenerator\n {\n      */\n     protected JsonGenerator delegate;\n \n+    /**\n+     * Delegate copy methods.  Defaults to true.\n+     */\n+    protected boolean delegateCopyMethods;\n+\n     /*\n     /**********************************************************\n     /* Construction, initialization\n      */\n     \n     public JsonGeneratorDelegate(JsonGenerator d) {\n+        this(d, true);\n+    }\n+    \n+    public JsonGeneratorDelegate(JsonGenerator d, boolean delegateCopyMethods) {\n         delegate = d;\n+        this.delegateCopyMethods = delegateCopyMethods;\n     }\n \n     @Override\n     \n     @Override\n     public void writeObject(Object pojo) throws IOException,JsonProcessingException {\n-        delegate.writeObject(pojo);\n+        if (delegateCopyMethods) {\n+            delegate.writeObject(pojo);\n+        } else {\n+            if (pojo == null) {\n+                // important: call method that does check value write:\n+                writeNull();\n+            } else {\n+                /* 02-Mar-2009, tatu: we are NOT to call _verifyValueWrite here,\n+                 *   because that will be done when codec actually serializes\n+                 *   contained POJO. If we did call it it would advance state\n+                 *   causing exception later on\n+                 */\n+                if (getCodec() != null) {\n+                    getCodec().writeValue(this, pojo);\n+                    return;\n+                }\n+                _writeSimpleObject(pojo);\n+            }\n+        }\n     }\n     \n     @Override\n     public void writeTree(TreeNode rootNode) throws IOException, JsonProcessingException {\n-        delegate.writeTree(rootNode);\n+        if (delegateCopyMethods) {\n+            delegate.writeTree(rootNode);\n+        } else {\n+            // As with 'writeObject()', we are not check if write would work\n+            if (rootNode == null) {\n+                writeNull();\n+            } else {\n+                if (getCodec() == null) {\n+                    throw new IllegalStateException(\"No ObjectCodec defined\");\n+                }\n+                getCodec().writeValue(this, rootNode);\n+            }\n+        }\n     }\n \n     /*\n \n     @Override\n     public void copyCurrentEvent(JsonParser jp) throws IOException, JsonProcessingException {\n-        delegate.copyCurrentEvent(jp);\n+        if (delegateCopyMethods) {\n+            delegate.copyCurrentEvent(jp);\n+        } else {\n+            JsonToken t = jp.getCurrentToken();\n+            // sanity check; what to do?\n+            if (t == null) {\n+                _reportError(\"No current event to copy\");\n+            }\n+            switch (t.id()) {\n+            case ID_NOT_AVAILABLE:\n+                _reportError(\"No current event to copy\");\n+            case ID_START_OBJECT:\n+                writeStartObject();\n+                break;\n+            case ID_END_OBJECT:\n+                writeEndObject();\n+                break;\n+            case ID_START_ARRAY:\n+                writeStartArray();\n+                break;\n+            case ID_END_ARRAY:\n+                writeEndArray();\n+                break;\n+            case ID_FIELD_NAME:\n+                writeFieldName(jp.getCurrentName());\n+                break;\n+            case ID_STRING:\n+                if (jp.hasTextCharacters()) {\n+                    writeString(jp.getTextCharacters(), jp.getTextOffset(), jp.getTextLength());\n+                } else {\n+                    writeString(jp.getText());\n+                }\n+                break;\n+            case ID_NUMBER_INT:\n+            {\n+                NumberType n = jp.getNumberType();\n+                if (n == NumberType.INT) {\n+                    writeNumber(jp.getIntValue());\n+                } else if (n == NumberType.BIG_INTEGER) {\n+                    writeNumber(jp.getBigIntegerValue());\n+                } else {\n+                    writeNumber(jp.getLongValue());\n+                }\n+                break;\n+            }\n+            case ID_NUMBER_FLOAT:\n+            {\n+                NumberType n = jp.getNumberType();\n+                if (n == NumberType.BIG_DECIMAL) {\n+                    writeNumber(jp.getDecimalValue());\n+                } else if (n == NumberType.FLOAT) {\n+                    writeNumber(jp.getFloatValue());\n+                } else {\n+                    writeNumber(jp.getDoubleValue());\n+                }\n+                break;\n+            }\n+            case ID_TRUE:\n+                writeBoolean(true);\n+                break;\n+            case ID_FALSE:\n+                writeBoolean(false);\n+                break;\n+            case ID_NULL:\n+                writeNull();\n+                break;\n+            case ID_EMBEDDED_OBJECT:\n+                writeObject(jp.getEmbeddedObject());\n+                break;\n+            default:\n+                _throwInternal();\n+            }\n+        }\n     }\n \n     @Override\n     public void copyCurrentStructure(JsonParser jp) throws IOException, JsonProcessingException {\n-        delegate.copyCurrentStructure(jp);\n+        if (delegateCopyMethods) {\n+            delegate.copyCurrentStructure(jp);\n+        } else {\n+            JsonToken t = jp.getCurrentToken();\n+            if (t == null) {\n+                _reportError(\"No current event to copy\");\n+            }\n+            // Let's handle field-name separately first\n+            int id = t.id();\n+            if (id == ID_FIELD_NAME) {\n+                writeFieldName(jp.getCurrentName());\n+                t = jp.nextToken();\n+                id = t.id();\n+                // fall-through to copy the associated value\n+            }\n+            switch (id) {\n+            case ID_START_OBJECT:\n+                writeStartObject();\n+                while (jp.nextToken() != JsonToken.END_OBJECT) {\n+                    copyCurrentStructure(jp);\n+                }\n+                writeEndObject();\n+                break;\n+            case ID_START_ARRAY:\n+                writeStartArray();\n+                while (jp.nextToken() != JsonToken.END_ARRAY) {\n+                    copyCurrentStructure(jp);\n+                }\n+                writeEndArray();\n+                break;\n+            default:\n+                copyCurrentEvent(jp);\n+            }\n+        }\n     }\n \n     /*\n     public boolean isClosed() {\n         return delegate.isClosed();\n     }\n+\n+    /**\n+     * Helper method used for constructing and throwing\n+     * {@link JsonGenerationException} with given base message.\n+     *<p>\n+     * Note that sub-classes may override this method to add more detail\n+     * or use a {@link JsonGenerationException} sub-class.\n+     */\n+    protected void _reportError(String msg)\n+        throws JsonGenerationException\n+    {\n+        throw new JsonGenerationException(msg);\n+    }\n+\n+    /**\n+     * Helper method to try to call appropriate write method for given\n+     * untyped Object. At this point, no structural conversions should be done,\n+     * only simple basic types are to be coerced as necessary.\n+     *\n+     * @param value Non-null value to write\n+     */\n+    protected void _writeSimpleObject(Object value) \n+        throws IOException, JsonGenerationException\n+    {\n+        /* 31-Dec-2009, tatu: Actually, we could just handle some basic\n+         *    types even without codec. This can improve interoperability,\n+         *    and specifically help with TokenBuffer.\n+         */\n+        if (value == null) {\n+            writeNull();\n+            return;\n+        }\n+        if (value instanceof String) {\n+            writeString((String) value);\n+            return;\n+        }\n+        if (value instanceof Number) {\n+            Number n = (Number) value;\n+            if (n instanceof Integer) {\n+                writeNumber(n.intValue());\n+                return;\n+            } else if (n instanceof Long) {\n+                writeNumber(n.longValue());\n+                return;\n+            } else if (n instanceof Double) {\n+                writeNumber(n.doubleValue());\n+                return;\n+            } else if (n instanceof Float) {\n+                writeNumber(n.floatValue());\n+                return;\n+            } else if (n instanceof Short) {\n+                writeNumber(n.shortValue());\n+                return;\n+            } else if (n instanceof Byte) {\n+                writeNumber(n.byteValue());\n+                return;\n+            } else if (n instanceof BigInteger) {\n+                writeNumber((BigInteger) n);\n+                return;\n+            } else if (n instanceof BigDecimal) {\n+                writeNumber((BigDecimal) n);\n+                return;\n+                \n+            // then Atomic types\n+                \n+            } else if (n instanceof AtomicInteger) {\n+                writeNumber(((AtomicInteger) n).get());\n+                return;\n+            } else if (n instanceof AtomicLong) {\n+                writeNumber(((AtomicLong) n).get());\n+                return;\n+            }\n+        } else if (value instanceof byte[]) {\n+            writeBinary((byte[]) value);\n+            return;\n+        } else if (value instanceof Boolean) {\n+            writeBoolean((Boolean) value);\n+            return;\n+        } else if (value instanceof AtomicBoolean) {\n+            writeBoolean(((AtomicBoolean) value).get());\n+            return;\n+        }\n+        throw new IllegalStateException(\"No ObjectCodec defined for the generator, can only serialize simple wrapper types (type passed \"\n+                +value.getClass().getName()+\")\");\n+    }    \n+\n+    protected final void _throwInternal() {\n+        VersionUtil.throwInternal();\n+    }\n }\n--- a/src/test/java/com/fasterxml/jackson/core/util/TestDelegates.java\n+++ b/src/test/java/com/fasterxml/jackson/core/util/TestDelegates.java\n         assertTrue(jg.isClosed());        \n         assertEquals(\"[13,null,false]\", sw.toString());\n     }\n+\n+    public void testNotDelegateCopyMethods() throws IOException\n+    {\n+        JsonParser jp = new JsonFactory().createParser(\"[{\\\"a\\\":[1,2,{\\\"b\\\":3}],\\\"c\\\":\\\"d\\\"},{\\\"e\\\":false},null]\");\n+        StringWriter sw = new StringWriter();\n+        JsonGenerator jg = new JsonGeneratorDelegate(new JsonFactory().createGenerator(sw), false) {\n+            @Override\n+            public void writeFieldName(String name) throws IOException, JsonGenerationException {\n+                super.writeFieldName(name+\"-test\");\n+                super.writeBoolean(true);\n+                super.writeFieldName(name);\n+            }\n+        };\n+        jp.nextToken();\n+        jg.copyCurrentStructure(jp);\n+        jg.flush();\n+        assertEquals(\"[{\\\"a-test\\\":true,\\\"a\\\":[1,2,{\\\"b-test\\\":true,\\\"b\\\":3}],\\\"c-test\\\":true,\\\"c\\\":\\\"d\\\"},{\\\"e-test\\\":true,\\\"e\\\":false},null]\", sw.toString());\n+    }\n }\n--- a/src/main/java/com/fasterxml/jackson/core/JsonPointer.java\n+++ b/src/main/java/com/fasterxml/jackson/core/JsonPointer.java\n  * <a href=\"http://tools.ietf.org/html/draft-ietf-appsawg-json-pointer-03\">JSON Pointer</a>\n  * specification.\n  * Pointer instances can be used to locate logical JSON nodes for things like\n- * tree traversal (see {@link TreeNode#at}) and filtering of streaming JSON content\n- * (see {@link JsonParser#filter}).\n+ * tree traversal (see {@link TreeNode#at}).\n+ * It may be used in future for filtering of streaming JSON content\n+ * as well (not implemented yet for 2.3).\n  *<p>\n  * Instances are fully immutable and can be shared, cached.\n  * \n--- a/src/main/java/com/fasterxml/jackson/core/base/ParserBase.java\n+++ b/src/main/java/com/fasterxml/jackson/core/base/ParserBase.java\n     public JsonLocation getTokenLocation()\n     {\n         return new JsonLocation(_ioContext.getSourceReference(),\n-                getTokenCharacterOffset(),\n+                -1L, getTokenCharacterOffset(), // bytes, chars\n                 getTokenLineNr(),\n                 getTokenColumnNr());\n     }\n     {\n         int col = _inputPtr - _currInputRowStart + 1; // 1-based\n         return new JsonLocation(_ioContext.getSourceReference(),\n-                _currInputProcessed + _inputPtr - 1,\n+                -1L, _currInputProcessed + _inputPtr, // bytes, chars\n                 _currInputRow, col);\n     }\n \n--- a/src/main/java/com/fasterxml/jackson/core/json/UTF8JsonGenerator.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/UTF8JsonGenerator.java\n      * needs to be returned to recycler once we are done) or not.\n      */\n     protected boolean _bufferRecyclable;\n-    \n+\n+    /*\n+    /**********************************************************\n+    /* Quick flags\n+    /**********************************************************\n+     */\n+\n+    protected final boolean _cfgQuoteNames;\n+\n     /*\n     /**********************************************************\n     /* Life-cycle\n         if (isEnabled(Feature.ESCAPE_NON_ASCII)) {\n             setHighestNonEscapedChar(127);\n         }\n+        _cfgQuoteNames = Feature.QUOTE_FIELD_NAMES.enabledIn(features);\n     }\n     \n     public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec,\n         _outputMaxContiguous = _outputEnd >> 3;\n         _charBuffer = ctxt.allocConcatBuffer();\n         _charBufferLength = _charBuffer.length;\n+        _cfgQuoteNames = Feature.QUOTE_FIELD_NAMES.enabledIn(features);\n     }\n \n     /*\n      */\n \n     @Override\n-    public final void writeFieldName(String name)  throws IOException, JsonGenerationException\n+    public void writeFieldName(String name)  throws IOException, JsonGenerationException\n     {\n         int status = _writeContext.writeFieldName(name);\n         if (status == JsonWriteContext.STATUS_EXPECT_VALUE) {\n         _writeFieldName(name);\n     }\n \n-    @Override\n-    public final void writeFieldName(SerializableString name)\n-        throws IOException, JsonGenerationException\n-    {\n-        // Object is a value, need to verify it's allowed\n-        int status = _writeContext.writeFieldName(name.getValue());\n-        if (status == JsonWriteContext.STATUS_EXPECT_VALUE) {\n-            _reportError(\"Can not write a field name, expecting a value\");\n-        }\n-        if (_cfgPrettyPrinter != null) {\n-            _writePPFieldName(name, (status == JsonWriteContext.STATUS_OK_AFTER_COMMA));\n-            return;\n-        }\n-        if (status == JsonWriteContext.STATUS_OK_AFTER_COMMA) {\n-            if (_outputTail >= _outputEnd) {\n-                _flushBuffer();\n-            }\n-            _outputBuffer[_outputTail++] = BYTE_COMMA;\n-        }\n-        _writeFieldName(name);\n-    }\n-\n-    /*\n-    /**********************************************************\n-    /* Output method implementations, structural\n-    /**********************************************************\n-     */\n-\n-    @Override\n-    public final void writeStartArray() throws IOException, JsonGenerationException\n-    {\n-        _verifyValueWrite(\"start an array\");\n-        _writeContext = _writeContext.createChildArrayContext();\n-        if (_cfgPrettyPrinter != null) {\n-            _cfgPrettyPrinter.writeStartArray(this);\n-        } else {\n-            if (_outputTail >= _outputEnd) {\n-                _flushBuffer();\n-            }\n-            _outputBuffer[_outputTail++] = BYTE_LBRACKET;\n-        }\n-    }\n-\n-    @Override\n-    public final void writeEndArray() throws IOException, JsonGenerationException\n-    {\n-        if (!_writeContext.inArray()) {\n-            _reportError(\"Current context not an ARRAY but \"+_writeContext.getTypeDesc());\n-        }\n-        if (_cfgPrettyPrinter != null) {\n-            _cfgPrettyPrinter.writeEndArray(this, _writeContext.getEntryCount());\n-        } else {\n-            if (_outputTail >= _outputEnd) {\n-                _flushBuffer();\n-            }\n-            _outputBuffer[_outputTail++] = BYTE_RBRACKET;\n-        }\n-        _writeContext = _writeContext.getParent();\n-    }\n-\n-    @Override\n-    public final void writeStartObject() throws IOException, JsonGenerationException\n-    {\n-        _verifyValueWrite(\"start an object\");\n-        _writeContext = _writeContext.createChildObjectContext();\n-        if (_cfgPrettyPrinter != null) {\n-            _cfgPrettyPrinter.writeStartObject(this);\n-        } else {\n-            if (_outputTail >= _outputEnd) {\n-                _flushBuffer();\n-            }\n-            _outputBuffer[_outputTail++] = BYTE_LCURLY;\n-        }\n-    }\n-\n-    @Override\n-    public final void writeEndObject() throws IOException, JsonGenerationException\n-    {\n-        if (!_writeContext.inObject()) {\n-            _reportError(\"Current context not an object but \"+_writeContext.getTypeDesc());\n-        }\n-        if (_cfgPrettyPrinter != null) {\n-            _cfgPrettyPrinter.writeEndObject(this, _writeContext.getEntryCount());\n-        } else {\n-            if (_outputTail >= _outputEnd) {\n-                _flushBuffer();\n-            }\n-            _outputBuffer[_outputTail++] = BYTE_RCURLY;\n-        }\n-        _writeContext = _writeContext.getParent();\n-    }\n-\n     protected final void _writeFieldName(String name)\n         throws IOException, JsonGenerationException\n     {\n         /* To support [JACKSON-46], we'll do this:\n          * (Question: should quoting of spaces (etc) still be enabled?)\n          */\n-        if (!isEnabled(Feature.QUOTE_FIELD_NAMES)) {\n+        if (!_cfgQuoteNames) {\n             _writeStringSegments(name);\n             return;\n         }\n         }\n         _outputBuffer[_outputTail++] = BYTE_QUOTE;\n     }\n+    \n+    @Override\n+    public void writeFieldName(SerializableString name)\n+        throws IOException, JsonGenerationException\n+    {\n+        // Object is a value, need to verify it's allowed\n+        int status = _writeContext.writeFieldName(name.getValue());\n+        if (status == JsonWriteContext.STATUS_EXPECT_VALUE) {\n+            _reportError(\"Can not write a field name, expecting a value\");\n+        }\n+        if (_cfgPrettyPrinter != null) {\n+            _writePPFieldName(name, (status == JsonWriteContext.STATUS_OK_AFTER_COMMA));\n+            return;\n+        }\n+        if (status == JsonWriteContext.STATUS_OK_AFTER_COMMA) {\n+            if (_outputTail >= _outputEnd) {\n+                _flushBuffer();\n+            }\n+            _outputBuffer[_outputTail++] = BYTE_COMMA;\n+        }\n+        _writeFieldName(name);\n+    }\n \n     protected final void _writeFieldName(SerializableString name)\n         throws IOException, JsonGenerationException\n     {\n-        if (!isEnabled(Feature.QUOTE_FIELD_NAMES)) {\n+        if (!_cfgQuoteNames) {\n             int len = name.appendQuotedUTF8(_outputBuffer, _outputTail); // different quoting (escaping)\n             if (len < 0) {\n                 _writeBytes(name.asQuotedUTF8());\n         }\n         _outputBuffer[_outputTail++] = BYTE_QUOTE;\n     }    \n-    \n+\n+    /*\n+    /**********************************************************\n+    /* Output method implementations, structural\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public final void writeStartArray() throws IOException, JsonGenerationException\n+    {\n+        _verifyValueWrite(\"start an array\");\n+        _writeContext = _writeContext.createChildArrayContext();\n+        if (_cfgPrettyPrinter != null) {\n+            _cfgPrettyPrinter.writeStartArray(this);\n+        } else {\n+            if (_outputTail >= _outputEnd) {\n+                _flushBuffer();\n+            }\n+            _outputBuffer[_outputTail++] = BYTE_LBRACKET;\n+        }\n+    }\n+\n+    @Override\n+    public final void writeEndArray() throws IOException, JsonGenerationException\n+    {\n+        if (!_writeContext.inArray()) {\n+            _reportError(\"Current context not an ARRAY but \"+_writeContext.getTypeDesc());\n+        }\n+        if (_cfgPrettyPrinter != null) {\n+            _cfgPrettyPrinter.writeEndArray(this, _writeContext.getEntryCount());\n+        } else {\n+            if (_outputTail >= _outputEnd) {\n+                _flushBuffer();\n+            }\n+            _outputBuffer[_outputTail++] = BYTE_RBRACKET;\n+        }\n+        _writeContext = _writeContext.getParent();\n+    }\n+\n+    @Override\n+    public final void writeStartObject() throws IOException, JsonGenerationException\n+    {\n+        _verifyValueWrite(\"start an object\");\n+        _writeContext = _writeContext.createChildObjectContext();\n+        if (_cfgPrettyPrinter != null) {\n+            _cfgPrettyPrinter.writeStartObject(this);\n+        } else {\n+            if (_outputTail >= _outputEnd) {\n+                _flushBuffer();\n+            }\n+            _outputBuffer[_outputTail++] = BYTE_LCURLY;\n+        }\n+    }\n+\n+    @Override\n+    public final void writeEndObject() throws IOException, JsonGenerationException\n+    {\n+        if (!_writeContext.inObject()) {\n+            _reportError(\"Current context not an object but \"+_writeContext.getTypeDesc());\n+        }\n+        if (_cfgPrettyPrinter != null) {\n+            _cfgPrettyPrinter.writeEndObject(this, _writeContext.getEntryCount());\n+        } else {\n+            if (_outputTail >= _outputEnd) {\n+                _flushBuffer();\n+            }\n+            _outputBuffer[_outputTail++] = BYTE_RCURLY;\n+        }\n+        _writeContext = _writeContext.getParent();\n+    }\n+\n     /**\n      * Specialized version of <code>_writeFieldName</code>, off-lined\n      * to keep the \"fast path\" as simple (and hopefully fast) as possible.\n             _cfgPrettyPrinter.beforeObjectEntries(this);\n         }\n \n-        if (isEnabled(Feature.QUOTE_FIELD_NAMES)) { // standard\n+        if (_cfgQuoteNames) { // standard\n             if (_outputTail >= _outputEnd) {\n                 _flushBuffer();\n             }\n             _cfgPrettyPrinter.beforeObjectEntries(this);\n         }\n \n-        boolean addQuotes = isEnabled(Feature.QUOTE_FIELD_NAMES); // standard\n+        final boolean addQuotes = _cfgQuoteNames; // standard\n         if (addQuotes) {\n             if (_outputTail >= _outputEnd) {\n                 _flushBuffer();\n         _outputTail = NumberOutput.outputInt(s, _outputBuffer, _outputTail);\n     }\n     \n-    private void _writeQuotedShort(short s) throws IOException {\n+    private final void _writeQuotedShort(short s) throws IOException {\n         if ((_outputTail + 8) >= _outputEnd) {\n             _flushBuffer();\n         }\n         _outputTail = NumberOutput.outputInt(i, _outputBuffer, _outputTail);\n     }\n \n-    private void _writeQuotedInt(int i) throws IOException {\n+    private final void _writeQuotedInt(int i) throws IOException\n+    {\n         if ((_outputTail + 13) >= _outputEnd) {\n             _flushBuffer();\n         }\n         _outputTail = NumberOutput.outputLong(l, _outputBuffer, _outputTail);\n     }\n \n-    private void _writeQuotedLong(long l) throws IOException {\n+    private final void _writeQuotedLong(long l) throws IOException\n+    {\n         if ((_outputTail + 23) >= _outputEnd) {\n             _flushBuffer();\n         }\n         }\n     }\n \n-    private void _writeQuotedRaw(Object value) throws IOException\n+    private final void _writeQuotedRaw(Object value) throws IOException\n     {\n         if (_outputTail >= _outputEnd) {\n             _flushBuffer();\n      */\n \n     @Override\n-    public final void flush()\n+    public void flush()\n         throws IOException\n     {\n         _flushBuffer();\n      * Same as <code>_writeStringSegmentASCII2(char[], ...)</code., but with\n      * additional checking for completely custom escapes\n      */\n-    private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end)\n+    private final void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end)\n         throws IOException, JsonGenerationException\n     {\n         // Ok: caller guarantees buffer can have room; but that may require flushing:\n         _outputTail = outputPtr;\n     }\n \n-    private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars)\n+    private final int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars)\n         throws IOException, JsonGenerationException\n     {\n         byte[] raw = esc.asUnquotedUTF8(); // must be escaped at this point, shouldn't double-quote\n         return (outputPtr + len);\n     }\n     \n-    private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw,\n+    private final int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw,\n             int remainingChars)\n         throws IOException, JsonGenerationException\n     {\n      * to fit in the output buffer after escaping; as such, we just need to\n      * chunk writes.\n      */\n-    private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen)\n+    private final void _writeUTF8Segments(byte[] utf8, int offset, int totalLen)\n         throws IOException, JsonGenerationException\n     {\n         do {\n         } while (totalLen > 0);\n     }\n     \n-    private void _writeUTF8Segment(byte[] utf8, final int offset, final int len)\n+    private final void _writeUTF8Segment(byte[] utf8, final int offset, final int len)\n         throws IOException, JsonGenerationException\n     {\n         // fast loop to see if escaping is needed; don't copy, just look\n         _outputTail += len;\n     }\n \n-    private void _writeUTF8Segment2(final byte[] utf8, int offset, int len)\n+    private final void _writeUTF8Segment2(final byte[] utf8, int offset, int len)\n         throws IOException, JsonGenerationException\n     {\n         int outputPtr = _outputTail;\n     /**********************************************************\n      */\n     \n-    protected void _writeBinary(Base64Variant b64variant,\n+    protected final void _writeBinary(Base64Variant b64variant,\n             byte[] input, int inputPtr, final int inputEnd)\n         throws IOException, JsonGenerationException\n     {\n     }\n \n     // write-method called when length is definitely known\n-    protected int _writeBinary(Base64Variant b64variant,\n+    protected final int _writeBinary(Base64Variant b64variant,\n             InputStream data, byte[] readBuffer, int bytesLeft)\n         throws IOException, JsonGenerationException\n     {\n     }\n \n     // write method when length is unknown\n-    protected int _writeBinary(Base64Variant b64variant,\n+    protected final int _writeBinary(Base64Variant b64variant,\n             InputStream data, byte[] readBuffer)\n         throws IOException, JsonGenerationException\n     {\n         return bytesDone;\n     }\n     \n-    private int _readMore(InputStream in,\n+    private final int _readMore(InputStream in,\n             byte[] readBuffer, int inputPtr, int inputEnd,\n             int maxRead) throws IOException\n     {\n      * 1- and 2-byte UTF-8 encodings, when outputting \"raw\" \n      * text (meaning it is not to be escaped or quoted)\n      */\n-    private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen)\n+    private final int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen)\n         throws IOException\n     {\n         // Let's handle surrogates gracefully (as 4 byte output):\n      * \n      * @throws IOException\n      */\n-    private int _outputMultiByteChar(int ch, int outputPtr)\n+    private final int _outputMultiByteChar(int ch, int outputPtr)\n         throws IOException\n     {\n         byte[] bbuf = _outputBuffer;\n         return c;\n     }\n     \n-    private void _writeNull() throws IOException\n+    private final void _writeNull() throws IOException\n     {\n         if ((_outputTail + 4) >= _outputEnd) {\n             _flushBuffer();\n--- a/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java\n /**\n  * This is a concrete implementation of {@link JsonParser}, which is\n  * based on a {@link java.io.InputStream} as the input source.\n+ *<p>\n+ * Note: non-final since version 2.3.\n  */\n-public final class UTF8StreamJsonParser\n+public class UTF8StreamJsonParser\n     extends ParserBase\n {\n     final static byte BYTE_LF = (byte) '\\n';\n         _inputBuffer = inputBuffer;\n         _inputPtr = start;\n         _inputEnd = end;\n+        _currInputRowStart = start;\n+        // If we have offset, need to omit that from byte offset, so:\n+        _currInputProcessed = -start;\n         _bufferRecyclable = bufferRecyclable;\n     }\n \n     \n     /*\n     /**********************************************************\n-    /* Overrides\n+    /* Overrides for life-cycle\n     /**********************************************************\n      */\n \n     \n     /*\n     /**********************************************************\n-    /* Low-level reading, other\n+    /* Overrides, low-level reading\n     /**********************************************************\n      */\n \n     @Override\n-    protected boolean loadMore()\n+    protected final boolean loadMore()\n         throws IOException\n     {\n         _currInputProcessed += _inputEnd;\n      * Helper method that will try to load at least specified number bytes in\n      * input buffer, possible moving existing data around if necessary\n      */\n-    protected boolean _loadToHaveAtLeast(int minAvailable)\n+    protected final boolean _loadToHaveAtLeast(int minAvailable)\n         throws IOException\n     {\n         // No input stream, no leading (either we are closed, or have non-stream input source)\n         return super.getValueAsString(defValue);\n     }\n     \n-    protected String _getText2(JsonToken t)\n+    protected final String _getText2(JsonToken t)\n     {\n         if (t == null) {\n             return null;\n         return outputCount;\n     }\n \n+    // As per [Issue#108], must ensure we call the right method\n+    @Override\n+    public JsonLocation getTokenLocation()\n+    {\n+        return new JsonLocation(_ioContext.getSourceReference(),\n+                getTokenCharacterOffset(), -1L, // bytes, chars\n+                getTokenLineNr(),\n+                getTokenColumnNr());\n+    }\n+\n+    // As per [Issue#108], must ensure we call the right method\n+    @Override\n+    public JsonLocation getCurrentLocation()\n+    {\n+        int col = _inputPtr - _currInputRowStart + 1; // 1-based\n+        return new JsonLocation(_ioContext.getSourceReference(),\n+                _currInputProcessed + _inputPtr, -1L, // bytes, chars\n+                _currInputRow, col);\n+    }\n+    \n     /*\n     /**********************************************************\n     /* Public API, traversal, basic\n         return _currToken;\n     }\n \n-    private JsonToken _nextTokenNotInObject(int i)\n+    private final JsonToken _nextTokenNotInObject(int i)\n         throws IOException, JsonParseException\n     {\n         if (i == INT_QUOTE) {\n         return (_currToken = _handleUnexpectedValue(i));\n     }\n     \n-    private JsonToken _nextAfterName()\n+    private final JsonToken _nextAfterName()\n     {\n         _nameCopied = false; // need to invalidate if it was copied\n         JsonToken t = _nextToken;\n         return _isNextTokenNameMaybe(i, str);\n     }\n \n-    private void _isNextTokenNameYes()\n+    private final void _isNextTokenNameYes()\n         throws IOException, JsonParseException\n     {\n         // very first thing: common case, colon, value, no white space\n         _nextToken = _handleUnexpectedValue(i);\n     }\n     \n-    private boolean _isNextTokenNameMaybe(int i, SerializableString str)\n+    private final boolean _isNextTokenNameMaybe(int i, SerializableString str)\n         throws IOException, JsonParseException\n     {\n         // // // and this is back to standard nextToken()\n      * Method called to handle parsing when input is split across buffer boundary\n      * (or output is longer than segment used to store it)\n      */\n-    private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative,\n+    private final JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative,\n             int intPartLength)\n         throws IOException, JsonParseException\n     {\n      * Method called when we have seen one zero, and want to ensure\n      * it is not followed by another\n      */\n-    private int _verifyNoLeadingZeroes()\n+    private final int _verifyNoLeadingZeroes()\n         throws IOException, JsonParseException\n     {\n         // Ok to have plain \"0\"\n         return ch;\n     }\n     \n-    private JsonToken _parseFloat(char[] outBuf, int outPtr, int c,\n+    private final JsonToken _parseFloat(char[] outBuf, int outPtr, int c,\n             boolean negative, int integerPartLength)\n         throws IOException, JsonParseException\n     {\n         return parseEscapedName(_quadBuffer, 0, 0, i, 0);\n     }\n \n-    private Name parseName(int q1, int ch, int lastQuadBytes) throws IOException\n+    private final Name parseName(int q1, int ch, int lastQuadBytes) throws IOException\n     {\n         return parseEscapedName(_quadBuffer, 0, q1, ch, lastQuadBytes);\n     }\n \n-    private Name parseName(int q1, int q2, int ch, int lastQuadBytes) throws IOException\n+    private final Name parseName(int q1, int q2, int ch, int lastQuadBytes) throws IOException\n     {\n         _quadBuffer[0] = q1;\n         return parseEscapedName(_quadBuffer, 1, q2, ch, lastQuadBytes);\n     /**********************************************************\n      */\n \n-    private Name findName(int q1, int lastQuadBytes)\n+    private final Name findName(int q1, int lastQuadBytes)\n         throws JsonParseException\n     {\n         // Usually we'll find it from the canonical symbol table already\n         return addName(_quadBuffer, 1, lastQuadBytes);\n     }\n \n-    private Name findName(int q1, int q2, int lastQuadBytes)\n+    private final Name findName(int q1, int q2, int lastQuadBytes)\n         throws JsonParseException\n     {\n         // Usually we'll find it from the canonical symbol table already\n         return addName(_quadBuffer, 2, lastQuadBytes);\n     }\n \n-    private Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes)\n+    private final Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes)\n         throws JsonParseException\n     {\n         if (qlen >= quads.length) {\n      * multi-byte chars (if any), and then construct Name instance\n      * and add it to the symbol table.\n      */\n-    private Name addName(int[] quads, int qlen, int lastQuadBytes)\n+    private final Name addName(int[] quads, int qlen, int lastQuadBytes)\n         throws JsonParseException\n     {\n         /* Ok: must decode UTF-8 chars. No other validation is\n         _finishString2(outBuf, outPtr);\n     }\n \n-    private void _finishString2(char[] outBuf, int outPtr)\n+    private final void _finishString2(char[] outBuf, int outPtr)\n         throws IOException\n     {\n         int c;\n         if (Character.isJavaIdentifierPart(c)) {\n             _reportInvalidToken(matchStr.substring(0, i));\n         }\n-    }\n-\n-    protected void _reportInvalidToken(String matchedPart)\n-       throws IOException\n-    {\n-        _reportInvalidToken(matchedPart, \"'null', 'true', 'false' or NaN\");\n-    }\n-    \n-    protected void _reportInvalidToken(String matchedPart, String msg)\n-        throws IOException\n-    {\n-        StringBuilder sb = new StringBuilder(matchedPart);\n-\n-        /* Let's just try to find what appears to be the token, using\n-         * regular Java identifier character rules. It's just a heuristic,\n-         * nothing fancy here (nor fast).\n-         */\n-        while (true) {\n-            if (_inputPtr >= _inputEnd && !loadMore()) {\n-                break;\n-            }\n-            int i = (int) _inputBuffer[_inputPtr++];\n-            char c = (char) _decodeCharForError(i);\n-            if (!Character.isJavaIdentifierPart(c)) {\n-                break;\n-            }\n-            sb.append(c);\n-        }\n-        _reportError(\"Unrecognized token '\"+sb.toString()+\"': was expecting \"+msg);\n     }\n \n     /*\n         throw _constructError(\"Unexpected end-of-input within/between \"+_parsingContext.getTypeDesc()+\" entries\");\n     }\n \n-    private int _skipWSOrEnd() throws IOException\n+    private final int _skipWSOrEnd() throws IOException\n     {\n         final int[] codes = _icWS;\n         while ((_inputPtr < _inputEnd) || loadMore()) {\n      * Helper method for matching and skipping a colon character,\n      * optionally surrounded by white space\n      */\n-    private int _skipColon() throws IOException\n+    private final int _skipColon() throws IOException\n     {\n         if (_inputPtr >= _inputEnd) {\n             loadMoreGuaranteed();\n         throw _constructError(\"Unexpected end-of-input within/between \"+_parsingContext.getTypeDesc()+\" entries\");\n     }\n     \n-    private void _skipComment() throws IOException\n+    private final void _skipComment() throws IOException\n     {\n         if (!isEnabled(Feature.ALLOW_COMMENTS)) {\n             _reportUnexpectedChar('/', \"maybe a (non-standard) comment? (not recognized as one since Feature 'ALLOW_COMMENTS' not enabled for parser)\");\n         }\n     }\n \n-    private void _skipCComment() throws IOException\n+    private final void _skipCComment() throws IOException\n     {\n         // Need to be UTF-8 aware here to decode content (for skipping)\n         final int[] codes = CharTypes.getInputCodeComment();\n         _reportInvalidEOF(\" in a comment\");\n     }\n \n-    private boolean _skipYAMLComment() throws IOException\n+    private final boolean _skipYAMLComment() throws IOException\n     {\n         if (!isEnabled(Feature.ALLOW_YAML_COMMENTS)) {\n             return false;\n      * Method for skipping contents of an input line; usually for CPP\n      * and YAML style comments.\n      */\n-    private void _skipLine() throws IOException\n+    private final void _skipLine() throws IOException\n     {\n         // Ok: need to find EOF or linefeed\n         final int[] codes = CharTypes.getInputCodeComment();\n     /**********************************************************\n      */\n \n-    private int _decodeUtf8_2(int c) throws IOException\n+    private final int _decodeUtf8_2(int c) throws IOException\n     {\n         if (_inputPtr >= _inputEnd) {\n             loadMoreGuaranteed();\n         return ((c & 0x1F) << 6) | (d & 0x3F);\n     }\n \n-    private int _decodeUtf8_3(int c1) throws IOException\n+    private final int _decodeUtf8_3(int c1) throws IOException\n     {\n         if (_inputPtr >= _inputEnd) {\n             loadMoreGuaranteed();\n         return c;\n     }\n \n-    private int _decodeUtf8_3fast(int c1) throws IOException\n+    private final int _decodeUtf8_3fast(int c1) throws IOException\n     {\n         c1 &= 0x0F;\n         int d = (int) _inputBuffer[_inputPtr++];\n      * @return Character value <b>minus 0x10000</c>; this so that caller\n      *    can readily expand it to actual surrogates\n      */\n-    private int _decodeUtf8_4(int c) throws IOException\n+    private final int _decodeUtf8_4(int c) throws IOException\n     {\n         if (_inputPtr >= _inputEnd) {\n             loadMoreGuaranteed();\n         return ((c << 6) | (d & 0x3F)) - 0x10000;\n     }\n \n-    private void _skipUtf8_2(int c) throws IOException\n+    private final void _skipUtf8_2(int c) throws IOException\n     {\n         if (_inputPtr >= _inputEnd) {\n             loadMoreGuaranteed();\n     /* Alas, can't heavily optimize skipping, since we still have to\n      * do validity checks...\n      */\n-    private void _skipUtf8_3(int c) throws IOException\n+    private final void _skipUtf8_3(int c) throws IOException\n     {\n         if (_inputPtr >= _inputEnd) {\n             loadMoreGuaranteed();\n         }\n     }\n \n-    private void _skipUtf8_4(int c) throws IOException\n+    private final void _skipUtf8_4(int c) throws IOException\n     {\n         if (_inputPtr >= _inputEnd) {\n             loadMoreGuaranteed();\n      * We actually need to check the character value here\n      * (to see if we have \\n following \\r).\n      */\n-    protected void _skipCR() throws IOException\n+    protected final void _skipCR() throws IOException\n     {\n         if (_inputPtr < _inputEnd || loadMore()) {\n             if (_inputBuffer[_inputPtr] == BYTE_LF) {\n     /**********************************************************\n      */\n \n+    protected void _reportInvalidToken(String matchedPart) throws IOException\n+     {\n+         _reportInvalidToken(matchedPart, \"'null', 'true', 'false' or NaN\");\n+     }\n+\n+    protected void _reportInvalidToken(String matchedPart, String msg) throws IOException\n+     {\n+         StringBuilder sb = new StringBuilder(matchedPart);\n+\n+         /* Let's just try to find what appears to be the token, using\n+          * regular Java identifier character rules. It's just a heuristic,\n+          * nothing fancy here (nor fast).\n+          */\n+         while (true) {\n+             if (_inputPtr >= _inputEnd && !loadMore()) {\n+                 break;\n+             }\n+             int i = (int) _inputBuffer[_inputPtr++];\n+             char c = (char) _decodeCharForError(i);\n+             if (!Character.isJavaIdentifierPart(c)) {\n+                 break;\n+             }\n+             sb.append(c);\n+         }\n+         _reportError(\"Unrecognized token '\"+sb.toString()+\"': was expecting \"+msg);\n+     }\n+        \n     protected void _reportInvalidChar(int c)\n         throws JsonParseException\n     {\n      * textual content.\n      */\n     @SuppressWarnings(\"resource\")\n-    protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException\n+    protected final byte[] _decodeBase64(Base64Variant b64variant) throws IOException\n     {\n         ByteArrayBuilder builder = _getByteArrayBuilder();\n \n--- a/src/test/java/com/fasterxml/jackson/core/json/TestJsonParser.java\n+++ b/src/test/java/com/fasterxml/jackson/core/json/TestJsonParser.java\n         JsonParser jp = jf.createParser(bytes.toByteArray());\n         assertEquals(JsonToken.START_ARRAY, jp.nextToken());\n         // should also have skipped first 3 bytes of BOM; but do we have offset available?\n-        /*\n+        /* 08-Oct-2013, tatu: Alas, due to [Issue#111], we have to omit BOM in calculations\n+         *   as we do not know what the offset is due to -- may need to revisit, if this\n+         *   discrepancy becomes an issue. For now it just means that BOM is considered\n+         *   \"out of stream\" (not part of input).\n+         */\n         JsonLocation loc = jp.getTokenLocation();\n-        assertEquals(3, loc.getByteOffset());\n+        // so if BOM was consider in-stream (part of input), this should expect 3:\n+        assertEquals(0, loc.getByteOffset());\n         assertEquals(-1, loc.getCharOffset());\n-        */\n-        jp.close();\n-    }\n-\n+        jp.close();\n+    }\n \n     // [Issue#48]\n     public void testSpacesInURL() throws Exception\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/core/json/TestLocation.java\n+package com.fasterxml.jackson.core.json;\n+\n+import com.fasterxml.jackson.core.*;\n+\n+// NOTE: just a stub so for, fill me!\n+public class TestLocation extends com.fasterxml.jackson.test.BaseTest\n+{\n+    // Trivially simple unit test for basics wrt offsets\n+    public void testSimpleInitialOffsets() throws Exception\n+    {\n+        final JsonFactory f = new JsonFactory();\n+        JsonLocation loc;\n+        JsonParser p;\n+        final String DOC = \"{ }\";\n+\n+        // first, char based:\n+        p = f.createParser(DOC);\n+        assertToken(JsonToken.START_OBJECT, p.nextToken());\n+\n+        loc = p.getTokenLocation();\n+        assertEquals(-1L, loc.getByteOffset());\n+        assertEquals(0L, loc.getCharOffset());\n+        assertEquals(1, loc.getLineNr());\n+        assertEquals(1, loc.getColumnNr());\n+        \n+        loc = p.getCurrentLocation();\n+        assertEquals(-1L, loc.getByteOffset());\n+        assertEquals(1L, loc.getCharOffset());\n+        assertEquals(1, loc.getLineNr());\n+        assertEquals(2, loc.getColumnNr());\n+\n+        p.close();\n+\n+        // then byte-based\n+        \n+        p = f.createParser(DOC.getBytes(\"UTF-8\"));\n+        assertToken(JsonToken.START_OBJECT, p.nextToken());\n+\n+        loc = p.getTokenLocation();\n+        assertEquals(0L, loc.getByteOffset());\n+        assertEquals(-1L, loc.getCharOffset());\n+        assertEquals(1, loc.getLineNr());\n+        assertEquals(1, loc.getColumnNr());\n+        \n+        loc = p.getCurrentLocation();\n+        assertEquals(1L, loc.getByteOffset());\n+        assertEquals(-1L, loc.getCharOffset());\n+        assertEquals(1, loc.getLineNr());\n+        assertEquals(2, loc.getColumnNr());\n+\n+        p.close();\n+    }\n+\n+    // for [Issue#111]\n+    public void testOffsetWithInputOffset() throws Exception\n+    {\n+        final JsonFactory f = new JsonFactory();\n+        JsonLocation loc;\n+        JsonParser p;\n+        // 3 spaces before, 2 after, just for padding\n+        byte[] b = \"   { }  \".getBytes(\"UTF-8\");\n+\n+        // and then peel them off\n+        p = f.createParser(b, 3, b.length-5);\n+        assertToken(JsonToken.START_OBJECT, p.nextToken());\n+\n+        loc = p.getTokenLocation();\n+        assertEquals(0L, loc.getByteOffset());\n+        assertEquals(-1L, loc.getCharOffset());\n+        assertEquals(1, loc.getLineNr());\n+        assertEquals(1, loc.getColumnNr());\n+        \n+        loc = p.getCurrentLocation();\n+        assertEquals(1L, loc.getByteOffset());\n+        assertEquals(-1L, loc.getCharOffset());\n+        assertEquals(1, loc.getLineNr());\n+        assertEquals(2, loc.getColumnNr());\n+\n+        p.close();\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/core/json/TestRootValues.java\n+package com.fasterxml.jackson.core.json;\n+\n+import java.io.*;\n+\n+import com.fasterxml.jackson.core.*;\n+\n+public class TestRootValues\n+    extends com.fasterxml.jackson.test.BaseTest\n+{\n+    private final JsonFactory JSON_F = new JsonFactory();\n+\n+    public void testSimpleNumbers() throws Exception\n+    {\n+        _testSimpleNumbers(false);\n+        _testSimpleNumbers(true);\n+    }\n+\n+    private void _testSimpleNumbers(boolean useStream) throws Exception\n+    {\n+        final String DOC = \"1 2\\t3\\r4\\n5\\r\\n6\\r\\n   7\";\n+        JsonParser jp = useStream ?\n+                createParserUsingStream(JSON_F, DOC, \"UTF-8\")\n+                : createParserUsingReader(JSON_F, DOC);\n+        for (int i = 1; i <= 7; ++i) {\n+            assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n+            assertEquals(i, jp.getIntValue());\n+        }\n+        assertNull(jp.nextToken());\n+        jp.close();\n+    }\n+\n+    public void testSimpleBooleans() throws Exception\n+    {\n+        _testSimpleBooleans(false);\n+        _testSimpleBooleans(true);\n+    }\n+\n+    private void _testSimpleBooleans(boolean useStream) throws Exception\n+    {\n+        final String DOC = \"true false\\ttrue\\rfalse\\ntrue\\r\\nfalse\\r\\n   true\";\n+        JsonParser jp = useStream ?\n+                createParserUsingStream(JSON_F, DOC, \"UTF-8\")\n+                : createParserUsingReader(JSON_F, DOC);\n+        boolean exp = true;\n+        for (int i = 1; i <= 7; ++i) {\n+            assertToken(exp ? JsonToken.VALUE_TRUE : JsonToken.VALUE_FALSE, jp.nextToken());\n+            exp = !exp;\n+        }\n+        assertNull(jp.nextToken());\n+        jp.close();\n+    }\n+\n+    public void testSimpleWrites() throws Exception\n+    {\n+        _testSimpleWrites(false);\n+        _testSimpleWrites(true);\n+    }\n+\n+    public void _testSimpleWrites(boolean useStream) throws Exception\n+    {\n+        ByteArrayOutputStream out = new ByteArrayOutputStream();\n+        StringWriter w = new StringWriter();\n+        JsonGenerator gen;\n+\n+        if (useStream) {\n+            gen = JSON_F.createGenerator(out, JsonEncoding.UTF8);\n+        } else {\n+            gen = JSON_F.createGenerator(w);\n+        }\n+        gen.writeNumber(123);\n+        gen.writeString(\"abc\");\n+        gen.writeBoolean(true);\n+        \n+        gen.close();\n+        out.close();\n+        w.close();\n+\n+        // and verify\n+        String json = useStream ? out.toString(\"UTF-8\") : w.toString();\n+        assertEquals(\"123 \\\"abc\\\" true\", json);\n+    }\n+}\n--- a/src/test/java/com/fasterxml/jackson/core/json/TestUtf8Generator.java\n+++ b/src/test/java/com/fasterxml/jackson/core/json/TestUtf8Generator.java\n \n import java.io.ByteArrayOutputStream;\n \n-import com.fasterxml.jackson.core.JsonGenerator;\n-import com.fasterxml.jackson.core.json.UTF8JsonGenerator;\n+import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.core.io.IOContext;\n import com.fasterxml.jackson.core.util.BufferRecycler;\n import com.fasterxml.jackson.test.BaseTest;\n         gen.writeString(str);\n         gen.flush();\n         gen.close();\n+        \n+        // Also verify it's parsable?\n+        JsonFactory f = new JsonFactory();\n+        JsonParser p = f.createParser(bytes.toByteArray());\n+        for (int i = 1; i <= length; ++i) {\n+            assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());\n+            assertEquals(1, p.getIntValue());\n+        }\n+        assertToken(JsonToken.VALUE_STRING, p.nextToken());\n+        assertEquals(str, p.getText());\n+        assertNull(p.nextToken());\n+        p.close();\n     }\n }", "timestamp": 1383449422, "metainfo": ""}