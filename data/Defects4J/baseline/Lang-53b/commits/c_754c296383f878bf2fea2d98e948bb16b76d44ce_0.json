{"sha": "754c296383f878bf2fea2d98e948bb16b76d44ce", "log": "Rewrite internal implementation, fix bugs, improve tests  ", "commit": "\n--- a/src/java/org/apache/commons/lang/text/StrTokenizer.java\n+++ b/src/java/org/apache/commons/lang/text/StrTokenizer.java\n import java.util.ArrayList;\n import java.util.List;\n import java.util.ListIterator;\n+import java.util.NoSuchElementException;\n \n import org.apache.commons.lang.ArrayUtils;\n \n  * Each token is separated from the next String by a <i>delimiter</i>.\n  * One or more delimiter characters must be specified.\n  * <p>\n- * The processing then strips all the <i>ignored</i> characters from then entire string (this\n- * is useful for removing things like carriage returns, and so forth)\n+ * Each token may be surrounded by quotes.\n+ * The <i>quote</i> matcher specifies the quote character(s).\n+ * A quote may be escaped within a quoted section by duplicating itself.\n  * <p>\n- * The processing then strips all the <i>trimmer</i> characters from the ends of the string.\n+ * Between each token and the delimiter are potentially characters that need trimming.\n+ * The <i>trimmer</i> matcher specifies these characters.\n+ * One usage might be to trim whitespace characters.\n  * <p>\n- * The token may also have <i>quotes</i> to mark an area not to be stripped or tokenized.\n+ * At any point outside the quotes there might potentially be invalid characters.\n+ * The <i>ignored</i> matcher specifies these characters to be removed.\n+ * One usage might be to remove new line characters.\n+ * <p>\n  * Empty tokens may be removed or returned as null.\n  * <pre>\n- * \"a,b,c\"       - Three tokens \"a\",\"b\",\"c\"   (comma delimiter)\n+ * \"a,b,c\"         - Three tokens \"a\",\"b\",\"c\"   (comma delimiter)\n  * \" a, b , c \"    - Three tokens \"a\",\"b\",\"c\"   (default CSV processing trims whitespace)\n  * \"a, \", b ,\", c\" - Three tokens \"a, \" , \" b \", \", c\" (quoted text untouched)\n  * </pre>\n      * @return the next String token\n      */\n     public Object next() {\n-        return nextToken();\n+        if (hasNext()) {\n+            return tokens[tokenPos++];\n+        }\n+        throw new NoSuchElementException();\n     }\n \n     /**\n      * @return the previous token\n      */\n     public Object previous() {\n-        return previousToken();\n+        if (hasPrevious()) {\n+            return tokens[--tokenPos];\n+        }\n+        throw new NoSuchElementException();\n     }\n \n     /**\n             return ArrayUtils.EMPTY_STRING_ARRAY;\n         }\n         int len = chars.length;\n-        char cbuf[] = new char[len];\n-        StringBuffer token = new StringBuffer();\n+        if (len == 0) {\n+            return ArrayUtils.EMPTY_STRING_ARRAY;\n+        }\n+        StrBuilder buf = new StrBuilder();\n+        List tokens = new ArrayList();\n         int start = 0;\n-        List tokens = new ArrayList();\n-        String tok = null;\n-\n-        // Keep going until we run out of characters\n-        while (start < len) {\n-            // read the next token\n-            start = readNextToken(start, cbuf, token);\n-            tok = token.toString();\n-\n-            // Add the token, following the rules\n-            // in this object\n-            addToken(tokens, tok);\n-\n-            // Reset the string buffer to zero length\n-            token.setLength(0);\n-\n-            // Handle the special case where the very last\n-            // character is a delimiter, in which case, we\n-            // need another empty string\n-            if (start == len && delim.isMatch(chars, start - 1, 0, len) == 1) {\n-                // Add the token, following the rules\n-                // in this object\n+        \n+        // loop around the entire buffer\n+        while (start >= 0 && start < len) {\n+            // find next token\n+            start = readNextToken(chars, start, len, buf, tokens);\n+            \n+            // handle case where end of string is a delimiter\n+            if (start >= len) {\n                 addToken(tokens, \"\");\n             }\n         }\n-\n         return (String[]) tokens.toArray(new String[tokens.size()]);\n     }\n \n     /**\n      * Reads character by character through the String to get the next token.\n      *\n+     * @param chars  the character array being tokenized\n      * @param start  the first character of field\n-     * @param cbuf  a character buffer for temporary computations (so we\n-     *  don't have to keep recreating one)\n-     * @param token  a StringBuffer where the output token will go\n+     * @param len  the length of the character array being tokenized\n+     * @param workArea  a temporary work area\n+     * @param tokens  the list of parsed tokens\n+     * @return the starting position of the next field (the character\n+     *  immediately after the delimiter), or -1 if end of string found\n+     */\n+    private int readNextToken(char[] chars, int start, int len, StrBuilder workArea, List tokens) {\n+        // skip all leading whitespace, unless it is the\n+        // field delimiter or the quote character\n+        while (start < len) {\n+            int removeLen = Math.max(\n+                    ignored.isMatch(chars, start, start, len),\n+                    trimmer.isMatch(chars, start, start, len));\n+            if (removeLen == 0 ||\n+                delim.isMatch(chars, start, start, len) > 0 ||\n+                quote.isMatch(chars, start, start, len) > 0) {\n+                break;\n+            }\n+            start += removeLen;\n+        }\n+        \n+        // handle reaching end\n+        if (start >= len) {\n+            addToken(tokens, \"\");\n+            return -1;\n+        }\n+        \n+        // handle empty token\n+        int delimLen = delim.isMatch(chars, start, start, len);\n+        if (delimLen > 0) {\n+            addToken(tokens, \"\");\n+            return start + delimLen;\n+        }\n+        \n+        // handle found token\n+        int quoteLen = quote.isMatch(chars, start, start, len);\n+        if (quoteLen > 0) {\n+            return readWithQuotes(chars, start + quoteLen, len, workArea, tokens, start, quoteLen);\n+        }\n+        return readWithQuotes(chars, start, len, workArea, tokens, 0, 0);\n+    }\n+\n+    /**\n+     * Reads a possibly quoted string token.\n+     *\n+     * @param chars  the character array being tokenized\n+     * @param start  the first character of field\n+     * @param len  the length of the character array being tokenized\n+     * @param workArea  a temporary work area\n+     * @param tokens  the list of parsed tokens\n+     * @param quoteStart  the start position of the matched quote, 0 if no quoting\n+     * @param quoteLen  the length of the matched quote, 0 if no quoting\n      * @return the starting position of the next field (the character\n      *  immediately after the delimiter, or if end of string found,\n      *  then the length of string\n      */\n-    private int readNextToken(int start, char cbuf[], StringBuffer token) {\n-        token.setLength(0);\n-        int len = chars.length;\n-\n-        // Skip all leading whitespace, unless it is the\n-        // field delimiter or the quote character\n-        int ignoreLen = 0;\n-        int delimLen = 0;\n-        int quoteLen = 0;\n-        while (start < len &&\n-                (ignoreLen = ignored.isMatch(chars, start, 0, len)) >= 1 &&\n-                (delimLen = delim.isMatch(chars, start, 0, len)) < 1 &&\n-                (quoteLen = quote.isMatch(chars, start, 0, len)) < 1) {\n-            start += ignoreLen;\n-        }\n-\n-        if (start >= len) {\n-            return start;\n-        } else {\n-            // lengths not setup\n-            if ((delimLen = delim.isMatch(chars, start, 0, len)) >= 1) {\n-                start += delimLen;\n-            } else if ((quoteLen = quote.isMatch(chars, start, 0, len)) >= 1) {\n-                start = readQuoted(start + quoteLen, cbuf, token);\n-            } else {\n-                start = readUnquoted(start, token);\n-            }\n-        }\n-//\n-//            // lengths not setup\n-//            if ((delimLen = delim.isMatch(chars, start)) >= 1) {\n-//                start += delimLen;\n-//            } else if ((quoteLen = quote.isMatch(chars, start)) >= 1) {\n-//                start = readQuoted(start + quoteLen, cbuf, token);\n-//            } else {\n-//                start = readUnquoted(start, token);\n-//            }\n-//        } else {\n-//            if (delimLen > 0) {\n-//                start += delimLen;\n-//            } else if (quoteLen >= 1) {\n-//                start = readQuoted(start + quoteLen, cbuf, token);\n-//            } else {\n-//                start = readUnquoted(start, token);\n-//            }\n-//        }\n-\n-        return start;\n-    }\n-\n-    /**\n-     * Reads a quoted string token.\n-     *\n-     * @param start The first character of field, immediately after any quote\n-     * @param cbuf A character buffer for temporary computations (so we\n-     *             don't have to keep recreating one)\n-     * @param token A StringBuffer where the output token will go.\n-     * @return The starting position of the next field (the character\n-     *         immediately after the delimiter, or if end of string found,\n-     *         then the length of string.\n-     */\n-    private int readQuoted(int start, char cbuf[], StringBuffer token) {\n+    private int readWithQuotes(char[] chars, int start, int len, StrBuilder workArea, List tokens, int quoteStart, int quoteLen) {\n         // Loop until we've found the end of the quoted\n         // string or the end of the input\n-        int cbufcnt = 0;\n+        workArea.clear();\n         int pos = start;\n-        boolean done = false;\n-        boolean quoting = true;\n-        int len = chars.length;\n-        int delimLen = 0;\n-        int quoteLen = 0;\n-\n-        while (pos < len && !done) {\n-            // Quoting mode can occur several times throughout\n-            // a given string, so must switch between quoting\n-            // and non-quoting until we encounter a non-quoted\n-            // delimiter, or end of string, which indicates end\n-            // of token.\n+        boolean quoting = (quoteLen > 0);\n+        int trimStart = 0;\n+        \n+        while (pos < len) {\n+            // quoting mode can occur several times throughout a string\n+            // we must switch between quoting and non-quoting until we\n+            // encounter a non-quoted delimiter, or end of string\n             if (quoting) {\n+                // In quoting mode\n+                \n                 // If we've found a quote character, see if it's\n                 // followed by a second quote.  If so, then we need\n                 // to actually put the quote character into the token\n                 // rather than end the token.\n-                if ((quoteLen = quote.isMatch(chars, pos, 0, len)) >= 1) {\n-                    if (pos + 1 < len && chars[pos + 1] == chars[pos]) {\n-                        cbuf[cbufcnt++] = chars[pos];\n-                        pos += 2;\n-                    } else {\n-                        // End the quoting if we get to this condition\n-                        quoting = false;\n-                        pos += quoteLen;\n+                if (isQuote(chars, pos, len, quoteStart, quoteLen)) {\n+                    if (isQuote(chars, pos + quoteLen, len, quoteStart, quoteLen)) {\n+                        // matched pair of quotes, thus an escaped quote\n+                        workArea.append(chars, pos, quoteLen);\n+                        pos += (quoteLen * 2);\n+                        trimStart = workArea.size();\n+                        continue;\n                     }\n-                } else {\n-                    // Otherwise, just put the character into the token\n-                    cbuf[cbufcnt++] = chars[pos];\n-                    pos++;\n+                    \n+                    // end of quoting\n+                    quoting = false;\n+                    pos += quoteLen;\n+                    continue;\n                 }\n-            }\n-            // If we're not in quoting mode, if we encounter\n-            // a delimiter, the token is ended.  If we encounter\n-            // a quote, we start quoting mode, otherwise, just append\n-            // the character\n-            else {\n-                // If we're\n-                if ((delimLen = delim.isMatch(chars, pos, 0, len)) >= 1) {\n-                    done = true;\n-                } else {\n-                    if ((quoteLen = quote.isMatch(chars, pos, 0, len)) >= 1) {\n+                \n+                // copy regular character from inside quotes\n+                workArea.append(chars[pos++]);\n+                trimStart = workArea.size();\n+                \n+            } else {\n+                // Not in quoting mode\n+                \n+                // check for delimiter, and thus end of token\n+                int delimLen = delim.isMatch(chars, pos, start, len);\n+                if (delimLen > 0) {\n+                    // return condition when end of token found\n+                    addToken(tokens, workArea.substring(0, trimStart));\n+                    return pos + delimLen;\n+                }\n+                \n+                // check for quote, and thus back into quoting mode\n+                if (quoteLen > 0) {\n+                    if (isQuote(chars, pos, len, quoteStart, quoteLen)) {\n                         quoting = true;\n                         pos += quoteLen;\n-                    } else {\n-                        cbuf[cbufcnt++] = chars[pos];\n-                        pos++;\n+                        continue;\n                     }\n                 }\n+                \n+                // check for ignored (outside quotes), and ignore\n+                int ignoredLen = ignored.isMatch(chars, pos, start, len);\n+                if (ignoredLen > 0) {\n+                    pos += ignoredLen;\n+                    continue;\n+                }\n+                \n+                // check for trimmed character\n+                // don't yet know if its at the end, so copy to workArea\n+                // use trimStart to keep track of trim at the end\n+                int trimmedLen = trimmer.isMatch(chars, pos, start, len);\n+                if (trimmedLen > 0) {\n+                    workArea.append(chars, pos, trimmedLen);\n+                    pos += trimmedLen;\n+                    continue;\n+                }\n+                \n+                // copy regular character from outside quotes\n+                workArea.append(chars[pos++]);\n+                trimStart = workArea.size();\n             }\n         }\n-\n-        token.append(cbuf, 0, cbufcnt);\n-\n-        return pos + delimLen;\n-    }\n-\n-    /**\n-     * Read an unquoted string until a delimiter is found.\n-     *\n-     * @param start  the first character of field\n-     * @param token  a StringBuffer where the output token will go.\n-     * @return  the starting position of the next field (the character\n-     *  immediately after the delimiter, or if end of string found,\n-     *  then the length of string.\n-     */\n-    private int readUnquoted(int start, StringBuffer token) {\n-        // Find delimiter or end of string\n-        char[] chars = this.chars;\n-        int len = chars.length;\n-        int pos = start;\n-        int delimLen = 0;\n-        while (pos < len && (delimLen = delim.isMatch(chars, pos, 0, len)) < 1) {\n-            pos++;\n-        }\n-\n-        /* Trim string based on the trimmer matcher */\n-        while (trimmer.isMatch(chars, start, 0, len) > 0) {\n-            start++;\n-        }\n-\n-        int length = Math.min(pos, len) - start;\n-\n-        while (trimmer.isMatch(chars, start + length - 1, 0, len) > 0) {\n-            length--;\n-        }\n-\n-        for (int i=0;i<length;i++) {\n-            if (ignored.isMatch(chars, start + i, 0, len) == 0) {\n-                token.append(chars[start + i]);\n+        \n+        // return condition when end of string found\n+        addToken(tokens, workArea.substring(0, trimStart));\n+        return -1;\n+    }\n+\n+    /**\n+     * Checks if the characters at the index specified match the quote\n+     * already matched in readNextToken().\n+     *\n+     * @param chars  the character array being tokenized\n+     * @param pos  the position to check for a quote\n+     * @param len  the length of the character array being tokenized\n+     * @param quoteStart  the start position of the matched quote, 0 if no quoting\n+     * @param quoteLen  the length of the matched quote, 0 if no quoting\n+     * @return true if a quote is matched\n+     */\n+    private boolean isQuote(char[] chars, int pos, int len, int quoteStart, int quoteLen) {\n+        for (int i = 0; i < quoteLen; i++) {\n+            if ((pos + i) >= len || chars[pos + i] != chars[quoteStart + i]) {\n+                return false;\n             }\n         }\n-\n-\n-        return pos + delimLen;\n+        return true;\n     }\n \n     // Delimiter\n     /**\n      * Gets the trimmer character matcher.\n      * <p>\n-     * These characters are trimmed off the beginning and ending of an unquoted string.\n+     * These characters are trimmed off on each side of the delimiter\n+     * until the token or quote is found.\n      * The default value is not to trim anything.\n      *\n      * @return the trimmer matcher in use\n     }\n \n     /**\n-     * Set the matcher for characters to trim off the beginning and end of an\n-     * unquoted string.\n+     * Sets the matcher for characters to trim.\n+     * <p>\n+     * These characters are trimmed off on each side of the delimiter\n+     * until the token or quote is found.\n      *\n      * @param trimmer  the trimmer matcher to use, null ignored\n      * @return this, to enable chaining\n     public Object clone() {\n         try {\n             StrTokenizer cloned = (StrTokenizer) super.clone();\n-            cloned.chars = (char[]) cloned.chars;\n+            if (cloned.chars != null) {\n+                cloned.chars = (char[]) cloned.chars;\n+            }\n             cloned.reset();\n             return cloned;\n \n--- a/src/test/org/apache/commons/lang/text/StrTokenizerTest.java\n+++ b/src/test/org/apache/commons/lang/text/StrTokenizerTest.java\n \n package org.apache.commons.lang.text;\n \n+import java.util.NoSuchElementException;\n+\n import junit.framework.Test;\n import junit.framework.TestCase;\n import junit.framework.TestSuite;\n import junit.textui.TestRunner;\n \n+import org.apache.commons.lang.ArrayUtils;\n import org.apache.commons.lang.ObjectUtils;\n \n /**\n     // -----------------------------------------------------------------------\n     public void test1() {\n \n-        String input = \"a;b;c;\\\"d;\\\"\\\"e\\\";f; ; ;\";\n+        String input = \"a;b;c;\\\"d;\\\"\\\"e\\\";f; ; ;  \";\n         StrTokenizer tok = new StrTokenizer(input);\n         tok.setDelimiterChar(';');\n         tok.setQuoteChar('\"');\n \n         String expected[] = new String[]{\"a\", \"b\", \"c\", \"d;\\\"e\", \"f\", \"\", \"\", \"\",};\n \n-        assertTrue(tokens.length == expected.length);\n+        assertEquals(ArrayUtils.toString(tokens), expected.length, tokens.length);\n         for (int i = 0; i < expected.length; i++) {\n             assertTrue(\"token[\" + i + \"] was '\" + tokens[i] + \"' but was expected to be '\" + expected[i] + \"'\",\n                     ObjectUtils.equals(expected[i], tokens[i]));\n \n         String expected[] = new String[]{\"a\", \"b\", \"c \", \"d;\\\"e\", \"f\", \" \", \" \", \"\",};\n \n-        assertTrue(tokens.length == expected.length);\n+        assertEquals(ArrayUtils.toString(tokens), expected.length, tokens.length);\n         for (int i = 0; i < expected.length; i++) {\n             assertTrue(\"token[\" + i + \"] was '\" + tokens[i] + \"' but was expected to be '\" + expected[i] + \"'\",\n                     ObjectUtils.equals(expected[i], tokens[i]));\n \n         String expected[] = new String[]{\"a\", \"b\", \" c\", \"d;\\\"e\", \"f\", \" \", \" \", \"\",};\n \n-        assertTrue(tokens.length == expected.length);\n+        assertEquals(ArrayUtils.toString(tokens), expected.length, tokens.length);\n         for (int i = 0; i < expected.length; i++) {\n             assertTrue(\"token[\" + i + \"] was '\" + tokens[i] + \"' but was expected to be '\" + expected[i] + \"'\",\n                     ObjectUtils.equals(expected[i], tokens[i]));\n \n         String expected[] = new String[]{\"a\", \"b\", \"c\", \"d;\\\"e\", \"f\",};\n \n-        assertTrue(tokens.length == expected.length);\n+        assertEquals(ArrayUtils.toString(tokens), expected.length, tokens.length);\n         for (int i = 0; i < expected.length; i++) {\n             assertTrue(\"token[\" + i + \"] was '\" + tokens[i] + \"' but was expected to be '\" + expected[i] + \"'\",\n                     ObjectUtils.equals(expected[i], tokens[i]));\n \n         String expected[] = new String[]{\"a\", \"b\", \"c\", \"d;\\\"e\", \"f\", null, null, null,};\n \n-        assertTrue(tokens.length == expected.length);\n+        assertEquals(ArrayUtils.toString(tokens), expected.length, tokens.length);\n         for (int i = 0; i < expected.length; i++) {\n             assertTrue(\"token[\" + i + \"] was '\" + tokens[i] + \"' but was expected to be '\" + expected[i] + \"'\",\n                     ObjectUtils.equals(expected[i], tokens[i]));\n             prevCount++;\n         }\n \n-        assertTrue(tokens.length == expected.length);\n+        assertEquals(ArrayUtils.toString(tokens), expected.length, tokens.length);\n \n         assertTrue(\"could not cycle through entire token list\" + \" using the 'hasNext' and 'next' methods\",\n                 nextCount == expected.length);\n \n         String expected[] = new String[]{\"a\", \"\", \"\", \"b\", \"c\", \"d e\", \"f\", \"\",};\n \n-        assertTrue(tokens.length == expected.length);\n+        assertEquals(ArrayUtils.toString(tokens), expected.length, tokens.length);\n         for (int i = 0; i < expected.length; i++) {\n             assertTrue(\"token[\" + i + \"] was '\" + tokens[i] + \"' but was expected to be '\" + expected[i] + \"'\",\n                     ObjectUtils.equals(expected[i], tokens[i]));\n \n         String expected[] = new String[]{\"a\", \"b\", \"c\", \"d e\", \"f\",};\n \n-        assertTrue(tokens.length == expected.length);\n+        assertEquals(ArrayUtils.toString(tokens), expected.length, tokens.length);\n         for (int i = 0; i < expected.length; i++) {\n             assertTrue(\"token[\" + i + \"] was '\" + tokens[i] + \"' but was expected to be '\" + expected[i] + \"'\",\n                     ObjectUtils.equals(expected[i], tokens[i]));\n         assertEquals(\"a\", tok.next());\n         assertEquals(\"b\", tok.next());\n         assertEquals(\"c\", tok.next());\n+        assertEquals(false, tok.hasNext());\n     }\n \n     public void testBasic2() {\n         assertEquals(\"a\", tok.next());\n         assertEquals(\"b\", tok.next());\n         assertEquals(\"c\", tok.next());\n+        assertEquals(false, tok.hasNext());\n     }\n \n     public void testBasic3() {\n         assertEquals(\"a\", tok.next());\n         assertEquals(\"b\\u0001\", tok.next());\n         assertEquals(\"c\", tok.next());\n+        assertEquals(false, tok.hasNext());\n     }\n \n     public void testBasic4() {\n         assertEquals(\"a\", tok.next());\n         assertEquals(\"\\\"b\\\"\", tok.next());\n         assertEquals(\"c\", tok.next());\n+        assertEquals(false, tok.hasNext());\n+    }\n+\n+    public void testBasic5() {\n+        String input = \"a:b':c\";\n+        StrTokenizer tok = new StrTokenizer(input, ':', '\\'');\n+        assertEquals(\"a\", tok.next());\n+        assertEquals(\"b'\", tok.next());\n+        assertEquals(\"c\", tok.next());\n+        assertEquals(false, tok.hasNext());\n     }\n \n     public void testBasicDelim1() {\n         assertEquals(\"a\", tok.next());\n         assertEquals(\"b\", tok.next());\n         assertEquals(\"c\", tok.next());\n+        assertEquals(false, tok.hasNext());\n     }\n \n     public void testBasicDelim2() {\n         String input = \"a:b:c\";\n         StrTokenizer tok = new StrTokenizer(input, ',');\n         assertEquals(\"a:b:c\", tok.next());\n+        assertEquals(false, tok.hasNext());\n     }\n \n     public void testBasicEmpty1() {\n         assertEquals(\"\", tok.next());\n         assertEquals(\"b\", tok.next());\n         assertEquals(\"c\", tok.next());\n+        assertEquals(false, tok.hasNext());\n     }\n \n     public void testBasicEmpty2() {\n         assertEquals(null, tok.next());\n         assertEquals(\"b\", tok.next());\n         assertEquals(\"c\", tok.next());\n+        assertEquals(false, tok.hasNext());\n     }\n \n     public void testBasicQuoted1() {\n-        String input = \"a \\\"b\\\" c\";\n-        StrTokenizer tok = new StrTokenizer(input, ' ', '\"');\n-        assertEquals(\"a\", tok.next());\n-        assertEquals(\"b\", tok.next());\n-        assertEquals(\"c\", tok.next());\n-    }\n-\n+        String input = \"a 'b' c\";\n+        StrTokenizer tok = new StrTokenizer(input, ' ', '\\'');\n+        assertEquals(\"a\", tok.next());\n+        assertEquals(\"b\", tok.next());\n+        assertEquals(\"c\", tok.next());\n+        assertEquals(false, tok.hasNext());\n+    }\n+\n+    public void testBasicQuoted2() {\n+        String input = \"a:'b':\";\n+        StrTokenizer tok = new StrTokenizer(input, ':', '\\'');\n+        tok.setIgnoreEmptyTokens(false);\n+        tok.setEmptyTokenAsNull(true);\n+        assertEquals(\"a\", tok.next());\n+        assertEquals(\"b\", tok.next());\n+        assertEquals(null, tok.next());\n+        assertEquals(false, tok.hasNext());\n+    }\n+\n+    public void testBasicQuoted3() {\n+        String input = \"a:'b''c'\";\n+        StrTokenizer tok = new StrTokenizer(input, ':', '\\'');\n+        tok.setIgnoreEmptyTokens(false);\n+        tok.setEmptyTokenAsNull(true);\n+        assertEquals(\"a\", tok.next());\n+        assertEquals(\"b'c\", tok.next());\n+        assertEquals(false, tok.hasNext());\n+    }\n+\n+    public void testBasicQuoted4() {\n+        String input = \"a: 'b' 'c' :d\";\n+        StrTokenizer tok = new StrTokenizer(input, ':', '\\'');\n+        tok.setTrimmerMatcher(StrMatcher.trimMatcher());\n+        tok.setIgnoreEmptyTokens(false);\n+        tok.setEmptyTokenAsNull(true);\n+        assertEquals(\"a\", tok.next());\n+        assertEquals(\"b c\", tok.next());\n+        assertEquals(\"d\", tok.next());\n+        assertEquals(false, tok.hasNext());\n+    }\n+\n+    public void testBasicQuoted5() {\n+        String input = \"a: 'b'x'c' :d\";\n+        StrTokenizer tok = new StrTokenizer(input, ':', '\\'');\n+        tok.setTrimmerMatcher(StrMatcher.trimMatcher());\n+        tok.setIgnoreEmptyTokens(false);\n+        tok.setEmptyTokenAsNull(true);\n+        assertEquals(\"a\", tok.next());\n+        assertEquals(\"bxc\", tok.next());\n+        assertEquals(\"d\", tok.next());\n+        assertEquals(false, tok.hasNext());\n+    }\n+\n+    public void testBasicQuoted6() {\n+        String input = \"a:'b'\\\"c':d\";\n+        StrTokenizer tok = new StrTokenizer(input, ':');\n+        tok.setQuoteMatcher(StrMatcher.quoteMatcher());\n+        assertEquals(\"a\", tok.next());\n+        assertEquals(\"b\\\"c:d\", tok.next());\n+        assertEquals(false, tok.hasNext());\n+    }\n+\n+    public void testBasicQuoted7() {\n+        String input = \"a:\\\"There's a reason here\\\":b\";\n+        StrTokenizer tok = new StrTokenizer(input, ':');\n+        tok.setQuoteMatcher(StrMatcher.quoteMatcher());\n+        assertEquals(\"a\", tok.next());\n+        assertEquals(\"There's a reason here\", tok.next());\n+        assertEquals(\"b\", tok.next());\n+        assertEquals(false, tok.hasNext());\n+    }\n+\n+    public void testBasicQuotedTrimmed1() {\n+        String input = \"a: 'b' :\";\n+        StrTokenizer tok = new StrTokenizer(input, ':', '\\'');\n+        tok.setTrimmerMatcher(StrMatcher.trimMatcher());\n+        tok.setIgnoreEmptyTokens(false);\n+        tok.setEmptyTokenAsNull(true);\n+        assertEquals(\"a\", tok.next());\n+        assertEquals(\"b\", tok.next());\n+        assertEquals(null, tok.next());\n+        assertEquals(false, tok.hasNext());\n+    }\n+\n+    public void testBasicTrimmed1() {\n+        String input = \"a: b :  \";\n+        StrTokenizer tok = new StrTokenizer(input, ':');\n+        tok.setTrimmerMatcher(StrMatcher.trimMatcher());\n+        tok.setIgnoreEmptyTokens(false);\n+        tok.setEmptyTokenAsNull(true);\n+        assertEquals(\"a\", tok.next());\n+        assertEquals(\"b\", tok.next());\n+        assertEquals(null, tok.next());\n+        assertEquals(false, tok.hasNext());\n+    }\n+\n+    public void testBasicTrimmed2() {\n+        String input = \"a:  b  :\";\n+        StrTokenizer tok = new StrTokenizer(input, ':');\n+        tok.setTrimmerMatcher(StrMatcher.stringMatcher(\"  \"));\n+        tok.setIgnoreEmptyTokens(false);\n+        tok.setEmptyTokenAsNull(true);\n+        assertEquals(\"a\", tok.next());\n+        assertEquals(\"b\", tok.next());\n+        assertEquals(null, tok.next());\n+        assertEquals(false, tok.hasNext());\n+    }\n+\n+    public void testBasicIgnoreTrimmed1() {\n+        String input = \"a: bIGNOREc : \";\n+        StrTokenizer tok = new StrTokenizer(input, ':');\n+        tok.setIgnoredMatcher(StrMatcher.stringMatcher(\"IGNORE\"));\n+        tok.setTrimmerMatcher(StrMatcher.trimMatcher());\n+        tok.setIgnoreEmptyTokens(false);\n+        tok.setEmptyTokenAsNull(true);\n+        assertEquals(\"a\", tok.next());\n+        assertEquals(\"bc\", tok.next());\n+        assertEquals(null, tok.next());\n+        assertEquals(false, tok.hasNext());\n+    }\n+\n+    public void testBasicIgnoreTrimmed2() {\n+        String input = \"IGNOREaIGNORE: IGNORE bIGNOREc IGNORE : IGNORE \";\n+        StrTokenizer tok = new StrTokenizer(input, ':');\n+        tok.setIgnoredMatcher(StrMatcher.stringMatcher(\"IGNORE\"));\n+        tok.setTrimmerMatcher(StrMatcher.trimMatcher());\n+        tok.setIgnoreEmptyTokens(false);\n+        tok.setEmptyTokenAsNull(true);\n+        assertEquals(\"a\", tok.next());\n+        assertEquals(\"bc\", tok.next());\n+        assertEquals(null, tok.next());\n+        assertEquals(false, tok.hasNext());\n+    }\n+\n+    public void testBasicIgnoreTrimmed3() {\n+        String input = \"IGNOREaIGNORE: IGNORE bIGNOREc IGNORE : IGNORE \";\n+        StrTokenizer tok = new StrTokenizer(input, ':');\n+        tok.setIgnoredMatcher(StrMatcher.stringMatcher(\"IGNORE\"));\n+        tok.setIgnoreEmptyTokens(false);\n+        tok.setEmptyTokenAsNull(true);\n+        assertEquals(\"a\", tok.next());\n+        assertEquals(\"  bc  \", tok.next());\n+        assertEquals(\"  \", tok.next());\n+        assertEquals(false, tok.hasNext());\n+    }\n+\n+    public void testBasicIgnoreTrimmed4() {\n+        String input = \"IGNOREaIGNORE: IGNORE 'bIGNOREc'IGNORE'd' IGNORE : IGNORE \";\n+        StrTokenizer tok = new StrTokenizer(input, ':', '\\'');\n+        tok.setIgnoredMatcher(StrMatcher.stringMatcher(\"IGNORE\"));\n+        tok.setTrimmerMatcher(StrMatcher.trimMatcher());\n+        tok.setIgnoreEmptyTokens(false);\n+        tok.setEmptyTokenAsNull(true);\n+        assertEquals(\"a\", tok.next());\n+        assertEquals(\"bIGNOREcd\", tok.next());\n+        assertEquals(null, tok.next());\n+        assertEquals(false, tok.hasNext());\n+    }\n+\n+    //-----------------------------------------------------------------------\n     public void testCSV(String data) {\n         this.testXSVAbc(StrTokenizer.getCSVInstance(data));\n         this.testXSVAbc(StrTokenizer.getCSVInstance(data.toCharArray()));\n         this.checkClone(tokenizer);\n         assertEquals(false, tokenizer.hasNext());\n         assertEquals(false, tokenizer.hasPrevious());\n-        assertEquals(null, tokenizer.next());\n         assertEquals(null, tokenizer.nextToken());\n         assertEquals(0, tokenizer.size());\n+        try {\n+            tokenizer.next();\n+            fail();\n+        } catch (NoSuchElementException ex) {}\n     }\n \n     public void testGetContent() {\n \n     public void testIteration() {\n         StrTokenizer tkn = new StrTokenizer(\"a b c\");\n+        assertEquals(false, tkn.hasPrevious());\n+        try {\n+            tkn.previous();\n+            fail();\n+        } catch (NoSuchElementException ex) {}\n         assertEquals(true, tkn.hasNext());\n+        \n         assertEquals(\"a\", tkn.next());\n         try {\n             tkn.remove();\n             tkn.add(\"y\");\n             fail();\n         } catch (UnsupportedOperationException ex) {}\n+        assertEquals(true, tkn.hasPrevious());\n         assertEquals(true, tkn.hasNext());\n+        \n         assertEquals(\"b\", tkn.next());\n+        assertEquals(true, tkn.hasPrevious());\n         assertEquals(true, tkn.hasNext());\n+        \n         assertEquals(\"c\", tkn.next());\n+        assertEquals(true, tkn.hasPrevious());\n         assertEquals(false, tkn.hasNext());\n+        \n+        try {\n+            tkn.next();\n+            fail();\n+        } catch (NoSuchElementException ex) {}\n+        assertEquals(true, tkn.hasPrevious());\n+        assertEquals(false, tkn.hasNext());\n     }\n \n }", "timestamp": 1124568908, "metainfo": ""}