{"sha": "e794af9688ae2dee664864be0d128df9a88509ba", "log": "A thread-safe, faster version of java.text's DateFormat. While JODA contains better, this version is religion-free.  Permission given by Brian S O'Neill: http://archives.apache.org/eyebrowse/ReadMsg?listName=commons-dev@jakarta.apache.org&msgNo=20612  Submitted by:\tSean Schofield   ", "commit": "\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang/time/FastDateFormat.java\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2002 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.lang.time;\n+\n+import java.util.Date;\n+import java.util.Calendar;\n+import java.util.GregorianCalendar;\n+import java.util.Locale;\n+import java.util.TimeZone;\n+import java.util.List;\n+import java.util.ArrayList;\n+import java.util.Map;\n+import java.util.HashMap;\n+import java.text.DateFormatSymbols;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+\n+/******************************************************************************\n+ * Similar to {@link java.text.SimpleDateFormat}, but faster and thread-safe.\n+ * Only formatting is supported, but all patterns are compatible with\n+ * SimpleDateFormat. [Code originally taken from the open source TreeTrove\n+ * project.]\n+ *\n+ * @author Brian S O'Neill\n+ * @author Sean Schofield\n+ * @since 2.0\n+ * @version $Id: FastDateFormat.java,v 1.1 2003/01/07 19:55:55 bayard Exp $\n+ */\n+public class FastDateFormat {\n+    /** Style pattern */\n+    public static final Object\n+        FULL = new Integer(SimpleDateFormat.FULL),\n+        LONG = new Integer(SimpleDateFormat.LONG),\n+        MEDIUM = new Integer(SimpleDateFormat.MEDIUM),\n+        SHORT = new Integer(SimpleDateFormat.SHORT);\n+\n+    private static final double LOG_10 = Math.log(10);\n+\n+    private static String cDefaultPattern;\n+    private static TimeZone cDefaultTimeZone = TimeZone.getDefault();\n+\n+    private static Map cTimeZoneDisplayCache = new HashMap();\n+\n+    private static Map cInstanceCache = new HashMap(7);\n+    private static Map cDateInstanceCache = new HashMap(7);\n+    private static Map cTimeInstanceCache = new HashMap(7);\n+    private static Map cDateTimeInstanceCache = new HashMap(7);\n+\n+    public static FastDateFormat getInstance() {\n+        //return getInstance(getDefaultPattern(), null, null, null);\n+        return getInstance(getDefaultPattern(), null, null);\n+    }\n+\n+    /**\n+     * @param pattern {@link java.text.SimpleDateFormat} compatible pattern\n+     */\n+    public static FastDateFormat getInstance(String pattern) {\n+        //return getInstance(pattern, null, null, null);\n+        return getInstance(pattern, null, null);\n+    }\n+\n+    /**\n+     * @param pattern {@link java.text.SimpleDateFormat} compatible pattern\n+     * @param timeZone optional time zone, overrides time zone of formatted\n+     * date\n+     */\n+    public static FastDateFormat getInstance(String pattern, TimeZone timeZone) {\n+        //return getInstance(pattern, timeZone, null, null);\n+        return getInstance(pattern, timeZone, null);\n+    }\n+\n+    /**\n+     * @param pattern {@link java.text.SimpleDateFormat} compatible pattern\n+     * @param locale optional locale, overrides system locale\n+     */\n+    public static FastDateFormat getInstance(String pattern, Locale locale) {\n+        //return getInstance(pattern, null, locale, null);\n+        return getInstance(pattern, null, locale);\n+    }\n+\n+    /**\n+     * @param pattern {@link java.text.SimpleDateFormat} compatible pattern\n+     * @param symbols optional date format symbols, overrides symbols for\n+     * system locale\n+     */\n+    /*\n+    public static FastDateFormat getInstance\n+        (String pattern, DateFormatSymbols symbols)\n+        throws IllegalArgumentException\n+    {\n+        return getInstance(pattern, null, null, symbols);\n+    }\n+    */\n+\n+    /**\n+     * @param pattern {@link java.text.SimpleDateFormat} compatible pattern\n+     * @param timeZone optional time zone, overrides time zone of formatted\n+     * date\n+     * @param locale optional locale, overrides system locale\n+     */\n+    public static FastDateFormat getInstance(String pattern, TimeZone timeZone, Locale locale) {\n+        //return getInstance(pattern, timeZone, locale, null);\n+        Object key = pattern;\n+\n+        if (timeZone != null) {\n+            key = new Pair(key, timeZone);\n+        }\n+        if (locale != null) {\n+            key = new Pair(key, locale);\n+        }\n+\n+        FastDateFormat format = (FastDateFormat)cInstanceCache.get(key);\n+        if (format == null) {\n+            if (locale == null) {\n+                locale = Locale.getDefault();\n+            }\n+\n+            format = new FastDateFormat(pattern, timeZone, locale, new DateFormatSymbols(locale));\n+            cInstanceCache.put(key, format);\n+        }\n+        return format;\n+    }\n+\n+    /**\n+     * @param pattern {@link java.text.SimpleDateFormat} compatible pattern\n+     * @param timeZone optional time zone, overrides time zone of formatted\n+     * date\n+     * @param locale optional locale, overrides system locale\n+     * @param symbols optional date format symbols, overrides symbols for\n+     * provided locale\n+     */\n+    /*\n+    public static synchronized FastDateFormat getInstance\n+        (String pattern, TimeZone timeZone, Locale locale,\n+         DateFormatSymbols symbols)\n+        throws IllegalArgumentException\n+    {\n+        Object key = pattern;\n+\n+        if (timeZone != null) {\n+            key = new Pair(key, timeZone);\n+        }\n+        if (locale != null) {\n+            key = new Pair(key, locale);\n+        }\n+        if (symbols != null) {\n+            key = new Pair(key, symbols);\n+        }\n+\n+        FastDateFormat format = (FastDateFormat)cInstanceCache.get(key);\n+        if (format == null) {\n+            if (locale == null) {\n+                locale = Locale.getDefault();\n+            }\n+            if (symbols == null) {\n+                symbols = new DateFormatSymbols(locale);\n+            }\n+            format = new FastDateFormat(pattern, timeZone, locale, symbols);\n+            cInstanceCache.put(key, format);\n+        }\n+        return format;\n+    }\n+    */\n+\n+    /**\n+     * @param style date style: FULL, LONG, MEDIUM, or SHORT (corresponds to those in java.text.DateFormat)\n+     * @param timeZone optional time zone, overrides time zone of formatted\n+     * date\n+     * @param locale optional locale, overrides system locale\n+     */\n+    public static synchronized FastDateFormat getDateInstance(int style, TimeZone timeZone, Locale locale) {\n+        Object key = new Integer(style);\n+\n+        if (timeZone != null) {\n+            key = new Pair(key, timeZone);\n+        }\n+        if (locale == null) {\n+            key = new Pair(key, locale);\n+        }\n+\n+        FastDateFormat format = (FastDateFormat)cDateInstanceCache.get(key);\n+\n+        if (format == null) {\n+            if (locale == null) {\n+                locale = Locale.getDefault();\n+            }\n+\n+            try {\n+                String pattern = ((SimpleDateFormat)DateFormat.getDateInstance(style, locale)).toPattern();\n+                format = getInstance(pattern, timeZone, locale);\n+                cDateInstanceCache.put(key, format);\n+            }\n+            catch (ClassCastException e) {\n+                throw new IllegalArgumentException\n+                    (\"No date pattern for locale: \" + locale);\n+            }\n+        }\n+\n+        return format;\n+    }\n+\n+    /**\n+     * @param style time style: FULL, LONG, MEDIUM, or SHORT\n+     * @param timeZone optional time zone, overrides time zone of formatted\n+     * date\n+     * @param locale optional locale, overrides system locale\n+     */\n+    public static synchronized FastDateFormat getTimeInstance(int style, TimeZone timeZone, Locale locale) {\n+        Object key = new Integer(style);\n+\n+        if (timeZone != null) {\n+            key = new Pair(key, timeZone);\n+        }\n+        if (locale != null) {\n+            key = new Pair(key, locale);\n+        }\n+\n+        FastDateFormat format = (FastDateFormat)cTimeInstanceCache.get(key);\n+\n+        if (format == null) {\n+\n+            if (locale == null) {\n+                locale = Locale.getDefault();\n+            }\n+\n+            try {\n+                String pattern = ((SimpleDateFormat)DateFormat.getTimeInstance(style, locale)).toPattern();\n+                format = getInstance(pattern, timeZone, locale);\n+                cTimeInstanceCache.put(key, format);\n+            }\n+            catch (ClassCastException e) {\n+                throw new IllegalArgumentException\n+                    (\"No date pattern for locale: \" + locale);\n+            }\n+        }\n+\n+        return format;\n+    }\n+\n+    /**\n+     * @param dateStyle date style: FULL, LONG, MEDIUM, or SHORT\n+     * @param timeStyle time style: FULL, LONG, MEDIUM, or SHORT\n+     * @param timeZone optional time zone, overrides time zone of formatted\n+     * date\n+     * @param locale optional locale, overrides system locale\n+     */\n+    public static synchronized FastDateFormat getDateTimeInstance(Object dateStyle, Object timeStyle,\n+            TimeZone timeZone, Locale locale) {\n+\n+        Object key = new Pair(dateStyle, timeStyle);\n+\n+        if (timeZone != null) {\n+            key = new Pair(key, timeZone);\n+        }\n+        if (locale != null) {\n+            key = new Pair(key, locale);\n+        }\n+\n+        FastDateFormat format =\n+            (FastDateFormat)cDateTimeInstanceCache.get(key);\n+\n+        if (format == null) {\n+            int ds;\n+            try {\n+                ds = ((Integer)dateStyle).intValue();\n+            }\n+            catch (ClassCastException e) {\n+                throw new IllegalArgumentException\n+                    (\"Illegal date style: \" + dateStyle);\n+            }\n+\n+            int ts;\n+            try {\n+                ts = ((Integer)timeStyle).intValue();\n+            }\n+            catch (ClassCastException e) {\n+                throw new IllegalArgumentException\n+                    (\"Illegal time style: \" + timeStyle);\n+            }\n+\n+            if (locale == null) {\n+                locale = Locale.getDefault();\n+            }\n+\n+            try {\n+                String pattern = ((SimpleDateFormat)DateFormat.getDateTimeInstance(ds, ts, locale)).toPattern();\n+                format = getInstance(pattern, timeZone, locale);\n+                cDateTimeInstanceCache.put(key, format);\n+            }\n+            catch (ClassCastException e) {\n+                throw new IllegalArgumentException\n+                    (\"No date time pattern for locale: \" + locale);\n+            }\n+        }\n+\n+        return format;\n+    }\n+\n+    static synchronized String getTimeZoneDisplay(TimeZone tz, boolean daylight, int style, Locale locale) {\n+        Object key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n+        String value = (String)cTimeZoneDisplayCache.get(key);\n+        if (value == null) {\n+            // This is a very slow call, so cache the results.\n+            value = tz.getDisplayName(daylight, style, locale);\n+            cTimeZoneDisplayCache.put(key, value);\n+        }\n+        return value;\n+    }\n+\n+    private static synchronized String getDefaultPattern() {\n+        if (cDefaultPattern == null) {\n+            cDefaultPattern = new SimpleDateFormat().toPattern();\n+        }\n+        return cDefaultPattern;\n+    }\n+\n+    /**\n+     * Returns a list of Rules.\n+     */\n+    private static List parse(String pattern, TimeZone timeZone, Locale locale, DateFormatSymbols symbols) {\n+        List rules = new ArrayList();\n+\n+        String[] ERAs = symbols.getEras();\n+        String[] months = symbols.getMonths();\n+        String[] shortMonths = symbols.getShortMonths();\n+        String[] weekdays = symbols.getWeekdays();\n+        String[] shortWeekdays = symbols.getShortWeekdays();\n+        String[] AmPmStrings = symbols.getAmPmStrings();\n+\n+        int length = pattern.length();\n+        int[] indexRef = new int[1];\n+\n+        for (int i=0; i<length; i++) {\n+            indexRef[0] = i;\n+            String token = parseToken(pattern, indexRef);\n+            i = indexRef[0];\n+\n+            int tokenLen = token.length();\n+            if (tokenLen == 0) {\n+                break;\n+            }\n+\n+            Rule rule;\n+            char c = token.charAt(0);\n+\n+            switch (c) {\n+            case 'G': // era designator (text)\n+                rule = new TextField(Calendar.ERA, ERAs);\n+                break;\n+            case 'y': // year (number)\n+                if (tokenLen >= 4) {\n+                    rule = new UnpaddedNumberField(Calendar.YEAR);\n+                }\n+                else {\n+                    rule = new TwoDigitYearField();\n+                }\n+                break;\n+            case 'M': // month in year (text and number)\n+                if (tokenLen >= 4) {\n+                    rule = new TextField(Calendar.MONTH, months);\n+                }\n+                else if (tokenLen == 3) {\n+                    rule = new TextField(Calendar.MONTH, shortMonths);\n+                }\n+                else if (tokenLen == 2) {\n+                    rule = new TwoDigitMonthField();\n+                }\n+                else {\n+                    rule = new UnpaddedMonthField();\n+                }\n+                break;\n+            case 'd': // day in month (number)\n+                rule = selectNumberRule(Calendar.DAY_OF_MONTH, tokenLen);\n+                break;\n+            case 'h': // hour in am/pm (number, 1..12)\n+                rule = new TwelveHourField\n+                    (selectNumberRule(Calendar.HOUR, tokenLen));\n+                break;\n+            case 'H': // hour in day (number, 0..23)\n+                rule = selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen);\n+                break;\n+            case 'm': // minute in hour (number)\n+                rule = selectNumberRule(Calendar.MINUTE, tokenLen);\n+                break;\n+            case 's': // second in minute (number)\n+                rule = selectNumberRule(Calendar.SECOND, tokenLen);\n+                break;\n+            case 'S': // millisecond (number)\n+                rule = selectNumberRule(Calendar.MILLISECOND, tokenLen);\n+                break;\n+            case 'E': // day in week (text)\n+                rule = new TextField\n+                    (Calendar.DAY_OF_WEEK,\n+                     tokenLen < 4 ? shortWeekdays : weekdays);\n+                break;\n+            case 'D': // day in year (number)\n+                rule = selectNumberRule(Calendar.DAY_OF_YEAR, tokenLen);\n+                break;\n+            case 'F': // day of week in month (number)\n+                rule = selectNumberRule\n+                    (Calendar.DAY_OF_WEEK_IN_MONTH, tokenLen);\n+                break;\n+            case 'w': // week in year (number)\n+                rule = selectNumberRule(Calendar.WEEK_OF_YEAR, tokenLen);\n+                break;\n+            case 'W': // week in month (number)\n+                rule = selectNumberRule(Calendar.WEEK_OF_MONTH, tokenLen);\n+                break;\n+            case 'a': // am/pm marker (text)\n+                rule = new TextField(Calendar.AM_PM, AmPmStrings);\n+                break;\n+            case 'k': // hour in day (1..24)\n+                rule = new TwentyFourHourField\n+                    (selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen));\n+                break;\n+            case 'K': // hour in am/pm (0..11)\n+                rule = selectNumberRule(Calendar.HOUR, tokenLen);\n+                break;\n+            case 'z': // time zone (text)\n+                if (tokenLen >= 4) {\n+                    rule = new TimeZoneRule(timeZone, locale, TimeZone.LONG);\n+                }\n+                else {\n+                    rule = new TimeZoneRule(timeZone, locale, TimeZone.SHORT);\n+                }\n+                break;\n+            case '\\'': // literal text\n+                String sub = token.substring(1);\n+                if (sub.length() == 1) {\n+                    rule = new CharacterLiteral(sub.charAt(0));\n+                }\n+                else {\n+                    rule = new StringLiteral(new String(sub));\n+                }\n+                break;\n+            default:\n+                throw new IllegalArgumentException\n+                    (\"Illegal pattern component: \" + token);\n+            }\n+\n+            rules.add(rule);\n+        }\n+\n+        return rules;\n+    }\n+\n+    private static String parseToken(String pattern, int[] indexRef) {\n+        StringBuffer buf = new StringBuffer();\n+\n+        int i = indexRef[0];\n+        int length = pattern.length();\n+\n+        char c = pattern.charAt(i);\n+        if (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z') {\n+            // Scan a run of the same character, which indicates a time\n+            // pattern.\n+            buf.append(c);\n+\n+            while (i + 1 < length) {\n+                char peek = pattern.charAt(i + 1);\n+                if (peek == c) {\n+                    buf.append(c);\n+                    i++;\n+                }\n+                else {\n+                    break;\n+                }\n+            }\n+        }\n+        else {\n+            // This will identify token as text.\n+            buf.append('\\'');\n+\n+            boolean inLiteral = false;\n+\n+            for (; i < length; i++) {\n+                c = pattern.charAt(i);\n+\n+                if (c == '\\'') {\n+                    if (i + 1 < length && pattern.charAt(i + 1) == '\\'') {\n+                        // '' is treated as escaped '\n+                        i++;\n+                        buf.append(c);\n+                    }\n+                    else {\n+                        inLiteral = !inLiteral;\n+                    }\n+                }\n+                else if (!inLiteral &&\n+                         (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z')) {\n+                    i--;\n+                    break;\n+                }\n+                else {\n+                    buf.append(c);\n+                }\n+            }\n+        }\n+\n+        indexRef[0] = i;\n+        return buf.toString();\n+    }\n+\n+    private static NumberRule selectNumberRule(int field, int padding) {\n+        switch (padding) {\n+        case 1:\n+            return new UnpaddedNumberField(field);\n+        case 2:\n+            return new TwoDigitNumberField(field);\n+        default:\n+            return new PaddedNumberField(field, padding);\n+        }\n+    }\n+\n+    private final String mPattern;\n+    private final TimeZone mTimeZone;\n+    private final Locale mLocale;\n+    private final Rule[] mRules;\n+    private final int mMaxLengthEstimate;\n+\n+    private FastDateFormat() {\n+        this(getDefaultPattern(), null, null, null);\n+    }\n+\n+    /**\n+     * @param pattern {@link java.text.SimpleDateFormat} compatible pattern\n+     */\n+    private FastDateFormat(String pattern) throws IllegalArgumentException {\n+        this(pattern, null, null, null);\n+    }\n+\n+    /**\n+     * @param pattern {@link java.text.SimpleDateFormat} compatible pattern\n+     * @param timeZone optional time zone, overrides time zone of formatted\n+     * date\n+     */\n+    private FastDateFormat(String pattern, TimeZone timeZone) {\n+        this(pattern, timeZone, null, null);\n+    }\n+\n+    /**\n+     * @param pattern {@link java.text.SimpleDateFormat} compatible pattern\n+     * @param locale optional locale, overrides system locale\n+     */\n+    private FastDateFormat(String pattern, Locale locale) {\n+        this(pattern, null, locale, null);\n+    }\n+\n+    /**\n+     * @param pattern {@link java.text.SimpleDateFormat} compatible pattern\n+     * @param symbols optional date format symbols, overrides symbols for\n+     * system locale\n+     */\n+    private FastDateFormat(String pattern, DateFormatSymbols symbols) {\n+        this(pattern, null, null, symbols);\n+    }\n+\n+    /**\n+     * @param pattern {@link java.text.SimpleDateFormat} compatible pattern\n+     * @param timeZone optional time zone, overrides time zone of formatted\n+     * date\n+     * @param locale optional locale, overrides system locale\n+     */\n+    private FastDateFormat(String pattern, TimeZone timeZone, Locale locale) {\n+        this(pattern, timeZone, locale, null);\n+    }\n+\n+    /**\n+     * @param pattern {@link java.text.SimpleDateFormat} compatible pattern\n+     * @param timeZone optional time zone, overrides time zone of formatted\n+     * date\n+     * @param locale optional locale, overrides system locale\n+     * @param symbols optional date format symbols, overrides symbols for\n+     * provided locale\n+     */\n+    private FastDateFormat(String pattern, TimeZone timeZone, Locale locale, DateFormatSymbols symbols) {\n+        if (locale == null) {\n+            locale = Locale.getDefault();\n+        }\n+\n+        mPattern = pattern;\n+        mTimeZone = timeZone;\n+        mLocale = locale;\n+\n+        if (symbols == null) {\n+            symbols = new DateFormatSymbols(locale);\n+        }\n+\n+        List rulesList = parse(pattern, timeZone, locale, symbols);\n+        mRules = (Rule[])rulesList.toArray(new Rule[rulesList.size()]);\n+\n+        int len = 0;\n+        for (int i=mRules.length; --i >= 0; ) {\n+            len += mRules[i].estimateLength();\n+        }\n+\n+        mMaxLengthEstimate = len;\n+    }\n+\n+    public String format(Date date) {\n+        Calendar c = new GregorianCalendar(cDefaultTimeZone);\n+        c.setTime(date);\n+        if (mTimeZone != null) {\n+            c.setTimeZone(mTimeZone);\n+        }\n+        return applyRules(c, new StringBuffer(mMaxLengthEstimate)).toString();\n+    }\n+\n+    public String format(Calendar calendar) {\n+        return format(calendar, new StringBuffer(mMaxLengthEstimate))\n+            .toString();\n+    }\n+\n+    public StringBuffer format(Date date, StringBuffer buf) {\n+        Calendar c = new GregorianCalendar(cDefaultTimeZone);\n+        c.setTime(date);\n+        if (mTimeZone != null) {\n+            c.setTimeZone(mTimeZone);\n+        }\n+        return applyRules(c, buf);\n+    }\n+\n+    public StringBuffer format(Calendar calendar, StringBuffer buf) {\n+        if (mTimeZone != null) {\n+            calendar = (Calendar)calendar.clone();\n+            calendar.setTimeZone(mTimeZone);\n+        }\n+        return applyRules(calendar, buf);\n+    }\n+\n+    private StringBuffer applyRules(Calendar calendar, StringBuffer buf) {\n+        Rule[] rules = mRules;\n+        int len = mRules.length;\n+        for (int i=0; i<len; i++) {\n+            rules[i].appendTo(buf, calendar);\n+        }\n+        return buf;\n+    }\n+\n+    public String getPattern() {\n+        return mPattern;\n+    }\n+\n+    /**\n+     * Returns the time zone used by this formatter, or null if time zone of\n+     * formatted dates is used instead.\n+     */\n+    public TimeZone getTimeZone() {\n+        return mTimeZone;\n+    }\n+\n+    public Locale getLocale() {\n+        return mLocale;\n+    }\n+\n+    /**\n+     * Returns an estimate for the maximum length date that this date\n+     * formatter will produce. The actual formatted length will almost always\n+     * be less than or equal to this amount.\n+     */\n+    public int getMaxLengthEstimate() {\n+        return mMaxLengthEstimate;\n+    }\n+\n+    private interface Rule {\n+        int estimateLength();\n+\n+        void appendTo(StringBuffer buffer, Calendar calendar);\n+    }\n+\n+    private interface NumberRule extends Rule {\n+        void appendTo(StringBuffer buffer, int value);\n+    }\n+\n+    private static class CharacterLiteral implements Rule {\n+        private final char mValue;\n+\n+        CharacterLiteral(char value) {\n+            mValue = value;\n+        }\n+\n+        public int estimateLength() {\n+            return 1;\n+        }\n+\n+        public void appendTo(StringBuffer buffer, Calendar calendar) {\n+            buffer.append(mValue);\n+        }\n+    }\n+\n+    private static class StringLiteral implements Rule {\n+        private final String mValue;\n+\n+        StringLiteral(String value) {\n+            mValue = value;\n+        }\n+\n+        public int estimateLength() {\n+            return mValue.length();\n+        }\n+\n+        public void appendTo(StringBuffer buffer, Calendar calendar) {\n+            buffer.append(mValue);\n+        }\n+    }\n+\n+    private static class TextField implements Rule {\n+        private final int mField;\n+        private final String[] mValues;\n+\n+        TextField(int field, String[] values) {\n+            mField = field;\n+            mValues = values;\n+        }\n+\n+        public int estimateLength() {\n+            int max = 0;\n+            for (int i=mValues.length; --i >= 0; ) {\n+                int len = mValues[i].length();\n+                if (len > max) {\n+                    max = len;\n+                }\n+            }\n+            return max;\n+        }\n+\n+        public void appendTo(StringBuffer buffer, Calendar calendar) {\n+            buffer.append(mValues[calendar.get(mField)]);\n+        }\n+    }\n+\n+    private static class UnpaddedNumberField implements NumberRule {\n+        private final int mField;\n+\n+        UnpaddedNumberField(int field) {\n+            mField = field;\n+        }\n+\n+        public int estimateLength() {\n+            return 4;\n+        }\n+\n+        public void appendTo(StringBuffer buffer, Calendar calendar) {\n+            appendTo(buffer, calendar.get(mField));\n+        }\n+\n+        public final void appendTo(StringBuffer buffer, int value) {\n+            if (value < 10) {\n+                buffer.append((char)(value + '0'));\n+            }\n+            else if (value < 100) {\n+                buffer.append((char)(value / 10 + '0'));\n+                buffer.append((char)(value % 10 + '0'));\n+            }\n+            else {\n+                buffer.append(Integer.toString(value));\n+            }\n+        }\n+    }\n+\n+    private static class UnpaddedMonthField implements NumberRule {\n+        UnpaddedMonthField() {\n+        }\n+\n+        public int estimateLength() {\n+            return 2;\n+        }\n+\n+        public void appendTo(StringBuffer buffer, Calendar calendar) {\n+            appendTo(buffer, calendar.get(Calendar.MONTH) + 1);\n+        }\n+\n+        public final void appendTo(StringBuffer buffer, int value) {\n+            if (value < 10) {\n+                buffer.append((char)(value + '0'));\n+            }\n+            else {\n+                buffer.append((char)(value / 10 + '0'));\n+                buffer.append((char)(value % 10 + '0'));\n+            }\n+        }\n+    }\n+\n+    private static class PaddedNumberField implements NumberRule {\n+        private final int mField;\n+        private final int mSize;\n+\n+        PaddedNumberField(int field, int size) {\n+            if (size < 3) {\n+                // Should use UnpaddedNumberField or TwoDigitNumberField.\n+                throw new IllegalArgumentException();\n+            }\n+            mField = field;\n+            mSize = size;\n+        }\n+\n+        public int estimateLength() {\n+            return 4;\n+        }\n+\n+        public void appendTo(StringBuffer buffer, Calendar calendar) {\n+            appendTo(buffer, calendar.get(mField));\n+        }\n+\n+        public final void appendTo(StringBuffer buffer, int value) {\n+            if (value < 100) {\n+                for (int i = mSize; --i >= 2; ) {\n+                    buffer.append('0');\n+                }\n+                buffer.append((char)(value / 10 + '0'));\n+                buffer.append((char)(value % 10 + '0'));\n+            }\n+            else {\n+                int digits;\n+                if (value < 1000) {\n+                    digits = 3;\n+                }\n+                else {\n+                    digits = (int)(Math.log(value) / LOG_10) + 1;\n+                }\n+                for (int i = mSize; --i >= digits; ) {\n+                    buffer.append('0');\n+                }\n+                buffer.append(Integer.toString(value));\n+            }\n+        }\n+    }\n+\n+    private static class TwoDigitNumberField implements NumberRule {\n+        private final int mField;\n+\n+        TwoDigitNumberField(int field) {\n+            mField = field;\n+        }\n+\n+        public int estimateLength() {\n+            return 2;\n+        }\n+\n+        public void appendTo(StringBuffer buffer, Calendar calendar) {\n+            appendTo(buffer, calendar.get(mField));\n+        }\n+\n+        public final void appendTo(StringBuffer buffer, int value) {\n+            if (value < 100) {\n+                buffer.append((char)(value / 10 + '0'));\n+                buffer.append((char)(value % 10 + '0'));\n+            }\n+            else {\n+                buffer.append(Integer.toString(value));\n+            }\n+        }\n+    }\n+\n+    private static class TwoDigitYearField implements NumberRule {\n+        TwoDigitYearField() {\n+        }\n+\n+        public int estimateLength() {\n+            return 2;\n+        }\n+\n+        public void appendTo(StringBuffer buffer, Calendar calendar) {\n+            appendTo(buffer, calendar.get(Calendar.YEAR) % 100);\n+        }\n+\n+        public final void appendTo(StringBuffer buffer, int value) {\n+            buffer.append((char)(value / 10 + '0'));\n+            buffer.append((char)(value % 10 + '0'));\n+        }\n+    }\n+\n+    private static class TwoDigitMonthField implements NumberRule {\n+        TwoDigitMonthField() {\n+        }\n+\n+        public int estimateLength() {\n+            return 2;\n+        }\n+\n+        public void appendTo(StringBuffer buffer, Calendar calendar) {\n+            appendTo(buffer, calendar.get(Calendar.MONTH) + 1);\n+        }\n+\n+        public final void appendTo(StringBuffer buffer, int value) {\n+            buffer.append((char)(value / 10 + '0'));\n+            buffer.append((char)(value % 10 + '0'));\n+        }\n+    }\n+\n+    private static class TwelveHourField implements NumberRule {\n+        private final NumberRule mRule;\n+\n+        TwelveHourField(NumberRule rule) {\n+            mRule = rule;\n+        }\n+\n+        public int estimateLength() {\n+            return mRule.estimateLength();\n+        }\n+\n+        public void appendTo(StringBuffer buffer, Calendar calendar) {\n+            int value = calendar.get(Calendar.HOUR);\n+            if (value == 0) {\n+                value = calendar.getLeastMaximum(Calendar.HOUR) + 1;\n+            }\n+            mRule.appendTo(buffer, value);\n+        }\n+\n+        public void appendTo(StringBuffer buffer, int value) {\n+            mRule.appendTo(buffer, value);\n+        }\n+    }\n+\n+    private static class TwentyFourHourField implements NumberRule {\n+        private final NumberRule mRule;\n+\n+        TwentyFourHourField(NumberRule rule) {\n+            mRule = rule;\n+        }\n+\n+        public int estimateLength() {\n+            return mRule.estimateLength();\n+        }\n+\n+        public void appendTo(StringBuffer buffer, Calendar calendar) {\n+            int value = calendar.get(Calendar.HOUR_OF_DAY);\n+            if (value == 0) {\n+                value = calendar.getMaximum(Calendar.HOUR_OF_DAY) + 1;\n+            }\n+            mRule.appendTo(buffer, value);\n+        }\n+\n+        public void appendTo(StringBuffer buffer, int value) {\n+            mRule.appendTo(buffer, value);\n+        }\n+    }\n+\n+    private static class TimeZoneRule implements Rule {\n+        private final TimeZone mTimeZone;\n+        private final Locale mLocale;\n+        private final int mStyle;\n+        private final String mStandard;\n+        private final String mDaylight;\n+\n+        TimeZoneRule(TimeZone timeZone, Locale locale, int style) {\n+            mTimeZone = timeZone;\n+            mLocale = locale;\n+            mStyle = style;\n+\n+            if (timeZone != null) {\n+                mStandard = getTimeZoneDisplay(timeZone, false, style, locale);\n+                mDaylight = getTimeZoneDisplay(timeZone, true, style, locale);\n+            }\n+            else {\n+                mStandard = null;\n+                mDaylight = null;\n+            }\n+        }\n+\n+        public int estimateLength() {\n+            if (mTimeZone != null) {\n+                return Math.max(mStandard.length(), mDaylight.length());\n+            }\n+            else if (mStyle == TimeZone.SHORT) {\n+                return 4;\n+            }\n+            else {\n+                return 40;\n+            }\n+        }\n+\n+        public void appendTo(StringBuffer buffer, Calendar calendar) {\n+            TimeZone timeZone;\n+            if ((timeZone = mTimeZone) != null) {\n+                if (timeZone.useDaylightTime() &&\n+                    calendar.get(Calendar.DST_OFFSET) != 0) {\n+\n+                    buffer.append(mDaylight);\n+                }\n+                else {\n+                    buffer.append(mStandard);\n+                }\n+            }\n+            else {\n+                timeZone = calendar.getTimeZone();\n+                if (timeZone.useDaylightTime() &&\n+                    calendar.get(Calendar.DST_OFFSET) != 0) {\n+\n+                    buffer.append(getTimeZoneDisplay\n+                                  (timeZone, true, mStyle, mLocale));\n+                }\n+                else {\n+                    buffer.append(getTimeZoneDisplay\n+                                  (timeZone, false, mStyle, mLocale));\n+                }\n+            }\n+        }\n+    }\n+\n+    private static class TimeZoneDisplayKey {\n+        private final TimeZone mTimeZone;\n+        private final int mStyle;\n+        private final Locale mLocale;\n+\n+        TimeZoneDisplayKey(TimeZone timeZone,\n+                           boolean daylight, int style, Locale locale) {\n+            mTimeZone = timeZone;\n+            if (daylight) {\n+                style |= 0x80000000;\n+            }\n+            mStyle = style;\n+            mLocale = locale;\n+        }\n+\n+        public int hashCode() {\n+            return mStyle * 31 + mLocale.hashCode();\n+        }\n+\n+        public boolean equals(Object obj) {\n+            if (this == obj) {\n+                return true;\n+            }\n+            if (obj instanceof TimeZoneDisplayKey) {\n+                TimeZoneDisplayKey other = (TimeZoneDisplayKey)obj;\n+                return\n+                    mTimeZone.equals(other.mTimeZone) &&\n+                    mStyle == other.mStyle &&\n+                    mLocale.equals(other.mLocale);\n+            }\n+            return false;\n+        }\n+    }\n+\n+    // Pair\n+    // ----------------------------------------------------------------------------------\n+    /**\n+     * Helper class for creating compound objects.  One use for this class is to create a\n+     * hashtable key out of multiple objects.\n+     */\n+    private static class Pair implements Comparable, java.io.Serializable {\n+        private final Object mObj1;\n+        private final Object mObj2;\n+\n+        public Pair(Object obj1, Object obj2) {\n+            mObj1 = obj1;\n+            mObj2 = obj2;\n+        }\n+\n+        public int compareTo(Object obj) {\n+            if (this == obj) {\n+                return 0;\n+            }\n+\n+            Pair other = (Pair)obj;\n+\n+            Object a = mObj1;\n+            Object b = other.mObj1;\n+\n+            firstTest: {\n+                if (a == null) {\n+                    if (b != null) {\n+                        return 1;\n+                    }\n+                    // Both a and b are null.\n+                    break firstTest;\n+                }\n+                else {\n+                    if (b == null) {\n+                        return -1;\n+                    }\n+                }\n+\n+                int result = ((Comparable)a).compareTo(b);\n+\n+                if (result != 0) {\n+                    return result;\n+                }\n+            }\n+\n+            a = mObj2;\n+            b = other.mObj2;\n+\n+            if (a == null) {\n+                if (b != null) {\n+                    return 1;\n+                }\n+                // Both a and b are null.\n+                return 0;\n+            }\n+            else {\n+                if (b == null) {\n+                    return -1;\n+                }\n+            }\n+\n+            return ((Comparable)a).compareTo(b);\n+        }\n+\n+        public boolean equals(Object obj) {\n+            if (this == obj) {\n+                return true;\n+            }\n+\n+            if (!(obj instanceof Pair)) {\n+                return false;\n+            }\n+\n+            Pair key = (Pair)obj;\n+\n+            return\n+                (mObj1 == null ?\n+                 key.mObj1 == null : mObj1.equals(key.mObj1)) &&\n+                (mObj2 == null ?\n+                 key.mObj2 == null : mObj2.equals(key.mObj2));\n+        }\n+\n+        public int hashCode() {\n+            return\n+                (mObj1 == null ? 0 : mObj1.hashCode()) +\n+                (mObj2 == null ? 0 : mObj2.hashCode());\n+        }\n+\n+        public String toString() {\n+            return \"[\" + mObj1 + ':' + mObj2 + ']';\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/lang/time/FastDateFormatTest.java\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2002 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.lang.time;\n+\n+import junit.framework.*;\n+import junit.textui.TestRunner;\n+import java.util.*;\n+import java.text.*;\n+\n+/**\n+ * Unit tests {@link org.apache.commons.lang.time.FastDateFormat}.\n+ *\n+ * @author Sean Schofield\n+ * @since 2.0\n+ * @version $Id: FastDateFormatTest.java,v 1.1 2003/01/07 19:55:55 bayard Exp $\n+ */\n+public class FastDateFormatTest extends TestCase {\n+\n+    private FastDateFormat fastDateFormat = null;\n+\n+    public FastDateFormatTest(String name) {\n+        super(name);\n+    }\n+\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(FastDateFormatTest.class);\n+        suite.setName(\"FastDateFormat Tests\");\n+\n+        return suite;\n+    }\n+\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+    }\n+\n+    protected void tearDown() throws Exception {\n+        super.tearDown();\n+    }\n+\n+    public void test_getInstance() {\n+        FastDateFormat format1 = FastDateFormat.getInstance();\n+        FastDateFormat format2 = FastDateFormat.getInstance();\n+        assertSame(format1, format2);\n+    }\n+\n+    public void test_getInstance_String() {\n+        FastDateFormat format1 = FastDateFormat.getInstance(\"MM/DD/yyyy\");\n+        FastDateFormat format2 = FastDateFormat.getInstance(\"MM-DD-yyyy\");\n+        assertTrue(format1 != format2); // -- junit 3.8 version -- assertFalse(format1 == format2);\n+        assertSame(format1, FastDateFormat.getInstance(\"MM/DD/yyyy\"));\n+    }\n+\n+    public void test_getInstance_String_TimeZone() {\n+        Locale realDefaultLocale = Locale.getDefault();\n+        Locale.setDefault(Locale.US);\n+        TimeZone realDefaultZone = TimeZone.getDefault();\n+        TimeZone.setDefault(TimeZone.getTimeZone(\"America/New_York\"));\n+\n+        FastDateFormat format1 = FastDateFormat.getInstance(\"MM/DD/yyyy\",\n+                TimeZone.getTimeZone(\"Atlantic/Reykjavik\"));\n+        FastDateFormat format2 = FastDateFormat.getInstance(\"MM/DD/yyyy\");\n+        FastDateFormat format3 = FastDateFormat.getInstance(\"MM/DD/yyyy\", TimeZone.getDefault());\n+        FastDateFormat format4 = FastDateFormat.getInstance(\"MM/DD/yyyy\", TimeZone.getDefault());\n+        FastDateFormat format5 = FastDateFormat.getInstance(\"MM-DD-yyyy\", TimeZone.getDefault());\n+\n+        assertTrue(format1 != format2); // -- junit 3.8 version -- assertFalse(format1 == format2);\n+        assertTrue(format1.getTimeZone().equals(TimeZone.getTimeZone(\"Atlantic/Reykjavik\")));\n+        assertNull(format2.getTimeZone());\n+        assertSame(format3, format4);\n+        assertTrue(format3 != format5); // -- junit 3.8 version -- assertFalse(format3 == format5);\n+\n+        Locale.setDefault(realDefaultLocale);\n+        TimeZone.setDefault(realDefaultZone);\n+    }\n+\n+    public void test_getInstance_String_Locale() {\n+        Locale realDefaultLocale = Locale.getDefault();\n+        Locale.setDefault(Locale.US);\n+        FastDateFormat format1 = FastDateFormat.getInstance(\"MM/DD/yyyy\", Locale.GERMANY);\n+        FastDateFormat format2 = FastDateFormat.getInstance(\"MM/DD/yyyy\");\n+        FastDateFormat format3 = FastDateFormat.getInstance(\"MM/DD/yyyy\", Locale.GERMANY);\n+\n+        assertTrue(format1 != format2); // -- junit 3.8 version -- assertFalse(format1 == format2);\n+        assertSame(format1, format3);\n+        assertSame(Locale.GERMANY, format1.getLocale());\n+\n+        Locale.setDefault(realDefaultLocale);\n+    }\n+\n+    public void test_getInstance_String_TimeZone_Locale() {\n+        Locale realDefaultLocale = Locale.getDefault();\n+        Locale.setDefault(Locale.US);\n+        TimeZone realDefaultZone = TimeZone.getDefault();\n+        TimeZone.setDefault(TimeZone.getTimeZone(\"America/New_York\"));\n+\n+        FastDateFormat format1 = FastDateFormat.getInstance(\"MM/DD/yyyy\",\n+                TimeZone.getTimeZone(\"Atlantic/Reykjavik\"), Locale.GERMANY);\n+        FastDateFormat format2 = FastDateFormat.getInstance(\"MM/DD/yyyy\", Locale.GERMANY);\n+        FastDateFormat format3 = FastDateFormat.getInstance(\"MM/DD/yyyy\",\n+                TimeZone.getDefault(), Locale.GERMANY);\n+\n+        assertTrue(format1 != format2); // -- junit 3.8 version -- assertNotSame(format1, format2);\n+        assertEquals(format1.getTimeZone(), TimeZone.getTimeZone(\"Atlantic/Reykjavik\"));\n+        assertNull(format2.getTimeZone());\n+        assertEquals(format3.getTimeZone(), TimeZone.getDefault());\n+        assertEquals(format3.getTimeZone(), TimeZone.getTimeZone(\"America/New_York\"));\n+\n+        Locale.setDefault(realDefaultLocale);\n+        TimeZone.setDefault(realDefaultZone);\n+    }\n+}", "timestamp": 1041969355, "metainfo": ""}