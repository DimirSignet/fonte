{"sha": "e7640031c6f8c5463f101495e45c5bd08ab03595", "log": "Fix 120-length warnings reported for 2.1-RC4 here: http://people.apache.org/~stevencaswell/commons-lang-2.1/docs/checkstyle-report.html  ", "commit": "\n--- a/src/java/org/apache/commons/lang/CharEncoding.java\n+++ b/src/java/org/apache/commons/lang/CharEncoding.java\n import java.io.UnsupportedEncodingException;\n \n /**\n- * <p>Character encoding names required of every implementation of the Java platform.</p>\n- * \n- * <p>According to the Java documentation\n- * <a href=\"http://java.sun.com/j2se/1.3/docs/api/java/lang/package-summary.html#charenc\">JRE character encoding names</a>:<br />\n- * <cite>Every implementation of the Java platform is required to support the following character encodings. Consult the\n- * release documentation for your implementation to see if any other encodings are supported. </cite>\n+ * <p>\n+ * Character encoding names required of every implementation of the Java platform.\n  * </p>\n  * \n- * @see <a href=\"http://java.sun.com/j2se/1.3/docs/api/java/lang/package-summary.html#charenc\">JRE character encoding names</a>\n+ * <p>\n+ * According to <a href=\"http://java.sun.com/j2se/1.3/docs/api/java/lang/package-summary.html#charenc\">JRE character\n+ * encoding names</a>:\n+ * <p>\n+ * <cite>Every implementation of the Java platform is required to support the following character encodings. Consult the\n+ * release documentation for your implementation to see if any other encodings are supported.</cite>\n+ * </p>\n+ * </p>\n+ * \n+ * @see <a href=\"http://java.sun.com/j2se/1.3/docs/api/java/lang/package-summary.html#charenc\">JRE character encoding\n+ *      names</a>\n  * @author Apache Software Foundation\n  * @since 2.1\n  * @version $Id$\n      * Every implementation of the Java platform is required to support this character encoding.\n      * </p>\n      * \n-     * @see <a href=\"http://java.sun.com/j2se/1.3/docs/api/java/lang/package-summary.html#charenc\">JRE character encoding names</a>\n+     * @see <a href=\"http://java.sun.com/j2se/1.3/docs/api/java/lang/package-summary.html#charenc\">JRE character\n+     *      encoding names</a>\n      */\n     public static final String ISO_8859_1 = \"ISO-8859-1\";\n \n      * Every implementation of the Java platform is required to support this character encoding.\n      * </p>\n      * \n-     * @see <a href=\"http://java.sun.com/j2se/1.3/docs/api/java/lang/package-summary.html#charenc\">JRE character encoding names</a>\n+     * @see <a href=\"http://java.sun.com/j2se/1.3/docs/api/java/lang/package-summary.html#charenc\">JRE character\n+     *      encoding names</a>\n      */\n     public static final String US_ASCII = \"US-ASCII\";\n \n      * Every implementation of the Java platform is required to support this character encoding.\n      * </p>\n      * \n-     * @see <a href=\"http://java.sun.com/j2se/1.3/docs/api/java/lang/package-summary.html#charenc\">JRE character encoding names</a>\n+     * @see <a href=\"http://java.sun.com/j2se/1.3/docs/api/java/lang/package-summary.html#charenc\">JRE character\n+     *      encoding names</a>\n      */\n     public static final String UTF_16 = \"UTF-16\";\n \n      * Every implementation of the Java platform is required to support this character encoding.\n      * </p>\n      * \n-     * @see <a href=\"http://java.sun.com/j2se/1.3/docs/api/java/lang/package-summary.html#charenc\">JRE character encoding names</a>\n+     * @see <a href=\"http://java.sun.com/j2se/1.3/docs/api/java/lang/package-summary.html#charenc\">JRE character\n+     *      encoding names</a>\n      */\n     public static final String UTF_16BE = \"UTF-16BE\";\n \n      * Every implementation of the Java platform is required to support this character encoding.\n      * </p>\n      * \n-     * @see <a href=\"http://java.sun.com/j2se/1.3/docs/api/java/lang/package-summary.html#charenc\">JRE character encoding names</a>\n+     * @see <a href=\"http://java.sun.com/j2se/1.3/docs/api/java/lang/package-summary.html#charenc\">JRE character\n+     *      encoding names</a>\n      */\n     public static final String UTF_16LE = \"UTF-16LE\";\n \n      * Every implementation of the Java platform is required to support this character encoding.\n      * </p>\n      * \n-     * @see <a href=\"http://java.sun.com/j2se/1.3/docs/api/java/lang/package-summary.html#charenc\">JRE character encoding names</a>\n+     * @see <a href=\"http://java.sun.com/j2se/1.3/docs/api/java/lang/package-summary.html#charenc\">JRE character\n+     *      encoding names</a>\n      */\n     public static final String UTF_8 = \"UTF-8\";\n \n      * Returns whether the named charset is supported.\n      * </p>\n      * <p>\n-     * This is similar to\n-     * <a href=\"http://java.sun.com/j2se/1.4.2/docs/api/java/nio/charset/Charset.html#isSupported(java.lang.String)\">java.nio.charset.Charset.isSupported(String)</a>\n+     * This is similar to <a\n+     * href=\"http://java.sun.com/j2se/1.4.2/docs/api/java/nio/charset/Charset.html#isSupported(java.lang.String)\">\n+     * java.nio.charset.Charset.isSupported(String)</a>\n      * </p>\n      * \n-     * @param name  the name of the requested charset; may be either a canonical name or an alias\n-     * @return <code>true</code> if, and only if, support for the named charset is available in the current Java virtual machine\n+     * @param name\n+     *            the name of the requested charset; may be either a canonical name or an alias\n+     * @return <code>true</code> if, and only if, support for the named charset is available in the current Java\n+     *         virtual machine\n      * \n-     * @see <a href=\"http://java.sun.com/j2se/1.3/docs/api/java/lang/package-summary.html#charenc\">JRE character encoding names</a>\n+     * @see <a href=\"http://java.sun.com/j2se/1.3/docs/api/java/lang/package-summary.html#charenc\">JRE character\n+     *      encoding names</a>\n      */\n     public static boolean isSupported(String name) {\n         if (name == null) {\n--- a/src/java/org/apache/commons/lang/StringEscapeUtils.java\n+++ b/src/java/org/apache/commons/lang/StringEscapeUtils.java\n      * <p>Escapes the characters in a <code>String</code> using HTML entities.</p>\n      *\n      * <p>\n-     * For example: <tt>\"bread\" & \"butter\"</tt> => <tt>&amp;quot;bread&amp;quot; &amp;amp; &amp;quot;butter&amp;quot;</tt>.\n+     * For example:\n+     * </p> \n+     * <p><code>\"bread\" & \"butter\"</code></p>\n+     * becomes:\n+     * <p>\n+     * <code>&amp;quot;bread&amp;quot; &amp;amp; &amp;quot;butter&amp;quot;</code>.\n      * </p>\n      *\n      * <p>Supports all known HTML 4.0 entities, including funky accents.</p>\n--- a/src/java/org/apache/commons/lang/SystemUtils.java\n+++ b/src/java/org/apache/commons/lang/SystemUtils.java\n      * @since 2.1\n      * @since Java 1.4\n      */\n-    public static final String JAVA_UTIL_PREFS_PREFERENCES_FACTORY = getSystemProperty(\"java.util.prefs.PreferencesFactory\");\n+    public static final String JAVA_UTIL_PREFS_PREFERENCES_FACTORY = \n+        getSystemProperty(\"java.util.prefs.PreferencesFactory\");\n \n     /**\n      * <p>The <code>java.vendor</code> System Property. Java vendor-specific string.</p>\n--- a/src/java/org/apache/commons/lang/Validate.java\n+++ b/src/java/org/apache/commons/lang/Validate.java\n     }\n \n     /**\n-     * <p>Validate an argument, throwing <code>IllegalArgumentException</code>\n-     * if the argument collection  is <code>null</code> or has elements that are not of \n-     * type <code>clazz</code> or a subclass.</p>\n-     *\n+     * <p>\n+     * Validate an argument, throwing <code>IllegalArgumentException</code> if the argument collection is\n+     * <code>null</code> or has elements that are not of type <code>clazz</code> or a subclass.\n+     * </p>\n+     * \n      * <pre>\n      * Validate.allElementsOfType(collection, String.class);\n      * </pre>\n-     *\n-     * <p>The message in the exception is 'The validated collection contains an element not of type clazz at index: '.</p>\n-     * \n-     * @param collection  the collection to check, not null\n-     * @param clazz the <code>Class</code> which the collection's elements are expected to be, not null\n+     * \n+     * <p>\n+     * The message in the exception is 'The validated collection contains an element not of type clazz at index: '.\n+     * </p>\n+     * \n+     * @param collection\n+     *            the collection to check, not null\n+     * @param clazz\n+     *            the <code>Class</code> which the collection's elements are expected to be, not null\n      * @since 2.1\n      */\n     public static void allElementsOfType(Collection collection, Class clazz) {\n--- a/src/java/org/apache/commons/lang/builder/ReflectionToStringBuilder.java\n+++ b/src/java/org/apache/commons/lang/builder/ReflectionToStringBuilder.java\n      *                  if the Object is <code>null</code>\n      * @since 2.0\n      */\n-    public static String toString(Object object, ToStringStyle style, boolean outputTransients, Class reflectUpToClass) {\n+    public static String toString(Object object, ToStringStyle style, boolean outputTransients, \n+            Class reflectUpToClass) {\n         return new ReflectionToStringBuilder(object, style, null, reflectUpToClass, outputTransients).toString();\n     }\n \n--- a/src/java/org/apache/commons/lang/time/DurationFormatUtils.java\n+++ b/src/java/org/apache/commons/lang/time/DurationFormatUtils.java\n      * @return the time as a String\n      */\n     public static String formatPeriodISO(long startMillis, long endMillis) {\n-        return formatPeriod(startMillis, endMillis, ISO_EXTENDED_FORMAT_PATTERN, false, TimeZone.getDefault() );\n+        return formatPeriod(startMillis, endMillis, ISO_EXTENDED_FORMAT_PATTERN, false, TimeZone.getDefault());\n     }\n \n     /**\n      * @param timezone the millis are defined in\n      * @return the time as a String\n      */\n-    public static String formatPeriod(long startMillis, long endMillis, String format, boolean padWithZeros, TimeZone timezone) {\n+    public static String formatPeriod(long startMillis, long endMillis, String format, boolean padWithZeros, \n+            TimeZone timezone) {\n \n         long millis = endMillis - startMillis;\n         if (millis < 28 * DateUtils.MILLIS_PER_DAY) {\n      * @param padWithZeros  whether to pad\n      * @return the formetted string\n      */\n-    static String format(Token[] tokens, int years, int months, int days, int hours, \n-                                 int minutes, int seconds, int milliseconds, boolean padWithZeros) \n-    { \n+    static String format(Token[] tokens, int years, int months, int days, int hours, int minutes, int seconds,\n+            int milliseconds, boolean padWithZeros) {\n         StringBuffer buffer = new StringBuffer();\n         boolean lastOutputSeconds = false;\n         int sz = tokens.length;\n             Token token = tokens[i];\n             Object value = token.getValue();\n             int count = token.getCount();\n-            if(value instanceof StringBuffer) {\n+            if (value instanceof StringBuffer) {\n                 buffer.append(value.toString());\n             } else {\n                 if (value == y) {\n-                    buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(years), count, '0') : Integer.toString(years));\n+                    buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(years), count, '0') : Integer\n+                            .toString(years));\n                     lastOutputSeconds = false;\n                 } else if (value == M) {\n-                    buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(months), count, '0') : Integer.toString(months));\n+                    buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(months), count, '0') : Integer\n+                            .toString(months));\n                     lastOutputSeconds = false;\n                 } else if (value == d) {\n-                    buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(days), count, '0') : Integer.toString(days));\n+                    buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(days), count, '0') : Integer\n+                            .toString(days));\n                     lastOutputSeconds = false;\n                 } else if (value == H) {\n-                    buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(hours), count, '0') : Integer.toString(hours));\n+                    buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(hours), count, '0') : Integer\n+                            .toString(hours));\n                     lastOutputSeconds = false;\n                 } else if (value == m) {\n-                    buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(minutes), count, '0') : Integer.toString(minutes));\n+                    buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(minutes), count, '0') : Integer\n+                            .toString(minutes));\n                     lastOutputSeconds = false;\n                 } else if (value == s) {\n-                    buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(seconds), count, '0') : Integer.toString(seconds));\n+                    buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(seconds), count, '0') : Integer\n+                            .toString(seconds));\n                     lastOutputSeconds = true;\n                 } else if (value == S) {\n                     if (lastOutputSeconds) {\n                         milliseconds += 1000;\n-                        String str = padWithZeros ? StringUtils.leftPad(Integer.toString(milliseconds), count, '0') : Integer.toString(milliseconds);\n+                        String str = padWithZeros\n+                                ? StringUtils.leftPad(Integer.toString(milliseconds), count, '0')\n+                                : Integer.toString(milliseconds);\n                         buffer.append(str.substring(1));\n                     } else {\n-                        buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(milliseconds), count, '0') : Integer.toString(milliseconds));\n+                        buffer.append(padWithZeros\n+                                ? StringUtils.leftPad(Integer.toString(milliseconds), count, '0')\n+                                : Integer.toString(milliseconds));\n                     }\n                     lastOutputSeconds = false;\n                 }\n             }\n         }\n-        \n         return buffer.toString();\n     }\n \n--- a/src/java/org/apache/commons/lang/time/FastDateFormat.java\n+++ b/src/java/org/apache/commons/lang/time/FastDateFormat.java\n      * @throws IllegalArgumentException if the Locale has no date/time\n      *  pattern defined\n      */\n-    public static synchronized FastDateFormat getDateTimeInstance(\n-            int dateStyle, int timeStyle, TimeZone timeZone, Locale locale) {\n+    public static synchronized FastDateFormat getDateTimeInstance(int dateStyle, int timeStyle, TimeZone timeZone,\n+            Locale locale) {\n \n         Object key = new Pair(new Integer(dateStyle), new Integer(timeStyle));\n         if (timeZone != null) {\n             }\n \n             try {\n-                SimpleDateFormat formatter = (SimpleDateFormat) DateFormat.getDateTimeInstance(dateStyle, timeStyle, locale);\n+                SimpleDateFormat formatter = (SimpleDateFormat) DateFormat.getDateTimeInstance(dateStyle, timeStyle,\n+                        locale);\n                 String pattern = formatter.toPattern();\n                 format = getInstance(pattern, timeZone, locale);\n                 cDateTimeInstanceCache.put(key, format);\n-                \n+\n             } catch (ClassCastException ex) {\n                 throw new IllegalArgumentException(\"No date time pattern for locale: \" + locale);\n             }", "timestamp": 1115058709, "metainfo": ""}