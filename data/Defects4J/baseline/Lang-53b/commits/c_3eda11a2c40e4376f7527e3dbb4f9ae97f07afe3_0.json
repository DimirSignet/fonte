{"sha": "3eda11a2c40e4376f7527e3dbb4f9ae97f07afe3", "log": "Enhance StrSubtstitutor with StringBuffer methods and replaceIn() methods  ", "commit": "\n--- a/src/java/org/apache/commons/lang/text/StrSubstitutor.java\n+++ b/src/java/org/apache/commons/lang/text/StrSubstitutor.java\n \n     //-----------------------------------------------------------------------\n     /**\n-     * Replaces all the occurrences of variables in the given source array with\n-     * their matching values from the resolver.\n+     * Replaces all the occurrences of variables with their matching values\n+     * from the resolver using the given source string as a template.\n+     *\n+     * @param source  the string to replace in, null returns null\n+     * @return the result of the replace operation\n+     */\n+    public String replace(String source) {\n+        if (source == null) {\n+            return null;\n+        }\n+        StrBuilder buf = new StrBuilder(source);\n+        if (substitute(buf, 0, source.length()) == false) {\n+            return source;\n+        }\n+        return buf.toString();\n+    }\n+\n+    /**\n+     * Replaces all the occurrences of variables with their matching values\n+     * from the resolver using the given source string as a template.\n+     * <p>\n+     * Only the specified portion of the string will be processed.\n+     * The rest of the string is not processed, and is not returned.\n+     *\n+     * @param source  the string to replace in, null returns null\n+     * @param offset  the start offset within the array, must be valid\n+     * @param length  the length within the array to be processed, must be valid\n+     * @return the result of the replace operation\n+     */\n+    public String replace(String source, int offset, int length) {\n+        if (source == null) {\n+            return null;\n+        }\n+        StrBuilder buf = new StrBuilder(length).append(source, offset, length);\n+        if (substitute(buf, 0, length) == false) {\n+            return source.substring(offset, offset + length);\n+        }\n+        return buf.toString();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Replaces all the occurrences of variables with their matching values\n+     * from the resolver using the given source array as a template.\n+     * The array is not altered by this method.\n      *\n      * @param source  the character array to replace in, not altered, null returns null\n      * @return the result of the replace operation\n     }\n \n     /**\n-     * Replaces all the occurrences of variables in the given source array by with\n-     * their matching values from the resolver.\n+     * Replaces all the occurrences of variables with their matching values\n+     * from the resolver using the given source array as a template.\n+     * The array is not altered by this method.\n+     * <p>\n      * Only the specified portion of the array will be processed.\n+     * The rest of the array is not processed, and is not returned.\n      *\n      * @param source  the character array to replace in, not altered, null returns null\n      * @param offset  the start offset within the array, must be valid\n \n     //-----------------------------------------------------------------------\n     /**\n-     * Replaces all the occurrences of variables in the given source string with\n-     * their matching values from the resolver.\n-     *\n-     * @param source  the string to replace in, null returns null\n-     * @return the result of the replace operation\n-     */\n-    public String replace(String source) {\n-        if (source == null) {\n-            return null;\n-        }\n-        StrBuilder buf = new StrBuilder(source);\n-        if (substitute(buf, 0, source.length()) == false) {\n-            return source;\n-        }\n+     * Replaces all the occurrences of variables with their matching values\n+     * from the resolver using the given source buffer as a template.\n+     * The buffer is not altered by this method.\n+     *\n+     * @param source  the buffer to use as a template, not changed, null returns null\n+     * @return the result of the replace operation\n+     */\n+    public String replace(StringBuffer source) {\n+        if (source == null) {\n+            return null;\n+        }\n+        StrBuilder buf = new StrBuilder(source.length()).append(source);\n+        substitute(buf, 0, buf.length());\n         return buf.toString();\n     }\n \n     /**\n-     * Replaces all the occurrences of variables in the given source string by with\n-     * their matching values from the resolver.\n-     * Only the specified portion of the string will be processed.\n-     *\n-     * @param source  the string to replace in, null returns null\n+     * Replaces all the occurrences of variables with their matching values\n+     * from the resolver using the given source buffer as a template.\n+     * The buffer is not altered by this method.\n+     * <p>\n+     * Only the specified portion of the buffer will be processed.\n+     * The rest of the buffer is not processed, and is not returned.\n+     *\n+     * @param source  the buffer to use as a template, not changed, null returns null\n      * @param offset  the start offset within the array, must be valid\n      * @param length  the length within the array to be processed, must be valid\n      * @return the result of the replace operation\n      */\n-    public String replace(String source, int offset, int length) {\n+    public String replace(StringBuffer source, int offset, int length) {\n         if (source == null) {\n             return null;\n         }\n         StrBuilder buf = new StrBuilder(length).append(source, offset, length);\n-        if (substitute(buf, 0, length) == false) {\n-            return source.substring(offset, offset + length);\n-        }\n+        substitute(buf, 0, length);\n+        return buf.toString();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Replaces all the occurrences of variables with their matching values\n+     * from the resolver using the given source builder as a template.\n+     * The builder is not altered by this method.\n+     *\n+     * @param source  the builder to use as a template, not changed, null returns null\n+     * @return the result of the replace operation\n+     */\n+    public String replace(StrBuilder source) {\n+        if (source == null) {\n+            return null;\n+        }\n+        StrBuilder buf = new StrBuilder(source.length()).append(source);\n+        substitute(buf, 0, buf.length());\n+        return buf.toString();\n+    }\n+\n+    /**\n+     * Replaces all the occurrences of variables with their matching values\n+     * from the resolver using the given source builder as a template.\n+     * The builder is not altered by this method.\n+     * <p>\n+     * Only the specified portion of the builder will be processed.\n+     * The rest of the builder is not processed, and is not returned.\n+     *\n+     * @param source  the builder to use as a template, not changed, null returns null\n+     * @param offset  the start offset within the array, must be valid\n+     * @param length  the length within the array to be processed, must be valid\n+     * @return the result of the replace operation\n+     */\n+    public String replace(StrBuilder source, int offset, int length) {\n+        if (source == null) {\n+            return null;\n+        }\n+        StrBuilder buf = new StrBuilder(length).append(source, offset, length);\n+        substitute(buf, 0, length);\n         return buf.toString();\n     }\n \n \n     //-----------------------------------------------------------------------\n     /**\n+     * Replaces all the occurrences of variables within the given source buffer\n+     * with their matching values from the resolver.\n+     * The buffer is updated with the result.\n+     *\n+     * @param source  the buffer to replace in, updated, null returns zero\n+     * @return true if altered\n+     */\n+    public boolean replaceIn(StringBuffer source) {\n+        if (source == null) {\n+            return false;\n+        }\n+        return replaceIn(source, 0, source.length());\n+    }\n+\n+    /**\n+     * Replaces all the occurrences of variables within the given source buffer\n+     * with their matching values from the resolver.\n+     * The buffer is updated with the result.\n+     * <p>\n+     * Only the specified portion of the buffer will be processed.\n+     * The rest of the buffer is not processed, but it is not deleted.\n+     *\n+     * @param source  the buffer to replace in, updated, null returns zero\n+     * @param offset  the start offset within the array, must be valid\n+     * @param length  the length within the buffer to be processed, must be valid\n+     * @return true if altered\n+     */\n+    public boolean replaceIn(StringBuffer source, int offset, int length) {\n+        if (source == null) {\n+            return false;\n+        }\n+        StrBuilder buf = new StrBuilder(length).append(source, offset, length);\n+        if (substitute(buf, 0, length) == false) {\n+            return false;\n+        }\n+        source.replace(offset, offset + length, buf.toString());\n+        return true;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n      * Replaces all the occurrences of variables within the given source\n      * builder with their matching values from the resolver.\n      *\n      * @param source  the builder to replace in, updated, null returns zero\n      * @return true if altered\n      */\n-    public boolean replace(StrBuilder source) {\n+    public boolean replaceIn(StrBuilder source) {\n         if (source == null) {\n             return false;\n         }\n     /**\n      * Replaces all the occurrences of variables within the given source\n      * builder with their matching values from the resolver.\n-     * Only the specified portion of the builder will be processed, with\n-     * the remainder left untouched.\n+     * <p>\n+     * Only the specified portion of the builder will be processed.\n+     * The rest of the builder is not processed, but it is not deleted.\n      *\n      * @param source  the builder to replace in, null returns zero\n      * @param offset  the start offset within the array, must be valid\n-     * @param length  the length within the array to be processed, must be valid\n+     * @param length  the length within the builder to be processed, must be valid\n      * @return true if altered\n      */\n-    public boolean replace(StrBuilder source, int offset, int length) {\n+    public boolean replaceIn(StrBuilder source, int offset, int length) {\n         if (source == null) {\n             return false;\n         }\n--- a/src/test/org/apache/commons/lang/text/StrSubstitutorTest.java\n+++ b/src/test/org/apache/commons/lang/text/StrSubstitutorTest.java\n \n import java.util.HashMap;\n import java.util.Map;\n+\n+import org.apache.commons.lang.mutable.MutableObject;\n \n import junit.framework.Test;\n import junit.framework.TestCase;\n                 return \"jakarta\";\n             }\n         };\n-        sub.replace(builder);\n+        sub.replaceIn(builder);\n         assertEquals(\"Hi jakarta!\", builder.toString());\n     }\n \n     //-----------------------------------------------------------------------\n     private void doTestReplace(String expectedResult, String replaceTemplate, boolean substring) {\n         String expectedShortResult = expectedResult.substring(1, expectedResult.length() - 1);\n-        \n         StrSubstitutor sub = new StrSubstitutor(values);\n+        \n+        // replace using String\n         assertEquals(expectedResult, sub.replace(replaceTemplate));\n         if (substring) {\n             assertEquals(expectedShortResult, sub.replace(replaceTemplate, 1, replaceTemplate.length() - 2));\n         }\n         \n+        // replace using char[]\n         char[] chars = replaceTemplate.toCharArray();\n         assertEquals(expectedResult, sub.replace(chars));\n         if (substring) {\n             assertEquals(expectedShortResult, sub.replace(chars, 1, chars.length - 2));\n         }\n         \n+        // replace using StringBuffer\n         StringBuffer buf = new StringBuffer(replaceTemplate);\n         assertEquals(expectedResult, sub.replace(buf));\n-        \n+        if (substring) {\n+            assertEquals(expectedShortResult, sub.replace(buf, 1, buf.length() - 2));\n+        }\n+        \n+        // replace using StrBuilder\n         StrBuilder bld = new StrBuilder(replaceTemplate);\n-        assertEquals(true, sub.replace(bld));\n+        assertEquals(expectedResult, sub.replace(bld));\n+        if (substring) {\n+            assertEquals(expectedShortResult, sub.replace(bld, 1, bld.length() - 2));\n+        }\n+        \n+        // replace using object\n+        MutableObject obj = new MutableObject(replaceTemplate);  // toString returns template\n+        assertEquals(expectedResult, sub.replace(obj));\n+        \n+        // replace in StringBuffer\n+        buf = new StringBuffer(replaceTemplate);\n+        assertEquals(true, sub.replaceIn(buf));\n+        assertEquals(expectedResult, buf.toString());\n+        if (substring) {\n+            buf = new StringBuffer(replaceTemplate);\n+            assertEquals(true, sub.replaceIn(buf, 1, buf.length() - 2));\n+            assertEquals(expectedResult, buf.toString());  // expect full result as remainder is untouched\n+        }\n+        \n+        // replace in StrBuilder\n+        bld = new StrBuilder(replaceTemplate);\n+        assertEquals(true, sub.replaceIn(bld));\n         assertEquals(expectedResult, bld.toString());\n-        \n         if (substring) {\n             bld = new StrBuilder(replaceTemplate);\n-            assertEquals(true, sub.replace(bld, 1, bld.length() - 2));\n+            assertEquals(true, sub.replaceIn(bld, 1, bld.length() - 2));\n             assertEquals(expectedResult, bld.toString());  // expect full result as remainder is untouched\n         }\n     }\n \n     private void doTestNoReplace(String replaceTemplate) {\n         StrSubstitutor sub = new StrSubstitutor(values);\n-        assertEquals(replaceTemplate, sub.replace(replaceTemplate));\n         \n         if (replaceTemplate == null) {\n+            assertEquals(null, sub.replace((String) null));\n             assertEquals(null, sub.replace((String) null, 0, 100));\n             assertEquals(null, sub.replace((char[]) null));\n             assertEquals(null, sub.replace((char[]) null, 0, 100));\n+            assertEquals(null, sub.replace((StringBuffer) null));\n+            assertEquals(null, sub.replace((StringBuffer) null, 0, 100));\n+            assertEquals(null, sub.replace((StrBuilder) null));\n+            assertEquals(null, sub.replace((StrBuilder) null, 0, 100));\n             assertEquals(null, sub.replace((Object) null));\n-            assertEquals(false, sub.replace((StrBuilder) null));\n-            assertEquals(false, sub.replace((StrBuilder) null, 0, 100));\n+            assertEquals(false, sub.replaceIn((StringBuffer) null));\n+            assertEquals(false, sub.replaceIn((StringBuffer) null, 0, 100));\n+            assertEquals(false, sub.replaceIn((StrBuilder) null));\n+            assertEquals(false, sub.replaceIn((StrBuilder) null, 0, 100));\n         } else {\n+            assertEquals(replaceTemplate, sub.replace(replaceTemplate));\n             StrBuilder bld = new StrBuilder(replaceTemplate);\n-            assertEquals(false, sub.replace(bld));\n+            assertEquals(false, sub.replaceIn(bld));\n             assertEquals(replaceTemplate, bld.toString());\n         }\n     }", "timestamp": 1155163965, "metainfo": ""}