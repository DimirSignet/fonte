{"sha": "006bfee2d38aadb9aa723e3d5b802d5cc4195c3c", "log": "Added a trimmer matcher which is now used to determine which characters to trim off the left and right of tokens. the ignore matcher is now truly an ignore matcher, which will leave out any matching characters from all tokens. I also fixed a few minor bugs.   ", "commit": "\n--- a/src/java/org/apache/commons/lang/text/StrTokenizer.java\n+++ b/src/java/org/apache/commons/lang/text/StrTokenizer.java\n /*\n  * Copyright 2003-2004 The Apache Software Foundation.\n- * \n+ *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n  * You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  * Each token is separated from the next String by a <i>delimiter</i>.\n  * One or more delimiter characters must be specified.\n  * <p>\n- * The processing then strips all the <i>ignored</i> characters from each side of the token.\n+ * The processing then strips all the <i>ignored</i> characters from then entire string (this\n+ * is useful for removing things like carriage returns, and so forth)\n+ * <p>\n+ * The processing then strips all the <i>trimmer</i> characters from the ends of the string.\n+ * <p>\n  * The token may also have <i>quotes</i> to mark an area not to be stripped or tokenized.\n  * Empty tokens may be removed or returned as null.\n- * This example is based on the CSV tokenizer.\n  * <pre>\n  * \"a,b,c\"       - Three tokens \"a\",\"b\",\"c\"   (comma delimiter)\n- * \"a, b , c\"    - Three tokens \"a\",\"b\",\"c\"   (ignored space characters stripped)\n- * \"a, \" b \", c\" - Three tokens \"a\",\" b \",\"c\" (quoted text untouched)\n+ * \" a, b , c \"    - Three tokens \"a\",\"b\",\"c\"   (default CSV processing trims whitespace)\n+ * \"a, \", b ,\", c\" - Three tokens \"a, \" , \" b \", \", c\" (quoted text untouched)\n  * </pre>\n  * <p>\n  *\n  * @author Stephen Colebourne\n  * @author Gary D. Gregory\n  * @since 2.1\n- * @version $Id: StrTokenizer.java,v 1.1 2004/10/06 22:29:24 scolebourne Exp $\n+ * @version $Id: StrTokenizer.java,v 1.2 2004/12/23 18:55:48 mattinger Exp $\n  */\n public class StrTokenizer implements ListIterator, Cloneable {\n \n     public static final Matcher DOUBLE_QUOTE_MATCHER = new CharMatcher('\"');\n     /**\n      * A Matcher which matches the String trim() whitespace characters.\n-     * Best used for <code>ignored</code>.\n+     * Best used for <code>trimmer</code>.\n      */\n     public static final Matcher TRIM_MATCHER = new TrimMatcher();\n     /**\n      * A Matcher that matches no characters. Don't use this for delimiters!\n-     * Best used for <code>ignored</code>.\n+     * Best used for <code>trimmer</code>.\n      */\n     public static final Matcher NONE_MATCHER = new NoMatcher();\n-    \n+\n     private static final StrTokenizer CSV_TOKENIZER_PROTOTYPE;\n     private static final StrTokenizer TSV_TOKENIZER_PROTOTYPE;\n     static {\n         CSV_TOKENIZER_PROTOTYPE = new StrTokenizer();\n         CSV_TOKENIZER_PROTOTYPE.setDelimiterMatcher(COMMA_MATCHER);\n         CSV_TOKENIZER_PROTOTYPE.setQuoteMatcher(DOUBLE_QUOTE_MATCHER);\n-        CSV_TOKENIZER_PROTOTYPE.setIgnoredMatcher(TRIM_MATCHER);\n+        CSV_TOKENIZER_PROTOTYPE.setIgnoredMatcher(NONE_MATCHER);\n+        CSV_TOKENIZER_PROTOTYPE.setTrimmerMatcher(TRIM_MATCHER);\n         CSV_TOKENIZER_PROTOTYPE.setEmptyTokenAsNull(false);\n         CSV_TOKENIZER_PROTOTYPE.setIgnoreEmptyTokens(false);\n \n         TSV_TOKENIZER_PROTOTYPE = new StrTokenizer();\n         TSV_TOKENIZER_PROTOTYPE.setDelimiterMatcher(TAB_MATCHER);\n         TSV_TOKENIZER_PROTOTYPE.setQuoteMatcher(DOUBLE_QUOTE_MATCHER);\n-        TSV_TOKENIZER_PROTOTYPE.setIgnoredMatcher(TRIM_MATCHER);\n+        TSV_TOKENIZER_PROTOTYPE.setIgnoredMatcher(NONE_MATCHER);\n+        CSV_TOKENIZER_PROTOTYPE.setTrimmerMatcher(TRIM_MATCHER);\n         TSV_TOKENIZER_PROTOTYPE.setEmptyTokenAsNull(false);\n         TSV_TOKENIZER_PROTOTYPE.setIgnoreEmptyTokens(false);\n     }\n     private Matcher quote = NONE_MATCHER;\n     /** The ignored matcher */\n     private Matcher ignored = NONE_MATCHER;\n+\n+    private Matcher trimmer = TRIM_MATCHER;\n+\n     /** Whether to return empty tokens as null */\n     private boolean emptyAsNull = false;\n     /** Whether to ignore empty tokens */\n     //-----------------------------------------------------------------------\n     /**\n      * Constructor that creates a matcher from a set of characters.\n-     * \n+     *\n      * @param chars  the characters to match, must not be null\n      * @throws IllegalArgumentException if the character set is null or empty\n      */\n \n     /**\n      * Constructor that creates a matcher from a string representing a set of characters.\n-     * \n+     *\n      * @param chars  the characters to match, must not be null\n      * @throws IllegalArgumentException if the character set is null or empty\n      */\n \n     /**\n      * Constructor that creates a matcher from a character.\n-     * \n+     *\n      * @param ch  the character to match, must not be null\n      */\n     public static Matcher createCharMatcher(char ch) {\n \n     /**\n      * Constructor that creates a matcher from a string.\n-     * \n+     *\n      * @param str  the string to match, must not be null\n      * @throws IllegalArgumentException if the string is null or empty\n      */\n     }\n \n     //-----------------------------------------------------------------------\n-    /**\n-     * Gets a new tokenizer instance which parses Comma Seperated Value strings.\n+\n+    /**\n+     * Gets a new tokenizer instance which parses Comma Seperated Value strings\n+     * initializing it with the given input.  The default for CSV processing\n+     * will be trim whitespace from both ends (which can be overriden with\n+     * the setTrimmer method).\n+     * <p>\n      * You must call a \"reset\" method to set the string which you want to parse.\n      */\n     public static StrTokenizer getCSVInstance() {\n \n     /**\n      * Gets a new tokenizer instance which parses Comma Seperated Value strings\n-     * initializing it with the given input.\n-     * \n-     * @param input  the string to parse\n+     * initializing it with the given input.  The default for CSV processing\n+     * will be trim whitespace from both ends (which can be overriden with\n+     * the setTrimmer method).\n+     *\n+     * @param input  the text to parse\n      */\n     public static StrTokenizer getCSVInstance(String input) {\n         StrTokenizer tok = (StrTokenizer)(CSV_TOKENIZER_PROTOTYPE.clone());\n \n     /**\n      * Gets a new tokenizer instance which parses Comma Seperated Value strings\n-     * initializing it with the given input.\n-     * \n+     * initializing it with the given input.  The default for CSV processing\n+     * will be trim whitespace from both ends (which can be overriden with\n+     * the setTrimmer method).\n+     *\n      * @param input  the text to parse\n      */\n     public static StrTokenizer getCSVInstance(char[] input) {\n \n     /**\n      * Gets a new tokenizer instance which parses Tab Seperated Value strings.\n+     * The default for CSV processing will be trim whitespace from both ends\n+     * (which can be overriden with the setTrimmer method).\n+     * <p>\n      * You must call a \"reset\" method to set the string which you want to parse.\n      */\n     public static StrTokenizer getTSVInstance() {\n     }\n \n     /**\n-     * Gets a new tokenizer instance which parses Tab Seperated Value strings\n-     * initializing it with the given input.\n-     * \n+     * Gets a new tokenizer instance which parses Tab Seperated Value strings.\n+     * The default for CSV processing will be trim whitespace from both ends\n+     * (which can be overriden with the setTrimmer method).\n      * @param input  the string to parse\n      */\n     public static StrTokenizer getTSVInstance(String input) {\n     }\n \n     /**\n-     * Gets a new tokenizer instance which parses Tab Seperated Value strings\n-     * initializing it with the given input.\n-     * \n-     * @param input  the text to parse\n+     * Gets a new tokenizer instance which parses Tab Seperated Value strings.\n+     * The default for CSV processing will be trim whitespace from both ends\n+     * (which can be overriden with the setTrimmer method).\n+     * @param input  the string to parse\n      */\n     public static StrTokenizer getTSVInstance(char[] input) {\n         StrTokenizer tok = (StrTokenizer)(TSV_TOKENIZER_PROTOTYPE.clone());\n     /**\n      * Constructs a tokenizer splitting on space, tab, newline and formfeed\n      * as per StringTokenizer.\n-     * \n+     *\n      * @param input  the string which is to be parsed\n      */\n     public StrTokenizer(String input) {\n \n     /**\n      * Constructs a tokenizer splitting on the specified delimiter character.\n-     * \n+     *\n      * @param input  the string which is to be parsed\n      * @param delim  the field delimiter character\n      */\n \n     /**\n      * Constructs a tokenizer splitting on the specified delimiter string.\n-     * \n+     *\n      * @param input  the string which is to be parsed\n      * @param delim  the field delimiter string\n      */\n \n     /**\n      * Constructs a tokenizer splitting using the specified delimiter matcher.\n-     * \n+     *\n      * @param input  the string which is to be parsed\n      * @param delim  the field delimiter matcher\n      */\n     /**\n      * Constructs a tokenizer splitting on the specified delimiter character\n      * and handling quotes using the specified quote character.\n-     * \n+     *\n      * @param input  the string which is to be parsed\n      * @param delim  the field delimiter character\n      * @param quote  the field quoted string character\n     /**\n      * Constructs a tokenizer splitting using the specified delimiter matcher\n      * and handling quotes using the specified quote matcher.\n-     * \n+     *\n      * @param input  the string which is to be parsed\n      * @param delim  the field delimiter matcher\n      * @param quote  the field quoted string matcher\n     /**\n      * Constructs a tokenizer splitting on space, tab, newline and formfeed\n      * as per StringTokenizer.\n-     * \n+     *\n      * @param input  the string which is to be parsed, cloned\n      */\n     public StrTokenizer(char[] input) {\n \n     /**\n      * Constructs a tokenizer splitting on the specified character.\n-     * \n+     *\n      * @param input  the string which is to be parsed, cloned\n      * @param delim the field delimiter character\n      */\n \n     /**\n      * Constructs a tokenizer splitting on the specified string.\n-     * \n+     *\n      * @param input  the string which is to be parsed, cloned\n      * @param delim the field delimiter string\n      */\n \n     /**\n      * Constructs a tokenizer splitting using the specified delimiter matcher.\n-     * \n+     *\n      * @param input  the string which is to be parsed, cloned\n      * @param delim  the field delimiter matcher\n      */\n     /**\n      * Constructs a tokenizer splitting on the specified delimiter character\n      * and handling quotes using the specified quote character.\n-     * \n+     *\n      * @param input  the string which is to be parsed, cloned\n      * @param delim  the field delimiter character\n      * @param quote  the field quoted string character\n     /**\n      * Constructs a tokenizer splitting using the specified delimiter matcher\n      * and handling quotes using the specified quote matcher.\n-     * \n+     *\n      * @param input  the string which is to be parsed, cloned\n      * @param delim  the field delimiter character\n      * @param quote  the field quoted string character\n     //-----------------------------------------------------------------------\n     /**\n      * Gets the number of tokens found in the String.\n-     * \n+     *\n      * @return the number of matched tokens\n      */\n     public int size() {\n \n     /**\n      * Gets the next token from the String.\n-     * \n+     *\n      * @return the next sequential token, or null when no more tokens are found\n      */\n     public String nextToken() {\n \n     /**\n      * Gets the previous token from the String.\n-     * \n+     *\n      * @return the previous sequential token, or null when no more tokens are found\n      */\n     public String previousToken() {\n \n     /**\n      * Gets a copy of the full token list.\n-     * \n+     *\n      * @return the tokens as a String array\n      */\n     public String[] getAllTokens() {\n      * Reset this tokenizer, giving it a new input string to parse.\n      * In this manner you can re-use a tokenizer with the same settings\n      * on multiple input lines.\n-     * \n+     *\n      * @param input  the new string to tokenize\n      */\n     public void reset(String input) {\n      * Reset this tokenizer, giving it a new input string to parse.\n      * In this manner you can re-use a tokenizer with the same settings\n      * on multiple input lines.\n-     * \n+     *\n      * @param input  the new character array to tokenize, cloned\n      */\n     public void reset(char [] input) {\n     //-----------------------------------------------------------------------\n     /**\n      * Checks whether there are any more tokens.\n-     * \n+     *\n      * @return true if there are more tokens\n      */\n     public boolean hasNext() {\n \n     /**\n      * Gets the next token. This method is equivalent to {@link #nextToken()}.\n-     * \n+     *\n      * @return the next String token\n      */\n     public Object next() {\n \n     /**\n      * Gets the index of the next token to return.\n-     * \n+     *\n      * @return the next token index\n      */\n     public int nextIndex() {\n \n     /**\n      * Checks whether there are any previous tokens that can be iterated to.\n-     * \n+     *\n      * @return true if there are previous tokens\n      */\n     public boolean hasPrevious() {\n \n     /**\n      * Gets the token previous to the last returned token.\n-     * \n+     *\n      * @return the previous token\n      */\n     public Object previous() {\n \n     /**\n      * Gets the index of the previous token.\n-     * \n+     *\n      * @return the previous token index\n      */\n     public int previousIndex() {\n \n     /**\n      * Adds a token to a list, paying attention to the parameters we've set.\n-     * \n+     *\n      * @param list  the list to add to\n      * @param tok  the token to add\n      */\n \n     /**\n      * Reads character by character through the String to get the next token.\n-     * \n+     *\n      * @param start  the first character of field\n      * @param cbuf  a character buffer for temporary computations (so we\n      *  don't have to keep recreating one)\n         int delimLen = 0;\n         int quoteLen = 0;\n         while (start < len &&\n-                (ignoreLen = ignored.isMatch(chars, len, start)) >= 1 &&\n                 (delimLen = delim.isMatch(chars, len, start)) < 1 &&\n                 (quoteLen = quote.isMatch(chars, len, start)) < 1) {\n             start += ignoreLen;\n         }\n-        \n+\n         if (start >= len) {\n             return start;\n         } else {\n                 start = readUnquoted(start, token);\n             }\n         }\n-//            \n+//\n //            // lengths not setup\n //            if ((delimLen = delim.isMatch(chars, start)) >= 1) {\n //                start += delimLen;\n \n     /**\n      * Reads a quoted string token.\n-     * \n+     *\n      * @param start The first character of field, immediately after any quote\n      * @param cbuf A character buffer for temporary computations (so we\n      *             don't have to keep recreating one)\n \n     /**\n      * Read an unquoted string until a delimiter is found.\n-     * \n+     *\n      * @param start  the first character of field\n      * @param token  a StringBuffer where the output token will go.\n      * @return  the starting position of the next field (the character\n             pos++;\n         }\n \n-        token.append(chars, start, Math.min(pos, len) - start);\n+        /* Trim string based on the trimmer matcher */\n+        while (trimmer.isMatch(chars, 1, start) > 0) {\n+\t\t\tstart++;\n+\t\t}\n+\n+\t\tint length = Math.min(pos, len) - start;\n+\n+        while (trimmer.isMatch(chars, 1, start + length - 1) > 0) {\n+\t\t\tlength--;\n+\t\t}\n+\n+        for (int i=0;i<length;i++) {\n+\t\t\tif (ignored.isMatch(chars, 1, start + i) == 0) {\n+\t\t\t\ttoken.append(chars[start + i]);\n+\t\t\t}\n+\t\t}\n+\n \n         return pos + delimLen;\n     }\n     //-----------------------------------------------------------------------\n     /**\n      * Gets the field delimiter matcher.\n-     * \n+     *\n      * @return the delimiter matcher in use\n      */\n     public Matcher getDelimiterMatcher() {\n      * Sets the field delimiter matcher.\n      * <p>\n      * The delimitier is used to separate one token from another.\n-     * \n+     *\n      * @param delim  the delimiter matcher to use\n      */\n     public void setDelimiterMatcher(Matcher delim) {\n \n     /**\n      * Sets the field delimiter character\n-     * \n+     *\n      * @param delim  the delimiter character to use\n      */\n     public void setDelimiterChar(char delim) {\n \n     /**\n      * Sets the field delimiter character\n-     * \n+     *\n      * @param delim  the delimiter character to use\n      */\n     public void setDelimiterString(String delim) {\n      * The quote character is used to wrap data between the tokens.\n      * This enables delimiters to be entered as data.\n      * The default value is '\"' (double quote).\n-     * \n+     *\n      * @return the quote matcher in use\n      */\n     public Matcher getQuoteMatcher() {\n      * <p>\n      * The quote character is used to wrap data between the tokens.\n      * This enables delimiters to be entered as data.\n-     * \n+     *\n      * @param quote  the quote matcher to use, null ignored\n      */\n     public void setQuoteMatcher(Matcher quote) {\n      * <p>\n      * The quote character is used to wrap data between the tokens.\n      * This enables delimiters to be entered as data.\n-     * \n+     *\n      * @param quote  the quote character to use\n      */\n     public void setQuoteChar(char quote) {\n      * These characters are ignored when parsing the String, unless they are\n      * within a quoted region.\n      * The default value is space (' ') and all char control characters (32 and less).\n-     * \n+     *\n      * @return the ignored matcher in use\n      */\n     public Matcher getIgnoredMatcher() {\n      * <p>\n      * These characters are ignored when parsing the String, unless they are\n      * within a quoted region.\n-     * \n+     *\n      * @param ignored  the ignored matcher to use, null ignored\n      */\n     public void setIgnoredMatcher(Matcher ignored) {\n         if (ignored != null) {\n             this.ignored = ignored;\n+        }\n+    }\n+\n+    // Trimmer\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the trimmer character matcher.\n+     * <p>\n+     * These characters are trimmed off the beginning and ending of an unquoted string.\n+     * The default value is space (' ') and all char control characters (32 and less).\n+     *\n+     * @return the trimmer matcher in use\n+     */\n+    public Matcher getTrimmerMatcher() {\n+        return trimmer;\n+    }\n+\n+    /**\n+     * Set the matcher for characters to trim off the beginning and end of an\n+     * unquoted string.\n+     *\n+     * @param trimmer  the trimmer matcher to use, null ignored\n+     */\n+    public void setTrimmerMatcher(Matcher trimmer) {\n+        if (trimmer != null) {\n+            this.trimmer = trimmer;\n         }\n     }\n \n      * <p>\n      * This character is ignored when parsing the String, unless it is\n      * within a quoted region.\n-     * \n+     *\n      * @param ignored  the ignored character to use\n      */\n     public void setIgnoredChar(char ignored) {\n     /**\n      * Gets whether the tokenizer currently returns empty tokens as null.\n      * The default for this property is false.\n-     * \n+     *\n      * @return true if empty tokens are returned as null\n      */\n     public boolean isEmptyTokenAsNull() {\n     /**\n      * Sets whether the tokenizer should return empty tokens as null.\n      * The default for this property is false.\n-     * \n+     *\n      * @param emptyAsNull  whether empty tokens are returned as null\n      */\n     public void setEmptyTokenAsNull(boolean emptyAsNull) {\n     /**\n      * Gets whether the tokenizer currently ignores empty tokens.\n      * The default for this property is false.\n-     * \n+     *\n      * @return true if empty tokens are not returned\n      */\n     public boolean isIgnoreEmptyTokens() {\n     /**\n      * Sets whether the tokenizer should ignore and not return empty tokens.\n      * The default for this property is false.\n-     * \n+     *\n      * @param ignoreEmptyTokens  whether empty tokens are not returned\n      */\n     public void setIgnoreEmptyTokens(boolean ignoreEmptyTokens) {\n     //-----------------------------------------------------------------------\n     /**\n      * Gets the String content that the tokenizer is parsing.\n-     * \n+     *\n      * @return the string content being parsed\n      */\n     public String getContent() {\n         }\n         return text;\n     }\n-    \n+\n     //-----------------------------------------------------------------------\n     /**\n      * Create a new instance of this Tokenizer.\n             // chars[] does not need additional clone as it is treated as immutable\n             cloned.reset();\n             return cloned;\n-            \n+\n         } catch (CloneNotSupportedException ex) {\n             return null;\n         }\n     }\n \n-    //-----------------------------------------------------------------------    \n+    //-----------------------------------------------------------------------\n     /**\n      * Defines the interface used to match a set of characters during tokenization.\n      * Standard implementations of this interface are provided in the library.\n          * The matching code may check one character or many.\n          * It must return zero for no match, or a positive number if a match was found.\n          * The number indicates the number of characters that matched.\n-         * \n+         *\n          * @param text  the text content to match against, do not change\n          * @param textLen  the length of the text\n          * @param pos  the starting position for the match, valid for text\n         int isMatch(char[] text, int textLen, int pos);\n     }\n \n-    //-----------------------------------------------------------------------    \n+    //-----------------------------------------------------------------------\n     /**\n      * Class used to define a set of characters for matching purposes.\n      */\n-    static final class CharSetMatcher implements Matcher {\n+    public static final class CharSetMatcher implements Matcher {\n         private char[] chars;\n \n         /**\n          * Constructor that creates a matcher from a character array.\n-         * \n+         *\n          * @param chars  the characters to match, must not be null\n          */\n-        CharSetMatcher(char chars[]) {\n+        public CharSetMatcher(char chars[]) {\n             super();\n             this.chars = (char[]) chars.clone();\n             Arrays.sort(this.chars);\n \n         /**\n          * Returns whether or not the given charatcer matches.\n-         * \n+         *\n          * @param text  the text content to match against\n          * @param textLen  the length of the text\n          * @param pos  the starting position\n         }\n     }\n \n-    //-----------------------------------------------------------------------    \n+    //-----------------------------------------------------------------------\n     /**\n      * Class used to define a character for matching purposes.\n      */\n \n         /**\n          * Constructor that creates a matcher that matches a single character.\n-         * \n+         *\n          * @param ch  the character to match\n          */\n         CharMatcher(char ch) {\n \n         /**\n          * Returns whether or not the given character matches.\n-         * \n+         *\n          * @param text  the text content to match against\n          * @param textLen  the length of the text\n          * @param pos  the starting position\n         }\n     }\n \n-    //-----------------------------------------------------------------------    \n+    //-----------------------------------------------------------------------\n     /**\n      * Class used to define a set of characters for matching purposes.\n      */\n \n         /**\n          * Constructor that creates a matcher from a String.\n-         * \n+         *\n          * @param chars  the characters to match, must not be null\n          */\n         StringMatcher(String str) {\n \n         /**\n          * Returns whether or not the given text matches the stored string.\n-         * \n+         *\n          * @param text  the text content to match against\n          * @param textLen  the length of the text\n          * @param pos  the starting position\n         }\n     }\n \n-    //-----------------------------------------------------------------------    \n+    //-----------------------------------------------------------------------\n     /**\n      * Class used to match no characters.\n      */\n \n         /**\n          * Always returns <code>false</code>.\n-         * \n+         *\n          * @param text  the text content to match against\n          * @param textLen  the length of the text\n          * @param pos  the starting position\n         }\n     }\n \n-    //-----------------------------------------------------------------------    \n+    //-----------------------------------------------------------------------\n     /**\n      * Class used to match whitespace as per trim().\n      */\n \n         /**\n          * Returns whether or not the given charatcer matches.\n-         * \n+         *\n          * @param text  the text content to match against\n          * @param textLen  the length of the text\n          * @param pos  the starting position", "timestamp": 1103828148, "metainfo": ""}