{"sha": "765445394812db1c3dedd22cce7749dfb7713971", "log": "PR: Bugzilla Bug 27789 \t  \t[Codec][PATCH] Quoted-printable codec (partial implementation) Submitted by:\tOleg Kalnichevski Reviewed by:\tGary Gregory   ", "commit": "\n--- /dev/null\n+++ b/src/java/org/apache/commons/codec/net/QuotedPrintableCodec.java\n+/*\n+ * Copyright 2001-2004 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */ \n+\n+package org.apache.commons.codec.net;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.UnsupportedEncodingException;\n+import java.util.BitSet;\n+\n+import org.apache.commons.codec.BinaryDecoder;\n+import org.apache.commons.codec.BinaryEncoder;\n+import org.apache.commons.codec.DecoderException;\n+import org.apache.commons.codec.EncoderException;\n+import org.apache.commons.codec.StringDecoder;\n+import org.apache.commons.codec.StringEncoder;\n+\n+/**\n+ * <p>\n+ * Codec for RFC 1521 MIME (Multipurpose Internet Mail Extensions) Part One.\n+ * </p>\n+ * <p>\n+ * The Quoted-Printable encoding is intended to represent data that\n+ * largely consists of octets that correspond to printable characters in\n+ * the ASCII character set.  It encodes the data in such a way that the\n+ * resulting octets are unlikely to be modified by mail transport.  If\n+ * the data being encoded are mostly ASCII text, the encoded form of the\n+ * data remains largely recognizable by humans.  A body which is\n+ * entirely ASCII may also be encoded in Quoted-Printable to ensure the\n+ * integrity of the data should the message pass through a character-\n+ * translating, and/or line-wrapping gateway.\n+ * </p>\n+ *  \n+ * <p>\n+ * Note:\n+ * </p>\n+ * <p>\n+ * Not implemented: rule #3, rule #4, rule #5 of the quoted-printable\n+ * spec, because the complete quoted-printable spec does not lend itself well\n+ * into the byte[] oriented codec framework. Complete the codec once the\n+ * steamable codec framework is ready. The motivation behind providing the codec in\n+ * a partial form is that it can already come in handy for those applications that\n+ * do not require quoted-printable line formatting (rules #3, #4, #5), for instance\n+ * Q codec.\n+ * </p>\n+ * \n+ * @see <a href=\"http://http://www.ietf.org/rfc/rfc1521.txt\">\n+ * MIME (Multipurpose Internet Mail Extensions) Part One</a>\n+ * \n+ * @author Apache Software Foundation\n+ * @since 1.3\n+ * @version $Id: QuotedPrintableCodec.java,v 1.1 2004/03/21 02:20:25 ggregory Exp $\n+ */\n+public class QuotedPrintableCodec \n+        implements BinaryEncoder, BinaryDecoder, \n+                   StringEncoder, StringDecoder \n+{\n+    \n+    private final static String US_ASCII = \"US-ASCII\";\n+    \n+    /**\n+     * The default charset used for string decoding and encoding.\n+     */\n+    protected String charset = \"UTF-8\";\n+    \n+    /**\n+     * BitSet of printable characters as defined in RFC 1521.\n+     */\n+    protected static final BitSet PRINTABLE_CHARS = new BitSet(256);\n+    \n+    protected static byte ESCAPE_CHAR = '=';\n+    protected static byte TAB = 9;\n+    protected static byte CR = 13;\n+    protected static byte LF = 10;\n+    protected static byte SPACE = 32;\n+    \n+    // Static initializer for printable chars collection\n+    static {\n+        // alpha characters\n+        for (int i = 33; i <= 60; i++) {\n+            PRINTABLE_CHARS.set(i);\n+        }\n+        for (int i = 62; i <= 126; i++) {\n+            PRINTABLE_CHARS.set(i);\n+        }\n+        PRINTABLE_CHARS.set(TAB);\n+        PRINTABLE_CHARS.set(SPACE);\n+    }\n+\n+\n+    /**\n+     * Default constructor.\n+     */\n+    public QuotedPrintableCodec() {\n+        super();\n+    }\n+\n+    /**\n+     * Constructor which allows for the selection of a default charset\n+     * \n+     * @param charset the default string charset to use.\n+     */\n+    public QuotedPrintableCodec(String charset) {\n+        super();\n+        this.charset = charset;\n+    }\n+\n+    /**\n+     * Encodes byte into its quoted-printable representation.\n+     * \n+     * @param b byte to encode\n+     * @param buffer the buffer to write to \n+     */\n+    private static final void encodeQuotedPrintable(int b, ByteArrayOutputStream buffer)\n+    {\n+        buffer.write(ESCAPE_CHAR);\n+        char hex1 = Character.toUpperCase(\n+          Character.forDigit((b >> 4) & 0xF, 16));\n+        char hex2 = Character.toUpperCase(\n+          Character.forDigit(b & 0xF, 16));\n+        buffer.write(hex1);\n+        buffer.write(hex2);\n+    }\n+\n+    /**\n+     * Encodes an array of bytes into an array of quoted-printable 7-bit \n+     * characters. Unsafe characters are escaped.\n+     * \n+     * <p>This function implements a subset of quoted-printable encoding \n+     * specification (rule #1 and rule #2) as defined in RFC 1521 and is \n+     * suitable for encoding binary data and unformatted text.\n+     * </p>\n+     *\n+     * @param printable bitset of characters deemed quoted-printable\n+     * @param pArray array of bytes to be encoded\n+     * @return array of bytes containing quoted-printable data\n+     */\n+    public static final byte[] encodeQuotedPrintable(BitSet printable, byte[] pArray) {\n+        if (pArray == null) {\n+            return null;\n+        }\n+        if (printable == null) {\n+            printable = PRINTABLE_CHARS;\n+        }\n+        ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n+        for (int i = 0; i < pArray.length; i++) {\n+            int b = pArray[i];\n+            if (b < 0) {\n+                b = 256 + b;\n+            }\n+            if (printable.get(b)) {\n+                buffer.write(b);\n+            } else {\n+                encodeQuotedPrintable(b, buffer);\n+            }\n+        }\n+        return buffer.toByteArray();\n+    }\n+\n+\n+    /**\n+     * Decodes an array quoted-printable characters into an array of \n+     * original bytes. Escaped characters are converted back to their \n+     * original representation.\n+     *\n+     * <p>This function implements a subset of quoted-printable encoding \n+     * specification (rule #1 and rule #2) as defined in RFC 1521.\n+     * </p>\n+     * \n+     * @param pArray array of quoted-printable characters\n+     * @return array of original bytes \n+     * @throws DecoderException Thrown if quoted-printable decoding is unsuccessful\n+     */\n+    public static final byte[] decodeQuotedPrintable(byte[] pArray) \n+         throws DecoderException\n+    {\n+        if (pArray == null) {\n+            return null;\n+        }\n+        ByteArrayOutputStream buffer = new ByteArrayOutputStream(); \n+        for (int i = 0; i < pArray.length; i++) {\n+            int b = pArray[i];\n+            if (b == ESCAPE_CHAR) {\n+                try {\n+                    int u = Character.digit((char)pArray[++i], 16);\n+                    int l = Character.digit((char)pArray[++i], 16);\n+                    if (u == -1 || l == -1) {\n+                        throw new DecoderException(\"Invalid quoted-printable encoding\");\n+                    }\n+                    buffer.write((char)((u << 4) + l));\n+                } catch(ArrayIndexOutOfBoundsException e) {\n+                    throw new DecoderException(\"Invalid quoted-printable encoding\");\n+                }\n+            } else {\n+                buffer.write(b);\n+            }\n+        }\n+        return buffer.toByteArray(); \n+    }\n+\n+\n+    /**\n+     * Encodes an array of bytes into an array of quoted-printable 7-bit \n+     * characters. Unsafe characters are escaped.\n+     * \n+     * <p>This function implements a subset of quoted-printable encoding \n+     * specification (rule #1 and rule #2) as defined in RFC 1521 and is \n+     * suitable for encoding binary data and unformatted text.\n+     * </p>\n+     *\n+     * @param pArray array of bytes to be encoded\n+     * @return array of bytes containing quoted-printable data\n+     */\n+    public byte[] encode(byte[] pArray) {\n+        return encodeQuotedPrintable(PRINTABLE_CHARS, pArray);\n+    }\n+\n+\n+    /**\n+     * Decodes an array of quoted-printable characters into an array of \n+     * original bytes. Escaped characters are converted back to their \n+     * original representation.\n+     *\n+     * <p>This function implements a subset of quoted-printable encoding \n+     * specification (rule #1 and rule #2) as defined in RFC 1521.\n+     * </p>\n+     * \n+     * @param pArray array of quoted-printable characters\n+     * @return array of original bytes \n+     * @throws DecoderException Thrown if quoted-printable decoding is unsuccessful\n+     */\n+    public byte[] decode(byte[] pArray) throws DecoderException {\n+        return decodeQuotedPrintable(pArray);\n+    }\n+\n+    /**\n+     * Encodes a string into its quoted-printable form using the default\n+     * string charset. Unsafe characters are escaped.\n+     * \n+     * <p>This function implements a subset of quoted-printable encoding \n+     * specification (rule #1 and rule #2) as defined in RFC 1521 and is \n+     * suitable for encoding binary data.\n+     * </p>\n+     *\n+     * @param pString string to convert to quoted-printable form\n+     * @return quoted-printable string\n+     * \n+     * @throws EncoderException Thrown if quoted-printable encoding is unsuccessful\n+     * \n+     * @see #getDefaultCharset()\n+     */\n+    public String encode(String pString) throws EncoderException {\n+        if (pString == null) {\n+            return null;\n+        }\n+        try {\n+            return encode(pString, getDefaultCharset());\n+        } catch(UnsupportedEncodingException e) {\n+            throw new EncoderException(e.getMessage());\n+        }\n+    }\n+\n+    /**\n+     * Decodes a quoted-printable string into its original form using the \n+     * specified string charset. Escaped characters are converted back \n+     * to their original representation.\n+     *\n+     * @param pString quoted-printable string to convert into its original form\n+     * @param charset the original string charset\n+     * @return original string \n+     * @throws DecoderException Thrown if quoted-printable decoding is \n+     *                          unsuccessful\n+     * @throws UnsupportedEncodingException Thrown if charset is not\n+     *                                      supported \n+     */\n+    public String decode(String pString, String charset) \n+        throws DecoderException, UnsupportedEncodingException \n+    {\n+        if (pString == null) {\n+            return null;\n+        }\n+        return new String(decode(pString.getBytes(US_ASCII)), charset);\n+    }\n+\n+    /**\n+     * Decodes a quoted-printable string into its original form using the \n+     * default string charset. Escaped characters are converted back \n+     * to their original representation.\n+     *\n+     * @param pString quoted-printable string to convert into its original form\n+     * @return original string \n+     * @throws DecoderException Thrown if quoted-printable decoding is \n+     *                          unsuccessful\n+     * @throws UnsupportedEncodingException Thrown if charset is not\n+     *                                      supported\n+     * @see #getDefaultCharset()\n+     */\n+    public String decode(String pString) throws DecoderException {\n+        if (pString == null) {\n+            return null;\n+        }\n+        try {\n+            return decode(pString, getDefaultCharset());\n+        } catch(UnsupportedEncodingException e) {\n+            throw new DecoderException(e.getMessage());\n+        }\n+    }\n+\n+    /**\n+     * Encodes an object into its quoted-printable safe form. Unsafe \n+     * characters are escaped.\n+     *\n+     * @param pObject string to convert to a quoted-printable form\n+     * @return quoted-printable object\n+     * @throws EncoderException Thrown if quoted-printable encoding is not \n+     *                          applicable to objects of this type or\n+     *                          if encoding is unsuccessful\n+     */\n+    public Object encode(Object pObject) throws EncoderException {\n+        if (pObject == null) {\n+            return null;\n+        } else if (pObject instanceof byte[]) {\n+            return encode((byte[])pObject);\n+        } else if (pObject instanceof String) {\n+            return encode((String)pObject);\n+        } else {\n+            throw new EncoderException(\"Objects of type \" +\n+                pObject.getClass().getName() + \" cannot be quoted-printable encoded\"); \n+              \n+        }\n+    }\n+\n+    /**\n+     * Decodes a quoted-printable object into its original form. Escaped \n+     * characters are converted back to their original representation.\n+     *\n+     * @param pObject quoted-printable object to convert into its original form\n+     * @return original object \n+     * @throws DecoderException Thrown if quoted-printable decoding is not \n+     *                          applicable to objects of this type\n+     *                          if decoding is unsuccessful\n+     */\n+    public Object decode(Object pObject) throws DecoderException {\n+        if (pObject == null) {\n+            return null;\n+        } else if (pObject instanceof byte[]) {\n+            return decode((byte[])pObject);\n+        } else if (pObject instanceof String) {\n+            return decode((String)pObject);\n+        } else {\n+            throw new DecoderException(\"Objects of type \" +\n+                pObject.getClass().getName() + \" cannot be quoted-printable decoded\"); \n+              \n+        }\n+    }\n+\n+    /**\n+     * Returns the default charset used for string decoding and encoding.\n+     *\n+     * @return the default string charset.\n+     */\n+    public String getDefaultCharset() {\n+        return this.charset;\n+    }\n+\n+    /**\n+     * Encodes a string into its quoted-printable form using the specified\n+     * charset. Unsafe characters are escaped.\n+     * \n+     * <p>This function implements a subset of quoted-printable encoding \n+     * specification (rule #1 and rule #2) as defined in RFC 1521 and is \n+     * suitable for encoding binary data and unformatted text.\n+     * </p>\n+     *\n+     * @param pString string to convert to quoted-printable form\n+     * @param charset the charset for pString\n+     * @return quoted-printable string\n+     * \n+     * @throws UnsupportedEncodingException Thrown if the charset is not\n+     *                                      supported \n+     */\n+    public String encode(String pString, String charset) \n+        throws UnsupportedEncodingException  \n+    {\n+        if (pString == null) {\n+            return null;\n+        }\n+        return new String(encode(pString.getBytes(charset)), US_ASCII);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/codec/net/QuotedPrintableCodecTest.java\n+/*\n+ * Copyright 2001-2004 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */ \n+\n+package org.apache.commons.codec.net;\n+\n+import org.apache.commons.codec.DecoderException;\n+import org.apache.commons.codec.EncoderException;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * Quoted-printable codec test cases\n+ * \n+ * @author <a href=\"mailto:oleg@ural.ru\">Oleg Kalnichevski</a>\n+ */\n+public class QuotedPrintableCodecTest extends TestCase {\n+    \n+    static final int SWISS_GERMAN_STUFF_UNICODE [] = {\n+        0x47, 0x72, 0xFC, 0x65, 0x7A, 0x69, 0x5F, 0x7A, 0xE4, 0x6D, 0xE4\n+    };\n+    \n+    static final int RUSSIAN_STUFF_UNICODE [] = {\n+        0x412, 0x441, 0x435, 0x43C, 0x5F, 0x43F, 0x440, 0x438, \n+        0x432, 0x435, 0x442 \n+    }; \n+\n+    public QuotedPrintableCodecTest(String name) {\n+        super(name);\n+    }\n+\n+    private String constructString(int [] unicodeChars) {\n+        StringBuffer buffer = new StringBuffer();\n+        if (unicodeChars != null) {\n+            for (int i = 0; i < unicodeChars.length; i++) {\n+                buffer.append((char)unicodeChars[i]); \n+            }\n+        }\n+        return buffer.toString();\n+    }\n+\n+    public void testUTF8RoundTrip() throws Exception {\n+\n+        String ru_msg = constructString(RUSSIAN_STUFF_UNICODE); \n+        String ch_msg = constructString(SWISS_GERMAN_STUFF_UNICODE); \n+        \n+        QuotedPrintableCodec qpcodec = new QuotedPrintableCodec();\n+        \n+        assertEquals(\n+            \"=D0=92=D1=81=D0=B5=D0=BC_=D0=BF=D1=80=D0=B8=D0=B2=D0=B5=D1=82\", \n+        qpcodec.encode(ru_msg, \"UTF-8\")\n+        );\n+        assertEquals(\"Gr=C3=BCezi_z=C3=A4m=C3=A4\", qpcodec.encode(ch_msg, \"UTF-8\"));\n+        \n+        assertEquals(ru_msg, qpcodec.decode(qpcodec.encode(ru_msg, \"UTF-8\"), \"UTF-8\"));\n+        assertEquals(ch_msg, qpcodec.decode(qpcodec.encode(ch_msg, \"UTF-8\"), \"UTF-8\"));\n+    }\n+\n+    public void testBasicEncodeDecode() throws Exception {\n+        QuotedPrintableCodec qpcodec = new QuotedPrintableCodec();\n+        String plain = \"= Hello there =\\r\\n\";\n+        String encoded = qpcodec.encode(plain);\n+        assertEquals(\"Basic quoted-printable encoding test\", \n+            \"=3D Hello there =3D=0D=0A\", encoded);\n+        assertEquals(\"Basic quoted-printable decoding test\", \n+            plain, qpcodec.decode(encoded));\n+    }\n+\n+    public void testSafeCharEncodeDecode() throws Exception {\n+        QuotedPrintableCodec qpcodec = new QuotedPrintableCodec();\n+        String plain = \"abc123_-.*~!@#$%^&()+{}\\\"\\\\;:`,/[]\";\n+        String encoded = qpcodec.encode(plain);\n+        assertEquals(\"Safe chars quoted-printable encoding test\", \n+            plain, encoded);\n+        assertEquals(\"Safe chars quoted-printable decoding test\", \n+            plain, qpcodec.decode(encoded));\n+    }\n+\n+\n+    public void testUnsafeEncodeDecode() throws Exception {\n+        QuotedPrintableCodec qpcodec = new QuotedPrintableCodec();\n+        String plain = \"=\\r\\n\";\n+        String encoded = qpcodec.encode(plain);\n+        assertEquals(\"Unsafe chars quoted-printable encoding test\", \n+            \"=3D=0D=0A\", encoded);\n+        assertEquals(\"Unsafe chars quoted-printable decoding test\", \n+            plain, qpcodec.decode(encoded));\n+    }\n+\n+    public void testEncodeDecodeNull() throws Exception {\n+        QuotedPrintableCodec qpcodec = new QuotedPrintableCodec();\n+        assertNull(\"Null string quoted-printable encoding test\", \n+            qpcodec.encode((String)null));\n+        assertNull(\"Null string quoted-printable decoding test\", \n+            qpcodec.decode((String)null));\n+    }\n+\n+\n+    public void testDecodeInvalid() throws Exception {\n+        QuotedPrintableCodec qpcodec = new QuotedPrintableCodec();\n+        try {\n+            qpcodec.decode(\"=\");\n+            fail(\"DecoderException should have been thrown\");\n+        } catch(DecoderException e) {\n+            // Expected. Move on\n+        }\n+        try {\n+            qpcodec.decode(\"=A\");\n+            fail(\"DecoderException should have been thrown\");\n+        } catch(DecoderException e) {\n+            // Expected. Move on\n+        }\n+        try {\n+            qpcodec.decode(\"=WW\");\n+            fail(\"DecoderException should have been thrown\");\n+        } catch(DecoderException e) {\n+            // Expected. Move on\n+        }\n+    }\n+\n+    public void testEncodeNull() throws Exception {\n+        QuotedPrintableCodec qpcodec = new QuotedPrintableCodec();\n+        byte[] plain = null;\n+        byte[] encoded = qpcodec.encode(plain);\n+        assertEquals(\"Encoding a null string should return null\", \n+            null, encoded);\n+    }\n+    \n+    public void testEncodeUrlWithNullBitSet() throws Exception {\n+        QuotedPrintableCodec qpcodec = new QuotedPrintableCodec();\n+        String plain = \"1+1 = 2\";\n+        String encoded = new String(QuotedPrintableCodec.\n+            encodeQuotedPrintable(null, plain.getBytes()));\n+        assertEquals(\"Basic quoted-printable encoding test\", \n+            \"1+1 =3D 2\", encoded);\n+        assertEquals(\"Basic quoted-printable decoding test\", \n+            plain, qpcodec.decode(encoded));\n+        \n+    }\n+\n+    public void testDecodeWithNullArray() throws Exception {\n+        byte[] plain = null;\n+        byte[] result = QuotedPrintableCodec.decodeQuotedPrintable( plain );\n+        assertEquals(\"Result should be null\", null, result);\n+    }\n+\n+    public void testEncodeStringWithNull() throws Exception {\n+        QuotedPrintableCodec qpcodec = new QuotedPrintableCodec();\n+        String test = null;\n+        String result = qpcodec.encode( test, \"charset\" );\n+        assertEquals(\"Result should be null\", null, result);\n+    }\n+\n+    public void testDecodeStringWithNull() throws Exception {\n+        QuotedPrintableCodec qpcodec = new QuotedPrintableCodec();\n+        String test = null;\n+        String result = qpcodec.decode( test, \"charset\" );\n+        assertEquals(\"Result should be null\", null, result);\n+    }\n+    \n+    public void testEncodeObjects() throws Exception {\n+        QuotedPrintableCodec qpcodec = new QuotedPrintableCodec();\n+        String plain = \"1+1 = 2\";\n+        String encoded = (String) qpcodec.encode((Object) plain);\n+        assertEquals(\"Basic quoted-printable encoding test\", \n+            \"1+1 =3D 2\", encoded);\n+\n+        byte[] plainBA = plain.getBytes();\n+        byte[] encodedBA = (byte[]) qpcodec.encode((Object) plainBA);\n+        encoded = new String(encodedBA);\n+        assertEquals(\"Basic quoted-printable encoding test\", \n+            \"1+1 =3D 2\", encoded);\n+            \n+        Object result = qpcodec.encode((Object) null);\n+        assertEquals( \"Encoding a null Object should return null\", null, result);\n+        \n+        try {\n+            Object dObj = new Double(3.0);\n+            qpcodec.encode( dObj );\n+            fail( \"Trying to url encode a Double object should cause an exception.\");\n+        } catch( EncoderException ee ) {\n+            // Exception expected, test segment passes.\n+        }\n+    }\n+    \n+    public void testInvalidEncoding() {\n+        QuotedPrintableCodec qpcodec = new QuotedPrintableCodec(\"NONSENSE\");\n+           String plain = \"Hello there!\";\n+            try {\n+               qpcodec.encode(plain);\n+                fail( \"We set the encoding to a bogus NONSENSE vlaue, this shouldn't have worked.\");\n+            } catch( EncoderException ee ) {\n+                // Exception expected, test segment passes.\n+            }\n+            try {\n+               qpcodec.decode(plain);\n+                fail( \"We set the encoding to a bogus NONSENSE vlaue, this shouldn't have worked.\");\n+            } catch( DecoderException ee ) {\n+                // Exception expected, test segment passes.\n+            }\n+    }\n+\n+    public void testDecodeObjects() throws Exception {\n+        QuotedPrintableCodec qpcodec = new QuotedPrintableCodec();\n+        String plain = \"1+1 =3D 2\";\n+        String decoded = (String) qpcodec.decode((Object) plain);\n+        assertEquals(\"Basic quoted-printable decoding test\", \n+            \"1+1 = 2\", decoded);\n+\n+        byte[] plainBA = plain.getBytes();\n+        byte[] decodedBA = (byte[]) qpcodec.decode((Object) plainBA);\n+        decoded = new String(decodedBA);\n+        assertEquals(\"Basic quoted-printable decoding test\", \n+            \"1+1 = 2\", decoded);\n+            \n+        Object result = qpcodec.decode((Object) null);\n+        assertEquals( \"Decoding a null Object should return null\", null, result);\n+        \n+        try {\n+            Object dObj = new Double(3.0);\n+            qpcodec.decode( dObj );\n+            fail( \"Trying to url encode a Double object should cause an exception.\");\n+        } catch( DecoderException ee ) {\n+            // Exception expected, test segment passes.\n+        }\n+    }\n+\n+    public void testDefaultEncoding() throws Exception {\n+        String plain = \"Hello there!\";\n+        QuotedPrintableCodec qpcodec = new QuotedPrintableCodec(\"UnicodeBig\");\n+        qpcodec.encode(plain); // To work around a weird quirk in Java 1.2.2\n+        String encoded1 = qpcodec.encode(plain, \"UnicodeBig\");\n+        String encoded2 = qpcodec.encode(plain);\n+        assertEquals(encoded1, encoded2);\n+    }\n+}", "timestamp": 1079835625, "metainfo": ""}