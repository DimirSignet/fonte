{"sha": "0e0d47592c8ce9aac136d336c8ac931a06fd6feb", "log": "Javadoc clean up such that the class description one liner forms a complete sentence. Under 1.4.x, javadoc was ending the one liner with the first initial of the last name of the first author since a period character followed the initial.   ", "commit": "\n--- a/src/java/org/apache/commons/codec/binary/Base64.java\n+++ b/src/java/org/apache/commons/codec/binary/Base64.java\n-/*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//codec/src/java/org/apache/commons/codec/binary/Base64.java,v 1.1 2003/04/25 17:50:56 tobrien Exp $\n- * $Revision: 1.1 $\n- * $Date: 2003/04/25 17:50:56 $\n-  *\n-  * ====================================================================\n-  *\n-  * The Apache Software License, Version 1.1\n-  *\n-  * Copyright (c) 2003 The Apache Software Foundation.  All rights\n-  * reserved.\n-  *\n-  * Redistribution and use in source and binary forms, with or without\n-  * modification, are permitted provided that the following conditions\n-  * are met:\n-  *\n-  * 1. Redistributions of source code must retain the above copyright\n-  *    notice, this list of conditions and the following disclaimer.\n-  *\n-  * 2. Redistributions in binary form must reproduce the above copyright\n-  *    notice, this list of conditions and the following disclaimer in\n-  *    the documentation and/or other materials provided with the\n-  *    distribution.\n-  *\n-  * 3. The end-user documentation included with the redistribution, if\n-  *    any, must include the following acknowlegement:\n-  *       \"This product includes software developed by the\n-  *        Apache Software Foundation (http://www.apache.org/).\"\n-  *    Alternately, this acknowlegement may appear in the software itself,\n-  *    if and wherever such third-party acknowlegements normally appear.\n-  *\n-  * 4. The names \"The Jakarta Project\", \"Tomcat\", and \"Apache Software\n-  *    Foundation\" must not be used to endorse or promote products derived\n-  *    from this software without prior written permission. For written\n-  *    permission, please contact apache@apache.org.\n-  *\n-  * 5. Products derived from this software may not be called \"Apache\"\n-  *    nor may \"Apache\" appear in their names without prior written\n-  *    permission of the Apache Group.\n-  *\n-  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n-  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n-  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n-  * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n-  * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n-  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n-  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n-  * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n-  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n-  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n-  * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n-  * SUCH DAMAGE.\n-  * ====================================================================\n-  *\n-  * This software consists of voluntary contributions made by many\n-  * individuals on behalf of the Apache Software Foundation.  For more\n-  * information on the Apache Software Foundation, please see\n-  * <http://www.apache.org/>.\n-  *\n-  * [Additional notices, if required by prior licensing conditions]\n-  *\n-  */\n-package org.apache.commons.codec.binary;\n-\n-import org.apache.commons.codec.BinaryDecoder;\n-import org.apache.commons.codec.BinaryEncoder;\n-import org.apache.commons.codec.DecoderException;\n-import org.apache.commons.codec.EncoderException;\n-\n-/**\n-  * This class provides encode/decode for RFC 2045 Base64 as \n-  * defined by RFC 2045, N. Freed and N. Borenstein.  <a\n-  * href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045</a>:\n-  * Multipurpose Internet Mail Extensions (MIME) Part One: Format of\n-  * Internet Message Bodies. Reference 1996\n-  *\n-  * @author Jeffrey Rodriguez\n-  * @author <a href=\"dlr@apache.org\">Daniel Rall</a>\n-  * @author <a href=\"m.redington@ucl.ac.uk\">Martin Redington</a>\n-  * @since 1.0-dev\n-  *\n-  * @todo Add more documentation\n-  */\n-public class Base64 implements BinaryEncoder, BinaryDecoder {\n-\n-    // Create constants pertaining to the chunk requirement\n-    static final int CHUNK_SIZE = 76;\n-    static final byte[] CHUNK_SEPARATOR = \"\\n\".getBytes();\n-\n-    // Create numerical and byte constants \n-    static final int BASELENGTH = 255;\n-    static final int LOOKUPLENGTH = 64;\n-    static final int TWENTYFOURBITGROUP = 24;\n-    static final int EIGHTBIT = 8;\n-    static final int SIXTEENBIT = 16;\n-    static final int SIXBIT = 6;\n-    static final int FOURBYTE = 4;\n-    static final int SIGN = -128;\n-    static final byte PAD = (byte) '=';\n-\n-    // Create arrays to hold the base64 characters and a \n-    // lookup for base64 chars\n-    private static byte[] base64Alphabet = new byte[BASELENGTH];\n-    private static byte[] lookUpBase64Alphabet = new byte[LOOKUPLENGTH];\n-\n-    // Populating the lookup and character arrays\n-    static {\n-        for (int i = 0; i < BASELENGTH; i++) {\n-            base64Alphabet[i] = (byte) -1;\n-        }\n-        for (int i = 'Z'; i >= 'A'; i--) {\n-            base64Alphabet[i] = (byte) (i - 'A');\n-        }\n-        for (int i = 'z'; i >= 'a'; i--) {\n-            base64Alphabet[i] = (byte) (i - 'a' + 26);\n-        }\n-        for (int i = '9'; i >= '0'; i--) {\n-            base64Alphabet[i] = (byte) (i - '0' + 52);\n-        }\n-\n-        base64Alphabet['+'] = 62;\n-        base64Alphabet['/'] = 63;\n-\n-        for (int i = 0; i <= 25; i++) {\n-            lookUpBase64Alphabet[i] = (byte) ('A' + i);\n-        }\n-\n-        for (int i = 26, j = 0; i <= 51; i++, j++) {\n-            lookUpBase64Alphabet[i] = (byte) ('a' + j);\n-        }\n-\n-        for (int i = 52, j = 0; i <= 61; i++, j++) {\n-            lookUpBase64Alphabet[i] = (byte) ('0' + j);\n-        }\n-\n-        lookUpBase64Alphabet[62] = (byte) '+';\n-        lookUpBase64Alphabet[63] = (byte) '/';\n-    }\n-\n-    private static boolean isBase64(byte octect) {\n-        if (octect == PAD) {\n-            return true;\n-        } \n-        else if (base64Alphabet[octect] == -1) {\n-            return false;\n-        } \n-        else {\n-            return true;\n-        }\n-    }\n-\n-    public static boolean isArrayByteBase64(byte[] arrayOctect) {\n-\n-        arrayOctect = discardWhitespace(arrayOctect);\n-\n-        int length = arrayOctect.length;\n-        if (length == 0) {\n-            // shouldn't a 0 length array be valid base64 data?\n-            // return false;\n-            return true;\n-        }\n-        for (int i = 0; i < length; i++) {\n-            if (!isBase64(arrayOctect[i])) {\n-                return false;\n-            }\n-        }\n-        return true;\n-    }\n-\n-\n-    public static byte[] encodeBase64(byte[] binaryData) {\n-        return (encodeBase64(binaryData, false));\n-    }\n-\n-    public static byte[] encodeBase64Chunked(byte[] binaryData) {\n-        return (encodeBase64(binaryData, true));\n-    }\n-\n-    public Object decode(Object pObject) throws DecoderException {\n-\n-        Object result;\n-\n-        if (!(pObject instanceof byte[])) {\n-            throw new DecoderException(\n-                \"Parameter supplied to \"\n-                    + \"Base64 \"\n-                    + \"decode is not a byte[]\");\n-        } \n-        else {\n-            result = decode((byte[]) pObject);\n-        }\n-\n-        return result;\n-\n-    }\n-\n-    public byte[] decode(byte[] pArray) throws DecoderException {\n-\n-        byte[] result;\n-\n-        if (!isArrayByteBase64(pArray)) {\n-            throw new DecoderException(\n-                \"Parameter supplied to \"\n-                    + \"Base64 \"\n-                    + \"decode is not a valid base64 data.\");\n-        } \n-        else {\n-            result = decodeBase64((byte[]) pArray);\n-        }\n-\n-        return (result);\n-    }\n-\n-    /**\n-     * Encodes hex octects into Base64.\n-     *\n-     * @param binaryData Array containing binary data to encode.\n-     * @return Base64-encoded data.\n-     */\n-    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n-        int lengthDataBits = binaryData.length * EIGHTBIT;\n-        int fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n-        int numberTriplets = lengthDataBits / TWENTYFOURBITGROUP;\n-        byte encodedData[] = null;\n-        int encodedDataLength = 0;\n-        int nbrChunks = 0;\n-\n-        if (fewerThan24bits != 0) {\n-            //data not divisible by 24 bit\n-            encodedDataLength = (numberTriplets + 1) * 4;\n-        } \n-        else {\n-            // 16 or 8 bit\n-            encodedDataLength = numberTriplets * 4;\n-        }\n-\n-        // If the output is to be \"chunked\" into 76 character sections, \n-        // for compliance with RFC 2045 MIME, then it is important to \n-        // allow for extra length to account for the separator(s)\n-        if (isChunked) {\n-\n-            nbrChunks =\n-                (CHUNK_SEPARATOR.length == 0\n-                    ? 0\n-                    : (int) Math.ceil((float) encodedDataLength / CHUNK_SIZE));\n-            encodedDataLength += nbrChunks * CHUNK_SEPARATOR.length;\n-        }\n-\n-        encodedData = new byte[encodedDataLength];\n-\n-        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n-\n-        int encodedIndex = 0;\n-        int dataIndex = 0;\n-        int i = 0;\n-        int nextSeparatorIndex = CHUNK_SIZE;\n-        int chunksSoFar = 0;\n-\n-        //log.debug(\"number of triplets = \" + numberTriplets);\n-        for (i = 0; i < numberTriplets; i++) {\n-            dataIndex = i * 3;\n-            b1 = binaryData[dataIndex];\n-            b2 = binaryData[dataIndex + 1];\n-            b3 = binaryData[dataIndex + 2];\n-\n-            //log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n-\n-            l = (byte) (b2 & 0x0f);\n-            k = (byte) (b1 & 0x03);\n-\n-            byte val1 =\n-                ((b1 & SIGN) == 0)\n-                    ? (byte) (b1 >> 2)\n-                    : (byte) ((b1) >> 2 ^ 0xc0);\n-            byte val2 =\n-                ((b2 & SIGN) == 0)\n-                    ? (byte) (b2 >> 4)\n-                    : (byte) ((b2) >> 4 ^ 0xf0);\n-            byte val3 =\n-                ((b3 & SIGN) == 0)\n-                    ? (byte) (b3 >> 6)\n-                    : (byte) ((b3) >> 6 ^ 0xfc);\n-\n-            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n-            //log.debug( \"val2 = \" + val2 );\n-            //log.debug( \"k4   = \" + (k<<4) );\n-            //log.debug(  \"vak  = \" + (val2 | (k<<4)) );\n-            encodedData[encodedIndex + 1] =\n-                lookUpBase64Alphabet[val2 | (k << 4)];\n-            encodedData[encodedIndex + 2] =\n-                lookUpBase64Alphabet[(l << 2) | val3];\n-            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n-\n-            encodedIndex += 4;\n-\n-            // If we are chunking, let's put a chunk separator down.\n-            if (isChunked) {\n-                // this assumes that CHUNK_SIZE % 4 == 0\n-                if (encodedIndex == nextSeparatorIndex) {\n-                    System.arraycopy(\n-                        CHUNK_SEPARATOR,\n-                        0,\n-                        encodedData,\n-                        encodedIndex,\n-                        CHUNK_SEPARATOR.length);\n-                    chunksSoFar++;\n-                    nextSeparatorIndex =\n-                        (CHUNK_SIZE * (chunksSoFar + 1))\n-                            + (chunksSoFar * CHUNK_SEPARATOR.length);\n-                    encodedIndex += CHUNK_SEPARATOR.length;\n-                }\n-            }\n-        }\n-\n-        // form integral number of 6-bit groups\n-        dataIndex = i * 3;\n-\n-        if (fewerThan24bits == EIGHTBIT) {\n-            b1 = binaryData[dataIndex];\n-            k = (byte) (b1 & 0x03);\n-            //log.debug(\"b1=\" + b1);\n-            //log.debug(\"b1<<2 = \" + (b1>>2) );\n-            byte val1 =\n-                ((b1 & SIGN) == 0)\n-                    ? (byte) (b1 >> 2)\n-                    : (byte) ((b1) >> 2 ^ 0xc0);\n-            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n-            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n-            encodedData[encodedIndex + 2] = PAD;\n-            encodedData[encodedIndex + 3] = PAD;\n-        } \n-        else if (fewerThan24bits == SIXTEENBIT) {\n-\n-            b1 = binaryData[dataIndex];\n-            b2 = binaryData[dataIndex + 1];\n-            l = (byte) (b2 & 0x0f);\n-            k = (byte) (b1 & 0x03);\n-\n-            byte val1 =\n-                ((b1 & SIGN) == 0)\n-                    ? (byte) (b1 >> 2)\n-                    : (byte) ((b1) >> 2 ^ 0xc0);\n-            byte val2 =\n-                ((b2 & SIGN) == 0)\n-                    ? (byte) (b2 >> 4)\n-                    : (byte) ((b2) >> 4 ^ 0xf0);\n-\n-            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n-            encodedData[encodedIndex + 1] =\n-                lookUpBase64Alphabet[val2 | (k << 4)];\n-            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n-            encodedData[encodedIndex + 3] = PAD;\n-        }\n-\n-        if (isChunked) {\n-            // we also add a separator to the end of the final chunk.\n-            if (chunksSoFar < nbrChunks) {\n-                System.arraycopy(\n-                    CHUNK_SEPARATOR,\n-                    0,\n-                    encodedData,\n-                    encodedDataLength - CHUNK_SEPARATOR.length,\n-                    CHUNK_SEPARATOR.length);\n-            }\n-        }\n-\n-        return encodedData;\n-    }\n-\n-    /**\n-     * Decodes Base64 data into octects\n-     *\n-     * @param binaryData Byte array containing Base64 data\n-     * @return Array containing decoded data.\n-     */\n-    public static byte[] decodeBase64(byte[] base64Data) {\n-        // RFC 2045 suggests line wrapping at (no more than) 76\n-        // characters -- we may have embedded whitespace.\n-        base64Data = discardWhitespace(base64Data);\n-\n-        // handle the edge case, so we don't have to worry about it later\n-        if (base64Data.length == 0) {\n-            return new byte[0];\n-        }\n-\n-        int numberQuadruple = base64Data.length / FOURBYTE;\n-        byte decodedData[] = null;\n-        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n-\n-        // Throw away anything not in base64Data\n-\n-        int encodedIndex = 0;\n-        int dataIndex = 0;\n-        {\n-            // this sizes the output array properly - rlw\n-            int lastData = base64Data.length;\n-            // ignore the '=' padding\n-            while (base64Data[lastData - 1] == PAD) {\n-                if (--lastData == 0) {\n-                    return new byte[0];\n-                }\n-            }\n-            decodedData = new byte[lastData - numberQuadruple];\n-        }\n-\n-        for (int i = 0; i < numberQuadruple; i++) {\n-            dataIndex = i * 4;\n-            marker0 = base64Data[dataIndex + 2];\n-            marker1 = base64Data[dataIndex + 3];\n-\n-            b1 = base64Alphabet[base64Data[dataIndex]];\n-            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n-\n-            if (marker0 != PAD && marker1 != PAD) {\n-                //No PAD e.g 3cQl\n-                b3 = base64Alphabet[marker0];\n-                b4 = base64Alphabet[marker1];\n-\n-                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n-                decodedData[encodedIndex + 1] =\n-                    (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n-                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n-            } \n-            else if (marker0 == PAD) {\n-                //Two PAD e.g. 3c[Pad][Pad]\n-                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n-            } \n-            else if (marker1 == PAD) {\n-                //One PAD e.g. 3cQ[Pad]\n-                b3 = base64Alphabet[marker0];\n-\n-                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n-                decodedData[encodedIndex + 1] =\n-                    (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n-            }\n-            encodedIndex += 3;\n-        }\n-        return decodedData;\n-    }\n-\n-    /**\n-     * Discards any whitespace from a base-64 encoded block.\n-     *\n-     * @param data The base-64 encoded data to discard the whitespace\n-     * from.\n-     * @return The data, less whitespace (see RFC 2045).\n-     */\n-    static byte[] discardWhitespace(byte[] data) {\n-        byte groomedData[] = new byte[data.length];\n-        int bytesCopied = 0;\n-\n-        for (int i = 0; i < data.length; i++) {\n-            switch (data[i]) {\n-                case (byte) ' ' :\n-                case (byte) '\\n' :\n-                case (byte) '\\r' :\n-                case (byte) '\\t' :\n-                    break;\n-                default:\n-                    groomedData[bytesCopied++] = data[i];\n-            }\n-        }\n-\n-        byte packedData[] = new byte[bytesCopied];\n-\n-        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);\n-\n-        return packedData;\n-    }\n-\n-    // Implementation of the Encoder Interface\n-\n-    /**\n-     * encode an Object\n-     */\n-    public Object encode(Object pObject) throws EncoderException {\n-\n-        Object result;\n-\n-        if (!(pObject instanceof byte[])) {\n-            throw new EncoderException(\n-                \"Parameter supplied to \"\n-                    + \"Base64 \"\n-                    + \"encode is not a byte[]\");\n-        } \n-        else {\n-            result = encode((byte[]) pObject);\n-        }\n-\n-        return result;\n-\n-    }\n-\n-    public byte[] encode(byte[] pArray) throws EncoderException {\n-        return (encodeBase64(pArray, false));\n-    }\n-\n-}\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//codec/src/java/org/apache/commons/codec/binary/Base64.java,v 1.2 2003/05/06 20:52:18 ggregory Exp $\n+ * $Revision: 1.2 $\n+ * $Date: 2003/05/06 20:52:18 $\n+  *\n+  * ====================================================================\n+  *\n+  * The Apache Software License, Version 1.1\n+  *\n+  * Copyright (c) 2003 The Apache Software Foundation.  All rights\n+  * reserved.\n+  *\n+  * Redistribution and use in source and binary forms, with or without\n+  * modification, are permitted provided that the following conditions\n+  * are met:\n+  *\n+  * 1. Redistributions of source code must retain the above copyright\n+  *    notice, this list of conditions and the following disclaimer.\n+  *\n+  * 2. Redistributions in binary form must reproduce the above copyright\n+  *    notice, this list of conditions and the following disclaimer in\n+  *    the documentation and/or other materials provided with the\n+  *    distribution.\n+  *\n+  * 3. The end-user documentation included with the redistribution, if\n+  *    any, must include the following acknowlegement:\n+  *       \"This product includes software developed by the\n+  *        Apache Software Foundation (http://www.apache.org/).\"\n+  *    Alternately, this acknowlegement may appear in the software itself,\n+  *    if and wherever such third-party acknowlegements normally appear.\n+  *\n+  * 4. The names \"The Jakarta Project\", \"Tomcat\", and \"Apache Software\n+  *    Foundation\" must not be used to endorse or promote products derived\n+  *    from this software without prior written permission. For written\n+  *    permission, please contact apache@apache.org.\n+  *\n+  * 5. Products derived from this software may not be called \"Apache\"\n+  *    nor may \"Apache\" appear in their names without prior written\n+  *    permission of the Apache Group.\n+  *\n+  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+  * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+  * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+  * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+  * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+  * SUCH DAMAGE.\n+  * ====================================================================\n+  *\n+  * This software consists of voluntary contributions made by many\n+  * individuals on behalf of the Apache Software Foundation.  For more\n+  * information on the Apache Software Foundation, please see\n+  * <http://www.apache.org/>.\n+  *\n+  * [Additional notices, if required by prior licensing conditions]\n+  *\n+  */\n+package org.apache.commons.codec.binary;\n+\n+import org.apache.commons.codec.BinaryDecoder;\n+import org.apache.commons.codec.BinaryEncoder;\n+import org.apache.commons.codec.DecoderException;\n+import org.apache.commons.codec.EncoderException;\n+\n+/**\n+  * Provides encode/decode for RFC 2045 Base64 as \n+  * defined by RFC 2045, by Freed and Borenstein.  <a\n+  * href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045</a>:\n+  * Multipurpose Internet Mail Extensions (MIME) Part One: Format of\n+  * Internet Message Bodies. Reference 1996.\n+  *\n+  * @author Jeffrey Rodriguez\n+  * @author <a href=\"dlr@apache.org\">Daniel Rall</a>\n+  * @author <a href=\"m.redington@ucl.ac.uk\">Martin Redington</a>\n+  * @author <a href=\"mailto:ggregory@seagullsw.com\">Gary Gregory</a>\n+  * @since 1.0-dev\n+  *\n+  * @todo Add more documentation\n+  */\n+public class Base64 implements BinaryEncoder, BinaryDecoder {\n+\n+    // Create constants pertaining to the chunk requirement\n+    static final int CHUNK_SIZE = 76;\n+    static final byte[] CHUNK_SEPARATOR = \"\\n\".getBytes();\n+\n+    // Create numerical and byte constants \n+    static final int BASELENGTH = 255;\n+    static final int LOOKUPLENGTH = 64;\n+    static final int TWENTYFOURBITGROUP = 24;\n+    static final int EIGHTBIT = 8;\n+    static final int SIXTEENBIT = 16;\n+    static final int SIXBIT = 6;\n+    static final int FOURBYTE = 4;\n+    static final int SIGN = -128;\n+    static final byte PAD = (byte) '=';\n+\n+    // Create arrays to hold the base64 characters and a \n+    // lookup for base64 chars\n+    private static byte[] base64Alphabet = new byte[BASELENGTH];\n+    private static byte[] lookUpBase64Alphabet = new byte[LOOKUPLENGTH];\n+\n+    // Populating the lookup and character arrays\n+    static {\n+        for (int i = 0; i < BASELENGTH; i++) {\n+            base64Alphabet[i] = (byte) -1;\n+        }\n+        for (int i = 'Z'; i >= 'A'; i--) {\n+            base64Alphabet[i] = (byte) (i - 'A');\n+        }\n+        for (int i = 'z'; i >= 'a'; i--) {\n+            base64Alphabet[i] = (byte) (i - 'a' + 26);\n+        }\n+        for (int i = '9'; i >= '0'; i--) {\n+            base64Alphabet[i] = (byte) (i - '0' + 52);\n+        }\n+\n+        base64Alphabet['+'] = 62;\n+        base64Alphabet['/'] = 63;\n+\n+        for (int i = 0; i <= 25; i++) {\n+            lookUpBase64Alphabet[i] = (byte) ('A' + i);\n+        }\n+\n+        for (int i = 26, j = 0; i <= 51; i++, j++) {\n+            lookUpBase64Alphabet[i] = (byte) ('a' + j);\n+        }\n+\n+        for (int i = 52, j = 0; i <= 61; i++, j++) {\n+            lookUpBase64Alphabet[i] = (byte) ('0' + j);\n+        }\n+\n+        lookUpBase64Alphabet[62] = (byte) '+';\n+        lookUpBase64Alphabet[63] = (byte) '/';\n+    }\n+\n+    private static boolean isBase64(byte octect) {\n+        if (octect == PAD) {\n+            return true;\n+        } \n+        else if (base64Alphabet[octect] == -1) {\n+            return false;\n+        } \n+        else {\n+            return true;\n+        }\n+    }\n+\n+    public static boolean isArrayByteBase64(byte[] arrayOctect) {\n+\n+        arrayOctect = discardWhitespace(arrayOctect);\n+\n+        int length = arrayOctect.length;\n+        if (length == 0) {\n+            // shouldn't a 0 length array be valid base64 data?\n+            // return false;\n+            return true;\n+        }\n+        for (int i = 0; i < length; i++) {\n+            if (!isBase64(arrayOctect[i])) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+\n+    public static byte[] encodeBase64(byte[] binaryData) {\n+        return (encodeBase64(binaryData, false));\n+    }\n+\n+    public static byte[] encodeBase64Chunked(byte[] binaryData) {\n+        return (encodeBase64(binaryData, true));\n+    }\n+\n+    public Object decode(Object pObject) throws DecoderException {\n+\n+        Object result;\n+\n+        if (!(pObject instanceof byte[])) {\n+            throw new DecoderException(\n+                \"Parameter supplied to \"\n+                    + \"Base64 \"\n+                    + \"decode is not a byte[]\");\n+        } \n+        else {\n+            result = decode((byte[]) pObject);\n+        }\n+\n+        return result;\n+\n+    }\n+\n+    public byte[] decode(byte[] pArray) throws DecoderException {\n+\n+        byte[] result;\n+\n+        if (!isArrayByteBase64(pArray)) {\n+            throw new DecoderException(\n+                \"Parameter supplied to \"\n+                    + \"Base64 \"\n+                    + \"decode is not a valid base64 data.\");\n+        } \n+        else {\n+            result = decodeBase64((byte[]) pArray);\n+        }\n+\n+        return (result);\n+    }\n+\n+    /**\n+     * Encodes hex octects into Base64.\n+     *\n+     * @param binaryData Array containing binary data to encode.\n+     * @return Base64-encoded data.\n+     */\n+    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n+        int lengthDataBits = binaryData.length * EIGHTBIT;\n+        int fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n+        int numberTriplets = lengthDataBits / TWENTYFOURBITGROUP;\n+        byte encodedData[] = null;\n+        int encodedDataLength = 0;\n+        int nbrChunks = 0;\n+\n+        if (fewerThan24bits != 0) {\n+            //data not divisible by 24 bit\n+            encodedDataLength = (numberTriplets + 1) * 4;\n+        } \n+        else {\n+            // 16 or 8 bit\n+            encodedDataLength = numberTriplets * 4;\n+        }\n+\n+        // If the output is to be \"chunked\" into 76 character sections, \n+        // for compliance with RFC 2045 MIME, then it is important to \n+        // allow for extra length to account for the separator(s)\n+        if (isChunked) {\n+\n+            nbrChunks =\n+                (CHUNK_SEPARATOR.length == 0\n+                    ? 0\n+                    : (int) Math.ceil((float) encodedDataLength / CHUNK_SIZE));\n+            encodedDataLength += nbrChunks * CHUNK_SEPARATOR.length;\n+        }\n+\n+        encodedData = new byte[encodedDataLength];\n+\n+        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n+\n+        int encodedIndex = 0;\n+        int dataIndex = 0;\n+        int i = 0;\n+        int nextSeparatorIndex = CHUNK_SIZE;\n+        int chunksSoFar = 0;\n+\n+        //log.debug(\"number of triplets = \" + numberTriplets);\n+        for (i = 0; i < numberTriplets; i++) {\n+            dataIndex = i * 3;\n+            b1 = binaryData[dataIndex];\n+            b2 = binaryData[dataIndex + 1];\n+            b3 = binaryData[dataIndex + 2];\n+\n+            //log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n+\n+            l = (byte) (b2 & 0x0f);\n+            k = (byte) (b1 & 0x03);\n+\n+            byte val1 =\n+                ((b1 & SIGN) == 0)\n+                    ? (byte) (b1 >> 2)\n+                    : (byte) ((b1) >> 2 ^ 0xc0);\n+            byte val2 =\n+                ((b2 & SIGN) == 0)\n+                    ? (byte) (b2 >> 4)\n+                    : (byte) ((b2) >> 4 ^ 0xf0);\n+            byte val3 =\n+                ((b3 & SIGN) == 0)\n+                    ? (byte) (b3 >> 6)\n+                    : (byte) ((b3) >> 6 ^ 0xfc);\n+\n+            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n+            //log.debug( \"val2 = \" + val2 );\n+            //log.debug( \"k4   = \" + (k<<4) );\n+            //log.debug(  \"vak  = \" + (val2 | (k<<4)) );\n+            encodedData[encodedIndex + 1] =\n+                lookUpBase64Alphabet[val2 | (k << 4)];\n+            encodedData[encodedIndex + 2] =\n+                lookUpBase64Alphabet[(l << 2) | val3];\n+            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n+\n+            encodedIndex += 4;\n+\n+            // If we are chunking, let's put a chunk separator down.\n+            if (isChunked) {\n+                // this assumes that CHUNK_SIZE % 4 == 0\n+                if (encodedIndex == nextSeparatorIndex) {\n+                    System.arraycopy(\n+                        CHUNK_SEPARATOR,\n+                        0,\n+                        encodedData,\n+                        encodedIndex,\n+                        CHUNK_SEPARATOR.length);\n+                    chunksSoFar++;\n+                    nextSeparatorIndex =\n+                        (CHUNK_SIZE * (chunksSoFar + 1))\n+                            + (chunksSoFar * CHUNK_SEPARATOR.length);\n+                    encodedIndex += CHUNK_SEPARATOR.length;\n+                }\n+            }\n+        }\n+\n+        // form integral number of 6-bit groups\n+        dataIndex = i * 3;\n+\n+        if (fewerThan24bits == EIGHTBIT) {\n+            b1 = binaryData[dataIndex];\n+            k = (byte) (b1 & 0x03);\n+            //log.debug(\"b1=\" + b1);\n+            //log.debug(\"b1<<2 = \" + (b1>>2) );\n+            byte val1 =\n+                ((b1 & SIGN) == 0)\n+                    ? (byte) (b1 >> 2)\n+                    : (byte) ((b1) >> 2 ^ 0xc0);\n+            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n+            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n+            encodedData[encodedIndex + 2] = PAD;\n+            encodedData[encodedIndex + 3] = PAD;\n+        } \n+        else if (fewerThan24bits == SIXTEENBIT) {\n+\n+            b1 = binaryData[dataIndex];\n+            b2 = binaryData[dataIndex + 1];\n+            l = (byte) (b2 & 0x0f);\n+            k = (byte) (b1 & 0x03);\n+\n+            byte val1 =\n+                ((b1 & SIGN) == 0)\n+                    ? (byte) (b1 >> 2)\n+                    : (byte) ((b1) >> 2 ^ 0xc0);\n+            byte val2 =\n+                ((b2 & SIGN) == 0)\n+                    ? (byte) (b2 >> 4)\n+                    : (byte) ((b2) >> 4 ^ 0xf0);\n+\n+            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n+            encodedData[encodedIndex + 1] =\n+                lookUpBase64Alphabet[val2 | (k << 4)];\n+            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n+            encodedData[encodedIndex + 3] = PAD;\n+        }\n+\n+        if (isChunked) {\n+            // we also add a separator to the end of the final chunk.\n+            if (chunksSoFar < nbrChunks) {\n+                System.arraycopy(\n+                    CHUNK_SEPARATOR,\n+                    0,\n+                    encodedData,\n+                    encodedDataLength - CHUNK_SEPARATOR.length,\n+                    CHUNK_SEPARATOR.length);\n+            }\n+        }\n+\n+        return encodedData;\n+    }\n+\n+    /**\n+     * Decodes Base64 data into octects\n+     *\n+     * @param binaryData Byte array containing Base64 data\n+     * @return Array containing decoded data.\n+     */\n+    public static byte[] decodeBase64(byte[] base64Data) {\n+        // RFC 2045 suggests line wrapping at (no more than) 76\n+        // characters -- we may have embedded whitespace.\n+        base64Data = discardWhitespace(base64Data);\n+\n+        // handle the edge case, so we don't have to worry about it later\n+        if (base64Data.length == 0) {\n+            return new byte[0];\n+        }\n+\n+        int numberQuadruple = base64Data.length / FOURBYTE;\n+        byte decodedData[] = null;\n+        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;\n+\n+        // Throw away anything not in base64Data\n+\n+        int encodedIndex = 0;\n+        int dataIndex = 0;\n+        {\n+            // this sizes the output array properly - rlw\n+            int lastData = base64Data.length;\n+            // ignore the '=' padding\n+            while (base64Data[lastData - 1] == PAD) {\n+                if (--lastData == 0) {\n+                    return new byte[0];\n+                }\n+            }\n+            decodedData = new byte[lastData - numberQuadruple];\n+        }\n+\n+        for (int i = 0; i < numberQuadruple; i++) {\n+            dataIndex = i * 4;\n+            marker0 = base64Data[dataIndex + 2];\n+            marker1 = base64Data[dataIndex + 3];\n+\n+            b1 = base64Alphabet[base64Data[dataIndex]];\n+            b2 = base64Alphabet[base64Data[dataIndex + 1]];\n+\n+            if (marker0 != PAD && marker1 != PAD) {\n+                //No PAD e.g 3cQl\n+                b3 = base64Alphabet[marker0];\n+                b4 = base64Alphabet[marker1];\n+\n+                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n+                decodedData[encodedIndex + 1] =\n+                    (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n+                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);\n+            } \n+            else if (marker0 == PAD) {\n+                //Two PAD e.g. 3c[Pad][Pad]\n+                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n+            } \n+            else if (marker1 == PAD) {\n+                //One PAD e.g. 3cQ[Pad]\n+                b3 = base64Alphabet[marker0];\n+\n+                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);\n+                decodedData[encodedIndex + 1] =\n+                    (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n+            }\n+            encodedIndex += 3;\n+        }\n+        return decodedData;\n+    }\n+\n+    /**\n+     * Discards any whitespace from a base-64 encoded block.\n+     *\n+     * @param data The base-64 encoded data to discard the whitespace\n+     * from.\n+     * @return The data, less whitespace (see RFC 2045).\n+     */\n+    static byte[] discardWhitespace(byte[] data) {\n+        byte groomedData[] = new byte[data.length];\n+        int bytesCopied = 0;\n+\n+        for (int i = 0; i < data.length; i++) {\n+            switch (data[i]) {\n+                case (byte) ' ' :\n+                case (byte) '\\n' :\n+                case (byte) '\\r' :\n+                case (byte) '\\t' :\n+                    break;\n+                default:\n+                    groomedData[bytesCopied++] = data[i];\n+            }\n+        }\n+\n+        byte packedData[] = new byte[bytesCopied];\n+\n+        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);\n+\n+        return packedData;\n+    }\n+\n+    // Implementation of the Encoder Interface\n+\n+    /**\n+     * encode an Object\n+     */\n+    public Object encode(Object pObject) throws EncoderException {\n+\n+        Object result;\n+\n+        if (!(pObject instanceof byte[])) {\n+            throw new EncoderException(\n+                \"Parameter supplied to \"\n+                    + \"Base64 \"\n+                    + \"encode is not a byte[]\");\n+        } \n+        else {\n+            result = encode((byte[]) pObject);\n+        }\n+\n+        return result;\n+\n+    }\n+\n+    public byte[] encode(byte[] pArray) throws EncoderException {\n+        return (encodeBase64(pArray, false));\n+    }\n+\n+}", "timestamp": 1052254338, "metainfo": ""}