{"sha": "00da5921e530ee96b4a03cb3f085bc292ac675bd", "log": "Use constants in code for MIME and PEM chunk size instead of magic numbers.   ", "commit": "\n--- a/src/java/org/apache/commons/codec/binary/Base64.java\n+++ b/src/java/org/apache/commons/codec/binary/Base64.java\n     private static final int DEFAULT_BUFFER_SIZE = 8192;\n \n     /**\n-     * Chunk size per RFC 2045 section 6.8.\n+     *  MIME chunk size per RFC 2045 section 6.8.\n      * \n      * <p>\n      * The {@value} character limit does not count the trailing CRLF, but counts all other characters, including any\n      * \n      * @see <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045 section 6.8</a>\n      */\n-    static final int CHUNK_SIZE = 76;\n+    public static final int MIME_CHUNK_SIZE = 76;\n+\n+    /**\n+     * PEM chunk size per RFC 1421 section 4.3.2.4.\n+     * \n+     * <p>\n+     * The {@value} character limit does not count the trailing CRLF, but counts all other characters, including any\n+     * equal signs.\n+     * </p>\n+     * \n+     * @see <a href=\"http://tools.ietf.org/html/rfc1421\">RFC 1421 section 4.3.2.4</a>\n+     */\n+    public static final int PEM_CHUNK_SIZE = 64;\n \n     /**\n      * Chunk separator per RFC 2045 section 2.1.\n      * @since 1.4\n      */\n     public Base64(boolean urlSafe) {\n-        this(CHUNK_SIZE, CHUNK_SEPARATOR, urlSafe);\n+        this(MIME_CHUNK_SIZE, CHUNK_SEPARATOR, urlSafe);\n     }\n \n     /**\n             return binaryData;\n         }\n \n-        long len = getEncodeLength(binaryData, CHUNK_SIZE, CHUNK_SEPARATOR);\n+        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);\n         if (len > maxResultSize) {\n             throw new IllegalArgumentException(\"Input array too big, the output array would be bigger (\" +\n                 len +\n--- a/src/test/org/apache/commons/codec/binary/Base64InputStreamTest.java\n+++ b/src/test/org/apache/commons/codec/binary/Base64InputStreamTest.java\n      * @throws Exception\n      *             for some failure scenarios.\n      */\n-    public void testBase64EmptyInputStream() throws Exception {\n+    public void testBase64EmptyInputStreamMimeChuckSize() throws Exception {\n+        testBase64EmptyInputStream(Base64.MIME_CHUNK_SIZE);\n+    }\n+\n+    /**\n+     * Tests the Base64InputStream implementation against empty input.\n+     * \n+     * @throws Exception\n+     *             for some failure scenarios.\n+     */\n+    public void testBase64EmptyInputStreamPemChuckSize() throws Exception {\n+        testBase64EmptyInputStream(Base64.PEM_CHUNK_SIZE);\n+    }\n+\n+    private void testBase64EmptyInputStream(int chuckSize) throws Exception {\n         byte[] emptyEncoded = new byte[0];\n         byte[] emptyDecoded = new byte[0];\n-        testByteByByte(emptyEncoded, emptyDecoded, 76, CRLF);\n-        testByChunk(emptyEncoded, emptyDecoded, 76, CRLF);\n+        testByteByByte(emptyEncoded, emptyDecoded, chuckSize, CRLF);\n+        testByChunk(emptyEncoded, emptyDecoded, chuckSize, CRLF);\n     }\n \n     /**\n         // Hello World test.\n         byte[] encoded = StringUtils.getBytesUtf8(\"SGVsbG8gV29ybGQ=\\r\\n\");\n         byte[] decoded = StringUtils.getBytesUtf8(STRING_FIXTURE);\n-        testByChunk(encoded, decoded, 76, CRLF);\n+        testByChunk(encoded, decoded, Base64.MIME_CHUNK_SIZE, CRLF);\n \n         // Single Byte test.\n         encoded = StringUtils.getBytesUtf8(\"AA==\\r\\n\");\n         decoded = new byte[]{(byte) 0};\n-        testByChunk(encoded, decoded, 76, CRLF);\n+        testByChunk(encoded, decoded, Base64.MIME_CHUNK_SIZE, CRLF);\n \n         // OpenSSL interop test.\n         encoded = StringUtils.getBytesUtf8(Base64TestData.ENCODED_64_CHARS_PER_LINE);\n         decoded = Base64TestData.DECODED;\n-        testByChunk(encoded, decoded, 64, LF);\n+        testByChunk(encoded, decoded, Base64.PEM_CHUNK_SIZE, LF);\n \n         // Single Line test.\n         String singleLine = Base64TestData.ENCODED_64_CHARS_PER_LINE.replaceAll(\"\\n\", \"\");\n         // Hello World test.\n         byte[] encoded = StringUtils.getBytesUtf8(\"SGVsbG8gV29ybGQ=\\r\\n\");\n         byte[] decoded = StringUtils.getBytesUtf8(STRING_FIXTURE);\n-        testByteByByte(encoded, decoded, 76, CRLF);\n+        testByteByByte(encoded, decoded, Base64.MIME_CHUNK_SIZE, CRLF);\n \n         // Single Byte test.\n         encoded = StringUtils.getBytesUtf8(\"AA==\\r\\n\");\n         decoded = new byte[]{(byte) 0};\n-        testByteByByte(encoded, decoded, 76, CRLF);\n+        testByteByByte(encoded, decoded, Base64.MIME_CHUNK_SIZE, CRLF);\n \n         // OpenSSL interop test.\n         encoded = StringUtils.getBytesUtf8(Base64TestData.ENCODED_64_CHARS_PER_LINE);\n         decoded = Base64TestData.DECODED;\n-        testByteByByte(encoded, decoded, 64, LF);\n+        testByteByByte(encoded, decoded, Base64.PEM_CHUNK_SIZE, LF);\n \n         // Single Line test.\n         String singleLine = Base64TestData.ENCODED_64_CHARS_PER_LINE.replaceAll(\"\\n\", \"\");\n--- a/src/test/org/apache/commons/codec/binary/Base64OutputStreamTest.java\n+++ b/src/test/org/apache/commons/codec/binary/Base64OutputStreamTest.java\n      * @throws Exception\n      *             for some failure scenarios.\n      */\n-    public void testBase64EmptyOutputStream() throws Exception {\n+    public void testBase64EmptyOutputStreamMimeChunkSize() throws Exception {\n+        testBase64EmptyOutputStream(Base64.MIME_CHUNK_SIZE);\n+    }\n+\n+    /**\n+     * Test the Base64OutputStream implementation against empty input.\n+     * \n+     * @throws Exception\n+     *             for some failure scenarios.\n+     */\n+    public void testBase64EmptyOutputStreamPemChunkSize() throws Exception {\n+        testBase64EmptyOutputStream(Base64.PEM_CHUNK_SIZE);\n+    }\n+\n+    private void testBase64EmptyOutputStream(int chunkSize) throws Exception {\n         byte[] emptyEncoded = new byte[0];\n         byte[] emptyDecoded = new byte[0];\n-        testByteByByte(emptyEncoded, emptyDecoded, 76, CRLF);\n-        testByChunk(emptyEncoded, emptyDecoded, 76, CRLF);\n+        testByteByByte(emptyEncoded, emptyDecoded, chunkSize, CRLF);\n+        testByChunk(emptyEncoded, emptyDecoded, chunkSize, CRLF);\n     }\n \n     /**\n         // Hello World test.\n         byte[] encoded = StringUtils.getBytesUtf8(\"SGVsbG8gV29ybGQ=\\r\\n\");\n         byte[] decoded = StringUtils.getBytesUtf8(STRING_FIXTURE);\n-        testByChunk(encoded, decoded, 76, CRLF);\n+        testByChunk(encoded, decoded, Base64.MIME_CHUNK_SIZE, CRLF);\n \n         // Single Byte test.\n         encoded = StringUtils.getBytesUtf8(\"AA==\\r\\n\");\n         decoded = new byte[]{(byte) 0};\n-        testByChunk(encoded, decoded, 76, CRLF);\n+        testByChunk(encoded, decoded, Base64.MIME_CHUNK_SIZE, CRLF);\n \n         // OpenSSL interop test.\n         encoded = StringUtils.getBytesUtf8(Base64TestData.ENCODED_64_CHARS_PER_LINE);\n         decoded = Base64TestData.DECODED;\n-        testByChunk(encoded, decoded, 64, LF);\n+        testByChunk(encoded, decoded, Base64.PEM_CHUNK_SIZE, LF);\n \n         // Single Line test.\n         String singleLine = Base64TestData.ENCODED_64_CHARS_PER_LINE.replaceAll(\"\\n\", \"\");\n--- a/src/test/org/apache/commons/codec/binary/Base64Test.java\n+++ b/src/test/org/apache/commons/codec/binary/Base64Test.java\n         encodedContent = StringUtils.newStringUtf8(encodedBytes);\n         assertTrue(\"encoding hello world\", encodedContent.equals(\"SGVsbG8gV29ybGQ=\"));\n \n-        Base64 b64 = new Base64(76, null);  // null lineSeparator same as saying no-chunking\n+        Base64 b64 = new Base64(Base64.MIME_CHUNK_SIZE, null);  // null lineSeparator same as saying no-chunking\n         encodedBytes = b64.encode(StringUtils.getBytesUtf8(content));\n         encodedContent = StringUtils.newStringUtf8(encodedBytes);\n         assertTrue(\"encoding hello world\", encodedContent.equals(\"SGVsbG8gV29ybGQ=\"));\n      * Tests RFC 2045 section 6.8 chuck size definition.\n      */\n     public void testRfc2045Section6Dot8ChunkSizeDefinition() {\n-        assertEquals(76, Base64.CHUNK_SIZE);\n+        assertEquals(76, Base64.MIME_CHUNK_SIZE);\n+    }\n+\n+    /**\n+     * Tests RFC 1421 section 4.3.2.4 chuck size definition.\n+     */\n+    public void testRfc1421Section6Dot8ChunkSizeDefinition() {\n+        assertEquals(64, Base64.PEM_CHUNK_SIZE);\n     }\n \n     public void testSingletons() {", "timestamp": 1269655164, "metainfo": ""}