{"sha": "2f76d9d334ac7470d908ab59feab58249f6ea8ac", "log": "[CODEC-78] Base64: Improve Code Coverage.  ", "commit": "\n--- a/src/test/org/apache/commons/codec/binary/Base64InputStreamTest.java\n+++ b/src/test/org/apache/commons/codec/binary/Base64InputStreamTest.java\n \n package org.apache.commons.codec.binary;\n \n-\n import java.io.ByteArrayInputStream;\n import java.io.InputStream;\n import java.util.Arrays;\n /**\n  * @author Apache Software Foundation\n  * @version $Id $\n+ * @since 1.4\n  */\n public class Base64InputStreamTest extends TestCase {\n \n     private final static byte[] CRLF = {(byte) '\\r', (byte) '\\n'};\n+\n     private final static byte[] LF = {(byte) '\\n'};\n \n+    private static final String STRING_FIXTURE = \"Hello World\";\n+\n+    private static final String UTF_8_NAME = \"UTF-8\";\n+\n     /**\n      * Construct a new instance of this test case.\n-     *\n-     * @param name Name of the test case\n+     * \n+     * @param name\n+     *            Name of the test case\n      */\n     public Base64InputStreamTest(String name) {\n         super(name);\n     }\n \n     /**\n-     * Test the Base64InputStream implementation against empty input.\n-     *\n-     * @throws Exception for some failure scenarios.\n-     */    \n+     * Tests the Base64InputStream implementation against empty input.\n+     * \n+     * @throws Exception\n+     *             for some failure scenarios.\n+     */\n     public void testBase64EmptyInputStream() throws Exception {\n         byte[] emptyEncoded = new byte[0];\n         byte[] emptyDecoded = new byte[0];\n     }\n \n     /**\n-     * Test the Base64InputStream implementation.\n-     *\n-     * @throws Exception for some failure scenarios.\n+     * Tests the Base64InputStream implementation.\n+     * \n+     * @throws Exception\n+     *             for some failure scenarios.\n+     */\n+    public void testBase64InputStreamByChunk() throws Exception {\n+        // Hello World test.\n+        byte[] encoded = \"SGVsbG8gV29ybGQ=\\r\\n\".getBytes(UTF_8_NAME);\n+        byte[] decoded = STRING_FIXTURE.getBytes(UTF_8_NAME);\n+        testByChunk(encoded, decoded, 76, CRLF);\n+\n+        // Single Byte test.\n+        encoded = \"AA==\\r\\n\".getBytes(UTF_8_NAME);\n+        decoded = new byte[]{(byte) 0};\n+        testByChunk(encoded, decoded, 76, CRLF);\n+\n+        // OpenSSL interop test.\n+        encoded = Base64TestData.ENCODED.getBytes(UTF_8_NAME);\n+        decoded = Base64TestData.DECODED;\n+        testByChunk(encoded, decoded, 64, LF);\n+\n+        // Single Line test.\n+        String singleLine = Base64TestData.ENCODED.replaceAll(\"\\n\", \"\");\n+        encoded = singleLine.getBytes(UTF_8_NAME);\n+        decoded = Base64TestData.DECODED;\n+        testByChunk(encoded, decoded, 0, LF);\n+\n+        // test random data of sizes 0 thru 150\n+        for (int i = 0; i <= 150; i++) {\n+            byte[][] randomData = Base64TestData.randomData(i, false);\n+            encoded = randomData[1];\n+            decoded = randomData[0];\n+            testByChunk(encoded, decoded, 0, LF);\n+        }\n+    }\n+\n+    /**\n+     * Tests the Base64InputStream implementation.\n+     * \n+     * @throws Exception\n+     *             for some failure scenarios.\n      */\n     public void testBase64InputStreamByteByByte() throws Exception {\n         // Hello World test.\n-        byte[] encoded = \"SGVsbG8gV29ybGQ=\\r\\n\".getBytes(\"UTF-8\");\n-        byte[] decoded = \"Hello World\".getBytes(\"UTF-8\");\n+        byte[] encoded = \"SGVsbG8gV29ybGQ=\\r\\n\".getBytes(UTF_8_NAME);\n+        byte[] decoded = STRING_FIXTURE.getBytes(UTF_8_NAME);\n         testByteByByte(encoded, decoded, 76, CRLF);\n \n         // Single Byte test.\n-        encoded = \"AA==\\r\\n\".getBytes(\"UTF-8\");\n+        encoded = \"AA==\\r\\n\".getBytes(UTF_8_NAME);\n         decoded = new byte[]{(byte) 0};\n         testByteByByte(encoded, decoded, 76, CRLF);\n \n         // OpenSSL interop test.\n-        encoded = Base64TestData.ENCODED.getBytes(\"UTF-8\");\n+        encoded = Base64TestData.ENCODED.getBytes(UTF_8_NAME);\n         decoded = Base64TestData.DECODED;\n         testByteByByte(encoded, decoded, 64, LF);\n \n         // Single Line test.\n         String singleLine = Base64TestData.ENCODED.replaceAll(\"\\n\", \"\");\n-        encoded = singleLine.getBytes(\"UTF-8\");\n+        encoded = singleLine.getBytes(UTF_8_NAME);\n         decoded = Base64TestData.DECODED;\n         testByteByByte(encoded, decoded, 0, LF);\n-    }\n-\n-    /**\n-     * Test the Base64InputStream implementation.\n-     *\n-     * @throws Exception for some failure scenarios.\n-     */\n-    public void testBase64InputStreamByChunk() throws Exception {\n-        // Hello World test.\n-        byte[] encoded = \"SGVsbG8gV29ybGQ=\\r\\n\".getBytes(\"UTF-8\");\n-        byte[] decoded = \"Hello World\".getBytes(\"UTF-8\");\n-        testByChunk(encoded, decoded, 76, CRLF);\n-\n-        // Single Byte test.\n-        encoded = \"AA==\\r\\n\".getBytes(\"UTF-8\");\n-        decoded = new byte[]{(byte) 0};\n-        testByChunk(encoded, decoded, 76, CRLF);\n-\n-        // OpenSSL interop test.\n-        encoded = Base64TestData.ENCODED.getBytes(\"UTF-8\");\n-        decoded = Base64TestData.DECODED;\n-        testByChunk(encoded, decoded, 64, LF);\n-\n-        // Single Line test.\n-        String singleLine = Base64TestData.ENCODED.replaceAll(\"\\n\", \"\");\n-        encoded = singleLine.getBytes(\"UTF-8\");\n-        decoded = Base64TestData.DECODED;\n-        testByChunk(encoded, decoded, 0, LF);\n-    }\n-\n-\n-    /**\n-     * Test method does three tests on the supplied data:\n-     * 1. encoded ---[DECODE]--> decoded\n-     * 2. decoded ---[ENCODE]--> encoded\n-     * 3. decoded ---[WRAP-WRAP-WRAP-etc...] --> decoded\n+\n+        // test random data of sizes 0 thru 150\n+        for (int i = 0; i <= 150; i++) {\n+            byte[][] randomData = Base64TestData.randomData(i, false);\n+            encoded = randomData[1];\n+            decoded = randomData[0];\n+            testByteByByte(encoded, decoded, 0, LF);\n+        }\n+    }\n+\n+    /**\n+     * Tests method does three tests on the supplied data: 1. encoded ---[DECODE]--> decoded 2. decoded ---[ENCODE]-->\n+     * encoded 3. decoded ---[WRAP-WRAP-WRAP-etc...] --> decoded\n      * <p/>\n-     * By \"[WRAP-WRAP-WRAP-etc...]\" we mean situation where the\n-     * Base64InputStream wraps itself in encode and decode mode\n+     * By \"[WRAP-WRAP-WRAP-etc...]\" we mean situation where the Base64InputStream wraps itself in encode and decode mode\n      * over and over again.\n-     *\n-     * @param encoded   base64 encoded data\n-     * @param decoded   the data from above, but decoded\n-     * @param chunkSize chunk size (line-length) of the base64 encoded data.\n-     * @param seperator Line separator in the base64 encoded data.\n-     * @throws Exception Usually signifies a bug in the Base64 commons-codec implementation.\n-     */\n-    private void testByteByByte(\n-            byte[] encoded, byte[] decoded, int chunkSize, byte[] seperator\n-    ) throws Exception {\n+     * \n+     * @param encoded\n+     *            base64 encoded data\n+     * @param decoded\n+     *            the data from above, but decoded\n+     * @param chunkSize\n+     *            chunk size (line-length) of the base64 encoded data.\n+     * @param seperator\n+     *            Line separator in the base64 encoded data.\n+     * @throws Exception\n+     *             Usually signifies a bug in the Base64 commons-codec implementation.\n+     */\n+    private void testByChunk(byte[] encoded, byte[] decoded, int chunkSize, byte[] seperator) throws Exception {\n+\n+        // Start with encode.\n+        InputStream in = new ByteArrayInputStream(decoded);\n+        in = new Base64InputStream(in, true, chunkSize, seperator);\n+        byte[] output = Base64TestData.streamToBytes(in);\n+\n+        assertEquals(\"EOF\", -1, in.read());\n+        assertEquals(\"Still EOF\", -1, in.read());\n+        assertTrue(\"Streaming base64 encode\", Arrays.equals(output, encoded));\n+\n+        // Now let's try decode.\n+        in = new ByteArrayInputStream(encoded);\n+        in = new Base64InputStream(in);\n+        output = Base64TestData.streamToBytes(in);\n+\n+        assertEquals(\"EOF\", -1, in.read());\n+        assertEquals(\"Still EOF\", -1, in.read());\n+        assertTrue(\"Streaming base64 decode\", Arrays.equals(output, decoded));\n+\n+        // I always wanted to do this! (wrap encoder with decoder etc etc).\n+        in = new ByteArrayInputStream(decoded);\n+        for (int i = 0; i < 10; i++) {\n+            in = new Base64InputStream(in, true, chunkSize, seperator);\n+            in = new Base64InputStream(in, false);\n+        }\n+        output = Base64TestData.streamToBytes(in);\n+\n+        assertEquals(\"EOF\", -1, in.read());\n+        assertEquals(\"Still EOF\", -1, in.read());\n+        assertTrue(\"Streaming base64 wrap-wrap-wrap!\", Arrays.equals(output, decoded));\n+    }\n+\n+    /**\n+     * Tests method does three tests on the supplied data: 1. encoded ---[DECODE]--> decoded 2. decoded ---[ENCODE]-->\n+     * encoded 3. decoded ---[WRAP-WRAP-WRAP-etc...] --> decoded\n+     * <p/>\n+     * By \"[WRAP-WRAP-WRAP-etc...]\" we mean situation where the Base64InputStream wraps itself in encode and decode mode\n+     * over and over again.\n+     * \n+     * @param encoded\n+     *            base64 encoded data\n+     * @param decoded\n+     *            the data from above, but decoded\n+     * @param chunkSize\n+     *            chunk size (line-length) of the base64 encoded data.\n+     * @param seperator\n+     *            Line separator in the base64 encoded data.\n+     * @throws Exception\n+     *             Usually signifies a bug in the Base64 commons-codec implementation.\n+     */\n+    private void testByteByByte(byte[] encoded, byte[] decoded, int chunkSize, byte[] seperator) throws Exception {\n \n         // Start with encode.\n         InputStream in = new ByteArrayInputStream(decoded);\n         assertEquals(\"Still EOF\", -1, in.read());\n         assertTrue(\"Streaming base64 decode\", Arrays.equals(output, decoded));\n \n-        // I always wanted to do this!  (wrap encoder with decoder etc etc).\n+        // I always wanted to do this! (wrap encoder with decoder etc etc).\n         in = new ByteArrayInputStream(decoded);\n         for (int i = 0; i < 10; i++) {\n             in = new Base64InputStream(in, true, chunkSize, seperator);\n     }\n \n     /**\n-     * Test method does three tests on the supplied data:\n-     * 1. encoded ---[DECODE]--> decoded\n-     * 2. decoded ---[ENCODE]--> encoded\n-     * 3. decoded ---[WRAP-WRAP-WRAP-etc...] --> decoded\n-     * <p/>\n-     * By \"[WRAP-WRAP-WRAP-etc...]\" we mean situation where the\n-     * Base64InputStream wraps itself in encode and decode mode\n-     * over and over again.\n-     *\n-     * @param encoded   base64 encoded data\n-     * @param decoded   the data from above, but decoded\n-     * @param chunkSize chunk size (line-length) of the base64 encoded data.\n-     * @param seperator Line separator in the base64 encoded data.\n-     * @throws Exception Usually signifies a bug in the Base64 commons-codec implementation.\n-     */\n-    private void testByChunk(\n-            byte[] encoded, byte[] decoded, int chunkSize, byte[] seperator\n-    ) throws Exception {\n-\n-        // Start with encode.\n-        InputStream in = new ByteArrayInputStream(decoded);\n-        in = new Base64InputStream(in, true, chunkSize, seperator);\n-        byte[] output = Base64TestData.streamToBytes(in);\n-\n-        assertEquals(\"EOF\", -1, in.read());\n-        assertEquals(\"Still EOF\", -1, in.read());\n-        assertTrue(\"Streaming base64 encode\", Arrays.equals(output, encoded));\n-\n-        // Now let's try decode.\n-        in = new ByteArrayInputStream(encoded);\n-        in = new Base64InputStream(in);\n-        output = Base64TestData.streamToBytes(in);\n-\n-        assertEquals(\"EOF\", -1, in.read());\n-        assertEquals(\"Still EOF\", -1, in.read());\n-        assertTrue(\"Streaming base64 decode\", Arrays.equals(output, decoded));\n-\n-        // I always wanted to do this!  (wrap encoder with decoder etc etc).\n-        in = new ByteArrayInputStream(decoded);\n-        for (int i = 0; i < 10; i++) {\n-            in = new Base64InputStream(in, true, chunkSize, seperator);\n-            in = new Base64InputStream(in, false);\n-        }\n-        output = Base64TestData.streamToBytes(in);\n-\n-        assertEquals(\"EOF\", -1, in.read());\n-        assertEquals(\"Still EOF\", -1, in.read());\n-        assertTrue(\"Streaming base64 wrap-wrap-wrap!\", Arrays.equals(output, decoded));\n+     * Tests markSupported.\n+     * \n+     * @throws Exception\n+     */\n+    public void testMarkSupported() throws Exception {\n+        byte[] decoded = STRING_FIXTURE.getBytes(UTF_8_NAME);\n+        ByteArrayInputStream bin = new ByteArrayInputStream(decoded);\n+        Base64InputStream in = new Base64InputStream(bin, true, 4, new byte[]{0, 0, 0});\n+        // Always returns false for now.\n+        assertFalse(\"Base64InputStream.markSupported() is false\", in.markSupported());\n+    }\n+\n+    /**\n+     * Tests read returning 0\n+     * \n+     * @throws Exception\n+     */\n+    public void testRead0() throws Exception {\n+        byte[] decoded = STRING_FIXTURE.getBytes(UTF_8_NAME);\n+        byte[] buf = new byte[1024];\n+        int bytesRead = 0;\n+        ByteArrayInputStream bin = new ByteArrayInputStream(decoded);\n+        Base64InputStream in = new Base64InputStream(bin, true, 4, new byte[]{0, 0, 0});\n+        bytesRead = in.read(buf, 0, 0);\n+        assertEquals(\"Base64InputStream.read(buf, 0, 0) returns 0\", 0, bytesRead);\n+    }\n+\n+    /**\n+     * Tests read with null.\n+     * \n+     * @throws Exception\n+     *             for some failure scenarios.\n+     */\n+    public void testReadNull() throws Exception {\n+        byte[] decoded = STRING_FIXTURE.getBytes(UTF_8_NAME);\n+        ByteArrayInputStream bin = new ByteArrayInputStream(decoded);\n+        Base64InputStream in = new Base64InputStream(bin, true, 4, new byte[]{0, 0, 0});\n+        try {\n+            in.read(null, 0, 0);\n+            fail(\"Base64InputStream.read(null, 0, 0) to throw a NullPointerException\");\n+        } catch (NullPointerException e) {\n+            // Expected\n+        }\n+    }\n+\n+    /**\n+     * Tests read throwing IndexOutOfBoundsException\n+     * \n+     * @throws Exception\n+     */\n+    public void testReadOutOfBounds() throws Exception {\n+        byte[] decoded = STRING_FIXTURE.getBytes(UTF_8_NAME);\n+        byte[] buf = new byte[1024];\n+        ByteArrayInputStream bin = new ByteArrayInputStream(decoded);\n+        Base64InputStream in = new Base64InputStream(bin, true, 4, new byte[]{0, 0, 0});\n+\n+        try {\n+            in.read(buf, -1, 0);\n+            fail(\"Expected Base64InputStream.read(buf, -1, 0) to throw IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // Expected\n+        }\n+\n+        try {\n+            in.read(buf, buf.length + 1, 0);\n+            fail(\"Base64InputStream.read(buf, buf.length + 1, 0) throws IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // Expected\n+        }\n     }\n }\n--- a/src/test/org/apache/commons/codec/binary/Base64OutputStreamTest.java\n+++ b/src/test/org/apache/commons/codec/binary/Base64OutputStreamTest.java\n \n package org.apache.commons.codec.binary;\n \n-\n import java.io.ByteArrayOutputStream;\n import java.io.OutputStream;\n import java.util.Arrays;\n /**\n  * @author Apache Software Foundation\n  * @version $Id $\n+ * @since 1.4\n  */\n public class Base64OutputStreamTest extends TestCase {\n \n     private final static byte[] CRLF = {(byte) '\\r', (byte) '\\n'};\n+\n     private final static byte[] LF = {(byte) '\\n'};\n \n     /**\n      * Construct a new instance of this test case.\n-     *\n-     * @param name Name of the test case\n+     * \n+     * @param name\n+     *            Name of the test case\n      */\n     public Base64OutputStreamTest(String name) {\n         super(name);\n \n     /**\n      * Test the Base64OutputStream implementation against empty input.\n-     *\n-     * @throws Exception for some failure scenarios.\n+     * \n+     * @throws Exception\n+     *             for some failure scenarios.\n      */\n     public void testBase64EmptyOutputStream() throws Exception {\n         byte[] emptyEncoded = new byte[0];\n         byte[] emptyDecoded = new byte[0];\n         testByteByByte(emptyEncoded, emptyDecoded, 76, CRLF);\n         testByChunk(emptyEncoded, emptyDecoded, 76, CRLF);\n-    }    \n+    }\n \n     /**\n      * Test the Base64OutputStream implementation\n-     *\n-     * @throws Exception for some failure scenarios.\n+     * \n+     * @throws Exception\n+     *             for some failure scenarios.\n+     */\n+    public void testBase64OutputStreamByChunk() throws Exception {\n+        // Hello World test.\n+        byte[] encoded = \"SGVsbG8gV29ybGQ=\\r\\n\".getBytes(\"UTF-8\");\n+        byte[] decoded = \"Hello World\".getBytes(\"UTF-8\");\n+        testByChunk(encoded, decoded, 76, CRLF);\n+\n+        // Single Byte test.\n+        encoded = \"AA==\\r\\n\".getBytes(\"UTF-8\");\n+        decoded = new byte[]{(byte) 0};\n+        testByChunk(encoded, decoded, 76, CRLF);\n+\n+        // OpenSSL interop test.\n+        encoded = Base64TestData.ENCODED.getBytes(\"UTF-8\");\n+        decoded = Base64TestData.DECODED;\n+        testByChunk(encoded, decoded, 64, LF);\n+\n+        // Single Line test.\n+        String singleLine = Base64TestData.ENCODED.replaceAll(\"\\n\", \"\");\n+        encoded = singleLine.getBytes(\"UTF-8\");\n+        decoded = Base64TestData.DECODED;\n+        testByChunk(encoded, decoded, 0, LF);\n+\n+        // test random data of sizes 0 thru 150\n+        for (int i = 0; i <= 150; i++) {\n+            byte[][] randomData = Base64TestData.randomData(i, false);\n+            encoded = randomData[1];\n+            decoded = randomData[0];\n+            testByChunk(encoded, decoded, 0, LF);\n+        }\n+    }\n+\n+    /**\n+     * Test the Base64OutputStream implementation\n+     * \n+     * @throws Exception\n+     *             for some failure scenarios.\n      */\n     public void testBase64OutputStreamByteByByte() throws Exception {\n         // Hello World test.\n         encoded = singleLine.getBytes(\"UTF-8\");\n         decoded = Base64TestData.DECODED;\n         testByteByByte(encoded, decoded, 0, LF);\n-    }\n-\n-    /**\n-     * Test the Base64OutputStream implementation\n-     *\n-     * @throws Exception for some failure scenarios.\n-     */\n-    public void testBase64OutputStreamByChunk() throws Exception {\n-        // Hello World test.\n-        byte[] encoded = \"SGVsbG8gV29ybGQ=\\r\\n\".getBytes(\"UTF-8\");\n-        byte[] decoded = \"Hello World\".getBytes(\"UTF-8\");\n-        testByChunk(encoded, decoded, 76, CRLF);\n-\n-        // Single Byte test.\n-        encoded = \"AA==\\r\\n\".getBytes(\"UTF-8\");\n-        decoded = new byte[]{(byte) 0};\n-        testByChunk(encoded, decoded, 76, CRLF);\n-\n-        // OpenSSL interop test.\n-        encoded = Base64TestData.ENCODED.getBytes(\"UTF-8\");\n-        decoded = Base64TestData.DECODED;\n-        testByChunk(encoded, decoded, 64, LF);\n-\n-        // Single Line test.\n-        String singleLine = Base64TestData.ENCODED.replaceAll(\"\\n\", \"\");\n-        encoded = singleLine.getBytes(\"UTF-8\");\n-        decoded = Base64TestData.DECODED;\n-        testByChunk(encoded, decoded, 0, LF);\n-    }\n-\n-\n-    /**\n-     * Test method does three tests on the supplied data:\n-     * 1. encoded ---[DECODE]--> decoded\n-     * 2. decoded ---[ENCODE]--> encoded\n-     * 3. decoded ---[WRAP-WRAP-WRAP-etc...] --> decoded\n+\n+        // test random data of sizes 0 thru 150\n+        for (int i = 0; i <= 150; i++) {\n+            byte[][] randomData = Base64TestData.randomData(i, false);\n+            encoded = randomData[1];\n+            decoded = randomData[0];\n+            testByteByByte(encoded, decoded, 0, LF);\n+        }\n+    }\n+\n+    /**\n+     * Test method does three tests on the supplied data: 1. encoded ---[DECODE]--> decoded 2. decoded ---[ENCODE]-->\n+     * encoded 3. decoded ---[WRAP-WRAP-WRAP-etc...] --> decoded\n      * <p/>\n-     * By \"[WRAP-WRAP-WRAP-etc...]\" we mean situation where the\n-     * Base64OutputStream wraps itself in encode and decode mode\n-     * over and over again.\n-     *\n-     * @param encoded   base64 encoded data\n-     * @param decoded   the data from above, but decoded\n-     * @param chunkSize chunk size (line-length) of the base64 encoded data.\n-     * @param seperator Line separator in the base64 encoded data.\n-     * @throws Exception Usually signifies a bug in the Base64 commons-codec implementation.\n-     */\n-    private void testByteByByte(\n-            byte[] encoded, byte[] decoded, int chunkSize, byte[] seperator\n-    ) throws Exception {\n+     * By \"[WRAP-WRAP-WRAP-etc...]\" we mean situation where the Base64OutputStream wraps itself in encode and decode\n+     * mode over and over again.\n+     * \n+     * @param encoded\n+     *            base64 encoded data\n+     * @param decoded\n+     *            the data from above, but decoded\n+     * @param chunkSize\n+     *            chunk size (line-length) of the base64 encoded data.\n+     * @param seperator\n+     *            Line separator in the base64 encoded data.\n+     * @throws Exception\n+     *             Usually signifies a bug in the Base64 commons-codec implementation.\n+     */\n+    private void testByChunk(byte[] encoded, byte[] decoded, int chunkSize, byte[] seperator) throws Exception {\n+\n+        // Start with encode.\n+        ByteArrayOutputStream byteOut = new ByteArrayOutputStream();\n+        OutputStream out = new Base64OutputStream(byteOut, true, chunkSize, seperator);\n+        out.write(decoded);\n+        out.close();\n+        byte[] output = byteOut.toByteArray();\n+        assertTrue(\"Streaming base64 encode\", Arrays.equals(output, encoded));\n+\n+        // Now let's try decode.\n+        byteOut = new ByteArrayOutputStream();\n+        out = new Base64OutputStream(byteOut, false);\n+        out.write(encoded);\n+        out.close();\n+        output = byteOut.toByteArray();\n+        assertTrue(\"Streaming base64 decode\", Arrays.equals(output, decoded));\n+\n+        // I always wanted to do this! (wrap encoder with decoder etc etc).\n+        byteOut = new ByteArrayOutputStream();\n+        out = byteOut;\n+        for (int i = 0; i < 10; i++) {\n+            out = new Base64OutputStream(out, false);\n+            out = new Base64OutputStream(out, true, chunkSize, seperator);\n+        }\n+        out.write(decoded);\n+        out.close();\n+        output = byteOut.toByteArray();\n+\n+        assertTrue(\"Streaming base64 wrap-wrap-wrap!\", Arrays.equals(output, decoded));\n+    }\n+\n+    /**\n+     * Test method does three tests on the supplied data: 1. encoded ---[DECODE]--> decoded 2. decoded ---[ENCODE]-->\n+     * encoded 3. decoded ---[WRAP-WRAP-WRAP-etc...] --> decoded\n+     * <p/>\n+     * By \"[WRAP-WRAP-WRAP-etc...]\" we mean situation where the Base64OutputStream wraps itself in encode and decode\n+     * mode over and over again.\n+     * \n+     * @param encoded\n+     *            base64 encoded data\n+     * @param decoded\n+     *            the data from above, but decoded\n+     * @param chunkSize\n+     *            chunk size (line-length) of the base64 encoded data.\n+     * @param seperator\n+     *            Line separator in the base64 encoded data.\n+     * @throws Exception\n+     *             Usually signifies a bug in the Base64 commons-codec implementation.\n+     */\n+    private void testByteByByte(byte[] encoded, byte[] decoded, int chunkSize, byte[] seperator) throws Exception {\n \n         // Start with encode.\n         ByteArrayOutputStream byteOut = new ByteArrayOutputStream();\n         output = byteOut.toByteArray();\n         assertTrue(\"Streaming base64 decode\", Arrays.equals(output, decoded));\n \n-        // I always wanted to do this!  (wrap encoder with decoder etc etc).\n+        // I always wanted to do this! (wrap encoder with decoder etc etc).\n         byteOut = new ByteArrayOutputStream();\n         out = byteOut;\n         for (int i = 0; i < 10; i++) {\n     }\n \n     /**\n-     * Test method does three tests on the supplied data:\n-     * 1. encoded ---[DECODE]--> decoded\n-     * 2. decoded ---[ENCODE]--> encoded\n-     * 3. decoded ---[WRAP-WRAP-WRAP-etc...] --> decoded\n-     * <p/>\n-     * By \"[WRAP-WRAP-WRAP-etc...]\" we mean situation where the\n-     * Base64OutputStream wraps itself in encode and decode mode\n-     * over and over again.\n-     *\n-     * @param encoded   base64 encoded data\n-     * @param decoded   the data from above, but decoded\n-     * @param chunkSize chunk size (line-length) of the base64 encoded data.\n-     * @param seperator Line separator in the base64 encoded data.\n-     * @throws Exception Usually signifies a bug in the Base64 commons-codec implementation.\n-     */\n-    private void testByChunk(\n-            byte[] encoded, byte[] decoded, int chunkSize, byte[] seperator\n-    ) throws Exception {\n-\n-        // Start with encode.\n-        ByteArrayOutputStream byteOut = new ByteArrayOutputStream();\n-        OutputStream out = new Base64OutputStream(byteOut, true, chunkSize, seperator);\n-        out.write(decoded);\n-        out.close();\n-        byte[] output = byteOut.toByteArray();\n-        assertTrue(\"Streaming base64 encode\", Arrays.equals(output, encoded));\n-\n-        // Now let's try decode.\n-        byteOut = new ByteArrayOutputStream();\n-        out = new Base64OutputStream(byteOut, false);\n-        out.write(encoded);\n-        out.close();\n-        output = byteOut.toByteArray();\n-        assertTrue(\"Streaming base64 decode\", Arrays.equals(output, decoded));\n-\n-        // I always wanted to do this!  (wrap encoder with decoder etc etc).\n-        byteOut = new ByteArrayOutputStream();\n-        out = byteOut;\n-        for (int i = 0; i < 10; i++) {\n-            out = new Base64OutputStream(out, false);\n-            out = new Base64OutputStream(out, true, chunkSize, seperator);\n-        }\n-        out.write(decoded);\n-        out.close();\n-        output = byteOut.toByteArray();\n-\n-        assertTrue(\"Streaming base64 wrap-wrap-wrap!\", Arrays.equals(output, decoded));\n+     * Tests Base64OutputStream.write for expected IndexOutOfBoundsException conditions.\n+     * \n+     * @throws Exception\n+     *             for some failure scenarios.\n+     */\n+    public void testWriteOutOfBounds() throws Exception {\n+        byte[] buf = new byte[1024];\n+        ByteArrayOutputStream bout = new ByteArrayOutputStream();\n+        Base64OutputStream out = new Base64OutputStream(bout);\n+\n+        try {\n+            out.write(buf, -1, 0);\n+            fail(\"Expected Base64OutputStream.write(buf, -1, 0) to throw a IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException ioobe) {\n+            // Expected\n+        }\n+\n+        try {\n+            out.write(buf, buf.length + 1, 0);\n+            fail(\"Expected Base64OutputStream.write(buf, buf.length + 1, 0) to throw a IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException ioobe) {\n+            // Expected\n+        }\n+    }\n+\n+    /**\n+     * Tests Base64OutputStream.write(null).\n+     * \n+     * @throws Exception\n+     *             for some failure scenarios.\n+     */\n+    public void testWriteToNullCoverage() throws Exception {\n+        ByteArrayOutputStream bout = new ByteArrayOutputStream();\n+        Base64OutputStream out = new Base64OutputStream(bout);\n+        try {\n+            out.write(null, 0, 0);\n+            fail(\"Expcted Base64OutputStream.write(null) to throw a NullPointerException\");\n+        } catch (NullPointerException e) {\n+            // Expected\n+        }\n     }\n \n }\n--- a/src/test/org/apache/commons/codec/binary/Base64Test.java\n+++ b/src/test/org/apache/commons/codec/binary/Base64Test.java\n         try {\n             base64 = new Base64(-1,new byte[]{'A'});\n             fail(\"Should have rejected attempt to use 'A' as a line separator\");\n-        } catch (IllegalArgumentException ignored){\n-            \n+        } catch (IllegalArgumentException ignored) {\n+            // Expected\n         }\n         try {\n             base64 = new Base64(64,new byte[]{'A'});\n             fail(\"Should have rejected attempt to use 'A' as a line separator\");\n-        } catch (IllegalArgumentException ignored){\n-            \n+        } catch (IllegalArgumentException ignored) {\n+            // Expected            \n         }\n         try {\n             base64 = new Base64(64,new byte[]{'='});\n             fail(\"Should have rejected attempt to use '=' as a line separator\");\n-        } catch (IllegalArgumentException ignored){\n-            \n+        } catch (IllegalArgumentException ignored) {\n+            // Expected\n         }\n         base64 = new Base64(64,new byte[]{'$'}); // OK\n         try {\n             base64 = new Base64(64,new byte[]{'A','$'});\n             fail(\"Should have rejected attempt to use 'A$' as a line separator\");\n-        } catch (IllegalArgumentException ignored){\n-            \n+        } catch (IllegalArgumentException ignored) {\n+            // Expected\n         }\n         base64 = new Base64(64,new byte[]{' ','$','\\n','\\r','\\t'}); // OK\n     }\n     }\n \n     /**\n+     * Tests url-safe Base64 against random data, sizes 0 to 150.\n+     */\n+    public void testUrlSafe() {\n+        // test random data of sizes 0 thru 150\n+        for (int i = 0; i <= 150; i++) {\n+            byte[][] randomData = Base64TestData.randomData(i, true);\n+            byte[] encoded = randomData[1];\n+            byte[] decoded = randomData[0];\n+            byte[] result = Base64.decodeBase64(encoded);\n+            assertTrue(\"url-safe i=\" + i, Arrays.equals(decoded, result));\n+        }\n+\n+    }\n+\n+    /**\n+     * Tests isUrlSafe.\n+     */    \n+    public void testIsUrlSafe() {\n+        Base64 base64Standard = new Base64(false);        \n+        Base64 base64URLSafe = new Base64(true);\n+\n+        assertFalse(\"Base64.isUrlSafe=false\", base64Standard.isUrlSafe());\n+        assertTrue(\"Base64.isUrlSafe=true\", base64URLSafe.isUrlSafe());\n+\n+        byte[] whiteSpace = {' ', '\\n', '\\r', '\\t'};\n+        assertTrue(\"Base64.isArrayByteBase64(whiteSpace)=true\", Base64.isArrayByteBase64(whiteSpace)); \n+    }\n+\n+    /**\n      * Test encode and decode of empty byte array.\n      */\n     public void testEmptyBase64() {\n         byte[] empty = new byte[0];\n         byte[] result = Base64.encodeBase64(empty);\n         assertEquals(\"empty base64 encode\", 0, result.length);\n-\n+        assertEquals(\"empty base64 encode\", null, Base64.encodeBase64(null));\n+        \n         empty = new byte[0];\n         result = Base64.decodeBase64(empty);        \n         assertEquals(\"empty base64 decode\", 0, result.length);        \n+        assertEquals(\"empty base64 encode\", null, Base64.decodeBase64(null));\n     }\n \n     // -------------------------------------------------------- Private Methods\n--- a/src/test/org/apache/commons/codec/binary/Base64TestData.java\n+++ b/src/test/org/apache/commons/codec/binary/Base64TestData.java\n \n import java.io.IOException;\n import java.io.InputStream;\n+import java.util.Random;\n \n /**\n- * This random data was encoded by OpenSSL.  Java had nothing to do with it.\n- * This data helps us test interop between Commons-Codec and OpenSSL.  Notice\n- * that OpenSSL creates 64 character lines instead of the 76 of Commons-Codec.\n- *\n+ * This random data was encoded by OpenSSL. Java had nothing to do with it. This data helps us test interop between\n+ * Commons-Codec and OpenSSL. Notice that OpenSSL creates 64 character lines instead of the 76 of Commons-Codec.\n+ * \n  * @author Apache Software Foundation\n  * @version $Id $\n+ * @since 1.4\n  */\n public class Base64TestData {\n \n         return biggerBytes;\n     }\n \n+\n+    /**\n+     * Returns an encoded and decoded copy of the same random data.\n+     * \n+     * @param size amount of random data to generate and encode\n+     * @param urlSafe true if encoding be urlSafe\n+     * @return two byte[] arrays:  [0] = decoded, [1] = encoded \n+     */\n+    public static byte[][] randomData(int size, boolean urlSafe) {\n+        Random r = new Random();\n+        byte[] decoded = new byte[size];\n+        r.nextBytes(decoded);\n+        byte[] encoded = urlSafe ? Base64.encodeBase64URLSafe(decoded) : Base64.encodeBase64(decoded);\n+        return new byte[][] {decoded, encoded};\n+    }\n+\n }", "timestamp": 1247716877, "metainfo": ""}