{"sha": "a8502b5f546eddda66cc5d75c3c4552ea81c9ef5", "log": "Move private static data to start of module. Use constants for masks  ", "commit": "\n--- a/src/java/org/apache/commons/codec/binary/Base64.java\n+++ b/src/java/org/apache/commons/codec/binary/Base64.java\n      * \n      * @see <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045 section 2.1</a>\n      */\n-    static final byte[] CHUNK_SEPARATOR = \"\\r\\n\".getBytes();\n+    static final byte[] CHUNK_SEPARATOR = {'\\r','\\n'};\n+\n+    /**\n+     * This array is a lookup table that translates 6-bit positive integer\n+     * index values into their \"Base64 Alphabet\" equivalents as specified\n+     * in Table 1 of RFC 2045.\n+     *\n+     * Thanks to \"commons\" project in ws.apache.org for this code. \n+     * http://svn.apache.org/repos/asf/webservices/commons/trunk/modules/util/\n+     */\n+    private static final byte[] intToBase64 = {\n+            'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\n+            'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',\n+            'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',\n+            'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',\n+            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'\n+    };\n \n     /**\n      * Byte used to pad output.\n      */\n     private static final byte PAD = '=';\n \n+    /**\n+     * This array is a lookup table that translates unicode characters\n+     * drawn from the \"Base64 Alphabet\" (as specified in Table 1 of RFC 2045)\n+     * into their 6-bit positive integer equivalents.  Characters that\n+     * are not in the Base64 alphabet but fall within the bounds of the\n+     * array are translated to -1.\n+     *\n+     * Thanks to \"commons\" project in ws.apache.org for this code.\n+     * http://svn.apache.org/repos/asf/webservices/commons/trunk/modules/util/ \n+     */\n+    private static final byte[] base64ToInt = {\n+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n+            -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, -1, -1, 63, 52, 53, 54,\n+            55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -1, -1, -1, -1, 0, 1, 2, 3, 4,\n+            5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23,\n+            24, 25, -1, -1, -1, -1, -1, -1, 26, 27, 28, 29, 30, 31, 32, 33, 34,\n+            35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51\n+    };\n+\n+    /** Mask used to extract 6 bits, used when encoding */\n+    private static final int MASK_6BITS = 0x3f;\n+\n+    /** Mask used to extract 8 bits, used in decoding base64 bytes */\n+    private static final int MASK_8BITS = 0xff;\n \n     // The static final fields above are used for the original static byte[] methods on Base64.\n     // The private member fields below are used with the new streaming approach, which requires\n \n \n     /**\n-     * Line length for encoding.  Not used when decoding.  Any value of zero or less implies\n+     * Line length for encoding.  Not used when decoding.  A value of zero or less implies\n      * no chunking of the base64 encoded data.\n      */\n     private final int lineLength;\n     }\n \n     /**\n-     * This array is a lookup table that translates 6-bit positive integer\n-     * index values into their \"Base64 Alphabet\" equivalents as specified\n-     * in Table 1 of RFC 2045.\n-     *\n-     * Thanks to \"commons\" project in ws.apache.org for this code. \n-     * http://svn.apache.org/repos/asf/webservices/commons/trunk/modules/util/\n-     */\n-    private static final byte[] intToBase64 = {\n-            'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\n-            'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',\n-            'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',\n-            'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',\n-            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'\n-    };\n-\n-    /**\n-     * This array is a lookup table that translates unicode characters\n-     * drawn from the \"Base64 Alphabet\" (as specified in Table 1 of RFC 2045)\n-     * into their 6-bit positive integer equivalents.  Characters that\n-     * are not in the Base64 alphabet but fall within the bounds of the\n-     * array are translated to -1.\n-     *\n-     * Thanks to \"commons\" project in ws.apache.org for this code.\n-     * http://svn.apache.org/repos/asf/webservices/commons/trunk/modules/util/ \n-     */\n-    private static final byte[] base64ToInt = {\n-            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n-            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n-            -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, -1, -1, 63, 52, 53, 54,\n-            55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -1, -1, -1, -1, 0, 1, 2, 3, 4,\n-            5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23,\n-            24, 25, -1, -1, -1, -1, -1, -1, 26, 27, 28, 29, 30, 31, 32, 33, 34,\n-            35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51\n-    };\n-\n-    /**\n      * Returns true if this Base64 object has buffered data for reading.\n      *\n      * @return true if there is Base64 object still available for reading.\n             }\n             switch (modulus) {\n                 case 1:\n-                    buf[pos++] = intToBase64[(x >> 2) & 0x3f];\n-                    buf[pos++] = intToBase64[(x << 4) & 0x3f];\n+                    buf[pos++] = intToBase64[(x >> 2) & MASK_6BITS];\n+                    buf[pos++] = intToBase64[(x << 4) & MASK_6BITS];\n                     buf[pos++] = PAD;\n                     buf[pos++] = PAD;\n                     break;\n \n                 case 2:\n-                    buf[pos++] = intToBase64[(x >> 10) & 0x3f];\n-                    buf[pos++] = intToBase64[(x >> 4) & 0x3f];\n-                    buf[pos++] = intToBase64[(x << 2) & 0x3f];\n+                    buf[pos++] = intToBase64[(x >> 10) & MASK_6BITS];\n+                    buf[pos++] = intToBase64[(x >> 4) & MASK_6BITS];\n+                    buf[pos++] = intToBase64[(x << 2) & MASK_6BITS];\n                     buf[pos++] = PAD;\n                     break;\n             }\n                 if (b < 0) { b += 256; }\n                 x = (x << 8) + b;\n                 if (0 == modulus) {\n-                    buf[pos++] = intToBase64[(x >> 18) & 0x3f];\n-                    buf[pos++] = intToBase64[(x >> 12) & 0x3f];\n-                    buf[pos++] = intToBase64[(x >> 6) & 0x3f];\n-                    buf[pos++] = intToBase64[x & 0x3f];\n+                    buf[pos++] = intToBase64[(x >> 18) & MASK_6BITS];\n+                    buf[pos++] = intToBase64[(x >> 12) & MASK_6BITS];\n+                    buf[pos++] = intToBase64[(x >> 6) & MASK_6BITS];\n+                    buf[pos++] = intToBase64[x & MASK_6BITS];\n                     currentLinePos += 4;\n                     if (lineLength > 0 && lineLength <= currentLinePos) {\n                         System.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length);\n                     case 3:\n                         x = x << 6;\n                     case 0:\n-                        buf[pos++] = (byte) ((x >> 16) & 0xff);\n+                        buf[pos++] = (byte) ((x >> 16) & MASK_8BITS);\n                         if (modulus == 0) {\n-                            buf[pos++] = (byte) ((x >> 8) & 0xff);\n+                            buf[pos++] = (byte) ((x >> 8) & MASK_8BITS);\n                         }\n                     default:\n                         // WE'RE DONE!!!!\n                         modulus = (++modulus) % 4;\n                         x = (x << 6) + result;\n                         if (modulus == 0) {\n-                            buf[pos++] = (byte) ((x >> 16) & 0xff);\n-                            buf[pos++] = (byte) ((x >> 8) & 0xff);\n-                            buf[pos++] = (byte) (x & 0xff);\n+                            buf[pos++] = (byte) ((x >> 16) & MASK_8BITS);\n+                            buf[pos++] = (byte) ((x >> 8) & MASK_8BITS);\n+                            buf[pos++] = (byte) (x & MASK_8BITS);\n                         }\n                     }\n                 }", "timestamp": 1213989454, "metainfo": ""}