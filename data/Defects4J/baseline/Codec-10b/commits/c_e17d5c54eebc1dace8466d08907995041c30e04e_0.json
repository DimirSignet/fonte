{"sha": "e17d5c54eebc1dace8466d08907995041c30e04e", "log": "[CODEC-59] Add methods to Base64 which work with String instead of byte[]. Patch applied with one added test code line to keep line code coverage at 100%. Branch coverage up to 92% from 91%.  ", "commit": "\n--- a/src/java/org/apache/commons/codec/binary/Base64.java\n+++ b/src/java/org/apache/commons/codec/binary/Base64.java\n             }\n             byte b = in[inPos++];\n             if (b == PAD) {\n-                // WE'RE DONE!!!!\n+                // We're done.\n                 eof = true;\n                 break;\n             } else {\n      * \n      * @param binaryData\n      *            binary data to encode\n-     * @return Base64 characters\n+     * @return byte[] containing Base64 characters in their UTF-8 representation.\n      */\n     public static byte[] encodeBase64(byte[] binaryData) {\n         return encodeBase64(binaryData, false);\n     }\n \n     /**\n+     * Encodes binary data using the base64 algorithm into 76 character blocks separated by CRLF.\n+     *\n+     * @param binaryData\n+     *            binary data to encode\n+     * @return String containing Base64 characters.\n+     */    \n+    public static String encodeBase64String(byte[] binaryData) {\n+        return StringUtils.newStringUtf8(encodeBase64(binaryData, true));\n+    }\n+    \n+    /**\n      * Encodes binary data using a URL-safe variation of the base64 algorithm but does not chunk the output. The\n      * url-safe variation emits - and _ instead of + and / characters.\n      * \n      * @param binaryData\n      *            binary data to encode\n-     * @return Base64 characters\n+     * @return byte[] containing Base64 characters in their UTF-8 representation.\n      * @since 1.4\n      */\n     public static byte[] encodeBase64URLSafe(byte[] binaryData) {\n         return encodeBase64(binaryData, false, true);\n     }\n+\n+    /**\n+     * Encodes binary data using a URL-safe variation of the base64 algorithm but does not chunk the output. The\n+     * url-safe variation emits - and _ instead of + and / characters.\n+     *\n+     * @param binaryData\n+     *            binary data to encode\n+     * @return String containing Base64 characters\n+     * @since 1.4\n+     */    \n+    public static String encodeBase64URLSafeString(byte[] binaryData) {\n+        return StringUtils.newStringUtf8(encodeBase64(binaryData, false, true));\n+    }    \n \n     /**\n      * Encodes binary data using the base64 algorithm and chunks the encoded output into 76 character blocks\n \n     /**\n      * Decodes an Object using the base64 algorithm. This method is provided in order to satisfy the requirements of the\n-     * Decoder interface, and will throw a DecoderException if the supplied object is not of type byte[].\n+     * Decoder interface, and will throw a DecoderException if the supplied object is not of type byte[] or String.\n      * \n      * @param pObject\n      *            Object to decode\n-     * @return An object (of type byte[]) containing the binary data which corresponds to the byte[] supplied.\n+     * @return An object (of type byte[]) containing the binary data which corresponds to the byte[] or String supplied.\n      * @throws DecoderException\n      *             if the parameter supplied is not of type byte[]\n      */\n-    public Object decode(Object pObject) throws DecoderException {\n+    public Object decode(Object pObject) throws DecoderException {        \n         if (pObject instanceof byte[]) {\n             return decode((byte[]) pObject);\n+        } else if (pObject instanceof String) {\n+            return decode((String) pObject);\n         } else {\n-            throw new DecoderException(\"Parameter supplied to Base64 decode is not a byte[]\");\n-        }\n+            throw new DecoderException(\"Parameter supplied to Base64 decode is not a byte[] or a String\");\n+        }\n+    }\n+\n+    /**\n+     * Decodes a String containing containing characters in the Base64 alphabet.\n+     *\n+     * @param pArray\n+     *            A String containing Base64 character data\n+     * @return a byte array containing binary data\n+     */\n+    public byte[] decode(String pArray) {\n+        return decode(StringUtils.getBytesUtf8(pArray));\n     }\n \n     /**\n      * @return a byte array containing binary data\n      */\n     public byte[] decode(byte[] pArray) {\n+        reset();\n         if (pArray == null || pArray.length == 0) {\n             return pArray;\n         }\n     }\n \n     /**\n+     * Decodes a Base64 String into octets\n+     *\n+     * @param base64String\n+     *            String containing Base64 data\n+     * @return Array containing decoded data.\n+     */\n+    public static byte[] decodeBase64(String base64String) {\n+        return new Base64().decode(base64String);\n+    }\n+\n+    /**\n      * Decodes Base64 data into octets\n      * \n      * @param base64Data\n      * @return Array containing decoded data.\n      */\n     public static byte[] decodeBase64(byte[] base64Data) {\n-        Base64 b64 = new Base64();\n-        return b64.decode(base64Data);\n+        return new Base64().decode(base64Data);\n     }\n \n     /**\n     }\n \n     /**\n+     * Encodes a byte[] containing binary data, into a String containing characters in the Base64 alphabet.\n+     *\n+     * @param pArray\n+     *            a byte array containing binary data\n+     * @return A String containing only Base64 character data\n+     */    \n+    public String encodeToString(byte[] pArray) {\n+        return StringUtils.newStringUtf8(encode(pArray));\n+    }\n+\n+    /**\n      * Encodes a byte[] containing binary data, into a byte[] containing characters in the Base64 alphabet.\n      * \n      * @param pArray\n      * @return A byte array containing only Base64 character data\n      */\n     public byte[] encode(byte[] pArray) {\n+        reset();        \n+        if (pArray == null || pArray.length == 0) {\n+            return pArray;\n+        }\n         long len = getEncodeLength(pArray, lineLength, lineSeparator);\n         byte[] buf = new byte[(int) len];\n         setInitialBuffer(buf, 0, buf.length);\n         System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);\n         return resizedBytes;\n     }\n+\n+    /**\n+     * Resets this Base64 object to its initial newly constructed state.\n+     */\n+    private void reset() {\n+        buffer = null;\n+        pos = 0;\n+        readPos = 0;\n+        currentLinePos = 0;\n+        modulus = 0;\n+        eof = false;\n+    }\n+\n }\n--- a/src/java/org/apache/commons/codec/binary/StringUtils.java\n+++ b/src/java/org/apache/commons/codec/binary/StringUtils.java\n      * @see String#getBytes(String)\n      */\n     public static byte[] getSupportedBytes(String string, String charsetName) {\n+        if (string == null) {\n+            return null;\n+        }\n         try {\n             return string.getBytes(charsetName);\n         } catch (UnsupportedEncodingException e) {\n      * @see String#String(byte[], String)\n      */\n     public static String newString(byte[] bytes, String charsetName) {\n+        if (bytes == null) {\n+            return null;\n+        }\n         try {\n             return new String(bytes, charsetName);\n         } catch (UnsupportedEncodingException e) {\n--- a/src/test/org/apache/commons/codec/binary/Base64Test.java\n+++ b/src/test/org/apache/commons/codec/binary/Base64Test.java\n     public void testBase64() {\n         String content = \"Hello World\";\n         String encodedContent;\n-        encodedContent = new String(Base64.encodeBase64(content.getBytes()));\n+        byte[] encodedBytes = Base64.encodeBase64(StringUtils.getBytesUtf8(content));\n+        encodedContent = StringUtils.newStringUtf8(encodedBytes);\n         assertTrue(\"encoding hello world\", encodedContent.equals(\"SGVsbG8gV29ybGQ=\"));\n     }\n \n         empty = new byte[0];\n         result = Base64.decodeBase64(empty);\n         assertEquals(\"empty base64 decode\", 0, result.length);\n-        assertEquals(\"empty base64 encode\", null, Base64.decodeBase64(null));\n+        assertEquals(\"empty base64 encode\", null, Base64.decodeBase64((byte[]) null));\n     }\n \n     // encode/decode a large random array\n         Base64 b64 = new Base64();\n \n         try {\n-            b64.decode(\"Yadayadayada\");\n-            fail(\"decode(Object) didn't throw an exception when passed a String object\");\n+            b64.decode(new Integer(5));\n+            fail(\"decode(Object) didn't throw an exception when passed an Integer object\");\n         } catch (DecoderException e) {\n             // ignored\n         }\n         }\n     }\n \n+    public void testByteToStringVariations() throws DecoderException {\n+        Base64 base64 = new Base64(0);\n+        byte[] b1 = StringUtils.getBytesUtf8(\"Hello World\");\n+        byte[] b2 = new byte[0];\n+        byte[] b3 = null;\n+        byte[] b4 = Hex.decodeHex(\"2bf7cc2701fe4397b49ebeed5acc7090\".toCharArray());  // for url-safe tests\n+\n+        assertEquals(\"byteToString Hello World\", \"SGVsbG8gV29ybGQ=\", base64.encodeToString(b1));\n+        assertEquals(\"byteToString static Hello World\", \"SGVsbG8gV29ybGQ=\\r\\n\", Base64.encodeBase64String(b1));\n+        assertEquals(\"byteToString \\\"\\\"\", \"\", base64.encodeToString(b2));\n+        assertEquals(\"byteToString static \\\"\\\"\", \"\", Base64.encodeBase64String(b2));\n+        assertEquals(\"byteToString null\", null, base64.encodeToString(b3));\n+        assertEquals(\"byteToString static null\", null, Base64.encodeBase64String(b3));\n+        assertEquals(\"byteToString UUID\", \"K/fMJwH+Q5e0nr7tWsxwkA==\", base64.encodeToString(b4));\n+        assertEquals(\"byteToString static UUID\", \"K/fMJwH+Q5e0nr7tWsxwkA==\\r\\n\", Base64.encodeBase64String(b4));\n+        assertEquals(\"byteToString static-url-safe UUID\", \"K_fMJwH-Q5e0nr7tWsxwkA\", Base64.encodeBase64URLSafeString(b4));\n+    }\n+\n+    public void testStringToByteVariations() throws DecoderException {\n+        Base64 base64 = new Base64();\n+        String s1 = \"SGVsbG8gV29ybGQ=\\r\\n\";\n+        String s2 = \"\";\n+        String s3 = null;\n+        String s4a = \"K/fMJwH+Q5e0nr7tWsxwkA==\\r\\n\";\n+        String s4b = \"K_fMJwH-Q5e0nr7tWsxwkA\";\n+        byte[] b4 = Hex.decodeHex(\"2bf7cc2701fe4397b49ebeed5acc7090\".toCharArray());  // for url-safe tests\n+\n+        assertEquals(\"StringToByte Hello World\", \"Hello World\", StringUtils.newStringUtf8(base64.decode(s1)));\n+        assertEquals(\"StringToByte Hello World\", \"Hello World\", StringUtils.newStringUtf8((byte[])base64.decode((Object)s1)));\n+        assertEquals(\"StringToByte static Hello World\", \"Hello World\", StringUtils.newStringUtf8(Base64.decodeBase64(s1)));\n+        assertEquals(\"StringToByte \\\"\\\"\", \"\", StringUtils.newStringUtf8(base64.decode(s2)));\n+        assertEquals(\"StringToByte static \\\"\\\"\", \"\", StringUtils.newStringUtf8(Base64.decodeBase64(s2)));\n+        assertEquals(\"StringToByte null\", null, StringUtils.newStringUtf8(base64.decode(s3)));\n+        assertEquals(\"StringToByte static null\", null, StringUtils.newStringUtf8(Base64.decodeBase64(s3)));\n+        assertTrue(\"StringToByte UUID\", Arrays.equals(b4, base64.decode(s4b)));\n+        assertTrue(\"StringToByte static UUID\", Arrays.equals(b4, Base64.decodeBase64(s4a)));\n+        assertTrue(\"StringToByte static-url-safe UUID\", Arrays.equals(b4, Base64.decodeBase64(s4b)));\n+    }\n+\n     private String toString(byte[] data) {\n         StringBuffer buf = new StringBuffer();\n         for (int i = 0; i < data.length; i++) {", "timestamp": 1249100109, "metainfo": ""}