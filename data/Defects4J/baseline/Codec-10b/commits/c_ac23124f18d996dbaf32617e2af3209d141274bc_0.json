{"sha": "ac23124f18d996dbaf32617e2af3209d141274bc", "log": "Fixed the ending-MB bug - Bugzilla #28457 - also refactored some of the index arithmetic and content tests into functions for readability.   ", "commit": "\n--- a/src/java/org/apache/commons/codec/language/Metaphone.java\n+++ b/src/java/org/apache/commons/codec/language/Metaphone.java\n  *      <i>Computer Language</i> of Dec. 1990, p 39   \n  * \n  * @author Apache Software Foundation\n- * @version $Id: Metaphone.java,v 1.15 2004/02/29 04:08:31 tobrien Exp $\n+ * @version $Id: Metaphone.java,v 1.16 2004/04/18 21:33:38 tobrien Exp $\n  */\n public class Metaphone implements StringEncoder {\n \n      * @return A metaphone code corresponding to the String supplied\n      */\n     public String metaphone(String txt) {\n-        int mtsz = 0  ;\n         boolean hard = false ;\n         if ((txt == null) || (txt.length() == 0)) {\n             return \"\" ;\n         int wdsz = local.length();\n         int n = 0 ;\n \n-        while ((mtsz < this.getMaxCodeLen()) && (n < wdsz)) { // max code size of 4 works well\n+        while ((code.length() < this.getMaxCodeLen()) && \n+        \t   (n < wdsz) ) { // max code size of 4 works well\n             char symb = local.charAt(n) ;\n             // remove duplicate letters except C\n-            if ((symb != 'C') && (n > 0) && (local.charAt(n - 1) == symb)) {\n+            if ((symb != 'C') && (isPreviousChar( local, n, symb )) ) {\n                 n++ ;\n             } else { // not dup\n                 switch(symb) {\n                 case 'A' : case 'E' : case 'I' : case 'O' : case 'U' :\n                     if (n == 0) { \n                         code.append(symb);\n-                        mtsz++;\n                     }\n                     break ; // only use vowel if leading char\n                 case 'B' :\n-                    if ((n > 0) && !(n + 1 == wdsz) && (local.charAt(n - 1) == 'M')) { // not MB at end of word \n+                    if ( isPreviousChar(local, n, 'M') && \n+                         isLastChar(wdsz, n) ) { // B is silent if word ends in MB\n+\t\t\t\t\t\tbreak;\n+                    } else {\n                         code.append(symb);\n-                    } else {\n-                        code.append(symb);\n-                    }\n-                    mtsz++;\n+                    }\n                     break;\n                 case 'C' : // lots of C special cases\n                     /* discard if SCI, SCE or SCY */\n-                    if ((n > 0) && (local.charAt(n - 1) == 'S') && (n + 1 < wdsz) && (this.frontv.indexOf(local.charAt(n + 1)) >= 0)) { \n+                    if ( isPreviousChar(local, n, 'S') && \n+                         !isLastChar(wdsz, n) && \n+                         (this.frontv.indexOf(local.charAt(n + 1)) >= 0) ) { \n+                        break;\n+                    }\n+                    tmpS = local.toString();\n+                    if (regionMatch(local, n, \"CIA\")) { // \"CIA\" -> X\n+                        code.append('X'); \n+                        break;\n+                    }\n+                    if (!isLastChar(wdsz, n) && \n+                        (this.frontv.indexOf(local.charAt(n + 1)) >= 0)) {\n+                        code.append('S');\n+                        break; // CI,CE,CY -> S\n+                    }\n+                    if (isPreviousChar(local, n, 'S') &&\n+\t\t\t\t\t\tisNextChar(local, n, 'H') ) { // SCH->sk\n+                        code.append('K') ; \n                         break ;\n                     }\n-                    tmpS = local.toString();\n-                    if (tmpS.indexOf(\"CIA\", n) == n) { // \"CIA\" -> X\n-                        code.append('X'); mtsz++; break ;\n-                    }\n-                    if ((n + 1 < wdsz) && (this.frontv.indexOf(local.charAt(n + 1)) >= 0)) {\n-                        code.append('S');\n-                        mtsz++; \n-                        break ; // CI,CE,CY -> S\n-                    }\n-                    if ((n > 0) && (tmpS.indexOf(\"SCH\", n - 1) == n - 1)) { // SCH->sk\n-                        code.append('K') ; \n-                        mtsz++;\n-                        break ;\n-                    }\n-                    if (tmpS.indexOf(\"CH\", n) == n) { // detect CH\n-                        if ((n == 0) && (wdsz >= 3) && (this.vowels.indexOf(local.charAt(2)) < 0)) { // CH consonant -> K consonant\n+                    if (isNextChar(local, n, 'H')) { // detect CH\n+                        if ((n == 0) && \n+                        \t(wdsz >= 3) && \n+                            isVowel(local,2) ) { // CH consonant -> K consonant\n                             code.append('K');\n                         } else { \n                             code.append('X'); // CHvowel -> X\n                         }\n-                        mtsz++;\n                     } else { \n                         code.append('K');\n-                        mtsz++;\n                     }\n                     break ;\n                 case 'D' :\n-                    if ((n + 2 < wdsz)   && (local.charAt(n + 1) == 'G') && (this.frontv.indexOf(local.charAt(n + 2)) >= 0)) { // DGE DGI DGY -> J \n+                    if (!isLastChar(wdsz, n + 1) && \n+                        isNextChar(local, n, 'G') && \n+                        (this.frontv.indexOf(local.charAt(n + 2)) >= 0)) { // DGE DGI DGY -> J \n                         code.append('J'); n += 2 ;\n                     } else { \n                         code.append('T');\n                     }\n-                    mtsz++;\n                     break ;\n                 case 'G' : // GH silent at end or before consonant\n-                    if ((n + 2 == wdsz) && (local.charAt(n + 1) == 'H')) {\n-                        break;\n-                    }\n-                    if ((n + 2 < wdsz) && (local.charAt(n + 1) == 'H') && (this.vowels.indexOf(local.charAt(n + 2)) < 0)) {\n+                    if (isLastChar(wdsz, n + 1) && \n+                        isNextChar(local, n, 'H')) {\n+                        break;\n+                    }\n+                    if (!isLastChar(wdsz, n + 1) &&  \n+                        isNextChar(local,n,'H') && \n+                        !isVowel(local,n+2)) {\n                         break;\n                     }\n                     tmpS = local.toString();\n-                    if ((n > 0) && (tmpS.indexOf(\"GN\", n) == n) || (tmpS.indexOf(\"GNED\", n) == n)) {\n+                    if ((n > 0) && \n+                    \t( regionMatch(local, n, \"GN\") ||\n+\t\t\t\t\t      regionMatch(local, n, \"GNED\") ) ) {\n                         break; // silent G\n                     }\n-                    if ((n > 0) && (local.charAt(n - 1) == 'G')) {\n+                    if (isPreviousChar(local, n, 'G')) {\n                         hard = true ;\n                     } else {\n                         hard = false ;\n                     }\n-                    if ((n + 1 < wdsz) && (this.frontv.indexOf(local.charAt(n + 1)) >= 0) && (!hard)) {\n+                    if (!isLastChar(wdsz, n) && \n+                        (this.frontv.indexOf(local.charAt(n + 1)) >= 0) && \n+                        (!hard)) {\n                         code.append('J');\n                     } else {\n                         code.append('K');\n                     }\n-                    mtsz++;\n                     break ;\n                 case 'H':\n-                    if (n + 1 == wdsz) {\n+                    if (isLastChar(wdsz, n)) {\n                         break ; // terminal H\n                     }\n-                    if ((n > 0) && (this.varson.indexOf(local.charAt(n - 1)) >= 0)) {\n-                        break;\n-                    }\n-                    if (this.vowels.indexOf(local.charAt(n + 1)) >= 0) {\n-                        code.append('H'); \n-                        mtsz++;// Hvowel\n+                    if ((n > 0) && \n+                        (this.varson.indexOf(local.charAt(n - 1)) >= 0)) {\n+                        break;\n+                    }\n+                    if (isVowel(local,n+1)) {\n+                        code.append('H'); // Hvowel\n                     }\n                     break;\n                 case 'F': \n                 case 'N' : \n                 case 'R' :\n                     code.append(symb); \n-                    mtsz++; \n                     break;\n                 case 'K' :\n                     if (n > 0) { // not initial\n-                        if (local.charAt(n - 1) != 'C') {\n+                        if (!isPreviousChar(local, n, 'C')) {\n                             code.append(symb);\n                         }\n                     } else {\n                         code.append(symb); // initial K\n                     }\n-                    mtsz++ ;\n                     break ;\n                 case 'P' :\n-                    if ((n + 1 < wdsz) && (local.charAt(n + 1) == 'H')) {\n+                    if (isNextChar(local,n,'H')) {\n                         // PH -> F\n                         code.append('F');\n                     } else {\n                         code.append(symb);\n                     }\n-                    mtsz++;\n                     break ;\n                 case 'Q' :\n                     code.append('K');\n-                    mtsz++; \n                     break;\n                 case 'S' :\n-                    tmpS = local.toString();\n-                    if ((tmpS.indexOf(\"SH\", n) == n) || (tmpS.indexOf(\"SIO\", n) == n) || (tmpS.indexOf(\"SIA\", n) == n)) {\n+                    if (regionMatch(local,n,\"SH\") || \n+\t\t\t\t\t    regionMatch(local,n,\"SIO\") || \n+\t\t\t\t\t    regionMatch(local,n,\"SIA\")) {\n                         code.append('X');\n                     } else {\n                         code.append('S');\n                     }\n-                    mtsz++;\n                     break;\n                 case 'T' :\n-                    tmpS = local.toString(); // TIA TIO -> X\n-                    if ((tmpS.indexOf(\"TIA\", n) == n) || (tmpS.indexOf(\"TIO\", n) == n)) {\n+                    if (regionMatch(local,n,\"TIA\") || \n+\t\t\t\t\t\tregionMatch(local,n,\"TIO\")) {\n                         code.append('X'); \n-                        mtsz++; \n-                        break;\n-                    }\n-                    if (tmpS.indexOf(\"TCH\", n) == n) {\n+                        break;\n+                    }\n+                    if (regionMatch(local,n,\"TCH\")) {\n+\t\t\t\t\t\t// Silent if in \"TCH\"\n                         break;\n                     }\n                     // substitute numeral 0 for TH (resembles theta after all)\n-                    if (tmpS.indexOf(\"TH\", n) == n) {\n+                    if (regionMatch(local,n,\"TH\")) {\n                         code.append('0');\n                     } else {\n                         code.append('T');\n                     }\n-                    mtsz++ ;\n                     break ;\n                 case 'V' :\n-                    code.append('F'); mtsz++;break ;\n+                    code.append('F'); break ;\n                 case 'W' : case 'Y' : // silent if not followed by vowel\n-                    if ((n + 1 < wdsz) && (this.vowels.indexOf(local.charAt(n + 1)) >= 0)) {\n+                    if (!isLastChar(wdsz,n) && \n+                    \tisVowel(local,n+1)) {\n                         code.append(symb);\n-                        mtsz++;\n                     }\n                     break ;\n                 case 'X' :\n-                    code.append('K'); code.append('S');mtsz += 2;\n+                    code.append('K'); code.append('S');\n                     break ;\n                 case 'Z' :\n-                    code.append('S'); mtsz++; break ;\n+                    code.append('S'); break ;\n                 } // end switch\n                 n++ ;\n             } // end else from symb != 'C'\n-            if (mtsz > this.getMaxCodeLen()) { code.setLength(this.getMaxCodeLen()); }\n+            if (code.length() > this.getMaxCodeLen()) { \n+            \tcode.setLength(this.getMaxCodeLen()); \n+            }\n         }\n         return code.toString();\n-    } \n+    }\n+\n+\tprivate boolean isVowel(StringBuffer string, int index) {\n+\t\treturn (this.vowels.indexOf(string.charAt(index)) >= 0);\n+\t}\n+\n+\tprivate boolean isPreviousChar(StringBuffer string, int index, char c) {\n+\t\tboolean matches = false;\n+\t\tif( index > 0 &&\n+\t\t    index < string.length() ) {\n+\t\t\tmatches = string.charAt(index - 1) == c;\n+\t\t}\n+\t\treturn matches;\n+\t}\n+\n+\tprivate boolean isNextChar(StringBuffer string, int index, char c) {\n+\t\tboolean matches = false;\n+\t\tif( index >= 0 &&\n+\t\t    index < string.length() - 1 ) {\n+\t\t\tmatches = string.charAt(index + 1) == c;\n+\t\t}\n+\t\treturn matches;\n+\t}\n+\n+\tprivate boolean regionMatch(StringBuffer string, int index, String test) {\n+\t\tboolean matches = false;\n+\t\tif( index >= 0 &&\n+\t\t    (index + test.length() - 1) < string.length() ) {\n+\t\t\tString substring = string.substring( index, index + test.length());\n+\t\t\tmatches = substring.equals( test );\n+\t\t}\n+\t\treturn matches;\n+\t}\n+\n+\tprivate boolean isLastChar(int wdsz, int n) {\n+\t\treturn n + 1 == wdsz;\n+\t} \n     \n     \n     /**", "timestamp": 1082324018, "metainfo": ""}