{"sha": "e7b46fdf5fc20526e0058946f5d47c0e4c3809ee", "log": "Javadoc  ", "commit": "\n--- a/src/java/org/apache/commons/codec/binary/Base32.java\n+++ b/src/java/org/apache/commons/codec/binary/Base32.java\n /**\n  * Provides Base32 encoding and decoding as defined by RFC 4648.\n  * \n- *                               <b>Initial implementation. API may change. Incomplete.</b>\n- *  \n  * <p>\n  * The class can be parameterized in the following manner with various constructors:\n  * <ul>\n+ * <li>Whether to use the \"base32hex\" variant instead of the default \"base32\"</li>\n  * <li>Line length: Default 76. Line length that aren't multiples of 8 will still essentially end up being multiples of\n  * 8 in the encoded data.\n- * \n  * <li>Line separator: Default is CRLF (\"\\r\\n\")</li>\n  * </ul>\n  * </p>\n  * <p>\n- * Since this class operates directly on byte streams, and not character streams, it is hard-coded to only encode/decode\n- * character encodings which are compatible with the lower 127 ASCII chart (ISO-8859-1, Windows-1252, UTF-8, etc).\n+ * This class operates directly on byte streams, and not character streams.\n  * </p>\n  * \n  * @see <a href=\"http://www.ietf.org/rfc/rfc4648.txt\">RFC 4648</a>\n      * They are formed by taking a block of five octets to form a 40-bit string, \n      * which is converted into eight BASE32 characters.\n      */\n-    private static final int BITS_PER_ENCODED_CHAR = 5;\n+    private static final int BITS_PER_ENCODED_BYTE = 5;\n     private static final int BYTES_PER_UNENCODED_BLOCK = 5;\n     private static final int BYTES_PER_ENCODED_BLOCK = 8;\n \n         } else {\n             for (int i = 0; i < inAvail; i++) {\n                 ensureBufferSize(encodeSize);\n-                modulus = (++modulus) % BITS_PER_ENCODED_CHAR;\n+                modulus = (++modulus) % BITS_PER_ENCODED_BYTE;\n                 int b = in[inPos++];\n                 if (b < 0) {\n                     b += 256;\n                     int result = this.decodeTable[b];\n                     if (result >= 0) {\n                         modulus = (++modulus) % BYTES_PER_ENCODED_BLOCK;\n-                        bitWorkArea = (bitWorkArea << BITS_PER_ENCODED_CHAR) + result; // collect decoded bytes\n+                        bitWorkArea = (bitWorkArea << BITS_PER_ENCODED_BYTE) + result; // collect decoded bytes\n                         if (modulus == 0) { // we can output the 5 bytes\n                             buffer[pos++] = (byte) ((bitWorkArea >> 32) & MASK_8BITS);\n                             buffer[pos++] = (byte) ((bitWorkArea >> 24) & MASK_8BITS);", "timestamp": 1296156793, "metainfo": ""}