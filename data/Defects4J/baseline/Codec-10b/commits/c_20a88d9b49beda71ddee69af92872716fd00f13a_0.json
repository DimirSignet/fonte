{"sha": "20a88d9b49beda71ddee69af92872716fd00f13a", "log": "- Applied patch for [CODEC-81] production pretty much unchanged.  - Applied patch for [CODEC-81] tests and split one new unit test method into two tests. One for URL-safe and another for normal processing. - Renamed StringBytesUtils to StringUtils - Added missing @return tags to StringUtils  ", "commit": "\n--- a/src/java/org/apache/commons/codec/binary/Base64.java\n+++ b/src/java/org/apache/commons/codec/binary/Base64.java\n      * </p>\n      * \n      * @param lineLength\n-     *            Each line of encoded data will be at most of the given length (rounded up to nearest multiple of 4).\n+     *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of 4).\n      *            If lineLength <= 0, then the output will not be divided into lines (chunks). Ignored when decoding.\n      * @since 1.4\n      */\n      * </p>\n      * \n      * @param lineLength\n-     *            Each line of encoded data will be at most of the given length (rounded up to nearest multiple of 4).\n+     *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of 4).\n      *            If lineLength <= 0, then the output will not be divided into lines (chunks). Ignored when decoding.\n      * @param lineSeparator\n      *            Each line of encoded data will end with this sequence of bytes.\n      * </p>\n      * \n      * @param lineLength\n-     *            Each line of encoded data will be at most of the given length (rounded up to nearest multiple of 4).\n+     *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of 4).\n      *            If lineLength <= 0, then the output will not be divided into lines (chunks). Ignored when decoding.\n      * @param lineSeparator\n      *            Each line of encoded data will end with this sequence of bytes.\n      * @since 1.4\n      */\n     public Base64(int lineLength, byte[] lineSeparator, boolean urlSafe) {\n-        this.lineLength = lineLength;\n+        this.lineLength = lineLength > 0 ? (lineLength / 4) * 4 : 0;\n         this.lineSeparator = new byte[lineSeparator.length];\n         System.arraycopy(lineSeparator, 0, this.lineSeparator, 0, lineSeparator.length);\n         if (lineLength > 0) {\n         }\n         this.decodeSize = this.encodeSize - 1;\n         if (containsBase64Byte(lineSeparator)) {\n-            String sep = StringBytesUtils.newStringUtf8(lineSeparator);\n+            String sep = StringUtils.newStringUtf8(lineSeparator);\n             throw new IllegalArgumentException(\"lineSeperator must not contain base64 characters: [\" + sep + \"]\");\n         }\n         this.encodeTable = urlSafe ? URL_SAFE_ENCODE_TABLE : STANDARD_ENCODE_TABLE;\n      *             if the parameter supplied is not of type byte[]\n      */\n     public Object decode(Object pObject) throws DecoderException {\n-        if (!(pObject instanceof byte[])) {\n+        if (pObject instanceof byte[]) {\n+            return decode((byte[]) pObject);\n+        } else {\n             throw new DecoderException(\"Parameter supplied to Base64 decode is not a byte[]\");\n         }\n-        return decode((byte[]) pObject);\n     }\n \n     /**\n      * @return a byte array containing binary data\n      */\n     public byte[] decode(byte[] pArray) {\n-        return decodeBase64(pArray);\n+        if (pArray == null || pArray.length == 0) {\n+            return pArray;\n+        }\n+        long len = (pArray.length * 3) / 4;\n+        byte[] buf = new byte[(int) len];\n+        setInitialBuffer(buf, 0, buf.length);\n+        decode(pArray, 0, pArray.length);\n+        decode(pArray, 0, -1); // Notify decoder of EOF.\n+\n+        // Would be nice to just return buf (like we sometimes do in the encode\n+        // logic), but we have no idea what the line-length was (could even be\n+        // variable).  So we cannot determine ahead of time exactly how big an\n+        // array is necessary.  Hence the need to construct a 2nd byte array to\n+        // hold the final result:\n+\n+        byte[] result = new byte[pos];\n+        readResults(result, 0, result.length);\n+        return result;\n     }\n \n     /**\n         if (binaryData == null || binaryData.length == 0) {\n             return binaryData;\n         }\n-        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);\n-        long len = (binaryData.length * 4) / 3;\n-        long mod = len % 4;\n-        if (mod != 0) {\n-            len += 4 - mod;\n-        }\n-        if (isChunked) {\n-            boolean lenChunksPerfectly = len % CHUNK_SIZE == 0;\n-            len += (len / CHUNK_SIZE) * CHUNK_SEPARATOR.length;\n-            if (!lenChunksPerfectly) {\n-                len += CHUNK_SEPARATOR.length;\n-            }\n-        }\n+\n+        long len = getEncodeLength(binaryData, CHUNK_SIZE, CHUNK_SEPARATOR);\n         if (len > maxResultSize) {\n             throw new IllegalArgumentException(\"Input array too big, the output array would be bigger (\" +\n                 len +\n                 \") than the specified maxium size of \" +\n                 maxResultSize);\n         }\n-        byte[] buf = new byte[(int) len];\n-        b64.setInitialBuffer(buf, 0, buf.length);\n-        b64.encode(binaryData, 0, binaryData.length);\n-        b64.encode(binaryData, 0, -1); // Notify encoder of EOF.\n-        // Encoder might have resized, even though it was unnecessary.\n-        if (b64.buffer != buf) {\n-            b64.readResults(buf, 0, buf.length);\n-        }\n-        // In URL-SAFE mode we skip the padding characters, so sometimes our\n-        // final length is a bit smaller.\n-        if (urlSafe && b64.pos < buf.length) {\n-            byte[] smallerBuf = new byte[b64.pos];\n-            System.arraycopy(buf, 0, smallerBuf, 0, b64.pos);\n-            buf = smallerBuf;\n-        }\n-        return buf;\n+                \n+        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);\n+        return b64.encode(binaryData);\n     }\n \n     /**\n      * @return Array containing decoded data.\n      */\n     public static byte[] decodeBase64(byte[] base64Data) {\n-        if (base64Data == null || base64Data.length == 0) {\n-            return base64Data;\n-        }\n         Base64 b64 = new Base64();\n-        long len = (base64Data.length * 3) / 4;\n-        byte[] buf = new byte[(int) len];\n-        b64.setInitialBuffer(buf, 0, buf.length);\n-        b64.decode(base64Data, 0, base64Data.length);\n-        b64.decode(base64Data, 0, -1); // Notify decoder of EOF.\n-        // We have no idea what the line-length was, so we\n-        // cannot know how much of our array wasn't used.\n-        byte[] result = new byte[b64.pos];\n-        b64.readResults(result, 0, result.length);\n-        return result;\n+        return b64.decode(base64Data);\n     }\n \n     /**\n      * @return A byte array containing only Base64 character data\n      */\n     public byte[] encode(byte[] pArray) {\n-        return encodeBase64(pArray, false, isUrlSafe());\n+        long len = getEncodeLength(pArray, lineLength, lineSeparator);\n+        byte[] buf = new byte[(int) len];\n+        setInitialBuffer(buf, 0, buf.length);\n+        encode(pArray, 0, pArray.length);\n+        encode(pArray, 0, -1); // Notify encoder of EOF.\n+        // Encoder might have resized, even though it was unnecessary.\n+        if (buffer != buf) {\n+            readResults(buf, 0, buf.length);\n+        }\n+        // In URL-SAFE mode we skip the padding characters, so sometimes our\n+        // final length is a bit smaller.\n+        if (isUrlSafe() && pos < buf.length) {\n+            byte[] smallerBuf = new byte[pos];\n+            System.arraycopy(buf, 0, smallerBuf, 0, pos);\n+            buf = smallerBuf;\n+        }\n+        return buf;        \n+    }\n+\n+    /**\n+     * Pre-calculates the amount of space needed to base64-encode the supplied array.\n+     *\n+     * @param pArray byte[] array which will later be encoded\n+     * @param chunkSize line-length of the output (<= 0 means no chunking) between each\n+     *        chunkSeparator (e.g. CRLF).\n+     * @param chunkSeparator the sequence of bytes used to separate chunks of output (e.g. CRLF).\n+     *\n+     * @return amount of space needed to encoded the supplied array.  Returns\n+     *         a long since a max-len array will require Integer.MAX_VALUE + 33%.\n+     */\n+    private static long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {\n+        // base64 always encodes to multiples of 4.\n+        chunkSize = (chunkSize / 4) * 4;\n+\n+        long len = (pArray.length * 4) / 3;\n+        long mod = len % 4;\n+        if (mod != 0) {\n+            len += 4 - mod;\n+        }\n+        if (chunkSize > 0 && chunkSeparator != null) {\n+            boolean lenChunksPerfectly = len % chunkSize == 0;\n+            len += (len / chunkSize) * chunkSeparator.length;\n+            if (!lenChunksPerfectly) {\n+                len += chunkSeparator.length;\n+            }\n+        }\n+        return len;\n     }\n \n     // Implementation of integer encoding used for crypto\n--- a/src/java/org/apache/commons/codec/binary/Base64InputStream.java\n+++ b/src/java/org/apache/commons/codec/binary/Base64InputStream.java\n import java.io.InputStream;\n \n /**\n- * Provides Base64 encoding and decoding in a streaming fashion (unlimited size).\n- * When encoding the default lineLength is 76 characters and the default\n- * lineEnding is CRLF, but these can be overridden by using the appropriate\n+ * Provides Base64 encoding and decoding in a streaming fashion (unlimited size). When encoding the default lineLength\n+ * is 76 characters and the default lineEnding is CRLF, but these can be overridden by using the appropriate\n  * constructor.\n  * <p>\n- * The default behaviour of the Base64InputStream is to DECODE, whereas the\n- * default behaviour of the Base64OutputStream is to ENCODE, but this\n- * behaviour can be overridden by using a different constructor.\n- * </p><p>\n+ * The default behaviour of the Base64InputStream is to DECODE, whereas the default behaviour of the Base64OutputStream\n+ * is to ENCODE, but this behaviour can be overridden by using a different constructor.\n+ * </p>\n+ * <p>\n  * This class implements section <cite>6.8. Base64 Content-Transfer-Encoding</cite> from RFC 2045 <cite>Multipurpose\n  * Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies</cite> by Freed and Borenstein.\n- * </p><p>\n+ * </p>\n+ * <p>\n  * Since this class operates directly on byte streams, and not character streams, it is hard-coded to only encode/decode\n- * character encodings which are compatible with the lower 127 ASCII chart (ISO-8859-1, Windows-1252, UTF-8, etc). \n+ * character encodings which are compatible with the lower 127 ASCII chart (ISO-8859-1, Windows-1252, UTF-8, etc).\n  * </p>\n+ * \n  * @author Apache Software Foundation\n  * @version $Id $\n  * @see <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045</a>\n public class Base64InputStream extends FilterInputStream {\n \n     private final boolean doEncode;\n+\n     private final Base64 base64;\n+\n     private final byte[] singleByte = new byte[1];\n \n     /**\n-     * Creates a Base64InputStream such that all data read is Base64-decoded\n-     * from the original provided InputStream.\n-     *\n-     * @param in InputStream to wrap.\n+     * Creates a Base64InputStream such that all data read is Base64-decoded from the original provided InputStream.\n+     * \n+     * @param in\n+     *            InputStream to wrap.\n      */\n     public Base64InputStream(InputStream in) {\n         this(in, false);\n     }\n \n     /**\n-     * Creates a Base64InputStream such that all data read is either\n-     * Base64-encoded or Base64-decoded from the original provided InputStream.\n-     *\n-     * @param in       InputStream to wrap.\n-     * @param doEncode true if we should encode all data read from us,\n-     *                 false if we should decode.\n+     * Creates a Base64InputStream such that all data read is either Base64-encoded or Base64-decoded from the original\n+     * provided InputStream.\n+     * \n+     * @param in\n+     *            InputStream to wrap.\n+     * @param doEncode\n+     *            true if we should encode all data read from us, false if we should decode.\n      */\n     public Base64InputStream(InputStream in, boolean doEncode) {\n         super(in);\n     }\n \n     /**\n-     * Creates a Base64InputStream such that all data read is either\n-     * Base64-encoded or Base64-decoded from the original provided InputStream.\n-     *\n-     * @param in            InputStream to wrap.\n-     * @param doEncode      true if we should encode all data read from us,\n-     *                      false if we should decode.\n-     * @param lineLength    If doEncode is true, each line of encoded\n-     *                      data will contain lineLength characters.\n-     *                      If lineLength <=0, the encoded data is not divided into lines.\n-     *                      If doEncode is false, lineLength is ignored.\n-     * @param lineSeparator If doEncode is true, each line of encoded\n-     *                      data will be terminated with this byte sequence (e.g. \\r\\n).\n-     *                      If lineLength <= 0, the lineSeparator is not used.  \n-     *                      If doEncode is false lineSeparator is ignored.\n+     * Creates a Base64InputStream such that all data read is either Base64-encoded or Base64-decoded from the original\n+     * provided InputStream.\n+     * \n+     * @param in\n+     *            InputStream to wrap.\n+     * @param doEncode\n+     *            true if we should encode all data read from us, false if we should decode.\n+     * @param lineLength\n+     *            If doEncode is true, each line of encoded data will contain lineLength characters (rounded down to\n+     *            nearest multiple of 4). If lineLength <=0, the encoded data is not divided into lines. If doEncode is\n+     *            false, lineLength is ignored.\n+     * @param lineSeparator\n+     *            If doEncode is true, each line of encoded data will be terminated with this byte sequence (e.g. \\r\\n).\n+     *            If lineLength <= 0, the lineSeparator is not used. If doEncode is false lineSeparator is ignored.\n      */\n     public Base64InputStream(InputStream in, boolean doEncode, int lineLength, byte[] lineSeparator) {\n         super(in);\n     /**\n      * Reads one <code>byte</code> from this input stream.\n      * \n-     * @return the byte as an integer in the range 0 to 255\n-     * Returns -1 if EOF has been reached.\n+     * @return the byte as an integer in the range 0 to 255. Returns -1 if EOF has been reached.\n+     * @throws IOException\n+     *             if an I/O error occurs.\n      */\n     public int read() throws IOException {\n         int r = read(singleByte, 0, 1);\n     }\n \n     /**\n-     * Attempts to read <code>len</code> bytes into the specified\n-     * <code>b</code> array starting at <code>offset</code> from\n-     * this InputStream.\n+     * Attempts to read <code>len</code> bytes into the specified <code>b</code> array starting at <code>offset</code>\n+     * from this InputStream.\n      * \n-     * @param b destination byte array\n-     * @param offset where to start writing the bytes\n-     * @param len maximum number of bytes to read\n+     * @param b\n+     *            destination byte array\n+     * @param offset\n+     *            where to start writing the bytes\n+     * @param len\n+     *            maximum number of bytes to read\n      * \n      * @return number of bytes read\n-     * @throws IOException if an I/O error occurs.\n-     * @throws NullPointerException if the byte array parameter is null\n-     * @throws IndexOutOfBoundsException if offset, len or buffer size are invalid\n+     * @throws IOException\n+     *             if an I/O error occurs.\n+     * @throws NullPointerException\n+     *             if the byte array parameter is null\n+     * @throws IndexOutOfBoundsException\n+     *             if offset, len or buffer size are invalid\n      */\n     public int read(byte b[], int offset, int len) throws IOException {\n         if (b == null) {\n             if (!base64.hasData()) {\n                 byte[] buf = new byte[doEncode ? 4096 : 8192];\n                 int c = in.read(buf);\n-\n                 // A little optimization to avoid System.arraycopy()\n                 // when possible.\n                 if (c > 0 && b.length == len) {\n                     base64.setInitialBuffer(b, offset, len);\n                 }\n-\n                 if (doEncode) {\n                     base64.encode(buf, 0, c);\n                 } else {\n \n     /**\n      * {@inheritDoc}\n+     * \n      * @return false\n      */\n     public boolean markSupported() {\n--- a/src/java/org/apache/commons/codec/binary/Base64OutputStream.java\n+++ b/src/java/org/apache/commons/codec/binary/Base64OutputStream.java\n import java.io.OutputStream;\n \n /**\n- * Provides Base64 encoding and decoding in a streaming fashion (unlimited size).\n- * When encoding the default lineLength is 76 characters and the default\n- * lineEnding is CRLF, but these can be overridden by using the appropriate\n+ * Provides Base64 encoding and decoding in a streaming fashion (unlimited size). When encoding the default lineLength\n+ * is 76 characters and the default lineEnding is CRLF, but these can be overridden by using the appropriate\n  * constructor.\n  * <p>\n- * The default behaviour of the Base64OutputStream is to ENCODE, whereas the\n- * default behaviour of the Base64InputStream is to DECODE.  But this behaviour\n- * can be overridden by using a different constructor.\n- * </p><p>\n+ * The default behaviour of the Base64OutputStream is to ENCODE, whereas the default behaviour of the Base64InputStream\n+ * is to DECODE. But this behaviour can be overridden by using a different constructor.\n+ * </p>\n+ * <p>\n  * This class implements section <cite>6.8. Base64 Content-Transfer-Encoding</cite> from RFC 2045 <cite>Multipurpose\n  * Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies</cite> by Freed and Borenstein.\n- * </p><p>\n+ * </p>\n+ * <p>\n  * Since this class operates directly on byte streams, and not character streams, it is hard-coded to only encode/decode\n  * character encodings which are compatible with the lower 127 ASCII chart (ISO-8859-1, Windows-1252, UTF-8, etc).\n- * </p> \n+ * </p>\n+ * \n  * @author Apache Software Foundation\n  * @version $Id $\n  * @see <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045</a>\n  */\n public class Base64OutputStream extends FilterOutputStream {\n     private final boolean doEncode;\n+\n     private final Base64 base64;\n+\n     private final byte[] singleByte = new byte[1];\n \n     /**\n-     * Creates a Base64OutputStream such that all data written is Base64-encoded\n-     * to the original provided OutputStream.\n-     *\n-     * @param out OutputStream to wrap.\n+     * Creates a Base64OutputStream such that all data written is Base64-encoded to the original provided OutputStream.\n+     * \n+     * @param out\n+     *            OutputStream to wrap.\n      */\n     public Base64OutputStream(OutputStream out) {\n         this(out, true);\n     }\n \n     /**\n-     * Creates a Base64OutputStream such that all data written is either\n-     * Base64-encoded or Base64-decoded to the original provided OutputStream.\n-     *\n-     * @param out      OutputStream to wrap.\n-     * @param doEncode true if we should encode all data written to us,\n-     *                 false if we should decode.\n+     * Creates a Base64OutputStream such that all data written is either Base64-encoded or Base64-decoded to the\n+     * original provided OutputStream.\n+     * \n+     * @param out\n+     *            OutputStream to wrap.\n+     * @param doEncode\n+     *            true if we should encode all data written to us, false if we should decode.\n      */\n     public Base64OutputStream(OutputStream out, boolean doEncode) {\n         super(out);\n     }\n \n     /**\n-     * Creates a Base64OutputStream such that all data written is either\n-     * Base64-encoded or Base64-decoded to the original provided OutputStream.\n-     *\n-     * @param out           OutputStream to wrap.\n-     * @param doEncode      true if we should encode all data written to us,\n-     *                      false if we should decode.\n-     * @param lineLength    If doEncode is true, each line of encoded\n-     *                      data will contain lineLength characters.  \n-     *                      If lineLength <=0, the encoded data is not divided into lines.\n-     *                      If doEncode is false, lineLength is ignored.\n-     * @param lineSeparator If doEncode is true, each line of encoded\n-     *                      data will be terminated with this byte sequence (e.g. \\r\\n).  \n-     *                      If lineLength <= 0, the lineSeparator is not used.\n-     *                      If doEncode is false lineSeparator is ignored.\n+     * Creates a Base64OutputStream such that all data written is either Base64-encoded or Base64-decoded to the\n+     * original provided OutputStream.\n+     * \n+     * @param out\n+     *            OutputStream to wrap.\n+     * @param doEncode\n+     *            true if we should encode all data written to us, false if we should decode.\n+     * @param lineLength\n+     *            If doEncode is true, each line of encoded data will contain lineLength characters (rounded down to\n+     *            nearest multiple of 4). If lineLength <=0, the encoded data is not divided into lines. If doEncode is\n+     *            false, lineLength is ignored.\n+     * @param lineSeparator\n+     *            If doEncode is true, each line of encoded data will be terminated with this byte sequence (e.g. \\r\\n).\n+     *            If lineLength <= 0, the lineSeparator is not used. If doEncode is false lineSeparator is ignored.\n      */\n     public Base64OutputStream(OutputStream out, boolean doEncode, int lineLength, byte[] lineSeparator) {\n         super(out);\n \n     /**\n      * Writes the specified <code>byte</code> to this output stream.\n+     * \n+     * @param i\n+     *            source byte\n+     * @throws IOException\n+     *             if an I/O error occurs.\n      */\n     public void write(int i) throws IOException {\n         singleByte[0] = (byte) i;\n     }\n \n     /**\n-     * Writes <code>len</code> bytes from the specified\n-     * <code>b</code> array starting at <code>offset</code> to\n-     * this output stream.\n-     *\n-     * @param b source byte array\n-     * @param offset where to start reading the bytes\n-     * @param len maximum number of bytes to write\n+     * Writes <code>len</code> bytes from the specified <code>b</code> array starting at <code>offset</code> to this\n+     * output stream.\n      * \n-     * @throws IOException if an I/O error occurs.\n-     * @throws NullPointerException if the byte array parameter is null\n-     * @throws IndexOutOfBoundsException if offset, len or buffer size are invalid\n+     * @param b\n+     *            source byte array\n+     * @param offset\n+     *            where to start reading the bytes\n+     * @param len\n+     *            maximum number of bytes to write\n+     * \n+     * @throws IOException\n+     *             if an I/O error occurs.\n+     * @throws NullPointerException\n+     *             if the byte array parameter is null\n+     * @throws IndexOutOfBoundsException\n+     *             if offset, len or buffer size are invalid\n      */\n     public void write(byte b[], int offset, int len) throws IOException {\n         if (b == null) {\n     }\n \n     /**\n-     * Flushes this output stream and forces any buffered output bytes\n-     * to be written out to the stream.  If propogate is true, the wrapped\n-     * stream will also be flushed.\n-     *\n-     * @param propogate boolean flag to indicate whether the wrapped\n-     *                  OutputStream should also be flushed.\n-     * @throws IOException if an I/O error occurs.\n+     * Flushes this output stream and forces any buffered output bytes to be written out to the stream. If propogate is\n+     * true, the wrapped stream will also be flushed.\n+     * \n+     * @param propogate\n+     *            boolean flag to indicate whether the wrapped OutputStream should also be flushed.\n+     * @throws IOException\n+     *             if an I/O error occurs.\n      */\n     private void flush(boolean propogate) throws IOException {\n         int avail = base64.avail();\n     }\n \n     /**\n-     * Flushes this output stream and forces any buffered output bytes\n-     * to be written out to the stream.\n-     *\n-     * @throws IOException if an I/O error occurs.\n+     * Flushes this output stream and forces any buffered output bytes to be written out to the stream.\n+     * \n+     * @throws IOException\n+     *             if an I/O error occurs.\n      */\n     public void flush() throws IOException {\n-        flush(true); \n+        flush(true);\n     }\n \n     /**\n-     * Closes this output stream and releases any system resources\n-     * associated with the stream.\n+     * Closes this output stream and releases any system resources associated with the stream.\n+     * \n+     * @throws IOException\n+     *             if an I/O error occurs.\n      */\n     public void close() throws IOException {\n         // Notify encoder of EOF (-1).\n--- /dev/null\n+++ b/src/java/org/apache/commons/codec/binary/StringUtils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.codec.binary;\n+\n+import java.io.UnsupportedEncodingException;\n+\n+import org.apache.commons.codec.CharEncoding;\n+\n+/**\n+ * Converts String to bytes using the encodings required by the Java specification. These encodings are specified in <a\n+ * href=\"http://java.sun.com/j2se/1.4.2/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n+ * \n+ * @see CharEncoding\n+ * @see <a href=\"http://java.sun.com/j2se/1.4.2/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n+ * @author <a href=\"mailto:ggregory@seagullsw.com\">Gary Gregory</a>\n+ * @version $Id: $\n+ * @since 1.4\n+ */\n+public class StringUtils {\n+\n+    /**\n+     * Encodes the given string into a sequence of bytes using the ISO-8859-1 charset, storing the result into a new\n+     * byte array.\n+     * \n+     * @param string\n+     *            the String to encode\n+     * @return encoded bytes\n+     * @throws IllegalStateException\n+     *             Thrown when the charset is missing, which should be never according the the Java specification.\n+     * @see <a href=\"http://java.sun.com/j2se/1.4.2/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n+     * @see #getSupportedBytes(String, String)\n+     */\n+    public static byte[] getBytesIso8859_1(String string) {\n+        return StringUtils.getSupportedBytes(string, CharEncoding.ISO_8859_1);\n+    }\n+\n+    /**\n+     * Encodes the given string into a sequence of bytes using the US-ASCII charset, storing the result into a new byte\n+     * array.\n+     * \n+     * @param string\n+     *            the String to encode\n+     * @return encoded bytes\n+     * @throws IllegalStateException\n+     *             Thrown when the charset is missing, which should be never according the the Java specification.\n+     * @see <a href=\"http://java.sun.com/j2se/1.4.2/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n+     * @see #getSupportedBytes(String, String)\n+     */\n+    public static byte[] getBytesUsAscii(String string) {\n+        return StringUtils.getSupportedBytes(string, CharEncoding.US_ASCII);\n+    }\n+\n+    /**\n+     * Encodes the given string into a sequence of bytes using the UTF-16 charset, storing the result into a new byte\n+     * array.\n+     * \n+     * @param string\n+     *            the String to encode\n+     * @return encoded bytes\n+     * @throws IllegalStateException\n+     *             Thrown when the charset is missing, which should be never according the the Java specification.\n+     * @see <a href=\"http://java.sun.com/j2se/1.4.2/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n+     * @see #getSupportedBytes(String, String)\n+     */\n+    public static byte[] getBytesUtf16(String string) {\n+        return StringUtils.getSupportedBytes(string, CharEncoding.UTF_16);\n+    }\n+\n+    /**\n+     * Encodes the given string into a sequence of bytes using the UTF-16BE charset, storing the result into a new byte\n+     * array.\n+     * \n+     * @param string\n+     *            the String to encode\n+     * @return encoded bytes\n+     * @throws IllegalStateException\n+     *             Thrown when the charset is missing, which should be never according the the Java specification.\n+     * @see <a href=\"http://java.sun.com/j2se/1.4.2/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n+     * @see #getSupportedBytes(String, String)\n+     */\n+    public static byte[] getBytesUtf16Be(String string) {\n+        return StringUtils.getSupportedBytes(string, CharEncoding.UTF_16BE);\n+    }\n+\n+    /**\n+     * Encodes the given string into a sequence of bytes using the UTF-16LE charset, storing the result into a new byte\n+     * array.\n+     * \n+     * @param string\n+     *            the String to encode\n+     * @return encoded bytes\n+     * @throws IllegalStateException\n+     *             Thrown when the charset is missing, which should be never according the the Java specification.\n+     * @see <a href=\"http://java.sun.com/j2se/1.4.2/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n+     * @see #getSupportedBytes(String, String)\n+     */\n+    public static byte[] getBytesUtf16Le(String string) {\n+        return StringUtils.getSupportedBytes(string, CharEncoding.UTF_16LE);\n+    }\n+\n+    /**\n+     * Encodes the given string into a sequence of bytes using the UTF-8 charset, storing the result into a new byte\n+     * array.\n+     * \n+     * @param string\n+     *            the String to encode\n+     * @return encoded bytes\n+     * @throws IllegalStateException\n+     *             Thrown when the charset is missing, which should be never according the the Java specification.\n+     * @see <a href=\"http://java.sun.com/j2se/1.4.2/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n+     * @see #getSupportedBytes(String, String)\n+     */\n+    public static byte[] getBytesUtf8(String string) {\n+        return StringUtils.getSupportedBytes(string, CharEncoding.UTF_8);\n+    }\n+\n+    /**\n+     * Encodes the given string into a sequence of bytes using the named charset, storing the result into a new byte\n+     * array.\n+     * <p>\n+     * This method catches {@link UnsupportedEncodingException} and rethrows it as {@link IllegalStateException}, which\n+     * should never happen for a required charset name. Use this method when the encoding is required to be in the JRE.\n+     * </p>\n+     * \n+     * @param string\n+     *            the String to encode\n+     * @param charsetName\n+     *            The name of a required {@link java.nio.charset.Charset}\n+     * @return encoded bytes\n+     * @throws IllegalStateException\n+     *             Thrown when a {@link UnsupportedEncodingException} is caught, which should never happen for a\n+     *             required charset name.\n+     * @see CharEncoding\n+     * @see String#getBytes(String)\n+     */\n+    public static byte[] getSupportedBytes(String string, String charsetName) {\n+        try {\n+            return string.getBytes(charsetName);\n+        } catch (UnsupportedEncodingException e) {\n+            throw StringUtils.newIllegalStateException(charsetName, e);\n+        }\n+    }\n+\n+    private static IllegalStateException newIllegalStateException(String charsetName, UnsupportedEncodingException e) {\n+        return new IllegalStateException(charsetName + \": \" + e);\n+    }\n+\n+    /**\n+     * Constructs a new <code>String</code> by decoding the specified array of bytes using the given charset.\n+     * <p>\n+     * This method catches {@link UnsupportedEncodingException} and re-throws it as {@link IllegalStateException}, which\n+     * should never happen for a required charset name. Use this method when the encoding is required to be in the JRE.\n+     * </p>\n+     * \n+     * @param bytes\n+     *            The bytes to be decoded into characters\n+     * @param charsetName\n+     *            The name of a required {@link java.nio.charset.Charset}\n+     * @return A new <code>String</code> decoded from the specified array of bytes using the given charset.\n+     * @throws IllegalStateException\n+     *             Thrown when a {@link UnsupportedEncodingException} is caught, which should never happen for a\n+     *             required charset name.\n+     * @see CharEncoding\n+     * @see String#String(byte[], String)\n+     */\n+    public static String newString(byte[] bytes, String charsetName) {\n+        try {\n+            return new String(bytes, charsetName);\n+        } catch (UnsupportedEncodingException e) {\n+            throw StringUtils.newIllegalStateException(charsetName, e);\n+        }\n+    }\n+\n+    /**\n+     * Constructs a new <code>String</code> by decoding the specified array of bytes using the ISO-8859-1 charset.\n+     * \n+     * @param bytes\n+     *            The bytes to be decoded into characters\n+     * @return A new <code>String</code> decoded from the specified array of bytes using the given charset.\n+     * @throws IllegalStateException\n+     *             Thrown when a {@link UnsupportedEncodingException} is caught, which should never happen since the\n+     *             charset is required.\n+     */\n+    public static String newStringIso8859_1(byte[] bytes) {\n+        return StringUtils.newString(bytes, CharEncoding.ISO_8859_1);\n+    }\n+\n+    /**\n+     * Constructs a new <code>String</code> by decoding the specified array of bytes using the US-ASCII charset.\n+     * \n+     * @param bytes\n+     *            The bytes to be decoded into characters\n+     * @return A new <code>String</code> decoded from the specified array of bytes using the given charset.\n+     * @throws IllegalStateException\n+     *             Thrown when a {@link UnsupportedEncodingException} is caught, which should never happen since the\n+     *             charset is required.\n+     */\n+    public static String newStringUsAscii(byte[] bytes) {\n+        return StringUtils.newString(bytes, CharEncoding.US_ASCII);\n+    }\n+\n+    /**\n+     * Constructs a new <code>String</code> by decoding the specified array of bytes using the UTF-16 charset.\n+     * \n+     * @param bytes\n+     *            The bytes to be decoded into characters\n+     * @return A new <code>String</code> decoded from the specified array of bytes using the given charset.\n+     * @throws IllegalStateException\n+     *             Thrown when a {@link UnsupportedEncodingException} is caught, which should never happen since the\n+     *             charset is required.\n+     */\n+    public static String newStringUtf16(byte[] bytes) {\n+        return StringUtils.newString(bytes, CharEncoding.UTF_16);\n+    }\n+\n+    /**\n+     * Constructs a new <code>String</code> by decoding the specified array of bytes using the UTF-16BE charset.\n+     * \n+     * @param bytes\n+     *            The bytes to be decoded into characters\n+     * @return A new <code>String</code> decoded from the specified array of bytes using the given charset.\n+     * @throws IllegalStateException\n+     *             Thrown when a {@link UnsupportedEncodingException} is caught, which should never happen since the\n+     *             charset is required.\n+     */\n+    public static String newStringUtf16Be(byte[] bytes) {\n+        return StringUtils.newString(bytes, CharEncoding.UTF_16BE);\n+    }\n+\n+    /**\n+     * Constructs a new <code>String</code> by decoding the specified array of bytes using the UTF-16LE charset.\n+     * \n+     * @param bytes\n+     *            The bytes to be decoded into characters\n+     * @return A new <code>String</code> decoded from the specified array of bytes using the given charset.\n+     * @throws IllegalStateException\n+     *             Thrown when a {@link UnsupportedEncodingException} is caught, which should never happen since the\n+     *             charset is required.\n+     */\n+    public static String newStringUtf16Le(byte[] bytes) {\n+        return StringUtils.newString(bytes, CharEncoding.UTF_16LE);\n+    }\n+\n+    /**\n+     * Constructs a new <code>String</code> by decoding the specified array of bytes using the UTF-8 charset.\n+     * \n+     * @param bytes\n+     *            The bytes to be decoded into characters\n+     * @return A new <code>String</code> decoded from the specified array of bytes using the given charset.\n+     * @throws IllegalStateException\n+     *             Thrown when a {@link UnsupportedEncodingException} is caught, which should never happen since the\n+     *             charset is required.\n+     */\n+    public static String newStringUtf8(byte[] bytes) {\n+        return StringUtils.newString(bytes, CharEncoding.UTF_8);\n+    }\n+\n+    private StringUtils() {\n+        // noop, cannot instantiate. Can always relax later.\n+    }\n+}\n--- a/src/java/org/apache/commons/codec/net/QuotedPrintableCodec.java\n+++ b/src/java/org/apache/commons/codec/net/QuotedPrintableCodec.java\n import org.apache.commons.codec.CharEncoding;\n import org.apache.commons.codec.StringDecoder;\n import org.apache.commons.codec.StringEncoder;\n-import org.apache.commons.codec.binary.StringBytesUtils;\n+import org.apache.commons.codec.binary.StringUtils;\n \n /**\n  * <p>\n         if (pString == null) {\n             return null;\n         }\n-        return new String(decode(StringBytesUtils.getBytesUsAscii(pString)), charset);\n+        return new String(decode(StringUtils.getBytesUsAscii(pString)), charset);\n     }\n \n     /**\n         if (pString == null) {\n             return null;\n         }\n-        return StringBytesUtils.newStringUsAscii(encode(pString.getBytes(charset)));\n+        return StringUtils.newStringUsAscii(encode(pString.getBytes(charset)));\n     }\n }\n--- a/src/java/org/apache/commons/codec/net/RFC1522Codec.java\n+++ b/src/java/org/apache/commons/codec/net/RFC1522Codec.java\n \n import org.apache.commons.codec.DecoderException;\n import org.apache.commons.codec.EncoderException;\n-import org.apache.commons.codec.binary.StringBytesUtils;\n+import org.apache.commons.codec.binary.StringUtils;\n \n /**\n  * <p>\n         buffer.append(getEncoding()); \n         buffer.append('?');\n         byte [] rawdata = doEncoding(text.getBytes(charset)); \n-        buffer.append(StringBytesUtils.newStringUsAscii(rawdata));\n+        buffer.append(StringUtils.newStringUsAscii(rawdata));\n         buffer.append(\"?=\"); \n         return buffer.toString();\n     }\n         }\n         from = to + 1;\n         to = text.indexOf(\"?\", from);\n-        byte[] data = StringBytesUtils.getBytesUsAscii(text.substring(from, to));\n+        byte[] data = StringUtils.getBytesUsAscii(text.substring(from, to));\n         data = doDecoding(data); \n         return new String(data, charset);\n     }\n--- a/src/java/org/apache/commons/codec/net/URLCodec.java\n+++ b/src/java/org/apache/commons/codec/net/URLCodec.java\n import org.apache.commons.codec.CharEncoding;\n import org.apache.commons.codec.StringDecoder;\n import org.apache.commons.codec.StringEncoder;\n-import org.apache.commons.codec.binary.StringBytesUtils;\n+import org.apache.commons.codec.binary.StringUtils;\n \n /**\n  * <p>Implements the 'www-form-urlencoded' encoding scheme, \n         if (pString == null) {\n             return null;\n         }\n-        return StringBytesUtils.newStringUsAscii(encode(pString.getBytes(charset)));\n+        return StringUtils.newStringUsAscii(encode(pString.getBytes(charset)));\n     }\n \n     /**\n         if (pString == null) {\n             return null;\n         }\n-        return new String(decode(StringBytesUtils.getBytesUsAscii(pString)), charset);\n+        return new String(decode(StringUtils.getBytesUsAscii(pString)), charset);\n     }\n \n     /**\n--- a/src/test/org/apache/commons/codec/binary/Base64InputStreamTest.java\n+++ b/src/test/org/apache/commons/codec/binary/Base64InputStreamTest.java\n      */\n     public void testBase64InputStreamByChunk() throws Exception {\n         // Hello World test.\n-        byte[] encoded = StringBytesUtils.getBytesUtf8(\"SGVsbG8gV29ybGQ=\\r\\n\");\n-        byte[] decoded = StringBytesUtils.getBytesUtf8(STRING_FIXTURE);\n+        byte[] encoded = StringUtils.getBytesUtf8(\"SGVsbG8gV29ybGQ=\\r\\n\");\n+        byte[] decoded = StringUtils.getBytesUtf8(STRING_FIXTURE);\n         testByChunk(encoded, decoded, 76, CRLF);\n \n         // Single Byte test.\n-        encoded = StringBytesUtils.getBytesUtf8(\"AA==\\r\\n\");\n+        encoded = StringUtils.getBytesUtf8(\"AA==\\r\\n\");\n         decoded = new byte[]{(byte) 0};\n         testByChunk(encoded, decoded, 76, CRLF);\n \n         // OpenSSL interop test.\n-        encoded = StringBytesUtils.getBytesUtf8(Base64TestData.ENCODED_64_CHARS_PER_LINE);\n+        encoded = StringUtils.getBytesUtf8(Base64TestData.ENCODED_64_CHARS_PER_LINE);\n         decoded = Base64TestData.DECODED;\n         testByChunk(encoded, decoded, 64, LF);\n \n         // Single Line test.\n         String singleLine = Base64TestData.ENCODED_64_CHARS_PER_LINE.replaceAll(\"\\n\", \"\");\n-        encoded = StringBytesUtils.getBytesUtf8(singleLine);\n+        encoded = StringUtils.getBytesUtf8(singleLine);\n         decoded = Base64TestData.DECODED;\n         testByChunk(encoded, decoded, 0, LF);\n \n      */\n     public void testBase64InputStreamByteByByte() throws Exception {\n         // Hello World test.\n-        byte[] encoded = StringBytesUtils.getBytesUtf8(\"SGVsbG8gV29ybGQ=\\r\\n\");\n-        byte[] decoded = StringBytesUtils.getBytesUtf8(STRING_FIXTURE);\n+        byte[] encoded = StringUtils.getBytesUtf8(\"SGVsbG8gV29ybGQ=\\r\\n\");\n+        byte[] decoded = StringUtils.getBytesUtf8(STRING_FIXTURE);\n         testByteByByte(encoded, decoded, 76, CRLF);\n \n         // Single Byte test.\n-        encoded = StringBytesUtils.getBytesUtf8(\"AA==\\r\\n\");\n+        encoded = StringUtils.getBytesUtf8(\"AA==\\r\\n\");\n         decoded = new byte[]{(byte) 0};\n         testByteByByte(encoded, decoded, 76, CRLF);\n \n         // OpenSSL interop test.\n-        encoded = StringBytesUtils.getBytesUtf8(Base64TestData.ENCODED_64_CHARS_PER_LINE);\n+        encoded = StringUtils.getBytesUtf8(Base64TestData.ENCODED_64_CHARS_PER_LINE);\n         decoded = Base64TestData.DECODED;\n         testByteByByte(encoded, decoded, 64, LF);\n \n         // Single Line test.\n         String singleLine = Base64TestData.ENCODED_64_CHARS_PER_LINE.replaceAll(\"\\n\", \"\");\n-        encoded = StringBytesUtils.getBytesUtf8(singleLine);\n+        encoded = StringUtils.getBytesUtf8(singleLine);\n         decoded = Base64TestData.DECODED;\n         testByteByByte(encoded, decoded, 0, LF);\n \n      * @throws Exception\n      */\n     public void testMarkSupported() throws Exception {\n-        byte[] decoded = StringBytesUtils.getBytesUtf8(STRING_FIXTURE);\n+        byte[] decoded = StringUtils.getBytesUtf8(STRING_FIXTURE);\n         ByteArrayInputStream bin = new ByteArrayInputStream(decoded);\n         Base64InputStream in = new Base64InputStream(bin, true, 4, new byte[]{0, 0, 0});\n         // Always returns false for now.\n      * @throws Exception\n      */\n     public void testRead0() throws Exception {\n-        byte[] decoded = StringBytesUtils.getBytesUtf8(STRING_FIXTURE);\n+        byte[] decoded = StringUtils.getBytesUtf8(STRING_FIXTURE);\n         byte[] buf = new byte[1024];\n         int bytesRead = 0;\n         ByteArrayInputStream bin = new ByteArrayInputStream(decoded);\n      *             for some failure scenarios.\n      */\n     public void testReadNull() throws Exception {\n-        byte[] decoded = StringBytesUtils.getBytesUtf8(STRING_FIXTURE);\n+        byte[] decoded = StringUtils.getBytesUtf8(STRING_FIXTURE);\n         ByteArrayInputStream bin = new ByteArrayInputStream(decoded);\n         Base64InputStream in = new Base64InputStream(bin, true, 4, new byte[]{0, 0, 0});\n         try {\n      * @throws Exception\n      */\n     public void testReadOutOfBounds() throws Exception {\n-        byte[] decoded = StringBytesUtils.getBytesUtf8(STRING_FIXTURE);\n+        byte[] decoded = StringUtils.getBytesUtf8(STRING_FIXTURE);\n         byte[] buf = new byte[1024];\n         ByteArrayInputStream bin = new ByteArrayInputStream(decoded);\n         Base64InputStream in = new Base64InputStream(bin, true, 4, new byte[]{0, 0, 0});\n--- a/src/test/org/apache/commons/codec/binary/Base64OutputStreamTest.java\n+++ b/src/test/org/apache/commons/codec/binary/Base64OutputStreamTest.java\n      */\n     public void testBase64OutputStreamByChunk() throws Exception {\n         // Hello World test.\n-        byte[] encoded = StringBytesUtils.getBytesUtf8(\"SGVsbG8gV29ybGQ=\\r\\n\");\n-        byte[] decoded = StringBytesUtils.getBytesUtf8(STRING_FIXTURE);\n+        byte[] encoded = StringUtils.getBytesUtf8(\"SGVsbG8gV29ybGQ=\\r\\n\");\n+        byte[] decoded = StringUtils.getBytesUtf8(STRING_FIXTURE);\n         testByChunk(encoded, decoded, 76, CRLF);\n \n         // Single Byte test.\n-        encoded = StringBytesUtils.getBytesUtf8(\"AA==\\r\\n\");\n+        encoded = StringUtils.getBytesUtf8(\"AA==\\r\\n\");\n         decoded = new byte[]{(byte) 0};\n         testByChunk(encoded, decoded, 76, CRLF);\n \n         // OpenSSL interop test.\n-        encoded = StringBytesUtils.getBytesUtf8(Base64TestData.ENCODED_64_CHARS_PER_LINE);\n+        encoded = StringUtils.getBytesUtf8(Base64TestData.ENCODED_64_CHARS_PER_LINE);\n         decoded = Base64TestData.DECODED;\n         testByChunk(encoded, decoded, 64, LF);\n \n         // Single Line test.\n         String singleLine = Base64TestData.ENCODED_64_CHARS_PER_LINE.replaceAll(\"\\n\", \"\");\n-        encoded = StringBytesUtils.getBytesUtf8(singleLine);\n+        encoded = StringUtils.getBytesUtf8(singleLine);\n         decoded = Base64TestData.DECODED;\n         testByChunk(encoded, decoded, 0, LF);\n \n      */\n     public void testBase64OutputStreamByteByByte() throws Exception {\n         // Hello World test.\n-        byte[] encoded = StringBytesUtils.getBytesUtf8(\"SGVsbG8gV29ybGQ=\\r\\n\");\n-        byte[] decoded = StringBytesUtils.getBytesUtf8(STRING_FIXTURE);\n+        byte[] encoded = StringUtils.getBytesUtf8(\"SGVsbG8gV29ybGQ=\\r\\n\");\n+        byte[] decoded = StringUtils.getBytesUtf8(STRING_FIXTURE);\n         testByteByByte(encoded, decoded, 76, CRLF);\n \n         // Single Byte test.\n-        encoded = StringBytesUtils.getBytesUtf8(\"AA==\\r\\n\");\n+        encoded = StringUtils.getBytesUtf8(\"AA==\\r\\n\");\n         decoded = new byte[]{(byte) 0};\n         testByteByByte(encoded, decoded, 76, CRLF);\n \n         // OpenSSL interop test.\n-        encoded = StringBytesUtils.getBytesUtf8(Base64TestData.ENCODED_64_CHARS_PER_LINE);\n+        encoded = StringUtils.getBytesUtf8(Base64TestData.ENCODED_64_CHARS_PER_LINE);\n         decoded = Base64TestData.DECODED;\n         testByteByByte(encoded, decoded, 64, LF);\n \n         // Single Line test.\n         String singleLine = Base64TestData.ENCODED_64_CHARS_PER_LINE.replaceAll(\"\\n\", \"\");\n-        encoded = StringBytesUtils.getBytesUtf8(singleLine);\n+        encoded = StringUtils.getBytesUtf8(singleLine);\n         decoded = Base64TestData.DECODED;\n         testByteByByte(encoded, decoded, 0, LF);\n \n--- a/src/test/org/apache/commons/codec/binary/Base64Test.java\n+++ b/src/test/org/apache/commons/codec/binary/Base64Test.java\n \n package org.apache.commons.codec.binary;\n \n-import java.io.UnsupportedEncodingException;\n import java.math.BigInteger;\n import java.util.Arrays;\n import java.util.Random;\n /**\n  * Test cases for Base64 class.\n  * \n+ * @see <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045</a>\n  * @author Apache Software Foundation\n  * @version $Id$\n  */\n \n     /**\n      * Tests Base64.encodeBase64().\n-     * \n-     * @throws Exception\n-     */\n-    public void testChunkedEncodeMultipleOf76() throws Exception {\n+     */\n+    public void testChunkedEncodeMultipleOf76() {\n         byte[] expectedEncode = Base64.encodeBase64(Base64TestData.DECODED, true);\n         // convert to \"\\r\\n\" so we're equal to the old openssl encoding test stored\n         // in Base64TestData.ENCODED_76_CHARS_PER_LINE:\n         String actualResult = Base64TestData.ENCODED_76_CHARS_PER_LINE.replaceAll(\"\\n\", \"\\r\\n\");\n-        byte[] actualEncode = actualResult.getBytes(\"UTF-8\");\n+        byte[] actualEncode = StringUtils.getBytesUtf8(actualResult);\n         assertTrue(\"chunkedEncodeMultipleOf76\", Arrays.equals(expectedEncode, actualEncode));\n     }\n \n             // Expected\n         }\n         base64 = new Base64(64, new byte[]{' ', '$', '\\n', '\\r', '\\t'}); // OK\n+    }\n+\n+    public void testConstructor_Int_ByteArray_Boolean() {\n+        Base64 base64 = new Base64(65, new byte[]{'\\t'}, false);\n+        byte[] encoded = base64.encode(Base64TestData.DECODED);\n+        String expectedResult = Base64TestData.ENCODED_64_CHARS_PER_LINE;\n+        expectedResult = expectedResult.replace('\\n', '\\t');\n+        String result = StringUtils.newStringUtf8(encoded);\n+        assertEquals(\"new Base64(65, \\\\t, false)\", expectedResult, result);\n+    }\n+\n+    public void testConstructor_Int_ByteArray_Boolean_UrlSafe() {\n+        // url-safe variation\n+        Base64 base64 = new Base64(64, new byte[]{'\\t'}, true);\n+        byte[] encoded = base64.encode(Base64TestData.DECODED);\n+        String expectedResult = Base64TestData.ENCODED_64_CHARS_PER_LINE;\n+        expectedResult = expectedResult.replaceAll(\"=\", \"\"); // url-safe has no == padding.\n+        expectedResult = expectedResult.replace('\\n', '\\t');\n+        expectedResult = expectedResult.replace('+', '-');\n+        expectedResult = expectedResult.replace('/', '_');\n+        String result = StringUtils.newStringUtf8(encoded);\n+        assertEquals(\"new Base64(64, \\\\t, true)\", result, expectedResult);\n     }\n \n     /**\n     public void testObjectDecodeWithValidParameter() throws Exception {\n \n         String original = \"Hello World!\";\n-        byte[] bArray = Base64.encodeBase64(original.getBytes());\n-        Object o = bArray;\n+        Object o = Base64.encodeBase64(original.getBytes());\n \n         Base64 b64 = new Base64();\n         Object oDecoded = b64.decode(o);\n     public void testObjectEncodeWithValidParameter() throws Exception {\n \n         String original = \"Hello World!\";\n-        byte[] origBytes = original.getBytes();\n-        Object origObj = origBytes;\n+        Object origObj = original.getBytes();\n \n         Base64 b64 = new Base64();\n         Object oEncoded = b64.encode(origObj);\n      * \n      * @throws DecoderException\n      *             if Hex.decode() fails - a serious problem since Hex comes from our own commons-codec!\n-     * @throws UnsupportedEncodingException\n-     *             Thrown if \"UTF-8\" character set is not available, not possible according to Java documentation.\n      */\n     public void testUUID() throws DecoderException {\n         // The 4 UUID's below contains mixtures of + and / to help us test the\n         ids[3] = Hex.decodeHex(\"ff7f8fc01cdb471a8c8b5a9306183fe8\".toCharArray());\n \n         byte[][] standard = new byte[4][];\n-        standard[0] = StringBytesUtils.getBytesUtf8(\"lO2NAxnkSTOZVg+2dATTcA==\");\n-        standard[1] = StringBytesUtils.getBytesUtf8(\"K/fMJwH+Q5e0nr7tWsxwkA==\");\n-        standard[2] = StringBytesUtils.getBytesUtf8(\"ZL4VS2/6QCWNGgEojnwxyg==\");\n-        standard[3] = StringBytesUtils.getBytesUtf8(\"/3+PwBzbRxqMi1qTBhg/6A==\");\n+        standard[0] = StringUtils.getBytesUtf8(\"lO2NAxnkSTOZVg+2dATTcA==\");\n+        standard[1] = StringUtils.getBytesUtf8(\"K/fMJwH+Q5e0nr7tWsxwkA==\");\n+        standard[2] = StringUtils.getBytesUtf8(\"ZL4VS2/6QCWNGgEojnwxyg==\");\n+        standard[3] = StringUtils.getBytesUtf8(\"/3+PwBzbRxqMi1qTBhg/6A==\");\n \n         byte[][] urlSafe1 = new byte[4][];\n         // regular padding (two '==' signs).\n-        urlSafe1[0] = StringBytesUtils.getBytesUtf8(\"lO2NAxnkSTOZVg-2dATTcA==\");\n-        urlSafe1[1] = StringBytesUtils.getBytesUtf8(\"K_fMJwH-Q5e0nr7tWsxwkA==\");\n-        urlSafe1[2] = StringBytesUtils.getBytesUtf8(\"ZL4VS2_6QCWNGgEojnwxyg==\");\n-        urlSafe1[3] = StringBytesUtils.getBytesUtf8(\"_3-PwBzbRxqMi1qTBhg_6A==\");\n+        urlSafe1[0] = StringUtils.getBytesUtf8(\"lO2NAxnkSTOZVg-2dATTcA==\");\n+        urlSafe1[1] = StringUtils.getBytesUtf8(\"K_fMJwH-Q5e0nr7tWsxwkA==\");\n+        urlSafe1[2] = StringUtils.getBytesUtf8(\"ZL4VS2_6QCWNGgEojnwxyg==\");\n+        urlSafe1[3] = StringUtils.getBytesUtf8(\"_3-PwBzbRxqMi1qTBhg_6A==\");\n \n         byte[][] urlSafe2 = new byte[4][];\n         // single padding (only one '=' sign).\n-        urlSafe2[0] = StringBytesUtils.getBytesUtf8(\"lO2NAxnkSTOZVg-2dATTcA=\");\n-        urlSafe2[1] = StringBytesUtils.getBytesUtf8(\"K_fMJwH-Q5e0nr7tWsxwkA=\");\n-        urlSafe2[2] = StringBytesUtils.getBytesUtf8(\"ZL4VS2_6QCWNGgEojnwxyg=\");\n-        urlSafe2[3] = StringBytesUtils.getBytesUtf8(\"_3-PwBzbRxqMi1qTBhg_6A=\");\n+        urlSafe2[0] = StringUtils.getBytesUtf8(\"lO2NAxnkSTOZVg-2dATTcA=\");\n+        urlSafe2[1] = StringUtils.getBytesUtf8(\"K_fMJwH-Q5e0nr7tWsxwkA=\");\n+        urlSafe2[2] = StringUtils.getBytesUtf8(\"ZL4VS2_6QCWNGgEojnwxyg=\");\n+        urlSafe2[3] = StringUtils.getBytesUtf8(\"_3-PwBzbRxqMi1qTBhg_6A=\");\n \n         byte[][] urlSafe3 = new byte[4][];\n         // no padding (no '=' signs).\n-        urlSafe3[0] = StringBytesUtils.getBytesUtf8(\"lO2NAxnkSTOZVg-2dATTcA\");\n-        urlSafe3[1] = StringBytesUtils.getBytesUtf8(\"K_fMJwH-Q5e0nr7tWsxwkA\");\n-        urlSafe3[2] = StringBytesUtils.getBytesUtf8(\"ZL4VS2_6QCWNGgEojnwxyg\");\n-        urlSafe3[3] = StringBytesUtils.getBytesUtf8(\"_3-PwBzbRxqMi1qTBhg_6A\");\n+        urlSafe3[0] = StringUtils.getBytesUtf8(\"lO2NAxnkSTOZVg-2dATTcA\");\n+        urlSafe3[1] = StringUtils.getBytesUtf8(\"K_fMJwH-Q5e0nr7tWsxwkA\");\n+        urlSafe3[2] = StringUtils.getBytesUtf8(\"ZL4VS2_6QCWNGgEojnwxyg\");\n+        urlSafe3[3] = StringUtils.getBytesUtf8(\"_3-PwBzbRxqMi1qTBhg_6A\");\n \n         for (int i = 0; i < 4; i++) {\n             byte[] encodedStandard = Base64.encodeBase64(ids[i]);\n             // ever need to delve closely into this stuff.\n             if (false) {\n                 System.out.println(\"reference: [\" + new String(Hex.encodeHex(ids[i])) + \"]\");\n-                System.out.println(\"standard:  [\"\n-                    + new String(Hex.encodeHex(decodedStandard))\n-                    + \"] From: [\"\n-                    + StringBytesUtils.newStringUtf8(standard[i])\n-                    + \"]\");\n-                System.out.println(\"safe1:     [\"\n-                    + new String(Hex.encodeHex(decodedUrlSafe1))\n-                    + \"] From: [\"\n-                    + StringBytesUtils.newStringUtf8(urlSafe1[i])\n-                    + \"]\");\n-                System.out.println(\"safe2:     [\"\n-                    + new String(Hex.encodeHex(decodedUrlSafe2))\n-                    + \"] From: [\"\n-                    + StringBytesUtils.newStringUtf8(urlSafe2[i])\n-                    + \"]\");\n-                System.out.println(\"safe3:     [\"\n-                    + new String(Hex.encodeHex(decodedUrlSafe3))\n-                    + \"] From: [\"\n-                    + StringBytesUtils.newStringUtf8(urlSafe3[i])\n-                    + \"]\");\n+                System.out.println(\"standard:  [\" +\n+                    new String(Hex.encodeHex(decodedStandard)) +\n+                    \"] From: [\" +\n+                    StringUtils.newStringUtf8(standard[i]) +\n+                    \"]\");\n+                System.out.println(\"safe1:     [\" +\n+                    new String(Hex.encodeHex(decodedUrlSafe1)) +\n+                    \"] From: [\" +\n+                    StringUtils.newStringUtf8(urlSafe1[i]) +\n+                    \"]\");\n+                System.out.println(\"safe2:     [\" +\n+                    new String(Hex.encodeHex(decodedUrlSafe2)) +\n+                    \"] From: [\" +\n+                    StringUtils.newStringUtf8(urlSafe2[i]) +\n+                    \"]\");\n+                System.out.println(\"safe3:     [\" +\n+                    new String(Hex.encodeHex(decodedUrlSafe3)) +\n+                    \"] From: [\" +\n+                    StringUtils.newStringUtf8(urlSafe3[i]) +\n+                    \"]\");\n             }\n \n             assertTrue(\"standard encode uuid\", Arrays.equals(encodedStandard, standard[i]));\n--- a/src/test/org/apache/commons/codec/binary/Base64TestData.java\n+++ b/src/test/org/apache/commons/codec/binary/Base64TestData.java\n  * This random data was encoded by OpenSSL. Java had nothing to do with it. This data helps us test interop between\n  * Commons-Codec and OpenSSL. Notice that OpenSSL creates 64 character lines instead of the 76 of Commons-Codec.\n  * \n+ * @see <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045</a>\n  * @author Apache Software Foundation\n  * @version $Id $\n  * @since 1.4\n--- /dev/null\n+++ b/src/test/org/apache/commons/codec/binary/StringUtilsTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.codec.binary;\n+\n+import java.io.UnsupportedEncodingException;\n+import java.util.Arrays;\n+\n+import junit.framework.Assert;\n+import junit.framework.TestCase;\n+\n+/**\n+ * @author <a href=\"mailto:ggregory@seagullsw.com\">Gary Gregory</a>\n+ * @version $Id: $\n+ */\n+public class StringUtilsTest extends TestCase {\n+\n+    private static byte[] BYTES_FIXTURE;\n+\n+    private static final String STRING_FIXTURE = \"ABC\";\n+    {\n+        try {\n+            BYTES_FIXTURE = \"abc\".getBytes(\"US-ASCII\");\n+        } catch (UnsupportedEncodingException e) {\n+            throw new IllegalArgumentException(e.toString());\n+        }\n+    }\n+\n+    public void testGetBytesIso8859_1() throws UnsupportedEncodingException {\n+        String charsetName = \"ISO-8859-1\";\n+        testGetSupportedBytes(charsetName);\n+        byte[] expected = STRING_FIXTURE.getBytes(charsetName);\n+        byte[] actual = StringUtils.getBytesIso8859_1(STRING_FIXTURE);\n+        Assert.assertTrue(Arrays.equals(expected, actual));\n+    }\n+\n+    public void testGetBytesUsAscii() throws UnsupportedEncodingException {\n+        String charsetName = \"US-ASCII\";\n+        testGetSupportedBytes(charsetName);\n+        byte[] expected = STRING_FIXTURE.getBytes(charsetName);\n+        byte[] actual = StringUtils.getBytesUsAscii(STRING_FIXTURE);\n+        Assert.assertTrue(Arrays.equals(expected, actual));\n+    }\n+\n+    public void testGetBytesUtf16() throws UnsupportedEncodingException {\n+        String charsetName = \"UTF-16\";\n+        testGetSupportedBytes(charsetName);\n+        byte[] expected = STRING_FIXTURE.getBytes(charsetName);\n+        byte[] actual = StringUtils.getBytesUtf16(STRING_FIXTURE);\n+        Assert.assertTrue(Arrays.equals(expected, actual));\n+    }\n+\n+    public void testGetBytesUtf16Be() throws UnsupportedEncodingException {\n+        String charsetName = \"UTF-16BE\";\n+        testGetSupportedBytes(charsetName);\n+        byte[] expected = STRING_FIXTURE.getBytes(charsetName);\n+        byte[] actual = StringUtils.getBytesUtf16Be(STRING_FIXTURE);\n+        Assert.assertTrue(Arrays.equals(expected, actual));\n+    }\n+\n+    public void testGetBytesUtf16Le() throws UnsupportedEncodingException {\n+        String charsetName = \"UTF-16LE\";\n+        testGetSupportedBytes(charsetName);\n+        byte[] expected = STRING_FIXTURE.getBytes(charsetName);\n+        byte[] actual = StringUtils.getBytesUtf16Le(STRING_FIXTURE);\n+        Assert.assertTrue(Arrays.equals(expected, actual));\n+    }\n+\n+    public void testGetBytesUtf8() throws UnsupportedEncodingException {\n+        String charsetName = \"UTF-8\";\n+        testGetSupportedBytes(charsetName);\n+        byte[] expected = STRING_FIXTURE.getBytes(charsetName);\n+        byte[] actual = StringUtils.getBytesUtf8(STRING_FIXTURE);\n+        Assert.assertTrue(Arrays.equals(expected, actual));\n+    }\n+\n+    private void testGetSupportedBytes(String charsetName) throws UnsupportedEncodingException {\n+        byte[] expected = STRING_FIXTURE.getBytes(charsetName);\n+        byte[] actual = StringUtils.getSupportedBytes(STRING_FIXTURE, charsetName);\n+        Assert.assertTrue(Arrays.equals(expected, actual));\n+    }\n+\n+    public void testGetSupportedBytesBadEnc() {\n+        try {\n+            StringUtils.getSupportedBytes(STRING_FIXTURE, \"UNKNOWN\");\n+            Assert.fail(\"Expected \" + IllegalStateException.class.getName());\n+        } catch (IllegalStateException e) {\n+            // Expected\n+        }\n+    }\n+\n+    private void testNewString(String charsetName) throws UnsupportedEncodingException {\n+        String expected = new String(BYTES_FIXTURE, charsetName);\n+        String actual = StringUtils.newString(BYTES_FIXTURE, charsetName);\n+        Assert.assertEquals(expected, actual);\n+    }\n+\n+    public void testNewStringBadEnc() {\n+        try {\n+            StringUtils.newString(BYTES_FIXTURE, \"UNKNOWN\");\n+            Assert.fail(\"Expected \" + IllegalStateException.class.getName());\n+        } catch (IllegalStateException e) {\n+            // Expected\n+        }\n+    }\n+\n+    public void testNewStringIso8859_1() throws UnsupportedEncodingException {\n+        String charsetName = \"ISO-8859-1\";\n+        testNewString(charsetName);\n+        String expected = new String(BYTES_FIXTURE, charsetName);\n+        String actual = StringUtils.newStringIso8859_1(BYTES_FIXTURE);\n+        Assert.assertEquals(expected, actual);\n+    }\n+\n+    public void testNewStringUsAscii() throws UnsupportedEncodingException {\n+        String charsetName = \"US-ASCII\";\n+        testNewString(charsetName);\n+        String expected = new String(BYTES_FIXTURE, charsetName);\n+        String actual = StringUtils.newStringUsAscii(BYTES_FIXTURE);\n+        Assert.assertEquals(expected, actual);\n+    }\n+\n+    public void testNewStringUtf16() throws UnsupportedEncodingException {\n+        String charsetName = \"UTF-16\";\n+        testNewString(charsetName);\n+        String expected = new String(BYTES_FIXTURE, charsetName);\n+        String actual = StringUtils.newStringUtf16(BYTES_FIXTURE);\n+        Assert.assertEquals(expected, actual);\n+    }\n+\n+    public void testNewStringUtf16Be() throws UnsupportedEncodingException {\n+        String charsetName = \"UTF-16BE\";\n+        testNewString(charsetName);\n+        String expected = new String(BYTES_FIXTURE, charsetName);\n+        String actual = StringUtils.newStringUtf16Be(BYTES_FIXTURE);\n+        Assert.assertEquals(expected, actual);\n+    }\n+\n+    public void testNewStringUtf16Le() throws UnsupportedEncodingException {\n+        String charsetName = \"UTF-16LE\";\n+        testNewString(charsetName);\n+        String expected = new String(BYTES_FIXTURE, charsetName);\n+        String actual = StringUtils.newStringUtf16Le(BYTES_FIXTURE);\n+        Assert.assertEquals(expected, actual);\n+    }\n+\n+    public void testNewStringUtf8() throws UnsupportedEncodingException {\n+        String charsetName = \"UTF-8\";\n+        testNewString(charsetName);\n+        String expected = new String(BYTES_FIXTURE, charsetName);\n+        String actual = StringUtils.newStringUtf8(BYTES_FIXTURE);\n+        Assert.assertEquals(expected, actual);\n+    }\n+\n+}", "timestamp": 1248738118, "metainfo": ""}