{"sha": "0309db6bdcc133c4f6ad871c28fbe468df8f6c55", "log": "Refactor Base64 to use new super-class Minimal fix to allow Base64OutputStream to compile (refactor to follow)  ", "commit": "\n--- a/src/java/org/apache/commons/codec/binary/Base64.java\n+++ b/src/java/org/apache/commons/codec/binary/Base64.java\n package org.apache.commons.codec.binary;\n \n import java.math.BigInteger;\n-\n-import org.apache.commons.codec.BinaryDecoder;\n-import org.apache.commons.codec.BinaryEncoder;\n-import org.apache.commons.codec.DecoderException;\n-import org.apache.commons.codec.EncoderException;\n \n /**\n  * Provides Base64 encoding and decoding as defined by RFC 2045.\n  * @see <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045</a>\n  * @author Apache Software Foundation\n  * @since 1.0\n- * @version $Id$\n+ * @version $Revision$\n  */\n-public class Base64 implements BinaryEncoder, BinaryDecoder {\n-    private static final int DEFAULT_BUFFER_RESIZE_FACTOR = 2;\n-\n-    private static final int DEFAULT_BUFFER_SIZE = 8192;\n-\n-    /**\n-     *  MIME chunk size per RFC 2045 section 6.8.\n-     * \n-     * <p>\n-     * The {@value} character limit does not count the trailing CRLF, but counts all other characters, including any\n-     * equal signs.\n-     * </p>\n-     * \n-     * @see <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045 section 6.8</a>\n-     */\n-    public static final int MIME_CHUNK_SIZE = 76;\n-\n-    /**\n-     * PEM chunk size per RFC 1421 section 4.3.2.4.\n-     * \n-     * <p>\n-     * The {@value} character limit does not count the trailing CRLF, but counts all other characters, including any\n-     * equal signs.\n-     * </p>\n-     * \n-     * @see <a href=\"http://tools.ietf.org/html/rfc1421\">RFC 1421 section 4.3.2.4</a>\n-     */\n-    public static final int PEM_CHUNK_SIZE = 64;\n+public class Base64 extends BaseNCodec {\n+\n+    /**\n+     * BASE32 characters are 6 bits in length. \n+     * They are formed by taking a block of 3 octets to form a 24-bit string, \n+     * which is converted into 4 BASE64 characters.\n+     */\n+    private static final int BITS_PER_ENCODED_BYTE = 6;\n+    private static final int BYTES_PER_UNENCODED_BLOCK = 3;\n+    private static final int BYTES_PER_ENCODED_BLOCK = 4;\n \n     /**\n      * Chunk separator per RFC 2045 section 2.1.\n     };\n \n     /**\n-     * Byte used to pad output.\n-     */\n-    private static final byte PAD = '=';\n-\n-    /**\n      * This array is a lookup table that translates Unicode characters drawn from the \"Base64 Alphabet\" (as specified in\n      * Table 1 of RFC 2045) into their 6-bit positive integer equivalents. Characters that are not in the Base64\n      * alphabet but fall within the bounds of the array are translated to -1.\n             35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51\n     };\n \n+    /**\n+     * Base64 uses 6-bit fields. \n+     */\n     /** Mask used to extract 6 bits, used when encoding */\n     private static final int MASK_6BITS = 0x3f;\n-\n-    /** Mask used to extract 8 bits, used in decoding base64 bytes */\n-    private static final int MASK_8BITS = 0xff;\n \n     // The static final fields above are used for the original static byte[] methods on Base64.\n     // The private member fields below are used with the new streaming approach, which requires\n      */\n     private final byte[] encodeTable;\n \n-    /**\n-     * Line length for encoding. Not used when decoding. A value of zero or less implies no chunking of the base64\n-     * encoded data.\n-     */\n-    private final int lineLength;\n+    // Only one decode table currently; keep for consistency with Base32 code\n+    private final byte[] decodeTable = DECODE_TABLE;\n \n     /**\n      * Line separator for encoding. Not used when decoding. Only used if lineLength > 0.\n     private final int encodeSize;\n \n     /**\n-     * Buffer for streaming.\n-     */\n-    private byte[] buffer;\n-\n-    /**\n-     * Position where next character should be written in the buffer.\n-     */\n-    private int pos;\n-\n-    /**\n-     * Position where next character should be read from the buffer.\n-     */\n-    private int readPos;\n-\n-    /**\n-     * Variable tracks how many characters have been written to the current line. Only used when encoding. We use it to\n-     * make sure each encoded line never goes beyond lineLength (if lineLength > 0).\n-     */\n-    private int currentLinePos;\n-\n-    /**\n-     * Writes to the buffer only occur after every 3 reads when encoding, an every 4 reads when decoding. This variable\n-     * helps track that.\n-     */\n-    private int modulus;\n-\n-    /**\n-     * Boolean flag to indicate the EOF has been reached. Once EOF has been reached, this Base64 object becomes useless,\n-     * and must be thrown away.\n-     */\n-    private boolean eof;\n-\n-    /**\n-     * Place holder for the 3 bytes we're dealing with for our base64 logic. Bitwise operations store and extract the\n-     * base64 encoding or decoding from this variable.\n-     */\n-    private int x;\n+     * Place holder for the bytes we're dealing with for our based logic. \n+     * Bitwise operations store and extract the encoding or decoding from this variable.\n+     */\n+    private int bitWorkArea;\n \n     /**\n      * Creates a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.\n      * @since 1.4\n      */\n     public Base64(int lineLength, byte[] lineSeparator, boolean urlSafe) {\n-        if (lineSeparator == null) {\n-            lineLength = 0;  // disable chunk-separating\n-            lineSeparator = CHUNK_SEPARATOR;  // this just gets ignored\n-        }\n-        this.lineLength = lineLength > 0 ? (lineLength / 4) * 4 : 0;\n-        this.lineSeparator = new byte[lineSeparator.length];\n-        System.arraycopy(lineSeparator, 0, this.lineSeparator, 0, lineSeparator.length);\n-        if (lineLength > 0) {\n-            this.encodeSize = 4 + lineSeparator.length;\n+        super(BYTES_PER_UNENCODED_BLOCK, BYTES_PER_ENCODED_BLOCK, \n+                lineLength,\n+                lineSeparator == null ? 0 : lineSeparator.length);\n+        // TODO could be simplified if there is no requirement to reject invalid line sep when length <=0\n+        // @see test case Base64Test.testConstructors() \n+        if (lineSeparator != null) {\n+            if (containsAlphabetOrPad(lineSeparator)) {\n+                String sep = StringUtils.newStringUtf8(lineSeparator);\n+                throw new IllegalArgumentException(\"lineSeparator must not contain base64 characters: [\" + sep + \"]\");\n+            }            \n+            if (lineLength > 0){ // null line-sep forces no chunking rather than throwing IAE\n+                this.encodeSize = BYTES_PER_ENCODED_BLOCK + lineSeparator.length;\n+                this.lineSeparator = new byte[lineSeparator.length];\n+                System.arraycopy(lineSeparator, 0, this.lineSeparator, 0, lineSeparator.length);\n+            } else {\n+                this.encodeSize = BYTES_PER_ENCODED_BLOCK;\n+                this.lineSeparator = null;\n+            }\n         } else {\n-            this.encodeSize = 4;\n+            this.encodeSize = BYTES_PER_ENCODED_BLOCK;\n+            this.lineSeparator = null;\n         }\n         this.decodeSize = this.encodeSize - 1;\n-        if (containsBase64Byte(lineSeparator)) {\n-            String sep = StringUtils.newStringUtf8(lineSeparator);\n-            throw new IllegalArgumentException(\"lineSeperator must not contain base64 characters: [\" + sep + \"]\");\n-        }\n         this.encodeTable = urlSafe ? URL_SAFE_ENCODE_TABLE : STANDARD_ENCODE_TABLE;\n     }\n \n      */\n     public boolean isUrlSafe() {\n         return this.encodeTable == URL_SAFE_ENCODE_TABLE;\n-    }\n-\n-    /**\n-     * Returns true if this Base64 object has buffered data for reading.\n-     * \n-     * @return true if there is Base64 object still available for reading.\n-     */\n-    boolean hasData() {\n-        return this.buffer != null;\n-    }\n-\n-    /**\n-     * Returns the amount of buffered data available for reading.\n-     * \n-     * @return The amount of buffered data available for reading.\n-     */\n-    int avail() {\n-        return buffer != null ? pos - readPos : 0;\n-    }\n-\n-    /** Doubles our buffer. */\n-    private void resizeBuffer() {\n-        if (buffer == null) {\n-            buffer = new byte[DEFAULT_BUFFER_SIZE];\n-            pos = 0;\n-            readPos = 0;\n-        } else {\n-            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];\n-            System.arraycopy(buffer, 0, b, 0, buffer.length);\n-            buffer = b;\n-        }\n-    }\n-\n-    /**\n-     * Extracts buffered data into the provided byte[] array, starting at position bPos, up to a maximum of bAvail\n-     * bytes. Returns how many bytes were actually extracted.\n-     * \n-     * @param b\n-     *            byte[] array to extract the buffered data into.\n-     * @param bPos\n-     *            position in byte[] array to start extraction at.\n-     * @param bAvail\n-     *            amount of bytes we're allowed to extract. We may extract fewer (if fewer are available).\n-     * @return The number of bytes successfully extracted into the provided byte[] array.\n-     */\n-    int readResults(byte[] b, int bPos, int bAvail) {\n-        if (buffer != null) {\n-            int len = Math.min(avail(), bAvail);\n-            System.arraycopy(buffer, readPos, b, bPos, len);\n-            readPos += len;\n-            if (readPos >= pos) {\n-                buffer = null;\n-            }\n-            return len;\n-        }\n-        return eof ? -1 : 0;\n     }\n \n     /**\n         // encoding.\n         if (inAvail < 0) {\n             eof = true;\n-            if (buffer == null || buffer.length - pos < encodeSize) {\n-                resizeBuffer();\n-            }\n-            switch (modulus) {\n-                case 1 :\n-                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];\n-                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];\n+            if (0 == modulus && lineLength == 0) {\n+                return; // no leftovers to process and not using chunking\n+            }\n+            ensureBufferSize(encodeSize);\n+            int savedPos = pos;\n+            switch (modulus) { // 0-2\n+                case 1 : // 8 bits = 6 + 2\n+                    buffer[pos++] = encodeTable[(bitWorkArea >> 2) & MASK_6BITS]; // top 6 bits\n+                    buffer[pos++] = encodeTable[(bitWorkArea << 4) & MASK_6BITS]; // remaining 2 \n                     // URL-SAFE skips the padding to further reduce size.\n                     if (encodeTable == STANDARD_ENCODE_TABLE) {\n                         buffer[pos++] = PAD;\n                     }\n                     break;\n \n-                case 2 :\n-                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];\n-                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];\n-                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];\n+                case 2 : // 16 bits = 6 + 6 + 4\n+                    buffer[pos++] = encodeTable[(bitWorkArea >> 10) & MASK_6BITS];\n+                    buffer[pos++] = encodeTable[(bitWorkArea >> 4) & MASK_6BITS];\n+                    buffer[pos++] = encodeTable[(bitWorkArea << 2) & MASK_6BITS];\n                     // URL-SAFE skips the padding to further reduce size.\n                     if (encodeTable == STANDARD_ENCODE_TABLE) {\n                         buffer[pos++] = PAD;\n                     }\n                     break;\n             }\n-            // Don't want to append the CRLF two times in a row, so make sure previous\n-            // character is not from CRLF!\n-            byte b = lineSeparator[lineSeparator.length - 1];\n-            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {\n+            currentLinePos += pos - savedPos; // keep track of current line position\n+            // if currentPos == 0 we are at the start of a line, so don't add CRLF\n+            if (lineLength > 0 && currentLinePos > 0) { \n                 System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);\n                 pos += lineSeparator.length;\n             }\n         } else {\n             for (int i = 0; i < inAvail; i++) {\n-                if (buffer == null || buffer.length - pos < encodeSize) {\n-                    resizeBuffer();\n-                }\n-                modulus = (++modulus) % 3;\n+                ensureBufferSize(encodeSize);\n+                modulus = (++modulus) % BYTES_PER_UNENCODED_BLOCK;\n                 int b = in[inPos++];\n                 if (b < 0) {\n                     b += 256;\n                 }\n-                x = (x << 8) + b;\n-                if (0 == modulus) {\n-                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];\n-                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];\n-                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];\n-                    buffer[pos++] = encodeTable[x & MASK_6BITS];\n-                    currentLinePos += 4;\n+                bitWorkArea = (bitWorkArea << 8) + b; //  BITS_PER_BYTE\n+                if (0 == modulus) { // 3 bytes = 24 bits = 4 * 6 bits to extract\n+                    buffer[pos++] = encodeTable[(bitWorkArea >> 18) & MASK_6BITS];\n+                    buffer[pos++] = encodeTable[(bitWorkArea >> 12) & MASK_6BITS];\n+                    buffer[pos++] = encodeTable[(bitWorkArea >> 6) & MASK_6BITS];\n+                    buffer[pos++] = encodeTable[bitWorkArea & MASK_6BITS];\n+                    currentLinePos += BYTES_PER_ENCODED_BLOCK;\n                     if (lineLength > 0 && lineLength <= currentLinePos) {\n                         System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);\n                         pos += lineSeparator.length;\n             eof = true;\n         }\n         for (int i = 0; i < inAvail; i++) {\n-            if (buffer == null || buffer.length - pos < decodeSize) {\n-                resizeBuffer();\n-            }\n+            ensureBufferSize(decodeSize);\n             byte b = in[inPos++];\n             if (b == PAD) {\n                 // We're done.\n                 if (b >= 0 && b < DECODE_TABLE.length) {\n                     int result = DECODE_TABLE[b];\n                     if (result >= 0) {\n-                        modulus = (++modulus) % 4;\n-                        x = (x << 6) + result;\n+                        modulus = (++modulus) % BYTES_PER_ENCODED_BLOCK;\n+                        bitWorkArea = (bitWorkArea << BITS_PER_ENCODED_BYTE) + result;\n                         if (modulus == 0) {\n-                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);\n-                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);\n-                            buffer[pos++] = (byte) (x & MASK_8BITS);\n+                            buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);\n+                            buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);\n+                            buffer[pos++] = (byte) (bitWorkArea & MASK_8BITS);\n                         }\n                     }\n                 }\n         // EOF (-1) and first time '=' character is encountered in stream.\n         // This approach makes the '=' padding characters completely optional.\n         if (eof && modulus != 0) {\n-            if (buffer == null || buffer.length - pos < decodeSize) {\n-                resizeBuffer();\n-            }\n+            ensureBufferSize(decodeSize);\n             \n             // We have some spare bits remaining\n             // Output all whole multiples of 8 bits and ignore the rest\n            //   case 1: // 6 bits - ignore entirely\n            //       break;\n                 case 2 : // 12 bits = 8 + 4\n-                    x = x >> 4;\n-                    buffer[pos++] = (byte) ((x) & MASK_8BITS);\n+                    bitWorkArea = bitWorkArea >> 4; // dump the extra 4 bits\n+                    buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);\n                     break;\n                 case 3 : // 18 bits = 8 + 8 + 2\n-                    x = x >> 2;\n-                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);\n-                    buffer[pos++] = (byte) ((x) & MASK_8BITS);\n+                    bitWorkArea = bitWorkArea >> 2; // dump 2 bits\n+                    buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);\n+                    buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);\n                     break;\n             }\n         }\n      * @since 1.4\n      */\n     public static boolean isBase64(byte octet) {\n-        return octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);\n+        return octet == PAD_DEFAULT || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);\n     }\n \n     /**\n     }\n     \n     /**\n-     * Tests a given byte array to see if it contains any characters fromn the Base64 alphabet.\n-     * \n-     * @param arrayOctet\n-     *            byte array to test\n-     * @return <code>true</code> if any byte is a valid character in the Base64 alphabet; <code>false</code> otherwise\n-     */\n-    private static boolean containsBase64Byte(byte[] arrayOctet) {\n-        for (int i = 0; i < arrayOctet.length; i++) {\n-            if (isBase64(arrayOctet[i])) {\n-                return true;\n-            }\n-        }\n-        return false;\n-    }\n-\n-    /**\n      * Encodes binary data using the base64 algorithm but does not chunk the output.\n      * \n      * @param binaryData\n      */\n     public static byte[] encodeBase64Chunked(byte[] binaryData) {\n         return encodeBase64(binaryData, true);\n-    }\n-\n-    /**\n-     * Decodes an Object using the base64 algorithm. This method is provided in order to satisfy the requirements of the\n-     * Decoder interface, and will throw a DecoderException if the supplied object is not of type byte[] or String.\n-     * \n-     * @param pObject\n-     *            Object to decode\n-     * @return An object (of type byte[]) containing the binary data which corresponds to the byte[] or String supplied.\n-     * @throws DecoderException\n-     *             if the parameter supplied is not of type byte[]\n-     */\n-    public Object decode(Object pObject) throws DecoderException {        \n-        if (pObject instanceof byte[]) {\n-            return decode((byte[]) pObject);\n-        } else if (pObject instanceof String) {\n-            return decode((String) pObject);\n-        } else {\n-            throw new DecoderException(\"Parameter supplied to Base64 decode is not a byte[] or a String\");\n-        }\n-    }\n-\n-    /**\n-     * Decodes a String containing characters in the Base64 alphabet.\n-     *\n-     * @param pArray\n-     *            A String containing Base64 character data\n-     * @return a byte array containing binary data\n-     * @since 1.4\n-     */\n-    public byte[] decode(String pArray) {\n-        return decode(StringUtils.getBytesUtf8(pArray));\n-    }\n-\n-    /**\n-     * Decodes a byte[] containing characters in the Base64 alphabet.\n-     * \n-     * @param pArray\n-     *            A byte array containing Base64 character data\n-     * @return a byte array containing binary data\n-     */\n-    public byte[] decode(byte[] pArray) {\n-        reset();\n-        if (pArray == null || pArray.length == 0) {\n-            return pArray;\n-        }\n-        decode(pArray, 0, pArray.length);\n-        decode(pArray, 0, -1); // Notify decoder of EOF.\n-        byte[] result = new byte[pos];\n-        readResults(result, 0, result.length);\n-        return result;\n     }\n \n     /**\n             return binaryData;\n         }\n \n-        long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);\n+        // Create this so can use the super-class method\n+        // Also ensures that the same roundings are performed by the ctor and the code\n+        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);\n+        long len = b64.getEncodedLength(binaryData);\n         if (len > maxResultSize) {\n             throw new IllegalArgumentException(\"Input array too big, the output array would be bigger (\" +\n                 len +\n-                \") than the specified maxium size of \" +\n+                \") than the specified maximum size of \" +\n                 maxResultSize);\n         }\n                 \n-        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);\n         return b64.encode(binaryData);\n     }\n \n         return packedData;\n     }\n \n-    /**\n-     * Checks if a byte value is whitespace or not.\n-     * \n-     * @param byteToCheck\n-     *            the byte to check\n-     * @return true if byte is whitespace, false otherwise\n-     */\n-    private static boolean isWhiteSpace(byte byteToCheck) {\n-        switch (byteToCheck) {\n-            case ' ' :\n-            case '\\n' :\n-            case '\\r' :\n-            case '\\t' :\n-                return true;\n-            default :\n-                return false;\n-        }\n-    }\n-\n     // Implementation of the Encoder Interface\n-\n-    /**\n-     * Encodes an Object using the base64 algorithm. This method is provided in order to satisfy the requirements of the\n-     * Encoder interface, and will throw an EncoderException if the supplied object is not of type byte[].\n-     * \n-     * @param pObject\n-     *            Object to encode\n-     * @return An object (of type byte[]) containing the base64 encoded data which corresponds to the byte[] supplied.\n-     * @throws EncoderException\n-     *             if the parameter supplied is not of type byte[]\n-     */\n-    public Object encode(Object pObject) throws EncoderException {\n-        if (!(pObject instanceof byte[])) {\n-            throw new EncoderException(\"Parameter supplied to Base64 encode is not a byte[]\");\n-        }\n-        return encode((byte[]) pObject);\n-    }\n-\n-    /**\n-     * Encodes a byte[] containing binary data, into a String containing characters in the Base64 alphabet.\n-     *\n-     * @param pArray\n-     *            a byte array containing binary data\n-     * @return A String containing only Base64 character data\n-     * @since 1.4\n-     */    \n-    public String encodeToString(byte[] pArray) {\n-        return StringUtils.newStringUtf8(encode(pArray));\n-    }\n-\n-    /**\n-     * Encodes a byte[] containing binary data, into a byte[] containing characters in the Base64 alphabet.\n-     * \n-     * @param pArray\n-     *            a byte array containing binary data\n-     * @return A byte array containing only Base64 character data\n-     */\n-    public byte[] encode(byte[] pArray) {\n-        reset();        \n-        if (pArray == null || pArray.length == 0) {\n-            return pArray;\n-        }\n-        encode(pArray, 0, pArray.length);\n-        encode(pArray, 0, -1); // Notify encoder of EOF.\n-        byte[] buf = new byte[pos - readPos];\n-        readResults(buf, 0, buf.length);\n-        return buf;\n-    }\n-\n-    /**\n-     * Pre-calculates the amount of space needed to base64-encode the supplied array.\n-     *\n-     * @param pArray byte[] array which will later be encoded\n-     * @param chunkSize line-length of the output (<= 0 means no chunking) between each\n-     *        chunkSeparator (e.g. CRLF).\n-     * @param chunkSeparator the sequence of bytes used to separate chunks of output (e.g. CRLF).\n-     *\n-     * @return amount of space needed to encoded the supplied array.  Returns\n-     *         a long since a max-len array will require Integer.MAX_VALUE + 33%.\n-     */\n-    private static long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {\n-        // base64 always encodes to multiples of 4.\n-        chunkSize = (chunkSize / 4) * 4;\n-\n-        long len = (pArray.length * 4) / 3;\n-        long mod = len % 4;\n-        if (mod != 0) {\n-            len += 4 - mod;\n-        }\n-        if (chunkSize > 0) {\n-            boolean lenChunksPerfectly = len % chunkSize == 0;\n-            len += (len / chunkSize) * chunkSeparator.length;\n-            if (!lenChunksPerfectly) {\n-                len += chunkSeparator.length;\n-            }\n-        }\n-        return len;\n-    }\n \n     // Implementation of integer encoding used for crypto\n     /**\n     }\n \n     /**\n-     * Resets this Base64 object to its initial newly constructed state.\n-     */\n-    private void reset() {\n-        buffer = null;\n-        pos = 0;\n-        readPos = 0;\n-        currentLinePos = 0;\n-        modulus = 0;\n-        eof = false;\n+     * Returns whether or not the <code>octet</code> is in the Base32 alphabet.\n+     * \n+     * @param octet\n+     *            The value to test\n+     * @return <code>true</code> if the value is defined in the the Base32 alphabet <code>false</code> otherwise.\n+     */\n+    protected boolean isInAlphabet(byte octet) {\n+        return (octet >= 0 && octet < decodeTable.length && decodeTable[octet] != -1);\n     }\n \n }\n--- a/src/java/org/apache/commons/codec/binary/Base64OutputStream.java\n+++ b/src/java/org/apache/commons/codec/binary/Base64OutputStream.java\n      *             if an I/O error occurs.\n      */\n     private void flush(boolean propogate) throws IOException {\n-        int avail = base64.avail();\n+        int avail = base64.available();\n         if (avail > 0) {\n             byte[] buf = new byte[avail];\n             int c = base64.readResults(buf, 0, avail);\n--- a/src/test/org/apache/commons/codec/binary/Base64Test.java\n+++ b/src/test/org/apache/commons/codec/binary/Base64Test.java\n         base64 = new Base64(-1, new byte[]{});\n         base64 = new Base64(64, new byte[]{});\n         try {\n-            base64 = new Base64(-1, new byte[]{'A'});\n+            base64 = new Base64(-1, new byte[]{'A'}); // TODO do we need to check sep if len = -1?\n             fail(\"Should have rejected attempt to use 'A' as a line separator\");\n         } catch (IllegalArgumentException ignored) {\n             // Expected", "timestamp": 1296179496, "metainfo": ""}