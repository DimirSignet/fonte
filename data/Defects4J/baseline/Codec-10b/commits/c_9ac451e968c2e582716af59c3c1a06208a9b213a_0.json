{"sha": "9ac451e968c2e582716af59c3c1a06208a9b213a", "log": "Refactor Base64 I/O streams  ", "commit": "\n--- a/src/java/org/apache/commons/codec/binary/Base64InputStream.java\n+++ b/src/java/org/apache/commons/codec/binary/Base64InputStream.java\n \n package org.apache.commons.codec.binary;\n \n-import java.io.FilterInputStream;\n-import java.io.IOException;\n import java.io.InputStream;\n \n /**\n  * @see <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045</a>\n  * @since 1.4\n  */\n-public class Base64InputStream extends FilterInputStream {\n-\n-    private final boolean doEncode;\n-\n-    private final Base64 base64;\n-\n-    private final byte[] singleByte = new byte[1];\n+public class Base64InputStream extends BaseNCodecInputStream {\n \n     /**\n      * Creates a Base64InputStream such that all data read is Base64-decoded from the original provided InputStream.\n      *            true if we should encode all data read from us, false if we should decode.\n      */\n     public Base64InputStream(InputStream in, boolean doEncode) {\n-        super(in);\n-        this.doEncode = doEncode;\n-        this.base64 = new Base64(false);\n+        super(in, new Base64(false), doEncode);\n     }\n \n     /**\n      *            If lineLength <= 0, the lineSeparator is not used. If doEncode is false lineSeparator is ignored.\n      */\n     public Base64InputStream(InputStream in, boolean doEncode, int lineLength, byte[] lineSeparator) {\n-        super(in);\n-        this.doEncode = doEncode;\n-        this.base64 = new Base64(lineLength, lineSeparator);\n-    }\n-\n-    /**\n-     * Reads one <code>byte</code> from this input stream.\n-     * \n-     * @return the byte as an integer in the range 0 to 255. Returns -1 if EOF has been reached.\n-     * @throws IOException\n-     *             if an I/O error occurs.\n-     */\n-    public int read() throws IOException {\n-        int r = read(singleByte, 0, 1);\n-        while (r == 0) {\n-            r = read(singleByte, 0, 1);\n-        }\n-        if (r > 0) {\n-            return singleByte[0] < 0 ? 256 + singleByte[0] : singleByte[0];\n-        }\n-        return -1;\n-    }\n-\n-    /**\n-     * Attempts to read <code>len</code> bytes into the specified <code>b</code> array starting at <code>offset</code>\n-     * from this InputStream.\n-     * \n-     * @param b\n-     *            destination byte array\n-     * @param offset\n-     *            where to start writing the bytes\n-     * @param len\n-     *            maximum number of bytes to read\n-     * \n-     * @return number of bytes read\n-     * @throws IOException\n-     *             if an I/O error occurs.\n-     * @throws NullPointerException\n-     *             if the byte array parameter is null\n-     * @throws IndexOutOfBoundsException\n-     *             if offset, len or buffer size are invalid\n-     */\n-    public int read(byte b[], int offset, int len) throws IOException {\n-        if (b == null) {\n-            throw new NullPointerException();\n-        } else if (offset < 0 || len < 0) {\n-            throw new IndexOutOfBoundsException();\n-        } else if (offset > b.length || offset + len > b.length) {\n-            throw new IndexOutOfBoundsException();\n-        } else if (len == 0) {\n-            return 0;\n-        } else {\n-            int readLen = 0;\n-            /*\n-             Rationale for while-loop on (readLen == 0):\n-             -----\n-             Base64.readResults() usually returns > 0 or EOF (-1).  In the\n-             rare case where it returns 0, we just keep trying.\n-\n-             This is essentially an undocumented contract for InputStream\n-             implementors that want their code to work properly with\n-             java.io.InputStreamReader, since the latter hates it when\n-             InputStream.read(byte[]) returns a zero.  Unfortunately our\n-             readResults() call must return 0 if a large amount of the data\n-             being decoded was non-base64, so this while-loop enables proper\n-             interop with InputStreamReader for that scenario.\n-             -----\n-             This is a fix for CODEC-101\n-            */\n-            while (readLen == 0) {\n-                if (!base64.hasData()) {\n-                    byte[] buf = new byte[doEncode ? 4096 : 8192];\n-                    int c = in.read(buf);\n-                    if (doEncode) {\n-                        base64.encode(buf, 0, c);\n-                    } else {\n-                        base64.decode(buf, 0, c);\n-                    }\n-                }\n-                readLen = base64.readResults(b, offset, len);\n-            }\n-            return readLen;\n-        }\n-    }\n-\n-    /**\n-     * {@inheritDoc}\n-     * \n-     * @return false\n-     */\n-    public boolean markSupported() {\n-        return false; // not an easy job to support marks\n+        super(in, new Base64(lineLength, lineSeparator), doEncode);\n     }\n }\n--- a/src/java/org/apache/commons/codec/binary/Base64OutputStream.java\n+++ b/src/java/org/apache/commons/codec/binary/Base64OutputStream.java\n \n package org.apache.commons.codec.binary;\n \n-import java.io.FilterOutputStream;\n-import java.io.IOException;\n import java.io.OutputStream;\n \n /**\n  * @see <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045</a>\n  * @since 1.4\n  */\n-public class Base64OutputStream extends FilterOutputStream {\n-    private final boolean doEncode;\n-\n-    private final Base64 base64;\n-\n-    private final byte[] singleByte = new byte[1];\n+public class Base64OutputStream extends BaseNCodecOutputStream {\n \n     /**\n      * Creates a Base64OutputStream such that all data written is Base64-encoded to the original provided OutputStream.\n      *            true if we should encode all data written to us, false if we should decode.\n      */\n     public Base64OutputStream(OutputStream out, boolean doEncode) {\n-        super(out);\n-        this.doEncode = doEncode;\n-        this.base64 = new Base64(false);\n+        super(out,new Base64(false), doEncode);\n     }\n \n     /**\n      *            If lineLength <= 0, the lineSeparator is not used. If doEncode is false lineSeparator is ignored.\n      */\n     public Base64OutputStream(OutputStream out, boolean doEncode, int lineLength, byte[] lineSeparator) {\n-        super(out);\n-        this.doEncode = doEncode;\n-        this.base64 = new Base64(lineLength, lineSeparator);\n+        super(out, new Base64(lineLength, lineSeparator), doEncode);\n     }\n-\n-    /**\n-     * Writes the specified <code>byte</code> to this output stream.\n-     * \n-     * @param i\n-     *            source byte\n-     * @throws IOException\n-     *             if an I/O error occurs.\n-     */\n-    public void write(int i) throws IOException {\n-        singleByte[0] = (byte) i;\n-        write(singleByte, 0, 1);\n-    }\n-\n-    /**\n-     * Writes <code>len</code> bytes from the specified <code>b</code> array starting at <code>offset</code> to this\n-     * output stream.\n-     * \n-     * @param b\n-     *            source byte array\n-     * @param offset\n-     *            where to start reading the bytes\n-     * @param len\n-     *            maximum number of bytes to write\n-     * \n-     * @throws IOException\n-     *             if an I/O error occurs.\n-     * @throws NullPointerException\n-     *             if the byte array parameter is null\n-     * @throws IndexOutOfBoundsException\n-     *             if offset, len or buffer size are invalid\n-     */\n-    public void write(byte b[], int offset, int len) throws IOException {\n-        if (b == null) {\n-            throw new NullPointerException();\n-        } else if (offset < 0 || len < 0) {\n-            throw new IndexOutOfBoundsException();\n-        } else if (offset > b.length || offset + len > b.length) {\n-            throw new IndexOutOfBoundsException();\n-        } else if (len > 0) {\n-            if (doEncode) {\n-                base64.encode(b, offset, len);\n-            } else {\n-                base64.decode(b, offset, len);\n-            }\n-            flush(false);\n-        }\n-    }\n-\n-    /**\n-     * Flushes this output stream and forces any buffered output bytes to be written out to the stream. If propogate is\n-     * true, the wrapped stream will also be flushed.\n-     * \n-     * @param propogate\n-     *            boolean flag to indicate whether the wrapped OutputStream should also be flushed.\n-     * @throws IOException\n-     *             if an I/O error occurs.\n-     */\n-    private void flush(boolean propogate) throws IOException {\n-        int avail = base64.available();\n-        if (avail > 0) {\n-            byte[] buf = new byte[avail];\n-            int c = base64.readResults(buf, 0, avail);\n-            if (c > 0) {\n-                out.write(buf, 0, c);\n-            }\n-        }\n-        if (propogate) {\n-            out.flush();\n-        }\n-    }\n-\n-    /**\n-     * Flushes this output stream and forces any buffered output bytes to be written out to the stream.\n-     * \n-     * @throws IOException\n-     *             if an I/O error occurs.\n-     */\n-    public void flush() throws IOException {\n-        flush(true);\n-    }\n-\n-    /**\n-     * Closes this output stream and releases any system resources associated with the stream.\n-     * \n-     * @throws IOException\n-     *             if an I/O error occurs.\n-     */\n-    public void close() throws IOException {\n-        // Notify encoder of EOF (-1).\n-        if (doEncode) {\n-            base64.encode(singleByte, 0, -1);\n-        } else {\n-            base64.decode(singleByte, 0, -1);\n-        }\n-        flush();\n-        out.close();\n-    }\n-\n-}\n+}", "timestamp": 1296180166, "metainfo": ""}