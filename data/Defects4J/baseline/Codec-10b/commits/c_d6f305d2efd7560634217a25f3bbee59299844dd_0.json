{"sha": "d6f305d2efd7560634217a25f3bbee59299844dd", "log": "Remove BASE32 and BASE32_ prefixes from private constants. Order members in AB order.  ", "commit": "\n--- a/src/java/org/apache/commons/codec/binary/Base32.java\n+++ b/src/java/org/apache/commons/codec/binary/Base32.java\n      * which is converted into eight BASE32 characters.\n      */\n     private static final int BITS_PER_ENCODED_BYTE = 5;\n+    private static final int BYTES_PER_ENCODED_BLOCK = 8;\n     private static final int BYTES_PER_UNENCODED_BLOCK = 5;\n-    private static final int BYTES_PER_ENCODED_BLOCK = 8;\n \n     /**\n      * Chunk separator per RFC 2045 section 2.1.\n     private static final byte[] CHUNK_SEPARATOR = {'\\r', '\\n'};\n \n     /**\n-     * This array is a lookup table that translates 5-bit positive integer index values into their \"Base32 Alphabet\"\n-     * equivalents as specified in Table 3 of RFC 2045.\n-     */\n-    private static final byte[] BASE32_ENCODE_TABLE = {\n-            'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\n-            'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',\n-            '2', '3', '4', '5', '6', '7',\n-    };\n-\n-    /**\n-     * This array is a lookup table that translates 5-bit positive integer index values into their \"Base32 Hex Alphabet\"\n-     * equivalents as specified in Table 3 of RFC 2045.\n-     */\n-    private static final byte[] BASE32HEX_ENCODE_TABLE = {\n-            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', \n-            'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\n-            'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V',\n-    };\n-\n-    /**\n      * This array is a lookup table that translates Unicode characters drawn from the \"Base32 Alphabet\" (as specified in\n      * Table 3 of RFC 2045) into their 5-bit positive integer equivalents. Characters that are not in the Base32\n      * alphabet but fall within the bounds of the array are translated to -1.\n      * \n      */\n-    private static final byte[] BASE32_DECODE_TABLE = {\n+    private static final byte[] DECODE_TABLE = {\n          //  0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F\n             -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 00-0f\n             -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 10-1f\n     };\n \n     /**\n+     * This array is a lookup table that translates 5-bit positive integer index values into their \"Base32 Alphabet\"\n+     * equivalents as specified in Table 3 of RFC 2045.\n+     */\n+    private static final byte[] ENCODE_TABLE = {\n+            'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\n+            'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',\n+            '2', '3', '4', '5', '6', '7',\n+    };\n+\n+    /**\n      * This array is a lookup table that translates Unicode characters drawn from the \"Base32 |Hex Alphabet\" (as specified in\n      * Table 3 of RFC 2045) into their 5-bit positive integer equivalents. Characters that are not in the Base32 Hex\n      * alphabet but fall within the bounds of the array are translated to -1.\n      * \n      */\n-    private static final byte[] BASE32HEX_DECODE_TABLE = {\n+    private static final byte[] HEX_DECODE_TABLE = {\n          //  0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F\n             -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 00-0f\n             -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 10-1f\n             25, 26, 27, 28, 29, 30, 31, 32,                                 // 50-57 O-V\n     };\n \n+    /**\n+     * This array is a lookup table that translates 5-bit positive integer index values into their \"Base32 Hex Alphabet\"\n+     * equivalents as specified in Table 3 of RFC 2045.\n+     */\n+    private static final byte[] HEX_ENCODE_TABLE = {\n+            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', \n+            'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\n+            'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V',\n+    };\n+\n     /** Mask used to extract 5 bits, used when encoding Base32 bytes */\n     private static final int MASK_5BITS = 0x1f;\n \n     // some state be preserved between calls of encode() and decode().\n \n     /**\n-     * Encode table to use.\n-     */\n-    private final byte[] encodeTable;\n-\n-    /**\n-     * Decode table to use.\n-     */\n-    private final byte[] decodeTable;\n-\n-    /**\n-     * Line separator for encoding. Not used when decoding. Only used if lineLength > 0.\n-     */\n-    private final byte[] lineSeparator;\n+     * Place holder for the bytes we're dealing with for our based logic. \n+     * Bitwise operations store and extract the encoding or decoding from this variable.\n+     */\n+    private long bitWorkArea;\n \n     /**\n      * Convenience variable to help us determine when our buffer is going to run out of room and needs resizing.\n     private final int decodeSize;\n \n     /**\n+     * Decode table to use.\n+     */\n+    private final byte[] decodeTable;\n+\n+    /**\n      * Convenience variable to help us determine when our buffer is going to run out of room and needs resizing.\n      * <code>encodeSize = {@link BYTES_PER_ENCODED_BLOCK} + lineSeparator.length;</code>\n      */\n     private final int encodeSize;\n \n     /**\n-     * Place holder for the bytes we're dealing with for our based logic. \n-     * Bitwise operations store and extract the encoding or decoding from this variable.\n-     */\n-    private long bitWorkArea;\n+     * Encode table to use.\n+     */\n+    private final byte[] encodeTable;\n+\n+    /**\n+     * Line separator for encoding. Not used when decoding. Only used if lineLength > 0.\n+     */\n+    private final byte[] lineSeparator;\n \n     /**\n      * Creates a Base32 codec used for decoding and encoding.\n                 lineLength, \n                 lineSeparator == null ? 0 : lineSeparator.length);\n         if (useHex){\n-            this.encodeTable = BASE32HEX_ENCODE_TABLE;\n-            this.decodeTable = BASE32HEX_DECODE_TABLE;            \n+            this.encodeTable = HEX_ENCODE_TABLE;\n+            this.decodeTable = HEX_DECODE_TABLE;            \n         } else {\n-            this.encodeTable = BASE32_ENCODE_TABLE;\n-            this.decodeTable = BASE32_DECODE_TABLE;            \n+            this.encodeTable = ENCODE_TABLE;\n+            this.decodeTable = DECODE_TABLE;            \n         }\n         if (lineLength > 0) {\n             if (lineSeparator == null) {\n     }\n \n     /**\n-     * Returns whether or not the <code>octet</code> is in the Base32 alphabet.\n-     * \n-     * @param octet\n-     *            The value to test\n-     * @return <code>true</code> if the value is defined in the the Base32 alphabet <code>false</code> otherwise.\n-     */\n-    public boolean isInAlphabet(byte octet) {\n-        return (octet >= 0 && octet < decodeTable.length && decodeTable[octet] != -1);\n+     * <p>\n+     * Decodes all of the provided data, starting at inPos, for inAvail bytes. Should be called at least twice: once\n+     * with the data to decode, and once with inAvail set to \"-1\" to alert decoder that EOF has been reached. The \"-1\"\n+     * call is not necessary when decoding, but it doesn't hurt, either.\n+     * </p>\n+     * <p>\n+     * Ignores all non-Base32 characters. This is how chunked (e.g. 76 character) data is handled, since CR and LF are\n+     * silently ignored, but has implications for other bytes, too. This method subscribes to the garbage-in,\n+     * garbage-out philosophy: it will not check the provided data for validity.\n+     * </p>\n+     * \n+     * @param in\n+     *            byte[] array of ascii data to Base32 decode.\n+     * @param inPos\n+     *            Position to start reading data from.\n+     * @param inAvail\n+     *            Amount of bytes available from input for encoding.\n+     *\n+     * Output is written to {@link #buffer} as 8-bit octets, using {@link pos} as the buffer position\n+     */\n+    void decode(byte[] in, int inPos, int inAvail) { // package protected for access from I/O streams\n+        if (eof) {\n+            return;\n+        }\n+        if (inAvail < 0) {\n+            eof = true;\n+        }\n+        for (int i = 0; i < inAvail; i++) {\n+            byte b = in[inPos++];\n+            if (b == PAD) {\n+                // We're done.\n+                eof = true;\n+                break;\n+            } else {\n+                ensureBufferSize(decodeSize);\n+                if (b >= 0 && b < this.decodeTable.length) {\n+                    int result = this.decodeTable[b];\n+                    if (result >= 0) {\n+                        modulus = (modulus+1) % BYTES_PER_ENCODED_BLOCK;\n+                        bitWorkArea = (bitWorkArea << BITS_PER_ENCODED_BYTE) + result; // collect decoded bytes\n+                        if (modulus == 0) { // we can output the 5 bytes\n+                            buffer[pos++] = (byte) ((bitWorkArea >> 32) & MASK_8BITS);\n+                            buffer[pos++] = (byte) ((bitWorkArea >> 24) & MASK_8BITS);\n+                            buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);\n+                            buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);\n+                            buffer[pos++] = (byte) (bitWorkArea & MASK_8BITS);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    \n+        // Two forms of EOF as far as Base32 decoder is concerned: actual\n+        // EOF (-1) and first time '=' character is encountered in stream.\n+        // This approach makes the '=' padding characters completely optional.\n+        if (eof && modulus >= 2) { // if modulus < 2, nothing to do\n+            ensureBufferSize(decodeSize);\n+    \n+            //  we ignore partial bytes, i.e. only multiples of 8 count\n+            switch (modulus) {\n+                case 2 : // 10 bits, drop 2 and output one byte\n+                    buffer[pos++] = (byte) ((bitWorkArea >> 2) & MASK_8BITS);\n+                    break;\n+                case 3 : // 15 bits, drop 7 and output 1 byte\n+                    buffer[pos++] = (byte) ((bitWorkArea >> 7) & MASK_8BITS);\n+                    break;\n+                case 4 : // 20 bits = 2*8 + 4\n+                    bitWorkArea = bitWorkArea >> 4; // drop 4 bits\n+                    buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);\n+                    buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);\n+                    break;\n+                case 5 : // 25bits = 3*8 + 1\n+                    bitWorkArea = bitWorkArea >> 1;\n+                    buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);\n+                    buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);\n+                    buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);\n+                    break;\n+                case 6 : // 30bits = 3*8 + 6\n+                    bitWorkArea = bitWorkArea >> 6;\n+                    buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);\n+                    buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);\n+                    buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);\n+                    break;\n+                case 7 : // 35 = 4*8 +3\n+                    bitWorkArea = bitWorkArea >> 3;\n+                    buffer[pos++] = (byte) ((bitWorkArea >> 24) & MASK_8BITS);\n+                    buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);\n+                    buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);\n+                    buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);\n+                    break;\n+            }\n+        }\n     }\n \n     /**\n     }\n \n     /**\n-     * <p>\n-     * Decodes all of the provided data, starting at inPos, for inAvail bytes. Should be called at least twice: once\n-     * with the data to decode, and once with inAvail set to \"-1\" to alert decoder that EOF has been reached. The \"-1\"\n-     * call is not necessary when decoding, but it doesn't hurt, either.\n-     * </p>\n-     * <p>\n-     * Ignores all non-Base32 characters. This is how chunked (e.g. 76 character) data is handled, since CR and LF are\n-     * silently ignored, but has implications for other bytes, too. This method subscribes to the garbage-in,\n-     * garbage-out philosophy: it will not check the provided data for validity.\n-     * </p>\n-     * \n-     * @param in\n-     *            byte[] array of ascii data to Base32 decode.\n-     * @param inPos\n-     *            Position to start reading data from.\n-     * @param inAvail\n-     *            Amount of bytes available from input for encoding.\n-     *\n-     * Output is written to {@link #buffer} as 8-bit octets, using {@link pos} as the buffer position\n-     */\n-    void decode(byte[] in, int inPos, int inAvail) { // package protected for access from I/O streams\n-        if (eof) {\n-            return;\n-        }\n-        if (inAvail < 0) {\n-            eof = true;\n-        }\n-        for (int i = 0; i < inAvail; i++) {\n-            byte b = in[inPos++];\n-            if (b == PAD) {\n-                // We're done.\n-                eof = true;\n-                break;\n-            } else {\n-                ensureBufferSize(decodeSize);\n-                if (b >= 0 && b < this.decodeTable.length) {\n-                    int result = this.decodeTable[b];\n-                    if (result >= 0) {\n-                        modulus = (modulus+1) % BYTES_PER_ENCODED_BLOCK;\n-                        bitWorkArea = (bitWorkArea << BITS_PER_ENCODED_BYTE) + result; // collect decoded bytes\n-                        if (modulus == 0) { // we can output the 5 bytes\n-                            buffer[pos++] = (byte) ((bitWorkArea >> 32) & MASK_8BITS);\n-                            buffer[pos++] = (byte) ((bitWorkArea >> 24) & MASK_8BITS);\n-                            buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);\n-                            buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);\n-                            buffer[pos++] = (byte) (bitWorkArea & MASK_8BITS);\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-    \n-        // Two forms of EOF as far as Base32 decoder is concerned: actual\n-        // EOF (-1) and first time '=' character is encountered in stream.\n-        // This approach makes the '=' padding characters completely optional.\n-        if (eof && modulus >= 2) { // if modulus < 2, nothing to do\n-            ensureBufferSize(decodeSize);\n-    \n-            //  we ignore partial bytes, i.e. only multiples of 8 count\n-            switch (modulus) {\n-                case 2 : // 10 bits, drop 2 and output one byte\n-                    buffer[pos++] = (byte) ((bitWorkArea >> 2) & MASK_8BITS);\n-                    break;\n-                case 3 : // 15 bits, drop 7 and output 1 byte\n-                    buffer[pos++] = (byte) ((bitWorkArea >> 7) & MASK_8BITS);\n-                    break;\n-                case 4 : // 20 bits = 2*8 + 4\n-                    bitWorkArea = bitWorkArea >> 4; // drop 4 bits\n-                    buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);\n-                    buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);\n-                    break;\n-                case 5 : // 25bits = 3*8 + 1\n-                    bitWorkArea = bitWorkArea >> 1;\n-                    buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);\n-                    buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);\n-                    buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);\n-                    break;\n-                case 6 : // 30bits = 3*8 + 6\n-                    bitWorkArea = bitWorkArea >> 6;\n-                    buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);\n-                    buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);\n-                    buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);\n-                    break;\n-                case 7 : // 35 = 4*8 +3\n-                    bitWorkArea = bitWorkArea >> 3;\n-                    buffer[pos++] = (byte) ((bitWorkArea >> 24) & MASK_8BITS);\n-                    buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);\n-                    buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);\n-                    buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);\n-                    break;\n-            }\n-        }\n+     * Returns whether or not the <code>octet</code> is in the Base32 alphabet.\n+     * \n+     * @param octet\n+     *            The value to test\n+     * @return <code>true</code> if the value is defined in the the Base32 alphabet <code>false</code> otherwise.\n+     */\n+    public boolean isInAlphabet(byte octet) {\n+        return (octet >= 0 && octet < decodeTable.length && decodeTable[octet] != -1);\n     }\n }", "timestamp": 1296236419, "metainfo": ""}