{"sha": "93333139710428b579e9b9bfb22a431028df4feb", "log": "[CODEC-58] Character set used by Base64 not documented. Apply modified patch. Better Javadocs. Changes to private field \"buf\" rename to \"buffer\". Rename private method \"resizeBuf\" to \"resizeBuffer\"  ", "commit": "\n--- a/src/java/org/apache/commons/codec/binary/Base64.java\n+++ b/src/java/org/apache/commons/codec/binary/Base64.java\n  * This class implements section <cite>6.8. Base64 Content-Transfer-Encoding</cite> from RFC 2045 <cite>Multipurpose\n  * Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies</cite> by Freed and Borenstein.\n  * </p>\n+ * <p>\n+ * The class can be parameterized in the following manner with various constructors:\n+ * <ul>\n+ * <li>URL-safe mode: Default off.</li>\n+ * <li>Line length: Default 76. Line length that aren't multiples of 4 will still essentially end up being multiples of 4 in the\n+ * encoded data. \n+ * <li>Line separator: Default is CRLF (\"\\r\\n\")</li>\n+ * </ul>\n+ * </p>\n+ * <p>\n+ * Since this class operates directly on byte streams, and not character streams, it is hard-coded to only encode/decode\n+ * character encodings which are compatible with the lower 127 ASCII chart (ISO-8859-1, Windows-1252, UTF-8, etc).\n+ * </p>\n  * \n  * @see <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045</a>\n  * @author Apache Software Foundation\n  * @version $Id$\n  */\n public class Base64 implements BinaryEncoder, BinaryDecoder {\n+    private static final int DEFAULT_BUFFER_RESIZE_FACTOR = 2;\n+\n+    private static final int DEFAULT_BUFFER_SIZE = 8192;\n+\n     /**\n      * Chunk size per RFC 2045 section 6.8.\n      * \n      * \n      * @see <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045 section 2.1</a>\n      */\n-    static final byte[] CHUNK_SEPARATOR = {'\\r','\\n'};\n+    static final byte[] CHUNK_SEPARATOR = {'\\r', '\\n'};\n \n     /**\n      * This array is a lookup table that translates 6-bit positive integer\n     // some state be preserved between calls of encode() and decode().\n \n     /**\n-     * Encode table to use:  either STANDARD or URL_SAFE.  Note:  the DECODE_TABLE above remains static\n-     * because it is able to decode both STANDARD and URL_SAFE streams, but the encodeTable must be a member\n-     * variable so we can switch between the two modes.\n+     * Encode table to use: either STANDARD or URL_SAFE. Note: the DECODE_TABLE above remains static because it is able\n+     * to decode both STANDARD and URL_SAFE streams, but the encodeTable must be a member variable so we can switch\n+     * between the two modes.\n      */\n     private final byte[] encodeTable;\n \n     /**\n-     * Line length for encoding.  Not used when decoding.  A value of zero or less implies\n-     * no chunking of the base64 encoded data.\n+     * Line length for encoding. Not used when decoding. A value of zero or less implies no chunking of the base64\n+     * encoded data.\n      */\n     private final int lineLength;\n \n     /**\n-     * Line separator for encoding.  Not used when decoding.  Only used if lineLength > 0.\n+     * Line separator for encoding. Not used when decoding. Only used if lineLength > 0.\n      */\n     private final byte[] lineSeparator;\n \n     /**\n-     * Convenience variable to help us determine when our buffer is going to run out of\n-     * room and needs resizing.  <code>decodeSize = 3 + lineSeparator.length;</code>\n+     * Convenience variable to help us determine when our buffer is going to run out of room and needs resizing.\n+     * <code>decodeSize = 3 + lineSeparator.length;</code>\n      */\n     private final int decodeSize;\n \n     /**\n-     * Convenience variable to help us determine when our buffer is going to run out of\n-     * room and needs resizing.  <code>encodeSize = 4 + lineSeparator.length;</code>\n+     * Convenience variable to help us determine when our buffer is going to run out of room and needs resizing.\n+     * <code>encodeSize = 4 + lineSeparator.length;</code>\n      */\n     private final int encodeSize;\n \n     /**\n-     * Buffer for streaming. \n-     */\n-    private byte[] buf;\n+     * Buffer for streaming.\n+     */\n+    private byte[] buffer;\n \n     /**\n      * Position where next character should be written in the buffer.\n     private int readPos;\n \n     /**\n-     * Variable tracks how many characters have been written to the current line.\n-     * Only used when encoding.  We use it to make sure each encoded line never\n-     * goes beyond lineLength (if lineLength > 0).\n+     * Variable tracks how many characters have been written to the current line. Only used when encoding. We use it to\n+     * make sure each encoded line never goes beyond lineLength (if lineLength > 0).\n      */\n     private int currentLinePos;\n \n     /**\n-     * Writes to the buffer only occur after every 3 reads when encoding, an\n-     * every 4 reads when decoding.  This variable helps track that.\n+     * Writes to the buffer only occur after every 3 reads when encoding, an every 4 reads when decoding. This variable\n+     * helps track that.\n      */\n     private int modulus;\n \n     /**\n-     * Boolean flag to indicate the EOF has been reached.  Once EOF has been\n-     * reached, this Base64 object becomes useless, and must be thrown away.\n+     * Boolean flag to indicate the EOF has been reached. Once EOF has been reached, this Base64 object becomes useless,\n+     * and must be thrown away.\n      */\n     private boolean eof;\n \n     /**\n-     * Place holder for the 3 bytes we're dealing with for our base64 logic.\n-     * Bitwise operations store and extract the base64 encoding or decoding from\n-     * this variable.\n+     * Place holder for the 3 bytes we're dealing with for our base64 logic. Bitwise operations store and extract the\n+     * base64 encoding or decoding from this variable.\n      */\n     private int x;\n \n     /**\n-     * Sets state for decoding and encoding.\n-     * <p>\n-     * When encoding the line length is 76, the line separator is CRLF, and we use the STANDARD_ENCODE_TABLE.\n-     * </p>\n-     * \n-     * <p>\n-     * When decoding all variants can be decoded.\n+     * Creates a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.\n+     * <p>\n+     * When encoding the line length is 76, the line separator is CRLF, and the encoding table is STANDARD_ENCODE_TABLE.\n+     * </p>\n+     * \n+     * <p>\n+     * When decoding all variants are supported.\n      * </p>\n      */\n     public Base64() {\n     }\n \n     /**\n-     * Same as default constructor (line length is 76, line separator is CRLF), but URL-SAFE mode for encoding is\n-     * supplied.\n-     * \n-     * When decoding: all variants can be decoded.\n+     * Creates a Base64 codec used for decoding (all modes) and encoding in the given URL-safe mode.\n+     * <p>\n+     * When encoding the line length is 76, the line separator is CRLF, and the encoding table is STANDARD_ENCODE_TABLE.\n+     * </p>\n+     * \n+     * <p>\n+     * When decoding all variants are supported.\n+     * </p>\n      * \n      * @param urlSafe\n-     *            true if URL-SAFE encoding should be performed. In most situations this should be set to false.\n+     *            if <code>true</code>, URL-safe encoding is used. In most cases this should be set to <code>false</code>.\n      * @since 1.4\n      */\n     public Base64(boolean urlSafe) {\n     }\n \n     /**\n-     * <p>\n-     * Sets the line length when encoding (line separator is still CRLF). All forms of data can be decoded.\n-     * </p>\n-     * <p>\n-     * Note: line lengths that aren't multiples of 4 will still essentially end up being multiples of 4 in the encoded\n-     * data.\n+     * Creates a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.\n+     * <p>\n+     * When encoding the line length is given in the constructor, the line separator is CRLF, and the encoding table is\n+     * STANDARD_ENCODE_TABLE.\n+     * </p>\n+     * <p>\n+     * Line lengths that aren't multiples of 4 will still essentially end up being multiples of 4 in the encoded data.\n+     * </p>\n+     * <p>\n+     * When decoding all variants are supported.\n      * </p>\n      * \n      * @param lineLength\n-     *            each line of encoded data will be at most this long (rounded up to nearest multiple of 4). If\n-     *            lineLength <= 0, then the output will not be divided into lines (chunks). Ignored when decoding.\n+     *            Each line of encoded data will be at most of the given length (rounded up to nearest multiple of 4).\n+     *            If lineLength <= 0, then the output will not be divided into lines (chunks). Ignored when decoding.\n      * @since 1.4\n      */\n     public Base64(int lineLength) {\n     }\n \n     /**\n-     * <p>\n-     * Sets the line length and line separator when encoding. All forms of data can be decoded.\n-     * </p>\n-     * <p>\n-     * Note: line lengths that aren't multiples of 4 will still essentially end up being multiples of 4 in the encoded\n-     * data.\n+     * Creates a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.\n+     * <p>\n+     * When encoding the line length and line separator are given in the constructor, and the encoding table is\n+     * STANDARD_ENCODE_TABLE.\n+     * </p>\n+     * <p>\n+     * Line lengths that aren't multiples of 4 will still essentially end up being multiples of 4 in the encoded data.\n+     * </p>\n+     * <p>\n+     * When decoding all variants are supported.\n      * </p>\n      * \n      * @param lineLength\n-     *            Each line of encoded data will be at most this long (rounded up to nearest multiple of 4). Ignored\n-     *            when decoding. If <= 0, then output will not be divided into lines (chunks).\n+     *            Each line of encoded data will be at most of the given length (rounded up to nearest multiple of 4).\n+     *            If lineLength <= 0, then the output will not be divided into lines (chunks). Ignored when decoding.\n      * @param lineSeparator\n      *            Each line of encoded data will end with this sequence of bytes.\n      * @throws IllegalArgumentException\n-     *             The provided lineSeparator included some base64 characters. That's not going to work!\n+     *             Thrown when the provided lineSeparator included some base64 characters. \n      * @since 1.4\n      */\n     public Base64(int lineLength, byte[] lineSeparator) {\n     }\n \n     /**\n-     * <p>\n-     * Consumer can use this constructor to choose a different lineLength,\n-     * lineSeparator, and whether to use URL-SAFE mode when encoding.\n-     * All forms of data can be decoded.\n-     * </p><p>\n-     * Note:  lineLengths that aren't multiples of 4 will still essentially\n-     * end up being multiples of 4 in the encoded data.\n-     * </p>\n-     * @param lineLength    Each line of encoded data will be at most this long\n-     *                      (rounded up to nearest multiple of 4).  Ignored when decoding.\n-     *                      If <= 0, then output will not be divided into lines (chunks).\n-     * @param lineSeparator Each line of encoded data will end with this\n-     *                      sequence of bytes.\n-     *                      If lineLength <= 0, then the lineSeparator is not used.\n-     * @param urlSafe       Instead of emitting '+' and '/' we emit '-' and '_' respectively.\n-     *                      urlSafe is only applied to \"encode\" operations.  Decoding seamlessly\n-     *                      handles both modes.\n-     *\n-     * @throws IllegalArgumentException The provided lineSeparator included\n-     *                                  some base64 characters.  That's not going to work!\n+     * Creates a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.\n+     * <p>\n+     * When encoding the line length and line separator are given in the constructor, and the encoding table is\n+     * STANDARD_ENCODE_TABLE.\n+     * </p>\n+     * <p>\n+     * Line lengths that aren't multiples of 4 will still essentially end up being multiples of 4 in the encoded data.\n+     * </p>\n+     * <p>\n+     * When decoding all variants are supported.\n+     * </p>\n+     * \n+     * @param lineLength\n+     *            Each line of encoded data will be at most of the given length (rounded up to nearest multiple of 4).\n+     *            If lineLength <= 0, then the output will not be divided into lines (chunks). Ignored when decoding.\n+     * @param lineSeparator\n+     *            Each line of encoded data will end with this sequence of bytes.\n+     * @param urlSafe\n+     *            Instead of emitting '+' and '/' we emit '-' and '_' respectively. urlSafe is only applied to encode\n+     *            operations. Decoding seamlessly handles both modes.\n+     * @throws IllegalArgumentException\n+     *             The provided lineSeparator included some base64 characters. That's not going to work!\n      * @since 1.4\n      */\n     public Base64(int lineLength, byte[] lineSeparator, boolean urlSafe) {\n      * @return true if there is Base64 object still available for reading.\n      */\n     boolean hasData() {\n-        return this.buf != null;\n+        return this.buffer != null;\n     }\n \n     /**\n      * @return The amount of buffered data available for reading.\n      */\n     int avail() {\n-        return buf != null ? pos - readPos : 0;\n+        return buffer != null ? pos - readPos : 0;\n     }\n \n     /** Doubles our buffer. */\n-    private void resizeBuf() {\n-        if (buf == null) {\n-            buf = new byte[8192];\n+    private void resizeBuffer() {\n+        if (buffer == null) {\n+            buffer = new byte[DEFAULT_BUFFER_SIZE];\n             pos = 0;\n             readPos = 0;\n         } else {\n-            byte[] b = new byte[buf.length * 2];\n-            System.arraycopy(buf, 0, b, 0, buf.length);\n-            buf = b;\n-        }\n-    }\n-\n-    /**\n-     * Extracts buffered data into the provided byte[] array, starting\n-     * at position bPos, up to a maximum of bAvail bytes.  Returns how\n-     * many bytes were actually extracted.\n-     *\n-     * @param b      byte[] array to extract the buffered data into.\n-     * @param bPos   position in byte[] array to start extraction at.\n-     * @param bAvail amount of bytes we're allowed to extract.  We may extract\n-     *               fewer (if fewer are available).\n-     * @return The number of bytes successfully extracted into the provided\n-     *         byte[] array.\n+            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];\n+            System.arraycopy(buffer, 0, b, 0, buffer.length);\n+            buffer = b;\n+        }\n+    }\n+\n+    /**\n+     * Extracts buffered data into the provided byte[] array, starting at position bPos, up to a maximum of bAvail\n+     * bytes. Returns how many bytes were actually extracted.\n+     * \n+     * @param b\n+     *            byte[] array to extract the buffered data into.\n+     * @param bPos\n+     *            position in byte[] array to start extraction at.\n+     * @param bAvail\n+     *            amount of bytes we're allowed to extract. We may extract fewer (if fewer are available).\n+     * @return The number of bytes successfully extracted into the provided byte[] array.\n      */\n     int readResults(byte[] b, int bPos, int bAvail) {\n-        if (buf != null) {\n+        if (buffer != null) {\n             int len = Math.min(avail(), bAvail);\n-            if (buf != b) {\n-                System.arraycopy(buf, readPos, b, bPos, len);\n+            if (buffer != b) {\n+                System.arraycopy(buffer, readPos, b, bPos, len);\n                 readPos += len;\n                 if (readPos >= pos) {\n-                    buf = null;\n+                    buffer = null;\n                 }\n             } else {\n                 // Re-using the original consumer's output array is only\n                 // allowed for one round.\n-                buf = null;\n+                buffer = null;\n             }\n             return len;\n         }\n      * Sets the streaming buffer. This is a small optimization where we try to buffer directly to the consumer's output\n      * array for one round (if the consumer calls this method first) instead of starting our own buffer.\n      * \n-     * @param out byte[] array to buffer directly to.\n-     * @param outPos Position to start buffering into.\n-     * @param outAvail Amount of bytes available for direct buffering.\n+     * @param out\n+     *            byte[] array to buffer directly to.\n+     * @param outPos\n+     *            Position to start buffering into.\n+     * @param outAvail\n+     *            Amount of bytes available for direct buffering.\n      */\n     void setInitialBuffer(byte[] out, int outPos, int outAvail) {\n         // We can re-use consumer's original output array under\n         // special circumstances, saving on some System.arraycopy().\n         if (out != null && out.length == outAvail) {\n-            buf = out;\n+            buffer = out;\n             pos = outPos;\n             readPos = outPos;\n         }\n \n     /**\n      * <p>\n-     * Encodes all of the provided data, starting at inPos, for inAvail bytes.\n-     * Must be called at least twice:  once with the data to encode, and once\n-     * with inAvail set to \"-1\" to alert encoder that EOF has been reached,\n-     * so flush last remaining bytes (if not multiple of 3).\n-     * </p><p>\n-     * Thanks to \"commons\" project in ws.apache.org for the bitwise operations,\n-     * and general approach.\n+     * Encodes all of the provided data, starting at inPos, for inAvail bytes. Must be called at least twice: once with\n+     * the data to encode, and once with inAvail set to \"-1\" to alert encoder that EOF has been reached, so flush last\n+     * remaining bytes (if not multiple of 3).\n+     * </p>\n+     * <p>\n+     * Thanks to \"commons\" project in ws.apache.org for the bitwise operations, and general approach.\n      * http://svn.apache.org/repos/asf/webservices/commons/trunk/modules/util/\n      * </p>\n-     *\n-     * @param in byte[] array of binary data to base64 encode.\n-     * @param inPos Position to start reading data from.\n-     * @param inAvail Amount of bytes available from input for encoding.\n+     * \n+     * @param in\n+     *            byte[] array of binary data to base64 encode.\n+     * @param inPos\n+     *            Position to start reading data from.\n+     * @param inAvail\n+     *            Amount of bytes available from input for encoding.\n      */\n     void encode(byte[] in, int inPos, int inAvail) {\n         if (eof) {\n         // encoding.\n         if (inAvail < 0) {\n             eof = true;\n-            if (buf == null || buf.length - pos < encodeSize) {\n-                resizeBuf();\n+            if (buffer == null || buffer.length - pos < encodeSize) {\n+                resizeBuffer();\n             }\n             switch (modulus) {\n-                case 1:\n-                    buf[pos++] = encodeTable[(x >> 2) & MASK_6BITS];\n-                    buf[pos++] = encodeTable[(x << 4) & MASK_6BITS];\n+                case 1 :\n+                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];\n+                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];\n                     // URL-SAFE skips the padding to further reduce size.\n                     if (encodeTable == STANDARD_ENCODE_TABLE) {\n-                        buf[pos++] = PAD;\n-                        buf[pos++] = PAD;\n+                        buffer[pos++] = PAD;\n+                        buffer[pos++] = PAD;\n                     }\n                     break;\n \n-                case 2:\n-                    buf[pos++] = encodeTable[(x >> 10) & MASK_6BITS];\n-                    buf[pos++] = encodeTable[(x >> 4) & MASK_6BITS];\n-                    buf[pos++] = encodeTable[(x << 2) & MASK_6BITS];\n+                case 2 :\n+                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];\n+                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];\n+                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];\n                     // URL-SAFE skips the padding to further reduce size.\n                     if (encodeTable == STANDARD_ENCODE_TABLE) {\n-                        buf[pos++] = PAD;\n+                        buffer[pos++] = PAD;\n                     }\n                     break;\n             }\n             if (lineLength > 0 && pos > 0) {\n-                System.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length);\n+                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);\n                 pos += lineSeparator.length;\n             }\n         } else {\n             for (int i = 0; i < inAvail; i++) {\n-                if (buf == null || buf.length - pos < encodeSize) {\n-                    resizeBuf();\n+                if (buffer == null || buffer.length - pos < encodeSize) {\n+                    resizeBuffer();\n                 }\n                 modulus = (++modulus) % 3;\n                 int b = in[inPos++];\n-                if (b < 0) { b += 256; }\n+                if (b < 0) {\n+                    b += 256;\n+                }\n                 x = (x << 8) + b;\n                 if (0 == modulus) {\n-                    buf[pos++] = encodeTable[(x >> 18) & MASK_6BITS];\n-                    buf[pos++] = encodeTable[(x >> 12) & MASK_6BITS];\n-                    buf[pos++] = encodeTable[(x >> 6) & MASK_6BITS];\n-                    buf[pos++] = encodeTable[x & MASK_6BITS];\n+                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];\n+                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];\n+                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];\n+                    buffer[pos++] = encodeTable[x & MASK_6BITS];\n                     currentLinePos += 4;\n                     if (lineLength > 0 && lineLength <= currentLinePos) {\n-                        System.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length);\n+                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);\n                         pos += lineSeparator.length;\n                         currentLinePos = 0;\n                     }\n \n     /**\n      * <p>\n-     * Decodes all of the provided data, starting at inPos, for inAvail bytes.\n-     * Should be called at least twice:  once with the data to decode, and once\n-     * with inAvail set to \"-1\" to alert decoder that EOF has been reached.\n-     * The \"-1\" call is not necessary when decoding, but it doesn't hurt, either.\n-     * </p><p>\n-     * Ignores all non-base64 characters.  This is how chunked (e.g. 76 character)\n-     * data is handled, since CR and LF are silently ignored, but has implications\n-     * for other bytes, too.  This method subscribes to the garbage-in, garbage-out\n-     * philosophy:  it will not check the provided data for validity.\n-     * </p><p>\n-     * Thanks to \"commons\" project in ws.apache.org for the bitwise operations,\n-     * and general approach.\n+     * Decodes all of the provided data, starting at inPos, for inAvail bytes. Should be called at least twice: once\n+     * with the data to decode, and once with inAvail set to \"-1\" to alert decoder that EOF has been reached. The \"-1\"\n+     * call is not necessary when decoding, but it doesn't hurt, either.\n+     * </p>\n+     * <p>\n+     * Ignores all non-base64 characters. This is how chunked (e.g. 76 character) data is handled, since CR and LF are\n+     * silently ignored, but has implications for other bytes, too. This method subscribes to the garbage-in,\n+     * garbage-out philosophy: it will not check the provided data for validity.\n+     * </p>\n+     * <p>\n+     * Thanks to \"commons\" project in ws.apache.org for the bitwise operations, and general approach.\n      * http://svn.apache.org/repos/asf/webservices/commons/trunk/modules/util/\n      * </p>\n-\n-     * @param in byte[] array of ascii data to base64 decode.\n-     * @param inPos Position to start reading data from.\n-     * @param inAvail Amount of bytes available from input for encoding.\n-     */    \n+     * \n+     * @param in\n+     *            byte[] array of ascii data to base64 decode.\n+     * @param inPos\n+     *            Position to start reading data from.\n+     * @param inAvail\n+     *            Amount of bytes available from input for encoding.\n+     */\n     void decode(byte[] in, int inPos, int inAvail) {\n         if (eof) {\n             return;\n             eof = true;\n         }\n         for (int i = 0; i < inAvail; i++) {\n-            if (buf == null || buf.length - pos < decodeSize) {\n-                resizeBuf();\n+            if (buffer == null || buffer.length - pos < decodeSize) {\n+                resizeBuffer();\n             }\n             byte b = in[inPos++];\n             if (b == PAD) {\n                         modulus = (++modulus) % 4;\n                         x = (x << 6) + result;\n                         if (modulus == 0) {\n-                            buf[pos++] = (byte) ((x >> 16) & MASK_8BITS);\n-                            buf[pos++] = (byte) ((x >> 8) & MASK_8BITS);\n-                            buf[pos++] = (byte) (x & MASK_8BITS);\n+                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);\n+                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);\n+                            buffer[pos++] = (byte) (x & MASK_8BITS);\n                         }\n                     }\n                 }\n             }\n         }\n \n-        // Two forms of EOF as far as base64 decoder is concerned:  actual\n+        // Two forms of EOF as far as base64 decoder is concerned: actual\n         // EOF (-1) and first time '=' character is encountered in stream.\n         // This approach makes the '=' padding characters completely optional.\n         if (eof && modulus != 0) {\n             x = x << 6;\n             switch (modulus) {\n-                case 2:\n+                case 2 :\n                     x = x << 6;\n-                    buf[pos++] = (byte) ((x >> 16) & MASK_8BITS);\n+                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);\n                     break;\n-                case 3:\n-                    buf[pos++] = (byte) ((x >> 16) & MASK_8BITS);\n-                    buf[pos++] = (byte) ((x >> 8) & MASK_8BITS);\n+                case 3 :\n+                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);\n+                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);\n                     break;\n             }\n         }\n     }\n \n     /**\n-     * Tests a given byte array to see if it contains only valid characters within the Base64 alphabet.\n-     * Currently the method treats whitespace as valid.\n+     * Tests a given byte array to see if it contains only valid characters within the Base64 alphabet. Currently the\n+     * method treats whitespace as valid.\n      * \n      * @param arrayOctet\n      *            byte array to test\n-     * @return <code>true</code> if all bytes are valid characters in the Base64 alphabet or if the byte array is\n-     *         empty; false, otherwise\n+     * @return <code>true</code> if all bytes are valid characters in the Base64 alphabet or if the byte array is empty;\n+     *         false, otherwise\n      */\n     public static boolean isArrayByteBase64(byte[] arrayOctet) {\n         for (int i = 0; i < arrayOctet.length; i++) {\n     }\n \n     /**\n-     * Encodes binary data using a url-safe variation of the base64 algorithm but does not chunk the output.\n-     * The url-safe variation emits - and _ instead of + and / characters.\n-     *\n+     * Encodes binary data using a URL-safe variation of the base64 algorithm but does not chunk the output. The\n+     * url-safe variation emits - and _ instead of + and / characters.\n+     * \n      * @param binaryData\n      *            binary data to encode\n      * @return Base64 characters\n     public static byte[] encodeBase64URLSafe(byte[] binaryData) {\n         return encodeBase64(binaryData, false, true);\n     }\n-    \n \n     /**\n      * Encodes binary data using the base64 algorithm and chunks the encoded output into 76 character blocks\n \n     /**\n      * Encodes binary data using the base64 algorithm, optionally chunking the output into 76 character blocks.\n-     *\n+     * \n      * @param binaryData\n      *            Array containing binary data to encode.\n      * @param isChunked\n             len += (1 + (len / CHUNK_SIZE)) * CHUNK_SEPARATOR.length;\n         }\n         if (len > Integer.MAX_VALUE) {\n-            throw new IllegalArgumentException(\n-                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n+            throw new IllegalArgumentException(\"Input array too big, output array would be bigger than Integer.MAX_VALUE=\"\n+                + Integer.MAX_VALUE);\n         }\n         byte[] buf = new byte[(int) len];\n         b64.setInitialBuffer(buf, 0, buf.length);\n         b64.encode(binaryData, 0, binaryData.length);\n         b64.encode(binaryData, 0, -1); // Notify encoder of EOF.\n         // Encoder might have resized, even though it was unnecessary.\n-        if (b64.buf != buf) {\n+        if (b64.buffer != buf) {\n             b64.readResults(buf, 0, buf.length);\n         }\n         // In URL-SAFE mode we skip the padding characters, so sometimes our\n \n     /**\n      * Decodes Base64 data into octets\n-     *\n-     * @param base64Data Byte array containing Base64 data\n+     * \n+     * @param base64Data\n+     *            Byte array containing Base64 data\n      * @return Array containing decoded data.\n      */\n     public static byte[] decodeBase64(byte[] base64Data) {\n         return packedData;\n     }\n \n-\n     /**\n      * Checks if a byte value is whitespace or not.\n      * \n         }\n     }\n \n-\n     // Implementation of the Encoder Interface\n \n     /**\n \n     // Implementation of integer encoding used for crypto\n     /**\n-     * Decodes a byte64-encoded integer according to crypto\n-     * standards such as W3C's XML-Signature\n-     * \n-     * @param pArray a byte array containing base64 character data\n+     * Decodes a byte64-encoded integer according to crypto standards such as W3C's XML-Signature\n+     * \n+     * @param pArray\n+     *            a byte array containing base64 character data\n      * @return A BigInteger\n      * @since 1.4\n      */\n     }\n \n     /**\n-     * Encodes to a byte64-encoded integer according to crypto\n-     * standards such as W3C's XML-Signature\n-     * \n-     * @param bigInt a BigInteger\n+     * Encodes to a byte64-encoded integer according to crypto standards such as W3C's XML-Signature\n+     * \n+     * @param bigInt\n+     *            a BigInteger\n      * @return A byte array containing base64 character data\n-     * @throws NullPointerException if null is passed in\n+     * @throws NullPointerException\n+     *             if null is passed in\n      * @since 1.4\n      */\n     public static byte[] encodeInteger(BigInteger bigInt) {\n-        if(bigInt == null)  {\n+        if (bigInt == null) {\n             throw new NullPointerException(\"encodeInteger called with null parameter\");\n         }\n         return encodeBase64(toIntegerBytes(bigInt), false);\n     }\n \n     /**\n-     * Returns a byte-array representation of a <code>BigInteger</code>\n-     * without sign bit.\n-     *\n-     * @param bigInt <code>BigInteger</code> to be converted\n+     * Returns a byte-array representation of a <code>BigInteger</code> without sign bit.\n+     * \n+     * @param bigInt\n+     *            <code>BigInteger</code> to be converted\n      * @return a byte array representation of the BigInteger parameter\n      */\n-     static byte[] toIntegerBytes(BigInteger bigInt) {\n+    static byte[] toIntegerBytes(BigInteger bigInt) {\n         int bitlen = bigInt.bitLength();\n         // round bitlen\n         bitlen = ((bitlen + 7) >> 3) << 3;\n         byte[] bigBytes = bigInt.toByteArray();\n \n-        if(((bigInt.bitLength() % 8) != 0) &&\n-            (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {\n+        if (((bigInt.bitLength() % 8) != 0) && (((bigInt.bitLength() / 8) + 1) == (bitlen / 8))) {\n             return bigBytes;\n         }\n         // set up params for copying everything but sign bit\n         int len = bigBytes.length;\n \n         // if bigInt is exactly byte-aligned, just skip signbit in copy\n-        if((bigInt.bitLength() % 8) == 0) {\n+        if ((bigInt.bitLength() % 8) == 0) {\n             startSrc = 1;\n             len--;\n         }\n--- a/src/java/org/apache/commons/codec/binary/Base64InputStream.java\n+++ b/src/java/org/apache/commons/codec/binary/Base64InputStream.java\n  * </p><p>\n  * This class implements section <cite>6.8. Base64 Content-Transfer-Encoding</cite> from RFC 2045 <cite>Multipurpose\n  * Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies</cite> by Freed and Borenstein.\n+ * </p><p>\n+ * Since this class operates directly on byte streams, and not character streams, it is hard-coded to only encode/decode\n+ * character encodings which are compatible with the lower 127 ASCII chart (ISO-8859-1, Windows-1252, UTF-8, etc). \n  * </p>\n- *\n  * @author Apache Software Foundation\n  * @version $Id $\n  * @see <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045</a>\n--- a/src/java/org/apache/commons/codec/binary/Base64OutputStream.java\n+++ b/src/java/org/apache/commons/codec/binary/Base64OutputStream.java\n  * </p><p>\n  * This class implements section <cite>6.8. Base64 Content-Transfer-Encoding</cite> from RFC 2045 <cite>Multipurpose\n  * Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies</cite> by Freed and Borenstein.\n- * </p>\n- *\n+ * </p><p>\n+ * Since this class operates directly on byte streams, and not character streams, it is hard-coded to only encode/decode\n+ * character encodings which are compatible with the lower 127 ASCII chart (ISO-8859-1, Windows-1252, UTF-8, etc).\n+ * </p> \n  * @author Apache Software Foundation\n  * @version $Id $\n  * @see <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045</a>", "timestamp": 1247877403, "metainfo": ""}