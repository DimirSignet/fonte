{"sha": "c86b5e26e0b9195f4928741b5b7dcd3d857f4de5", "log": "FindBugs detected potential calculation overflow  ", "commit": "\n--- a/src/java/org/apache/commons/codec/binary/BaseNCodec.java\n+++ b/src/java/org/apache/commons/codec/binary/BaseNCodec.java\n import org.apache.commons.codec.DecoderException;\n import org.apache.commons.codec.EncoderException;\n \n+/**\n+ * Implements common Base-N codec functions.\n+ * \n+ * This class is not thread-safe.\n+ * Each thread should use its own instance.\n+ */\n public abstract class BaseNCodec implements BinaryEncoder, BinaryDecoder {\n \n     /**\n      *\n      * @param pArray byte[] array which will later be encoded\n      *\n-     * @return amount of space needed to encoded the supplied array.  Returns\n-     *         a long since a max-len array will require > Integer.MAX_VALUE\n+     * @return amount of space needed to encoded the supplied array.  \n+     * Returns a long since a max-len array will require > Integer.MAX_VALUE\n      */\n     public long getEncodedLength(byte[] pArray) {\n         // Calculate non-chunked size - rounded up to allow for padding\n-        long len = ((pArray.length + unencodedBlockSize-1)  / unencodedBlockSize) * encodedBlockSize;\n+        // cast to long is needed to avoid possibility of overflow\n+        long len = ((pArray.length + unencodedBlockSize-1)  / unencodedBlockSize) * (long) encodedBlockSize;\n         if (lineLength > 0) { // We're using chunking\n             // Round up to nearest multiple\n             len += ((len + lineLength-1) / lineLength) * chunkSeparatorLength;", "timestamp": 1296159790, "metainfo": ""}