{"sha": "59c42b102e5396b2ebd4541ed9007f385a00c357", "log": "SOme basic Base32 I/O tests  ", "commit": "\n--- /dev/null\n+++ b/src/test/org/apache/commons/codec/binary/Base32InputStreamTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.codec.binary;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.Arrays;\n+\n+import junit.framework.TestCase;\n+\n+public class Base32InputStreamTest extends TestCase {\n+\n+    private final static byte[] CRLF = {(byte) '\\r', (byte) '\\n'};\n+\n+    private final static byte[] LF = {(byte) '\\n'};\n+\n+    /**\n+     * Construct a new instance of this test case.\n+     * \n+     * @param name\n+     *            Name of the test case\n+     */\n+    public Base32InputStreamTest(String name) {\n+        super(name);\n+    }\n+\n+    /**\n+     * Tests the bug reported in CODEC-105. Bad interactions with InputStream when reading one byte at a time.\n+     */\n+    public void testCodec105() throws IOException {\n+        Base32InputStream in = new Base32InputStream(new Codec105ErrorInputStream(), true, 0, null);\n+        for (int i = 0; i < 5; i++) {\n+            in.read();\n+        }\n+    }\n+\n+//    /**\n+//     * Test for the CODEC-101 bug:  InputStream.read(byte[]) should never return 0\n+//     * because Java's builtin InputStreamReader hates that.\n+//     *\n+//     * @throws Exception for some failure scenarios.\n+//     */\n+//    public void testCodec101() throws Exception {\n+//        byte[] codec101 = StringUtils.getBytesUtf8(Base32TestData.CODEC_101_MULTIPLE_OF_3);\n+//        ByteArrayInputStream bais = new ByteArrayInputStream(codec101);\n+//        Base32InputStream in = new Base32InputStream(bais);\n+//        byte[] result = new byte[8192];\n+//        int c = in.read(result);\n+//        assertTrue(\"Codec101: First read successful [c=\" + c + \"]\", c > 0);\n+//\n+//        c = in.read(result);\n+//        assertTrue(\"Codec101: Second read should report end-of-stream [c=\" + c + \"]\", c < 0);\n+//    }\n+\n+    /**\n+     * Another test for the CODEC-101 bug:\n+     * In commons-codec-1.4 this test shows InputStreamReader explicitly hating an\n+     * InputStream.read(byte[]) return of 0:\n+     *\n+     * java.io.IOException: Underlying input stream returned zero bytes\n+     * at sun.nio.cs.StreamDecoder.readBytes(StreamDecoder.java:268)\n+     * at sun.nio.cs.StreamDecoder.implRead(StreamDecoder.java:306)\n+     * at sun.nio.cs.StreamDecoder.read(StreamDecoder.java:158)\n+     * at java.io.InputStreamReader.read(InputStreamReader.java:167)\n+     * at java.io.BufferedReader.fill(BufferedReader.java:136)\n+     * at java.io.BufferedReader.readLine(BufferedReader.java:299)\n+     * at java.io.BufferedReader.readLine(BufferedReader.java:362)\n+     * at org.apache.commons.codec.binary.Base32InputStreamTest.testInputStreamReader(Base32InputStreamTest.java:75)\n+     *\n+     * But in commons-codec-1.5 it's fixed.  :-)\n+     *\n+     * @throws Exception for some failure scenarios.\n+     */\n+//    public void testInputStreamReader() throws Exception {\n+//        byte[] codec101 = StringUtils.getBytesUtf8(Base32TestData.CODEC_101_MULTIPLE_OF_3);\n+//        ByteArrayInputStream bais = new ByteArrayInputStream(codec101);\n+//        Base32InputStream in = new Base32InputStream(bais);\n+//        InputStreamReader isr = new InputStreamReader(in);\n+//        BufferedReader br = new BufferedReader(isr);\n+//        String line = br.readLine();\n+//        assertNotNull(\"Codec101:  InputStreamReader works!\", line);\n+//    }\n+\n+    /**\n+     * Test the Base32InputStream implementation against the special NPE inducing input\n+     * identified in the CODEC-98 bug.\n+     *\n+     * @throws Exception for some failure scenarios.\n+     */\n+//    public void testCodec98NPE() throws Exception {\n+//        byte[] codec98 = StringUtils.getBytesUtf8(Base32TestData.CODEC_98_NPE);\n+//        ByteArrayInputStream data = new ByteArrayInputStream(codec98);\n+//        Base32InputStream stream = new Base32InputStream(data);\n+//\n+//        // This line causes an NPE in commons-codec-1.4.jar:\n+//        byte[] decodedBytes = Base32TestData.streamToBytes(stream, new byte[1024]);\n+//\n+//        String decoded = StringUtils.newStringUtf8(decodedBytes);\n+//        assertEquals(\n+//            \"codec-98 NPE Base32InputStream\", Base32TestData.CODEC_98_NPE_DECODED, decoded\n+//        );\n+//    }\n+\n+    /**\n+     * Tests the Base32InputStream implementation against empty input.\n+     * \n+     * @throws Exception\n+     *             for some failure scenarios.\n+     */\n+    public void testBase32EmptyInputStreamMimeChuckSize() throws Exception {\n+        testBase32EmptyInputStream(Base32.MIME_CHUNK_SIZE);\n+    }\n+\n+    /**\n+     * Tests the Base32InputStream implementation against empty input.\n+     * \n+     * @throws Exception\n+     *             for some failure scenarios.\n+     */\n+    public void testBase32EmptyInputStreamPemChuckSize() throws Exception {\n+        testBase32EmptyInputStream(Base32.PEM_CHUNK_SIZE);\n+    }\n+\n+    private void testBase32EmptyInputStream(int chuckSize) throws Exception {\n+        byte[] emptyEncoded = new byte[0];\n+        byte[] emptyDecoded = new byte[0];\n+        testByteByByte(emptyEncoded, emptyDecoded, chuckSize, CRLF);\n+        testByChunk(emptyEncoded, emptyDecoded, chuckSize, CRLF);\n+    }\n+\n+    /**\n+     * Tests the Base32InputStream implementation.\n+     * \n+     * @throws Exception\n+     *             for some failure scenarios.\n+     */\n+    public void testBase32InputStreamByChunk() throws Exception {\n+        // Hello World test.\n+        byte[] encoded = StringUtils.getBytesUtf8(Base32TestData.BASE32_FIXTURE);\n+        byte[] decoded = StringUtils.getBytesUtf8(Base32TestData.STRING_FIXTURE);\n+        testByChunk(encoded, decoded, Base32.MIME_CHUNK_SIZE, CRLF);\n+\n+        // Single Byte test.\n+        encoded = StringUtils.getBytesUtf8(\"AA==\\r\\n\");\n+        decoded = new byte[]{(byte) 0};\n+//        testByChunk(encoded, decoded, Base32.MIME_CHUNK_SIZE, CRLF);\n+\n+//        // OpenSSL interop test.\n+//        encoded = StringUtils.getBytesUtf8(Base32TestData.ENCODED_32_CHARS_PER_LINE);\n+//        decoded = Base32TestData.DECODED;\n+//        testByChunk(encoded, decoded, Base32.PEM_CHUNK_SIZE, LF);\n+//\n+//        // Single Line test.\n+//        String singleLine = Base32TestData.ENCODED_32_CHARS_PER_LINE.replaceAll(\"\\n\", \"\");\n+//        encoded = StringUtils.getBytesUtf8(singleLine);\n+//        decoded = Base32TestData.DECODED;\n+//        testByChunk(encoded, decoded, 0, LF);\n+\n+        // test random data of sizes 0 thru 150\n+        for (int i = 0; i <= 150; i++) {\n+            byte[][] randomData = Base32TestData.randomData(i, false);\n+            encoded = randomData[1];\n+            decoded = randomData[0];\n+            testByChunk(encoded, decoded, 0, LF);\n+        }\n+    }\n+\n+    /**\n+     * Tests the Base32InputStream implementation.\n+     * \n+     * @throws Exception\n+     *             for some failure scenarios.\n+     */\n+    public void testBase32InputStreamByteByByte() throws Exception {\n+        // Hello World test.\n+        byte[] encoded = StringUtils.getBytesUtf8(Base32TestData.BASE32_FIXTURE);\n+        byte[] decoded = StringUtils.getBytesUtf8(Base32TestData.STRING_FIXTURE);\n+        testByteByByte(encoded, decoded, Base32.MIME_CHUNK_SIZE, CRLF);\n+\n+        // Single Byte test.\n+        encoded = StringUtils.getBytesUtf8(\"AA==\\r\\n\");\n+        decoded = new byte[]{(byte) 0};\n+//        testByteByByte(encoded, decoded, Base32.MIME_CHUNK_SIZE, CRLF);\n+\n+//        // Single Line test.\n+//        String singleLine = Base32TestData.ENCODED_32_CHARS_PER_LINE.replaceAll(\"\\n\", \"\");\n+//        encoded = StringUtils.getBytesUtf8(singleLine);\n+//        decoded = Base32TestData.DECODED;\n+//        testByteByByte(encoded, decoded, 0, LF);\n+\n+        // test random data of sizes 0 thru 150\n+        for (int i = 0; i <= 150; i++) {\n+            byte[][] randomData = Base32TestData.randomData(i, false);\n+            encoded = randomData[1];\n+            decoded = randomData[0];\n+            testByteByByte(encoded, decoded, 0, LF);\n+        }\n+    }\n+\n+    /**\n+     * Tests method does three tests on the supplied data: 1. encoded ---[DECODE]--> decoded 2. decoded ---[ENCODE]-->\n+     * encoded 3. decoded ---[WRAP-WRAP-WRAP-etc...] --> decoded\n+     * <p/>\n+     * By \"[WRAP-WRAP-WRAP-etc...]\" we mean situation where the Base32InputStream wraps itself in encode and decode mode\n+     * over and over again.\n+     * \n+     * @param encoded\n+     *            base32 encoded data\n+     * @param decoded\n+     *            the data from above, but decoded\n+     * @param chunkSize\n+     *            chunk size (line-length) of the base32 encoded data.\n+     * @param seperator\n+     *            Line separator in the base32 encoded data.\n+     * @throws Exception\n+     *             Usually signifies a bug in the Base32 commons-codec implementation.\n+     */\n+    private void testByChunk(byte[] encoded, byte[] decoded, int chunkSize, byte[] seperator) throws Exception {\n+\n+        // Start with encode.\n+        InputStream in = new ByteArrayInputStream(decoded);\n+        in = new Base32InputStream(in, true, chunkSize, seperator);\n+        byte[] output = Base32TestData.streamToBytes(in);\n+\n+        assertEquals(\"EOF\", -1, in.read());\n+        assertEquals(\"Still EOF\", -1, in.read());\n+        assertTrue(\"Streaming base32 encode\", Arrays.equals(output, encoded));\n+\n+        // Now let's try decode.\n+        in = new ByteArrayInputStream(encoded);\n+        in = new Base32InputStream(in);\n+        output = Base32TestData.streamToBytes(in);\n+\n+        assertEquals(\"EOF\", -1, in.read());\n+        assertEquals(\"Still EOF\", -1, in.read());\n+        assertTrue(\"Streaming base32 decode\", Arrays.equals(output, decoded));\n+\n+        // I always wanted to do this! (wrap encoder with decoder etc etc).\n+        in = new ByteArrayInputStream(decoded);\n+        for (int i = 0; i < 10; i++) {\n+            in = new Base32InputStream(in, true, chunkSize, seperator);\n+            in = new Base32InputStream(in, false);\n+        }\n+        output = Base32TestData.streamToBytes(in);\n+\n+        assertEquals(\"EOF\", -1, in.read());\n+        assertEquals(\"Still EOF\", -1, in.read());\n+        assertTrue(\"Streaming base32 wrap-wrap-wrap!\", Arrays.equals(output, decoded));\n+    }\n+\n+    /**\n+     * Tests method does three tests on the supplied data: 1. encoded ---[DECODE]--> decoded 2. decoded ---[ENCODE]-->\n+     * encoded 3. decoded ---[WRAP-WRAP-WRAP-etc...] --> decoded\n+     * <p/>\n+     * By \"[WRAP-WRAP-WRAP-etc...]\" we mean situation where the Base32InputStream wraps itself in encode and decode mode\n+     * over and over again.\n+     * \n+     * @param encoded\n+     *            base32 encoded data\n+     * @param decoded\n+     *            the data from above, but decoded\n+     * @param chunkSize\n+     *            chunk size (line-length) of the base32 encoded data.\n+     * @param seperator\n+     *            Line separator in the base32 encoded data.\n+     * @throws Exception\n+     *             Usually signifies a bug in the Base32 commons-codec implementation.\n+     */\n+    private void testByteByByte(byte[] encoded, byte[] decoded, int chunkSize, byte[] seperator) throws Exception {\n+\n+        // Start with encode.\n+        InputStream in = new ByteArrayInputStream(decoded);\n+        in = new Base32InputStream(in, true, chunkSize, seperator);\n+        byte[] output = new byte[encoded.length];\n+        for (int i = 0; i < output.length; i++) {\n+            output[i] = (byte) in.read();\n+        }\n+\n+        assertEquals(\"EOF\", -1, in.read());\n+        assertEquals(\"Still EOF\", -1, in.read());\n+        assertTrue(\"Streaming base32 encode\", Arrays.equals(output, encoded));\n+\n+        // Now let's try decode.\n+        in = new ByteArrayInputStream(encoded);\n+        in = new Base32InputStream(in);\n+        output = new byte[decoded.length];\n+        for (int i = 0; i < output.length; i++) {\n+            output[i] = (byte) in.read();\n+        }\n+\n+        assertEquals(\"EOF\", -1, in.read());\n+        assertEquals(\"Still EOF\", -1, in.read());\n+        assertTrue(\"Streaming base32 decode\", Arrays.equals(output, decoded));\n+\n+        // I always wanted to do this! (wrap encoder with decoder etc etc).\n+        in = new ByteArrayInputStream(decoded);\n+        for (int i = 0; i < 10; i++) {\n+            in = new Base32InputStream(in, true, chunkSize, seperator);\n+            in = new Base32InputStream(in, false);\n+        }\n+        output = new byte[decoded.length];\n+        for (int i = 0; i < output.length; i++) {\n+            output[i] = (byte) in.read();\n+        }\n+\n+        assertEquals(\"EOF\", -1, in.read());\n+        assertEquals(\"Still EOF\", -1, in.read());\n+        assertTrue(\"Streaming base32 wrap-wrap-wrap!\", Arrays.equals(output, decoded));\n+    }\n+\n+    /**\n+     * Tests markSupported.\n+     * \n+     * @throws Exception\n+     */\n+    public void testMarkSupported() throws Exception {\n+        byte[] decoded = StringUtils.getBytesUtf8(Base32TestData.STRING_FIXTURE);\n+        ByteArrayInputStream bin = new ByteArrayInputStream(decoded);\n+        Base32InputStream in = new Base32InputStream(bin, true, 4, new byte[]{0, 0, 0});\n+        // Always returns false for now.\n+        assertFalse(\"Base32InputStream.markSupported() is false\", in.markSupported());\n+    }\n+\n+    /**\n+     * Tests read returning 0\n+     * \n+     * @throws Exception\n+     */\n+    public void testRead0() throws Exception {\n+        byte[] decoded = StringUtils.getBytesUtf8(Base32TestData.STRING_FIXTURE);\n+        byte[] buf = new byte[1024];\n+        int bytesRead = 0;\n+        ByteArrayInputStream bin = new ByteArrayInputStream(decoded);\n+        Base32InputStream in = new Base32InputStream(bin, true, 4, new byte[]{0, 0, 0});\n+        bytesRead = in.read(buf, 0, 0);\n+        assertEquals(\"Base32InputStream.read(buf, 0, 0) returns 0\", 0, bytesRead);\n+    }\n+\n+    /**\n+     * Tests read with null.\n+     * \n+     * @throws Exception\n+     *             for some failure scenarios.\n+     */\n+    public void testReadNull() throws Exception {\n+        byte[] decoded = StringUtils.getBytesUtf8(Base32TestData.STRING_FIXTURE);\n+        ByteArrayInputStream bin = new ByteArrayInputStream(decoded);\n+        Base32InputStream in = new Base32InputStream(bin, true, 4, new byte[]{0, 0, 0});\n+        try {\n+            in.read(null, 0, 0);\n+            fail(\"Base32InputStream.read(null, 0, 0) to throw a NullPointerException\");\n+        } catch (NullPointerException e) {\n+            // Expected\n+        }\n+    }\n+\n+    /**\n+     * Tests read throwing IndexOutOfBoundsException\n+     * \n+     * @throws Exception\n+     */\n+    public void testReadOutOfBounds() throws Exception {\n+        byte[] decoded = StringUtils.getBytesUtf8(Base32TestData.STRING_FIXTURE);\n+        byte[] buf = new byte[1024];\n+        ByteArrayInputStream bin = new ByteArrayInputStream(decoded);\n+        Base32InputStream in = new Base32InputStream(bin, true, 4, new byte[]{0, 0, 0});\n+\n+        try {\n+            in.read(buf, -1, 0);\n+            fail(\"Expected Base32InputStream.read(buf, -1, 0) to throw IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // Expected\n+        }\n+\n+        try {\n+            in.read(buf, 0, -1);\n+            fail(\"Expected Base32InputStream.read(buf, 0, -1) to throw IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // Expected\n+        }\n+\n+        try {\n+            in.read(buf, buf.length + 1, 0);\n+            fail(\"Base32InputStream.read(buf, buf.length + 1, 0) throws IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // Expected\n+        }\n+\n+        try {\n+            in.read(buf, buf.length - 1, 2);\n+            fail(\"Base32InputStream.read(buf, buf.length - 1, 2) throws IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // Expected\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/codec/binary/Base32OutputStreamTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.codec.binary;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.OutputStream;\n+import java.util.Arrays;\n+\n+import junit.framework.TestCase;\n+\n+public class Base32OutputStreamTest extends TestCase {\n+\n+    private final static byte[] CRLF = {(byte) '\\r', (byte) '\\n'};\n+\n+    private final static byte[] LF = {(byte) '\\n'};\n+\n+    /**\n+     * Construct a new instance of this test case.\n+     * \n+     * @param name\n+     *            Name of the test case\n+     */\n+    public Base32OutputStreamTest(String name) {\n+        super(name);\n+    }\n+\n+//    /**\n+//     * Test the Base32OutputStream implementation against the special NPE inducing input\n+//     * identified in the CODEC-98 bug.\n+//     *\n+//     * @throws Exception for some failure scenarios.\n+//     */\n+//    public void testCodec98NPE() throws Exception {\n+//        byte[] codec98 = StringUtils.getBytesUtf8(Base32TestData.CODEC_98_NPE);\n+//        byte[] codec98_1024 = new byte[1024];\n+//        System.arraycopy(codec98, 0, codec98_1024, 0, codec98.length);\n+//        ByteArrayOutputStream data = new ByteArrayOutputStream(1024);\n+//        Base32OutputStream stream = new Base32OutputStream(data, false);\n+//        stream.write(codec98_1024, 0, 1024);\n+//        stream.close();\n+//\n+//        byte[] decodedBytes = data.toByteArray();\n+//        String decoded = StringUtils.newStringUtf8(decodedBytes);\n+//        assertEquals(\n+//            \"codec-98 NPE Base32OutputStream\", Base32TestData.CODEC_98_NPE_DECODED, decoded\n+//        );\n+//    }\n+    \n+\n+    /**\n+     * Test the Base32OutputStream implementation against empty input.\n+     * \n+     * @throws Exception\n+     *             for some failure scenarios.\n+     */\n+    public void testBase32EmptyOutputStreamMimeChunkSize() throws Exception {\n+        testBase32EmptyOutputStream(Base32.MIME_CHUNK_SIZE);\n+    }\n+\n+    /**\n+     * Test the Base32OutputStream implementation against empty input.\n+     * \n+     * @throws Exception\n+     *             for some failure scenarios.\n+     */\n+    public void testBase32EmptyOutputStreamPemChunkSize() throws Exception {\n+        testBase32EmptyOutputStream(Base32.PEM_CHUNK_SIZE);\n+    }\n+\n+    private void testBase32EmptyOutputStream(int chunkSize) throws Exception {\n+        byte[] emptyEncoded = new byte[0];\n+        byte[] emptyDecoded = new byte[0];\n+        testByteByByte(emptyEncoded, emptyDecoded, chunkSize, CRLF);\n+        testByChunk(emptyEncoded, emptyDecoded, chunkSize, CRLF);\n+    }\n+\n+    /**\n+     * Test the Base32OutputStream implementation\n+     * \n+     * @throws Exception\n+     *             for some failure scenarios.\n+     */\n+    public void testBase32OutputStreamByChunk() throws Exception {\n+        // Hello World test.\n+        byte[] encoded = StringUtils.getBytesUtf8(Base32TestData.BASE32_FIXTURE);\n+        byte[] decoded = StringUtils.getBytesUtf8(Base32TestData.STRING_FIXTURE);\n+        testByChunk(encoded, decoded, Base32.MIME_CHUNK_SIZE, CRLF);\n+\n+//        // Single Byte test.\n+//        encoded = StringUtils.getBytesUtf8(\"AA==\\r\\n\");\n+//        decoded = new byte[]{(byte) 0};\n+//        testByChunk(encoded, decoded, Base32.MIME_CHUNK_SIZE, CRLF);\n+\n+\n+//        // Single Line test.\n+//        String singleLine = Base32TestData.ENCODED_64_CHARS_PER_LINE.replaceAll(\"\\n\", \"\");\n+//        encoded = StringUtils.getBytesUtf8(singleLine);\n+//        decoded = Base32TestData.DECODED;\n+//        testByChunk(encoded, decoded, 0, LF);\n+\n+        // test random data of sizes 0 thru 150\n+        for (int i = 0; i <= 150; i++) {\n+            byte[][] randomData = Base32TestData.randomData(i, false);\n+            encoded = randomData[1];\n+            decoded = randomData[0];\n+            testByChunk(encoded, decoded, 0, LF);\n+        }\n+    }\n+\n+    /**\n+     * Test the Base32OutputStream implementation\n+     * \n+     * @throws Exception\n+     *             for some failure scenarios.\n+     */\n+    public void testBase32OutputStreamByteByByte() throws Exception {\n+        // Hello World test.\n+        byte[] encoded = StringUtils.getBytesUtf8(Base32TestData.BASE32_FIXTURE);\n+        byte[] decoded = StringUtils.getBytesUtf8(Base32TestData.STRING_FIXTURE);\n+        testByteByByte(encoded, decoded, 76, CRLF);\n+\n+//        // Single Byte test.\n+//        encoded = StringUtils.getBytesUtf8(\"AA==\\r\\n\");\n+//        decoded = new byte[]{(byte) 0};\n+//        testByteByByte(encoded, decoded, 76, CRLF);\n+\n+\n+//        // Single Line test.\n+//        String singleLine = Base32TestData.ENCODED_64_CHARS_PER_LINE.replaceAll(\"\\n\", \"\");\n+//        encoded = StringUtils.getBytesUtf8(singleLine);\n+//        decoded = Base32TestData.DECODED;\n+//        testByteByByte(encoded, decoded, 0, LF);\n+\n+        // test random data of sizes 0 thru 150\n+        for (int i = 0; i <= 150; i++) {\n+            byte[][] randomData = Base32TestData.randomData(i, false);\n+            encoded = randomData[1];\n+            decoded = randomData[0];\n+            testByteByByte(encoded, decoded, 0, LF);\n+        }\n+    }\n+\n+    /**\n+     * Test method does three tests on the supplied data: 1. encoded ---[DECODE]--> decoded 2. decoded ---[ENCODE]-->\n+     * encoded 3. decoded ---[WRAP-WRAP-WRAP-etc...] --> decoded\n+     * <p/>\n+     * By \"[WRAP-WRAP-WRAP-etc...]\" we mean situation where the Base32OutputStream wraps itself in encode and decode\n+     * mode over and over again.\n+     * \n+     * @param encoded\n+     *            Base32 encoded data\n+     * @param decoded\n+     *            the data from above, but decoded\n+     * @param chunkSize\n+     *            chunk size (line-length) of the Base32 encoded data.\n+     * @param seperator\n+     *            Line separator in the Base32 encoded data.\n+     * @throws Exception\n+     *             Usually signifies a bug in the Base32 commons-codec implementation.\n+     */\n+    private void testByChunk(byte[] encoded, byte[] decoded, int chunkSize, byte[] seperator) throws Exception {\n+\n+        // Start with encode.\n+        ByteArrayOutputStream byteOut = new ByteArrayOutputStream();\n+        OutputStream out = new Base32OutputStream(byteOut, true, chunkSize, seperator);\n+        out.write(decoded);\n+        out.close();\n+        byte[] output = byteOut.toByteArray();\n+        assertTrue(\"Streaming chunked Base32 encode\", Arrays.equals(output, encoded));\n+\n+        // Now let's try decode.\n+        byteOut = new ByteArrayOutputStream();\n+        out = new Base32OutputStream(byteOut, false);\n+        out.write(encoded);\n+        out.close();\n+        output = byteOut.toByteArray();\n+        assertTrue(\"Streaming chunked Base32 decode\", Arrays.equals(output, decoded));\n+\n+        // I always wanted to do this! (wrap encoder with decoder etc etc).\n+        byteOut = new ByteArrayOutputStream();\n+        out = byteOut;\n+        for (int i = 0; i < 10; i++) {\n+            out = new Base32OutputStream(out, false);\n+            out = new Base32OutputStream(out, true, chunkSize, seperator);\n+        }\n+        out.write(decoded);\n+        out.close();\n+        output = byteOut.toByteArray();\n+\n+        assertTrue(\"Streaming chunked Base32 wrap-wrap-wrap!\", Arrays.equals(output, decoded));\n+    }\n+\n+    /**\n+     * Test method does three tests on the supplied data: 1. encoded ---[DECODE]--> decoded 2. decoded ---[ENCODE]-->\n+     * encoded 3. decoded ---[WRAP-WRAP-WRAP-etc...] --> decoded\n+     * <p/>\n+     * By \"[WRAP-WRAP-WRAP-etc...]\" we mean situation where the Base32OutputStream wraps itself in encode and decode\n+     * mode over and over again.\n+     * \n+     * @param encoded\n+     *            Base32 encoded data\n+     * @param decoded\n+     *            the data from above, but decoded\n+     * @param chunkSize\n+     *            chunk size (line-length) of the Base32 encoded data.\n+     * @param seperator\n+     *            Line separator in the Base32 encoded data.\n+     * @throws Exception\n+     *             Usually signifies a bug in the Base32 commons-codec implementation.\n+     */\n+    private void testByteByByte(byte[] encoded, byte[] decoded, int chunkSize, byte[] seperator) throws Exception {\n+\n+        // Start with encode.\n+        ByteArrayOutputStream byteOut = new ByteArrayOutputStream();\n+        OutputStream out = new Base32OutputStream(byteOut, true, chunkSize, seperator);\n+        for (int i = 0; i < decoded.length; i++) {\n+            out.write(decoded[i]);\n+        }\n+        out.close();\n+        byte[] output = byteOut.toByteArray();\n+        assertTrue(\"Streaming byte-by-byte Base32 encode\", Arrays.equals(output, encoded));\n+\n+        // Now let's try decode.\n+        byteOut = new ByteArrayOutputStream();\n+        out = new Base32OutputStream(byteOut, false);\n+        for (int i = 0; i < encoded.length; i++) {\n+            out.write(encoded[i]);\n+        }\n+        out.close();\n+        output = byteOut.toByteArray();\n+        assertTrue(\"Streaming byte-by-byte Base32 decode\", Arrays.equals(output, decoded));\n+\n+        // Now let's try decode with tonnes of flushes.\n+        byteOut = new ByteArrayOutputStream();\n+        out = new Base32OutputStream(byteOut, false);\n+        for (int i = 0; i < encoded.length; i++) {\n+            out.write(encoded[i]);\n+            out.flush();\n+        }\n+        out.close();\n+        output = byteOut.toByteArray();\n+        assertTrue(\"Streaming byte-by-byte flush() Base32 decode\", Arrays.equals(output, decoded));\n+\n+        // I always wanted to do this! (wrap encoder with decoder etc etc).\n+        byteOut = new ByteArrayOutputStream();\n+        out = byteOut;\n+        for (int i = 0; i < 10; i++) {\n+            out = new Base32OutputStream(out, false);\n+            out = new Base32OutputStream(out, true, chunkSize, seperator);\n+        }\n+        for (int i = 0; i < decoded.length; i++) {\n+            out.write(decoded[i]);\n+        }\n+        out.close();\n+        output = byteOut.toByteArray();\n+\n+        assertTrue(\"Streaming byte-by-byte Base32 wrap-wrap-wrap!\", Arrays.equals(output, decoded));\n+    }\n+\n+    /**\n+     * Tests Base32OutputStream.write for expected IndexOutOfBoundsException conditions.\n+     * \n+     * @throws Exception\n+     *             for some failure scenarios.\n+     */\n+    public void testWriteOutOfBounds() throws Exception {\n+        byte[] buf = new byte[1024];\n+        ByteArrayOutputStream bout = new ByteArrayOutputStream();\n+        Base32OutputStream out = new Base32OutputStream(bout);\n+\n+        try {\n+            out.write(buf, -1, 1);\n+            fail(\"Expected Base32OutputStream.write(buf, -1, 1) to throw a IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException ioobe) {\n+            // Expected\n+        }\n+\n+        try {\n+            out.write(buf, 1, -1);\n+            fail(\"Expected Base32OutputStream.write(buf, 1, -1) to throw a IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException ioobe) {\n+            // Expected\n+        }\n+\n+        try {\n+            out.write(buf, buf.length + 1, 0);\n+            fail(\"Expected Base32OutputStream.write(buf, buf.length + 1, 0) to throw a IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException ioobe) {\n+            // Expected\n+        }\n+\n+        try {\n+            out.write(buf, buf.length - 1, 2);\n+            fail(\"Expected Base32OutputStream.write(buf, buf.length - 1, 2) to throw a IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException ioobe) {\n+            // Expected\n+        }\n+    }\n+\n+    /**\n+     * Tests Base32OutputStream.write(null).\n+     * \n+     * @throws Exception\n+     *             for some failure scenarios.\n+     */\n+    public void testWriteToNullCoverage() throws Exception {\n+        ByteArrayOutputStream bout = new ByteArrayOutputStream();\n+        Base32OutputStream out = new Base32OutputStream(bout);\n+        try {\n+            out.write(null, 0, 0);\n+            fail(\"Expcted Base32OutputStream.write(null) to throw a NullPointerException\");\n+        } catch (NullPointerException e) {\n+            // Expected\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/codec/binary/Base32TestData.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.codec.binary;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.Random;\n+\n+/**\n+ * This random data was encoded by OpenSSL. Java had nothing to do with it. This data helps us test interop between\n+ * Commons-Codec and OpenSSL. Notice that OpenSSL creates 64 character lines instead of the 76 of Commons-Codec.\n+ * \n+ * @see <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045</a>\n+ * @author Apache Software Foundation\n+ * @version $Id $\n+ * @since 1.4\n+ */\n+public class Base32TestData {\n+\n+    static final String STRING_FIXTURE = \"Hello World\";\n+\n+    static final String BASE32_FIXTURE = \"JBSWY3DPEBLW64TMMQ======\\r\\n\";\n+//  static final String BASE32HEX_FIXTURE = \"91IMOR3F41BMUSJCCG======\";\n+\n+    // Some utility code to help test chunked reads of the InputStream.\n+\n+    private final static int SIZE_KEY = 0;\n+    private final static int LAST_READ_KEY = 1;\n+\n+    static byte[] streamToBytes(final InputStream in) throws IOException {\n+        // new byte[7] is obviously quite slow, but helps exercise the code.\n+        return streamToBytes(in, new byte[7]);\n+    }\n+\n+    static byte[] streamToBytes(final InputStream in, byte[] buf) throws IOException {\n+        try {\n+            int[] status = fill(buf, 0, in);\n+            int size = status[SIZE_KEY];\n+            int lastRead = status[LAST_READ_KEY];\n+            while (lastRead != -1) {\n+                buf = resizeArray(buf);\n+                status = fill(buf, size, in);\n+                size = status[SIZE_KEY];\n+                lastRead = status[LAST_READ_KEY];\n+            }\n+            if (buf.length != size) {\n+                byte[] smallerBuf = new byte[size];\n+                System.arraycopy(buf, 0, smallerBuf, 0, size);\n+                buf = smallerBuf;\n+            }\n+        }\n+        finally {\n+            in.close();\n+        }\n+        return buf;\n+    }\n+\n+    private static int[] fill(final byte[] buf, final int offset, final InputStream in)\n+            throws IOException {\n+        int read = in.read(buf, offset, buf.length - offset);\n+        int lastRead = read;\n+        if (read == -1) {\n+            read = 0;\n+        }\n+        while (lastRead != -1 && read + offset < buf.length) {\n+            lastRead = in.read(buf, offset + read, buf.length - read - offset);\n+            if (lastRead != -1) {\n+                read += lastRead;\n+            }\n+        }\n+        return new int[]{offset + read, lastRead};\n+    }\n+\n+    private static byte[] resizeArray(final byte[] bytes) {\n+        byte[] biggerBytes = new byte[bytes.length * 2];\n+        System.arraycopy(bytes, 0, biggerBytes, 0, bytes.length);\n+        return biggerBytes;\n+    }\n+\n+\n+    /**\n+     * Returns an encoded and decoded copy of the same random data.\n+     * \n+     * @param size amount of random data to generate and encode\n+     * @param useHex true if encoding be hex\n+     * @return two byte[] arrays:  [0] = decoded, [1] = encoded \n+     */\n+    static byte[][] randomData(int size, boolean useHex) {\n+        Random r = new Random();\n+        byte[] decoded = new byte[size];\n+        r.nextBytes(decoded);\n+        byte[] encoded = new Base32(useHex).encode(decoded);\n+        return new byte[][] {decoded, encoded};\n+    }\n+\n+    /**\n+     * Tests the supplied byte[] array to see if it contains the specified byte c.\n+     *\n+     * @param bytes byte[] array to test\n+     * @param c byte to look for\n+     * @return true if bytes contains c, false otherwise\n+     */\n+    static boolean bytesContain(byte[] bytes, byte c) {\n+        for (int i = 0; i < bytes.length; i++) {\n+            if (bytes[i] == c) { return true; }\n+        }\n+        return false;\n+    }\n+\n+}", "timestamp": 1296061156, "metainfo": ""}