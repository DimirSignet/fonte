{"sha": "2835bfb46e708b5d08c87afaeb22e92664e2b395", "log": "Fix testParses() so it works for non-GMT timezones: the format must include hours to allow for GMT-offsets  ", "commit": "\n--- a/src/test/java/org/apache/commons/lang3/time/FastDateParserTest.java\n+++ b/src/test/java/org/apache/commons/lang3/time/FastDateParserTest.java\n  * @since 3.2\n  */\n public class FastDateParserTest {\n-    private static final String SHORT_FORMAT = \"G/y/M/d/a/E/Z\";\n-    private static final String LONG_FORMAT = \"GGGG/yyyy/MMMM/dddd/aaaa/EEEE/ZZZZ\";\n-    private static final String SHORT_FORMAT_NOERA = \"y/M/d/a/E/Z\";\n-    private static final String LONG_FORMAT_NOERA = \"yyyy/MMMM/dddd/aaaa/EEEE/ZZZZ\";\n+    private static final String SHORT_FORMAT_NOERA = \"y/M/d/h/a/E/Z\";\n+    private static final String LONG_FORMAT_NOERA = \"yyyy/MMMM/dddd/hhhh/aaaa/EEEE/ZZZZ\";\n+    private static final String SHORT_FORMAT = \"G/\" + SHORT_FORMAT_NOERA;\n+    private static final String LONG_FORMAT = \"GGGG/\" + LONG_FORMAT_NOERA;\n+\n     private static final String yMdHmsSZ = \"yyyy-MM-dd'T'HH:mm:ss.SSS Z\";\n     private static final String DMY_DOT = \"dd.MM.yyyy\";\n     private static final String YMD_SLASH = \"yyyy/MM/dd\";\n     private static final String MDY_DASH = \"MM-DD-yyyy\";\n     private static final String MDY_SLASH = \"MM/DD/yyyy\";\n+\n     private static final TimeZone REYKJAVIK = TimeZone.getTimeZone(\"Atlantic/Reykjavik\");\n     private static final TimeZone NEW_YORK = TimeZone.getTimeZone(\"America/New_York\");\n     private static final TimeZone GMT = TimeZone.getTimeZone(\"GMT\");\n+\n     private static final Locale SWEDEN = new Locale(\"sv\", \"SE\");\n \n     DateParser getInstance(String format) {\n     }\n \n     private DateParser getDateInstance(int dateStyle, Locale locale) {\n-        return getInstance(FormatCache.getPatternForStyle(dateStyle, null, locale), TimeZone.getDefault(), Locale.getDefault());\n+        return getInstance(FormatCache.getPatternForStyle(Integer.valueOf(dateStyle), null, locale), TimeZone.getDefault(), Locale.getDefault());\n     }\n \n     private DateParser getInstance(String format, Locale locale) {\n         Map<DateParser,Integer> map= new HashMap<DateParser,Integer>();\n         int i= 0;\n         for(DateParser parser:parsers) {\n-            map.put(parser, i++);            \n+            map.put(parser, Integer.valueOf(i++));            \n         }\n \n         i= 0;\n         for(DateParser parser:parsers) {\n-            assertEquals(i++, (int)map.get(parser));\n+            assertEquals(i++, map.get(parser).intValue());\n         }        \n     }\n \n     }\n \n     @Test\n-    // Check that all Locales can parse their own formats\n+    // Check that all Locales can parse the formats we use\n     public void testParses() throws Exception {\n-        Calendar cal = Calendar.getInstance(GMT); // fails for non-GMT\n         for(Locale locale : Locale.getAvailableLocales()) {\n-            cal.clear();\n-            cal.set(2003, 1, 10);\n-            Date in = cal.getTime();\n-            SimpleDateFormat sdf = new SimpleDateFormat(LONG_FORMAT, locale);\n-            String fmt = sdf.format(in);\n-            Date out = sdf.parse(fmt);\n-            assertEquals(locale.toString(), in, out);\n+            for(TimeZone tz : new TimeZone[]{NEW_YORK, GMT}) {\n+                Calendar cal = Calendar.getInstance(tz);                \n+                cal.clear();\n+                cal.set(2003, 1, 10);\n+                Date in = cal.getTime();\n+                for(String format : new String[]{LONG_FORMAT, SHORT_FORMAT}) {\n+                    SimpleDateFormat sdf = new SimpleDateFormat(LONG_FORMAT, locale);\n+                    String fmt = sdf.format(in);\n+                    Date out = sdf.parse(fmt);\n+                    assertEquals(locale.toString()+\" \"+ format+ \" \"+tz.getID(), in, out);                \n+                }\n+            }\n         }\n     }\n ", "timestamp": 1348582067, "metainfo": ""}