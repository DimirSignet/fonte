{"sha": "8c1980ed47ca190a430b3cbbe140a0865fffdbea", "log": "Trailing spaces  ", "commit": "\n--- a/src/main/java/org/apache/commons/lang3/time/FastDateParser.java\n+++ b/src/main/java/org/apache/commons/lang3/time/FastDateParser.java\n  * The ASF licenses this file to You under the Apache License, Version 2.0\n  * (the \"License\"); you may not use this file except in compliance with\n  * the License.  You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n /**\n  * <p>FastDateParser is a fast and thread-safe version of\n  * {@link java.text.SimpleDateFormat}.</p>\n- * \n+ *\n  * <p>This class can be used as a direct replacement for\n  * <code>SimpleDateFormat</code> in most parsing situations.\n  * This class is especially useful in multi-threaded server environments.\n  * <code>SimpleDateFormat</code> is not thread-safe in any JDK version,\n- * nor will it be as Sun have closed the \n+ * nor will it be as Sun have closed the\n  * <a href=\"http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4228335\">bug</a>/RFE.\n  * </p>\n  *\n  * <p>Only parsing is supported, but all patterns are compatible with\n  * SimpleDateFormat.</p>\n- * \n+ *\n  * <p>Timing tests indicate this class is as about as fast as SimpleDateFormat\n  * in single thread applications and about 25% faster in multi-thread applications.</p>\n  *\n public class FastDateParser implements DateParser, Serializable {\n     /**\n      * Required for serialization support.\n-     * \n+     *\n      * @see java.io.Serializable\n      */\n     private static final long serialVersionUID = 1L;\n-    \n-    private static final ConcurrentMap<Locale,TimeZoneStrategy> tzsCache= \n+\n+    private static final ConcurrentMap<Locale,TimeZoneStrategy> tzsCache=\n         new ConcurrentHashMap<Locale,TimeZoneStrategy>(3);\n \n     static final Locale JAPANESE_IMPERIAL = new Locale(\"ja\",\"JP\",\"JP\");\n     private final String pattern;\n     private final TimeZone timeZone;\n     private final Locale locale;\n-    \n+\n     // derived fields\n     private transient Pattern parsePattern;\n     private transient Strategy[] strategies;\n \n     /**\n      * <p>Constructs a new FastDateParser.</p>\n-     * \n+     *\n      * @param pattern non-null {@link java.text.SimpleDateFormat} compatible\n      *  pattern\n      * @param timeZone non-null time zone to use\n     protected FastDateParser(String pattern, TimeZone timeZone, Locale locale) {\n         this.pattern = pattern;\n         this.timeZone = timeZone;\n-        this.locale = locale;        \n+        this.locale = locale;\n         init();\n     }\n-    \n+\n     /**\n      * Initialize derived fields from defining fields.\n-     * This is called from constructor and from readObject (de-serialization)   \n+     * This is called from constructor and from readObject (de-serialization)\n      */\n     private void init() {\n         thisYear= Calendar.getInstance(timeZone, locale).get(Calendar.YEAR);\n-        \n+\n         nameValues= new ConcurrentHashMap<Integer, KeyValue[]>();\n-        \n+\n         StringBuilder regex= new StringBuilder();\n         List<Strategy> collector = new ArrayList<Strategy>();\n-        \n+\n         Matcher patternMatcher= formatPattern.matcher(pattern);\n         if(!patternMatcher.lookingAt()) {\n             throw new IllegalArgumentException(\"Invalid pattern\");\n             String nextFormatField= patternMatcher.group();\n             nextStrategy = getStrategy(nextFormatField);\n             if(currentStrategy.addRegex(this, regex)) {\n-                collector.add(currentStrategy);                \n+                collector.add(currentStrategy);\n             }\n             currentFormatField= nextFormatField;\n             currentStrategy= nextStrategy;\n         }\n         if(currentStrategy.addRegex(this, regex)) {\n-            collector.add(currentStrategy);                \n+            collector.add(currentStrategy);\n         }\n         currentFormatField= null;\n         strategies= collector.toArray(new Strategy[collector.size()]);\n         parsePattern= Pattern.compile(regex.toString());\n     }\n-    \n+\n     // Accessors\n     //-----------------------------------------------------------------------\n     /* (non-Javadoc)\n     //-----------------------------------------------------------------------\n     /**\n      * <p>Compare another object for equality with this object.</p>\n-     * \n+     *\n      * @param obj  the object to compare to\n      * @return <code>true</code>if equal to this instance\n      */\n         }\n         FastDateParser other = (FastDateParser) obj;\n         return pattern.equals(other.pattern)\n-            && timeZone.equals(other.timeZone) \n+            && timeZone.equals(other.timeZone)\n             && locale.equals(other.locale);\n     }\n \n     /**\n      * <p>Return a hashcode compatible with equals.</p>\n-     * \n+     *\n      * @return a hashcode compatible with equals\n      */\n     @Override\n \n     /**\n      * <p>Get a string version of this formatter.</p>\n-     * \n+     *\n      * @return a debugging string\n      */\n     @Override\n     // Serializing\n     //-----------------------------------------------------------------------\n     /**\n-     * Create the object after serialization. This implementation reinitializes the \n+     * Create the object after serialization. This implementation reinitializes the\n      * transient properties.\n      *\n      * @param in ObjectInputStream from which the object is being deserialized.\n         in.defaultReadObject();\n         init();\n     }\n-    \n+\n     /* (non-Javadoc)\n      * @see org.apache.commons.lang3.time.DateParser#parseObject(java.lang.String)\n      */\n         pos.setIndex(offset+matcher.end());\n         return cal.getTime();\n     }\n-        \n+\n     // Support for strategies\n     //-----------------------------------------------------------------------\n \n         }\n         return regex;\n     }\n-    \n+\n     /**\n      * A class to store Key / Value pairs\n      */\n         public int value;\n \n         /**\n-         * Construct a Key / Value pair \n+         * Construct a Key / Value pair\n          * @param key The key\n          * @param value The value\n          */\n             this.value= value;\n         }\n     }\n-    \n+\n     /**\n      * ignore case comparison of keys\n      */\n         @Override\n         public int compare(KeyValue left, KeyValue right) {\n             return left.key.compareToIgnoreCase(right.key);\n-        }        \n+        }\n     };\n \n     /**\n         }\n         return eras;\n     }\n-    \n-    /**\n-     * Create key / value pairs from keys \n+\n+    /**\n+     * Create key / value pairs from keys\n      * @param longValues The allowable long names for a field\n      * @param shortValues The optional allowable short names for a field\n      * @return The sorted name / value pairs for the field\n     }\n \n     /**\n-     * Get a count of valid values in array.  A valid value is of non-zero length. \n+     * Get a count of valid values in array.  A valid value is of non-zero length.\n      * @param values The values to check.  This parameter may be null\n      * @return The number of valid values\n      */\n     }\n \n     /**\n-     * Create key / value pairs from values \n+     * Create key / value pairs from values\n      * @param fieldKeyValues The destination array\n-     * @param offset The offset into the destination array \n+     * @param offset The offset into the destination array\n      * @param values The values to use to create key / value pairs.  This parameter may be null.\n      * @return The offset into the destination array\n      */\n \n     /**\n      * Is the next field a number?\n-     * @return true, if next field will be a number \n+     * @return true, if next field will be a number\n      */\n     boolean isNextNumber() {\n         return nextStrategy!=null && nextStrategy.isNumber();\n     }\n-    \n+\n     /**\n      * What is the width of the current field?\n      * @return The number of characters in the current format field\n     int getFieldWidth() {\n         return currentFormatField.length();\n     }\n-    \n+\n     /**\n      * A strategy to parse a single field from the parsing pattern\n      */\n          */\n         void setCalendar(FastDateParser parser, Calendar cal, String value);\n         /**\n-         * Generate a <code>Pattern</code> regular expression to the <code>StringBuilder</code> \n+         * Generate a <code>Pattern</code> regular expression to the <code>StringBuilder</code>\n          * which will accept this field\n          * @param parser The parser calling this strategy\n          * @param regex The <code>StringBuilder</code> to append to\n-         * @return true, if this field will set the calendar; \n-         * false, if this field is a constant value  \n+         * @return true, if this field will set the calendar;\n+         * false, if this field is a constant value\n          */\n         boolean addRegex(FastDateParser parser, StringBuilder regex);\n     }\n-    \n+\n     /**\n      * A <code>Pattern</code> to parse the user supplied SimpleDateFormat pattern\n      */\n     private static final Pattern formatPattern= Pattern.compile(\n             \"D+|E+|F+|G+|H+|K+|M+|S+|W+|Z+|a+|d+|h+|k+|m+|s+|w+|y+|z+|''|'[^']++(''[^']*+)*+'|[^'A-Za-z]++\");\n-    \n+\n     /**\n      * Obtain a Strategy given a field from a SimpleDateFormat pattern\n      * @param formatField A sub-sequence of the SimpleDateFormat pattern\n         public boolean isNumber() {\n             char c= formatField.charAt(0);\n             if(c=='\\'') {\n-                c= formatField.charAt(1);                \n+                c= formatField.charAt(1);\n             }\n             return Character.isDigit(c);\n         }\n-        \n+\n         /**\n          * {@inheritDoc}\n          */\n      */\n     private static class TextStrategy implements Strategy {\n         private final int field;\n-        \n+\n         /**\n          * Construct a Strategy that parses a Text field\n          * @param field The Calendar field\n         TextStrategy(int field) {\n             this.field= field;\n         }\n-        \n+\n         /**\n          * {@inheritDoc}\n          */\n         public boolean isNumber() {\n             return false;\n         }\n-        \n+\n         /**\n          * {@inheritDoc}\n          */\n             regex.setCharAt(regex.length()-1, ')');\n             return true;\n         }\n-        \n+\n         /**\n          * {@inheritDoc}\n          */\n      */\n     private static class NumberStrategy implements Strategy {\n         protected final int field;\n-        \n+\n         /**\n          * Construct a Strategy that parses a Number field\n          * @param field The Calendar field\n         NumberStrategy(int field) {\n              this.field= field;\n         }\n-        \n+\n         /**\n          * {@inheritDoc}\n          */\n         public boolean isNumber() {\n             return true;\n         }\n-        \n+\n         /**\n          * {@inheritDoc}\n          */\n             }\n             return true;\n         }\n-        \n+\n         /**\n          * {@inheritDoc}\n          */\n         public void setCalendar(FastDateParser parser, Calendar cal, String value) {\n             cal.set(field, modify(Integer.parseInt(value)));\n         }\n-        \n-        /**\n-         * Make any modifications to parsed integer \n+\n+        /**\n+         * Make any modifications to parsed integer\n          * @param iValue The parsed integer\n          * @return The modified value\n          */\n         public int modify(int iValue) {\n-            return iValue;            \n+            return iValue;\n         }\n     }\n \n             cal.set(Calendar.YEAR, iValue);\n         }\n     };\n-    \n+\n     /**\n      * A strategy that handles a timezone field in the parsing pattern\n      */\n \n         final String validTimeZoneChars;\n         final SortedMap<String, TimeZone> tzNames= new TreeMap<String, TimeZone>(String.CASE_INSENSITIVE_ORDER);\n-        \n+\n         /**\n          * Construct a Strategy that parses a TimeZone\n          * @param locale The Locale\n                 }\n             }\n             StringBuilder sb= new StringBuilder();\n-            sb.append(\"(GMT[+\\\\-]\\\\d{0,1}\\\\d{2}|[+\\\\-]\\\\d{2}:?\\\\d{2}|\");            \n+            sb.append(\"(GMT[+\\\\-]\\\\d{0,1}\\\\d{2}|[+\\\\-]\\\\d{2}:?\\\\d{2}|\");\n             for(String id : tzNames.keySet()) {\n                 escapeRegex(sb, id, false).append('|');\n             }\n                 }\n             }\n             cal.setTimeZone(tz);\n-        }        \n+        }\n     }\n \n \n     private static final Strategy DAY_OF_WEEK_STRATEGY = new TextStrategy(Calendar.DAY_OF_WEEK);\n     private static final Strategy AM_PM_STRATEGY = new TextStrategy(Calendar.AM_PM);\n     private static final Strategy TEXT_MONTH_STRATEGY = new TextStrategy(Calendar.MONTH);\n-    \n+\n     private static final Strategy NUMBER_MONTH_STRATEGY = new NumberStrategy(Calendar.MONTH) {\n         @Override\n         public int modify(int iValue) {\n-            return iValue-1;            \n+            return iValue-1;\n         }\n     };\n     private static final Strategy LITERAL_YEAR_STRATEGY = new NumberStrategy(Calendar.YEAR);\n     private static final Strategy MODULO_HOUR_OF_DAY_STRATEGY = new NumberStrategy(Calendar.HOUR_OF_DAY) {\n         @Override\n         public int modify(int iValue) {\n-            return iValue%24;            \n+            return iValue%24;\n         }\n     };\n     private static final Strategy MODULO_HOUR_STRATEGY = new NumberStrategy(Calendar.HOUR) {\n         @Override\n         public int modify(int iValue) {\n-            return iValue%12;            \n+            return iValue%12;\n         }\n     };\n     private static final Strategy HOUR_STRATEGY = new NumberStrategy(Calendar.HOUR);\n--- a/src/test/java/org/apache/commons/lang3/time/FastDateParserTest.java\n+++ b/src/test/java/org/apache/commons/lang3/time/FastDateParserTest.java\n  * The ASF licenses this file to You under the Apache License, Version 2.0\n  * (the \"License\"); you may not use this file except in compliance with\n  * the License.  You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     }\n \n     @Test\n-    public void test_Equality_Hash() {        \n+    public void test_Equality_Hash() {\n         DateParser[] parsers= {\n             getInstance(yMdHmsSZ, NEW_YORK, Locale.US),\n             getInstance(DMY_DOT, NEW_YORK, Locale.US),\n             getInstance(MDY_SLASH, REYKJAVIK, Locale.US),\n             getInstance(MDY_SLASH, REYKJAVIK, SWEDEN)\n         };\n-        \n+\n         Map<DateParser,Integer> map= new HashMap<DateParser,Integer>();\n         int i= 0;\n         for(DateParser parser:parsers) {\n-            map.put(parser, Integer.valueOf(i++));            \n+            map.put(parser, Integer.valueOf(i++));\n         }\n \n         i= 0;\n         for(DateParser parser:parsers) {\n             assertEquals(i++, map.get(parser).intValue());\n-        }        \n+        }\n     }\n \n     @Test\n         Calendar cal= Calendar.getInstance(NEW_YORK, Locale.US);\n         cal.clear();\n         cal.set(2003, 6, 10, 16, 33, 20);\n-        \n+\n         DateParser fdf = getInstance(yMdHmsSZ, NEW_YORK, Locale.US);\n-        \n+\n         assertEquals(cal.getTime(), fdf.parse(\"2003-07-10T15:33:20.000 -0500\"));\n         assertEquals(cal.getTime(), fdf.parse(\"2003-07-10T15:33:20.000 GMT-05:00\"));\n         assertEquals(cal.getTime(), fdf.parse(\"2003-07-10T16:33:20.000 Eastern Daylight Time\"));\n         assertEquals(cal.getTime(), fdf.parse(\"2003-07-10T16:33:20.000 EDT\"));\n-        \n+\n         cal.setTimeZone(TimeZone.getTimeZone(\"GMT-3\"));\n         cal.set(2003, 1, 10, 9, 0, 0);\n-        \n+\n         assertEquals(cal.getTime(), fdf.parse(\"2003-02-10T09:00:00.000 -0300\"));\n-        \n+\n         cal.setTimeZone(TimeZone.getTimeZone(\"GMT+5\"));\n         cal.set(2003, 1, 10, 15, 5, 6);\n-       \n+\n         assertEquals(cal.getTime(), fdf.parse(\"2003-02-10T15:05:06.000 +0500\"));\n     }\n-    \n+\n     @Test\n     public void testParseLongShort() throws ParseException {\n-        Calendar cal= Calendar.getInstance(NEW_YORK, Locale.US);        \n+        Calendar cal= Calendar.getInstance(NEW_YORK, Locale.US);\n         cal.clear();\n         cal.set(2003, 1, 10, 15, 33, 20);\n         cal.set(Calendar.MILLISECOND, 989);\n         cal.setTimeZone(NEW_YORK);\n-        \n+\n         DateParser fdf = getInstance(\"yyyy GGGG MMMM dddd aaaa EEEE HHHH mmmm ssss SSSS ZZZZ\", NEW_YORK, Locale.US);\n-        \n+\n         assertEquals(cal.getTime(), fdf.parse(\"2003 AD February 0010 PM Monday 0015 0033 0020 0989 GMT-05:00\"));\n         cal.set(Calendar.ERA, GregorianCalendar.BC);\n-        \n+\n         Date parse = fdf.parse(\"2003 BC February 0010 PM Saturday 0015 0033 0020 0989 GMT-05:00\");\n                 assertEquals(cal.getTime(), parse);\n-                \n+\n         fdf = getInstance(\"y G M d a E H m s S Z\", NEW_YORK, Locale.US);\n         assertEquals(cal.getTime(), fdf.parse(\"03 BC 2 10 PM Sat 15 33 20 989 -0500\"));\n-        \n+\n         cal.set(Calendar.ERA, GregorianCalendar.AD);\n         assertEquals(cal.getTime(), fdf.parse(\"03 AD 2 10 PM Saturday 15 33 20 989 -0500\"));\n     }\n-    \n+\n     @Test\n     public void testAmPm() throws ParseException {\n         Calendar cal= Calendar.getInstance(NEW_YORK, Locale.US);\n         cal.clear();\n-        \n-        DateParser h = getInstance(\"yyyy-MM-dd hh a mm:ss\", NEW_YORK, Locale.US);        \n-        DateParser K = getInstance(\"yyyy-MM-dd KK a mm:ss\", NEW_YORK, Locale.US);        \n-        DateParser k = getInstance(\"yyyy-MM-dd kk:mm:ss\", NEW_YORK, Locale.US);        \n-        DateParser H = getInstance(\"yyyy-MM-dd HH:mm:ss\", NEW_YORK, Locale.US);        \n+\n+        DateParser h = getInstance(\"yyyy-MM-dd hh a mm:ss\", NEW_YORK, Locale.US);\n+        DateParser K = getInstance(\"yyyy-MM-dd KK a mm:ss\", NEW_YORK, Locale.US);\n+        DateParser k = getInstance(\"yyyy-MM-dd kk:mm:ss\", NEW_YORK, Locale.US);\n+        DateParser H = getInstance(\"yyyy-MM-dd HH:mm:ss\", NEW_YORK, Locale.US);\n \n         cal.set(2010, 7, 1, 0, 33, 20);\n         assertEquals(cal.getTime(), h.parse(\"2010-08-01 12 AM 33:20\"));\n         assertEquals(cal.getTime(), K.parse(\"2010-08-01 0 AM 33:20\"));\n         assertEquals(cal.getTime(), k.parse(\"2010-08-01 00:33:20\"));\n         assertEquals(cal.getTime(), H.parse(\"2010-08-01 00:33:20\"));\n-        \n+\n         cal.set(2010, 7, 1, 3, 33, 20);\n         assertEquals(cal.getTime(), h.parse(\"2010-08-01 3 AM 33:20\"));\n         assertEquals(cal.getTime(), K.parse(\"2010-08-01 3 AM 33:20\"));\n                         String fmt = sdf.format(in);\n                         try {\n                             Date out = sdf.parse(fmt);\n-                            \n+\n                             assertEquals(locale.toString()+\" \"+year+\" \"+ format+ \" \"+tz.getID(), in, out);\n                         } catch (ParseException pe) {\n                             System.out.println(fmt+\" \"+locale.toString()+\" \"+year+\" \"+ format+ \" \"+tz.getID());\n     }\n \n     private void testLocales(String format, boolean eraBC) throws Exception {\n-                \n+\n         Calendar cal= Calendar.getInstance(GMT);\n         cal.clear();\n         cal.set(2003, 1, 10);\n     }\n \n     private void checkParse(Locale locale, Calendar cal, SimpleDateFormat sdf, DateParser fdf) throws ParseException {\n-        String formattedDate= sdf.format(cal.getTime());                \n+        String formattedDate= sdf.format(cal.getTime());\n         Date expectedTime = sdf.parse(formattedDate);\n         Date actualTime = fdf.parse(formattedDate);\n         assertEquals(locale.toString()+\" \"+formattedDate\n                 +\"\\n\",expectedTime, actualTime);\n     }\n-    \n+\n     @Test\n     public void testParseNumerics() throws ParseException {\n         Calendar cal= Calendar.getInstance(NEW_YORK, Locale.US);\n         cal.clear();\n         cal.set(2003, 1, 10, 15, 33, 20);\n         cal.set(Calendar.MILLISECOND, 989);\n-        \n+\n         DateParser fdf = getInstance(\"yyyyMMddHHmmssSSS\", NEW_YORK, Locale.US);\n         assertEquals(cal.getTime(), fdf.parse(\"20030210153320989\"));\n     }\n-    \n+\n     @Test\n     public void testQuotes() throws ParseException {\n         Calendar cal= Calendar.getInstance(NEW_YORK, Locale.US);\n         cal.clear();\n         cal.set(2003, 1, 10, 15, 33, 20);\n         cal.set(Calendar.MILLISECOND, 989);\n-        \n+\n         DateParser fdf = getInstance(\"''yyyyMMdd'A''B'HHmmssSSS''\", NEW_YORK, Locale.US);\n         assertEquals(cal.getTime(), fdf.parse(\"'20030210A'B153320989'\"));\n     }\n-    \n+\n     @Test\n     public void testDayOf() throws ParseException {\n         Calendar cal= Calendar.getInstance(NEW_YORK, Locale.US);\n         cal.clear();\n         cal.set(2003, 1, 10);\n-        \n+\n         DateParser fdf = getInstance(\"W w F D y\", NEW_YORK, Locale.US);\n         assertEquals(cal.getTime(), fdf.parse(\"3 7 2 41 03\"));\n     }\n-    \n+\n     /**\n      * Test case for {@link FastDateParser#FastDateParser(String, TimeZone, Locale)}.\n-     * @throws ParseException \n+     * @throws ParseException\n      */\n     @Test\n     public void testShortDateStyleWithLocales() throws ParseException {\n         DateParser fdf = getDateInstance(FastDateFormat.SHORT, Locale.US);\n         Calendar cal = Calendar.getInstance();\n         cal.clear();\n-        \n+\n         cal.set(2004, 1, 3);\n         assertEquals(cal.getTime(), fdf.parse(\"2/3/04\"));\n \n \n     /**\n      * Tests that pre-1000AD years get padded with yyyy\n-     * @throws ParseException \n+     * @throws ParseException\n      */\n     @Test\n     public void testLowYearPadding() throws ParseException {\n         cal.set(999,0,1);\n         assertEquals(cal.getTime(), parser.parse(\"0999/01/01\"));\n     }\n-    \n+\n     /**\n-     * @throws ParseException \n+     * @throws ParseException\n      */\n     @Test\n     public void testMilleniumBug() throws ParseException {\n         DateParser parser = getInstance(DMY_DOT);\n         Calendar cal = Calendar.getInstance();\n         cal.clear();\n-        \n+\n         cal.set(1000,0,1);\n         assertEquals(cal.getTime(), parser.parse(\"01.01.1000\"));\n     }\n     @Test\n     public void testLang538() throws ParseException {\n         DateParser parser = getInstance(\"yyyy-MM-dd'T'HH:mm:ss.SSS'Z'\", GMT);\n-        \n+\n         Calendar cal = Calendar.getInstance(TimeZone.getTimeZone(\"GMT-8\"));\n         cal.clear();\n         cal.set(2009, 9, 16, 8, 42, 16);\n \n         assertEquals(cal.getTime(), parser.parse(\"2009-10-16T16:42:16.000Z\"));\n     }\n-    \n+\n     @Test\n     public void testEquals() {\n         DateParser parser1= getInstance(YMD_SLASH);\n         DateParser parser2= getInstance(YMD_SLASH);\n \n-        assertEquals(parser1, parser2);        \n+        assertEquals(parser1, parser2);\n         assertEquals(parser1.hashCode(), parser2.hashCode());\n-        \n+\n         assertFalse(parser1.equals(new Object()));\n     }\n \n         DateParser parser= getInstance(YMD_SLASH);\n         assertTrue(parser.toString().startsWith(\"FastDate\"));\n     }\n-    \n+\n     @Test\n     public void testPatternMatches() {\n         DateParser parser= getInstance(yMdHmsSZ);\n         assertEquals(yMdHmsSZ, parser.getPattern());\n     }\n-    \n+\n     @Test\n     public void testLocaleMatches() {\n         DateParser parser= getInstance(yMdHmsSZ, SWEDEN);\n         assertEquals(SWEDEN, parser.getLocale());\n     }\n-    \n+\n     @Test\n     public void testTimeZoneMatches() {\n         DateParser parser= getInstance(yMdHmsSZ, REYKJAVIK);", "timestamp": 1348692256, "metainfo": ""}