{"sha": "209d8f1821cd7f4b9c6f5311981eb9dfbe801302", "log": "LANG-828 FastDateParser does not handle non-Gregorian calendars properly Use Calendar#getDisplayNames() instead of DateFormatSymbols#getEras()  ", "commit": "\n--- a/src/main/java/org/apache/commons/lang3/time/FastDateParser.java\n+++ b/src/main/java/org/apache/commons/lang3/time/FastDateParser.java\n import java.text.DateFormatSymbols;\n import java.text.ParseException;\n import java.text.ParsePosition;\n-import java.text.SimpleDateFormat;\n import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.Calendar;\n import java.util.Date;\n import java.util.List;\n import java.util.Locale;\n+import java.util.Map;\n import java.util.SortedMap;\n import java.util.TimeZone;\n import java.util.TreeMap;\n             throw new IllegalArgumentException(\"Invalid pattern\");\n         }\n \n-        // These locales don't use the Gregorian calendar\n-        // See http://docs.oracle.com/javase/6/docs/technotes/guides/intl/calendar.doc.html\n-        // Also, the getEras() methods don't return the correct era names.\n-        // N.B. Not safe to use toString() comparison because that changes between Java versions\n-        if (locale.equals(JAPANESE_IMPERIAL)\n-        || (locale.getLanguage().equals(\"th\") && locale.getCountry().equals(\"TH\"))) {\n-            collector.add(new SimpleDateFormatStrategy());\n-            strategies= collector.toArray(new Strategy[collector.size()]);\n-            parsePattern= Pattern.compile(\"(.*+)\");\n-            return;\n-        }\n-\n         currentFormatField= patternMatcher.group();\n         Strategy currentStrategy= getStrategy(currentFormatField);\n         for(;;) {\n     public Date parse(String source) throws ParseException {\n         Date date= parse(source, new ParsePosition(0));\n         if(date==null) {\n-            throw new ParseException(source+\" does not match \"+parsePattern.pattern(), 0);            \n+            // Add a note re supported date range\n+            if (locale.equals(JAPANESE_IMPERIAL)) {\n+                throw new ParseException(\n+                        \"(The \" +locale + \" locale does not support dates before 1868 AD)\\n\" +\n+                        source+\" does not match \"+parsePattern.pattern(), 0);\n+            }\n+            throw new ParseException(source+\" does not match \"+parsePattern.pattern(), 0);\n         }\n         return date;\n     }\n             DateFormatSymbols symbols= DateFormatSymbols.getInstance(locale);\n             switch(field) {\n             case Calendar.ERA:\n-                fieldKeyValues= createKeyValues(symbols.getEras(), null);\n+                // DateFormatSymbols#getEras() only returns AD/BC or translations\n+                // It does not work for the Thai Buddhist or Japanese Imperial calendars.\n+                // see: https://issues.apache.org/jira/browse/TRINIDAD-2126\n+                Calendar c = Calendar.getInstance(locale);\n+                // N.B. Some calendars have different short and long symbols, e.g. ja_JP_JP\n+                String[] shortEras = toArray(c.getDisplayNames(Calendar.ERA, Calendar.SHORT, locale));\n+                String[] longEras = toArray(c.getDisplayNames(Calendar.ERA, Calendar.LONG, locale));\n+                fieldKeyValues= createKeyValues(longEras, shortEras);\n                 break;\n             case Calendar.DAY_OF_WEEK:\n                 fieldKeyValues= createKeyValues(symbols.getWeekdays(), symbols.getShortWeekdays());\n             }\n         }\n         return fieldKeyValues;\n+    }\n+\n+    private String[] toArray(Map<String, Integer> era) {\n+        String[] eras = new String[era.size()]; // assume no gaps in entry values\n+        for(Map.Entry<String, Integer> me : era.entrySet()) {\n+            int idx = me.getValue().intValue();\n+            final String key = me.getKey();\n+            if (key == null) {\n+                throw new IllegalArgumentException();\n+            }\n+            eras[idx] = key;\n+        }\n+        return eras;\n     }\n     \n     /**\n     }\n \n \n-    /**\n-     * Dummy strategy which delegates to SimpleDateFormat.\n-     */\n-    private static class SimpleDateFormatStrategy implements Strategy {\n-\n-        @Override\n-        public boolean isNumber() {\n-            return false;\n-        }\n-\n-        @Override\n-        public void setCalendar(FastDateParser parser, Calendar cal, String value) {\n-            String pat = parser.pattern;\n-            Locale loc = parser.locale;\n-            SimpleDateFormat sdf = new SimpleDateFormat(pat, loc);\n-            try {\n-                Date d = sdf.parse(value);\n-                cal.setTime(d);\n-            } catch (ParseException e) {\n-                throw new IllegalArgumentException(\n-                        \"Unexpected error using pattern \" + pat + \" with locale \" + loc.toString(), e);\n-            }\n-        }\n-\n-        @Override\n-        public boolean addRegex(FastDateParser parser, StringBuilder regex) {\n-            return false;\n-        }\n-        \n-    }\n-\n     private static final Strategy ERA_STRATEGY = new TextStrategy(Calendar.ERA);\n     private static final Strategy DAY_OF_WEEK_STRATEGY = new TextStrategy(Calendar.DAY_OF_WEEK);\n     private static final Strategy AM_PM_STRATEGY = new TextStrategy(Calendar.AM_PM);\n--- a/src/test/java/org/apache/commons/lang3/time/FastDateParserTest.java\n+++ b/src/test/java/org/apache/commons/lang3/time/FastDateParserTest.java\n import static org.junit.Assert.assertFalse;\n import static org.junit.Assert.assertTrue;\n import java.io.Serializable;\n-import java.text.DateFormatSymbols;\n import java.text.ParseException;\n import java.text.SimpleDateFormat;\n-import java.util.Arrays;\n import java.util.Calendar;\n import java.util.Date;\n import java.util.GregorianCalendar;\n import java.util.HashMap;\n-import java.util.HashSet;\n import java.util.Locale;\n import java.util.Map;\n-import java.util.Set;\n import java.util.TimeZone;\n \n import junit.framework.Assert;\n \n import org.apache.commons.lang3.SerializationUtils;\n-import org.apache.commons.lang3.tuple.ImmutablePair;\n import org.junit.Test;\n \n /**\n     }\n \n     @Test\n-    // Check that all Locales generate Strings containing the expected eras\n-    public void testEras() throws Exception {\n-        Set<ImmutablePair<Locale, String>> locale2Absent = new HashSet<ImmutablePair<Locale, String>>();\n-        Map<Locale, String[]> locale2Eras = new HashMap<Locale, String[]>();\n-        for(Locale locale : Locale.getAvailableLocales()) {\n-            for(TimeZone tz : new TimeZone[]{GMT}) {\n-                Calendar cal = Calendar.getInstance(tz);\n-                String[] eras = DateFormatSymbols.getInstance(locale).getEras();\n-                String[] erasPrint = new String[eras.length];\n-                for(int i = 0; i < eras.length ; i++) {\n-                    String s = eras[i];\n-                    if (s.length() > 4) {\n-                        erasPrint[i] = s;\n-                    } else {\n-                        erasPrint[i] = display(s);\n-                    }\n-                }\n-                for(int year : new int[]{2003, 1927, 1913, 1868, 1867, -2003}) {\n-                    cal.clear();\n-                    if (year < 0) {\n-                        cal.set(-year, 1, 10);\n-                        cal.set(Calendar.ERA, GregorianCalendar.BC);\n-                    } else {\n-                        cal.set(year, 1, 10);\n-                    }\n-                    Date in = cal.getTime();\n-                    for(String format : new String[]{\"GGGG\",\"G\"}) {\n-                        SimpleDateFormat sdf = new SimpleDateFormat(format, locale);\n-                        String fmt = sdf.format(in);\n-                        boolean found = false;\n-                        for(String era : eras) {\n-                            if (fmt.startsWith(era)) {\n-                                found=true;\n-                            }\n-                        }\n-                        if (!found) {\n-                            locale2Absent.add(ImmutablePair.of(locale, fmt));\n-                            locale2Eras.put(locale, erasPrint);\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-        \n-        if (locale2Absent.size() > 0) {\n-            System.out.println(\"FastDateParserTest: one or more missing era designators detected:\");\n-            for(ImmutablePair<Locale, String> me : locale2Absent) {\n-                Locale loc = me.getKey();\n-                String [] erasPrint = locale2Eras.get(loc);\n-                System.out.println(\"Locale: \"+loc.toString()+\" era: '\"+display(me.getValue())+\"' not found in eras: \" + Arrays.toString(erasPrint));                \n-            }\n-        }\n-//        assertFalse(\"One or more failures detected\",fail);\n-    }\n-\n-    private String display(String fmt) {\n-        if (fmt.matches(\"\\\\p{ASCII}*\")) {\n-            return fmt;\n-        }\n-        StringBuilder sb = new StringBuilder();\n-        sb.append(fmt);\n-        sb.append(\" = \");\n-        for(int i =0; i < fmt.length(); i++) {\n-            if (i > 0) {\n-                sb.append(' ');\n-            }\n-            String s = fmt.substring(i,i+1);\n-            if (s.matches(\"\\\\p{ASCII}\")) {\n-                sb.append(s);\n-            } else {\n-                char charAt = fmt.charAt(i);\n-                sb.append(\"\\\\u\");\n-                sb.append(Integer.toHexString(charAt));                \n-            }\n-        }\n-        return sb.toString();\n-    }\n-\n-    @Test\n     public void testLocales_Long_AD() throws Exception {\n         testLocales(LONG_FORMAT, false);\n     }\n         if (eraBC) {\n             cal.set(Calendar.ERA, GregorianCalendar.BC);\n         }\n-        boolean failed = false;\n         for(Locale locale : Locale.getAvailableLocales()) {\n             // ja_JP_JP cannot handle dates before 1868 properly\n-            if (eraBC && format.equals(SHORT_FORMAT) && locale.equals(FastDateParser.JAPANESE_IMPERIAL)) {\n+            if (eraBC && locale.equals(FastDateParser.JAPANESE_IMPERIAL)) {\n                 continue;\n             }\n             SimpleDateFormat sdf = new SimpleDateFormat(format, locale);\n             try {\n                 checkParse(locale, cal, sdf, fdf);\n             } catch(ParseException ex) {\n-                failed = true;\n-                // TODO: are these Java bugs?\n-                // ja_JP_JP, th_TH, and th_TH_TH fail with both eras because the generated era name does not match\n-                // ja_JP_JP fails with era BC because it converts to -2002\n-                System.out.println(\"Locale \"+locale+ \" failed with \"+format+\" era \"+(eraBC?\"BC\":\"AD\")+\"\\n\" + trimMessage(ex.toString()));\n+                Assert.fail(\"Locale \"+locale+ \" failed with \"+format+\" era \"+(eraBC?\"BC\":\"AD\")+\"\\n\" + trimMessage(ex.toString()));\n             }\n-        }\n-        if (failed) {\n-            Assert.fail(\"One or more tests failed, see above\");\n         }\n     }\n \n         String formattedDate= sdf.format(cal.getTime());                \n         Date expectedTime = sdf.parse(formattedDate);\n         Date actualTime = fdf.parse(formattedDate);\n-        assertEquals(locale.toString()+\" \"+formattedDate,expectedTime, actualTime);\n+        assertEquals(locale.toString()+\" \"+formattedDate\n+                +\"\\n\",expectedTime, actualTime);\n     }\n     \n     @Test", "timestamp": 1348682604, "metainfo": ""}