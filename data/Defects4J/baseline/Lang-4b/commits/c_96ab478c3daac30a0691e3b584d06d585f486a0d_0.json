{"sha": "96ab478c3daac30a0691e3b584d06d585f486a0d", "log": "more varargs-related updates  ", "commit": "\n--- a/src/main/java/org/apache/commons/lang3/builder/CompareToBuilder.java\n+++ b/src/main/java/org/apache/commons/lang3/builder/CompareToBuilder.java\n      *  with <code>lhs</code>\n      */\n     public static int reflectionCompare(Object lhs, Object rhs) {\n-        return reflectionCompare(lhs, rhs, false, null, null);\n+        return reflectionCompare(lhs, rhs, false, null);\n     }\n \n     /**\n      *  with <code>lhs</code>\n      */\n     public static int reflectionCompare(Object lhs, Object rhs, boolean compareTransients) {\n-        return reflectionCompare(lhs, rhs, compareTransients, null, null);\n+        return reflectionCompare(lhs, rhs, compareTransients, null);\n     }\n \n     /**\n      *  with <code>lhs</code>\n      * @since 2.2\n      */\n-    public static int reflectionCompare(Object lhs, Object rhs, String[] excludeFields) {\n+    public static int reflectionCompare(Object lhs, Object rhs, String... excludeFields) {\n         return reflectionCompare(lhs, rhs, false, null, excludeFields);\n-    }\n-\n-    /**\n-     * <p>Compares two <code>Object</code>s via reflection.</p>\n-     *\n-     * <p>Fields can be private, thus <code>AccessibleObject.setAccessible</code>\n-     * is used to bypass normal access control checks. This will fail under a \n-     * security manager unless the appropriate permissions are set.</p>\n-     *\n-     * <ul>\n-     * <li>Static fields will not be compared</li>\n-     * <li>If the <code>compareTransients</code> is <code>true</code>,\n-     *     compares transient members.  Otherwise ignores them, as they\n-     *     are likely derived fields.</li>\n-     * <li>Compares superclass fields up to and including <code>reflectUpToClass</code>.\n-     *     If <code>reflectUpToClass</code> is <code>null</code>, compares all superclass fields.</li>\n-     * </ul>\n-     *\n-     * <p>If both <code>lhs</code> and <code>rhs</code> are <code>null</code>,\n-     * they are considered equal.</p>\n-     *\n-     * @param lhs  left-hand object\n-     * @param rhs  right-hand object\n-     * @param compareTransients  whether to compare transient fields\n-     * @param reflectUpToClass  last superclass for which fields are compared\n-     * @return a negative integer, zero, or a positive integer as <code>lhs</code>\n-     *  is less than, equal to, or greater than <code>rhs</code>\n-     * @throws NullPointerException  if either <code>lhs</code> or <code>rhs</code>\n-     *  (but not both) is <code>null</code>\n-     * @throws ClassCastException  if <code>rhs</code> is not assignment-compatible\n-     *  with <code>lhs</code>\n-     * @since 2.0\n-     */\n-    public static int reflectionCompare(\n-            Object lhs, Object rhs, boolean compareTransients, Class<?> reflectUpToClass) {\n-        return reflectionCompare(lhs, rhs, compareTransients, reflectUpToClass, null);\n     }\n \n     /**\n      *  (but not both) is <code>null</code>\n      * @throws ClassCastException  if <code>rhs</code> is not assignment-compatible\n      *  with <code>lhs</code>\n-     * @since 2.2\n+     * @since 2.2 (2.0 as <code>reflectionCompare(Object, Object, boolean, Class)</code>)\n      */\n     public static int reflectionCompare(\n         Object lhs, \n         Object rhs, \n         boolean compareTransients, \n         Class<?> reflectUpToClass, \n-        String[] excludeFields) {\n+        String... excludeFields) {\n \n         if (lhs == rhs) {\n             return 0;\n--- a/src/main/java/org/apache/commons/lang3/builder/EqualsBuilder.java\n+++ b/src/main/java/org/apache/commons/lang3/builder/EqualsBuilder.java\n      *\n      * @param lhs  <code>this</code> object\n      * @param rhs  the other object\n+     * @param excludeFields  Collection of String field names to exclude from testing\n      * @return <code>true</code> if the two Objects have tested equals.\n      */\n-    public static boolean reflectionEquals(Object lhs, Object rhs) {\n-        return reflectionEquals(lhs, rhs, false, null, null);\n+    public static boolean reflectionEquals(Object lhs, Object rhs, Collection<String> excludeFields) {\n+        return reflectionEquals(lhs, rhs, ReflectionToStringBuilder.toNoNullStringArray(excludeFields));\n     }\n \n     /**\n      *\n      * @param lhs  <code>this</code> object\n      * @param rhs  the other object\n-     * @param excludeFields  Collection of String field names to exclude from testing\n+     * @param excludeFields  array of field names to exclude from testing\n      * @return <code>true</code> if the two Objects have tested equals.\n      */\n-    public static boolean reflectionEquals(Object lhs, Object rhs, Collection<String> excludeFields) {\n-        return reflectionEquals(lhs, rhs, ReflectionToStringBuilder.toNoNullStringArray(excludeFields));\n+    public static boolean reflectionEquals(Object lhs, Object rhs, String... excludeFields) {\n+        return reflectionEquals(lhs, rhs, false, null, excludeFields);\n     }\n \n     /**\n      * a security manager, if the permissions are not set up correctly. It is also\n      * not as efficient as testing explicitly.</p>\n      *\n-     * <p>Transient members will be not be tested, as they are likely derived\n-     * fields, and not part of the value of the Object.</p>\n-     *\n-     * <p>Static fields will not be tested. Superclass fields will be included.</p>\n-     *\n-     * @param lhs  <code>this</code> object\n-     * @param rhs  the other object\n-     * @param excludeFields  array of field names to exclude from testing\n-     * @return <code>true</code> if the two Objects have tested equals.\n-     */\n-    public static boolean reflectionEquals(Object lhs, Object rhs, String[] excludeFields) {\n-        return reflectionEquals(lhs, rhs, false, null, excludeFields);\n-    }\n-\n-    /**\n-     * <p>This method uses reflection to determine if the two <code>Object</code>s\n-     * are equal.</p>\n-     *\n-     * <p>It uses <code>AccessibleObject.setAccessible</code> to gain access to private\n-     * fields. This means that it will throw a security exception if run under\n-     * a security manager, if the permissions are not set up correctly. It is also\n-     * not as efficient as testing explicitly.</p>\n-     *\n      * <p>If the TestTransients parameter is set to <code>true</code>, transient\n      * members will be tested, otherwise they are ignored, as they are likely\n      * derived fields, and not part of the value of the <code>Object</code>.</p>\n      * @return <code>true</code> if the two Objects have tested equals.\n      */\n     public static boolean reflectionEquals(Object lhs, Object rhs, boolean testTransients) {\n-        return reflectionEquals(lhs, rhs, testTransients, null, null);\n-    }\n-\n-    /**\n-     * <p>This method uses reflection to determine if the two <code>Object</code>s\n-     * are equal.</p>\n-     *\n-     * <p>It uses <code>AccessibleObject.setAccessible</code> to gain access to private\n-     * fields. This means that it will throw a security exception if run under\n-     * a security manager, if the permissions are not set up correctly. It is also\n-     * not as efficient as testing explicitly.</p>\n-     *\n-     * <p>If the testTransients parameter is set to <code>true</code>, transient\n-     * members will be tested, otherwise they are ignored, as they are likely\n-     * derived fields, and not part of the value of the <code>Object</code>.</p>\n-     *\n-     * <p>Static fields will not be included. Superclass fields will be appended\n-     * up to and including the specified superclass. A null superclass is treated\n-     * as java.lang.Object.</p>\n-     *\n-     * @param lhs  <code>this</code> object\n-     * @param rhs  the other object\n-     * @param testTransients  whether to include transient fields\n-     * @param reflectUpToClass  the superclass to reflect up to (inclusive),\n-     *  may be <code>null</code>\n-     * @return <code>true</code> if the two Objects have tested equals.\n-     * @since 2.0\n-     */\n-    public static boolean reflectionEquals(Object lhs, Object rhs, boolean testTransients, Class<?> reflectUpToClass) {\n-        return reflectionEquals(lhs, rhs, testTransients, reflectUpToClass, null);\n+        return reflectionEquals(lhs, rhs, testTransients, null);\n     }\n \n     /**\n      * @since 2.0\n      */\n     public static boolean reflectionEquals(Object lhs, Object rhs, boolean testTransients, Class<?> reflectUpToClass,\n-            String[] excludeFields) {\n+            String... excludeFields) {\n         if (lhs == rhs) {\n             return true;\n         }\n--- a/src/main/java/org/apache/commons/lang3/builder/HashCodeBuilder.java\n+++ b/src/main/java/org/apache/commons/lang3/builder/HashCodeBuilder.java\n      *             if the number is zero or even\n      */\n     public static int reflectionHashCode(int initialNonZeroOddNumber, int multiplierNonZeroOddNumber, Object object) {\n-        return reflectionHashCode(initialNonZeroOddNumber, multiplierNonZeroOddNumber, object, false, null, null);\n+        return reflectionHashCode(initialNonZeroOddNumber, multiplierNonZeroOddNumber, object, false, null);\n     }\n \n     /**\n      */\n     public static int reflectionHashCode(int initialNonZeroOddNumber, int multiplierNonZeroOddNumber, Object object,\n             boolean testTransients) {\n-        return reflectionHashCode(initialNonZeroOddNumber, multiplierNonZeroOddNumber, object, testTransients, null,\n-                null);\n-    }\n-\n-    /**\n-     * Calls {@link #reflectionHashCode(int, int, Object, boolean, Class, String[])} with excludeFields set to\n-     * <code>null</code>.\n-     *\n-     * @param <T>\n-     *            the type of the object involved\n-     * @param initialNonZeroOddNumber\n-     *            a non-zero, odd number used as the initial value\n-     * @param multiplierNonZeroOddNumber\n-     *            a non-zero, odd number used as the multiplier\n-     * @param object\n-     *            the Object to create a <code>hashCode</code> for\n-     * @param testTransients\n-     *            whether to include transient fields\n-     * @param reflectUpToClass\n-     *            the superclass to reflect up to (inclusive), may be <code>null</code>\n-     * @return int hash code\n-     */\n-    public static <T> int reflectionHashCode(int initialNonZeroOddNumber, int multiplierNonZeroOddNumber, T object,\n-            boolean testTransients, Class<? super T> reflectUpToClass) {\n-        return reflectionHashCode(initialNonZeroOddNumber, multiplierNonZeroOddNumber, object, testTransients,\n-                reflectUpToClass, null);\n+        return reflectionHashCode(initialNonZeroOddNumber, multiplierNonZeroOddNumber, object, testTransients, null);\n     }\n \n     /**\n      * @since 2.0\n      */\n     public static <T> int reflectionHashCode(int initialNonZeroOddNumber, int multiplierNonZeroOddNumber, T object,\n-            boolean testTransients, Class<? super T> reflectUpToClass, String[] excludeFields) {\n+            boolean testTransients, Class<? super T> reflectUpToClass, String... excludeFields) {\n \n         if (object == null) {\n             throw new IllegalArgumentException(\"The object to build a hash code for must not be null\");\n             reflectionAppend(object, clazz, builder, testTransients, excludeFields);\n         }\n         return builder.toHashCode();\n-    }\n-\n-    /**\n-     * <p>\n-     * This method uses reflection to build a valid hash code.\n-     * </p>\n-     *\n-     * <p>\n-     * This constructor uses two hard coded choices for the constants needed to build a hash code.\n-     * </p>\n-     *\n-     * <p>\n-     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n-     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n-     * also not as efficient as testing explicitly.\n-     * </p>\n-     *\n-     * <p>\n-     * Transient members will be not be used, as they are likely derived fields, and not part of the value of the\n-     * <code>Object</code>.\n-     * </p>\n-     *\n-     * <p>\n-     * Static fields will not be tested. Superclass fields will be included.\n-     * </p>\n-     *\n-     * @param object\n-     *            the Object to create a <code>hashCode</code> for\n-     * @return int hash code\n-     * @throws IllegalArgumentException\n-     *             if the object is <code>null</code>\n-     */\n-    public static int reflectionHashCode(Object object) {\n-        return reflectionHashCode(17, 37, object, false, null, null);\n     }\n \n     /**\n      *             if the object is <code>null</code>\n      */\n     public static int reflectionHashCode(Object object, boolean testTransients) {\n-        return reflectionHashCode(17, 37, object, testTransients, null, null);\n+        return reflectionHashCode(17, 37, object, testTransients, null);\n     }\n \n     /**\n      * @throws IllegalArgumentException\n      *             if the object is <code>null</code>\n      */\n-    public static int reflectionHashCode(Object object, String[] excludeFields) {\n+    public static int reflectionHashCode(Object object, String... excludeFields) {\n         return reflectionHashCode(17, 37, object, false, null, excludeFields);\n     }\n \n--- a/src/main/java/org/apache/commons/lang3/builder/ReflectionToStringBuilder.java\n+++ b/src/main/java/org/apache/commons/lang3/builder/ReflectionToStringBuilder.java\n     }\n \n     /**\n-     * Builds a String for a toString method excluding the given field name.\n-     *\n-     * @param object\n-     *            The object to \"toString\".\n-     * @param excludeFieldName\n-     *            The field name to exclude\n-     * @return The toString value.\n-     */\n-    public static String toStringExclude(Object object, final String excludeFieldName) {\n-        return toStringExclude(object, new String[] { excludeFieldName });\n-    }\n-\n-    /**\n      * Builds a String for a toString method excluding the given field names.\n      *\n      * @param object\n      *            The field names to exclude\n      * @return The toString value.\n      */\n-    public static String toStringExclude(Object object, String[] excludeFieldNames) {\n+    public static String toStringExclude(Object object, String... excludeFieldNames) {\n         return new ReflectionToStringBuilder(object).setExcludeFieldNames(excludeFieldNames).toString();\n     }\n \n      *            The excludeFieldNames to excluding from toString or <code>null</code>.\n      * @return <code>this</code>\n      */\n-    public ReflectionToStringBuilder setExcludeFieldNames(String[] excludeFieldNamesParam) {\n+    public ReflectionToStringBuilder setExcludeFieldNames(String... excludeFieldNamesParam) {\n         if (excludeFieldNamesParam == null) {\n             this.excludeFieldNames = null;\n         } else {\n-            this.excludeFieldNames = toNoNullStringArray(excludeFieldNamesParam);\n+            this.excludeFieldNames = excludeFieldNamesParam.clone();\n             Arrays.sort(this.excludeFieldNames);\n         }\n         return this;", "timestamp": 1302447803, "metainfo": ""}