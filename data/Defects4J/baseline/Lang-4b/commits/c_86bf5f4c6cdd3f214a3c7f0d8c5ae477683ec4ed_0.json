{"sha": "86bf5f4c6cdd3f214a3c7f0d8c5ae477683ec4ed", "log": "Moved isAssignmentCompatable method from MethodUtils into ReflectionUtils and renamed it. Enhanced existing isCompatible so that widening of primitives is allowed. Created test case for moved method.   ", "commit": "\n--- a/src/java/org/apache/commons/lang/reflect/MethodUtils.java\n+++ b/src/java/org/apache/commons/lang/reflect/MethodUtils.java\n  * @author Gregor Raman\n  * @author Jan Sorensen\n  * @author Robert Burrell Donkin\n- * @version $Id: MethodUtils.java,v 1.4 2002/11/18 23:00:26 rdonkin Exp $\n+ * @version $Id: MethodUtils.java,v 1.5 2002/11/20 21:45:47 rdonkin Exp $\n  */\n public class MethodUtils {\n     \n                             log(\"Param=\" + parameterTypes[n].getName());\n                             log(\"Method=\" + methodsParams[n].getName());\n                         }\n-                        if (!isAssignmentCompatible(methodsParams[n], parameterTypes[n])) {\n+                        if (!ReflectionUtils.isCompatable(parameterTypes[n], methodsParams[n])) {\n                             if (debug) {\n                                 log(methodsParams[n] + \" is not assignable from \" \n                                             + parameterTypes[n]);\n         // didn't find a match\n         log(\"No match found.\");\n         return null;                                        \n-    }\n-\n-\n-    /**\n-     * <p>Determine whether a type can be used as a parameter in a method invocation.\n-     * This method handles primitive conversions correctly.</p>\n-     *\n-     * <p>In order words, it will match a <code>Boolean</code> to a <code>boolean</code>,\n-     * a <code>Long</code> to a <code>long</code>,\n-     * a <code>Float</code> to a <code>float</code>,\n-     * a <code>Integer</code> to a <code>int</code>,\n-     * and a <code>Double</code> to a <code>double</code>.\n-     * Now logic widening matches are allowed.\n-     * For example, a <code>Long</code> will not match a <code>int</code>.\n-     *\n-     * @param parameterType the type of parameter accepted by the method\n-     * @param parameterization the type of parameter being tested \n-     *\n-     * @return true if the assignement is compatible.\n-     */\n-    private static final boolean isAssignmentCompatible(Class parameterType, Class parameterization) {\n-        // try plain assignment\n-        if (parameterType.isAssignableFrom(parameterization)) {\n-            return true;\n-        }\n-        \n-        if (parameterType.isPrimitive()) {\n-            // does anyone know a better strategy than comparing names?\n-            // also, this method does *not* do widening - you must specify exactly\n-            // is this the right behaviour?\n-            if (boolean.class.equals(parameterType)) {\n-                return Boolean.class.equals(parameterization);\n-            }         \n-            if (float.class.equals(parameterType)) {\n-                return Float.class.equals(parameterization);\n-            }     \n-            if (long.class.equals(parameterType)) {\n-                return Long.class.equals(parameterization);\n-            }     \n-            if (int.class.equals(parameterType)) {\n-                return Integer.class.equals(parameterization);\n-            }                \n-            if (double.class.equals(parameterType)) {\n-                return Double.class.equals(parameterization);\n-            }               \n-        }\n-        \n-        return false;\n-    }\n-    \n+    }    \n     \n     private static void log(Object o) {\n         if (debug) {\n--- a/src/java/org/apache/commons/lang/reflect/ReflectionUtils.java\n+++ b/src/java/org/apache/commons/lang/reflect/ReflectionUtils.java\n  * reflection.\n  *\n  * @author <a href=\"mailto:scolebourne@apache.org\">Stephen Colebourne</a>\n- * @version $Id: ReflectionUtils.java,v 1.2 2002/11/18 23:01:36 rdonkin Exp $\n+ * @version $Id: ReflectionUtils.java,v 1.3 2002/11/20 21:45:47 rdonkin Exp $\n  */\n public class ReflectionUtils {\n     \n      * Primitive classes are handled correctly .\n      * <p>\n      * In other words, a <code>boolean</code> Class will be converted to \n-     * a <code>Boolean</code> Class and so on.\n+     * a <code>Boolean</code> Class and so on.</p>\n+     *\n+     * <p>This method also handles widening for primitives as given in section 5.1.2 of the\n+     * <em><a href=\"http://java.sun.com/docs/books/jls/\">The Java Language Specification</a></em>.\n      *\n      * @param requestedTypes  the class array requested\n      * @param paramTypes  the actual class array for the method\n             paramTypes = ArrayUtils.EMPTY_CLASS_ARRAY;\n         }\n         for (int i = 0; i < requestedTypes.length; i++) {\n-            if (ClassUtils.isAssignable(requestedTypes[i], paramTypes[i]) == false) {\n+            if (isCompatable(requestedTypes[i], paramTypes[i]) == false) {\n                 return false;\n             }\n         }\n         return true;\n     }\n+    \n+\n+    /**\n+     * <p>Determine whether a type can be used as a parameter in a method invocation.\n+     * This method handles primitive conversions correctly.</p>\n+     *\n+     * <p>This method also handles widening for primitives as given in section 5.1.2 of the\n+     * <em><a href=\"http://java.sun.com/docs/books/jls/\">The Java Language Specification</a></em>.\n+     *\n+     * @param parameterType the type of parameter accepted by the method\n+     * @param requestedType the type of parameter being requested \n+     *\n+     * @return true if the assignement is compatible.\n+     */\n+    public static boolean isCompatable(Class requestedType, Class parameterType) {\n+        // try plain assignment\n+        if (ClassUtils.isAssignable(requestedType, parameterType)) {\n+            return true;\n+        }\n+        \n+        if (parameterType.isPrimitive()) {\n+            // also, this method does *not* do widening - you must specify exactly\n+            // is this the right behaviour?\n+            if (boolean.class.equals(parameterType)) {\n+                return Boolean.class.equals(requestedType);\n+            }              \n+            \n+            if (byte.class.equals(parameterType)) {\n+                return Byte.class.equals(requestedType);\n+            }\n+            \n+            if (short.class.equals(parameterType)) {\n+                return (Short.class.equals(requestedType)\n+                        || Byte.class.equals(requestedType));\n+            }                    \n+            \n+            if (char.class.equals(parameterType)) {\n+                return Character.class.equals(requestedType);\n+            }\n+                               \n+            if (int.class.equals(parameterType)) {\n+                return (Integer.class.equals(requestedType)\n+                        || Character.class.equals(requestedType)\n+                        || Short.class.equals(requestedType)\n+                        || Byte.class.equals(requestedType));\n+            }       \n+            if (long.class.equals(parameterType)) {\n+                return (Long.class.equals(requestedType) \n+                        || Integer.class.equals(requestedType)\n+                        || Character.class.equals(requestedType)\n+                        || Short.class.equals(requestedType)\n+                        || Byte.class.equals(requestedType));\n+            }                   \n+                \n+            if (float.class.equals(parameterType)) {\n+                return (Float.class.equals(requestedType)\n+                        || Long.class.equals(requestedType)\n+                        || Integer.class.equals(requestedType)\n+                        || Character.class.equals(requestedType)\n+                        || Short.class.equals(requestedType)\n+                        || Byte.class.equals(requestedType));\n+            }     \n+               \n+            if (double.class.equals(parameterType)) {\n+                return (Double.class.equals(requestedType)\t\n+                        || Float.class.equals(requestedType)\n+                        || Long.class.equals(requestedType)\n+                        || Integer.class.equals(requestedType)\n+                        || Character.class.equals(requestedType)\n+                        || Short.class.equals(requestedType)\n+                        || Byte.class.equals(requestedType));\n+            }   \n+        }\n+        \n+        return false;\n+    }\n+\n     \n     /**\n      * Converts a primitive class to its matching object class.\n--- a/src/test/org/apache/commons/lang/reflect/PrimitiveBean.java\n+++ b/src/test/org/apache/commons/lang/reflect/PrimitiveBean.java\n     private boolean _boolean;\n     private long _long;\n     private int _int;\n+    private short _short;\n+    \n+    public short getShort() {\n+        return _short;\n+    }\n+    \n+    public void setShort(short _short) {\n+        this._short = _short;\n+    }\n     \n     public float getFloat() {\n         return _float;\n--- a/src/test/org/apache/commons/lang/reflect/ReflectionUtilsTestCase.java\n+++ b/src/test/org/apache/commons/lang/reflect/ReflectionUtilsTestCase.java\n         assertEquals(\"Static scope (method) [isPublicScope]\", true, ReflectionUtils.isPublicScope(method));\n         assertEquals(\"Static scope (method) [isStatic]\", true, ReflectionUtils.isStatic(method));\n     }\n+    \n+    public void testWidening() throws Exception\n+    {\n+        // test byte conversions\n+        assertEquals(\"byte -> char\", ReflectionUtils.isCompatable(Byte.class, char.class), false);\n+        assertEquals(\"byte -> byte\", ReflectionUtils.isCompatable(Byte.class, byte.class), true);\n+        assertEquals(\"byte -> short\", ReflectionUtils.isCompatable(Byte.class, short.class), true);\n+        assertEquals(\"byte -> int\", ReflectionUtils.isCompatable(Byte.class, int.class), true);\n+        assertEquals(\"byte -> long\", ReflectionUtils.isCompatable(Byte.class, long.class), true);\n+        assertEquals(\"byte -> float\", ReflectionUtils.isCompatable(Byte.class, float.class), true);\n+        assertEquals(\"byte -> double\", ReflectionUtils.isCompatable(Byte.class, double.class), true);\n+        assertEquals(\"byte -> boolean\", ReflectionUtils.isCompatable(Byte.class, boolean.class), false);\n+        \n+        // test short conversions\n+        assertEquals(\"short -> char\", ReflectionUtils.isCompatable(Short.class, char.class), false);\n+        assertEquals(\"short -> byte\", ReflectionUtils.isCompatable(Short.class, byte.class), false);\n+        assertEquals(\"short -> short\", ReflectionUtils.isCompatable(Short.class, short.class), true);\n+        assertEquals(\"short -> int\", ReflectionUtils.isCompatable(Short.class, int.class), true);\n+        assertEquals(\"short -> long\", ReflectionUtils.isCompatable(Short.class, long.class), true);\n+        assertEquals(\"short -> float\", ReflectionUtils.isCompatable(Short.class, float.class), true);\n+        assertEquals(\"short -> double\", ReflectionUtils.isCompatable(Short.class, double.class), true);\n+        assertEquals(\"short -> boolean\", ReflectionUtils.isCompatable(Short.class, boolean.class), false);\n+        \n+        // test char conversions\n+        assertEquals(\"char -> char\", ReflectionUtils.isCompatable(Character.class, char.class), true);\n+        assertEquals(\"char -> byte\", ReflectionUtils.isCompatable(Character.class, byte.class), false);\n+        assertEquals(\"char -> short\", ReflectionUtils.isCompatable(Character.class, short.class), false);\n+        assertEquals(\"char -> int\", ReflectionUtils.isCompatable(Character.class, int.class), true);\n+        assertEquals(\"char -> long\", ReflectionUtils.isCompatable(Character.class, long.class), true);\n+        assertEquals(\"char -> float\", ReflectionUtils.isCompatable(Character.class, float.class), true);\n+        assertEquals(\"char -> double\", ReflectionUtils.isCompatable(Character.class, double.class), true);\n+        assertEquals(\"char -> boolean\", ReflectionUtils.isCompatable(Character.class, boolean.class), false);\n+        \n+        // test int conversions\n+        assertEquals(\"int -> char\", ReflectionUtils.isCompatable(Integer.class, char.class), false);\n+        assertEquals(\"int -> byte\", ReflectionUtils.isCompatable(Integer.class, byte.class), false);\n+        assertEquals(\"int -> short\", ReflectionUtils.isCompatable(Integer.class, short.class), false);\n+        assertEquals(\"int -> int\", ReflectionUtils.isCompatable(Integer.class, int.class), true);\n+        assertEquals(\"int -> long\", ReflectionUtils.isCompatable(Integer.class, long.class), true);\n+        assertEquals(\"int -> float\", ReflectionUtils.isCompatable(Integer.class, float.class), true);\n+        assertEquals(\"int -> double\", ReflectionUtils.isCompatable(Integer.class, double.class), true);\n+        assertEquals(\"int -> boolean\", ReflectionUtils.isCompatable(Integer.class, boolean.class), false);\n+ \n+        // test long conversions\n+        assertEquals(\"long -> char\", ReflectionUtils.isCompatable(Long.class, char.class), false);\n+        assertEquals(\"long -> byte\", ReflectionUtils.isCompatable(Long.class, byte.class), false);\n+        assertEquals(\"long -> short\", ReflectionUtils.isCompatable(Long.class, short.class), false);\n+        assertEquals(\"long -> int\", ReflectionUtils.isCompatable(Long.class, int.class), false);\n+        assertEquals(\"long -> long\", ReflectionUtils.isCompatable(Long.class, long.class), true);\n+        assertEquals(\"long -> float\", ReflectionUtils.isCompatable(Long.class, float.class), true);\n+        assertEquals(\"long -> double\", ReflectionUtils.isCompatable(Long.class, double.class), true);\n+        assertEquals(\"long -> boolean\", ReflectionUtils.isCompatable(Long.class, boolean.class), false);\n+ \n+        // test float conversions\n+        assertEquals(\"float -> char\", ReflectionUtils.isCompatable(Float.class, char.class), false);\n+        assertEquals(\"float -> byte\", ReflectionUtils.isCompatable(Float.class, byte.class), false);\n+        assertEquals(\"float -> short\", ReflectionUtils.isCompatable(Float.class, short.class), false);\n+        assertEquals(\"float -> int\", ReflectionUtils.isCompatable(Float.class, int.class), false);\n+        assertEquals(\"float -> long\", ReflectionUtils.isCompatable(Float.class, long.class), false);\n+        assertEquals(\"float -> float\", ReflectionUtils.isCompatable(Float.class, float.class), true);\n+        assertEquals(\"float -> double\", ReflectionUtils.isCompatable(Float.class, double.class), true);\n+        assertEquals(\"float -> boolean\", ReflectionUtils.isCompatable(Float.class, boolean.class), false);\n+        \n+        // test float conversions\n+        assertEquals(\"double -> char\", ReflectionUtils.isCompatable(Double.class, char.class), false);\n+        assertEquals(\"double -> byte\", ReflectionUtils.isCompatable(Double.class, byte.class), false);\n+        assertEquals(\"double -> short\", ReflectionUtils.isCompatable(Double.class, short.class), false);\n+        assertEquals(\"double -> int\", ReflectionUtils.isCompatable(Double.class, int.class), false);\n+        assertEquals(\"double -> long\", ReflectionUtils.isCompatable(Double.class, long.class), false);\n+        assertEquals(\"double -> float\", ReflectionUtils.isCompatable(Double.class, float.class), false);\n+        assertEquals(\"double -> double\", ReflectionUtils.isCompatable(Double.class, double.class), true);\n+        assertEquals(\"double -> boolean\", ReflectionUtils.isCompatable(Double.class, boolean.class), false);\n+        \n+        // test float conversions\n+        assertEquals(\"boolean -> char\", ReflectionUtils.isCompatable(Boolean.class, char.class), false);\n+        assertEquals(\"boolean -> byte\", ReflectionUtils.isCompatable(Boolean.class, byte.class), false);\n+        assertEquals(\"boolean -> short\", ReflectionUtils.isCompatable(Boolean.class, short.class), false);\n+        assertEquals(\"boolean -> int\", ReflectionUtils.isCompatable(Boolean.class, int.class), false);\n+        assertEquals(\"boolean -> long\", ReflectionUtils.isCompatable(Boolean.class, long.class), false);\n+        assertEquals(\"boolean -> float\", ReflectionUtils.isCompatable(Boolean.class, float.class), false);\n+        assertEquals(\"boolean -> double\", ReflectionUtils.isCompatable(Boolean.class, double.class), false);\n+        assertEquals(\"boolean -> boolean\", ReflectionUtils.isCompatable(Boolean.class, boolean.class), true);\n+    }\n }", "timestamp": 1037828747, "metainfo": ""}