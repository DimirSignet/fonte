{"sha": "29468bd78b6c58c84c85fd32506be37184a961ee", "log": "Remove superfluous parens like: return (foo + 1); int len = (foo + 1); if ((foo + 1 > 2)) ((String) foo)    ", "commit": "\n--- a/src/main/java/org/apache/commons/lang3/BooleanUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/BooleanUtils.java\n         switch (str.length()) {\n             case 1: {\n                 char ch0 = str.charAt(0);\n-                if ((ch0 == 'y' || ch0 == 'Y') ||\n-                    (ch0 == 't' || ch0 == 'T')) {\n+                if (ch0 == 'y' || ch0 == 'Y' ||\n+                    ch0 == 't' || ch0 == 'T') {\n                     return Boolean.TRUE;\n                 }\n-                if ((ch0 == 'n' || ch0 == 'N') ||\n-                    (ch0 == 'f' || ch0 == 'F')) {\n+                if (ch0 == 'n' || ch0 == 'N' ||\n+                    ch0 == 'f' || ch0 == 'F') {\n                     return Boolean.FALSE;\n                 }\n                 break;\n--- a/src/main/java/org/apache/commons/lang3/CharSequenceUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/CharSequenceUtils.java\n     static boolean regionMatches(CharSequence cs, boolean ignoreCase, int thisStart,\n             CharSequence substring, int start, int length)    {\n         if (cs instanceof String && substring instanceof String) {\n-            return ((String) cs).regionMatches(ignoreCase, thisStart, ((String) substring), start, length);\n+            return ((String) cs).regionMatches(ignoreCase, thisStart, (String) substring, start, length);\n         } else {\n             // TODO: Implement rather than convert to String\n             return cs.toString().regionMatches(ignoreCase, thisStart, substring.toString(), start, length);\n--- a/src/main/java/org/apache/commons/lang3/CharSet.java\n+++ b/src/main/java/org/apache/commons/lang3/CharSet.java\n         int len = str.length();\n         int pos = 0;\n         while (pos < len) {\n-            int remainder = (len - pos);\n+            int remainder = len - pos;\n             if (remainder >= 4 && str.charAt(pos) == '^' && str.charAt(pos + 2) == '-') {\n                 // negated range\n                 set.add(CharRange.isNotIn(str.charAt(pos + 1), str.charAt(pos + 3)));\n--- a/src/main/java/org/apache/commons/lang3/ClassUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/ClassUtils.java\n         }\n         // have to check for null, as isAssignableFrom doesn't\n         if (cls == null) {\n-            return !(toClass.isPrimitive());\n+            return !toClass.isPrimitive();\n         }\n         //autoboxing:\n         if (autoboxing) {\n--- a/src/main/java/org/apache/commons/lang3/EnumUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/EnumUtils.java\n         Validate.notNull(values);\n         long total = 0;\n         for (E constant : values) {\n-            total |= (1 << constant.ordinal());\n+            total |= 1 << constant.ordinal();\n         }\n         return total;\n     }\n         final E[] constants = checkBitVectorable(enumClass).getEnumConstants();\n         final EnumSet<E> results = EnumSet.noneOf(enumClass);\n         for (E constant : constants) {\n-            if ((value & (1 << constant.ordinal())) != 0) {\n+            if ((value & 1 << constant.ordinal()) != 0) {\n                 results.add(constant);\n             }\n         }\n--- a/src/main/java/org/apache/commons/lang3/ObjectUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/ObjectUtils.java\n         if (object1 == object2) {\n             return true;\n         }\n-        if ((object1 == null) || (object2 == null)) {\n+        if (object1 == null || object2 == null) {\n             return false;\n         }\n         return object1.equals(object2);\n      */\n     public static int hashCode(Object obj) {\n         // hashCode(Object) retained for performance, as hash code is often critical\n-        return (obj == null) ? 0 : obj.hashCode();\n+        return obj == null ? 0 : obj.hashCode();\n     }\n \n     /**\n         if (c1 == c2) {\n             return 0;\n         } else if (c1 == null) {\n-            return (nullGreater ? 1 : -1);\n+            return nullGreater ? 1 : -1;\n         } else if (c2 == null) {\n-            return (nullGreater ? -1 : 1);\n+            return nullGreater ? -1 : 1;\n         }\n         return c1.compareTo(c2);\n     }\n--- a/src/main/java/org/apache/commons/lang3/RandomStringUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/RandomStringUtils.java\n         } else if (count < 0) {\n             throw new IllegalArgumentException(\"Requested random string length \" + count + \" is less than 0.\");\n         }\n-        if ((start == 0) && (end == 0)) {\n+        if (start == 0 && end == 0) {\n             end = 'z' + 1;\n             start = ' ';\n             if (!letters && !numbers) {\n             } else {\n                 ch = chars[random.nextInt(gap) + start];\n             }\n-            if ((letters && Character.isLetter(ch))\n-                    || (numbers && Character.isDigit(ch))\n-                    || (!letters && !numbers)) {\n+            if (letters && Character.isLetter(ch)\n+                    || numbers && Character.isDigit(ch)\n+                    || !letters && !numbers) {\n                 if(ch >= 56320 && ch <= 57343) {\n                     if(count == 0) {\n                         count++;\n--- a/src/main/java/org/apache/commons/lang3/Range.java\n+++ b/src/main/java/org/apache/commons/lang3/Range.java\n         if (element == null) {\n             return false;\n         }\n-        return (comparator.compare(element, minimum) > -1) && (comparator.compare(element, maximum) < 1);\n+        return comparator.compare(element, minimum) > -1 && comparator.compare(element, maximum) < 1;\n     }\n \n     /**\n--- a/src/main/java/org/apache/commons/lang3/StringUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/StringUtils.java\n             return true;\n         }\n         for (int i = 0; i < strLen; i++) {\n-            if ((Character.isWhitespace(cs.charAt(i)) == false)) {\n+            if (Character.isWhitespace(cs.charAt(i)) == false) {\n                 return false;\n             }\n         }\n         }\n         int start = 0;\n         if (stripChars == null) {\n-            while ((start != strLen) && Character.isWhitespace(str.charAt(start))) {\n+            while (start != strLen && Character.isWhitespace(str.charAt(start))) {\n                 start++;\n             }\n         } else if (stripChars.length() == 0) {\n             return str;\n         } else {\n-            while ((start != strLen) && (stripChars.indexOf(str.charAt(start)) != INDEX_NOT_FOUND)) {\n+            while (start != strLen && stripChars.indexOf(str.charAt(start)) != INDEX_NOT_FOUND) {\n                 start++;\n             }\n         }\n         }\n \n         if (stripChars == null) {\n-            while ((end != 0) && Character.isWhitespace(str.charAt(end - 1))) {\n+            while (end != 0 && Character.isWhitespace(str.charAt(end - 1))) {\n                 end--;\n             }\n         } else if (stripChars.length() == 0) {\n             return str;\n         } else {\n-            while ((end != 0) && (stripChars.indexOf(str.charAt(end - 1)) != INDEX_NOT_FOUND)) {\n+            while (end != 0 && stripChars.indexOf(str.charAt(end - 1)) != INDEX_NOT_FOUND) {\n                 end--;\n             }\n         }\n         if (startPos < 0) {\n             startPos = 0;\n         }\n-        int endLimit = (str.length() - searchStr.length()) + 1;\n+        int endLimit = str.length() - searchStr.length() + 1;\n         if (startPos > endLimit) {\n             return INDEX_NOT_FOUND;\n         }\n         if (str == null || searchStr == null) {\n             return INDEX_NOT_FOUND;\n         }\n-        if (startPos > (str.length() - searchStr.length())) {\n+        if (startPos > str.length() - searchStr.length()) {\n             startPos = str.length() - searchStr.length();\n         }\n         if (startPos < 0) {\n             }\n         }\n \n-        return (ret == Integer.MAX_VALUE) ? INDEX_NOT_FOUND : ret;\n+        return ret == Integer.MAX_VALUE ? INDEX_NOT_FOUND : ret;\n     }\n \n     /**\n         if (pos < 0) {\n             pos = 0;\n         }\n-        if (str.length() <= (pos + len)) {\n+        if (str.length() <= pos + len) {\n             return str.substring(pos);\n         }\n         return str.substring(pos, pos + len);\n             return EMPTY;\n         }\n         int pos = str.lastIndexOf(separator);\n-        if (pos == INDEX_NOT_FOUND || pos == (str.length() - separator.length())) {\n+        if (pos == INDEX_NOT_FOUND || pos == str.length() - separator.length()) {\n             return EMPTY;\n         }\n         return str.substring(pos + separator.length());\n         int openLen = open.length();\n         List<String> list = new ArrayList<String>();\n         int pos = 0;\n-        while (pos < (strLen - closeLen)) {\n+        while (pos < strLen - closeLen) {\n             int start = str.indexOf(open, pos);\n             if (start < 0) {\n                 break;\n             return ArrayUtils.EMPTY_STRING_ARRAY;\n         }\n \n-        if ((separator == null) || (EMPTY.equals(separator))) {\n+        if (separator == null || EMPTY.equals(separator)) {\n             // Split on whitespace.\n             return splitWorker(str, null, max, preserveAllTokens);\n         }\n             match = true;\n             i++;\n         }\n-        if (match || (preserveAllTokens && lastMatch)) {\n+        if (match || preserveAllTokens && lastMatch) {\n             list.add(str.substring(start, i));\n         }\n         return list.toArray(new String[list.size()]);\n                 i++;\n             }\n         }\n-        if (match || (preserveAllTokens && lastMatch)) {\n+        if (match || preserveAllTokens && lastMatch) {\n             list.add(str.substring(start, i));\n         }\n         return list.toArray(new String[list.size()]);\n         if (array == null) {\n             return null;\n         }\n-        int noOfItems = (endIndex - startIndex);\n+        int noOfItems = endIndex - startIndex;\n         if (noOfItems <= 0) {\n             return EMPTY;\n         }\n \n         // endIndex - startIndex > 0:   Len = NofStrings *(len(firstString) + len(separator))\n         //           (Assuming that all Strings are roughly equally long)\n-        int noOfItems = (endIndex - startIndex);\n+        int noOfItems = endIndex - startIndex;\n         if (noOfItems <= 0) {\n             return EMPTY;\n         }\n         }\n         int replLength = searchString.length();\n         int increase = replacement.length() - replLength;\n-        increase = (increase < 0 ? 0 : increase);\n-        increase *= (max < 0 ? 16 : (max > 64 ? 64 : max));\n+        increase = increase < 0 ? 0 : increase;\n+        increase *= max < 0 ? 16 : max > 64 ? 64 : max;\n         StringBuilder buf = new StringBuilder(text.length() + increase);\n         while (end != INDEX_NOT_FOUND) {\n             buf.append(text.substring(start, end)).append(replacement);\n         }\n         int sz = cs.length();\n         for (int i = 0; i < sz; i++) {\n-            if ((Character.isLetter(cs.charAt(i)) == false) && (cs.charAt(i) != ' ')) {\n+            if (Character.isLetter(cs.charAt(i)) == false && cs.charAt(i) != ' ') {\n                 return false;\n             }\n         }\n         }\n         int sz = cs.length();\n         for (int i = 0; i < sz; i++) {\n-            if ((Character.isLetterOrDigit(cs.charAt(i)) == false) && (cs.charAt(i) != ' ')) {\n+            if (Character.isLetterOrDigit(cs.charAt(i)) == false && cs.charAt(i) != ' ') {\n                 return false;\n             }\n         }\n         }\n         int sz = cs.length();\n         for (int i = 0; i < sz; i++) {\n-            if ((Character.isDigit(cs.charAt(i)) == false) && (cs.charAt(i) != ' ')) {\n+            if (Character.isDigit(cs.charAt(i)) == false && cs.charAt(i) != ' ') {\n                 return false;\n             }\n         }\n         }\n         int sz = cs.length();\n         for (int i = 0; i < sz; i++) {\n-            if ((Character.isWhitespace(cs.charAt(i)) == false)) {\n+            if (Character.isWhitespace(cs.charAt(i)) == false) {\n                 return false;\n             }\n         }\n         if (offset > str.length()) {\n             offset = str.length();\n         }\n-        if ((str.length() - offset) < (maxWidth - 3)) {\n+        if (str.length() - offset < maxWidth - 3) {\n             offset = str.length() - (maxWidth - 3);\n         }\n         final String abrevMarker = \"...\";\n         if (maxWidth < 7) {\n             throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\");\n         }\n-        if ((offset + (maxWidth - 3)) < str.length()) {\n+        if (offset + maxWidth - 3 < str.length()) {\n             return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3);\n         }\n         return abrevMarker + str.substring(str.length() - (maxWidth - 3));\n             return str;\n         }\n \n-        if (length >= str.length() || length < (middle.length()+2)) {\n+        if (length >= str.length() || length < middle.length()+2) {\n             return str;\n         }\n \n         }\n \n         // handle lists containing all nulls or all empty strings\n-        if (allStringsNull || (longestStrLen == 0 && !anyStringNull)) {\n+        if (allStringsNull || longestStrLen == 0 && !anyStringNull) {\n             return INDEX_NOT_FOUND;\n         }\n \n      */\n     private static boolean startsWith(CharSequence str, CharSequence prefix, boolean ignoreCase) {\n         if (str == null || prefix == null) {\n-            return (str == null && prefix == null);\n+            return str == null && prefix == null;\n         }\n         if (prefix.length() > str.length()) {\n             return false;\n--- a/src/main/java/org/apache/commons/lang3/concurrent/ConcurrentUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/concurrent/ConcurrentUtils.java\n      */\n     public static <T> T initialize(ConcurrentInitializer<T> initializer)\n             throws ConcurrentException {\n-        return (initializer != null) ? initializer.get() : null;\n+        return initializer != null ? initializer.get() : null;\n     }\n \n     /**\n         }\n \n         V result = map.putIfAbsent(key, value);\n-        return (result != null) ? result : value;\n+        return result != null ? result : value;\n     }\n \n     /**\n--- a/src/main/java/org/apache/commons/lang3/concurrent/ConstantInitializer.java\n+++ b/src/main/java/org/apache/commons/lang3/concurrent/ConstantInitializer.java\n      */\n     @Override\n     public int hashCode() {\n-        return (getObject() != null) ? getObject().hashCode() : 0;\n+        return getObject() != null ? getObject().hashCode() : 0;\n     }\n \n     /**\n--- a/src/main/java/org/apache/commons/lang3/concurrent/TimedSemaphore.java\n+++ b/src/main/java/org/apache/commons/lang3/concurrent/TimedSemaphore.java\n      * unit\n      */\n     public synchronized double getAverageCallsPerPeriod() {\n-        return (periodCount == 0) ? 0 : (double) totalAcquireCount\n+        return periodCount == 0 ? 0 : (double) totalAcquireCount\n                 / (double) periodCount;\n     }\n \n--- a/src/main/java/org/apache/commons/lang3/exception/ExceptionUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/exception/ExceptionUtils.java\n      */\n     public static Throwable getRootCause(Throwable throwable) {\n         List<Throwable> list = getThrowableList(throwable);\n-        return (list.size() < 2 ? null : (Throwable)list.get(list.size() - 1));\n+        return list.size() < 2 ? null : (Throwable)list.get(list.size() - 1);\n     }\n \n     /**\n      */\n     public static String getRootCauseMessage(Throwable th) {\n         Throwable root = ExceptionUtils.getRootCause(th);\n-        root = (root == null ? th : root);\n+        root = root == null ? th : root;\n         return getMessage(root);\n     }\n \n--- a/src/main/java/org/apache/commons/lang3/math/Fraction.java\n+++ b/src/main/java/org/apache/commons/lang3/math/Fraction.java\n      * @throws ArithmeticException if the the algorithm does not converge\n      */\n     public static Fraction getFraction(double value) {\n-        int sign = (value < 0 ? -1 : 1);\n+        int sign = value < 0 ? -1 : 1;\n         value = Math.abs(value);\n         if (value  > Integer.MAX_VALUE || Double.isNaN(value)) {\n             throw new ArithmeticException\n             denom1 = denom2;\n             i++;\n //            System.out.println(\">>\" + delta1 +\" \"+ delta2+\" \"+(delta1 > delta2)+\" \"+i+\" \"+denom2);\n-        } while ((delta1 > delta2) && (denom2 <= 10000) && (denom2 > 0) && (i < 25));\n+        } while (delta1 > delta2 && denom2 <= 10000 && denom2 > 0 && i < 25);\n         if (i == 25) {\n             throw new ArithmeticException(\"Unable to convert double to fraction\");\n         }\n      */\n     @Override\n     public float floatValue() {\n-        return ((float) numerator) / ((float) denominator);\n+        return (float) numerator / (float) denominator;\n     }\n \n     /**\n      */\n     @Override\n     public double doubleValue() {\n-        return ((double) numerator) / ((double) denominator);\n+        return (double) numerator / (double) denominator;\n     }\n \n     // Calculations\n             return this.invert().pow(-power);\n         } else {\n             Fraction f = this.multiplyBy(this);\n-            if ((power % 2) == 0) { // if even...\n+            if (power % 2 == 0) { // if even...\n                 return f.pow(power/2);\n             } else { // if odd...\n                 return f.pow(power/2).multiplyBy(this);\n      */\n     private static int greatestCommonDivisor(int u, int v) {\n         // From Commons Math:\n-        if ((u == 0) || (v == 0)) {\n-            if ((u == Integer.MIN_VALUE) || (v == Integer.MIN_VALUE)) {\n+        if (u == 0 || v == 0) {\n+            if (u == Integer.MIN_VALUE || v == Integer.MIN_VALUE) {\n                 throw new ArithmeticException(\"overflow: gcd is 2^31\");\n             }\n             return Math.abs(u) + Math.abs(v);\n         }\n         // B2. Initialize: u and v have been divided by 2^k and at least\n         //     one is odd.\n-        int t = ((u&1)==1) ? v : -(u/2)/*B3*/;\n+        int t = (u&1)==1 ? v : -(u/2)/*B3*/;\n         // t negative: u was odd, v may be even (t replaces v)\n         // t positive: u was even, v is odd (t replaces u)\n         do {\n      *                             an int\n      */\n     private static int mulAndCheck(int x, int y) {\n-        long m = ((long)x)*((long)y);\n+        long m = (long)x*(long)y;\n         if (m < Integer.MIN_VALUE ||\n             m > Integer.MAX_VALUE) {\n             throw new ArithmeticException(\"overflow: mul\");\n      */\n     private static int mulPosAndCheck(int x, int y) {\n         /* assert x>=0 && y>=0; */\n-        long m = ((long)x)*((long)y);\n+        long m = (long)x*(long)y;\n         if (m > Integer.MAX_VALUE) {\n             throw new ArithmeticException(\"overflow: mulPos\");\n         }\n         // but d2 doesn't need extra precision because\n         // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n         int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n-        int d2 = (tmodd1==0)?d1:greatestCommonDivisor(tmodd1, d1);\n+        int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n \n         // result is (t/d2) / (u'/d1)(v'/d2)\n         BigInteger w = t.divide(BigInteger.valueOf(d2));\n             return false;\n         }\n         Fraction other = (Fraction) obj;\n-        return (getNumerator() == other.getNumerator() &&\n-                getDenominator() == other.getDenominator());\n+        return getNumerator() == other.getNumerator() &&\n+                getDenominator() == other.getDenominator();\n     }\n \n     /**\n--- a/src/main/java/org/apache/commons/lang3/mutable/MutableDouble.java\n+++ b/src/main/java/org/apache/commons/lang3/mutable/MutableDouble.java\n      */\n     @Override\n     public boolean equals(Object obj) {\n-        return (obj instanceof MutableDouble)\n-            && (Double.doubleToLongBits(((MutableDouble) obj).value) == Double.doubleToLongBits(value));\n+        return obj instanceof MutableDouble\n+            && Double.doubleToLongBits(((MutableDouble) obj).value) == Double.doubleToLongBits(value);\n     }\n \n     /**\n     @Override\n     public int hashCode() {\n         long bits = Double.doubleToLongBits(value);\n-        return (int) (bits ^ (bits >>> 32));\n+        return (int) (bits ^ bits >>> 32);\n     }\n \n     //-----------------------------------------------------------------------\n--- a/src/main/java/org/apache/commons/lang3/mutable/MutableFloat.java\n+++ b/src/main/java/org/apache/commons/lang3/mutable/MutableFloat.java\n      */\n     @Override\n     public boolean equals(Object obj) {\n-        return (obj instanceof MutableFloat)\n-            && (Float.floatToIntBits(((MutableFloat) obj).value) == Float.floatToIntBits(value));\n+        return obj instanceof MutableFloat\n+            && Float.floatToIntBits(((MutableFloat) obj).value) == Float.floatToIntBits(value);\n     }\n \n     /**\n--- a/src/main/java/org/apache/commons/lang3/text/StrSubstitutor.java\n+++ b/src/main/java/org/apache/commons/lang3/text/StrSubstitutor.java\n         StrMatcher suffixMatcher = getVariableSuffixMatcher();\n         char escape = getEscapeChar();\n \n-        boolean top = (priorVariables == null);\n+        boolean top = priorVariables == null;\n         boolean altered = false;\n         int lengthChange = 0;\n         char[] chars = buf.buffer;\n                                     int change = substitute(buf, startPos,\n                                             varLen, priorVariables);\n                                     change = change\n-                                            + (varLen - (endPos - startPos));\n+                                            + varLen - (endPos - startPos);\n                                     pos += change;\n                                     bufEnd += change;\n                                     lengthChange += change;\n             }\n         }\n         if (top) {\n-            return (altered ? 1 : 0);\n+            return altered ? 1 : 0;\n         }\n         return lengthChange;\n     }\n--- a/src/main/java/org/apache/commons/lang3/text/StrTokenizer.java\n+++ b/src/main/java/org/apache/commons/lang3/text/StrTokenizer.java\n         // string or the end of the input\n         workArea.clear();\n         int pos = start;\n-        boolean quoting = (quoteLen > 0);\n+        boolean quoting = quoteLen > 0;\n         int trimStart = 0;\n         \n         while (pos < len) {\n                     if (isQuote(chars, pos + quoteLen, len, quoteStart, quoteLen)) {\n                         // matched pair of quotes, thus an escaped quote\n                         workArea.append(chars, pos, quoteLen);\n-                        pos += (quoteLen * 2);\n+                        pos += quoteLen * 2;\n                         trimStart = workArea.size();\n                         continue;\n                     }\n      */\n     private boolean isQuote(char[] chars, int pos, int len, int quoteStart, int quoteLen) {\n         for (int i = 0; i < quoteLen; i++) {\n-            if ((pos + i) >= len || chars[pos + i] != chars[quoteStart + i]) {\n+            if (pos + i >= len || chars[pos + i] != chars[quoteStart + i]) {\n                 return false;\n             }\n         }\n--- a/src/main/java/org/apache/commons/lang3/text/WordUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/text/WordUtils.java\n         int offset = 0;\n         StringBuilder wrappedLine = new StringBuilder(inputLineLength + 32);\n         \n-        while ((inputLineLength - offset) > wrapLength) {\n+        while (inputLineLength - offset > wrapLength) {\n             if (str.charAt(offset) == ' ') {\n                 offset++;\n                 continue;\n      * @since 2.1\n      */\n     public static String capitalizeFully(String str, char... delimiters) {\n-        int delimLen = (delimiters == null ? -1 : delimiters.length);\n+        int delimLen = delimiters == null ? -1 : delimiters.length;\n         if (StringUtils.isEmpty(str) || delimLen == 0) {\n             return str;\n         }\n      * @since 2.1\n      */\n     public static String uncapitalize(String str, char... delimiters) {\n-        int delimLen = (delimiters == null ? -1 : delimiters.length);\n+        int delimLen = delimiters == null ? -1 : delimiters.length;\n         if (StringUtils.isEmpty(str) || delimLen == 0) {\n             return str;\n         }\n--- a/src/main/java/org/apache/commons/lang3/text/translate/NumericEntityUnescaper.java\n+++ b/src/main/java/org/apache/commons/lang3/text/translate/NumericEntityUnescaper.java\n      * @return whether the option is set\n      */\n     public boolean isSet(OPTION option) { \n-        return (options == null) ? false : options.contains(option);\n+        return options == null ? false : options.contains(option);\n     }\n \n     /**\n \n             int end = start;\n             // Note that this supports character codes without a ; on the end\n-            while(end < seqEnd && ( (input.charAt(end) >= '0' && input.charAt(end) <= '9') ||\n-                                    (input.charAt(end) >= 'a' && input.charAt(end) <= 'f') ||\n-                                    (input.charAt(end) >= 'A' && input.charAt(end) <= 'F') ) )\n+            while(end < seqEnd && ( input.charAt(end) >= '0' && input.charAt(end) <= '9' ||\n+                                    input.charAt(end) >= 'a' && input.charAt(end) <= 'f' ||\n+                                    input.charAt(end) >= 'A' && input.charAt(end) <= 'F' ) )\n             {\n                 end++;\n             }\n \n-            boolean semiNext = (end != seqEnd) && (input.charAt(end) == ';');\n+            boolean semiNext = end != seqEnd && input.charAt(end) == ';';\n \n             if(!semiNext) {\n                 if(isSet(OPTION.semiColonRequired)) {\n                 out.write(entityValue);\n             }\n \n-            return 2 + (end - start) + (isHex ? 1 : 0) + (semiNext ? 1 : 0);\n+            return 2 + end - start + (isHex ? 1 : 0) + (semiNext ? 1 : 0);\n         }\n         return 0;\n     }\n--- a/src/main/java/org/apache/commons/lang3/text/translate/UnicodeUnescaper.java\n+++ b/src/main/java/org/apache/commons/lang3/text/translate/UnicodeUnescaper.java\n      */\n     @Override\n     public int translate(CharSequence input, int index, Writer out) throws IOException {\n-        if (input.charAt(index) == '\\\\' && (index + 1 < input.length()) && input.charAt(index + 1) == 'u') {\n+        if (input.charAt(index) == '\\\\' && index + 1 < input.length() && input.charAt(index + 1) == 'u') {\n             // consume optional additional 'u' chars\n             int i = 2;\n-            while ((index + i < input.length()) && input.charAt(index + i) == 'u') {\n+            while (index + i < input.length() && input.charAt(index + i) == 'u') {\n                 i++;\n             }\n \n-            if ((index + i < input.length()) && (input.charAt(index + i) == '+')) {\n+            if (index + i < input.length() && input.charAt(index + i) == '+') {\n                 i++;\n             }\n \n-            if ((index + i + 4 <= input.length())) {\n+            if (index + i + 4 <= input.length()) {\n                 // Get 4 hex digits\n                 CharSequence unicode = input.subSequence(index + i, index + i + 4);\n \n--- a/src/main/java/org/apache/commons/lang3/time/StopWatch.java\n+++ b/src/main/java/org/apache/commons/lang3/time/StopWatch.java\n         if (this.runningState != STATE_SUSPENDED) {\n             throw new IllegalStateException(\"Stopwatch must be suspended to resume. \");\n         }\n-        this.startTime += (System.nanoTime() - this.stopTime);\n+        this.startTime += System.nanoTime() - this.stopTime;\n         this.runningState = STATE_RUNNING;\n     }\n \n--- a/src/test/java/org/apache/commons/lang3/ArrayUtilsAddTest.java\n+++ b/src/test/java/org/apache/commons/lang3/ArrayUtilsAddTest.java\n \n         //show that not casting is okay\n         newArray = ArrayUtils.add((Object[])null, \"a\");\n-        assertTrue(Arrays.equals((new String[]{\"a\"}), newArray));\n-        assertTrue(Arrays.equals((new Object[]{\"a\"}), newArray));\n+        assertTrue(Arrays.equals(new String[]{\"a\"}, newArray));\n+        assertTrue(Arrays.equals(new Object[]{\"a\"}, newArray));\n         assertEquals(String.class, newArray.getClass().getComponentType());\n \n         //show that not casting to Object[] is okay and will assume String based on \"a\"\n         String[] newStringArray = ArrayUtils.add(null, \"a\");\n-        assertTrue(Arrays.equals((new String[]{\"a\"}), newStringArray));\n-        assertTrue(Arrays.equals((new Object[]{\"a\"}), newStringArray));\n+        assertTrue(Arrays.equals(new String[]{\"a\"}, newStringArray));\n+        assertTrue(Arrays.equals(new Object[]{\"a\"}, newStringArray));\n         assertEquals(String.class, newStringArray.getClass().getComponentType());\n \n         String[] stringArray1 = new String[]{\"a\", \"b\", \"c\"};\n         newArray = ArrayUtils.add(stringArray1, null);\n-        assertTrue(Arrays.equals((new String[]{\"a\", \"b\", \"c\", null}), newArray));\n+        assertTrue(Arrays.equals(new String[]{\"a\", \"b\", \"c\", null}, newArray));\n         assertEquals(String.class, newArray.getClass().getComponentType());\n \n         newArray = ArrayUtils.add(stringArray1, \"d\");\n-        assertTrue(Arrays.equals((new String[]{\"a\", \"b\", \"c\", \"d\"}), newArray));\n+        assertTrue(Arrays.equals(new String[]{\"a\", \"b\", \"c\", \"d\"}, newArray));\n         assertEquals(String.class, newArray.getClass().getComponentType());\n \n         Number[] numberArray1 = new Number[]{Integer.valueOf(1), Double.valueOf(2)};\n         newArray = ArrayUtils.add(numberArray1, Float.valueOf(3));\n-        assertTrue(Arrays.equals((new Number[]{Integer.valueOf(1), Double.valueOf(2), Float.valueOf(3)}), newArray));\n+        assertTrue(Arrays.equals(new Number[]{Integer.valueOf(1), Double.valueOf(2), Float.valueOf(3)}, newArray));\n         assertEquals(Number.class, newArray.getClass().getComponentType());\n \n         numberArray1 = null;\n         newArray = ArrayUtils.add(numberArray1, Float.valueOf(3));\n-        assertTrue(Arrays.equals((new Float[]{Float.valueOf(3)}), newArray));\n+        assertTrue(Arrays.equals(new Float[]{Float.valueOf(3)}, newArray));\n         assertEquals(Float.class, newArray.getClass().getComponentType());\n     }\n     \n         newArray = ArrayUtils.addAll(stringArray1, (String[]) null);\n         assertNotSame(stringArray1, newArray);\n         assertTrue(Arrays.equals(stringArray1, newArray));\n-        assertTrue(Arrays.equals((new String[]{\"a\", \"b\", \"c\"}), newArray));\n+        assertTrue(Arrays.equals(new String[]{\"a\", \"b\", \"c\"}, newArray));\n         assertEquals(String.class, newArray.getClass().getComponentType());\n         newArray = ArrayUtils.addAll(null, stringArray2);\n         assertNotSame(stringArray2, newArray);\n         assertTrue(Arrays.equals(stringArray2, newArray));\n-        assertTrue(Arrays.equals((new String[]{\"1\", \"2\", \"3\"}), newArray));\n+        assertTrue(Arrays.equals(new String[]{\"1\", \"2\", \"3\"}, newArray));\n         assertEquals(String.class, newArray.getClass().getComponentType());\n         newArray = ArrayUtils.addAll(stringArray1, stringArray2);\n-        assertTrue(Arrays.equals((new String[]{\"a\", \"b\", \"c\", \"1\", \"2\", \"3\"}), newArray));\n+        assertTrue(Arrays.equals(new String[]{\"a\", \"b\", \"c\", \"1\", \"2\", \"3\"}, newArray));\n         assertEquals(String.class, newArray.getClass().getComponentType());\n         newArray = ArrayUtils.addAll(ArrayUtils.EMPTY_STRING_ARRAY, (String[]) null);\n         assertTrue(Arrays.equals(ArrayUtils.EMPTY_STRING_ARRAY, newArray));\n-        assertTrue(Arrays.equals((new String[]{}), newArray));\n+        assertTrue(Arrays.equals(new String[]{}, newArray));\n         assertEquals(String.class, newArray.getClass().getComponentType());\n         newArray = ArrayUtils.addAll(null, ArrayUtils.EMPTY_STRING_ARRAY);\n         assertTrue(Arrays.equals(ArrayUtils.EMPTY_STRING_ARRAY, newArray));\n-        assertTrue(Arrays.equals((new String[]{}), newArray));\n+        assertTrue(Arrays.equals(new String[]{}, newArray));\n         assertEquals(String.class, newArray.getClass().getComponentType());\n         newArray = ArrayUtils.addAll(ArrayUtils.EMPTY_STRING_ARRAY, ArrayUtils.EMPTY_STRING_ARRAY);\n         assertTrue(Arrays.equals(ArrayUtils.EMPTY_STRING_ARRAY, newArray));\n-        assertTrue(Arrays.equals((new String[]{}), newArray));\n+        assertTrue(Arrays.equals(new String[]{}, newArray));\n         assertEquals(String.class, newArray.getClass().getComponentType());\n         String[] stringArrayNull = new String []{null};\n         newArray = ArrayUtils.addAll(stringArrayNull, stringArrayNull);\n-        assertTrue(Arrays.equals((new String[]{null, null}), newArray));\n+        assertTrue(Arrays.equals(new String[]{null, null}, newArray));\n         assertEquals(String.class, newArray.getClass().getComponentType());\n \n         // boolean\n     public void testAddObjectAtIndex() {\n         Object[] newArray;\n         newArray = ArrayUtils.add((Object[])null, 0, \"a\");\n-        assertTrue(Arrays.equals((new String[]{\"a\"}), newArray));\n-        assertTrue(Arrays.equals((new Object[]{\"a\"}), newArray));\n+        assertTrue(Arrays.equals(new String[]{\"a\"}, newArray));\n+        assertTrue(Arrays.equals(new Object[]{\"a\"}, newArray));\n         assertEquals(String.class, newArray.getClass().getComponentType());\n         String[] stringArray1 = new String[]{\"a\", \"b\", \"c\"};\n         newArray = ArrayUtils.add(stringArray1, 0, null);\n-        assertTrue(Arrays.equals((new String[]{null, \"a\", \"b\", \"c\"}), newArray));\n+        assertTrue(Arrays.equals(new String[]{null, \"a\", \"b\", \"c\"}, newArray));\n         assertEquals(String.class, newArray.getClass().getComponentType());\n         newArray = ArrayUtils.add(stringArray1, 1, null);\n-        assertTrue(Arrays.equals((new String[]{\"a\", null, \"b\", \"c\"}), newArray));\n+        assertTrue(Arrays.equals(new String[]{\"a\", null, \"b\", \"c\"}, newArray));\n         assertEquals(String.class, newArray.getClass().getComponentType());\n         newArray = ArrayUtils.add(stringArray1, 3, null);\n-        assertTrue(Arrays.equals((new String[]{\"a\", \"b\", \"c\", null}), newArray));\n+        assertTrue(Arrays.equals(new String[]{\"a\", \"b\", \"c\", null}, newArray));\n         assertEquals(String.class, newArray.getClass().getComponentType());\n         newArray = ArrayUtils.add(stringArray1, 3, \"d\");\n-        assertTrue(Arrays.equals((new String[]{\"a\", \"b\", \"c\", \"d\"}), newArray));\n+        assertTrue(Arrays.equals(new String[]{\"a\", \"b\", \"c\", \"d\"}, newArray));\n         assertEquals(String.class, newArray.getClass().getComponentType());\n         assertEquals(String.class, newArray.getClass().getComponentType());\n \n--- a/src/test/java/org/apache/commons/lang3/BitFieldTest.java\n+++ b/src/test/java/org/apache/commons/lang3/BitFieldTest.java\n         }\n         for (int j = 0; j < 128; j++) {\n             assertEquals(bf_zero.getShortValue(bf_zero.setShortValue((short) 0, (short) j)), (short) 0);\n-            assertEquals(bf_zero.setShortValue((short) 0, (short) j), (short) (0));\n+            assertEquals(bf_zero.setShortValue((short) 0, (short) j), (short) 0);\n         }\n \n         // verify that excess bits are stripped off\n--- a/src/test/java/org/apache/commons/lang3/CharUtilsPerfRun.java\n+++ b/src/test/java/org/apache/commons/lang3/CharUtilsPerfRun.java\n         int t = 0;\n         for (int i = 0; i < loopCount; i++) {\n             for (char ch : CHAR_SAMPLES) {\n-                boolean b = (ch >= '0' && ch <= '9');\n+                boolean b = ch >= '0' && ch <= '9';\n                 t += b ? 1 : 0;\n             }\n         }\n--- a/src/test/java/org/apache/commons/lang3/RandomStringUtilsTest.java\n+++ b/src/test/java/org/apache/commons/lang3/RandomStringUtilsTest.java\n         double sumSq = 0.0d;\n         double dev = 0.0d;\n         for (int i = 0; i < observed.length; i++) {\n-            dev = (observed[i] - expected[i]);\n+            dev = observed[i] - expected[i];\n             sumSq += dev * dev / expected[i];\n         }\n         return sumSq;\n         for (int i=0; i < orig.length() && i < copy.length(); i++) {\n             char o = orig.charAt(i);\n             char c = copy.charAt(i);\n-            assertEquals(\"differs at \" + i + \"(\" + Integer.toHexString((new Character(o)).hashCode()) + \",\" +\n-            Integer.toHexString((new Character(c)).hashCode()) + \")\", o, c);\n+            assertEquals(\"differs at \" + i + \"(\" + Integer.toHexString(new Character(o).hashCode()) + \",\" +\n+            Integer.toHexString(new Character(c).hashCode()) + \")\", o, c);\n         }\n         // compare length also\n         assertEquals(orig.length(), copy.length());\n--- a/src/test/java/org/apache/commons/lang3/builder/CompareToBuilderTest.java\n+++ b/src/test/java/org/apache/commons/lang3/builder/CompareToBuilderTest.java\n                 return false;\n             }\n             TestObject rhs = (TestObject) o;\n-            return (a == rhs.a);\n+            return a == rhs.a;\n         }\n \n         public void setA(int a) {\n             return a;\n         }\n         public int compareTo(TestObject rhs) {\n-            return (a < rhs.a) ? -1 : (a > rhs.a) ? +1 : 0;\n+            return a < rhs.a ? -1 : a > rhs.a ? +1 : 0;\n         }\n     }\n \n                 return false;\n             }\n             TestSubObject rhs = (TestSubObject) o;\n-            return super.equals(o) && (b == rhs.b);\n+            return super.equals(o) && b == rhs.b;\n         }\n     }\n \n         }\n         \n         // strongly recommended but not strictly required\n-        assertTrue((CompareToBuilder.reflectionCompare(x, y, testTransients) ==0 ) == EqualsBuilder.reflectionEquals(x, y, testTransients));\n+        assertTrue(CompareToBuilder.reflectionCompare(x, y, testTransients) ==0 == EqualsBuilder.reflectionEquals(x, y, testTransients));\n     }\n     \n     /**\n         float[][] array3 = new float[2][3];\n         for (int i = 0; i < array1.length; ++i) {\n             for (int j = 0; j < array1[0].length; j++) {\n-                array1[i][j] = ((i + 1) * (j + 1));\n-                array2[i][j] = ((i + 1) * (j + 1));\n-                array3[i][j] = ((i + 1) * (j + 1));\n+                array1[i][j] = (i + 1) * (j + 1);\n+                array2[i][j] = (i + 1) * (j + 1);\n+                array3[i][j] = (i + 1) * (j + 1);\n             }\n         }\n         array3[1][2] = 100;\n         double[][] array3 = new double[2][3];\n         for (int i = 0; i < array1.length; ++i) {\n             for (int j = 0; j < array1[0].length; j++) {\n-                array1[i][j] = ((i + 1) * (j + 1));\n-                array2[i][j] = ((i + 1) * (j + 1));\n-                array3[i][j] = ((i + 1) * (j + 1));\n+                array1[i][j] = (i + 1) * (j + 1);\n+                array2[i][j] = (i + 1) * (j + 1);\n+                array3[i][j] = (i + 1) * (j + 1);\n             }\n         }\n         array3[1][2] = 100;\n         boolean[][] array3 = new boolean[2][3];\n         for (int i = 0; i < array1.length; ++i) {\n             for (int j = 0; j < array1[0].length; j++) {\n-                array1[i][j] = ((i == 1) ^ (j == 1));\n-                array2[i][j] = ((i == 1) ^ (j == 1));\n-                array3[i][j] = ((i == 1) ^ (j == 1));\n+                array1[i][j] = i == 1 ^ j == 1;\n+                array2[i][j] = i == 1 ^ j == 1;\n+                array3[i][j] = i == 1 ^ j == 1;\n             }\n         }\n         array3[1][2] = false;\n--- a/src/test/java/org/apache/commons/lang3/builder/EqualsBuilderTest.java\n+++ b/src/test/java/org/apache/commons/lang3/builder/EqualsBuilderTest.java\n             }\n \n             TestObject rhs = (TestObject) o;\n-            return (a == rhs.a);\n+            return a == rhs.a;\n         }\n \n         public void setA(int a) {\n             }\n \n             TestSubObject rhs = (TestSubObject) o;\n-            return super.equals(o) && (b == rhs.b);\n+            return super.equals(o) && b == rhs.b;\n         }\n \n         public void setB(int b) {\n         boolean[][] array2 = new boolean[2][2];\n         for (int i = 0; i < array1.length; ++i) {\n             for (int j = 0; j < array1[0].length; j++) {\n-                array1[i][j] = (i == 1) || (j == 1);\n-                array2[i][j] = (i == 1) || (j == 1);\n+                array1[i][j] = i == 1 || j == 1;\n+                array2[i][j] = i == 1 || j == 1;\n             }\n         }\n         assertTrue(new EqualsBuilder().append(array1, array1).isEquals());\n--- a/src/test/java/org/apache/commons/lang3/builder/HashCodeBuilderTest.java\n+++ b/src/test/java/org/apache/commons/lang3/builder/HashCodeBuilderTest.java\n                 return false;\n             }\n             TestObject rhs = (TestObject) o;\n-            return (a == rhs.a);\n+            return a == rhs.a;\n         }\n \n         public void setA(int a) {\n                 return false;\n             }\n             TestSubObject rhs = (TestSubObject) o;\n-            return super.equals(o) && (b == rhs.b);\n+            return super.equals(o) && b == rhs.b;\n         }\n     }\n \n     @Test\n     public void testSuper() {\n         Object obj = new Object();\n-        assertEquals(17 * 37 + (19 * 41 + obj.hashCode()), new HashCodeBuilder(17, 37).appendSuper(\n+        assertEquals(17 * 37 + 19 * 41 + obj.hashCode(), new HashCodeBuilder(17, 37).appendSuper(\n                 new HashCodeBuilder(19, 41).append(obj).toHashCode()).toHashCode());\n     }\n \n     @SuppressWarnings(\"cast\") // cast is not really needed, keep for consistency\n     public void testLong() {\n         assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((long) 0L).toHashCode());\n-        assertEquals(17 * 37 + (int) (123456789L ^ (123456789L >> 32)), new HashCodeBuilder(17, 37).append(\n+        assertEquals(17 * 37 + (int) (123456789L ^ 123456789L >> 32), new HashCodeBuilder(17, 37).append(\n                 (long) 123456789L).toHashCode());\n     }\n \n         assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((double) 0d).toHashCode());\n         double d = 1234567.89;\n         long l = Double.doubleToLongBits(d);\n-        assertEquals(17 * 37 + (int) (l ^ (l >> 32)), new HashCodeBuilder(17, 37).append(d).toHashCode());\n+        assertEquals(17 * 37 + (int) (l ^ l >> 32), new HashCodeBuilder(17, 37).append(d).toHashCode());\n     }\n \n     @Test\n     public void testObjectArray() {\n         assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((Object[]) null).toHashCode());\n         Object[] obj = new Object[2];\n-        assertEquals((17 * 37) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());\n+        assertEquals(17 * 37 * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());\n         obj[0] = new Object();\n         assertEquals((17 * 37 + obj[0].hashCode()) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());\n         obj[1] = new Object();\n     @Test\n     public void testObjectArrayAsObject() {\n         Object[] obj = new Object[2];\n-        assertEquals((17 * 37) * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());\n+        assertEquals(17 * 37 * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());\n         obj[0] = new Object();\n         assertEquals((17 * 37 + obj[0].hashCode()) * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());\n         obj[1] = new Object();\n     public void testLongArray() {\n         assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((long[]) null).toHashCode());\n         long[] obj = new long[2];\n-        assertEquals((17 * 37) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());\n+        assertEquals(17 * 37 * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());\n         obj[0] = 5L;\n-        int h1 = (int) (5L ^ (5L >> 32));\n+        int h1 = (int) (5L ^ 5L >> 32);\n         assertEquals((17 * 37 + h1) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());\n         obj[1] = 6L;\n-        int h2 = (int) (6L ^ (6L >> 32));\n+        int h2 = (int) (6L ^ 6L >> 32);\n         assertEquals((17 * 37 + h1) * 37 + h2, new HashCodeBuilder(17, 37).append(obj).toHashCode());\n     }\n \n     @Test\n     public void testLongArrayAsObject() {\n         long[] obj = new long[2];\n-        assertEquals((17 * 37) * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());\n+        assertEquals(17 * 37 * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());\n         obj[0] = 5L;\n-        int h1 = (int) (5L ^ (5L >> 32));\n+        int h1 = (int) (5L ^ 5L >> 32);\n         assertEquals((17 * 37 + h1) * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());\n         obj[1] = 6L;\n-        int h2 = (int) (6L ^ (6L >> 32));\n+        int h2 = (int) (6L ^ 6L >> 32);\n         assertEquals((17 * 37 + h1) * 37 + h2, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());\n     }\n \n     public void testIntArray() {\n         assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((int[]) null).toHashCode());\n         int[] obj = new int[2];\n-        assertEquals((17 * 37) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());\n+        assertEquals(17 * 37 * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());\n         obj[0] = 5;\n         assertEquals((17 * 37 + 5) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());\n         obj[1] = 6;\n     @Test\n     public void testIntArrayAsObject() {\n         int[] obj = new int[2];\n-        assertEquals((17 * 37) * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());\n+        assertEquals(17 * 37 * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());\n         obj[0] = 5;\n         assertEquals((17 * 37 + 5) * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());\n         obj[1] = 6;\n     public void testShortArray() {\n         assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((short[]) null).toHashCode());\n         short[] obj = new short[2];\n-        assertEquals((17 * 37) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());\n+        assertEquals(17 * 37 * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());\n         obj[0] = (short) 5;\n         assertEquals((17 * 37 + 5) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());\n         obj[1] = (short) 6;\n     @Test\n     public void testShortArrayAsObject() {\n         short[] obj = new short[2];\n-        assertEquals((17 * 37) * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());\n+        assertEquals(17 * 37 * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());\n         obj[0] = (short) 5;\n         assertEquals((17 * 37 + 5) * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());\n         obj[1] = (short) 6;\n     public void testCharArray() {\n         assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((char[]) null).toHashCode());\n         char[] obj = new char[2];\n-        assertEquals((17 * 37) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());\n+        assertEquals(17 * 37 * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());\n         obj[0] = (char) 5;\n         assertEquals((17 * 37 + 5) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());\n         obj[1] = (char) 6;\n     @Test\n     public void testCharArrayAsObject() {\n         char[] obj = new char[2];\n-        assertEquals((17 * 37) * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());\n+        assertEquals(17 * 37 * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());\n         obj[0] = (char) 5;\n         assertEquals((17 * 37 + 5) * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());\n         obj[1] = (char) 6;\n     public void testByteArray() {\n         assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((byte[]) null).toHashCode());\n         byte[] obj = new byte[2];\n-        assertEquals((17 * 37) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());\n+        assertEquals(17 * 37 * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());\n         obj[0] = (byte) 5;\n         assertEquals((17 * 37 + 5) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());\n         obj[1] = (byte) 6;\n     @Test\n     public void testByteArrayAsObject() {\n         byte[] obj = new byte[2];\n-        assertEquals((17 * 37) * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());\n+        assertEquals(17 * 37 * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());\n         obj[0] = (byte) 5;\n         assertEquals((17 * 37 + 5) * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());\n         obj[1] = (byte) 6;\n     public void testDoubleArray() {\n         assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((double[]) null).toHashCode());\n         double[] obj = new double[2];\n-        assertEquals((17 * 37) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());\n+        assertEquals(17 * 37 * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());\n         obj[0] = 5.4d;\n         long l1 = Double.doubleToLongBits(5.4d);\n-        int h1 = (int) (l1 ^ (l1 >> 32));\n+        int h1 = (int) (l1 ^ l1 >> 32);\n         assertEquals((17 * 37 + h1) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());\n         obj[1] = 6.3d;\n         long l2 = Double.doubleToLongBits(6.3d);\n-        int h2 = (int) (l2 ^ (l2 >> 32));\n+        int h2 = (int) (l2 ^ l2 >> 32);\n         assertEquals((17 * 37 + h1) * 37 + h2, new HashCodeBuilder(17, 37).append(obj).toHashCode());\n     }\n \n     @Test\n     public void testDoubleArrayAsObject() {\n         double[] obj = new double[2];\n-        assertEquals((17 * 37) * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());\n+        assertEquals(17 * 37 * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());\n         obj[0] = 5.4d;\n         long l1 = Double.doubleToLongBits(5.4d);\n-        int h1 = (int) (l1 ^ (l1 >> 32));\n+        int h1 = (int) (l1 ^ l1 >> 32);\n         assertEquals((17 * 37 + h1) * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());\n         obj[1] = 6.3d;\n         long l2 = Double.doubleToLongBits(6.3d);\n-        int h2 = (int) (l2 ^ (l2 >> 32));\n+        int h2 = (int) (l2 ^ l2 >> 32);\n         assertEquals((17 * 37 + h1) * 37 + h2, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());\n     }\n \n     public void testFloatArray() {\n         assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((float[]) null).toHashCode());\n         float[] obj = new float[2];\n-        assertEquals((17 * 37) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());\n+        assertEquals(17 * 37 * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());\n         obj[0] = 5.4f;\n         int h1 = Float.floatToIntBits(5.4f);\n         assertEquals((17 * 37 + h1) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());\n     @Test\n     public void testFloatArrayAsObject() {\n         float[] obj = new float[2];\n-        assertEquals((17 * 37) * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());\n+        assertEquals(17 * 37 * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());\n         obj[0] = 5.4f;\n         int h1 = Float.floatToIntBits(5.4f);\n         assertEquals((17 * 37 + h1) * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());\n     @Test\n     public void testBooleanMultiArray() {\n         boolean[][] obj = new boolean[2][];\n-        assertEquals((17 * 37) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());\n+        assertEquals(17 * 37 * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());\n         obj[0] = new boolean[0];\n         assertEquals(17 * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());\n         obj[0] = new boolean[1];\n         obj[0][0] = true;\n         assertEquals(((17 * 37 + 0) * 37 + 1) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());\n         obj[1] = new boolean[1];\n-        assertEquals((((17 * 37 + 0) * 37 + 1) * 37 + 1), new HashCodeBuilder(17, 37).append(obj).toHashCode());\n+        assertEquals(((17 * 37 + 0) * 37 + 1) * 37 + 1, new HashCodeBuilder(17, 37).append(obj).toHashCode());\n     }\n \n     @Test\n     public void testReflectionHashCodeExcludeFields() throws Exception {\n         TestObjectWithMultipleFields x = new TestObjectWithMultipleFields(1, 2, 3);\n \n-        assertEquals((((17 * 37 + 1) * 37 + 2) * 37 + 3), HashCodeBuilder.reflectionHashCode(x));\n-\n-        assertEquals((((17 * 37 + 1) * 37 + 2) * 37 + 3), HashCodeBuilder.reflectionHashCode(x, (String[]) null));\n-        assertEquals((((17 * 37 + 1) * 37 + 2) * 37 + 3), HashCodeBuilder.reflectionHashCode(x, new String[]{}));\n-        assertEquals((((17 * 37 + 1) * 37 + 2) * 37 + 3), HashCodeBuilder.reflectionHashCode(x, new String[]{\"xxx\"}));\n-\n-        assertEquals(((17 * 37 + 1) * 37 + 3), HashCodeBuilder.reflectionHashCode(x, new String[]{\"two\"}));\n-        assertEquals(((17 * 37 + 1) * 37 + 2), HashCodeBuilder.reflectionHashCode(x, new String[]{\"three\"}));\n-\n-        assertEquals((17 * 37 + 1), HashCodeBuilder.reflectionHashCode(x, new String[]{\"two\", \"three\"}));\n+        assertEquals(((17 * 37 + 1) * 37 + 2) * 37 + 3, HashCodeBuilder.reflectionHashCode(x));\n+\n+        assertEquals(((17 * 37 + 1) * 37 + 2) * 37 + 3, HashCodeBuilder.reflectionHashCode(x, (String[]) null));\n+        assertEquals(((17 * 37 + 1) * 37 + 2) * 37 + 3, HashCodeBuilder.reflectionHashCode(x, new String[]{}));\n+        assertEquals(((17 * 37 + 1) * 37 + 2) * 37 + 3, HashCodeBuilder.reflectionHashCode(x, new String[]{\"xxx\"}));\n+\n+        assertEquals((17 * 37 + 1) * 37 + 3, HashCodeBuilder.reflectionHashCode(x, new String[]{\"two\"}));\n+        assertEquals((17 * 37 + 1) * 37 + 2, HashCodeBuilder.reflectionHashCode(x, new String[]{\"three\"}));\n+\n+        assertEquals(17 * 37 + 1, HashCodeBuilder.reflectionHashCode(x, new String[]{\"two\", \"three\"}));\n \n         assertEquals(17, HashCodeBuilder.reflectionHashCode(x, new String[]{\"one\", \"two\", \"three\"}));\n         assertEquals(17, HashCodeBuilder.reflectionHashCode(x, new String[]{\"one\", \"two\", \"three\", \"xxx\"}));\n--- a/src/test/java/org/apache/commons/lang3/concurrent/TimedSemaphoreTest.java\n+++ b/src/test/java/org/apache/commons/lang3/concurrent/TimedSemaphoreTest.java\n          */\n         @Override\n         protected ScheduledFuture<?> startTimer() {\n-            return (schedFuture != null) ? schedFuture : super.startTimer();\n+            return schedFuture != null ? schedFuture : super.startTimer();\n         }\n     }\n \n--- a/src/test/java/org/apache/commons/lang3/text/StrTokenizerTest.java\n+++ b/src/test/java/org/apache/commons/lang3/text/StrTokenizerTest.java\n      * <code>null</code>.\n      */\n     public void testCloneNotSupportedException() {\n-        Object notCloned = (new StrTokenizer() {\n+        Object notCloned = new StrTokenizer() {\n             @Override\n             Object cloneReset() throws CloneNotSupportedException {\n                 throw new CloneNotSupportedException(\"test\");\n             }\n-        }).clone();\n+        }.clone();\n         assertNull(notCloned);\n     }\n ", "timestamp": 1320861239, "metainfo": ""}