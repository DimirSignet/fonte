{"sha": "29e5d1a451044c19e2a34340fcea28b560fde09d", "log": "LANG-829: FastDateParser could use Calendar.getDisplayNames for all text fields  ", "commit": "\n--- a/src/main/java/org/apache/commons/lang3/time/FastDateParser.java\n+++ b/src/main/java/org/apache/commons/lang3/time/FastDateParser.java\n import java.io.IOException;\n import java.io.ObjectInputStream;\n import java.io.Serializable;\n-import java.text.DateFormatSymbols;\n import java.text.ParseException;\n import java.text.ParsePosition;\n import java.util.ArrayList;\n      */\n     private static final long serialVersionUID = 1L;\n \n-    private static final ConcurrentMap<Locale,TimeZoneStrategy> tzsCache=\n-        new ConcurrentHashMap<Locale,TimeZoneStrategy>(3);\n-\n     static final Locale JAPANESE_IMPERIAL = new Locale(\"ja\",\"JP\",\"JP\");\n \n     // defining fields\n     private transient Pattern parsePattern;\n     private transient Strategy[] strategies;\n     private transient int thisYear;\n-    private transient ConcurrentMap<Integer, KeyValue[]> nameValues;\n \n     // dynamic fields to communicate with Strategy\n     private transient String currentFormatField;\n      * This is called from constructor and from readObject (de-serialization)\n      */\n     private void init() {\n-        thisYear= Calendar.getInstance(timeZone, locale).get(Calendar.YEAR);\n-\n-        nameValues= new ConcurrentHashMap<Integer, KeyValue[]>();\n+        Calendar definingCalendar = Calendar.getInstance(timeZone, locale);\n+\t\tthisYear= definingCalendar.get(Calendar.YEAR);\n \n         StringBuilder regex= new StringBuilder();\n         List<Strategy> collector = new ArrayList<Strategy>();\n         }\n \n         currentFormatField= patternMatcher.group();\n-        Strategy currentStrategy= getStrategy(currentFormatField);\n+        Strategy currentStrategy= getStrategy(currentFormatField, definingCalendar);\n         for(;;) {\n             patternMatcher.region(patternMatcher.end(), patternMatcher.regionEnd());\n             if(!patternMatcher.lookingAt()) {\n                 break;\n             }\n             String nextFormatField= patternMatcher.group();\n-            nextStrategy = getStrategy(nextFormatField);\n+            nextStrategy = getStrategy(nextFormatField, definingCalendar);\n             if(currentStrategy.addRegex(this, regex)) {\n                 collector.add(currentStrategy);\n             }\n     /**\n      * Get the short and long values displayed for a field\n      * @param field The field of interest\n+     * @param definingCalendar The calendar to obtain the short and long values\n+     * @param locale The locale of dislay names\n      * @return A sorted array of the field key / value pairs\n      */\n-    KeyValue[] getDisplayNames(int field) {\n-        Integer fieldInt = Integer.valueOf(field);\n-        KeyValue[] fieldKeyValues= nameValues.get(fieldInt);\n-        if(fieldKeyValues==null) {\n-            DateFormatSymbols symbols= DateFormatSymbols.getInstance(locale);\n-            switch(field) {\n-            case Calendar.ERA:\n-                // DateFormatSymbols#getEras() only returns AD/BC or translations\n-                // It does not work for the Thai Buddhist or Japanese Imperial calendars.\n-                // see: https://issues.apache.org/jira/browse/TRINIDAD-2126\n-                Calendar c = Calendar.getInstance(locale);\n-                // N.B. Some calendars have different short and long symbols, e.g. ja_JP_JP\n-                // TODO Seems to be only that locale; if that is guaranteed, could skip some work here\n-                String[] shortEras = toArray(c.getDisplayNames(Calendar.ERA, Calendar.SHORT, locale));\n-                String[] longEras = toArray(c.getDisplayNames(Calendar.ERA, Calendar.LONG, locale));\n-                if (Arrays.equals(shortEras, longEras)) {\n-                    fieldKeyValues = createKeyValues(longEras, null); // save memory\n-                } else {\n-                    fieldKeyValues = createKeyValues(longEras, shortEras);                    \n-                }\n-                break;\n-            case Calendar.DAY_OF_WEEK:\n-                fieldKeyValues= createKeyValues(symbols.getWeekdays(), symbols.getShortWeekdays());\n-                break;\n-            case Calendar.AM_PM:\n-                fieldKeyValues= createKeyValues(symbols.getAmPmStrings(), null);\n-                break;\n-            case Calendar.MONTH:\n-                fieldKeyValues= createKeyValues(symbols.getMonths(), symbols.getShortMonths());\n-                break;\n-            default:\n-                throw new IllegalArgumentException(\"Invalid field value \"+field);\n-            }\n-            KeyValue[] prior = nameValues.putIfAbsent(fieldInt, fieldKeyValues);\n-            if(prior!=null) {\n-                fieldKeyValues= prior;\n-            }\n-        }\n-        return fieldKeyValues;\n-    }\n-\n-    private String[] toArray(Map<String, Integer> era) {\n-        String[] eras = new String[era.size()]; // assume no gaps in entry values\n-        for(Map.Entry<String, Integer> me : era.entrySet()) {\n-            int idx = me.getValue().intValue();\n-            final String key = me.getKey();\n-            if (key == null) {\n-                throw new IllegalArgumentException();\n-            }\n-            eras[idx] = key;\n-        }\n-        return eras;\n-    }\n-\n-    /**\n-     * Create key / value pairs from keys\n-     * @param longValues The allowable long names for a field\n-     * @param shortValues The optional allowable short names for a field\n-     * @return The sorted name / value pairs for the field\n-     */\n-    private static KeyValue[] createKeyValues(String[] longValues, String[] shortValues) {\n-        KeyValue[] fieldKeyValues= new KeyValue[count(longValues)+count(shortValues)];\n-        copy(fieldKeyValues, copy(fieldKeyValues, 0, longValues), shortValues);\n+    private static KeyValue[] getDisplayNames(int field, Calendar definingCalendar, Locale locale) {\n+\t\tList<KeyValue> keyValues = new ArrayList<KeyValue>(24);\n+\t\taddNamesToKeyValues(keyValues, definingCalendar.getDisplayNames(field, Calendar.ALL_STYLES, locale));\n+        return createKeyValues(keyValues);\n+    }\n+\n+\tprivate static void addNamesToKeyValues(List<KeyValue> keyValues, Map<String, Integer> displayNames) {\n+        for(Map.Entry<String, Integer> me : displayNames.entrySet()) {\n+        \tkeyValues.add(new KeyValue(me.getKey(), me.getValue()));\n+        }\n+    }\n+\n+    private static KeyValue[] createKeyValues(List<KeyValue> keyValues) {\n+        KeyValue[] fieldKeyValues= keyValues.toArray(new KeyValue[keyValues.size()]);\n         Arrays.sort(fieldKeyValues, IGNORE_CASE_COMPARATOR);\n         return fieldKeyValues;\n-    }\n-\n-    /**\n-     * Get a count of valid values in array.  A valid value is of non-zero length.\n-     * @param values The values to check.  This parameter may be null\n-     * @return The number of valid values\n-     */\n-    private static int count(String[] values) {\n-        int count= 0;\n-        if(values!=null) {\n-            for(String value : values) {\n-                if(value.length()>0) {\n-                    ++count;\n-                }\n-            }\n-        }\n-        return count;\n-    }\n-\n-    /**\n-     * Create key / value pairs from values\n-     * @param fieldKeyValues The destination array\n-     * @param offset The offset into the destination array\n-     * @param values The values to use to create key / value pairs.  This parameter may be null.\n-     * @return The offset into the destination array\n-     */\n-    private static int copy(KeyValue[] fieldKeyValues, int offset, String[] values) {\n-        if(values!=null) {\n-            for(int i= 0; i<values.length; ++i) {\n-                String value= values[i];\n-                if(value.length()>0) {\n-                    fieldKeyValues[offset++]= new KeyValue(value, i);\n-                }\n-            }\n-        }\n-        return offset;\n     }\n \n     /**\n          * which will accept this field\n          * @param parser The parser calling this strategy\n          * @param regex The <code>StringBuilder</code> to append to\n+         * @param Calendar The calendar this strategy must parse\n          * @return true, if this field will set the calendar;\n          * false, if this field is a constant value\n          */\n     /**\n      * Obtain a Strategy given a field from a SimpleDateFormat pattern\n      * @param formatField A sub-sequence of the SimpleDateFormat pattern\n+     * @param definingCalendar The calendar to obtain the short and long values\n      * @return The Strategy that will handle parsing for the field\n      */\n-    private Strategy getStrategy(String formatField) {\n+    private Strategy getStrategy(String formatField, Calendar definingCalendar) {\n         switch(formatField.charAt(0)) {\n         case '\\'':\n             if(formatField.length()>2) {\n         case 'D':\n             return DAY_OF_YEAR_STRATEGY;\n         case 'E':\n-            return DAY_OF_WEEK_STRATEGY;\n+            return getLocaleSpecificStrategy(Calendar.DAY_OF_WEEK, definingCalendar);\n         case 'F':\n             return DAY_OF_WEEK_IN_MONTH_STRATEGY;\n         case 'G':\n-            return ERA_STRATEGY;\n+            return getLocaleSpecificStrategy(Calendar.ERA, definingCalendar);\n         case 'H':\n             return MODULO_HOUR_OF_DAY_STRATEGY;\n         case 'K':\n             return HOUR_STRATEGY;\n         case 'M':\n-            return formatField.length()>=3 ?TEXT_MONTH_STRATEGY :NUMBER_MONTH_STRATEGY;\n+            return formatField.length()>=3 ?getLocaleSpecificStrategy(Calendar.MONTH, definingCalendar) :NUMBER_MONTH_STRATEGY;\n         case 'S':\n             return MILLISECOND_STRATEGY;\n         case 'W':\n             return WEEK_OF_MONTH_STRATEGY;\n-        case 'Z':\n-            break;\n         case 'a':\n-            return AM_PM_STRATEGY;\n+            return getLocaleSpecificStrategy(Calendar.AM_PM, definingCalendar);\n         case 'd':\n             return DAY_OF_MONTH_STRATEGY;\n         case 'h':\n             return WEEK_OF_YEAR_STRATEGY;\n         case 'y':\n             return formatField.length()>2 ?LITERAL_YEAR_STRATEGY :ABBREVIATED_YEAR_STRATEGY;\n+        case 'Z':\n         case 'z':\n-            break;\n-        }\n-        TimeZoneStrategy tzs= tzsCache.get(locale);\n-        if(tzs==null) {\n-            tzs= new TimeZoneStrategy(locale);\n-            TimeZoneStrategy inCache= tzsCache.putIfAbsent(locale, tzs);\n+        \treturn getLocaleSpecificStrategy(Calendar.ZONE_OFFSET, definingCalendar);\n+        }\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private static ConcurrentMap<Locale, Strategy>[] caches = new ConcurrentMap[Calendar.FIELD_COUNT];\n+\n+    /**\n+     * Get a cache of Strategies for a particular field\n+     * @param field The Calendar field\n+     * @return a cache of Locale to Strategy\n+     */\n+    private static ConcurrentMap<Locale, Strategy> getCache(int field) {\n+    \tsynchronized(caches) {\n+    \t\tif(caches[field]==null) {\n+    \t\t\tcaches[field]= new ConcurrentHashMap<Locale,Strategy>(3);\n+    \t\t}\n+    \t\treturn caches[field];\n+    \t}\n+    }\n+\n+    /**\n+     * Construct a Strategy that parses a Text field\n+     * @param locale The Locale of the TimeZone to parse\n+     * @param field The Calendar field\n+     * @param definingCalendar The calendar to obtain the short and long values\n+     * @return a TextStrategy for the field and Locale\n+     */\n+    private Strategy getLocaleSpecificStrategy(int field, Calendar definingCalendar) {\n+    \tConcurrentMap<Locale,Strategy> cache = getCache(field);\n+    \tStrategy strategy= cache.get(field);\n+        if(strategy==null) {\n+        \tstrategy= field==Calendar.ZONE_OFFSET\n+        \t\t\t? new TimeZoneStrategy(locale)\n+        \t\t\t: new TextStrategy(field, definingCalendar, locale);\n+            Strategy inCache= cache.putIfAbsent(locale, strategy);\n             if(inCache!=null) {\n                 return inCache;\n             }\n         }\n-        return tzs;\n-    }\n-\n-    /**\n+        return strategy;\n+    }\n+\n+\t/**\n      * A strategy that copies the static or quoted field in the parsing pattern\n      */\n     private static class CopyQuotedStrategy implements Strategy {\n         }\n     }\n \n-    /**\n+\t/**\n      * A strategy that handles a text field in the parsing pattern\n      */\n-    private static class TextStrategy implements Strategy {\n+     private static class TextStrategy implements Strategy {\n         private final int field;\n+        private final KeyValue[] keyValues;\n \n         /**\n          * Construct a Strategy that parses a Text field\n          * @param field The Calendar field\n          */\n-        TextStrategy(int field) {\n+        TextStrategy(int field, Calendar definingCalendar, Locale locale) {\n             this.field= field;\n+            this.keyValues= getDisplayNames(field, definingCalendar, locale);\n         }\n \n         /**\n         @Override\n         public boolean addRegex(FastDateParser parser, StringBuilder regex) {\n             regex.append('(');\n-            for(KeyValue textKeyValue : parser.getDisplayNames(field)) {\n+            for(KeyValue textKeyValue : keyValues) {\n                 escapeRegex(regex, textKeyValue.key, false).append('|');\n             }\n             regex.setCharAt(regex.length()-1, ')');\n          */\n         @Override\n         public void setCalendar(FastDateParser parser, Calendar cal, String value) {\n-            KeyValue[] textKeyValues= parser.getDisplayNames(field);\n-            int idx= Arrays.binarySearch(textKeyValues, new KeyValue(value, -1), IGNORE_CASE_COMPARATOR);\n+            int idx= Arrays.binarySearch(keyValues, new KeyValue(value, -1), IGNORE_CASE_COMPARATOR);\n             if(idx<0) {\n                 StringBuilder sb= new StringBuilder(value);\n                 sb.append(\" not in (\");\n-                for(KeyValue textKeyValue : textKeyValues) {\n+                for(KeyValue textKeyValue : keyValues) {\n                     sb.append(textKeyValue.key).append(' ');\n                 }\n                 sb.setCharAt(sb.length()-1, ')');\n                 throw new IllegalArgumentException(sb.toString());\n             }\n-            cal.set(field, textKeyValues[idx].value);\n-        }\n-    }\n+            cal.set(field, keyValues[idx].value);\n+        }\n+    }\n+\n \n     /**\n      * A strategy that handles a number field in the parsing pattern\n         }\n     }\n \n-\n-    private static final Strategy ERA_STRATEGY = new TextStrategy(Calendar.ERA);\n-    private static final Strategy DAY_OF_WEEK_STRATEGY = new TextStrategy(Calendar.DAY_OF_WEEK);\n-    private static final Strategy AM_PM_STRATEGY = new TextStrategy(Calendar.AM_PM);\n-    private static final Strategy TEXT_MONTH_STRATEGY = new TextStrategy(Calendar.MONTH);\n-\n     private static final Strategy NUMBER_MONTH_STRATEGY = new NumberStrategy(Calendar.MONTH) {\n         @Override\n         public int modify(int iValue) {", "timestamp": 1348721421, "metainfo": ""}