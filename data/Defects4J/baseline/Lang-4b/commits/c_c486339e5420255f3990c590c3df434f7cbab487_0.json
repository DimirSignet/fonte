{"sha": "c486339e5420255f3990c590c3df434f7cbab487", "log": "Ensure that the reader is a proper view (previously if the builder buffer changed due to appends after creating the reader these weren't picked up)  ", "commit": "\n--- a/src/java/org/apache/commons/lang/text/StrBuilder.java\n+++ b/src/java/org/apache/commons/lang/text/StrBuilder.java\n  */\n package org.apache.commons.lang.text;\n \n-import java.io.CharArrayReader;\n import java.io.Reader;\n import java.io.Writer;\n import java.util.Collection;\n  *  </ul>\n  * </li>\n  * </ul>\n+ * <li>Views\n+ *  <ul>\n+ *   <li>asTokenizer - uses the internal buffer as the source of a StrTokenizer</li>\n+ *   <li>asReader - uses the internal buffer as the source of a Reader</li>\n+ *   <li>asWriter - allows a Writer to write directly to the internal buffer</li>\n+ *  </ul>\n+ * </li>\n+ * </ul>\n  * <p>\n  * The aim has been to provide an API that mimics very closely what StringBuffer\n  * provides, but with additional methods. It should be noted that some edge cases,\n \n     //-----------------------------------------------------------------------\n     /**\n+     * Creates a tokenizer using the current contents of this builder.\n+     * <p>\n+     * This method allows the contents of the builder to be tokenized.\n+     * The tokenizer will be setup to tokenize on space, tab, newline\n+     * and formfeed (as per StringTokenizer). These values can be changed\n+     * on the tokenizer class, before retrieving the tokens.\n+     * <p>\n+     * Note that the internal character array is shared between the two\n+     * objects and no synchronization occurs, so you must not alter this\n+     * builder in one thread while tokenizing it in another thread.\n+     *\n+     * @return a StrTokenizer instance\n+     */\n+    public StrTokenizer asTokenizer() {\n+        return new StrTokenizer(buffer);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n      * Gets the contents of this builder as a Reader.\n      * <p>\n      * This method allows the contents of the builder to be read\n      * using any standard method that expects a Reader.\n-     * The current implementation returns a CharArrayReader, but\n-     * you should not rely on this.\n-     * <p>\n-     * Note that no synchronization occurs, so you must not alter this\n+     * <p>\n+     * To use, simply create a <code>StrBuilder</code>, populate it with\n+     * data, call <code>asReader</code>, and then read away.\n+     * <p>\n+     * Note that the internal character array is shared between the two\n+     * objects and no synchronization occurs, so you must not alter this\n      * builder in one thread while reading it in another thread.\n+     * Note also that close has no effect on the reader, and that\n+     * marking is supported.\n      *\n      * @return a reader that reads from this builder\n      */\n     public Reader asReader() {\n-        return new CharArrayReader(buffer, 0, size);\n+        return new StrBuilderReader();\n     }\n \n     //-----------------------------------------------------------------------\n      * To use, simply create a <code>StrBuilder</code>,\n      * call <code>asWriter</code>, and populate away. The data is available\n      * at any time using the methods of the <code>StrBuilder</code>.\n-     * Note however, that no synchronization occurs, so you must not read\n+     * <p>\n+     * Note that the internal character array is shared between the two\n+     * objects and no synchronization occurs, so you must not alter this\n      * the builder from one thread while writing in another thread.\n      * Note also that close and flush have no effect on the writer.\n      *\n     /**\n      * Inner class to allow StrBuilder to operate as a writer.\n      */\n+    class StrBuilderReader extends Reader {\n+        /** The current stream position. */\n+        private int pos;\n+        /** The last mark position. */\n+        private int mark;\n+\n+        StrBuilderReader() {\n+            super();\n+        }\n+\n+        /** @inheritdoc */\n+        public void close() {\n+            // do nothing\n+        }\n+\n+        /** @inheritdoc */\n+        public int read() {\n+            if (ready() == false) {\n+                return -1;\n+            }\n+            return charAt(pos++);\n+        }\n+\n+        /** @inheritdoc */\n+        public int read(char b[], int off, int len) {\n+            if (off < 0 || len < 0 || off > b.length ||\n+                    (off + len) > b.length || (off + len) < 0) {\n+                throw new IndexOutOfBoundsException();\n+            }\n+            if (len == 0) {\n+                return 0;\n+            }\n+            if (pos >= size()) {\n+                return -1;\n+            }\n+            if (pos + len > size()) {\n+                len = size() - pos;\n+            }\n+            getChars(pos, pos + len, b, off);\n+            pos += len;\n+            return len;\n+        }\n+\n+        public long skip(long n) {\n+            if (pos + n > size()) {\n+                n = size() - pos;\n+            }\n+            if (n < 0) {\n+                return 0;\n+            }\n+            pos += n;\n+            return n;\n+        }\n+\n+        /** @inheritdoc */\n+        public boolean ready() {\n+            return pos < size();\n+        }\n+\n+        /** @inheritdoc */\n+        public boolean markSupported() {\n+            return true;\n+        }\n+\n+        /** @inheritdoc */\n+        public void mark(int readAheadLimit) {\n+            mark = pos;\n+        }\n+\n+        /** @inheritdoc */\n+        public void reset() {\n+            pos = mark;\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Inner class to allow StrBuilder to operate as a writer.\n+     */\n     class StrBuilderWriter extends Writer {\n         StrBuilderWriter() {\n             super();\n--- a/src/test/org/apache/commons/lang/text/StrBuilderTest.java\n+++ b/src/test/org/apache/commons/lang/text/StrBuilderTest.java\n \n     // -----------------------------------------------------------------------\n     public void testAsReader() throws Exception {\n-        StrBuilder sb = new StrBuilder (\"some text\");\n+        StrBuilder sb = new StrBuilder(\"some text\");\n         Reader reader = sb.asReader();\n+        assertEquals(true, reader.ready());\n         char[] buf = new char[40];\n         assertEquals(9, reader.read(buf));\n         assertEquals(\"some text\", new String(buf, 0, 9));\n         \n-        buf = new char[40];\n-        assertEquals(-1, reader.read(buf));\n+        assertEquals(-1, reader.read());\n+        assertEquals(false, reader.ready());\n+        assertEquals(0, reader.skip(2));\n+        assertEquals(0, reader.skip(-1));\n+        \n+        assertEquals(true, reader.markSupported());\n+        reader = sb.asReader();\n+        assertEquals('s', reader.read());\n+        reader.mark(-1);\n+        char[] array = new char[3];\n+        assertEquals(3, reader.read(array, 0, 3));\n+        assertEquals('o', array[0]);\n+        assertEquals('m', array[1]);\n+        assertEquals('e', array[2]);\n+        reader.reset();\n+        assertEquals(1, reader.read(array, 1, 1));\n+        assertEquals('o', array[0]);\n+        assertEquals('o', array[1]);\n+        assertEquals('e', array[2]);\n+        assertEquals(2, reader.skip(2));\n+        assertEquals(' ', reader.read());\n+        \n+        assertEquals(true, reader.ready());\n+        reader.close();\n+        assertEquals(true, reader.ready());\n+        \n+        reader = sb.asReader();\n+        array = new char[3];\n+        try {\n+            reader.read(array, -1, 0);\n+            fail();\n+        } catch (IndexOutOfBoundsException ex) {}\n+        try {\n+            reader.read(array, 0, -1);\n+            fail();\n+        } catch (IndexOutOfBoundsException ex) {}\n+        try {\n+            reader.read(array, 100, 1);\n+            fail();\n+        } catch (IndexOutOfBoundsException ex) {}\n+        try {\n+            reader.read(array, 0, 100);\n+            fail();\n+        } catch (IndexOutOfBoundsException ex) {}\n+        try {\n+            reader.read(array, Integer.MAX_VALUE, Integer.MAX_VALUE);\n+            fail();\n+        } catch (IndexOutOfBoundsException ex) {}\n+        \n+        assertEquals(0, reader.read(array, 0, 0));\n+        assertEquals(0, array[0]);\n+        assertEquals(0, array[1]);\n+        assertEquals(0, array[2]);\n+        \n+        reader.skip(9);\n+        assertEquals(-1, reader.read(array, 0, 1));\n+        \n+        reader.reset();\n+        array = new char[30];\n+        assertEquals(9, reader.read(array, 0, 30));\n     }\n \n     //-----------------------------------------------------------------------\n     public void testAsWriter() throws Exception {\n-        StrBuilder sb = new StrBuilder (\"base\");\n+        StrBuilder sb = new StrBuilder(\"base\");\n         Writer writer = sb.asWriter();\n         \n         writer.write('l');", "timestamp": 1124546204, "metainfo": ""}