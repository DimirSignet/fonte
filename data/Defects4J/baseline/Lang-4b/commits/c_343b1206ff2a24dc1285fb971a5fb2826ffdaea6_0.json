{"sha": "343b1206ff2a24dc1285fb971a5fb2826ffdaea6", "log": "[LANG-684] Levenshtein Distance Within a Given Threshold; submitted by Eli Lindsey  ", "commit": "\n--- a/src/main/java/org/apache/commons/lang3/StringUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/StringUtils.java\n import java.lang.reflect.InvocationTargetException;\n import java.lang.reflect.Method;\n import java.util.ArrayList;\n+import java.util.Arrays;\n import java.util.Iterator;\n import java.util.List;\n import java.util.Locale;\n         return p[n];\n     }\n \n+    /**\n+     * <p>Find the Levenshtein distance between two Strings if it's less than or equal to a given \n+     * threshold.</p>\n+     *\n+     * <p>This is the number of changes needed to change one String into\n+     * another, where each change is a single character modification (deletion,\n+     * insertion or substitution).</p>\n+     *\n+     * <p>This implementation follows from Algorithms on Strings, Trees and Sequences by Dan Gusfield\n+     * and Chas Emerick's implementation of the Levenshtein distance algorithm from\n+     * <a href=\"http://www.merriampark.com/ld.htm\">http://www.merriampark.com/ld.htm</a></p>\n+     *\n+     * <pre>\n+     * StringUtils.getLevenshteinDistance(null, *, *)             = IllegalArgumentException\n+     * StringUtils.getLevenshteinDistance(*, null, *)             = IllegalArgumentException\n+     * StringUtils.getLevenshteinDistance(*, *, -1)               = IllegalArgumentException\n+     * StringUtils.getLevenshteinDistance(\"\",\"\", 0)               = 0\n+     * StringUtils.getLevenshteinDistance(\"aaapppp\", \"\", 8)       = 7\n+     * StringUtils.getLevenshteinDistance(\"aaapppp\", \"\", 7)       = 7\n+     * StringUtils.getLevenshteinDistance(\"aaapppp\", \"\", 6))      = -1\n+     * StringUtils.getLevenshteinDistance(\"elephant\", \"hippo\", 7) = 7\n+     * StringUtils.getLevenshteinDistance(\"elephant\", \"hippo\", 6) = -1\n+     * StringUtils.getLevenshteinDistance(\"hippo\", \"elephant\", 7) = 7\n+     * StringUtils.getLevenshteinDistance(\"hippo\", \"elephant\", 6) = -1\n+     * </pre>\n+     *\n+     * @param s  the first String, must not be null\n+     * @param t  the second String, must not be null\n+     * @param threshold the target threshold, must not be negative\n+     * @return result distance, or -1 if the distance would be greater than the threshold\n+     * @throws IllegalArgumentException if either String input {@code null} or negative threshold\n+     */\n+    public static int getLevenshteinDistance(CharSequence s, CharSequence t, int threshold) {\n+        if(s == null || t == null) {\n+            throw new IllegalArgumentException(\"String must not be null\");\n+        }\n+        if(threshold < 0) {\n+            throw new IllegalArgumentException(\"Threshold must not be negative\");\n+        }\n+\n+        /*\n+        This implementation only computes the distance if it's less than or equal to the\n+        threshold value, returning -1 if it's greater.  The advantage is performance: unbounded\n+        distance is O(nm), but a bound of k allows us to reduce it to O(km) time by only \n+        computing a diagonal stripe of width 2k+1 of the cost table.\n+        It is also possible to use this to compute the unbounded Levenshtein distance by starting\n+        the threshold at 1 and doubling each time until the distance is found; this is O(dm), where\n+        d is the distance.\n+        \n+        One subtlety comes from needing to ignore entries on the border of our stripe\n+        eg.\n+        p[] = |#|#|#|*\n+        d[] =  *|#|#|#|\n+        We must ignore the entry to the left of the leftmost member\n+        We must ignore the entry above the rightmost member\n+        \n+        Another subtlety comes from our stripe running off the matrix if the strings aren't\n+        of the same size.  Since string s is always swapped to be the shorter of the two, \n+        the stripe will always run off to the upper right instead of the lower left of the matrix.\n+        \n+        As a concrete example, suppose s is of length 5, t is of length 7, and our threshold is 1.\n+        In this case we're going to walk a stripe of length 3.  The matrix would look like so:\n+        \n+           1 2 3 4 5\n+        1 |#|#| | | |\n+        2 |#|#|#| | |\n+        3 | |#|#|#| |\n+        4 | | |#|#|#|\n+        5 | | | |#|#|\n+        6 | | | | |#|\n+        7 | | | | | |\n+\n+        Note how the stripe leads off the table as there is no possible way to turn a string of length 5\n+        into one of length 7 in edit distance of 1.\n+        \n+        Additionally, this implementation decreases memory usage by using two \n+        single-dimensional arrays and swapping them back and forth instead of allocating\n+        an entire n by m matrix.  This requires a few minor changes, such as immediately returning \n+        when it's detected that the stripe has run off the matrix and initially filling the arrays with\n+        large values so that entries we don't compute are ignored.\n+\n+        See Algorithms on Strings, Trees and Sequences by Dan Gusfield for some discussion.\n+         */\n+\n+        int n = s.length(); // length of s\n+        int m = t.length(); // length of t\n+\n+        // if one string is empty, the edit distance is necessarily the length of the other\n+        if(n == 0) {\n+            return m <= threshold? m : -1;\n+        } else if(m == 0) {\n+            return n <= threshold? n : -1;\n+        }\n+\n+        if(n > m) {\n+            // swap the two strings to consume less memory\n+            CharSequence tmp = s;\n+            s = t;\n+            t = tmp;\n+            n = m;\n+            m = t.length();\n+        }\n+\n+        int p[] = new int[n+1]; // 'previous' cost array, horizontally\n+        int d[] = new int[n+1]; // cost array, horizontally\n+        int _d[]; // placeholder to assist in swapping p and d\n+\n+        // fill in starting table values\n+        int boundary = Math.min(n, threshold) + 1;\n+        for(int i = 0; i < boundary; i++) {\n+            p[i] = i;\n+        }\n+        // these fills ensure that the value above the rightmost entry of our \n+        // stripe will be ignored in following loop iterations\n+        Arrays.fill(p, boundary, p.length, Integer.MAX_VALUE);\n+        Arrays.fill(d, Integer.MAX_VALUE);\n+\n+        // iterates through t\n+        for(int j = 1; j <= m; j++) {\n+            char t_j = t.charAt(j-1); // jth character of t\n+            d[0] = j;\n+\n+            // compute stripe indices, constrain to array size\n+            int min = Math.max(1, j - threshold);\n+            int max = Math.min(n, j + threshold);\n+\n+            // the stripe may lead off of the table if s and t are of different sizes\n+            if(min > max) {\n+                return -1;\n+            }\n+\n+            // ignore entry left of leftmost\n+            if(min > 1) {\n+                d[min-1] = Integer.MAX_VALUE;\n+            }\n+\n+            // iterates through [min, max] in s\n+            for(int i = min; i <= max; i++) {\n+                if(s.charAt(i-1) == t_j) {\n+                    // diagonally left and up\n+                    d[i] = p[i-1];\n+                } else {\n+                    // 1 + minimum of cell to the left, to the top, diagonally left and up\n+                    d[i] = 1 + Math.min(Math.min(d[i-1], p[i]), p[i-1]);\n+                }\n+            }\n+\n+            // copy current distance counts to 'previous row' distance counts\n+            _d = p;\n+            p = d;\n+            d = _d;\n+        }\n+\n+        // if p[n] is greater than the threshold, there's no guarantee on it being the correct\n+        // distance\n+        if(p[n] <= threshold) {\n+            return p[n];\n+        } else {\n+            return -1;\n+        }\n+    }\n+\n     // startsWith\n     //-----------------------------------------------------------------------\n \n--- a/src/test/java/org/apache/commons/lang3/StringUtilsTest.java\n+++ b/src/test/java/org/apache/commons/lang3/StringUtilsTest.java\n         }\n     }\n \n+    public void testGetLevenshteinDistance_StringStringInt() {\n+        // empty strings\n+        assertEquals(0, StringUtils.getLevenshteinDistance(\"\", \"\", 0));\n+        assertEquals(7, StringUtils.getLevenshteinDistance(\"aaapppp\", \"\", 8));\n+        assertEquals(7, StringUtils.getLevenshteinDistance(\"aaapppp\", \"\", 7));\n+        assertEquals(-1, StringUtils.getLevenshteinDistance(\"aaapppp\", \"\", 6));\n+\n+        // unequal strings, zero threshold\n+        assertEquals(-1, StringUtils.getLevenshteinDistance(\"b\", \"a\", 0));\n+        assertEquals(-1, StringUtils.getLevenshteinDistance(\"a\", \"b\", 0));\n+    \n+        // equal strings\n+        assertEquals(0, StringUtils.getLevenshteinDistance(\"aa\", \"aa\", 0));\n+        assertEquals(0, StringUtils.getLevenshteinDistance(\"aa\", \"aa\", 2));\n+\n+        // same length\n+        assertEquals(-1, StringUtils.getLevenshteinDistance(\"aaa\", \"bbb\", 2));\n+        assertEquals(3, StringUtils.getLevenshteinDistance(\"aaa\", \"bbb\", 3));\n+    \n+        // big stripe\n+        assertEquals(6, StringUtils.getLevenshteinDistance(\"aaaaaa\", \"b\", 10));\n+\n+        // distance less than threshold\n+        assertEquals(7, StringUtils.getLevenshteinDistance(\"aaapppp\", \"b\", 8));\n+        assertEquals(3, StringUtils.getLevenshteinDistance(\"a\", \"bbb\", 4));\n+    \n+        // distance equal to threshold\n+        assertEquals(7, StringUtils.getLevenshteinDistance(\"aaapppp\", \"b\", 7));\n+        assertEquals(3, StringUtils.getLevenshteinDistance(\"a\", \"bbb\", 3));\n+\n+        // distance greater than threshold\n+        assertEquals(-1, StringUtils.getLevenshteinDistance(\"a\", \"bbb\", 2));\n+        assertEquals(-1, StringUtils.getLevenshteinDistance(\"bbb\", \"a\", 2));\n+        assertEquals(-1, StringUtils.getLevenshteinDistance(\"aaapppp\", \"b\", 6));\n+\n+        // stripe runs off array, strings not similar\n+        assertEquals(-1, StringUtils.getLevenshteinDistance(\"a\", \"bbb\", 1));\n+        assertEquals(-1, StringUtils.getLevenshteinDistance(\"bbb\", \"a\", 1));\n+\n+        // stripe runs off array, strings are similar\n+        assertEquals(-1, StringUtils.getLevenshteinDistance(\"12345\", \"1234567\", 1));\n+        assertEquals(-1, StringUtils.getLevenshteinDistance(\"1234567\", \"12345\", 1));\n+\n+        // old getLevenshteinDistance test cases\n+        assertEquals(1, StringUtils.getLevenshteinDistance(\"frog\", \"fog\",1) );\n+        assertEquals(3, StringUtils.getLevenshteinDistance(\"fly\", \"ant\",3) );\n+        assertEquals(7, StringUtils.getLevenshteinDistance(\"elephant\", \"hippo\",7) );\n+        assertEquals(-1, StringUtils.getLevenshteinDistance(\"elephant\", \"hippo\",6) );\n+        assertEquals(7, StringUtils.getLevenshteinDistance(\"hippo\", \"elephant\",7) );\n+        assertEquals(-1, StringUtils.getLevenshteinDistance(\"hippo\", \"elephant\",6) );\n+        assertEquals(8, StringUtils.getLevenshteinDistance(\"hippo\", \"zzzzzzzz\",8) );\n+        assertEquals(8, StringUtils.getLevenshteinDistance(\"zzzzzzzz\", \"hippo\",8) );\n+        assertEquals(1, StringUtils.getLevenshteinDistance(\"hello\", \"hallo\",1) );\n+\n+        // exceptions\n+        try {\n+            @SuppressWarnings(\"unused\")\n+            int d = StringUtils.getLevenshteinDistance(\"a\", null, 0);\n+            fail(\"expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // empty\n+        }\n+        try {\n+            @SuppressWarnings(\"unused\")\n+            int d = StringUtils.getLevenshteinDistance(null, \"a\", 0);\n+            fail(\"expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // empty\n+        }\n+\n+        try {\n+            @SuppressWarnings(\"unused\")\n+            int d = StringUtils.getLevenshteinDistance(\"a\", \"a\", -1);\n+            fail(\"expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // empty\n+        }\n+    }\n+\n     /**\n      * A sanity check for {@link StringUtils#EMPTY}.\n      */", "timestamp": 1308239529, "metainfo": ""}