{"sha": "f5d8a8ffa4d22d1db95517d8d1e0d87b54d813ef", "log": "LANG-881 NumberUtils.createNumber() Javadoc says it does not work for octal numbers  ", "commit": "\n--- a/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\n     /**\n      * <p>Turns a string value into a java.lang.Number.</p>\n      *\n-     * <p>If the string starts with <code>0x</code> or <code>-0x</code> (lower or upper case), it\n-     * will be interpreted as a hexadecimal integer - or long, if the number of digits after the 0x\n-     * prefix is more than 8.\n-     * Values with leading <code>0</code>'s will not be interpreted as octal.</p>\n-     *\n+     * <p>If the string starts with {@code 0x} or {@code -0x} (lower or upper case) or {@code #} or {@code -#}, it\n+     * will be interpreted as a hexadecimal Integer - or Long, if the number of digits after the\n+     * prefix is more than 8 - or BigInteger if there are more than 16 digits.\n+     * </p>\n      * <p>Then, the value is examined for a type qualifier on the end, i.e. one of\n      * <code>'f','F','d','D','l','L'</code>.  If it is found, it starts \n      * trying to create successively larger types from the type specified\n      * <p>If a type specifier is not found, it will check for a decimal point\n      * and then try successively larger types from <code>Integer</code> to\n      * <code>BigInteger</code> and from <code>Float</code> to\n-     * <code>BigDecimal</code>.</p>\n+    * <code>BigDecimal</code>.</p>\n+    * \n+     * <p>\n+     * Integral values with a leading {@code 0} will be interpreted as octal; the returned number will\n+     * be Integer, Long or BigDecimal as appropriate.\n+     * </p>\n      *\n      * <p>Returns <code>null</code> if the string is <code>null</code>.</p>\n      *\n                 break;\n             }\n         }\n-        if (pfxLen > 0) {\n+        if (pfxLen > 0) { // we have a hex number\n             final int hexDigits = str.length() - pfxLen;\n             if (hexDigits > 16) { // too many for Long\n                 return createBigInteger(str);\n         String dec;\n         String exp;\n         final int decPos = str.indexOf('.');\n-        final int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n-\n-        if (decPos > -1) {\n-\n-            if (expPos > -1) {\n+        final int expPos = str.indexOf('e') + str.indexOf('E') + 1; // TODO assumes both not present\n+\n+        if (decPos > -1) { // there is a decimal point\n+\n+            if (expPos > -1) { // there is an exponent\n                 if (expPos < decPos || expPos > str.length()) {\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 }\n         } else {\n             exp = null;\n         }\n-        if (dec == null && exp == null) {\n-            //Must be an int,long,bigint\n+        if (dec == null && exp == null) { // no decimal point and no exponent\n+            //Must be an Integer, Long, Biginteger\n             try {\n                 return createInteger(str);\n             } catch (final NumberFormatException nfe) { // NOPMD\n                 // ignore the bad number\n             }\n             return createBigInteger(str);\n-\n-        }\n-        //Must be a float,double,BigDec\n+        }\n+\n+        //Must be a Float, Double, BigDecimal\n         final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n         try {\n             final Float f = createFloat(str);", "timestamp": 1364399545, "metainfo": ""}