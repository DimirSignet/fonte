{"sha": "d47dd98f69831aa32ebc2b57786d561785f03d98", "log": "Enhance pair classes; Shorten toString form; Javadoc  ", "commit": "\n--- a/src/main/java/org/apache/commons/lang3/ImmutablePair.java\n+++ b/src/main/java/org/apache/commons/lang3/ImmutablePair.java\n package org.apache.commons.lang3;\n \n /**\n- * Immutable concrete manifestation of the {@link Pair} type.\n+ * <p>An immutable pair consisting of two {@code Object} elements.</p>\n+ * \n+ * <p>Although the implementation is immutable, there is no restriction on the objects\n+ * that may be stored. If mutable objects are stored in the pair, then the pair\n+ * itself effectively becomes mutable. The class is also not {@code final}, so a subclass\n+ * could add undesirable behaviour.</p>\n+ * \n+ * <p>#ThreadSafe# if the objects are threadsafe</p>\n  *\n- * <p>#ThreadSafe# if the objects are threadsafe</p>\n+ * @param <L> the first element type\n+ * @param <R> the second element type\n+ *\n  * @since Lang 3.0\n  * @version $Id$\n- *\n- * @param <L> left generic type\n- * @param <R> right generic type\n  */\n public class ImmutablePair<L, R> extends Pair<L, R> {\n+\n     /** Serialization version */\n     private static final long serialVersionUID = 4954918890077093841L;\n \n     public final R right;\n \n     /**\n-     * Create a new ImmutablePair instance.\n+     * <p>Obtains an immutable pair of from two objects inferring the generic types.</p>\n+     * \n+     * <p>This factory allows the pair to be created using inference to\n+     * obtain the generic types.</p>\n+     * \n+     * @param <L> the left element type\n+     * @param <R> the right element type\n+     * @param left  the left element, may be null\n+     * @param right  the right element, may be null\n+     * @return a pair formed from the two parameters, not null\n+     */\n+    public static <L, R> ImmutablePair<L, R> of(L left, R right) {\n+        return new ImmutablePair<L, R>(left, right);\n+    }\n+\n+    /**\n+     * Create a new pair instance.\n      *\n-     * @param left the left value\n-     * @param right the right value\n+     * @param left  the left value, may be null\n+     * @param right  the right value, may be null\n      */\n     public ImmutablePair(L left, R right) {\n         super();\n         this.right = right;\n     }\n \n+    //-----------------------------------------------------------------------\n     /**\n      * {@inheritDoc}\n      */\n     }\n \n     /**\n-     * {@link java.util.Map.Entry#setValue(Object)} implementation. Because this\n-     * class is immutable the {@code setValue()} operation is not supported.\n-     * Therefore always an exception is thrown.\n+     * <p>Throws {@code UnsupportedOperationException}.</p>\n+     * \n+     * <p>This pair is immutable, so this operation is not supported.</p>\n      *\n-     * @param value the value to set\n-     * @return the old right value\n+     * @param value  the value to set\n+     * @return never\n      * @throws UnsupportedOperationException as this operation is not supported\n      */\n     public R setValue(R value) {\n         throw new UnsupportedOperationException();\n     }\n \n-    /**\n-     * Static fluent creation method for an {@link ImmutablePair}<L, R>:\n-     * <code>ImmutablePair.of(left, right)</code>\n-     *\n-     * @param <L> the left generic type\n-     * @param <R> the right generic type\n-     * @param left the let value\n-     * @param right the right value\n-     * @return ImmutablePair<L, R>(left, right)\n-     */\n-    public static <L, R> ImmutablePair<L, R> of(L left, R right) {\n-        return new ImmutablePair<L, R>(left, right);\n-    }\n }\n--- a/src/main/java/org/apache/commons/lang3/MutablePair.java\n+++ b/src/main/java/org/apache/commons/lang3/MutablePair.java\n package org.apache.commons.lang3;\n \n /**\n- * Mutable concrete manifestation of the {@link Pair} type.\n+ * <p>A mutable pair consisting of two {@code Object} elements.</p>\n+ * \n+ * <p>Not #ThreadSafe#</p>\n  *\n- * <p>#ThreadSafe# if the objects are threadsafe</p>\n+ * @param <L> the first element type\n+ * @param <R> the second element type\n+ *\n  * @since Lang 3.0\n  * @version $Id$\n- *\n- * @param <L> left generic type\n- * @param <R> right generic type\n  */\n public class MutablePair<L, R> extends Pair<L, R> {\n+\n     /** Serialization version */\n     private static final long serialVersionUID = 4954918890077093841L;\n \n-    private L leftElement;\n-    private R rightElement;\n+    /** Left object */\n+    public L left;\n+    /** Right object */\n+    public R right;\n \n     /**\n-     * Create a new MutablePair instance.\n+     * <p>Obtains an immutable pair of from two objects inferring the generic types.</p>\n+     * \n+     * <p>This factory allows the pair to be created using inference to\n+     * obtain the generic types.</p>\n+     * \n+     * @param <L> the left element type\n+     * @param <R> the right element type\n+     * @param left  the left element, may be null\n+     * @param right  the right element, may be null\n+     * @return a pair formed from the two parameters, not null\n+     */\n+    public static <L, R> MutablePair<L, R> of(L left, R right) {\n+        return new MutablePair<L, R>(left, right);\n+    }\n+\n+    /**\n+     * Create a new pair instance of two nulls.\n      */\n     public MutablePair() {\n         super();\n     }\n \n     /**\n-     * Create a new MutablePair instance.\n+     * Create a new pair instance.\n      *\n-     * @param leftElement the left value\n-     * @param rightElement the right value\n+     * @param left  the left value, may be null\n+     * @param right  the right value, may be null\n      */\n-    public MutablePair(L leftElement, R rightElement) {\n+    public MutablePair(L left, R right) {\n         super();\n-        this.leftElement = leftElement;\n-        this.rightElement = rightElement;\n+        this.left = left;\n+        this.right = right;\n     }\n \n+    //-----------------------------------------------------------------------\n     /**\n      * {@inheritDoc}\n      */\n     @Override\n     public L getLeftElement() {\n-        return leftElement;\n+        return left;\n     }\n \n     /**\n      * Set the left element of the pair.\n-     * @param leftElement the value of the left element\n+     * \n+     * @param left  the new value of the left element, may be null\n      */\n-    public void setLeftElement(L leftElement) {\n-        this.leftElement = leftElement;\n+    public void setLeftElement(L left) {\n+        this.left = left;\n     }\n \n     /**\n      */\n     @Override\n     public R getRightElement() {\n-        return rightElement;\n+        return right;\n     }\n \n     /**\n      * Set the right element of the pair.\n-     * @param rightElement the value of the right element\n+     * \n+     * @param right  the value of the right element\n      */\n-    public void setRightElement(R rightElement) {\n-        this.rightElement = rightElement;\n+    public void setRightElement(R right) {\n+        this.right = right;\n     }\n \n     /**\n-     * Implement {@link java.util.Map.Entry#setValue(Object)}.\n-     * @param value value (<code>rightElement</code>) to set\n+     * Sets the {@code Map.Entry} value.\n+     * This sets the right element of the pair.\n+     * \n+     * @param value  the right value to set, not null\n      * @return the old value for the right element\n      */\n     public R setValue(R value) {\n         return result;\n     }\n \n-    /**\n-     * Static fluent creation method for a {@link MutablePair}<L, R>:\n-     * <code>MutablePair.of(left, right)</code>\n-     * @param <L> the left generic type\n-     * @param <R> the right generic type\n-     * @param left the left value\n-     * @param right the right value\n-     * @return MutablePair<L, R>(left, right)\n-     */\n-    public static <L, R> MutablePair<L, R> of(L left, R right) {\n-        return new MutablePair<L, R>(left, right);\n-    }\n }\n--- a/src/main/java/org/apache/commons/lang3/Pair.java\n+++ b/src/main/java/org/apache/commons/lang3/Pair.java\n import java.io.Serializable;\n import java.util.Map;\n \n-import org.apache.commons.lang3.builder.HashCodeBuilder;\n+import org.apache.commons.lang3.builder.CompareToBuilder;\n \n /**\n- * Abstract Pair (or 2-element Tuple).\n+ * <p>A pair consisting of two elements.</p>\n+ * \n+ * <p>This class is an abstract implementation defining the basic API.\n+ * It refers to the elements as 'left' and 'right'. It also implements the\n+ * {@code Map.Entry} interface where the key is 'left' and the value is 'right'.</p>\n+ * \n+ * <p>Subclass implementations may be mutable or immutable.\n+ * However, there is no restriction on the type of the stored objects that may be stored.\n+ * If mutable objects are stored in the pair, then the pair itself effectively becomes mutable.</p>\n+ *\n+ * @param <L> the first element type\n+ * @param <R> the second element type\n  *\n  * @since Lang 3.0\n  * @version $Id$\n  */\n-public abstract class Pair<L, R> implements Serializable, Map.Entry<L, R> {\n+public abstract class Pair<L, R> implements Map.Entry<L, R>, Comparable<Pair<L, R>>, Serializable {\n+\n     /** Serialization version */\n     private static final long serialVersionUID = 4954918890077093841L;\n \n     /**\n-     * Get the \"left\" element of the pair.\n-     * @return L\n+     * <p>Obtains an immutable pair of from two objects inferring the generic types.</p>\n+     * \n+     * <p>This factory allows the pair to be created using inference to\n+     * obtain the generic types.</p>\n+     * \n+     * @param <L> the left element type\n+     * @param <R> the right element type\n+     * @param left  the left element, may be null\n+     * @param right  the right element, may be null\n+     * @return a pair formed from the two parameters, not null\n+     */\n+    public static <L, R> Pair<L, R> of(L left, R right) {\n+        return new ImmutablePair<L, R>(left, right);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Gets the left element from this pair.</p>\n+     * \n+     * <p>When treated as a key-value pair, this is the key.</p>\n+     * \n+     * @return the left element, may be null\n      */\n     public abstract L getLeftElement();\n \n     /**\n-     * Get the \"right\" element of the pair.\n-     * @return R\n+     * <p>Gets the right element from this pair.</p>\n+     * \n+     * <p>When treated as a key-value pair, this is the value.</p>\n+     * \n+     * @return the right element, may be null\n      */\n     public abstract R getRightElement();\n \n     /**\n-     * Return {@link #getLeftElement()} as a {@link java.util.Map.Entry}'s key.\n-     * @return L\n+     * <p>Gets the key from this pair.</p>\n+     * \n+     * <p>This method implements the {@code Map.Entry} interface returning the\n+     * left element as the key.</p>\n+     * \n+     * @return the left element as the key, may be null\n      */\n     public final L getKey() {\n         return getLeftElement();\n     }\n \n     /**\n-     * Return {@link #getRightElement()} as a {@link java.util.Map.Entry}'s value.\n-     * @return R\n+     * <p>Gets the value from this pair.</p>\n+     * \n+     * <p>This method implements the {@code Map.Entry} interface returning the\n+     * right element as the value.</p>\n+     * \n+     * @return the right element as the value, may be null\n      */\n     public R getValue() {\n         return getRightElement();\n     }\n \n+    //-----------------------------------------------------------------------\n     /**\n-     * {@inheritDoc}\n+     * <p>Compares the pair based on the first element followed by the second element.\n+     * The types must be {@code Comparable}.</p>\n+     * \n+     * @param other  the other pair, not null\n+     * @return negative if this is less, zero if equal, positive if greater\n+     */\n+    public int compareTo(Pair<L, R> other) {\n+      return new CompareToBuilder().append(getLeftElement(), other.getLeftElement())\n+              .append(getRightElement(), other.getRightElement()).toComparison();\n+    }\n+\n+    /**\n+     * <p>Compares this pair to another based on the two elements.</p>\n+     * \n+     * @param obj  the object to compare to, null returns false\n+     * @return true if the elements of the pair are equal\n      */\n     @Override\n     public boolean equals(Object obj) {\n         if (obj == this) {\n             return true;\n         }\n-        if (obj instanceof Pair<?, ?> == false) {\n-            return false;\n+        if (obj instanceof Map.Entry<?, ?>) {\n+            Map.Entry<?, ?> other = (Map.Entry<?, ?>) obj;\n+            return ObjectUtils.equals(getKey(), other.getKey())\n+                    && ObjectUtils.equals(getValue(), other.getValue());\n         }\n-        Pair<?, ?> other = (Pair<?, ?>) obj;\n-        return ObjectUtils.equals(getLeftElement(), other.getLeftElement())\n-                && ObjectUtils.equals(getRightElement(), other.getRightElement());\n+        return false;\n     }\n \n     /**\n-     * {@inheritDoc}\n+     * <p>Returns a suitable hash code.\n+     * The hash code follows the definition in {@code Map.Entry}.</p>\n+     * \n+     * @return the hash code\n      */\n     @Override\n     public int hashCode() {\n-        // TODO should the hashCodeBuilder be seeded per concrete type?\n-        return new HashCodeBuilder().append(getLeftElement()).append(getRightElement())\n-                .toHashCode();\n+        // see Map.Entry API specification\n+        return (getKey() == null ? 0 : getKey().hashCode()) ^\n+                (getValue() == null ? 0 : getValue().hashCode());\n     }\n \n     /**\n-     * Returns a String representation of the Pair in the form: (L,R)\n+     * <p>Returns a String representation of the Pair in the form: (L,R).</p>\n+     * \n      * @return a string for this object\n      */\n     @Override\n     public String toString() {\n-        StringBuilder builder = new StringBuilder(this.getClass().getSimpleName());\n+        StringBuilder builder = new StringBuilder();\n         builder.append(\"(\");\n         builder.append(getLeftElement());\n         builder.append(\",\");\n         return builder.toString();\n     }\n \n-    /**\n-     * Static fluent creation method for a {@link Pair}<L, R>:\n-     * <code>Pair.of(left, right)</code>\n-     * @param <L> the left generic type\n-     * @param <R> the right generic type\n-     * @param left the left value\n-     * @param right the right value\n-     * @return ImmutablePair<L, R>(left, right)\n-     */\n-    public static <L, R> Pair<L, R> of(L left, R right) {\n-        return new ImmutablePair<L, R>(left, right);\n-    }\n }\n--- a/src/test/java/org/apache/commons/lang3/ImmutablePairTest.java\n+++ b/src/test/java/org/apache/commons/lang3/ImmutablePairTest.java\n \n     @Test\n     public void testToString() throws Exception {\n-        assertEquals(\"ImmutablePair(null,null)\", ImmutablePair.of(null, null).toString());\n-        assertEquals(\"ImmutablePair(null,two)\", ImmutablePair.of(null, \"two\").toString());\n-        assertEquals(\"ImmutablePair(one,null)\", ImmutablePair.of(\"one\", null).toString());\n-        assertEquals(\"ImmutablePair(one,two)\", ImmutablePair.of(\"one\", \"two\").toString());\n+        assertEquals(\"(null,null)\", ImmutablePair.of(null, null).toString());\n+        assertEquals(\"(null,two)\", ImmutablePair.of(null, \"two\").toString());\n+        assertEquals(\"(one,null)\", ImmutablePair.of(\"one\", null).toString());\n+        assertEquals(\"(one,two)\", ImmutablePair.of(\"one\", \"two\").toString());\n     }\n \n     @Test\n--- a/src/test/java/org/apache/commons/lang3/MutablePairTest.java\n+++ b/src/test/java/org/apache/commons/lang3/MutablePairTest.java\n \n     @Test\n     public void testToString() throws Exception {\n-        assertEquals(\"MutablePair(null,null)\", MutablePair.of(null, null).toString());\n-        assertEquals(\"MutablePair(null,two)\", MutablePair.of(null, \"two\").toString());\n-        assertEquals(\"MutablePair(one,null)\", MutablePair.of(\"one\", null).toString());\n-        assertEquals(\"MutablePair(one,two)\", MutablePair.of(\"one\", \"two\").toString());\n+        assertEquals(\"(null,null)\", MutablePair.of(null, null).toString());\n+        assertEquals(\"(null,two)\", MutablePair.of(null, \"two\").toString());\n+        assertEquals(\"(one,null)\", MutablePair.of(\"one\", null).toString());\n+        assertEquals(\"(one,two)\", MutablePair.of(\"one\", \"two\").toString());\n     }\n \n     @Test\n--- a/src/test/java/org/apache/commons/lang3/PairTest.java\n+++ b/src/test/java/org/apache/commons/lang3/PairTest.java\n import static org.junit.Assert.assertNull;\n import static org.junit.Assert.assertTrue;\n \n+import java.util.HashMap;\n import java.util.HashSet;\n+import java.util.Map.Entry;\n \n import org.junit.Test;\n \n     }\n \n     @Test\n-    public void testCompatibility() throws Exception {\n+    public void testCompatibilityBetweenPairs() throws Exception {\n         Pair<Integer, String> pair = ImmutablePair.of(0, \"foo\");\n         Pair<Integer, String> pair2 = MutablePair.of(0, \"foo\");\n         assertEquals(pair, pair2);\n     }\n \n     @Test\n+    public void testMapEntry() throws Exception {\n+        Pair<Integer, String> pair = ImmutablePair.of(0, \"foo\");\n+        HashMap<Integer, String> map = new HashMap<Integer, String>();\n+        map.put(0, \"foo\");\n+        Entry<Integer, String> entry = map.entrySet().iterator().next();\n+        assertEquals(pair, entry);\n+        assertEquals(pair.hashCode(), entry.hashCode());\n+    }\n+\n+    @Test\n+    public void testComparable1() throws Exception {\n+        Pair<String, String> pair1 = Pair.of(\"A\", \"D\");\n+        Pair<String, String> pair2 = Pair.of(\"B\", \"C\");\n+        assertEquals(true, pair1.compareTo(pair1) == 0);\n+        assertEquals(true, pair1.compareTo(pair2) < 0);\n+        assertEquals(true, pair2.compareTo(pair2) == 0);\n+        assertEquals(true, pair2.compareTo(pair1) > 0);\n+    }\n+\n+    @Test\n+    public void testComparable2() throws Exception {\n+        Pair<String, String> pair1 = Pair.of(\"A\", \"C\");\n+        Pair<String, String> pair2 = Pair.of(\"A\", \"D\");\n+        assertEquals(true, pair1.compareTo(pair1) == 0);\n+        assertEquals(true, pair1.compareTo(pair2) < 0);\n+        assertEquals(true, pair2.compareTo(pair2) == 0);\n+        assertEquals(true, pair2.compareTo(pair1) > 0);\n+    }\n+\n+    @Test\n     public void testToString() throws Exception {\n         Pair<String, String> pair = Pair.of(\"Key\", \"Value\");\n-        assertEquals(\"ImmutablePair(Key,Value)\", pair.toString());\n+        assertEquals(\"(Key,Value)\", pair.toString());\n     }\n+\n }", "timestamp": 1302544094, "metainfo": ""}