{"sha": "1a6b33077c93f5d901788c6cc0df8eca89cc45c3", "log": "Updated method utils with latest code from the beanutils version.   ", "commit": "\n--- a/src/java/org/apache/commons/lang/reflect/MethodUtils.java\n+++ b/src/java/org/apache/commons/lang/reflect/MethodUtils.java\n  * programmer. This can break an implementation if used incorrectly. This\n  * facility should be used with care.\n  *\n- * @author Based on code from BeanUtils\n  * @author <a href=\"mailto:scolebourne@apache.org\">Stephen Colebourne</a>\n- * @version $Id: MethodUtils.java,v 1.1 2002/10/24 23:12:54 scolebourne Exp $\n+ * @author Based on code from <code>BeanUtils</code> by: Craig R. McClanahan\n+ * @author Ralph Schaer\n+ * @author Chris Audley\n+ * @author Rey Franois\n+ * @author Gregor Raman\n+ * @author Jan Sorensen\n+ * @author Robert Burrell Donkin\n+ * @version $Id: MethodUtils.java,v 1.2 2002/11/14 18:51:57 rdonkin Exp $\n  */\n public class MethodUtils {\n+    \n+    public static final boolean debug = true;\n     \n     /** An empty method array */\n     public static final Method[] EMPTY_METHOD_ARRAY = new Method[0];\n             args = ArrayUtils.EMPTY_OBJECT_ARRAY;\n         }  \n \n-return null;\n-//        Method method = getMatchingAccessibleMethod(\n-//                object.getClass(),\n-//                methodName,\n-//                parameterTypes);\n-//        if (method == null)\n-//            throw new NoSuchMethodException(\"No such accessible method: \" +\n-//                    methodName + \"() on object: \" + object.getClass().getName());\n-//        return method.invoke(object, args);\n+//return null;\n+        Method method = getMatchingAccessibleMethod(\n+                object.getClass(),\n+                methodName,\n+                parameterTypes);\n+        if (method == null)\n+            throw new NoSuchMethodException(\"No such accessible method: \" +\n+                    methodName + \"() on object: \" + object.getClass().getName());\n+        return method.invoke(object, args);\n     }\n \n \n \n     }\n \n-//    /**\n-//     * <p>Find an accessible method that matches the given name and has compatible parameters.\n-//     * Compatible parameters mean that every method parameter is assignable from \n-//     * the given parameters.\n-//     * In other words, it finds a method with the given name \n-//     * that will take the parameters given.<p>\n-//     *\n-//     * <p>This method is slightly undeterminstic since it loops \n-//     * through methods names and return the first matching method.</p>\n-//     * \n-//     * <p>This method is used by \n-//     * {@link \n-//     * #invokeMethod(Object object,String methodName,Object [] args,Class[] parameterTypes)}.\n-//     *\n-//     * <p>This method can match primitive parameter by passing in wrapper classes.\n-//     * For example, a <code>Boolean</code> will match a primitive <code>boolean</code>\n-//     * parameter.\n-//     *\n-//     * @param clazz find method in this class\n-//     * @param methodName find method with this name\n-//     * @param parameterTypes find method with compatible parameters \n-//     */\n-//    private static Method getMatchingAccessibleMethod(\n-//                                                Class clazz,\n-//                                                String methodName,\n-//                                                Class[] parameterTypes) {\n-//        // trace logging\n-//        if (log.isTraceEnabled()) {\n-//            log.trace(\"Matching name=\" + methodName + \" on \" + clazz);\n-//        }\n-//        \n-//        // see if we can find the method directly\n-//        // most of the time this works and it's much faster\n-//        try {\n-//            Method method = clazz.getMethod(methodName, parameterTypes);\n-//            return method;\n-//            \n-//        } catch (NoSuchMethodException e) { /* SWALLOW */ }\n-//        \n-//        // search through all methods \n-//        int paramSize = parameterTypes.length;\n-//        Method[] methods = clazz.getMethods();\n-//        for (int i = 0, size = methods.length; i < size ; i++) {\n-//            if (methods[i].getName().equals(methodName)) {\t\n-//                // log some trace information\n-//                if (log.isTraceEnabled()) {\n-//                    log.trace(\"Found matching name:\");\n-//                    log.trace(methods[i]);\n-//                }                \n-//                \n-//                // compare parameters\n-//                Class[] methodsParams = methods[i].getParameterTypes();\n-//                int methodParamSize = methodsParams.length;\n-//                if (methodParamSize == paramSize) {          \n-//                    boolean match = true;\n-//                    for (int n = 0 ; n < methodParamSize; n++) {\n-//                        if (log.isTraceEnabled()) {\n-//                            log.trace(\"Param=\" + parameterTypes[n].getName());\n-//                            log.trace(\"Method=\" + methodsParams[n].getName());\n-//                        }\n-//                        if (!isAssignmentCompatible(methodsParams[n], parameterTypes[n])) {\n-//                            if (log.isTraceEnabled()) {\n-//                                log.trace(methodsParams[n] + \" is not assignable from \" \n-//                                            + parameterTypes[n]);\n-//                            }    \n-//                            match = false;\n-//                            break;\n-//                        }\n-//                    }\n-//                    \n-//                    if (match) {\n-//                        // get accessible version of method\n-//                        Method method = getAccessibleMethod(methods[i]);\n-//                        if (method != null) {\n-//                            if (log.isTraceEnabled()) {\n-//                                log.trace(method + \" accessible version of \" \n-//                                            + methods[i]);\n-//                            }\n-//                            return method;\n-//                        }\n-//                        \n-//                        log.trace(\"Couldn't find accessible method.\");\n-//                    }\n-//                }\n-//            }\n-//        }\n-//        \n-//        // didn't find a match\n-//        log.trace(\"No match found.\");\n-//        return null;                                        \n-//    }\n-//\n-//    /**\n-//     * <p>Determine whether a type can be used as a parameter in a method invocation.\n-//     * This method handles primitive conversions correctly.</p>\n-//     *\n-//     * <p>In order words, it will match a <code>Boolean</code> to a <code>boolean</code>,\n-//     * a <code>Long</code> to a <code>long</code>,\n-//     * a <code>Float</code> to a <code>float</code>,\n-//     * a <code>Integer</code> to a <code>int</code>,\n-//     * and a <code>Double</code> to a <code>double</code>.\n-//     * Now logic widening matches are allowed.\n-//     * For example, a <code>Long</code> will not match a <code>int</code>.\n-//     *\n-//     * @param parameterType the type of parameter accepted by the method\n-//     * @param parameterization the type of parameter being tested \n-//     *\n-//     * @return true if the assignement is compatible.\n-//     */\n-//    private static final boolean isAssignmentCompatible(Class parameterType, Class parameterization) {\n-//        // try plain assignment\n-//        if (parameterType.isAssignableFrom(parameterization)) {\n-//            return true;\n-//        }\n-//        \n-//        if (parameterType.isPrimitive()) {\n-//            // does anyone know a better strategy than comparing names?\n-//            // also, this method does *not* do widening - you must specify exactly\n-//            // is this the right behaviour?\n-//            if (boolean.class.equals(parameterType)) {\n-//                return Boolean.class.equals(parameterization);\n-//            }         \n-//            if (float.class.equals(parameterType)) {\n-//                return Float.class.equals(parameterization);\n-//            }     \n-//            if (long.class.equals(parameterType)) {\n-//                return Long.class.equals(parameterization);\n-//            }     \n-//            if (int.class.equals(parameterType)) {\n-//                return Integer.class.equals(parameterization);\n-//            }                \n-//            if (double.class.equals(parameterType)) {\n-//                return Double.class.equals(parameterization);\n-//            }               \n-//        }\n-//        \n-//        return false;\n-//    }\n-//    \n+\n+    /**\n+     * <p>Find an accessible method that matches the given name and has compatible parameters.\n+     * Compatible parameters mean that every method parameter is assignable from \n+     * the given parameters.\n+     * In other words, it finds a method with the given name \n+     * that will take the parameters given.<p>\n+     *\n+     * <p>This method is slightly undeterminstic since it loops \n+     * through methods names and return the first matching method.</p>\n+     * \n+     * <p>This method is used by \n+     * {@link \n+     * #invokeMethod(Object object,String methodName,Object [] args,Class[] parameterTypes)}.\n+     *\n+     * <p>This method can match primitive parameter by passing in wrapper classes.\n+     * For example, a <code>Boolean</code> will match a primitive <code>boolean</code>\n+     * parameter.\n+     *\n+     * @param clazz find method in this class\n+     * @param methodName find method with this name\n+     * @param parameterTypes find method with compatible parameters \n+     */\n+    private static Method getMatchingAccessibleMethod(\n+                                                Class clazz,\n+                                                String methodName,\n+                                                Class[] parameterTypes) {\n+        // trace logging\n+        if (debug) {\n+            log(\"Matching name=\" + methodName + \" on \" + clazz);\n+        }\n+        \n+        // see if we can find the method directly\n+        // most of the time this works and it's much faster\n+        try {\n+            Method method = clazz.getMethod(methodName, parameterTypes);\n+            if (debug) {\n+                log(\"Found straight match: \" + method);\n+                log(\"isPublic:\" + Modifier.isPublic(method.getModifiers()));\n+            }\n+            \n+            try {\n+                //\n+                // XXX Default access superclass workaround\n+                //\n+                // When a public class has a default access superclass\n+                // with public methods, these methods are accessible.\n+                // Calling them from compiled code works fine.\n+                //\n+                // Unfortunately, using reflection to invoke these methods\n+                // seems to (wrongly) to prevent access even when the method\n+                // modifer is public.\n+                //\n+                // The following workaround solves the problem but will only\n+                // work from sufficiently privilages code. \n+                //\n+                // Better workarounds would be greatfully accepted.\n+                //\n+                method.setAccessible(true);\n+                \n+            } catch (SecurityException se) {\n+                // log but continue just in case the method.invoke works anyway\n+                log(\n+                \"Cannot setAccessible on method. Therefore cannot use jvm access bug workaround.\", \n+                se);\n+            }\n+            return method;\n+            \n+        } catch (NoSuchMethodException e) { /* SWALLOW */ }\n+        \n+        // search through all methods \n+        int paramSize = parameterTypes.length;\n+        Method[] methods = clazz.getMethods();\n+        for (int i = 0, size = methods.length; i < size ; i++) {\n+            if (methods[i].getName().equals(methodName)) {\t\n+                // log some trace information\n+                if (debug) {\n+                    log(\"Found matching name:\");\n+                    log(methods[i]);\n+                }                \n+                \n+                // compare parameters\n+                Class[] methodsParams = methods[i].getParameterTypes();\n+                int methodParamSize = methodsParams.length;\n+                if (methodParamSize == paramSize) {          \n+                    boolean match = true;\n+                    for (int n = 0 ; n < methodParamSize; n++) {\n+                        if (debug) {\n+                            log(\"Param=\" + parameterTypes[n].getName());\n+                            log(\"Method=\" + methodsParams[n].getName());\n+                        }\n+                        if (!isAssignmentCompatible(methodsParams[n], parameterTypes[n])) {\n+                            if (debug) {\n+                                log(methodsParams[n] + \" is not assignable from \" \n+                                            + parameterTypes[n]);\n+                            }    \n+                            match = false;\n+                            break;\n+                        }\n+                    }\n+                    \n+                    if (match) {\n+                        // get accessible version of method\n+                        Method method = getAccessibleMethod(methods[i]);\n+                        if (method != null) {\n+                            if (debug) {\n+                                log(method + \" accessible version of \" \n+                                            + methods[i]);\n+                            }\n+                            try {\n+                                //\n+                                // XXX Default access superclass workaround\n+                                // (See above for more details.)\n+                                //\n+                                method.setAccessible(true);\n+                                \n+                            } catch (SecurityException se) {\n+                                // log but continue just in case the method.invoke works anyway\n+                                log(\n+                                \"Cannot setAccessible on method. Therefore cannot use jvm access bug workaround.\", \n+                                se);\n+                            }\n+                            return method;\n+                        }\n+                        \n+                        log(\"Couldn't find accessible method.\");\n+                    }\n+                }\n+            }\n+        }\n+        \n+        // didn't find a match\n+        log(\"No match found.\");\n+        return null;                                        \n+    }\n+\n+\n+    /**\n+     * <p>Determine whether a type can be used as a parameter in a method invocation.\n+     * This method handles primitive conversions correctly.</p>\n+     *\n+     * <p>In order words, it will match a <code>Boolean</code> to a <code>boolean</code>,\n+     * a <code>Long</code> to a <code>long</code>,\n+     * a <code>Float</code> to a <code>float</code>,\n+     * a <code>Integer</code> to a <code>int</code>,\n+     * and a <code>Double</code> to a <code>double</code>.\n+     * Now logic widening matches are allowed.\n+     * For example, a <code>Long</code> will not match a <code>int</code>.\n+     *\n+     * @param parameterType the type of parameter accepted by the method\n+     * @param parameterization the type of parameter being tested \n+     *\n+     * @return true if the assignement is compatible.\n+     */\n+    private static final boolean isAssignmentCompatible(Class parameterType, Class parameterization) {\n+        // try plain assignment\n+        if (parameterType.isAssignableFrom(parameterization)) {\n+            return true;\n+        }\n+        \n+        if (parameterType.isPrimitive()) {\n+            // does anyone know a better strategy than comparing names?\n+            // also, this method does *not* do widening - you must specify exactly\n+            // is this the right behaviour?\n+            if (boolean.class.equals(parameterType)) {\n+                return Boolean.class.equals(parameterization);\n+            }         \n+            if (float.class.equals(parameterType)) {\n+                return Float.class.equals(parameterization);\n+            }     \n+            if (long.class.equals(parameterType)) {\n+                return Long.class.equals(parameterization);\n+            }     \n+            if (int.class.equals(parameterType)) {\n+                return Integer.class.equals(parameterization);\n+            }                \n+            if (double.class.equals(parameterType)) {\n+                return Double.class.equals(parameterization);\n+            }               \n+        }\n+        \n+        return false;\n+    }\n+    \n+    \n+    private static void log(Object o) {\n+        if (debug) {\n+            System.err.println(o);\n+        }\n+    }\n+    \n+    private static void log(Object o, Throwable t) {\n+        if (debug) {\n+            System.err.println(o);\n+            System.err.println(t);\n+            \n+        }\n+    }\n }", "timestamp": 1037299917, "metainfo": ""}