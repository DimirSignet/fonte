{"sha": "5811e4c52f9990a0bd80c5c0643454de742e9b90", "log": "Switched to static builder methods, allowing two of the constructors to restrict T to Comparables, and removed javadoc that discussed subclasses optimising methods  ", "commit": "\n--- a/src/java/org/apache/commons/lang/Range.java\n+++ b/src/java/org/apache/commons/lang/Range.java\n      * @throws IllegalArgumentException if the value is <code>null</code>\n      * @throws ClassCastException if the value is not Comparable\n      */\n-    // TODO: Ideally the ClassCastException would be compile-time via generics\n-    public Range(T element) {\n-        this( element, element);\n+    public static <T extends Comparable> Range is(T element) {\n+        return new Range(element, element, ComparableComparator.INSTANCE);\n     }\n \n     /**\n      * @throws IllegalArgumentException if either value is <code>null</code>\n      * @throws ClassCastException if either value is not Comparable\n      */\n-    // TODO: Ideally the ClassCastException would be compile-time via generics\n-    public Range(T element1, T element2) {\n-        this( element1, element2, ComparableComparator.INSTANCE);\n+    public static <T extends Comparable> Range between(T element1, T element2) {\n+        return new Range( element1, element2, ComparableComparator.INSTANCE);\n     }\n \n     /**\n      * @param c comparator to be used\n      * @throws IllegalArgumentException if the value is <code>null</code>\n      */\n-    public Range(T element, Comparator c) {\n-        this(element, element, c);\n+    public static <T> Range is(T element, Comparator c) {\n+        return new Range(element, element, c);\n     }\n \n     /**\n      * @param c comparator to be used\n      * @throws IllegalArgumentException if either value is <code>null</code>\n      */\n-    public Range(T element1, T element2, Comparator c) {\n+    public static <T> Range between(T element1, T element2, Comparator c) {\n+        return new Range(element1, element2, c);\n+    }\n+\n+    private Range(T element1, T element2, Comparator c) {\n         if(element1 == null || element2 == null) {\n             throw new IllegalArgumentException(\"Elements in a range must not be null: element1=\" + \n                                                element1 + \", element2=\" + element2);\n     /**\n      * <p>Tests whether the specified range occurs entirely within this range.</p>\n      * \n-     * <p>The exact comparison implementation varies by subclass. It is\n-     * intended that an <code>int</code> specific subclass will compare using\n-     * <code>int</code> comparison.</p>\n-     * \n      * <p><code>null</code> is handled and returns <code>false</code>.</p>\n      * \n-     * <p>This implementation uses the {@link #contains(Object)} method.\n-     * Subclasses may be able to optimise this.</p>\n-     *\n      * @param range  the range to test, may be <code>null</code>\n      * @return <code>true</code> if the specified range occurs entirely within\n      *  this range; otherwise, <code>false</code>\n     /**\n      * <p>Tests whether the specified range overlaps with this range.</p>\n      * \n-     * <p>The exact comparison implementation varies by subclass. It is\n-     * intended that an <code>int</code> specific subclass will compare using\n-     * <code>int</code> comparison.</p>\n-     * \n      * <p><code>null</code> is handled and returns <code>false</code>.</p>\n      * \n-     * <p>This implementation uses the {@link #contains(Object)} and\n-     * {@link #containsRange(Range)} methods.\n-     * Subclasses may be able to optimise this.</p>\n-     *\n      * @param range  the range to test, may be <code>null</code>\n      * @return <code>true</code> if the specified range overlaps with this\n      *  range; otherwise, <code>false</code>\n      * \n      * <p>To be equal, the class, minimum and maximum must be equal.</p>\n      * \n-     * <p>This implementation uses the {@link #getMinimum()} and \n-     * {@link #getMaximum()} methods. \n-     * Subclasses may be able to optimise this.</p>\n-     *\n      * @param obj the reference object with which to compare\n      * @return <code>true</code> if this object is equal\n      */\n     /**\n      * <p>Gets a hashCode for the range.</p>\n      * \n-     * <p>This implementation uses the {@link #getMinimum()} and \n-     * {@link #getMaximum()} methods. \n-     * Subclasses may be able to optimise this.</p>\n-     *\n      * @return a hash code value for this object\n      */\n     @Override\n      *\n      * <p>The format of the String is 'Range[<i>min</i>,<i>max</i>]'.</p>\n      * \n-     * <p>This implementation uses the {@link #getMinimum()} and \n-     * {@link #getMaximum()} methods. \n-     * Subclasses may be able to optimise this.</p>\n-     *\n      * @return the <code>String</code> representation of this range\n      */\n     @Override\n--- a/src/test/org/apache/commons/lang/RangeTest.java\n+++ b/src/test/org/apache/commons/lang/RangeTest.java\n \n     @Override\n     public void setUp() {\n-        byteRange   = new Range((byte) 0, (byte) 5);\n-        byteRange2  = new Range((byte) 0, (byte) 5);\n-        byteRange3  = new Range((byte) 0, (byte) 10);\n-\n-        intRange    = new Range<Integer>((int) 10, (int) 20);\n-        longRange   = new Range<Long>((long) 10, (long) 20);\n-        floatRange  = new Range<Float>((float) 10, (float) 20);\n-        doubleRange = new Range<Double>((double) 10, (double) 20);\n+        byteRange   = Range.between((byte) 0, (byte) 5);\n+        byteRange2  = Range.between((byte) 0, (byte) 5);\n+        byteRange3  = Range.between((byte) 0, (byte) 10);\n+\n+        intRange    = Range.between((int) 10, (int) 20);\n+        longRange   = Range.between((long) 10, (long) 20);\n+        floatRange  = Range.between((float) 10, (float) 20);\n+        doubleRange = Range.between((double) 10, (double) 20);\n     }\n \n     // --------------------------------------------------------------------------\n \n     public void testComparableConstructors() {\n-        try {\n-            Range range = new Range(new Object());\n-            fail(\"IllegalArgumentException expected\");\n-        } catch(ClassCastException cce) {\n-            // expected\n-        }\n-\n-        try {\n-            Range range = new Range(new Object(), new Object());\n-            fail(\"ClassCastException expected\");\n-        } catch(ClassCastException cce) {\n-            // expected\n-        }\n-    }\n+        Comparable c = \n+            new Comparable() { \n+                public int compareTo(Object other) {\n+                    return 1;\n+                }\n+            };\n+        Range.is(c);\n+        Range.between(c, c);\n+    }\n+\n \n     // --------------------------------------------------------------------------\n \n         String str = intRange.toString();\n         assertEquals(\"Range[10,20]\", str);\n //        assertSame(str, intRange.toString());  // no longer passes - does it matter?\n-        assertEquals(\"Range[-20,-10]\", new Range<Integer>(-20, -10).toString());\n+        assertEquals(\"Range[-20,-10]\", Range.between(-20, -10).toString());\n     }\n \n     // --------------------------------------------------------------------------\n         assertFalse(intRange.containsRange(null));\n \n         // easy inside range\n-        assertTrue(intRange.containsRange(new Range(12, 18)));\n+        assertTrue(intRange.containsRange(Range.between(12, 18)));\n \n         // outside range on each side\n-        assertFalse(intRange.containsRange(new Range(32, 45)));\n-        assertFalse(intRange.containsRange(new Range(2, 8)));\n+        assertFalse(intRange.containsRange(Range.between(32, 45)));\n+        assertFalse(intRange.containsRange(Range.between(2, 8)));\n \n         // equals range\n-        assertTrue(intRange.containsRange(new Range(10, 20)));\n+        assertTrue(intRange.containsRange(Range.between(10, 20)));\n \n         // overlaps\n-        assertFalse(intRange.containsRange(new Range(9, 14)));\n-        assertFalse(intRange.containsRange(new Range(16, 21)));\n+        assertFalse(intRange.containsRange(Range.between(9, 14)));\n+        assertFalse(intRange.containsRange(Range.between(16, 21)));\n \n         // touches lower boundary\n-        assertTrue(intRange.containsRange(new Range(10, 19)));\n-        assertFalse(intRange.containsRange(new Range(10, 21)));\n+        assertTrue(intRange.containsRange(Range.between(10, 19)));\n+        assertFalse(intRange.containsRange(Range.between(10, 21)));\n \n         // touches upper boundary\n-        assertTrue(intRange.containsRange(new Range(11, 20)));\n-        assertFalse(intRange.containsRange(new Range(9, 20)));\n+        assertTrue(intRange.containsRange(Range.between(11, 20)));\n+        assertFalse(intRange.containsRange(Range.between(9, 20)));\n         \n         // negative\n-        assertFalse(intRange.containsRange(new Range(-11, -18)));\n+        assertFalse(intRange.containsRange(Range.between(-11, -18)));\n \n     }\n \n         assertFalse(intRange.overlapsRange(null));\n \n         // easy inside range\n-        assertTrue(intRange.overlapsRange(new Range(12, 18)));\n+        assertTrue(intRange.overlapsRange(Range.between(12, 18)));\n \n         // outside range on each side\n-        assertFalse(intRange.overlapsRange(new Range(32, 45)));\n-        assertFalse(intRange.overlapsRange(new Range(2, 8)));\n+        assertFalse(intRange.overlapsRange(Range.between(32, 45)));\n+        assertFalse(intRange.overlapsRange(Range.between(2, 8)));\n \n         // equals range\n-        assertTrue(intRange.overlapsRange(new Range(10, 20)));\n+        assertTrue(intRange.overlapsRange(Range.between(10, 20)));\n \n         // overlaps\n-        assertTrue(intRange.overlapsRange(new Range(9, 14)));\n-        assertTrue(intRange.overlapsRange(new Range(16, 21)));\n+        assertTrue(intRange.overlapsRange(Range.between(9, 14)));\n+        assertTrue(intRange.overlapsRange(Range.between(16, 21)));\n \n         // touches lower boundary\n-        assertTrue(intRange.overlapsRange(new Range(10, 19)));\n-        assertTrue(intRange.overlapsRange(new Range(10, 21)));\n+        assertTrue(intRange.overlapsRange(Range.between(10, 19)));\n+        assertTrue(intRange.overlapsRange(Range.between(10, 21)));\n \n         // touches upper boundary\n-        assertTrue(intRange.overlapsRange(new Range(11, 20)));\n-        assertTrue(intRange.overlapsRange(new Range(9, 20)));\n+        assertTrue(intRange.overlapsRange(Range.between(11, 20)));\n+        assertTrue(intRange.overlapsRange(Range.between(9, 20)));\n         \n         // negative\n-        assertFalse(intRange.overlapsRange(new Range(-11, -18)));\n+        assertFalse(intRange.overlapsRange(Range.between(-11, -18)));\n \n     }\n ", "timestamp": 1258790755, "metainfo": ""}