{"sha": "79dd6a2f742b8577d12aefd1781ebff8d8e39458", "log": "Document some @SuppressWarning annotations  ", "commit": "\n--- a/src/main/java/org/apache/commons/lang3/AnnotationUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/AnnotationUtils.java\n             Class<? extends Annotation> annotationType = null;\n             for (Class<?> iface : ClassUtils.getAllInterfaces(cls)) {\n                 if (Annotation.class.isAssignableFrom(iface)) {\n-                    @SuppressWarnings(\"unchecked\")\n-                    //because we just checked the assignability\n+                    @SuppressWarnings(\"unchecked\") // OK because we just checked the assignability\n                     Class<? extends Annotation> found = (Class<? extends Annotation>) iface;\n                     annotationType = found;\n                     break;\n--- a/src/main/java/org/apache/commons/lang3/ArrayUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/ArrayUtils.java\n      * (index < 0 || index >= array.length), or if the array is {@code null}.\n      * @since 3.0.1\n      */\n-    @SuppressWarnings(\"unchecked\")\n-    // removeAll() always creates an array of the same type as its input\n+    @SuppressWarnings(\"unchecked\") // removeAll() always creates an array of the same type as its input\n     public static <T> T[] removeAll(T[] array, int... indices) {\n         return (T[]) removeAll((Object) array, clone(indices));\n     }\n--- a/src/main/java/org/apache/commons/lang3/ObjectUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/ObjectUtils.java\n                         + obj.getClass().getName(), e.getCause());\n                 }\n             }\n-            @SuppressWarnings(\"unchecked\")\n+            @SuppressWarnings(\"unchecked\") // OK because input is of type T\n             final T checked = (T) result;\n             return checked;\n         }\n--- a/src/main/java/org/apache/commons/lang3/event/EventListenerSupport.java\n+++ b/src/main/java/org/apache/commons/lang3/event/EventListenerSupport.java\n      * @throws ClassNotFoundException if the class cannot be resolved\n      */\n     private void readObject(ObjectInputStream objectInputStream) throws IOException, ClassNotFoundException {\n-        @SuppressWarnings(\"unchecked\")\n+        @SuppressWarnings(\"unchecked\") // Will throw CCE here if not correct\n         L[] listeners = (L[]) objectInputStream.readObject();\n \n         this.listeners = new CopyOnWriteArrayList<L>(listeners);\n \n-        @SuppressWarnings(\"unchecked\")\n+        @SuppressWarnings(\"unchecked\") // Will throw CCE here if not correct\n         Class<L> listenerInterface = (Class<L>) listeners.getClass().getComponentType();\n \n         initializeTransientFields(listenerInterface, Thread.currentThread().getContextClassLoader());\n      * @param classLoader the class loader to be used\n      */\n     private void initializeTransientFields(Class<L> listenerInterface, ClassLoader classLoader) {\n-        @SuppressWarnings(\"unchecked\")\n+        @SuppressWarnings(\"unchecked\") // Will throw CCE here if not correct\n         L[] array = (L[]) Array.newInstance(listenerInterface, 0);\n         this.prototypeArray = array;\n         createProxy(listenerInterface, classLoader);", "timestamp": 1348752873, "metainfo": ""}