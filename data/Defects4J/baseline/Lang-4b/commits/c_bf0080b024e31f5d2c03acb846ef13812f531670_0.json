{"sha": "bf0080b024e31f5d2c03acb846ef13812f531670", "log": "LANG-828 FastDateParser does not handle non-Gregorian calendars properly Fix bug in Java 7 (Locale.toString() format has changed)  ", "commit": "\n--- a/src/main/java/org/apache/commons/lang3/time/FastDateParser.java\n+++ b/src/main/java/org/apache/commons/lang3/time/FastDateParser.java\n     \n     private static final ConcurrentMap<Locale,TimeZoneStrategy> tzsCache= \n         new ConcurrentHashMap<Locale,TimeZoneStrategy>(3);\n-    \n+\n+    static final Locale JAPANESE_IMPERIAL = new Locale(\"ja\",\"JP\",\"JP\");\n+\n     // defining fields\n     private final String pattern;\n     private final TimeZone timeZone;\n             throw new IllegalArgumentException(\"Invalid pattern\");\n         }\n \n-        String localeName = locale.toString();\n         // These locales don't use the Gregorian calendar\n         // See http://docs.oracle.com/javase/6/docs/technotes/guides/intl/calendar.doc.html\n-        if (localeName.equals(\"ja_JP_JP\") || localeName.startsWith(\"th_TH\")) {\n+        // Also, the getEras() methods don't return the correct era names.\n+        // N.B. Not safe to use toString() comparison because that changes between Java versions\n+        if (locale.equals(JAPANESE_IMPERIAL)\n+        || (locale.getLanguage().equals(\"th\") && locale.getCountry().equals(\"TH\"))) {\n             collector.add(new SimpleDateFormatStrategy());\n             strategies= collector.toArray(new Strategy[collector.size()]);\n             parsePattern= Pattern.compile(\"(.*+)\");\n--- a/src/test/java/org/apache/commons/lang3/time/FastDateParserTest.java\n+++ b/src/test/java/org/apache/commons/lang3/time/FastDateParserTest.java\n                 Calendar cal = Calendar.getInstance(tz);\n                 for(int year : new int[]{2003, 1940, 1868, 1867, 0, -1940}) {\n                     // http://docs.oracle.com/javase/6/docs/technotes/guides/intl/calendar.doc.html\n-                    if (year < 1868 && locale.toString().equals(\"ja_JP_JP\")) {\n+                    if (year < 1868 && locale.equals(FastDateParser.JAPANESE_IMPERIAL)) {\n                         continue; // Japanese imperial calendar does not support eras before 1868\n                     }\n                     cal.clear();\n         boolean failed = false;\n         for(Locale locale : Locale.getAvailableLocales()) {\n             // ja_JP_JP cannot handle dates before 1868 properly\n-            if (eraBC && format.equals(SHORT_FORMAT) && locale.toString().equals(\"ja_JP_JP\")) {\n+            if (eraBC && format.equals(SHORT_FORMAT) && locale.equals(FastDateParser.JAPANESE_IMPERIAL)) {\n                 continue;\n             }\n             SimpleDateFormat sdf = new SimpleDateFormat(format, locale);", "timestamp": 1348611134, "metainfo": ""}