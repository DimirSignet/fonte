{"sha": "6b070903294f99f22f96f3440dfa00246c619561", "log": "LANG-778: Add to Conversion from byte[] to UUID and UUID to byte[]  ", "commit": "\n--- a/src/main/java/org/apache/commons/lang3/Conversion.java\n+++ b/src/main/java/org/apache/commons/lang3/Conversion.java\n  * under the License.\n  *******************************************************************************/\n package org.apache.commons.lang3;\n+\n+import java.util.UUID;\n \n /**\n  * <p>\n      *            conversion\n      * @param dstInit initial value of the destination long\n      * @param dstPos the position of the lsb, in bits, in the result long\n-     * @param nInts the number of int to convert\n+     * @param nInts the number of ints to convert\n      * @return a long containing the selected bits\n      * @throws IllegalArgumentException if {@code (nInts-1)*32+dstPos >= 64}   \n      */\n      *            conversion\n      * @param dstInit initial value of the destination long\n      * @param dstPos the position of the lsb, in bits, in the result long\n-     * @param nShorts the number of short to convert\n+     * @param nShorts the number of shorts to convert\n      * @return a long containing the selected bits\n      * @throws IllegalArgumentException if {@code (nShorts-1)*16+dstPos >= 64}   \n      */\n      *            conversion\n      * @param dstInit initial value of the destination int\n      * @param dstPos the position of the lsb, in bits, in the result int\n-     * @param nShorts the number of short to convert\n+     * @param nShorts the number of shorts to convert\n      * @return a int containing the selected bits\n      * @throws IllegalArgumentException if {@code (nShorts-1)*16+dstPos >= 32}   \n      */\n      *            conversion\n      * @param dstInit initial value of the destination long\n      * @param dstPos the position of the lsb, in bits, in the result long\n-     * @param nBytes the number of byte to convert\n+     * @param nBytes the number of bytes to convert\n      * @return a long containing the selected bits\n      * @throws IllegalArgumentException if {@code (nBytes-1)*8+dstPos >= 64}   \n      */\n      *            conversion\n      * @param dstInit initial value of the destination int\n      * @param dstPos the position of the lsb, in bits, in the result int\n-     * @param nBytes the number of byte to convert\n+     * @param nBytes the number of bytes to convert\n      * @return a int containing the selected bits\n      * @throws IllegalArgumentException if {@code (nBytes-1)*8+dstPos >= 32}   \n      */\n      *            conversion\n      * @param dstInit initial value of the destination short\n      * @param dstPos the position of the lsb, in bits, in the result short\n-     * @param nBytes the number of byte to convert\n+     * @param nBytes the number of bytes to convert\n      * @return a short containing the selected bits\n      * @throws IllegalArgumentException if {@code (nBytes-1)*8+dstPos >= 16}   \n      */\n      *            conversion\n      * @param dstInit initial value of the destination long\n      * @param dstPos the position of the lsb, in bits, in the result long\n-     * @param nHexs the number of Char to convert\n+     * @param nHexs the number of Chars to convert\n      * @return a long containing the selected bits\n      * @throws IllegalArgumentException if {@code (nHexs-1)*4+dstPos >= 64}   \n      */\n      *            conversion\n      * @param dstInit initial value of the destination int\n      * @param dstPos the position of the lsb, in bits, in the result int\n-     * @param nHexs the number of Char to convert\n+     * @param nHexs the number of Chars to convert\n      * @return a int containing the selected bits\n      * @throws IllegalArgumentException if {@code (nHexs-1)*4+dstPos >= 32}   \n      */\n      *            conversion\n      * @param dstInit initial value of the destination short\n      * @param dstPos the position of the lsb, in bits, in the result short\n-     * @param nHexs the number of Char to convert\n+     * @param nHexs the number of Chars to convert\n      * @return a short containing the selected bits\n      * @throws IllegalArgumentException if {@code (nHexs-1)*4+dstPos >= 16}   \n      */\n      *            conversion\n      * @param dstInit initial value of the destination byte\n      * @param dstPos the position of the lsb, in bits, in the result byte\n-     * @param nHexs the number of Char to convert\n+     * @param nHexs the number of Chars to convert\n      * @return a byte containing the selected bits\n      * @throws IllegalArgumentException if {@code (nHexs-1)*4+dstPos >= 8}   \n      */\n      *            conversion\n      * @param dstInit initial value of the destination long\n      * @param dstPos the position of the lsb, in bits, in the result long\n-     * @param nBools the number of boolean to convert\n+     * @param nBools the number of booleans to convert\n      * @return a long containing the selected bits\n      * @throws IllegalArgumentException if {@code nBools-1+dstPos >= 64}   \n      */\n      *            conversion\n      * @param dstInit initial value of the destination int\n      * @param dstPos the position of the lsb, in bits, in the result int\n-     * @param nBools the number of boolean to convert\n+     * @param nBools the number of booleans to convert\n      * @return a int containing the selected bits\n      * @throws IllegalArgumentException if {@code nBools-1+dstPos >= 32}   \n      */\n      *            conversion\n      * @param dstInit initial value of the destination short\n      * @param dstPos the position of the lsb, in bits, in the result short\n-     * @param nBools the number of boolean to convert\n+     * @param nBools the number of booleans to convert\n      * @return a short containing the selected bits\n      * @throws IllegalArgumentException if {@code nBools-1+dstPos >= 16}   \n      */\n      *            conversion\n      * @param dstInit initial value of the destination byte\n      * @param dstPos the position of the lsb, in bits, in the result byte\n-     * @param nBools the number of boolean to convert\n+     * @param nBools the number of booleans to convert\n      * @return a byte containing the selected bits\n      * @throws IllegalArgumentException if {@code nBools-1+dstPos >= 8}   \n      */\n      *            conversion\n      * @param dst the destination array\n      * @param dstPos the position in {@code dst} where to copy the result\n-     * @param nInts the number of int to copy to {@code dst}, must be smaller or equal to\n+     * @param nInts the number of ints to copy to {@code dst}, must be smaller or equal to\n      *            the width of the input (from srcPos to msb)\n      * @return {@code dst}\n      * @throws IllegalArgumentException if {@code (nInts-1)*32+srcPos >= 64}   \n      *            conversion\n      * @param dst the destination array\n      * @param dstPos the position in {@code dst} where to copy the result\n-     * @param nShorts the number of short to copy to {@code dst}, must be smaller or equal\n+     * @param nShorts the number of shorts to copy to {@code dst}, must be smaller or equal\n      *            to the width of the input (from srcPos to msb)\n      * @return {@code dst}\n      * @throws IllegalArgumentException if {@code (nShorts-1)*16+srcPos >= 64}   \n      *            conversion\n      * @param dst the destination array\n      * @param dstPos the position in {@code dst} where to copy the result\n-     * @param nShorts the number of short to copy to {@code dst}, must be smaller or equal\n+     * @param nShorts the number of shorts to copy to {@code dst}, must be smaller or equal\n      *            to the width of the input (from srcPos to msb)\n      * @return {@code dst}\n      * @throws IllegalArgumentException if {@code (nShorts-1)*16+srcPos >= 32}   \n      *            conversion\n      * @param dst the destination array\n      * @param dstPos the position in {@code dst} where to copy the result\n-     * @param nBytes the number of byte to copy to {@code dst}, must be smaller or equal to\n+     * @param nBytes the number of bytes to copy to {@code dst}, must be smaller or equal to\n      *            the width of the input (from srcPos to msb)\n      * @return {@code dst}\n      * @throws IllegalArgumentException if {@code (nBytes-1)*8+srcPos >= 64}   \n      *            conversion\n      * @param dst the destination array\n      * @param dstPos the position in {@code dst} where to copy the result\n-     * @param nBytes the number of byte to copy to {@code dst}, must be smaller or equal to\n+     * @param nBytes the number of bytes to copy to {@code dst}, must be smaller or equal to\n      *            the width of the input (from srcPos to msb)\n      * @return {@code dst}\n      * @throws IllegalArgumentException if {@code (nBytes-1)*8+srcPos >= 32}   \n      *            conversion\n      * @param dst the destination array\n      * @param dstPos the position in {@code dst} where to copy the result\n-     * @param nBytes the number of byte to copy to {@code dst}, must be smaller or equal to\n+     * @param nBytes the number of bytes to copy to {@code dst}, must be smaller or equal to\n      *            the width of the input (from srcPos to msb)\n      * @return {@code dst}\n      * @throws IllegalArgumentException if {@code (nBytes-1)*8+srcPos >= 16}   \n      *            conversion\n      * @param dstInit the initial value for the result String\n      * @param dstPos the position in {@code dst} where to copy the result\n-     * @param nHexs the number of Char to copy to {@code dst}, must be smaller or equal to\n+     * @param nHexs the number of Chars to copy to {@code dst}, must be smaller or equal to\n      *            the width of the input (from srcPos to msb)\n      * @return {@code dst}\n      * @throws IllegalArgumentException if {@code (nHexs-1)*4+srcPos >= 64}   \n      *            conversion\n      * @param dstInit the initial value for the result String\n      * @param dstPos the position in {@code dst} where to copy the result\n-     * @param nHexs the number of Char to copy to {@code dst}, must be smaller or equal to\n+     * @param nHexs the number of Chars to copy to {@code dst}, must be smaller or equal to\n      *            the width of the input (from srcPos to msb)\n      * @return {@code dst}\n      * @throws IllegalArgumentException if {@code (nHexs-1)*4+srcPos >= 32}   \n      *            conversion\n      * @param dstInit the initial value for the result String\n      * @param dstPos the position in {@code dst} where to copy the result\n-     * @param nHexs the number of Char to copy to {@code dst}, must be smaller or equal to\n+     * @param nHexs the number of Chars to copy to {@code dst}, must be smaller or equal to\n      *            the width of the input (from srcPos to msb)\n      * @return {@code dst}\n      * @throws IllegalArgumentException if {@code (nHexs-1)*4+srcPos >= 16}   \n      *            conversion\n      * @param dstInit the initial value for the result String\n      * @param dstPos the position in {@code dst} where to copy the result\n-     * @param nHexs the number of Char to copy to {@code dst}, must be smaller or equal to\n+     * @param nHexs the number of Chars to copy to {@code dst}, must be smaller or equal to\n      *            the width of the input (from srcPos to msb)\n      * @return {@code dst}\n      * @throws IllegalArgumentException if {@code (nHexs-1)*4+srcPos >= 8}   \n      *            conversion\n      * @param dst the destination array\n      * @param dstPos the position in {@code dst} where to copy the result\n-     * @param nBools the number of boolean to copy to {@code dst}, must be smaller or equal\n+     * @param nBools the number of booleans to copy to {@code dst}, must be smaller or equal\n      *            to the width of the input (from srcPos to msb)\n      * @return {@code dst}\n      * @throws IllegalArgumentException if {@code nBools-1+srcPos >= 64}   \n      *            conversion\n      * @param dst the destination array\n      * @param dstPos the position in {@code dst} where to copy the result\n-     * @param nBools the number of boolean to copy to {@code dst}, must be smaller or equal\n+     * @param nBools the number of booleans to copy to {@code dst}, must be smaller or equal\n      *            to the width of the input (from srcPos to msb)\n      * @return {@code dst}\n      * @throws IllegalArgumentException if {@code nBools-1+srcPos >= 32}   \n      *            conversion\n      * @param dst the destination array\n      * @param dstPos the position in {@code dst} where to copy the result\n-     * @param nBools the number of boolean to copy to {@code dst}, must be smaller or equal\n+     * @param nBools the number of booleans to copy to {@code dst}, must be smaller or equal\n      *            to the width of the input (from srcPos to msb)\n      * @return {@code dst}\n      * @throws IllegalArgumentException if {@code nBools-1+srcPos >= 16}   \n      *            conversion\n      * @param dst the destination array\n      * @param dstPos the position in {@code dst} where to copy the result\n-     * @param nBools the number of boolean to copy to {@code dst}, must be smaller or equal\n+     * @param nBools the number of booleans to copy to {@code dst}, must be smaller or equal\n      *            to the width of the input (from srcPos to msb)\n      * @return {@code dst}\n      * @throws IllegalArgumentException if {@code nBools-1+srcPos >= 8}   \n         }\n         return dst;\n     }\n+\n+    /**\n+     * <p>\n+     * Converts UUID into an array of byte using the default (little endian, Lsb0) byte and\n+     * bit ordering.\n+     * </p>\n+     * \n+     * @param src the UUID to convert\n+     * @param dst the destination array\n+     * @param dstPos the position in {@code dst} where to copy the result\n+     * @param nBytes the number of bytes to copy to {@code dst}, must be smaller or equal to\n+     *            the width of the input (from srcPos to msb)\n+     * @return {@code dst}\n+     * @throws IllegalArgumentException if {@code nBytes > 16}   \n+     */\n+    public static byte[] uuidToBytes(UUID src, byte[] dst, int dstPos, int nBytes) {\n+        if (0 == nBytes)\n+            return dst;\n+        if (nBytes > 16 )\n+            throw new IllegalArgumentException(\"nBytes is greather than 16\");\n+        longToBytes(src.getMostSignificantBits(), 0, dst, dstPos, nBytes > 8 ? 8 : nBytes);\n+        if (nBytes >= 8)\n+            longToBytes(src.getLeastSignificantBits(), 0, dst, dstPos+8, nBytes-8);\n+        return dst;\n+    }\n+\n+    /**\n+     * <p>\n+     * Converts bytes fomr an array into a UUID using the default (little endian, Lsb0) byte and\n+     * bit ordering.\n+     * </p>\n+     * \n+     * @param src the source byte array\n+     * @param srcPos the position in {@code src} where to copy the result from\n+     * @return a UUID\n+     * @throws IllegalArgumentException if array does not contain at least 16 bytes beginning with {@code srcPos}   \n+     */\n+    public static UUID bytesToUuid(byte[] src, int srcPos) {\n+        if (src.length-srcPos < 16 )\n+            throw new IllegalArgumentException(\"Need at least 16 bytes for UUID\");\n+        return new UUID(bytesToLong(src, srcPos, 0, 0, 8), bytesToLong(src, srcPos+8, 0, 0, 8));\n+    }\n }\n--- a/src/test/java/org/apache/commons/lang3/ConversionTest.java\n+++ b/src/test/java/org/apache/commons/lang3/ConversionTest.java\n import static org.junit.Assert.assertEquals;\n import static org.junit.Assert.assertArrayEquals;\n import static org.junit.Assert.fail;\n+\n+import java.util.UUID;\n \n import org.junit.Test;\n \n         assertEquals('e', Conversion.boolsToHexDigit(new boolean[]{false, true, true, true}));\n         assertEquals('f', Conversion.boolsToHexDigit(new boolean[]{true, true, true, true}));\n         assertEquals('1', Conversion.boolsToHexDigit(new boolean[]{true}));\n-        assertEquals('f', Conversion.boolsToHexDigit(new boolean[]{true, true, true, true, true}));\n+        assertEquals(\n+            'f', Conversion.boolsToHexDigit(new boolean[]{true, true, true, true, true}));\n         try {\n             Conversion.boolsToHexDigit(new boolean[]{});\n             fail(\"Thrown \" + IllegalArgumentException.class.getName() + \" expected\");\n             false, false, false, true, false, true, false, false, true, false, false, false,\n             false}, Conversion.byteToBools((byte)0x95, 2, new boolean[13], 3, 6));\n     }\n+\n+    /**\n+     * Tests {@link Conversion#uuidToBytes(UUID, byte[], int, int)}.\n+     */\n+    @Test\n+    public void testUuidToBytes() {\n+        assertArrayEquals(new byte[]{\n+            (byte)0xff, (byte)0xff, (byte)0xff, (byte)0xff, (byte)0xff, (byte)0xff, (byte)0xff,\n+            (byte)0xff, (byte)0xff, (byte)0xff, (byte)0xff, (byte)0xff, (byte)0xff, (byte)0xff,\n+            (byte)0xff, (byte)0xff}, Conversion.uuidToBytes(new UUID(\n+            0xFFFFFFFFFFFFFFFFL, 0xFFFFFFFFFFFFFFFFL), new byte[16], 0, 16));\n+        assertArrayEquals(new byte[]{\n+            (byte)0x88, (byte)0x99, (byte)0xaa, (byte)0xbb, (byte)0xcc, (byte)0xdd, (byte)0xee,\n+            (byte)0xff, (byte)0x00, (byte)0x11, (byte)0x22, (byte)0x33, (byte)0x44, (byte)0x55,\n+            (byte)0x66, (byte)0x77}, Conversion.uuidToBytes(new UUID(\n+            0xFFEEDDCCBBAA9988L, 0x7766554433221100L), new byte[16], 0, 16));\n+        assertArrayEquals(new byte[]{\n+            (byte)0x00, (byte)0x00, (byte)0x00, (byte)0x00, (byte)0x88, (byte)0x99, (byte)0xaa,\n+            (byte)0xbb, (byte)0xcc, (byte)0xdd, (byte)0xee, (byte)0xff, (byte)0x00, (byte)0x00,\n+            (byte)0x00, (byte)0x00}, Conversion.uuidToBytes(new UUID(\n+            0xFFEEDDCCBBAA9988L, 0x7766554433221100L), new byte[16], 4, 8));\n+        assertArrayEquals(new byte[]{\n+            (byte)0x00, (byte)0x00, (byte)0x88, (byte)0x99, (byte)0xaa, (byte)0xbb, (byte)0xcc,\n+            (byte)0xdd, (byte)0xee, (byte)0xff, (byte)0x00, (byte)0x11, (byte)0x22, (byte)0x33,\n+            (byte)0x00, (byte)0x00}, Conversion.uuidToBytes(new UUID(\n+            0xFFEEDDCCBBAA9988L, 0x7766554433221100L), new byte[16], 2, 12));\n+    }\n+\n+    /**\n+     * Tests {@link Conversion#bytesToUuid(byte[], int)}.\n+     */\n+    @Test\n+    public void testBytesToUuid() {\n+        assertEquals(\n+            new UUID(0xFFFFFFFFFFFFFFFFL, 0xFFFFFFFFFFFFFFFFL),\n+            Conversion.bytesToUuid(new byte[]{\n+                (byte)0xff, (byte)0xff, (byte)0xff, (byte)0xff, (byte)0xff, (byte)0xff,\n+                (byte)0xff, (byte)0xff, (byte)0xff, (byte)0xff, (byte)0xff, (byte)0xff,\n+                (byte)0xff, (byte)0xff, (byte)0xff, (byte)0xff}, 0));\n+        assertEquals(\n+            new UUID(0xFFEEDDCCBBAA9988L, 0x7766554433221100L),\n+            Conversion.bytesToUuid(new byte[]{\n+                (byte)0x88, (byte)0x99, (byte)0xaa, (byte)0xbb, (byte)0xcc, (byte)0xdd,\n+                (byte)0xee, (byte)0xff, (byte)0x00, (byte)0x11, (byte)0x22, (byte)0x33,\n+                (byte)0x44, (byte)0x55, (byte)0x66, (byte)0x77}, 0));\n+        assertEquals(\n+            new UUID(0xFFEEDDCCBBAA9988L, 0x7766554433221100L),\n+            Conversion.bytesToUuid(new byte[]{\n+                0, 0, (byte)0x88, (byte)0x99, (byte)0xaa, (byte)0xbb, (byte)0xcc, (byte)0xdd,\n+                (byte)0xee, (byte)0xff, (byte)0x00, (byte)0x11, (byte)0x22, (byte)0x33,\n+                (byte)0x44, (byte)0x55, (byte)0x66, (byte)0x77}, 2));\n+    }\n }", "timestamp": 1349283608, "metainfo": ""}