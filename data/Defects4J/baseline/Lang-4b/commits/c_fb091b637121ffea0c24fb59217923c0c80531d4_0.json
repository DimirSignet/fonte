{"sha": "fb091b637121ffea0c24fb59217923c0c80531d4", "log": "[LANG-873] Add FieldUtils getDeclaredFields() to return all the fields defined in the given class and super classes.  ", "commit": "\n--- a/src/main/java/org/apache/commons/lang3/reflect/FieldUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/reflect/FieldUtils.java\n \n import java.lang.reflect.Field;\n import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.List;\n \n import org.apache.commons.lang3.ClassUtils;\n \n /**\n- * Utilities for working with fields by reflection. Adapted and refactored\n- * from the dormant [reflect] Commons sandbox component.\n+ * Utilities for working with fields by reflection. Adapted and refactored from the dormant [reflect] Commons sandbox\n+ * component.\n  * <p>\n- * The ability is provided to break the scoping restrictions coded by the\n- * programmer. This can allow fields to be changed that shouldn't be. This\n- * facility should be used with care.\n- *\n+ * The ability is provided to break the scoping restrictions coded by the programmer. This can allow fields to be\n+ * changed that shouldn't be. This facility should be used with care.\n+ * \n  * @since 2.5\n  * @version $Id$\n  */\n     /**\n      * FieldUtils instances should NOT be constructed in standard programming.\n      * <p>\n-     * This constructor is public to permit tools that require a JavaBean instance\n-     * to operate.\n+     * This constructor is public to permit tools that require a JavaBean instance to operate.\n      */\n     public FieldUtils() {\n         super();\n     }\n \n     /**\n-     * Gets an accessible <code>Field</code> by name respecting scope.\n-     * Superclasses/interfaces will be considered.\n-     *\n-     * @param cls  the class to reflect, must not be null\n-     * @param fieldName  the field name to obtain\n+     * Gets an accessible <code>Field</code> by name respecting scope. Superclasses/interfaces will be considered.\n+     * \n+     * @param cls\n+     *            the class to reflect, must not be null\n+     * @param fieldName\n+     *            the field name to obtain\n      * @return the Field object\n-     * @throws IllegalArgumentException if the class or field name is null\n+     * @throws IllegalArgumentException\n+     *             if the class or field name is null\n      */\n     public static Field getField(final Class<?> cls, final String fieldName) {\n         final Field field = getField(cls, fieldName, false);\n     }\n \n     /**\n-     * Gets an accessible <code>Field</code> by name breaking scope\n-     * if requested. Superclasses/interfaces will be considered.\n-     *\n-     * @param cls  the class to reflect, must not be null\n-     * @param fieldName  the field name to obtain\n-     * @param forceAccess  whether to break scope restrictions using the\n-     *  <code>setAccessible</code> method. <code>False</code> will only\n-     *  match public fields.\n+     * Gets an accessible <code>Field</code> by name breaking scope if requested. Superclasses/interfaces will be\n+     * considered.\n+     * \n+     * @param cls\n+     *            the class to reflect, must not be null\n+     * @param fieldName\n+     *            the field name to obtain\n+     * @param forceAccess\n+     *            whether to break scope restrictions using the <code>setAccessible</code> method. <code>False</code>\n+     *            will only match public fields.\n      * @return the Field object\n-     * @throws IllegalArgumentException if the class or field name is null\n+     * @throws IllegalArgumentException\n+     *             if the class or field name is null\n      */\n     public static Field getField(final Class<?> cls, final String fieldName, final boolean forceAccess) {\n         if (cls == null) {\n         // priority order for lookup:\n         // searchclass private/protected/package/public\n         // superclass protected/package/public\n-        //  private/different package blocks access to further superclasses\n+        // private/different package blocks access to further superclasses\n         // implementedinterface public\n \n         // check up the superclass hierarchy\n             try {\n                 final Field test = ((Class<?>) class1).getField(fieldName);\n                 if (match != null) {\n-                    throw new IllegalArgumentException(\"Reference to field \" + fieldName + \" is ambiguous relative to \" + cls\n-                            + \"; a matching field exists on two or more implemented interfaces.\");\n+                    throw new IllegalArgumentException(\"Reference to field \" + fieldName + \" is ambiguous relative to \" + cls +\n+                            \"; a matching field exists on two or more implemented interfaces.\");\n                 }\n                 match = test;\n             } catch (final NoSuchFieldException ex) { // NOPMD\n     }\n \n     /**\n-     * Gets an accessible <code>Field</code> by name respecting scope.\n-     * Only the specified class will be considered.\n-     *\n-     * @param cls  the class to reflect, must not be null\n-     * @param fieldName  the field name to obtain\n+     * Gets an accessible <code>Field</code> by name respecting scope. Only the specified class will be considered.\n+     * \n+     * @param cls\n+     *            the class to reflect, must not be null\n+     * @param fieldName\n+     *            the field name to obtain\n      * @return the Field object\n-     * @throws IllegalArgumentException if the class or field name is null\n+     * @throws IllegalArgumentException\n+     *             if the class or field name is null\n      */\n     public static Field getDeclaredField(final Class<?> cls, final String fieldName) {\n         return getDeclaredField(cls, fieldName, false);\n     }\n \n     /**\n-     * Gets an accessible <code>Field</code> by name breaking scope\n-     * if requested. Only the specified class will be considered.\n-     *\n-     * @param cls  the class to reflect, must not be null\n-     * @param fieldName  the field name to obtain\n-     * @param forceAccess  whether to break scope restrictions using the\n-     *  <code>setAccessible</code> method. False will only match public fields.\n+     * Gets an accessible <code>Field</code> by name breaking scope if requested. Only the specified class will be\n+     * considered.\n+     * \n+     * @param cls\n+     *            the class to reflect, must not be null\n+     * @param fieldName\n+     *            the field name to obtain\n+     * @param forceAccess\n+     *            whether to break scope restrictions using the <code>setAccessible</code> method. False will only\n+     *            match public fields.\n      * @return the Field object\n-     * @throws IllegalArgumentException if the class or field name is null\n+     * @throws IllegalArgumentException\n+     *             if the class or field name is null\n      */\n     public static Field getDeclaredField(final Class<?> cls, final String fieldName, final boolean forceAccess) {\n         if (cls == null) {\n     }\n \n     /**\n+     * Gets all declared fields of the given class and its parents (if any).\n+     * \n+     * @param cls\n+     *            the class to query\n+     * @return an array of Fields (maybe an empty array).\n+     * @since 3.2\n+     */\n+    public static Field[] getDeclaredFields(Class<?> cls) {\n+        if (cls == null) {\n+            throw new IllegalArgumentException(\"The class must not be null\");\n+        }\n+        List<Field[]> fieldArrayList = new ArrayList<Field[]>();\n+        int fieldCount = 0;\n+        Class<?> queryClass = cls;\n+        while (queryClass != null) {\n+            final Field[] declaredFields = queryClass.getDeclaredFields();\n+            fieldCount += declaredFields.length;\n+            fieldArrayList.add(declaredFields);\n+            queryClass = queryClass.getSuperclass();\n+        }\n+        Field fields[] = new Field[fieldCount];\n+        int fieldIndex = 0;\n+        for (Field[] fieldArray : fieldArrayList) {\n+            for (Field field : fieldArray) {\n+                fields[fieldIndex++] = field;\n+            }\n+        }\n+        return fields;\n+    }\n+\n+    /**\n      * Reads an accessible static Field.\n-     * @param field to read\n+     * \n+     * @param field\n+     *            to read\n      * @return the field value\n-     * @throws IllegalArgumentException if the field is null or not static\n-     * @throws IllegalAccessException if the field is not accessible\n+     * @throws IllegalArgumentException\n+     *             if the field is null or not static\n+     * @throws IllegalAccessException\n+     *             if the field is not accessible\n      */\n     public static Object readStaticField(final Field field) throws IllegalAccessException {\n         return readStaticField(field, false);\n \n     /**\n      * Reads a static Field.\n-     * @param field to read\n-     * @param forceAccess  whether to break scope restrictions using the\n-     *  <code>setAccessible</code> method.\n+     * \n+     * @param field\n+     *            to read\n+     * @param forceAccess\n+     *            whether to break scope restrictions using the <code>setAccessible</code> method.\n      * @return the field value\n-     * @throws IllegalArgumentException if the field is null or not static\n-     * @throws IllegalAccessException if the field is not made accessible\n+     * @throws IllegalArgumentException\n+     *             if the field is null or not static\n+     * @throws IllegalAccessException\n+     *             if the field is not made accessible\n      */\n     public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException {\n         if (field == null) {\n \n     /**\n      * Reads the named public static field. Superclasses will be considered.\n-     * @param cls  the class to reflect, must not be null\n-     * @param fieldName  the field name to obtain\n+     * \n+     * @param cls\n+     *            the class to reflect, must not be null\n+     * @param fieldName\n+     *            the field name to obtain\n      * @return the value of the field\n-     * @throws IllegalArgumentException if the class is null, the field name is null or if the field could not be found\n-     * @throws IllegalAccessException if the field is not accessible\n+     * @throws IllegalArgumentException\n+     *             if the class is null, the field name is null or if the field could not be found\n+     * @throws IllegalAccessException\n+     *             if the field is not accessible\n      */\n     public static Object readStaticField(final Class<?> cls, final String fieldName) throws IllegalAccessException {\n         return readStaticField(cls, fieldName, false);\n \n     /**\n      * Reads the named static field. Superclasses will be considered.\n-     * @param cls  the class to reflect, must not be null\n-     * @param fieldName  the field name to obtain\n-     * @param forceAccess  whether to break scope restrictions using the\n-     *  <code>setAccessible</code> method. <code>False</code> will only\n-     *  match public fields.\n+     * \n+     * @param cls\n+     *            the class to reflect, must not be null\n+     * @param fieldName\n+     *            the field name to obtain\n+     * @param forceAccess\n+     *            whether to break scope restrictions using the <code>setAccessible</code> method. <code>False</code>\n+     *            will only match public fields.\n      * @return the Field object\n-     * @throws IllegalArgumentException if the class is null, the field name is null or if the field could not be found\n-     * @throws IllegalAccessException if the field is not made accessible\n-     */\n-    public static Object readStaticField(final Class<?> cls, final String fieldName, final boolean forceAccess)\n-        throws IllegalAccessException {\n+     * @throws IllegalArgumentException\n+     *             if the class is null, the field name is null or if the field could not be found\n+     * @throws IllegalAccessException\n+     *             if the field is not made accessible\n+     */\n+    public static Object readStaticField(final Class<?> cls, final String fieldName, final boolean forceAccess) throws IllegalAccessException {\n         final Field field = getField(cls, fieldName, forceAccess);\n         if (field == null) {\n             throw new IllegalArgumentException(\"Cannot locate field \" + fieldName + \" on \" + cls);\n         }\n-        //already forced access above, don't repeat it here:\n+        // already forced access above, don't repeat it here:\n         return readStaticField(field, false);\n     }\n \n     /**\n-     * Gets a static Field value by name. The field must be public.\n-     * Only the specified class will be considered.\n-     *\n-     * @param cls  the class to reflect, must not be null\n-     * @param fieldName  the field name to obtain\n+     * Gets a static Field value by name. The field must be public. Only the specified class will be considered.\n+     * \n+     * @param cls\n+     *            the class to reflect, must not be null\n+     * @param fieldName\n+     *            the field name to obtain\n      * @return the value of the field\n-     * @throws IllegalArgumentException if the class is null, the field name is null or if the field could not be found\n-     * @throws IllegalAccessException if the field is not accessible\n+     * @throws IllegalArgumentException\n+     *             if the class is null, the field name is null or if the field could not be found\n+     * @throws IllegalAccessException\n+     *             if the field is not accessible\n      */\n     public static Object readDeclaredStaticField(final Class<?> cls, final String fieldName) throws IllegalAccessException {\n         return readDeclaredStaticField(cls, fieldName, false);\n     }\n \n     /**\n-     * Gets a static Field value by name. Only the specified class will\n-     * be considered.\n-     *\n-     * @param cls  the class to reflect, must not be null\n-     * @param fieldName  the field name to obtain\n-     * @param forceAccess  whether to break scope restrictions using the\n-     *  <code>setAccessible</code> method. <code>False</code> will only\n-     *  match public fields.\n+     * Gets a static Field value by name. Only the specified class will be considered.\n+     * \n+     * @param cls\n+     *            the class to reflect, must not be null\n+     * @param fieldName\n+     *            the field name to obtain\n+     * @param forceAccess\n+     *            whether to break scope restrictions using the <code>setAccessible</code> method. <code>False</code>\n+     *            will only match public fields.\n      * @return the Field object\n-     * @throws IllegalArgumentException if the class is null, the field name is null or if the field could not be found\n-     * @throws IllegalAccessException if the field is not made accessible\n-     */\n-    public static Object readDeclaredStaticField(final Class<?> cls, final String fieldName, final boolean forceAccess)\n-            throws IllegalAccessException {\n+     * @throws IllegalArgumentException\n+     *             if the class is null, the field name is null or if the field could not be found\n+     * @throws IllegalAccessException\n+     *             if the field is not made accessible\n+     */\n+    public static Object readDeclaredStaticField(final Class<?> cls, final String fieldName, final boolean forceAccess) throws IllegalAccessException {\n         final Field field = getDeclaredField(cls, fieldName, forceAccess);\n         if (field == null) {\n             throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n         }\n-        //already forced access above, don't repeat it here:\n+        // already forced access above, don't repeat it here:\n         return readStaticField(field, false);\n     }\n \n     /**\n      * Reads an accessible Field.\n-     * @param field  the field to use\n-     * @param target  the object to call on, may be null for static fields\n+     * \n+     * @param field\n+     *            the field to use\n+     * @param target\n+     *            the object to call on, may be null for static fields\n      * @return the field value\n-     * @throws IllegalArgumentException if the field is null\n-     * @throws IllegalAccessException if the field is not accessible\n+     * @throws IllegalArgumentException\n+     *             if the field is null\n+     * @throws IllegalAccessException\n+     *             if the field is not accessible\n      */\n     public static Object readField(final Field field, final Object target) throws IllegalAccessException {\n         return readField(field, target, false);\n \n     /**\n      * Reads a Field.\n-     * @param field  the field to use\n-     * @param target  the object to call on, may be null for static fields\n-     * @param forceAccess  whether to break scope restrictions using the\n-     *  <code>setAccessible</code> method.\n+     * \n+     * @param field\n+     *            the field to use\n+     * @param target\n+     *            the object to call on, may be null for static fields\n+     * @param forceAccess\n+     *            whether to break scope restrictions using the <code>setAccessible</code> method.\n      * @return the field value\n-     * @throws IllegalArgumentException if the field is null\n-     * @throws IllegalAccessException if the field is not made accessible\n+     * @throws IllegalArgumentException\n+     *             if the field is null\n+     * @throws IllegalAccessException\n+     *             if the field is not made accessible\n      */\n     public static Object readField(final Field field, final Object target, final boolean forceAccess) throws IllegalAccessException {\n         if (field == null) {\n \n     /**\n      * Reads the named public field. Superclasses will be considered.\n-     * @param target  the object to reflect, must not be null\n-     * @param fieldName  the field name to obtain\n+     * \n+     * @param target\n+     *            the object to reflect, must not be null\n+     * @param fieldName\n+     *            the field name to obtain\n      * @return the value of the field\n-     * @throws IllegalArgumentException if the class or field name is null\n-     * @throws IllegalAccessException if the named field is not public\n+     * @throws IllegalArgumentException\n+     *             if the class or field name is null\n+     * @throws IllegalAccessException\n+     *             if the named field is not public\n      */\n     public static Object readField(final Object target, final String fieldName) throws IllegalAccessException {\n         return readField(target, fieldName, false);\n \n     /**\n      * Reads the named field. Superclasses will be considered.\n-     * @param target  the object to reflect, must not be null\n-     * @param fieldName  the field name to obtain\n-     * @param forceAccess  whether to break scope restrictions using the\n-     *  <code>setAccessible</code> method. <code>False</code> will only\n-     *  match public fields.\n+     * \n+     * @param target\n+     *            the object to reflect, must not be null\n+     * @param fieldName\n+     *            the field name to obtain\n+     * @param forceAccess\n+     *            whether to break scope restrictions using the <code>setAccessible</code> method. <code>False</code>\n+     *            will only match public fields.\n      * @return the field value\n-     * @throws IllegalArgumentException if the class or field name is null\n-     * @throws IllegalAccessException if the named field is not made accessible\n+     * @throws IllegalArgumentException\n+     *             if the class or field name is null\n+     * @throws IllegalAccessException\n+     *             if the named field is not made accessible\n      */\n     public static Object readField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException {\n         if (target == null) {\n         if (field == null) {\n             throw new IllegalArgumentException(\"Cannot locate field \" + fieldName + \" on \" + cls);\n         }\n-        //already forced access above, don't repeat it here:\n+        // already forced access above, don't repeat it here:\n         return readField(field, target);\n     }\n \n     /**\n      * Reads the named public field. Only the class of the specified object will be considered.\n-     * @param target  the object to reflect, must not be null\n-     * @param fieldName  the field name to obtain\n+     * \n+     * @param target\n+     *            the object to reflect, must not be null\n+     * @param fieldName\n+     *            the field name to obtain\n      * @return the value of the field\n-     * @throws IllegalArgumentException if the class or field name is null\n-     * @throws IllegalAccessException if the named field is not public\n+     * @throws IllegalArgumentException\n+     *             if the class or field name is null\n+     * @throws IllegalAccessException\n+     *             if the named field is not public\n      */\n     public static Object readDeclaredField(final Object target, final String fieldName) throws IllegalAccessException {\n         return readDeclaredField(target, fieldName, false);\n     }\n \n     /**\n-     * <p<>Gets a Field value by name. Only the class of the specified\n-     * object will be considered.\n-     *\n-     * @param target  the object to reflect, must not be null\n-     * @param fieldName  the field name to obtain\n-     * @param forceAccess  whether to break scope restrictions using the\n-     *  <code>setAccessible</code> method. <code>False</code> will only\n-     *  match public fields.\n+     * <p<>Gets a Field value by name. Only the class of the specified object will be considered.\n+     * \n+     * @param target\n+     *            the object to reflect, must not be null\n+     * @param fieldName\n+     *            the field name to obtain\n+     * @param forceAccess\n+     *            whether to break scope restrictions using the <code>setAccessible</code> method. <code>False</code>\n+     *            will only match public fields.\n      * @return the Field object\n-     * @throws IllegalArgumentException if <code>target</code> or <code>fieldName</code> is null\n-     * @throws IllegalAccessException if the field is not made accessible\n-     */\n-    public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess)\n-        throws IllegalAccessException {\n+     * @throws IllegalArgumentException\n+     *             if <code>target</code> or <code>fieldName</code> is null\n+     * @throws IllegalAccessException\n+     *             if the field is not made accessible\n+     */\n+    public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException {\n         if (target == null) {\n             throw new IllegalArgumentException(\"target object must not be null\");\n         }\n         if (field == null) {\n             throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n         }\n-        //already forced access above, don't repeat it here:\n+        // already forced access above, don't repeat it here:\n         return readField(field, target);\n     }\n \n     /**\n      * Writes a public static Field.\n-     * @param field to write\n-     * @param value to set\n-     * @throws IllegalArgumentException if the field is null or not static\n-     * @throws IllegalAccessException if the field is not public or is final\n+     * \n+     * @param field\n+     *            to write\n+     * @param value\n+     *            to set\n+     * @throws IllegalArgumentException\n+     *             if the field is null or not static\n+     * @throws IllegalAccessException\n+     *             if the field is not public or is final\n      */\n     public static void writeStaticField(final Field field, final Object value) throws IllegalAccessException {\n         writeStaticField(field, value, false);\n \n     /**\n      * Writes a static Field.\n-     * @param field to write\n-     * @param value to set\n-     * @param forceAccess  whether to break scope restrictions using the\n-     *  <code>setAccessible</code> method. <code>False</code> will only\n-     *  match public fields.\n-     * @throws IllegalArgumentException if the field is null or not static\n-     * @throws IllegalAccessException if the field is not made accessible or is final\n+     * \n+     * @param field\n+     *            to write\n+     * @param value\n+     *            to set\n+     * @param forceAccess\n+     *            whether to break scope restrictions using the <code>setAccessible</code> method. <code>False</code>\n+     *            will only match public fields.\n+     * @throws IllegalArgumentException\n+     *             if the field is null or not static\n+     * @throws IllegalAccessException\n+     *             if the field is not made accessible or is final\n      */\n     public static void writeStaticField(final Field field, final Object value, final boolean forceAccess) throws IllegalAccessException {\n         if (field == null) {\n \n     /**\n      * Writes a named public static Field. Superclasses will be considered.\n-     * @param cls Class on which the Field is to be found\n-     * @param fieldName to write\n-     * @param value to set\n-     * @throws IllegalArgumentException if the field cannot be located or is not static\n-     * @throws IllegalAccessException if the field is not public or is final\n+     * \n+     * @param cls\n+     *            Class on which the Field is to be found\n+     * @param fieldName\n+     *            to write\n+     * @param value\n+     *            to set\n+     * @throws IllegalArgumentException\n+     *             if the field cannot be located or is not static\n+     * @throws IllegalAccessException\n+     *             if the field is not public or is final\n      */\n     public static void writeStaticField(final Class<?> cls, final String fieldName, final Object value) throws IllegalAccessException {\n         writeStaticField(cls, fieldName, value, false);\n \n     /**\n      * Writes a named static Field. Superclasses will be considered.\n-     * @param cls Class on which the Field is to be found\n-     * @param fieldName to write\n-     * @param value to set\n-     * @param forceAccess  whether to break scope restrictions using the\n-     *  <code>setAccessible</code> method. <code>False</code> will only\n-     *  match public fields.\n-     * @throws IllegalArgumentException if the field cannot be located or is not static\n-     * @throws IllegalAccessException if the field is not made accessible or is final\n+     * \n+     * @param cls\n+     *            Class on which the Field is to be found\n+     * @param fieldName\n+     *            to write\n+     * @param value\n+     *            to set\n+     * @param forceAccess\n+     *            whether to break scope restrictions using the <code>setAccessible</code> method. <code>False</code>\n+     *            will only match public fields.\n+     * @throws IllegalArgumentException\n+     *             if the field cannot be located or is not static\n+     * @throws IllegalAccessException\n+     *             if the field is not made accessible or is final\n      */\n     public static void writeStaticField(final Class<?> cls, final String fieldName, final Object value, final boolean forceAccess)\n             throws IllegalAccessException {\n         if (field == null) {\n             throw new IllegalArgumentException(\"Cannot locate field \" + fieldName + \" on \" + cls);\n         }\n-        //already forced access above, don't repeat it here:\n+        // already forced access above, don't repeat it here:\n         writeStaticField(field, value);\n     }\n \n     /**\n      * Writes a named public static Field. Only the specified class will be considered.\n-     * @param cls Class on which the Field is to be found\n-     * @param fieldName to write\n-     * @param value to set\n-     * @throws IllegalArgumentException if the field cannot be located or is not static\n-     * @throws IllegalAccessException if the field is not public or is final\n-     */\n-    public static void writeDeclaredStaticField(final Class<?> cls, final String fieldName, final Object value)\n-            throws IllegalAccessException {\n+     * \n+     * @param cls\n+     *            Class on which the Field is to be found\n+     * @param fieldName\n+     *            to write\n+     * @param value\n+     *            to set\n+     * @throws IllegalArgumentException\n+     *             if the field cannot be located or is not static\n+     * @throws IllegalAccessException\n+     *             if the field is not public or is final\n+     */\n+    public static void writeDeclaredStaticField(final Class<?> cls, final String fieldName, final Object value) throws IllegalAccessException {\n         writeDeclaredStaticField(cls, fieldName, value, false);\n     }\n \n     /**\n      * Writes a named static Field. Only the specified class will be considered.\n-     * @param cls Class on which the Field is to be found\n-     * @param fieldName to write\n-     * @param value to set\n-     * @param forceAccess  whether to break scope restrictions using the\n-     *  <code>setAccessible</code> method. <code>False</code> will only\n-     *  match public fields.\n-     * @throws IllegalArgumentException if the field cannot be located or is not static\n-     * @throws IllegalAccessException if the field is not made accessible or is final\n-      */\n+     * \n+     * @param cls\n+     *            Class on which the Field is to be found\n+     * @param fieldName\n+     *            to write\n+     * @param value\n+     *            to set\n+     * @param forceAccess\n+     *            whether to break scope restrictions using the <code>setAccessible</code> method. <code>False</code>\n+     *            will only match public fields.\n+     * @throws IllegalArgumentException\n+     *             if the field cannot be located or is not static\n+     * @throws IllegalAccessException\n+     *             if the field is not made accessible or is final\n+     */\n     public static void writeDeclaredStaticField(final Class<?> cls, final String fieldName, final Object value, final boolean forceAccess)\n             throws IllegalAccessException {\n         final Field field = getDeclaredField(cls, fieldName, forceAccess);\n         if (field == null) {\n             throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n         }\n-        //already forced access above, don't repeat it here:\n+        // already forced access above, don't repeat it here:\n         writeField(field, (Object) null, value);\n     }\n \n     /**\n      * Writes an accessible field.\n-     * @param field to write\n-     * @param target  the object to call on, may be null for static fields\n-     * @param value to set\n-     * @throws IllegalArgumentException if the field is null\n-     * @throws IllegalAccessException if the field is not accessible or is final\n+     * \n+     * @param field\n+     *            to write\n+     * @param target\n+     *            the object to call on, may be null for static fields\n+     * @param value\n+     *            to set\n+     * @throws IllegalArgumentException\n+     *             if the field is null\n+     * @throws IllegalAccessException\n+     *             if the field is not accessible or is final\n      */\n     public static void writeField(final Field field, final Object target, final Object value) throws IllegalAccessException {\n         writeField(field, target, value, false);\n \n     /**\n      * Writes a field.\n-     * @param field to write\n-     * @param target  the object to call on, may be null for static fields\n-     * @param value to set\n-     * @param forceAccess  whether to break scope restrictions using the\n-     *  <code>setAccessible</code> method. <code>False</code> will only\n-     *  match public fields.\n-     * @throws IllegalArgumentException if the field is null\n-     * @throws IllegalAccessException if the field is not made accessible or is final\n+     * \n+     * @param field\n+     *            to write\n+     * @param target\n+     *            the object to call on, may be null for static fields\n+     * @param value\n+     *            to set\n+     * @param forceAccess\n+     *            whether to break scope restrictions using the <code>setAccessible</code> method. <code>False</code>\n+     *            will only match public fields.\n+     * @throws IllegalArgumentException\n+     *             if the field is null\n+     * @throws IllegalAccessException\n+     *             if the field is not made accessible or is final\n      */\n     public static void writeField(final Field field, final Object target, final Object value, final boolean forceAccess)\n-        throws IllegalAccessException {\n+            throws IllegalAccessException {\n         if (field == null) {\n             throw new IllegalArgumentException(\"The field must not be null\");\n         }\n \n     /**\n      * Writes a public field. Superclasses will be considered.\n-     * @param target  the object to reflect, must not be null\n-     * @param fieldName  the field name to obtain\n-     * @param value to set\n-     * @throws IllegalArgumentException if <code>target</code> or <code>fieldName</code> is null\n-     * @throws IllegalAccessException if the field is not accessible\n+     * \n+     * @param target\n+     *            the object to reflect, must not be null\n+     * @param fieldName\n+     *            the field name to obtain\n+     * @param value\n+     *            to set\n+     * @throws IllegalArgumentException\n+     *             if <code>target</code> or <code>fieldName</code> is null\n+     * @throws IllegalAccessException\n+     *             if the field is not accessible\n      */\n     public static void writeField(final Object target, final String fieldName, final Object value) throws IllegalAccessException {\n         writeField(target, fieldName, value, false);\n \n     /**\n      * Writes a field. Superclasses will be considered.\n-     * @param target  the object to reflect, must not be null\n-     * @param fieldName  the field name to obtain\n-     * @param value to set\n-     * @param forceAccess  whether to break scope restrictions using the\n-     *  <code>setAccessible</code> method. <code>False</code> will only\n-     *  match public fields.\n-     * @throws IllegalArgumentException if <code>target</code> or <code>fieldName</code> is null\n-     * @throws IllegalAccessException if the field is not made accessible\n+     * \n+     * @param target\n+     *            the object to reflect, must not be null\n+     * @param fieldName\n+     *            the field name to obtain\n+     * @param value\n+     *            to set\n+     * @param forceAccess\n+     *            whether to break scope restrictions using the <code>setAccessible</code> method. <code>False</code>\n+     *            will only match public fields.\n+     * @throws IllegalArgumentException\n+     *             if <code>target</code> or <code>fieldName</code> is null\n+     * @throws IllegalAccessException\n+     *             if the field is not made accessible\n      */\n     public static void writeField(final Object target, final String fieldName, final Object value, final boolean forceAccess)\n             throws IllegalAccessException {\n         if (field == null) {\n             throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n         }\n-        //already forced access above, don't repeat it here:\n+        // already forced access above, don't repeat it here:\n         writeField(field, target, value);\n     }\n \n     /**\n      * Writes a public field. Only the specified class will be considered.\n-     * @param target  the object to reflect, must not be null\n-     * @param fieldName  the field name to obtain\n-     * @param value to set\n-     * @throws IllegalArgumentException if <code>target</code> or <code>fieldName</code> is null\n-     * @throws IllegalAccessException if the field is not made accessible\n+     * \n+     * @param target\n+     *            the object to reflect, must not be null\n+     * @param fieldName\n+     *            the field name to obtain\n+     * @param value\n+     *            to set\n+     * @throws IllegalArgumentException\n+     *             if <code>target</code> or <code>fieldName</code> is null\n+     * @throws IllegalAccessException\n+     *             if the field is not made accessible\n      */\n     public static void writeDeclaredField(final Object target, final String fieldName, final Object value) throws IllegalAccessException {\n         writeDeclaredField(target, fieldName, value, false);\n \n     /**\n      * Writes a public field. Only the specified class will be considered.\n-     * @param target  the object to reflect, must not be null\n-     * @param fieldName  the field name to obtain\n-     * @param value to set\n-     * @param forceAccess  whether to break scope restrictions using the\n-     *  <code>setAccessible</code> method. <code>False</code> will only\n-     *  match public fields.\n-     * @throws IllegalArgumentException if <code>target</code> or <code>fieldName</code> is null\n-     * @throws IllegalAccessException if the field is not made accessible\n+     * \n+     * @param target\n+     *            the object to reflect, must not be null\n+     * @param fieldName\n+     *            the field name to obtain\n+     * @param value\n+     *            to set\n+     * @param forceAccess\n+     *            whether to break scope restrictions using the <code>setAccessible</code> method. <code>False</code>\n+     *            will only match public fields.\n+     * @throws IllegalArgumentException\n+     *             if <code>target</code> or <code>fieldName</code> is null\n+     * @throws IllegalAccessException\n+     *             if the field is not made accessible\n      */\n     public static void writeDeclaredField(final Object target, final String fieldName, final Object value, final boolean forceAccess)\n             throws IllegalAccessException {\n         if (field == null) {\n             throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n         }\n-        //already forced access above, don't repeat it here:\n+        // already forced access above, don't repeat it here:\n         writeField(field, target, value);\n     }\n }\n--- a/src/test/java/org/apache/commons/lang3/reflect/FieldUtilsTest.java\n+++ b/src/test/java/org/apache/commons/lang3/reflect/FieldUtilsTest.java\n  */\n package org.apache.commons.lang3.reflect;\n \n+import static org.junit.Assert.assertArrayEquals;\n import static org.junit.Assert.assertEquals;\n import static org.junit.Assert.assertFalse;\n import static org.junit.Assert.assertNotNull;\n import java.lang.reflect.Field;\n import java.lang.reflect.Modifier;\n \n+import org.apache.commons.lang3.ArrayUtils;\n import org.apache.commons.lang3.reflect.testbed.Ambig;\n import org.apache.commons.lang3.reflect.testbed.Foo;\n import org.apache.commons.lang3.reflect.testbed.PrivatelyShadowedChild;\n \n /**\n  * Unit tests FieldUtils\n+ * \n  * @version $Id$\n  */\n public class FieldUtilsTest {\n         assertTrue(Modifier.isPublic(FieldUtils.class.getModifiers()));\n         assertFalse(Modifier.isFinal(FieldUtils.class.getModifiers()));\n     }\n-    \n+\n     @Test\n     public void testGetField() {\n         assertEquals(Foo.class, FieldUtils.getField(PublicChild.class, \"VALUE\").getDeclaringClass());\n         assertNull(FieldUtils.getField(PublicChild.class, \"i\"));\n         assertNull(FieldUtils.getField(PublicChild.class, \"d\"));\n         assertEquals(Foo.class, FieldUtils.getField(PubliclyShadowedChild.class, \"VALUE\").getDeclaringClass());\n-        assertEquals(PubliclyShadowedChild.class, FieldUtils.getField(PubliclyShadowedChild.class, \"s\")\n-                .getDeclaringClass());\n-        assertEquals(PubliclyShadowedChild.class, FieldUtils.getField(PubliclyShadowedChild.class, \"b\")\n-                .getDeclaringClass());\n-        assertEquals(PubliclyShadowedChild.class, FieldUtils.getField(PubliclyShadowedChild.class, \"i\")\n-                .getDeclaringClass());\n-        assertEquals(PubliclyShadowedChild.class, FieldUtils.getField(PubliclyShadowedChild.class, \"d\")\n-                .getDeclaringClass());\n+        assertEquals(PubliclyShadowedChild.class, FieldUtils.getField(PubliclyShadowedChild.class, \"s\").getDeclaringClass());\n+        assertEquals(PubliclyShadowedChild.class, FieldUtils.getField(PubliclyShadowedChild.class, \"b\").getDeclaringClass());\n+        assertEquals(PubliclyShadowedChild.class, FieldUtils.getField(PubliclyShadowedChild.class, \"i\").getDeclaringClass());\n+        assertEquals(PubliclyShadowedChild.class, FieldUtils.getField(PubliclyShadowedChild.class, \"d\").getDeclaringClass());\n         assertEquals(Foo.class, FieldUtils.getField(PrivatelyShadowedChild.class, \"VALUE\").getDeclaringClass());\n         assertEquals(parentClass, FieldUtils.getField(PrivatelyShadowedChild.class, \"s\").getDeclaringClass());\n         assertNull(FieldUtils.getField(PrivatelyShadowedChild.class, \"b\"));\n         assertNull(FieldUtils.getField(PrivatelyShadowedChild.class, \"d\"));\n     }\n \n-    @Test(expected=IllegalArgumentException.class)\n+    @Test(expected = IllegalArgumentException.class)\n     public void testGetFieldIllegalArgumentException1() {\n         FieldUtils.getField(null, \"none\");\n     }\n-    \n-    @Test(expected=IllegalArgumentException.class)\n+\n+    @Test(expected = IllegalArgumentException.class)\n     public void testGetFieldIllegalArgumentException2() {\n         FieldUtils.getField(PublicChild.class, null);\n     }\n-    \n+\n     @Test\n     public void testGetFieldForceAccess() {\n         assertEquals(PublicChild.class, FieldUtils.getField(PublicChild.class, \"VALUE\", true).getDeclaringClass());\n         assertEquals(parentClass, FieldUtils.getField(PublicChild.class, \"i\", true).getDeclaringClass());\n         assertEquals(parentClass, FieldUtils.getField(PublicChild.class, \"d\", true).getDeclaringClass());\n         assertEquals(Foo.class, FieldUtils.getField(PubliclyShadowedChild.class, \"VALUE\", true).getDeclaringClass());\n-        assertEquals(PubliclyShadowedChild.class, FieldUtils.getField(PubliclyShadowedChild.class, \"s\", true)\n-                .getDeclaringClass());\n-        assertEquals(PubliclyShadowedChild.class, FieldUtils.getField(PubliclyShadowedChild.class, \"b\", true)\n-                .getDeclaringClass());\n-        assertEquals(PubliclyShadowedChild.class, FieldUtils.getField(PubliclyShadowedChild.class, \"i\", true)\n-                .getDeclaringClass());\n-        assertEquals(PubliclyShadowedChild.class, FieldUtils.getField(PubliclyShadowedChild.class, \"d\", true)\n-                .getDeclaringClass());\n+        assertEquals(PubliclyShadowedChild.class, FieldUtils.getField(PubliclyShadowedChild.class, \"s\", true).getDeclaringClass());\n+        assertEquals(PubliclyShadowedChild.class, FieldUtils.getField(PubliclyShadowedChild.class, \"b\", true).getDeclaringClass());\n+        assertEquals(PubliclyShadowedChild.class, FieldUtils.getField(PubliclyShadowedChild.class, \"i\", true).getDeclaringClass());\n+        assertEquals(PubliclyShadowedChild.class, FieldUtils.getField(PubliclyShadowedChild.class, \"d\", true).getDeclaringClass());\n         assertEquals(Foo.class, FieldUtils.getField(PrivatelyShadowedChild.class, \"VALUE\", true).getDeclaringClass());\n-        assertEquals(PrivatelyShadowedChild.class, FieldUtils.getField(PrivatelyShadowedChild.class, \"s\", true)\n-                .getDeclaringClass());\n-        assertEquals(PrivatelyShadowedChild.class, FieldUtils.getField(PrivatelyShadowedChild.class, \"b\", true)\n-                .getDeclaringClass());\n-        assertEquals(PrivatelyShadowedChild.class, FieldUtils.getField(PrivatelyShadowedChild.class, \"i\", true)\n-                .getDeclaringClass());\n-        assertEquals(PrivatelyShadowedChild.class, FieldUtils.getField(PrivatelyShadowedChild.class, \"d\", true)\n-                .getDeclaringClass());\n-    }\n-\n-    @Test(expected=IllegalArgumentException.class)\n+        assertEquals(PrivatelyShadowedChild.class, FieldUtils.getField(PrivatelyShadowedChild.class, \"s\", true).getDeclaringClass());\n+        assertEquals(PrivatelyShadowedChild.class, FieldUtils.getField(PrivatelyShadowedChild.class, \"b\", true).getDeclaringClass());\n+        assertEquals(PrivatelyShadowedChild.class, FieldUtils.getField(PrivatelyShadowedChild.class, \"i\", true).getDeclaringClass());\n+        assertEquals(PrivatelyShadowedChild.class, FieldUtils.getField(PrivatelyShadowedChild.class, \"d\", true).getDeclaringClass());\n+    }\n+\n+    @Test(expected = IllegalArgumentException.class)\n     public void testGetFieldForceAccessIllegalArgumentException1() {\n         FieldUtils.getField(null, \"none\", true);\n     }\n-    \n-    @Test(expected=IllegalArgumentException.class)\n+\n+    @Test(expected = IllegalArgumentException.class)\n     public void testGetFieldForceAccessIllegalArgumentException2() {\n         FieldUtils.getField(PublicChild.class, null, true);\n-    }    \n+    }\n+\n+    @Test\n+    public void testGetDeclaredFields() {\n+        assertArrayEquals(new Field[0], FieldUtils.getDeclaredFields(Object.class));\n+        final Field[] fieldsNumber = Number.class.getDeclaredFields();\n+        assertArrayEquals(fieldsNumber, FieldUtils.getDeclaredFields(Number.class));\n+        final Field[] fieldsInteger = Integer.class.getDeclaredFields();\n+        assertArrayEquals(ArrayUtils.addAll(fieldsInteger, fieldsNumber), FieldUtils.getDeclaredFields(Integer.class));\n+        assertEquals(5, FieldUtils.getDeclaredFields(PublicChild.class).length);\n+    }\n \n     @Test\n     public void testGetDeclaredField() {\n         assertNull(FieldUtils.getDeclaredField(PublicChild.class, \"i\"));\n         assertNull(FieldUtils.getDeclaredField(PublicChild.class, \"d\"));\n         assertNull(FieldUtils.getDeclaredField(PubliclyShadowedChild.class, \"VALUE\"));\n-        assertEquals(PubliclyShadowedChild.class, FieldUtils.getDeclaredField(PubliclyShadowedChild.class, \"s\")\n-                .getDeclaringClass());\n-        assertEquals(PubliclyShadowedChild.class, FieldUtils.getDeclaredField(PubliclyShadowedChild.class, \"b\")\n-                .getDeclaringClass());\n-        assertEquals(PubliclyShadowedChild.class, FieldUtils.getDeclaredField(PubliclyShadowedChild.class, \"i\")\n-                .getDeclaringClass());\n-        assertEquals(PubliclyShadowedChild.class, FieldUtils.getDeclaredField(PubliclyShadowedChild.class, \"d\")\n-                .getDeclaringClass());\n+        assertEquals(PubliclyShadowedChild.class, FieldUtils.getDeclaredField(PubliclyShadowedChild.class, \"s\").getDeclaringClass());\n+        assertEquals(PubliclyShadowedChild.class, FieldUtils.getDeclaredField(PubliclyShadowedChild.class, \"b\").getDeclaringClass());\n+        assertEquals(PubliclyShadowedChild.class, FieldUtils.getDeclaredField(PubliclyShadowedChild.class, \"i\").getDeclaringClass());\n+        assertEquals(PubliclyShadowedChild.class, FieldUtils.getDeclaredField(PubliclyShadowedChild.class, \"d\").getDeclaringClass());\n         assertNull(FieldUtils.getDeclaredField(PrivatelyShadowedChild.class, \"VALUE\"));\n         assertNull(FieldUtils.getDeclaredField(PrivatelyShadowedChild.class, \"s\"));\n         assertNull(FieldUtils.getDeclaredField(PrivatelyShadowedChild.class, \"b\"));\n         assertNull(FieldUtils.getDeclaredField(PrivatelyShadowedChild.class, \"d\"));\n     }\n \n-    @Test(expected=IllegalArgumentException.class)\n+    @Test(expected = IllegalArgumentException.class)\n     public void testGetDeclaredFieldAccessIllegalArgumentException1() {\n         FieldUtils.getDeclaredField(null, \"none\");\n-    }    \n-\n-    @Test(expected=IllegalArgumentException.class)\n+    }\n+\n+    @Test(expected = IllegalArgumentException.class)\n     public void testGetDeclaredFieldAccessIllegalArgumentException2() {\n         FieldUtils.getDeclaredField(PublicChild.class, null);\n-    }    \n+    }\n \n     @Test\n     public void testGetDeclaredFieldForceAccess() {\n-        assertEquals(PublicChild.class, FieldUtils.getDeclaredField(PublicChild.class, \"VALUE\", true)\n-                .getDeclaringClass());\n+        assertEquals(PublicChild.class, FieldUtils.getDeclaredField(PublicChild.class, \"VALUE\", true).getDeclaringClass());\n         assertNull(FieldUtils.getDeclaredField(PublicChild.class, \"s\", true));\n         assertNull(FieldUtils.getDeclaredField(PublicChild.class, \"b\", true));\n         assertNull(FieldUtils.getDeclaredField(PublicChild.class, \"i\", true));\n         assertNull(FieldUtils.getDeclaredField(PublicChild.class, \"d\", true));\n         assertNull(FieldUtils.getDeclaredField(PubliclyShadowedChild.class, \"VALUE\", true));\n-        assertEquals(PubliclyShadowedChild.class, FieldUtils.getDeclaredField(PubliclyShadowedChild.class, \"s\", true)\n-                .getDeclaringClass());\n-        assertEquals(PubliclyShadowedChild.class, FieldUtils.getDeclaredField(PubliclyShadowedChild.class, \"b\", true)\n-                .getDeclaringClass());\n-        assertEquals(PubliclyShadowedChild.class, FieldUtils.getDeclaredField(PubliclyShadowedChild.class, \"i\", true)\n-                .getDeclaringClass());\n-        assertEquals(PubliclyShadowedChild.class, FieldUtils.getDeclaredField(PubliclyShadowedChild.class, \"d\", true)\n-                .getDeclaringClass());\n+        assertEquals(PubliclyShadowedChild.class, FieldUtils.getDeclaredField(PubliclyShadowedChild.class, \"s\", true).getDeclaringClass());\n+        assertEquals(PubliclyShadowedChild.class, FieldUtils.getDeclaredField(PubliclyShadowedChild.class, \"b\", true).getDeclaringClass());\n+        assertEquals(PubliclyShadowedChild.class, FieldUtils.getDeclaredField(PubliclyShadowedChild.class, \"i\", true).getDeclaringClass());\n+        assertEquals(PubliclyShadowedChild.class, FieldUtils.getDeclaredField(PubliclyShadowedChild.class, \"d\", true).getDeclaringClass());\n         assertNull(FieldUtils.getDeclaredField(PrivatelyShadowedChild.class, \"VALUE\", true));\n-        assertEquals(PrivatelyShadowedChild.class, FieldUtils.getDeclaredField(PrivatelyShadowedChild.class, \"s\", true)\n-                .getDeclaringClass());\n-        assertEquals(PrivatelyShadowedChild.class, FieldUtils.getDeclaredField(PrivatelyShadowedChild.class, \"b\", true)\n-                .getDeclaringClass());\n-        assertEquals(PrivatelyShadowedChild.class, FieldUtils.getDeclaredField(PrivatelyShadowedChild.class, \"i\", true)\n-                .getDeclaringClass());\n-        assertEquals(PrivatelyShadowedChild.class, FieldUtils.getDeclaredField(PrivatelyShadowedChild.class, \"d\", true)\n-                .getDeclaringClass());\n-    }\n-\n-    @Test(expected=IllegalArgumentException.class)\n+        assertEquals(PrivatelyShadowedChild.class, FieldUtils.getDeclaredField(PrivatelyShadowedChild.class, \"s\", true).getDeclaringClass());\n+        assertEquals(PrivatelyShadowedChild.class, FieldUtils.getDeclaredField(PrivatelyShadowedChild.class, \"b\", true).getDeclaringClass());\n+        assertEquals(PrivatelyShadowedChild.class, FieldUtils.getDeclaredField(PrivatelyShadowedChild.class, \"i\", true).getDeclaringClass());\n+        assertEquals(PrivatelyShadowedChild.class, FieldUtils.getDeclaredField(PrivatelyShadowedChild.class, \"d\", true).getDeclaringClass());\n+    }\n+\n+    @Test(expected = IllegalArgumentException.class)\n     public void testGetDeclaredFieldForceAccessIllegalArgumentException1() {\n         FieldUtils.getDeclaredField(null, \"none\", true);\n-    }    \n-\n-    @Test(expected=IllegalArgumentException.class)\n+    }\n+\n+    @Test(expected = IllegalArgumentException.class)\n     public void testGetDeclaredFieldForceAccessIllegalArgumentException2() {\n         FieldUtils.getDeclaredField(PublicChild.class, null, true);\n-    }    \n+    }\n \n     @Test\n     public void testReadStaticField() throws Exception {\n         assertEquals(Foo.VALUE, FieldUtils.readStaticField(FieldUtils.getField(Foo.class, \"VALUE\")));\n     }\n \n-    @Test(expected=IllegalArgumentException.class)\n+    @Test(expected = IllegalArgumentException.class)\n     public void testReadStaticFieldIllegalArgumentException1() throws Exception {\n-         FieldUtils.readStaticField(null);\n-    }\n-\n-    @Test(expected=IllegalArgumentException.class)\n+        FieldUtils.readStaticField(null);\n+    }\n+\n+    @Test(expected = IllegalArgumentException.class)\n     public void testReadStaticFieldIllegalArgumentException2() throws Exception {\n         assertEquals(Foo.VALUE, FieldUtils.readStaticField(FieldUtils.getField(Foo.class, \"VALUE\")));\n         final Field nonStaticField = FieldUtils.getField(PublicChild.class, \"s\");\n         assertEquals(Foo.VALUE, FieldUtils.readStaticField(FieldUtils.getField(PublicChild.class, \"VALUE\")));\n     }\n \n-    @Test(expected=IllegalArgumentException.class)\n+    @Test(expected = IllegalArgumentException.class)\n     public void testReadStaticFieldForceAccessIllegalArgumentException1() throws Exception {\n         FieldUtils.readStaticField(null, true);\n     }\n \n-    @Test(expected=IllegalArgumentException.class)\n+    @Test(expected = IllegalArgumentException.class)\n     public void testReadStaticFieldForceAccessIllegalArgumentException2() throws Exception {\n         final Field nonStaticField = FieldUtils.getField(PublicChild.class, \"s\", true);\n         assumeNotNull(nonStaticField);\n         assertEquals(Foo.VALUE, FieldUtils.readStaticField(PubliclyShadowedChild.class, \"VALUE\"));\n         assertEquals(Foo.VALUE, FieldUtils.readStaticField(PrivatelyShadowedChild.class, \"VALUE\"));\n         assertEquals(Foo.VALUE, FieldUtils.readStaticField(PublicChild.class, \"VALUE\"));\n-        \n+\n         try {\n             FieldUtils.readStaticField(null, \"none\");\n             fail(\"null class should cause an IllegalArgumentException\");\n         } catch (final IllegalArgumentException e) {\n             // expected\n         }\n-        \n+\n         try {\n             FieldUtils.readStaticField(Foo.class, null);\n             fail(\"null field name should cause an IllegalArgumentException\");\n         } catch (final IllegalArgumentException e) {\n             // expected\n         }\n-        \n+\n         try {\n             FieldUtils.readStaticField(Foo.class, \"does_not_exist\");\n             fail(\"a field that doesn't exist should cause an IllegalArgumentException\");\n         } catch (final IllegalArgumentException e) {\n             // expected\n         }\n-        \n+\n         try {\n             FieldUtils.readStaticField(PublicChild.class, \"s\");\n             fail(\"non-static field should cause an IllegalArgumentException\");\n         assertEquals(Foo.VALUE, FieldUtils.readStaticField(PubliclyShadowedChild.class, \"VALUE\", true));\n         assertEquals(Foo.VALUE, FieldUtils.readStaticField(PrivatelyShadowedChild.class, \"VALUE\", true));\n         assertEquals(\"child\", FieldUtils.readStaticField(PublicChild.class, \"VALUE\", true));\n-        \n+\n         try {\n             FieldUtils.readStaticField(null, \"none\", true);\n             fail(\"null class should cause an IllegalArgumentException\");\n         } catch (final IllegalArgumentException e) {\n             // expected\n         }\n-        \n+\n         try {\n             FieldUtils.readStaticField(Foo.class, null, true);\n             fail(\"null field name should cause an IllegalArgumentException\");\n         } catch (final IllegalArgumentException e) {\n             // expected\n         }\n-        \n+\n         try {\n             FieldUtils.readStaticField(Foo.class, \"does_not_exist\", true);\n             fail(\"a field that doesn't exist should cause an IllegalArgumentException\");\n         } catch (final IllegalArgumentException e) {\n             // expected\n         }\n-        \n+\n         try {\n             FieldUtils.readStaticField(PublicChild.class, \"s\", false);\n             fail(\"non-static field should cause an IllegalArgumentException\");\n         assertEquals(D0, FieldUtils.readField(parentD, publicChild));\n         assertEquals(D0, FieldUtils.readField(parentD, publiclyShadowedChild));\n         assertEquals(D0, FieldUtils.readField(parentD, privatelyShadowedChild));\n-        \n-        try {\n-            FieldUtils.readField((Field)null, publicChild);\n+\n+        try {\n+            FieldUtils.readField((Field) null, publicChild);\n             fail(\"a null field should cause an IllegalArgumentException\");\n         } catch (final IllegalArgumentException e) {\n             // expected\n         assertEquals(D0, FieldUtils.readField(parentD, publicChild, true));\n         assertEquals(D0, FieldUtils.readField(parentD, publiclyShadowedChild, true));\n         assertEquals(D0, FieldUtils.readField(parentD, privatelyShadowedChild, true));\n-        \n-        try {\n-            FieldUtils.readField((Field)null, publicChild, true);\n+\n+        try {\n+            FieldUtils.readField((Field) null, publicChild, true);\n             fail(\"a null field should cause an IllegalArgumentException\");\n         } catch (final IllegalArgumentException e) {\n             // expected\n         assertEquals(\"s\", FieldUtils.readField(publicChild, \"s\"));\n         assertEquals(\"ss\", FieldUtils.readField(publiclyShadowedChild, \"s\"));\n         assertEquals(\"s\", FieldUtils.readField(privatelyShadowedChild, \"s\"));\n-        \n+\n         try {\n             FieldUtils.readField(publicChild, null);\n             fail(\"a null field name should cause an IllegalArgumentException\");\n         } catch (final IllegalArgumentException e) {\n             // expected\n         }\n-        \n-        try {\n-            FieldUtils.readField((Object)null, \"none\");\n+\n+        try {\n+            FieldUtils.readField((Object) null, \"none\");\n             fail(\"a null target should cause an IllegalArgumentException\");\n         } catch (final IllegalArgumentException e) {\n             // expected\n         }\n-        \n+\n         try {\n             assertEquals(Boolean.FALSE, FieldUtils.readField(publicChild, \"b\"));\n             fail(\"expected IllegalArgumentException\");\n         assertEquals(D0, FieldUtils.readField(publicChild, \"d\", true));\n         assertEquals(D1, FieldUtils.readField(publiclyShadowedChild, \"d\", true));\n         assertEquals(D1, FieldUtils.readField(privatelyShadowedChild, \"d\", true));\n-        \n+\n         try {\n             FieldUtils.readField(publicChild, null, true);\n             fail(\"a null field name should cause an IllegalArgumentException\");\n         } catch (final IllegalArgumentException e) {\n             // expected\n         }\n-        \n-        try {\n-            FieldUtils.readField((Object)null, \"none\", true);\n+\n+        try {\n+            FieldUtils.readField((Object) null, \"none\", true);\n             fail(\"a null target should cause an IllegalArgumentException\");\n         } catch (final IllegalArgumentException e) {\n             // expected\n         } catch (final IllegalArgumentException e) {\n             // expected\n         }\n-        \n-        try {\n-            FieldUtils.readDeclaredField((Object)null, \"none\");\n+\n+        try {\n+            FieldUtils.readDeclaredField((Object) null, \"none\");\n             fail(\"a null target should cause an IllegalArgumentException\");\n         } catch (final IllegalArgumentException e) {\n             // expected\n         }\n-        \n+\n         try {\n             assertEquals(\"s\", FieldUtils.readDeclaredField(publicChild, \"s\"));\n             fail(\"expected IllegalArgumentException\");\n         } catch (final IllegalArgumentException e) {\n             // expected\n         }\n-        \n-        try {\n-            FieldUtils.readDeclaredField((Object)null, \"none\", true);\n+\n+        try {\n+            FieldUtils.readDeclaredField((Object) null, \"none\", true);\n             fail(\"a null target should cause an IllegalArgumentException\");\n         } catch (final IllegalArgumentException e) {\n             // expected\n         }\n-        \n+\n         try {\n             assertEquals(\"s\", FieldUtils.readDeclaredField(publicChild, \"s\", true));\n             fail(\"expected IllegalArgumentException\");\n         assertEquals(Double.valueOf(0.0), FieldUtils.readDeclaredField(privatelyShadowedChild, \"d\", true));\n     }\n \n-    @Test(expected=IllegalArgumentException.class)\n+    @Test(expected = IllegalArgumentException.class)\n     public void testAmbig() {\n         FieldUtils.getField(Ambig.class, \"VALUE\");\n     }", "timestamp": 1363130584, "metainfo": ""}