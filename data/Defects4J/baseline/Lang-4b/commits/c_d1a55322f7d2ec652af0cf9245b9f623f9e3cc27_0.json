{"sha": "d1a55322f7d2ec652af0cf9245b9f623f9e3cc27", "log": "LANG-799 - DateUtils#parseDate uses default locale; add Locale support Remove inappropriate test - we don't use localized formats  ", "commit": "\n--- a/src/test/java/org/apache/commons/lang3/time/DateUtilsTest.java\n+++ b/src/test/java/org/apache/commons/lang3/time/DateUtilsTest.java\n             Locale.setDefault(dflt);            \n         }\n     }\n-\n-    /**\n-     * Retrieves a non-system locale date pattern string and attempts\n-     * to use it.\n-     * \n-     * @throws Exception\n-     */\n-    @Test\n-    public void testParseNonSystemLocale() throws Exception {\n-        // Retrieve standard long form date pattern\n-        String localPattern = getLongDateFormatForLocale(Locale.getDefault());\n-        assumeTrue(localPattern != null);\n-        \n-        // Find a pattern from another locale that doesn't match\n-        String nonMatchingPattern = null;        \n-        Locale foreignLocale = null;\n-        for (Locale locale : DateFormat.getAvailableLocales()) {\n-            String foreignPattern = getLongDateFormatForLocale(locale);\n-            if (foreignPattern != null && !foreignPattern.equals(localPattern)) {\n-                getLongDateFormatForLocale(locale);\n-                nonMatchingPattern = foreignPattern;\n-                foreignLocale = locale;\n-                break;\n-            }\n-        }\n-        \n-        // There is a slim chance that we can't find a date string that\n-        // differs from the system default. Skip test in that case.\n-        assumeTrue(nonMatchingPattern != null && foreignLocale != null);\n-        \n-        Date testDate = new Date();\n-        SimpleDateFormat sdf = new SimpleDateFormat(\"\", foreignLocale);\n-        sdf.applyLocalizedPattern(nonMatchingPattern);\n-        String testDateString = sdf.format(testDate);\n-        \n-        Date resultDate = DateUtils.parseDate(testDateString, foreignLocale, \n-                new String[] {nonMatchingPattern});\n-        \n-        assertTrue(DateUtils.isSameDay(testDate, resultDate));\n-    }\n     \n-    /**\n-     * Retrieves the long date format pattern string for the supplied\n-     * locale.\n-     * \n-     * @param locale the locale to retrieve the pattern for\n-     * @return the long date pattern string, or <code>null</code> if\n-     * not found\n-     */\n-    private String getLongDateFormatForLocale(Locale locale) {\n-        if (! ArrayUtils.contains(DateFormat.getAvailableLocales(), locale)) {\n-            return null;            \n-        }\n-        \n-        DateFormat localFormat = DateFormat.getDateInstance(DateFormat.LONG, \n-                locale);\n-        if (!(localFormat instanceof SimpleDateFormat)) {\n-            return null;\n-        }\n-        \n-        return ((SimpleDateFormat) localFormat).toLocalizedPattern();        \n-    }\n-\n     /**\n      * This checks that this is a 7 element iterator of Calendar objects\n      * that are dates (no time), and exactly 1 day spaced after each other.", "timestamp": 1348445483, "metainfo": ""}