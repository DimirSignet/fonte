{"sha": "ae6928a0354b67a222c5ea6f9082d864a15e9f59", "log": "Add final modifier to local variables.  ", "commit": "\n--- a/src/main/java/org/apache/commons/lang3/AnnotationUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/AnnotationUtils.java\n         @Override\n         protected String getShortClassName(final java.lang.Class<?> cls) {\n             Class<? extends Annotation> annotationType = null;\n-            for (Class<?> iface : ClassUtils.getAllInterfaces(cls)) {\n+            for (final Class<?> iface : ClassUtils.getAllInterfaces(cls)) {\n                 if (Annotation.class.isAssignableFrom(iface)) {\n                     @SuppressWarnings(\"unchecked\") // OK because we just checked the assignability\n+                    final\n                     Class<? extends Annotation> found = (Class<? extends Annotation>) iface;\n                     annotationType = found;\n                     break;\n         if (a1 == null || a2 == null) {\n             return false;\n         }\n-        Class<? extends Annotation> type = a1.annotationType();\n-        Class<? extends Annotation> type2 = a2.annotationType();\n+        final Class<? extends Annotation> type = a1.annotationType();\n+        final Class<? extends Annotation> type2 = a2.annotationType();\n         Validate.notNull(type, \"Annotation %s with null annotationType()\", a1);\n         Validate.notNull(type2, \"Annotation %s with null annotationType()\", a2);\n         if (!type.equals(type2)) {\n             return false;\n         }\n         try {\n-            for (Method m : type.getDeclaredMethods()) {\n+            for (final Method m : type.getDeclaredMethods()) {\n                 if (m.getParameterTypes().length == 0\n                         && isValidAnnotationMemberType(m.getReturnType())) {\n-                    Object v1 = m.invoke(a1);\n-                    Object v2 = m.invoke(a2);\n+                    final Object v1 = m.invoke(a1);\n+                    final Object v2 = m.invoke(a2);\n                     if (!memberEquals(m.getReturnType(), v1, v2)) {\n                         return false;\n                     }\n                 }\n             }\n-        } catch (IllegalAccessException ex) {\n-            return false;\n-        } catch (InvocationTargetException ex) {\n+        } catch (final IllegalAccessException ex) {\n+            return false;\n+        } catch (final InvocationTargetException ex) {\n             return false;\n         }\n         return true;\n      */\n     public static int hashCode(final Annotation a) {\n         int result = 0;\n-        Class<? extends Annotation> type = a.annotationType();\n-        for (Method m : type.getDeclaredMethods()) {\n+        final Class<? extends Annotation> type = a.annotationType();\n+        for (final Method m : type.getDeclaredMethods()) {\n             try {\n-                Object value = m.invoke(a);\n+                final Object value = m.invoke(a);\n                 if (value == null) {\n                     throw new IllegalStateException(\n                             String.format(\"Annotation method %s returned null\", m));\n                 }\n                 result += hashMember(m.getName(), value);\n-            } catch (RuntimeException ex) {\n+            } catch (final RuntimeException ex) {\n                 throw ex;\n-            } catch (Exception ex) {\n+            } catch (final Exception ex) {\n                 throw new RuntimeException(ex);\n             }\n         }\n      * {@code null}\n      */\n     public static String toString(final Annotation a) {\n-        ToStringBuilder builder = new ToStringBuilder(a, TO_STRING_STYLE);\n-        for (Method m : a.annotationType().getDeclaredMethods()) {\n+        final ToStringBuilder builder = new ToStringBuilder(a, TO_STRING_STYLE);\n+        for (final Method m : a.annotationType().getDeclaredMethods()) {\n             if (m.getParameterTypes().length > 0) {\n                 continue; //wtf?\n             }\n             try {\n                 builder.append(m.getName(), m.invoke(a));\n-            } catch (RuntimeException ex) {\n+            } catch (final RuntimeException ex) {\n                 throw ex;\n-            } catch (Exception ex) {\n+            } catch (final Exception ex) {\n                 throw new RuntimeException(ex);\n             }\n         }\n      * @return a hash code for this member\n      */\n     private static int hashMember(final String name, final Object value) {\n-        int part1 = name.hashCode() * 127;\n+        final int part1 = name.hashCode() * 127;\n         if (value.getClass().isArray()) {\n             return part1 ^ arrayMemberHash(value.getClass().getComponentType(), value);\n         }\n--- a/src/main/java/org/apache/commons/lang3/ArrayUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/ArrayUtils.java\n         }\n         final Map<Object, Object> map = new HashMap<Object, Object>((int) (array.length * 1.5));\n         for (int i = 0; i < array.length; i++) {\n-            Object object = array[i];\n+            final Object object = array[i];\n             if (object instanceof Map.Entry<?, ?>) {\n-                Map.Entry<?,?> entry = (Map.Entry<?,?>) object;\n+                final Map.Entry<?,?> entry = (Map.Entry<?,?>) object;\n                 map.put(entry.getKey(), entry.getValue());\n             } else if (object instanceof Object[]) {\n-                Object[] entry = (Object[]) object;\n+                final Object[] entry = (Object[]) object;\n                 if (entry.length < 2) {\n                     throw new IllegalArgumentException(\"Array element \" + i + \", '\"\n                         + object\n         if (endIndexExclusive > array.length) {\n             endIndexExclusive = array.length;\n         }\n-        int newSize = endIndexExclusive - startIndexInclusive;\n-        Class<?> type = array.getClass().getComponentType();\n+        final int newSize = endIndexExclusive - startIndexInclusive;\n+        final Class<?> type = array.getClass().getComponentType();\n         if (newSize <= 0) {\n             @SuppressWarnings(\"unchecked\") // OK, because array is of type T\n             final T[] emptyArray = (T[]) Array.newInstance(type, 0);\n             return emptyArray;\n         }\n         @SuppressWarnings(\"unchecked\") // OK, because array is of type T\n+        final\n         T[] subarray = (T[]) Array.newInstance(type, newSize);\n         System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);\n         return subarray;\n         if (endIndexExclusive > array.length) {\n             endIndexExclusive = array.length;\n         }\n-        int newSize = endIndexExclusive - startIndexInclusive;\n+        final int newSize = endIndexExclusive - startIndexInclusive;\n         if (newSize <= 0) {\n             return EMPTY_LONG_ARRAY;\n         }\n \n-        long[] subarray = new long[newSize];\n+        final long[] subarray = new long[newSize];\n         System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);\n         return subarray;\n     }\n         if (endIndexExclusive > array.length) {\n             endIndexExclusive = array.length;\n         }\n-        int newSize = endIndexExclusive - startIndexInclusive;\n+        final int newSize = endIndexExclusive - startIndexInclusive;\n         if (newSize <= 0) {\n             return EMPTY_INT_ARRAY;\n         }\n \n-        int[] subarray = new int[newSize];\n+        final int[] subarray = new int[newSize];\n         System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);\n         return subarray;\n     }\n         if (endIndexExclusive > array.length) {\n             endIndexExclusive = array.length;\n         }\n-        int newSize = endIndexExclusive - startIndexInclusive;\n+        final int newSize = endIndexExclusive - startIndexInclusive;\n         if (newSize <= 0) {\n             return EMPTY_SHORT_ARRAY;\n         }\n \n-        short[] subarray = new short[newSize];\n+        final short[] subarray = new short[newSize];\n         System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);\n         return subarray;\n     }\n         if (endIndexExclusive > array.length) {\n             endIndexExclusive = array.length;\n         }\n-        int newSize = endIndexExclusive - startIndexInclusive;\n+        final int newSize = endIndexExclusive - startIndexInclusive;\n         if (newSize <= 0) {\n             return EMPTY_CHAR_ARRAY;\n         }\n \n-        char[] subarray = new char[newSize];\n+        final char[] subarray = new char[newSize];\n         System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);\n         return subarray;\n     }\n         if (endIndexExclusive > array.length) {\n             endIndexExclusive = array.length;\n         }\n-        int newSize = endIndexExclusive - startIndexInclusive;\n+        final int newSize = endIndexExclusive - startIndexInclusive;\n         if (newSize <= 0) {\n             return EMPTY_BYTE_ARRAY;\n         }\n \n-        byte[] subarray = new byte[newSize];\n+        final byte[] subarray = new byte[newSize];\n         System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);\n         return subarray;\n     }\n         if (endIndexExclusive > array.length) {\n             endIndexExclusive = array.length;\n         }\n-        int newSize = endIndexExclusive - startIndexInclusive;\n+        final int newSize = endIndexExclusive - startIndexInclusive;\n         if (newSize <= 0) {\n             return EMPTY_DOUBLE_ARRAY;\n         }\n \n-        double[] subarray = new double[newSize];\n+        final double[] subarray = new double[newSize];\n         System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);\n         return subarray;\n     }\n         if (endIndexExclusive > array.length) {\n             endIndexExclusive = array.length;\n         }\n-        int newSize = endIndexExclusive - startIndexInclusive;\n+        final int newSize = endIndexExclusive - startIndexInclusive;\n         if (newSize <= 0) {\n             return EMPTY_FLOAT_ARRAY;\n         }\n \n-        float[] subarray = new float[newSize];\n+        final float[] subarray = new float[newSize];\n         System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);\n         return subarray;\n     }\n         if (endIndexExclusive > array.length) {\n             endIndexExclusive = array.length;\n         }\n-        int newSize = endIndexExclusive - startIndexInclusive;\n+        final int newSize = endIndexExclusive - startIndexInclusive;\n         if (newSize <= 0) {\n             return EMPTY_BOOLEAN_ARRAY;\n         }\n \n-        boolean[] subarray = new boolean[newSize];\n+        final boolean[] subarray = new boolean[newSize];\n         System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);\n         return subarray;\n     }\n         if (startIndex < 0) {\n             startIndex = 0;\n         }\n-        double min = valueToFind - tolerance;\n-        double max = valueToFind + tolerance;\n+        final double min = valueToFind - tolerance;\n+        final double max = valueToFind + tolerance;\n         for (int i = startIndex; i < array.length; i++) {\n             if (array[i] >= min && array[i] <= max) {\n                 return i;\n         } else if (startIndex >= array.length) {\n             startIndex = array.length - 1;\n         }\n-        double min = valueToFind - tolerance;\n-        double max = valueToFind + tolerance;\n+        final double min = valueToFind - tolerance;\n+        final double max = valueToFind + tolerance;\n         for (int i = startIndex; i >= 0; i--) {\n             if (array[i] >= min && array[i] <= max) {\n                 return i;\n         }\n         final char[] result = new char[array.length];\n         for (int i = 0; i < array.length; i++) {\n-            Character b = array[i];\n+            final Character b = array[i];\n             result[i] = (b == null ? valueForNull : b.charValue());\n         }\n         return result;\n         }\n         final long[] result = new long[array.length];\n         for (int i = 0; i < array.length; i++) {\n-            Long b = array[i];\n+            final Long b = array[i];\n             result[i] = (b == null ? valueForNull : b.longValue());\n         }\n         return result;\n         }\n         final int[] result = new int[array.length];\n         for (int i = 0; i < array.length; i++) {\n-            Integer b = array[i];\n+            final Integer b = array[i];\n             result[i] = (b == null ? valueForNull : b.intValue());\n         }\n         return result;\n         }\n         final short[] result = new short[array.length];\n         for (int i = 0; i < array.length; i++) {\n-            Short b = array[i];\n+            final Short b = array[i];\n             result[i] = (b == null ? valueForNull : b.shortValue());\n         }\n         return result;\n         }\n         final byte[] result = new byte[array.length];\n         for (int i = 0; i < array.length; i++) {\n-            Byte b = array[i];\n+            final Byte b = array[i];\n             result[i] = (b == null ? valueForNull : b.byteValue());\n         }\n         return result;\n         }\n         final double[] result = new double[array.length];\n         for (int i = 0; i < array.length; i++) {\n-            Double b = array[i];\n+            final Double b = array[i];\n             result[i] = (b == null ? valueForNull : b.doubleValue());\n         }\n         return result;\n         }\n         final float[] result = new float[array.length];\n         for (int i = 0; i < array.length; i++) {\n-            Float b = array[i];\n+            final Float b = array[i];\n             result[i] = (b == null ? valueForNull : b.floatValue());\n         }\n         return result;\n         }\n         final boolean[] result = new boolean[array.length];\n         for (int i = 0; i < array.length; i++) {\n-            Boolean b = array[i];\n+            final Boolean b = array[i];\n             result[i] = (b == null ? valueForNull : b.booleanValue());\n         }\n         return result;\n         }\n         final Class<?> type1 = array1.getClass().getComponentType();\n         @SuppressWarnings(\"unchecked\") // OK, because array is of type T\n+        final\n         T[] joinedArray = (T[]) Array.newInstance(type1, array1.length + array2.length);\n         System.arraycopy(array1, 0, joinedArray, 0, array1.length);\n         try {\n             System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n-        } catch (ArrayStoreException ase) {\n+        } catch (final ArrayStoreException ase) {\n             // Check if problem was due to incompatible types\n             /*\n              * We do this here, rather than before the copy because:\n         } else if (array2 == null) {\n             return clone(array1);\n         }\n-        boolean[] joinedArray = new boolean[array1.length + array2.length];\n+        final boolean[] joinedArray = new boolean[array1.length + array2.length];\n         System.arraycopy(array1, 0, joinedArray, 0, array1.length);\n         System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n         return joinedArray;\n         } else if (array2 == null) {\n             return clone(array1);\n         }\n-        char[] joinedArray = new char[array1.length + array2.length];\n+        final char[] joinedArray = new char[array1.length + array2.length];\n         System.arraycopy(array1, 0, joinedArray, 0, array1.length);\n         System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n         return joinedArray;\n         } else if (array2 == null) {\n             return clone(array1);\n         }\n-        byte[] joinedArray = new byte[array1.length + array2.length];\n+        final byte[] joinedArray = new byte[array1.length + array2.length];\n         System.arraycopy(array1, 0, joinedArray, 0, array1.length);\n         System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n         return joinedArray;\n         } else if (array2 == null) {\n             return clone(array1);\n         }\n-        short[] joinedArray = new short[array1.length + array2.length];\n+        final short[] joinedArray = new short[array1.length + array2.length];\n         System.arraycopy(array1, 0, joinedArray, 0, array1.length);\n         System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n         return joinedArray;\n         } else if (array2 == null) {\n             return clone(array1);\n         }\n-        int[] joinedArray = new int[array1.length + array2.length];\n+        final int[] joinedArray = new int[array1.length + array2.length];\n         System.arraycopy(array1, 0, joinedArray, 0, array1.length);\n         System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n         return joinedArray;\n         } else if (array2 == null) {\n             return clone(array1);\n         }\n-        long[] joinedArray = new long[array1.length + array2.length];\n+        final long[] joinedArray = new long[array1.length + array2.length];\n         System.arraycopy(array1, 0, joinedArray, 0, array1.length);\n         System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n         return joinedArray;\n         } else if (array2 == null) {\n             return clone(array1);\n         }\n-        float[] joinedArray = new float[array1.length + array2.length];\n+        final float[] joinedArray = new float[array1.length + array2.length];\n         System.arraycopy(array1, 0, joinedArray, 0, array1.length);\n         System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n         return joinedArray;\n         } else if (array2 == null) {\n             return clone(array1);\n         }\n-        double[] joinedArray = new double[array1.length + array2.length];\n+        final double[] joinedArray = new double[array1.length + array2.length];\n         System.arraycopy(array1, 0, joinedArray, 0, array1.length);\n         System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n         return joinedArray;\n             throw new IllegalArgumentException(\"Arguments cannot both be null\");\n         }\n         @SuppressWarnings(\"unchecked\") // type must be T\n+        final\n         T[] newArray = (T[]) copyArrayGrow1(array, type);\n         newArray[newArray.length - 1] = element;\n         return newArray;\n      * @since 2.1\n      */\n     public static boolean[] add(final boolean[] array, final boolean element) {\n-        boolean[] newArray = (boolean[])copyArrayGrow1(array, Boolean.TYPE);\n+        final boolean[] newArray = (boolean[])copyArrayGrow1(array, Boolean.TYPE);\n         newArray[newArray.length - 1] = element;\n         return newArray;\n     }\n      * @since 2.1\n      */\n     public static byte[] add(final byte[] array, final byte element) {\n-        byte[] newArray = (byte[])copyArrayGrow1(array, Byte.TYPE);\n+        final byte[] newArray = (byte[])copyArrayGrow1(array, Byte.TYPE);\n         newArray[newArray.length - 1] = element;\n         return newArray;\n     }\n      * @since 2.1\n      */\n     public static char[] add(final char[] array, final char element) {\n-        char[] newArray = (char[])copyArrayGrow1(array, Character.TYPE);\n+        final char[] newArray = (char[])copyArrayGrow1(array, Character.TYPE);\n         newArray[newArray.length - 1] = element;\n         return newArray;\n     }\n      * @since 2.1\n      */\n     public static double[] add(final double[] array, final double element) {\n-        double[] newArray = (double[])copyArrayGrow1(array, Double.TYPE);\n+        final double[] newArray = (double[])copyArrayGrow1(array, Double.TYPE);\n         newArray[newArray.length - 1] = element;\n         return newArray;\n     }\n      * @since 2.1\n      */\n     public static float[] add(final float[] array, final float element) {\n-        float[] newArray = (float[])copyArrayGrow1(array, Float.TYPE);\n+        final float[] newArray = (float[])copyArrayGrow1(array, Float.TYPE);\n         newArray[newArray.length - 1] = element;\n         return newArray;\n     }\n      * @since 2.1\n      */\n     public static int[] add(final int[] array, final int element) {\n-        int[] newArray = (int[])copyArrayGrow1(array, Integer.TYPE);\n+        final int[] newArray = (int[])copyArrayGrow1(array, Integer.TYPE);\n         newArray[newArray.length - 1] = element;\n         return newArray;\n     }\n      * @since 2.1\n      */\n     public static long[] add(final long[] array, final long element) {\n-        long[] newArray = (long[])copyArrayGrow1(array, Long.TYPE);\n+        final long[] newArray = (long[])copyArrayGrow1(array, Long.TYPE);\n         newArray[newArray.length - 1] = element;\n         return newArray;\n     }\n      * @since 2.1\n      */\n     public static short[] add(final short[] array, final short element) {\n-        short[] newArray = (short[])copyArrayGrow1(array, Short.TYPE);\n+        final short[] newArray = (short[])copyArrayGrow1(array, Short.TYPE);\n         newArray[newArray.length - 1] = element;\n         return newArray;\n     }\n      */\n     private static Object copyArrayGrow1(final Object array, final Class<?> newArrayComponentType) {\n         if (array != null) {\n-            int arrayLength = Array.getLength(array);\n-            Object newArray = Array.newInstance(array.getClass().getComponentType(), arrayLength + 1);\n+            final int arrayLength = Array.getLength(array);\n+            final Object newArray = Array.newInstance(array.getClass().getComponentType(), arrayLength + 1);\n             System.arraycopy(array, 0, newArray, 0, arrayLength);\n             return newArray;\n         }\n             if (index != 0) {\n                 throw new IndexOutOfBoundsException(\"Index: \" + index + \", Length: 0\");\n             }\n-            Object joinedArray = Array.newInstance(clss, 1);\n+            final Object joinedArray = Array.newInstance(clss, 1);\n             Array.set(joinedArray, 0, element);\n             return joinedArray;\n         }\n-        int length = Array.getLength(array);\n+        final int length = Array.getLength(array);\n         if (index > length || index < 0) {\n             throw new IndexOutOfBoundsException(\"Index: \" + index + \", Length: \" + length);\n         }\n-        Object result = Array.newInstance(clss, length + 1);\n+        final Object result = Array.newInstance(clss, length + 1);\n         System.arraycopy(array, 0, result, 0, index);\n         Array.set(result, index, element);\n         if (index < length) {\n      * @since 2.1\n      */\n     public static <T> T[] removeElement(final T[] array, final Object element) {\n-        int index = indexOf(array, element);\n+        final int index = indexOf(array, element);\n         if (index == INDEX_NOT_FOUND) {\n             return clone(array);\n         }\n      * @since 2.1\n      */\n     public static boolean[] removeElement(final boolean[] array, final boolean element) {\n-        int index = indexOf(array, element);\n+        final int index = indexOf(array, element);\n         if (index == INDEX_NOT_FOUND) {\n             return clone(array);\n         }\n      * @since 2.1\n      */\n     public static byte[] removeElement(final byte[] array, final byte element) {\n-        int index = indexOf(array, element);\n+        final int index = indexOf(array, element);\n         if (index == INDEX_NOT_FOUND) {\n             return clone(array);\n         }\n      * @since 2.1\n      */\n     public static char[] removeElement(final char[] array, final char element) {\n-        int index = indexOf(array, element);\n+        final int index = indexOf(array, element);\n         if (index == INDEX_NOT_FOUND) {\n             return clone(array);\n         }\n      * @since 2.1\n      */\n     public static double[] removeElement(final double[] array, final double element) {\n-        int index = indexOf(array, element);\n+        final int index = indexOf(array, element);\n         if (index == INDEX_NOT_FOUND) {\n             return clone(array);\n         }\n      * @since 2.1\n      */\n     public static float[] removeElement(final float[] array, final float element) {\n-        int index = indexOf(array, element);\n+        final int index = indexOf(array, element);\n         if (index == INDEX_NOT_FOUND) {\n             return clone(array);\n         }\n      * @since 2.1\n      */\n     public static int[] removeElement(final int[] array, final int element) {\n-        int index = indexOf(array, element);\n+        final int index = indexOf(array, element);\n         if (index == INDEX_NOT_FOUND) {\n             return clone(array);\n         }\n      * @since 2.1\n      */\n     public static long[] removeElement(final long[] array, final long element) {\n-        int index = indexOf(array, element);\n+        final int index = indexOf(array, element);\n         if (index == INDEX_NOT_FOUND) {\n             return clone(array);\n         }\n      * @since 2.1\n      */\n     public static short[] removeElement(final short[] array, final short element) {\n-        int index = indexOf(array, element);\n+        final int index = indexOf(array, element);\n         if (index == INDEX_NOT_FOUND) {\n             return clone(array);\n         }\n      * @since 2.1\n      */\n     private static Object remove(final Object array, final int index) {\n-        int length = getLength(array);\n+        final int length = getLength(array);\n         if (index < 0 || index >= length) {\n             throw new IndexOutOfBoundsException(\"Index: \" + index + \", Length: \" + length);\n         }\n \n-        Object result = Array.newInstance(array.getClass().getComponentType(), length - 1);\n+        final Object result = Array.newInstance(array.getClass().getComponentType(), length - 1);\n         System.arraycopy(array, 0, result, 0, index);\n         if (index < length - 1) {\n             System.arraycopy(array, index + 1, result, index, length - index - 1);\n         if (isEmpty(array) || isEmpty(values)) {\n             return clone(array);\n         }\n-        HashMap<T, MutableInt> occurrences = new HashMap<T, MutableInt>(values.length);\n-        for (T v : values) {\n-            MutableInt count = occurrences.get(v);\n+        final HashMap<T, MutableInt> occurrences = new HashMap<T, MutableInt>(values.length);\n+        for (final T v : values) {\n+            final MutableInt count = occurrences.get(v);\n             if (count == null) {\n                 occurrences.put(v, new MutableInt(1));\n             } else {\n                 count.increment();\n             }\n         }\n-        BitSet toRemove = new BitSet();\n-        for (Map.Entry<T, MutableInt> e : occurrences.entrySet()) {\n-            T v = e.getKey();\n+        final BitSet toRemove = new BitSet();\n+        for (final Map.Entry<T, MutableInt> e : occurrences.entrySet()) {\n+            final T v = e.getKey();\n             int found = 0;\n             for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) {\n                 found = indexOf(array, v, found);\n             }\n         }\n         @SuppressWarnings(\"unchecked\") // removeAll() always creates an array of the same type as its input\n+        final\n         T[] result = (T[]) removeAll(array, toRemove);\n         return result;\n     }\n         if (isEmpty(array) || isEmpty(values)) {\n             return clone(array);\n         }\n-        HashMap<Byte, MutableInt> occurrences = new HashMap<Byte, MutableInt>(values.length);\n-        for (byte v : values) {\n-            Byte boxed = Byte.valueOf(v);\n-            MutableInt count = occurrences.get(boxed);\n+        final HashMap<Byte, MutableInt> occurrences = new HashMap<Byte, MutableInt>(values.length);\n+        for (final byte v : values) {\n+            final Byte boxed = Byte.valueOf(v);\n+            final MutableInt count = occurrences.get(boxed);\n             if (count == null) {\n                 occurrences.put(boxed, new MutableInt(1));\n             } else {\n                 count.increment();\n             }\n         }\n-        BitSet toRemove = new BitSet();\n-        for (Map.Entry<Byte, MutableInt> e : occurrences.entrySet()) {\n-            Byte v = e.getKey();\n+        final BitSet toRemove = new BitSet();\n+        for (final Map.Entry<Byte, MutableInt> e : occurrences.entrySet()) {\n+            final Byte v = e.getKey();\n             int found = 0;\n             for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) {\n                 found = indexOf(array, v.byteValue(), found);\n         if (isEmpty(array) || isEmpty(values)) {\n             return clone(array);\n         }\n-        HashMap<Short, MutableInt> occurrences = new HashMap<Short, MutableInt>(values.length);\n-        for (short v : values) {\n-            Short boxed = Short.valueOf(v);\n-            MutableInt count = occurrences.get(boxed);\n+        final HashMap<Short, MutableInt> occurrences = new HashMap<Short, MutableInt>(values.length);\n+        for (final short v : values) {\n+            final Short boxed = Short.valueOf(v);\n+            final MutableInt count = occurrences.get(boxed);\n             if (count == null) {\n                 occurrences.put(boxed, new MutableInt(1));\n             } else {\n                 count.increment();\n             }\n         }\n-        BitSet toRemove = new BitSet();\n-        for (Map.Entry<Short, MutableInt> e : occurrences.entrySet()) {\n-            Short v = e.getKey();\n+        final BitSet toRemove = new BitSet();\n+        for (final Map.Entry<Short, MutableInt> e : occurrences.entrySet()) {\n+            final Short v = e.getKey();\n             int found = 0;\n             for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) {\n                 found = indexOf(array, v.shortValue(), found);\n         if (isEmpty(array) || isEmpty(values)) {\n             return clone(array);\n         }\n-        HashMap<Integer, MutableInt> occurrences = new HashMap<Integer, MutableInt>(values.length);\n-        for (int v : values) {\n-            Integer boxed = Integer.valueOf(v);\n-            MutableInt count = occurrences.get(boxed);\n+        final HashMap<Integer, MutableInt> occurrences = new HashMap<Integer, MutableInt>(values.length);\n+        for (final int v : values) {\n+            final Integer boxed = Integer.valueOf(v);\n+            final MutableInt count = occurrences.get(boxed);\n             if (count == null) {\n                 occurrences.put(boxed, new MutableInt(1));\n             } else {\n                 count.increment();\n             }\n         }\n-        BitSet toRemove = new BitSet();\n-        for (Map.Entry<Integer, MutableInt> e : occurrences.entrySet()) {\n-            Integer v = e.getKey();\n+        final BitSet toRemove = new BitSet();\n+        for (final Map.Entry<Integer, MutableInt> e : occurrences.entrySet()) {\n+            final Integer v = e.getKey();\n             int found = 0;\n             for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) {\n                 found = indexOf(array, v.intValue(), found);\n         if (isEmpty(array) || isEmpty(values)) {\n             return clone(array);\n         }\n-        HashMap<Character, MutableInt> occurrences = new HashMap<Character, MutableInt>(values.length);\n-        for (char v : values) {\n-            Character boxed = Character.valueOf(v);\n-            MutableInt count = occurrences.get(boxed);\n+        final HashMap<Character, MutableInt> occurrences = new HashMap<Character, MutableInt>(values.length);\n+        for (final char v : values) {\n+            final Character boxed = Character.valueOf(v);\n+            final MutableInt count = occurrences.get(boxed);\n             if (count == null) {\n                 occurrences.put(boxed, new MutableInt(1));\n             } else {\n                 count.increment();\n             }\n         }\n-        BitSet toRemove = new BitSet();\n-        for (Map.Entry<Character, MutableInt> e : occurrences.entrySet()) {\n-            Character v = e.getKey();\n+        final BitSet toRemove = new BitSet();\n+        for (final Map.Entry<Character, MutableInt> e : occurrences.entrySet()) {\n+            final Character v = e.getKey();\n             int found = 0;\n             for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) {\n                 found = indexOf(array, v.charValue(), found);\n         if (isEmpty(array) || isEmpty(values)) {\n             return clone(array);\n         }\n-        HashMap<Long, MutableInt> occurrences = new HashMap<Long, MutableInt>(values.length);\n-        for (long v : values) {\n-            Long boxed = Long.valueOf(v);\n-            MutableInt count = occurrences.get(boxed);\n+        final HashMap<Long, MutableInt> occurrences = new HashMap<Long, MutableInt>(values.length);\n+        for (final long v : values) {\n+            final Long boxed = Long.valueOf(v);\n+            final MutableInt count = occurrences.get(boxed);\n             if (count == null) {\n                 occurrences.put(boxed, new MutableInt(1));\n             } else {\n                 count.increment();\n             }\n         }\n-        BitSet toRemove = new BitSet();\n-        for (Map.Entry<Long, MutableInt> e : occurrences.entrySet()) {\n-            Long v = e.getKey();\n+        final BitSet toRemove = new BitSet();\n+        for (final Map.Entry<Long, MutableInt> e : occurrences.entrySet()) {\n+            final Long v = e.getKey();\n             int found = 0;\n             for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) {\n                 found = indexOf(array, v.longValue(), found);\n         if (isEmpty(array) || isEmpty(values)) {\n             return clone(array);\n         }\n-        HashMap<Float, MutableInt> occurrences = new HashMap<Float, MutableInt>(values.length);\n-        for (float v : values) {\n-            Float boxed = Float.valueOf(v);\n-            MutableInt count = occurrences.get(boxed);\n+        final HashMap<Float, MutableInt> occurrences = new HashMap<Float, MutableInt>(values.length);\n+        for (final float v : values) {\n+            final Float boxed = Float.valueOf(v);\n+            final MutableInt count = occurrences.get(boxed);\n             if (count == null) {\n                 occurrences.put(boxed, new MutableInt(1));\n             } else {\n                 count.increment();\n             }\n         }\n-        BitSet toRemove = new BitSet();\n-        for (Map.Entry<Float, MutableInt> e : occurrences.entrySet()) {\n-            Float v = e.getKey();\n+        final BitSet toRemove = new BitSet();\n+        for (final Map.Entry<Float, MutableInt> e : occurrences.entrySet()) {\n+            final Float v = e.getKey();\n             int found = 0;\n             for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) {\n                 found = indexOf(array, v.floatValue(), found);\n         if (isEmpty(array) || isEmpty(values)) {\n             return clone(array);\n         }\n-        HashMap<Double, MutableInt> occurrences = new HashMap<Double, MutableInt>(values.length);\n-        for (double v : values) {\n-            Double boxed = Double.valueOf(v);\n-            MutableInt count = occurrences.get(boxed);\n+        final HashMap<Double, MutableInt> occurrences = new HashMap<Double, MutableInt>(values.length);\n+        for (final double v : values) {\n+            final Double boxed = Double.valueOf(v);\n+            final MutableInt count = occurrences.get(boxed);\n             if (count == null) {\n                 occurrences.put(boxed, new MutableInt(1));\n             } else {\n                 count.increment();\n             }\n         }\n-        BitSet toRemove = new BitSet();\n-        for (Map.Entry<Double, MutableInt> e : occurrences.entrySet()) {\n-            Double v = e.getKey();\n+        final BitSet toRemove = new BitSet();\n+        for (final Map.Entry<Double, MutableInt> e : occurrences.entrySet()) {\n+            final Double v = e.getKey();\n             int found = 0;\n             for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) {\n                 found = indexOf(array, v.doubleValue(), found);\n         if (isEmpty(array) || isEmpty(values)) {\n             return clone(array);\n         }\n-        HashMap<Boolean, MutableInt> occurrences = new HashMap<Boolean, MutableInt>(2); // only two possible values here\n-        for (boolean v : values) {\n-            Boolean boxed = Boolean.valueOf(v);\n-            MutableInt count = occurrences.get(boxed);\n+        final HashMap<Boolean, MutableInt> occurrences = new HashMap<Boolean, MutableInt>(2); // only two possible values here\n+        for (final boolean v : values) {\n+            final Boolean boxed = Boolean.valueOf(v);\n+            final MutableInt count = occurrences.get(boxed);\n             if (count == null) {\n                 occurrences.put(boxed, new MutableInt(1));\n             } else {\n                 count.increment();\n             }\n         }\n-        BitSet toRemove = new BitSet();\n-        for (Map.Entry<Boolean, MutableInt> e : occurrences.entrySet()) {\n-            Boolean v = e.getKey();\n+        final BitSet toRemove = new BitSet();\n+        for (final Map.Entry<Boolean, MutableInt> e : occurrences.entrySet()) {\n+            final Boolean v = e.getKey();\n             int found = 0;\n             for (int i = 0, ct = e.getValue().intValue(); i < ct; i++) {\n                 found = indexOf(array, v.booleanValue(), found);\n      */\n     // package protected for access by unit tests\n     static Object removeAll(final Object array, final int... indices) {\n-        int length = getLength(array);\n+        final int length = getLength(array);\n         int diff = 0; // number of distinct indexes, i.e. number of entries that will be removed\n \n         if (isNotEmpty(indices)) {\n             int i = indices.length;\n             int prevIndex = length;\n             while (--i >= 0) {\n-                int index = indices[i];\n+                final int index = indices[i];\n                 if (index < 0 || index >= length) {\n                     throw new IndexOutOfBoundsException(\"Index: \" + index + \", Length: \" + length);\n                 }\n                 prevIndex = index;\n             }\n         }\n-        Object result = Array.newInstance(array.getClass().getComponentType(), length - diff);\n+        final Object result = Array.newInstance(array.getClass().getComponentType(), length - diff);\n         if (diff < length) {\n             int end = length; // index just after last copy\n             int dest = length - diff; // number of entries so far not copied\n             for (int i = indices.length - 1; i >= 0; i--) {\n-                int index = indices[i];\n+                final int index = indices[i];\n                 if (end - index > 1) { // same as (cp > 0)\n-                    int cp = end - index - 1;\n+                    final int cp = end - index - 1;\n                     dest -= cp;\n                     System.arraycopy(array, index + 1, result, dest, cp);\n                     // Afer this copy, we still have room for dest items.\n //            throw new IndexOutOfBoundsException(\"Index: \" + (maxIndex-1) + \", Length: \" + srcLength);\n //        }\n         final int removals = indices.cardinality(); // true bits are items to remove\n-        Object result = Array.newInstance(array.getClass().getComponentType(), srcLength - removals);\n+        final Object result = Array.newInstance(array.getClass().getComponentType(), srcLength - removals);\n         int srcIndex=0;\n         int destIndex=0;\n         int count;\n--- a/src/main/java/org/apache/commons/lang3/BooleanUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/BooleanUtils.java\n         }\n         switch (str.length()) {\n             case 1: {\n-                char ch0 = str.charAt(0);\n+                final char ch0 = str.charAt(0);\n                 if (ch0 == 'y' || ch0 == 'Y' ||\n                     ch0 == 't' || ch0 == 'T') {\n                     return Boolean.TRUE;\n                 break;\n             }\n             case 2: {\n-                char ch0 = str.charAt(0);\n-                char ch1 = str.charAt(1);\n+                final char ch0 = str.charAt(0);\n+                final char ch1 = str.charAt(1);\n                 if ((ch0 == 'o' || ch0 == 'O') &&\n                     (ch1 == 'n' || ch1 == 'N') ) {\n                     return Boolean.TRUE;\n                 break;\n             }\n             case 3: {\n-                char ch0 = str.charAt(0);\n-                char ch1 = str.charAt(1);\n-                char ch2 = str.charAt(2);\n+                final char ch0 = str.charAt(0);\n+                final char ch1 = str.charAt(1);\n+                final char ch2 = str.charAt(2);\n                 if ((ch0 == 'y' || ch0 == 'Y') &&\n                     (ch1 == 'e' || ch1 == 'E') &&\n                     (ch2 == 's' || ch2 == 'S') ) {\n                 break;\n             }\n             case 4: {\n-                char ch0 = str.charAt(0);\n-                char ch1 = str.charAt(1);\n-                char ch2 = str.charAt(2);\n-                char ch3 = str.charAt(3);\n+                final char ch0 = str.charAt(0);\n+                final char ch1 = str.charAt(1);\n+                final char ch2 = str.charAt(2);\n+                final char ch3 = str.charAt(3);\n                 if ((ch0 == 't' || ch0 == 'T') &&\n                     (ch1 == 'r' || ch1 == 'R') &&\n                     (ch2 == 'u' || ch2 == 'U') &&\n                 break;\n             }\n             case 5: {\n-                char ch0 = str.charAt(0);\n-                char ch1 = str.charAt(1);\n-                char ch2 = str.charAt(2);\n-                char ch3 = str.charAt(3);\n-                char ch4 = str.charAt(4);\n+                final char ch0 = str.charAt(0);\n+                final char ch1 = str.charAt(1);\n+                final char ch2 = str.charAt(2);\n+                final char ch3 = str.charAt(3);\n+                final char ch4 = str.charAt(4);\n                 if ((ch0 == 'f' || ch0 == 'F') &&\n                     (ch1 == 'a' || ch1 == 'A') &&\n                     (ch2 == 'l' || ch2 == 'L') &&\n         if (array.length == 0) {\n             throw new IllegalArgumentException(\"Array is empty\");\n         }\n-        for (boolean element : array) {\n+        for (final boolean element : array) {\n             if (!element) {\n                 return false;\n             }\n             throw new IllegalArgumentException(\"Array is empty\");\n         }\n         try {\n-            boolean[] primitive = ArrayUtils.toPrimitive(array);\n+            final boolean[] primitive = ArrayUtils.toPrimitive(array);\n             return and(primitive) ? Boolean.TRUE : Boolean.FALSE;\n-        } catch (NullPointerException ex) {\n+        } catch (final NullPointerException ex) {\n             throw new IllegalArgumentException(\"The array must not contain any null elements\");\n         }\n     }\n         if (array.length == 0) {\n             throw new IllegalArgumentException(\"Array is empty\");\n         }\n-        for (boolean element : array) {\n+        for (final boolean element : array) {\n             if (element) {\n                 return true;\n             }\n             throw new IllegalArgumentException(\"Array is empty\");\n         }\n         try {\n-            boolean[] primitive = ArrayUtils.toPrimitive(array);\n+            final boolean[] primitive = ArrayUtils.toPrimitive(array);\n             return or(primitive) ? Boolean.TRUE : Boolean.FALSE;\n-        } catch (NullPointerException ex) {\n+        } catch (final NullPointerException ex) {\n             throw new IllegalArgumentException(\"The array must not contain any null elements\");\n         }\n     }\n \n         // Loops through array, comparing each item\n         int trueCount = 0;\n-        for (boolean element : array) {\n+        for (final boolean element : array) {\n             // If item is true, and trueCount is < 1, increments count\n             // Else, xor fails\n             if (element) {\n             throw new IllegalArgumentException(\"Array is empty\");\n         }\n         try {\n-            boolean[] primitive = ArrayUtils.toPrimitive(array);\n+            final boolean[] primitive = ArrayUtils.toPrimitive(array);\n             return xor(primitive) ? Boolean.TRUE : Boolean.FALSE;\n-        } catch (NullPointerException ex) {\n+        } catch (final NullPointerException ex) {\n             throw new IllegalArgumentException(\"The array must not contain any null elements\");\n         }\n     }\n--- a/src/main/java/org/apache/commons/lang3/CharEncoding.java\n+++ b/src/main/java/org/apache/commons/lang3/CharEncoding.java\n         }\n         try {\n             return Charset.isSupported(name);\n-        } catch (IllegalCharsetNameException ex) {\n+        } catch (final IllegalCharsetNameException ex) {\n             return false;\n         }\n     }\n--- a/src/main/java/org/apache/commons/lang3/CharRange.java\n+++ b/src/main/java/org/apache/commons/lang3/CharRange.java\n     private CharRange(char start, char end, final boolean negated) {\n         super();\n         if (start > end) {\n-            char temp = start;\n+            final char temp = start;\n             start = end;\n             end = temp;\n         }\n         if (obj instanceof CharRange == false) {\n             return false;\n         }\n-        CharRange other = (CharRange) obj;\n+        final CharRange other = (CharRange) obj;\n         return start == other.start && end == other.end && negated == other.negated;\n     }\n \n     @Override\n     public String toString() {\n         if (iToString == null) {\n-            StringBuilder buf = new StringBuilder(4);\n+            final StringBuilder buf = new StringBuilder(4);\n             if (isNegated()) {\n                 buf.append('^');\n             }\n             if (hasNext == false) {\n                 throw new NoSuchElementException();\n             }\n-            char cur = current;\n+            final char cur = current;\n             prepareNext();\n             return Character.valueOf(cur);\n         }\n--- a/src/main/java/org/apache/commons/lang3/CharSequenceUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/CharSequenceUtils.java\n         if (cs instanceof String) {\n             return ((String) cs).indexOf(searchChar, start);\n         } else {\n-            int sz = cs.length();\n+            final int sz = cs.length();\n             if (start < 0) {\n                 start = 0;\n             }\n         if (cs instanceof String) {\n             return ((String) cs).lastIndexOf(searchChar, start);\n         } else {\n-            int sz = cs.length();\n+            final int sz = cs.length();\n             if (start < 0) {\n                 return -1;\n             }\n         if (cs instanceof String) {\n             return ((String) cs).toCharArray();\n         } else {\n-            int sz = cs.length();\n-            char[] array = new char[cs.length()];\n+            final int sz = cs.length();\n+            final char[] array = new char[cs.length()];\n             for (int i = 0; i < sz; i++) {\n                 array[i] = cs.charAt(i);\n             }\n--- a/src/main/java/org/apache/commons/lang3/CharSet.java\n+++ b/src/main/java/org/apache/commons/lang3/CharSet.java\n             return null;\n         }\n         if (setStrs.length == 1) {\n-            CharSet common = COMMON.get(setStrs[0]);\n+            final CharSet common = COMMON.get(setStrs[0]);\n             if (common != null) {\n                 return common;\n             }\n      */\n     protected CharSet(final String... set) {\n         super();\n-        int sz = set.length;\n+        final int sz = set.length;\n         for (int i = 0; i < sz; i++) {\n             add(set[i]);\n         }\n             return;\n         }\n \n-        int len = str.length();\n+        final int len = str.length();\n         int pos = 0;\n         while (pos < len) {\n-            int remainder = len - pos;\n+            final int remainder = len - pos;\n             if (remainder >= 4 && str.charAt(pos) == '^' && str.charAt(pos + 2) == '-') {\n                 // negated range\n                 set.add(CharRange.isNotIn(str.charAt(pos + 1), str.charAt(pos + 3)));\n      * @return {@code true} if the set contains the characters\n      */\n     public boolean contains(final char ch) {\n-        for (CharRange range : set) {\n+        for (final CharRange range : set) {\n             if (range.contains(ch)) {\n                 return true;\n             }\n         if (obj instanceof CharSet == false) {\n             return false;\n         }\n-        CharSet other = (CharSet) obj;\n+        final CharSet other = (CharSet) obj;\n         return set.equals(other.set);\n     }\n \n--- a/src/main/java/org/apache/commons/lang3/CharSetUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/CharSetUtils.java\n         if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n             return str;\n         }\n-        CharSet chars = CharSet.getInstance(set);\n-        StringBuilder buffer = new StringBuilder(str.length());\n-        char[] chrs = str.toCharArray();\n-        int sz = chrs.length;\n+        final CharSet chars = CharSet.getInstance(set);\n+        final StringBuilder buffer = new StringBuilder(str.length());\n+        final char[] chrs = str.toCharArray();\n+        final int sz = chrs.length;\n         char lastChar = ' ';\n         char ch = ' ';\n         for (int i = 0; i < sz; i++) {\n         if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n             return 0;\n         }\n-        CharSet chars = CharSet.getInstance(set);\n+        final CharSet chars = CharSet.getInstance(set);\n         int count = 0;\n-        for (char c : str.toCharArray()) {\n+        for (final char c : str.toCharArray()) {\n             if (chars.contains(c)) {\n                 count++;\n             }\n      * @return the modified String, not null\n      */\n     private static String modify(final String str, final String[] set, final boolean expect) {\n-        CharSet chars = CharSet.getInstance(set);\n-        StringBuilder buffer = new StringBuilder(str.length());\n-        char[] chrs = str.toCharArray();\n-        int sz = chrs.length;\n+        final CharSet chars = CharSet.getInstance(set);\n+        final StringBuilder buffer = new StringBuilder(str.length());\n+        final char[] chrs = str.toCharArray();\n+        final int sz = chrs.length;\n         for(int i=0; i<sz; i++) {\n             if(chars.contains(chrs[i]) == expect) {\n                 buffer.append(chrs[i]);\n      */\n     private static boolean deepEmpty(final String[] strings) {\n         if (strings != null) {\n-            for (String s : strings) {\n+            for (final String s : strings) {\n                 if (StringUtils.isNotEmpty(s)) {\n                     return false;\n                 }\n--- a/src/main/java/org/apache/commons/lang3/ClassUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/ClassUtils.java\n      */\n     private static final Map<Class<?>, Class<?>> wrapperPrimitiveMap = new HashMap<Class<?>, Class<?>>();\n     static {\n-        for (Class<?> primitiveClass : primitiveWrapperMap.keySet()) {\n-            Class<?> wrapperClass = primitiveWrapperMap.get(primitiveClass);\n+        for (final Class<?> primitiveClass : primitiveWrapperMap.keySet()) {\n+            final Class<?> wrapperClass = primitiveWrapperMap.get(primitiveClass);\n             if (!primitiveClass.equals(wrapperClass)) {\n                 wrapperPrimitiveMap.put(wrapperClass, primitiveClass);\n             }\n             return StringUtils.EMPTY;\n         }\n \n-        StringBuilder arrayPrefix = new StringBuilder();\n+        final StringBuilder arrayPrefix = new StringBuilder();\n \n         // Handle array encoding\n         if (className.startsWith(\"[\")) {\n             className = reverseAbbreviationMap.get(className);\n         }\n \n-        int lastDotIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR);\n-        int innerIdx = className.indexOf(\n+        final int lastDotIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR);\n+        final int innerIdx = className.indexOf(\n                 INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1 ? 0 : lastDotIdx + 1);\n         String out = className.substring(lastDotIdx + 1);\n         if (innerIdx != -1) {\n             className = className.substring(1);\n         }\n \n-        int i = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR);\n+        final int i = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR);\n         if (i == -1) {\n             return StringUtils.EMPTY;\n         }\n         if (cls == null) {\n             return null;\n         }\n-        List<Class<?>> classes = new ArrayList<Class<?>>();\n+        final List<Class<?>> classes = new ArrayList<Class<?>>();\n         Class<?> superclass = cls.getSuperclass();\n         while (superclass != null) {\n             classes.add(superclass);\n             return null;\n         }\n \n-        LinkedHashSet<Class<?>> interfacesFound = new LinkedHashSet<Class<?>>();\n+        final LinkedHashSet<Class<?>> interfacesFound = new LinkedHashSet<Class<?>>();\n         getAllInterfaces(cls, interfacesFound);\n \n         return new ArrayList<Class<?>>(interfacesFound);\n      */\n     private static void getAllInterfaces(Class<?> cls, final HashSet<Class<?>> interfacesFound) {\n         while (cls != null) {\n-            Class<?>[] interfaces = cls.getInterfaces();\n-\n-            for (Class<?> i : interfaces) {\n+            final Class<?>[] interfaces = cls.getInterfaces();\n+\n+            for (final Class<?> i : interfaces) {\n                 if (interfacesFound.add(i)) {\n                     getAllInterfaces(i, interfacesFound);\n                 }\n         if (classNames == null) {\n             return null;\n         }\n-        List<Class<?>> classes = new ArrayList<Class<?>>(classNames.size());\n-        for (String className : classNames) {\n+        final List<Class<?>> classes = new ArrayList<Class<?>>(classNames.size());\n+        for (final String className : classNames) {\n             try {\n                 classes.add(Class.forName(className));\n-            } catch (Exception ex) {\n+            } catch (final Exception ex) {\n                 classes.add(null);\n             }\n         }\n         if (classes == null) {\n             return null;\n         }\n-        List<String> classNames = new ArrayList<String>(classes.size());\n-        for (Class<?> cls : classes) {\n+        final List<String> classNames = new ArrayList<String>(classes.size());\n+        for (final Class<?> cls : classes) {\n             if (cls == null) {\n                 classNames.add(null);\n             } else {\n             return classes;\n         }\n \n-        Class<?>[] convertedClasses = new Class[classes.length];\n+        final Class<?>[] convertedClasses = new Class[classes.length];\n         for (int i = 0; i < classes.length; i++) {\n             convertedClasses[i] = primitiveToWrapper(classes[i]);\n         }\n             return classes;\n         }\n \n-        Class<?>[] convertedClasses = new Class[classes.length];\n+        final Class<?>[] convertedClasses = new Class[classes.length];\n         for (int i = 0; i < classes.length; i++) {\n             convertedClasses[i] = wrapperToPrimitive(classes[i]);\n         }\n         try {\n             Class<?> clazz;\n             if (abbreviationMap.containsKey(className)) {\n-                String clsName = \"[\" + abbreviationMap.get(className);\n+                final String clsName = \"[\" + abbreviationMap.get(className);\n                 clazz = Class.forName(clsName, initialize, classLoader).getComponentType();\n             } else {\n                 clazz = Class.forName(toCanonicalName(className), initialize, classLoader);\n             }\n             return clazz;\n-        } catch (ClassNotFoundException ex) {\n+        } catch (final ClassNotFoundException ex) {\n             // allow path separators (.) as inner class name separators\n-            int lastDotIndex = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR);\n+            final int lastDotIndex = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR);\n \n             if (lastDotIndex != -1) {\n                 try {\n                     return getClass(classLoader, className.substring(0, lastDotIndex) +\n                             INNER_CLASS_SEPARATOR_CHAR + className.substring(lastDotIndex + 1),\n                             initialize);\n-                } catch (ClassNotFoundException ex2) { // NOPMD\n+                } catch (final ClassNotFoundException ex2) { // NOPMD\n                     // ignore exception\n                 }\n             }\n      * @throws ClassNotFoundException if the class is not found\n      */\n     public static Class<?> getClass(final String className, final boolean initialize) throws ClassNotFoundException {\n-        ClassLoader contextCL = Thread.currentThread().getContextClassLoader();\n-        ClassLoader loader = contextCL == null ? ClassUtils.class.getClassLoader() : contextCL;\n+        final ClassLoader contextCL = Thread.currentThread().getContextClassLoader();\n+        final ClassLoader loader = contextCL == null ? ClassUtils.class.getClassLoader() : contextCL;\n         return getClass(loader, className, initialize);\n     }\n \n     public static Method getPublicMethod(final Class<?> cls, final String methodName, final Class<?>... parameterTypes)\n             throws SecurityException, NoSuchMethodException {\n \n-        Method declaredMethod = cls.getMethod(methodName, parameterTypes);\n+        final Method declaredMethod = cls.getMethod(methodName, parameterTypes);\n         if (Modifier.isPublic(declaredMethod.getDeclaringClass().getModifiers())) {\n             return declaredMethod;\n         }\n \n-        List<Class<?>> candidateClasses = new ArrayList<Class<?>>();\n+        final List<Class<?>> candidateClasses = new ArrayList<Class<?>>();\n         candidateClasses.addAll(getAllInterfaces(cls));\n         candidateClasses.addAll(getAllSuperclasses(cls));\n \n-        for (Class<?> candidateClass : candidateClasses) {\n+        for (final Class<?> candidateClass : candidateClasses) {\n             if (!Modifier.isPublic(candidateClass.getModifiers())) {\n                 continue;\n             }\n             Method candidateMethod;\n             try {\n                 candidateMethod = candidateClass.getMethod(methodName, parameterTypes);\n-            } catch (NoSuchMethodException ex) {\n+            } catch (final NoSuchMethodException ex) {\n                 continue;\n             }\n             if (Modifier.isPublic(candidateMethod.getDeclaringClass().getModifiers())) {\n         if (className == null) {\n             throw new NullPointerException(\"className must not be null.\");\n         } else if (className.endsWith(\"[]\")) {\n-            StringBuilder classNameBuffer = new StringBuilder();\n+            final StringBuilder classNameBuffer = new StringBuilder();\n             while (className.endsWith(\"[]\")) {\n                 className = className.substring(0, className.length() - 2);\n                 classNameBuffer.append(\"[\");\n             }\n-            String abbreviation = abbreviationMap.get(className);\n+            final String abbreviation = abbreviationMap.get(className);\n             if (abbreviation != null) {\n                 classNameBuffer.append(abbreviation);\n             } else {\n         } else if (array.length == 0) {\n             return ArrayUtils.EMPTY_CLASS_ARRAY;\n         }\n-        Class<?>[] classes = new Class[array.length];\n+        final Class<?>[] classes = new Class[array.length];\n         for (int i = 0; i < array.length; i++) {\n             classes[i] = array[i] == null ? null : array[i].getClass();\n         }\n                         className = reverseAbbreviationMap.get(className.substring(0, 1));\n                     }\n                 }\n-                StringBuilder canonicalClassNameBuffer = new StringBuilder(className);\n+                final StringBuilder canonicalClassNameBuffer = new StringBuilder(className);\n                 for (int i = 0; i < dim; i++) {\n                     canonicalClassNameBuffer.append(\"[]\");\n                 }\n--- a/src/main/java/org/apache/commons/lang3/Conversion.java\n+++ b/src/main/java/org/apache/commons/lang3/Conversion.java\n         if (src.length == 0) {\n             throw new IllegalArgumentException(\"Cannot convert an empty array.\");\n         }\n-        int beSrcPos = src.length - 1 - srcPos;\n-        int srcLen = Math.min(4, beSrcPos + 1);\n-        boolean[] paddedSrc = new boolean[4];\n+        final int beSrcPos = src.length - 1 - srcPos;\n+        final int srcLen = Math.min(4, beSrcPos + 1);\n+        final boolean[] paddedSrc = new boolean[4];\n         System.arraycopy(src, beSrcPos + 1 - srcLen, paddedSrc, 4 - srcLen, srcLen);\n         src = paddedSrc;\n         srcPos = 0;\n      * @throws IllegalArgumentException if {@code nibble < 0} or {@code nibble > 15}\n      */\n     public static char intToHexDigit(final int nibble) {\n-        char c = Character.forDigit(nibble, 16);\n+        final char c = Character.forDigit(nibble, 16);\n         if (c == Character.MIN_VALUE) {\n             throw new IllegalArgumentException(\"nibble value not between 0 and 15: \" + nibble);\n         }\n         int shift = 0;\n         for (int i = 0; i < nInts; i++ ) {\n             shift = i * 32 + dstPos;\n-            long bits = ((0xffffffffL & src[i + srcPos]) << shift);\n-            long mask = 0xffffffffL << shift;\n+            final long bits = ((0xffffffffL & src[i + srcPos]) << shift);\n+            final long mask = 0xffffffffL << shift;\n             out = (out & ~mask) | bits;\n         }\n         return out;\n         int shift = 0;\n         for (int i = 0; i < nShorts; i++ ) {\n             shift = i * 16 + dstPos;\n-            long bits = (0xffffL & src[i + srcPos]) << shift;\n-            long mask = 0xffffL << shift;\n+            final long bits = (0xffffL & src[i + srcPos]) << shift;\n+            final long mask = 0xffffL << shift;\n             out = (out & ~mask) | bits;\n         }\n         return out;\n         int shift = 0;\n         for (int i = 0; i < nShorts; i++ ) {\n             shift = i * 16 + dstPos;\n-            int bits = (0xffff & src[i + srcPos]) << shift;\n-            int mask = 0xffff << shift;\n+            final int bits = (0xffff & src[i + srcPos]) << shift;\n+            final int mask = 0xffff << shift;\n             out = (out & ~mask) | bits;\n         }\n         return out;\n         int shift = 0;\n         for (int i = 0; i < nBytes; i++ ) {\n             shift = i * 8 + dstPos;\n-            long bits = (0xffL & src[i + srcPos]) << shift;\n-            long mask = 0xffL << shift;\n+            final long bits = (0xffL & src[i + srcPos]) << shift;\n+            final long mask = 0xffL << shift;\n             out = (out & ~mask) | bits;\n         }\n         return out;\n         int shift = 0;\n         for (int i = 0; i < nBytes; i++ ) {\n             shift = i * 8 + dstPos;\n-            int bits = (0xff & src[i + srcPos]) << shift;\n-            int mask = 0xff << shift;\n+            final int bits = (0xff & src[i + srcPos]) << shift;\n+            final int mask = 0xff << shift;\n             out = (out & ~mask) | bits;\n         }\n         return out;\n         int shift = 0;\n         for (int i = 0; i < nBytes; i++ ) {\n             shift = i * 8 + dstPos;\n-            int bits = (0xff & src[i + srcPos]) << shift;\n-            int mask = 0xff << shift;\n+            final int bits = (0xff & src[i + srcPos]) << shift;\n+            final int mask = 0xff << shift;\n             out = (short)((out & ~mask) | bits);\n         }\n         return out;\n         int shift = 0;\n         for (int i = 0; i < nHex; i++ ) {\n             shift = i * 4 + dstPos;\n-            long bits = (0xfL & hexDigitToInt(src.charAt(i + srcPos))) << shift;\n-            long mask = 0xfL << shift;\n+            final long bits = (0xfL & hexDigitToInt(src.charAt(i + srcPos))) << shift;\n+            final long mask = 0xfL << shift;\n             out = (out & ~mask) | bits;\n         }\n         return out;\n         int shift = 0;\n         for (int i = 0; i < nHex; i++ ) {\n             shift = i * 4 + dstPos;\n-            int bits = (0xf & hexDigitToInt(src.charAt(i + srcPos))) << shift;\n-            int mask = 0xf << shift;\n+            final int bits = (0xf & hexDigitToInt(src.charAt(i + srcPos))) << shift;\n+            final int mask = 0xf << shift;\n             out = (out & ~mask) | bits;\n         }\n         return out;\n         int shift = 0;\n         for (int i = 0; i < nHex; i++ ) {\n             shift = i * 4 + dstPos;\n-            int bits = (0xf & hexDigitToInt(src.charAt(i + srcPos))) << shift;\n-            int mask = 0xf << shift;\n+            final int bits = (0xf & hexDigitToInt(src.charAt(i + srcPos))) << shift;\n+            final int mask = 0xf << shift;\n             out = (short)((out & ~mask) | bits);\n         }\n         return out;\n         int shift = 0;\n         for (int i = 0; i < nHex; i++ ) {\n             shift = i * 4 + dstPos;\n-            int bits = (0xf & hexDigitToInt(src.charAt(i + srcPos))) << shift;\n-            int mask = 0xf << shift;\n+            final int bits = (0xf & hexDigitToInt(src.charAt(i + srcPos))) << shift;\n+            final int mask = 0xf << shift;\n             out = (byte)((out & ~mask) | bits);\n         }\n         return out;\n         int shift = 0;\n         for (int i = 0; i < nBools; i++ ) {\n             shift = i * 1 + dstPos;\n-            long bits = (src[i + srcPos] ? 1L : 0) << shift;\n-            long mask = 0x1L << shift;\n+            final long bits = (src[i + srcPos] ? 1L : 0) << shift;\n+            final long mask = 0x1L << shift;\n             out = (out & ~mask) | bits;\n         }\n         return out;\n         int shift = 0;\n         for (int i = 0; i < nBools; i++ ) {\n             shift = i * 1 + dstPos;\n-            int bits = (src[i + srcPos] ? 1 : 0) << shift;\n-            int mask = 0x1 << shift;\n+            final int bits = (src[i + srcPos] ? 1 : 0) << shift;\n+            final int mask = 0x1 << shift;\n             out = (out & ~mask) | bits;\n         }\n         return out;\n         int shift = 0;\n         for (int i = 0; i < nBools; i++ ) {\n             shift = i * 1 + dstPos;\n-            int bits = (src[i + srcPos] ? 1 : 0) << shift;\n-            int mask = 0x1 << shift;\n+            final int bits = (src[i + srcPos] ? 1 : 0) << shift;\n+            final int mask = 0x1 << shift;\n             out = (short)((out & ~mask) | bits);\n         }\n         return out;\n         int shift = 0;\n         for (int i = 0; i < nBools; i++ ) {\n             shift = i * 1 + dstPos;\n-            int bits = (src[i + srcPos] ? 1 : 0) << shift;\n-            int mask = 0x1 << shift;\n+            final int bits = (src[i + srcPos] ? 1 : 0) << shift;\n+            final int mask = 0x1 << shift;\n             out = (byte)((out & ~mask) | bits);\n         }\n         return out;\n             throw new IllegalArgumentException(\n                 \"(nHexs-1)*4+srcPos is greather or equal to than 64\");\n         }\n-        StringBuilder sb = new StringBuilder(dstInit);\n+        final StringBuilder sb = new StringBuilder(dstInit);\n         int shift = 0;\n         int append = sb.length();\n         for (int i = 0; i < nHexs; i++ ) {\n             shift = i * 4 + srcPos;\n-            int bits = (int)(0xF & (src >> shift));\n+            final int bits = (int)(0xF & (src >> shift));\n             if (dstPos + i == append) {\n                 ++append;\n                 sb.append(intToHexDigit(bits));\n             throw new IllegalArgumentException(\n                 \"(nHexs-1)*4+srcPos is greather or equal to than 32\");\n         }\n-        StringBuilder sb = new StringBuilder(dstInit);\n+        final StringBuilder sb = new StringBuilder(dstInit);\n         int shift = 0;\n         int append = sb.length();\n         for (int i = 0; i < nHexs; i++ ) {\n             shift = i * 4 + srcPos;\n-            int bits = 0xF & (src >> shift);\n+            final int bits = 0xF & (src >> shift);\n             if (dstPos + i == append) {\n                 ++append;\n                 sb.append(intToHexDigit(bits));\n             throw new IllegalArgumentException(\n                 \"(nHexs-1)*4+srcPos is greather or equal to than 16\");\n         }\n-        StringBuilder sb = new StringBuilder(dstInit);\n+        final StringBuilder sb = new StringBuilder(dstInit);\n         int shift = 0;\n         int append = sb.length();\n         for (int i = 0; i < nHexs; i++ ) {\n             shift = i * 4 + srcPos;\n-            int bits = 0xF & (src >> shift);\n+            final int bits = 0xF & (src >> shift);\n             if (dstPos + i == append) {\n                 ++append;\n                 sb.append(intToHexDigit(bits));\n             throw new IllegalArgumentException(\n                 \"(nHexs-1)*4+srcPos is greather or equal to than 8\");\n         }\n-        StringBuilder sb = new StringBuilder(dstInit);\n+        final StringBuilder sb = new StringBuilder(dstInit);\n         int shift = 0;\n         int append = sb.length();\n         for (int i = 0; i < nHexs; i++ ) {\n             shift = i * 4 + srcPos;\n-            int bits = 0xF & (src >> shift);\n+            final int bits = 0xF & (src >> shift);\n             if (dstPos + i == append) {\n                 ++append;\n                 sb.append(intToHexDigit(bits));\n--- a/src/main/java/org/apache/commons/lang3/EnumUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/EnumUtils.java\n      * @return the modifiable map of enum names to enums, never null\n      */\n     public static <E extends Enum<E>> Map<String, E> getEnumMap(final Class<E> enumClass) {\n-        Map<String, E> map = new LinkedHashMap<String, E>();\n-        for (E e: enumClass.getEnumConstants()) {\n+        final Map<String, E> map = new LinkedHashMap<String, E>();\n+        for (final E e: enumClass.getEnumConstants()) {\n             map.put(e.name(), e);\n         }\n         return map;\n         try {\n             Enum.valueOf(enumClass, enumName);\n             return true;\n-        } catch (IllegalArgumentException ex) {\n+        } catch (final IllegalArgumentException ex) {\n             return false;\n         }\n     }\n         }\n         try {\n             return Enum.valueOf(enumClass, enumName);\n-        } catch (IllegalArgumentException ex) {\n+        } catch (final IllegalArgumentException ex) {\n             return null;\n         }\n     }\n         checkBitVectorable(enumClass);\n         Validate.notNull(values);\n         long total = 0;\n-        for (E constant : values) {\n+        for (final E constant : values) {\n             Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n             total |= 1 << constant.ordinal();\n         }\n         asEnum(enumClass);\n         Validate.notNull(values);\n         final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n-        for (E constant : values) {\n+        for (final E constant : values) {\n             Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n             condensed.add(constant);\n         }\n         final long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1];\n-        for (E value : condensed) {\n+        for (final E value : condensed) {\n             result[value.ordinal() / Long.SIZE] |= 1 << (value.ordinal() % Long.SIZE);\n         }\n         ArrayUtils.reverse(result);\n         final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n         Collections.addAll(condensed, values);\n         final long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1];\n-        for (E value : condensed) {\n+        for (final E value : condensed) {\n             result[value.ordinal() / Long.SIZE] |= 1 << (value.ordinal() % Long.SIZE);\n         }\n         ArrayUtils.reverse(result);\n         final EnumSet<E> results = EnumSet.noneOf(asEnum(enumClass));\n         values = ArrayUtils.clone(Validate.notNull(values));\n         ArrayUtils.reverse(values);\n-        for (E constant : enumClass.getEnumConstants()) {\n-            int block = constant.ordinal() / Long.SIZE;\n+        for (final E constant : enumClass.getEnumConstants()) {\n+            final int block = constant.ordinal() / Long.SIZE;\n             if (block < values.length && (values[block] & 1 << (constant.ordinal() % Long.SIZE)) != 0) {\n                 results.add(constant);\n             }\n--- a/src/main/java/org/apache/commons/lang3/LocaleUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/LocaleUtils.java\n      * @return the unmodifiable list of Locale objects, 0 being locale, not null\n      */\n     public static List<Locale> localeLookupList(final Locale locale, final Locale defaultLocale) {\n-        List<Locale> list = new ArrayList<Locale>(4);\n+        final List<Locale> list = new ArrayList<Locale>(4);\n         if (locale != null) {\n             list.add(locale);\n             if (locale.getVariant().length() > 0) {\n         List<Locale> langs = cLanguagesByCountry.get(countryCode);\n         if (langs == null) {\n             langs = new ArrayList<Locale>();\n-            List<Locale> locales = availableLocaleList();\n+            final List<Locale> locales = availableLocaleList();\n             for (int i = 0; i < locales.size(); i++) {\n-                Locale locale = locales.get(i);\n+                final Locale locale = locales.get(i);\n                 if (countryCode.equals(locale.getCountry()) &&\n                         locale.getVariant().isEmpty()) {\n                     langs.add(locale);\n         List<Locale> countries = cCountriesByLanguage.get(languageCode);\n         if (countries == null) {\n             countries = new ArrayList<Locale>();\n-            List<Locale> locales = availableLocaleList();\n+            final List<Locale> locales = availableLocaleList();\n             for (int i = 0; i < locales.size(); i++) {\n-                Locale locale = locales.get(i);\n+                final Locale locale = locales.get(i);\n                 if (languageCode.equals(locale.getLanguage()) &&\n                         locale.getCountry().length() != 0 &&\n                         locale.getVariant().isEmpty()) {\n         private static final Set<Locale> AVAILABLE_LOCALE_SET;\n         \n         static {\n-            List<Locale> list = new ArrayList<Locale>(Arrays.asList(Locale.getAvailableLocales()));  // extra safe\n+            final List<Locale> list = new ArrayList<Locale>(Arrays.asList(Locale.getAvailableLocales()));  // extra safe\n             AVAILABLE_LOCALE_LIST = Collections.unmodifiableList(list);\n             AVAILABLE_LOCALE_SET = Collections.unmodifiableSet(new HashSet<Locale>(list));\n         }\n--- a/src/main/java/org/apache/commons/lang3/ObjectUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/ObjectUtils.java\n      */\n     public static <T> T firstNonNull(final T... values) {\n         if (values != null) {\n-            for (T val : values) {\n+            for (final T val : values) {\n                 if (val != null) {\n                     return val;\n                 }\n     public static int hashCodeMulti(final Object... objects) {\n         int hash = 1;\n         if (objects != null) {\n-            for (Object object : objects) {\n+            for (final Object object : objects) {\n                 hash = hash * 31 + ObjectUtils.hashCode(object);\n             }\n         }\n         if (object == null) {\n             return null;\n         }\n-        StringBuffer buffer = new StringBuffer();\n+        final StringBuffer buffer = new StringBuffer();\n         identityToString(buffer, object);\n         return buffer.toString();\n     }\n     public static <T extends Comparable<? super T>> T min(final T... values) {\n         T result = null;\n         if (values != null) {\n-            for (T value : values) {\n+            for (final T value : values) {\n                 if (compare(value, result, true) < 0) {\n                     result = value;\n                 }\n     public static <T extends Comparable<? super T>> T max(final T... values) {\n         T result = null;\n         if (values != null) {\n-            for (T value : values) {\n+            for (final T value : values) {\n                 if (compare(value, result, false) > 0) {\n                     result = value;\n                 }\n     public static <T extends Comparable<? super T>> T median(final T... items) {\n         Validate.notEmpty(items);\n         Validate.noNullElements(items);\n-        TreeSet<T> sort = new TreeSet<T>();\n+        final TreeSet<T> sort = new TreeSet<T>();\n         Collections.addAll(sort, items);\n         @SuppressWarnings(\"unchecked\") //we know all items added were T instances\n+        final\n         T result = (T) sort.toArray()[(sort.size() - 1) / 2];\n         return result;\n     }\n         Validate.notEmpty(items, \"null/empty items\");\n         Validate.noNullElements(items);\n         Validate.notNull(comparator, \"null comparator\");\n-        TreeSet<T> sort = new TreeSet<T>(comparator);\n+        final TreeSet<T> sort = new TreeSet<T>(comparator);\n         Collections.addAll(sort, items);\n         @SuppressWarnings(\"unchecked\") //we know all items added were T instances\n+        final\n         T result = (T) sort.toArray()[(sort.size() - 1) / 2];\n         return result;\n     }\n      */\n     public static <T> T mode(final T... items) {\n         if (ArrayUtils.isNotEmpty(items)) {\n-            HashMap<T, MutableInt> occurrences = new HashMap<T, MutableInt>(items.length);\n-            for (T t : items) {\n-                MutableInt count = occurrences.get(t);\n+            final HashMap<T, MutableInt> occurrences = new HashMap<T, MutableInt>(items.length);\n+            for (final T t : items) {\n+                final MutableInt count = occurrences.get(t);\n                 if (count == null) {\n                     occurrences.put(t, new MutableInt(1));\n                 } else {\n             }\n             T result = null;\n             int max = 0;\n-            for (Map.Entry<T, MutableInt> e : occurrences.entrySet()) {\n-                int cmp = e.getValue().intValue();\n+            for (final Map.Entry<T, MutableInt> e : occurrences.entrySet()) {\n+                final int cmp = e.getValue().intValue();\n                 if (cmp == max) {\n                     result = null;\n                 } else if (cmp > max) {\n--- a/src/main/java/org/apache/commons/lang3/RandomStringUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/RandomStringUtils.java\n             }\n         }\n \n-        char[] buffer = new char[count];\n-        int gap = end - start;\n+        final char[] buffer = new char[count];\n+        final int gap = end - start;\n \n         while (count-- != 0) {\n             char ch;\n--- a/src/main/java/org/apache/commons/lang3/Range.java\n+++ b/src/main/java/org/apache/commons/lang3/Range.java\n         if (this.equals(other)) {\n             return this;\n         }\n-        T min = getComparator().compare(minimum, other.minimum) < 0 ? other.minimum : minimum;\n-        T max = getComparator().compare(maximum, other.maximum) < 0 ? maximum : other.maximum;\n+        final T min = getComparator().compare(minimum, other.minimum) < 0 ? other.minimum : minimum;\n+        final T max = getComparator().compare(maximum, other.maximum) < 0 ? maximum : other.maximum;\n         return between(min, max, getComparator());\n     }\n \n             return false;\n         } else {\n             @SuppressWarnings(\"unchecked\") // OK because we checked the class above\n+            final\n             Range<T> range = (Range<T>) obj;\n             return minimum.equals(range.minimum) &&\n                    maximum.equals(range.maximum);\n     public String toString() {\n         String result = toString;\n         if (result == null) {\n-            StringBuilder buf = new StringBuilder(32);\n+            final StringBuilder buf = new StringBuilder(32);\n             buf.append('[');\n             buf.append(minimum);\n             buf.append(\"..\");\n--- a/src/main/java/org/apache/commons/lang3/SerializationUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/SerializationUtils.java\n         if (object == null) {\n             return null;\n         }\n-        byte[] objectData = serialize(object);\n-        ByteArrayInputStream bais = new ByteArrayInputStream(objectData);\n+        final byte[] objectData = serialize(object);\n+        final ByteArrayInputStream bais = new ByteArrayInputStream(objectData);\n \n         ClassLoaderAwareObjectInputStream in = null;\n         try {\n              * is of the same type as the original serialized object\n              */\n             @SuppressWarnings(\"unchecked\") // see above\n+            final\n             T readObject = (T) in.readObject();\n             return readObject;\n \n-        } catch (ClassNotFoundException ex) {\n+        } catch (final ClassNotFoundException ex) {\n             throw new SerializationException(\"ClassNotFoundException while reading cloned object data\", ex);\n-        } catch (IOException ex) {\n+        } catch (final IOException ex) {\n             throw new SerializationException(\"IOException while reading cloned object data\", ex);\n         } finally {\n             try {\n                 if (in != null) {\n                     in.close();\n                 }\n-            } catch (IOException ex) {\n+            } catch (final IOException ex) {\n                 throw new SerializationException(\"IOException on closing cloned object data InputStream.\", ex);\n             }\n         }\n             out = new ObjectOutputStream(outputStream);\n             out.writeObject(obj);\n \n-        } catch (IOException ex) {\n+        } catch (final IOException ex) {\n             throw new SerializationException(ex);\n         } finally {\n             try {\n                 if (out != null) {\n                     out.close();\n                 }\n-            } catch (IOException ex) { // NOPMD\n+            } catch (final IOException ex) { // NOPMD\n                 // ignore close exception\n             }\n         }\n      * @throws SerializationException (runtime) if the serialization fails\n      */\n     public static byte[] serialize(final Serializable obj) {\n-        ByteArrayOutputStream baos = new ByteArrayOutputStream(512);\n+        final ByteArrayOutputStream baos = new ByteArrayOutputStream(512);\n         serialize(obj, baos);\n         return baos.toByteArray();\n     }\n             in = new ObjectInputStream(inputStream);\n             return (T) in.readObject();\n \n-        } catch (ClassNotFoundException ex) {\n+        } catch (final ClassNotFoundException ex) {\n             throw new SerializationException(ex);\n-        } catch (IOException ex) {\n+        } catch (final IOException ex) {\n             throw new SerializationException(ex);\n         } finally {\n             try {\n                 if (in != null) {\n                     in.close();\n                 }\n-            } catch (IOException ex) { // NOPMD\n+            } catch (final IOException ex) { // NOPMD\n                 // ignore close exception\n             }\n         }\n          */\n         @Override\n         protected Class<?> resolveClass(final ObjectStreamClass desc) throws IOException, ClassNotFoundException {\n-            String name = desc.getName();\n+            final String name = desc.getName();\n             try {\n                 return Class.forName(name, false, classLoader);\n-            } catch (ClassNotFoundException ex) {\n+            } catch (final ClassNotFoundException ex) {\n                 try {\n                     return Class.forName(name, false, Thread.currentThread().getContextClassLoader());\n-                } catch (ClassNotFoundException cnfe) {\n-                    Class<?> cls = primitiveTypes.get(name);\n+                } catch (final ClassNotFoundException cnfe) {\n+                    final Class<?> cls = primitiveTypes.get(name);\n                     if (cls != null) {\n                         return cls;\n                     } else {\n--- a/src/main/java/org/apache/commons/lang3/StringEscapeUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/StringEscapeUtils.java\n             }\n \n             // strip quotes\n-            String quoteless = input.subSequence(1, input.length() - 1).toString();\n+            final String quoteless = input.subSequence(1, input.length() - 1).toString();\n \n             if ( StringUtils.containsAny(quoteless, CSV_SEARCH_CHARS) ) {\n                 // deal with escaped quotes; ie) \"\"\n--- a/src/main/java/org/apache/commons/lang3/StringUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/StringUtils.java\n      * @since 2.0\n      */\n     public static String trimToNull(final String str) {\n-        String ts = trim(str);\n+        final String ts = trim(str);\n         return isEmpty(ts) ? null : ts;\n     }\n \n         if (strs == null || (strsLen = strs.length) == 0) {\n             return strs;\n         }\n-        String[] newArr = new String[strsLen];\n+        final String[] newArr = new String[strsLen];\n         for (int i = 0; i < strsLen; i++) {\n             newArr[i] = strip(strs[i], stripChars);\n         }\n         if(input == null) {\n             return null;\n         }\n-        Pattern pattern = Pattern.compile(\"\\\\p{InCombiningDiacriticalMarks}+\");//$NON-NLS-1$\n-        String decomposed = Normalizer.normalize(input, Normalizer.Form.NFD);\n+        final Pattern pattern = Pattern.compile(\"\\\\p{InCombiningDiacriticalMarks}+\");//$NON-NLS-1$\n+        final String decomposed = Normalizer.normalize(input, Normalizer.Form.NFD);\n         // Note that this doesn't correctly remove ligatures...\n         return pattern.matcher(decomposed).replaceAll(\"\");//$NON-NLS-1$\n     }\n         if (startPos < 0) {\n             startPos = 0;\n         }\n-        int endLimit = str.length() - searchStr.length() + 1;\n+        final int endLimit = str.length() - searchStr.length() + 1;\n         if (startPos > endLimit) {\n             return INDEX_NOT_FOUND;\n         }\n         if (str == null || searchStr == null) {\n             return false;\n         }\n-        int len = searchStr.length();\n-        int max = str.length() - len;\n+        final int len = searchStr.length();\n+        final int max = str.length() - len;\n         for (int i = 0; i <= max; i++) {\n             if (CharSequenceUtils.regionMatches(str, true, i, searchStr, 0, len)) {\n                 return true;\n         if (isEmpty(seq)) {\n             return false;\n         }\n-        int strLen = seq.length();\n+        final int strLen = seq.length();\n         for (int i = 0; i < strLen; i++) {\n             if (Character.isWhitespace(seq.charAt(i))) {\n                 return true;\n         if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {\n             return INDEX_NOT_FOUND;\n         }\n-        int csLen = cs.length();\n-        int csLast = csLen - 1;\n-        int searchLen = searchChars.length;\n-        int searchLast = searchLen - 1;\n+        final int csLen = cs.length();\n+        final int csLast = csLen - 1;\n+        final int searchLen = searchChars.length;\n+        final int searchLast = searchLen - 1;\n         for (int i = 0; i < csLen; i++) {\n-            char ch = cs.charAt(i);\n+            final char ch = cs.charAt(i);\n             for (int j = 0; j < searchLen; j++) {\n                 if (searchChars[j] == ch) {\n                     if (i < csLast && j < searchLast && Character.isHighSurrogate(ch)) {\n         if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {\n             return false;\n         }\n-        int csLength = cs.length();\n-        int searchLength = searchChars.length;\n-        int csLast = csLength - 1;\n-        int searchLast = searchLength - 1;\n+        final int csLength = cs.length();\n+        final int searchLength = searchChars.length;\n+        final int csLast = csLength - 1;\n+        final int searchLast = searchLength - 1;\n         for (int i = 0; i < csLength; i++) {\n-            char ch = cs.charAt(i);\n+            final char ch = cs.charAt(i);\n             for (int j = 0; j < searchLength; j++) {\n                 if (searchChars[j] == ch) {\n                     if (Character.isHighSurrogate(ch)) {\n         if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {\n             return INDEX_NOT_FOUND;\n         }\n-        int csLen = cs.length();\n-        int csLast = csLen - 1;\n-        int searchLen = searchChars.length;\n-        int searchLast = searchLen - 1;\n+        final int csLen = cs.length();\n+        final int csLast = csLen - 1;\n+        final int searchLen = searchChars.length;\n+        final int searchLast = searchLen - 1;\n         outer:\n         for (int i = 0; i < csLen; i++) {\n-            char ch = cs.charAt(i);\n+            final char ch = cs.charAt(i);\n             for (int j = 0; j < searchLen; j++) {\n                 if (searchChars[j] == ch) {\n                     if (i < csLast && j < searchLast && Character.isHighSurrogate(ch)) {\n         if (isEmpty(seq) || isEmpty(searchChars)) {\n             return INDEX_NOT_FOUND;\n         }\n-        int strLen = seq.length();\n+        final int strLen = seq.length();\n         for (int i = 0; i < strLen; i++) {\n-            char ch = seq.charAt(i);\n-            boolean chFound = CharSequenceUtils.indexOf(searchChars, ch, 0) >= 0;\n+            final char ch = seq.charAt(i);\n+            final boolean chFound = CharSequenceUtils.indexOf(searchChars, ch, 0) >= 0;\n             if (i + 1 < strLen && Character.isHighSurrogate(ch)) {\n-                char ch2 = seq.charAt(i + 1);\n+                final char ch2 = seq.charAt(i + 1);\n                 if (chFound && CharSequenceUtils.indexOf(searchChars, ch2, 0) < 0) {\n                     return i;\n                 }\n         if (cs == null || searchChars == null) {\n             return true;\n         }\n-        int csLen = cs.length();\n-        int csLast = csLen - 1;\n-        int searchLen = searchChars.length;\n-        int searchLast = searchLen - 1;\n+        final int csLen = cs.length();\n+        final int csLast = csLen - 1;\n+        final int searchLen = searchChars.length;\n+        final int searchLast = searchLen - 1;\n         for (int i = 0; i < csLen; i++) {\n-            char ch = cs.charAt(i);\n+            final char ch = cs.charAt(i);\n             for (int j = 0; j < searchLen; j++) {\n                 if (searchChars[j] == ch) {\n                     if (Character.isHighSurrogate(ch)) {\n         if (str == null || searchStrs == null) {\n             return INDEX_NOT_FOUND;\n         }\n-        int sz = searchStrs.length;\n+        final int sz = searchStrs.length;\n \n         // String's can't have a MAX_VALUEth index.\n         int ret = Integer.MAX_VALUE;\n \n         int tmp = 0;\n         for (int i = 0; i < sz; i++) {\n-            CharSequence search = searchStrs[i];\n+            final CharSequence search = searchStrs[i];\n             if (search == null) {\n                 continue;\n             }\n         if (str == null || searchStrs == null) {\n             return INDEX_NOT_FOUND;\n         }\n-        int sz = searchStrs.length;\n+        final int sz = searchStrs.length;\n         int ret = INDEX_NOT_FOUND;\n         int tmp = 0;\n         for (int i = 0; i < sz; i++) {\n-            CharSequence search = searchStrs[i];\n+            final CharSequence search = searchStrs[i];\n             if (search == null) {\n                 continue;\n             }\n         if (separator.length() == 0) {\n             return EMPTY;\n         }\n-        int pos = str.indexOf(separator);\n+        final int pos = str.indexOf(separator);\n         if (pos == INDEX_NOT_FOUND) {\n             return str;\n         }\n         if (separator == null) {\n             return EMPTY;\n         }\n-        int pos = str.indexOf(separator);\n+        final int pos = str.indexOf(separator);\n         if (pos == INDEX_NOT_FOUND) {\n             return EMPTY;\n         }\n         if (isEmpty(str) || isEmpty(separator)) {\n             return str;\n         }\n-        int pos = str.lastIndexOf(separator);\n+        final int pos = str.lastIndexOf(separator);\n         if (pos == INDEX_NOT_FOUND) {\n             return str;\n         }\n         if (isEmpty(separator)) {\n             return EMPTY;\n         }\n-        int pos = str.lastIndexOf(separator);\n+        final int pos = str.lastIndexOf(separator);\n         if (pos == INDEX_NOT_FOUND || pos == str.length() - separator.length()) {\n             return EMPTY;\n         }\n         if (str == null || open == null || close == null) {\n             return null;\n         }\n-        int start = str.indexOf(open);\n+        final int start = str.indexOf(open);\n         if (start != INDEX_NOT_FOUND) {\n-            int end = str.indexOf(close, start + open.length());\n+            final int end = str.indexOf(close, start + open.length());\n             if (end != INDEX_NOT_FOUND) {\n                 return str.substring(start + open.length(), end);\n             }\n         if (str == null || isEmpty(open) || isEmpty(close)) {\n             return null;\n         }\n-        int strLen = str.length();\n+        final int strLen = str.length();\n         if (strLen == 0) {\n             return ArrayUtils.EMPTY_STRING_ARRAY;\n         }\n-        int closeLen = close.length();\n-        int openLen = open.length();\n-        List<String> list = new ArrayList<String>();\n+        final int closeLen = close.length();\n+        final int openLen = open.length();\n+        final List<String> list = new ArrayList<String>();\n         int pos = 0;\n         while (pos < strLen - closeLen) {\n             int start = str.indexOf(open, pos);\n                 break;\n             }\n             start += openLen;\n-            int end = str.indexOf(close, start);\n+            final int end = str.indexOf(close, start);\n             if (end < 0) {\n                 break;\n             }\n             return null;\n         }\n \n-        int len = str.length();\n+        final int len = str.length();\n \n         if (len == 0) {\n             return ArrayUtils.EMPTY_STRING_ARRAY;\n             return splitWorker(str, null, max, preserveAllTokens);\n         }\n \n-        int separatorLength = separator.length();\n-\n-        ArrayList<String> substrings = new ArrayList<String>();\n+        final int separatorLength = separator.length();\n+\n+        final ArrayList<String> substrings = new ArrayList<String>();\n         int numberOfSubstrings = 0;\n         int beg = 0;\n         int end = 0;\n         if (str == null) {\n             return null;\n         }\n-        int len = str.length();\n+        final int len = str.length();\n         if (len == 0) {\n             return ArrayUtils.EMPTY_STRING_ARRAY;\n         }\n-        List<String> list = new ArrayList<String>();\n+        final List<String> list = new ArrayList<String>();\n         int i = 0, start = 0;\n         boolean match = false;\n         boolean lastMatch = false;\n         if (str == null) {\n             return null;\n         }\n-        int len = str.length();\n+        final int len = str.length();\n         if (len == 0) {\n             return ArrayUtils.EMPTY_STRING_ARRAY;\n         }\n-        List<String> list = new ArrayList<String>();\n+        final List<String> list = new ArrayList<String>();\n         int sizePlus1 = 1;\n         int i = 0, start = 0;\n         boolean match = false;\n             }\n         } else if (separatorChars.length() == 1) {\n             // Optimise 1 character case\n-            char sep = separatorChars.charAt(0);\n+            final char sep = separatorChars.charAt(0);\n             while (i < len) {\n                 if (str.charAt(i) == sep) {\n                     if (match || preserveAllTokens) {\n         if (str.length() == 0) {\n             return ArrayUtils.EMPTY_STRING_ARRAY;\n         }\n-        char[] c = str.toCharArray();\n-        List<String> list = new ArrayList<String>();\n+        final char[] c = str.toCharArray();\n+        final List<String> list = new ArrayList<String>();\n         int tokenStart = 0;\n         int currentType = Character.getType(c[tokenStart]);\n         for (int pos = tokenStart + 1; pos < c.length; pos++) {\n-            int type = Character.getType(c[pos]);\n+            final int type = Character.getType(c[pos]);\n             if (type == currentType) {\n                 continue;\n             }\n             if (camelCase && type == Character.LOWERCASE_LETTER && currentType == Character.UPPERCASE_LETTER) {\n-                int newTokenStart = pos - 1;\n+                final int newTokenStart = pos - 1;\n                 if (newTokenStart != tokenStart) {\n                     list.add(new String(c, tokenStart, newTokenStart - tokenStart));\n                     tokenStart = newTokenStart;\n         if (array == null) {\n             return null;\n         }\n-        int noOfItems = endIndex - startIndex;\n+        final int noOfItems = endIndex - startIndex;\n         if (noOfItems <= 0) {\n             return EMPTY;\n         }\n-        StringBuilder buf = new StringBuilder(noOfItems * 16);\n+        final StringBuilder buf = new StringBuilder(noOfItems * 16);\n         for (int i = startIndex; i < endIndex; i++) {\n             if (i > startIndex) {\n                 buf.append(separator);\n         if (array == null) {\n             return null;\n         }\n-        int noOfItems = endIndex - startIndex;\n+        final int noOfItems = endIndex - startIndex;\n         if (noOfItems <= 0) {\n             return EMPTY;\n         }\n-        StringBuilder buf = new StringBuilder(noOfItems * 16);\n+        final StringBuilder buf = new StringBuilder(noOfItems * 16);\n         for (int i = startIndex; i < endIndex; i++) {\n             if (i > startIndex) {\n                 buf.append(separator);\n         if (array == null) {\n             return null;\n         }\n-        int noOfItems = endIndex - startIndex;\n+        final int noOfItems = endIndex - startIndex;\n         if (noOfItems <= 0) {\n             return EMPTY;\n         }\n-        StringBuilder buf = new StringBuilder(noOfItems * 16);\n+        final StringBuilder buf = new StringBuilder(noOfItems * 16);\n         for (int i = startIndex; i < endIndex; i++) {\n             if (i > startIndex) {\n                 buf.append(separator);\n         if (array == null) {\n             return null;\n         }\n-        int noOfItems = endIndex - startIndex;\n+        final int noOfItems = endIndex - startIndex;\n         if (noOfItems <= 0) {\n             return EMPTY;\n         }\n-        StringBuilder buf = new StringBuilder(noOfItems * 16);\n+        final StringBuilder buf = new StringBuilder(noOfItems * 16);\n         for (int i = startIndex; i < endIndex; i++) {\n             if (i > startIndex) {\n                 buf.append(separator);\n         if (array == null) {\n             return null;\n         }\n-        int noOfItems = endIndex - startIndex;\n+        final int noOfItems = endIndex - startIndex;\n         if (noOfItems <= 0) {\n             return EMPTY;\n         }\n-        StringBuilder buf = new StringBuilder(noOfItems * 16);\n+        final StringBuilder buf = new StringBuilder(noOfItems * 16);\n         for (int i = startIndex; i < endIndex; i++) {\n             if (i > startIndex) {\n                 buf.append(separator);\n         if (array == null) {\n             return null;\n         }\n-        int noOfItems = endIndex - startIndex;\n+        final int noOfItems = endIndex - startIndex;\n         if (noOfItems <= 0) {\n             return EMPTY;\n         }\n-        StringBuilder buf = new StringBuilder(noOfItems * 16);\n+        final StringBuilder buf = new StringBuilder(noOfItems * 16);\n         for (int i = startIndex; i < endIndex; i++) {\n             if (i > startIndex) {\n                 buf.append(separator);\n         if (array == null) {\n             return null;\n         }\n-        int noOfItems = endIndex - startIndex;\n+        final int noOfItems = endIndex - startIndex;\n         if (noOfItems <= 0) {\n             return EMPTY;\n         }\n-        StringBuilder buf = new StringBuilder(noOfItems * 16);\n+        final StringBuilder buf = new StringBuilder(noOfItems * 16);\n         for (int i = startIndex; i < endIndex; i++) {\n             if (i > startIndex) {\n                 buf.append(separator);\n         if (array == null) {\n             return null;\n         }\n-        int noOfItems = endIndex - startIndex;\n+        final int noOfItems = endIndex - startIndex;\n         if (noOfItems <= 0) {\n             return EMPTY;\n         }\n-        StringBuilder buf = new StringBuilder(noOfItems * 16);\n+        final StringBuilder buf = new StringBuilder(noOfItems * 16);\n         for (int i = startIndex; i < endIndex; i++) {\n             if (i > startIndex) {\n                 buf.append(separator);\n \n         // endIndex - startIndex > 0:   Len = NofStrings *(len(firstString) + len(separator))\n         //           (Assuming that all Strings are roughly equally long)\n-        int noOfItems = endIndex - startIndex;\n+        final int noOfItems = endIndex - startIndex;\n         if (noOfItems <= 0) {\n             return EMPTY;\n         }\n \n-        StringBuilder buf = new StringBuilder(noOfItems * 16);\n+        final StringBuilder buf = new StringBuilder(noOfItems * 16);\n \n         for (int i = startIndex; i < endIndex; i++) {\n             if (i > startIndex) {\n         if (!iterator.hasNext()) {\n             return EMPTY;\n         }\n-        Object first = iterator.next();\n+        final Object first = iterator.next();\n         if (!iterator.hasNext()) {\n             return ObjectUtils.toString(first);\n         }\n \n         // two or more elements\n-        StringBuilder buf = new StringBuilder(256); // Java default is 16, probably too small\n+        final StringBuilder buf = new StringBuilder(256); // Java default is 16, probably too small\n         if (first != null) {\n             buf.append(first);\n         }\n \n         while (iterator.hasNext()) {\n             buf.append(separator);\n-            Object obj = iterator.next();\n+            final Object obj = iterator.next();\n             if (obj != null) {\n                 buf.append(obj);\n             }\n         if (!iterator.hasNext()) {\n             return EMPTY;\n         }\n-        Object first = iterator.next();\n+        final Object first = iterator.next();\n         if (!iterator.hasNext()) {\n             return ObjectUtils.toString(first);\n         }\n \n         // two or more elements\n-        StringBuilder buf = new StringBuilder(256); // Java default is 16, probably too small\n+        final StringBuilder buf = new StringBuilder(256); // Java default is 16, probably too small\n         if (first != null) {\n             buf.append(first);\n         }\n             if (separator != null) {\n                 buf.append(separator);\n             }\n-            Object obj = iterator.next();\n+            final Object obj = iterator.next();\n             if (obj != null) {\n                 buf.append(obj);\n             }\n         if (isEmpty(str)) {\n             return str;\n         }\n-        int sz = str.length();\n-        char[] chs = new char[sz];\n+        final int sz = str.length();\n+        final char[] chs = new char[sz];\n         int count = 0;\n         for (int i = 0; i < sz; i++) {\n             if (!Character.isWhitespace(str.charAt(i))) {\n         if (isEmpty(str) || str.indexOf(remove) == INDEX_NOT_FOUND) {\n             return str;\n         }\n-        char[] chars = str.toCharArray();\n+        final char[] chars = str.toCharArray();\n         int pos = 0;\n         for (int i = 0; i < chars.length; i++) {\n             if (chars[i] != remove) {\n         if (end == INDEX_NOT_FOUND) {\n             return text;\n         }\n-        int replLength = searchString.length();\n+        final int replLength = searchString.length();\n         int increase = replacement.length() - replLength;\n         increase = increase < 0 ? 0 : increase;\n         increase *= max < 0 ? 16 : max > 64 ? 64 : max;\n-        StringBuilder buf = new StringBuilder(text.length() + increase);\n+        final StringBuilder buf = new StringBuilder(text.length() + increase);\n         while (end != INDEX_NOT_FOUND) {\n             buf.append(text.substring(start, end)).append(replacement);\n             start = end + replLength;\n     public static String replaceEachRepeatedly(final String text, final String[] searchList, final String[] replacementList) {\n         // timeToLive should be 0 if not used or nothing to replace, else it's\n         // the length of the replace array\n-        int timeToLive = searchList == null ? 0 : searchList.length;\n+        final int timeToLive = searchList == null ? 0 : searchList.length;\n         return replaceEach(text, searchList, replacementList, true, timeToLive);\n     }\n \n                                             \"output of one loop is the input of another\");\n         }\n \n-        int searchLength = searchList.length;\n-        int replacementLength = replacementList.length;\n+        final int searchLength = searchList.length;\n+        final int replacementLength = replacementList.length;\n \n         // make sure lengths are ok, these need to be equal\n         if (searchLength != replacementLength) {\n         }\n \n         // keep track of which still have matches\n-        boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];\n+        final boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];\n \n         // index on index that the match was found\n         int textIndex = -1;\n             if (searchList[i] == null || replacementList[i] == null) {\n                 continue;\n             }\n-            int greater = replacementList[i].length() - searchList[i].length();\n+            final int greater = replacementList[i].length() - searchList[i].length();\n             if (greater > 0) {\n                 increase += 3 * greater; // assume 3 matches\n             }\n         // have upper-bound at 20% increase, then let Java take over\n         increase = Math.min(increase, text.length() / 5);\n \n-        StringBuilder buf = new StringBuilder(text.length() + increase);\n+        final StringBuilder buf = new StringBuilder(text.length() + increase);\n \n         while (textIndex != -1) {\n \n             // NOTE: logic duplicated above END\n \n         }\n-        int textLength = text.length();\n+        final int textLength = text.length();\n         for (int i = start; i < textLength; i++) {\n             buf.append(text.charAt(i));\n         }\n-        String result = buf.toString();\n+        final String result = buf.toString();\n         if (!repeat) {\n             return result;\n         }\n             replaceChars = EMPTY;\n         }\n         boolean modified = false;\n-        int replaceCharsLength = replaceChars.length();\n-        int strLength = str.length();\n-        StringBuilder buf = new StringBuilder(strLength);\n+        final int replaceCharsLength = replaceChars.length();\n+        final int strLength = str.length();\n+        final StringBuilder buf = new StringBuilder(strLength);\n         for (int i = 0; i < strLength; i++) {\n-            char ch = str.charAt(i);\n-            int index = searchChars.indexOf(ch);\n+            final char ch = str.charAt(i);\n+            final int index = searchChars.indexOf(ch);\n             if (index >= 0) {\n                 modified = true;\n                 if (index < replaceCharsLength) {\n         if (overlay == null) {\n             overlay = EMPTY;\n         }\n-        int len = str.length();\n+        final int len = str.length();\n         if (start < 0) {\n             start = 0;\n         }\n             end = len;\n         }\n         if (start > end) {\n-            int temp = start;\n+            final int temp = start;\n             start = end;\n             end = temp;\n         }\n         }\n \n         if (str.length() == 1) {\n-            char ch = str.charAt(0);\n+            final char ch = str.charAt(0);\n             if (ch == CharUtils.CR || ch == CharUtils.LF) {\n                 return EMPTY;\n             }\n         }\n \n         int lastIdx = str.length() - 1;\n-        char last = str.charAt(lastIdx);\n+        final char last = str.charAt(lastIdx);\n \n         if (last == CharUtils.LF) {\n             if (str.charAt(lastIdx - 1) == CharUtils.CR) {\n         if (str == null) {\n             return null;\n         }\n-        int strLen = str.length();\n+        final int strLen = str.length();\n         if (strLen < 2) {\n             return EMPTY;\n         }\n-        int lastIdx = strLen - 1;\n-        String ret = str.substring(0, lastIdx);\n-        char last = str.charAt(lastIdx);\n+        final int lastIdx = strLen - 1;\n+        final String ret = str.substring(0, lastIdx);\n+        final char last = str.charAt(lastIdx);\n         if (last == CharUtils.LF && ret.charAt(lastIdx - 1) == CharUtils.CR) {\n             return ret.substring(0, lastIdx - 1);\n         }\n         if (repeat <= 0) {\n             return EMPTY;\n         }\n-        int inputLength = str.length();\n+        final int inputLength = str.length();\n         if (repeat == 1 || inputLength == 0) {\n             return str;\n         }\n             return repeat(str.charAt(0), repeat);\n         }\n \n-        int outputLength = inputLength * repeat;\n+        final int outputLength = inputLength * repeat;\n         switch (inputLength) {\n             case 1 :\n                 return repeat(str.charAt(0), repeat);\n             case 2 :\n-                char ch0 = str.charAt(0);\n-                char ch1 = str.charAt(1);\n-                char[] output2 = new char[outputLength];\n+                final char ch0 = str.charAt(0);\n+                final char ch1 = str.charAt(1);\n+                final char[] output2 = new char[outputLength];\n                 for (int i = repeat * 2 - 2; i >= 0; i--, i--) {\n                     output2[i] = ch0;\n                     output2[i + 1] = ch1;\n                 }\n                 return new String(output2);\n             default :\n-                StringBuilder buf = new StringBuilder(outputLength);\n+                final StringBuilder buf = new StringBuilder(outputLength);\n                 for (int i = 0; i < repeat; i++) {\n                     buf.append(str);\n                 }\n             return repeat(str, repeat);\n         } else {\n             // given that repeat(String, int) is quite optimized, better to rely on it than try and splice this into it\n-            String result = repeat(str + separator, repeat);\n+            final String result = repeat(str + separator, repeat);\n             return removeEnd(result, separator);\n         }\n     }\n      * @see #repeat(String, int)\n      */\n     public static String repeat(final char ch, final int repeat) {\n-        char[] buf = new char[repeat];\n+        final char[] buf = new char[repeat];\n         for (int i = repeat - 1; i >= 0; i--) {\n             buf[i] = ch;\n         }\n         if (str == null) {\n             return null;\n         }\n-        int pads = size - str.length();\n+        final int pads = size - str.length();\n         if (pads <= 0) {\n             return str; // returns original String when possible\n         }\n         if (isEmpty(padStr)) {\n             padStr = SPACE;\n         }\n-        int padLen = padStr.length();\n-        int strLen = str.length();\n-        int pads = size - strLen;\n+        final int padLen = padStr.length();\n+        final int strLen = str.length();\n+        final int pads = size - strLen;\n         if (pads <= 0) {\n             return str; // returns original String when possible\n         }\n         } else if (pads < padLen) {\n             return str.concat(padStr.substring(0, pads));\n         } else {\n-            char[] padding = new char[pads];\n-            char[] padChars = padStr.toCharArray();\n+            final char[] padding = new char[pads];\n+            final char[] padChars = padStr.toCharArray();\n             for (int i = 0; i < pads; i++) {\n                 padding[i] = padChars[i % padLen];\n             }\n         if (str == null) {\n             return null;\n         }\n-        int pads = size - str.length();\n+        final int pads = size - str.length();\n         if (pads <= 0) {\n             return str; // returns original String when possible\n         }\n         if (isEmpty(padStr)) {\n             padStr = SPACE;\n         }\n-        int padLen = padStr.length();\n-        int strLen = str.length();\n-        int pads = size - strLen;\n+        final int padLen = padStr.length();\n+        final int strLen = str.length();\n+        final int pads = size - strLen;\n         if (pads <= 0) {\n             return str; // returns original String when possible\n         }\n         } else if (pads < padLen) {\n             return padStr.substring(0, pads).concat(str);\n         } else {\n-            char[] padding = new char[pads];\n-            char[] padChars = padStr.toCharArray();\n+            final char[] padding = new char[pads];\n+            final char[] padChars = padStr.toCharArray();\n             for (int i = 0; i < pads; i++) {\n                 padding[i] = padChars[i % padLen];\n             }\n         if (str == null || size <= 0) {\n             return str;\n         }\n-        int strLen = str.length();\n-        int pads = size - strLen;\n+        final int strLen = str.length();\n+        final int pads = size - strLen;\n         if (pads <= 0) {\n             return str;\n         }\n         if (isEmpty(padStr)) {\n             padStr = SPACE;\n         }\n-        int strLen = str.length();\n-        int pads = size - strLen;\n+        final int strLen = str.length();\n+        final int pads = size - strLen;\n         if (pads <= 0) {\n             return str;\n         }\n             return str;\n         }\n \n-        char[] buffer = str.toCharArray();\n+        final char[] buffer = str.toCharArray();\n \n         for (int i = 0; i < buffer.length; i++) {\n-            char ch = buffer[i];\n+            final char ch = buffer[i];\n             if (Character.isUpperCase(ch)) {\n                 buffer[i] = Character.toLowerCase(ch);\n             } else if (Character.isTitleCase(ch)) {\n         if (cs == null || cs.length() == 0) {\n             return false;\n         }\n-        int sz = cs.length();\n+        final int sz = cs.length();\n         for (int i = 0; i < sz; i++) {\n             if (Character.isLetter(cs.charAt(i)) == false) {\n                 return false;\n         if (cs == null) {\n             return false;\n         }\n-        int sz = cs.length();\n+        final int sz = cs.length();\n         for (int i = 0; i < sz; i++) {\n             if (Character.isLetter(cs.charAt(i)) == false && cs.charAt(i) != ' ') {\n                 return false;\n         if (cs == null || cs.length() == 0) {\n             return false;\n         }\n-        int sz = cs.length();\n+        final int sz = cs.length();\n         for (int i = 0; i < sz; i++) {\n             if (Character.isLetterOrDigit(cs.charAt(i)) == false) {\n                 return false;\n         if (cs == null) {\n             return false;\n         }\n-        int sz = cs.length();\n+        final int sz = cs.length();\n         for (int i = 0; i < sz; i++) {\n             if (Character.isLetterOrDigit(cs.charAt(i)) == false && cs.charAt(i) != ' ') {\n                 return false;\n         if (cs == null) {\n             return false;\n         }\n-        int sz = cs.length();\n+        final int sz = cs.length();\n         for (int i = 0; i < sz; i++) {\n             if (CharUtils.isAsciiPrintable(cs.charAt(i)) == false) {\n                 return false;\n         if (cs == null || cs.length() == 0) {\n             return false;\n         }\n-        int sz = cs.length();\n+        final int sz = cs.length();\n         for (int i = 0; i < sz; i++) {\n             if (Character.isDigit(cs.charAt(i)) == false) {\n                 return false;\n         if (cs == null) {\n             return false;\n         }\n-        int sz = cs.length();\n+        final int sz = cs.length();\n         for (int i = 0; i < sz; i++) {\n             if (Character.isDigit(cs.charAt(i)) == false && cs.charAt(i) != ' ') {\n                 return false;\n         if (cs == null) {\n             return false;\n         }\n-        int sz = cs.length();\n+        final int sz = cs.length();\n         for (int i = 0; i < sz; i++) {\n             if (Character.isWhitespace(cs.charAt(i)) == false) {\n                 return false;\n         if (cs == null || isEmpty(cs)) {\n             return false;\n         }\n-        int sz = cs.length();\n+        final int sz = cs.length();\n         for (int i = 0; i < sz; i++) {\n             if (Character.isLowerCase(cs.charAt(i)) == false) {\n                 return false;\n         if (cs == null || isEmpty(cs)) {\n             return false;\n         }\n-        int sz = cs.length();\n+        final int sz = cs.length();\n         for (int i = 0; i < sz; i++) {\n             if (Character.isUpperCase(cs.charAt(i)) == false) {\n                 return false;\n         }\n         // could implement manually, but simple way is to reuse other,\n         // probably slower, methods.\n-        String[] strs = split(str, separatorChar);\n+        final String[] strs = split(str, separatorChar);\n         ArrayUtils.reverse(strs);\n         return join(strs, separatorChar);\n     }\n             return str;\n         }\n \n-        int targetSting = length-middle.length();\n-        int startOffset = targetSting/2+targetSting%2;\n-        int endOffset = str.length()-targetSting/2;\n-\n-        StringBuilder builder = new StringBuilder(length);\n+        final int targetSting = length-middle.length();\n+        final int startOffset = targetSting/2+targetSting%2;\n+        final int endOffset = str.length()-targetSting/2;\n+\n+        final StringBuilder builder = new StringBuilder(length);\n         builder.append(str.substring(0,startOffset));\n         builder.append(middle);\n         builder.append(str.substring(endOffset));\n         if (str2 == null) {\n             return str1;\n         }\n-        int at = indexOfDifference(str1, str2);\n+        final int at = indexOfDifference(str1, str2);\n         if (at == INDEX_NOT_FOUND) {\n             return EMPTY;\n         }\n         }\n         boolean anyStringNull = false;\n         boolean allStringsNull = true;\n-        int arrayLen = css.length;\n+        final int arrayLen = css.length;\n         int shortestStrLen = Integer.MAX_VALUE;\n         int longestStrLen = 0;\n \n         // find the position with the first difference across all strings\n         int firstDiff = -1;\n         for (int stringPos = 0; stringPos < shortestStrLen; stringPos++) {\n-            char comparisonChar = css[0].charAt(stringPos);\n+            final char comparisonChar = css[0].charAt(stringPos);\n             for (int arrayPos = 1; arrayPos < arrayLen; arrayPos++) {\n                 if (css[arrayPos].charAt(stringPos) != comparisonChar) {\n                     firstDiff = stringPos;\n         if (strs == null || strs.length == 0) {\n             return EMPTY;\n         }\n-        int smallestIndexOfDiff = indexOfDifference(strs);\n+        final int smallestIndexOfDiff = indexOfDifference(strs);\n         if (smallestIndexOfDiff == INDEX_NOT_FOUND) {\n             // all strings were identical\n             if (strs[0] == null) {\n \n         if (n > m) {\n             // swap the input strings to consume less memory\n-            CharSequence tmp = s;\n+            final CharSequence tmp = s;\n             s = t;\n             t = tmp;\n             n = m;\n \n         if (n > m) {\n             // swap the two strings to consume less memory\n-            CharSequence tmp = s;\n+            final CharSequence tmp = s;\n             s = t;\n             t = tmp;\n             n = m;\n         int _d[]; // placeholder to assist in swapping p and d\n \n         // fill in starting table values\n-        int boundary = Math.min(n, threshold) + 1;\n+        final int boundary = Math.min(n, threshold) + 1;\n         for (int i = 0; i < boundary; i++) {\n             p[i] = i;\n         }\n \n         // iterates through t\n         for (int j = 1; j <= m; j++) {\n-            char t_j = t.charAt(j - 1); // jth character of t\n+            final char t_j = t.charAt(j - 1); // jth character of t\n             d[0] = j;\n \n             // compute stripe indices, constrain to array size\n-            int min = Math.max(1, j - threshold);\n-            int max = Math.min(n, j + threshold);\n+            final int min = Math.max(1, j - threshold);\n+            final int max = Math.min(n, j + threshold);\n \n             // the stripe may lead off of the table if s and t are of different sizes\n             if (min > max) {\n         if (isEmpty(string) || ArrayUtils.isEmpty(searchStrings)) {\n             return false;\n         }\n-        for (CharSequence searchString : searchStrings) {\n+        for (final CharSequence searchString : searchStrings) {\n             if (StringUtils.startsWith(string, searchString)) {\n                 return true;\n             }\n         if (suffix.length() > str.length()) {\n             return false;\n         }\n-        int strOffset = str.length() - suffix.length();\n+        final int strOffset = str.length() - suffix.length();\n         return CharSequenceUtils.regionMatches(str, ignoreCase, strOffset, suffix, 0, suffix.length());\n     }\n \n         if (isEmpty(string) || ArrayUtils.isEmpty(searchStrings)) {\n             return false;\n         }\n-        for (CharSequence searchString : searchStrings) {\n+        for (final CharSequence searchString : searchStrings) {\n             if (StringUtils.endsWith(string, searchString)) {\n                 return true;\n             }\n--- a/src/main/java/org/apache/commons/lang3/SystemUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/SystemUtils.java\n     private static String getSystemProperty(final String property) {\n         try {\n             return System.getProperty(property);\n-        } catch (SecurityException ex) {\n+        } catch (final SecurityException ex) {\n             // we are not allowed to look at this property\n             System.err.println(\"Caught a SecurityException reading the system property '\" + property\n                     + \"'; the SystemUtils property value will default to null.\");\n--- a/src/main/java/org/apache/commons/lang3/Validate.java\n+++ b/src/main/java/org/apache/commons/lang3/Validate.java\n         Validate.notNull(array);\n         for (int i = 0; i < array.length; i++) {\n             if (array[i] == null) {\n-                Object[] values2 = ArrayUtils.add(values, Integer.valueOf(i));\n+                final Object[] values2 = ArrayUtils.add(values, Integer.valueOf(i));\n                 throw new IllegalArgumentException(String.format(message, values2));\n             }\n         }\n     public static <T extends Iterable<?>> T noNullElements(final T iterable, final String message, final Object... values) {\n         Validate.notNull(iterable);\n         int i = 0;\n-        for (Iterator<?> it = iterable.iterator(); it.hasNext(); i++) {\n+        for (final Iterator<?> it = iterable.iterator(); it.hasNext(); i++) {\n             if (it.next() == null) {\n-                Object[] values2 = ArrayUtils.addAll(values, Integer.valueOf(i));\n+                final Object[] values2 = ArrayUtils.addAll(values, Integer.valueOf(i));\n                 throw new IllegalArgumentException(String.format(message, values2));\n             }\n         }\n--- a/src/main/java/org/apache/commons/lang3/builder/CompareToBuilder.java\n+++ b/src/main/java/org/apache/commons/lang3/builder/CompareToBuilder.java\n         if (!lhsClazz.isInstance(rhs)) {\n             throw new ClassCastException();\n         }\n-        CompareToBuilder compareToBuilder = new CompareToBuilder();\n+        final CompareToBuilder compareToBuilder = new CompareToBuilder();\n         reflectionAppend(lhs, rhs, lhsClazz, compareToBuilder, compareTransients, excludeFields);\n         while (lhsClazz.getSuperclass() != null && lhsClazz != reflectUpToClass) {\n             lhsClazz = lhsClazz.getSuperclass();\n         final boolean useTransients,\n         final String[] excludeFields) {\n         \n-        Field[] fields = clazz.getDeclaredFields();\n+        final Field[] fields = clazz.getDeclaredFields();\n         AccessibleObject.setAccessible(fields, true);\n         for (int i = 0; i < fields.length && builder.comparison == 0; i++) {\n-            Field f = fields[i];\n+            final Field f = fields[i];\n             if (!ArrayUtils.contains(excludeFields, f.getName())\n                 && (f.getName().indexOf('$') == -1)\n                 && (useTransients || !Modifier.isTransient(f.getModifiers()))\n                 && (!Modifier.isStatic(f.getModifiers()))) {\n                 try {\n                     builder.append(f.get(lhs), f.get(rhs));\n-                } catch (IllegalAccessException e) {\n+                } catch (final IllegalAccessException e) {\n                     // This can't happen. Would get a Security exception instead.\n                     // Throw a runtime exception in case the impossible happens.\n                     throw new InternalError(\"Unexpected IllegalAccessException\");\n--- a/src/main/java/org/apache/commons/lang3/builder/EqualsBuilder.java\n+++ b/src/main/java/org/apache/commons/lang3/builder/EqualsBuilder.java\n      * @return the pair\n      */\n     static Pair<IDKey, IDKey> getRegisterPair(final Object lhs, final Object rhs) {\n-        IDKey left = new IDKey(lhs);\n-        IDKey right = new IDKey(rhs);\n+        final IDKey left = new IDKey(lhs);\n+        final IDKey right = new IDKey(rhs);\n         return Pair.of(left, right);\n     }\n \n      * @since 3.0\n      */\n     static boolean isRegistered(final Object lhs, final Object rhs) {\n-        Set<Pair<IDKey, IDKey>> registry = getRegistry();\n-        Pair<IDKey, IDKey> pair = getRegisterPair(lhs, rhs);\n-        Pair<IDKey, IDKey> swappedPair = Pair.of(pair.getLeft(), pair.getRight());\n+        final Set<Pair<IDKey, IDKey>> registry = getRegistry();\n+        final Pair<IDKey, IDKey> pair = getRegisterPair(lhs, rhs);\n+        final Pair<IDKey, IDKey> swappedPair = Pair.of(pair.getLeft(), pair.getRight());\n \n         return registry != null\n                 && (registry.contains(pair) || registry.contains(swappedPair));\n             }\n         }\n \n-        Set<Pair<IDKey, IDKey>> registry = getRegistry();\n-        Pair<IDKey, IDKey> pair = getRegisterPair(lhs, rhs);\n+        final Set<Pair<IDKey, IDKey>> registry = getRegistry();\n+        final Pair<IDKey, IDKey> pair = getRegisterPair(lhs, rhs);\n         registry.add(pair);\n     }\n \n     static void unregister(final Object lhs, final Object rhs) {\n         Set<Pair<IDKey, IDKey>> registry = getRegistry();\n         if (registry != null) {\n-            Pair<IDKey, IDKey> pair = getRegisterPair(lhs, rhs);\n+            final Pair<IDKey, IDKey> pair = getRegisterPair(lhs, rhs);\n             registry.remove(pair);\n             synchronized (EqualsBuilder.class) {\n                 //read again\n         // class or in classes between the leaf and root.\n         // If we are not testing transients or a subclass has no ivars,\n         // then a subclass can test equals to a superclass.\n-        Class<?> lhsClass = lhs.getClass();\n-        Class<?> rhsClass = rhs.getClass();\n+        final Class<?> lhsClass = lhs.getClass();\n+        final Class<?> rhsClass = rhs.getClass();\n         Class<?> testClass;\n         if (lhsClass.isInstance(rhs)) {\n             testClass = lhsClass;\n             // The two classes are not related.\n             return false;\n         }\n-        EqualsBuilder equalsBuilder = new EqualsBuilder();\n+        final EqualsBuilder equalsBuilder = new EqualsBuilder();\n         try {\n             reflectionAppend(lhs, rhs, testClass, equalsBuilder, testTransients, excludeFields);\n             while (testClass.getSuperclass() != null && testClass != reflectUpToClass) {\n                 testClass = testClass.getSuperclass();\n                 reflectionAppend(lhs, rhs, testClass, equalsBuilder, testTransients, excludeFields);\n             }\n-        } catch (IllegalArgumentException e) {\n+        } catch (final IllegalArgumentException e) {\n             // In this case, we tried to test a subclass vs. a superclass and\n             // the subclass has ivars or the ivars are transient and\n             // we are testing transients.\n \n         try {\n             register(lhs, rhs);\n-            Field[] fields = clazz.getDeclaredFields();\n+            final Field[] fields = clazz.getDeclaredFields();\n             AccessibleObject.setAccessible(fields, true);\n             for (int i = 0; i < fields.length && builder.isEquals; i++) {\n-                Field f = fields[i];\n+                final Field f = fields[i];\n                 if (!ArrayUtils.contains(excludeFields, f.getName())\n                     && (f.getName().indexOf('$') == -1)\n                     && (useTransients || !Modifier.isTransient(f.getModifiers()))\n                     && (!Modifier.isStatic(f.getModifiers()))) {\n                     try {\n                         builder.append(f.get(lhs), f.get(rhs));\n-                    } catch (IllegalAccessException e) {\n+                    } catch (final IllegalAccessException e) {\n                         //this can't happen. Would get a Security exception instead\n                         //throw a runtime exception in case the impossible happens.\n                         throw new InternalError(\"Unexpected IllegalAccessException\");\n             this.setEquals(false);\n             return this;\n         }\n-        Class<?> lhsClass = lhs.getClass();\n+        final Class<?> lhsClass = lhs.getClass();\n         if (!lhsClass.isArray()) {\n             // The simple case, not an array, just test the element\n             isEquals = lhs.equals(rhs);\n--- a/src/main/java/org/apache/commons/lang3/builder/HashCodeBuilder.java\n+++ b/src/main/java/org/apache/commons/lang3/builder/HashCodeBuilder.java\n      * @since 2.3\n      */\n     static boolean isRegistered(final Object value) {\n-        Set<IDKey> registry = getRegistry();\n+        final Set<IDKey> registry = getRegistry();\n         return registry != null && registry.contains(new IDKey(value));\n     }\n \n         }\n         try {\n             register(object);\n-            Field[] fields = clazz.getDeclaredFields();\n+            final Field[] fields = clazz.getDeclaredFields();\n             AccessibleObject.setAccessible(fields, true);\n-            for (Field field : fields) {\n+            for (final Field field : fields) {\n                 if (!ArrayUtils.contains(excludeFields, field.getName())\n                     && (field.getName().indexOf('$') == -1)\n                     && (useTransients || !Modifier.isTransient(field.getModifiers()))\n                     && (!Modifier.isStatic(field.getModifiers()))) {\n                     try {\n-                        Object fieldValue = field.get(object);\n+                        final Object fieldValue = field.get(object);\n                         builder.append(fieldValue);\n-                    } catch (IllegalAccessException e) {\n+                    } catch (final IllegalAccessException e) {\n                         // this can't happen. Would get a Security exception instead\n                         // throw a runtime exception in case the impossible happens.\n                         throw new InternalError(\"Unexpected IllegalAccessException\");\n         if (object == null) {\n             throw new IllegalArgumentException(\"The object to build a hash code for must not be null\");\n         }\n-        HashCodeBuilder builder = new HashCodeBuilder(initialNonZeroOddNumber, multiplierNonZeroOddNumber);\n+        final HashCodeBuilder builder = new HashCodeBuilder(initialNonZeroOddNumber, multiplierNonZeroOddNumber);\n         Class<?> clazz = object.getClass();\n         reflectionAppend(object, clazz, builder, testTransients, excludeFields);\n         while (clazz.getSuperclass() != null && clazz != reflectUpToClass) {\n         if (array == null) {\n             iTotal = iTotal * iConstant;\n         } else {\n-            for (boolean element : array) {\n+            for (final boolean element : array) {\n                 append(element);\n             }\n         }\n         if (array == null) {\n             iTotal = iTotal * iConstant;\n         } else {\n-            for (byte element : array) {\n+            for (final byte element : array) {\n                 append(element);\n             }\n         }\n         if (array == null) {\n             iTotal = iTotal * iConstant;\n         } else {\n-            for (char element : array) {\n+            for (final char element : array) {\n                 append(element);\n             }\n         }\n         if (array == null) {\n             iTotal = iTotal * iConstant;\n         } else {\n-            for (double element : array) {\n+            for (final double element : array) {\n                 append(element);\n             }\n         }\n         if (array == null) {\n             iTotal = iTotal * iConstant;\n         } else {\n-            for (float element : array) {\n+            for (final float element : array) {\n                 append(element);\n             }\n         }\n         if (array == null) {\n             iTotal = iTotal * iConstant;\n         } else {\n-            for (int element : array) {\n+            for (final int element : array) {\n                 append(element);\n             }\n         }\n         if (array == null) {\n             iTotal = iTotal * iConstant;\n         } else {\n-            for (long element : array) {\n+            for (final long element : array) {\n                 append(element);\n             }\n         }\n         if (array == null) {\n             iTotal = iTotal * iConstant;\n         } else {\n-            for (Object element : array) {\n+            for (final Object element : array) {\n                 append(element);\n             }\n         }\n         if (array == null) {\n             iTotal = iTotal * iConstant;\n         } else {\n-            for (short element : array) {\n+            for (final short element : array) {\n                 append(element);\n             }\n         }\n--- a/src/main/java/org/apache/commons/lang3/builder/IDKey.java\n+++ b/src/main/java/org/apache/commons/lang3/builder/IDKey.java\n             if (!(other instanceof IDKey)) {\n                 return false;\n             }\n-            IDKey idKey = (IDKey) other;\n+            final IDKey idKey = (IDKey) other;\n             if (id != idKey.id) {\n                 return false;\n             }\n--- a/src/main/java/org/apache/commons/lang3/builder/ReflectionToStringBuilder.java\n+++ b/src/main/java/org/apache/commons/lang3/builder/ReflectionToStringBuilder.java\n      * @return The given array or a new array without null.\n      */\n     static String[] toNoNullStringArray(final Object[] array) {\n-        List<String> list = new ArrayList<String>(array.length);\n-        for (Object e : array) {\n+        final List<String> list = new ArrayList<String>(array.length);\n+        for (final Object e : array) {\n             if (e != null) {\n                 list.add(e.toString());\n             }\n             this.reflectionAppendArray(this.getObject());\n             return;\n         }\n-        Field[] fields = clazz.getDeclaredFields();\n+        final Field[] fields = clazz.getDeclaredFields();\n         AccessibleObject.setAccessible(fields, true);\n-        for (Field field : fields) {\n-            String fieldName = field.getName();\n+        for (final Field field : fields) {\n+            final String fieldName = field.getName();\n             if (this.accept(field)) {\n                 try {\n                     // Warning: Field.get(Object) creates wrappers objects\n                     // for primitive types.\n-                    Object fieldValue = this.getValue(field);\n+                    final Object fieldValue = this.getValue(field);\n                     this.append(fieldName, fieldValue);\n-                } catch (IllegalAccessException ex) {\n+                } catch (final IllegalAccessException ex) {\n                     //this can't happen. Would get a Security exception\n                     // instead\n                     //throw a runtime exception in case the impossible\n      */\n     public void setUpToClass(final Class<?> clazz) {\n         if (clazz != null) {\n-            Object object = getObject();\n+            final Object object = getObject();\n             if (object != null && clazz.isInstance(object) == false) {\n                 throw new IllegalArgumentException(\"Specified class is not a superclass of the object\");\n             }\n--- a/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java\n+++ b/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java\n      *             object.\n      */\n     static boolean isRegistered(final Object value) {\n-        Map<Object, Object> m = getRegistry();\n+        final Map<Object, Object> m = getRegistry();\n         return m != null && m.containsKey(value);\n     }\n \n      */\n     static void register(final Object value) {\n         if (value != null) {\n-            Map<Object, Object> m = getRegistry();\n+            final Map<Object, Object> m = getRegistry();\n             if (m == null) {\n                 REGISTRY.set(new WeakHashMap<Object, Object>());\n             }\n      */\n     static void unregister(final Object value) {\n         if (value != null) {\n-            Map<Object, Object> m = getRegistry();\n+            final Map<Object, Object> m = getRegistry();\n             if (m != null) {\n                 m.remove(value);\n                 if (m.isEmpty()) {\n      */\n     public void appendToString(final StringBuffer buffer, final String toString) {\n         if (toString != null) {\n-            int pos1 = toString.indexOf(contentStart) + contentStart.length();\n-            int pos2 = toString.lastIndexOf(contentEnd);\n+            final int pos1 = toString.indexOf(contentStart) + contentStart.length();\n+            final int pos2 = toString.lastIndexOf(contentEnd);\n             if (pos1 != pos2 && pos1 >= 0 && pos2 >= 0) {\n-                String data = toString.substring(pos1, pos2);\n+                final String data = toString.substring(pos1, pos2);\n                 if (fieldSeparatorAtStart) {\n                     removeLastFieldSeparator(buffer);\n                 }\n      * @since 2.0\n      */\n     protected void removeLastFieldSeparator(final StringBuffer buffer) {\n-        int len = buffer.length();\n-        int sepLen = fieldSeparator.length();\n+        final int len = buffer.length();\n+        final int sepLen = fieldSeparator.length();\n         if (len > 0 && sepLen > 0 && len >= sepLen) {\n             boolean match = true;\n             for (int i = 0; i < sepLen; i++) {\n     protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array) {\n         buffer.append(arrayStart);\n         for (int i = 0; i < array.length; i++) {\n-            Object item = array[i];\n+            final Object item = array[i];\n             if (i > 0) {\n                 buffer.append(arraySeparator);\n             }\n      */\n     protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array) {\n         buffer.append(arrayStart);\n-        int length = Array.getLength(array);\n+        final int length = Array.getLength(array);\n         for (int i = 0; i < length; i++) {\n-            Object item = Array.get(array, i);\n+            final Object item = Array.get(array, i);\n             if (i > 0) {\n                 buffer.append(arraySeparator);\n             }\n--- a/src/main/java/org/apache/commons/lang3/concurrent/BackgroundInitializer.java\n+++ b/src/main/java/org/apache/commons/lang3/concurrent/BackgroundInitializer.java\n     public T get() throws ConcurrentException {\n         try {\n             return getFuture().get();\n-        } catch (ExecutionException execex) {\n+        } catch (final ExecutionException execex) {\n             ConcurrentUtils.handleCause(execex);\n             return null; // should not be reached\n-        } catch (InterruptedException iex) {\n+        } catch (final InterruptedException iex) {\n             // reset interrupted state\n             Thread.currentThread().interrupt();\n             throw new ConcurrentException(iex);\n--- a/src/main/java/org/apache/commons/lang3/concurrent/BasicThreadFactory.java\n+++ b/src/main/java/org/apache/commons/lang3/concurrent/BasicThreadFactory.java\n      */\n     @Override\n     public Thread newThread(final Runnable r) {\n-        Thread t = getWrappedFactory().newThread(r);\n+        final Thread t = getWrappedFactory().newThread(r);\n         initializeThread(t);\n \n         return t;\n     private void initializeThread(final Thread t) {\n \n         if (getNamingPattern() != null) {\n-            Long count = Long.valueOf(threadCounter.incrementAndGet());\n+            final Long count = Long.valueOf(threadCounter.incrementAndGet());\n             t.setName(String.format(getNamingPattern(), count));\n         }\n \n          */\n         @Override\n         public BasicThreadFactory build() {\n-            BasicThreadFactory factory = new BasicThreadFactory(this);\n+            final BasicThreadFactory factory = new BasicThreadFactory(this);\n             reset();\n             return factory;\n         }\n--- a/src/main/java/org/apache/commons/lang3/concurrent/ConcurrentUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/concurrent/ConcurrentUtils.java\n      */\n     public static void handleCause(final ExecutionException ex)\n             throws ConcurrentException {\n-        ConcurrentException cex = extractCause(ex);\n+        final ConcurrentException cex = extractCause(ex);\n \n         if (cex != null) {\n             throw cex;\n      * wrapped in the thrown runtime exception\n      */\n     public static void handleCauseUnchecked(final ExecutionException ex) {\n-        ConcurrentRuntimeException crex = extractCauseUnchecked(ex);\n+        final ConcurrentRuntimeException crex = extractCauseUnchecked(ex);\n \n         if (crex != null) {\n             throw crex;\n     public static <T> T initializeUnchecked(final ConcurrentInitializer<T> initializer) {\n         try {\n             return initialize(initializer);\n-        } catch (ConcurrentException cex) {\n+        } catch (final ConcurrentException cex) {\n             throw new ConcurrentRuntimeException(cex.getCause());\n         }\n     }\n             return null;\n         }\n \n-        V result = map.putIfAbsent(key, value);\n+        final V result = map.putIfAbsent(key, value);\n         return result != null ? result : value;\n     }\n \n             return null;\n         }\n \n-        V value = map.get(key);\n+        final V value = map.get(key);\n         if (value == null) {\n             return putIfAbsent(map, key, init.get());\n         }\n             final K key, final ConcurrentInitializer<V> init) {\n         try {\n             return createIfAbsent(map, key, init);\n-        } catch (ConcurrentException cex) {\n+        } catch (final ConcurrentException cex) {\n             throw new ConcurrentRuntimeException(cex.getCause());\n         }\n     }\n--- a/src/main/java/org/apache/commons/lang3/concurrent/ConstantInitializer.java\n+++ b/src/main/java/org/apache/commons/lang3/concurrent/ConstantInitializer.java\n             return false;\n         }\n \n-        ConstantInitializer<?> c = (ConstantInitializer<?>) obj;\n+        final ConstantInitializer<?> c = (ConstantInitializer<?>) obj;\n         return ObjectUtils.equals(getObject(), c.getObject());\n     }\n \n--- a/src/main/java/org/apache/commons/lang3/concurrent/MultiBackgroundInitializer.java\n+++ b/src/main/java/org/apache/commons/lang3/concurrent/MultiBackgroundInitializer.java\n     protected int getTaskCount() {\n         int result = 1;\n \n-        for (BackgroundInitializer<?> bi : childInitializers.values()) {\n+        for (final BackgroundInitializer<?> bi : childInitializers.values()) {\n             result += bi.getTaskCount();\n         }\n \n         }\n \n         // start the child initializers\n-        ExecutorService exec = getActiveExecutor();\n-        for (BackgroundInitializer<?> bi : inits.values()) {\n+        final ExecutorService exec = getActiveExecutor();\n+        for (final BackgroundInitializer<?> bi : inits.values()) {\n             if (bi.getExternalExecutor() == null) {\n                 // share the executor service if necessary\n                 bi.setExternalExecutor(exec);\n         }\n \n         // collect the results\n-        Map<String, Object> results = new HashMap<String, Object>();\n-        Map<String, ConcurrentException> excepts = new HashMap<String, ConcurrentException>();\n-        for (Map.Entry<String, BackgroundInitializer<?>> e : inits.entrySet()) {\n+        final Map<String, Object> results = new HashMap<String, Object>();\n+        final Map<String, ConcurrentException> excepts = new HashMap<String, ConcurrentException>();\n+        for (final Map.Entry<String, BackgroundInitializer<?>> e : inits.entrySet()) {\n             try {\n                 results.put(e.getKey(), e.getValue().get());\n-            } catch (ConcurrentException cex) {\n+            } catch (final ConcurrentException cex) {\n                 excepts.put(e.getKey(), cex);\n             }\n         }\n          * @throws NoSuchElementException if the name is unknown\n          */\n         private BackgroundInitializer<?> checkName(final String name) {\n-            BackgroundInitializer<?> init = initializers.get(name);\n+            final BackgroundInitializer<?> init = initializers.get(name);\n             if (init == null) {\n                 throw new NoSuchElementException(\n                         \"No child initializer with name \" + name);\n--- a/src/main/java/org/apache/commons/lang3/concurrent/TimedSemaphore.java\n+++ b/src/main/java/org/apache/commons/lang3/concurrent/TimedSemaphore.java\n             executorService = service;\n             ownExecutor = false;\n         } else {\n-            ScheduledThreadPoolExecutor s = new ScheduledThreadPoolExecutor(\n+            final ScheduledThreadPoolExecutor s = new ScheduledThreadPoolExecutor(\n                     THREAD_POOL_SIZE);\n             s.setContinueExistingPeriodicTasksAfterShutdownPolicy(false);\n             s.setExecuteExistingDelayedTasksAfterShutdownPolicy(false);\n--- a/src/main/java/org/apache/commons/lang3/event/EventListenerSupport.java\n+++ b/src/main/java/org/apache/commons/lang3/event/EventListenerSupport.java\n      * @throws IOException if an IO error occurs\n      */\n     private void writeObject(final ObjectOutputStream objectOutputStream) throws IOException {\n-        ArrayList<L> serializableListeners = new ArrayList<L>();\n+        final ArrayList<L> serializableListeners = new ArrayList<L>();\n \n         // don't just rely on instanceof Serializable:\n         ObjectOutputStream testObjectOutputStream = new ObjectOutputStream(new ByteArrayOutputStream());\n-        for (L listener : listeners) {\n+        for (final L listener : listeners) {\n             try {\n                 testObjectOutputStream.writeObject(listener);\n                 serializableListeners.add(listener);\n-            } catch (IOException exception) {\n+            } catch (final IOException exception) {\n                 //recreate test stream in case of indeterminate state\n                 testObjectOutputStream = new ObjectOutputStream(new ByteArrayOutputStream());\n             }\n      */\n     private void readObject(final ObjectInputStream objectInputStream) throws IOException, ClassNotFoundException {\n         @SuppressWarnings(\"unchecked\") // Will throw CCE here if not correct\n+        final\n         L[] listeners = (L[]) objectInputStream.readObject();\n \n         this.listeners = new CopyOnWriteArrayList<L>(listeners);\n \n         @SuppressWarnings(\"unchecked\") // Will throw CCE here if not correct\n+        final\n         Class<L> listenerInterface = (Class<L>) listeners.getClass().getComponentType();\n \n         initializeTransientFields(listenerInterface, Thread.currentThread().getContextClassLoader());\n      */\n     private void initializeTransientFields(final Class<L> listenerInterface, final ClassLoader classLoader) {\n         @SuppressWarnings(\"unchecked\") // Will throw CCE here if not correct\n+        final\n         L[] array = (L[]) Array.newInstance(listenerInterface, 0);\n         this.prototypeArray = array;\n         createProxy(listenerInterface, classLoader);\n          */\n         @Override\n         public Object invoke(final Object proxy, final Method method, final Object[] args) throws Throwable {\n-            for (L listener : listeners) {\n+            for (final L listener : listeners) {\n                 method.invoke(listener, args);\n             }\n             return null;\n--- a/src/main/java/org/apache/commons/lang3/event/EventUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/event/EventUtils.java\n     public static <L> void addEventListener(final Object eventSource, final Class<L> listenerType, final L listener) {\n         try {\n             MethodUtils.invokeMethod(eventSource, \"add\" + listenerType.getSimpleName(), listener);\n-        } catch (NoSuchMethodException e) {\n+        } catch (final NoSuchMethodException e) {\n             throw new IllegalArgumentException(\"Class \" + eventSource.getClass().getName()\n                     + \" does not have a public add\" + listenerType.getSimpleName()\n                     + \" method which takes a parameter of type \" + listenerType.getName() + \".\");\n-        } catch (IllegalAccessException e) {\n+        } catch (final IllegalAccessException e) {\n             throw new IllegalArgumentException(\"Class \" + eventSource.getClass().getName()\n                     + \" does not have an accessible add\" + listenerType.getSimpleName ()\n                     + \" method which takes a parameter of type \" + listenerType.getName() + \".\");\n-        } catch (InvocationTargetException e) {\n+        } catch (final InvocationTargetException e) {\n             throw new RuntimeException(\"Unable to add listener.\", e.getCause());\n         }\n     }\n--- a/src/main/java/org/apache/commons/lang3/exception/DefaultExceptionContext.java\n+++ b/src/main/java/org/apache/commons/lang3/exception/DefaultExceptionContext.java\n      */\n     @Override\n     public String getFormattedExceptionMessage(final String baseMessage){\n-        StringBuilder buffer = new StringBuilder(256);\n+        final StringBuilder buffer = new StringBuilder(256);\n         if (baseMessage != null) {\n             buffer.append(baseMessage);\n         }\n                     String valueStr;\n                     try {\n                         valueStr = value.toString();\n-                    } catch (Exception e) {\n+                    } catch (final Exception e) {\n                         valueStr = \"Exception thrown on toString(): \" + ExceptionUtils.getStackTrace(e);\n                     }\n                     buffer.append(valueStr);\n--- a/src/main/java/org/apache/commons/lang3/exception/ExceptionUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/exception/ExceptionUtils.java\n             methodNames = CAUSE_METHOD_NAMES;\n         }\n \n-        for (String methodName : methodNames) {\n+        for (final String methodName : methodNames) {\n             if (methodName != null) {\n-                Throwable cause = getCauseUsingMethodName(throwable, methodName);\n+                final Throwable cause = getCauseUsingMethodName(throwable, methodName);\n                 if (cause != null) {\n                     return cause;\n                 }\n      *  <code>null</code> if none found or null throwable input\n      */\n     public static Throwable getRootCause(final Throwable throwable) {\n-        List<Throwable> list = getThrowableList(throwable);\n+        final List<Throwable> list = getThrowableList(throwable);\n         return list.size() < 2 ? null : (Throwable)list.get(list.size() - 1);\n     }\n \n         Method method = null;\n         try {\n             method = throwable.getClass().getMethod(methodName);\n-        } catch (NoSuchMethodException ignored) { // NOPMD\n+        } catch (final NoSuchMethodException ignored) { // NOPMD\n             // exception ignored\n-        } catch (SecurityException ignored) { // NOPMD\n+        } catch (final SecurityException ignored) { // NOPMD\n             // exception ignored\n         }\n \n         if (method != null && Throwable.class.isAssignableFrom(method.getReturnType())) {\n             try {\n                 return (Throwable) method.invoke(throwable);\n-            } catch (IllegalAccessException ignored) { // NOPMD\n+            } catch (final IllegalAccessException ignored) { // NOPMD\n                 // exception ignored\n-            } catch (IllegalArgumentException ignored) { // NOPMD\n+            } catch (final IllegalArgumentException ignored) { // NOPMD\n                 // exception ignored\n-            } catch (InvocationTargetException ignored) { // NOPMD\n+            } catch (final InvocationTargetException ignored) { // NOPMD\n                 // exception ignored\n             }\n         }\n      * @return the array of throwables, never null\n      */\n     public static Throwable[] getThrowables(final Throwable throwable) {\n-        List<Throwable> list = getThrowableList(throwable);\n+        final List<Throwable> list = getThrowableList(throwable);\n         return list.toArray(new Throwable[list.size()]);\n     }\n \n      * @since Commons Lang 2.2\n      */\n     public static List<Throwable> getThrowableList(Throwable throwable) {\n-        List<Throwable> list = new ArrayList<Throwable>();\n+        final List<Throwable> list = new ArrayList<Throwable>();\n         while (throwable != null && list.contains(throwable) == false) {\n             list.add(throwable);\n             throwable = ExceptionUtils.getCause(throwable);\n         if (fromIndex < 0) {\n             fromIndex = 0;\n         }\n-        Throwable[] throwables = ExceptionUtils.getThrowables(throwable);\n+        final Throwable[] throwables = ExceptionUtils.getThrowables(throwable);\n         if (fromIndex >= throwables.length) {\n             return -1;\n         }\n         if (stream == null) {\n             throw new IllegalArgumentException(\"The PrintStream must not be null\");\n         }\n-        String trace[] = getRootCauseStackTrace(throwable);\n-        for (String element : trace) {\n+        final String trace[] = getRootCauseStackTrace(throwable);\n+        for (final String element : trace) {\n             stream.println(element);\n         }\n         stream.flush();\n         if (writer == null) {\n             throw new IllegalArgumentException(\"The PrintWriter must not be null\");\n         }\n-        String trace[] = getRootCauseStackTrace(throwable);\n-        for (String element : trace) {\n+        final String trace[] = getRootCauseStackTrace(throwable);\n+        for (final String element : trace) {\n             writer.println(element);\n         }\n         writer.flush();\n         if (throwable == null) {\n             return ArrayUtils.EMPTY_STRING_ARRAY;\n         }\n-        Throwable throwables[] = getThrowables(throwable);\n-        int count = throwables.length;\n-        List<String> frames = new ArrayList<String>();\n+        final Throwable throwables[] = getThrowables(throwable);\n+        final int count = throwables.length;\n+        final List<String> frames = new ArrayList<String>();\n         List<String> nextTrace = getStackFrameList(throwables[count - 1]);\n         for (int i = count; --i >= 0;) {\n-            List<String> trace = nextTrace;\n+            final List<String> trace = nextTrace;\n             if (i != 0) {\n                 nextTrace = getStackFrameList(throwables[i - 1]);\n                 removeCommonFrames(trace, nextTrace);\n         while (causeFrameIndex >= 0 && wrapperFrameIndex >= 0) {\n             // Remove the frame from the cause trace if it is the same\n             // as in the wrapper trace\n-            String causeFrame = causeFrames.get(causeFrameIndex);\n-            String wrapperFrame = wrapperFrames.get(wrapperFrameIndex);\n+            final String causeFrame = causeFrames.get(causeFrameIndex);\n+            final String wrapperFrame = wrapperFrames.get(wrapperFrameIndex);\n             if (causeFrame.equals(wrapperFrame)) {\n                 causeFrames.remove(causeFrameIndex);\n             }\n      *  <code>printStackTrace(PrintWriter)</code> method\n      */\n     public static String getStackTrace(final Throwable throwable) {\n-        StringWriter sw = new StringWriter();\n-        PrintWriter pw = new PrintWriter(sw, true);\n+        final StringWriter sw = new StringWriter();\n+        final PrintWriter pw = new PrintWriter(sw, true);\n         throwable.printStackTrace(pw);\n         return sw.getBuffer().toString();\n     }\n      * @return an array where each element is a line from the argument\n      */\n     static String[] getStackFrames(final String stackTrace) {\n-        String linebreak = SystemUtils.LINE_SEPARATOR;\n-        StringTokenizer frames = new StringTokenizer(stackTrace, linebreak);\n-        List<String> list = new ArrayList<String>();\n+        final String linebreak = SystemUtils.LINE_SEPARATOR;\n+        final StringTokenizer frames = new StringTokenizer(stackTrace, linebreak);\n+        final List<String> list = new ArrayList<String>();\n         while (frames.hasMoreTokens()) {\n             list.add(frames.nextToken());\n         }\n      * @return List of stack frames\n      */\n     static List<String> getStackFrameList(final Throwable t) {\n-        String stackTrace = getStackTrace(t);\n-        String linebreak = SystemUtils.LINE_SEPARATOR;\n-        StringTokenizer frames = new StringTokenizer(stackTrace, linebreak);\n-        List<String> list = new ArrayList<String>();\n+        final String stackTrace = getStackTrace(t);\n+        final String linebreak = SystemUtils.LINE_SEPARATOR;\n+        final StringTokenizer frames = new StringTokenizer(stackTrace, linebreak);\n+        final List<String> list = new ArrayList<String>();\n         boolean traceStarted = false;\n         while (frames.hasMoreTokens()) {\n-            String token = frames.nextToken();\n+            final String token = frames.nextToken();\n             // Determine if the line starts with <whitespace>at\n-            int at = token.indexOf(\"at\");\n+            final int at = token.indexOf(\"at\");\n             if (at != -1 && token.substring(0, at).trim().isEmpty()) {\n                 traceStarted = true;\n                 list.add(token);\n         if (th == null) {\n             return \"\";\n         }\n-        String clsName = ClassUtils.getShortClassName(th, null);\n-        String msg = th.getMessage();\n+        final String clsName = ClassUtils.getShortClassName(th, null);\n+        final String msg = th.getMessage();\n         return clsName + \": \" + StringUtils.defaultString(msg);\n     }\n \n--- a/src/main/java/org/apache/commons/lang3/math/Fraction.java\n+++ b/src/main/java/org/apache/commons/lang3/math/Fraction.java\n             denominator = -denominator;\n         }\n         // simplify fraction.\n-        int gcd = greatestCommonDivisor(numerator, denominator);\n+        final int gcd = greatestCommonDivisor(numerator, denominator);\n         numerator /= gcd;\n         denominator /= gcd;\n         return new Fraction(numerator, denominator);\n      * @throws ArithmeticException if the the algorithm does not converge\n      */\n     public static Fraction getFraction(double value) {\n-        int sign = value < 0 ? -1 : 1;\n+        final int sign = value < 0 ? -1 : 1;\n         value = Math.abs(value);\n         if (value  > Integer.MAX_VALUE || Double.isNaN(value)) {\n             throw new ArithmeticException\n                 (\"The value must not be greater than Integer.MAX_VALUE or NaN\");\n         }\n-        int wholeNumber = (int) value;\n+        final int wholeNumber = (int) value;\n         value -= wholeNumber;\n         \n         int numer0 = 0;  // the pre-previous\n         // parse X Y/Z format\n         pos = str.indexOf(' ');\n         if (pos > 0) {\n-            int whole = Integer.parseInt(str.substring(0, pos));\n+            final int whole = Integer.parseInt(str.substring(0, pos));\n             str = str.substring(pos + 1);\n             pos = str.indexOf('/');\n             if (pos < 0) {\n                 throw new NumberFormatException(\"The fraction could not be parsed as the format X Y/Z\");\n             } else {\n-                int numer = Integer.parseInt(str.substring(0, pos));\n-                int denom = Integer.parseInt(str.substring(pos + 1));\n+                final int numer = Integer.parseInt(str.substring(0, pos));\n+                final int denom = Integer.parseInt(str.substring(pos + 1));\n                 return getFraction(whole, numer, denom);\n             }\n         }\n             // simple whole number\n             return getFraction(Integer.parseInt(str), 1);\n         } else {\n-            int numer = Integer.parseInt(str.substring(0, pos));\n-            int denom = Integer.parseInt(str.substring(pos + 1));\n+            final int numer = Integer.parseInt(str.substring(0, pos));\n+            final int denom = Integer.parseInt(str.substring(pos + 1));\n             return getFraction(numer, denom);\n         }\n     }\n         if (numerator == 0) {\n             return equals(ZERO) ? this : ZERO;\n         }\n-        int gcd = greatestCommonDivisor(Math.abs(numerator), denominator);\n+        final int gcd = greatestCommonDivisor(Math.abs(numerator), denominator);\n         if (gcd == 1) {\n             return this;\n         }\n             }\n             return this.invert().pow(-power);\n         } else {\n-            Fraction f = this.multiplyBy(this);\n+            final Fraction f = this.multiplyBy(this);\n             if (power % 2 == 0) { // if even...\n                 return f.pow(power/2);\n             } else { // if odd...\n      *                             an int\n      */\n     private static int mulAndCheck(final int x, final int y) {\n-        long m = (long)x*(long)y;\n+        final long m = (long)x*(long)y;\n         if (m < Integer.MIN_VALUE ||\n             m > Integer.MAX_VALUE) {\n             throw new ArithmeticException(\"overflow: mul\");\n      */\n     private static int mulPosAndCheck(final int x, final int y) {\n         /* assert x>=0 && y>=0; */\n-        long m = (long)x*(long)y;\n+        final long m = (long)x*(long)y;\n         if (m > Integer.MAX_VALUE) {\n             throw new ArithmeticException(\"overflow: mulPos\");\n         }\n      * an int\n      */\n     private static int addAndCheck(final int x, final int y) {\n-        long s = (long)x+(long)y;\n+        final long s = (long)x+(long)y;\n         if (s < Integer.MIN_VALUE ||\n             s > Integer.MAX_VALUE) {\n             throw new ArithmeticException(\"overflow: add\");\n      * an int\n      */\n     private static int subAndCheck(final int x, final int y) {\n-        long s = (long)x-(long)y;\n+        final long s = (long)x-(long)y;\n         if (s < Integer.MIN_VALUE ||\n             s > Integer.MAX_VALUE) {\n             throw new ArithmeticException(\"overflow: add\");\n         }     \n         // if denominators are randomly distributed, d1 will be 1 about 61%\n         // of the time.\n-        int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n+        final int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n         if (d1==1) {\n             // result is ( (u*v' +/- u'v) / u'v')\n-            int uvp = mulAndCheck(numerator, fraction.denominator);\n-            int upv = mulAndCheck(fraction.numerator, denominator);\n+            final int uvp = mulAndCheck(numerator, fraction.denominator);\n+            final int upv = mulAndCheck(fraction.numerator, denominator);\n             return new Fraction\n                 (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                  mulPosAndCheck(denominator, fraction.denominator));\n         // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n         // exercise 7.  we're going to use a BigInteger.\n         // t = u(v'/d1) +/- v(u'/d1)\n-        BigInteger uvp = BigInteger.valueOf(numerator)\n+        final BigInteger uvp = BigInteger.valueOf(numerator)\n             .multiply(BigInteger.valueOf(fraction.denominator/d1));\n-        BigInteger upv = BigInteger.valueOf(fraction.numerator)\n+        final BigInteger upv = BigInteger.valueOf(fraction.numerator)\n             .multiply(BigInteger.valueOf(denominator/d1));\n-        BigInteger t = isAdd ? uvp.add(upv) : uvp.subtract(upv);\n+        final BigInteger t = isAdd ? uvp.add(upv) : uvp.subtract(upv);\n         // but d2 doesn't need extra precision because\n         // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n-        int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n-        int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n+        final int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n+        final int d2 = tmodd1==0?d1:greatestCommonDivisor(tmodd1, d1);\n \n         // result is (t/d2) / (u'/d1)(v'/d2)\n-        BigInteger w = t.divide(BigInteger.valueOf(d2));\n+        final BigInteger w = t.divide(BigInteger.valueOf(d2));\n         if (w.bitLength() > 31) {\n             throw new ArithmeticException\n                 (\"overflow: numerator too large after multiply\");\n         }\n         // knuth 4.5.1\n         // make sure we don't overflow unless the result *must* overflow.\n-        int d1 = greatestCommonDivisor(numerator, fraction.denominator);\n-        int d2 = greatestCommonDivisor(fraction.numerator, denominator);\n+        final int d1 = greatestCommonDivisor(numerator, fraction.denominator);\n+        final int d2 = greatestCommonDivisor(fraction.numerator, denominator);\n         return getReducedFraction\n             (mulAndCheck(numerator/d1, fraction.numerator/d2),\n              mulPosAndCheck(denominator/d2, fraction.denominator/d1));\n         if (obj instanceof Fraction == false) {\n             return false;\n         }\n-        Fraction other = (Fraction) obj;\n+        final Fraction other = (Fraction) obj;\n         return getNumerator() == other.getNumerator() &&\n                 getDenominator() == other.getDenominator();\n     }\n         }\n \n         // otherwise see which is less\n-        long first = (long) numerator * (long) other.denominator;\n-        long second = (long) other.numerator * (long) denominator;\n+        final long first = (long) numerator * (long) other.denominator;\n+        final long second = (long) other.numerator * (long) denominator;\n         if (first == second) {\n             return 0;\n         } else if (first < second) {\n                 // NEGATIVE (not positive) numbers, since negative numbers\n                 // have a larger range.  otherwise numerator==Integer.MIN_VALUE\n                 // is handled incorrectly.\n-                int properNumerator = getProperNumerator();\n+                final int properNumerator = getProperNumerator();\n                 if (properNumerator == 0) {\n                     toProperString = Integer.toString(getProperWhole());\n                 } else {\n--- a/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\n         }\n         try {\n             return Integer.parseInt(str);\n-        } catch (NumberFormatException nfe) {\n+        } catch (final NumberFormatException nfe) {\n             return defaultValue;\n         }\n     }\n         }\n         try {\n             return Long.parseLong(str);\n-        } catch (NumberFormatException nfe) {\n+        } catch (final NumberFormatException nfe) {\n             return defaultValue;\n         }\n     }\n       }     \n       try {\n           return Float.parseFloat(str);\n-      } catch (NumberFormatException nfe) {\n+      } catch (final NumberFormatException nfe) {\n           return defaultValue;\n       }\n     }\n       }\n       try {\n           return Double.parseDouble(str);\n-      } catch (NumberFormatException nfe) {\n+      } catch (final NumberFormatException nfe) {\n           return defaultValue;\n       }\n     }\n         }\n         try {\n             return Byte.parseByte(str);\n-        } catch (NumberFormatException nfe) {\n+        } catch (final NumberFormatException nfe) {\n             return defaultValue;\n         }\n     }\n         }\n         try {\n             return Short.parseShort(str);\n-        } catch (NumberFormatException nfe) {\n+        } catch (final NumberFormatException nfe) {\n             return defaultValue;\n         }\n     }\n         // Need to deal with all possible hex prefixes here\n         final String[] hex_prefixes = {\"0x\", \"0X\", \"-0x\", \"-0X\", \"#\", \"-#\"};\n         int pfxLen = 0;\n-        for(String pfx : hex_prefixes) {\n+        for(final String pfx : hex_prefixes) {\n             if (str.startsWith(pfx)) {\n                 pfxLen += pfx.length();\n                 break;\n             }\n         }\n         if (pfxLen > 0) {\n-            int hexDigits = str.length() - pfxLen;\n+            final int hexDigits = str.length() - pfxLen;\n             if (hexDigits > 16) { // too many for Long\n                 return createBigInteger(str);\n             }\n             }\n             return createInteger(str);\n         }\n-        char lastChar = str.charAt(str.length() - 1);\n+        final char lastChar = str.charAt(str.length() - 1);\n         String mant;\n         String dec;\n         String exp;\n-        int decPos = str.indexOf('.');\n-        int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n+        final int decPos = str.indexOf('.');\n+        final int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n \n         if (decPos > -1) {\n \n                 exp = null;\n             }\n             //Requesting a specific type..\n-            String numeric = str.substring(0, str.length() - 1);\n-            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n+            final String numeric = str.substring(0, str.length() - 1);\n+            final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n             switch (lastChar) {\n                 case 'l' :\n                 case 'L' :\n                         && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                         try {\n                             return createLong(numeric);\n-                        } catch (NumberFormatException nfe) { // NOPMD\n+                        } catch (final NumberFormatException nfe) { // NOPMD\n                             // Too big for a long\n                         }\n                         return createBigInteger(numeric);\n                 case 'f' :\n                 case 'F' :\n                     try {\n-                        Float f = NumberUtils.createFloat(numeric);\n+                        final Float f = NumberUtils.createFloat(numeric);\n                         if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                             //If it's too big for a float or the float value = 0 and the string\n                             //has non-zeros in it, then float does not have the precision we want\n                             return f;\n                         }\n \n-                    } catch (NumberFormatException nfe) { // NOPMD\n+                    } catch (final NumberFormatException nfe) { // NOPMD\n                         // ignore the bad number\n                     }\n                     //$FALL-THROUGH$\n                 case 'd' :\n                 case 'D' :\n                     try {\n-                        Double d = NumberUtils.createDouble(numeric);\n+                        final Double d = NumberUtils.createDouble(numeric);\n                         if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n                             return d;\n                         }\n-                    } catch (NumberFormatException nfe) { // NOPMD\n+                    } catch (final NumberFormatException nfe) { // NOPMD\n                         // ignore the bad number\n                     }\n                     try {\n                         return createBigDecimal(numeric);\n-                    } catch (NumberFormatException e) { // NOPMD\n+                    } catch (final NumberFormatException e) { // NOPMD\n                         // ignore the bad number\n                     }\n                     //$FALL-THROUGH$\n                 //Must be an int,long,bigint\n                 try {\n                     return createInteger(str);\n-                } catch (NumberFormatException nfe) { // NOPMD\n+                } catch (final NumberFormatException nfe) { // NOPMD\n                     // ignore the bad number\n                 }\n                 try {\n                     return createLong(str);\n-                } catch (NumberFormatException nfe) { // NOPMD\n+                } catch (final NumberFormatException nfe) { // NOPMD\n                     // ignore the bad number\n                 }\n                 return createBigInteger(str);\n \n             } else {\n                 //Must be a float,double,BigDec\n-                boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n+                final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n                 try {\n-                    Float f = createFloat(str);\n+                    final Float f = createFloat(str);\n                     if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                         return f;\n                     }\n-                } catch (NumberFormatException nfe) { // NOPMD\n+                } catch (final NumberFormatException nfe) { // NOPMD\n                     // ignore the bad number\n                 }\n                 try {\n-                    Double d = createDouble(str);\n+                    final Double d = createDouble(str);\n                     if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                         return d;\n                     }\n-                } catch (NumberFormatException nfe) { // NOPMD\n+                } catch (final NumberFormatException nfe) { // NOPMD\n                     // ignore the bad number\n                 }\n \n         if (StringUtils.isEmpty(str)) {\n             return false;\n         }\n-        char[] chars = str.toCharArray();\n+        final char[] chars = str.toCharArray();\n         int sz = chars.length;\n         boolean hasExp = false;\n         boolean hasDecPoint = false;\n         boolean allowSigns = false;\n         boolean foundDigit = false;\n         // deal with any possible sign up front\n-        int start = (chars[0] == '-') ? 1 : 0;\n+        final int start = (chars[0] == '-') ? 1 : 0;\n         if (sz > start + 1 && chars[start] == '0' && chars[start + 1] == 'x') {\n             int i = start + 2;\n             if (i == sz) {\n--- a/src/main/java/org/apache/commons/lang3/mutable/MutableBoolean.java\n+++ b/src/main/java/org/apache/commons/lang3/mutable/MutableBoolean.java\n      */\n     @Override\n     public int compareTo(final MutableBoolean other) {\n-        boolean anotherVal = other.value;\n+        final boolean anotherVal = other.value;\n         return value == anotherVal ? 0 : (value ? 1 : -1);\n     }\n \n--- a/src/main/java/org/apache/commons/lang3/mutable/MutableByte.java\n+++ b/src/main/java/org/apache/commons/lang3/mutable/MutableByte.java\n      */\n     @Override\n     public int compareTo(final MutableByte other) {\n-        byte anotherVal = other.value;\n+        final byte anotherVal = other.value;\n         return value < anotherVal ? -1 : (value == anotherVal ? 0 : 1);\n     }\n \n--- a/src/main/java/org/apache/commons/lang3/mutable/MutableDouble.java\n+++ b/src/main/java/org/apache/commons/lang3/mutable/MutableDouble.java\n      */\n     @Override\n     public int hashCode() {\n-        long bits = Double.doubleToLongBits(value);\n+        final long bits = Double.doubleToLongBits(value);\n         return (int) (bits ^ bits >>> 32);\n     }\n \n      */\n     @Override\n     public int compareTo(final MutableDouble other) {\n-        double anotherVal = other.value;\n+        final double anotherVal = other.value;\n         return Double.compare(value, anotherVal);\n     }\n \n--- a/src/main/java/org/apache/commons/lang3/mutable/MutableFloat.java\n+++ b/src/main/java/org/apache/commons/lang3/mutable/MutableFloat.java\n      */\n     @Override\n     public int compareTo(final MutableFloat other) {\n-        float anotherVal = other.value;\n+        final float anotherVal = other.value;\n         return Float.compare(value, anotherVal);\n     }\n \n--- a/src/main/java/org/apache/commons/lang3/mutable/MutableInt.java\n+++ b/src/main/java/org/apache/commons/lang3/mutable/MutableInt.java\n      */\n     @Override\n     public int compareTo(final MutableInt other) {\n-        int anotherVal = other.value;\n+        final int anotherVal = other.value;\n         return value < anotherVal ? -1 : (value == anotherVal ? 0 : 1);\n     }\n \n--- a/src/main/java/org/apache/commons/lang3/mutable/MutableLong.java\n+++ b/src/main/java/org/apache/commons/lang3/mutable/MutableLong.java\n      */\n     @Override\n     public int compareTo(final MutableLong other) {\n-        long anotherVal = other.value;\n+        final long anotherVal = other.value;\n         return value < anotherVal ? -1 : (value == anotherVal ? 0 : 1);\n     }\n \n--- a/src/main/java/org/apache/commons/lang3/mutable/MutableObject.java\n+++ b/src/main/java/org/apache/commons/lang3/mutable/MutableObject.java\n             return true;\n         }\n         if (this.getClass() == obj.getClass()) {\n-            MutableObject<?> that = (MutableObject<?>) obj;\n+            final MutableObject<?> that = (MutableObject<?>) obj;\n             return this.value.equals(that.value);\n         } else {\n             return false;\n--- a/src/main/java/org/apache/commons/lang3/mutable/MutableShort.java\n+++ b/src/main/java/org/apache/commons/lang3/mutable/MutableShort.java\n      */\n     @Override\n     public int compareTo(final MutableShort other) {\n-        short anotherVal = other.value;\n+        final short anotherVal = other.value;\n         return value < anotherVal ? -1 : (value == anotherVal ? 0 : 1);\n     }\n \n--- a/src/main/java/org/apache/commons/lang3/reflect/ConstructorUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/reflect/ConstructorUtils.java\n         if (args == null) {\n             args = ArrayUtils.EMPTY_OBJECT_ARRAY;\n         }\n-        Class<?> parameterTypes[] = ClassUtils.toClass(args);\n+        final Class<?> parameterTypes[] = ClassUtils.toClass(args);\n         return invokeConstructor(cls, args, parameterTypes);\n     }\n \n         if (args == null) {\n             args = ArrayUtils.EMPTY_OBJECT_ARRAY;\n         }\n-        Constructor<T> ctor = getMatchingAccessibleConstructor(cls, parameterTypes);\n+        final Constructor<T> ctor = getMatchingAccessibleConstructor(cls, parameterTypes);\n         if (ctor == null) {\n             throw new NoSuchMethodException(\n                 \"No such accessible constructor on object: \" + cls.getName());\n         if (args == null) {\n             args = ArrayUtils.EMPTY_OBJECT_ARRAY;\n         }\n-        Class<?> parameterTypes[] = ClassUtils.toClass(args);\n+        final Class<?> parameterTypes[] = ClassUtils.toClass(args);\n         return invokeExactConstructor(cls, args, parameterTypes);\n     }\n \n         if (parameterTypes == null) {\n             parameterTypes = ArrayUtils.EMPTY_CLASS_ARRAY;\n         }\n-        Constructor<T> ctor = getAccessibleConstructor(cls, parameterTypes);\n+        final Constructor<T> ctor = getAccessibleConstructor(cls, parameterTypes);\n         if (ctor == null) {\n             throw new NoSuchMethodException(\n                 \"No such accessible constructor on object: \"+ cls.getName());\n             final Class<?>... parameterTypes) {\n         try {\n             return getAccessibleConstructor(cls.getConstructor(parameterTypes));\n-        } catch (NoSuchMethodException e) {\n+        } catch (final NoSuchMethodException e) {\n             return null;\n         }\n     }\n         // see if we can find the constructor directly\n         // most of the time this works and it's much faster\n         try {\n-            Constructor<T> ctor = cls.getConstructor(parameterTypes);\n+            final Constructor<T> ctor = cls.getConstructor(parameterTypes);\n             MemberUtils.setAccessibleWorkaround(ctor);\n             return ctor;\n-        } catch (NoSuchMethodException e) { // NOPMD - Swallow\n+        } catch (final NoSuchMethodException e) { // NOPMD - Swallow\n         }\n         Constructor<T> result = null;\n         /*\n          * (1) Class.getConstructors() is documented to return Constructor<T> so as\n          * long as the array is not subsequently modified, everything's fine.\n          */\n-        Constructor<?>[] ctors = cls.getConstructors();\n+        final Constructor<?>[] ctors = cls.getConstructors();\n \n         // return best match:\n         for (Constructor<?> ctor : ctors) {\n                                     .getParameterTypes(), parameterTypes) < 0) {\n                         // temporary variable for annotation, see comment above (1)\n                         @SuppressWarnings(\"unchecked\")\n+                        final\n                         Constructor<T> constructor = (Constructor<T>)ctor;\n                         result = constructor;\n                     }\n--- a/src/main/java/org/apache/commons/lang3/reflect/FieldUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/reflect/FieldUtils.java\n      * @throws IllegalArgumentException if the class or field name is null\n      */\n     public static Field getField(final Class<?> cls, final String fieldName) {\n-        Field field = getField(cls, fieldName, false);\n+        final Field field = getField(cls, fieldName, false);\n         MemberUtils.setAccessibleWorkaround(field);\n         return field;\n     }\n         // check up the superclass hierarchy\n         for (Class<?> acls = cls; acls != null; acls = acls.getSuperclass()) {\n             try {\n-                Field field = acls.getDeclaredField(fieldName);\n+                final Field field = acls.getDeclaredField(fieldName);\n                 // getDeclaredField checks for non-public scopes as well\n                 // and it returns accurate results\n                 if (!Modifier.isPublic(field.getModifiers())) {\n                     }\n                 }\n                 return field;\n-            } catch (NoSuchFieldException ex) { // NOPMD\n+            } catch (final NoSuchFieldException ex) { // NOPMD\n                 // ignore\n             }\n         }\n         // incase there is a public supersuperclass field hidden by a private/package\n         // superclass field.\n         Field match = null;\n-        for (Class<?> class1 : ClassUtils.getAllInterfaces(cls)) {\n+        for (final Class<?> class1 : ClassUtils.getAllInterfaces(cls)) {\n             try {\n-                Field test = ((Class<?>) class1).getField(fieldName);\n+                final Field test = ((Class<?>) class1).getField(fieldName);\n                 if (match != null) {\n                     throw new IllegalArgumentException(\"Reference to field \" + fieldName + \" is ambiguous relative to \" + cls\n                             + \"; a matching field exists on two or more implemented interfaces.\");\n                 }\n                 match = test;\n-            } catch (NoSuchFieldException ex) { // NOPMD\n+            } catch (final NoSuchFieldException ex) { // NOPMD\n                 // ignore\n             }\n         }\n         }\n         try {\n             // only consider the specified class by using getDeclaredField()\n-            Field field = cls.getDeclaredField(fieldName);\n+            final Field field = cls.getDeclaredField(fieldName);\n             if (!MemberUtils.isAccessible(field)) {\n                 if (forceAccess) {\n                     field.setAccessible(true);\n                 }\n             }\n             return field;\n-        } catch (NoSuchFieldException e) { // NOPMD\n+        } catch (final NoSuchFieldException e) { // NOPMD\n             // ignore\n         }\n         return null;\n      */\n     public static Object readStaticField(final Class<?> cls, final String fieldName, final boolean forceAccess)\n         throws IllegalAccessException {\n-        Field field = getField(cls, fieldName, forceAccess);\n+        final Field field = getField(cls, fieldName, forceAccess);\n         if (field == null) {\n             throw new IllegalArgumentException(\"Cannot locate field \" + fieldName + \" on \" + cls);\n         }\n      */\n     public static Object readDeclaredStaticField(final Class<?> cls, final String fieldName, final boolean forceAccess)\n             throws IllegalAccessException {\n-        Field field = getDeclaredField(cls, fieldName, forceAccess);\n+        final Field field = getDeclaredField(cls, fieldName, forceAccess);\n         if (field == null) {\n             throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n         }\n         if (target == null) {\n             throw new IllegalArgumentException(\"target object must not be null\");\n         }\n-        Class<?> cls = target.getClass();\n-        Field field = getField(cls, fieldName, forceAccess);\n+        final Class<?> cls = target.getClass();\n+        final Field field = getField(cls, fieldName, forceAccess);\n         if (field == null) {\n             throw new IllegalArgumentException(\"Cannot locate field \" + fieldName + \" on \" + cls);\n         }\n         if (target == null) {\n             throw new IllegalArgumentException(\"target object must not be null\");\n         }\n-        Class<?> cls = target.getClass();\n-        Field field = getDeclaredField(cls, fieldName, forceAccess);\n+        final Class<?> cls = target.getClass();\n+        final Field field = getDeclaredField(cls, fieldName, forceAccess);\n         if (field == null) {\n             throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n         }\n      */\n     public static void writeStaticField(final Class<?> cls, final String fieldName, final Object value, final boolean forceAccess)\n             throws IllegalAccessException {\n-        Field field = getField(cls, fieldName, forceAccess);\n+        final Field field = getField(cls, fieldName, forceAccess);\n         if (field == null) {\n             throw new IllegalArgumentException(\"Cannot locate field \" + fieldName + \" on \" + cls);\n         }\n       */\n     public static void writeDeclaredStaticField(final Class<?> cls, final String fieldName, final Object value, final boolean forceAccess)\n             throws IllegalAccessException {\n-        Field field = getDeclaredField(cls, fieldName, forceAccess);\n+        final Field field = getDeclaredField(cls, fieldName, forceAccess);\n         if (field == null) {\n             throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n         }\n         if (target == null) {\n             throw new IllegalArgumentException(\"target object must not be null\");\n         }\n-        Class<?> cls = target.getClass();\n-        Field field = getField(cls, fieldName, forceAccess);\n+        final Class<?> cls = target.getClass();\n+        final Field field = getField(cls, fieldName, forceAccess);\n         if (field == null) {\n             throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n         }\n         if (target == null) {\n             throw new IllegalArgumentException(\"target object must not be null\");\n         }\n-        Class<?> cls = target.getClass();\n-        Field field = getDeclaredField(cls, fieldName, forceAccess);\n+        final Class<?> cls = target.getClass();\n+        final Field field = getDeclaredField(cls, fieldName, forceAccess);\n         if (field == null) {\n             throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n         }\n--- a/src/main/java/org/apache/commons/lang3/reflect/MemberUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/reflect/MemberUtils.java\n         if (o == null || o.isAccessible()) {\n             return;\n         }\n-        Member m = (Member) o;\n+        final Member m = (Member) o;\n         if (Modifier.isPublic(m.getModifiers())\n                 && isPackageAccess(m.getDeclaringClass().getModifiers())) {\n             try {\n                 o.setAccessible(true);\n-            } catch (SecurityException e) { // NOPMD\n+            } catch (final SecurityException e) { // NOPMD\n                 // ignore in favor of subsequent IllegalAccessException\n             }\n         }\n      * @return int consistent with <code>compare</code> semantics\n      */\n     static int compareParameterTypes(final Class<?>[] left, final Class<?>[] right, final Class<?>[] actual) {\n-        float leftCost = getTotalTransformationCost(actual, left);\n-        float rightCost = getTotalTransformationCost(actual, right);\n+        final float leftCost = getTotalTransformationCost(actual, left);\n+        final float rightCost = getTotalTransformationCost(actual, right);\n         return leftCost < rightCost ? -1 : rightCost < leftCost ? 1 : 0;\n     }\n \n--- a/src/main/java/org/apache/commons/lang3/reflect/MethodUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/reflect/MethodUtils.java\n         if (args == null) {\n             args = ArrayUtils.EMPTY_OBJECT_ARRAY;\n         }\n-        Class<?>[] parameterTypes = ClassUtils.toClass(args);\n+        final Class<?>[] parameterTypes = ClassUtils.toClass(args);\n         return invokeMethod(object, methodName, args, parameterTypes);\n     }\n \n         if (args == null) {\n             args = ArrayUtils.EMPTY_OBJECT_ARRAY;\n         }\n-        Method method = getMatchingAccessibleMethod(object.getClass(),\n+        final Method method = getMatchingAccessibleMethod(object.getClass(),\n                 methodName, parameterTypes);\n         if (method == null) {\n             throw new NoSuchMethodException(\"No such accessible method: \"\n         if (args == null) {\n             args = ArrayUtils.EMPTY_OBJECT_ARRAY;\n         }\n-        Class<?>[] parameterTypes = ClassUtils.toClass(args);\n+        final Class<?>[] parameterTypes = ClassUtils.toClass(args);\n         return invokeExactMethod(object, methodName, args, parameterTypes);\n     }\n \n         if (parameterTypes == null) {\n             parameterTypes = ArrayUtils.EMPTY_CLASS_ARRAY;\n         }\n-        Method method = getAccessibleMethod(object.getClass(), methodName,\n+        final Method method = getAccessibleMethod(object.getClass(), methodName,\n                 parameterTypes);\n         if (method == null) {\n             throw new NoSuchMethodException(\"No such accessible method: \"\n         if (parameterTypes == null) {\n             parameterTypes = ArrayUtils.EMPTY_CLASS_ARRAY;\n         }\n-        Method method = getAccessibleMethod(cls, methodName, parameterTypes);\n+        final Method method = getAccessibleMethod(cls, methodName, parameterTypes);\n         if (method == null) {\n             throw new NoSuchMethodException(\"No such accessible method: \"\n                     + methodName + \"() on class: \" + cls.getName());\n         if (args == null) {\n             args = ArrayUtils.EMPTY_OBJECT_ARRAY;\n         }\n-        Class<?>[] parameterTypes = ClassUtils.toClass(args);\n+        final Class<?>[] parameterTypes = ClassUtils.toClass(args);\n         return invokeStaticMethod(cls, methodName, args, parameterTypes);\n     }\n \n         if (args == null) {\n             args = ArrayUtils.EMPTY_OBJECT_ARRAY;\n         }\n-        Method method = getMatchingAccessibleMethod(cls, methodName,\n+        final Method method = getMatchingAccessibleMethod(cls, methodName,\n                 parameterTypes);\n         if (method == null) {\n             throw new NoSuchMethodException(\"No such accessible method: \"\n         if (args == null) {\n             args = ArrayUtils.EMPTY_OBJECT_ARRAY;\n         }\n-        Class<?>[] parameterTypes = ClassUtils.toClass(args);\n+        final Class<?>[] parameterTypes = ClassUtils.toClass(args);\n         return invokeExactStaticMethod(cls, methodName, args, parameterTypes);\n     }\n \n         try {\n             return getAccessibleMethod(cls.getMethod(methodName,\n                     parameterTypes));\n-        } catch (NoSuchMethodException e) {\n+        } catch (final NoSuchMethodException e) {\n             return null;\n         }\n     }\n             return null;\n         }\n         // If the declaring class is public, we are done\n-        Class<?> cls = method.getDeclaringClass();\n+        final Class<?> cls = method.getDeclaringClass();\n         if (Modifier.isPublic(cls.getModifiers())) {\n             return method;\n         }\n-        String methodName = method.getName();\n-        Class<?>[] parameterTypes = method.getParameterTypes();\n+        final String methodName = method.getName();\n+        final Class<?>[] parameterTypes = method.getParameterTypes();\n \n         // Check the implemented interfaces and subinterfaces\n         method = getAccessibleMethodFromInterfaceNest(cls, methodName,\n             if (Modifier.isPublic(parentClass.getModifiers())) {\n                 try {\n                     return parentClass.getMethod(methodName, parameterTypes);\n-                } catch (NoSuchMethodException e) {\n+                } catch (final NoSuchMethodException e) {\n                     return null;\n                 }\n             }\n         for (; cls != null; cls = cls.getSuperclass()) {\n \n             // Check the implemented interfaces of the parent class\n-            Class<?>[] interfaces = cls.getInterfaces();\n+            final Class<?>[] interfaces = cls.getInterfaces();\n             for (int i = 0; i < interfaces.length; i++) {\n                 // Is this interface public?\n                 if (!Modifier.isPublic(interfaces[i].getModifiers())) {\n                 try {\n                     method = interfaces[i].getDeclaredMethod(methodName,\n                             parameterTypes);\n-                } catch (NoSuchMethodException e) { // NOPMD\n+                } catch (final NoSuchMethodException e) { // NOPMD\n                     /*\n                      * Swallow, if no method is found after the loop then this\n                      * method returns null.\n     public static Method getMatchingAccessibleMethod(final Class<?> cls,\n             final String methodName, final Class<?>... parameterTypes) {\n         try {\n-            Method method = cls.getMethod(methodName, parameterTypes);\n+            final Method method = cls.getMethod(methodName, parameterTypes);\n             MemberUtils.setAccessibleWorkaround(method);\n             return method;\n-        } catch (NoSuchMethodException e) { // NOPMD - Swallow the exception\n+        } catch (final NoSuchMethodException e) { // NOPMD - Swallow the exception\n         }\n         // search through all methods\n         Method bestMatch = null;\n-        Method[] methods = cls.getMethods();\n-        for (Method method : methods) {\n+        final Method[] methods = cls.getMethods();\n+        for (final Method method : methods) {\n             // compare name and parameters\n             if (method.getName().equals(methodName) && ClassUtils.isAssignable(parameterTypes, method.getParameterTypes(), true)) {\n                 // get accessible version of method\n-                Method accessibleMethod = getAccessibleMethod(method);\n+                final Method accessibleMethod = getAccessibleMethod(method);\n                 if (accessibleMethod != null && (bestMatch == null || MemberUtils.compareParameterTypes(\n                             accessibleMethod.getParameterTypes(),\n                             bestMatch.getParameterTypes(),\n--- a/src/main/java/org/apache/commons/lang3/reflect/TypeUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/reflect/TypeUtils.java\n         if (type instanceof TypeVariable<?>) {\n             // if any of the bounds are assignable to the class, then the\n             // type is assignable to the class.\n-            for (Type bound : ((TypeVariable<?>) type).getBounds()) {\n+            for (final Type bound : ((TypeVariable<?>) type).getBounds()) {\n                 if (isAssignable(bound, toClass)) {\n                     return true;\n                 }\n         }\n \n         // get the target type's raw type\n-        Class<?> toClass = getRawType(toParameterizedType);\n+        final Class<?> toClass = getRawType(toParameterizedType);\n         // get the subject type's type arguments including owner type arguments\n         // and supertype arguments up to and including the target class.\n-        Map<TypeVariable<?>, Type> fromTypeVarAssigns = getTypeArguments(type, toClass, null);\n+        final Map<TypeVariable<?>, Type> fromTypeVarAssigns = getTypeArguments(type, toClass, null);\n \n         // null means the two types are not compatible\n         if (fromTypeVarAssigns == null) {\n         }\n \n         // get the target type's type arguments including owner type arguments\n-        Map<TypeVariable<?>, Type> toTypeVarAssigns = getTypeArguments(toParameterizedType,\n+        final Map<TypeVariable<?>, Type> toTypeVarAssigns = getTypeArguments(toParameterizedType,\n                 toClass, typeVarAssigns);\n \n         // now to check each type argument\n-        for (TypeVariable<?> var : toTypeVarAssigns.keySet()) {\n-            Type toTypeArg = unrollVariableAssignments(var, toTypeVarAssigns);\n-            Type fromTypeArg = unrollVariableAssignments(var, fromTypeVarAssigns);\n+        for (final TypeVariable<?> var : toTypeVarAssigns.keySet()) {\n+            final Type toTypeArg = unrollVariableAssignments(var, toTypeVarAssigns);\n+            final Type fromTypeArg = unrollVariableAssignments(var, fromTypeVarAssigns);\n \n             // parameters must either be absent from the subject type, within\n             // the bounds of the wildcard type, or be an exact match to the\n             return true;\n         }\n \n-        Type toComponentType = toGenericArrayType.getGenericComponentType();\n+        final Type toComponentType = toGenericArrayType.getGenericComponentType();\n \n         if (type instanceof Class<?>) {\n-            Class<?> cls = (Class<?>) type;\n+            final Class<?> cls = (Class<?>) type;\n \n             // compare the component types\n             return cls.isArray()\n \n         if (type instanceof WildcardType) {\n             // so long as one of the upper bounds is assignable, it's good\n-            for (Type bound : getImplicitUpperBounds((WildcardType) type)) {\n+            for (final Type bound : getImplicitUpperBounds((WildcardType) type)) {\n                 if (isAssignable(bound, toGenericArrayType)) {\n                     return true;\n                 }\n         if (type instanceof TypeVariable<?>) {\n             // probably should remove the following logic and just return false.\n             // type variables cannot specify arrays as bounds.\n-            for (Type bound : getImplicitBounds((TypeVariable<?>) type)) {\n+            for (final Type bound : getImplicitBounds((TypeVariable<?>) type)) {\n                 if (isAssignable(bound, toGenericArrayType)) {\n                     return true;\n                 }\n             return true;\n         }\n \n-        Type[] toUpperBounds = getImplicitUpperBounds(toWildcardType);\n-        Type[] toLowerBounds = getImplicitLowerBounds(toWildcardType);\n+        final Type[] toUpperBounds = getImplicitUpperBounds(toWildcardType);\n+        final Type[] toLowerBounds = getImplicitLowerBounds(toWildcardType);\n \n         if (type instanceof WildcardType) {\n-            WildcardType wildcardType = (WildcardType) type;\n-            Type[] upperBounds = getImplicitUpperBounds(wildcardType);\n-            Type[] lowerBounds = getImplicitLowerBounds(wildcardType);\n+            final WildcardType wildcardType = (WildcardType) type;\n+            final Type[] upperBounds = getImplicitUpperBounds(wildcardType);\n+            final Type[] lowerBounds = getImplicitLowerBounds(wildcardType);\n \n             for (Type toBound : toUpperBounds) {\n                 // if there are assignments for unresolved type variables,\n                 // each upper bound of the subject type has to be assignable to\n                 // each\n                 // upper bound of the target type\n-                for (Type bound : upperBounds) {\n+                for (final Type bound : upperBounds) {\n                     if (!isAssignable(bound, toBound, typeVarAssigns)) {\n                         return false;\n                     }\n                 // each lower bound of the target type has to be assignable to\n                 // each\n                 // lower bound of the subject type\n-                for (Type bound : lowerBounds) {\n+                for (final Type bound : lowerBounds) {\n                     if (!isAssignable(toBound, bound, typeVarAssigns)) {\n                         return false;\n                     }\n             return true;\n         }\n \n-        for (Type toBound : toUpperBounds) {\n+        for (final Type toBound : toUpperBounds) {\n             // if there are assignments for unresolved type variables,\n             // now's the time to substitute them.\n             if (!isAssignable(type, substituteTypeVariables(toBound, typeVarAssigns),\n             }\n         }\n \n-        for (Type toBound : toLowerBounds) {\n+        for (final Type toBound : toLowerBounds) {\n             // if there are assignments for unresolved type variables,\n             // now's the time to substitute them.\n             if (!isAssignable(substituteTypeVariables(toBound, typeVarAssigns), type,\n             // a type variable is assignable to another type variable, if\n             // and only if the former is the latter, extends the latter, or\n             // is otherwise a descendant of the latter.\n-            Type[] bounds = getImplicitBounds((TypeVariable<?>) type);\n-\n-            for (Type bound : bounds) {\n+            final Type[] bounds = getImplicitBounds((TypeVariable<?>) type);\n+\n+            for (final Type bound : bounds) {\n                 if (isAssignable(bound, toTypeVariable, typeVarAssigns)) {\n                     return true;\n                 }\n      */\n     private static Type substituteTypeVariables(final Type type, final Map<TypeVariable<?>, Type> typeVarAssigns) {\n         if (type instanceof TypeVariable<?> && typeVarAssigns != null) {\n-            Type replacementType = typeVarAssigns.get(type);\n+            final Type replacementType = typeVarAssigns.get(type);\n \n             if (replacementType == null) {\n                 throw new IllegalArgumentException(\"missing assignment type for type variable \"\n         // since wildcard types are not assignable to classes, should this just\n         // return null?\n         if (type instanceof WildcardType) {\n-            for (Type bound : getImplicitUpperBounds((WildcardType) type)) {\n+            for (final Type bound : getImplicitUpperBounds((WildcardType) type)) {\n                 // find the first bound that is assignable to the target class\n                 if (isAssignable(bound, toClass)) {\n                     return getTypeArguments(bound, toClass, subtypeVarAssigns);\n \n         // *\n         if (type instanceof TypeVariable<?>) {\n-            for (Type bound : getImplicitBounds((TypeVariable<?>) type)) {\n+            for (final Type bound : getImplicitBounds((TypeVariable<?>) type)) {\n                 // find the first bound that is assignable to the target class\n                 if (isAssignable(bound, toClass)) {\n                     return getTypeArguments(bound, toClass, subtypeVarAssigns);\n     private static Map<TypeVariable<?>, Type> getTypeArguments(\n             final ParameterizedType parameterizedType, final Class<?> toClass,\n             final Map<TypeVariable<?>, Type> subtypeVarAssigns) {\n-        Class<?> cls = getRawType(parameterizedType);\n+        final Class<?> cls = getRawType(parameterizedType);\n \n         // make sure they're assignable\n         if (!isAssignable(cls, toClass)) {\n             return null;\n         }\n \n-        Type ownerType = parameterizedType.getOwnerType();\n+        final Type ownerType = parameterizedType.getOwnerType();\n         Map<TypeVariable<?>, Type> typeVarAssigns;\n \n         if (ownerType instanceof ParameterizedType) {\n             // get the owner type arguments first\n-            ParameterizedType parameterizedOwnerType = (ParameterizedType) ownerType;\n+            final ParameterizedType parameterizedOwnerType = (ParameterizedType) ownerType;\n             typeVarAssigns = getTypeArguments(parameterizedOwnerType,\n                     getRawType(parameterizedOwnerType), subtypeVarAssigns);\n         } else {\n         }\n \n         // get the subject parameterized type's arguments\n-        Type[] typeArgs = parameterizedType.getActualTypeArguments();\n+        final Type[] typeArgs = parameterizedType.getActualTypeArguments();\n         // and get the corresponding type variables from the raw class\n-        TypeVariable<?>[] typeParams = cls.getTypeParameters();\n+        final TypeVariable<?>[] typeParams = cls.getTypeParameters();\n \n         // map the arguments to their respective type variables\n         for (int i = 0; i < typeParams.length; i++) {\n-            Type typeArg = typeArgs[i];\n+            final Type typeArg = typeArgs[i];\n             typeVarAssigns.put(typeParams[i], typeVarAssigns.containsKey(typeArg) ? typeVarAssigns\n                     .get(typeArg) : typeArg);\n         }\n         }\n \n         // create a copy of the incoming map, or an empty one if it's null\n-        HashMap<TypeVariable<?>, Type> typeVarAssigns = subtypeVarAssigns == null ? new HashMap<TypeVariable<?>, Type>()\n+        final HashMap<TypeVariable<?>, Type> typeVarAssigns = subtypeVarAssigns == null ? new HashMap<TypeVariable<?>, Type>()\n                 : new HashMap<TypeVariable<?>, Type>(subtypeVarAssigns);\n \n         // has target class been reached?\n      */\n     public static Map<TypeVariable<?>, Type> determineTypeArguments(final Class<?> cls,\n             final ParameterizedType superType) {\n-        Class<?> superClass = getRawType(superType);\n+        final Class<?> superClass = getRawType(superType);\n \n         // compatibility check\n         if (!isAssignable(cls, superClass)) {\n         }\n \n         // get the next class in the inheritance hierarchy\n-        Type midType = getClosestParentType(cls, superClass);\n+        final Type midType = getClosestParentType(cls, superClass);\n \n         // can only be a class or a parameterized type\n         if (midType instanceof Class<?>) {\n             return determineTypeArguments((Class<?>) midType, superType);\n         }\n \n-        ParameterizedType midParameterizedType = (ParameterizedType) midType;\n-        Class<?> midClass = getRawType(midParameterizedType);\n+        final ParameterizedType midParameterizedType = (ParameterizedType) midType;\n+        final Class<?> midClass = getRawType(midParameterizedType);\n         // get the type variables of the mid class that map to the type\n         // arguments of the super class\n-        Map<TypeVariable<?>, Type> typeVarAssigns = determineTypeArguments(midClass, superType);\n+        final Map<TypeVariable<?>, Type> typeVarAssigns = determineTypeArguments(midClass, superType);\n         // map the arguments of the mid type to the class type variables\n         mapTypeVariablesToArguments(cls, midParameterizedType, typeVarAssigns);\n \n     private static <T> void mapTypeVariablesToArguments(final Class<T> cls,\n             final ParameterizedType parameterizedType, final Map<TypeVariable<?>, Type> typeVarAssigns) {\n         // capture the type variables from the owner type that have assignments\n-        Type ownerType = parameterizedType.getOwnerType();\n+        final Type ownerType = parameterizedType.getOwnerType();\n \n         if (ownerType instanceof ParameterizedType) {\n             // recursion to make sure the owner's owner type gets processed\n         // hierarchy of said interface/class) implemented/extended by the class\n         // cls. Find out which type variables of cls are type arguments of\n         // parameterizedType:\n-        Type[] typeArgs = parameterizedType.getActualTypeArguments();\n+        final Type[] typeArgs = parameterizedType.getActualTypeArguments();\n \n         // of the cls's type variables that are arguments of parameterizedType,\n         // find out which ones can be determined from the super type's arguments\n-        TypeVariable<?>[] typeVars = getRawType(parameterizedType).getTypeParameters();\n+        final TypeVariable<?>[] typeVars = getRawType(parameterizedType).getTypeParameters();\n \n         // use List view of type parameters of cls so the contains() method can be used:\n-        List<TypeVariable<Class<T>>> typeVarList = Arrays.asList(cls\n+        final List<TypeVariable<Class<T>>> typeVarList = Arrays.asList(cls\n                 .getTypeParameters());\n \n         for (int i = 0; i < typeArgs.length; i++) {\n-            TypeVariable<?> typeVar = typeVars[i];\n-            Type typeArg = typeArgs[i];\n+            final TypeVariable<?> typeVar = typeVars[i];\n+            final Type typeArg = typeArgs[i];\n \n             // argument of parameterizedType is a type variable of cls\n             if (typeVarList.contains(typeArg)\n         // only look at the interfaces if the super class is also an interface\n         if (superClass.isInterface()) {\n             // get the generic interfaces of the subject class\n-            Type[] interfaceTypes = cls.getGenericInterfaces();\n+            final Type[] interfaceTypes = cls.getGenericInterfaces();\n             // will hold the best generic interface match found\n             Type genericInterface = null;\n \n             // find the interface closest to the super class\n-            for (Type midType : interfaceTypes) {\n+            for (final Type midType : interfaceTypes) {\n                 Class<?> midClass = null;\n \n                 if (midType instanceof ParameterizedType) {\n             return bounds;\n         }\n \n-        Set<Type> types = new HashSet<Type>(bounds.length);\n-\n-        for (Type type1 : bounds) {\n+        final Set<Type> types = new HashSet<Type>(bounds.length);\n+\n+        for (final Type type1 : bounds) {\n             boolean subtypeFound = false;\n \n-            for (Type type2 : bounds) {\n+            for (final Type type2 : bounds) {\n                 if (type1 != type2 && isAssignable(type2, type1, null)) {\n                     subtypeFound = true;\n                     break;\n      * @return a non-empty array containing the bounds of the type variable.\n      */\n     public static Type[] getImplicitBounds(final TypeVariable<?> typeVariable) {\n-        Type[] bounds = typeVariable.getBounds();\n+        final Type[] bounds = typeVariable.getBounds();\n \n         return bounds.length == 0 ? new Type[] { Object.class } : normalizeUpperBounds(bounds);\n     }\n      * type.\n      */\n     public static Type[] getImplicitUpperBounds(final WildcardType wildcardType) {\n-        Type[] bounds = wildcardType.getUpperBounds();\n+        final Type[] bounds = wildcardType.getUpperBounds();\n \n         return bounds.length == 0 ? new Type[] { Object.class } : normalizeUpperBounds(bounds);\n     }\n      * type.\n      */\n     public static Type[] getImplicitLowerBounds(final WildcardType wildcardType) {\n-        Type[] bounds = wildcardType.getLowerBounds();\n+        final Type[] bounds = wildcardType.getLowerBounds();\n \n         return bounds.length == 0 ? new Type[] { null } : bounds;\n     }\n     public static boolean typesSatisfyVariables(final Map<TypeVariable<?>, Type> typeVarAssigns) {\n         // all types must be assignable to all the bounds of the their mapped\n         // type variable.\n-        for (Map.Entry<TypeVariable<?>, Type> entry : typeVarAssigns.entrySet()) {\n-            TypeVariable<?> typeVar = entry.getKey();\n-            Type type = entry.getValue();\n-\n-            for (Type bound : getImplicitBounds(typeVar)) {\n+        for (final Map.Entry<TypeVariable<?>, Type> entry : typeVarAssigns.entrySet()) {\n+            final TypeVariable<?> typeVar = entry.getKey();\n+            final Type type = entry.getValue();\n+\n+            for (final Type bound : getImplicitBounds(typeVar)) {\n                 if (!isAssignable(type, substituteTypeVariables(bound, typeVarAssigns),\n                         typeVarAssigns)) {\n                     return false;\n      * @throws IllegalStateException if the conversion fails\n      */\n     private static Class<?> getRawType(final ParameterizedType parameterizedType) {\n-        Type rawType = parameterizedType.getRawType();\n+        final Type rawType = parameterizedType.getRawType();\n \n         // check if raw type is a Class object\n         // not currently necessary, but since the return type is Type instead of\n             }\n \n             // get the entity declaring this type variable\n-            Object genericDeclaration = ((TypeVariable<?>) type).getGenericDeclaration();\n+            final Object genericDeclaration = ((TypeVariable<?>) type).getGenericDeclaration();\n \n             // can't get the raw type of a method- or constructor-declared type\n             // variable\n \n             // get the type arguments for the declaring class/interface based\n             // on the enclosing type\n-            Map<TypeVariable<?>, Type> typeVarAssigns = getTypeArguments(assigningType,\n+            final Map<TypeVariable<?>, Type> typeVarAssigns = getTypeArguments(assigningType,\n                     (Class<?>) genericDeclaration);\n \n             // enclosingType has to be a subclass (or subinterface) of the\n             }\n \n             // get the argument assigned to this type variable\n-            Type typeArgument = typeVarAssigns.get(type);\n+            final Type typeArgument = typeVarAssigns.get(type);\n \n             if (typeArgument == null) {\n                 return null;\n \n         if (type instanceof GenericArrayType) {\n             // get raw component type\n-            Class<?> rawComponentType = getRawType(((GenericArrayType) type)\n+            final Class<?> rawComponentType = getRawType(((GenericArrayType) type)\n                     .getGenericComponentType(), assigningType);\n \n             // create array type from raw component type and return its class\n      */\n     public static Type getArrayComponentType(final Type type) {\n         if (type instanceof Class<?>) {\n-            Class<?> clazz = (Class<?>) type;\n+            final Class<?> clazz = (Class<?>) type;\n             return clazz.isArray() ? clazz.getComponentType() : null;\n         }\n         if (type instanceof GenericArrayType) {\n--- a/src/main/java/org/apache/commons/lang3/text/ExtendedMessageFormat.java\n+++ b/src/main/java/org/apache/commons/lang3/text/ExtendedMessageFormat.java\n             toPattern = super.toPattern();\n             return;\n         }\n-        ArrayList<Format> foundFormats = new ArrayList<Format>();\n-        ArrayList<String> foundDescriptions = new ArrayList<String>();\n-        StringBuilder stripCustom = new StringBuilder(pattern.length());\n-\n-        ParsePosition pos = new ParsePosition(0);\n-        char[] c = pattern.toCharArray();\n+        final ArrayList<Format> foundFormats = new ArrayList<Format>();\n+        final ArrayList<String> foundDescriptions = new ArrayList<String>();\n+        final StringBuilder stripCustom = new StringBuilder(pattern.length());\n+\n+        final ParsePosition pos = new ParsePosition(0);\n+        final char[] c = pattern.toCharArray();\n         int fmtCount = 0;\n         while (pos.getIndex() < pattern.length()) {\n             switch (c[pos.getIndex()]) {\n             case START_FE:\n                 fmtCount++;\n                 seekNonWs(pattern, pos);\n-                int start = pos.getIndex();\n-                int index = readArgumentIndex(pattern, next(pos));\n+                final int start = pos.getIndex();\n+                final int index = readArgumentIndex(pattern, next(pos));\n                 stripCustom.append(START_FE).append(index);\n                 seekNonWs(pattern, pos);\n                 Format format = null;\n         super.applyPattern(stripCustom.toString());\n         toPattern = insertFormats(super.toPattern(), foundDescriptions);\n         if (containsElements(foundFormats)) {\n-            Format[] origFormats = getFormats();\n+            final Format[] origFormats = getFormats();\n             // only loop over what we know we have, as MessageFormat on Java 1.3\n             // seems to provide an extra format element:\n             int i = 0;\n-            for (Iterator<Format> it = foundFormats.iterator(); it.hasNext(); i++) {\n-                Format f = it.next();\n+            for (final Iterator<Format> it = foundFormats.iterator(); it.hasNext(); i++) {\n+                final Format f = it.next();\n                 if (f != null) {\n                     origFormats[i] = f;\n                 }\n         if (ObjectUtils.notEqual(getClass(), obj.getClass())) {\n           return false;\n         }\n-        ExtendedMessageFormat rhs = (ExtendedMessageFormat)obj;\n+        final ExtendedMessageFormat rhs = (ExtendedMessageFormat)obj;\n         if (ObjectUtils.notEqual(toPattern, rhs.toPattern)) {\n             return false;\n         }\n         if (registry != null) {\n             String name = desc;\n             String args = null;\n-            int i = desc.indexOf(START_FMT);\n+            final int i = desc.indexOf(START_FMT);\n             if (i > 0) {\n                 name = desc.substring(0, i).trim();\n                 args = desc.substring(i + 1).trim();\n             }\n-            FormatFactory factory = registry.get(name);\n+            final FormatFactory factory = registry.get(name);\n             if (factory != null) {\n                 return factory.getFormat(name, args, getLocale());\n             }\n      * @return argument index\n      */\n     private int readArgumentIndex(final String pattern, final ParsePosition pos) {\n-        int start = pos.getIndex();\n+        final int start = pos.getIndex();\n         seekNonWs(pattern, pos);\n-        StringBuilder result = new StringBuilder();\n+        final StringBuilder result = new StringBuilder();\n         boolean error = false;\n         for (; !error && pos.getIndex() < pattern.length(); next(pos)) {\n             char c = pattern.charAt(pos.getIndex());\n             if ((c == START_FMT || c == END_FE) && result.length() > 0) {\n                 try {\n                     return Integer.parseInt(result.toString());\n-                } catch (NumberFormatException e) { // NOPMD\n+                } catch (final NumberFormatException e) { // NOPMD\n                     // we've already ensured only digits, so unless something\n                     // outlandishly large was specified we should be okay.\n                 }\n      * @return Format description String\n      */\n     private String parseFormatDescription(final String pattern, final ParsePosition pos) {\n-        int start = pos.getIndex();\n+        final int start = pos.getIndex();\n         seekNonWs(pattern, pos);\n-        int text = pos.getIndex();\n+        final int text = pos.getIndex();\n         int depth = 1;\n         for (; pos.getIndex() < pattern.length(); next(pos)) {\n             switch (pattern.charAt(pos.getIndex())) {\n         if (!containsElements(customPatterns)) {\n             return pattern;\n         }\n-        StringBuilder sb = new StringBuilder(pattern.length() * 2);\n-        ParsePosition pos = new ParsePosition(0);\n+        final StringBuilder sb = new StringBuilder(pattern.length() * 2);\n+        final ParsePosition pos = new ParsePosition(0);\n         int fe = -1;\n         int depth = 0;\n         while (pos.getIndex() < pattern.length()) {\n-            char c = pattern.charAt(pos.getIndex());\n+            final char c = pattern.charAt(pos.getIndex());\n             switch (c) {\n             case QUOTE:\n                 appendQuotedString(pattern, pos, sb, false);\n                     fe++;\n                     sb.append(START_FE).append(\n                             readArgumentIndex(pattern, next(pos)));\n-                    String customPattern = customPatterns.get(fe);\n+                    final String customPattern = customPatterns.get(fe);\n                     if (customPattern != null) {\n                         sb.append(START_FMT).append(customPattern);\n                     }\n      */\n     private void seekNonWs(final String pattern, final ParsePosition pos) {\n         int len = 0;\n-        char[] buffer = pattern.toCharArray();\n+        final char[] buffer = pattern.toCharArray();\n         do {\n             len = StrMatcher.splitMatcher().isMatch(buffer, pos.getIndex());\n             pos.setIndex(pos.getIndex() + len);\n      */\n     private StringBuilder appendQuotedString(final String pattern, final ParsePosition pos,\n             final StringBuilder appendTo, final boolean escapingOn) {\n-        int start = pos.getIndex();\n-        char[] c = pattern.toCharArray();\n+        final int start = pos.getIndex();\n+        final char[] c = pattern.toCharArray();\n         if (escapingOn && c[start] == QUOTE) {\n             next(pos);\n             return appendTo == null ? null : appendTo.append(QUOTE);\n         if (coll == null || coll.isEmpty()) {\n             return false;\n         }\n-        for (Object name : coll) {\n+        for (final Object name : coll) {\n             if (name != null) {\n                 return true;\n             }\n--- a/src/main/java/org/apache/commons/lang3/text/FormattableUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/text/FormattableUtils.java\n             final int precision, final char padChar, final CharSequence ellipsis) {\n         Validate.isTrue(ellipsis == null || precision < 0 || ellipsis.length() <= precision,\n                 \"Specified ellipsis '%1$s' exceeds precision of %2$s\", ellipsis, Integer.valueOf(precision));\n-        StringBuilder buf = new StringBuilder(seq);\n+        final StringBuilder buf = new StringBuilder(seq);\n         if (precision >= 0 && precision < seq.length()) {\n-            CharSequence _ellipsis = ObjectUtils.defaultIfNull(ellipsis, StringUtils.EMPTY);\n+            final CharSequence _ellipsis = ObjectUtils.defaultIfNull(ellipsis, StringUtils.EMPTY);\n             buf.replace(precision - _ellipsis.length(), seq.length(), _ellipsis.toString());\n         }\n-        boolean leftJustify = (flags & LEFT_JUSTIFY) == LEFT_JUSTIFY;\n+        final boolean leftJustify = (flags & LEFT_JUSTIFY) == LEFT_JUSTIFY;\n         for (int i = buf.length(); i < width; i++) {\n             buf.insert(leftJustify ? i : 0, padChar);\n         }\n--- a/src/main/java/org/apache/commons/lang3/text/StrBuilder.java\n+++ b/src/main/java/org/apache/commons/lang3/text/StrBuilder.java\n             size = length;\n         } else if (length > size) {\n             ensureCapacity(length);\n-            int oldEnd = size;\n-            int newEnd = length;\n+            final int oldEnd = size;\n+            final int newEnd = length;\n             size = length;\n             for (int i = oldEnd; i < newEnd; i++) {\n                 buffer[i] = '\\0';\n      */\n     public StrBuilder ensureCapacity(final int capacity) {\n         if (capacity > buffer.length) {\n-            char[] old = buffer;\n+            final char[] old = buffer;\n             buffer = new char[capacity * 2];\n             System.arraycopy(old, 0, buffer, 0, size);\n         }\n      */\n     public StrBuilder minimizeCapacity() {\n         if (buffer.length > length()) {\n-            char[] old = buffer;\n+            final char[] old = buffer;\n             buffer = new char[length()];\n             System.arraycopy(old, 0, buffer, 0, size);\n         }\n         if (size == 0) {\n             return ArrayUtils.EMPTY_CHAR_ARRAY;\n         }\n-        char chars[] = new char[size];\n+        final char chars[] = new char[size];\n         System.arraycopy(buffer, 0, chars, 0, size);\n         return chars;\n     }\n      */\n     public char[] toCharArray(final int startIndex, int endIndex) {\n         endIndex = validateRange(startIndex, endIndex);\n-        int len = endIndex - startIndex;\n+        final int len = endIndex - startIndex;\n         if (len == 0) {\n             return ArrayUtils.EMPTY_CHAR_ARRAY;\n         }\n-        char chars[] = new char[len];\n+        final char chars[] = new char[len];\n         System.arraycopy(buffer, startIndex, chars, 0, len);\n         return chars;\n     }\n      * @return the input array, unless that was null or too small\n      */\n     public char[] getChars(char[] destination) {\n-        int len = length();\n+        final int len = length();\n         if (destination == null || destination.length < len) {\n             destination = new char[len];\n         }\n         if (str == null) {\n             return appendNull();\n         }\n-        int strLen = str.length();\n+        final int strLen = str.length();\n         if (strLen > 0) {\n-            int len = length();\n+            final int len = length();\n             ensureCapacity(len + strLen);\n             str.getChars(0, strLen, buffer, len);\n             size += strLen;\n             throw new StringIndexOutOfBoundsException(\"length must be valid\");\n         }\n         if (length > 0) {\n-            int len = length();\n+            final int len = length();\n             ensureCapacity(len + length);\n             str.getChars(startIndex, startIndex + length, buffer, len);\n             size += length;\n         if (str == null) {\n             return appendNull();\n         }\n-        int strLen = str.length();\n+        final int strLen = str.length();\n         if (strLen > 0) {\n-            int len = length();\n+            final int len = length();\n             ensureCapacity(len + strLen);\n             str.getChars(0, strLen, buffer, len);\n             size += strLen;\n             throw new StringIndexOutOfBoundsException(\"length must be valid\");\n         }\n         if (length > 0) {\n-            int len = length();\n+            final int len = length();\n             ensureCapacity(len + length);\n             str.getChars(startIndex, startIndex + length, buffer, len);\n             size += length;\n         if (str == null) {\n             return appendNull();\n         }\n-        int strLen = str.length();\n+        final int strLen = str.length();\n         if (strLen > 0) {\n-            int len = length();\n+            final int len = length();\n             ensureCapacity(len + strLen);\n             str.getChars(0, strLen, buffer, len);\n             size += strLen;\n             throw new StringIndexOutOfBoundsException(\"length must be valid\");\n         }\n         if (length > 0) {\n-            int len = length();\n+            final int len = length();\n             ensureCapacity(len + length);\n             str.getChars(startIndex, startIndex + length, buffer, len);\n             size += length;\n         if (str == null) {\n             return appendNull();\n         }\n-        int strLen = str.length();\n+        final int strLen = str.length();\n         if (strLen > 0) {\n-            int len = length();\n+            final int len = length();\n             ensureCapacity(len + strLen);\n             System.arraycopy(str.buffer, 0, buffer, len, strLen);\n             size += strLen;\n             throw new StringIndexOutOfBoundsException(\"length must be valid\");\n         }\n         if (length > 0) {\n-            int len = length();\n+            final int len = length();\n             ensureCapacity(len + length);\n             str.getChars(startIndex, startIndex + length, buffer, len);\n             size += length;\n         if (chars == null) {\n             return appendNull();\n         }\n-        int strLen = chars.length;\n+        final int strLen = chars.length;\n         if (strLen > 0) {\n-            int len = length();\n+            final int len = length();\n             ensureCapacity(len + strLen);\n             System.arraycopy(chars, 0, buffer, len, strLen);\n             size += strLen;\n             throw new StringIndexOutOfBoundsException(\"Invalid length: \" + length);\n         }\n         if (length > 0) {\n-            int len = length();\n+            final int len = length();\n             ensureCapacity(len + length);\n             System.arraycopy(chars, startIndex, buffer, len, length);\n             size += length;\n      */\n     @Override\n     public StrBuilder append(final char ch) {\n-        int len = length();\n+        final int len = length();\n         ensureCapacity(len + 1);\n         buffer[size++] = ch;\n         return this;\n      */\n     public <T> StrBuilder appendAll(final T... array) {\n         if (array != null && array.length > 0) {\n-            for (Object element : array) {\n+            for (final Object element : array) {\n                 append(element);\n             }\n         }\n      */\n     public StrBuilder appendAll(final Iterable<?> iterable) {\n         if (iterable != null) {\n-            for (Object o : iterable) {\n+            for (final Object o : iterable) {\n                 append(o);\n             }\n         }\n     public StrBuilder appendWithSeparators(final Iterable<?> iterable, String separator) {\n         if (iterable != null) {\n             separator = ObjectUtils.toString(separator);\n-            Iterator<?> it = iterable.iterator();\n+            final Iterator<?> it = iterable.iterator();\n             while (it.hasNext()) {\n                 append(it.next());\n                 if (it.hasNext()) {\n      * @since 2.5\n      */\n     public StrBuilder appendSeparator(final String standard, final String defaultIfEmpty) {\n-        String str = isEmpty() ? defaultIfEmpty : standard;\n+        final String str = isEmpty() ? defaultIfEmpty : standard;\n         if (str != null) {\n             append(str);\n         }\n             if (str == null) {\n                 str = \"\";\n             }\n-            int strLen = str.length();\n+            final int strLen = str.length();\n             if (strLen >= width) {\n                 str.getChars(strLen - width, strLen, buffer, size);\n             } else {\n-                int padLen = width - strLen;\n+                final int padLen = width - strLen;\n                 for (int i = 0; i < padLen; i++) {\n                     buffer[size + i] = padChar;\n                 }\n             if (str == null) {\n                 str = \"\";\n             }\n-            int strLen = str.length();\n+            final int strLen = str.length();\n             if (strLen >= width) {\n                 str.getChars(0, width, buffer, size);\n             } else {\n-                int padLen = width - strLen;\n+                final int padLen = width - strLen;\n                 str.getChars(0, strLen, buffer, size);\n                 for (int i = 0; i < padLen; i++) {\n                     buffer[size + strLen + i] = padChar;\n         if (str == null) {\n             str = nullText;\n         }\n-        int strLen = (str == null ? 0 : str.length());\n+        final int strLen = (str == null ? 0 : str.length());\n         if (strLen > 0) {\n-            int newSize = size + strLen;\n+            final int newSize = size + strLen;\n             ensureCapacity(newSize);\n             System.arraycopy(buffer, index, buffer, index + strLen, size - index);\n             size = newSize;\n         if (chars == null) {\n             return insert(index, nullText);\n         }\n-        int len = chars.length;\n+        final int len = chars.length;\n         if (len > 0) {\n             ensureCapacity(size + len);\n             System.arraycopy(buffer, index, buffer, index + len, size - index);\n      */\n     public StrBuilder delete(final int startIndex, int endIndex) {\n         endIndex = validateRange(startIndex, endIndex);\n-        int len = endIndex - startIndex;\n+        final int len = endIndex - startIndex;\n         if (len > 0) {\n             deleteImpl(startIndex, endIndex, len);\n         }\n     public StrBuilder deleteAll(final char ch) {\n         for (int i = 0; i < size; i++) {\n             if (buffer[i] == ch) {\n-                int start = i;\n+                final int start = i;\n                 while (++i < size) {\n                     if (buffer[i] != ch) {\n                         break;\n                     }\n                 }\n-                int len = i - start;\n+                final int len = i - start;\n                 deleteImpl(start, i, len);\n                 i -= len;\n             }\n      * @return this, to enable chaining\n      */\n     public StrBuilder deleteAll(final String str) {\n-        int len = (str == null ? 0 : str.length());\n+        final int len = (str == null ? 0 : str.length());\n         if (len > 0) {\n             int index = indexOf(str, 0);\n             while (index >= 0) {\n      * @return this, to enable chaining\n      */\n     public StrBuilder deleteFirst(final String str) {\n-        int len = (str == null ? 0 : str.length());\n+        final int len = (str == null ? 0 : str.length());\n         if (len > 0) {\n-            int index = indexOf(str, 0);\n+            final int index = indexOf(str, 0);\n             if (index >= 0) {\n                 deleteImpl(index, index + len, len);\n             }\n      * @throws IndexOutOfBoundsException if any index is invalid\n      */\n     private void replaceImpl(final int startIndex, final int endIndex, final int removeLen, final String insertStr, final int insertLen) {\n-        int newSize = size - removeLen + insertLen;\n+        final int newSize = size - removeLen + insertLen;\n         if (insertLen != removeLen) {\n             ensureCapacity(newSize);\n             System.arraycopy(buffer, endIndex, buffer, startIndex + insertLen, size - endIndex);\n      */\n     public StrBuilder replace(final int startIndex, int endIndex, final String replaceStr) {\n         endIndex = validateRange(startIndex, endIndex);\n-        int insertLen = (replaceStr == null ? 0 : replaceStr.length());\n+        final int insertLen = (replaceStr == null ? 0 : replaceStr.length());\n         replaceImpl(startIndex, endIndex, endIndex - startIndex, replaceStr, insertLen);\n         return this;\n     }\n      * @return this, to enable chaining\n      */\n     public StrBuilder replaceAll(final String searchStr, final String replaceStr) {\n-        int searchLen = (searchStr == null ? 0 : searchStr.length());\n+        final int searchLen = (searchStr == null ? 0 : searchStr.length());\n         if (searchLen > 0) {\n-            int replaceLen = (replaceStr == null ? 0 : replaceStr.length());\n+            final int replaceLen = (replaceStr == null ? 0 : replaceStr.length());\n             int index = indexOf(searchStr, 0);\n             while (index >= 0) {\n                 replaceImpl(index, index + searchLen, searchLen, replaceStr, replaceLen);\n      * @return this, to enable chaining\n      */\n     public StrBuilder replaceFirst(final String searchStr, final String replaceStr) {\n-        int searchLen = (searchStr == null ? 0 : searchStr.length());\n+        final int searchLen = (searchStr == null ? 0 : searchStr.length());\n         if (searchLen > 0) {\n-            int index = indexOf(searchStr, 0);\n+            final int index = indexOf(searchStr, 0);\n             if (index >= 0) {\n-                int replaceLen = (replaceStr == null ? 0 : replaceStr.length());\n+                final int replaceLen = (replaceStr == null ? 0 : replaceStr.length());\n                 replaceImpl(index, index + searchLen, searchLen, replaceStr, replaceLen);\n             }\n         }\n         if (matcher == null || size == 0) {\n             return this;\n         }\n-        int replaceLen = (replaceStr == null ? 0 : replaceStr.length());\n-        char[] buf = buffer;\n+        final int replaceLen = (replaceStr == null ? 0 : replaceStr.length());\n+        final char[] buf = buffer;\n         for (int i = from; i < to && replaceCount != 0; i++) {\n-            int removeLen = matcher.isMatch(buf, i, from, to);\n+            final int removeLen = matcher.isMatch(buf, i, from, to);\n             if (removeLen > 0) {\n                 replaceImpl(i, i + removeLen, removeLen, replaceStr, replaceLen);\n                 to = to - removeLen + replaceLen;\n             return this;\n         }\n         \n-        int half = size / 2;\n-        char[] buf = buffer;\n+        final int half = size / 2;\n+        final char[] buf = buffer;\n         for (int leftIdx = 0, rightIdx = size - 1; leftIdx < half; leftIdx++,rightIdx--) {\n-            char swap = buf[leftIdx];\n+            final char swap = buf[leftIdx];\n             buf[leftIdx] = buf[rightIdx];\n             buf[rightIdx] = swap;\n         }\n             return this;\n         }\n         int len = size;\n-        char[] buf = buffer;\n+        final char[] buf = buffer;\n         int pos = 0;\n         while (pos < len && buf[pos] <= ' ') {\n             pos++;\n         if (str == null) {\n             return false;\n         }\n-        int len = str.length();\n+        final int len = str.length();\n         if (len == 0) {\n             return true;\n         }\n         if (str == null) {\n             return false;\n         }\n-        int len = str.length();\n+        final int len = str.length();\n         if (len == 0) {\n             return true;\n         }\n      * @return true if the builder contains the character\n      */\n     public boolean contains(final char ch) {\n-        char[] thisBuf = buffer;\n+        final char[] thisBuf = buffer;\n         for (int i = 0; i < this.size; i++) {\n             if (thisBuf[i] == ch) {\n                 return true;\n         if (startIndex >= size) {\n             return -1;\n         }\n-        char[] thisBuf = buffer;\n+        final char[] thisBuf = buffer;\n         for (int i = startIndex; i < size; i++) {\n             if (thisBuf[i] == ch) {\n                 return i;\n         if (str == null || startIndex >= size) {\n             return -1;\n         }\n-        int strLen = str.length();\n+        final int strLen = str.length();\n         if (strLen == 1) {\n             return indexOf(str.charAt(0), startIndex);\n         }\n         if (strLen > size) {\n             return -1;\n         }\n-        char[] thisBuf = buffer;\n-        int len = size - strLen + 1;\n+        final char[] thisBuf = buffer;\n+        final int len = size - strLen + 1;\n         outer:\n         for (int i = startIndex; i < len; i++) {\n             for (int j = 0; j < strLen; j++) {\n         if (matcher == null || startIndex >= size) {\n             return -1;\n         }\n-        int len = size;\n-        char[] buf = buffer;\n+        final int len = size;\n+        final char[] buf = buffer;\n         for (int i = startIndex; i < len; i++) {\n             if (matcher.isMatch(buf, i, startIndex, len) > 0) {\n                 return i;\n         if (str == null || startIndex < 0) {\n             return -1;\n         }\n-        int strLen = str.length();\n+        final int strLen = str.length();\n         if (strLen > 0 && strLen <= size) {\n             if (strLen == 1) {\n                 return lastIndexOf(str.charAt(0), startIndex);\n         if (matcher == null || startIndex < 0) {\n             return -1;\n         }\n-        char[] buf = buffer;\n-        int endIndex = startIndex + 1;\n+        final char[] buf = buffer;\n+        final int endIndex = startIndex + 1;\n         for (int i = startIndex; i >= 0; i--) {\n             if (matcher.isMatch(buf, i, 0, endIndex) > 0) {\n                 return i;\n         if (this.size != other.size) {\n             return false;\n         }\n-        char thisBuf[] = this.buffer;\n-        char otherBuf[] = other.buffer;\n+        final char thisBuf[] = this.buffer;\n+        final char otherBuf[] = other.buffer;\n         for (int i = size - 1; i >= 0; i--) {\n-            char c1 = thisBuf[i];\n-            char c2 = otherBuf[i];\n+            final char c1 = thisBuf[i];\n+            final char c2 = otherBuf[i];\n             if (c1 != c2 && Character.toUpperCase(c1) != Character.toUpperCase(c2)) {\n                 return false;\n             }\n         if (this.size != other.size) {\n             return false;\n         }\n-        char thisBuf[] = this.buffer;\n-        char otherBuf[] = other.buffer;\n+        final char thisBuf[] = this.buffer;\n+        final char otherBuf[] = other.buffer;\n         for (int i = size - 1; i >= 0; i--) {\n             if (thisBuf[i] != otherBuf[i]) {\n                 return false;\n      */\n     @Override\n     public int hashCode() {\n-        char buf[] = buffer;\n+        final char buf[] = buffer;\n         int hash = 0;\n         for (int i = size - 1; i >= 0; i--) {\n             hash = 31 * hash + buf[i];\n         /** {@inheritDoc} */\n         @Override\n         public String getContent() {\n-            String str = super.getContent();\n+            final String str = super.getContent();\n             if (str == null) {\n                 return StrBuilder.this.toString();\n             } else {\n--- a/src/main/java/org/apache/commons/lang3/text/StrLookup.java\n+++ b/src/main/java/org/apache/commons/lang3/text/StrLookup.java\n             @SuppressWarnings(\"unchecked\") // System property keys and values are always Strings\n             final Map<String, String> properties = (Map<String, String>) propMap;\n             lookup = new MapStrLookup<String>(properties);\n-        } catch (SecurityException ex) {\n+        } catch (final SecurityException ex) {\n             lookup = NONE_LOOKUP;\n         }\n         SYSTEM_PROPERTIES_LOOKUP = lookup;\n             if (map == null) {\n                 return null;\n             }\n-            Object obj = map.get(key);\n+            final Object obj = map.get(key);\n             if (obj == null) {\n                 return null;\n             }\n--- a/src/main/java/org/apache/commons/lang3/text/StrMatcher.java\n+++ b/src/main/java/org/apache/commons/lang3/text/StrMatcher.java\n          */\n         @Override\n         public int isMatch(final char[] buffer, int pos, final int bufferStart, final int bufferEnd) {\n-            int len = chars.length;\n+            final int len = chars.length;\n             if (pos + len > bufferEnd) {\n                 return 0;\n             }\n--- a/src/main/java/org/apache/commons/lang3/text/StrSubstitutor.java\n+++ b/src/main/java/org/apache/commons/lang3/text/StrSubstitutor.java\n         if (valueProperties == null) {\n             return source.toString();\n         }\n-        Map<String,String> valueMap = new HashMap<String,String>();\n-        Enumeration<?> propNames = valueProperties.propertyNames();\n+        final Map<String,String> valueMap = new HashMap<String,String>();\n+        final Enumeration<?> propNames = valueProperties.propertyNames();\n         while (propNames.hasMoreElements()) {\n-            String propName = (String)propNames.nextElement();\n-            String propValue = valueProperties.getProperty(propName);\n+            final String propName = (String)propNames.nextElement();\n+            final String propValue = valueProperties.getProperty(propName);\n             valueMap.put(propName, propValue);\n         }\n         return StrSubstitutor.replace(source, valueMap);\n         if (source == null) {\n             return null;\n         }\n-        StrBuilder buf = new StrBuilder(source);\n+        final StrBuilder buf = new StrBuilder(source);\n         if (substitute(buf, 0, source.length()) == false) {\n             return source;\n         }\n         if (source == null) {\n             return null;\n         }\n-        StrBuilder buf = new StrBuilder(length).append(source, offset, length);\n+        final StrBuilder buf = new StrBuilder(length).append(source, offset, length);\n         if (substitute(buf, 0, length) == false) {\n             return source.substring(offset, offset + length);\n         }\n         if (source == null) {\n             return null;\n         }\n-        StrBuilder buf = new StrBuilder(source.length).append(source);\n+        final StrBuilder buf = new StrBuilder(source.length).append(source);\n         substitute(buf, 0, source.length);\n         return buf.toString();\n     }\n         if (source == null) {\n             return null;\n         }\n-        StrBuilder buf = new StrBuilder(length).append(source, offset, length);\n+        final StrBuilder buf = new StrBuilder(length).append(source, offset, length);\n         substitute(buf, 0, length);\n         return buf.toString();\n     }\n         if (source == null) {\n             return null;\n         }\n-        StrBuilder buf = new StrBuilder(source.length()).append(source);\n+        final StrBuilder buf = new StrBuilder(source.length()).append(source);\n         substitute(buf, 0, buf.length());\n         return buf.toString();\n     }\n         if (source == null) {\n             return null;\n         }\n-        StrBuilder buf = new StrBuilder(length).append(source, offset, length);\n+        final StrBuilder buf = new StrBuilder(length).append(source, offset, length);\n         substitute(buf, 0, length);\n         return buf.toString();\n     }\n         if (source == null) {\n             return null;\n         }\n-        StrBuilder buf = new StrBuilder(source.length()).append(source);\n+        final StrBuilder buf = new StrBuilder(source.length()).append(source);\n         substitute(buf, 0, buf.length());\n         return buf.toString();\n     }\n         if (source == null) {\n             return null;\n         }\n-        StrBuilder buf = new StrBuilder(length).append(source, offset, length);\n+        final StrBuilder buf = new StrBuilder(length).append(source, offset, length);\n         substitute(buf, 0, length);\n         return buf.toString();\n     }\n         if (source == null) {\n             return null;\n         }\n-        StrBuilder buf = new StrBuilder().append(source);\n+        final StrBuilder buf = new StrBuilder().append(source);\n         substitute(buf, 0, buf.length());\n         return buf.toString();\n     }\n         if (source == null) {\n             return false;\n         }\n-        StrBuilder buf = new StrBuilder(length).append(source, offset, length);\n+        final StrBuilder buf = new StrBuilder(length).append(source, offset, length);\n         if (substitute(buf, 0, length) == false) {\n             return false;\n         }\n      *  represents a boolean flag as to whether any change occurred.\n      */\n     private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables) {\n-        StrMatcher prefixMatcher = getVariablePrefixMatcher();\n-        StrMatcher suffixMatcher = getVariableSuffixMatcher();\n-        char escape = getEscapeChar();\n-\n-        boolean top = priorVariables == null;\n+        final StrMatcher prefixMatcher = getVariablePrefixMatcher();\n+        final StrMatcher suffixMatcher = getVariableSuffixMatcher();\n+        final char escape = getEscapeChar();\n+\n+        final boolean top = priorVariables == null;\n         boolean altered = false;\n         int lengthChange = 0;\n         char[] chars = buf.buffer;\n         int bufEnd = offset + length;\n         int pos = offset;\n         while (pos < bufEnd) {\n-            int startMatchLen = prefixMatcher.isMatch(chars, pos, offset,\n+            final int startMatchLen = prefixMatcher.isMatch(chars, pos, offset,\n                     bufEnd);\n             if (startMatchLen == 0) {\n                 pos++;\n                     bufEnd--;\n                 } else {\n                     // find suffix\n-                    int startPos = pos;\n+                    final int startPos = pos;\n                     pos += startMatchLen;\n                     int endMatchLen = 0;\n                     int nestedVarCount = 0;\n                                         + startMatchLen, pos - startPos\n                                         - startMatchLen);\n                                 if (isEnableSubstitutionInVariables()) {\n-                                    StrBuilder bufName = new StrBuilder(varName);\n+                                    final StrBuilder bufName = new StrBuilder(varName);\n                                     substitute(bufName, 0, bufName.length());\n                                     varName = bufName.toString();\n                                 }\n                                 pos += endMatchLen;\n-                                int endPos = pos;\n+                                final int endPos = pos;\n \n                                 // on the first call initialize priorVariables\n                                 if (priorVariables == null) {\n                                 priorVariables.add(varName);\n \n                                 // resolve the variable\n-                                String varValue = resolveVariable(varName, buf,\n+                                final String varValue = resolveVariable(varName, buf,\n                                         startPos, endPos);\n                                 if (varValue != null) {\n                                     // recursive replace\n-                                    int varLen = varValue.length();\n+                                    final int varLen = varValue.length();\n                                     buf.replace(startPos, endPos, varValue);\n                                     altered = true;\n                                     int change = substitute(buf, startPos,\n         if (priorVariables.contains(varName) == false) {\n             return;\n         }\n-        StrBuilder buf = new StrBuilder(256);\n+        final StrBuilder buf = new StrBuilder(256);\n         buf.append(\"Infinite loop in property interpolation of \");\n         buf.append(priorVariables.remove(0));\n         buf.append(\": \");\n      * @return the variable's value or <b>null</b> if the variable is unknown\n      */\n     protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos) {\n-        StrLookup<?> resolver = getVariableResolver();\n+        final StrLookup<?> resolver = getVariableResolver();\n         if (resolver == null) {\n             return null;\n         }\n--- a/src/main/java/org/apache/commons/lang3/text/StrTokenizer.java\n+++ b/src/main/java/org/apache/commons/lang3/text/StrTokenizer.java\n      * @return a new tokenizer instance which parses Comma Separated Value strings\n      */\n     public static StrTokenizer getCSVInstance(final String input) {\n-        StrTokenizer tok = getCSVClone();\n+        final StrTokenizer tok = getCSVClone();\n         tok.reset(input);\n         return tok;\n     }\n      * @return a new tokenizer instance which parses Comma Separated Value strings\n      */\n     public static StrTokenizer getCSVInstance(final char[] input) {\n-        StrTokenizer tok = getCSVClone();\n+        final StrTokenizer tok = getCSVClone();\n         tok.reset(input);\n         return tok;\n     }\n      * @return a new tokenizer instance which parses Tab Separated Value strings.\n      */\n     public static StrTokenizer getTSVInstance(final String input) {\n-        StrTokenizer tok = getTSVClone();\n+        final StrTokenizer tok = getTSVClone();\n         tok.reset(input);\n         return tok;\n     }\n      * @return a new tokenizer instance which parses Tab Separated Value strings.\n      */\n     public static StrTokenizer getTSVInstance(final char[] input) {\n-        StrTokenizer tok = getTSVClone();\n+        final StrTokenizer tok = getTSVClone();\n         tok.reset(input);\n         return tok;\n     }\n      */\n     public List<String> getTokenList() {\n         checkTokenized();\n-        List<String> list = new ArrayList<String>(tokens.length);\n-        for (String element : tokens) {\n+        final List<String> list = new ArrayList<String>(tokens.length);\n+        for (final String element : tokens) {\n             list.add(element);\n         }\n         return list;\n         if (tokens == null) {\n             if (chars == null) {\n                 // still call tokenize as subclass may do some work\n-                List<String> split = tokenize(null, 0, 0);\n+                final List<String> split = tokenize(null, 0, 0);\n                 tokens = split.toArray(new String[split.size()]);\n             } else {\n-                List<String> split = tokenize(chars, 0, chars.length);\n+                final List<String> split = tokenize(chars, 0, chars.length);\n                 tokens = split.toArray(new String[split.size()]);\n             }\n         }\n         if (chars == null || count == 0) {\n             return Collections.emptyList();\n         }\n-        StrBuilder buf = new StrBuilder();\n-        List<String> tokens = new ArrayList<String>();\n+        final StrBuilder buf = new StrBuilder();\n+        final List<String> tokens = new ArrayList<String>();\n         int pos = offset;\n         \n         // loop around the entire buffer\n         // skip all leading whitespace, unless it is the\n         // field delimiter or the quote character\n         while (start < len) {\n-            int removeLen = Math.max(\n+            final int removeLen = Math.max(\n                     getIgnoredMatcher().isMatch(chars, start, start, len),\n                     getTrimmerMatcher().isMatch(chars, start, start, len));\n             if (removeLen == 0 ||\n         }\n         \n         // handle empty token\n-        int delimLen = getDelimiterMatcher().isMatch(chars, start, start, len);\n+        final int delimLen = getDelimiterMatcher().isMatch(chars, start, start, len);\n         if (delimLen > 0) {\n             addToken(tokens, \"\");\n             return start + delimLen;\n         }\n         \n         // handle found token\n-        int quoteLen = getQuoteMatcher().isMatch(chars, start, start, len);\n+        final int quoteLen = getQuoteMatcher().isMatch(chars, start, start, len);\n         if (quoteLen > 0) {\n             return readWithQuotes(chars, start + quoteLen, len, workArea, tokens, start, quoteLen);\n         }\n                 // Not in quoting mode\n                 \n                 // check for delimiter, and thus end of token\n-                int delimLen = getDelimiterMatcher().isMatch(chars, pos, start, len);\n+                final int delimLen = getDelimiterMatcher().isMatch(chars, pos, start, len);\n                 if (delimLen > 0) {\n                     // return condition when end of token found\n                     addToken(tokens, workArea.substring(0, trimStart));\n                 }\n                 \n                 // check for ignored (outside quotes), and ignore\n-                int ignoredLen = getIgnoredMatcher().isMatch(chars, pos, start, len);\n+                final int ignoredLen = getIgnoredMatcher().isMatch(chars, pos, start, len);\n                 if (ignoredLen > 0) {\n                     pos += ignoredLen;\n                     continue;\n                 // check for trimmed character\n                 // don't yet know if its at the end, so copy to workArea\n                 // use trimStart to keep track of trim at the end\n-                int trimmedLen = getTrimmerMatcher().isMatch(chars, pos, start, len);\n+                final int trimmedLen = getTrimmerMatcher().isMatch(chars, pos, start, len);\n                 if (trimmedLen > 0) {\n                     workArea.append(chars, pos, trimmedLen);\n                     pos += trimmedLen;\n     public Object clone() {\n         try {\n             return cloneReset();\n-        } catch (CloneNotSupportedException ex) {\n+        } catch (final CloneNotSupportedException ex) {\n             return null;\n         }\n     }\n      */\n     Object cloneReset() throws CloneNotSupportedException {\n         // this method exists to enable 100% test coverage\n-        StrTokenizer cloned = (StrTokenizer) super.clone();\n+        final StrTokenizer cloned = (StrTokenizer) super.clone();\n         if (cloned.chars != null) {\n             cloned.chars = cloned.chars.clone();\n         }\n--- a/src/main/java/org/apache/commons/lang3/text/WordUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/text/WordUtils.java\n         if (wrapLength < 1) {\n             wrapLength = 1;\n         }\n-        int inputLineLength = str.length();\n+        final int inputLineLength = str.length();\n         int offset = 0;\n-        StringBuilder wrappedLine = new StringBuilder(inputLineLength + 32);\n+        final StringBuilder wrappedLine = new StringBuilder(inputLineLength + 32);\n         \n         while (inputLineLength - offset > wrapLength) {\n             if (str.charAt(offset) == ' ') {\n      * @since 2.1\n      */\n     public static String capitalize(final String str, final char... delimiters) {\n-        int delimLen = delimiters == null ? -1 : delimiters.length;\n+        final int delimLen = delimiters == null ? -1 : delimiters.length;\n         if (StringUtils.isEmpty(str) || delimLen == 0) {\n             return str;\n         }\n-        char[] buffer = str.toCharArray();\n+        final char[] buffer = str.toCharArray();\n         boolean capitalizeNext = true;\n         for (int i = 0; i < buffer.length; i++) {\n-            char ch = buffer[i];\n+            final char ch = buffer[i];\n             if (isDelimiter(ch, delimiters)) {\n                 capitalizeNext = true;\n             } else if (capitalizeNext) {\n      * @since 2.1\n      */\n     public static String capitalizeFully(String str, final char... delimiters) {\n-        int delimLen = delimiters == null ? -1 : delimiters.length;\n+        final int delimLen = delimiters == null ? -1 : delimiters.length;\n         if (StringUtils.isEmpty(str) || delimLen == 0) {\n             return str;\n         }\n      * @since 2.1\n      */\n     public static String uncapitalize(final String str, final char... delimiters) {\n-        int delimLen = delimiters == null ? -1 : delimiters.length;\n+        final int delimLen = delimiters == null ? -1 : delimiters.length;\n         if (StringUtils.isEmpty(str) || delimLen == 0) {\n             return str;\n         }\n-        char[] buffer = str.toCharArray();\n+        final char[] buffer = str.toCharArray();\n         boolean uncapitalizeNext = true;\n         for (int i = 0; i < buffer.length; i++) {\n-            char ch = buffer[i];\n+            final char ch = buffer[i];\n             if (isDelimiter(ch, delimiters)) {\n                 uncapitalizeNext = true;\n             } else if (uncapitalizeNext) {\n         if (StringUtils.isEmpty(str)) {\n             return str;\n         }\n-        char[] buffer = str.toCharArray();\n+        final char[] buffer = str.toCharArray();\n \n         boolean whitespace = true;\n \n         for (int i = 0; i < buffer.length; i++) {\n-            char ch = buffer[i];\n+            final char ch = buffer[i];\n             if (Character.isUpperCase(ch)) {\n                 buffer[i] = Character.toLowerCase(ch);\n                 whitespace = false;\n         if (delimiters != null && delimiters.length == 0) {\n             return \"\";\n         }\n-        int strLen = str.length();\n-        char[] buf = new char[strLen / 2 + 1];\n+        final int strLen = str.length();\n+        final char[] buf = new char[strLen / 2 + 1];\n         int count = 0;\n         boolean lastWasGap = true;\n         for (int i = 0; i < strLen; i++) {\n-            char ch = str.charAt(i);\n+            final char ch = str.charAt(i);\n \n             if (isDelimiter(ch, delimiters)) {\n                 lastWasGap = true;\n         if (delimiters == null) {\n             return Character.isWhitespace(ch);\n         }\n-        for (char delimiter : delimiters) {\n+        for (final char delimiter : delimiters) {\n             if (ch == delimiter) {\n                 return true;\n             }\n--- a/src/main/java/org/apache/commons/lang3/text/translate/AggregateTranslator.java\n+++ b/src/main/java/org/apache/commons/lang3/text/translate/AggregateTranslator.java\n      */\n     @Override\n     public int translate(final CharSequence input, final int index, final Writer out) throws IOException {\n-        for (CharSequenceTranslator translator : translators) {\n-            int consumed = translator.translate(input, index, out);\n+        for (final CharSequenceTranslator translator : translators) {\n+            final int consumed = translator.translate(input, index, out);\n             if(consumed != 0) {\n                 return consumed;\n             }\n--- a/src/main/java/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java\n+++ b/src/main/java/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java\n             return null;\n         }\n         try {\n-            StringWriter writer = new StringWriter(input.length() * 2);\n+            final StringWriter writer = new StringWriter(input.length() * 2);\n             translate(input, writer);\n             return writer.toString();\n-        } catch (IOException ioe) {\n+        } catch (final IOException ioe) {\n             // this should never ever happen while writing to a StringWriter\n             throw new RuntimeException(ioe);\n         }\n             return;\n         }\n         int pos = 0;\n-        int len = input.length();\n+        final int len = input.length();\n         while (pos < len) {\n-            int consumed = translate(input, pos, out);\n+            final int consumed = translate(input, pos, out);\n             if (consumed == 0) {\n-                char[] c = Character.toChars(Character.codePointAt(input, pos));\n+                final char[] c = Character.toChars(Character.codePointAt(input, pos));\n                 out.write(c);\n                 pos+= c.length;\n                 continue;\n      * @return CharSequenceTranslator merging this translator with the others\n      */\n     public final CharSequenceTranslator with(final CharSequenceTranslator... translators) {\n-        CharSequenceTranslator[] newArray = new CharSequenceTranslator[translators.length + 1];\n+        final CharSequenceTranslator[] newArray = new CharSequenceTranslator[translators.length + 1];\n         newArray[0] = this;\n         System.arraycopy(translators, 0, newArray, 1, translators.length);\n         return new AggregateTranslator(newArray);\n--- a/src/main/java/org/apache/commons/lang3/text/translate/CodePointTranslator.java\n+++ b/src/main/java/org/apache/commons/lang3/text/translate/CodePointTranslator.java\n      */\n     @Override\n     public final int translate(final CharSequence input, final int index, final Writer out) throws IOException {\n-        int codepoint = Character.codePointAt(input, index);\n-        boolean consumed = translate(codepoint, out);\n+        final int codepoint = Character.codePointAt(input, index);\n+        final boolean consumed = translate(codepoint, out);\n         if (consumed) {\n             return 1;\n         } else {\n--- a/src/main/java/org/apache/commons/lang3/text/translate/EntityArrays.java\n+++ b/src/main/java/org/apache/commons/lang3/text/translate/EntityArrays.java\n      * @return String[][] inverted array\n      */\n     public static String[][] invert(final String[][] array) {\n-        String[][] newarray = new String[array.length][2];\n+        final String[][] newarray = new String[array.length][2];\n         for(int i = 0; i<array.length; i++) {\n             newarray[i][0] = array[i][1];\n             newarray[i][1] = array[i][0];\n--- a/src/main/java/org/apache/commons/lang3/text/translate/JavaUnicodeEscaper.java\n+++ b/src/main/java/org/apache/commons/lang3/text/translate/JavaUnicodeEscaper.java\n      */\n     @Override\n     protected String toUtf16Escape(final int codepoint) {\n-        char[] surrogatePair = Character.toChars(codepoint);\n+        final char[] surrogatePair = Character.toChars(codepoint);\n         return \"\\\\u\" + hex(surrogatePair[0]) + \"\\\\u\" + hex(surrogatePair[1]);\n     }\n \n--- a/src/main/java/org/apache/commons/lang3/text/translate/LookupTranslator.java\n+++ b/src/main/java/org/apache/commons/lang3/text/translate/LookupTranslator.java\n         int _shortest = Integer.MAX_VALUE;\n         int _longest = 0;\n         if (lookup != null) {\n-            for (CharSequence[] seq : lookup) {\n+            for (final CharSequence[] seq : lookup) {\n                 this.lookupMap.put(seq[0], seq[1]);\n-                int sz = seq[0].length();\n+                final int sz = seq[0].length();\n                 if (sz < _shortest) {\n                     _shortest = sz;\n                 }\n         }\n         // descend so as to get a greedy algorithm\n         for (int i = max; i >= shortest; i--) {\n-            CharSequence subSeq = input.subSequence(index, index + i);\n-            CharSequence result = lookupMap.get(subSeq);\n+            final CharSequence subSeq = input.subSequence(index, index + i);\n+            final CharSequence result = lookupMap.get(subSeq);\n             if (result != null) {\n                 out.write(result.toString());\n                 return i;\n--- a/src/main/java/org/apache/commons/lang3/text/translate/NumericEntityUnescaper.java\n+++ b/src/main/java/org/apache/commons/lang3/text/translate/NumericEntityUnescaper.java\n      */\n     @Override\n     public int translate(final CharSequence input, final int index, final Writer out) throws IOException {\n-        int seqEnd = input.length();\n+        final int seqEnd = input.length();\n         // Uses -2 to ensure there is something after the &#\n         if(input.charAt(index) == '&' && index < seqEnd - 2 && input.charAt(index + 1) == '#') {\n             int start = index + 2;\n             boolean isHex = false;\n \n-            char firstChar = input.charAt(start);\n+            final char firstChar = input.charAt(start);\n             if(firstChar == 'x' || firstChar == 'X') {\n                 start++;\n                 isHex = true;\n                 end++;\n             }\n \n-            boolean semiNext = end != seqEnd && input.charAt(end) == ';';\n+            final boolean semiNext = end != seqEnd && input.charAt(end) == ';';\n \n             if(!semiNext) {\n                 if(isSet(OPTION.semiColonRequired)) {\n                 } else {\n                     entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10);\n                 }\n-            } catch(NumberFormatException nfe) {\n+            } catch(final NumberFormatException nfe) {\n                 return 0;\n             }\n \n             if(entityValue > 0xFFFF) {\n-                char[] chrs = Character.toChars(entityValue);\n+                final char[] chrs = Character.toChars(entityValue);\n                 out.write(chrs[0]);\n                 out.write(chrs[1]);\n             } else {\n--- a/src/main/java/org/apache/commons/lang3/text/translate/OctalUnescaper.java\n+++ b/src/main/java/org/apache/commons/lang3/text/translate/OctalUnescaper.java\n     @Override\n     public int translate(final CharSequence input, final int index, final Writer out) throws IOException {\n         if(input.charAt(index) == '\\\\' && index < (input.length() - 1) && Character.isDigit(input.charAt(index + 1)) ) {\n-            int start = index + 1;\n+            final int start = index + 1;\n \n             int end = index + 2;\n             while ( end < input.length() && Character.isDigit(input.charAt(end)) ) {\n--- a/src/main/java/org/apache/commons/lang3/text/translate/UnicodeUnescaper.java\n+++ b/src/main/java/org/apache/commons/lang3/text/translate/UnicodeUnescaper.java\n \n             if (index + i + 4 <= input.length()) {\n                 // Get 4 hex digits\n-                CharSequence unicode = input.subSequence(index + i, index + i + 4);\n+                final CharSequence unicode = input.subSequence(index + i, index + i + 4);\n \n                 try {\n-                    int value = Integer.parseInt(unicode.toString(), 16);\n+                    final int value = Integer.parseInt(unicode.toString(), 16);\n                     out.write((char) value);\n-                } catch (NumberFormatException nfe) {\n+                } catch (final NumberFormatException nfe) {\n                     throw new IllegalArgumentException(\"Unable to parse unicode value: \" + unicode, nfe);\n                 }\n                 return i + 4;\n--- a/src/main/java/org/apache/commons/lang3/time/DateFormatUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/time/DateFormatUtils.java\n      * @return the formatted date\n      */\n     public static String format(final Date date, final String pattern, final TimeZone timeZone, final Locale locale) {\n-        FastDateFormat df = FastDateFormat.getInstance(pattern, timeZone, locale);\n+        final FastDateFormat df = FastDateFormat.getInstance(pattern, timeZone, locale);\n         return df.format(date);\n     }\n \n      * @since 2.4\n      */\n     public static String format(final Calendar calendar, final String pattern, final TimeZone timeZone, final Locale locale) {\n-        FastDateFormat df = FastDateFormat.getInstance(pattern, timeZone, locale);\n+        final FastDateFormat df = FastDateFormat.getInstance(pattern, timeZone, locale);\n         return df.format(calendar);\n     }\n \n--- a/src/main/java/org/apache/commons/lang3/time/DateUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/time/DateUtils.java\n         if (date1 == null || date2 == null) {\n             throw new IllegalArgumentException(\"The date must not be null\");\n         }\n-        Calendar cal1 = Calendar.getInstance();\n+        final Calendar cal1 = Calendar.getInstance();\n         cal1.setTime(date1);\n-        Calendar cal2 = Calendar.getInstance();\n+        final Calendar cal2 = Calendar.getInstance();\n         cal2.setTime(date2);\n         return isSameDay(cal1, cal2);\n     }\n         }\n         \n         parser.setLenient(lenient);\n-        ParsePosition pos = new ParsePosition(0);\n-        for (String parsePattern : parsePatterns) {\n+        final ParsePosition pos = new ParsePosition(0);\n+        for (final String parsePattern : parsePatterns) {\n \n             String pattern = parsePattern;\n \n                 str2 = str.replaceAll(\"([-+][0-9][0-9]):([0-9][0-9])$\", \"$1$2\"); \n             }\n \n-            Date date = parser.parse(str2, pos);\n+            final Date date = parser.parse(str2, pos);\n             if (date != null && pos.getIndex() == str2.length()) {\n                 return date;\n             }\n         if (date == null) {\n             throw new IllegalArgumentException(\"The date must not be null\");\n         }\n-        Calendar c = Calendar.getInstance();\n+        final Calendar c = Calendar.getInstance();\n         c.setTime(date);\n         c.add(calendarField, amount);\n         return c.getTime();\n             throw new IllegalArgumentException(\"The date must not be null\");\n         }\n         // getInstance() returns a new object, so this method is thread safe.\n-        Calendar c = Calendar.getInstance();\n+        final Calendar c = Calendar.getInstance();\n         c.setLenient(false);\n         c.setTime(date);\n         c.set(calendarField, amount);\n      * @since 3.0\n      */\n     public static Calendar toCalendar(final Date date) {\n-        Calendar c = Calendar.getInstance();\n+        final Calendar c = Calendar.getInstance();\n         c.setTime(date);\n         return c;\n     }\n         if (date == null) {\n             throw new IllegalArgumentException(\"The date must not be null\");\n         }\n-        Calendar gval = Calendar.getInstance();\n+        final Calendar gval = Calendar.getInstance();\n         gval.setTime(date);\n         modify(gval, field, MODIFY_ROUND);\n         return gval.getTime();\n         if (date == null) {\n             throw new IllegalArgumentException(\"The date must not be null\");\n         }\n-        Calendar rounded = (Calendar) date.clone();\n+        final Calendar rounded = (Calendar) date.clone();\n         modify(rounded, field, MODIFY_ROUND);\n         return rounded;\n     }\n         if (date == null) {\n             throw new IllegalArgumentException(\"The date must not be null\");\n         }\n-        Calendar gval = Calendar.getInstance();\n+        final Calendar gval = Calendar.getInstance();\n         gval.setTime(date);\n         modify(gval, field, MODIFY_TRUNCATE);\n         return gval.getTime();\n         if (date == null) {\n             throw new IllegalArgumentException(\"The date must not be null\");\n         }\n-        Calendar truncated = (Calendar) date.clone();\n+        final Calendar truncated = (Calendar) date.clone();\n         modify(truncated, field, MODIFY_TRUNCATE);\n         return truncated;\n     }\n         if (date == null) {\n             throw new IllegalArgumentException(\"The date must not be null\");\n         }\n-        Calendar gval = Calendar.getInstance();\n+        final Calendar gval = Calendar.getInstance();\n         gval.setTime(date);\n         modify(gval, field, MODIFY_CEILING);\n         return gval.getTime();\n         if (date == null) {\n             throw new IllegalArgumentException(\"The date must not be null\");\n         }\n-        Calendar ceiled = (Calendar) date.clone();\n+        final Calendar ceiled = (Calendar) date.clone();\n         modify(ceiled, field, MODIFY_CEILING);\n         return ceiled;\n     }\n         // Manually truncate milliseconds, seconds and minutes, rather than using\n         // Calendar methods.\n \n-        Date date = val.getTime();\n+        final Date date = val.getTime();\n         long time = date.getTime();\n         boolean done = false;\n \n         // truncate milliseconds\n-        int millisecs = val.get(Calendar.MILLISECOND);\n+        final int millisecs = val.get(Calendar.MILLISECOND);\n         if (MODIFY_TRUNCATE == modType || millisecs < 500) {\n             time = time - millisecs;\n         }\n         }\n \n         // truncate seconds\n-        int seconds = val.get(Calendar.SECOND);\n+        final int seconds = val.get(Calendar.SECOND);\n         if (!done && (MODIFY_TRUNCATE == modType || seconds < 30)) {\n             time = time - (seconds * 1000L);\n         }\n         }\n \n         // truncate minutes\n-        int minutes = val.get(Calendar.MINUTE);\n+        final int minutes = val.get(Calendar.MINUTE);\n         if (!done && (MODIFY_TRUNCATE == modType || minutes < 30)) {\n             time = time - (minutes * 60000L);\n         }\n         // ----------------- Fix for LANG-59 ----------------------- END ----------------\n \n         boolean roundUp = false;\n-        for (int[] aField : fields) {\n-            for (int element : aField) {\n+        for (final int[] aField : fields) {\n+            for (final int element : aField) {\n                 if (element == field) {\n                     //This is our field... we stop looping\n                     if (modType == MODIFY_CEILING || (modType == MODIFY_ROUND && roundUp)) {\n                     break;\n             }\n             if (!offsetSet) {\n-                int min = val.getActualMinimum(aField[0]);\n-                int max = val.getActualMaximum(aField[0]);\n+                final int min = val.getActualMinimum(aField[0]);\n+                final int max = val.getActualMaximum(aField[0]);\n                 //Calculate the offset from the minimum allowed value\n                 offset = val.get(aField[0]) - min;\n                 //Set roundUp if this is more than half way between the minimum and maximum\n         if (focus == null) {\n             throw new IllegalArgumentException(\"The date must not be null\");\n         }\n-        Calendar gval = Calendar.getInstance();\n+        final Calendar gval = Calendar.getInstance();\n         gval.setTime(focus);\n         return iterator(gval, rangeStyle);\n     }\n         if(date == null) {\n             throw  new IllegalArgumentException(\"The date must not be null\");\n         }\n-        Calendar calendar = Calendar.getInstance();\n+        final Calendar calendar = Calendar.getInstance();\n         calendar.setTime(date);\n         return getFragment(calendar, fragment, unit);\n     }\n         if(calendar == null) {\n             throw  new IllegalArgumentException(\"The date must not be null\"); \n         }\n-        long millisPerUnit = getMillisPerUnit(unit);\n+        final long millisPerUnit = getMillisPerUnit(unit);\n         long result = 0;\n         \n         // Fragments bigger than a day require a breakdown to days\n      * @since 3.0\n      */\n     public static int truncatedCompareTo(final Calendar cal1, final Calendar cal2, final int field) {\n-        Calendar truncatedCal1 = truncate(cal1, field);\n-        Calendar truncatedCal2 = truncate(cal2, field);\n+        final Calendar truncatedCal1 = truncate(cal1, field);\n+        final Calendar truncatedCal2 = truncate(cal2, field);\n         return truncatedCal1.compareTo(truncatedCal2);\n     }\n \n      * @since 3.0\n      */\n     public static int truncatedCompareTo(final Date date1, final Date date2, final int field) {\n-        Date truncatedDate1 = truncate(date1, field);\n-        Date truncatedDate2 = truncate(date2, field);\n+        final Date truncatedDate1 = truncate(date1, field);\n+        final Date truncatedDate2 = truncate(date2, field);\n         return truncatedDate1.compareTo(truncatedDate2);\n     }\n \n--- a/src/main/java/org/apache/commons/lang3/time/DurationFormatUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/time/DurationFormatUtils.java\n      */\n     public static String formatDuration(long durationMillis, final String format, final boolean padWithZeros) {\n \n-        Token[] tokens = lexx(format);\n+        final Token[] tokens = lexx(format);\n \n         int days         = 0;\n         int hours        = 0;\n         // TODO: Compare performance to see if anything was lost by \n         // losing this optimisation. \n         \n-        Token[] tokens = lexx(format);\n+        final Token[] tokens = lexx(format);\n \n         // timezones get funky around 0, so normalizing everything to GMT \n         // stops the hours being off\n-        Calendar start = Calendar.getInstance(timezone);\n+        final Calendar start = Calendar.getInstance(timezone);\n         start.setTime(new Date(startMillis));\n-        Calendar end = Calendar.getInstance(timezone);\n+        final Calendar end = Calendar.getInstance(timezone);\n         end.setTime(new Date(endMillis));\n \n         // initial estimates\n      */\n     static String format(final Token[] tokens, final int years, final int months, final int days, final int hours, final int minutes, final int seconds,\n             int milliseconds, final boolean padWithZeros) {\n-        StringBuilder buffer = new StringBuilder();\n+        final StringBuilder buffer = new StringBuilder();\n         boolean lastOutputSeconds = false;\n-        int sz = tokens.length;\n+        final int sz = tokens.length;\n         for (int i = 0; i < sz; i++) {\n-            Token token = tokens[i];\n-            Object value = token.getValue();\n-            int count = token.getCount();\n+            final Token token = tokens[i];\n+            final Object value = token.getValue();\n+            final int count = token.getCount();\n             if (value instanceof StringBuilder) {\n                 buffer.append(value.toString());\n             } else {\n                 } else if (value == S) {\n                     if (lastOutputSeconds) {\n                         milliseconds += 1000;\n-                        String str = padWithZeros\n+                        final String str = padWithZeros\n                                 ? StringUtils.leftPad(Integer.toString(milliseconds), count, '0')\n                                 : Integer.toString(milliseconds);\n                         buffer.append(str.substring(1));\n      * @return array of Token[]\n      */\n     static Token[] lexx(final String format) {\n-        char[] array = format.toCharArray();\n-        ArrayList<Token> list = new ArrayList<Token>(array.length);\n+        final char[] array = format.toCharArray();\n+        final ArrayList<Token> list = new ArrayList<Token>(array.length);\n \n         boolean inLiteral = false;\n         // Although the buffer is stored in a Token, the Tokens are only\n         // used internally, so cannot be accessed by other threads\n         StringBuilder buffer = null;\n         Token previous = null;\n-        int sz = array.length;\n+        final int sz = array.length;\n         for(int i=0; i<sz; i++) {\n-            char ch = array[i];\n+            final char ch = array[i];\n             if(inLiteral && ch != '\\'') {\n                 buffer.append(ch); // buffer can't be null if inLiteral is true\n                 continue;\n                 if(previous != null && previous.getValue() == value) {\n                     previous.increment();\n                 } else {\n-                    Token token = new Token(value);\n+                    final Token token = new Token(value);\n                     list.add(token); \n                     previous = token;\n                 }\n          * @return boolean <code>true</code> if contained\n          */\n         static boolean containsTokenWithValue(final Token[] tokens, final Object value) {\n-            int sz = tokens.length;\n+            final int sz = tokens.length;\n             for (int i = 0; i < sz; i++) {\n                 if (tokens[i].getValue() == value) {\n                     return true;\n         @Override\n         public boolean equals(final Object obj2) {\n             if (obj2 instanceof Token) {\n-                Token tok2 = (Token) obj2;\n+                final Token tok2 = (Token) obj2;\n                 if (this.value.getClass() != tok2.value.getClass()) {\n                     return false;\n                 }\n--- a/src/main/java/org/apache/commons/lang3/time/FastDateFormat.java\n+++ b/src/main/java/org/apache/commons/lang3/time/FastDateFormat.java\n         if (obj instanceof FastDateFormat == false) {\n             return false;\n         }\n-        FastDateFormat other = (FastDateFormat) obj;\n+        final FastDateFormat other = (FastDateFormat) obj;\n         // no need to check parser, as it has same invariants as printer\n         return printer.equals(other.printer);\n     }\n--- a/src/main/java/org/apache/commons/lang3/time/FastDateParser.java\n+++ b/src/main/java/org/apache/commons/lang3/time/FastDateParser.java\n      * This is called from constructor and from readObject (de-serialization)\n      */\n     private void init() {\n-        Calendar definingCalendar = Calendar.getInstance(timeZone, locale);\n+        final Calendar definingCalendar = Calendar.getInstance(timeZone, locale);\n         thisYear= definingCalendar.get(Calendar.YEAR);\n \n-        StringBuilder regex= new StringBuilder();\n-        List<Strategy> collector = new ArrayList<Strategy>();\n-\n-        Matcher patternMatcher= formatPattern.matcher(pattern);\n+        final StringBuilder regex= new StringBuilder();\n+        final List<Strategy> collector = new ArrayList<Strategy>();\n+\n+        final Matcher patternMatcher= formatPattern.matcher(pattern);\n         if(!patternMatcher.lookingAt()) {\n             throw new IllegalArgumentException(\n                     \"Illegal pattern character '\" + pattern.charAt(patternMatcher.regionStart()) + \"'\");\n                 nextStrategy = null;\n                 break;\n             }\n-            String nextFormatField= patternMatcher.group();\n+            final String nextFormatField= patternMatcher.group();\n             nextStrategy = getStrategy(nextFormatField, definingCalendar);\n             if(currentStrategy.addRegex(this, regex)) {\n                 collector.add(currentStrategy);\n         if (! (obj instanceof FastDateParser) ) {\n             return false;\n         }\n-        FastDateParser other = (FastDateParser) obj;\n+        final FastDateParser other = (FastDateParser) obj;\n         return pattern.equals(other.pattern)\n             && timeZone.equals(other.timeZone)\n             && locale.equals(other.locale);\n      */\n     @Override\n     public Date parse(final String source) throws ParseException {\n-        Date date= parse(source, new ParsePosition(0));\n+        final Date date= parse(source, new ParsePosition(0));\n         if(date==null) {\n             // Add a note re supported date range\n             if (locale.equals(JAPANESE_IMPERIAL)) {\n      */\n     @Override\n     public Date parse(final String source, final ParsePosition pos) {\n-        int offset= pos.getIndex();\n-        Matcher matcher= parsePattern.matcher(source.substring(offset));\n+        final int offset= pos.getIndex();\n+        final Matcher matcher= parsePattern.matcher(source.substring(offset));\n         if(!matcher.lookingAt()) {\n             return null;\n         }\n         // timing tests indicate getting new instance is 19% faster than cloning\n-        Calendar cal= Calendar.getInstance(timeZone, locale);\n+        final Calendar cal= Calendar.getInstance(timeZone, locale);\n         cal.clear();\n \n         for(int i=0; i<strategies.length;) {\n-            Strategy strategy= strategies[i++];\n+            final Strategy strategy= strategies[i++];\n             strategy.setCalendar(this, cal, matcher.group(i));\n         }\n         pos.setIndex(offset+matcher.end());\n      * @return A value within -80 and +20 years from instantiation of this instance\n      */\n     int adjustYear(final int twoDigitYear) {\n-        int trial= twoDigitYear + thisYear - thisYear%100;\n+        final int trial= twoDigitYear + thisYear - thisYear%100;\n         if(trial < thisYear+20) {\n             return trial;\n         }\n      * @return a TextStrategy for the field and Locale\n      */\n     private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar) {\n-        ConcurrentMap<Locale,Strategy> cache = getCache(field);\n+        final ConcurrentMap<Locale,Strategy> cache = getCache(field);\n         Strategy strategy= cache.get(Integer.valueOf(field));\n         if(strategy==null) {\n             strategy= field==Calendar.ZONE_OFFSET\n                     ? new TimeZoneStrategy(locale)\n                     : new TextStrategy(field, definingCalendar, locale);\n-            Strategy inCache= cache.putIfAbsent(locale, strategy);\n+            final Strategy inCache= cache.putIfAbsent(locale, strategy);\n             if(inCache!=null) {\n                 return inCache;\n             }\n         @Override\n         boolean addRegex(final FastDateParser parser, final StringBuilder regex) {\n             regex.append('(');\n-            for(String textKeyValue : keyValues.keySet()) {\n+            for(final String textKeyValue : keyValues.keySet()) {\n                 escapeRegex(regex, textKeyValue, false).append('|');\n             }\n             regex.setCharAt(regex.length()-1, ')');\n          */\n         @Override\n         void setCalendar(final FastDateParser parser, final Calendar cal, final String value) {\n-            Integer iVal = keyValues.get(value);\n+            final Integer iVal = keyValues.get(value);\n             if(iVal == null) {\n-                StringBuilder sb= new StringBuilder(value);\n+                final StringBuilder sb= new StringBuilder(value);\n                 sb.append(\" not in (\");\n-                for(String textKeyValue : keyValues.keySet()) {\n+                for(final String textKeyValue : keyValues.keySet()) {\n                     sb.append(textKeyValue).append(' ');\n                 }\n                 sb.setCharAt(sb.length()-1, ')');\n          * @param locale The Locale\n          */\n         TimeZoneStrategy(final Locale locale) {\n-            for(String id : TimeZone.getAvailableIDs()) {\n+            for(final String id : TimeZone.getAvailableIDs()) {\n                 if(id.startsWith(\"GMT\")) {\n                     continue;\n                 }\n-                TimeZone tz= TimeZone.getTimeZone(id);\n+                final TimeZone tz= TimeZone.getTimeZone(id);\n                 tzNames.put(tz.getDisplayName(false, TimeZone.SHORT, locale), tz);\n                 tzNames.put(tz.getDisplayName(false, TimeZone.LONG, locale), tz);\n                 if(tz.useDaylightTime()) {\n                     tzNames.put(tz.getDisplayName(true, TimeZone.LONG, locale), tz);\n                 }\n             }\n-            StringBuilder sb= new StringBuilder();\n+            final StringBuilder sb= new StringBuilder();\n             sb.append(\"(GMT[+\\\\-]\\\\d{0,1}\\\\d{2}|[+\\\\-]\\\\d{2}:?\\\\d{2}|\");\n-            for(String id : tzNames.keySet()) {\n+            for(final String id : tzNames.keySet()) {\n                 escapeRegex(sb, id, false).append('|');\n             }\n             sb.setCharAt(sb.length()-1, ')');\n--- a/src/main/java/org/apache/commons/lang3/time/FastDatePrinter.java\n+++ b/src/main/java/org/apache/commons/lang3/time/FastDatePrinter.java\n      * <p>Initializes the instance for first use.</p>\n      */\n     private void init() {\n-        List<Rule> rulesList = parsePattern();\n+        final List<Rule> rulesList = parsePattern();\n         mRules = rulesList.toArray(new Rule[rulesList.size()]);\n \n         int len = 0;\n      * @throws IllegalArgumentException if pattern is invalid\n      */\n     protected List<Rule> parsePattern() {\n-        DateFormatSymbols symbols = new DateFormatSymbols(mLocale);\n-        List<Rule> rules = new ArrayList<Rule>();\n-\n-        String[] ERAs = symbols.getEras();\n-        String[] months = symbols.getMonths();\n-        String[] shortMonths = symbols.getShortMonths();\n-        String[] weekdays = symbols.getWeekdays();\n-        String[] shortWeekdays = symbols.getShortWeekdays();\n-        String[] AmPmStrings = symbols.getAmPmStrings();\n-\n-        int length = mPattern.length();\n-        int[] indexRef = new int[1];\n+        final DateFormatSymbols symbols = new DateFormatSymbols(mLocale);\n+        final List<Rule> rules = new ArrayList<Rule>();\n+\n+        final String[] ERAs = symbols.getEras();\n+        final String[] months = symbols.getMonths();\n+        final String[] shortMonths = symbols.getShortMonths();\n+        final String[] weekdays = symbols.getWeekdays();\n+        final String[] shortWeekdays = symbols.getShortWeekdays();\n+        final String[] AmPmStrings = symbols.getAmPmStrings();\n+\n+        final int length = mPattern.length();\n+        final int[] indexRef = new int[1];\n \n         for (int i = 0; i < length; i++) {\n             indexRef[0] = i;\n-            String token = parseToken(mPattern, indexRef);\n+            final String token = parseToken(mPattern, indexRef);\n             i = indexRef[0];\n \n-            int tokenLen = token.length();\n+            final int tokenLen = token.length();\n             if (tokenLen == 0) {\n                 break;\n             }\n \n             Rule rule;\n-            char c = token.charAt(0);\n+            final char c = token.charAt(0);\n \n             switch (c) {\n             case 'G': // era designator (text)\n                 }\n                 break;\n             case '\\'': // literal text\n-                String sub = token.substring(1);\n+                final String sub = token.substring(1);\n                 if (sub.length() == 1) {\n                     rule = new CharacterLiteral(sub.charAt(0));\n                 } else {\n      * @return parsed token\n      */\n     protected String parseToken(final String pattern, final int[] indexRef) {\n-        StringBuilder buf = new StringBuilder();\n+        final StringBuilder buf = new StringBuilder();\n \n         int i = indexRef[0];\n-        int length = pattern.length();\n+        final int length = pattern.length();\n \n         char c = pattern.charAt(i);\n         if (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z') {\n             buf.append(c);\n \n             while (i + 1 < length) {\n-                char peek = pattern.charAt(i + 1);\n+                final char peek = pattern.charAt(i + 1);\n                 if (peek == c) {\n                     buf.append(c);\n                     i++;\n      */\n     @Override\n     public String format(final long millis) {\n-        Calendar c = newCalendar();  // hard code GregorianCalendar\n+        final Calendar c = newCalendar();  // hard code GregorianCalendar\n         c.setTimeInMillis(millis);\n         return applyRulesToString(c);\n     }\n      */\n     @Override\n     public String format(final Date date) {\n-        Calendar c = newCalendar();  // hard code GregorianCalendar\n+        final Calendar c = newCalendar();  // hard code GregorianCalendar\n         c.setTime(date);\n         return applyRulesToString(c);\n     }\n      */\n     @Override\n     public StringBuffer format(final Date date, final StringBuffer buf) {\n-        Calendar c = newCalendar();  // hard code GregorianCalendar\n+        final Calendar c = newCalendar();  // hard code GregorianCalendar\n         c.setTime(date);\n         return applyRules(c, buf);\n     }\n      * @return the specified string buffer\n      */\n     protected StringBuffer applyRules(final Calendar calendar, final StringBuffer buf) {\n-        for (Rule rule : mRules) {\n+        for (final Rule rule : mRules) {\n             rule.appendTo(buf, calendar);\n         }\n         return buf;\n         if (obj instanceof FastDatePrinter == false) {\n             return false;\n         }\n-        FastDatePrinter other = (FastDatePrinter) obj;\n+        final FastDatePrinter other = (FastDatePrinter) obj;\n         return mPattern.equals(other.mPattern)\n             && mTimeZone.equals(other.mTimeZone) \n             && mLocale.equals(other.mLocale);\n         public int estimateLength() {\n             int max = 0;\n             for (int i=mValues.length; --i >= 0; ) {\n-                int len = mValues[i].length();\n+                final int len = mValues[i].length();\n                 if (len > max) {\n                     max = len;\n                 }\n      * @return the textual name of the time zone\n      */\n     static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale) {\n-        TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n+        final TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n         String value = cTimeZoneDisplayCache.get(key);\n         if (value == null) {\n             // This is a very slow call, so cache the results.\n             value = tz.getDisplayName(daylight, style, locale);\n-            String prior = cTimeZoneDisplayCache.putIfAbsent(key, value);\n+            final String prior = cTimeZoneDisplayCache.putIfAbsent(key, value);\n             if (prior != null) {\n                 value= prior;\n             }\n          */\n         @Override\n         public void appendTo(final StringBuffer buffer, final Calendar calendar) {\n-            TimeZone zone = calendar.getTimeZone();\n+            final TimeZone zone = calendar.getTimeZone();\n             if (zone.useDaylightTime()\n                     && calendar.get(Calendar.DST_OFFSET) != 0) {\n                 buffer.append(getTimeZoneDisplay(zone, true, mStyle, mLocale));\n                 buffer.append('+');\n             }\n \n-            int hours = offset / (60 * 60 * 1000);\n+            final int hours = offset / (60 * 60 * 1000);\n             buffer.append((char)(hours / 10 + '0'));\n             buffer.append((char)(hours % 10 + '0'));\n \n                 buffer.append(':');\n             }\n \n-            int minutes = offset / (60 * 1000) - 60 * hours;\n+            final int minutes = offset / (60 * 1000) - 60 * hours;\n             buffer.append((char)(minutes / 10 + '0'));\n             buffer.append((char)(minutes % 10 + '0'));\n         }\n                 return true;\n             }\n             if (obj instanceof TimeZoneDisplayKey) {\n-                TimeZoneDisplayKey other = (TimeZoneDisplayKey)obj;\n+                final TimeZoneDisplayKey other = (TimeZoneDisplayKey)obj;\n                 return\n                     mTimeZone.equals(other.mTimeZone) &&\n                     mStyle == other.mStyle &&\n--- a/src/main/java/org/apache/commons/lang3/time/FormatCache.java\n+++ b/src/main/java/org/apache/commons/lang3/time/FormatCache.java\n         if (locale == null) {\n             locale = Locale.getDefault();\n         }\n-        MultipartKey key = new MultipartKey(pattern, timeZone, locale);\n+        final MultipartKey key = new MultipartKey(pattern, timeZone, locale);\n         F format = cInstanceCache.get(key);\n         if (format == null) {           \n             format = createInstance(pattern, timeZone, locale);\n-            F previousValue= cInstanceCache.putIfAbsent(key, format);\n+            final F previousValue= cInstanceCache.putIfAbsent(key, format);\n             if (previousValue != null) {\n                 // another thread snuck in and did the same work\n                 // we should return the instance that is in ConcurrentMap\n         if (locale == null) {\n             locale = Locale.getDefault();\n         }\n-        String pattern = getPatternForStyle(dateStyle, timeStyle, locale);\n+        final String pattern = getPatternForStyle(dateStyle, timeStyle, locale);\n         return getInstance(pattern, timeZone, locale);\n     }\n \n      * @throws IllegalArgumentException if the Locale has no date/time pattern defined\n      */\n     public static String getPatternForStyle(final Integer dateStyle, final Integer timeStyle, final Locale locale) {\n-        MultipartKey key = new MultipartKey(dateStyle, timeStyle, locale);\n+        final MultipartKey key = new MultipartKey(dateStyle, timeStyle, locale);\n \n         String pattern = cDateTimeInstanceCache.get(key);\n         if (pattern == null) {\n                     formatter = DateFormat.getDateTimeInstance(dateStyle.intValue(), timeStyle.intValue(), locale);\n                 }\n                 pattern = ((SimpleDateFormat)formatter).toPattern();\n-                String previous = cDateTimeInstanceCache.putIfAbsent(key, pattern);\n+                final String previous = cDateTimeInstanceCache.putIfAbsent(key, pattern);\n                 if (previous != null) {\n                     // even though it doesn't matter if another thread put the pattern\n                     // it's still good practice to return the String instance that is\n                     // actually in the ConcurrentMap\n                     pattern= previous;\n                 }\n-            } catch (ClassCastException ex) {\n+            } catch (final ClassCastException ex) {\n                 throw new IllegalArgumentException(\"No date time pattern for locale: \" + locale);\n             }\n         }\n         public int hashCode() {\n             if(hashCode==0) {\n                 int rc= 0;\n-                for(Object key : keys) {\n+                for(final Object key : keys) {\n                     if(key!=null) {\n                         rc= rc*7 + key.hashCode();\n                     }\n--- a/src/main/java/org/apache/commons/lang3/tuple/MutablePair.java\n+++ b/src/main/java/org/apache/commons/lang3/tuple/MutablePair.java\n      */\n     @Override\n     public R setValue(final R value) {\n-        R result = getRight();\n+        final R result = getRight();\n         setRight(value);\n         return result;\n     }\n--- a/src/main/java/org/apache/commons/lang3/tuple/Pair.java\n+++ b/src/main/java/org/apache/commons/lang3/tuple/Pair.java\n             return true;\n         }\n         if (obj instanceof Map.Entry<?, ?>) {\n-            Map.Entry<?, ?> other = (Map.Entry<?, ?>) obj;\n+            final Map.Entry<?, ?> other = (Map.Entry<?, ?>) obj;\n             return ObjectUtils.equals(getKey(), other.getKey())\n                     && ObjectUtils.equals(getValue(), other.getValue());\n         }\n--- a/src/main/java/org/apache/commons/lang3/tuple/Triple.java\n+++ b/src/main/java/org/apache/commons/lang3/tuple/Triple.java\n             return true;\n         }\n         if (obj instanceof Triple<?, ?, ?>) {\n-            Triple<?, ?, ?> other = (Triple<?, ?, ?>) obj;\n+            final Triple<?, ?, ?> other = (Triple<?, ?, ?>) obj;\n             return ObjectUtils.equals(getLeft(), other.getLeft())\n                 && ObjectUtils.equals(getMiddle(), other.getMiddle())\n                 && ObjectUtils.equals(getRight(), other.getRight());\n--- a/src/test/java/org/apache/commons/lang3/AnnotationUtilsTest.java\n+++ b/src/test/java/org/apache/commons/lang3/AnnotationUtilsTest.java\n \n     @Test\n     public void testIsValidAnnotationMemberType() {\n-        for (Class<?> type : new Class[] { byte.class, short.class, int.class, char.class,\n+        for (final Class<?> type : new Class[] { byte.class, short.class, int.class, char.class,\n                 long.class, float.class, double.class, boolean.class, String.class, Class.class,\n                 NestAnnotation.class, TestAnnotation.class, Stooge.class, ElementType.class }) {\n             assertTrue(AnnotationUtils.isValidAnnotationMemberType(type));\n             assertTrue(AnnotationUtils.isValidAnnotationMemberType(Array.newInstance(type, 0)\n                     .getClass()));\n         }\n-        for (Class<?> type : new Class[] { Object.class, Map.class, Collection.class }) {\n+        for (final Class<?> type : new Class[] { Object.class, Map.class, Collection.class }) {\n             assertFalse(AnnotationUtils.isValidAnnotationMemberType(type));\n             assertFalse(AnnotationUtils.isValidAnnotationMemberType(Array.newInstance(type, 0)\n                     .getClass()));\n         final Test real = getClass().getDeclaredMethod(\n                 \"testGeneratedAnnotationEquivalentToRealAnnotation\").getAnnotation(Test.class);\n \n-        InvocationHandler generatedTestInvocationHandler = new InvocationHandler() {\n+        final InvocationHandler generatedTestInvocationHandler = new InvocationHandler() {\n \n             @Override\n             public Object invoke(final Object proxy, final Method method, final Object[] args) throws Throwable {\n             }\n         };\n \n-        Test generated = (Test) Proxy.newProxyInstance(Thread.currentThread()\n+        final Test generated = (Test) Proxy.newProxyInstance(Thread.currentThread()\n                 .getContextClassLoader(), new Class[] { Test.class },\n                 generatedTestInvocationHandler);\n         assertTrue(real.equals(generated));\n         assertTrue(AnnotationUtils.equals(generated, real));\n         assertTrue(AnnotationUtils.equals(real, generated));\n \n-        Test generated2 = (Test) Proxy.newProxyInstance(Thread.currentThread()\n+        final Test generated2 = (Test) Proxy.newProxyInstance(Thread.currentThread()\n                 .getContextClassLoader(), new Class[] { Test.class },\n                 generatedTestInvocationHandler);\n         assertFalse(generated.equals(generated2));\n     public void testToString() throws Exception {\n         final Test testAnno = getClass().getDeclaredMethod(\"testToString\")\n                 .getAnnotation(Test.class);\n-        String toString = AnnotationUtils.toString(testAnno);\n+        final String toString = AnnotationUtils.toString(testAnno);\n         assertTrue(toString.startsWith(\"@org.junit.Test(\"));\n         assertTrue(toString.endsWith(\")\"));\n         assertTrue(toString.contains(\"expected=class org.junit.Test$None\"));\n--- a/src/test/java/org/apache/commons/lang3/ArrayUtilsAddTest.java\n+++ b/src/test/java/org/apache/commons/lang3/ArrayUtilsAddTest.java\n             // Invalid - can't store Long in Integer array\n                n = ArrayUtils.addAll(new Integer[]{Integer.valueOf(1)}, new Long[]{Long.valueOf(2)});\n                fail(\"Should have generated IllegalArgumentException\");\n-        } catch (IllegalArgumentException expected) {\n+        } catch (final IllegalArgumentException expected) {\n         }\n     }\n \n         newArray = ArrayUtils.add((boolean[])null, true);\n         assertTrue(Arrays.equals(new boolean[]{true}, newArray));\n         assertEquals(Boolean.TYPE, newArray.getClass().getComponentType());\n-        boolean[] array1 = new boolean[]{true, false, true};\n+        final boolean[] array1 = new boolean[]{true, false, true};\n         newArray = ArrayUtils.add(array1, false);\n         assertTrue(Arrays.equals(new boolean[]{true, false, true, false}, newArray));\n         assertEquals(Boolean.TYPE, newArray.getClass().getComponentType());\n         newArray = ArrayUtils.add((byte[])null, (byte)1);\n         assertTrue(Arrays.equals(new byte[]{1}, newArray));\n         assertEquals(Byte.TYPE, newArray.getClass().getComponentType());\n-        byte[] array1 = new byte[]{1, 2, 3};\n+        final byte[] array1 = new byte[]{1, 2, 3};\n         newArray = ArrayUtils.add(array1, (byte)0);\n         assertTrue(Arrays.equals(new byte[]{1, 2, 3, 0}, newArray));\n         assertEquals(Byte.TYPE, newArray.getClass().getComponentType());\n         newArray = ArrayUtils.add((char[])null, (char)1);\n         assertTrue(Arrays.equals(new char[]{1}, newArray));\n         assertEquals(Character.TYPE, newArray.getClass().getComponentType());\n-        char[] array1 = new char[]{1, 2, 3};\n+        final char[] array1 = new char[]{1, 2, 3};\n         newArray = ArrayUtils.add(array1, (char)0);\n         assertTrue(Arrays.equals(new char[]{1, 2, 3, 0}, newArray));\n         assertEquals(Character.TYPE, newArray.getClass().getComponentType());\n         newArray = ArrayUtils.add((double[])null, 1);\n         assertTrue(Arrays.equals(new double[]{1}, newArray));\n         assertEquals(Double.TYPE, newArray.getClass().getComponentType());\n-        double[] array1 = new double[]{1, 2, 3};\n+        final double[] array1 = new double[]{1, 2, 3};\n         newArray = ArrayUtils.add(array1, 0);\n         assertTrue(Arrays.equals(new double[]{1, 2, 3, 0}, newArray));\n         assertEquals(Double.TYPE, newArray.getClass().getComponentType());\n         newArray = ArrayUtils.add((float[])null, 1);\n         assertTrue(Arrays.equals(new float[]{1}, newArray));\n         assertEquals(Float.TYPE, newArray.getClass().getComponentType());\n-        float[] array1 = new float[]{1, 2, 3};\n+        final float[] array1 = new float[]{1, 2, 3};\n         newArray = ArrayUtils.add(array1, 0);\n         assertTrue(Arrays.equals(new float[]{1, 2, 3, 0}, newArray));\n         assertEquals(Float.TYPE, newArray.getClass().getComponentType());\n         newArray = ArrayUtils.add((int[])null, 1);\n         assertTrue(Arrays.equals(new int[]{1}, newArray));\n         assertEquals(Integer.TYPE, newArray.getClass().getComponentType());\n-        int[] array1 = new int[]{1, 2, 3};\n+        final int[] array1 = new int[]{1, 2, 3};\n         newArray = ArrayUtils.add(array1, 0);\n         assertTrue(Arrays.equals(new int[]{1, 2, 3, 0}, newArray));\n         assertEquals(Integer.TYPE, newArray.getClass().getComponentType());\n         newArray = ArrayUtils.add((long[])null, 1);\n         assertTrue(Arrays.equals(new long[]{1}, newArray));\n         assertEquals(Long.TYPE, newArray.getClass().getComponentType());\n-        long[] array1 = new long[]{1, 2, 3};\n+        final long[] array1 = new long[]{1, 2, 3};\n         newArray = ArrayUtils.add(array1, 0);\n         assertTrue(Arrays.equals(new long[]{1, 2, 3, 0}, newArray));\n         assertEquals(Long.TYPE, newArray.getClass().getComponentType());\n         newArray = ArrayUtils.add((short[])null, (short)1);\n         assertTrue(Arrays.equals(new short[]{1}, newArray));\n         assertEquals(Short.TYPE, newArray.getClass().getComponentType());\n-        short[] array1 = new short[]{1, 2, 3};\n+        final short[] array1 = new short[]{1, 2, 3};\n         newArray = ArrayUtils.add(array1, (short)0);\n         assertTrue(Arrays.equals(new short[]{1, 2, 3, 0}, newArray));\n         assertEquals(Short.TYPE, newArray.getClass().getComponentType());\n         assertEquals(String.class, newArray.getClass().getComponentType());\n \n         //show that not casting to Object[] is okay and will assume String based on \"a\"\n-        String[] newStringArray = ArrayUtils.add(null, \"a\");\n+        final String[] newStringArray = ArrayUtils.add(null, \"a\");\n         assertTrue(Arrays.equals(new String[]{\"a\"}, newStringArray));\n         assertTrue(Arrays.equals(new Object[]{\"a\"}, newStringArray));\n         assertEquals(String.class, newStringArray.getClass().getComponentType());\n \n-        String[] stringArray1 = new String[]{\"a\", \"b\", \"c\"};\n+        final String[] stringArray1 = new String[]{\"a\", \"b\", \"c\"};\n         newArray = ArrayUtils.add(stringArray1, null);\n         assertTrue(Arrays.equals(new String[]{\"a\", \"b\", \"c\", null}, newArray));\n         assertEquals(String.class, newArray.getClass().getComponentType());\n     \n     @Test\n     public void testLANG571(){\n-        String[] stringArray=null;\n-        String aString=null;\n+        final String[] stringArray=null;\n+        final String aString=null;\n         try {\n             @SuppressWarnings(\"unused\")\n+            final\n             String[] sa = ArrayUtils.add(stringArray, aString);\n             fail(\"Should have caused IllegalArgumentException\");\n-        } catch (IllegalArgumentException iae){\n+        } catch (final IllegalArgumentException iae){\n             //expected\n         }\n         try {\n             @SuppressWarnings(\"unused\")\n+            final\n             String[] sa = ArrayUtils.add(stringArray, 0, aString);\n             fail(\"Should have caused IllegalArgumentException\");\n-        } catch (IllegalArgumentException iae){\n+        } catch (final IllegalArgumentException iae){\n             //expected\n         }\n     }\n     public void testAddObjectArrayToObjectArray() {\n         assertNull(ArrayUtils.addAll((Object[]) null, (Object[]) null));\n         Object[] newArray;\n-        String[] stringArray1 = new String[]{\"a\", \"b\", \"c\"};\n-        String[] stringArray2 = new String[]{\"1\", \"2\", \"3\"};\n+        final String[] stringArray1 = new String[]{\"a\", \"b\", \"c\"};\n+        final String[] stringArray2 = new String[]{\"1\", \"2\", \"3\"};\n         newArray = ArrayUtils.addAll(stringArray1, (String[]) null);\n         assertNotSame(stringArray1, newArray);\n         assertTrue(Arrays.equals(stringArray1, newArray));\n         assertTrue(Arrays.equals(ArrayUtils.EMPTY_STRING_ARRAY, newArray));\n         assertTrue(Arrays.equals(new String[]{}, newArray));\n         assertEquals(String.class, newArray.getClass().getComponentType());\n-        String[] stringArrayNull = new String []{null};\n+        final String[] stringArrayNull = new String []{null};\n         newArray = ArrayUtils.addAll(stringArrayNull, stringArrayNull);\n         assertTrue(Arrays.equals(new String[]{null, null}, newArray));\n         assertEquals(String.class, newArray.getClass().getComponentType());\n         assertTrue(Arrays.equals(new String[]{\"a\"}, newArray));\n         assertTrue(Arrays.equals(new Object[]{\"a\"}, newArray));\n         assertEquals(String.class, newArray.getClass().getComponentType());\n-        String[] stringArray1 = new String[]{\"a\", \"b\", \"c\"};\n+        final String[] stringArray1 = new String[]{\"a\", \"b\", \"c\"};\n         newArray = ArrayUtils.add(stringArray1, 0, null);\n         assertTrue(Arrays.equals(new String[]{null, \"a\", \"b\", \"c\"}, newArray));\n         assertEquals(String.class, newArray.getClass().getComponentType());\n         assertEquals(String.class, newArray.getClass().getComponentType());\n         assertEquals(String.class, newArray.getClass().getComponentType());\n \n-        Object[] o = new Object[] {\"1\", \"2\", \"4\"};\n-        Object[] result = ArrayUtils.add(o, 2, \"3\");\n-        Object[] result2 = ArrayUtils.add(o, 3, \"5\");\n+        final Object[] o = new Object[] {\"1\", \"2\", \"4\"};\n+        final Object[] result = ArrayUtils.add(o, 2, \"3\");\n+        final Object[] result2 = ArrayUtils.add(o, 3, \"5\");\n \n         assertNotNull(result);\n         assertEquals(4, result.length);\n         assertTrue( Arrays.equals( new boolean[] { true }, booleanArray ) );\n         try {\n             booleanArray = ArrayUtils.add( null, -1, true );\n-        } catch(IndexOutOfBoundsException e) {\n+        } catch(final IndexOutOfBoundsException e) {\n             assertEquals(\"Index: -1, Length: 0\", e.getMessage());\n         }\n         booleanArray = ArrayUtils.add( new boolean[] { true }, 0, false);\n         assertTrue( Arrays.equals( new boolean[] { true, true, false }, booleanArray ) );\n         try {\n             booleanArray = ArrayUtils.add( new boolean[] { true, false }, 4, true);\n-        } catch(IndexOutOfBoundsException e) {\n+        } catch(final IndexOutOfBoundsException e) {\n             assertEquals(\"Index: 4, Length: 2\", e.getMessage());\n         }\n         try {\n             booleanArray = ArrayUtils.add( new boolean[] { true, false }, -1, true);\n-        } catch(IndexOutOfBoundsException e) {\n+        } catch(final IndexOutOfBoundsException e) {\n             assertEquals(\"Index: -1, Length: 2\", e.getMessage());\n         }\n \n         assertTrue( Arrays.equals( new char[] { 'a' }, charArray ) );\n         try {\n             charArray = ArrayUtils.add( (char[]) null, -1, 'a' );\n-        } catch(IndexOutOfBoundsException e) {\n+        } catch(final IndexOutOfBoundsException e) {\n             assertEquals(\"Index: -1, Length: 0\", e.getMessage());\n         }\n         charArray = ArrayUtils.add( new char[] { 'a' }, 0, 'b');\n         assertTrue( Arrays.equals( new char[] { 'a', 't', 'b', 'c' }, charArray ) );\n         try {\n             charArray = ArrayUtils.add( new char[] { 'a', 'b' }, 4, 'c');\n-        } catch(IndexOutOfBoundsException e) {\n+        } catch(final IndexOutOfBoundsException e) {\n             assertEquals(\"Index: 4, Length: 2\", e.getMessage());\n         }\n         try {\n             charArray = ArrayUtils.add( new char[] { 'a', 'b' }, -1, 'c');\n-        } catch(IndexOutOfBoundsException e) {\n+        } catch(final IndexOutOfBoundsException e) {\n             assertEquals(\"Index: -1, Length: 2\", e.getMessage());\n         }\n \n         assertTrue( Arrays.equals( new short[] { 2, 1 }, shortArray ) );\n         try {\n             shortArray = ArrayUtils.add( (short[]) null, -1, (short) 2);\n-        } catch(IndexOutOfBoundsException e) {\n+        } catch(final IndexOutOfBoundsException e) {\n             assertEquals(\"Index: -1, Length: 0\", e.getMessage());\n         }\n         shortArray = ArrayUtils.add( new short[] { 2, 6 }, 2, (short) 10);\n         assertTrue( Arrays.equals( new short[] { 2, 6, 1, 3 }, shortArray ) );\n         try {\n             shortArray = ArrayUtils.add( new short[] { 2, 6 }, 4, (short) 10);\n-        } catch(IndexOutOfBoundsException e) {\n+        } catch(final IndexOutOfBoundsException e) {\n             assertEquals(\"Index: 4, Length: 2\", e.getMessage());\n         }\n         try {\n             shortArray = ArrayUtils.add( new short[] { 2, 6 }, -1, (short) 10);\n-        } catch(IndexOutOfBoundsException e) {\n+        } catch(final IndexOutOfBoundsException e) {\n             assertEquals(\"Index: -1, Length: 2\", e.getMessage());\n         }\n \n         assertTrue( Arrays.equals( new byte[] { 2, 1 }, byteArray ) );\n         try {\n             byteArray = ArrayUtils.add( (byte[]) null, -1, (byte) 2);\n-        } catch(IndexOutOfBoundsException e) {\n+        } catch(final IndexOutOfBoundsException e) {\n             assertEquals(\"Index: -1, Length: 0\", e.getMessage());\n         }\n         byteArray = ArrayUtils.add( new byte[] { 2, 6 }, 2, (byte) 3);\n         assertTrue( Arrays.equals( new byte[] { 2, 6, 1, 3 }, byteArray ) );\n         try {\n             byteArray = ArrayUtils.add( new byte[] { 2, 6 }, 4, (byte) 3);\n-        } catch(IndexOutOfBoundsException e) {\n+        } catch(final IndexOutOfBoundsException e) {\n             assertEquals(\"Index: 4, Length: 2\", e.getMessage());\n         }\n         try {\n             byteArray = ArrayUtils.add( new byte[] { 2, 6 }, -1, (byte) 3);\n-        } catch(IndexOutOfBoundsException e) {\n+        } catch(final IndexOutOfBoundsException e) {\n             assertEquals(\"Index: -1, Length: 2\", e.getMessage());\n         }\n \n         assertTrue( Arrays.equals( new int[] { 2, 1 }, intArray ) );\n         try {\n             intArray = ArrayUtils.add( (int[]) null, -1, 2);\n-        } catch(IndexOutOfBoundsException e) {\n+        } catch(final IndexOutOfBoundsException e) {\n             assertEquals(\"Index: -1, Length: 0\", e.getMessage());\n         }\n         intArray = ArrayUtils.add( new int[] { 2, 6 }, 2, 10);\n         assertTrue( Arrays.equals( new int[] { 2, 6, 1, 3 }, intArray ) );\n         try {\n             intArray = ArrayUtils.add( new int[] { 2, 6 }, 4, 10);\n-        } catch(IndexOutOfBoundsException e) {\n+        } catch(final IndexOutOfBoundsException e) {\n             assertEquals(\"Index: 4, Length: 2\", e.getMessage());\n         }\n         try {\n             intArray = ArrayUtils.add( new int[] { 2, 6 }, -1, 10);\n-        } catch(IndexOutOfBoundsException e) {\n+        } catch(final IndexOutOfBoundsException e) {\n             assertEquals(\"Index: -1, Length: 2\", e.getMessage());\n         }\n \n         assertTrue( Arrays.equals( new long[] { 2L, 1L }, longArray ) );\n         try {\n             longArray = ArrayUtils.add( (long[]) null, -1, 2L);\n-        } catch(IndexOutOfBoundsException e) {\n+        } catch(final IndexOutOfBoundsException e) {\n             assertEquals(\"Index: -1, Length: 0\", e.getMessage());\n         }\n         longArray = ArrayUtils.add( new long[] { 2L, 6L }, 2, 10L);\n         assertTrue( Arrays.equals( new long[] { 2L, 6L, 1L, 3L }, longArray ) );\n         try {\n             longArray = ArrayUtils.add( new long[] { 2L, 6L }, 4, 10L);\n-        } catch(IndexOutOfBoundsException e) {\n+        } catch(final IndexOutOfBoundsException e) {\n             assertEquals(\"Index: 4, Length: 2\", e.getMessage());\n         }\n         try {\n             longArray = ArrayUtils.add( new long[] { 2L, 6L }, -1, 10L);\n-        } catch(IndexOutOfBoundsException e) {\n+        } catch(final IndexOutOfBoundsException e) {\n             assertEquals(\"Index: -1, Length: 2\", e.getMessage());\n         }\n \n         assertTrue( Arrays.equals( new float[] { 2.2f, 1.1f }, floatArray ) );\n         try {\n             floatArray = ArrayUtils.add( (float[]) null, -1, 2.2f);\n-        } catch(IndexOutOfBoundsException e) {\n+        } catch(final IndexOutOfBoundsException e) {\n             assertEquals(\"Index: -1, Length: 0\", e.getMessage());\n         }\n         floatArray = ArrayUtils.add( new float[] { 2.3f, 6.4f }, 2, 10.5f);\n         assertTrue( Arrays.equals( new float[] { 2.9f, 6.0f, 1.0f, 0.3f }, floatArray ) );\n         try {\n             floatArray = ArrayUtils.add( new float[] { 2.3f, 6.4f }, 4, 10.5f);\n-        } catch(IndexOutOfBoundsException e) {\n+        } catch(final IndexOutOfBoundsException e) {\n             assertEquals(\"Index: 4, Length: 2\", e.getMessage());\n         }\n         try {\n             floatArray = ArrayUtils.add( new float[] { 2.3f, 6.4f }, -1, 10.5f);\n-        } catch(IndexOutOfBoundsException e) {\n+        } catch(final IndexOutOfBoundsException e) {\n             assertEquals(\"Index: -1, Length: 2\", e.getMessage());\n         }\n \n         assertTrue( Arrays.equals( new double[] { 2.2, 1.1 }, doubleArray ) );\n         try {\n           doubleArray = ArrayUtils.add( (double[]) null, -1, 2.2);\n-        } catch(IndexOutOfBoundsException e) {\n+        } catch(final IndexOutOfBoundsException e) {\n             assertEquals(\"Index: -1, Length: 0\", e.getMessage());\n         }\n         doubleArray = ArrayUtils.add( new double[] { 2.3, 6.4 }, 2, 10.5);\n         assertTrue( Arrays.equals( new double[] { 2.9, 6.0, 1.0, 0.3 }, doubleArray ) );\n         try {\n             doubleArray = ArrayUtils.add( new double[] { 2.3, 6.4 }, 4, 10.5);\n-        } catch(IndexOutOfBoundsException e) {\n+        } catch(final IndexOutOfBoundsException e) {\n             assertEquals(\"Index: 4, Length: 2\", e.getMessage());\n         }\n         try {\n             doubleArray = ArrayUtils.add( new double[] { 2.3, 6.4 }, -1, 10.5);\n-        } catch(IndexOutOfBoundsException e) {\n+        } catch(final IndexOutOfBoundsException e) {\n             assertEquals(\"Index: -1, Length: 2\", e.getMessage());\n         }\n     }\n--- a/src/test/java/org/apache/commons/lang3/ArrayUtilsRemoveMultipleTest.java\n+++ b/src/test/java/org/apache/commons/lang3/ArrayUtilsRemoveMultipleTest.java\n \n     @Test\n     public void testRemoveAllObjectArrayRemoveNone() {\n-        Object[] array1 = new Object[] { \"foo\", \"bar\", \"baz\" };\n-        Object[] array2 = ArrayUtils.removeAll(array1);\n+        final Object[] array1 = new Object[] { \"foo\", \"bar\", \"baz\" };\n+        final Object[] array2 = ArrayUtils.removeAll(array1);\n         assertNotSame(array1, array2);\n         assertArrayEquals(array1, array2);\n         assertEquals(Object.class, array2.getClass().getComponentType());\n \n     @Test\n     public void testRemoveAllNumberArray() {\n-        Number[] inarray = { Integer.valueOf(1), Long.valueOf(2L), Byte.valueOf((byte) 3) };\n+        final Number[] inarray = { Integer.valueOf(1), Long.valueOf(2L), Byte.valueOf((byte) 3) };\n         assertEquals(3, inarray.length);\n         Number[] outarray;\n         outarray = ArrayUtils.removeAll(inarray, 1);\n \n     @Test\n     public void testRemoveAllBooleanArrayRemoveNone() {\n-        boolean[] array1 = new boolean[] { true, false };\n-        boolean[] array2 = ArrayUtils.removeAll(array1);\n+        final boolean[] array1 = new boolean[] { true, false };\n+        final boolean[] array2 = ArrayUtils.removeAll(array1);\n         assertNotSame(array1, array2);\n         assertTrue(Arrays.equals(array1, array2));\n         assertEquals(boolean.class, array2.getClass().getComponentType());\n \n     @Test\n     public void testRemoveAllByteArrayRemoveNone() {\n-        byte[] array1 = new byte[] { 1, 2 };\n-        byte[] array2 = ArrayUtils.removeAll(array1);\n+        final byte[] array1 = new byte[] { 1, 2 };\n+        final byte[] array2 = ArrayUtils.removeAll(array1);\n         assertNotSame(array1, array2);\n         assertArrayEquals(array1, array2);\n         assertEquals(byte.class, array2.getClass().getComponentType());\n \n     @Test\n     public void testRemoveAllCharArrayRemoveNone() {\n-        char[] array1 = new char[] { 'a', 'b' };\n-        char[] array2 = ArrayUtils.removeAll(array1);\n+        final char[] array1 = new char[] { 'a', 'b' };\n+        final char[] array2 = ArrayUtils.removeAll(array1);\n         assertNotSame(array1, array2);\n         assertArrayEquals(array1, array2);\n         assertEquals(char.class, array2.getClass().getComponentType());\n \n     @Test\n     public void testRemoveAllDoubleArrayRemoveNone() {\n-        double[] array1 = new double[] { 1, 2 };\n-        double[] array2 = ArrayUtils.removeAll(array1);\n+        final double[] array1 = new double[] { 1, 2 };\n+        final double[] array2 = ArrayUtils.removeAll(array1);\n         assertNotSame(array1, array2);\n         assertTrue(Arrays.equals(array1, array2));\n         assertEquals(double.class, array2.getClass().getComponentType());\n \n     @Test\n     public void testRemoveAllFloatArrayRemoveNone() {\n-        float[] array1 = new float[] { 1, 2 };\n-        float[] array2 = ArrayUtils.removeAll(array1);\n+        final float[] array1 = new float[] { 1, 2 };\n+        final float[] array2 = ArrayUtils.removeAll(array1);\n         assertNotSame(array1, array2);\n         assertTrue(Arrays.equals(array1, array2));\n         assertEquals(float.class, array2.getClass().getComponentType());\n \n     @Test\n     public void testRemoveAllIntArrayRemoveNone() {\n-        int[] array1 = new int[] { 1, 2 };\n-        int[] array2 = ArrayUtils.removeAll(array1);\n+        final int[] array1 = new int[] { 1, 2 };\n+        final int[] array2 = ArrayUtils.removeAll(array1);\n         assertNotSame(array1, array2);\n         assertArrayEquals(array1, array2);\n         assertEquals(int.class, array2.getClass().getComponentType());\n \n     @Test\n     public void testRemoveAllLongArrayRemoveNone() {\n-        long[] array1 = new long[] { 1, 2 };\n-        long[] array2 = ArrayUtils.removeAll(array1);\n+        final long[] array1 = new long[] { 1, 2 };\n+        final long[] array2 = ArrayUtils.removeAll(array1);\n         assertNotSame(array1, array2);\n         assertArrayEquals(array1, array2);\n         assertEquals(long.class, array2.getClass().getComponentType());\n \n     @Test\n     public void testRemoveAllShortArrayRemoveNone() {\n-        short[] array1 = new short[] { 1, 2 };\n-        short[] array2 = ArrayUtils.removeAll(array1);\n+        final short[] array1 = new short[] { 1, 2 };\n+        final short[] array2 = ArrayUtils.removeAll(array1);\n         assertNotSame(array1, array2);\n         assertArrayEquals(array1, array2);\n         assertEquals(short.class, array2.getClass().getComponentType());\n--- a/src/test/java/org/apache/commons/lang3/ArrayUtilsRemoveTest.java\n+++ b/src/test/java/org/apache/commons/lang3/ArrayUtilsRemoveTest.java\n         try {\n             ArrayUtils.remove(new Object[] {\"a\", \"b\"}, -1);\n             fail(\"IndexOutOfBoundsException expected\");\n-        } catch (IndexOutOfBoundsException e) {}\n+        } catch (final IndexOutOfBoundsException e) {}\n         try {\n             ArrayUtils.remove(new Object[] {\"a\", \"b\"}, 2);\n             fail(\"IndexOutOfBoundsException expected\");\n-        } catch (IndexOutOfBoundsException e) {}\n+        } catch (final IndexOutOfBoundsException e) {}\n         try {\n             ArrayUtils.remove((Object[]) null, 0);\n             fail(\"IndexOutOfBoundsException expected\");\n-        } catch (IndexOutOfBoundsException e) {}\n+        } catch (final IndexOutOfBoundsException e) {}\n     }\n \n     @Test\n     public void testRemoveNumberArray(){\n-        Number[] inarray = {Integer.valueOf(1),Long.valueOf(2),Byte.valueOf((byte) 3)};\n+        final Number[] inarray = {Integer.valueOf(1),Long.valueOf(2),Byte.valueOf((byte) 3)};\n         assertEquals(3, inarray.length);\n         Number[] outarray;\n         outarray = ArrayUtils.remove(inarray, 1);\n         try {\n             ArrayUtils.remove(new boolean[] {true, false}, -1);\n             fail(\"IndexOutOfBoundsException expected\");\n-        } catch (IndexOutOfBoundsException e) {}\n+        } catch (final IndexOutOfBoundsException e) {}\n         try {\n             ArrayUtils.remove(new boolean[] {true, false}, 2);\n             fail(\"IndexOutOfBoundsException expected\");\n-        } catch (IndexOutOfBoundsException e) {}\n+        } catch (final IndexOutOfBoundsException e) {}\n         try {\n             ArrayUtils.remove((boolean[]) null, 0);\n             fail(\"IndexOutOfBoundsException expected\");\n-        } catch (IndexOutOfBoundsException e) {}\n+        } catch (final IndexOutOfBoundsException e) {}\n     }\n     \n     @Test\n         try {\n             ArrayUtils.remove(new byte[] {1, 2}, -1);\n             fail(\"IndexOutOfBoundsException expected\");\n-        } catch (IndexOutOfBoundsException e) {}\n+        } catch (final IndexOutOfBoundsException e) {}\n         try {\n             ArrayUtils.remove(new byte[] {1, 2}, 2);\n             fail(\"IndexOutOfBoundsException expected\");\n-        } catch (IndexOutOfBoundsException e) {}\n+        } catch (final IndexOutOfBoundsException e) {}\n         try {\n             ArrayUtils.remove((byte[]) null, 0);\n             fail(\"IndexOutOfBoundsException expected\");\n-        } catch (IndexOutOfBoundsException e) {}\n+        } catch (final IndexOutOfBoundsException e) {}\n     }\n     \n     @Test\n         try {\n             ArrayUtils.remove(new char[] {'a', 'b'}, -1);\n             fail(\"IndexOutOfBoundsException expected\");\n-        } catch (IndexOutOfBoundsException e) {}\n+        } catch (final IndexOutOfBoundsException e) {}\n         try {\n             ArrayUtils.remove(new char[] {'a', 'b'}, 2);\n             fail(\"IndexOutOfBoundsException expected\");\n-        } catch (IndexOutOfBoundsException e) {}\n+        } catch (final IndexOutOfBoundsException e) {}\n         try {\n             ArrayUtils.remove((char[]) null, 0);\n             fail(\"IndexOutOfBoundsException expected\");\n-        } catch (IndexOutOfBoundsException e) {}\n+        } catch (final IndexOutOfBoundsException e) {}\n     }\n     \n     @Test\n         try {\n             ArrayUtils.remove(new double[] {1, 2}, -1);\n             fail(\"IndexOutOfBoundsException expected\");\n-        } catch (IndexOutOfBoundsException e) {}\n+        } catch (final IndexOutOfBoundsException e) {}\n         try {\n             ArrayUtils.remove(new double[] {1, 2}, 2);\n             fail(\"IndexOutOfBoundsException expected\");\n-        } catch (IndexOutOfBoundsException e) {}\n+        } catch (final IndexOutOfBoundsException e) {}\n         try {\n             ArrayUtils.remove((double[]) null, 0);\n             fail(\"IndexOutOfBoundsException expected\");\n-        } catch (IndexOutOfBoundsException e) {}\n+        } catch (final IndexOutOfBoundsException e) {}\n     }\n     \n     @Test\n         try {\n             ArrayUtils.remove(new float[] {1, 2}, -1);\n             fail(\"IndexOutOfBoundsException expected\");\n-        } catch (IndexOutOfBoundsException e) {}\n+        } catch (final IndexOutOfBoundsException e) {}\n         try {\n             ArrayUtils.remove(new float[] {1, 2}, 2);\n             fail(\"IndexOutOfBoundsException expected\");\n-        } catch (IndexOutOfBoundsException e) {}\n+        } catch (final IndexOutOfBoundsException e) {}\n         try {\n             ArrayUtils.remove((float[]) null, 0);\n             fail(\"IndexOutOfBoundsException expected\");\n-        } catch (IndexOutOfBoundsException e) {}\n+        } catch (final IndexOutOfBoundsException e) {}\n     }\n     \n     @Test\n         try {\n             ArrayUtils.remove(new int[] {1, 2}, -1);\n             fail(\"IndexOutOfBoundsException expected\");\n-        } catch (IndexOutOfBoundsException e) {}\n+        } catch (final IndexOutOfBoundsException e) {}\n         try {\n             ArrayUtils.remove(new int[] {1, 2}, 2);\n             fail(\"IndexOutOfBoundsException expected\");\n-        } catch (IndexOutOfBoundsException e) {}\n+        } catch (final IndexOutOfBoundsException e) {}\n         try {\n             ArrayUtils.remove((int[]) null, 0);\n             fail(\"IndexOutOfBoundsException expected\");\n-        } catch (IndexOutOfBoundsException e) {}\n+        } catch (final IndexOutOfBoundsException e) {}\n     }\n     \n     @Test\n         try {\n             ArrayUtils.remove(new long[] {1, 2}, -1);\n             fail(\"IndexOutOfBoundsException expected\");\n-        } catch (IndexOutOfBoundsException e) {}\n+        } catch (final IndexOutOfBoundsException e) {}\n         try {\n             ArrayUtils.remove(new long[] {1, 2}, 2);\n             fail(\"IndexOutOfBoundsException expected\");\n-        } catch (IndexOutOfBoundsException e) {}\n+        } catch (final IndexOutOfBoundsException e) {}\n         try {\n             ArrayUtils.remove((long[]) null, 0);\n             fail(\"IndexOutOfBoundsException expected\");\n-        } catch (IndexOutOfBoundsException e) {}\n+        } catch (final IndexOutOfBoundsException e) {}\n     }\n     \n     @Test\n         try {\n             ArrayUtils.remove(new short[] {1, 2}, -1);\n             fail(\"IndexOutOfBoundsException expected\");\n-        } catch (IndexOutOfBoundsException e) {}\n+        } catch (final IndexOutOfBoundsException e) {}\n         try {\n             ArrayUtils.remove(new short[] {1, 2}, 2);\n             fail(\"IndexOutOfBoundsException expected\");\n-        } catch (IndexOutOfBoundsException e) {}\n+        } catch (final IndexOutOfBoundsException e) {}\n         try {\n             ArrayUtils.remove((short[]) null, 0);\n             fail(\"IndexOutOfBoundsException expected\");\n-        } catch (IndexOutOfBoundsException e) {}\n+        } catch (final IndexOutOfBoundsException e) {}\n     }\n     \n     @Test\n--- a/src/test/java/org/apache/commons/lang3/ArrayUtilsTest.java\n+++ b/src/test/java/org/apache/commons/lang3/ArrayUtilsTest.java\n     @Test\n     public void testConstructor() {\n         assertNotNull(new ArrayUtils());\n-        Constructor<?>[] cons = ArrayUtils.class.getDeclaredConstructors();\n+        final Constructor<?>[] cons = ArrayUtils.class.getDeclaredConstructors();\n         assertEquals(1, cons.length);\n         assertTrue(Modifier.isPublic(cons[0].getModifiers()));\n         assertTrue(Modifier.isPublic(ArrayUtils.class.getModifiers()));\n     //-----------------------------------------------------------------------\n     @Test\n     public void testHashCode() {\n-        long[][] array1 = new long[][] {{2,5}, {4,5}};\n-        long[][] array2 = new long[][] {{2,5}, {4,6}};\n+        final long[][] array1 = new long[][] {{2,5}, {4,5}};\n+        final long[][] array2 = new long[][] {{2,5}, {4,6}};\n         assertTrue(ArrayUtils.hashCode(array1) == ArrayUtils.hashCode(array1));\n         assertFalse(ArrayUtils.hashCode(array1) == ArrayUtils.hashCode(array2));\n         \n-        Object[] array3 = new Object[] {new String(new char[] {'A', 'B'})};\n-        Object[] array4 = new Object[] {\"AB\"};\n+        final Object[] array3 = new Object[] {new String(new char[] {'A', 'B'})};\n+        final Object[] array4 = new Object[] {\"AB\"};\n         assertTrue(ArrayUtils.hashCode(array3) == ArrayUtils.hashCode(array3));\n         assertTrue(ArrayUtils.hashCode(array3) == ArrayUtils.hashCode(array4));\n         \n-        Object[] arrayA = new Object[] {new boolean[] {true, false}, new int[] {6, 7}};\n-        Object[] arrayB = new Object[] {new boolean[] {true, false}, new int[] {6, 7}};\n+        final Object[] arrayA = new Object[] {new boolean[] {true, false}, new int[] {6, 7}};\n+        final Object[] arrayB = new Object[] {new boolean[] {true, false}, new int[] {6, 7}};\n         assertTrue(ArrayUtils.hashCode(arrayB) == ArrayUtils.hashCode(arrayA));\n     }\n \n \n     @Test\n     public void testIsEquals() {\n-        long[][] larray1 = new long[][]{{2, 5}, {4, 5}};\n-        long[][] larray2 = new long[][]{{2, 5}, {4, 6}};\n-        long[] larray3 = new long[]{2, 5};\n+        final long[][] larray1 = new long[][]{{2, 5}, {4, 5}};\n+        final long[][] larray2 = new long[][]{{2, 5}, {4, 6}};\n+        final long[] larray3 = new long[]{2, 5};\n         this.assertIsEquals(larray1, larray2, larray3);\n \n-        int[][] iarray1 = new int[][]{{2, 5}, {4, 5}};\n-        int[][] iarray2 = new int[][]{{2, 5}, {4, 6}};\n-        int[] iarray3 = new int[]{2, 5};\n+        final int[][] iarray1 = new int[][]{{2, 5}, {4, 5}};\n+        final int[][] iarray2 = new int[][]{{2, 5}, {4, 6}};\n+        final int[] iarray3 = new int[]{2, 5};\n         this.assertIsEquals(iarray1, iarray2, iarray3);\n \n-        short[][] sarray1 = new short[][]{{2, 5}, {4, 5}};\n-        short[][] sarray2 = new short[][]{{2, 5}, {4, 6}};\n-        short[] sarray3 = new short[]{2, 5};\n+        final short[][] sarray1 = new short[][]{{2, 5}, {4, 5}};\n+        final short[][] sarray2 = new short[][]{{2, 5}, {4, 6}};\n+        final short[] sarray3 = new short[]{2, 5};\n         this.assertIsEquals(sarray1, sarray2, sarray3);\n \n-        float[][] farray1 = new float[][]{{2, 5}, {4, 5}};\n-        float[][] farray2 = new float[][]{{2, 5}, {4, 6}};\n-        float[] farray3 = new float[]{2, 5};\n+        final float[][] farray1 = new float[][]{{2, 5}, {4, 5}};\n+        final float[][] farray2 = new float[][]{{2, 5}, {4, 6}};\n+        final float[] farray3 = new float[]{2, 5};\n         this.assertIsEquals(farray1, farray2, farray3);\n \n-        double[][] darray1 = new double[][]{{2, 5}, {4, 5}};\n-        double[][] darray2 = new double[][]{{2, 5}, {4, 6}};\n-        double[] darray3 = new double[]{2, 5};\n+        final double[][] darray1 = new double[][]{{2, 5}, {4, 5}};\n+        final double[][] darray2 = new double[][]{{2, 5}, {4, 6}};\n+        final double[] darray3 = new double[]{2, 5};\n         this.assertIsEquals(darray1, darray2, darray3);\n \n-        byte[][] byteArray1 = new byte[][]{{2, 5}, {4, 5}};\n-        byte[][] byteArray2 = new byte[][]{{2, 5}, {4, 6}};\n-        byte[] byteArray3 = new byte[]{2, 5};\n+        final byte[][] byteArray1 = new byte[][]{{2, 5}, {4, 5}};\n+        final byte[][] byteArray2 = new byte[][]{{2, 5}, {4, 6}};\n+        final byte[] byteArray3 = new byte[]{2, 5};\n         this.assertIsEquals(byteArray1, byteArray2, byteArray3);\n \n-        char[][] charArray1 = new char[][]{{2, 5}, {4, 5}};\n-        char[][] charArray2 = new char[][]{{2, 5}, {4, 6}};\n-        char[] charArray3 = new char[]{2, 5};\n+        final char[][] charArray1 = new char[][]{{2, 5}, {4, 5}};\n+        final char[][] charArray2 = new char[][]{{2, 5}, {4, 6}};\n+        final char[] charArray3 = new char[]{2, 5};\n         this.assertIsEquals(charArray1, charArray2, charArray3);\n \n-        boolean[][] barray1 = new boolean[][]{{true, false}, {true, true}};\n-        boolean[][] barray2 = new boolean[][]{{true, false}, {true, false}};\n-        boolean[] barray3 = new boolean[]{false, true};\n+        final boolean[][] barray1 = new boolean[][]{{true, false}, {true, true}};\n+        final boolean[][] barray2 = new boolean[][]{{true, false}, {true, false}};\n+        final boolean[] barray3 = new boolean[]{false, true};\n         this.assertIsEquals(barray1, barray2, barray3);\n \n-        Object[] array3 = new Object[]{new String(new char[]{'A', 'B'})};\n-        Object[] array4 = new Object[]{\"AB\"};\n+        final Object[] array3 = new Object[]{new String(new char[]{'A', 'B'})};\n+        final Object[] array4 = new Object[]{\"AB\"};\n         assertTrue(ArrayUtils.isEquals(array3, array3));\n         assertTrue(ArrayUtils.isEquals(array3, array4));\n \n         try {\n             ArrayUtils.toMap(new String[][] {{\"foo\", \"bar\"}, {\"short\"}});\n             fail(\"exception expected\");\n-        } catch (IllegalArgumentException ex) {}\n+        } catch (final IllegalArgumentException ex) {}\n         try {\n             ArrayUtils.toMap(new Object[] {new Object[] {\"foo\", \"bar\"}, \"illegal type\"});\n             fail(\"exception expected\");\n-        } catch (IllegalArgumentException ex) {}\n+        } catch (final IllegalArgumentException ex) {}\n         try {\n             ArrayUtils.toMap(new Object[] {new Object[] {\"foo\", \"bar\"}, null});\n             fail(\"exception expected\");\n-        } catch (IllegalArgumentException ex) {}\n+        } catch (final IllegalArgumentException ex) {}\n         \n         map = ArrayUtils.toMap(new Object[] {new Map.Entry<Object, Object>() {\n             @Override\n         assertTrue(Arrays.equals(original1, cloned1));\n         assertTrue(original1 != cloned1);\n         \n-        StringBuffer buf = new StringBuffer(\"pick\");\n+        final StringBuffer buf = new StringBuffer(\"pick\");\n         original1 = new Object[] {buf, \"a\", new String[] {\"stick\"}};\n         cloned1 = ArrayUtils.clone(original1);\n         assertTrue(Arrays.equals(original1, cloned1));\n     @Test\n     public void testCloneBoolean() {\n         assertEquals(null, ArrayUtils.clone((boolean[]) null));\n-        boolean[] original = new boolean[] {true, false};\n-        boolean[] cloned = ArrayUtils.clone(original);\n+        final boolean[] original = new boolean[] {true, false};\n+        final boolean[] cloned = ArrayUtils.clone(original);\n         assertTrue(Arrays.equals(original, cloned));\n         assertTrue(original != cloned);\n     }\n     @Test\n     public void testCloneLong() {\n         assertEquals(null, ArrayUtils.clone((long[]) null));\n-        long[] original = new long[] {0L, 1L};\n-        long[] cloned = ArrayUtils.clone(original);\n+        final long[] original = new long[] {0L, 1L};\n+        final long[] cloned = ArrayUtils.clone(original);\n         assertTrue(Arrays.equals(original, cloned));\n         assertTrue(original != cloned);\n     }\n     @Test\n     public void testCloneInt() {\n         assertEquals(null, ArrayUtils.clone((int[]) null));\n-        int[] original = new int[] {5, 8};\n-        int[] cloned = ArrayUtils.clone(original);\n+        final int[] original = new int[] {5, 8};\n+        final int[] cloned = ArrayUtils.clone(original);\n         assertTrue(Arrays.equals(original, cloned));\n         assertTrue(original != cloned);\n     }\n     @Test\n     public void testCloneShort() {\n         assertEquals(null, ArrayUtils.clone((short[]) null));\n-        short[] original = new short[] {1, 4};\n-        short[] cloned = ArrayUtils.clone(original);\n+        final short[] original = new short[] {1, 4};\n+        final short[] cloned = ArrayUtils.clone(original);\n         assertTrue(Arrays.equals(original, cloned));\n         assertTrue(original != cloned);\n     }\n     @Test\n     public void testCloneChar() {\n         assertEquals(null, ArrayUtils.clone((char[]) null));\n-        char[] original = new char[] {'a', '4'};\n-        char[] cloned = ArrayUtils.clone(original);\n+        final char[] original = new char[] {'a', '4'};\n+        final char[] cloned = ArrayUtils.clone(original);\n         assertTrue(Arrays.equals(original, cloned));\n         assertTrue(original != cloned);\n     }\n     @Test\n     public void testCloneByte() {\n         assertEquals(null, ArrayUtils.clone((byte[]) null));\n-        byte[] original = new byte[] {1, 6};\n-        byte[] cloned = ArrayUtils.clone(original);\n+        final byte[] original = new byte[] {1, 6};\n+        final byte[] cloned = ArrayUtils.clone(original);\n         assertTrue(Arrays.equals(original, cloned));\n         assertTrue(original != cloned);\n     }\n     @Test\n     public void testCloneDouble() {\n         assertEquals(null, ArrayUtils.clone((double[]) null));\n-        double[] original = new double[] {2.4d, 5.7d};\n-        double[] cloned = ArrayUtils.clone(original);\n+        final double[] original = new double[] {2.4d, 5.7d};\n+        final double[] cloned = ArrayUtils.clone(original);\n         assertTrue(Arrays.equals(original, cloned));\n         assertTrue(original != cloned);\n     }\n     @Test\n     public void testCloneFloat() {\n         assertEquals(null, ArrayUtils.clone((float[]) null));\n-        float[] original = new float[] {2.6f, 6.4f};\n-        float[] cloned = ArrayUtils.clone(original);\n+        final float[] original = new float[] {2.6f, 6.4f};\n+        final float[] cloned = ArrayUtils.clone(original);\n         assertTrue(Arrays.equals(original, cloned));\n         assertTrue(original != cloned);\n     }\n         // Test null handling\n         assertEquals(ArrayUtils.EMPTY_BOOLEAN_ARRAY, ArrayUtils.nullToEmpty((boolean[]) null));\n         // Test valid array handling\n-        boolean[] original = new boolean[] {true, false};\n+        final boolean[] original = new boolean[] {true, false};\n         assertEquals(original, ArrayUtils.nullToEmpty(original));\n         // Test empty array handling\n-        boolean[] empty = new boolean[]{};\n-        boolean[] result = ArrayUtils.nullToEmpty(empty);\n+        final boolean[] empty = new boolean[]{};\n+        final boolean[] result = ArrayUtils.nullToEmpty(empty);\n         assertEquals(ArrayUtils.EMPTY_BOOLEAN_ARRAY, result);\n         assertTrue(empty != result);\n     }\n         // Test null handling\n         assertEquals(ArrayUtils.EMPTY_LONG_ARRAY, ArrayUtils.nullToEmpty((long[]) null));\n         // Test valid array handling\n-        long[] original = new long[] {1L, 2L};\n+        final long[] original = new long[] {1L, 2L};\n         assertEquals(original, ArrayUtils.nullToEmpty(original));\n         // Test empty array handling\n-        long[] empty = new long[]{};\n-        long[] result = ArrayUtils.nullToEmpty(empty);\n+        final long[] empty = new long[]{};\n+        final long[] result = ArrayUtils.nullToEmpty(empty);\n         assertEquals(ArrayUtils.EMPTY_LONG_ARRAY, result);\n         assertTrue(empty != result);\n     }\n         // Test null handling\n         assertEquals(ArrayUtils.EMPTY_INT_ARRAY, ArrayUtils.nullToEmpty((int[]) null));\n         // Test valid array handling\n-        int[] original = new int[] {1, 2};\n+        final int[] original = new int[] {1, 2};\n         assertEquals(original, ArrayUtils.nullToEmpty(original));\n         // Test empty array handling\n-        int[] empty = new int[]{};\n-        int[] result = ArrayUtils.nullToEmpty(empty);\n+        final int[] empty = new int[]{};\n+        final int[] result = ArrayUtils.nullToEmpty(empty);\n         assertEquals(ArrayUtils.EMPTY_INT_ARRAY, result);\n         assertTrue(empty != result);\n     }\n         // Test null handling\n         assertEquals(ArrayUtils.EMPTY_SHORT_ARRAY, ArrayUtils.nullToEmpty((short[]) null));\n         // Test valid array handling\n-        short[] original = new short[] {1, 2};\n+        final short[] original = new short[] {1, 2};\n         assertEquals(original, ArrayUtils.nullToEmpty(original));\n         // Test empty array handling\n-        short[] empty = new short[]{};\n-        short[] result = ArrayUtils.nullToEmpty(empty);\n+        final short[] empty = new short[]{};\n+        final short[] result = ArrayUtils.nullToEmpty(empty);\n         assertEquals(ArrayUtils.EMPTY_SHORT_ARRAY, result);\n         assertTrue(empty != result);\n     }\n         // Test null handling\n         assertEquals(ArrayUtils.EMPTY_CHAR_ARRAY, ArrayUtils.nullToEmpty((char[]) null));\n         // Test valid array handling\n-        char[] original = new char[] {'a', 'b'};\n+        final char[] original = new char[] {'a', 'b'};\n         assertEquals(original, ArrayUtils.nullToEmpty(original));\n         // Test empty array handling\n-        char[] empty = new char[]{};\n-        char[] result = ArrayUtils.nullToEmpty(empty);\n+        final char[] empty = new char[]{};\n+        final char[] result = ArrayUtils.nullToEmpty(empty);\n         assertEquals(ArrayUtils.EMPTY_CHAR_ARRAY, result);\n         assertTrue(empty != result);\n     }\n         // Test null handling\n         assertEquals(ArrayUtils.EMPTY_BYTE_ARRAY, ArrayUtils.nullToEmpty((byte[]) null));\n         // Test valid array handling\n-        byte[] original = new byte[] {0x0F, 0x0E};\n+        final byte[] original = new byte[] {0x0F, 0x0E};\n         assertEquals(original, ArrayUtils.nullToEmpty(original));\n         // Test empty array handling\n-        byte[] empty = new byte[]{};\n-        byte[] result = ArrayUtils.nullToEmpty(empty);\n+        final byte[] empty = new byte[]{};\n+        final byte[] result = ArrayUtils.nullToEmpty(empty);\n         assertEquals(ArrayUtils.EMPTY_BYTE_ARRAY, result);\n         assertTrue(empty != result);\n     }\n         // Test null handling\n         assertEquals(ArrayUtils.EMPTY_DOUBLE_ARRAY, ArrayUtils.nullToEmpty((double[]) null));\n         // Test valid array handling\n-        double[] original = new double[] {1L, 2L};\n+        final double[] original = new double[] {1L, 2L};\n         assertEquals(original, ArrayUtils.nullToEmpty(original));\n         // Test empty array handling\n-        double[] empty = new double[]{};\n-        double[] result = ArrayUtils.nullToEmpty(empty);\n+        final double[] empty = new double[]{};\n+        final double[] result = ArrayUtils.nullToEmpty(empty);\n         assertEquals(ArrayUtils.EMPTY_DOUBLE_ARRAY, result);\n         assertTrue(empty != result);\n     }\n         // Test null handling\n         assertEquals(ArrayUtils.EMPTY_FLOAT_ARRAY, ArrayUtils.nullToEmpty((float[]) null));\n         // Test valid array handling\n-        float[] original = new float[] {2.6f, 3.8f};\n+        final float[] original = new float[] {2.6f, 3.8f};\n         assertEquals(original, ArrayUtils.nullToEmpty(original));\n         // Test empty array handling\n-        float[] empty = new float[]{};\n-        float[] result = ArrayUtils.nullToEmpty(empty);\n+        final float[] empty = new float[]{};\n+        final float[] result = ArrayUtils.nullToEmpty(empty);\n         assertEquals(ArrayUtils.EMPTY_FLOAT_ARRAY, result);\n         assertTrue(empty != result);\n     }\n         // Test null handling\n         assertArrayEquals(ArrayUtils.EMPTY_OBJECT_ARRAY, ArrayUtils.nullToEmpty((Object[]) null));\n         // Test valid array handling\n-        Object[] original = new Object[] {Boolean.TRUE, Boolean.FALSE};\n+        final Object[] original = new Object[] {Boolean.TRUE, Boolean.FALSE};\n         assertArrayEquals(original, ArrayUtils.nullToEmpty(original));\n         // Test empty array handling\n-        Object[] empty = new Object[]{};\n-        Object[] result = ArrayUtils.nullToEmpty(empty);\n+        final Object[] empty = new Object[]{};\n+        final Object[] result = ArrayUtils.nullToEmpty(empty);\n         assertArrayEquals(ArrayUtils.EMPTY_OBJECT_ARRAY, result);\n         assertTrue(empty != result);\n     }\n         // Test null handling\n         assertArrayEquals(ArrayUtils.EMPTY_STRING_ARRAY, ArrayUtils.nullToEmpty((String[]) null));\n         // Test valid array handling\n-        String[] original = new String[] {\"abc\", \"def\"};\n+        final String[] original = new String[] {\"abc\", \"def\"};\n         assertArrayEquals(original, ArrayUtils.nullToEmpty(original));\n         // Test empty array handling\n-        String[] empty = new String[]{};\n-        String[] result = ArrayUtils.nullToEmpty(empty);\n+        final String[] empty = new String[]{};\n+        final String[] result = ArrayUtils.nullToEmpty(empty);\n         assertArrayEquals(ArrayUtils.EMPTY_STRING_ARRAY, result);\n         assertTrue(empty != result);\n     }\n         // Test null handling\n         assertArrayEquals(ArrayUtils.EMPTY_BOOLEAN_OBJECT_ARRAY, ArrayUtils.nullToEmpty((Boolean[]) null));\n         // Test valid array handling\n-        Boolean[] original = new Boolean[] {Boolean.TRUE, Boolean.FALSE};\n+        final Boolean[] original = new Boolean[] {Boolean.TRUE, Boolean.FALSE};\n         assertArrayEquals(original, ArrayUtils.nullToEmpty(original));\n         // Test empty array handling\n-        Boolean[] empty = new Boolean[]{};\n-        Boolean[] result = ArrayUtils.nullToEmpty(empty);\n+        final Boolean[] empty = new Boolean[]{};\n+        final Boolean[] result = ArrayUtils.nullToEmpty(empty);\n         assertArrayEquals(ArrayUtils.EMPTY_BOOLEAN_OBJECT_ARRAY, result);\n         assertTrue(empty != result);\n     }\n         assertArrayEquals(ArrayUtils.EMPTY_LONG_OBJECT_ARRAY, ArrayUtils.nullToEmpty((Long[]) null));\n         // Test valid array handling\n         @SuppressWarnings(\"boxing\")\n+        final\n         Long[] original = new Long[] {1L, 2L};\n         assertArrayEquals(original, ArrayUtils.nullToEmpty(original));\n         // Test empty array handling\n-        Long[] empty = new Long[]{};\n-        Long[] result = ArrayUtils.nullToEmpty(empty);\n+        final Long[] empty = new Long[]{};\n+        final Long[] result = ArrayUtils.nullToEmpty(empty);\n         assertArrayEquals(ArrayUtils.EMPTY_LONG_OBJECT_ARRAY, result);\n         assertTrue(empty != result);\n     }\n         // Test null handling\n         assertArrayEquals(ArrayUtils.EMPTY_INTEGER_OBJECT_ARRAY, ArrayUtils.nullToEmpty((Integer[]) null));\n         // Test valid array handling\n-        Integer[] original = new Integer[] {1, 2};\n+        final Integer[] original = new Integer[] {1, 2};\n         assertArrayEquals(original, ArrayUtils.nullToEmpty(original));\n         // Test empty array handling\n-        Integer[] empty = new Integer[]{};\n-        Integer[] result = ArrayUtils.nullToEmpty(empty);\n+        final Integer[] empty = new Integer[]{};\n+        final Integer[] result = ArrayUtils.nullToEmpty(empty);\n         assertArrayEquals(ArrayUtils.EMPTY_INTEGER_OBJECT_ARRAY, result);\n         assertTrue(empty != result);\n     }\n         assertArrayEquals(ArrayUtils.EMPTY_SHORT_OBJECT_ARRAY, ArrayUtils.nullToEmpty((Short[]) null));\n         // Test valid array handling\n         @SuppressWarnings(\"boxing\")\n+        final\n         Short[] original = new Short[] {1, 2};\n         assertArrayEquals(original, ArrayUtils.nullToEmpty(original));\n         // Test empty array handling\n-        Short[] empty = new Short[]{};\n-        Short[] result = ArrayUtils.nullToEmpty(empty);\n+        final Short[] empty = new Short[]{};\n+        final Short[] result = ArrayUtils.nullToEmpty(empty);\n         assertArrayEquals(ArrayUtils.EMPTY_SHORT_OBJECT_ARRAY, result);\n         assertTrue(empty != result);\n     }\n         // Test null handling\n         assertArrayEquals(ArrayUtils.EMPTY_CHARACTER_OBJECT_ARRAY, ArrayUtils.nullToEmpty((Character[]) null));\n         // Test valid array handling\n-        Character[] original = new Character[] {'a', 'b'};\n+        final Character[] original = new Character[] {'a', 'b'};\n         assertArrayEquals(original, ArrayUtils.nullToEmpty(original));\n         // Test empty array handling\n-        Character[] empty = new Character[]{};\n-        Character[] result = ArrayUtils.nullToEmpty(empty);\n+        final Character[] empty = new Character[]{};\n+        final Character[] result = ArrayUtils.nullToEmpty(empty);\n         assertArrayEquals(ArrayUtils.EMPTY_CHARACTER_OBJECT_ARRAY, result);\n         assertTrue(empty != result);\n     }\n         // Test null handling\n         assertArrayEquals(ArrayUtils.EMPTY_BYTE_OBJECT_ARRAY, ArrayUtils.nullToEmpty((Byte[]) null));\n         // Test valid array handling\n-        Byte[] original = new Byte[] {0x0F, 0x0E};\n+        final Byte[] original = new Byte[] {0x0F, 0x0E};\n         assertArrayEquals(original, ArrayUtils.nullToEmpty(original));\n         // Test empty array handling\n-        Byte[] empty = new Byte[]{};\n-        Byte[] result = ArrayUtils.nullToEmpty(empty);\n+        final Byte[] empty = new Byte[]{};\n+        final Byte[] result = ArrayUtils.nullToEmpty(empty);\n         assertArrayEquals(ArrayUtils.EMPTY_BYTE_OBJECT_ARRAY, result);\n         assertTrue(empty != result);\n     }\n         // Test null handling\n         assertArrayEquals(ArrayUtils.EMPTY_DOUBLE_OBJECT_ARRAY, ArrayUtils.nullToEmpty((Double[]) null));\n         // Test valid array handling\n-        Double[] original = new Double[] {1D, 2D};\n+        final Double[] original = new Double[] {1D, 2D};\n         assertArrayEquals(original, ArrayUtils.nullToEmpty(original));\n         // Test empty array handling\n-        Double[] empty = new Double[]{};\n-        Double[] result = ArrayUtils.nullToEmpty(empty);\n+        final Double[] empty = new Double[]{};\n+        final Double[] result = ArrayUtils.nullToEmpty(empty);\n         assertArrayEquals(ArrayUtils.EMPTY_DOUBLE_OBJECT_ARRAY, result);\n         assertTrue(empty != result);\n     }\n         // Test null handling\n         assertArrayEquals(ArrayUtils.EMPTY_FLOAT_OBJECT_ARRAY, ArrayUtils.nullToEmpty((Float[]) null));\n         // Test valid array handling\n-        Float[] original = new Float[] {2.6f, 3.8f};\n+        final Float[] original = new Float[] {2.6f, 3.8f};\n         assertArrayEquals(original, ArrayUtils.nullToEmpty(original));\n         // Test empty array handling\n-        Float[] empty = new Float[]{};\n-        Float[] result = ArrayUtils.nullToEmpty(empty);\n+        final Float[] empty = new Float[]{};\n+        final Float[] result = ArrayUtils.nullToEmpty(empty);\n         assertArrayEquals(ArrayUtils.EMPTY_FLOAT_OBJECT_ARRAY, result);\n         assertTrue(empty != result);\n     }\n \n     @Test\n     public void testSubarrayObject() {\n-        Object[] nullArray = null;\n-        Object[] objectArray = { \"a\", \"b\", \"c\", \"d\", \"e\", \"f\"};\n+        final Object[] nullArray = null;\n+        final Object[] objectArray = { \"a\", \"b\", \"c\", \"d\", \"e\", \"f\"};\n \n         assertEquals(\"0 start, mid end\", \"abcd\",\n             StringUtils.join(ArrayUtils.subarray(objectArray, 0, 4)));\n             StringUtils.join(ArrayUtils.subarray(objectArray, -2, 12)));\n             \n         // array type tests\n-        Date[] dateArray = { new java.sql.Date(new Date().getTime()),\n+        final Date[] dateArray = { new java.sql.Date(new Date().getTime()),\n             new Date(), new Date(), new Date(), new Date() };\n \n         assertSame(\"Object type\", Object.class,\n             ArrayUtils.subarray(dateArray, 1, 4).getClass().getComponentType());\n         try {\n             @SuppressWarnings(\"unused\")\n+            final\n             java.sql.Date[] dummy = (java.sql.Date[])ArrayUtils.subarray(dateArray, 1,3);\n             fail(\"Invalid downcast\");\n-        } catch (ClassCastException e) {}\n+        } catch (final ClassCastException e) {}\n     }\n \n     @Test\n     public void testSubarrayLong() {\n-        long[] nullArray = null;\n-        long[] array = { 999910, 999911, 999912, 999913, 999914, 999915 };\n-        long[] leftSubarray     = { 999910, 999911, 999912, 999913 };\n-        long[] midSubarray      = { 999911, 999912, 999913, 999914 };\n-        long[] rightSubarray    = { 999912, 999913, 999914, 999915 };\n+        final long[] nullArray = null;\n+        final long[] array = { 999910, 999911, 999912, 999913, 999914, 999915 };\n+        final long[] leftSubarray     = { 999910, 999911, 999912, 999913 };\n+        final long[] midSubarray      = { 999911, 999912, 999913, 999914 };\n+        final long[] rightSubarray    = { 999912, 999913, 999914, 999915 };\n \n         assertTrue(\"0 start, mid end\",\n             ArrayUtils.isEquals(leftSubarray,\n \n     @Test\n     public void testSubarrayInt() {\n-        int[] nullArray = null;\n-        int[] array = { 10, 11, 12, 13, 14, 15 };\n-        int[] leftSubarray  = { 10, 11, 12, 13 };\n-        int[] midSubarray   = { 11, 12, 13, 14 };\n-        int[] rightSubarray = { 12, 13, 14, 15 };\n+        final int[] nullArray = null;\n+        final int[] array = { 10, 11, 12, 13, 14, 15 };\n+        final int[] leftSubarray  = { 10, 11, 12, 13 };\n+        final int[] midSubarray   = { 11, 12, 13, 14 };\n+        final int[] rightSubarray = { 12, 13, 14, 15 };\n \n \n         assertTrue(\"0 start, mid end\",\n \n     @Test\n     public void testSubarrayShort() {\n-        short[] nullArray = null;\n-        short[] array = { 10, 11, 12, 13, 14, 15 };\n-        short[] leftSubarray    = { 10, 11, 12, 13 };\n-        short[] midSubarray     = { 11, 12, 13, 14 };\n-        short[] rightSubarray   = { 12, 13, 14, 15 };\n+        final short[] nullArray = null;\n+        final short[] array = { 10, 11, 12, 13, 14, 15 };\n+        final short[] leftSubarray    = { 10, 11, 12, 13 };\n+        final short[] midSubarray     = { 11, 12, 13, 14 };\n+        final short[] rightSubarray   = { 12, 13, 14, 15 };\n \n \n         assertTrue(\"0 start, mid end\",\n \n     @Test\n     public void testSubarrChar() {\n-        char[] nullArray = null;\n-        char[] array = { 'a', 'b', 'c', 'd', 'e', 'f' };\n-        char[] leftSubarray     = { 'a', 'b', 'c', 'd', };\n-        char[] midSubarray      = { 'b', 'c', 'd', 'e', };\n-        char[] rightSubarray    = { 'c', 'd', 'e', 'f', };\n+        final char[] nullArray = null;\n+        final char[] array = { 'a', 'b', 'c', 'd', 'e', 'f' };\n+        final char[] leftSubarray     = { 'a', 'b', 'c', 'd', };\n+        final char[] midSubarray      = { 'b', 'c', 'd', 'e', };\n+        final char[] rightSubarray    = { 'c', 'd', 'e', 'f', };\n \n \n         assertTrue(\"0 start, mid end\",\n \n     @Test\n     public void testSubarrayByte() {\n-        byte[] nullArray = null;\n-        byte[] array = { 10, 11, 12, 13, 14, 15 };\n-        byte[] leftSubarray     = { 10, 11, 12, 13 };\n-        byte[] midSubarray      = { 11, 12, 13, 14 };\n-        byte[] rightSubarray = { 12, 13, 14, 15 };\n+        final byte[] nullArray = null;\n+        final byte[] array = { 10, 11, 12, 13, 14, 15 };\n+        final byte[] leftSubarray     = { 10, 11, 12, 13 };\n+        final byte[] midSubarray      = { 11, 12, 13, 14 };\n+        final byte[] rightSubarray = { 12, 13, 14, 15 };\n \n \n         assertTrue(\"0 start, mid end\",\n \n     @Test\n     public void testSubarrayDouble() {\n-        double[] nullArray = null;\n-        double[] array = { 10.123, 11.234, 12.345, 13.456, 14.567, 15.678 };\n-        double[] leftSubarray   = { 10.123, 11.234, 12.345, 13.456, };\n-        double[] midSubarray    = { 11.234, 12.345, 13.456, 14.567, };\n-        double[] rightSubarray  = { 12.345, 13.456, 14.567, 15.678 };\n+        final double[] nullArray = null;\n+        final double[] array = { 10.123, 11.234, 12.345, 13.456, 14.567, 15.678 };\n+        final double[] leftSubarray   = { 10.123, 11.234, 12.345, 13.456, };\n+        final double[] midSubarray    = { 11.234, 12.345, 13.456, 14.567, };\n+        final double[] rightSubarray  = { 12.345, 13.456, 14.567, 15.678 };\n \n \n         assertTrue(\"0 start, mid end\",\n \n     @Test\n     public void testSubarrayFloat() {\n-        float[] nullArray = null;\n-        float[] array = { 10, 11, 12, 13, 14, 15 };\n-        float[] leftSubarray    = { 10, 11, 12, 13 };\n-        float[] midSubarray     = { 11, 12, 13, 14 };\n-        float[] rightSubarray   = { 12, 13, 14, 15 };\n+        final float[] nullArray = null;\n+        final float[] array = { 10, 11, 12, 13, 14, 15 };\n+        final float[] leftSubarray    = { 10, 11, 12, 13 };\n+        final float[] midSubarray     = { 11, 12, 13, 14 };\n+        final float[] rightSubarray   = { 12, 13, 14, 15 };\n \n \n         assertTrue(\"0 start, mid end\",\n \n     @Test\n     public void testSubarrayBoolean() {\n-        boolean[] nullArray = null;\n-        boolean[] array = { true, true, false, true, false, true };\n-        boolean[] leftSubarray  = { true, true, false, true  };\n-        boolean[] midSubarray   = { true, false, true, false };\n-        boolean[] rightSubarray = { false, true, false, true };\n+        final boolean[] nullArray = null;\n+        final boolean[] array = { true, true, false, true, false, true };\n+        final boolean[] leftSubarray  = { true, true, false, true  };\n+        final boolean[] midSubarray   = { true, false, true, false };\n+        final boolean[] rightSubarray = { false, true, false, true };\n \n \n         assertTrue(\"0 start, mid end\",\n     //-----------------------------------------------------------------------\n     @Test\n     public void testSameLength() {\n-        Object[] nullArray = null;\n-        Object[] emptyArray = new Object[0];\n-        Object[] oneArray = new Object[] {\"pick\"};\n-        Object[] twoArray = new Object[] {\"pick\", \"stick\"};\n+        final Object[] nullArray = null;\n+        final Object[] emptyArray = new Object[0];\n+        final Object[] oneArray = new Object[] {\"pick\"};\n+        final Object[] twoArray = new Object[] {\"pick\", \"stick\"};\n         \n         assertTrue(ArrayUtils.isSameLength(nullArray, nullArray));\n         assertTrue(ArrayUtils.isSameLength(nullArray, emptyArray));\n \n     @Test\n     public void testSameLengthBoolean() {\n-        boolean[] nullArray = null;\n-        boolean[] emptyArray = new boolean[0];\n-        boolean[] oneArray = new boolean[] {true};\n-        boolean[] twoArray = new boolean[] {true, false};\n+        final boolean[] nullArray = null;\n+        final boolean[] emptyArray = new boolean[0];\n+        final boolean[] oneArray = new boolean[] {true};\n+        final boolean[] twoArray = new boolean[] {true, false};\n         \n         assertTrue(ArrayUtils.isSameLength(nullArray, nullArray));\n         assertTrue(ArrayUtils.isSameLength(nullArray, emptyArray));\n     \n     @Test\n     public void testSameLengthLong() {\n-        long[] nullArray = null;\n-        long[] emptyArray = new long[0];\n-        long[] oneArray = new long[] {0L};\n-        long[] twoArray = new long[] {0L, 76L};\n+        final long[] nullArray = null;\n+        final long[] emptyArray = new long[0];\n+        final long[] oneArray = new long[] {0L};\n+        final long[] twoArray = new long[] {0L, 76L};\n         \n         assertTrue(ArrayUtils.isSameLength(nullArray, nullArray));\n         assertTrue(ArrayUtils.isSameLength(nullArray, emptyArray));\n     \n     @Test\n     public void testSameLengthInt() {\n-        int[] nullArray = null;\n-        int[] emptyArray = new int[0];\n-        int[] oneArray = new int[] {4};\n-        int[] twoArray = new int[] {5, 7};\n+        final int[] nullArray = null;\n+        final int[] emptyArray = new int[0];\n+        final int[] oneArray = new int[] {4};\n+        final int[] twoArray = new int[] {5, 7};\n         \n         assertTrue(ArrayUtils.isSameLength(nullArray, nullArray));\n         assertTrue(ArrayUtils.isSameLength(nullArray, emptyArray));\n     \n     @Test\n     public void testSameLengthShort() {\n-        short[] nullArray = null;\n-        short[] emptyArray = new short[0];\n-        short[] oneArray = new short[] {4};\n-        short[] twoArray = new short[] {6, 8};\n+        final short[] nullArray = null;\n+        final short[] emptyArray = new short[0];\n+        final short[] oneArray = new short[] {4};\n+        final short[] twoArray = new short[] {6, 8};\n         \n         assertTrue(ArrayUtils.isSameLength(nullArray, nullArray));\n         assertTrue(ArrayUtils.isSameLength(nullArray, emptyArray));\n     \n     @Test\n     public void testSameLengthChar() {\n-        char[] nullArray = null;\n-        char[] emptyArray = new char[0];\n-        char[] oneArray = new char[] {'f'};\n-        char[] twoArray = new char[] {'d', 't'};\n+        final char[] nullArray = null;\n+        final char[] emptyArray = new char[0];\n+        final char[] oneArray = new char[] {'f'};\n+        final char[] twoArray = new char[] {'d', 't'};\n         \n         assertTrue(ArrayUtils.isSameLength(nullArray, nullArray));\n         assertTrue(ArrayUtils.isSameLength(nullArray, emptyArray));\n     \n     @Test\n     public void testSameLengthByte() {\n-        byte[] nullArray = null;\n-        byte[] emptyArray = new byte[0];\n-        byte[] oneArray = new byte[] {3};\n-        byte[] twoArray = new byte[] {4, 6};\n+        final byte[] nullArray = null;\n+        final byte[] emptyArray = new byte[0];\n+        final byte[] oneArray = new byte[] {3};\n+        final byte[] twoArray = new byte[] {4, 6};\n         \n         assertTrue(ArrayUtils.isSameLength(nullArray, nullArray));\n         assertTrue(ArrayUtils.isSameLength(nullArray, emptyArray));\n     \n     @Test\n     public void testSameLengthDouble() {\n-        double[] nullArray = null;\n-        double[] emptyArray = new double[0];\n-        double[] oneArray = new double[] {1.3d};\n-        double[] twoArray = new double[] {4.5d, 6.3d};\n+        final double[] nullArray = null;\n+        final double[] emptyArray = new double[0];\n+        final double[] oneArray = new double[] {1.3d};\n+        final double[] twoArray = new double[] {4.5d, 6.3d};\n         \n         assertTrue(ArrayUtils.isSameLength(nullArray, nullArray));\n         assertTrue(ArrayUtils.isSameLength(nullArray, emptyArray));\n     \n     @Test\n     public void testSameLengthFloat() {\n-        float[] nullArray = null;\n-        float[] emptyArray = new float[0];\n-        float[] oneArray = new float[] {2.5f};\n-        float[] twoArray = new float[] {6.4f, 5.8f};\n+        final float[] nullArray = null;\n+        final float[] emptyArray = new float[0];\n+        final float[] oneArray = new float[] {2.5f};\n+        final float[] twoArray = new float[] {6.4f, 5.8f};\n         \n         assertTrue(ArrayUtils.isSameLength(nullArray, nullArray));\n         assertTrue(ArrayUtils.isSameLength(nullArray, emptyArray));\n         try {\n             ArrayUtils.isSameType(null, null);\n             fail();\n-        } catch (IllegalArgumentException ex) {}\n+        } catch (final IllegalArgumentException ex) {}\n         try {\n             ArrayUtils.isSameType(null, new Object[0]);\n             fail();\n-        } catch (IllegalArgumentException ex) {}\n+        } catch (final IllegalArgumentException ex) {}\n         try {\n             ArrayUtils.isSameType(new Object[0], null);\n             fail();\n-        } catch (IllegalArgumentException ex) {}\n+        } catch (final IllegalArgumentException ex) {}\n         \n         assertTrue(ArrayUtils.isSameType(new Object[0], new Object[0]));\n         assertFalse(ArrayUtils.isSameType(new String[0], new Object[0]));\n     //-----------------------------------------------------------------------\n     @Test\n     public void testReverse() {\n-        StringBuffer str1 = new StringBuffer(\"pick\");\n-        String str2 = \"a\";\n-        String[] str3 = new String[] {\"stick\"};\n-        String str4 = \"up\";\n+        final StringBuffer str1 = new StringBuffer(\"pick\");\n+        final String str2 = \"a\";\n+        final String[] str3 = new String[] {\"stick\"};\n+        final String str4 = \"up\";\n         \n         Object[] array = new Object[] {str1, str2, str3};\n         ArrayUtils.reverse(array);\n     //-----------------------------------------------------------------------\n     @Test\n     public void testIndexOf() {\n-        Object[] array = new Object[] { \"0\", \"1\", \"2\", \"3\", null, \"0\" };\n+        final Object[] array = new Object[] { \"0\", \"1\", \"2\", \"3\", null, \"0\" };\n         assertEquals(-1, ArrayUtils.indexOf(null, null));\n         assertEquals(-1, ArrayUtils.indexOf(null, \"0\"));\n         assertEquals(-1, ArrayUtils.indexOf(new Object[0], \"0\"));\n \n     @Test\n     public void testIndexOfWithStartIndex() {\n-        Object[] array = new Object[] { \"0\", \"1\", \"2\", \"3\", null, \"0\" };\n+        final Object[] array = new Object[] { \"0\", \"1\", \"2\", \"3\", null, \"0\" };\n         assertEquals(-1, ArrayUtils.indexOf(null, null, 2));\n         assertEquals(-1, ArrayUtils.indexOf(new Object[0], \"0\", 0));\n         assertEquals(-1, ArrayUtils.indexOf(null, \"0\", 2));\n \n     @Test\n     public void testLastIndexOf() {\n-        Object[] array = new Object[] { \"0\", \"1\", \"2\", \"3\", null, \"0\" };\n+        final Object[] array = new Object[] { \"0\", \"1\", \"2\", \"3\", null, \"0\" };\n         assertEquals(-1, ArrayUtils.lastIndexOf(null, null));\n         assertEquals(-1, ArrayUtils.lastIndexOf(null, \"0\"));\n         assertEquals(5, ArrayUtils.lastIndexOf(array, \"0\"));\n \n     @Test\n     public void testLastIndexOfWithStartIndex() {\n-        Object[] array = new Object[] { \"0\", \"1\", \"2\", \"3\", null, \"0\" };\n+        final Object[] array = new Object[] { \"0\", \"1\", \"2\", \"3\", null, \"0\" };\n         assertEquals(-1, ArrayUtils.lastIndexOf(null, null, 2));\n         assertEquals(-1, ArrayUtils.lastIndexOf(null, \"0\", 2));\n         assertEquals(0, ArrayUtils.lastIndexOf(array, \"0\", 2));\n \n     @Test\n     public void testContains() {\n-        Object[] array = new Object[] { \"0\", \"1\", \"2\", \"3\", null, \"0\" };\n+        final Object[] array = new Object[] { \"0\", \"1\", \"2\", \"3\", null, \"0\" };\n         assertFalse(ArrayUtils.contains(null, null));\n         assertFalse(ArrayUtils.contains(null, \"1\"));\n         assertTrue(ArrayUtils.contains(array, \"0\"));\n         try {\n             ArrayUtils.toPrimitive(new Boolean[] {Boolean.TRUE, null});\n             fail();\n-        } catch (NullPointerException ex) {}\n+        } catch (final NullPointerException ex) {}\n     }\n \n     @Test\n         try {\n             ArrayUtils.toPrimitive(new Character[] {new Character(Character.MIN_VALUE), null});\n             fail();\n-        } catch (NullPointerException ex) {}\n+        } catch (final NullPointerException ex) {}\n     }\n \n     @Test\n         try {\n             ArrayUtils.toPrimitive(new Byte[] {Byte.valueOf(Byte.MIN_VALUE), null});\n             fail();\n-        } catch (NullPointerException ex) {}\n+        } catch (final NullPointerException ex) {}\n     }\n \n     @Test\n         try {\n             ArrayUtils.toPrimitive(new Short[] {Short.valueOf(Short.MIN_VALUE), null});\n             fail();\n-        } catch (NullPointerException ex) {}\n+        } catch (final NullPointerException ex) {}\n     }\n \n     @Test\n          try {\n              ArrayUtils.toPrimitive(new Integer[] {Integer.valueOf(Integer.MIN_VALUE), null});\n              fail();\n-         } catch (NullPointerException ex) {}\n+         } catch (final NullPointerException ex) {}\n      }\n \n      @Test\n      \n     @Test\n     public void testToPrimitive_intNull() {\n-        Integer[] iArray = null;\n+        final Integer[] iArray = null;\n         assertEquals(null, ArrayUtils.toPrimitive(iArray, Integer.MIN_VALUE));\n     }\n \n          try {\n              ArrayUtils.toPrimitive(new Long[] {Long.valueOf(Long.MIN_VALUE), null});\n              fail();\n-         } catch (NullPointerException ex) {}\n+         } catch (final NullPointerException ex) {}\n      }\n \n      @Test\n          try {\n              ArrayUtils.toPrimitive(new Float[] {Float.valueOf(Float.MIN_VALUE), null});\n              fail();\n-         } catch (NullPointerException ex) {}\n+         } catch (final NullPointerException ex) {}\n      }\n \n      @Test\n          try {\n              ArrayUtils.toPrimitive(new Float[] {Float.valueOf(Float.MIN_VALUE), null});\n              fail();\n-         } catch (NullPointerException ex) {}\n+         } catch (final NullPointerException ex) {}\n      }\n \n      @Test\n      */\n     @Test\n     public void testIsEmptyObject() {\n-        Object[] emptyArray = new Object[] {};\n-        Object[] notEmptyArray = new Object[] { new String(\"Value\") };\n+        final Object[] emptyArray = new Object[] {};\n+        final Object[] notEmptyArray = new Object[] { new String(\"Value\") };\n         assertTrue(ArrayUtils.isEmpty((Object[])null));\n         assertTrue(ArrayUtils.isEmpty(emptyArray));\n         assertFalse(ArrayUtils.isEmpty(notEmptyArray));\n      */\n     @Test\n     public void testIsEmptyPrimitives() {\n-        long[] emptyLongArray = new long[] {};\n-        long[] notEmptyLongArray = new long[] { 1L };\n+        final long[] emptyLongArray = new long[] {};\n+        final long[] notEmptyLongArray = new long[] { 1L };\n         assertTrue(ArrayUtils.isEmpty((long[])null));\n         assertTrue(ArrayUtils.isEmpty(emptyLongArray));\n         assertFalse(ArrayUtils.isEmpty(notEmptyLongArray));\n \n-        int[] emptyIntArray = new int[] {};\n-        int[] notEmptyIntArray = new int[] { 1 };\n+        final int[] emptyIntArray = new int[] {};\n+        final int[] notEmptyIntArray = new int[] { 1 };\n         assertTrue(ArrayUtils.isEmpty((int[])null));\n         assertTrue(ArrayUtils.isEmpty(emptyIntArray));\n         assertFalse(ArrayUtils.isEmpty(notEmptyIntArray));\n \n-        short[] emptyShortArray = new short[] {};\n-        short[] notEmptyShortArray = new short[] { 1 };\n+        final short[] emptyShortArray = new short[] {};\n+        final short[] notEmptyShortArray = new short[] { 1 };\n         assertTrue(ArrayUtils.isEmpty((short[])null));\n         assertTrue(ArrayUtils.isEmpty(emptyShortArray));\n         assertFalse(ArrayUtils.isEmpty(notEmptyShortArray));\n \n-        char[] emptyCharArray = new char[] {};\n-        char[] notEmptyCharArray = new char[] { 1 };\n+        final char[] emptyCharArray = new char[] {};\n+        final char[] notEmptyCharArray = new char[] { 1 };\n         assertTrue(ArrayUtils.isEmpty((char[])null));\n         assertTrue(ArrayUtils.isEmpty(emptyCharArray));\n         assertFalse(ArrayUtils.isEmpty(notEmptyCharArray));\n \n-        byte[] emptyByteArray = new byte[] {};\n-        byte[] notEmptyByteArray = new byte[] { 1 };\n+        final byte[] emptyByteArray = new byte[] {};\n+        final byte[] notEmptyByteArray = new byte[] { 1 };\n         assertTrue(ArrayUtils.isEmpty((byte[])null));\n         assertTrue(ArrayUtils.isEmpty(emptyByteArray));\n         assertFalse(ArrayUtils.isEmpty(notEmptyByteArray));\n \n-        double[] emptyDoubleArray = new double[] {};\n-        double[] notEmptyDoubleArray = new double[] { 1.0 };\n+        final double[] emptyDoubleArray = new double[] {};\n+        final double[] notEmptyDoubleArray = new double[] { 1.0 };\n         assertTrue(ArrayUtils.isEmpty((double[])null));\n         assertTrue(ArrayUtils.isEmpty(emptyDoubleArray));\n         assertFalse(ArrayUtils.isEmpty(notEmptyDoubleArray));\n \n-        float[] emptyFloatArray = new float[] {};\n-        float[] notEmptyFloatArray = new float[] { 1.0F };\n+        final float[] emptyFloatArray = new float[] {};\n+        final float[] notEmptyFloatArray = new float[] { 1.0F };\n         assertTrue(ArrayUtils.isEmpty((float[])null));\n         assertTrue(ArrayUtils.isEmpty(emptyFloatArray));\n         assertFalse(ArrayUtils.isEmpty(notEmptyFloatArray));\n \n-        boolean[] emptyBooleanArray = new boolean[] {};\n-        boolean[] notEmptyBooleanArray = new boolean[] { true };\n+        final boolean[] emptyBooleanArray = new boolean[] {};\n+        final boolean[] notEmptyBooleanArray = new boolean[] { true };\n         assertTrue(ArrayUtils.isEmpty((boolean[])null));\n         assertTrue(ArrayUtils.isEmpty(emptyBooleanArray));\n         assertFalse(ArrayUtils.isEmpty(notEmptyBooleanArray));\n      */\n     @Test\n     public void testIsNotEmptyObject() {\n-        Object[] emptyArray = new Object[] {};\n-        Object[] notEmptyArray = new Object[] { new String(\"Value\") };\n+        final Object[] emptyArray = new Object[] {};\n+        final Object[] notEmptyArray = new Object[] { new String(\"Value\") };\n         assertFalse(ArrayUtils.isNotEmpty((Object[])null));\n         assertFalse(ArrayUtils.isNotEmpty(emptyArray));\n         assertTrue(ArrayUtils.isNotEmpty(notEmptyArray));\n      */\n     @Test\n     public void testIsNotEmptyPrimitives() {\n-        long[] emptyLongArray = new long[] {};\n-        long[] notEmptyLongArray = new long[] { 1L };\n+        final long[] emptyLongArray = new long[] {};\n+        final long[] notEmptyLongArray = new long[] { 1L };\n         assertFalse(ArrayUtils.isNotEmpty((long[])null));\n         assertFalse(ArrayUtils.isNotEmpty(emptyLongArray));\n         assertTrue(ArrayUtils.isNotEmpty(notEmptyLongArray));\n \n-        int[] emptyIntArray = new int[] {};\n-        int[] notEmptyIntArray = new int[] { 1 };\n+        final int[] emptyIntArray = new int[] {};\n+        final int[] notEmptyIntArray = new int[] { 1 };\n         assertFalse(ArrayUtils.isNotEmpty((int[])null));\n         assertFalse(ArrayUtils.isNotEmpty(emptyIntArray));\n         assertTrue(ArrayUtils.isNotEmpty(notEmptyIntArray));\n \n-        short[] emptyShortArray = new short[] {};\n-        short[] notEmptyShortArray = new short[] { 1 };\n+        final short[] emptyShortArray = new short[] {};\n+        final short[] notEmptyShortArray = new short[] { 1 };\n         assertFalse(ArrayUtils.isNotEmpty((short[])null));\n         assertFalse(ArrayUtils.isNotEmpty(emptyShortArray));\n         assertTrue(ArrayUtils.isNotEmpty(notEmptyShortArray));\n \n-        char[] emptyCharArray = new char[] {};\n-        char[] notEmptyCharArray = new char[] { 1 };\n+        final char[] emptyCharArray = new char[] {};\n+        final char[] notEmptyCharArray = new char[] { 1 };\n         assertFalse(ArrayUtils.isNotEmpty((char[])null));\n         assertFalse(ArrayUtils.isNotEmpty(emptyCharArray));\n         assertTrue(ArrayUtils.isNotEmpty(notEmptyCharArray));\n \n-        byte[] emptyByteArray = new byte[] {};\n-        byte[] notEmptyByteArray = new byte[] { 1 };\n+        final byte[] emptyByteArray = new byte[] {};\n+        final byte[] notEmptyByteArray = new byte[] { 1 };\n         assertFalse(ArrayUtils.isNotEmpty((byte[])null));\n         assertFalse(ArrayUtils.isNotEmpty(emptyByteArray));\n         assertTrue(ArrayUtils.isNotEmpty(notEmptyByteArray));\n \n-        double[] emptyDoubleArray = new double[] {};\n-        double[] notEmptyDoubleArray = new double[] { 1.0 };\n+        final double[] emptyDoubleArray = new double[] {};\n+        final double[] notEmptyDoubleArray = new double[] { 1.0 };\n         assertFalse(ArrayUtils.isNotEmpty((double[])null));\n         assertFalse(ArrayUtils.isNotEmpty(emptyDoubleArray));\n         assertTrue(ArrayUtils.isNotEmpty(notEmptyDoubleArray));\n \n-        float[] emptyFloatArray = new float[] {};\n-        float[] notEmptyFloatArray = new float[] { 1.0F };\n+        final float[] emptyFloatArray = new float[] {};\n+        final float[] notEmptyFloatArray = new float[] { 1.0F };\n         assertFalse(ArrayUtils.isNotEmpty((float[])null));\n         assertFalse(ArrayUtils.isNotEmpty(emptyFloatArray));\n         assertTrue(ArrayUtils.isNotEmpty(notEmptyFloatArray));\n \n-        boolean[] emptyBooleanArray = new boolean[] {};\n-        boolean[] notEmptyBooleanArray = new boolean[] { true };\n+        final boolean[] emptyBooleanArray = new boolean[] {};\n+        final boolean[] notEmptyBooleanArray = new boolean[] { true };\n         assertFalse(ArrayUtils.isNotEmpty((boolean[])null));\n         assertFalse(ArrayUtils.isNotEmpty(emptyBooleanArray));\n         assertTrue(ArrayUtils.isNotEmpty(notEmptyBooleanArray));\n     public void testGetLength() {\n         assertEquals(0, ArrayUtils.getLength(null));\n         \n-        Object[] emptyObjectArray = new Object[0];\n-        Object[] notEmptyObjectArray = new Object[] {\"aValue\"};\n+        final Object[] emptyObjectArray = new Object[0];\n+        final Object[] notEmptyObjectArray = new Object[] {\"aValue\"};\n         assertEquals(0, ArrayUtils.getLength((Object[]) null));\n         assertEquals(0, ArrayUtils.getLength(emptyObjectArray));\n         assertEquals(1, ArrayUtils.getLength(notEmptyObjectArray));\n  \n-        int[] emptyIntArray = new int[] {};\n-        int[] notEmptyIntArray = new int[] { 1 };\n+        final int[] emptyIntArray = new int[] {};\n+        final int[] notEmptyIntArray = new int[] { 1 };\n         assertEquals(0, ArrayUtils.getLength((int[]) null));\n         assertEquals(0, ArrayUtils.getLength(emptyIntArray));\n         assertEquals(1, ArrayUtils.getLength(notEmptyIntArray));\n \n-        short[] emptyShortArray = new short[] {};\n-        short[] notEmptyShortArray = new short[] { 1 };\n+        final short[] emptyShortArray = new short[] {};\n+        final short[] notEmptyShortArray = new short[] { 1 };\n         assertEquals(0, ArrayUtils.getLength((short[]) null));\n         assertEquals(0, ArrayUtils.getLength(emptyShortArray));\n         assertEquals(1, ArrayUtils.getLength(notEmptyShortArray));\n \n-        char[] emptyCharArray = new char[] {};\n-        char[] notEmptyCharArray = new char[] { 1 };\n+        final char[] emptyCharArray = new char[] {};\n+        final char[] notEmptyCharArray = new char[] { 1 };\n         assertEquals(0, ArrayUtils.getLength((char[]) null));\n         assertEquals(0, ArrayUtils.getLength(emptyCharArray));\n         assertEquals(1, ArrayUtils.getLength(notEmptyCharArray));\n \n-        byte[] emptyByteArray = new byte[] {};\n-        byte[] notEmptyByteArray = new byte[] { 1 };\n+        final byte[] emptyByteArray = new byte[] {};\n+        final byte[] notEmptyByteArray = new byte[] { 1 };\n         assertEquals(0, ArrayUtils.getLength((byte[]) null));\n         assertEquals(0, ArrayUtils.getLength(emptyByteArray));\n         assertEquals(1, ArrayUtils.getLength(notEmptyByteArray));\n \n-        double[] emptyDoubleArray = new double[] {};\n-        double[] notEmptyDoubleArray = new double[] { 1.0 };\n+        final double[] emptyDoubleArray = new double[] {};\n+        final double[] notEmptyDoubleArray = new double[] { 1.0 };\n         assertEquals(0, ArrayUtils.getLength((double[]) null));\n         assertEquals(0, ArrayUtils.getLength(emptyDoubleArray));\n         assertEquals(1, ArrayUtils.getLength(notEmptyDoubleArray));\n \n-        float[] emptyFloatArray = new float[] {};\n-        float[] notEmptyFloatArray = new float[] { 1.0F };\n+        final float[] emptyFloatArray = new float[] {};\n+        final float[] notEmptyFloatArray = new float[] { 1.0F };\n         assertEquals(0, ArrayUtils.getLength((float[]) null));\n         assertEquals(0, ArrayUtils.getLength(emptyFloatArray));\n         assertEquals(1, ArrayUtils.getLength(notEmptyFloatArray));\n \n-        boolean[] emptyBooleanArray = new boolean[] {};\n-        boolean[] notEmptyBooleanArray = new boolean[] { true };\n+        final boolean[] emptyBooleanArray = new boolean[] {};\n+        final boolean[] notEmptyBooleanArray = new boolean[] { true };\n         assertEquals(0, ArrayUtils.getLength((boolean[]) null));\n         assertEquals(0, ArrayUtils.getLength(emptyBooleanArray));\n         assertEquals(1, ArrayUtils.getLength(notEmptyBooleanArray));\n         try {\n             ArrayUtils.getLength(\"notAnArray\");\n             fail(\"IllegalArgumentException should have been thrown\");\n-        } catch (IllegalArgumentException e) {}\n+        } catch (final IllegalArgumentException e) {}\n     }\n \n }\n--- a/src/test/java/org/apache/commons/lang3/BitFieldTest.java\n+++ b/src/test/java/org/apache/commons/lang3/BitFieldTest.java\n         assertEquals(0, new BitField(64).setByteBoolean((byte) 64, false));\n         assertEquals(0, new BitField(128).setByteBoolean((byte) 128, false));\n         assertEquals(-2, new BitField(1).setByteBoolean((byte) 255, false));\n-        byte clearedBit = new BitField(0x40).setByteBoolean((byte) - 63, false);\n+        final byte clearedBit = new BitField(0x40).setByteBoolean((byte) - 63, false);\n \n         assertFalse(new BitField(0x40).isSet(clearedBit));\n     }\n--- a/src/test/java/org/apache/commons/lang3/BooleanUtilsTest.java\n+++ b/src/test/java/org/apache/commons/lang3/BooleanUtilsTest.java\n     @Test\n     public void testConstructor() {\n         assertNotNull(new BooleanUtils());\n-        Constructor<?>[] cons = BooleanUtils.class.getDeclaredConstructors();\n+        final Constructor<?>[] cons = BooleanUtils.class.getDeclaredConstructors();\n         assertEquals(1, cons.length);\n         assertTrue(Modifier.isPublic(cons[0].getModifiers()));\n         assertTrue(Modifier.isPublic(BooleanUtils.class.getModifiers()));\n     \n     @Test\n     public void test_toBoolean_Integer_Integer_Integer() {\n-        Integer six = Integer.valueOf(6);\n-        Integer seven = Integer.valueOf(7);\n+        final Integer six = Integer.valueOf(6);\n+        final Integer seven = Integer.valueOf(7);\n \n         assertTrue(BooleanUtils.toBoolean((Integer) null, null, seven));\n         assertFalse(BooleanUtils.toBoolean((Integer) null, six, null));\n     \n     @Test\n     public void test_toBooleanObject_Integer_Integer_Integer_Integer() {\n-        Integer six = Integer.valueOf(6);\n-        Integer seven = Integer.valueOf(7);\n-        Integer eight = Integer.valueOf(8);\n+        final Integer six = Integer.valueOf(6);\n+        final Integer seven = Integer.valueOf(7);\n+        final Integer eight = Integer.valueOf(8);\n \n         assertSame(Boolean.TRUE, BooleanUtils.toBooleanObject((Integer) null, null, seven, eight));\n         assertSame(Boolean.FALSE, BooleanUtils.toBooleanObject((Integer) null, six, null, eight));\n     \n     @Test\n     public void test_toIntegerObject_boolean_Integer_Integer() {\n-        Integer six = Integer.valueOf(6);\n-        Integer seven = Integer.valueOf(7);\n+        final Integer six = Integer.valueOf(6);\n+        final Integer seven = Integer.valueOf(7);\n         assertEquals(six, BooleanUtils.toIntegerObject(true, six, seven));\n         assertEquals(seven, BooleanUtils.toIntegerObject(false, six, seven));\n     }\n     \n     @Test\n     public void test_toIntegerObject_Boolean_Integer_Integer_Integer() {\n-        Integer six = Integer.valueOf(6);\n-        Integer seven = Integer.valueOf(7);\n-        Integer eight = Integer.valueOf(8);\n+        final Integer six = Integer.valueOf(6);\n+        final Integer seven = Integer.valueOf(7);\n+        final Integer eight = Integer.valueOf(8);\n         assertEquals(six, BooleanUtils.toIntegerObject(Boolean.TRUE, six, seven, eight));\n         assertEquals(seven, BooleanUtils.toIntegerObject(Boolean.FALSE, six, seven, eight));\n         assertEquals(eight, BooleanUtils.toIntegerObject((Boolean) null, six, seven, eight));\n--- a/src/test/java/org/apache/commons/lang3/CharRangeTest.java\n+++ b/src/test/java/org/apache/commons/lang3/CharRangeTest.java\n     //-----------------------------------------------------------------------\n     @Test\n     public void testConstructorAccessors_is() {\n-        CharRange rangea = CharRange.is('a');\n+        final CharRange rangea = CharRange.is('a');\n         assertEquals('a', rangea.getStart());\n         assertEquals('a', rangea.getEnd());\n         assertFalse(rangea.isNegated());\n \n     @Test\n     public void testConstructorAccessors_isNot() {\n-        CharRange rangea = CharRange.isNot('a');\n+        final CharRange rangea = CharRange.isNot('a');\n         assertEquals('a', rangea.getStart());\n         assertEquals('a', rangea.getEnd());\n         assertTrue(rangea.isNegated());\n \n     @Test\n     public void testConstructorAccessors_isIn_Same() {\n-        CharRange rangea = CharRange.isIn('a', 'a');\n+        final CharRange rangea = CharRange.isIn('a', 'a');\n         assertEquals('a', rangea.getStart());\n         assertEquals('a', rangea.getEnd());\n         assertFalse(rangea.isNegated());\n \n     @Test\n     public void testConstructorAccessors_isIn_Normal() {\n-        CharRange rangea = CharRange.isIn('a', 'e');\n+        final CharRange rangea = CharRange.isIn('a', 'e');\n         assertEquals('a', rangea.getStart());\n         assertEquals('e', rangea.getEnd());\n         assertFalse(rangea.isNegated());\n \n     @Test\n     public void testConstructorAccessors_isIn_Reversed() {\n-        CharRange rangea = CharRange.isIn('e', 'a');\n+        final CharRange rangea = CharRange.isIn('e', 'a');\n         assertEquals('a', rangea.getStart());\n         assertEquals('e', rangea.getEnd());\n         assertFalse(rangea.isNegated());\n \n     @Test\n     public void testConstructorAccessors_isNotIn_Same() {\n-        CharRange rangea = CharRange.isNotIn('a', 'a');\n+        final CharRange rangea = CharRange.isNotIn('a', 'a');\n         assertEquals('a', rangea.getStart());\n         assertEquals('a', rangea.getEnd());\n         assertTrue(rangea.isNegated());\n \n     @Test\n     public void testConstructorAccessors_isNotIn_Normal() {\n-        CharRange rangea = CharRange.isNotIn('a', 'e');\n+        final CharRange rangea = CharRange.isNotIn('a', 'e');\n         assertEquals('a', rangea.getStart());\n         assertEquals('e', rangea.getEnd());\n         assertTrue(rangea.isNegated());\n \n     @Test\n     public void testConstructorAccessors_isNotIn_Reversed() {\n-        CharRange rangea = CharRange.isNotIn('e', 'a');\n+        final CharRange rangea = CharRange.isNotIn('e', 'a');\n         assertEquals('a', rangea.getStart());\n         assertEquals('e', rangea.getEnd());\n         assertTrue(rangea.isNegated());\n     //-----------------------------------------------------------------------\n     @Test\n     public void testEquals_Object() {\n-        CharRange rangea = CharRange.is('a');\n-        CharRange rangeae = CharRange.isIn('a', 'e');\n-        CharRange rangenotbf = CharRange.isIn('b', 'f');\n+        final CharRange rangea = CharRange.is('a');\n+        final CharRange rangeae = CharRange.isIn('a', 'e');\n+        final CharRange rangenotbf = CharRange.isIn('b', 'f');\n \n         assertFalse(rangea.equals(null));\n \n \n     @Test\n     public void testHashCode() {\n-        CharRange rangea = CharRange.is('a');\n-        CharRange rangeae = CharRange.isIn('a', 'e');\n-        CharRange rangenotbf = CharRange.isIn('b', 'f');\n+        final CharRange rangea = CharRange.is('a');\n+        final CharRange rangeae = CharRange.isIn('a', 'e');\n+        final CharRange rangenotbf = CharRange.isIn('b', 'f');\n \n         assertTrue(rangea.hashCode() == rangea.hashCode());\n         assertTrue(rangea.hashCode() == CharRange.is('a').hashCode());\n     //-----------------------------------------------------------------------\n     @Test\n     public void testContains_Charrange() {\n-        CharRange a = CharRange.is('a');\n-        CharRange b = CharRange.is('b');\n-        CharRange c = CharRange.is('c');\n-        CharRange c2 = CharRange.is('c');\n-        CharRange d = CharRange.is('d');\n-        CharRange e = CharRange.is('e');\n-        CharRange cd = CharRange.isIn('c', 'd');\n-        CharRange bd = CharRange.isIn('b', 'd');\n-        CharRange bc = CharRange.isIn('b', 'c');\n-        CharRange ab = CharRange.isIn('a', 'b');\n-        CharRange de = CharRange.isIn('d', 'e');\n-        CharRange ef = CharRange.isIn('e', 'f');\n-        CharRange ae = CharRange.isIn('a', 'e');\n+        final CharRange a = CharRange.is('a');\n+        final CharRange b = CharRange.is('b');\n+        final CharRange c = CharRange.is('c');\n+        final CharRange c2 = CharRange.is('c');\n+        final CharRange d = CharRange.is('d');\n+        final CharRange e = CharRange.is('e');\n+        final CharRange cd = CharRange.isIn('c', 'd');\n+        final CharRange bd = CharRange.isIn('b', 'd');\n+        final CharRange bc = CharRange.isIn('b', 'c');\n+        final CharRange ab = CharRange.isIn('a', 'b');\n+        final CharRange de = CharRange.isIn('d', 'e');\n+        final CharRange ef = CharRange.isIn('e', 'f');\n+        final CharRange ae = CharRange.isIn('a', 'e');\n \n         // normal/normal\n         assertFalse(c.contains(b));\n         assertTrue(ae.contains(cd));\n         assertTrue(ae.contains(de));\n \n-        CharRange notb = CharRange.isNot('b');\n-        CharRange notc = CharRange.isNot('c');\n-        CharRange notd = CharRange.isNot('d');\n-        CharRange notab = CharRange.isNotIn('a', 'b');\n-        CharRange notbc = CharRange.isNotIn('b', 'c');\n-        CharRange notbd = CharRange.isNotIn('b', 'd');\n-        CharRange notcd = CharRange.isNotIn('c', 'd');\n-        CharRange notde = CharRange.isNotIn('d', 'e');\n-        CharRange notae = CharRange.isNotIn('a', 'e');\n-        CharRange all = CharRange.isIn((char) 0, Character.MAX_VALUE);\n-        CharRange allbutfirst = CharRange.isIn((char) 1, Character.MAX_VALUE);\n+        final CharRange notb = CharRange.isNot('b');\n+        final CharRange notc = CharRange.isNot('c');\n+        final CharRange notd = CharRange.isNot('d');\n+        final CharRange notab = CharRange.isNotIn('a', 'b');\n+        final CharRange notbc = CharRange.isNotIn('b', 'c');\n+        final CharRange notbd = CharRange.isNotIn('b', 'd');\n+        final CharRange notcd = CharRange.isNotIn('c', 'd');\n+        final CharRange notde = CharRange.isNotIn('d', 'e');\n+        final CharRange notae = CharRange.isNotIn('a', 'e');\n+        final CharRange all = CharRange.isIn((char) 0, Character.MAX_VALUE);\n+        final CharRange allbutfirst = CharRange.isIn((char) 1, Character.MAX_VALUE);\n \n         // normal/negated\n         assertFalse(c.contains(notc));\n \n     @Test\n     public void testContainsNullArg() {\n-        CharRange range = CharRange.is('a');\n+        final CharRange range = CharRange.is('a');\n         try {\n             @SuppressWarnings(\"unused\")\n+            final\n             boolean contains = range.contains(null);\n-        } catch(IllegalArgumentException e) {\n+        } catch(final IllegalArgumentException e) {\n             assertEquals(\"The Range must not be null\", e.getMessage());\n         }\n     }\n \n     @Test\n     public void testIterator() {\n-        CharRange a = CharRange.is('a');\n-        CharRange ad = CharRange.isIn('a', 'd');\n-        CharRange nota = CharRange.isNot('a');\n-        CharRange emptySet = CharRange.isNotIn((char) 0, Character.MAX_VALUE);\n-        CharRange notFirst = CharRange.isNotIn((char) 1, Character.MAX_VALUE);\n-        CharRange notLast = CharRange.isNotIn((char) 0, (char) (Character.MAX_VALUE - 1));\n-\n-        Iterator<Character> aIt = a.iterator();\n+        final CharRange a = CharRange.is('a');\n+        final CharRange ad = CharRange.isIn('a', 'd');\n+        final CharRange nota = CharRange.isNot('a');\n+        final CharRange emptySet = CharRange.isNotIn((char) 0, Character.MAX_VALUE);\n+        final CharRange notFirst = CharRange.isNotIn((char) 1, Character.MAX_VALUE);\n+        final CharRange notLast = CharRange.isNotIn((char) 0, (char) (Character.MAX_VALUE - 1));\n+\n+        final Iterator<Character> aIt = a.iterator();\n         assertNotNull(aIt);\n         assertTrue(aIt.hasNext());\n         assertEquals(Character.valueOf('a'), aIt.next());\n         assertFalse(aIt.hasNext());\n \n-        Iterator<Character> adIt = ad.iterator();\n+        final Iterator<Character> adIt = ad.iterator();\n         assertNotNull(adIt);\n         assertTrue(adIt.hasNext());\n         assertEquals(Character.valueOf('a'), adIt.next());\n         assertEquals(Character.valueOf('d'), adIt.next());\n         assertFalse(adIt.hasNext());\n \n-        Iterator<Character> notaIt = nota.iterator();\n+        final Iterator<Character> notaIt = nota.iterator();\n         assertNotNull(notaIt);\n         assertTrue(notaIt.hasNext());\n         while (notaIt.hasNext()) {\n-            Character c = notaIt.next();\n+            final Character c = notaIt.next();\n             assertFalse('a' == c.charValue());\n         }\n \n-        Iterator<Character> emptySetIt = emptySet.iterator();\n+        final Iterator<Character> emptySetIt = emptySet.iterator();\n         assertNotNull(emptySetIt);\n         assertFalse(emptySetIt.hasNext());\n         try {\n             emptySetIt.next();\n             fail(\"Should throw NoSuchElementException\");\n-        } catch (NoSuchElementException e) {\n+        } catch (final NoSuchElementException e) {\n             assertTrue(true);\n         }\n \n-        Iterator<Character> notFirstIt = notFirst.iterator();\n+        final Iterator<Character> notFirstIt = notFirst.iterator();\n         assertNotNull(notFirstIt);\n         assertTrue(notFirstIt.hasNext());\n         assertEquals(Character.valueOf((char) 0), notFirstIt.next());\n         try {\n             notFirstIt.next();\n             fail(\"Should throw NoSuchElementException\");\n-        } catch (NoSuchElementException e) {\n+        } catch (final NoSuchElementException e) {\n             assertTrue(true);\n         }\n \n-        Iterator<Character> notLastIt = notLast.iterator();\n+        final Iterator<Character> notLastIt = notLast.iterator();\n         assertNotNull(notLastIt);\n         assertTrue(notLastIt.hasNext());\n         assertEquals(Character.valueOf(Character.MAX_VALUE), notLastIt.next());\n         try {\n             notLastIt.next();\n             fail(\"Should throw NoSuchElementException\");\n-        } catch (NoSuchElementException e) {\n+        } catch (final NoSuchElementException e) {\n             assertTrue(true);\n         }\n     }\n--- a/src/test/java/org/apache/commons/lang3/CharSequenceUtilsTest.java\n+++ b/src/test/java/org/apache/commons/lang3/CharSequenceUtilsTest.java\n     @Test\n     public void testConstructor() {\n         assertNotNull(new CharSequenceUtils());\n-        Constructor<?>[] cons = CharSequenceUtils.class.getDeclaredConstructors();\n+        final Constructor<?>[] cons = CharSequenceUtils.class.getDeclaredConstructors();\n         assertEquals(1, cons.length);\n         assertTrue(Modifier.isPublic(cons[0].getModifiers()));\n         assertTrue(Modifier.isPublic(CharSequenceUtils.class.getModifiers()));\n         try {\n             Assert.assertEquals(null, CharSequenceUtils.subSequence(StringUtils.EMPTY, -1));\n             Assert.fail(\"Expected \" + IndexOutOfBoundsException.class.getName());\n-        } catch (IndexOutOfBoundsException e) {\n+        } catch (final IndexOutOfBoundsException e) {\n             // Expected\n         }\n         try {\n             Assert.assertEquals(null, CharSequenceUtils.subSequence(StringUtils.EMPTY, 1));\n             Assert.fail(\"Expected \" + IndexOutOfBoundsException.class.getName());\n-        } catch (IndexOutOfBoundsException e) {\n+        } catch (final IndexOutOfBoundsException e) {\n             // Expected\n         }\n     }\n--- a/src/test/java/org/apache/commons/lang3/CharSetTest.java\n+++ b/src/test/java/org/apache/commons/lang3/CharSetTest.java\n     //-----------------------------------------------------------------------    \n     @Test\n     public void testEquals_Object() {\n-        CharSet abc = CharSet.getInstance(\"abc\");\n-        CharSet abc2 = CharSet.getInstance(\"abc\");\n-        CharSet atoc = CharSet.getInstance(\"a-c\");\n-        CharSet atoc2 = CharSet.getInstance(\"a-c\");\n-        CharSet notatoc = CharSet.getInstance(\"^a-c\");\n-        CharSet notatoc2 = CharSet.getInstance(\"^a-c\");\n+        final CharSet abc = CharSet.getInstance(\"abc\");\n+        final CharSet abc2 = CharSet.getInstance(\"abc\");\n+        final CharSet atoc = CharSet.getInstance(\"a-c\");\n+        final CharSet atoc2 = CharSet.getInstance(\"a-c\");\n+        final CharSet notatoc = CharSet.getInstance(\"^a-c\");\n+        final CharSet notatoc2 = CharSet.getInstance(\"^a-c\");\n         \n         assertFalse(abc.equals(null));\n         \n             \n     @Test\n     public void testHashCode() {\n-        CharSet abc = CharSet.getInstance(\"abc\");\n-        CharSet abc2 = CharSet.getInstance(\"abc\");\n-        CharSet atoc = CharSet.getInstance(\"a-c\");\n-        CharSet atoc2 = CharSet.getInstance(\"a-c\");\n-        CharSet notatoc = CharSet.getInstance(\"^a-c\");\n-        CharSet notatoc2 = CharSet.getInstance(\"^a-c\");\n+        final CharSet abc = CharSet.getInstance(\"abc\");\n+        final CharSet abc2 = CharSet.getInstance(\"abc\");\n+        final CharSet atoc = CharSet.getInstance(\"a-c\");\n+        final CharSet atoc2 = CharSet.getInstance(\"a-c\");\n+        final CharSet notatoc = CharSet.getInstance(\"^a-c\");\n+        final CharSet notatoc2 = CharSet.getInstance(\"^a-c\");\n         \n         assertEquals(abc.hashCode(), abc.hashCode());\n         assertEquals(abc.hashCode(), abc2.hashCode());\n     //-----------------------------------------------------------------------    \n     @Test\n     public void testContains_Char() {\n-        CharSet btod = CharSet.getInstance(\"b-d\");\n-        CharSet dtob = CharSet.getInstance(\"d-b\");\n-        CharSet bcd = CharSet.getInstance(\"bcd\");\n-        CharSet bd = CharSet.getInstance(\"bd\");\n-        CharSet notbtod = CharSet.getInstance(\"^b-d\");\n+        final CharSet btod = CharSet.getInstance(\"b-d\");\n+        final CharSet dtob = CharSet.getInstance(\"d-b\");\n+        final CharSet bcd = CharSet.getInstance(\"bcd\");\n+        final CharSet bd = CharSet.getInstance(\"bd\");\n+        final CharSet notbtod = CharSet.getInstance(\"^b-d\");\n         \n         assertFalse(btod.contains('a'));\n         assertTrue(btod.contains('b'));\n         assertTrue(dtob.contains('d'));\n         assertFalse(dtob.contains('e'));\n       \n-        CharRange[] array = dtob.getCharRanges();\n+        final CharRange[] array = dtob.getCharRanges();\n         assertEquals(\"[b-d]\", dtob.toString());\n         assertEquals(1, array.length);\n     }\n--- a/src/test/java/org/apache/commons/lang3/CharSetUtilsTest.java\n+++ b/src/test/java/org/apache/commons/lang3/CharSetUtilsTest.java\n     @Test\n     public void testConstructor() {\n         assertNotNull(new CharSetUtils());\n-        Constructor<?>[] cons = CharSetUtils.class.getDeclaredConstructors();\n+        final Constructor<?>[] cons = CharSetUtils.class.getDeclaredConstructors();\n         assertEquals(1, cons.length);\n         assertTrue(Modifier.isPublic(cons[0].getModifiers()));\n         assertTrue(Modifier.isPublic(CharSetUtils.class.getModifiers()));\n--- a/src/test/java/org/apache/commons/lang3/CharUtilsPerfRun.java\n+++ b/src/test/java/org/apache/commons/lang3/CharUtilsPerfRun.java\n     private int run_CharSet(final int loopCount) {\n         int t = 0;\n         for (int i = 0; i < loopCount; i++) {\n-            for (char ch : CHAR_SAMPLES) {\n-                boolean b = CharSet.ASCII_NUMERIC.contains(ch);\n+            for (final char ch : CHAR_SAMPLES) {\n+                final boolean b = CharSet.ASCII_NUMERIC.contains(ch);\n                 t += b ? 1 : 0;\n             }\n         }\n     private int run_CharUtils_isAsciiNumeric(final int loopCount) {\n         int t = 0;\n         for (int i = 0; i < loopCount; i++) {\n-            for (char ch : CHAR_SAMPLES) {\n-                boolean b = CharUtils.isAsciiNumeric(ch);\n+            for (final char ch : CHAR_SAMPLES) {\n+                final boolean b = CharUtils.isAsciiNumeric(ch);\n                 t += b ? 1 : 0;\n             }\n         }\n     private int run_inlined_CharUtils_isAsciiNumeric(final int loopCount) {\n         int t = 0;\n         for (int i = 0; i < loopCount; i++) {\n-            for (char ch : CHAR_SAMPLES) {\n-                boolean b = ch >= '0' && ch <= '9';\n+            for (final char ch : CHAR_SAMPLES) {\n+                final boolean b = ch >= '0' && ch <= '9';\n                 t += b ? 1 : 0;\n             }\n         }\n     }\n \n     private void printlnTotal(final String prefix, final long start) {\n-        long total = System.currentTimeMillis() - start;\n+        final long total = System.currentTimeMillis() - start;\n         System.out.println(prefix + \": \" + NumberFormat.getInstance().format(total) + \" milliseconds.\");\n     }\n }\n--- a/src/test/java/org/apache/commons/lang3/CharUtilsTest.java\n+++ b/src/test/java/org/apache/commons/lang3/CharUtilsTest.java\n     @Test\n     public void testConstructor() {\n         assertNotNull(new CharUtils());\n-        Constructor<?>[] cons = CharUtils.class.getDeclaredConstructors();\n+        final Constructor<?>[] cons = CharUtils.class.getDeclaredConstructors();\n         assertEquals(1, cons.length);\n         assertTrue(Modifier.isPublic(cons[0].getModifiers()));\n         assertTrue(Modifier.isPublic(BooleanUtils.class.getModifiers()));\n         assertSame(CharUtils.toCharacterObject('a'), CharUtils.toCharacterObject('a'));\n        \n         for (int i = 0; i < 128; i++) {\n-            Character ch = CharUtils.toCharacterObject((char) i);\n-            Character ch2 = CharUtils.toCharacterObject((char) i);\n+            final Character ch = CharUtils.toCharacterObject((char) i);\n+            final Character ch2 = CharUtils.toCharacterObject((char) i);\n             assertSame(ch, ch2);\n             assertEquals(i, ch.charValue());\n         }\n         for (int i = 128; i < 196; i++) {\n-            Character ch = CharUtils.toCharacterObject((char) i);\n-            Character ch2 = CharUtils.toCharacterObject((char) i);\n+            final Character ch = CharUtils.toCharacterObject((char) i);\n+            final Character ch2 = CharUtils.toCharacterObject((char) i);\n             assertEquals(ch, ch2);\n             assertTrue(ch != ch2);\n             assertEquals(i, ch.charValue());\n         assertEquals('B', CharUtils.toChar(CHARACTER_B));\n         try {\n             CharUtils.toChar((Character) null);\n-        } catch (IllegalArgumentException ex) {}\n+        } catch (final IllegalArgumentException ex) {}\n     }\n     \n     @Test\n         assertEquals('B', CharUtils.toChar(\"BA\"));\n         try {\n             CharUtils.toChar((String) null);\n-        } catch (IllegalArgumentException ex) {}\n+        } catch (final IllegalArgumentException ex) {}\n         try {\n             CharUtils.toChar(\"\");\n-        } catch (IllegalArgumentException ex) {}\n+        } catch (final IllegalArgumentException ex) {}\n     }\n     \n     @Test\n         assertEquals(9, CharUtils.toIntValue('9'));\n         try {\n             CharUtils.toIntValue('a');\n-        } catch (IllegalArgumentException ex) {}\n+        } catch (final IllegalArgumentException ex) {}\n     }\n     \n     @Test\n         assertEquals(3, CharUtils.toIntValue(new Character('3')));\n         try {\n             CharUtils.toIntValue(null);\n-        } catch (IllegalArgumentException ex) {}\n+        } catch (final IllegalArgumentException ex) {}\n         try {\n             CharUtils.toIntValue(CHARACTER_A);\n-        } catch (IllegalArgumentException ex) {}\n+        } catch (final IllegalArgumentException ex) {}\n     }\n     \n     @Test\n         assertSame(CharUtils.toString('a'), CharUtils.toString('a'));\n        \n         for (int i = 0; i < 128; i++) {\n-            String str = CharUtils.toString((char) i);\n-            String str2 = CharUtils.toString((char) i);\n+            final String str = CharUtils.toString((char) i);\n+            final String str2 = CharUtils.toString((char) i);\n             assertSame(str, str2);\n             assertEquals(1, str.length());\n             assertEquals(i, str.charAt(0));\n         }\n         for (int i = 128; i < 196; i++) {\n-            String str = CharUtils.toString((char) i);\n-            String str2 = CharUtils.toString((char) i);\n+            final String str = CharUtils.toString((char) i);\n+            final String str2 = CharUtils.toString((char) i);\n             assertEquals(str, str2);\n             assertTrue(str != str2);\n             assertEquals(1, str.length());\n         assertEquals(\"\\\\u0041\", CharUtils.unicodeEscaped('A'));\n        \n         for (int i = 0; i < 196; i++) {\n-            String str = CharUtils.unicodeEscaped((char) i);\n+            final String str = CharUtils.unicodeEscaped((char) i);\n             assertEquals(6, str.length());\n-            int val = Integer.parseInt(str.substring(2), 16);\n+            final int val = Integer.parseInt(str.substring(2), 16);\n             assertEquals(i, val);\n         }\n         assertEquals(\"\\\\u0999\", CharUtils.unicodeEscaped((char) 0x999));\n--- a/src/test/java/org/apache/commons/lang3/ClassUtilsTest.java\n+++ b/src/test/java/org/apache/commons/lang3/ClassUtilsTest.java\n     @Test\n     public void testConstructor() {\n         assertNotNull(new ClassUtils());\n-        Constructor<?>[] cons = ClassUtils.class.getDeclaredConstructors();\n+        final Constructor<?>[] cons = ClassUtils.class.getDeclaredConstructors();\n         assertEquals(1, cons.length);\n         assertTrue(Modifier.isPublic(cons[0].getModifiers()));\n         assertTrue(Modifier.isPublic(ClassUtils.class.getModifiers()));\n     // -------------------------------------------------------------------------\n     @Test\n     public void test_getAllSuperclasses_Class() {\n-        List<?> list = ClassUtils.getAllSuperclasses(CY.class);\n+        final List<?> list = ClassUtils.getAllSuperclasses(CY.class);\n         assertEquals(2, list.size());\n         assertEquals(CX.class, list.get(0));\n         assertEquals(Object.class, list.get(1));\n \n     @Test\n     public void test_getAllInterfaces_Class() {\n-        List<?> list = ClassUtils.getAllInterfaces(CY.class);\n+        final List<?> list = ClassUtils.getAllInterfaces(CY.class);\n         assertEquals(6, list.size());\n         assertEquals(IB.class, list.get(0));\n         assertEquals(IC.class, list.get(1));\n     // -------------------------------------------------------------------------\n     @Test\n     public void test_convertClassNamesToClasses_List() {\n-        List<String> list = new ArrayList<String>();\n+        final List<String> list = new ArrayList<String>();\n         List<Class<?>> result = ClassUtils.convertClassNamesToClasses(list);\n         assertEquals(0, result.size());\n \n         assertEquals(Object.class, result.get(2));\n \n         @SuppressWarnings(\"unchecked\") // test what happens when non-generic code adds wrong type of element\n+        final\n         List<Object> olist = (List<Object>)(List<?>)list;\n         olist.add(new Object());\n         try {\n             ClassUtils.convertClassNamesToClasses(list);\n             fail(\"Should not have been able to convert list\");\n-        } catch (ClassCastException expected) {}\n+        } catch (final ClassCastException expected) {}\n         assertEquals(null, ClassUtils.convertClassNamesToClasses(null));\n     }\n \n     @Test\n     public void test_convertClassesToClassNames_List() {\n-        List<Class<?>> list = new ArrayList<Class<?>>();\n+        final List<Class<?>> list = new ArrayList<Class<?>>();\n         List<String> result = ClassUtils.convertClassesToClassNames(list);\n         assertEquals(0, result.size());\n \n         assertEquals(\"java.lang.Object\", result.get(2));\n \n         @SuppressWarnings(\"unchecked\") // test what happens when non-generic code adds wrong type of element\n+        final\n         List<Object> olist = (List<Object>)(List<?>)list;\n         olist.add(new Object());\n         try {\n             ClassUtils.convertClassesToClassNames(list);\n             fail(\"Should not have been able to convert list\");\n-        } catch (ClassCastException expected) {}\n+        } catch (final ClassCastException expected) {}\n         assertEquals(null, ClassUtils.convertClassesToClassNames(null));\n     }\n \n     // -------------------------------------------------------------------------\n     @Test\n     public void test_isAssignable_ClassArray_ClassArray() throws Exception {\n-        Class<?>[] array2 = new Class[] {Object.class, Object.class};\n-        Class<?>[] array1 = new Class[] {Object.class};\n-        Class<?>[] array1s = new Class[] {String.class};\n-        Class<?>[] array0 = new Class[] {};\n-        Class<?>[] arrayPrimitives = { Integer.TYPE, Boolean.TYPE };\n-        Class<?>[] arrayWrappers = { Integer.class, Boolean.class };\n+        final Class<?>[] array2 = new Class[] {Object.class, Object.class};\n+        final Class<?>[] array1 = new Class[] {Object.class};\n+        final Class<?>[] array1s = new Class[] {String.class};\n+        final Class<?>[] array0 = new Class[] {};\n+        final Class<?>[] arrayPrimitives = { Integer.TYPE, Boolean.TYPE };\n+        final Class<?>[] arrayWrappers = { Integer.class, Boolean.class };\n \n         assertFalse(ClassUtils.isAssignable(array1, array2));\n         assertFalse(ClassUtils.isAssignable(null, array2));\n         assertTrue(ClassUtils.isAssignable(array1s, array1s));\n         assertTrue(ClassUtils.isAssignable(array1s, array1));\n \n-        boolean autoboxing = SystemUtils.isJavaVersionAtLeast(JAVA_1_5);\n+        final boolean autoboxing = SystemUtils.isJavaVersionAtLeast(JAVA_1_5);\n \n         assertEquals(autoboxing, ClassUtils.isAssignable(arrayPrimitives, arrayWrappers));\n         assertEquals(autoboxing, ClassUtils.isAssignable(arrayWrappers, arrayPrimitives));\n \n     @Test\n     public void test_isAssignable_ClassArray_ClassArray_Autoboxing() throws Exception {\n-        Class<?>[] array2 = new Class[] {Object.class, Object.class};\n-        Class<?>[] array1 = new Class[] {Object.class};\n-        Class<?>[] array1s = new Class[] {String.class};\n-        Class<?>[] array0 = new Class[] {};\n-        Class<?>[] arrayPrimitives = { Integer.TYPE, Boolean.TYPE };\n-        Class<?>[] arrayWrappers = { Integer.class, Boolean.class };\n+        final Class<?>[] array2 = new Class[] {Object.class, Object.class};\n+        final Class<?>[] array1 = new Class[] {Object.class};\n+        final Class<?>[] array1s = new Class[] {String.class};\n+        final Class<?>[] array0 = new Class[] {};\n+        final Class<?>[] arrayPrimitives = { Integer.TYPE, Boolean.TYPE };\n+        final Class<?>[] arrayWrappers = { Integer.class, Boolean.class };\n \n         assertFalse(ClassUtils.isAssignable(array1, array2, true));\n         assertFalse(ClassUtils.isAssignable(null, array2, true));\n \n     @Test\n     public void test_isAssignable_ClassArray_ClassArray_NoAutoboxing() throws Exception {\n-        Class<?>[] array2 = new Class[] {Object.class, Object.class};\n-        Class<?>[] array1 = new Class[] {Object.class};\n-        Class<?>[] array1s = new Class[] {String.class};\n-        Class<?>[] array0 = new Class[] {};\n-        Class<?>[] arrayPrimitives = { Integer.TYPE, Boolean.TYPE };\n-        Class<?>[] arrayWrappers = { Integer.class, Boolean.class };\n+        final Class<?>[] array2 = new Class[] {Object.class, Object.class};\n+        final Class<?>[] array1 = new Class[] {Object.class};\n+        final Class<?>[] array1s = new Class[] {String.class};\n+        final Class<?>[] array0 = new Class[] {};\n+        final Class<?>[] arrayPrimitives = { Integer.TYPE, Boolean.TYPE };\n+        final Class<?>[] arrayWrappers = { Integer.class, Boolean.class };\n \n         assertFalse(ClassUtils.isAssignable(array1, array2, false));\n         assertFalse(ClassUtils.isAssignable(null, array2, false));\n         assertTrue(ClassUtils.isAssignable(String.class, String.class));\n         assertFalse(ClassUtils.isAssignable(Object.class, String.class));\n \n-        boolean autoboxing = SystemUtils.isJavaVersionAtLeast(JAVA_1_5);\n+        final boolean autoboxing = SystemUtils.isJavaVersionAtLeast(JAVA_1_5);\n \n         assertEquals(autoboxing, ClassUtils.isAssignable(Integer.TYPE, Integer.class));\n         assertEquals(autoboxing, ClassUtils.isAssignable(Integer.TYPE, Object.class));\n \n     @Test\n     public void test_isAssignable_DefaultUnboxing_Widening() throws Exception {\n-        boolean autoboxing = SystemUtils.isJavaVersionAtLeast(JAVA_1_5);\n+        final boolean autoboxing = SystemUtils.isJavaVersionAtLeast(JAVA_1_5);\n \n         // test byte conversions\n         assertFalse(\"byte -> char\", ClassUtils.isAssignable(Byte.class, Character.TYPE));\n         assertNull(\"null -> null\", ClassUtils.primitivesToWrappers((Class<?>[]) null)); // equivalent cast to avoid warning\n         // Other possible casts for null\n         assertTrue(\"empty -> empty\", Arrays.equals(ArrayUtils.EMPTY_CLASS_ARRAY, ClassUtils.primitivesToWrappers()));\n-        Class<?>[] castNull = ClassUtils.primitivesToWrappers((Class<?>)null); // == new Class<?>[]{null}\n+        final Class<?>[] castNull = ClassUtils.primitivesToWrappers((Class<?>)null); // == new Class<?>[]{null}\n         assertTrue(\"(Class<?>)null -> [null]\", Arrays.equals(new Class<?>[]{null}, castNull));\n         // test empty array is returned unchanged\n         // TODO this is not documented\n                 Integer.TYPE, Long.TYPE, Double.TYPE, Float.TYPE,\n                 String.class, ClassUtils.class\n         };\n-        Class<?>[] wrappers= ClassUtils.primitivesToWrappers(primitives);\n+        final Class<?>[] wrappers= ClassUtils.primitivesToWrappers(primitives);\n \n         for (int i=0; i < primitives.length; i++) {\n             // test each returned wrapper\n-            Class<?> primitive = primitives[i];\n-            Class<?> expectedWrapper = ClassUtils.primitiveToWrapper(primitive);\n+            final Class<?> primitive = primitives[i];\n+            final Class<?> expectedWrapper = ClassUtils.primitiveToWrapper(primitive);\n \n             assertEquals(primitive + \" -> \" + expectedWrapper, expectedWrapper, wrappers[i]);\n         }\n                 Boolean.TYPE, Byte.TYPE, Character.TYPE, Short.TYPE,\n                 Integer.TYPE, Long.TYPE, Float.TYPE, Double.TYPE\n         };\n-        for (Class<?> primitive : primitives) {\n-            Class<?> wrapperCls = ClassUtils.primitiveToWrapper(primitive);\n+        for (final Class<?> primitive : primitives) {\n+            final Class<?> wrapperCls = ClassUtils.primitiveToWrapper(primitive);\n             assertFalse(\"Still primitive\", wrapperCls.isPrimitive());\n             assertEquals(wrapperCls + \" -> \" + primitive, primitive,\n                     ClassUtils.wrapperToPrimitive(wrapperCls));\n                 String.class, ClassUtils.class, null\n         };\n \n-        Class<?>[] primitives = ClassUtils.wrappersToPrimitives(classes);\n+        final Class<?>[] primitives = ClassUtils.wrappersToPrimitives(classes);\n         // now test the result\n         assertEquals(\"Wrong length of result array\", classes.length, primitives.length);\n         for (int i = 0; i < classes.length; i++) {\n-            Class<?> expectedPrimitive = ClassUtils.wrapperToPrimitive(classes[i]);\n+            final Class<?> expectedPrimitive = ClassUtils.wrapperToPrimitive(classes[i]);\n             assertEquals(classes[i] + \" -> \" + expectedPrimitive, expectedPrimitive,\n                     primitives[i]);\n         }\n         assertNull(\"Wrong result for null input\", ClassUtils.wrappersToPrimitives((Class<?>[]) null)); // equivalent cast\n         // Other possible casts for null\n         assertTrue(\"empty -> empty\", Arrays.equals(ArrayUtils.EMPTY_CLASS_ARRAY, ClassUtils.wrappersToPrimitives()));\n-        Class<?>[] castNull = ClassUtils.wrappersToPrimitives((Class<?>)null); // == new Class<?>[]{null}\n+        final Class<?>[] castNull = ClassUtils.wrappersToPrimitives((Class<?>)null); // == new Class<?>[]{null}\n         assertTrue(\"(Class<?>)null -> [null]\", Arrays.equals(new Class<?>[]{null}, castNull));\n }\n \n     @Test\n     public void testWrappersToPrimitivesEmpty() {\n-        Class<?>[] empty = new Class[0];\n+        final Class<?>[] empty = new Class[0];\n         assertArrayEquals(\"Wrong result for empty input\", empty, ClassUtils.wrappersToPrimitives(empty));\n     }\n \n             ClassUtils.getClass( className );\n             fail( \"ClassUtils.getClass() should fail with an exception of type \" + exceptionType.getName() + \" when given class name \\\"\" + className + \"\\\".\" );\n         }\n-        catch( Exception e ) {\n+        catch( final Exception e ) {\n             assertTrue( exceptionType.isAssignableFrom( e.getClass() ) );\n         }\n     }\n     @Test\n     public void testShowJavaBug() throws Exception {\n         // Tests with Collections$UnmodifiableSet\n-        Set<?> set = Collections.unmodifiableSet(new HashSet<Object>());\n-        Method isEmptyMethod = set.getClass().getMethod(\"isEmpty\",  new Class[0]);\n+        final Set<?> set = Collections.unmodifiableSet(new HashSet<Object>());\n+        final Method isEmptyMethod = set.getClass().getMethod(\"isEmpty\",  new Class[0]);\n         try {\n             isEmptyMethod.invoke(set, new Object[0]);\n             fail(\"Failed to throw IllegalAccessException as expected\");\n-        } catch(IllegalAccessException iae) {\n+        } catch(final IllegalAccessException iae) {\n             // expected\n         }\n     }\n     @Test\n     public void testGetPublicMethod() throws Exception {\n         // Tests with Collections$UnmodifiableSet\n-        Set<?> set = Collections.unmodifiableSet(new HashSet<Object>());\n-        Method isEmptyMethod = ClassUtils.getPublicMethod(set.getClass(), \"isEmpty\",  new Class[0]);\n+        final Set<?> set = Collections.unmodifiableSet(new HashSet<Object>());\n+        final Method isEmptyMethod = ClassUtils.getPublicMethod(set.getClass(), \"isEmpty\",  new Class[0]);\n             assertTrue(Modifier.isPublic(isEmptyMethod.getDeclaringClass().getModifiers()));\n \n         try {\n             isEmptyMethod.invoke(set, new Object[0]);\n-        } catch(java.lang.IllegalAccessException iae) {\n+        } catch(final java.lang.IllegalAccessException iae) {\n             fail(\"Should not have thrown IllegalAccessException\");\n         }\n \n         // Tests with a public Class\n-        Method toStringMethod = ClassUtils.getPublicMethod(Object.class, \"toString\",  new Class[0]);\n+        final Method toStringMethod = ClassUtils.getPublicMethod(Object.class, \"toString\",  new Class[0]);\n             assertEquals(Object.class.getMethod(\"toString\", new Class[0]), toStringMethod);\n     }\n \n         \n         // Additional varargs tests\n         assertTrue(\"empty -> empty\", Arrays.equals(ArrayUtils.EMPTY_CLASS_ARRAY, ClassUtils.toClass()));\n-        Class<?>[] castNull = ClassUtils.toClass((Object) null); // == new Object[]{null}\n+        final Class<?>[] castNull = ClassUtils.toClass((Object) null); // == new Object[]{null}\n         assertTrue(\"(Object)null -> [null]\", Arrays.equals(new Object[]{null}, castNull));\n \n         assertSame(ArrayUtils.EMPTY_CLASS_ARRAY, ClassUtils.toClass(ArrayUtils.EMPTY_OBJECT_ARRAY));\n--- a/src/test/java/org/apache/commons/lang3/ConversionTest.java\n+++ b/src/test/java/org/apache/commons/lang3/ConversionTest.java\n      */\n     @Test\n     public void testBinaryToHexDigit_2args() {\n-        boolean[] shortArray = new boolean[]{false, true, true};\n+        final boolean[] shortArray = new boolean[]{false, true, true};\n         assertEquals('6', Conversion.binaryToHexDigit(shortArray, 0));\n         assertEquals('3', Conversion.binaryToHexDigit(shortArray, 1));\n         assertEquals('1', Conversion.binaryToHexDigit(shortArray, 2));\n-        boolean[] longArray = new boolean[]{true, false, true, false, false, true, true};\n+        final boolean[] longArray = new boolean[]{true, false, true, false, false, true, true};\n         assertEquals('5', Conversion.binaryToHexDigit(longArray, 0));\n         assertEquals('2', Conversion.binaryToHexDigit(longArray, 1));\n         assertEquals('9', Conversion.binaryToHexDigit(longArray, 2));\n         // assertEquals('6', Conversion.BinaryToHexDigitMsb0(shortArray,0));\n         // assertEquals('3', Conversion.BinaryToHexDigitMsb0(shortArray,1));\n         // assertEquals('1', Conversion.BinaryToHexDigitMsb0(shortArray,2));\n-        boolean[] shortArray = new boolean[]{true, true, false, true};\n+        final boolean[] shortArray = new boolean[]{true, true, false, true};\n         assertEquals('d', Conversion.binaryToHexDigitMsb0_4bits(shortArray, 0));\n-        boolean[] longArray = new boolean[]{true, false, true, false, false, true, true};\n+        final boolean[] longArray = new boolean[]{true, false, true, false, false, true, true};\n         assertEquals('a', Conversion.binaryToHexDigitMsb0_4bits(longArray, 0));\n         assertEquals('4', Conversion.binaryToHexDigitMsb0_4bits(longArray, 1));\n         assertEquals('9', Conversion.binaryToHexDigitMsb0_4bits(longArray, 2));\n         // assertEquals('6', Conversion.BinaryToHexDigitMsb0(longArray,4));\n         // assertEquals('3', Conversion.BinaryToHexDigitMsb0(longArray,5));\n         // assertEquals('1', Conversion.BinaryToHexDigitMsb0(longArray,6));\n-        boolean[] maxLengthArray = new boolean[]{\n+        final boolean[] maxLengthArray = new boolean[]{\n             true, false, true, false, false, true, true, true};\n         assertEquals('a', Conversion.binaryToHexDigitMsb0_4bits(maxLengthArray, 0));\n         assertEquals('4', Conversion.binaryToHexDigitMsb0_4bits(maxLengthArray, 1));\n         // assertEquals('7', Conversion.BinaryToHexDigitMsb0(longArray,5));\n         // assertEquals('3', Conversion.BinaryToHexDigitMsb0(longArray,6));\n         // assertEquals('1', Conversion.BinaryToHexDigitMsb0(longArray,7));\n-        boolean[] javaDocCheck = new boolean[]{\n+        final boolean[] javaDocCheck = new boolean[]{\n             true, false, false, true, true, false, true, false};\n         assertEquals('d', Conversion.binaryToHexDigitMsb0_4bits(javaDocCheck, 3));\n \n                 true, false, false, false, false, false, false, false, false, false, false,\n                 true, false, true, false, false}, 2));\n \n-        boolean[] shortArray = new boolean[]{true, true, false};\n+        final boolean[] shortArray = new boolean[]{true, true, false};\n         assertEquals('6', Conversion.binaryBeMsb0ToHexDigit(shortArray, 0));\n         assertEquals('3', Conversion.binaryBeMsb0ToHexDigit(shortArray, 1));\n         assertEquals('1', Conversion.binaryBeMsb0ToHexDigit(shortArray, 2));\n-        boolean[] shortArray2 = new boolean[]{true, true, true, false, false, true, false, true};\n+        final boolean[] shortArray2 = new boolean[]{true, true, true, false, false, true, false, true};\n         assertEquals('5', Conversion.binaryBeMsb0ToHexDigit(shortArray2, 0));\n         assertEquals('2', Conversion.binaryBeMsb0ToHexDigit(shortArray2, 1));\n         assertEquals('9', Conversion.binaryBeMsb0ToHexDigit(shortArray2, 2));\n         assertEquals('7', Conversion.binaryBeMsb0ToHexDigit(shortArray2, 5));\n         assertEquals('3', Conversion.binaryBeMsb0ToHexDigit(shortArray2, 6));\n         assertEquals('1', Conversion.binaryBeMsb0ToHexDigit(shortArray2, 7));\n-        boolean[] multiBytesArray = new boolean[]{\n+        final boolean[] multiBytesArray = new boolean[]{\n             true, true, false, false, true, false, true, false, true, true, true, false, false,\n             true, false, true};\n         assertEquals('5', Conversion.binaryBeMsb0ToHexDigit(multiBytesArray, 0));\n     }\n \n     static String dbgPrint(final boolean[] src) {\n-        StringBuilder sb = new StringBuilder();\n-        for (boolean e : src) {\n+        final StringBuilder sb = new StringBuilder();\n+        for (final boolean e : src) {\n             if (e) {\n                 sb.append(\"1,\");\n             } else {\n                 sb.append(\"0,\");\n             }\n         }\n-        String out = sb.toString();\n+        final String out = sb.toString();\n         return out.substring(0, out.length() - 1);\n     }\n \n         for (int i = 0; i < expected.length; i++ ) {\n             try {\n                 assertEquals(expected[i], actual[i]);\n-            } catch (Throwable e) {\n-                String msg = \"Mismatch at index \"\n+            } catch (final Throwable e) {\n+                final String msg = \"Mismatch at index \"\n                     + i\n                     + \" between:\\n\"\n                     + dbgPrint(expected)\n      */\n     @Test\n     public void testIntArrayToLong() {\n-        int[] src = new int[]{0xCDF1F0C1, 0x0F123456, 0x78000000};\n+        final int[] src = new int[]{0xCDF1F0C1, 0x0F123456, 0x78000000};\n         assertEquals(0x0000000000000000L, Conversion.intArrayToLong(src, 0, 0L, 0, 0));\n         assertEquals(0x0000000000000000L, Conversion.intArrayToLong(src, 1, 0L, 0, 0));\n         assertEquals(0x00000000CDF1F0C1L, Conversion.intArrayToLong(src, 0, 0L, 0, 1));\n      */\n     @Test\n     public void testShortArrayToLong() {\n-        short[] src = new short[]{\n+        final short[] src = new short[]{\n             (short)0xCDF1, (short)0xF0C1, (short)0x0F12, (short)0x3456, (short)0x7800};\n         assertEquals(0x0000000000000000L, Conversion.shortArrayToLong(src, 0, 0L, 0, 0));\n         assertEquals(0x000000000000CDF1L, Conversion.shortArrayToLong(src, 0, 0L, 0, 1));\n      */\n     @Test\n     public void testByteArrayToLong() {\n-        byte[] src = new byte[]{\n+        final byte[] src = new byte[]{\n             (byte)0xCD, (byte)0xF1, (byte)0xF0, (byte)0xC1, (byte)0x0F, (byte)0x12, (byte)0x34,\n             (byte)0x56, (byte)0x78};\n         assertEquals(0x0000000000000000L, Conversion.byteArrayToLong(src, 0, 0L, 0, 0));\n      */\n     @Test\n     public void testShortArrayToInt() {\n-        short[] src = new short[]{\n+        final short[] src = new short[]{\n             (short)0xCDF1, (short)0xF0C1, (short)0x0F12, (short)0x3456, (short)0x7800};\n         assertEquals(0x00000000, Conversion.shortArrayToInt(src, 0, 0, 0, 0));\n         assertEquals(0x0000CDF1, Conversion.shortArrayToInt(src, 0, 0, 0, 1));\n      */\n     @Test\n     public void testByteArrayToInt() {\n-        byte[] src = new byte[]{\n+        final byte[] src = new byte[]{\n             (byte)0xCD, (byte)0xF1, (byte)0xF0, (byte)0xC1, (byte)0x0F, (byte)0x12, (byte)0x34,\n             (byte)0x56, (byte)0x78};\n         assertEquals(0x00000000, Conversion.byteArrayToInt(src, 0, 0, 0, 0));\n      */\n     @Test\n     public void testByteArrayToShort() {\n-        byte[] src = new byte[]{\n+        final byte[] src = new byte[]{\n             (byte)0xCD, (byte)0xF1, (byte)0xF0, (byte)0xC1, (byte)0x0F, (byte)0x12, (byte)0x34,\n             (byte)0x56, (byte)0x78};\n         assertEquals((short)0x0000, Conversion.byteArrayToShort(src, 0, (short)0, 0, 0));\n      */\n     @Test\n     public void testHexToLong() {\n-        String src = \"CDF1F0C10F12345678\";\n+        final String src = \"CDF1F0C10F12345678\";\n         assertEquals(0x0000000000000000L, Conversion.hexToLong(src, 0, 0L, 0, 0));\n         assertEquals(0x000000000000000CL, Conversion.hexToLong(src, 0, 0L, 0, 1));\n         assertEquals(0x000000001C0F1FDCL, Conversion.hexToLong(src, 0, 0L, 0, 8));\n      */\n     @Test\n     public void testHexToInt() {\n-        String src = \"CDF1F0C10F12345678\";\n+        final String src = \"CDF1F0C10F12345678\";\n         assertEquals(0x00000000, Conversion.hexToInt(src, 0, 0, 0, 0));\n         assertEquals(0x0000000C, Conversion.hexToInt(src, 0, 0, 0, 1));\n         assertEquals(0x1C0F1FDC, Conversion.hexToInt(src, 0, 0, 0, 8));\n      */\n     @Test\n     public void testHexToShort() {\n-        String src = \"CDF1F0C10F12345678\";\n+        final String src = \"CDF1F0C10F12345678\";\n         assertEquals((short)0x0000, Conversion.hexToShort(src, 0, (short)0, 0, 0));\n         assertEquals((short)0x000C, Conversion.hexToShort(src, 0, (short)0, 0, 1));\n         assertEquals((short)0x1FDC, Conversion.hexToShort(src, 0, (short)0, 0, 4));\n      */\n     @Test\n     public void testHexToByte() {\n-        String src = \"CDF1F0C10F12345678\";\n+        final String src = \"CDF1F0C10F12345678\";\n         assertEquals((byte)0x00, Conversion.hexToByte(src, 0, (byte)0, 0, 0));\n         assertEquals((byte)0x0C, Conversion.hexToByte(src, 0, (byte)0, 0, 1));\n         assertEquals((byte)0xDC, Conversion.hexToByte(src, 0, (byte)0, 0, 2));\n      */\n     @Test\n     public void testBinaryToLong() {\n-        boolean[] src = new boolean[]{\n+        final boolean[] src = new boolean[]{\n             false, false, true, true, true, false, true, true, true, true, true, true, true,\n             false, false, false, true, true, true, true, false, false, false, false, false,\n             false, true, true, true, false, false, false, false, false, false, false, true,\n      */\n     @Test\n     public void testBinaryToInt() {\n-        boolean[] src = new boolean[]{\n+        final boolean[] src = new boolean[]{\n             false, false, true, true, true, false, true, true, true, true, true, true, true,\n             false, false, false, true, true, true, true, false, false, false, false, false,\n             false, true, true, true, false, false, false, false, false, false, false, true,\n      */\n     @Test\n     public void testBinaryToShort() {\n-        boolean[] src = new boolean[]{\n+        final boolean[] src = new boolean[]{\n             false, false, true, true, true, false, true, true, true, true, true, true, true,\n             false, false, false, true, true, true, true, false, false, false, false, false,\n             false, true, true, true, false, false, false, false, false, false, false, true,\n      */\n     @Test\n     public void testBinaryToByte() {\n-        boolean[] src = new boolean[]{\n+        final boolean[] src = new boolean[]{\n             false, false, true, true, true, false, true, true, true, true, true, true, true,\n             false, false, false, true, true, true, true, false, false, false, false, false,\n             false, true, true, true, false, false, false, false, false, false, false, true,\n--- a/src/test/java/org/apache/commons/lang3/EnumUtilsTest.java\n+++ b/src/test/java/org/apache/commons/lang3/EnumUtilsTest.java\n \n     @Test\n     public void test_getEnumMap() {\n-        Map<String, Traffic> test = EnumUtils.getEnumMap(Traffic.class);\n+        final Map<String, Traffic> test = EnumUtils.getEnumMap(Traffic.class);\n         assertEquals( \"getEnumMap not created correctly\", \"{RED=RED, AMBER=AMBER, GREEN=GREEN}\", test.toString());\n         assertEquals(3, test.size());\n         assertTrue(test.containsKey(\"RED\"));\n \n     @Test\n     public void test_getEnumList() {\n-        List<Traffic> test = EnumUtils.getEnumList(Traffic.class);\n+        final List<Traffic> test = EnumUtils.getEnumList(Traffic.class);\n         assertEquals(3, test.size());\n         assertEquals(Traffic.RED, test.get(0));\n         assertEquals(Traffic.AMBER, test.get(1));\n     @Test(expected=IllegalArgumentException.class)\n     public void test_generateBitVector_nonEnumClass() {\n         @SuppressWarnings(\"rawtypes\")\n+        final\n         Class rawType = Object.class;\n         @SuppressWarnings(\"rawtypes\")\n+        final\n         List rawList = new ArrayList();\n         EnumUtils.generateBitVector(rawType, rawList);\n     }\n     @Test(expected=IllegalArgumentException.class)\n     public void test_generateBitVectors_nonEnumClass() {\n         @SuppressWarnings(\"rawtypes\")\n+        final\n         Class rawType = Object.class;\n         @SuppressWarnings(\"rawtypes\")\n+        final\n         List rawList = new ArrayList();\n         EnumUtils.generateBitVectors(rawType, rawList);\n     }\n     @Test(expected=IllegalArgumentException.class)\n     public void test_generateBitVector_nonEnumClassWithArray() {\n         @SuppressWarnings(\"rawtypes\")\n+        final\n         Class rawType = Object.class;\n         EnumUtils.generateBitVector(rawType);\n     }\n     @Test(expected=IllegalArgumentException.class)\n     public void test_generateBitVectors_nonEnumClassWithArray() {\n         @SuppressWarnings(\"rawtypes\")\n+        final\n         Class rawType = Object.class;\n         EnumUtils.generateBitVectors(rawType);\n     }\n--- a/src/test/java/org/apache/commons/lang3/HashSetvBitSetTest.java\n+++ b/src/test/java/org/apache/commons/lang3/HashSetvBitSetTest.java\n      * @return bitSet - HashSet\n      */\n     private long printTimes(final int count) {\n-        long hashSet = timeHashSet(count);\n-        long bitSet = timeBitSet(count);\n+        final long hashSet = timeHashSet(count);\n+        final long bitSet = timeBitSet(count);\n         // If percent is less than 100, then bitset is faster\n         System.out.println(\"Ratio=\"+(bitSet*100/hashSet)+\"% count=\"+count+\" hash=\"+hashSet+\" bits=\"+bitSet);\n         return bitSet - hashSet;\n \n     private static long timeHashSet(final int count) {\n         int [] result = new int[0];\n-        long start = System.nanoTime();\n+        final long start = System.nanoTime();\n         for (int i = 0; i < LOOPS; i++) {\n             result = testHashSet(count);\n         }\n-        long elapsed = System.nanoTime() - start;\n+        final long elapsed = System.nanoTime() - start;\n         Assert.assertEquals(count, result.length);\n         return elapsed;\n     }\n \n     private static long timeBitSet(final int count) {\n         int [] result = new int[0];\n-        long start = System.nanoTime();\n+        final long start = System.nanoTime();\n         for (int i = 0; i < LOOPS; i++) {\n             result = testBitSet(count);\n         }\n-        long elapsed = System.nanoTime() - start;\n+        final long elapsed = System.nanoTime() - start;\n         Assert.assertEquals(count, result.length);\n         return elapsed;\n     }\n \n     @SuppressWarnings(\"boxing\")\n     private static int[] testHashSet(final int count) {\n-        HashSet<Integer> toRemove = new HashSet<Integer>();\n+        final HashSet<Integer> toRemove = new HashSet<Integer>();\n             int found = 0;\n             for (int i = 0; i < count; i++) {\n                 toRemove.add(found++);\n         }\n     \n     private static int[] testBitSet(final int count) {\n-        BitSet toRemove = new BitSet();\n+        final BitSet toRemove = new BitSet();\n         int found = 0;\n         for (int i = 0; i < count; i++) {\n             toRemove.set(found++);\n     \n \n     private static int[] extractIndices(final HashSet<Integer> coll) {\n-        int[] result = new int[coll.size()];\n+        final int[] result = new int[coll.size()];\n         int i = 0;\n-        for (Integer index : coll) {\n+        for (final Integer index : coll) {\n             result[i++] = index.intValue();\n         }\n         return result;\n     }\n \n     private static int[] extractIndices(final BitSet coll) {\n-        int[] result = new int[coll.cardinality()];\n+        final int[] result = new int[coll.cardinality()];\n         int i = 0;\n         int j=0;\n         while((j=coll.nextSetBit(j)) != -1) {\n     }\n \n     private long printTimes(final int arraySize, final int bitSetSize) {\n-        int[] array = new int[arraySize];\n-        BitSet remove = new BitSet();\n+        final int[] array = new int[arraySize];\n+        final BitSet remove = new BitSet();\n         for (int i = 0; i < bitSetSize; i++) {\n             remove.set(i);\n         }\n-        long bitSet = timeBitSetRemoveAll(array, remove );\n-        long extract = timeExtractRemoveAll(array, remove);\n+        final long bitSet = timeBitSetRemoveAll(array, remove );\n+        final long extract = timeExtractRemoveAll(array, remove);\n         // If percent is less than 100, then direct use of bitset is faster\n         System.out.println(\"Ratio=\"+(bitSet*100/extract)+\"% array=\"+array.length+\" count=\"+remove.cardinality()+\" extract=\"+extract+\" bitset=\"+bitSet);\n         return bitSet - extract;\n \n     private long timeBitSetRemoveAll(final int[] array, final BitSet toRemove) {\n         int[] output = new int[0];\n-        long start = System.nanoTime();\n+        final long start = System.nanoTime();\n         for(int i = 0; i < LOOPS2; i++){\n             output = (int[]) ArrayUtils.removeAll(array, toRemove);            \n         }\n-        long end = System.nanoTime();\n+        final long end = System.nanoTime();\n         Assert.assertEquals(array.length-toRemove.cardinality(), output.length);\n         return end - start;\n     }\n     \n     private long timeExtractRemoveAll(final int[] array, final BitSet toRemove) {\n         int[] output = new int[0];\n-        long start = System.nanoTime();\n+        final long start = System.nanoTime();\n         for(int i = 0; i < LOOPS2; i++){\n             final int[] extractIndices = extractIndices(toRemove);\n             output = (int[]) ArrayUtils.removeAll((Object)array, extractIndices);\n         }\n-        long end = System.nanoTime();\n+        final long end = System.nanoTime();\n         Assert.assertEquals(array.length-toRemove.cardinality(), output.length);\n         return end - start;\n     }\n--- a/src/test/java/org/apache/commons/lang3/LocaleUtilsTest.java\n+++ b/src/test/java/org/apache/commons/lang3/LocaleUtilsTest.java\n     @Test\n     public void testConstructor() {\n         assertNotNull(new LocaleUtils());\n-        Constructor<?>[] cons = LocaleUtils.class.getDeclaredConstructors();\n+        final Constructor<?>[] cons = LocaleUtils.class.getDeclaredConstructors();\n         assertEquals(1, cons.length);\n         assertTrue(Modifier.isPublic(cons[0].getModifiers()));\n         assertTrue(Modifier.isPublic(LocaleUtils.class.getModifiers()));\n      * @param language  the language string\n      */\n     private void assertValidToLocale(final String language) {\n-        Locale locale = LocaleUtils.toLocale(language);\n+        final Locale locale = LocaleUtils.toLocale(language);\n         assertNotNull(\"valid locale\", locale);\n         assertEquals(language, locale.getLanguage());\n         //country and variant are empty\n      * @param country of the resulting Locale\n      */\n     private void assertValidToLocale(final String localeString, final String language, final String country) {\n-        Locale locale = LocaleUtils.toLocale(localeString);\n+        final Locale locale = LocaleUtils.toLocale(localeString);\n         assertNotNull(\"valid locale\", locale);\n         assertEquals(language, locale.getLanguage());\n         assertEquals(country, locale.getCountry());\n     private void assertValidToLocale(\n             final String localeString, final String language, \n             final String country, final String variant) {\n-        Locale locale = LocaleUtils.toLocale(localeString);\n+        final Locale locale = LocaleUtils.toLocale(localeString);\n         assertNotNull(\"valid locale\", locale);\n         assertEquals(language, locale.getLanguage());\n         assertEquals(country, locale.getCountry());\n         try {\n             LocaleUtils.toLocale(\"Us\");\n             fail(\"Should fail if not lowercase\");\n-        } catch (IllegalArgumentException iae) {}\n+        } catch (final IllegalArgumentException iae) {}\n         try {\n             LocaleUtils.toLocale(\"US\");\n             fail(\"Should fail if not lowercase\");\n-        } catch (IllegalArgumentException iae) {}\n+        } catch (final IllegalArgumentException iae) {}\n         try {\n             LocaleUtils.toLocale(\"uS\");\n             fail(\"Should fail if not lowercase\");\n-        } catch (IllegalArgumentException iae) {}\n+        } catch (final IllegalArgumentException iae) {}\n         try {\n             LocaleUtils.toLocale(\"u#\");\n             fail(\"Should fail if not lowercase\");\n-        } catch (IllegalArgumentException iae) {}\n+        } catch (final IllegalArgumentException iae) {}\n         \n         try {\n             LocaleUtils.toLocale(\"u\");\n             fail(\"Must be 2 chars if less than 5\");\n-        } catch (IllegalArgumentException iae) {}\n+        } catch (final IllegalArgumentException iae) {}\n        \n         try {\n             LocaleUtils.toLocale(\"uuu\");\n             fail(\"Must be 2 chars if less than 5\");\n-        } catch (IllegalArgumentException iae) {}\n+        } catch (final IllegalArgumentException iae) {}\n \n         try {\n             LocaleUtils.toLocale(\"uu_U\");\n             fail(\"Must be 2 chars if less than 5\");\n-        } catch (IllegalArgumentException iae) {}\n+        } catch (final IllegalArgumentException iae) {}\n     }        \n \n     /**\n         try {\n             LocaleUtils.toLocale(\"us-EN\");\n             fail(\"Should fail as not underscore\");\n-        } catch (IllegalArgumentException iae) {}\n+        } catch (final IllegalArgumentException iae) {}\n         try {\n             LocaleUtils.toLocale(\"us_En\");\n             fail(\"Should fail second part not uppercase\");\n-        } catch (IllegalArgumentException iae) {}\n+        } catch (final IllegalArgumentException iae) {}\n         try {\n             LocaleUtils.toLocale(\"us_en\");\n             fail(\"Should fail second part not uppercase\");\n-        } catch (IllegalArgumentException iae) {}\n+        } catch (final IllegalArgumentException iae) {}\n         try {\n             LocaleUtils.toLocale(\"us_eN\");\n             fail(\"Should fail second part not uppercase\");\n-        } catch (IllegalArgumentException iae) {}\n+        } catch (final IllegalArgumentException iae) {}\n         try {\n             LocaleUtils.toLocale(\"uS_EN\");\n             fail(\"Should fail first part not lowercase\");\n-        } catch (IllegalArgumentException iae) {}\n+        } catch (final IllegalArgumentException iae) {}\n         try {\n             LocaleUtils.toLocale(\"us_E3\");\n             fail(\"Should fail second part not uppercase\");\n-        } catch (IllegalArgumentException iae) {}\n+        } catch (final IllegalArgumentException iae) {}\n     }        \n \n     /**\n         try {\n             LocaleUtils.toLocale(\"us_EN-a\");\n             fail(\"Should fail as not underscore\");\n-        } catch (IllegalArgumentException iae) {}\n+        } catch (final IllegalArgumentException iae) {}\n         try {\n             LocaleUtils.toLocale(\"uu_UU_\");\n             fail(\"Must be 3, 5 or 7+ in length\");\n-        } catch (IllegalArgumentException iae) {}\n+        } catch (final IllegalArgumentException iae) {}\n     }\n \n     //-----------------------------------------------------------------------\n      * @param expected  expected results\n      */\n     private void assertLocaleLookupList(final Locale locale, final Locale defaultLocale, final Locale[] expected) {\n-        List<Locale> localeList = defaultLocale == null ?\n+        final List<Locale> localeList = defaultLocale == null ?\n                 LocaleUtils.localeLookupList(locale) :\n                 LocaleUtils.localeLookupList(locale, defaultLocale);\n         \n      */\n     @Test\n     public void testAvailableLocaleList() {\n-        List<Locale> list = LocaleUtils.availableLocaleList();\n-        List<Locale> list2 = LocaleUtils.availableLocaleList();\n+        final List<Locale> list = LocaleUtils.availableLocaleList();\n+        final List<Locale> list2 = LocaleUtils.availableLocaleList();\n         assertNotNull(list);\n         assertSame(list, list2);\n         assertUnmodifiableCollection(list);\n         \n-        Locale[] jdkLocaleArray = Locale.getAvailableLocales();\n-        List<Locale> jdkLocaleList = Arrays.asList(jdkLocaleArray);\n+        final Locale[] jdkLocaleArray = Locale.getAvailableLocales();\n+        final List<Locale> jdkLocaleList = Arrays.asList(jdkLocaleArray);\n         assertEquals(jdkLocaleList, list);\n     }\n \n      */\n     @Test\n     public void testAvailableLocaleSet() {\n-        Set<Locale> set = LocaleUtils.availableLocaleSet();\n-        Set<Locale> set2 = LocaleUtils.availableLocaleSet();\n+        final Set<Locale> set = LocaleUtils.availableLocaleSet();\n+        final Set<Locale> set2 = LocaleUtils.availableLocaleSet();\n         assertNotNull(set);\n         assertSame(set, set2);\n         assertUnmodifiableCollection(set);\n         \n-        Locale[] jdkLocaleArray = Locale.getAvailableLocales();\n-        List<Locale> jdkLocaleList = Arrays.asList(jdkLocaleArray);\n-        Set<Locale> jdkLocaleSet = new HashSet<Locale>(jdkLocaleList);\n+        final Locale[] jdkLocaleArray = Locale.getAvailableLocales();\n+        final List<Locale> jdkLocaleList = Arrays.asList(jdkLocaleArray);\n+        final Set<Locale> jdkLocaleSet = new HashSet<Locale>(jdkLocaleList);\n         assertEquals(jdkLocaleSet, set);\n     }\n \n     @SuppressWarnings(\"boxing\") // JUnit4 does not support primitive equality testing apart from long\n     @Test\n     public void testIsAvailableLocale() {\n-        Set<Locale> set = LocaleUtils.availableLocaleSet();\n+        final Set<Locale> set = LocaleUtils.availableLocaleSet();\n         assertEquals(set.contains(LOCALE_EN), LocaleUtils.isAvailableLocale(LOCALE_EN));\n         assertEquals(set.contains(LOCALE_EN_US), LocaleUtils.isAvailableLocale(LOCALE_EN_US));\n         assertEquals(set.contains(LOCALE_EN_US_ZZZZ), LocaleUtils.isAvailableLocale(LOCALE_EN_US_ZZZZ));\n      * @param languages array of languages that should be returned\n      */\n     private void assertLanguageByCountry(final String country, final String[] languages) {\n-        List<Locale> list = LocaleUtils.languagesByCountry(country);\n-        List<Locale> list2 = LocaleUtils.languagesByCountry(country);\n+        final List<Locale> list = LocaleUtils.languagesByCountry(country);\n+        final List<Locale> list2 = LocaleUtils.languagesByCountry(country);\n         assertNotNull(list);\n         assertSame(list, list2);\n         //search through langauges\n-        for (String language : languages) {\n-            Iterator<Locale> iterator = list.iterator();\n+        for (final String language : languages) {\n+            final Iterator<Locale> iterator = list.iterator();\n             boolean found = false;\n             // see if it was returned by the set\n             while (iterator.hasNext()) {\n-                Locale locale = iterator.next();\n+                final Locale locale = iterator.next();\n                 // should have an en empty variant\n                 assertTrue(locale.getVariant() == null\n                         || locale.getVariant().isEmpty());\n      * @param countries array of countries that should be returned\n      */\n     private void assertCountriesByLanguage(final String language, final String[] countries) {\n-        List<Locale> list = LocaleUtils.countriesByLanguage(language);\n-        List<Locale> list2 = LocaleUtils.countriesByLanguage(language);\n+        final List<Locale> list = LocaleUtils.countriesByLanguage(language);\n+        final List<Locale> list2 = LocaleUtils.countriesByLanguage(language);\n         assertNotNull(list);\n         assertSame(list, list2);\n         //search through langauges\n-        for (String countrie : countries) {\n-            Iterator<Locale> iterator = list.iterator();\n+        for (final String countrie : countries) {\n+            final Iterator<Locale> iterator = list.iterator();\n             boolean found = false;\n             // see if it was returned by the set\n             while (iterator.hasNext()) {\n-                Locale locale = iterator.next();\n+                final Locale locale = iterator.next();\n                 // should have an en empty variant\n                 assertTrue(locale.getVariant() == null\n                         || locale.getVariant().isEmpty());\n         try {\n             coll.add(null);\n             fail();\n-        } catch (UnsupportedOperationException ex) {}\n+        } catch (final UnsupportedOperationException ex) {}\n     }\n \n     /**\n--- a/src/test/java/org/apache/commons/lang3/ObjectUtilsTest.java\n+++ b/src/test/java/org/apache/commons/lang3/ObjectUtilsTest.java\n     @Test\n     public void testConstructor() {\n         assertNotNull(new ObjectUtils());\n-        Constructor<?>[] cons = ObjectUtils.class.getDeclaredConstructors();\n+        final Constructor<?>[] cons = ObjectUtils.class.getDeclaredConstructors();\n         assertEquals(1, cons.length);\n         assertTrue(Modifier.isPublic(cons[0].getModifiers()));\n         assertTrue(Modifier.isPublic(ObjectUtils.class.getModifiers()));\n     //-----------------------------------------------------------------------\n     @Test\n     public void testIsNull() {\n-        Object o = FOO;\n-        Object dflt = BAR;\n+        final Object o = FOO;\n+        final Object dflt = BAR;\n         assertSame(\"dflt was not returned when o was null\", dflt, ObjectUtils.defaultIfNull(null, dflt));\n         assertSame(\"dflt was returned when o was not null\", o, ObjectUtils.defaultIfNull(o, dflt));\n     }\n     public void testFirstNonNull() {\n         assertEquals(null, ObjectUtils.firstNonNull(null, null));\n         assertEquals(\"\", ObjectUtils.firstNonNull(null, \"\"));\n-        String firstNonNullGenerics = ObjectUtils.firstNonNull(null, null, \"123\", \"456\");\n+        final String firstNonNullGenerics = ObjectUtils.firstNonNull(null, null, \"123\", \"456\");\n         assertEquals(\"123\", firstNonNullGenerics);\n         assertEquals(\"123\", ObjectUtils.firstNonNull(\"123\", null, \"456\", null));\n         assertEquals(null, ObjectUtils.firstNonNull());\n \n     @Test\n     public void testHashCodeMulti_multiple_emptyArray() {\n-        Object[] array = new Object[0];\n+        final Object[] array = new Object[0];\n         assertEquals(1, ObjectUtils.hashCodeMulti(array));\n     }\n \n     @Test\n     public void testHashCodeMulti_multiple_nullArray() {\n-        Object[] array = null;\n+        final Object[] array = null;\n         assertEquals(1, ObjectUtils.hashCodeMulti(array));\n     }\n \n     @Test\n     public void testHashCodeMulti_multiple_likeList() {\n-        List<Object> list0 = new ArrayList<Object>(Arrays.asList());\n+        final List<Object> list0 = new ArrayList<Object>(Arrays.asList());\n         assertEquals(list0.hashCode(), ObjectUtils.hashCodeMulti());\n         \n-        List<Object> list1 = new ArrayList<Object>(Arrays.asList(\"a\"));\n+        final List<Object> list1 = new ArrayList<Object>(Arrays.asList(\"a\"));\n         assertEquals(list1.hashCode(), ObjectUtils.hashCodeMulti(\"a\"));\n         \n-        List<Object> list2 = new ArrayList<Object>(Arrays.asList(\"a\", \"b\"));\n+        final List<Object> list2 = new ArrayList<Object>(Arrays.asList(\"a\", \"b\"));\n         assertEquals(list2.hashCode(), ObjectUtils.hashCodeMulti(\"a\", \"b\"));\n         \n-        List<Object> list3 = new ArrayList<Object>(Arrays.asList(\"a\", \"b\", \"c\"));\n+        final List<Object> list3 = new ArrayList<Object>(Arrays.asList(\"a\", \"b\", \"c\"));\n         assertEquals(list3.hashCode(), ObjectUtils.hashCodeMulti(\"a\", \"b\", \"c\"));\n     }\n \n         assertEquals(\n             \"java.lang.String@\" + Integer.toHexString(System.identityHashCode(FOO)),\n             ObjectUtils.identityToString(FOO));\n-        Integer i = Integer.valueOf(90);\n-        String expected = \"java.lang.Integer@\" + Integer.toHexString(System.identityHashCode(i));\n+        final Integer i = Integer.valueOf(90);\n+        final String expected = \"java.lang.Integer@\" + Integer.toHexString(System.identityHashCode(i));\n         assertEquals(expected, ObjectUtils.identityToString(i));\n-        StringBuffer buffer = new StringBuffer();\n+        final StringBuffer buffer = new StringBuffer();\n         ObjectUtils.identityToString(buffer, i);\n         assertEquals(expected, buffer.toString());\n \n         try {\n             ObjectUtils.identityToString(null, \"tmp\");\n             fail(\"NullPointerException expected\");\n-        } catch(NullPointerException npe) {\n+        } catch(final NullPointerException npe) {\n         }\n         try {\n             ObjectUtils.identityToString(new StringBuffer(), null);\n             fail(\"NullPointerException expected\");\n-        } catch(NullPointerException npe) {\n+        } catch(final NullPointerException npe) {\n         }\n     }\n \n \n     @Test\n     public void testMax() {\n-        Calendar calendar = Calendar.getInstance();\n-        Date nonNullComparable1 = calendar.getTime();\n-        Date nonNullComparable2 = calendar.getTime();\n-        String[] nullAray = null;\n+        final Calendar calendar = Calendar.getInstance();\n+        final Date nonNullComparable1 = calendar.getTime();\n+        final Date nonNullComparable2 = calendar.getTime();\n+        final String[] nullAray = null;\n         \n         calendar.set( Calendar.YEAR, calendar.get( Calendar.YEAR ) -1 );\n-        Date minComparable = calendar.getTime();\n+        final Date minComparable = calendar.getTime();\n         \n         assertNotSame( nonNullComparable1, nonNullComparable2 );\n         \n \n     @Test\n     public void testMin() {\n-        Calendar calendar = Calendar.getInstance();\n-        Date nonNullComparable1 = calendar.getTime();\n-        Date nonNullComparable2 = calendar.getTime();\n-        String[] nullAray = null;\n+        final Calendar calendar = Calendar.getInstance();\n+        final Date nonNullComparable1 = calendar.getTime();\n+        final Date nonNullComparable2 = calendar.getTime();\n+        final String[] nullAray = null;\n         \n         calendar.set( Calendar.YEAR, calendar.get( Calendar.YEAR ) -1 );\n-        Date minComparable = calendar.getTime();\n+        final Date minComparable = calendar.getTime();\n         \n         assertNotSame( nonNullComparable1, nonNullComparable2 );\n         \n      */\n     @Test\n     public void testCompare() {\n-        Integer one = Integer.valueOf(1);\n-        Integer two = Integer.valueOf(2);\n-        Integer nullValue = null;\n+        final Integer one = Integer.valueOf(1);\n+        final Integer two = Integer.valueOf(2);\n+        final Integer nullValue = null;\n \n         assertEquals(\"Null Null false\", 0, ObjectUtils.compare(nullValue, nullValue));\n         assertEquals(\"Null Null true\",  0, ObjectUtils.compare(nullValue, nullValue, true));\n \n     @Test\n     public void testComparatorMedian() {\n-        CharSequenceComparator cmp = new CharSequenceComparator();\n-        NonComparableCharSequence foo = new NonComparableCharSequence(\"foo\");\n-        NonComparableCharSequence bar = new NonComparableCharSequence(\"bar\");\n-        NonComparableCharSequence baz = new NonComparableCharSequence(\"baz\");\n-        NonComparableCharSequence blah = new NonComparableCharSequence(\"blah\");\n-        NonComparableCharSequence wah = new NonComparableCharSequence(\"wah\");\n+        final CharSequenceComparator cmp = new CharSequenceComparator();\n+        final NonComparableCharSequence foo = new NonComparableCharSequence(\"foo\");\n+        final NonComparableCharSequence bar = new NonComparableCharSequence(\"bar\");\n+        final NonComparableCharSequence baz = new NonComparableCharSequence(\"baz\");\n+        final NonComparableCharSequence blah = new NonComparableCharSequence(\"blah\");\n+        final NonComparableCharSequence wah = new NonComparableCharSequence(\"wah\");\n         assertSame(foo, ObjectUtils.median(cmp, foo));\n         assertSame(bar, ObjectUtils.median(cmp, foo, bar));\n         assertSame(baz, ObjectUtils.median(cmp, foo, bar, baz));\n         // for \"Can you screw this up?\"  The answer is, yes,\n         // you can even screw this up.  (When you == Julius)\n         // .\n-        boolean MAGIC_FLAG = ObjectUtils.CONST(true);\n-        byte MAGIC_BYTE1 = ObjectUtils.CONST((byte) 127);\n-        byte MAGIC_BYTE2 = ObjectUtils.CONST_BYTE(127);\n-        char MAGIC_CHAR = ObjectUtils.CONST('a');\n-        short MAGIC_SHORT1 = ObjectUtils.CONST((short) 123);\n-        short MAGIC_SHORT2 = ObjectUtils.CONST_SHORT(127);\n-        int MAGIC_INT = ObjectUtils.CONST(123);\n-        long MAGIC_LONG1 = ObjectUtils.CONST(123L);\n-        long MAGIC_LONG2 = ObjectUtils.CONST(3);\n-        float MAGIC_FLOAT = ObjectUtils.CONST(1.0f);\n-        double MAGIC_DOUBLE = ObjectUtils.CONST(1.0);\n-        String MAGIC_STRING = ObjectUtils.CONST(\"abc\");\n+        final boolean MAGIC_FLAG = ObjectUtils.CONST(true);\n+        final byte MAGIC_BYTE1 = ObjectUtils.CONST((byte) 127);\n+        final byte MAGIC_BYTE2 = ObjectUtils.CONST_BYTE(127);\n+        final char MAGIC_CHAR = ObjectUtils.CONST('a');\n+        final short MAGIC_SHORT1 = ObjectUtils.CONST((short) 123);\n+        final short MAGIC_SHORT2 = ObjectUtils.CONST_SHORT(127);\n+        final int MAGIC_INT = ObjectUtils.CONST(123);\n+        final long MAGIC_LONG1 = ObjectUtils.CONST(123L);\n+        final long MAGIC_LONG2 = ObjectUtils.CONST(3);\n+        final float MAGIC_FLOAT = ObjectUtils.CONST(1.0f);\n+        final double MAGIC_DOUBLE = ObjectUtils.CONST(1.0);\n+        final String MAGIC_STRING = ObjectUtils.CONST(\"abc\");\n \n         assertTrue(MAGIC_FLAG);\n         assertEquals(127, MAGIC_BYTE1);\n         try {\n             ObjectUtils.CONST_BYTE(-129);\n             fail(\"CONST_BYTE(-129): IllegalArgumentException should have been thrown.\");\n-        } catch (IllegalArgumentException iae) {\n+        } catch (final IllegalArgumentException iae) {\n \n         }\n         try {\n             ObjectUtils.CONST_BYTE(128);\n             fail(\"CONST_BYTE(128): IllegalArgumentException should have been thrown.\");\n-        } catch (IllegalArgumentException iae) {\n+        } catch (final IllegalArgumentException iae) {\n \n         }\n         try {\n             ObjectUtils.CONST_SHORT(-32769);\n             fail(\"CONST_SHORT(-32769): IllegalArgumentException should have been thrown.\");\n-        } catch (IllegalArgumentException iae) {\n+        } catch (final IllegalArgumentException iae) {\n \n         }\n         try {\n             ObjectUtils.CONST_BYTE(32768);\n             fail(\"CONST_SHORT(32768): IllegalArgumentException should have been thrown.\");\n-        } catch (IllegalArgumentException iae) {\n+        } catch (final IllegalArgumentException iae) {\n \n         }\n \n--- a/src/test/java/org/apache/commons/lang3/RandomStringUtilsTest.java\n+++ b/src/test/java/org/apache/commons/lang3/RandomStringUtilsTest.java\n     @Test\n     public void testConstructor() {\n         assertNotNull(new RandomStringUtils());\n-        Constructor<?>[] cons = RandomStringUtils.class.getDeclaredConstructors();\n+        final Constructor<?>[] cons = RandomStringUtils.class.getDeclaredConstructors();\n         assertEquals(1, cons.length);\n         assertTrue(Modifier.isPublic(cons[0].getModifiers()));\n         assertTrue(Modifier.isPublic(RandomStringUtils.class.getModifiers()));\n         assertEquals(\"random(50) length\", 50, r2.length());\n         assertTrue(\"!r1.equals(r2)\", !r1.equals(r2));\n \n-        long seed = System.currentTimeMillis();\n+        final long seed = System.currentTimeMillis();\n         r1 = RandomStringUtils.random(50,0,0,true,true,null,new Random(seed));\n         r2 = RandomStringUtils.random(50,0,0,true,true,null,new Random(seed));\n         assertEquals(\"r1.equals(r2)\", r1, r2);\n \n     @Test\n     public void testLANG805() {\n-        long seed = System.currentTimeMillis();\n+        final long seed = System.currentTimeMillis();\n         assertEquals(\"aaa\", RandomStringUtils.random(3,0,0,false,false,new char[]{'a'},new Random(seed)));\n     }\n \n         try {\n             RandomStringUtils.random(3,5,5,false,false);\n             fail(\"Expected IllegalArgumentException\");\n-        } catch (IllegalArgumentException ex) { // distinguish from Random#nextInt message\n+        } catch (final IllegalArgumentException ex) { // distinguish from Random#nextInt message\n             final String msg = ex.getMessage();\n             assertTrue(\"Message (\" + msg + \") must contain 'start'\", msg.contains(\"start\"));\n             assertTrue(\"Message (\" + msg + \") must contain 'end'\", msg.contains(\"end\"));\n         try {\n             RandomStringUtils.random(-1);\n             fail();\n-        } catch (IllegalArgumentException ex) {}\n+        } catch (final IllegalArgumentException ex) {}\n         try {\n             RandomStringUtils.random(-1, true, true);\n             fail();\n-        } catch (IllegalArgumentException ex) {}\n+        } catch (final IllegalArgumentException ex) {}\n         try {\n             RandomStringUtils.random(-1, DUMMY);\n             fail();\n-        } catch (IllegalArgumentException ex) {}\n+        } catch (final IllegalArgumentException ex) {}\n         try {\n             RandomStringUtils.random(1, new char[0]); // must not provide empty array => IAE\n             fail();\n-        } catch (IllegalArgumentException ex) {}\n+        } catch (final IllegalArgumentException ex) {}\n         try {\n             RandomStringUtils.random(-1, \"\");\n             fail();\n-        } catch (IllegalArgumentException ex) {}\n+        } catch (final IllegalArgumentException ex) {}\n         try {\n             RandomStringUtils.random(-1, (String)null);\n             fail();\n-        } catch (IllegalArgumentException ex) {}\n+        } catch (final IllegalArgumentException ex) {}\n         try {\n             RandomStringUtils.random(-1, 'a', 'z', false, false);\n             fail();\n-        } catch (IllegalArgumentException ex) {}\n+        } catch (final IllegalArgumentException ex) {}\n         try {\n             RandomStringUtils.random(-1, 'a', 'z', false, false, DUMMY);\n             fail();\n-        } catch (IllegalArgumentException ex) {}\n+        } catch (final IllegalArgumentException ex) {}\n         try {\n             RandomStringUtils.random(-1, 'a', 'z', false, false, DUMMY, new Random());\n             fail();\n-        } catch (IllegalArgumentException ex) {}\n+        } catch (final IllegalArgumentException ex) {}\n     }\n     \n     /**\n      */  \n     @Test\n     public void testRandomAlphaNumeric() {\n-        char[] testChars = {'a', 'z', 'A', 'Z', '0', '9'};\n-        boolean[] found = {false, false, false, false, false, false};\n+        final char[] testChars = {'a', 'z', 'A', 'Z', '0', '9'};\n+        final boolean[] found = {false, false, false, false, false, false};\n         for (int i = 0; i < 100; i++) {\n-            String randString = RandomStringUtils.randomAlphanumeric(10);\n+            final String randString = RandomStringUtils.randomAlphanumeric(10);\n             for (int j = 0; j < testChars.length; j++) {\n                 if (randString.indexOf(testChars[j]) > 0) {\n                     found[j] = true;\n      */  \n     @Test\n     public void testRandomNumeric() {\n-        char[] testChars = {'0','9'};\n-        boolean[] found = {false, false};\n+        final char[] testChars = {'0','9'};\n+        final boolean[] found = {false, false};\n         for (int i = 0; i < 100; i++) {\n-            String randString = RandomStringUtils.randomNumeric(10);\n+            final String randString = RandomStringUtils.randomNumeric(10);\n             for (int j = 0; j < testChars.length; j++) {\n                 if (randString.indexOf(testChars[j]) > 0) {\n                     found[j] = true;\n      */  \n     @Test\n     public void testRandomAlphabetic() {\n-        char[] testChars = {'a', 'z', 'A', 'Z'};\n-        boolean[] found = {false, false, false, false};\n+        final char[] testChars = {'a', 'z', 'A', 'Z'};\n+        final boolean[] found = {false, false, false, false};\n         for (int i = 0; i < 100; i++) {\n-            String randString = RandomStringUtils.randomAlphabetic(10);\n+            final String randString = RandomStringUtils.randomAlphabetic(10);\n             for (int j = 0; j < testChars.length; j++) {\n                 if (randString.indexOf(testChars[j]) > 0) {\n                     found[j] = true;\n      */  \n     @Test\n     public void testRandomAscii() {\n-        char[] testChars = {(char) 32, (char) 126};\n-        boolean[] found = {false, false};\n+        final char[] testChars = {(char) 32, (char) 126};\n+        final boolean[] found = {false, false};\n         for (int i = 0; i < 100; i++) {\n-            String randString = RandomStringUtils.randomAscii(10);\n+            final String randString = RandomStringUtils.randomAscii(10);\n             for (int j = 0; j < testChars.length; j++) {\n                 if (randString.indexOf(testChars[j]) > 0) {\n                     found[j] = true;\n      */\n     @Test\n     public void testRandomStringUtilsHomog() {\n-        String set = \"abc\";\n-        char[] chars = set.toCharArray();\n+        final String set = \"abc\";\n+        final char[] chars = set.toCharArray();\n         String gen = \"\";\n-        int[] counts = {0,0,0};\n-        int[] expected = {200,200,200};\n+        final int[] counts = {0,0,0};\n+        final int[] expected = {200,200,200};\n         for (int i = 0; i< 100; i++) {\n            gen = RandomStringUtils.random(6,chars);\n            for (int j = 0; j < 6; j++) {\n      */\n     @Test\n     public void testLang100() throws Exception {\n-        int size = 5000;\n-        String encoding = \"UTF-8\";\n-        String orig = RandomStringUtils.random(size);\n-        byte[] bytes = orig.getBytes(encoding);\n-        String copy = new String(bytes, encoding);\n+        final int size = 5000;\n+        final String encoding = \"UTF-8\";\n+        final String orig = RandomStringUtils.random(size);\n+        final byte[] bytes = orig.getBytes(encoding);\n+        final String copy = new String(bytes, encoding);\n \n         // for a verbose compare:\n         for (int i=0; i < orig.length() && i < copy.length(); i++) {\n-            char o = orig.charAt(i);\n-            char c = copy.charAt(i);\n+            final char o = orig.charAt(i);\n+            final char c = copy.charAt(i);\n             assertEquals(\"differs at \" + i + \"(\" + Integer.toHexString(new Character(o).hashCode()) + \",\" +\n             Integer.toHexString(new Character(c).hashCode()) + \")\", o, c);\n         }\n--- a/src/test/java/org/apache/commons/lang3/RangeTest.java\n+++ b/src/test/java/org/apache/commons/lang3/RangeTest.java\n     @SuppressWarnings({ \"rawtypes\", \"unchecked\" })\n     @Test\n     public void testComparableConstructors() {\n-        Comparable c = \n+        final Comparable c = \n             new Comparable() { \n                 @Override\n                 public int compareTo(final Object other) {\n                     return 1;\n                 }\n             };\n-        Range r1 = Range.is(c);\n-        Range r2 = Range.between(c, c);\n+        final Range r1 = Range.is(c);\n+        final Range r2 = Range.between(c, c);\n         assertEquals(true, r1.isNaturalOrdering());\n         assertEquals(true, r2.isNaturalOrdering());\n     }\n \n     @Test\n     public void testIsWithCompare(){\n-        Comparator<Integer> c = new Comparator<Integer>(){\n+        final Comparator<Integer> c = new Comparator<Integer>(){\n             @Override\n             public int compare(final Integer o1, final Integer o2) {\n                 return 0; // all integers are equal\n     @Test\n     public void testBetweenWithCompare(){\n         // TODO add tests with a better comparator\n-        Comparator<Integer> c = new Comparator<Integer>(){\n+        final Comparator<Integer> c = new Comparator<Integer>(){\n             @Override\n             public int compare(final Integer o1, final Integer o2) {\n                 return 0; // all integers are equal\n     //-----------------------------------------------------------------------\n     @Test\n     public void testRangeOfChars() {\n-        Range<Character> chars = Range.between('a', 'z');\n+        final Range<Character> chars = Range.between('a', 'z');\n         assertTrue(chars.contains('b'));\n         assertFalse(chars.contains('B'));\n     }\n     public void testToString() {\n         assertNotNull(byteRange.toString());\n         \n-        String str = intRange.toString();\n+        final String str = intRange.toString();\n         assertEquals(\"[10..20]\", str);\n         assertEquals(\"[-20..-10]\", Range.between(-20, -10).toString());\n     }\n \n     @Test\n     public void testToStringFormat() {\n-        String str = intRange.toString(\"From %1$s to %2$s\");\n+        final String str = intRange.toString(\"From %1$s to %2$s\");\n         assertEquals(\"From 10 to 20\", str);\n     }\n \n         try {\n             intRange.elementCompareTo(null);\n             fail(\"NullPointerException should have been thrown\");\n-        } catch(NullPointerException npe) {\n+        } catch(final NullPointerException npe) {\n             // expected\n         }\n         \n--- a/src/test/java/org/apache/commons/lang3/SerializationUtilsTest.java\n+++ b/src/test/java/org/apache/commons/lang3/SerializationUtilsTest.java\n     @Test\n     public void testConstructor() {\n         assertNotNull(new SerializationUtils());\n-        Constructor<?>[] cons = SerializationUtils.class.getDeclaredConstructors();\n+        final Constructor<?>[] cons = SerializationUtils.class.getDeclaredConstructors();\n         assertEquals(1, cons.length);\n         assertTrue(Modifier.isPublic(cons[0].getModifiers()));\n         assertTrue(Modifier.isPublic(SerializationUtils.class.getModifiers()));\n     @Test\n     public void testException() {\n         SerializationException serEx;\n-        Exception ex = new Exception();\n+        final Exception ex = new Exception();\n         \n         serEx = new SerializationException();\n         assertSame(null, serEx.getMessage());\n \n     @Test\n     public void testSerializeStream() throws Exception {\n-        ByteArrayOutputStream streamTest = new ByteArrayOutputStream();\n+        final ByteArrayOutputStream streamTest = new ByteArrayOutputStream();\n         SerializationUtils.serialize(iMap, streamTest);\n \n-        ByteArrayOutputStream streamReal = new ByteArrayOutputStream();\n-        ObjectOutputStream oos = new ObjectOutputStream(streamReal);\n+        final ByteArrayOutputStream streamReal = new ByteArrayOutputStream();\n+        final ObjectOutputStream oos = new ObjectOutputStream(streamReal);\n         oos.writeObject(iMap);\n         oos.flush();\n         oos.close();\n \n-        byte[] testBytes = streamTest.toByteArray();\n-        byte[] realBytes = streamReal.toByteArray();\n+        final byte[] testBytes = streamTest.toByteArray();\n+        final byte[] realBytes = streamReal.toByteArray();\n         assertEquals(testBytes.length, realBytes.length);\n         for (int i = 0; i < realBytes.length; i++) {\n             assertEquals(realBytes[i], testBytes[i]);\n \n     @Test\n     public void testSerializeStreamUnserializable() throws Exception {\n-        ByteArrayOutputStream streamTest = new ByteArrayOutputStream();\n+        final ByteArrayOutputStream streamTest = new ByteArrayOutputStream();\n         try {\n             iMap.put(new Object(), new Object());\n             SerializationUtils.serialize(iMap, streamTest);\n-        } catch (SerializationException ex) {\n+        } catch (final SerializationException ex) {\n             return;\n         }\n         fail();\n \n     @Test\n     public void testSerializeStreamNullObj() throws Exception {\n-        ByteArrayOutputStream streamTest = new ByteArrayOutputStream();\n+        final ByteArrayOutputStream streamTest = new ByteArrayOutputStream();\n         SerializationUtils.serialize(null, streamTest);\n \n-        ByteArrayOutputStream streamReal = new ByteArrayOutputStream();\n-        ObjectOutputStream oos = new ObjectOutputStream(streamReal);\n+        final ByteArrayOutputStream streamReal = new ByteArrayOutputStream();\n+        final ObjectOutputStream oos = new ObjectOutputStream(streamReal);\n         oos.writeObject(null);\n         oos.flush();\n         oos.close();\n \n-        byte[] testBytes = streamTest.toByteArray();\n-        byte[] realBytes = streamReal.toByteArray();\n+        final byte[] testBytes = streamTest.toByteArray();\n+        final byte[] realBytes = streamReal.toByteArray();\n         assertEquals(testBytes.length, realBytes.length);\n         for (int i = 0; i < realBytes.length; i++) {\n             assertEquals(realBytes[i], testBytes[i]);\n     public void testSerializeStreamObjNull() throws Exception {\n         try {\n             SerializationUtils.serialize(iMap, null);\n-        } catch (IllegalArgumentException ex) {\n+        } catch (final IllegalArgumentException ex) {\n             return;\n         }\n         fail();\n     public void testSerializeStreamNullNull() throws Exception {\n         try {\n             SerializationUtils.serialize(null, null);\n-        } catch (IllegalArgumentException ex) {\n+        } catch (final IllegalArgumentException ex) {\n             return;\n         }\n         fail();\n     public void testSerializeIOException() throws Exception {\n         // forces an IOException when the ObjectOutputStream is created, to test not closing the stream\n         // in the finally block\n-        OutputStream streamTest = new OutputStream() {\n+        final OutputStream streamTest = new OutputStream() {\n             @Override\n             public void write(final int arg0) throws IOException {\n                 throw new IOException(SERIALIZE_IO_EXCEPTION_MESSAGE);\n         try {\n             SerializationUtils.serialize(iMap, streamTest);\n         }\n-        catch(SerializationException e) {\n+        catch(final SerializationException e) {\n             assertEquals(\"java.io.IOException: \" + SERIALIZE_IO_EXCEPTION_MESSAGE, e.getMessage());\n         }\n     }\n \n     @Test\n     public void testDeserializeStream() throws Exception {\n-        ByteArrayOutputStream streamReal = new ByteArrayOutputStream();\n-        ObjectOutputStream oos = new ObjectOutputStream(streamReal);\n+        final ByteArrayOutputStream streamReal = new ByteArrayOutputStream();\n+        final ObjectOutputStream oos = new ObjectOutputStream(streamReal);\n         oos.writeObject(iMap);\n         oos.flush();\n         oos.close();\n \n-        ByteArrayInputStream inTest = new ByteArrayInputStream(streamReal.toByteArray());\n-        Object test = SerializationUtils.deserialize(inTest);\n+        final ByteArrayInputStream inTest = new ByteArrayInputStream(streamReal.toByteArray());\n+        final Object test = SerializationUtils.deserialize(inTest);\n         assertNotNull(test);\n         assertTrue(test instanceof HashMap<?, ?>);\n         assertTrue(test != iMap);\n-        HashMap<?, ?> testMap = (HashMap<?, ?>) test;\n+        final HashMap<?, ?> testMap = (HashMap<?, ?>) test;\n         assertEquals(iString, testMap.get(\"FOO\"));\n         assertTrue(iString != testMap.get(\"FOO\"));\n         assertEquals(iInteger, testMap.get(\"BAR\"));\n     @Test(expected=ClassCastException.class)\n     public void testDeserializeClassCastException() {\n         final String value = \"Hello\";\n-        byte[] serialized = SerializationUtils.serialize(value);\n+        final byte[] serialized = SerializationUtils.serialize(value);\n         Assert.assertEquals(value, SerializationUtils.deserialize(serialized));\n         // Causes ClassCastException in call site, not in SerializationUtils.deserialize \n-        Integer i = SerializationUtils.deserialize(serialized);\n+        final Integer i = SerializationUtils.deserialize(serialized);\n     }\n \n     @Test\n     public void testDeserializeStreamOfNull() throws Exception {\n-        ByteArrayOutputStream streamReal = new ByteArrayOutputStream();\n-        ObjectOutputStream oos = new ObjectOutputStream(streamReal);\n+        final ByteArrayOutputStream streamReal = new ByteArrayOutputStream();\n+        final ObjectOutputStream oos = new ObjectOutputStream(streamReal);\n         oos.writeObject(null);\n         oos.flush();\n         oos.close();\n \n-        ByteArrayInputStream inTest = new ByteArrayInputStream(streamReal.toByteArray());\n-        Object test = SerializationUtils.deserialize(inTest);\n+        final ByteArrayInputStream inTest = new ByteArrayInputStream(streamReal.toByteArray());\n+        final Object test = SerializationUtils.deserialize(inTest);\n         assertNull(test);\n     }\n \n     public void testDeserializeStreamNull() throws Exception {\n         try {\n             SerializationUtils.deserialize((InputStream) null);\n-        } catch (IllegalArgumentException ex) {\n+        } catch (final IllegalArgumentException ex) {\n             return;\n         }\n         fail();\n     public void testDeserializeStreamBadStream() throws Exception {\n         try {\n             SerializationUtils.deserialize(new ByteArrayInputStream(new byte[0]));\n-        } catch (SerializationException ex) {\n+        } catch (final SerializationException ex) {\n             return;\n         }\n         fail();\n \n     @Test\n     public void testDeserializeStreamClassNotFound() throws Exception {\n-        ByteArrayOutputStream streamReal = new ByteArrayOutputStream();\n-        ObjectOutputStream oos = new ObjectOutputStream(streamReal);\n+        final ByteArrayOutputStream streamReal = new ByteArrayOutputStream();\n+        final ObjectOutputStream oos = new ObjectOutputStream(streamReal);\n         oos.writeObject(new ClassNotFoundSerialization());\n         oos.flush();\n         oos.close();\n \n-        ByteArrayInputStream inTest = new ByteArrayInputStream(streamReal.toByteArray());\n+        final ByteArrayInputStream inTest = new ByteArrayInputStream(streamReal.toByteArray());\n         try {\n             @SuppressWarnings(\"unused\")\n+            final\n             Object test = SerializationUtils.deserialize(inTest);\n-        } catch(SerializationException se) {\n+        } catch(final SerializationException se) {\n             assertEquals(\"java.lang.ClassNotFoundException: \" + CLASS_NOT_FOUND_MESSAGE, se.getMessage());\n         }\n     }\n \n     @Test\n     public void testSerializeBytes() throws Exception {\n-        byte[] testBytes = SerializationUtils.serialize(iMap);\n-\n-        ByteArrayOutputStream streamReal = new ByteArrayOutputStream();\n-        ObjectOutputStream oos = new ObjectOutputStream(streamReal);\n+        final byte[] testBytes = SerializationUtils.serialize(iMap);\n+\n+        final ByteArrayOutputStream streamReal = new ByteArrayOutputStream();\n+        final ObjectOutputStream oos = new ObjectOutputStream(streamReal);\n         oos.writeObject(iMap);\n         oos.flush();\n         oos.close();\n \n-        byte[] realBytes = streamReal.toByteArray();\n+        final byte[] realBytes = streamReal.toByteArray();\n         assertEquals(testBytes.length, realBytes.length);\n         for (int i = 0; i < realBytes.length; i++) {\n             assertEquals(realBytes[i], testBytes[i]);\n         try {\n             iMap.put(new Object(), new Object());\n             SerializationUtils.serialize(iMap);\n-        } catch (SerializationException ex) {\n+        } catch (final SerializationException ex) {\n             return;\n         }\n         fail();\n \n     @Test\n     public void testSerializeBytesNull() throws Exception {\n-        byte[] testBytes = SerializationUtils.serialize(null);\n-\n-        ByteArrayOutputStream streamReal = new ByteArrayOutputStream();\n-        ObjectOutputStream oos = new ObjectOutputStream(streamReal);\n+        final byte[] testBytes = SerializationUtils.serialize(null);\n+\n+        final ByteArrayOutputStream streamReal = new ByteArrayOutputStream();\n+        final ObjectOutputStream oos = new ObjectOutputStream(streamReal);\n         oos.writeObject(null);\n         oos.flush();\n         oos.close();\n \n-        byte[] realBytes = streamReal.toByteArray();\n+        final byte[] realBytes = streamReal.toByteArray();\n         assertEquals(testBytes.length, realBytes.length);\n         for (int i = 0; i < realBytes.length; i++) {\n             assertEquals(realBytes[i], testBytes[i]);\n \n     @Test\n     public void testDeserializeBytes() throws Exception {\n-        ByteArrayOutputStream streamReal = new ByteArrayOutputStream();\n-        ObjectOutputStream oos = new ObjectOutputStream(streamReal);\n+        final ByteArrayOutputStream streamReal = new ByteArrayOutputStream();\n+        final ObjectOutputStream oos = new ObjectOutputStream(streamReal);\n         oos.writeObject(iMap);\n         oos.flush();\n         oos.close();\n \n-        Object test = SerializationUtils.deserialize(streamReal.toByteArray());\n+        final Object test = SerializationUtils.deserialize(streamReal.toByteArray());\n         assertNotNull(test);\n         assertTrue(test instanceof HashMap<?, ?>);\n         assertTrue(test != iMap);\n-        HashMap<?, ?> testMap = (HashMap<?, ?>) test;\n+        final HashMap<?, ?> testMap = (HashMap<?, ?>) test;\n         assertEquals(iString, testMap.get(\"FOO\"));\n         assertTrue(iString != testMap.get(\"FOO\"));\n         assertEquals(iInteger, testMap.get(\"BAR\"));\n \n     @Test\n     public void testDeserializeBytesOfNull() throws Exception {\n-        ByteArrayOutputStream streamReal = new ByteArrayOutputStream();\n-        ObjectOutputStream oos = new ObjectOutputStream(streamReal);\n+        final ByteArrayOutputStream streamReal = new ByteArrayOutputStream();\n+        final ObjectOutputStream oos = new ObjectOutputStream(streamReal);\n         oos.writeObject(null);\n         oos.flush();\n         oos.close();\n \n-        Object test = SerializationUtils.deserialize(streamReal.toByteArray());\n+        final Object test = SerializationUtils.deserialize(streamReal.toByteArray());\n         assertNull(test);\n     }\n \n     public void testDeserializeBytesNull() throws Exception {\n         try {\n             SerializationUtils.deserialize((byte[]) null);\n-        } catch (IllegalArgumentException ex) {\n+        } catch (final IllegalArgumentException ex) {\n             return;\n         }\n         fail();\n     public void testDeserializeBytesBadStream() throws Exception {\n         try {\n             SerializationUtils.deserialize(new byte[0]);\n-        } catch (SerializationException ex) {\n+        } catch (final SerializationException ex) {\n             return;\n         }\n         fail();\n \n     @Test\n     public void testClone() throws Exception {\n-        Object test = SerializationUtils.clone(iMap);\n+        final Object test = SerializationUtils.clone(iMap);\n         assertNotNull(test);\n         assertTrue(test instanceof HashMap<?,?>);\n         assertTrue(test != iMap);\n-        HashMap<?, ?> testMap = (HashMap<?, ?>) test;\n+        final HashMap<?, ?> testMap = (HashMap<?, ?>) test;\n         assertEquals(iString, testMap.get(\"FOO\"));\n         assertTrue(iString != testMap.get(\"FOO\"));\n         assertEquals(iInteger, testMap.get(\"BAR\"));\n \n     @Test\n     public void testCloneNull() throws Exception {\n-        Object test = SerializationUtils.clone(null);\n+        final Object test = SerializationUtils.clone(null);\n         assertNull(test);\n     }\n \n         try {\n             iMap.put(new Object(), new Object());\n             SerializationUtils.clone(iMap);\n-        } catch (SerializationException ex) {\n+        } catch (final SerializationException ex) {\n             return;\n         }\n         fail();\n     \n     @Test\n     public void testPrimitiveTypeClassSerialization() {\n-        Class<?>[] primitiveTypes = { byte.class, short.class, int.class, long.class, float.class, double.class,\n+        final Class<?>[] primitiveTypes = { byte.class, short.class, int.class, long.class, float.class, double.class,\n                 boolean.class, char.class, void.class };\n \n-        for (Class<?> primitiveType : primitiveTypes) {\n-            Class<?> clone = SerializationUtils.clone(primitiveType);\n+        for (final Class<?> primitiveType : primitiveTypes) {\n+            final Class<?> clone = SerializationUtils.clone(primitiveType);\n             assertEquals(primitiveType, clone);\n         }\n     }\n--- a/src/test/java/org/apache/commons/lang3/StringEscapeUtilsTest.java\n+++ b/src/test/java/org/apache/commons/lang3/StringEscapeUtilsTest.java\n     @Test\n     public void testConstructor() {\n         assertNotNull(new StringEscapeUtils());\n-        Constructor<?>[] cons = StringEscapeUtils.class.getDeclaredConstructors();\n+        final Constructor<?>[] cons = StringEscapeUtils.class.getDeclaredConstructors();\n         assertEquals(1, cons.length);\n         assertTrue(Modifier.isPublic(cons[0].getModifiers()));\n         assertTrue(Modifier.isPublic(StringEscapeUtils.class.getModifiers()));\n         try {\n             StringEscapeUtils.ESCAPE_JAVA.translate(null, null);\n             fail();\n-        } catch (IOException ex) {\n-            fail();\n-        } catch (IllegalArgumentException ex) {\n+        } catch (final IOException ex) {\n+            fail();\n+        } catch (final IllegalArgumentException ex) {\n         }\n         try {\n             StringEscapeUtils.ESCAPE_JAVA.translate(\"\", null);\n             fail();\n-        } catch (IOException ex) {\n-            fail();\n-        } catch (IllegalArgumentException ex) {\n+        } catch (final IOException ex) {\n+            fail();\n+        } catch (final IllegalArgumentException ex) {\n         }\n         \n         assertEscapeJava(\"empty string\", \"\", \"\");\n     }\n \n     private void assertEscapeJava(String message, final String expected, final String original) throws IOException {\n-        String converted = StringEscapeUtils.escapeJava(original);\n+        final String converted = StringEscapeUtils.escapeJava(original);\n         message = \"escapeJava(String) failed\" + (message == null ? \"\" : (\": \" + message));\n         assertEquals(message, expected, converted);\n \n-        StringWriter writer = new StringWriter();\n+        final StringWriter writer = new StringWriter();\n         StringEscapeUtils.ESCAPE_JAVA.translate(original, writer);\n         assertEquals(expected, writer.toString());\n     }\n         try {\n             StringEscapeUtils.UNESCAPE_JAVA.translate(null, null);\n             fail();\n-        } catch (IOException ex) {\n-            fail();\n-        } catch (IllegalArgumentException ex) {\n+        } catch (final IOException ex) {\n+            fail();\n+        } catch (final IllegalArgumentException ex) {\n         }\n         try {\n             StringEscapeUtils.UNESCAPE_JAVA.translate(\"\", null);\n             fail();\n-        } catch (IOException ex) {\n-            fail();\n-        } catch (IllegalArgumentException ex) {\n+        } catch (final IOException ex) {\n+            fail();\n+        } catch (final IllegalArgumentException ex) {\n         }\n         try {\n             StringEscapeUtils.unescapeJava(\"\\\\u02-3\");\n             fail();\n-        } catch (RuntimeException ex) {\n+        } catch (final RuntimeException ex) {\n         }\n         \n         assertUnescapeJava(\"\", \"\");\n     }\n \n     private void assertUnescapeJava(final String message, final String unescaped, final String original) throws IOException {\n-        String expected = unescaped;\n-        String actual = StringEscapeUtils.unescapeJava(original);\n+        final String expected = unescaped;\n+        final String actual = StringEscapeUtils.unescapeJava(original);\n \n         assertEquals(\"unescape(String) failed\" +\n                 (message == null ? \"\" : (\": \" + message)) +\n                 \"' actual '\" + StringEscapeUtils.escapeJava(actual) + \"'\",\n                 expected, actual);\n \n-        StringWriter writer = new StringWriter();\n+        final StringWriter writer = new StringWriter();\n         StringEscapeUtils.UNESCAPE_JAVA.translate(original, writer);\n         assertEquals(unescaped, writer.toString());\n \n         try {\n             StringEscapeUtils.ESCAPE_ECMASCRIPT.translate(null, null);\n             fail();\n-        } catch (IOException ex) {\n-            fail();\n-        } catch (IllegalArgumentException ex) {\n+        } catch (final IOException ex) {\n+            fail();\n+        } catch (final IllegalArgumentException ex) {\n         }\n         try {\n             StringEscapeUtils.ESCAPE_ECMASCRIPT.translate(\"\", null);\n             fail();\n-        } catch (IOException ex) {\n-            fail();\n-        } catch (IllegalArgumentException ex) {\n+        } catch (final IOException ex) {\n+            fail();\n+        } catch (final IllegalArgumentException ex) {\n         }\n         \n         assertEquals(\"He didn\\\\'t say, \\\\\\\"stop!\\\\\\\"\", StringEscapeUtils.escapeEcmaScript(\"He didn't say, \\\"stop!\\\"\"));\n     @Test\n     public void testEscapeHtml() {\n         for (int i = 0; i < HTML_ESCAPES.length; ++i) {\n-            String message = HTML_ESCAPES[i][0];\n-            String expected = HTML_ESCAPES[i][1];\n-            String original = HTML_ESCAPES[i][2];\n+            final String message = HTML_ESCAPES[i][0];\n+            final String expected = HTML_ESCAPES[i][1];\n+            final String original = HTML_ESCAPES[i][2];\n             assertEquals(message, expected, StringEscapeUtils.escapeHtml4(original));\n-            StringWriter sw = new StringWriter();\n+            final StringWriter sw = new StringWriter();\n             try {\n                 StringEscapeUtils.ESCAPE_HTML4.translate(original, sw);\n-            } catch (IOException e) {\n+            } catch (final IOException e) {\n             }\n-            String actual = original == null ? null : sw.toString();\n+            final String actual = original == null ? null : sw.toString();\n             assertEquals(message, expected, actual);\n         }\n     }\n     @Test\n     public void testUnescapeHtml4() {\n         for (int i = 0; i < HTML_ESCAPES.length; ++i) {\n-            String message = HTML_ESCAPES[i][0];\n-            String expected = HTML_ESCAPES[i][2];\n-            String original = HTML_ESCAPES[i][1];\n+            final String message = HTML_ESCAPES[i][0];\n+            final String expected = HTML_ESCAPES[i][2];\n+            final String original = HTML_ESCAPES[i][1];\n             assertEquals(message, expected, StringEscapeUtils.unescapeHtml4(original));\n             \n-            StringWriter sw = new StringWriter();\n+            final StringWriter sw = new StringWriter();\n             try {\n                 StringEscapeUtils.UNESCAPE_HTML4.translate(original, sw);\n-            } catch (IOException e) {\n+            } catch (final IOException e) {\n             }\n-            String actual = original == null ? null : sw.toString();\n+            final String actual = original == null ? null : sw.toString();\n             assertEquals(message, expected, actual);\n         }\n         // \\u00E7 is a cedilla (c with wiggle under)\n         assertEquals(\"hex number unescape\", \"\\u0080\\u009F\", StringEscapeUtils.unescapeHtml4(\"&#X80;&#X9F;\"));\n         // Test all Character values:\n         for (char i = Character.MIN_VALUE; i < Character.MAX_VALUE; i++) {\n-            Character c1 = new Character(i);\n-            Character c2 = new Character((char)(i+1));\n-            String expected = c1.toString() + c2.toString();\n-            String escapedC1 = \"&#x\" + Integer.toHexString((c1.charValue())) + \";\";\n-            String escapedC2 = \"&#x\" + Integer.toHexString((c2.charValue())) + \";\";\n+            final Character c1 = new Character(i);\n+            final Character c2 = new Character((char)(i+1));\n+            final String expected = c1.toString() + c2.toString();\n+            final String escapedC1 = \"&#x\" + Integer.toHexString((c1.charValue())) + \";\";\n+            final String escapedC2 = \"&#x\" + Integer.toHexString((c2.charValue())) + \";\";\n             assertEquals(\"hex number unescape index \" + (int)i, expected, StringEscapeUtils.unescapeHtml4(escapedC1 + escapedC2));\n         }\n     }\n         StringWriter sw = new StringWriter();\n         try {\n             StringEscapeUtils.ESCAPE_XML.translate(\"<abc>\", sw);\n-        } catch (IOException e) {\n+        } catch (final IOException e) {\n         }\n         assertEquals(\"XML was escaped incorrectly\", \"&lt;abc&gt;\", sw.toString() );\n \n         sw = new StringWriter();\n         try {\n             StringEscapeUtils.UNESCAPE_XML.translate(\"&lt;abc&gt;\", sw);\n-        } catch (IOException e) {\n+        } catch (final IOException e) {\n         }\n         assertEquals(\"XML was unescaped incorrectly\", \"<abc>\", sw.toString() );\n     }\n      */\n     @Test\n     public void testEscapeXmlSupplementaryCharacters() {\n-        CharSequenceTranslator escapeXml = \n+        final CharSequenceTranslator escapeXml = \n             StringEscapeUtils.ESCAPE_XML.with( NumericEntityEscaper.between(0x7f, Integer.MAX_VALUE) );\n \n         assertEquals(\"Supplementary character must be represented using a single escape\", \"&#144308;\",\n         // http://www.w3.org/TR/xml/#charsets says:\n         // Char ::= #x9 | #xA | #xD | [#x20-#xD7FF] | [#xE000-#xFFFD] | [#x10000-#x10FFFF] /* any Unicode character,\n         // excluding the surrogate blocks, FFFE, and FFFF. */\n-        CharSequenceTranslator escapeXml = StringEscapeUtils.ESCAPE_XML\n+        final CharSequenceTranslator escapeXml = StringEscapeUtils.ESCAPE_XML\n                 .with(NumericEntityEscaper.below(9), NumericEntityEscaper.between(0xB, 0xC), NumericEntityEscaper.between(0xE, 0x19),\n                         NumericEntityEscaper.between(0xD800, 0xDFFF), NumericEntityEscaper.between(0xFFFE, 0xFFFF), NumericEntityEscaper.above(0x110000));\n \n \n     private void checkCsvEscapeWriter(final String expected, final String value) {\n         try {\n-            StringWriter writer = new StringWriter();\n+            final StringWriter writer = new StringWriter();\n             StringEscapeUtils.ESCAPE_CSV.translate(value, writer);\n             assertEquals(expected, writer.toString());\n-        } catch (IOException e) {\n+        } catch (final IOException e) {\n             fail(\"Threw: \" + e);\n         }\n     }\n \n     private void checkCsvUnescapeWriter(final String expected, final String value) {\n         try {\n-            StringWriter writer = new StringWriter();\n+            final StringWriter writer = new StringWriter();\n             StringEscapeUtils.UNESCAPE_CSV.translate(value, writer);\n             assertEquals(expected, writer.toString());\n-        } catch (IOException e) {\n+        } catch (final IOException e) {\n             fail(\"Threw: \" + e);\n         }\n     }\n         // COUNTING ROD UNIT DIGIT THREE\n         // in Unicode\n         // codepoint: U+1D362\n-        byte[] data = new byte[] { (byte)0xF0, (byte)0x9D, (byte)0x8D, (byte)0xA2 };\n-\n-        String original = new String(data, \"UTF8\");\n-\n-        String escaped = StringEscapeUtils.escapeHtml4( original );\n+        final byte[] data = new byte[] { (byte)0xF0, (byte)0x9D, (byte)0x8D, (byte)0xA2 };\n+\n+        final String original = new String(data, \"UTF8\");\n+\n+        final String escaped = StringEscapeUtils.escapeHtml4( original );\n         assertEquals( \"High Unicode should not have been escaped\", original, escaped);\n \n-        String unescaped = StringEscapeUtils.unescapeHtml4( escaped );\n+        final String unescaped = StringEscapeUtils.unescapeHtml4( escaped );\n         assertEquals( \"High Unicode should have been unchanged\", original, unescaped);\n \n // TODO: I think this should hold, needs further investigation\n     @Test\n     public void testEscapeHiragana() {\n         // Some random Japanese Unicode characters\n-        String original = \"\\u304B\\u304C\\u3068\";\n-        String escaped = StringEscapeUtils.escapeHtml4(original);\n+        final String original = \"\\u304B\\u304C\\u3068\";\n+        final String escaped = StringEscapeUtils.escapeHtml4(original);\n         assertEquals( \"Hiragana character Unicode behaviour should not be being escaped by escapeHtml4\",\n         original, escaped);\n \n-        String unescaped = StringEscapeUtils.unescapeHtml4( escaped );\n+        final String unescaped = StringEscapeUtils.unescapeHtml4( escaped );\n \n         assertEquals( \"Hiragana character Unicode behaviour has changed - expected no unescaping\", escaped, unescaped);\n     }\n      */\n     @Test\n     public void testLang708() throws IOException {\n-        String input = IOUtils.toString(new FileInputStream(\"src/test/resources/lang-708-input.txt\"), \"UTF-8\");\n-        String escaped = StringEscapeUtils.escapeEcmaScript(input);\n+        final String input = IOUtils.toString(new FileInputStream(\"src/test/resources/lang-708-input.txt\"), \"UTF-8\");\n+        final String escaped = StringEscapeUtils.escapeEcmaScript(input);\n         // just the end:\n         assertTrue(escaped, escaped.endsWith(\"}]\"));\n         // a little more:\n      */\n     @Test\n     public void testLang720() {\n-        String input = new StringBuilder(\"\\ud842\\udfb7\").append(\"A\").toString();\n-        String escaped = StringEscapeUtils.escapeXml(input);\n+        final String input = new StringBuilder(\"\\ud842\\udfb7\").append(\"A\").toString();\n+        final String escaped = StringEscapeUtils.escapeXml(input);\n         assertEquals(input, escaped);\n     }\n }\n--- a/src/test/java/org/apache/commons/lang3/StringUtilsEqualsIndexOfTest.java\n+++ b/src/test/java/org/apache/commons/lang3/StringUtilsEqualsIndexOfTest.java\n \n     @Test\n     public void testContainsIgnoreCase_LocaleIndependence() {\n-        Locale orig = Locale.getDefault();\n-\n-        Locale[] locales = { Locale.ENGLISH, new Locale(\"tr\"), Locale.getDefault() };\n-\n-        String[][] tdata = {\n+        final Locale orig = Locale.getDefault();\n+\n+        final Locale[] locales = { Locale.ENGLISH, new Locale(\"tr\"), Locale.getDefault() };\n+\n+        final String[][] tdata = {\n             { \"i\", \"I\" },\n             { \"I\", \"i\" },\n             { \"\\u03C2\", \"\\u03C3\" },\n             { \"\\u03A3\", \"\\u03C3\" },\n         };\n \n-        String[][] fdata = {\n+        final String[][] fdata = {\n             { \"\\u00DF\", \"SS\" },\n         };\n \n         try {\n-            for (Locale locale : locales) {\n+            for (final Locale locale : locales) {\n                 Locale.setDefault(locale);\n                 for (int j = 0; j < tdata.length; j++) {\n                     assertTrue(Locale.getDefault() + \": \" + j + \" \" + tdata[j][0] + \" \" + tdata[j][1], StringUtils\n \n     @Test\n     public void testContainsNone_CharArray() {\n-        String str1 = \"a\";\n-        String str2 = \"b\";\n-        String str3 = \"ab.\";\n-        char[] chars1= {'b'};\n-        char[] chars2= {'.'};\n-        char[] chars3= {'c', 'd'};\n-        char[] emptyChars = new char[0];\n+        final String str1 = \"a\";\n+        final String str2 = \"b\";\n+        final String str3 = \"ab.\";\n+        final char[] chars1= {'b'};\n+        final char[] chars2= {'.'};\n+        final char[] chars3= {'c', 'd'};\n+        final char[] emptyChars = new char[0];\n         assertTrue(StringUtils.containsNone(null, (char[]) null));\n         assertTrue(StringUtils.containsNone(\"\", (char[]) null));\n         assertTrue(StringUtils.containsNone(null, emptyChars));\n \n     @Test\n     public void testContainsNone_String() {\n-        String str1 = \"a\";\n-        String str2 = \"b\";\n-        String str3 = \"ab.\";\n-        String chars1= \"b\";\n-        String chars2= \".\";\n-        String chars3= \"cd\";\n+        final String str1 = \"a\";\n+        final String str2 = \"b\";\n+        final String str3 = \"ab.\";\n+        final String chars1= \"b\";\n+        final String chars2= \".\";\n+        final String chars3= \"cd\";\n         assertTrue(StringUtils.containsNone(null, (String) null));\n         assertTrue(StringUtils.containsNone(\"\", (String) null));\n         assertTrue(StringUtils.containsNone(null, \"\"));\n \n     @Test\n     public void testContainsOnly_CharArray() {\n-        String str1 = \"a\";\n-        String str2 = \"b\";\n-        String str3 = \"ab\";\n-        char[] chars1= {'b'};\n-        char[] chars2= {'a'};\n-        char[] chars3= {'a', 'b'};\n-        char[] emptyChars = new char[0];\n+        final String str1 = \"a\";\n+        final String str2 = \"b\";\n+        final String str3 = \"ab\";\n+        final char[] chars1= {'b'};\n+        final char[] chars2= {'a'};\n+        final char[] chars3= {'a', 'b'};\n+        final char[] emptyChars = new char[0];\n         assertFalse(StringUtils.containsOnly(null, (char[]) null));\n         assertFalse(StringUtils.containsOnly(\"\", (char[]) null));\n         assertFalse(StringUtils.containsOnly(null, emptyChars));\n \n     @Test\n     public void testContainsOnly_String() {\n-        String str1 = \"a\";\n-        String str2 = \"b\";\n-        String str3 = \"ab\";\n-        String chars1= \"b\";\n-        String chars2= \"a\";\n-        String chars3= \"ab\";\n+        final String str1 = \"a\";\n+        final String str2 = \"b\";\n+        final String str3 = \"ab\";\n+        final String chars1= \"b\";\n+        final String chars2= \"a\";\n+        final String chars3= \"ab\";\n         assertFalse(StringUtils.containsOnly(null, (String) null));\n         assertFalse(StringUtils.containsOnly(\"\", (String) null));\n         assertFalse(StringUtils.containsOnly(null, \"\"));\n             if (obj == null || !(obj instanceof CustomCharSequence)) {\n                 return false;\n             }\n-            CustomCharSequence other = (CustomCharSequence) obj;\n+            final CustomCharSequence other = (CustomCharSequence) obj;\n             return seq.equals(other.seq);\n         }\n \n--- a/src/test/java/org/apache/commons/lang3/StringUtilsTest.java\n+++ b/src/test/java/org/apache/commons/lang3/StringUtilsTest.java\n     @Test\n     public void testConstructor() {\n         assertNotNull(new StringUtils());\n-        Constructor<?>[] cons = StringUtils.class.getDeclaredConstructors();\n+        final Constructor<?>[] cons = StringUtils.class.getDeclaredConstructors();\n         assertEquals(1, cons.length);\n         assertTrue(Modifier.isPublic(cons[0].getModifiers()));\n         assertTrue(Modifier.isPublic(StringUtils.class.getModifiers()));\n         assertEquals(\"I AM here 123\", StringUtils.swapCase(\"i am HERE 123\") );\n         assertEquals(\"i am here 123\", StringUtils.swapCase(\"I AM HERE 123\") );\n         \n-        String test = \"This String contains a TitleCase character: \\u01C8\";\n-        String expect = \"tHIS sTRING CONTAINS A tITLEcASE CHARACTER: \\u01C9\";\n+        final String test = \"This String contains a TitleCase character: \\u01C8\";\n+        final String expect = \"tHIS sTRING CONTAINS A tITLEcASE CHARACTER: \\u01C9\";\n         assertEquals(expect, WordUtils.swapCase(test));\n     }\n \n         }\n         \n         String[] results;\n-        String[] expectedResults = {\"ab\", \"de fg\"};\n+        final String[] expectedResults = {\"ab\", \"de fg\"};\n         results = StringUtils.split(\"ab   de fg\", null, 2);\n         assertEquals(expectedResults.length, results.length);\n         for (int i = 0; i < expectedResults.length; i++) {\n             assertEquals(expectedResults[i], results[i]);\n         }\n         \n-        String[] expectedResults2 = {\"ab\", \"cd:ef\"};\n+        final String[] expectedResults2 = {\"ab\", \"cd:ef\"};\n         results = StringUtils.split(\"ab:cd:ef\",\":\", 2);\n         assertEquals(expectedResults2.length, results.length);\n         for (int i = 0; i < expectedResults2.length; i++) {\n     }\n     \n     private void innerTestSplit(final char separator, final String sepStr, final char noMatch) {\n-        String msg = \"Failed on separator hex(\" + Integer.toHexString(separator) +\n+        final String msg = \"Failed on separator hex(\" + Integer.toHexString(separator) +\n             \"), noMatch hex(\" + Integer.toHexString(noMatch) + \"), sepStr(\" + sepStr + \")\";\n         \n         final String str = \"a\" + separator + \"b\" + separator + separator + noMatch + \"c\";\n \n         assertEquals( 0, StringUtils.splitByWholeSeparator( \"\", \".\" ).length ) ;\n \n-        String stringToSplitOnNulls = \"ab   de fg\" ;\n-        String[] splitOnNullExpectedResults = { \"ab\", \"de\", \"fg\" } ;\n-\n-        String[] splitOnNullResults = StringUtils.splitByWholeSeparator( stringToSplitOnNulls, null ) ;\n+        final String stringToSplitOnNulls = \"ab   de fg\" ;\n+        final String[] splitOnNullExpectedResults = { \"ab\", \"de\", \"fg\" } ;\n+\n+        final String[] splitOnNullResults = StringUtils.splitByWholeSeparator( stringToSplitOnNulls, null ) ;\n         assertEquals( splitOnNullExpectedResults.length, splitOnNullResults.length ) ;\n         for ( int i = 0 ; i < splitOnNullExpectedResults.length ; i+= 1 ) {\n             assertEquals( splitOnNullExpectedResults[i], splitOnNullResults[i] ) ;\n         }\n \n-        String stringToSplitOnCharactersAndString = \"abstemiouslyaeiouyabstemiously\" ;\n-\n-        String[] splitOnStringExpectedResults = { \"abstemiously\", \"abstemiously\" } ;\n-        String[] splitOnStringResults = StringUtils.splitByWholeSeparator( stringToSplitOnCharactersAndString, \"aeiouy\" ) ;\n+        final String stringToSplitOnCharactersAndString = \"abstemiouslyaeiouyabstemiously\" ;\n+\n+        final String[] splitOnStringExpectedResults = { \"abstemiously\", \"abstemiously\" } ;\n+        final String[] splitOnStringResults = StringUtils.splitByWholeSeparator( stringToSplitOnCharactersAndString, \"aeiouy\" ) ;\n         assertEquals( splitOnStringExpectedResults.length, splitOnStringResults.length ) ;\n         for ( int i = 0 ; i < splitOnStringExpectedResults.length ; i+= 1 ) {\n             assertEquals( splitOnStringExpectedResults[i], splitOnStringResults[i] ) ;\n         }\n \n-        String[] splitWithMultipleSeparatorExpectedResults = {\"ab\", \"cd\", \"ef\"};\n-        String[] splitWithMultipleSeparator = StringUtils.splitByWholeSeparator(\"ab:cd::ef\", \":\");\n+        final String[] splitWithMultipleSeparatorExpectedResults = {\"ab\", \"cd\", \"ef\"};\n+        final String[] splitWithMultipleSeparator = StringUtils.splitByWholeSeparator(\"ab:cd::ef\", \":\");\n         assertEquals( splitWithMultipleSeparatorExpectedResults.length, splitWithMultipleSeparator.length );\n         for( int i = 0; i < splitWithMultipleSeparatorExpectedResults.length ; i++ ) {\n             assertEquals( splitWithMultipleSeparatorExpectedResults[i], splitWithMultipleSeparator[i] ) ;\n \n         assertEquals( 0, StringUtils.splitByWholeSeparator( \"\", \".\", 3 ).length ) ;\n \n-        String stringToSplitOnNulls = \"ab   de fg\" ;\n-        String[] splitOnNullExpectedResults = { \"ab\", \"de fg\" } ;\n+        final String stringToSplitOnNulls = \"ab   de fg\" ;\n+        final String[] splitOnNullExpectedResults = { \"ab\", \"de fg\" } ;\n         //String[] splitOnNullExpectedResults = { \"ab\", \"de\" } ;\n \n-        String[] splitOnNullResults = StringUtils.splitByWholeSeparator( stringToSplitOnNulls, null, 2 ) ;\n+        final String[] splitOnNullResults = StringUtils.splitByWholeSeparator( stringToSplitOnNulls, null, 2 ) ;\n         assertEquals( splitOnNullExpectedResults.length, splitOnNullResults.length ) ;\n         for ( int i = 0 ; i < splitOnNullExpectedResults.length ; i+= 1 ) {\n             assertEquals( splitOnNullExpectedResults[i], splitOnNullResults[i] ) ;\n         }\n \n-        String stringToSplitOnCharactersAndString = \"abstemiouslyaeiouyabstemiouslyaeiouyabstemiously\" ;\n-\n-        String[] splitOnStringExpectedResults = { \"abstemiously\", \"abstemiouslyaeiouyabstemiously\" } ;\n+        final String stringToSplitOnCharactersAndString = \"abstemiouslyaeiouyabstemiouslyaeiouyabstemiously\" ;\n+\n+        final String[] splitOnStringExpectedResults = { \"abstemiously\", \"abstemiouslyaeiouyabstemiously\" } ;\n         //String[] splitOnStringExpectedResults = { \"abstemiously\", \"abstemiously\" } ;\n-        String[] splitOnStringResults = StringUtils.splitByWholeSeparator( stringToSplitOnCharactersAndString, \"aeiouy\", 2 ) ;\n+        final String[] splitOnStringResults = StringUtils.splitByWholeSeparator( stringToSplitOnCharactersAndString, \"aeiouy\", 2 ) ;\n         assertEquals( splitOnStringExpectedResults.length, splitOnStringResults.length ) ;\n         for ( int i = 0 ; i < splitOnStringExpectedResults.length ; i++ ) {\n             assertEquals( splitOnStringExpectedResults[i], splitOnStringResults[i] ) ;\n         // Match example in javadoc\n         {\n           String[] results;\n-          String[] expectedResults = {\"a\", \"\", \"b\", \"c\"};\n+          final String[] expectedResults = {\"a\", \"\", \"b\", \"c\"};\n           results = StringUtils.splitPreserveAllTokens(\"a..b.c\",'.');\n           assertEquals(expectedResults.length, results.length);\n           for (int i = 0; i < expectedResults.length; i++) {\n \n         {\n           String[] results;\n-          String[] expectedResults = {\"ab\", \"de fg\"};\n+          final String[] expectedResults = {\"ab\", \"de fg\"};\n           results = StringUtils.splitPreserveAllTokens(\"ab de fg\", null, 2);\n           assertEquals(expectedResults.length, results.length);\n           for (int i = 0; i < expectedResults.length; i++) {\n \n         {\n           String[] results;\n-          String[] expectedResults = {\"ab\", \"  de fg\"};\n+          final String[] expectedResults = {\"ab\", \"  de fg\"};\n           results = StringUtils.splitPreserveAllTokens(\"ab   de fg\", null, 2);\n           assertEquals(expectedResults.length, results.length);\n           for (int i = 0; i < expectedResults.length; i++) {\n         \n         {\n           String[] results;\n-          String[] expectedResults = {\"ab\", \"::de:fg\"};\n+          final String[] expectedResults = {\"ab\", \"::de:fg\"};\n           results = StringUtils.splitPreserveAllTokens(\"ab:::de:fg\", \":\", 2);\n           assertEquals(expectedResults.length, results.length);\n           for (int i = 0; i < expectedResults.length; i++) {\n         \n         {\n           String[] results;\n-          String[] expectedResults = {\"ab\", \"\", \" de fg\"};\n+          final String[] expectedResults = {\"ab\", \"\", \" de fg\"};\n           results = StringUtils.splitPreserveAllTokens(\"ab   de fg\", null, 3);\n           assertEquals(expectedResults.length, results.length);\n           for (int i = 0; i < expectedResults.length; i++) {\n         \n         {\n           String[] results;\n-          String[] expectedResults = {\"ab\", \"\", \"\", \"de fg\"};\n+          final String[] expectedResults = {\"ab\", \"\", \"\", \"de fg\"};\n           results = StringUtils.splitPreserveAllTokens(\"ab   de fg\", null, 4);\n           assertEquals(expectedResults.length, results.length);\n           for (int i = 0; i < expectedResults.length; i++) {\n         }\n \n         {\n-          String[] expectedResults = {\"ab\", \"cd:ef\"};\n+          final String[] expectedResults = {\"ab\", \"cd:ef\"};\n           String[] results;\n           results = StringUtils.splitPreserveAllTokens(\"ab:cd:ef\",\":\", 2);\n           assertEquals(expectedResults.length, results.length);\n \n         {\n           String[] results;\n-          String[] expectedResults = {\"ab\", \":cd:ef\"};\n+          final String[] expectedResults = {\"ab\", \":cd:ef\"};\n           results = StringUtils.splitPreserveAllTokens(\"ab::cd:ef\",\":\", 2);\n           assertEquals(expectedResults.length, results.length);\n           for (int i = 0; i < expectedResults.length; i++) {\n \n         {\n           String[] results;\n-          String[] expectedResults = {\"ab\", \"\", \":cd:ef\"};\n+          final String[] expectedResults = {\"ab\", \"\", \":cd:ef\"};\n           results = StringUtils.splitPreserveAllTokens(\"ab:::cd:ef\",\":\", 3);\n           assertEquals(expectedResults.length, results.length);\n           for (int i = 0; i < expectedResults.length; i++) {\n \n         {\n           String[] results;\n-          String[] expectedResults = {\"ab\", \"\", \"\", \"cd:ef\"};\n+          final String[] expectedResults = {\"ab\", \"\", \"\", \"cd:ef\"};\n           results = StringUtils.splitPreserveAllTokens(\"ab:::cd:ef\",\":\", 4);\n           assertEquals(expectedResults.length, results.length);\n           for (int i = 0; i < expectedResults.length; i++) {\n \n         {\n           String[] results;\n-          String[] expectedResults = {\"\", \"ab\", \"\", \"\", \"cd:ef\"};\n+          final String[] expectedResults = {\"\", \"ab\", \"\", \"\", \"cd:ef\"};\n           results = StringUtils.splitPreserveAllTokens(\":ab:::cd:ef\",\":\", 5);\n           assertEquals(expectedResults.length, results.length);\n           for (int i = 0; i < expectedResults.length; i++) {\n         \n         {\n           String[] results;\n-          String[] expectedResults = {\"\", \"\", \"ab\", \"\", \"\", \"cd:ef\"};\n+          final String[] expectedResults = {\"\", \"\", \"ab\", \"\", \"\", \"cd:ef\"};\n           results = StringUtils.splitPreserveAllTokens(\"::ab:::cd:ef\",\":\", 6);\n           assertEquals(expectedResults.length, results.length);\n           for (int i = 0; i < expectedResults.length; i++) {\n     }\n     \n     private void innerTestSplitPreserveAllTokens(final char separator, final String sepStr, final char noMatch) {\n-        String msg = \"Failed on separator hex(\" + Integer.toHexString(separator) +\n+        final String msg = \"Failed on separator hex(\" + Integer.toHexString(separator) +\n             \"), noMatch hex(\" + Integer.toHexString(noMatch) + \"), sepStr(\" + sepStr + \")\";\n         \n         final String str = \"a\" + separator + \"b\" + separator + separator + noMatch + \"c\";\n         assertEquals(\"\", StringUtils.replace(\"\", \"any\", null, 2));\n         assertEquals(\"\", StringUtils.replace(\"\", \"any\", \"any\", 2));\n         \n-        String str = new String(new char[] {'o', 'o', 'f', 'o', 'o'});\n+        final String str = new String(new char[] {'o', 'o', 'f', 'o', 'o'});\n         assertSame(str, StringUtils.replace(str, \"x\", \"\", -1));\n         \n         assertEquals(\"f\", StringUtils.replace(\"oofoo\", \"o\", \"\", -1));\n         try {\n             StringUtils.replaceEachRepeatedly(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"ab\"});\n             fail(\"Should be a circular reference\");\n-        } catch (IllegalStateException e) {}\n+        } catch (final IllegalStateException e) {}\n \n         //JAVADOC TESTS END\n     }\n         assertEquals(\"aaa\", StringUtils.repeat(\"a\", 3));\n         assertEquals(\"ababab\", StringUtils.repeat(\"ab\", 3));\n         assertEquals(\"abcabcabc\", StringUtils.repeat(\"abc\", 3));\n-        String str = StringUtils.repeat(\"a\", 10000);  // bigger than pad limit\n+        final String str = StringUtils.repeat(\"a\", 10000);  // bigger than pad limit\n         assertEquals(10000, str.length());\n         assertTrue(StringUtils.containsOnly(str, new char[] {'a'}));\n     }\n     @Test\n     public void testChop() {\n \n-        String[][] chopCases = {\n+        final String[][] chopCases = {\n             { FOO_UNCAP + \"\\r\\n\", FOO_UNCAP } ,\n             { FOO_UNCAP + \"\\n\" , FOO_UNCAP } ,\n             { FOO_UNCAP + \"\\r\", FOO_UNCAP },\n             { \"\", \"\" },\n             { \"a\", \"\" },\n         };\n-        for (String[] chopCase : chopCases) {\n-            String original = chopCase[0];\n-            String expectedResult = chopCase[1];\n+        for (final String[] chopCase : chopCases) {\n+            final String original = chopCase[0];\n+            final String expectedResult = chopCase[1];\n             assertEquals(\"chop(String) failed\",\n                     expectedResult, StringUtils.chop(original));\n         }\n     @Test\n     public void testChomp() {\n \n-        String[][] chompCases = {\n+        final String[][] chompCases = {\n             { FOO_UNCAP + \"\\r\\n\", FOO_UNCAP },\n             { FOO_UNCAP + \"\\n\" , FOO_UNCAP },\n             { FOO_UNCAP + \"\\r\", FOO_UNCAP },\n             { null, null },\n             { FOO_UNCAP + \"\\n\\r\", FOO_UNCAP + \"\\n\"}\n         };\n-        for (String[] chompCase : chompCases) {\n-            String original = chompCase[0];\n-            String expectedResult = chompCase[1];\n+        for (final String[] chompCase : chompCases) {\n+            final String original = chompCase[0];\n+            final String expectedResult = chompCase[1];\n             assertEquals(\"chomp(String) failed\",\n                     expectedResult, StringUtils.chomp(original));\n         }\n         assertEquals(\"abc\", StringUtils.rightPad(\"abc\", 2, ' '));\n         assertEquals(\"abc\", StringUtils.rightPad(\"abc\", -1, ' '));\n         assertEquals(\"abcxx\", StringUtils.rightPad(\"abc\", 5, 'x'));\n-        String str = StringUtils.rightPad(\"aaa\", 10000, 'a');  // bigger than pad length\n+        final String str = StringUtils.rightPad(\"aaa\", 10000, 'a');  // bigger than pad length\n         assertEquals(10000, str.length());\n         assertTrue(StringUtils.containsOnly(str, new char[] {'a'}));\n     }\n         assertEquals(\"xxabc\", StringUtils.leftPad(\"abc\", 5, 'x'));\n         assertEquals(\"\\uffff\\uffffabc\", StringUtils.leftPad(\"abc\", 5, '\\uffff'));\n         assertEquals(\"abc\", StringUtils.leftPad(\"abc\", 2, ' '));\n-        String str = StringUtils.leftPad(\"aaa\", 10000, 'a');  // bigger than pad length\n+        final String str = StringUtils.leftPad(\"aaa\", 10000, 'a');  // bigger than pad length\n         assertEquals(10000, str.length());\n         assertTrue(StringUtils.containsOnly(str, new char[] {'a'}));\n     }\n         assertEquals(\"abc\", StringUtils.defaultIfEmpty(\"abc\", \"NULL\"));\n         assertNull(StringUtils.defaultIfEmpty(\"\", null));\n         // Tests compatibility for the API return type\n-        String s = StringUtils.defaultIfEmpty(\"abc\", \"NULL\");\n+        final String s = StringUtils.defaultIfEmpty(\"abc\", \"NULL\");\n         assertEquals(\"abc\", s);\n     }\n \n         assertEquals(\"abc\", StringUtils.defaultIfBlank(\"abc\", \"NULL\"));\n         assertNull(StringUtils.defaultIfBlank(\"\", null));\n         // Tests compatibility for the API return type\n-        String s = StringUtils.defaultIfBlank(\"abc\", \"NULL\");\n+        final String s = StringUtils.defaultIfBlank(\"abc\", \"NULL\");\n         assertEquals(\"abc\", s);\n     }\n \n         assertEquals(\"abc\", StringUtils.defaultIfEmpty(new StringBuilder(\"abc\"), new StringBuilder(\"NULL\")).toString());\n         assertNull(StringUtils.defaultIfEmpty(new StringBuilder(\"\"), null));\n         // Tests compatibility for the API return type\n-        StringBuilder s = StringUtils.defaultIfEmpty(new StringBuilder(\"abc\"), new StringBuilder(\"NULL\"));\n+        final StringBuilder s = StringUtils.defaultIfEmpty(new StringBuilder(\"abc\"), new StringBuilder(\"NULL\"));\n         assertEquals(\"abc\", s.toString());\n     }\n \n         assertEquals(\"abc\", StringUtils.defaultIfBlank(new StringBuilder(\"abc\"), new StringBuilder(\"NULL\")).toString());\n         assertNull(StringUtils.defaultIfBlank(new StringBuilder(\"\"), null));\n         // Tests compatibility for the API return type\n-        StringBuilder s = StringUtils.defaultIfBlank(new StringBuilder(\"abc\"), new StringBuilder(\"NULL\"));\n+        final StringBuilder s = StringUtils.defaultIfBlank(new StringBuilder(\"abc\"), new StringBuilder(\"NULL\"));\n         assertEquals(\"abc\", s.toString());\n     }\n \n         assertEquals(\"abc\", StringUtils.defaultIfEmpty(new StringBuffer(\"abc\"), new StringBuffer(\"NULL\")).toString());\n         assertNull(StringUtils.defaultIfEmpty(new StringBuffer(\"\"), null));\n         // Tests compatibility for the API return type\n-        StringBuffer s = StringUtils.defaultIfEmpty(new StringBuffer(\"abc\"), new StringBuffer(\"NULL\"));\n+        final StringBuffer s = StringUtils.defaultIfEmpty(new StringBuffer(\"abc\"), new StringBuffer(\"NULL\"));\n         assertEquals(\"abc\", s.toString());\n     }\n \n         assertEquals(\"abc\", StringUtils.defaultIfBlank(new StringBuffer(\"abc\"), new StringBuffer(\"NULL\")).toString());\n         assertNull(StringUtils.defaultIfBlank(new StringBuffer(\"\"), null));\n         // Tests compatibility for the API return type\n-        StringBuffer s = StringUtils.defaultIfBlank(new StringBuffer(\"abc\"), new StringBuffer(\"NULL\"));\n+        final StringBuffer s = StringUtils.defaultIfBlank(new StringBuffer(\"abc\"), new StringBuffer(\"NULL\"));\n         assertEquals(\"abc\", s.toString());\n     }\n \n         assertEquals(\"abc\", StringUtils.defaultIfEmpty(CharBuffer.wrap(\"abc\"), CharBuffer.wrap(\"NULL\")).toString());\n         assertNull(StringUtils.defaultIfEmpty(CharBuffer.wrap(\"\"), null));\n         // Tests compatibility for the API return type\n-        CharBuffer s = StringUtils.defaultIfEmpty(CharBuffer.wrap(\"abc\"), CharBuffer.wrap(\"NULL\"));\n+        final CharBuffer s = StringUtils.defaultIfEmpty(CharBuffer.wrap(\"abc\"), CharBuffer.wrap(\"NULL\"));\n         assertEquals(\"abc\", s.toString());\n     }\n \n         assertEquals(\"abc\", StringUtils.defaultIfBlank(CharBuffer.wrap(\"abc\"), CharBuffer.wrap(\"NULL\")).toString());\n         assertNull(StringUtils.defaultIfBlank(CharBuffer.wrap(\"\"), null));\n         // Tests compatibility for the API return type\n-        CharBuffer s = StringUtils.defaultIfBlank(CharBuffer.wrap(\"abc\"), CharBuffer.wrap(\"NULL\"));\n+        final CharBuffer s = StringUtils.defaultIfBlank(CharBuffer.wrap(\"abc\"), CharBuffer.wrap(\"NULL\"));\n         assertEquals(\"abc\", s.toString());\n     }\n \n         assertEquals(\"short\", StringUtils.abbreviate(\"short\", 10));\n         assertEquals(\"Now is ...\", StringUtils.abbreviate(\"Now is the time for all good men to come to the aid of their party.\", 10));\n \n-        String raspberry = \"raspberry peach\";\n+        final String raspberry = \"raspberry peach\";\n         assertEquals(\"raspberry p...\", StringUtils.abbreviate(raspberry, 14));\n         assertEquals(\"raspberry peach\", StringUtils.abbreviate(\"raspberry peach\", 15));\n         assertEquals(\"raspberry peach\", StringUtils.abbreviate(\"raspberry peach\", 16));\n         \n         try {\n             @SuppressWarnings(\"unused\")\n+            final\n             String res = StringUtils.abbreviate(\"abc\", 3);\n             fail(\"StringUtils.abbreviate expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {\n+        } catch (final IllegalArgumentException ex) {\n                 // empty\n         }              \n     }\n         \n         try {\n             @SuppressWarnings(\"unused\")\n+            final\n             String res = StringUtils.abbreviate(\"abcdefghij\", 0, 3);\n             fail(\"StringUtils.abbreviate expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {\n+        } catch (final IllegalArgumentException ex) {\n                 // empty\n         }      \n         try {\n             @SuppressWarnings(\"unused\")\n+            final\n             String res = StringUtils.abbreviate(\"abcdefghij\", 5, 6);\n             fail(\"StringUtils.abbreviate expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {\n+        } catch (final IllegalArgumentException ex) {\n                 // empty\n         }      \n         \n \n-        String raspberry = \"raspberry peach\";\n+        final String raspberry = \"raspberry peach\";\n         assertEquals(\"raspberry peach\", StringUtils.abbreviate(raspberry, 11, 15));\n \n         assertEquals(null, StringUtils.abbreviate(null, 7, 14));\n     }\n \n     private void assertAbbreviateWithOffset(final String expected, final int offset, final int maxWidth) {\n-        String abcdefghijklmno = \"abcdefghijklmno\";\n-        String message = \"abbreviate(String,int,int) failed\";\n-        String actual = StringUtils.abbreviate(abcdefghijklmno, offset, maxWidth);\n+        final String abcdefghijklmno = \"abcdefghijklmno\";\n+        final String message = \"abbreviate(String,int,int) failed\";\n+        final String actual = StringUtils.abbreviate(abcdefghijklmno, offset, maxWidth);\n         if (offset >= 0 && offset < abcdefghijklmno.length()) {\n             assertTrue(message + \" -- should contain offset character\",\n                     actual.indexOf((char)('a'+offset)) != -1);\n                 \"end to see if the text is complete.\", \"...\", 50) );\n \n         // Test a much longer text :)\n-        String longText = \"Start text\" + StringUtils.repeat(\"x\", 10000) + \"Close text\";\n+        final String longText = \"Start text\" + StringUtils.repeat(\"x\", 10000) + \"Close text\";\n         assertEquals( \n             \"Start text->Close text\",\n             StringUtils.abbreviateMiddle( longText, \"->\", 22 ) );\n         assertEquals(1, StringUtils.getLevenshteinDistance(\"hello\", \"hallo\") );\n         try {\n             @SuppressWarnings(\"unused\")\n+            final\n             int d = StringUtils.getLevenshteinDistance(\"a\", null);\n             fail(\"expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {\n+        } catch (final IllegalArgumentException ex) {\n             // empty\n         }\n         try {\n             @SuppressWarnings(\"unused\")\n+            final\n             int d = StringUtils.getLevenshteinDistance(null, \"a\");\n             fail(\"expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {\n+        } catch (final IllegalArgumentException ex) {\n             // empty\n         }\n     }\n         // exceptions\n         try {\n             @SuppressWarnings(\"unused\")\n+            final\n             int d = StringUtils.getLevenshteinDistance(\"a\", null, 0);\n             fail(\"expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {\n+        } catch (final IllegalArgumentException ex) {\n             // empty\n         }\n         try {\n             @SuppressWarnings(\"unused\")\n+            final\n             int d = StringUtils.getLevenshteinDistance(null, \"a\", 0);\n             fail(\"expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {\n+        } catch (final IllegalArgumentException ex) {\n             // empty\n         }\n \n         try {\n             @SuppressWarnings(\"unused\")\n+            final\n             int d = StringUtils.getLevenshteinDistance(\"a\", \"a\", -1);\n             fail(\"expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {\n+        } catch (final IllegalArgumentException ex) {\n             // empty\n         }\n     }\n     // This test enforces that this is done.\n     @Test\n     public void testStringUtilsCharSequenceContract() {\n-        Class<StringUtils> c = StringUtils.class;\n-        Method[] methods = c.getMethods();\n-        for (Method m : methods) {\n+        final Class<StringUtils> c = StringUtils.class;\n+        final Method[] methods = c.getMethods();\n+        for (final Method m : methods) {\n             if (m.getReturnType() == String.class || m.getReturnType() == String[].class) {\n                 // Assume this is mutable and ensure the first parameter is not CharSequence.\n                 // It may be String or it may be something else (String[], Object, Object[]) so \n                 // don't actively test for that.\n-                Class<?>[] params = m.getParameterTypes();\n+                final Class<?>[] params = m.getParameterTypes();\n                 if ( params.length > 0 && (params[0] == CharSequence.class || params[0] == CharSequence[].class)) {\n                     fail(\"The method \" + m + \" appears to be mutable in spirit and therefore must not accept a CharSequence\");\n                 }\n             } else {\n                 // Assume this is immutable in spirit and ensure the first parameter is not String.\n                 // As above, it may be something other than CharSequence.\n-                Class<?>[] params = m.getParameterTypes();\n+                final Class<?>[] params = m.getParameterTypes();\n                 if ( params.length > 0 && (params[0] == String.class || params[0] == String[].class)) {\n                     fail(\"The method \" + m + \" appears to be immutable in spirit and therefore must not accept a String\");\n                 }\n--- a/src/test/java/org/apache/commons/lang3/StringUtilsTrimEmptyTest.java\n+++ b/src/test/java/org/apache/commons/lang3/StringUtilsTrimEmptyTest.java\n     @Test\n     public void testStripAll() {\n         // test stripAll method, merely an array version of the above strip\n-        String[] empty = new String[0];\n-        String[] fooSpace = new String[] { \"  \"+FOO+\"  \", \"  \"+FOO, FOO+\"  \" };\n-        String[] fooDots = new String[] { \"..\"+FOO+\"..\", \"..\"+FOO, FOO+\"..\" };\n-        String[] foo = new String[] { FOO, FOO, FOO };\n+        final String[] empty = new String[0];\n+        final String[] fooSpace = new String[] { \"  \"+FOO+\"  \", \"  \"+FOO, FOO+\"  \" };\n+        final String[] fooDots = new String[] { \"..\"+FOO+\"..\", \"..\"+FOO, FOO+\"..\" };\n+        final String[] foo = new String[] { FOO, FOO, FOO };\n \n         assertNull(StringUtils.stripAll((String[]) null));\n         // Additional varargs tests\n \n     @Test\n     public void testStripAccents() {\n-        String cue = \"\\u00C7\\u00FA\\u00EA\";\n+        final String cue = \"\\u00C7\\u00FA\\u00EA\";\n         assertEquals( \"Failed to strip accents from \" + cue, \"Cue\", StringUtils.stripAccents(cue));\n \n-        String lots = \"\\u00C0\\u00C1\\u00C2\\u00C3\\u00C4\\u00C5\\u00C7\\u00C8\\u00C9\" + \n+        final String lots = \"\\u00C0\\u00C1\\u00C2\\u00C3\\u00C4\\u00C5\\u00C7\\u00C8\\u00C9\" + \n                       \"\\u00CA\\u00CB\\u00CC\\u00CD\\u00CE\\u00CF\\u00D1\\u00D2\\u00D3\" + \n                       \"\\u00D4\\u00D5\\u00D6\\u00D9\\u00DA\\u00DB\\u00DC\\u00DD\";\n         assertEquals( \"Failed to strip accents from \" + lots, \n--- a/src/test/java/org/apache/commons/lang3/SystemUtilsTest.java\n+++ b/src/test/java/org/apache/commons/lang3/SystemUtilsTest.java\n     @Test\n     public void testConstructor() {\n         assertNotNull(new SystemUtils());\n-        Constructor<?>[] cons = SystemUtils.class.getDeclaredConstructors();\n+        final Constructor<?>[] cons = SystemUtils.class.getDeclaredConstructors();\n         assertEquals(1, cons.length);\n         assertTrue(Modifier.isPublic(cons[0].getModifiers()));\n         assertTrue(Modifier.isPublic(SystemUtils.class.getModifiers()));\n      */\n     @Test\n     public void testGetJavaHome() {\n-        File dir = SystemUtils.getJavaHome();\n+        final File dir = SystemUtils.getJavaHome();\n         Assert.assertNotNull(dir);\n         Assert.assertTrue(dir.exists());\n     }\n      */\n     @Test\n     public void testGetJavaIoTmpDir() {\n-        File dir = SystemUtils.getJavaIoTmpDir();\n+        final File dir = SystemUtils.getJavaIoTmpDir();\n         Assert.assertNotNull(dir);\n         Assert.assertTrue(dir.exists());\n     }\n      */\n     @Test\n     public void testGetUserDir() {\n-        File dir = SystemUtils.getUserDir();\n+        final File dir = SystemUtils.getUserDir();\n         Assert.assertNotNull(dir);\n         Assert.assertTrue(dir.exists());\n     }\n      */\n     @Test\n     public void testGetUserHome() {\n-        File dir = SystemUtils.getUserHome();\n+        final File dir = SystemUtils.getUserHome();\n         Assert.assertNotNull(dir);\n         Assert.assertTrue(dir.exists());\n     }\n \n     @Test\n     public void testIS_JAVA() {\n-        String javaVersion = System.getProperty(\"java.version\");\n+        final String javaVersion = System.getProperty(\"java.version\");\n         if (javaVersion == null) {\n             assertFalse(SystemUtils.IS_JAVA_1_1);\n             assertFalse(SystemUtils.IS_JAVA_1_2);\n \n     @Test\n     public void testIS_OS() {\n-        String osName = System.getProperty(\"os.name\");\n+        final String osName = System.getProperty(\"os.name\");\n         if (osName == null) {\n             assertFalse(SystemUtils.IS_OS_WINDOWS);\n             assertFalse(SystemUtils.IS_OS_UNIX);\n \n     @Test\n     public void testJavaAwtHeadless() {\n-        boolean atLeastJava14 = SystemUtils.isJavaVersionAtLeast(JAVA_1_4);\n-        String expectedStringValue = System.getProperty(\"java.awt.headless\");\n-        String expectedStringValueWithDefault = System.getProperty(\"java.awt.headless\", \"false\");\n+        final boolean atLeastJava14 = SystemUtils.isJavaVersionAtLeast(JAVA_1_4);\n+        final String expectedStringValue = System.getProperty(\"java.awt.headless\");\n+        final String expectedStringValueWithDefault = System.getProperty(\"java.awt.headless\", \"false\");\n         assertNotNull(expectedStringValueWithDefault);\n         if (atLeastJava14) {\n-            boolean expectedValue = Boolean.valueOf(expectedStringValue).booleanValue();\n+            final boolean expectedValue = Boolean.valueOf(expectedStringValue).booleanValue();\n             if (expectedStringValue != null) {\n                 assertEquals(expectedStringValue, SystemUtils.JAVA_AWT_HEADLESS);\n             }\n--- a/src/test/java/org/apache/commons/lang3/ValidateTest.java\n+++ b/src/test/java/org/apache/commons/lang3/ValidateTest.java\n         try {\n             Validate.isTrue(false);\n             fail(\"Expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {\n+        } catch (final IllegalArgumentException ex) {\n             assertEquals(\"The validated expression is false\", ex.getMessage());\n         }\n     }\n         try {\n             Validate.isTrue(false, \"MSG\");\n             fail(\"Expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {\n+        } catch (final IllegalArgumentException ex) {\n             assertEquals(\"MSG\", ex.getMessage());\n         }\n     }\n         try {\n             Validate.isTrue(false, \"MSG\", 6);\n             fail(\"Expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {\n+        } catch (final IllegalArgumentException ex) {\n             assertEquals(\"MSG\", ex.getMessage());\n         }\n     }\n         try {\n             Validate.isTrue(false, \"MSG\", 7);\n             fail(\"Expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {\n+        } catch (final IllegalArgumentException ex) {\n             assertEquals(\"MSG\", ex.getMessage());\n         }\n     }\n         try {\n             Validate.isTrue(false, \"MSG\", 7.4d);\n             fail(\"Expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {\n+        } catch (final IllegalArgumentException ex) {\n             assertEquals(\"MSG\", ex.getMessage());\n         }\n     }\n         try {\n             Validate.notNull(null);\n             fail(\"Expecting NullPointerException\");\n-        } catch (NullPointerException ex) {\n+        } catch (final NullPointerException ex) {\n             assertEquals(\"The validated object is null\", ex.getMessage());\n         }\n         \n-        String str = \"Hi\";\n-        String testStr = Validate.notNull(str);\n+        final String str = \"Hi\";\n+        final String testStr = Validate.notNull(str);\n         assertSame(str, testStr);\n     }\n \n         try {\n             Validate.notNull(null, \"MSG\");\n             fail(\"Expecting NullPointerException\");\n-        } catch (NullPointerException ex) {\n-            assertEquals(\"MSG\", ex.getMessage());\n-        }\n-        \n-        String str = \"Hi\";\n-        String testStr = Validate.notNull(str, \"Message\");\n+        } catch (final NullPointerException ex) {\n+            assertEquals(\"MSG\", ex.getMessage());\n+        }\n+        \n+        final String str = \"Hi\";\n+        final String testStr = Validate.notNull(str, \"Message\");\n         assertSame(str, testStr);\n     }\n \n         try {\n             Validate.notEmpty((Object[]) null);\n             fail(\"Expecting NullPointerException\");\n-        } catch (NullPointerException ex) {\n+        } catch (final NullPointerException ex) {\n             assertEquals(\"The validated array is empty\", ex.getMessage());\n         }\n         try {\n             Validate.notEmpty(new Object[0]);\n             fail(\"Expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {\n+        } catch (final IllegalArgumentException ex) {\n             assertEquals(\"The validated array is empty\", ex.getMessage());\n         }\n         \n-        String[] array = new String[] {\"hi\"};\n-        String[] test = Validate.notEmpty(array);\n+        final String[] array = new String[] {\"hi\"};\n+        final String[] test = Validate.notEmpty(array);\n         assertSame(array, test);\n     }\n \n         try {\n             Validate.notEmpty((Object[]) null, \"MSG\");\n             fail(\"Expecting NullPointerException\");\n-        } catch (NullPointerException ex) {\n+        } catch (final NullPointerException ex) {\n             assertEquals(\"MSG\", ex.getMessage());\n         }\n         try {\n             Validate.notEmpty(new Object[0], \"MSG\");\n             fail(\"Expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {\n-            assertEquals(\"MSG\", ex.getMessage());\n-        }\n-        \n-        String[] array = new String[] {\"hi\"};\n-        String[] test = Validate.notEmpty(array, \"Message\");\n+        } catch (final IllegalArgumentException ex) {\n+            assertEquals(\"MSG\", ex.getMessage());\n+        }\n+        \n+        final String[] array = new String[] {\"hi\"};\n+        final String[] test = Validate.notEmpty(array, \"Message\");\n         assertSame(array, test);\n     }\n \n     //-----------------------------------------------------------------------\n     @Test\n     public void testNotEmptyCollection1() {\n-        Collection<Integer> coll = new ArrayList<Integer>();\n+        final Collection<Integer> coll = new ArrayList<Integer>();\n         try {\n             Validate.notEmpty((Collection<?>) null);\n             fail(\"Expecting NullPointerException\");\n-        } catch (NullPointerException ex) {\n+        } catch (final NullPointerException ex) {\n             assertEquals(\"The validated collection is empty\", ex.getMessage());\n         }\n         try {\n             Validate.notEmpty(coll);\n             fail(\"Expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {\n+        } catch (final IllegalArgumentException ex) {\n             assertEquals(\"The validated collection is empty\", ex.getMessage());\n         }\n         coll.add(Integer.valueOf(8));\n         Validate.notEmpty(coll);\n         \n-        Collection<Integer> test = Validate.notEmpty(coll);\n+        final Collection<Integer> test = Validate.notEmpty(coll);\n         assertSame(coll, test);\n     }\n \n     //-----------------------------------------------------------------------\n     @Test\n     public void testNotEmptyCollection2() {\n-        Collection<Integer> coll = new ArrayList<Integer>();\n+        final Collection<Integer> coll = new ArrayList<Integer>();\n         try {\n             Validate.notEmpty((Collection<?>) null, \"MSG\");\n             fail(\"Expecting NullPointerException\");\n-        } catch (NullPointerException ex) {\n+        } catch (final NullPointerException ex) {\n             assertEquals(\"MSG\", ex.getMessage());\n         }\n         try {\n             Validate.notEmpty(coll, \"MSG\");\n             fail(\"Expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {\n+        } catch (final IllegalArgumentException ex) {\n             assertEquals(\"MSG\", ex.getMessage());\n         }\n         coll.add(Integer.valueOf(8));\n         Validate.notEmpty(coll, \"MSG\");\n         \n-        Collection<Integer> test = Validate.notEmpty(coll, \"Message\");\n+        final Collection<Integer> test = Validate.notEmpty(coll, \"Message\");\n         assertSame(coll, test);\n     }\n \n     //-----------------------------------------------------------------------\n     @Test\n     public void testNotEmptyMap1() {\n-        Map<String, Integer> map = new HashMap<String, Integer>();\n+        final Map<String, Integer> map = new HashMap<String, Integer>();\n         try {\n             Validate.notEmpty((Map<?, ?>) null);\n             fail(\"Expecting NullPointerException\");\n-        } catch (NullPointerException ex) {\n+        } catch (final NullPointerException ex) {\n             assertEquals(\"The validated map is empty\", ex.getMessage());\n         }\n         try {\n             Validate.notEmpty(map);\n             fail(\"Expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {\n+        } catch (final IllegalArgumentException ex) {\n             assertEquals(\"The validated map is empty\", ex.getMessage());\n         }\n         map.put(\"ll\", Integer.valueOf(8));\n         Validate.notEmpty(map);\n         \n-        Map<String, Integer> test = Validate.notEmpty(map);\n+        final Map<String, Integer> test = Validate.notEmpty(map);\n         assertSame(map, test);\n     }\n \n     //-----------------------------------------------------------------------\n     @Test\n     public void testNotEmptyMap2() {\n-        Map<String, Integer> map = new HashMap<String, Integer>();\n+        final Map<String, Integer> map = new HashMap<String, Integer>();\n         try {\n             Validate.notEmpty((Map<?, ?>) null, \"MSG\");\n             fail(\"Expecting NullPointerException\");\n-        } catch (NullPointerException ex) {\n+        } catch (final NullPointerException ex) {\n             assertEquals(\"MSG\", ex.getMessage());\n         }\n         try {\n             Validate.notEmpty(map, \"MSG\");\n             fail(\"Expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {\n+        } catch (final IllegalArgumentException ex) {\n             assertEquals(\"MSG\", ex.getMessage());\n         }\n         map.put(\"ll\", Integer.valueOf(8));\n         Validate.notEmpty(map, \"MSG\");\n         \n-        Map<String, Integer> test = Validate.notEmpty(map, \"Message\");\n+        final Map<String, Integer> test = Validate.notEmpty(map, \"Message\");\n         assertSame(map, test);\n     }\n \n         try {\n             Validate.notEmpty((String) null);\n             fail(\"Expecting NullPointerException\");\n-        } catch (NullPointerException ex) {\n+        } catch (final NullPointerException ex) {\n             assertEquals(\"The validated character sequence is empty\", ex.getMessage());\n         }\n         try {\n             Validate.notEmpty(\"\");\n             fail(\"Expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {\n+        } catch (final IllegalArgumentException ex) {\n             assertEquals(\"The validated character sequence is empty\", ex.getMessage());\n         }\n         \n-        String str = \"Hi\";\n-        String testStr = Validate.notEmpty(str);\n+        final String str = \"Hi\";\n+        final String testStr = Validate.notEmpty(str);\n         assertSame(str, testStr);\n     }\n \n         try {\n             Validate.notEmpty((String) null, \"MSG\");\n             fail(\"Expecting NullPointerException\");\n-        } catch (NullPointerException ex) {\n+        } catch (final NullPointerException ex) {\n             assertEquals(\"MSG\", ex.getMessage());\n         }\n         try {\n             Validate.notEmpty(\"\", \"MSG\");\n             fail(\"Expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {\n-            assertEquals(\"MSG\", ex.getMessage());\n-        }\n-        \n-        String str = \"Hi\";\n-        String testStr = Validate.notEmpty(str, \"Message\");\n+        } catch (final IllegalArgumentException ex) {\n+            assertEquals(\"MSG\", ex.getMessage());\n+        }\n+        \n+        final String str = \"Hi\";\n+        final String testStr = Validate.notEmpty(str, \"Message\");\n         assertSame(str, testStr);\n     }\n \n     @Test\n     public void testNotBlankNullStringShouldThrow() {\n         //given\n-        String string = null;\n+        final String string = null;\n \n         try {\n             //when\n             Validate.notBlank(string);\n             fail(\"Expecting NullPointerException\");\n-        } catch (NullPointerException e) {\n+        } catch (final NullPointerException e) {\n             //then\n             assertEquals(\"The validated character sequence is blank\", e.getMessage());\n         }\n     @Test\n     public void testNotBlankMsgNullStringShouldThrow() {\n         //given\n-        String string = null;\n+        final String string = null;\n \n         try {\n             //when\n             Validate.notBlank(string, \"Message\");\n             fail(\"Expecting NullPointerException\");\n-        } catch (NullPointerException e) {\n+        } catch (final NullPointerException e) {\n             //then\n             assertEquals(\"Message\", e.getMessage());\n         }\n     @Test\n     public void testNotBlankEmptyStringShouldThrow() {\n         //given\n-        String string = \"\";\n+        final String string = \"\";\n \n         try {\n             //when\n             Validate.notBlank(string);\n             fail(\"Expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException e) {\n+        } catch (final IllegalArgumentException e) {\n             //then\n             assertEquals(\"The validated character sequence is blank\", e.getMessage());\n         }\n     @Test\n     public void testNotBlankBlankStringWithWhitespacesShouldThrow() {\n         //given\n-        String string = \"   \";\n+        final String string = \"   \";\n \n         try {\n             //when\n             Validate.notBlank(string);\n             fail(\"Expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException e) {\n+        } catch (final IllegalArgumentException e) {\n             //then\n             assertEquals(\"The validated character sequence is blank\", e.getMessage());\n         }\n     @Test\n     public void testNotBlankBlankStringWithNewlinesShouldThrow() {\n         //given\n-        String string = \" \\n \\t \\r \\n \";\n+        final String string = \" \\n \\t \\r \\n \";\n \n         try {\n             //when\n             Validate.notBlank(string);\n             fail(\"Expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException e) {\n+        } catch (final IllegalArgumentException e) {\n             //then\n             assertEquals(\"The validated character sequence is blank\", e.getMessage());\n         }\n     @Test\n     public void testNotBlankMsgBlankStringShouldThrow() {\n         //given\n-        String string = \" \\n \\t \\r \\n \";\n+        final String string = \" \\n \\t \\r \\n \";\n \n         try {\n             //when\n             Validate.notBlank(string, \"Message\");\n             fail(\"Expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException e) {\n+        } catch (final IllegalArgumentException e) {\n             //then\n             assertEquals(\"Message\", e.getMessage());\n         }\n     @Test\n     public void testNotBlankMsgBlankStringWithWhitespacesShouldThrow() {\n         //given\n-        String string = \"   \";\n+        final String string = \"   \";\n \n         try {\n             //when\n             Validate.notBlank(string, \"Message\");\n             fail(\"Expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException e) {\n+        } catch (final IllegalArgumentException e) {\n             //then\n             assertEquals(\"Message\", e.getMessage());\n         }\n     @Test\n     public void testNotBlankMsgEmptyStringShouldThrow() {\n         //given\n-        String string = \"\";\n+        final String string = \"\";\n \n         try {\n             //when\n             Validate.notBlank(string, \"Message\");\n             fail(\"Expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException e) {\n+        } catch (final IllegalArgumentException e) {\n             //then\n             assertEquals(\"Message\", e.getMessage());\n         }\n     @Test\n     public void testNotBlankNotBlankStringShouldNotThrow() {\n         //given\n-        String string = \"abc\";\n+        final String string = \"abc\";\n \n         //when\n         Validate.notBlank(string);\n     @Test\n     public void testNotBlankNotBlankStringWithWhitespacesShouldNotThrow() {\n         //given\n-        String string = \"  abc   \";\n+        final String string = \"  abc   \";\n \n         //when\n         Validate.notBlank(string);\n     @Test\n     public void testNotBlankNotBlankStringWithNewlinesShouldNotThrow() {\n         //given\n-        String string = \" \\n \\t abc \\r \\n \";\n+        final String string = \" \\n \\t abc \\r \\n \";\n \n         //when\n         Validate.notBlank(string);\n     @Test\n     public void testNotBlankMsgNotBlankStringShouldNotThrow() {\n         //given\n-        String string = \"abc\";\n+        final String string = \"abc\";\n \n         //when\n         Validate.notBlank(string, \"Message\");\n     @Test\n     public void testNotBlankMsgNotBlankStringWithWhitespacesShouldNotThrow() {\n         //given\n-        String string = \"  abc   \";\n+        final String string = \"  abc   \";\n \n         //when\n         Validate.notBlank(string, \"Message\");\n     @Test\n     public void testNotBlankMsgNotBlankStringWithNewlinesShouldNotThrow() {\n         //given\n-        String string = \" \\n \\t abc \\r \\n \";\n+        final String string = \" \\n \\t abc \\r \\n \";\n \n         //when\n         Validate.notBlank(string, \"Message\");\n     //-----------------------------------------------------------------------\n     @Test\n     public void testNotBlankReturnValues1() {\n-        String str = \"Hi\";\n-        String test = Validate.notBlank(str);\n+        final String str = \"Hi\";\n+        final String test = Validate.notBlank(str);\n         assertSame(str, test);\n     }\n \n     @Test\n     public void testNotBlankReturnValues2() {\n-        String str = \"Hi\";\n-        String test = Validate.notBlank(str, \"Message\");\n+        final String str = \"Hi\";\n+        final String test = Validate.notBlank(str, \"Message\");\n         assertSame(str, test);\n     }\n \n         try {\n             Validate.noNullElements((Object[]) null);\n             fail(\"Expecting NullPointerException\");\n-        } catch (NullPointerException ex) {\n+        } catch (final NullPointerException ex) {\n             assertEquals(\"The validated object is null\", ex.getMessage());\n         }\n         array[1] = null;\n         try {\n             Validate.noNullElements(array);\n             fail(\"Expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {\n+        } catch (final IllegalArgumentException ex) {\n             assertEquals(\"The validated array contains null element at index: 1\", ex.getMessage());\n         }\n         \n         array = new String[] {\"a\", \"b\"};\n-        String[] test = Validate.noNullElements(array);\n+        final String[] test = Validate.noNullElements(array);\n         assertSame(array, test);\n     }\n \n         try {\n             Validate.noNullElements((Object[]) null, \"MSG\");\n             fail(\"Expecting NullPointerException\");\n-        } catch (NullPointerException ex) {\n+        } catch (final NullPointerException ex) {\n             assertEquals(\"The validated object is null\", ex.getMessage());\n         }\n         array[1] = null;\n         try {\n             Validate.noNullElements(array, \"MSG\");\n             fail(\"Expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {\n+        } catch (final IllegalArgumentException ex) {\n             assertEquals(\"MSG\", ex.getMessage());\n         }\n         \n         array = new String[] {\"a\", \"b\"};\n-        String[] test = Validate.noNullElements(array, \"Message\");\n+        final String[] test = Validate.noNullElements(array, \"Message\");\n         assertSame(array, test);\n     }\n \n     //-----------------------------------------------------------------------\n     @Test\n     public void testNoNullElementsCollection1() {\n-        List<String> coll = new ArrayList<String>();\n+        final List<String> coll = new ArrayList<String>();\n         coll.add(\"a\");\n         coll.add(\"b\");\n         Validate.noNullElements(coll);\n         try {\n             Validate.noNullElements((Collection<?>) null);\n             fail(\"Expecting NullPointerException\");\n-        } catch (NullPointerException ex) {\n+        } catch (final NullPointerException ex) {\n             assertEquals(\"The validated object is null\", ex.getMessage());\n         }\n         coll.set(1, null);\n         try {\n             Validate.noNullElements(coll);\n             fail(\"Expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {\n+        } catch (final IllegalArgumentException ex) {\n             assertEquals(\"The validated collection contains null element at index: 1\", ex.getMessage());\n         }\n         \n         coll.set(1, \"b\");\n-        List<String> test = Validate.noNullElements(coll);\n+        final List<String> test = Validate.noNullElements(coll);\n         assertSame(coll, test);\n     }\n \n     //-----------------------------------------------------------------------\n     @Test\n     public void testNoNullElementsCollection2() {\n-        List<String> coll = new ArrayList<String>();\n+        final List<String> coll = new ArrayList<String>();\n         coll.add(\"a\");\n         coll.add(\"b\");\n         Validate.noNullElements(coll, \"MSG\");\n         try {\n             Validate.noNullElements((Collection<?>) null, \"MSG\");\n             fail(\"Expecting NullPointerException\");\n-        } catch (NullPointerException ex) {\n+        } catch (final NullPointerException ex) {\n             assertEquals(\"The validated object is null\", ex.getMessage());\n         }\n         coll.set(1, null);\n         try {\n             Validate.noNullElements(coll, \"MSG\");\n             fail(\"Expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {\n+        } catch (final IllegalArgumentException ex) {\n             assertEquals(\"MSG\", ex.getMessage());\n         }\n         \n         coll.set(1, \"b\");\n-        List<String> test = Validate.noNullElements(coll, \"Message\");\n+        final List<String> test = Validate.noNullElements(coll, \"Message\");\n         assertSame(coll, test);\n     }\n \n     @Test\n     public void testConstructor() {\n         assertNotNull(new Validate());\n-        Constructor<?>[] cons = Validate.class.getDeclaredConstructors();\n+        final Constructor<?>[] cons = Validate.class.getDeclaredConstructors();\n         assertEquals(1, cons.length);\n         assertTrue(Modifier.isPublic(cons[0].getModifiers()));\n         assertTrue(Modifier.isPublic(Validate.class.getModifiers()));\n     //-----------------------------------------------------------------------\n     @Test\n     public void testValidIndex_withMessage_array() {\n-        Object[] array = new Object[2];\n+        final Object[] array = new Object[2];\n         Validate.validIndex(array, 0, \"Broken: \");\n         Validate.validIndex(array, 1, \"Broken: \");\n         try {\n             Validate.validIndex(array, -1, \"Broken: \");\n             fail(\"Expecting IndexOutOfBoundsException\");\n-        } catch (IndexOutOfBoundsException ex) {\n+        } catch (final IndexOutOfBoundsException ex) {\n             assertEquals(\"Broken: \", ex.getMessage());\n         }\n         try {\n             Validate.validIndex(array, 2, \"Broken: \");\n             fail(\"Expecting IndexOutOfBoundsException\");\n-        } catch (IndexOutOfBoundsException ex) {\n+        } catch (final IndexOutOfBoundsException ex) {\n             assertEquals(\"Broken: \", ex.getMessage());\n         }\n         \n-        String[] strArray = new String[] {\"Hi\"};\n-        String[] test = Validate.noNullElements(strArray, \"Message\");\n+        final String[] strArray = new String[] {\"Hi\"};\n+        final String[] test = Validate.noNullElements(strArray, \"Message\");\n         assertSame(strArray, test);\n     }\n \n     @Test\n     public void testValidIndex_array() {\n-        Object[] array = new Object[2];\n+        final Object[] array = new Object[2];\n         Validate.validIndex(array, 0);\n         Validate.validIndex(array, 1);\n         try {\n             Validate.validIndex(array, -1);\n             fail(\"Expecting IndexOutOfBoundsException\");\n-        } catch (IndexOutOfBoundsException ex) {\n+        } catch (final IndexOutOfBoundsException ex) {\n             assertEquals(\"The validated array index is invalid: -1\", ex.getMessage());\n         }\n         try {\n             Validate.validIndex(array, 2);\n             fail(\"Expecting IndexOutOfBoundsException\");\n-        } catch (IndexOutOfBoundsException ex) {\n+        } catch (final IndexOutOfBoundsException ex) {\n             assertEquals(\"The validated array index is invalid: 2\", ex.getMessage());\n         }\n         \n-        String[] strArray = new String[] {\"Hi\"};\n-        String[] test = Validate.noNullElements(strArray);\n+        final String[] strArray = new String[] {\"Hi\"};\n+        final String[] test = Validate.noNullElements(strArray);\n         assertSame(strArray, test);\n     }\n \n     //-----------------------------------------------------------------------\n     @Test\n     public void testValidIndex_withMessage_collection() {\n-        Collection<String> coll = new ArrayList<String>();\n+        final Collection<String> coll = new ArrayList<String>();\n         coll.add(null);\n         coll.add(null);\n         Validate.validIndex(coll, 0, \"Broken: \");\n         try {\n             Validate.validIndex(coll, -1, \"Broken: \");\n             fail(\"Expecting IndexOutOfBoundsException\");\n-        } catch (IndexOutOfBoundsException ex) {\n+        } catch (final IndexOutOfBoundsException ex) {\n             assertEquals(\"Broken: \", ex.getMessage());\n         }\n         try {\n             Validate.validIndex(coll, 2, \"Broken: \");\n             fail(\"Expecting IndexOutOfBoundsException\");\n-        } catch (IndexOutOfBoundsException ex) {\n+        } catch (final IndexOutOfBoundsException ex) {\n             assertEquals(\"Broken: \", ex.getMessage());\n         }\n         \n-        List<String> strColl = Arrays.asList(new String[] {\"Hi\"});\n-        List<String> test = Validate.validIndex(strColl, 0, \"Message\");\n+        final List<String> strColl = Arrays.asList(new String[] {\"Hi\"});\n+        final List<String> test = Validate.validIndex(strColl, 0, \"Message\");\n         assertSame(strColl, test);\n     }\n \n     @Test\n     public void testValidIndex_collection() {\n-        Collection<String> coll = new ArrayList<String>();\n+        final Collection<String> coll = new ArrayList<String>();\n         coll.add(null);\n         coll.add(null);\n         Validate.validIndex(coll, 0);\n         try {\n             Validate.validIndex(coll, -1);\n             fail(\"Expecting IndexOutOfBoundsException\");\n-        } catch (IndexOutOfBoundsException ex) {\n+        } catch (final IndexOutOfBoundsException ex) {\n             assertEquals(\"The validated collection index is invalid: -1\", ex.getMessage());\n         }\n         try {\n             Validate.validIndex(coll, 2);\n             fail(\"Expecting IndexOutOfBoundsException\");\n-        } catch (IndexOutOfBoundsException ex) {\n+        } catch (final IndexOutOfBoundsException ex) {\n             assertEquals(\"The validated collection index is invalid: 2\", ex.getMessage());\n         }\n         \n-        List<String> strColl = Arrays.asList(new String[] {\"Hi\"});\n-        List<String> test = Validate.validIndex(strColl, 0);\n+        final List<String> strColl = Arrays.asList(new String[] {\"Hi\"});\n+        final List<String> test = Validate.validIndex(strColl, 0);\n         assertSame(strColl, test);\n     }\n \n     //-----------------------------------------------------------------------\n     @Test\n     public void testValidIndex_withMessage_charSequence() {\n-        CharSequence str = \"Hi\";\n+        final CharSequence str = \"Hi\";\n         Validate.validIndex(str, 0, \"Broken: \");\n         Validate.validIndex(str, 1, \"Broken: \");\n         try {\n             Validate.validIndex(str, -1, \"Broken: \");\n             fail(\"Expecting IndexOutOfBoundsException\");\n-        } catch (IndexOutOfBoundsException ex) {\n+        } catch (final IndexOutOfBoundsException ex) {\n             assertEquals(\"Broken: \", ex.getMessage());\n         }\n         try {\n             Validate.validIndex(str, 2, \"Broken: \");\n             fail(\"Expecting IndexOutOfBoundsException\");\n-        } catch (IndexOutOfBoundsException ex) {\n+        } catch (final IndexOutOfBoundsException ex) {\n             assertEquals(\"Broken: \", ex.getMessage());\n         }\n         \n-        String input = \"Hi\";\n-        String test = Validate.validIndex(input, 0, \"Message\");\n+        final String input = \"Hi\";\n+        final String test = Validate.validIndex(input, 0, \"Message\");\n         assertSame(input, test);\n     }\n \n     @Test\n     public void testValidIndex_charSequence() {\n-        CharSequence str = \"Hi\";\n+        final CharSequence str = \"Hi\";\n         Validate.validIndex(str, 0);\n         Validate.validIndex(str, 1);\n         try {\n             Validate.validIndex(str, -1);\n             fail(\"Expecting IndexOutOfBoundsException\");\n-        } catch (IndexOutOfBoundsException ex) {\n+        } catch (final IndexOutOfBoundsException ex) {\n             assertEquals(\"The validated character sequence index is invalid: -1\", ex.getMessage());\n         }\n         try {\n             Validate.validIndex(str, 2);\n             fail(\"Expecting IndexOutOfBoundsException\");\n-        } catch (IndexOutOfBoundsException ex) {\n+        } catch (final IndexOutOfBoundsException ex) {\n             assertEquals(\"The validated character sequence index is invalid: 2\", ex.getMessage());\n         }\n         \n-        String input = \"Hi\";\n-        String test = Validate.validIndex(input, 0);\n+        final String input = \"Hi\";\n+        final String test = Validate.validIndex(input, 0);\n         assertSame(input, test);\n     }\n     \n     @Test\n     public void testMatchesPattern()\n     {\n-        CharSequence str = \"hi\";\n+        final CharSequence str = \"hi\";\n         Validate.matchesPattern(str, \"[a-z]*\");\n         try\n         {\n             Validate.matchesPattern(str, \"[0-9]*\");\n             fail(\"Expecting IllegalArgumentException\");\n         }\n-        catch (IllegalArgumentException e)\n+        catch (final IllegalArgumentException e)\n         {\n             assertEquals(\"The string hi does not match the pattern [0-9]*\", e.getMessage());\n         }\n     @Test\n     public void testMatchesPattern_withMessage()\n     {\n-        CharSequence str = \"hi\";\n+        final CharSequence str = \"hi\";\n         Validate.matchesPattern(str, \"[a-z]*\", \"Does not match\");\n         try\n         {\n             Validate.matchesPattern(str, \"[0-9]*\", \"Does not match\");\n             fail(\"Expecting IllegalArgumentException\");\n         }\n-        catch (IllegalArgumentException e)\n+        catch (final IllegalArgumentException e)\n         {\n             assertEquals(\"Does not match\", e.getMessage());\n         }\n         try {\n             Validate.inclusiveBetween(0, 5, 6);\n             fail(\"Expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException e) {\n+        } catch (final IllegalArgumentException e) {\n             assertEquals(\"The value 6 is not in the specified inclusive range of 0 to 5\", e.getMessage());\n         }\n     }\n         try {\n             Validate.inclusiveBetween(0, 5, 6, \"Error\");\n             fail(\"Expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException e) {\n+        } catch (final IllegalArgumentException e) {\n             assertEquals(\"Error\", e.getMessage());\n         }\n     }\n         try {\n             Validate.exclusiveBetween(0, 5, 6);\n             fail(\"Expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException e) {\n+        } catch (final IllegalArgumentException e) {\n             assertEquals(\"The value 6 is not in the specified exclusive range of 0 to 5\", e.getMessage());\n         }\n         try {\n             Validate.exclusiveBetween(0, 5, 5);\n             fail(\"Expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException e) {\n+        } catch (final IllegalArgumentException e) {\n             assertEquals(\"The value 5 is not in the specified exclusive range of 0 to 5\", e.getMessage());\n         }\n     }\n         try {\n             Validate.exclusiveBetween(0, 5, 6, \"Error\");\n             fail(\"Expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException e) {\n+        } catch (final IllegalArgumentException e) {\n             assertEquals(\"Error\", e.getMessage());\n         }\n         try {\n             Validate.exclusiveBetween(0, 5, 5, \"Error\");\n             fail(\"Expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException e) {\n+        } catch (final IllegalArgumentException e) {\n             assertEquals(\"Error\", e.getMessage());\n         }\n     }\n         try {\n             Validate.isInstanceOf(List.class, \"hi\");\n             fail(\"Expecting IllegalArgumentException\");\n-        } catch(IllegalArgumentException e) {\n+        } catch(final IllegalArgumentException e) {\n             assertEquals(\"Expected type: java.util.List, actual: java.lang.String\", e.getMessage());\n         }\n     }\n         try {\n             Validate.isInstanceOf(List.class, \"hi\", \"Error\");\n             fail(\"Expecting IllegalArgumentException\");\n-        } catch(IllegalArgumentException e) {\n+        } catch(final IllegalArgumentException e) {\n             assertEquals(\"Error\", e.getMessage());\n         }\n     }\n         try {\n             Validate.isAssignableFrom(List.class, String.class);\n             fail(\"Expecting IllegalArgumentException\");\n-        } catch(IllegalArgumentException e) {\n+        } catch(final IllegalArgumentException e) {\n             assertEquals(\"Cannot assign a java.lang.String to a java.util.List\", e.getMessage());\n         }\n     }\n         try {\n             Validate.isAssignableFrom(List.class, String.class, \"Error\");\n             fail(\"Expecting IllegalArgumentException\");\n-        } catch(IllegalArgumentException e) {\n+        } catch(final IllegalArgumentException e) {\n             assertEquals(\"Error\", e.getMessage());\n         }\n     }\n--- a/src/test/java/org/apache/commons/lang3/builder/CompareToBuilderTest.java\n+++ b/src/test/java/org/apache/commons/lang3/builder/CompareToBuilderTest.java\n             if (!(o instanceof TestObject)) {\n                 return false;\n             }\n-            TestObject rhs = (TestObject) o;\n+            final TestObject rhs = (TestObject) o;\n             return a == rhs.a;\n         }\n \n             if (!(o instanceof TestSubObject)) {\n                 return false;\n             }\n-            TestSubObject rhs = (TestSubObject) o;\n+            final TestSubObject rhs = (TestSubObject) o;\n             return super.equals(o) && b == rhs.b;\n         }\n     }\n     \n     @Test\n     public void testReflectionCompare() {\n-        TestObject o1 = new TestObject(4);\n-        TestObject o2 = new TestObject(4);\n+        final TestObject o1 = new TestObject(4);\n+        final TestObject o2 = new TestObject(4);\n         assertTrue(CompareToBuilder.reflectionCompare(o1, o1) == 0);\n         assertTrue(CompareToBuilder.reflectionCompare(o1, o2) == 0);\n         o2.setA(5);\n \n     @Test(expected=NullPointerException.class)\n     public void testReflectionCompareEx1() {\n-        TestObject o1 = new TestObject(4);\n+        final TestObject o1 = new TestObject(4);\n         CompareToBuilder.reflectionCompare(o1, null);\n     }\n \n     @Test(expected=ClassCastException.class)\n     public void testReflectionCompareEx2() {\n-        TestObject o1 = new TestObject(4);\n-        Object o2 = new Object();\n+        final TestObject o1 = new TestObject(4);\n+        final Object o2 = new Object();\n         CompareToBuilder.reflectionCompare(o1, o2);\n     }\n \n     \n     @Test\n     public void testReflectionHierarchyCompareExcludeFields() {\n-        String[] excludeFields = new String[] { \"b\" };\n+        final String[] excludeFields = new String[] { \"b\" };\n         testReflectionHierarchyCompare(true, excludeFields);\n         \n         TestSubObject x;\n     }\n     \n     private void testReflectionHierarchyCompare(final boolean testTransients, final String[] excludeFields) {\n-        TestObject to1 = new TestObject(1);\n-        TestObject to2 = new TestObject(2);\n-        TestObject to3 = new TestObject(3);\n-        TestSubObject tso1 = new TestSubObject(1, 1);\n-        TestSubObject tso2 = new TestSubObject(2, 2);\n-        TestSubObject tso3 = new TestSubObject(3, 3);\n+        final TestObject to1 = new TestObject(1);\n+        final TestObject to2 = new TestObject(2);\n+        final TestObject to3 = new TestObject(3);\n+        final TestSubObject tso1 = new TestSubObject(1, 1);\n+        final TestSubObject tso2 = new TestSubObject(2, 2);\n+        final TestSubObject tso3 = new TestSubObject(3, 3);\n         \n         assertReflectionCompareContract(to1, to1, to1, false, excludeFields);\n         assertReflectionCompareContract(to1, to2, to3, false, excludeFields);\n     \n     @Test\n     public void testAppendSuper() {\n-        TestObject o1 = new TestObject(4);\n-        TestObject o2 = new TestObject(5);\n+        final TestObject o1 = new TestObject(4);\n+        final TestObject o2 = new TestObject(5);\n         assertTrue(new CompareToBuilder().appendSuper(0).append(o1, o1).toComparison() == 0);\n         assertTrue(new CompareToBuilder().appendSuper(0).append(o1, o2).toComparison() < 0);\n         assertTrue(new CompareToBuilder().appendSuper(0).append(o2, o1).toComparison() > 0);\n     \n     @Test\n     public void testObject() {\n-        TestObject o1 = new TestObject(4);\n-        TestObject o2 = new TestObject(4);\n+        final TestObject o1 = new TestObject(4);\n+        final TestObject o2 = new TestObject(4);\n         assertTrue(new CompareToBuilder().append(o1, o1).toComparison() == 0);\n         assertTrue(new CompareToBuilder().append(o1, o2).toComparison() == 0);\n         o2.setA(5);\n     \n     @Test\n     public void testObjectBuild() {\n-        TestObject o1 = new TestObject(4);\n-        TestObject o2 = new TestObject(4);\n+        final TestObject o1 = new TestObject(4);\n+        final TestObject o2 = new TestObject(4);\n         assertEquals(Integer.valueOf(0), new CompareToBuilder().append(o1, o1).build());\n         assertEquals(Integer.valueOf(0), new CompareToBuilder().append(o1, o2).build());\n         o2.setA(5);\n \n     @Test(expected=ClassCastException.class)\n     public void testObjectEx2() {\n-        TestObject o1 = new TestObject(4);\n-        Object o2 = new Object();\n+        final TestObject o1 = new TestObject(4);\n+        final Object o2 = new Object();\n         new CompareToBuilder().append(o1, o2);\n     }\n \n     @Test\n     public void testObjectComparator() {\n-        String o1 = \"Fred\";\n+        final String o1 = \"Fred\";\n         String o2 = \"Fred\";\n         assertTrue(new CompareToBuilder().append(o1, o1, String.CASE_INSENSITIVE_ORDER).toComparison() == 0);\n         assertTrue(new CompareToBuilder().append(o1, o2, String.CASE_INSENSITIVE_ORDER).toComparison() == 0);\n     \n     @Test\n     public void testObjectComparatorNull() {\n-        String o1 = \"Fred\";\n+        final String o1 = \"Fred\";\n         String o2 = \"Fred\";\n         assertTrue(new CompareToBuilder().append(o1, o1, null).toComparison() == 0);\n         assertTrue(new CompareToBuilder().append(o1, o2, null).toComparison() == 0);\n \n     @Test\n     public void testLong() {\n-        long o1 = 1L;\n-        long o2 = 2L;\n+        final long o1 = 1L;\n+        final long o2 = 2L;\n         assertTrue(new CompareToBuilder().append(o1, o1).toComparison() == 0);\n         assertTrue(new CompareToBuilder().append(o1, o2).toComparison() < 0);\n         assertTrue(new CompareToBuilder().append(o2, o1).toComparison() > 0);\n \n     @Test\n     public void testInt() {\n-        int o1 = 1;\n-        int o2 = 2;\n+        final int o1 = 1;\n+        final int o2 = 2;\n         assertTrue(new CompareToBuilder().append(o1, o1).toComparison() == 0);\n         assertTrue(new CompareToBuilder().append(o1, o2).toComparison() < 0);\n         assertTrue(new CompareToBuilder().append(o2, o1).toComparison() > 0);\n \n     @Test\n     public void testShort() {\n-        short o1 = 1;\n-        short o2 = 2;\n+        final short o1 = 1;\n+        final short o2 = 2;\n         assertTrue(new CompareToBuilder().append(o1, o1).toComparison() == 0);\n         assertTrue(new CompareToBuilder().append(o1, o2).toComparison() < 0);\n         assertTrue(new CompareToBuilder().append(o2, o1).toComparison() > 0);\n \n     @Test\n     public void testChar() {\n-        char o1 = 1;\n-        char o2 = 2;\n+        final char o1 = 1;\n+        final char o2 = 2;\n         assertTrue(new CompareToBuilder().append(o1, o1).toComparison() == 0);\n         assertTrue(new CompareToBuilder().append(o1, o2).toComparison() < 0);\n         assertTrue(new CompareToBuilder().append(o2, o1).toComparison() > 0);\n \n     @Test\n     public void testByte() {\n-        byte o1 = 1;\n-        byte o2 = 2;\n+        final byte o1 = 1;\n+        final byte o2 = 2;\n         assertTrue(new CompareToBuilder().append(o1, o1).toComparison() == 0);\n         assertTrue(new CompareToBuilder().append(o1, o2).toComparison() < 0);\n         assertTrue(new CompareToBuilder().append(o2, o1).toComparison() > 0);\n \n     @Test\n     public void testDouble() {\n-        double o1 = 1;\n-        double o2 = 2;\n+        final double o1 = 1;\n+        final double o2 = 2;\n         assertTrue(new CompareToBuilder().append(o1, o1).toComparison() == 0);\n         assertTrue(new CompareToBuilder().append(o1, o2).toComparison() < 0);\n         assertTrue(new CompareToBuilder().append(o2, o1).toComparison() > 0);\n \n     @Test\n     public void testFloat() {\n-        float o1 = 1;\n-        float o2 = 2;\n+        final float o1 = 1;\n+        final float o2 = 2;\n         assertTrue(new CompareToBuilder().append(o1, o1).toComparison() == 0);\n         assertTrue(new CompareToBuilder().append(o1, o2).toComparison() < 0);\n         assertTrue(new CompareToBuilder().append(o2, o1).toComparison() > 0);\n \n     @Test\n     public void testBoolean() {\n-        boolean o1 = true;\n-        boolean o2 = false;\n+        final boolean o1 = true;\n+        final boolean o2 = false;\n         assertTrue(new CompareToBuilder().append(o1, o1).toComparison() == 0);\n         assertTrue(new CompareToBuilder().append(o2, o2).toComparison() == 0);\n         assertTrue(new CompareToBuilder().append(o1, o2).toComparison() > 0);\n \n     @Test\n     public void testObjectArray() {\n-        TestObject[] obj1 = new TestObject[2];\n+        final TestObject[] obj1 = new TestObject[2];\n         obj1[0] = new TestObject(4);\n         obj1[1] = new TestObject(5);\n-        TestObject[] obj2 = new TestObject[2];\n+        final TestObject[] obj2 = new TestObject[2];\n         obj2[0] = new TestObject(4);\n         obj2[1] = new TestObject(5);\n-        TestObject[] obj3 = new TestObject[3];\n+        final TestObject[] obj3 = new TestObject[3];\n         obj3[0] = new TestObject(4);\n         obj3[1] = new TestObject(5);\n         obj3[2] = new TestObject(6);\n \n     @Test\n     public void testLongArray() {\n-        long[] obj1 = new long[2];\n+        final long[] obj1 = new long[2];\n         obj1[0] = 5L;\n         obj1[1] = 6L;\n-        long[] obj2 = new long[2];\n+        final long[] obj2 = new long[2];\n         obj2[0] = 5L;\n         obj2[1] = 6L;\n-        long[] obj3 = new long[3];\n+        final long[] obj3 = new long[3];\n         obj3[0] = 5L;\n         obj3[1] = 6L;\n         obj3[2] = 7L;\n \n     @Test\n     public void testIntArray() {\n-        int[] obj1 = new int[2];\n+        final int[] obj1 = new int[2];\n         obj1[0] = 5;\n         obj1[1] = 6;\n-        int[] obj2 = new int[2];\n+        final int[] obj2 = new int[2];\n         obj2[0] = 5;\n         obj2[1] = 6;\n-        int[] obj3 = new int[3];\n+        final int[] obj3 = new int[3];\n         obj3[0] = 5;\n         obj3[1] = 6;\n         obj3[2] = 7;\n \n     @Test\n     public void testShortArray() {\n-        short[] obj1 = new short[2];\n+        final short[] obj1 = new short[2];\n         obj1[0] = 5;\n         obj1[1] = 6;\n-        short[] obj2 = new short[2];\n+        final short[] obj2 = new short[2];\n         obj2[0] = 5;\n         obj2[1] = 6;\n-        short[] obj3 = new short[3];\n+        final short[] obj3 = new short[3];\n         obj3[0] = 5;\n         obj3[1] = 6;\n         obj3[2] = 7;\n \n     @Test\n     public void testCharArray() {\n-        char[] obj1 = new char[2];\n+        final char[] obj1 = new char[2];\n         obj1[0] = 5;\n         obj1[1] = 6;\n-        char[] obj2 = new char[2];\n+        final char[] obj2 = new char[2];\n         obj2[0] = 5;\n         obj2[1] = 6;\n-        char[] obj3 = new char[3];\n+        final char[] obj3 = new char[3];\n         obj3[0] = 5;\n         obj3[1] = 6;\n         obj3[2] = 7;\n \n     @Test\n     public void testByteArray() {\n-        byte[] obj1 = new byte[2];\n+        final byte[] obj1 = new byte[2];\n         obj1[0] = 5;\n         obj1[1] = 6;\n-        byte[] obj2 = new byte[2];\n+        final byte[] obj2 = new byte[2];\n         obj2[0] = 5;\n         obj2[1] = 6;\n-        byte[] obj3 = new byte[3];\n+        final byte[] obj3 = new byte[3];\n         obj3[0] = 5;\n         obj3[1] = 6;\n         obj3[2] = 7;\n \n     @Test\n     public void testDoubleArray() {\n-        double[] obj1 = new double[2];\n+        final double[] obj1 = new double[2];\n         obj1[0] = 5;\n         obj1[1] = 6;\n-        double[] obj2 = new double[2];\n+        final double[] obj2 = new double[2];\n         obj2[0] = 5;\n         obj2[1] = 6;\n-        double[] obj3 = new double[3];\n+        final double[] obj3 = new double[3];\n         obj3[0] = 5;\n         obj3[1] = 6;\n         obj3[2] = 7;\n \n     @Test\n     public void testFloatArray() {\n-        float[] obj1 = new float[2];\n+        final float[] obj1 = new float[2];\n         obj1[0] = 5;\n         obj1[1] = 6;\n-        float[] obj2 = new float[2];\n+        final float[] obj2 = new float[2];\n         obj2[0] = 5;\n         obj2[1] = 6;\n-        float[] obj3 = new float[3];\n+        final float[] obj3 = new float[3];\n         obj3[0] = 5;\n         obj3[1] = 6;\n         obj3[2] = 7;\n \n     @Test\n     public void testBooleanArray() {\n-        boolean[] obj1 = new boolean[2];\n+        final boolean[] obj1 = new boolean[2];\n         obj1[0] = true;\n         obj1[1] = false;\n-        boolean[] obj2 = new boolean[2];\n+        final boolean[] obj2 = new boolean[2];\n         obj2[0] = true;\n         obj2[1] = false;\n-        boolean[] obj3 = new boolean[3];\n+        final boolean[] obj3 = new boolean[3];\n         obj3[0] = true;\n         obj3[1] = false;\n         obj3[2] = true;\n \n     @Test\n     public void testMultiLongArray() {\n-        long[][] array1 = new long[2][2];\n-        long[][] array2 = new long[2][2];\n-        long[][] array3 = new long[2][3];\n+        final long[][] array1 = new long[2][2];\n+        final long[][] array2 = new long[2][2];\n+        final long[][] array3 = new long[2][3];\n         for (int i = 0; i < array1.length; ++i) {\n             for (int j = 0; j < array1[0].length; j++) {\n                 array1[i][j] = (i + 1) * (j + 1);\n \n     @Test\n     public void testMultiIntArray() {\n-        int[][] array1 = new int[2][2];\n-        int[][] array2 = new int[2][2];\n-        int[][] array3 = new int[2][3];\n+        final int[][] array1 = new int[2][2];\n+        final int[][] array2 = new int[2][2];\n+        final int[][] array3 = new int[2][3];\n         for (int i = 0; i < array1.length; ++i) {\n             for (int j = 0; j < array1[0].length; j++) {\n                 array1[i][j] = (i + 1) * (j + 1);\n \n     @Test\n     public void testMultiShortArray() {\n-        short[][] array1 = new short[2][2];\n-        short[][] array2 = new short[2][2];\n-        short[][] array3 = new short[2][3];\n+        final short[][] array1 = new short[2][2];\n+        final short[][] array2 = new short[2][2];\n+        final short[][] array3 = new short[2][3];\n         for (short i = 0; i < array1.length; ++i) {\n             for (short j = 0; j < array1[0].length; j++) {\n                 array1[i][j] = (short)((i + 1) * (j + 1));\n \n     @Test\n     public void testMultiCharArray() {\n-        char[][] array1 = new char[2][2];\n-        char[][] array2 = new char[2][2];\n-        char[][] array3 = new char[2][3];\n+        final char[][] array1 = new char[2][2];\n+        final char[][] array2 = new char[2][2];\n+        final char[][] array3 = new char[2][3];\n         for (short i = 0; i < array1.length; ++i) {\n             for (short j = 0; j < array1[0].length; j++) {\n                 array1[i][j] = (char)((i + 1) * (j + 1));\n \n     @Test\n     public void testMultiByteArray() {\n-        byte[][] array1 = new byte[2][2];\n-        byte[][] array2 = new byte[2][2];\n-        byte[][] array3 = new byte[2][3];\n+        final byte[][] array1 = new byte[2][2];\n+        final byte[][] array2 = new byte[2][2];\n+        final byte[][] array3 = new byte[2][3];\n         for (byte i = 0; i < array1.length; ++i) {\n             for (byte j = 0; j < array1[0].length; j++) {\n                 array1[i][j] = (byte)((i + 1) * (j + 1));\n     \n     @Test\n     public void testMultiFloatArray() {\n-        float[][] array1 = new float[2][2];\n-        float[][] array2 = new float[2][2];\n-        float[][] array3 = new float[2][3];\n+        final float[][] array1 = new float[2][2];\n+        final float[][] array2 = new float[2][2];\n+        final float[][] array3 = new float[2][3];\n         for (int i = 0; i < array1.length; ++i) {\n             for (int j = 0; j < array1[0].length; j++) {\n                 array1[i][j] = (i + 1) * (j + 1);\n \n     @Test\n     public void testMultiDoubleArray() {\n-        double[][] array1 = new double[2][2];\n-        double[][] array2 = new double[2][2];\n-        double[][] array3 = new double[2][3];\n+        final double[][] array1 = new double[2][2];\n+        final double[][] array2 = new double[2][2];\n+        final double[][] array3 = new double[2][3];\n         for (int i = 0; i < array1.length; ++i) {\n             for (int j = 0; j < array1[0].length; j++) {\n                 array1[i][j] = (i + 1) * (j + 1);\n \n     @Test\n     public void testMultiBooleanArray() {\n-        boolean[][] array1 = new boolean[2][2];\n-        boolean[][] array2 = new boolean[2][2];\n-        boolean[][] array3 = new boolean[2][3];\n+        final boolean[][] array1 = new boolean[2][2];\n+        final boolean[][] array2 = new boolean[2][2];\n+        final boolean[][] array3 = new boolean[2][3];\n         for (int i = 0; i < array1.length; ++i) {\n             for (int j = 0; j < array1[0].length; j++) {\n                 array1[i][j] = i == 1 ^ j == 1;\n \n     @Test\n     public void testRaggedArray() {\n-        long array1[][] = new long[2][];\n-        long array2[][] = new long[2][];\n-        long array3[][] = new long[3][];\n+        final long array1[][] = new long[2][];\n+        final long array2[][] = new long[2][];\n+        final long array3[][] = new long[3][];\n         for (int i = 0; i < array1.length; ++i) {\n             array1[i] = new long[2];\n             array2[i] = new long[2];\n \n     @Test\n     public void testMixedArray() {\n-        Object array1[] = new Object[2];\n-        Object array2[] = new Object[2];\n-        Object array3[] = new Object[2];\n+        final Object array1[] = new Object[2];\n+        final Object array2[] = new Object[2];\n+        final Object array3[] = new Object[2];\n         for (int i = 0; i < array1.length; ++i) {\n             array1[i] = new long[2];\n             array2[i] = new long[2];\n \n     @Test\n     public void testObjectArrayHiddenByObject() {\n-        TestObject[] array1 = new TestObject[2];\n+        final TestObject[] array1 = new TestObject[2];\n         array1[0] = new TestObject(4);\n         array1[1] = new TestObject(5);\n-        TestObject[] array2 = new TestObject[2];\n+        final TestObject[] array2 = new TestObject[2];\n         array2[0] = new TestObject(4);\n         array2[1] = new TestObject(5);\n-        TestObject[] array3 = new TestObject[3];\n+        final TestObject[] array3 = new TestObject[3];\n         array3[0] = new TestObject(4);\n         array3[1] = new TestObject(5);\n         array3[2] = new TestObject(6);\n         \n-        Object obj1 = array1;\n-        Object obj2 = array2;\n-        Object obj3 = array3;\n+        final Object obj1 = array1;\n+        final Object obj2 = array2;\n+        final Object obj3 = array3;\n         \n         assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0);\n         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0);\n \n     @Test\n     public void testLongArrayHiddenByObject() {\n-        long[] array1 = new long[2];\n+        final long[] array1 = new long[2];\n         array1[0] = 5L;\n         array1[1] = 6L;\n-        long[] array2 = new long[2];\n+        final long[] array2 = new long[2];\n         array2[0] = 5L;\n         array2[1] = 6L;\n-        long[] array3 = new long[3];\n+        final long[] array3 = new long[3];\n         array3[0] = 5L;\n         array3[1] = 6L;\n         array3[2] = 7L;\n-        Object obj1 = array1;\n-        Object obj2 = array2;\n-        Object obj3 = array3;\n+        final Object obj1 = array1;\n+        final Object obj2 = array2;\n+        final Object obj3 = array3;\n         assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0);\n         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0);\n         assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0);\n \n     @Test\n     public void testIntArrayHiddenByObject() {\n-        int[] array1 = new int[2];\n+        final int[] array1 = new int[2];\n         array1[0] = 5;\n         array1[1] = 6;\n-        int[] array2 = new int[2];\n+        final int[] array2 = new int[2];\n         array2[0] = 5;\n         array2[1] = 6;\n-        int[] array3 = new int[3];\n+        final int[] array3 = new int[3];\n         array3[0] = 5;\n         array3[1] = 6;\n         array3[2] = 7;\n-        Object obj1 = array1;\n-        Object obj2 = array2;\n-        Object obj3 = array3;\n+        final Object obj1 = array1;\n+        final Object obj2 = array2;\n+        final Object obj3 = array3;\n         assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0);\n         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0);\n         assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0);\n \n     @Test\n     public void testShortArrayHiddenByObject() {\n-        short[] array1 = new short[2];\n+        final short[] array1 = new short[2];\n         array1[0] = 5;\n         array1[1] = 6;\n-        short[] array2 = new short[2];\n+        final short[] array2 = new short[2];\n         array2[0] = 5;\n         array2[1] = 6;\n-        short[] array3 = new short[3];\n+        final short[] array3 = new short[3];\n         array3[0] = 5;\n         array3[1] = 6;\n         array3[2] = 7;\n-        Object obj1 = array1;\n-        Object obj2 = array2;\n-        Object obj3 = array3;\n+        final Object obj1 = array1;\n+        final Object obj2 = array2;\n+        final Object obj3 = array3;\n         assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0);\n         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0);\n         assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0);\n \n     @Test\n     public void testCharArrayHiddenByObject() {\n-        char[] array1 = new char[2];\n+        final char[] array1 = new char[2];\n         array1[0] = 5;\n         array1[1] = 6;\n-        char[] array2 = new char[2];\n+        final char[] array2 = new char[2];\n         array2[0] = 5;\n         array2[1] = 6;\n-        char[] array3 = new char[3];\n+        final char[] array3 = new char[3];\n         array3[0] = 5;\n         array3[1] = 6;\n         array3[2] = 7;\n-        Object obj1 = array1;\n-        Object obj2 = array2;\n-        Object obj3 = array3;\n+        final Object obj1 = array1;\n+        final Object obj2 = array2;\n+        final Object obj3 = array3;\n         assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0);\n         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0);\n         assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0);\n \n     @Test\n     public void testByteArrayHiddenByObject() {\n-        byte[] array1 = new byte[2];\n+        final byte[] array1 = new byte[2];\n         array1[0] = 5;\n         array1[1] = 6;\n-        byte[] array2 = new byte[2];\n+        final byte[] array2 = new byte[2];\n         array2[0] = 5;\n         array2[1] = 6;\n-        byte[] array3 = new byte[3];\n+        final byte[] array3 = new byte[3];\n         array3[0] = 5;\n         array3[1] = 6;\n         array3[2] = 7;\n-        Object obj1 = array1;\n-        Object obj2 = array2;\n-        Object obj3 = array3;\n+        final Object obj1 = array1;\n+        final Object obj2 = array2;\n+        final Object obj3 = array3;\n         assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0);\n         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0);\n         assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0);\n \n     @Test\n     public void testDoubleArrayHiddenByObject() {\n-        double[] array1 = new double[2];\n+        final double[] array1 = new double[2];\n         array1[0] = 5;\n         array1[1] = 6;\n-        double[] array2 = new double[2];\n+        final double[] array2 = new double[2];\n         array2[0] = 5;\n         array2[1] = 6;\n-        double[] array3 = new double[3];\n+        final double[] array3 = new double[3];\n         array3[0] = 5;\n         array3[1] = 6;\n         array3[2] = 7;\n-        Object obj1 = array1;\n-        Object obj2 = array2;\n-        Object obj3 = array3;\n+        final Object obj1 = array1;\n+        final Object obj2 = array2;\n+        final Object obj3 = array3;\n         assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0);\n         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0);\n         assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0);\n \n     @Test\n     public void testFloatArrayHiddenByObject() {\n-        float[] array1 = new float[2];\n+        final float[] array1 = new float[2];\n         array1[0] = 5;\n         array1[1] = 6;\n-        float[] array2 = new float[2];\n+        final float[] array2 = new float[2];\n         array2[0] = 5;\n         array2[1] = 6;\n-        float[] array3 = new float[3];\n+        final float[] array3 = new float[3];\n         array3[0] = 5;\n         array3[1] = 6;\n         array3[2] = 7;\n-        Object obj1 = array1;\n-        Object obj2 = array2;\n-        Object obj3 = array3;\n+        final Object obj1 = array1;\n+        final Object obj2 = array2;\n+        final Object obj3 = array3;\n         assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0);\n         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0);\n         assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0);\n \n     @Test\n     public void testBooleanArrayHiddenByObject() {\n-        boolean[] array1 = new boolean[2];\n+        final boolean[] array1 = new boolean[2];\n         array1[0] = true;\n         array1[1] = false;\n-        boolean[] array2 = new boolean[2];\n+        final boolean[] array2 = new boolean[2];\n         array2[0] = true;\n         array2[1] = false;\n-        boolean[] array3 = new boolean[3];\n+        final boolean[] array3 = new boolean[3];\n         array3[0] = true;\n         array3[1] = false;\n         array3[2] = true;\n-        Object obj1 = array1;\n-        Object obj2 = array2;\n-        Object obj3 = array3;\n+        final Object obj1 = array1;\n+        final Object obj2 = array2;\n+        final Object obj3 = array3;\n         assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0);\n         assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0);\n         assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0);\n--- a/src/test/java/org/apache/commons/lang3/builder/DefaultToStringStyleTest.java\n+++ b/src/test/java/org/apache/commons/lang3/builder/DefaultToStringStyleTest.java\n     \n     @Test\n     public void testObject() {\n-        Integer i3 = Integer.valueOf(3);\n-        Integer i4 = Integer.valueOf(4);\n+        final Integer i3 = Integer.valueOf(3);\n+        final Integer i4 = Integer.valueOf(4);\n         assertEquals(baseStr + \"[<null>]\", new ToStringBuilder(base).append((Object) null).toString());\n         assertEquals(baseStr + \"[3]\", new ToStringBuilder(base).append(i3).toString());\n         assertEquals(baseStr + \"[a=<null>]\", new ToStringBuilder(base).append(\"a\", (Object) null).toString());\n \n     @Test\n     public void testPerson() {\n-        Person p = new Person();\n+        final Person p = new Person();\n         p.name = \"John Doe\";\n         p.age = 33;\n         p.smoker = false;\n-        String pBaseStr = p.getClass().getName() + \"@\" + Integer.toHexString(System.identityHashCode(p));\n+        final String pBaseStr = p.getClass().getName() + \"@\" + Integer.toHexString(System.identityHashCode(p));\n         assertEquals(pBaseStr + \"[name=John Doe,age=33,smoker=false]\", new ToStringBuilder(p).append(\"name\", p.name).append(\"age\", p.age).append(\"smoker\", p.smoker).toString());\n     }\n \n--- a/src/test/java/org/apache/commons/lang3/builder/EqualsBuilderTest.java\n+++ b/src/test/java/org/apache/commons/lang3/builder/EqualsBuilderTest.java\n                 return false;\n             }\n \n-            TestObject rhs = (TestObject) o;\n+            final TestObject rhs = (TestObject) o;\n             return a == rhs.a;\n         }\n \n                 return false;\n             }\n \n-            TestSubObject rhs = (TestSubObject) o;\n+            final TestSubObject rhs = (TestSubObject) o;\n             return super.equals(o) && b == rhs.b;\n         }\n \n \n     @Test\n     public void testReflectionEquals() {\n-        TestObject o1 = new TestObject(4);\n-        TestObject o2 = new TestObject(5);\n+        final TestObject o1 = new TestObject(4);\n+        final TestObject o2 = new TestObject(5);\n         assertTrue(EqualsBuilder.reflectionEquals(o1, o1));\n         assertTrue(!EqualsBuilder.reflectionEquals(o1, o2));\n         o2.setA(4);\n     }\n \n     private void testReflectionHierarchyEquals(final boolean testTransients) {\n-        TestObject to1 = new TestObject(4);\n-        TestObject to1Bis = new TestObject(4);\n-        TestObject to1Ter = new TestObject(4);\n-        TestObject to2 = new TestObject(5);\n-        TestEmptySubObject teso = new TestEmptySubObject(4);\n-        TestTSubObject ttso = new TestTSubObject(4, 1);\n-        TestTTSubObject tttso = new TestTTSubObject(4, 1, 2);\n-        TestTTLeafObject ttlo = new TestTTLeafObject(4, 1, 2, 3);\n-        TestSubObject tso1 = new TestSubObject(1, 4);\n-        TestSubObject tso1bis = new TestSubObject(1, 4);\n-        TestSubObject tso1ter = new TestSubObject(1, 4);\n-        TestSubObject tso2 = new TestSubObject(2, 5);\n+        final TestObject to1 = new TestObject(4);\n+        final TestObject to1Bis = new TestObject(4);\n+        final TestObject to1Ter = new TestObject(4);\n+        final TestObject to2 = new TestObject(5);\n+        final TestEmptySubObject teso = new TestEmptySubObject(4);\n+        final TestTSubObject ttso = new TestTSubObject(4, 1);\n+        final TestTTSubObject tttso = new TestTTSubObject(4, 1, 2);\n+        final TestTTLeafObject ttlo = new TestTTLeafObject(4, 1, 2, 3);\n+        final TestSubObject tso1 = new TestSubObject(1, 4);\n+        final TestSubObject tso1bis = new TestSubObject(1, 4);\n+        final TestSubObject tso1ter = new TestSubObject(1, 4);\n+        final TestSubObject tso2 = new TestSubObject(2, 5);\n \n         testReflectionEqualsEquivalenceRelationship(to1, to1Bis, to1Ter, to2, new TestObject(), testTransients);\n         testReflectionEqualsEquivalenceRelationship(tso1, tso1bis, tso1ter, tso2, new TestSubObject(), testTransients);\n \n     @Test\n     public void testSuper() {\n-        TestObject o1 = new TestObject(4);\n-        TestObject o2 = new TestObject(5);\n+        final TestObject o1 = new TestObject(4);\n+        final TestObject o2 = new TestObject(5);\n         assertTrue(new EqualsBuilder().appendSuper(true).append(o1, o1).isEquals());\n         assertFalse(new EqualsBuilder().appendSuper(false).append(o1, o1).isEquals());\n         assertFalse(new EqualsBuilder().appendSuper(true).append(o1, o2).isEquals());\n \n     @Test\n     public void testObject() {\n-        TestObject o1 = new TestObject(4);\n-        TestObject o2 = new TestObject(5);\n+        final TestObject o1 = new TestObject(4);\n+        final TestObject o2 = new TestObject(5);\n         assertTrue(new EqualsBuilder().append(o1, o1).isEquals());\n         assertTrue(!new EqualsBuilder().append(o1, o2).isEquals());\n         o2.setA(4);\n     \n     @Test\n     public void testObjectBuild() {\n-        TestObject o1 = new TestObject(4);\n-        TestObject o2 = new TestObject(5);\n+        final TestObject o1 = new TestObject(4);\n+        final TestObject o2 = new TestObject(5);\n         assertEquals(Boolean.TRUE, new EqualsBuilder().append(o1, o1).build());\n         assertEquals(Boolean.FALSE, new EqualsBuilder().append(o1, o2).build());\n         o2.setA(4);\n \n     @Test\n     public void testLong() {\n-        long o1 = 1L;\n-        long o2 = 2L;\n+        final long o1 = 1L;\n+        final long o2 = 2L;\n         assertTrue(new EqualsBuilder().append(o1, o1).isEquals());\n         assertTrue(!new EqualsBuilder().append(o1, o2).isEquals());\n     }\n \n     @Test\n     public void testInt() {\n-        int o1 = 1;\n-        int o2 = 2;\n+        final int o1 = 1;\n+        final int o2 = 2;\n         assertTrue(new EqualsBuilder().append(o1, o1).isEquals());\n         assertTrue(!new EqualsBuilder().append(o1, o2).isEquals());\n     }\n \n     @Test\n     public void testShort() {\n-        short o1 = 1;\n-        short o2 = 2;\n+        final short o1 = 1;\n+        final short o2 = 2;\n         assertTrue(new EqualsBuilder().append(o1, o1).isEquals());\n         assertTrue(!new EqualsBuilder().append(o1, o2).isEquals());\n     }\n \n     @Test\n     public void testChar() {\n-        char o1 = 1;\n-        char o2 = 2;\n+        final char o1 = 1;\n+        final char o2 = 2;\n         assertTrue(new EqualsBuilder().append(o1, o1).isEquals());\n         assertTrue(!new EqualsBuilder().append(o1, o2).isEquals());\n     }\n \n     @Test\n     public void testByte() {\n-        byte o1 = 1;\n-        byte o2 = 2;\n+        final byte o1 = 1;\n+        final byte o2 = 2;\n         assertTrue(new EqualsBuilder().append(o1, o1).isEquals());\n         assertTrue(!new EqualsBuilder().append(o1, o2).isEquals());\n     }\n \n     @Test\n     public void testDouble() {\n-        double o1 = 1;\n-        double o2 = 2;\n+        final double o1 = 1;\n+        final double o2 = 2;\n         assertTrue(new EqualsBuilder().append(o1, o1).isEquals());\n         assertTrue(!new EqualsBuilder().append(o1, o2).isEquals());\n         assertTrue(!new EqualsBuilder().append(o1, Double.NaN).isEquals());\n \n     @Test\n     public void testFloat() {\n-        float o1 = 1;\n-        float o2 = 2;\n+        final float o1 = 1;\n+        final float o2 = 2;\n         assertTrue(new EqualsBuilder().append(o1, o1).isEquals());\n         assertTrue(!new EqualsBuilder().append(o1, o2).isEquals());\n         assertTrue(!new EqualsBuilder().append(o1, Float.NaN).isEquals());\n \n     @Test\n     public void testAccessors() {\n-        EqualsBuilder equalsBuilder = new EqualsBuilder();\n+        final EqualsBuilder equalsBuilder = new EqualsBuilder();\n         assertTrue(equalsBuilder.isEquals());\n         equalsBuilder.setEquals(true);\n         assertTrue(equalsBuilder.isEquals());\n \n     @Test\n     public void testReset() {\n-        EqualsBuilder equalsBuilder = new EqualsBuilder();\n+        final EqualsBuilder equalsBuilder = new EqualsBuilder();\n         assertTrue(equalsBuilder.isEquals());\n         equalsBuilder.setEquals(false);\n         assertFalse(equalsBuilder.isEquals());\n     \n     @Test\n     public void testBoolean() {\n-        boolean o1 = true;\n-        boolean o2 = false;\n+        final boolean o1 = true;\n+        final boolean o2 = false;\n         assertTrue(new EqualsBuilder().append(o1, o1).isEquals());\n         assertTrue(!new EqualsBuilder().append(o1, o2).isEquals());\n     }\n \n     @Test\n     public void testMultiLongArray() {\n-        long[][] array1 = new long[2][2];\n-        long[][] array2 = new long[2][2];\n+        final long[][] array1 = new long[2][2];\n+        final long[][] array2 = new long[2][2];\n         for (int i = 0; i < array1.length; ++i) {\n             for (int j = 0; j < array1[0].length; j++) {\n                 array1[i][j] = (i + 1) * (j + 1);\n \n     @Test\n     public void testMultiIntArray() {\n-        int[][] array1 = new int[2][2];\n-        int[][] array2 = new int[2][2];\n+        final int[][] array1 = new int[2][2];\n+        final int[][] array2 = new int[2][2];\n         for (int i = 0; i < array1.length; ++i) {\n             for (int j = 0; j < array1[0].length; j++) {\n                 array1[i][j] = (i + 1) * (j + 1);\n \n     @Test\n     public void testMultiShortArray() {\n-        short[][] array1 = new short[2][2];\n-        short[][] array2 = new short[2][2];\n+        final short[][] array1 = new short[2][2];\n+        final short[][] array2 = new short[2][2];\n         for (short i = 0; i < array1.length; ++i) {\n             for (short j = 0; j < array1[0].length; j++) {\n                 array1[i][j] = i;\n \n     @Test\n     public void testMultiCharArray() {\n-        char[][] array1 = new char[2][2];\n-        char[][] array2 = new char[2][2];\n+        final char[][] array1 = new char[2][2];\n+        final char[][] array2 = new char[2][2];\n         for (char i = 0; i < array1.length; ++i) {\n             for (char j = 0; j < array1[0].length; j++) {\n                 array1[i][j] = i;\n \n     @Test\n     public void testMultiByteArray() {\n-        byte[][] array1 = new byte[2][2];\n-        byte[][] array2 = new byte[2][2];\n+        final byte[][] array1 = new byte[2][2];\n+        final byte[][] array2 = new byte[2][2];\n         for (byte i = 0; i < array1.length; ++i) {\n             for (byte j = 0; j < array1[0].length; j++) {\n                 array1[i][j] = i;\n \n     @Test\n     public void testMultiFloatArray() {\n-        float[][] array1 = new float[2][2];\n-        float[][] array2 = new float[2][2];\n+        final float[][] array1 = new float[2][2];\n+        final float[][] array2 = new float[2][2];\n         for (int i = 0; i < array1.length; ++i) {\n             for (int j = 0; j < array1[0].length; j++) {\n                 array1[i][j] = (i + 1) * (j + 1);\n \n     @Test\n     public void testMultiDoubleArray() {\n-        double[][] array1 = new double[2][2];\n-        double[][] array2 = new double[2][2];\n+        final double[][] array1 = new double[2][2];\n+        final double[][] array2 = new double[2][2];\n         for (int i = 0; i < array1.length; ++i) {\n             for (int j = 0; j < array1[0].length; j++) {\n                 array1[i][j] = (i + 1) * (j + 1);\n \n     @Test\n     public void testMultiBooleanArray() {\n-        boolean[][] array1 = new boolean[2][2];\n-        boolean[][] array2 = new boolean[2][2];\n+        final boolean[][] array1 = new boolean[2][2];\n+        final boolean[][] array2 = new boolean[2][2];\n         for (int i = 0; i < array1.length; ++i) {\n             for (int j = 0; j < array1[0].length; j++) {\n                 array1[i][j] = i == 1 || j == 1;\n         assertTrue(!new EqualsBuilder().append(array1, array2).isEquals());\n         \n         // compare 1 dim to 2.\n-        boolean[] array3 = new boolean[]{true, true};\n+        final boolean[] array3 = new boolean[]{true, true};\n         assertFalse(new EqualsBuilder().append(array1, array3).isEquals());\n         assertFalse(new EqualsBuilder().append(array3, array1).isEquals());\n         assertFalse(new EqualsBuilder().append(array2, array3).isEquals());\n \n     @Test\n     public void testRaggedArray() {\n-        long array1[][] = new long[2][];\n-        long array2[][] = new long[2][];\n+        final long array1[][] = new long[2][];\n+        final long array2[][] = new long[2][];\n         for (int i = 0; i < array1.length; ++i) {\n             array1[i] = new long[2];\n             array2[i] = new long[2];\n \n     @Test\n     public void testMixedArray() {\n-        Object array1[] = new Object[2];\n-        Object array2[] = new Object[2];\n+        final Object array1[] = new Object[2];\n+        final Object array2[] = new Object[2];\n         for (int i = 0; i < array1.length; ++i) {\n             array1[i] = new long[2];\n             array2[i] = new long[2];\n \n     @Test\n     public void testObjectArrayHiddenByObject() {\n-        TestObject[] array1 = new TestObject[2];\n+        final TestObject[] array1 = new TestObject[2];\n         array1[0] = new TestObject(4);\n         array1[1] = new TestObject(5);\n-        TestObject[] array2 = new TestObject[2];\n+        final TestObject[] array2 = new TestObject[2];\n         array2[0] = new TestObject(4);\n         array2[1] = new TestObject(5);\n-        Object obj1 = array1;\n-        Object obj2 = array2;\n+        final Object obj1 = array1;\n+        final Object obj2 = array2;\n         assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals());\n         assertTrue(new EqualsBuilder().append(obj1, array1).isEquals());\n         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());\n \n     @Test\n     public void testLongArrayHiddenByObject() {\n-        long[] array1 = new long[2];\n+        final long[] array1 = new long[2];\n         array1[0] = 5L;\n         array1[1] = 6L;\n-        long[] array2 = new long[2];\n+        final long[] array2 = new long[2];\n         array2[0] = 5L;\n         array2[1] = 6L;\n-        Object obj1 = array1;\n-        Object obj2 = array2;\n+        final Object obj1 = array1;\n+        final Object obj2 = array2;\n         assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals());\n         assertTrue(new EqualsBuilder().append(obj1, array1).isEquals());\n         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());\n \n     @Test\n     public void testIntArrayHiddenByObject() {\n-        int[] array1 = new int[2];\n+        final int[] array1 = new int[2];\n         array1[0] = 5;\n         array1[1] = 6;\n-        int[] array2 = new int[2];\n+        final int[] array2 = new int[2];\n         array2[0] = 5;\n         array2[1] = 6;\n-        Object obj1 = array1;\n-        Object obj2 = array2;\n+        final Object obj1 = array1;\n+        final Object obj2 = array2;\n         assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals());\n         assertTrue(new EqualsBuilder().append(obj1, array1).isEquals());\n         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());\n \n     @Test\n     public void testShortArrayHiddenByObject() {\n-        short[] array1 = new short[2];\n+        final short[] array1 = new short[2];\n         array1[0] = 5;\n         array1[1] = 6;\n-        short[] array2 = new short[2];\n+        final short[] array2 = new short[2];\n         array2[0] = 5;\n         array2[1] = 6;\n-        Object obj1 = array1;\n-        Object obj2 = array2;\n+        final Object obj1 = array1;\n+        final Object obj2 = array2;\n         assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals());\n         assertTrue(new EqualsBuilder().append(obj1, array1).isEquals());\n         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());\n \n     @Test\n     public void testCharArrayHiddenByObject() {\n-        char[] array1 = new char[2];\n+        final char[] array1 = new char[2];\n         array1[0] = 5;\n         array1[1] = 6;\n-        char[] array2 = new char[2];\n+        final char[] array2 = new char[2];\n         array2[0] = 5;\n         array2[1] = 6;\n-        Object obj1 = array1;\n-        Object obj2 = array2;\n+        final Object obj1 = array1;\n+        final Object obj2 = array2;\n         assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals());\n         assertTrue(new EqualsBuilder().append(obj1, array1).isEquals());\n         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());\n \n     @Test\n     public void testByteArrayHiddenByObject() {\n-        byte[] array1 = new byte[2];\n+        final byte[] array1 = new byte[2];\n         array1[0] = 5;\n         array1[1] = 6;\n-        byte[] array2 = new byte[2];\n+        final byte[] array2 = new byte[2];\n         array2[0] = 5;\n         array2[1] = 6;\n-        Object obj1 = array1;\n-        Object obj2 = array2;\n+        final Object obj1 = array1;\n+        final Object obj2 = array2;\n         assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals());\n         assertTrue(new EqualsBuilder().append(obj1, array1).isEquals());\n         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());\n \n     @Test\n     public void testDoubleArrayHiddenByObject() {\n-        double[] array1 = new double[2];\n+        final double[] array1 = new double[2];\n         array1[0] = 5;\n         array1[1] = 6;\n-        double[] array2 = new double[2];\n+        final double[] array2 = new double[2];\n         array2[0] = 5;\n         array2[1] = 6;\n-        Object obj1 = array1;\n-        Object obj2 = array2;\n+        final Object obj1 = array1;\n+        final Object obj2 = array2;\n         assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals());\n         assertTrue(new EqualsBuilder().append(obj1, array1).isEquals());\n         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());\n \n     @Test\n     public void testFloatArrayHiddenByObject() {\n-        float[] array1 = new float[2];\n+        final float[] array1 = new float[2];\n         array1[0] = 5;\n         array1[1] = 6;\n-        float[] array2 = new float[2];\n+        final float[] array2 = new float[2];\n         array2[0] = 5;\n         array2[1] = 6;\n-        Object obj1 = array1;\n-        Object obj2 = array2;\n+        final Object obj1 = array1;\n+        final Object obj2 = array2;\n         assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals());\n         assertTrue(new EqualsBuilder().append(obj1, array1).isEquals());\n         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());\n \n     @Test\n     public void testBooleanArrayHiddenByObject() {\n-        boolean[] array1 = new boolean[2];\n+        final boolean[] array1 = new boolean[2];\n         array1[0] = true;\n         array1[1] = false;\n-        boolean[] array2 = new boolean[2];\n+        final boolean[] array2 = new boolean[2];\n         array2[0] = true;\n         array2[1] = false;\n-        Object obj1 = array1;\n-        Object obj2 = array2;\n+        final Object obj1 = array1;\n+        final Object obj2 = array2;\n         assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals());\n         assertTrue(new EqualsBuilder().append(obj1, array1).isEquals());\n         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());\n      */\n     @Test\n     public void testUnrelatedClasses() {\n-        Object[] x = new Object[]{new TestACanEqualB(1)};\n-        Object[] y = new Object[]{new TestBCanEqualA(1)};\n+        final Object[] x = new Object[]{new TestACanEqualB(1)};\n+        final Object[] y = new Object[]{new TestBCanEqualA(1)};\n \n         // sanity checks:\n         assertTrue(Arrays.equals(x, x));\n      */\n     @Test\n     public void testNpeForNullElement() {\n-        Object[] x1 = new Object[] { Integer.valueOf(1), null, Integer.valueOf(3) };\n-        Object[] x2 = new Object[] { Integer.valueOf(1), Integer.valueOf(2), Integer.valueOf(3) };\n+        final Object[] x1 = new Object[] { Integer.valueOf(1), null, Integer.valueOf(3) };\n+        final Object[] x2 = new Object[] { Integer.valueOf(1), Integer.valueOf(2), Integer.valueOf(3) };\n \n         // causes an NPE in 2.0 according to:\n         // http://issues.apache.org/bugzilla/show_bug.cgi?id=33067\n \n     @Test\n     public void testReflectionEqualsExcludeFields() throws Exception {\n-        TestObjectWithMultipleFields x1 = new TestObjectWithMultipleFields(1, 2, 3);\n-        TestObjectWithMultipleFields x2 = new TestObjectWithMultipleFields(1, 3, 4);\n+        final TestObjectWithMultipleFields x1 = new TestObjectWithMultipleFields(1, 2, 3);\n+        final TestObjectWithMultipleFields x2 = new TestObjectWithMultipleFields(1, 3, 4);\n \n         // not equal when including all fields\n         assertTrue(!EqualsBuilder.reflectionEquals(x1, x2));\n      */\n     @Test\n     public void testCyclicalObjectReferences() {\n-        TestObjectReference refX1 = new TestObjectReference(1);\n-        TestObjectReference x1 = new TestObjectReference(1);\n+        final TestObjectReference refX1 = new TestObjectReference(1);\n+        final TestObjectReference x1 = new TestObjectReference(1);\n         x1.setObjectReference(refX1);\n         refX1.setObjectReference(x1);\n \n-        TestObjectReference refX2 = new TestObjectReference(1);\n-        TestObjectReference x2 = new TestObjectReference(1);\n+        final TestObjectReference refX2 = new TestObjectReference(1);\n+        final TestObjectReference x2 = new TestObjectReference(1);\n         x2.setObjectReference(refX2);\n         refX2.setObjectReference(x2);\n \n-        TestObjectReference refX3 = new TestObjectReference(2);\n-        TestObjectReference x3 = new TestObjectReference(2);\n+        final TestObjectReference refX3 = new TestObjectReference(2);\n+        final TestObjectReference x3 = new TestObjectReference(2);\n         x3.setObjectReference(refX3);\n         refX3.setObjectReference(x3);\n \n--- a/src/test/java/org/apache/commons/lang3/builder/HashCodeBuilderAndEqualsBuilderTest.java\n+++ b/src/test/java/org/apache/commons/lang3/builder/HashCodeBuilderAndEqualsBuilderTest.java\n     //-----------------------------------------------------------------------\n \n     private void testInteger(final boolean testTransients) {\n-        Integer i1 = Integer.valueOf(12345);\n-        Integer i2 = Integer.valueOf(12345);\n+        final Integer i1 = Integer.valueOf(12345);\n+        final Integer i2 = Integer.valueOf(12345);\n         assertEqualsAndHashCodeContract(i1, i2, testTransients);\n     }\n \n--- a/src/test/java/org/apache/commons/lang3/builder/HashCodeBuilderTest.java\n+++ b/src/test/java/org/apache/commons/lang3/builder/HashCodeBuilderTest.java\n             if (!(o instanceof TestObject)) {\n                 return false;\n             }\n-            TestObject rhs = (TestObject) o;\n+            final TestObject rhs = (TestObject) o;\n             return a == rhs.a;\n         }\n \n             if (!(o instanceof TestSubObject)) {\n                 return false;\n             }\n-            TestSubObject rhs = (TestSubObject) o;\n+            final TestSubObject rhs = (TestSubObject) o;\n             return super.equals(o) && b == rhs.b;\n         }\n \n \n     @Test\n     public void testSuper() {\n-        Object obj = new Object();\n+        final Object obj = new Object();\n         assertEquals(17 * 37 + 19 * 41 + obj.hashCode(), new HashCodeBuilder(17, 37).appendSuper(\n                 new HashCodeBuilder(19, 41).append(obj).toHashCode()).toHashCode());\n     }\n     @SuppressWarnings(\"cast\") // cast is not really needed, keep for consistency\n     public void testDouble() {\n         assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((double) 0d).toHashCode());\n-        double d = 1234567.89;\n-        long l = Double.doubleToLongBits(d);\n+        final double d = 1234567.89;\n+        final long l = Double.doubleToLongBits(d);\n         assertEquals(17 * 37 + (int) (l ^ l >> 32), new HashCodeBuilder(17, 37).append(d).toHashCode());\n     }\n \n     @SuppressWarnings(\"cast\") // cast is not really needed, keep for consistency\n     public void testFloat() {\n         assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((float) 0f).toHashCode());\n-        float f = 1234.89f;\n-        int i = Float.floatToIntBits(f);\n+        final float f = 1234.89f;\n+        final int i = Float.floatToIntBits(f);\n         assertEquals(17 * 37 + i, new HashCodeBuilder(17, 37).append(f).toHashCode());\n     }\n \n     @Test\n     public void testObjectArray() {\n         assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((Object[]) null).toHashCode());\n-        Object[] obj = new Object[2];\n+        final Object[] obj = new Object[2];\n         assertEquals(17 * 37 * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());\n         obj[0] = new Object();\n         assertEquals((17 * 37 + obj[0].hashCode()) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());\n \n     @Test\n     public void testObjectArrayAsObject() {\n-        Object[] obj = new Object[2];\n+        final Object[] obj = new Object[2];\n         assertEquals(17 * 37 * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());\n         obj[0] = new Object();\n         assertEquals((17 * 37 + obj[0].hashCode()) * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());\n     @Test\n     public void testLongArray() {\n         assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((long[]) null).toHashCode());\n-        long[] obj = new long[2];\n+        final long[] obj = new long[2];\n         assertEquals(17 * 37 * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());\n         obj[0] = 5L;\n-        int h1 = (int) (5L ^ 5L >> 32);\n+        final int h1 = (int) (5L ^ 5L >> 32);\n         assertEquals((17 * 37 + h1) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());\n         obj[1] = 6L;\n-        int h2 = (int) (6L ^ 6L >> 32);\n+        final int h2 = (int) (6L ^ 6L >> 32);\n         assertEquals((17 * 37 + h1) * 37 + h2, new HashCodeBuilder(17, 37).append(obj).toHashCode());\n     }\n \n     @Test\n     public void testLongArrayAsObject() {\n-        long[] obj = new long[2];\n+        final long[] obj = new long[2];\n         assertEquals(17 * 37 * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());\n         obj[0] = 5L;\n-        int h1 = (int) (5L ^ 5L >> 32);\n+        final int h1 = (int) (5L ^ 5L >> 32);\n         assertEquals((17 * 37 + h1) * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());\n         obj[1] = 6L;\n-        int h2 = (int) (6L ^ 6L >> 32);\n+        final int h2 = (int) (6L ^ 6L >> 32);\n         assertEquals((17 * 37 + h1) * 37 + h2, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());\n     }\n \n     @Test\n     public void testIntArray() {\n         assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((int[]) null).toHashCode());\n-        int[] obj = new int[2];\n+        final int[] obj = new int[2];\n         assertEquals(17 * 37 * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());\n         obj[0] = 5;\n         assertEquals((17 * 37 + 5) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());\n \n     @Test\n     public void testIntArrayAsObject() {\n-        int[] obj = new int[2];\n+        final int[] obj = new int[2];\n         assertEquals(17 * 37 * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());\n         obj[0] = 5;\n         assertEquals((17 * 37 + 5) * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());\n     @Test\n     public void testShortArray() {\n         assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((short[]) null).toHashCode());\n-        short[] obj = new short[2];\n+        final short[] obj = new short[2];\n         assertEquals(17 * 37 * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());\n         obj[0] = (short) 5;\n         assertEquals((17 * 37 + 5) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());\n \n     @Test\n     public void testShortArrayAsObject() {\n-        short[] obj = new short[2];\n+        final short[] obj = new short[2];\n         assertEquals(17 * 37 * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());\n         obj[0] = (short) 5;\n         assertEquals((17 * 37 + 5) * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());\n     @Test\n     public void testCharArray() {\n         assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((char[]) null).toHashCode());\n-        char[] obj = new char[2];\n+        final char[] obj = new char[2];\n         assertEquals(17 * 37 * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());\n         obj[0] = (char) 5;\n         assertEquals((17 * 37 + 5) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());\n \n     @Test\n     public void testCharArrayAsObject() {\n-        char[] obj = new char[2];\n+        final char[] obj = new char[2];\n         assertEquals(17 * 37 * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());\n         obj[0] = (char) 5;\n         assertEquals((17 * 37 + 5) * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());\n     @Test\n     public void testByteArray() {\n         assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((byte[]) null).toHashCode());\n-        byte[] obj = new byte[2];\n+        final byte[] obj = new byte[2];\n         assertEquals(17 * 37 * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());\n         obj[0] = (byte) 5;\n         assertEquals((17 * 37 + 5) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());\n \n     @Test\n     public void testByteArrayAsObject() {\n-        byte[] obj = new byte[2];\n+        final byte[] obj = new byte[2];\n         assertEquals(17 * 37 * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());\n         obj[0] = (byte) 5;\n         assertEquals((17 * 37 + 5) * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());\n     @Test\n     public void testDoubleArray() {\n         assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((double[]) null).toHashCode());\n-        double[] obj = new double[2];\n+        final double[] obj = new double[2];\n         assertEquals(17 * 37 * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());\n         obj[0] = 5.4d;\n-        long l1 = Double.doubleToLongBits(5.4d);\n-        int h1 = (int) (l1 ^ l1 >> 32);\n+        final long l1 = Double.doubleToLongBits(5.4d);\n+        final int h1 = (int) (l1 ^ l1 >> 32);\n         assertEquals((17 * 37 + h1) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());\n         obj[1] = 6.3d;\n-        long l2 = Double.doubleToLongBits(6.3d);\n-        int h2 = (int) (l2 ^ l2 >> 32);\n+        final long l2 = Double.doubleToLongBits(6.3d);\n+        final int h2 = (int) (l2 ^ l2 >> 32);\n         assertEquals((17 * 37 + h1) * 37 + h2, new HashCodeBuilder(17, 37).append(obj).toHashCode());\n     }\n \n     @Test\n     public void testDoubleArrayAsObject() {\n-        double[] obj = new double[2];\n+        final double[] obj = new double[2];\n         assertEquals(17 * 37 * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());\n         obj[0] = 5.4d;\n-        long l1 = Double.doubleToLongBits(5.4d);\n-        int h1 = (int) (l1 ^ l1 >> 32);\n+        final long l1 = Double.doubleToLongBits(5.4d);\n+        final int h1 = (int) (l1 ^ l1 >> 32);\n         assertEquals((17 * 37 + h1) * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());\n         obj[1] = 6.3d;\n-        long l2 = Double.doubleToLongBits(6.3d);\n-        int h2 = (int) (l2 ^ l2 >> 32);\n+        final long l2 = Double.doubleToLongBits(6.3d);\n+        final int h2 = (int) (l2 ^ l2 >> 32);\n         assertEquals((17 * 37 + h1) * 37 + h2, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());\n     }\n \n     @Test\n     public void testFloatArray() {\n         assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((float[]) null).toHashCode());\n-        float[] obj = new float[2];\n+        final float[] obj = new float[2];\n         assertEquals(17 * 37 * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());\n         obj[0] = 5.4f;\n-        int h1 = Float.floatToIntBits(5.4f);\n+        final int h1 = Float.floatToIntBits(5.4f);\n         assertEquals((17 * 37 + h1) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());\n         obj[1] = 6.3f;\n-        int h2 = Float.floatToIntBits(6.3f);\n+        final int h2 = Float.floatToIntBits(6.3f);\n         assertEquals((17 * 37 + h1) * 37 + h2, new HashCodeBuilder(17, 37).append(obj).toHashCode());\n     }\n \n     @Test\n     public void testFloatArrayAsObject() {\n-        float[] obj = new float[2];\n+        final float[] obj = new float[2];\n         assertEquals(17 * 37 * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());\n         obj[0] = 5.4f;\n-        int h1 = Float.floatToIntBits(5.4f);\n+        final int h1 = Float.floatToIntBits(5.4f);\n         assertEquals((17 * 37 + h1) * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());\n         obj[1] = 6.3f;\n-        int h2 = Float.floatToIntBits(6.3f);\n+        final int h2 = Float.floatToIntBits(6.3f);\n         assertEquals((17 * 37 + h1) * 37 + h2, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());\n     }\n \n     @Test\n     public void testBooleanArray() {\n         assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((boolean[]) null).toHashCode());\n-        boolean[] obj = new boolean[2];\n+        final boolean[] obj = new boolean[2];\n         assertEquals((17 * 37 + 1) * 37 + 1, new HashCodeBuilder(17, 37).append(obj).toHashCode());\n         obj[0] = true;\n         assertEquals((17 * 37 + 0) * 37 + 1, new HashCodeBuilder(17, 37).append(obj).toHashCode());\n \n     @Test\n     public void testBooleanArrayAsObject() {\n-        boolean[] obj = new boolean[2];\n+        final boolean[] obj = new boolean[2];\n         assertEquals((17 * 37 + 1) * 37 + 1, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());\n         obj[0] = true;\n         assertEquals((17 * 37 + 0) * 37 + 1, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());\n \n     @Test\n     public void testBooleanMultiArray() {\n-        boolean[][] obj = new boolean[2][];\n+        final boolean[][] obj = new boolean[2][];\n         assertEquals(17 * 37 * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());\n         obj[0] = new boolean[0];\n         assertEquals(17 * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());\n \n     @Test\n     public void testReflectionHashCodeExcludeFields() throws Exception {\n-        TestObjectWithMultipleFields x = new TestObjectWithMultipleFields(1, 2, 3);\n+        final TestObjectWithMultipleFields x = new TestObjectWithMultipleFields(1, 2, 3);\n \n         assertEquals(((17 * 37 + 1) * 37 + 2) * 37 + 3, HashCodeBuilder.reflectionHashCode(x));\n \n      */\n     @Test\n     public void testReflectionObjectCycle() {\n-        ReflectionTestCycleA a = new ReflectionTestCycleA();\n-        ReflectionTestCycleB b = new ReflectionTestCycleB();\n+        final ReflectionTestCycleA a = new ReflectionTestCycleA();\n+        final ReflectionTestCycleB b = new ReflectionTestCycleB();\n         a.b = b;\n         b.a = a;\n         \n      */\n     @Test\n     public void testToHashCodeEqualsHashCode() {\n-        HashCodeBuilder hcb = new HashCodeBuilder(17, 37).append(new Object()).append('a');\n+        final HashCodeBuilder hcb = new HashCodeBuilder(17, 37).append(new Object()).append('a');\n         assertEquals(\"hashCode() is no longer returning the same value as toHashCode() - see LANG-520\", \n                      hcb.toHashCode(), hcb.hashCode());\n     }\n--- a/src/test/java/org/apache/commons/lang3/builder/MultiLineToStringStyleTest.java\n+++ b/src/test/java/org/apache/commons/lang3/builder/MultiLineToStringStyleTest.java\n     \n     @Test\n     public void testObject() {\n-        Integer i3 = Integer.valueOf(3);\n-        Integer i4 = Integer.valueOf(4);\n+        final Integer i3 = Integer.valueOf(3);\n+        final Integer i4 = Integer.valueOf(4);\n         assertEquals(baseStr + \"[\" + SystemUtils.LINE_SEPARATOR + \"  <null>\" + SystemUtils.LINE_SEPARATOR + \"]\", new ToStringBuilder(base).append((Object) null).toString());\n         assertEquals(baseStr + \"[\" + SystemUtils.LINE_SEPARATOR + \"  3\" + SystemUtils.LINE_SEPARATOR + \"]\", new ToStringBuilder(base).append(i3).toString());\n         assertEquals(baseStr + \"[\" + SystemUtils.LINE_SEPARATOR + \"  a=<null>\" + SystemUtils.LINE_SEPARATOR + \"]\", new ToStringBuilder(base).append(\"a\", (Object) null).toString());\n \n     @Test\n     public void testPerson() {\n-        Person p = new Person();\n+        final Person p = new Person();\n         p.name = \"Jane Doe\";\n         p.age = 25;\n         p.smoker = true;\n-        String pBaseStr = p.getClass().getName() + \"@\" + Integer.toHexString(System.identityHashCode(p));\n+        final String pBaseStr = p.getClass().getName() + \"@\" + Integer.toHexString(System.identityHashCode(p));\n         assertEquals(pBaseStr + \"[\" + SystemUtils.LINE_SEPARATOR + \"  name=Jane Doe\" + SystemUtils.LINE_SEPARATOR + \"  age=25\" + SystemUtils.LINE_SEPARATOR + \"  smoker=true\" + SystemUtils.LINE_SEPARATOR + \"]\", new ToStringBuilder(p).append(\"name\", p.name).append(\"age\", p.age).append(\"smoker\", p.smoker).toString());\n     }\n \n--- a/src/test/java/org/apache/commons/lang3/builder/NoFieldNamesToStringStyleTest.java\n+++ b/src/test/java/org/apache/commons/lang3/builder/NoFieldNamesToStringStyleTest.java\n     \n     @Test\n     public void testObject() {\n-        Integer i3 = Integer.valueOf(3);\n-        Integer i4 = Integer.valueOf(4);\n+        final Integer i3 = Integer.valueOf(3);\n+        final Integer i4 = Integer.valueOf(4);\n         assertEquals(baseStr + \"[<null>]\", new ToStringBuilder(base).append((Object) null).toString());\n         assertEquals(baseStr + \"[3]\", new ToStringBuilder(base).append(i3).toString());\n         assertEquals(baseStr + \"[<null>]\", new ToStringBuilder(base).append(\"a\", (Object) null).toString());\n \n     @Test\n     public void testPerson() {\n-        Person p = new Person();\n+        final Person p = new Person();\n         p.name = \"Ron Paul\";\n         p.age = 72;\n         p.smoker = false;\n-        String pBaseStr = p.getClass().getName() + \"@\" + Integer.toHexString(System.identityHashCode(p));\n+        final String pBaseStr = p.getClass().getName() + \"@\" + Integer.toHexString(System.identityHashCode(p));\n         assertEquals(pBaseStr + \"[Ron Paul,72,false]\", new ToStringBuilder(p).append(\"name\", p.name).append(\"age\", p.age).append(\"smoker\", p.smoker).toString());\n     }\n \n--- a/src/test/java/org/apache/commons/lang3/builder/ReflectionToStringBuilderConcurrencyTest.java\n+++ b/src/test/java/org/apache/commons/lang3/builder/ReflectionToStringBuilderConcurrencyTest.java\n         // Create a thread pool with two threads to cause the most contention on the underlying resource.\n         final ExecutorService threadPool = Executors.newFixedThreadPool(2);\n         // Consumes toStrings\n-        Callable<Integer> consumer = new Callable<Integer>() {\n+        final Callable<Integer> consumer = new Callable<Integer>() {\n             @Override\n             public Integer call() {\n                 for (int i = 0; i < REPEAT; i++) {\n-                    String s = ReflectionToStringBuilder.toString(holder);\n+                    final String s = ReflectionToStringBuilder.toString(holder);\n                     Assert.assertNotNull(s);\n                 }\n                 return Integer.valueOf(REPEAT);\n             }\n         };\n         // Produces changes in the list\n-        Callable<Integer> producer = new Callable<Integer>() {\n+        final Callable<Integer> producer = new Callable<Integer>() {\n             @Override\n             public Integer call() {\n                 for (int i = 0; i < DATA_SIZE; i++) {\n                 return Integer.valueOf(REPEAT);\n             }\n         };\n-        Collection<Callable<Integer>> tasks = new ArrayList<Callable<Integer>>();\n+        final Collection<Callable<Integer>> tasks = new ArrayList<Callable<Integer>>();\n         tasks.add(consumer);\n         tasks.add(producer);\n         final List<Future<Integer>> futures = threadPool.invokeAll(tasks);\n-        for (Future<Integer> future : futures) {\n+        for (final Future<Integer> future : futures) {\n             Assert.assertEquals(REPEAT, future.get().intValue());\n         }\n     }\n--- a/src/test/java/org/apache/commons/lang3/builder/ReflectionToStringBuilderExcludeTest.java\n+++ b/src/test/java/org/apache/commons/lang3/builder/ReflectionToStringBuilderExcludeTest.java\n \n     @Test\n     public void test_toStringExclude() {\n-        String toString = ReflectionToStringBuilder.toStringExclude(new TestFixture(), SECRET_FIELD);\n+        final String toString = ReflectionToStringBuilder.toStringExclude(new TestFixture(), SECRET_FIELD);\n         this.validateSecretFieldAbsent(toString);\n     }\n \n     @Test\n     public void test_toStringExcludeArray() {\n-        String toString = ReflectionToStringBuilder.toStringExclude(new TestFixture(), new String[]{SECRET_FIELD});\n+        final String toString = ReflectionToStringBuilder.toStringExclude(new TestFixture(), new String[]{SECRET_FIELD});\n         this.validateSecretFieldAbsent(toString);\n     }\n \n     @Test\n     public void test_toStringExcludeArrayWithNull() {\n-        String toString = ReflectionToStringBuilder.toStringExclude(new TestFixture(), new String[]{null});\n+        final String toString = ReflectionToStringBuilder.toStringExclude(new TestFixture(), new String[]{null});\n         this.validateSecretFieldPresent(toString);\n     }\n \n     @Test\n     public void test_toStringExcludeArrayWithNulls() {\n-        String toString = ReflectionToStringBuilder.toStringExclude(new TestFixture(), new String[]{null, null});\n+        final String toString = ReflectionToStringBuilder.toStringExclude(new TestFixture(), new String[]{null, null});\n         this.validateSecretFieldPresent(toString);\n     }\n \n     @Test\n     public void test_toStringExcludeCollection() {\n-        List<String> excludeList = new ArrayList<String>();\n+        final List<String> excludeList = new ArrayList<String>();\n         excludeList.add(SECRET_FIELD);\n-        String toString = ReflectionToStringBuilder.toStringExclude(new TestFixture(), excludeList);\n+        final String toString = ReflectionToStringBuilder.toStringExclude(new TestFixture(), excludeList);\n         this.validateSecretFieldAbsent(toString);\n     }\n \n     @Test\n     public void test_toStringExcludeCollectionWithNull() {\n-        List<String> excludeList = new ArrayList<String>();\n+        final List<String> excludeList = new ArrayList<String>();\n         excludeList.add(null);\n-        String toString = ReflectionToStringBuilder.toStringExclude(new TestFixture(), excludeList);\n+        final String toString = ReflectionToStringBuilder.toStringExclude(new TestFixture(), excludeList);\n         this.validateSecretFieldPresent(toString);\n     }\n \n     @Test\n     public void test_toStringExcludeCollectionWithNulls() {\n-        List<String> excludeList = new ArrayList<String>();\n+        final List<String> excludeList = new ArrayList<String>();\n         excludeList.add(null);\n         excludeList.add(null);\n-        String toString = ReflectionToStringBuilder.toStringExclude(new TestFixture(), excludeList);\n+        final String toString = ReflectionToStringBuilder.toStringExclude(new TestFixture(), excludeList);\n         this.validateSecretFieldPresent(toString);\n     }\n \n     @Test\n     public void test_toStringExcludeEmptyArray() {\n-        String toString = ReflectionToStringBuilder.toStringExclude(new TestFixture(), ArrayUtils.EMPTY_STRING_ARRAY);\n+        final String toString = ReflectionToStringBuilder.toStringExclude(new TestFixture(), ArrayUtils.EMPTY_STRING_ARRAY);\n         this.validateSecretFieldPresent(toString);\n     }\n \n     @Test\n     public void test_toStringExcludeEmptyCollection() {\n-        String toString = ReflectionToStringBuilder.toStringExclude(new TestFixture(), new ArrayList<String>());\n+        final String toString = ReflectionToStringBuilder.toStringExclude(new TestFixture(), new ArrayList<String>());\n         this.validateSecretFieldPresent(toString);\n     }\n \n     @Test\n     public void test_toStringExcludeNullArray() {\n-        String toString = ReflectionToStringBuilder.toStringExclude(new TestFixture(), (String[]) null);\n+        final String toString = ReflectionToStringBuilder.toStringExclude(new TestFixture(), (String[]) null);\n         this.validateSecretFieldPresent(toString);\n     }\n \n     @Test\n     public void test_toStringExcludeNullCollection() {\n-        String toString = ReflectionToStringBuilder.toStringExclude(new TestFixture(), (Collection<String>) null);\n+        final String toString = ReflectionToStringBuilder.toStringExclude(new TestFixture(), (Collection<String>) null);\n         this.validateSecretFieldPresent(toString);\n     }\n \n--- a/src/test/java/org/apache/commons/lang3/builder/ReflectionToStringBuilderMutateInspectConcurrencyTest.java\n+++ b/src/test/java/org/apache/commons/lang3/builder/ReflectionToStringBuilderMutateInspectConcurrencyTest.java\n     @Test\n     @Ignore\n     public void testConcurrency() throws Exception {\n-        TestFixture testFixture = new TestFixture();\n+        final TestFixture testFixture = new TestFixture();\n         final int numMutators = 10;\n         final int numIterations = 10;\n         for (int i = 0; i < numIterations; i++) {\n             for (int j = 0; j < numMutators; j++) {\n-                Thread t = new Thread(new MutatingClient(testFixture));\n+                final Thread t = new Thread(new MutatingClient(testFixture));\n                 t.start();\n-                Thread s = new Thread(new InspectingClient(testFixture));\n+                final Thread s = new Thread(new InspectingClient(testFixture));\n                 s.start();\n             }\n         }\n--- a/src/test/java/org/apache/commons/lang3/builder/ShortPrefixToStringStyleTest.java\n+++ b/src/test/java/org/apache/commons/lang3/builder/ShortPrefixToStringStyleTest.java\n     \n     @Test\n     public void testObject() {\n-        Integer i3 = Integer.valueOf(3);\n-        Integer i4 = Integer.valueOf(4);\n+        final Integer i3 = Integer.valueOf(3);\n+        final Integer i4 = Integer.valueOf(4);\n         assertEquals(baseStr + \"[<null>]\", new ToStringBuilder(base).append((Object) null).toString());\n         assertEquals(baseStr + \"[3]\", new ToStringBuilder(base).append(i3).toString());\n         assertEquals(baseStr + \"[a=<null>]\", new ToStringBuilder(base).append(\"a\", (Object) null).toString());\n \n     @Test\n     public void testPerson() {\n-        Person p = new Person();\n+        final Person p = new Person();\n         p.name = \"John Q. Public\";\n         p.age = 45;\n         p.smoker = true;\n-        String pBaseStr = \"ToStringStyleTest.Person\";\n+        final String pBaseStr = \"ToStringStyleTest.Person\";\n         assertEquals(pBaseStr + \"[name=John Q. Public,age=45,smoker=true]\", new ToStringBuilder(p).append(\"name\", p.name).append(\"age\", p.age).append(\"smoker\", p.smoker).toString());\n     }\n \n--- a/src/test/java/org/apache/commons/lang3/builder/SimpleToStringStyleTest.java\n+++ b/src/test/java/org/apache/commons/lang3/builder/SimpleToStringStyleTest.java\n     \n     @Test\n     public void testObject() {\n-        Integer i3 = Integer.valueOf(3);\n-        Integer i4 = Integer.valueOf(4);\n+        final Integer i3 = Integer.valueOf(3);\n+        final Integer i4 = Integer.valueOf(4);\n         assertEquals(\"<null>\", new ToStringBuilder(base).append((Object) null).toString());\n         assertEquals(\"3\", new ToStringBuilder(base).append(i3).toString());\n         assertEquals(\"<null>\", new ToStringBuilder(base).append(\"a\", (Object) null).toString());\n \n     @Test\n     public void testPerson() {\n-        Person p = new Person();\n+        final Person p = new Person();\n         p.name = \"Jane Q. Public\";\n         p.age = 47;\n         p.smoker = false;\n--- a/src/test/java/org/apache/commons/lang3/builder/StandardToStringStyleTest.java\n+++ b/src/test/java/org/apache/commons/lang3/builder/StandardToStringStyleTest.java\n     \n     @Test\n     public void testObject() {\n-        Integer i3 = Integer.valueOf(3);\n-        Integer i4 = Integer.valueOf(4);\n+        final Integer i3 = Integer.valueOf(3);\n+        final Integer i4 = Integer.valueOf(4);\n         assertEquals(baseStr + \"[%NULL%]\", new ToStringBuilder(base).append((Object) null).toString());\n         assertEquals(baseStr + \"[3]\", new ToStringBuilder(base).append(i3).toString());\n         assertEquals(baseStr + \"[a=%NULL%]\", new ToStringBuilder(base).append(\"a\", (Object) null).toString());\n \n     @Test\n     public void testPerson() {\n-        Person p = new Person();\n+        final Person p = new Person();\n         p.name = \"Suzy Queue\";\n         p.age = 19;\n         p.smoker = false;\n-        String pBaseStr = \"ToStringStyleTest.Person\";\n+        final String pBaseStr = \"ToStringStyleTest.Person\";\n         assertEquals(pBaseStr + \"[name=Suzy Queue,age=19,smoker=false]\", new ToStringBuilder(p).append(\"name\", p.name).append(\"age\", p.age).append(\"smoker\", p.smoker).toString());\n     }\n \n--- a/src/test/java/org/apache/commons/lang3/builder/ToStringBuilderTest.java\n+++ b/src/test/java/org/apache/commons/lang3/builder/ToStringBuilderTest.java\n      */\n     @Test\n     public void testReflectionCharacter() {\n-        Character c = new Character('A');\n+        final Character c = new Character('A');\n         assertEquals(this.toBaseString(c) + \"[value=A]\", ToStringBuilder.reflectionToString(c));\n     }\n \n     @Test\n     public void testReflectionObjectArray() {\n         Object[] array = new Object[] { null, base, new int[] { 3, 6 } };\n-        String baseStr = this.toBaseString(array);\n+        final String baseStr = this.toBaseString(array);\n         assertEquals(baseStr + \"[{<null>,5,{3,6}}]\", ToStringBuilder.reflectionToString(array));\n         array = null;\n         assertReflectionArray(\"<null>\", array);\n     @Test\n     public void testReflectionLongArray() {\n         long[] array = new long[] { 1, 2, -3, 4 };\n-        String baseStr = this.toBaseString(array);\n+        final String baseStr = this.toBaseString(array);\n         assertEquals(baseStr + \"[{1,2,-3,4}]\", ToStringBuilder.reflectionToString(array));\n         array = null;\n         assertReflectionArray(\"<null>\", array);\n     @Test\n     public void testReflectionIntArray() {\n         int[] array = new int[] { 1, 2, -3, 4 };\n-        String baseStr = this.toBaseString(array);\n+        final String baseStr = this.toBaseString(array);\n         assertEquals(baseStr + \"[{1,2,-3,4}]\", ToStringBuilder.reflectionToString(array));\n         array = null;\n         assertReflectionArray(\"<null>\", array);\n     @Test\n     public void testReflectionShortArray() {\n         short[] array = new short[] { 1, 2, -3, 4 };\n-        String baseStr = this.toBaseString(array);\n+        final String baseStr = this.toBaseString(array);\n         assertEquals(baseStr + \"[{1,2,-3,4}]\", ToStringBuilder.reflectionToString(array));\n         array = null;\n         assertReflectionArray(\"<null>\", array);\n     @Test\n     public void testReflectionyteArray() {\n         byte[] array = new byte[] { 1, 2, -3, 4 };\n-        String baseStr = this.toBaseString(array);\n+        final String baseStr = this.toBaseString(array);\n         assertEquals(baseStr + \"[{1,2,-3,4}]\", ToStringBuilder.reflectionToString(array));\n         array = null;\n         assertReflectionArray(\"<null>\", array);\n     @Test\n     public void testReflectionCharArray() {\n         char[] array = new char[] { 'A', '2', '_', 'D' };\n-        String baseStr = this.toBaseString(array);\n+        final String baseStr = this.toBaseString(array);\n         assertEquals(baseStr + \"[{A,2,_,D}]\", ToStringBuilder.reflectionToString(array));\n         array = null;\n         assertReflectionArray(\"<null>\", array);\n     @Test\n     public void testReflectionDoubleArray() {\n         double[] array = new double[] { 1.0, 2.9876, -3.00001, 4.3 };\n-        String baseStr = this.toBaseString(array);\n+        final String baseStr = this.toBaseString(array);\n         assertEquals(baseStr + \"[{1.0,2.9876,-3.00001,4.3}]\", ToStringBuilder.reflectionToString(array));\n         array = null;\n         assertReflectionArray(\"<null>\", array);\n     @Test\n     public void testReflectionFloatArray() {\n         float[] array = new float[] { 1.0f, 2.9876f, -3.00001f, 4.3f };\n-        String baseStr = this.toBaseString(array);\n+        final String baseStr = this.toBaseString(array);\n         assertEquals(baseStr + \"[{1.0,2.9876,-3.00001,4.3}]\", ToStringBuilder.reflectionToString(array));\n         array = null;\n         assertReflectionArray(\"<null>\", array);\n     @Test\n     public void testReflectionBooleanArray() {\n         boolean[] array = new boolean[] { true, false, false };\n-        String baseStr = this.toBaseString(array);\n+        final String baseStr = this.toBaseString(array);\n         assertEquals(baseStr + \"[{true,false,false}]\", ToStringBuilder.reflectionToString(array));\n         array = null;\n         assertReflectionArray(\"<null>\", array);\n     @Test\n     public void testReflectionFloatArrayArray() {\n         float[][] array = new float[][] { { 1.0f, 2.29686f }, null, { Float.NaN } };\n-        String baseStr = this.toBaseString(array);\n+        final String baseStr = this.toBaseString(array);\n         assertEquals(baseStr + \"[{{1.0,2.29686},<null>,{NaN}}]\", ToStringBuilder.reflectionToString(array));\n         array = null;\n         assertReflectionArray(\"<null>\", array);\n     @Test\n     public void testReflectionLongArrayArray() {\n         long[][] array = new long[][] { { 1, 2 }, null, { 5 } };\n-        String baseStr = this.toBaseString(array);\n+        final String baseStr = this.toBaseString(array);\n         assertEquals(baseStr + \"[{{1,2},<null>,{5}}]\", ToStringBuilder.reflectionToString(array));\n         array = null;\n         assertReflectionArray(\"<null>\", array);\n     @Test\n     public void testReflectionIntArrayArray() {\n         int[][] array = new int[][] { { 1, 2 }, null, { 5 } };\n-        String baseStr = this.toBaseString(array);\n+        final String baseStr = this.toBaseString(array);\n         assertEquals(baseStr + \"[{{1,2},<null>,{5}}]\", ToStringBuilder.reflectionToString(array));\n         array = null;\n         assertReflectionArray(\"<null>\", array);\n     @Test\n     public void testReflectionhortArrayArray() {\n         short[][] array = new short[][] { { 1, 2 }, null, { 5 } };\n-        String baseStr = this.toBaseString(array);\n+        final String baseStr = this.toBaseString(array);\n         assertEquals(baseStr + \"[{{1,2},<null>,{5}}]\", ToStringBuilder.reflectionToString(array));\n         array = null;\n         assertReflectionArray(\"<null>\", array);\n     @Test\n     public void testReflectionByteArrayArray() {\n         byte[][] array = new byte[][] { { 1, 2 }, null, { 5 } };\n-        String baseStr = this.toBaseString(array);\n+        final String baseStr = this.toBaseString(array);\n         assertEquals(baseStr + \"[{{1,2},<null>,{5}}]\", ToStringBuilder.reflectionToString(array));\n         array = null;\n         assertReflectionArray(\"<null>\", array);\n     @Test\n     public void testReflectionCharArrayArray() {\n         char[][] array = new char[][] { { 'A', 'B' }, null, { 'p' } };\n-        String baseStr = this.toBaseString(array);\n+        final String baseStr = this.toBaseString(array);\n         assertEquals(baseStr + \"[{{A,B},<null>,{p}}]\", ToStringBuilder.reflectionToString(array));\n         array = null;\n         assertReflectionArray(\"<null>\", array);\n     @Test\n     public void testReflectionDoubleArrayArray() {\n         double[][] array = new double[][] { { 1.0, 2.29686 }, null, { Double.NaN } };\n-        String baseStr = this.toBaseString(array);\n+        final String baseStr = this.toBaseString(array);\n         assertEquals(baseStr + \"[{{1.0,2.29686},<null>,{NaN}}]\", ToStringBuilder.reflectionToString(array));\n         array = null;\n         assertReflectionArray(\"<null>\", array);\n     @Test\n     public void testReflectionBooleanArrayArray() {\n         boolean[][] array = new boolean[][] { { true, false }, null, { false } };\n-        String baseStr = this.toBaseString(array);\n+        final String baseStr = this.toBaseString(array);\n         assertEquals(baseStr + \"[{{true,false},<null>,{false}}]\", ToStringBuilder.reflectionToString(array));\n         assertEquals(baseStr + \"[{{true,false},<null>,{false}}]\", ToStringBuilder.reflectionToString(array));\n         array = null;\n     // Reflection hierarchy tests\n     @Test\n     public void testReflectionHierarchyArrayList() {\n-        List<Object> base = new ArrayList<Object>();\n-        String baseStr = this.toBaseString(base);\n+        final List<Object> base = new ArrayList<Object>();\n+        final String baseStr = this.toBaseString(base);\n         // note, the test data depends on the internal representation of the ArrayList, which may differ between JDK versions and vendors\n-        String expectedWithTransients = baseStr + \"[elementData={<null>,<null>,<null>,<null>,<null>,<null>,<null>,<null>,<null>,<null>},size=0,modCount=0]\";\n-        String toStringWithTransients = ToStringBuilder.reflectionToString(base, null, true);\n+        final String expectedWithTransients = baseStr + \"[elementData={<null>,<null>,<null>,<null>,<null>,<null>,<null>,<null>,<null>,<null>},size=0,modCount=0]\";\n+        final String toStringWithTransients = ToStringBuilder.reflectionToString(base, null, true);\n         if (!expectedWithTransients.equals(toStringWithTransients)) {\n             // representation different for IBM JDK 1.6.0, LANG-727\n             if (!(\"IBM Corporation\".equals(SystemUtils.JAVA_VENDOR) && \"1.6\".equals(SystemUtils.JAVA_SPECIFICATION_VERSION))) {\n                 assertEquals(expectedWithTransients, toStringWithTransients);\n             }\n         }\n-        String expectedWithoutTransients = baseStr + \"[size=0]\";\n-        String toStringWithoutTransients = ToStringBuilder.reflectionToString(base, null, false);\n+        final String expectedWithoutTransients = baseStr + \"[size=0]\";\n+        final String toStringWithoutTransients = ToStringBuilder.reflectionToString(base, null, false);\n         if (!expectedWithoutTransients.equals(toStringWithoutTransients)) {\n             // representation different for IBM JDK 1.6.0, LANG-727\n             if (!(\"IBM Corporation\".equals(SystemUtils.JAVA_VENDOR) && \"1.6\".equals(SystemUtils.JAVA_SPECIFICATION_VERSION))) {\n \n     @Test\n     public void testReflectionHierarchy() {\n-        ReflectionTestFixtureA baseA = new ReflectionTestFixtureA();\n+        final ReflectionTestFixtureA baseA = new ReflectionTestFixtureA();\n         String baseStr = this.toBaseString(baseA);\n         assertEquals(baseStr + \"[a=a]\", ToStringBuilder.reflectionToString(baseA));\n         assertEquals(baseStr + \"[a=a]\", ToStringBuilder.reflectionToString(baseA, null));\n         assertEquals(baseStr + \"[a=a]\", ToStringBuilder.reflectionToString(baseA, null, false, Object.class));\n         assertEquals(baseStr + \"[a=a]\", ToStringBuilder.reflectionToString(baseA, null, false, ReflectionTestFixtureA.class));\n \n-        ReflectionTestFixtureB baseB = new ReflectionTestFixtureB();\n+        final ReflectionTestFixtureB baseB = new ReflectionTestFixtureB();\n         baseStr = this.toBaseString(baseB);\n         assertEquals(baseStr + \"[b=b,a=a]\", ToStringBuilder.reflectionToString(baseB));\n         assertEquals(baseStr + \"[b=b,a=a]\", ToStringBuilder.reflectionToString(baseB));\n \n     @Test\n     public void testInnerClassReflection() {\n-        Outer outer = new Outer();\n+        final Outer outer = new Outer();\n         assertEquals(toBaseString(outer) + \"[inner=\" + toBaseString(outer.inner) + \"[]]\", outer.toString());\n     }\n \n      */\n     @Test\n     public void testReflectionArrayCycle() throws Exception {\n-        Object[] objects = new Object[1];\n+        final Object[] objects = new Object[1];\n         objects[0] = objects;\n         assertEquals(\n             this.toBaseString(objects) + \"[{\" + this.toBaseString(objects) + \"}]\",\n      */\n     @Test\n     public void testReflectionArrayCycleLevel2() throws Exception {\n-        Object[] objects = new Object[1];\n-        Object[] objectsLevel2 = new Object[1];\n+        final Object[] objects = new Object[1];\n+        final Object[] objectsLevel2 = new Object[1];\n         objects[0] = objectsLevel2;\n         objectsLevel2[0] = objects;\n         assertEquals(\n \n     @Test\n     public void testReflectionArrayArrayCycle() throws Exception {\n-        Object[][] objects = new Object[2][2];\n+        final Object[][] objects = new Object[2][2];\n         objects[0][0] = objects;\n         objects[0][1] = objects;\n         objects[1][0] = objects;\n         objects[1][1] = objects;\n-        String basicToString = this.toBaseString(objects);\n+        final String basicToString = this.toBaseString(objects);\n         assertEquals(\n             basicToString\n                 + \"[{{\"\n      */\n     @Test\n     public void testSimpleReflectionObjectCycle() throws Exception {\n-        SimpleReflectionTestFixture simple = new SimpleReflectionTestFixture();\n+        final SimpleReflectionTestFixture simple = new SimpleReflectionTestFixture();\n         simple.o = simple;\n         assertEquals(this.toBaseString(simple) + \"[o=\" + this.toBaseString(simple) + \"]\", simple.toString());\n     }\n      */\n     @Test\n     public void testSelfInstanceVarReflectionObjectCycle() throws Exception {\n-        SelfInstanceVarReflectionTestFixture test = new SelfInstanceVarReflectionTestFixture();\n+        final SelfInstanceVarReflectionTestFixture test = new SelfInstanceVarReflectionTestFixture();\n         assertEquals(this.toBaseString(test) + \"[typeIsSelf=\" + this.toBaseString(test) + \"]\", test.toString());\n     }\n \n      */\n     @Test\n     public void testSelfInstanceTwoVarsReflectionObjectCycle() throws Exception {\n-        SelfInstanceTwoVarsReflectionTestFixture test = new SelfInstanceTwoVarsReflectionTestFixture();\n+        final SelfInstanceTwoVarsReflectionTestFixture test = new SelfInstanceTwoVarsReflectionTestFixture();\n         assertEquals(this.toBaseString(test) + \"[typeIsSelf=\" + this.toBaseString(test) + \",otherType=\" + test.getOtherType().toString() + \"]\", test.toString());\n     }\n \n      */\n     @Test\n     public void testReflectionObjectCycle() throws Exception {\n-        ReflectionTestCycleA a = new ReflectionTestCycleA();\n-        ReflectionTestCycleB b = new ReflectionTestCycleB();\n+        final ReflectionTestCycleA a = new ReflectionTestCycleA();\n+        final ReflectionTestCycleB b = new ReflectionTestCycleB();\n         a.b = b;\n         b.a = a;\n         assertEquals(\n      */\n     @Test\n     public void testReflectionArrayAndObjectCycle() throws Exception {\n-        Object[] objects = new Object[1];\n-        SimpleReflectionTestFixture simple = new SimpleReflectionTestFixture(objects);\n+        final Object[] objects = new Object[1];\n+        final SimpleReflectionTestFixture simple = new SimpleReflectionTestFixture(objects);\n         objects[0] = simple;\n         assertEquals(\n             this.toBaseString(objects)\n \n     @Test\n     public void testObject() {\n-        Integer i3 = Integer.valueOf(3);\n-        Integer i4 = Integer.valueOf(4);\n+        final Integer i3 = Integer.valueOf(3);\n+        final Integer i4 = Integer.valueOf(4);\n         assertEquals(baseStr + \"[<null>]\", new ToStringBuilder(base).append((Object) null).toString());\n         assertEquals(baseStr + \"[3]\", new ToStringBuilder(base).append(i3).toString());\n         assertEquals(baseStr + \"[a=<null>]\", new ToStringBuilder(base).append(\"a\", (Object) null).toString());\n     \n     @Test\n     public void testObjectBuild() {\n-        Integer i3 = Integer.valueOf(3);\n-        Integer i4 = Integer.valueOf(4);\n+        final Integer i3 = Integer.valueOf(3);\n+        final Integer i4 = Integer.valueOf(4);\n         assertEquals(baseStr + \"[<null>]\", new ToStringBuilder(base).append((Object) null).build());\n         assertEquals(baseStr + \"[3]\", new ToStringBuilder(base).append(i3).build());\n         assertEquals(baseStr + \"[a=<null>]\", new ToStringBuilder(base).append(\"a\", (Object) null).build());\n \n     @Test\n     public void testObjectCycle() {\n-        ObjectCycle a = new ObjectCycle();\n-        ObjectCycle b = new ObjectCycle();\n+        final ObjectCycle a = new ObjectCycle();\n+        final ObjectCycle b = new ObjectCycle();\n         a.obj = b;\n         b.obj = a;\n \n-        String expected = toBaseString(a) + \"[\" + toBaseString(b) + \"[\" + toBaseString(a) + \"]]\";\n+        final String expected = toBaseString(a) + \"[\" + toBaseString(b) + \"[\" + toBaseString(a) + \"]]\";\n         assertEquals(expected, a.toString());\n     }\n \n \n     @Test\n     public void testSimpleReflectionStatics() {\n-        SimpleReflectionStaticFieldsFixture instance1 = new SimpleReflectionStaticFieldsFixture();\n+        final SimpleReflectionStaticFieldsFixture instance1 = new SimpleReflectionStaticFieldsFixture();\n         assertEquals(\n             this.toBaseString(instance1) + \"[staticString=staticString,staticInt=12345]\",\n             ReflectionToStringBuilder.toString(instance1, null, false, true, SimpleReflectionStaticFieldsFixture.class));\n      */\n     @Test\n     public void testReflectionStatics() {\n-        ReflectionStaticFieldsFixture instance1 = new ReflectionStaticFieldsFixture();\n+        final ReflectionStaticFieldsFixture instance1 = new ReflectionStaticFieldsFixture();\n         assertEquals(\n             this.toBaseString(instance1) + \"[staticString=staticString,staticInt=12345,instanceString=instanceString,instanceInt=67890]\",\n             ReflectionToStringBuilder.toString(instance1, null, false, true, ReflectionStaticFieldsFixture.class));\n      */\n     @Test\n     public void testInheritedReflectionStatics() {\n-        InheritedReflectionStaticFieldsFixture instance1 = new InheritedReflectionStaticFieldsFixture();\n+        final InheritedReflectionStaticFieldsFixture instance1 = new InheritedReflectionStaticFieldsFixture();\n         assertEquals(\n             this.toBaseString(instance1) + \"[staticString2=staticString2,staticInt2=67890]\",\n             ReflectionToStringBuilder.toString(instance1, null, false, true, InheritedReflectionStaticFieldsFixture.class));\n      */\n     @Test\n     public void test_setUpToClass_valid() {\n-        Integer val = Integer.valueOf(5);\n-        ReflectionToStringBuilder test = new ReflectionToStringBuilder(val);\n+        final Integer val = Integer.valueOf(5);\n+        final ReflectionToStringBuilder test = new ReflectionToStringBuilder(val);\n         test.setUpToClass(Number.class);\n         test.toString();\n     }\n      */\n     @Test(expected=IllegalArgumentException.class)\n     public void test_setUpToClass_invalid() {\n-        Integer val = Integer.valueOf(5);\n-        ReflectionToStringBuilder test = new ReflectionToStringBuilder(val);\n+        final Integer val = Integer.valueOf(5);\n+        final ReflectionToStringBuilder test = new ReflectionToStringBuilder(val);\n         try {\n             test.setUpToClass(String.class);\n         } finally {\n \n     @Test\n     public void testAppendToStringUsingMultiLineStyle() {\n-        MultiLineTestObject obj = new MultiLineTestObject();\n-        ToStringBuilder testBuilder = new ToStringBuilder(this, ToStringStyle.MULTI_LINE_STYLE)\n+        final MultiLineTestObject obj = new MultiLineTestObject();\n+        final ToStringBuilder testBuilder = new ToStringBuilder(this, ToStringStyle.MULTI_LINE_STYLE)\n                                           .appendToString(obj.toString());\n         assertEquals(testBuilder.toString().indexOf(\"testInt=31337\"), -1);\n     }\n--- a/src/test/java/org/apache/commons/lang3/builder/ToStringStyleConcurrencyTest.java\n+++ b/src/test/java/org/apache/commons/lang3/builder/ToStringStyleConcurrencyTest.java\n         // Create a thread pool with two threads to cause the most contention on the underlying resource.\n         final ExecutorService threadPool = Executors.newFixedThreadPool(2);\n         // Consumes toStrings\n-        Callable<Integer> consumer = new Callable<Integer>() {\n+        final Callable<Integer> consumer = new Callable<Integer>() {\n             @Override\n             public Integer call() {\n                 for (int i = 0; i < REPEAT; i++) {\n                 return Integer.valueOf(REPEAT);\n             }\n         };\n-        Collection<Callable<Integer>> tasks = new ArrayList<Callable<Integer>>();\n+        final Collection<Callable<Integer>> tasks = new ArrayList<Callable<Integer>>();\n         tasks.add(consumer);\n         tasks.add(consumer);\n         final List<Future<Integer>> futures = threadPool.invokeAll(tasks);\n-        for (Future<Integer> future : futures) {\n+        for (final Future<Integer> future : futures) {\n             future.get();\n         }\n     }\n--- a/src/test/java/org/apache/commons/lang3/builder/ToStringStyleTest.java\n+++ b/src/test/java/org/apache/commons/lang3/builder/ToStringStyleTest.java\n     //-----------------------------------------------------------------------\n     @Test\n     public void testSetArrayStart() {\n-        ToStringStyle style = new ToStringStyleImpl();\n+        final ToStringStyle style = new ToStringStyleImpl();\n         style.setArrayStart(null);\n         assertEquals(\"\", style.getArrayStart());\n     }\n \n     @Test\n     public void testSetArrayEnd() {\n-        ToStringStyle style = new ToStringStyleImpl();\n+        final ToStringStyle style = new ToStringStyleImpl();\n         style.setArrayEnd(null);\n         assertEquals(\"\", style.getArrayEnd());\n     }\n \n     @Test\n     public void testSetArraySeparator() {\n-        ToStringStyle style = new ToStringStyleImpl();\n+        final ToStringStyle style = new ToStringStyleImpl();\n         style.setArraySeparator(null);\n         assertEquals(\"\", style.getArraySeparator());\n     }\n \n     @Test\n     public void testSetContentStart() {\n-        ToStringStyle style = new ToStringStyleImpl();\n+        final ToStringStyle style = new ToStringStyleImpl();\n         style.setContentStart(null);\n         assertEquals(\"\", style.getContentStart());\n     }\n \n     @Test\n     public void testSetContentEnd() {\n-        ToStringStyle style = new ToStringStyleImpl();\n+        final ToStringStyle style = new ToStringStyleImpl();\n         style.setContentEnd(null);\n         assertEquals(\"\", style.getContentEnd());\n     }\n \n     @Test\n     public void testSetFieldNameValueSeparator() {\n-        ToStringStyle style = new ToStringStyleImpl();\n+        final ToStringStyle style = new ToStringStyleImpl();\n         style.setFieldNameValueSeparator(null);\n         assertEquals(\"\", style.getFieldNameValueSeparator());\n     }\n \n     @Test\n     public void testSetFieldSeparator() {\n-        ToStringStyle style = new ToStringStyleImpl();\n+        final ToStringStyle style = new ToStringStyleImpl();\n         style.setFieldSeparator(null);\n         assertEquals(\"\", style.getFieldSeparator());\n     }\n \n     @Test\n     public void testSetNullText() {\n-        ToStringStyle style = new ToStringStyleImpl();\n+        final ToStringStyle style = new ToStringStyleImpl();\n         style.setNullText(null);\n         assertEquals(\"\", style.getNullText());\n     }\n \n     @Test\n     public void testSetSizeStartText() {\n-        ToStringStyle style = new ToStringStyleImpl();\n+        final ToStringStyle style = new ToStringStyleImpl();\n         style.setSizeStartText(null);\n         assertEquals(\"\", style.getSizeStartText());\n     }\n \n     @Test\n     public void testSetSizeEndText() {\n-        ToStringStyle style = new ToStringStyleImpl();\n+        final ToStringStyle style = new ToStringStyleImpl();\n         style.setSizeEndText(null);\n         assertEquals(\"\", style.getSizeEndText());\n     }\n \n     @Test\n     public void testSetSummaryObjectStartText() {\n-        ToStringStyle style = new ToStringStyleImpl();\n+        final ToStringStyle style = new ToStringStyleImpl();\n         style.setSummaryObjectStartText(null);\n         assertEquals(\"\", style.getSummaryObjectStartText());\n     }\n \n     @Test\n     public void testSetSummaryObjectEndText() {\n-        ToStringStyle style = new ToStringStyleImpl();\n+        final ToStringStyle style = new ToStringStyleImpl();\n         style.setSummaryObjectEndText(null);\n         assertEquals(\"\", style.getSummaryObjectEndText());\n     }\n--- a/src/test/java/org/apache/commons/lang3/concurrent/AbstractConcurrentInitializerTest.java\n+++ b/src/test/java/org/apache/commons/lang3/concurrent/AbstractConcurrentInitializerTest.java\n      */\n     @Test\n     public void testGetMultipleTimes() throws ConcurrentException {\n-        ConcurrentInitializer<Object> initializer = createInitializer();\n-        Object obj = initializer.get();\n+        final ConcurrentInitializer<Object> initializer = createInitializer();\n+        final Object obj = initializer.get();\n         for (int i = 0; i < 10; i++) {\n             assertEquals(\"Got different object at \" + i, obj, initializer.get());\n         }\n                     startLatch.await();\n                     // access the initializer\n                     object = initializer.get();\n-                } catch (InterruptedException iex) {\n+                } catch (final InterruptedException iex) {\n                     // ignore\n-                } catch (ConcurrentException cex) {\n+                } catch (final ConcurrentException cex) {\n                     object = cex;\n                 }\n             }\n         }\n \n-        GetThread[] threads = new GetThread[threadCount];\n+        final GetThread[] threads = new GetThread[threadCount];\n         for (int i = 0; i < threadCount; i++) {\n             threads[i] = new GetThread();\n             threads[i].start();\n \n         // fire all threads and wait until they are ready\n         startLatch.countDown();\n-        for (Thread t : threads) {\n+        for (final Thread t : threads) {\n             t.join();\n         }\n \n         // check results\n-        Object managedObject = initializer.get();\n-        for (GetThread t : threads) {\n+        final Object managedObject = initializer.get();\n+        for (final GetThread t : threads) {\n             assertEquals(\"Wrong object\", managedObject, t.object);\n         }\n     }\n--- a/src/test/java/org/apache/commons/lang3/concurrent/BackgroundInitializerTest.java\n+++ b/src/test/java/org/apache/commons/lang3/concurrent/BackgroundInitializerTest.java\n      */\n     private void checkInitialize(final BackgroundInitializerTestImpl init) {\n         try {\n-            Integer result = init.get();\n+            final Integer result = init.get();\n             assertEquals(\"Wrong result\", 1, result.intValue());\n             assertEquals(\"Wrong number of invocations\", 1, init.initializeCalls);\n             assertNotNull(\"No future\", init.getFuture());\n-        } catch (ConcurrentException cex) {\n+        } catch (final ConcurrentException cex) {\n             fail(\"Unexpected exception: \" + cex);\n         }\n     }\n      */\n     @Test\n     public void testInitialize() {\n-        BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n+        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n         init.start();\n         checkInitialize(init);\n     }\n      */\n     @Test\n     public void testGetActiveExecutorBeforeStart() {\n-        BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n+        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n         assertNull(\"Got an executor\", init.getActiveExecutor());\n     }\n \n      */\n     @Test\n     public void testGetActiveExecutorExternal() {\n-        ExecutorService exec = Executors.newSingleThreadExecutor();\n-        try {\n-            BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl(\n+        final ExecutorService exec = Executors.newSingleThreadExecutor();\n+        try {\n+            final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl(\n                     exec);\n             init.start();\n             assertSame(\"Wrong executor\", exec, init.getActiveExecutor());\n      */\n     @Test\n     public void testGetActiveExecutorTemp() {\n-        BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n+        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n         init.start();\n         assertNotNull(\"No active executor\", init.getActiveExecutor());\n         checkInitialize(init);\n      */\n     @Test\n     public void testInitializeTempExecutor() {\n-        BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n+        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n         assertTrue(\"Wrong result of start()\", init.start());\n         checkInitialize(init);\n         assertTrue(\"Executor not shutdown\", init.getActiveExecutor()\n      */\n     @Test\n     public void testSetExternalExecutor() throws Exception {\n-        ExecutorService exec = Executors.newCachedThreadPool();\n-        try {\n-            BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n+        final ExecutorService exec = Executors.newCachedThreadPool();\n+        try {\n+            final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n             init.setExternalExecutor(exec);\n             assertEquals(\"Wrong executor service\", exec, init\n                     .getExternalExecutor());\n      */\n     @Test\n     public void testSetExternalExecutorAfterStart() throws ConcurrentException {\n-        BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n+        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n         init.start();\n         try {\n             init.setExternalExecutor(Executors.newSingleThreadExecutor());\n             fail(\"Could set executor after start()!\");\n-        } catch (IllegalStateException istex) {\n+        } catch (final IllegalStateException istex) {\n             init.get();\n         }\n     }\n      */\n     @Test\n     public void testStartMultipleTimes() {\n-        BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n+        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n         assertTrue(\"Wrong result for start()\", init.start());\n         for (int i = 0; i < 10; i++) {\n             assertFalse(\"Could start again\", init.start());\n      */\n     @Test(expected=IllegalStateException.class)\n     public void testGetBeforeStart() throws ConcurrentException {\n-        BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n+        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n         init.get();\n     }\n \n      */\n     @Test\n     public void testGetRuntimeException() throws Exception {\n-        BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n-        RuntimeException rex = new RuntimeException();\n+        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n+        final RuntimeException rex = new RuntimeException();\n         init.ex = rex;\n         init.start();\n         try {\n             init.get();\n             fail(\"Exception not thrown!\");\n-        } catch (Exception ex) {\n+        } catch (final Exception ex) {\n             assertEquals(\"Runtime exception not thrown\", rex, ex);\n         }\n     }\n      */\n     @Test\n     public void testGetCheckedException() throws Exception {\n-        BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n-        Exception ex = new Exception();\n+        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n+        final Exception ex = new Exception();\n         init.ex = ex;\n         init.start();\n         try {\n             init.get();\n             fail(\"Exception not thrown!\");\n-        } catch (ConcurrentException cex) {\n+        } catch (final ConcurrentException cex) {\n             assertEquals(\"Exception not thrown\", ex, cex.getCause());\n         }\n     }\n      */\n     @Test\n     public void testGetInterruptedException() throws Exception {\n-        ExecutorService exec = Executors.newSingleThreadExecutor();\n+        final ExecutorService exec = Executors.newSingleThreadExecutor();\n         final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl(\n                 exec);\n         final CountDownLatch latch1 = new CountDownLatch(1);\n         init.shouldSleep = true;\n         init.start();\n         final AtomicReference<InterruptedException> iex = new AtomicReference<InterruptedException>();\n-        Thread getThread = new Thread() {\n+        final Thread getThread = new Thread() {\n             @Override\n             public void run() {\n                 try {\n                     init.get();\n-                } catch (ConcurrentException cex) {\n+                } catch (final ConcurrentException cex) {\n                     if (cex.getCause() instanceof InterruptedException) {\n                         iex.set((InterruptedException) cex.getCause());\n                     }\n      */\n     @Test\n     public void testIsStartedFalse() {\n-        BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n+        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n         assertFalse(\"Already started\", init.isStarted());\n     }\n \n      */\n     @Test\n     public void testIsStartedTrue() {\n-        BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n+        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n         init.start();\n         assertTrue(\"Not started\", init.isStarted());\n     }\n      */\n     @Test\n     public void testIsStartedAfterGet() {\n-        BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n+        final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl();\n         init.start();\n         checkInitialize(init);\n         assertTrue(\"Not started\", init.isStarted());\n--- a/src/test/java/org/apache/commons/lang3/concurrent/BasicThreadFactoryTest.java\n+++ b/src/test/java/org/apache/commons/lang3/concurrent/BasicThreadFactoryTest.java\n      */\n     @Test\n     public void testBuildDefaults() {\n-        BasicThreadFactory factory = builder.build();\n+        final BasicThreadFactory factory = builder.build();\n         checkFactoryDefaults(factory);\n     }\n \n      */\n     @Test\n     public void testBuilderReset() {\n-        ThreadFactory wrappedFactory = EasyMock.createMock(ThreadFactory.class);\n-        Thread.UncaughtExceptionHandler exHandler = EasyMock\n+        final ThreadFactory wrappedFactory = EasyMock.createMock(ThreadFactory.class);\n+        final Thread.UncaughtExceptionHandler exHandler = EasyMock\n                 .createMock(Thread.UncaughtExceptionHandler.class);\n         EasyMock.replay(wrappedFactory, exHandler);\n         builder.namingPattern(PATTERN).daemon(true).priority(\n                 Thread.MAX_PRIORITY).uncaughtExceptionHandler(exHandler)\n                 .wrappedFactory(wrappedFactory);\n         builder.reset();\n-        BasicThreadFactory factory = builder.build();\n+        final BasicThreadFactory factory = builder.build();\n         checkFactoryDefaults(factory);\n         assertNotSame(\"Wrapped factory not reset\", wrappedFactory, factory\n                 .getWrappedFactory());\n      */\n     @Test\n     public void testNewThreadNamingPattern() {\n-        ThreadFactory wrapped = EasyMock.createMock(ThreadFactory.class);\n-        Runnable r = EasyMock.createMock(Runnable.class);\n+        final ThreadFactory wrapped = EasyMock.createMock(ThreadFactory.class);\n+        final Runnable r = EasyMock.createMock(Runnable.class);\n         final int count = 12;\n         for (int i = 0; i < count; i++) {\n             EasyMock.expect(wrapped.newThread(r)).andReturn(new Thread());\n         }\n         EasyMock.replay(wrapped, r);\n-        BasicThreadFactory factory = builder.wrappedFactory(wrapped)\n+        final BasicThreadFactory factory = builder.wrappedFactory(wrapped)\n                 .namingPattern(PATTERN).build();\n         for (int i = 0; i < count; i++) {\n-            Thread t = factory.newThread(r);\n+            final Thread t = factory.newThread(r);\n             assertEquals(\"Wrong thread name\", String.format(PATTERN, Long\n                     .valueOf(i + 1)), t.getName());\n             assertEquals(\"Wrong thread count\", i + 1, factory.getThreadCount());\n      */\n     @Test\n     public void testNewThreadNoNamingPattern() {\n-        ThreadFactory wrapped = EasyMock.createMock(ThreadFactory.class);\n-        Runnable r = EasyMock.createMock(Runnable.class);\n+        final ThreadFactory wrapped = EasyMock.createMock(ThreadFactory.class);\n+        final Runnable r = EasyMock.createMock(Runnable.class);\n         final String name = \"unchangedThreadName\";\n-        Thread t = new Thread(name);\n-        EasyMock.expect(wrapped.newThread(r)).andReturn(t);\n-        EasyMock.replay(wrapped, r);\n-        BasicThreadFactory factory = builder.wrappedFactory(wrapped).build();\n+        final Thread t = new Thread(name);\n+        EasyMock.expect(wrapped.newThread(r)).andReturn(t);\n+        EasyMock.replay(wrapped, r);\n+        final BasicThreadFactory factory = builder.wrappedFactory(wrapped).build();\n         assertSame(\"Wrong thread\", t, factory.newThread(r));\n         assertEquals(\"Name was changed\", name, t.getName());\n         EasyMock.verify(wrapped, r);\n      * @param flag the value of the flag\n      */\n     private void checkDaemonFlag(final boolean flag) {\n-        ThreadFactory wrapped = EasyMock.createMock(ThreadFactory.class);\n-        Runnable r = EasyMock.createMock(Runnable.class);\n-        Thread t = new Thread();\n-        EasyMock.expect(wrapped.newThread(r)).andReturn(t);\n-        EasyMock.replay(wrapped, r);\n-        BasicThreadFactory factory = builder.wrappedFactory(wrapped).daemon(\n+        final ThreadFactory wrapped = EasyMock.createMock(ThreadFactory.class);\n+        final Runnable r = EasyMock.createMock(Runnable.class);\n+        final Thread t = new Thread();\n+        EasyMock.expect(wrapped.newThread(r)).andReturn(t);\n+        EasyMock.replay(wrapped, r);\n+        final BasicThreadFactory factory = builder.wrappedFactory(wrapped).daemon(\n                 flag).build();\n         assertSame(\"Wrong thread\", t, factory.newThread(r));\n         assertTrue(\"Wrong daemon flag\", flag == t.isDaemon());\n      */\n     @Test\n     public void testNewThreadNoDaemonFlag() {\n-        ThreadFactory wrapped = EasyMock.createMock(ThreadFactory.class);\n-        Runnable r1 = EasyMock.createMock(Runnable.class);\n-        Runnable r2 = EasyMock.createMock(Runnable.class);\n-        Thread t1 = new Thread();\n-        Thread t2 = new Thread();\n+        final ThreadFactory wrapped = EasyMock.createMock(ThreadFactory.class);\n+        final Runnable r1 = EasyMock.createMock(Runnable.class);\n+        final Runnable r2 = EasyMock.createMock(Runnable.class);\n+        final Thread t1 = new Thread();\n+        final Thread t2 = new Thread();\n         t1.setDaemon(true);\n         EasyMock.expect(wrapped.newThread(r1)).andReturn(t1);\n         EasyMock.expect(wrapped.newThread(r2)).andReturn(t2);\n         EasyMock.replay(wrapped, r1, r2);\n-        BasicThreadFactory factory = builder.wrappedFactory(wrapped).build();\n+        final BasicThreadFactory factory = builder.wrappedFactory(wrapped).build();\n         assertSame(\"Wrong thread 1\", t1, factory.newThread(r1));\n         assertTrue(\"No daemon thread\", t1.isDaemon());\n         assertSame(\"Wrong thread 2\", t2, factory.newThread(r2));\n      */\n     @Test\n     public void testNewThreadPriority() {\n-        ThreadFactory wrapped = EasyMock.createMock(ThreadFactory.class);\n-        Runnable r = EasyMock.createMock(Runnable.class);\n-        Thread t = new Thread();\n+        final ThreadFactory wrapped = EasyMock.createMock(ThreadFactory.class);\n+        final Runnable r = EasyMock.createMock(Runnable.class);\n+        final Thread t = new Thread();\n         EasyMock.expect(wrapped.newThread(r)).andReturn(t);\n         EasyMock.replay(wrapped, r);\n         final int priority = Thread.NORM_PRIORITY + 1;\n-        BasicThreadFactory factory = builder.wrappedFactory(wrapped).priority(\n+        final BasicThreadFactory factory = builder.wrappedFactory(wrapped).priority(\n                 priority).build();\n         assertSame(\"Wrong thread\", t, factory.newThread(r));\n         assertEquals(\"Wrong priority\", priority, t.getPriority());\n      */\n     @Test\n     public void testNewThreadNoPriority() {\n-        ThreadFactory wrapped = EasyMock.createMock(ThreadFactory.class);\n-        Runnable r = EasyMock.createMock(Runnable.class);\n+        final ThreadFactory wrapped = EasyMock.createMock(ThreadFactory.class);\n+        final Runnable r = EasyMock.createMock(Runnable.class);\n         final int orgPriority = Thread.NORM_PRIORITY + 1;\n-        Thread t = new Thread();\n+        final Thread t = new Thread();\n         t.setPriority(orgPriority);\n         EasyMock.expect(wrapped.newThread(r)).andReturn(t);\n         EasyMock.replay(wrapped, r);\n-        BasicThreadFactory factory = builder.wrappedFactory(wrapped).build();\n+        final BasicThreadFactory factory = builder.wrappedFactory(wrapped).build();\n         assertSame(\"Wrong thread\", t, factory.newThread(r));\n         assertEquals(\"Wrong priority\", orgPriority, t.getPriority());\n         EasyMock.verify(wrapped, r);\n      */\n     @Test\n     public void testNewThreadExHandler() {\n-        ThreadFactory wrapped = EasyMock.createMock(ThreadFactory.class);\n-        Runnable r = EasyMock.createMock(Runnable.class);\n-        Thread.UncaughtExceptionHandler handler = EasyMock\n+        final ThreadFactory wrapped = EasyMock.createMock(ThreadFactory.class);\n+        final Runnable r = EasyMock.createMock(Runnable.class);\n+        final Thread.UncaughtExceptionHandler handler = EasyMock\n                 .createMock(Thread.UncaughtExceptionHandler.class);\n-        Thread t = new Thread();\n+        final Thread t = new Thread();\n         EasyMock.expect(wrapped.newThread(r)).andReturn(t);\n         EasyMock.replay(wrapped, r, handler);\n-        BasicThreadFactory factory = builder.wrappedFactory(wrapped)\n+        final BasicThreadFactory factory = builder.wrappedFactory(wrapped)\n                 .uncaughtExceptionHandler(handler).build();\n         assertSame(\"Wrong thread\", t, factory.newThread(r));\n         assertEquals(\"Wrong exception handler\", handler, t\n      */\n     @Test\n     public void testNewThreadNoExHandler() {\n-        ThreadFactory wrapped = EasyMock.createMock(ThreadFactory.class);\n-        Runnable r = EasyMock.createMock(Runnable.class);\n-        Thread.UncaughtExceptionHandler handler = EasyMock\n+        final ThreadFactory wrapped = EasyMock.createMock(ThreadFactory.class);\n+        final Runnable r = EasyMock.createMock(Runnable.class);\n+        final Thread.UncaughtExceptionHandler handler = EasyMock\n                 .createMock(Thread.UncaughtExceptionHandler.class);\n-        Thread t = new Thread();\n+        final Thread t = new Thread();\n         t.setUncaughtExceptionHandler(handler);\n         EasyMock.expect(wrapped.newThread(r)).andReturn(t);\n         EasyMock.replay(wrapped, r, handler);\n-        BasicThreadFactory factory = builder.wrappedFactory(wrapped).build();\n+        final BasicThreadFactory factory = builder.wrappedFactory(wrapped).build();\n         assertSame(\"Wrong thread\", t, factory.newThread(r));\n         assertEquals(\"Wrong exception handler\", handler, t\n                 .getUncaughtExceptionHandler());\n--- a/src/test/java/org/apache/commons/lang3/concurrent/CallableBackgroundInitializerTest.java\n+++ b/src/test/java/org/apache/commons/lang3/concurrent/CallableBackgroundInitializerTest.java\n      */\n     @Test\n     public void testInitExecutor() {\n-        ExecutorService exec = Executors.newSingleThreadExecutor();\n-        CallableBackgroundInitializer<Integer> init = new CallableBackgroundInitializer<Integer>(\n+        final ExecutorService exec = Executors.newSingleThreadExecutor();\n+        final CallableBackgroundInitializer<Integer> init = new CallableBackgroundInitializer<Integer>(\n                 new TestCallable(), exec);\n         assertEquals(\"Executor not set\", exec, init.getExternalExecutor());\n     }\n      */\n     @Test(expected=IllegalArgumentException.class)\n     public void testInitExecutorNullCallable() {\n-        ExecutorService exec = Executors.newSingleThreadExecutor();\n+        final ExecutorService exec = Executors.newSingleThreadExecutor();\n         new CallableBackgroundInitializer<Integer>(null, exec);\n     }\n \n      */\n     @Test\n     public void testInitialize() throws Exception {\n-        TestCallable call = new TestCallable();\n-        CallableBackgroundInitializer<Integer> init = new CallableBackgroundInitializer<Integer>(\n+        final TestCallable call = new TestCallable();\n+        final CallableBackgroundInitializer<Integer> init = new CallableBackgroundInitializer<Integer>(\n                 call);\n         assertEquals(\"Wrong result\", RESULT, init.initialize());\n         assertEquals(\"Wrong number of invocations\", 1, call.callCount);\n--- a/src/test/java/org/apache/commons/lang3/concurrent/ConcurrentUtilsTest.java\n+++ b/src/test/java/org/apache/commons/lang3/concurrent/ConcurrentUtilsTest.java\n      */\n     @Test\n     public void testExtractCauseError() {\n-        Error err = new AssertionError(\"Test\");\n+        final Error err = new AssertionError(\"Test\");\n         try {\n             ConcurrentUtils.extractCause(new ExecutionException(err));\n             fail(\"Error not thrown!\");\n-        } catch (Error e) {\n+        } catch (final Error e) {\n             assertEquals(\"Wrong error\", err, e);\n         }\n     }\n      */\n     @Test\n     public void testExtractCauseUncheckedException() {\n-        RuntimeException rex = new RuntimeException(\"Test\");\n+        final RuntimeException rex = new RuntimeException(\"Test\");\n         try {\n             ConcurrentUtils.extractCause(new ExecutionException(rex));\n             fail(\"Runtime exception not thrown!\");\n-        } catch (RuntimeException r) {\n+        } catch (final RuntimeException r) {\n             assertEquals(\"Wrong exception\", rex, r);\n         }\n     }\n      */\n     @Test\n     public void testExtractCauseChecked() {\n-        Exception ex = new Exception(\"Test\");\n-        ConcurrentException cex = ConcurrentUtils\n+        final Exception ex = new Exception(\"Test\");\n+        final ConcurrentException cex = ConcurrentUtils\n                 .extractCause(new ExecutionException(ex));\n         assertSame(\"Wrong cause\", ex, cex.getCause());\n     }\n      */\n     @Test\n     public void testExtractCauseUncheckedError() {\n-        Error err = new AssertionError(\"Test\");\n+        final Error err = new AssertionError(\"Test\");\n         try {\n             ConcurrentUtils.extractCauseUnchecked(new ExecutionException(err));\n             fail(\"Error not thrown!\");\n-        } catch (Error e) {\n+        } catch (final Error e) {\n             assertEquals(\"Wrong error\", err, e);\n         }\n     }\n      */\n     @Test\n     public void testExtractCauseUncheckedUncheckedException() {\n-        RuntimeException rex = new RuntimeException(\"Test\");\n+        final RuntimeException rex = new RuntimeException(\"Test\");\n         try {\n             ConcurrentUtils.extractCauseUnchecked(new ExecutionException(rex));\n             fail(\"Runtime exception not thrown!\");\n-        } catch (RuntimeException r) {\n+        } catch (final RuntimeException r) {\n             assertEquals(\"Wrong exception\", rex, r);\n         }\n     }\n      */\n     @Test\n     public void testExtractCauseUncheckedChecked() {\n-        Exception ex = new Exception(\"Test\");\n-        ConcurrentRuntimeException cex = ConcurrentUtils\n+        final Exception ex = new Exception(\"Test\");\n+        final ConcurrentRuntimeException cex = ConcurrentUtils\n                 .extractCauseUnchecked(new ExecutionException(ex));\n         assertSame(\"Wrong cause\", ex, cex.getCause());\n     }\n      */\n     @Test\n     public void testHandleCauseError() throws ConcurrentException {\n-        Error err = new AssertionError(\"Test\");\n+        final Error err = new AssertionError(\"Test\");\n         try {\n             ConcurrentUtils.handleCause(new ExecutionException(err));\n             fail(\"Error not thrown!\");\n-        } catch (Error e) {\n+        } catch (final Error e) {\n             assertEquals(\"Wrong error\", err, e);\n         }\n     }\n      */\n     @Test\n     public void testHandleCauseUncheckedException() throws ConcurrentException {\n-        RuntimeException rex = new RuntimeException(\"Test\");\n+        final RuntimeException rex = new RuntimeException(\"Test\");\n         try {\n             ConcurrentUtils.handleCause(new ExecutionException(rex));\n             fail(\"Runtime exception not thrown!\");\n-        } catch (RuntimeException r) {\n+        } catch (final RuntimeException r) {\n             assertEquals(\"Wrong exception\", rex, r);\n         }\n     }\n      */\n     @Test\n     public void testHandleCauseChecked() {\n-        Exception ex = new Exception(\"Test\");\n+        final Exception ex = new Exception(\"Test\");\n         try {\n             ConcurrentUtils.handleCause(new ExecutionException(ex));\n             fail(\"ConcurrentException not thrown!\");\n-        } catch (ConcurrentException cex) {\n+        } catch (final ConcurrentException cex) {\n             assertEquals(\"Wrong cause\", ex, cex.getCause());\n         }\n     }\n      */\n     @Test\n     public void testHandleCauseUncheckedError() {\n-        Error err = new AssertionError(\"Test\");\n+        final Error err = new AssertionError(\"Test\");\n         try {\n             ConcurrentUtils.handleCauseUnchecked(new ExecutionException(err));\n             fail(\"Error not thrown!\");\n-        } catch (Error e) {\n+        } catch (final Error e) {\n             assertEquals(\"Wrong error\", err, e);\n         }\n     }\n      */\n     @Test\n     public void testHandleCauseUncheckedUncheckedException() {\n-        RuntimeException rex = new RuntimeException(\"Test\");\n+        final RuntimeException rex = new RuntimeException(\"Test\");\n         try {\n             ConcurrentUtils.handleCauseUnchecked(new ExecutionException(rex));\n             fail(\"Runtime exception not thrown!\");\n-        } catch (RuntimeException r) {\n+        } catch (final RuntimeException r) {\n             assertEquals(\"Wrong exception\", rex, r);\n         }\n     }\n      */\n     @Test\n     public void testHandleCauseUncheckedChecked() {\n-        Exception ex = new Exception(\"Test\");\n+        final Exception ex = new Exception(\"Test\");\n         try {\n             ConcurrentUtils.handleCauseUnchecked(new ExecutionException(ex));\n             fail(\"ConcurrentRuntimeException not thrown!\");\n-        } catch (ConcurrentRuntimeException crex) {\n+        } catch (final ConcurrentRuntimeException crex) {\n             assertEquals(\"Wrong cause\", ex, crex.getCause());\n         }\n     }\n     @Test\n     public void testInitialize() throws ConcurrentException {\n         @SuppressWarnings(\"unchecked\")\n+        final\n         ConcurrentInitializer<Object> init = EasyMock\n                 .createMock(ConcurrentInitializer.class);\n         final Object result = new Object();\n     @Test\n     public void testInitializeUnchecked() throws ConcurrentException {\n         @SuppressWarnings(\"unchecked\")\n+        final\n         ConcurrentInitializer<Object> init = EasyMock\n                 .createMock(ConcurrentInitializer.class);\n         final Object result = new Object();\n     @Test\n     public void testInitializeUncheckedEx() throws ConcurrentException {\n         @SuppressWarnings(\"unchecked\")\n+        final\n         ConcurrentInitializer<Object> init = EasyMock\n                 .createMock(ConcurrentInitializer.class);\n         final Exception cause = new Exception();\n         try {\n             ConcurrentUtils.initializeUnchecked(init);\n             fail(\"Exception not thrown!\");\n-        } catch (ConcurrentRuntimeException crex) {\n+        } catch (final ConcurrentRuntimeException crex) {\n             assertSame(\"Wrong cause\", cause, crex.getCause());\n         }\n         EasyMock.verify(init);\n      */\n     @Test\n     public void testConstantFuture_Integer() throws Exception {\n-        Integer value = Integer.valueOf(5);\n-        Future<Integer> test = ConcurrentUtils.constantFuture(value);\n+        final Integer value = Integer.valueOf(5);\n+        final Future<Integer> test = ConcurrentUtils.constantFuture(value);\n         assertTrue(test.isDone());\n         assertSame(value, test.get());\n         assertSame(value, test.get(1000, TimeUnit.SECONDS));\n      */\n     @Test\n     public void testConstantFuture_null() throws Exception {\n-        Integer value = null;\n-        Future<Integer> test = ConcurrentUtils.constantFuture(value);\n+        final Integer value = null;\n+        final Future<Integer> test = ConcurrentUtils.constantFuture(value);\n         assertTrue(test.isDone());\n         assertSame(value, test.get());\n         assertSame(value, test.get(1000, TimeUnit.SECONDS));\n     public void testPutIfAbsentKeyPresent() {\n         final String key = \"testKey\";\n         final Integer value = 42;\n-        ConcurrentMap<String, Integer> map = new ConcurrentHashMap<String, Integer>();\n+        final ConcurrentMap<String, Integer> map = new ConcurrentHashMap<String, Integer>();\n         map.put(key, value);\n         assertEquals(\"Wrong result\", value,\n                 ConcurrentUtils.putIfAbsent(map, key, 0));\n     public void testPutIfAbsentKeyNotPresent() {\n         final String key = \"testKey\";\n         final Integer value = 42;\n-        ConcurrentMap<String, Integer> map = new ConcurrentHashMap<String, Integer>();\n+        final ConcurrentMap<String, Integer> map = new ConcurrentHashMap<String, Integer>();\n         assertEquals(\"Wrong result\", value,\n                 ConcurrentUtils.putIfAbsent(map, key, value));\n         assertEquals(\"Wrong value in map\", value, map.get(key));\n     @Test\n     public void testCreateIfAbsentKeyPresent() throws ConcurrentException {\n         @SuppressWarnings(\"unchecked\")\n+        final\n         ConcurrentInitializer<Integer> init = EasyMock\n                 .createMock(ConcurrentInitializer.class);\n         EasyMock.replay(init);\n         final String key = \"testKey\";\n         final Integer value = 42;\n-        ConcurrentMap<String, Integer> map = new ConcurrentHashMap<String, Integer>();\n+        final ConcurrentMap<String, Integer> map = new ConcurrentHashMap<String, Integer>();\n         map.put(key, value);\n         assertEquals(\"Wrong result\", value,\n                 ConcurrentUtils.createIfAbsent(map, key, init));\n     @Test\n     public void testCreateIfAbsentKeyNotPresent() throws ConcurrentException {\n         @SuppressWarnings(\"unchecked\")\n+        final\n         ConcurrentInitializer<Integer> init = EasyMock\n                 .createMock(ConcurrentInitializer.class);\n         final String key = \"testKey\";\n         final Integer value = 42;\n         EasyMock.expect(init.get()).andReturn(value);\n         EasyMock.replay(init);\n-        ConcurrentMap<String, Integer> map = new ConcurrentHashMap<String, Integer>();\n+        final ConcurrentMap<String, Integer> map = new ConcurrentHashMap<String, Integer>();\n         assertEquals(\"Wrong result\", value,\n                 ConcurrentUtils.createIfAbsent(map, key, init));\n         assertEquals(\"Wrong value in map\", value, map.get(key));\n     @Test\n     public void testCreateIfAbsentNullMap() throws ConcurrentException {\n         @SuppressWarnings(\"unchecked\")\n+        final\n         ConcurrentInitializer<Integer> init = EasyMock\n                 .createMock(ConcurrentInitializer.class);\n         EasyMock.replay(init);\n      */\n     @Test\n     public void testCreateIfAbsentNullInit() throws ConcurrentException {\n-        ConcurrentMap<String, Integer> map = new ConcurrentHashMap<String, Integer>();\n+        final ConcurrentMap<String, Integer> map = new ConcurrentHashMap<String, Integer>();\n         final String key = \"testKey\";\n         final Integer value = 42;\n         map.put(key, value);\n     public void testCreateIfAbsentUncheckedSuccess() {\n         final String key = \"testKey\";\n         final Integer value = 42;\n-        ConcurrentMap<String, Integer> map = new ConcurrentHashMap<String, Integer>();\n+        final ConcurrentMap<String, Integer> map = new ConcurrentHashMap<String, Integer>();\n         assertEquals(\"Wrong result\", value,\n                 ConcurrentUtils.createIfAbsentUnchecked(map, key,\n                         new ConstantInitializer<Integer>(value)));\n     public void testCreateIfAbsentUncheckedException()\n             throws ConcurrentException {\n         @SuppressWarnings(\"unchecked\")\n+        final\n         ConcurrentInitializer<Integer> init = EasyMock\n                 .createMock(ConcurrentInitializer.class);\n-        Exception ex = new Exception();\n+        final Exception ex = new Exception();\n         EasyMock.expect(init.get()).andThrow(new ConcurrentException(ex));\n         EasyMock.replay(init);\n         try {\n             ConcurrentUtils.createIfAbsentUnchecked(\n                     new ConcurrentHashMap<String, Integer>(), \"test\", init);\n             fail(\"Exception not thrown!\");\n-        } catch (ConcurrentRuntimeException crex) {\n+        } catch (final ConcurrentRuntimeException crex) {\n             assertEquals(\"Wrong cause\", ex, crex.getCause());\n         }\n         EasyMock.verify(init);\n--- a/src/test/java/org/apache/commons/lang3/concurrent/ConstantInitializerTest.java\n+++ b/src/test/java/org/apache/commons/lang3/concurrent/ConstantInitializerTest.java\n      */\n     @Test\n     public void testToString() {\n-        String s = init.toString();\n-        Pattern pattern = Pattern\n+        final String s = init.toString();\n+        final Pattern pattern = Pattern\n                 .compile(\"ConstantInitializer@\\\\d+ \\\\[ object = \" + VALUE\n                         + \" \\\\]\");\n         assertTrue(\"Wrong string: \" + s, pattern.matcher(s).matches());\n      */\n     @Test\n     public void testToStringNull() {\n-        String s = new ConstantInitializer<Object>(null).toString();\n+        final String s = new ConstantInitializer<Object>(null).toString();\n         assertTrue(\"Object not found: \" + s, s.indexOf(\"object = null\") > 0);\n     }\n }\n--- a/src/test/java/org/apache/commons/lang3/concurrent/MultiBackgroundInitializerTest.java\n+++ b/src/test/java/org/apache/commons/lang3/concurrent/MultiBackgroundInitializerTest.java\n      */\n     private void checkChild(final BackgroundInitializer<?> child,\n             final ExecutorService expExec) throws ConcurrentException {\n-        ChildBackgroundInitializer cinit = (ChildBackgroundInitializer) child;\n-        Integer result = cinit.get();\n+        final ChildBackgroundInitializer cinit = (ChildBackgroundInitializer) child;\n+        final Integer result = cinit.get();\n         assertEquals(\"Wrong result\", 1, result.intValue());\n         assertEquals(\"Wrong number of executions\", 1, cinit.initializeCalls);\n         if (expExec != null) {\n     @Test\n     public void testInitializeNoChildren() throws ConcurrentException {\n         assertTrue(\"Wrong result of start()\", initializer.start());\n-        MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n+        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n                 .get();\n         assertTrue(\"Got child initializers\", res.initializerNames().isEmpty());\n         assertTrue(\"Executor not shutdown\", initializer.getActiveExecutor()\n                     new ChildBackgroundInitializer());\n         }\n         initializer.start();\n-        MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n+        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n                 .get();\n         assertEquals(\"Wrong number of child initializers\", count, res\n                 .initializerNames().size());\n         for (int i = 0; i < count; i++) {\n-            String key = CHILD_INIT + i;\n+            final String key = CHILD_INIT + i;\n             assertTrue(\"Name not found: \" + key, res.initializerNames()\n                     .contains(key));\n             assertEquals(\"Wrong result object\", Integer.valueOf(1), res\n      */\n     @Test\n     public void testInitializeExternalExec() throws ConcurrentException {\n-        ExecutorService exec = Executors.newCachedThreadPool();\n+        final ExecutorService exec = Executors.newCachedThreadPool();\n         try {\n             initializer = new MultiBackgroundInitializer(exec);\n             checkInitialize();\n     @Test\n     public void testInitializeChildWithExecutor() throws ConcurrentException {\n         final String initExec = \"childInitializerWithExecutor\";\n-        ExecutorService exec = Executors.newSingleThreadExecutor();\n+        final ExecutorService exec = Executors.newSingleThreadExecutor();\n         try {\n-            ChildBackgroundInitializer c1 = new ChildBackgroundInitializer();\n-            ChildBackgroundInitializer c2 = new ChildBackgroundInitializer();\n+            final ChildBackgroundInitializer c1 = new ChildBackgroundInitializer();\n+            final ChildBackgroundInitializer c2 = new ChildBackgroundInitializer();\n             c2.setExternalExecutor(exec);\n             initializer.addInitializer(CHILD_INIT, c1);\n             initializer.addInitializer(initExec, c2);\n             initializer.addInitializer(CHILD_INIT,\n                     new ChildBackgroundInitializer());\n             fail(\"Could add initializer after start()!\");\n-        } catch (IllegalStateException istex) {\n+        } catch (final IllegalStateException istex) {\n             initializer.get();\n         }\n     }\n      */\n     @Test(expected = NoSuchElementException.class)\n     public void testResultGetInitializerUnknown() throws ConcurrentException {\n-        MultiBackgroundInitializer.MultiBackgroundInitializerResults res = checkInitialize();\n+        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = checkInitialize();\n         res.getInitializer(\"unknown\");\n     }\n \n      */\n     @Test(expected = NoSuchElementException.class)\n     public void testResultGetResultObjectUnknown() throws ConcurrentException {\n-        MultiBackgroundInitializer.MultiBackgroundInitializerResults res = checkInitialize();\n+        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = checkInitialize();\n         res.getResultObject(\"unknown\");\n     }\n \n      */\n     @Test(expected = NoSuchElementException.class)\n     public void testResultGetExceptionUnknown() throws ConcurrentException {\n-        MultiBackgroundInitializer.MultiBackgroundInitializerResults res = checkInitialize();\n+        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = checkInitialize();\n         res.getException(\"unknown\");\n     }\n \n      */\n     @Test(expected = NoSuchElementException.class)\n     public void testResultIsExceptionUnknown() throws ConcurrentException {\n-        MultiBackgroundInitializer.MultiBackgroundInitializerResults res = checkInitialize();\n+        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = checkInitialize();\n         res.isException(\"unknown\");\n     }\n \n     @Test(expected = UnsupportedOperationException.class)\n     public void testResultInitializerNamesModify() throws ConcurrentException {\n         checkInitialize();\n-        MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n-                .get();\n-        Iterator<String> it = res.initializerNames().iterator();\n+        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n+                .get();\n+        final Iterator<String> it = res.initializerNames().iterator();\n         it.next();\n         it.remove();\n     }\n      */\n     @Test\n     public void testInitializeRuntimeEx() {\n-        ChildBackgroundInitializer child = new ChildBackgroundInitializer();\n+        final ChildBackgroundInitializer child = new ChildBackgroundInitializer();\n         child.ex = new RuntimeException();\n         initializer.addInitializer(CHILD_INIT, child);\n         initializer.start();\n         try {\n             initializer.get();\n             fail(\"Runtime exception not thrown!\");\n-        } catch (Exception ex) {\n+        } catch (final Exception ex) {\n             assertEquals(\"Wrong exception\", child.ex, ex);\n         }\n     }\n      */\n     @Test\n     public void testInitializeEx() throws ConcurrentException {\n-        ChildBackgroundInitializer child = new ChildBackgroundInitializer();\n+        final ChildBackgroundInitializer child = new ChildBackgroundInitializer();\n         child.ex = new Exception();\n         initializer.addInitializer(CHILD_INIT, child);\n         initializer.start();\n-        MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n+        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n                 .get();\n         assertTrue(\"No exception flag\", res.isException(CHILD_INIT));\n         assertNull(\"Got a results object\", res.getResultObject(CHILD_INIT));\n-        ConcurrentException cex = res.getException(CHILD_INIT);\n+        final ConcurrentException cex = res.getException(CHILD_INIT);\n         assertEquals(\"Wrong cause\", child.ex, cex.getCause());\n     }\n \n     @Test\n     public void testInitializeResultsIsSuccessfulTrue()\n             throws ConcurrentException {\n-        ChildBackgroundInitializer child = new ChildBackgroundInitializer();\n+        final ChildBackgroundInitializer child = new ChildBackgroundInitializer();\n         initializer.addInitializer(CHILD_INIT, child);\n         initializer.start();\n-        MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n+        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n                 .get();\n         assertTrue(\"Wrong success flag\", res.isSuccessful());\n     }\n     @Test\n     public void testInitializeResultsIsSuccessfulFalse()\n             throws ConcurrentException {\n-        ChildBackgroundInitializer child = new ChildBackgroundInitializer();\n+        final ChildBackgroundInitializer child = new ChildBackgroundInitializer();\n         child.ex = new Exception();\n         initializer.addInitializer(CHILD_INIT, child);\n         initializer.start();\n-        MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n+        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n                 .get();\n         assertFalse(\"Wrong success flag\", res.isSuccessful());\n     }\n         final String nameMulti = \"multiChildInitializer\";\n         initializer\n                 .addInitializer(CHILD_INIT, new ChildBackgroundInitializer());\n-        MultiBackgroundInitializer mi2 = new MultiBackgroundInitializer();\n+        final MultiBackgroundInitializer mi2 = new MultiBackgroundInitializer();\n         final int count = 3;\n         for (int i = 0; i < count; i++) {\n             mi2\n         }\n         initializer.addInitializer(nameMulti, mi2);\n         initializer.start();\n-        MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n-                .get();\n-        ExecutorService exec = initializer.getActiveExecutor();\n+        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer\n+                .get();\n+        final ExecutorService exec = initializer.getActiveExecutor();\n         checkChild(res.getInitializer(CHILD_INIT), exec);\n-        MultiBackgroundInitializer.MultiBackgroundInitializerResults res2 = (MultiBackgroundInitializer.MultiBackgroundInitializerResults) res\n+        final MultiBackgroundInitializer.MultiBackgroundInitializerResults res2 = (MultiBackgroundInitializer.MultiBackgroundInitializerResults) res\n                 .getResultObject(nameMulti);\n         assertEquals(\"Wrong number of initializers\", count, res2\n                 .initializerNames().size());\n--- a/src/test/java/org/apache/commons/lang3/concurrent/TimedSemaphoreTest.java\n+++ b/src/test/java/org/apache/commons/lang3/concurrent/TimedSemaphoreTest.java\n      */\n     @Test\n     public void testInit() {\n-        ScheduledExecutorService service = EasyMock\n+        final ScheduledExecutorService service = EasyMock\n                 .createMock(ScheduledExecutorService.class);\n         EasyMock.replay(service);\n-        TimedSemaphore semaphore = new TimedSemaphore(service, PERIOD, UNIT,\n+        final TimedSemaphore semaphore = new TimedSemaphore(service, PERIOD, UNIT,\n                 LIMIT);\n         EasyMock.verify(service);\n         assertEquals(\"Wrong service\", service, semaphore.getExecutorService());\n      */\n     @Test\n     public void testInitDefaultService() {\n-        TimedSemaphore semaphore = new TimedSemaphore(PERIOD, UNIT, LIMIT);\n-        ScheduledThreadPoolExecutor exec = (ScheduledThreadPoolExecutor) semaphore\n+        final TimedSemaphore semaphore = new TimedSemaphore(PERIOD, UNIT, LIMIT);\n+        final ScheduledThreadPoolExecutor exec = (ScheduledThreadPoolExecutor) semaphore\n                 .getExecutorService();\n         assertFalse(\"Wrong periodic task policy\", exec\n                 .getContinueExistingPeriodicTasksAfterShutdownPolicy());\n      */\n     @Test\n     public void testStartTimer() throws InterruptedException {\n-        TimedSemaphoreTestImpl semaphore = new TimedSemaphoreTestImpl(PERIOD,\n+        final TimedSemaphoreTestImpl semaphore = new TimedSemaphoreTestImpl(PERIOD,\n                 UNIT, LIMIT);\n-        ScheduledFuture<?> future = semaphore.startTimer();\n+        final ScheduledFuture<?> future = semaphore.startTimer();\n         assertNotNull(\"No future returned\", future);\n         Thread.sleep(PERIOD);\n         final int trials = 10;\n      */\n     @Test\n     public void testShutdownOwnExecutor() {\n-        TimedSemaphore semaphore = new TimedSemaphore(PERIOD, UNIT, LIMIT);\n+        final TimedSemaphore semaphore = new TimedSemaphore(PERIOD, UNIT, LIMIT);\n         semaphore.shutdown();\n         assertTrue(\"Not shutdown\", semaphore.isShutdown());\n         assertTrue(\"Executor not shutdown\", semaphore.getExecutorService()\n      */\n     @Test\n     public void testShutdownSharedExecutorNoTask() {\n-        ScheduledExecutorService service = EasyMock\n+        final ScheduledExecutorService service = EasyMock\n                 .createMock(ScheduledExecutorService.class);\n         EasyMock.replay(service);\n-        TimedSemaphore semaphore = new TimedSemaphore(service, PERIOD, UNIT,\n+        final TimedSemaphore semaphore = new TimedSemaphore(service, PERIOD, UNIT,\n                 LIMIT);\n         semaphore.shutdown();\n         assertTrue(\"Not shutdown\", semaphore.isShutdown());\n      */\n     @Test\n     public void testShutdownSharedExecutorTask() throws InterruptedException {\n-        ScheduledExecutorService service = EasyMock\n-                .createMock(ScheduledExecutorService.class);\n-        ScheduledFuture<?> future = EasyMock.createMock(ScheduledFuture.class);\n+        final ScheduledExecutorService service = EasyMock\n+                .createMock(ScheduledExecutorService.class);\n+        final ScheduledFuture<?> future = EasyMock.createMock(ScheduledFuture.class);\n         prepareStartTimer(service, future);\n         EasyMock.expect(Boolean.valueOf(future.cancel(false))).andReturn(Boolean.TRUE);\n         EasyMock.replay(service, future);\n-        TimedSemaphoreTestImpl semaphore = new TimedSemaphoreTestImpl(service,\n+        final TimedSemaphoreTestImpl semaphore = new TimedSemaphoreTestImpl(service,\n                 PERIOD, UNIT, LIMIT);\n         semaphore.acquire();\n         semaphore.shutdown();\n      */\n     @Test\n     public void testShutdownMultipleTimes() throws InterruptedException {\n-        ScheduledExecutorService service = EasyMock\n-                .createMock(ScheduledExecutorService.class);\n-        ScheduledFuture<?> future = EasyMock.createMock(ScheduledFuture.class);\n+        final ScheduledExecutorService service = EasyMock\n+                .createMock(ScheduledExecutorService.class);\n+        final ScheduledFuture<?> future = EasyMock.createMock(ScheduledFuture.class);\n         prepareStartTimer(service, future);\n         EasyMock.expect(Boolean.valueOf(future.cancel(false))).andReturn(Boolean.TRUE);\n         EasyMock.replay(service, future);\n-        TimedSemaphoreTestImpl semaphore = new TimedSemaphoreTestImpl(service,\n+        final TimedSemaphoreTestImpl semaphore = new TimedSemaphoreTestImpl(service,\n                 PERIOD, UNIT, LIMIT);\n         semaphore.acquire();\n         for (int i = 0; i < 10; i++) {\n      */\n     @Test\n     public void testAcquireLimit() throws InterruptedException {\n-        ScheduledExecutorService service = EasyMock\n-                .createMock(ScheduledExecutorService.class);\n-        ScheduledFuture<?> future = EasyMock.createMock(ScheduledFuture.class);\n+        final ScheduledExecutorService service = EasyMock\n+                .createMock(ScheduledExecutorService.class);\n+        final ScheduledFuture<?> future = EasyMock.createMock(ScheduledFuture.class);\n         prepareStartTimer(service, future);\n         EasyMock.replay(service, future);\n         final int count = 10;\n-        CountDownLatch latch = new CountDownLatch(count - 1);\n-        TimedSemaphore semaphore = new TimedSemaphore(service, PERIOD, UNIT, 1);\n-        SemaphoreThread t = new SemaphoreThread(semaphore, latch, count,\n+        final CountDownLatch latch = new CountDownLatch(count - 1);\n+        final TimedSemaphore semaphore = new TimedSemaphore(service, PERIOD, UNIT, 1);\n+        final SemaphoreThread t = new SemaphoreThread(semaphore, latch, count,\n                 count - 1);\n         semaphore.setLimit(count - 1);\n \n      */\n     @Test\n     public void testAcquireMultipleThreads() throws InterruptedException {\n-        ScheduledExecutorService service = EasyMock\n-                .createMock(ScheduledExecutorService.class);\n-        ScheduledFuture<?> future = EasyMock.createMock(ScheduledFuture.class);\n-        prepareStartTimer(service, future);\n-        EasyMock.replay(service, future);\n-        TimedSemaphoreTestImpl semaphore = new TimedSemaphoreTestImpl(service,\n+        final ScheduledExecutorService service = EasyMock\n+                .createMock(ScheduledExecutorService.class);\n+        final ScheduledFuture<?> future = EasyMock.createMock(ScheduledFuture.class);\n+        prepareStartTimer(service, future);\n+        EasyMock.replay(service, future);\n+        final TimedSemaphoreTestImpl semaphore = new TimedSemaphoreTestImpl(service,\n                 PERIOD, UNIT, 1);\n         semaphore.latch = new CountDownLatch(1);\n         final int count = 10;\n-        SemaphoreThread[] threads = new SemaphoreThread[count];\n+        final SemaphoreThread[] threads = new SemaphoreThread[count];\n         for (int i = 0; i < count; i++) {\n             threads[i] = new SemaphoreThread(semaphore, null, 1, 0);\n             threads[i].start();\n      */\n     @Test\n     public void testAcquireNoLimit() throws InterruptedException {\n-        ScheduledExecutorService service = EasyMock\n-                .createMock(ScheduledExecutorService.class);\n-        ScheduledFuture<?> future = EasyMock.createMock(ScheduledFuture.class);\n-        prepareStartTimer(service, future);\n-        EasyMock.replay(service, future);\n-        TimedSemaphoreTestImpl semaphore = new TimedSemaphoreTestImpl(service,\n+        final ScheduledExecutorService service = EasyMock\n+                .createMock(ScheduledExecutorService.class);\n+        final ScheduledFuture<?> future = EasyMock.createMock(ScheduledFuture.class);\n+        prepareStartTimer(service, future);\n+        EasyMock.replay(service, future);\n+        final TimedSemaphoreTestImpl semaphore = new TimedSemaphoreTestImpl(service,\n                 PERIOD, UNIT, TimedSemaphore.NO_LIMIT);\n         final int count = 1000;\n-        CountDownLatch latch = new CountDownLatch(count);\n-        SemaphoreThread t = new SemaphoreThread(semaphore, latch, count, count);\n+        final CountDownLatch latch = new CountDownLatch(count);\n+        final SemaphoreThread t = new SemaphoreThread(semaphore, latch, count, count);\n         t.start();\n         latch.await();\n         EasyMock.verify(service, future);\n      */\n     @Test(expected = IllegalStateException.class)\n     public void testPassAfterShutdown() throws InterruptedException {\n-        TimedSemaphore semaphore = new TimedSemaphore(PERIOD, UNIT, LIMIT);\n+        final TimedSemaphore semaphore = new TimedSemaphore(PERIOD, UNIT, LIMIT);\n         semaphore.shutdown();\n         semaphore.acquire();\n     }\n     @Test\n     public void testAcquireMultiplePeriods() throws InterruptedException {\n         final int count = 1000;\n-        TimedSemaphoreTestImpl semaphore = new TimedSemaphoreTestImpl(\n+        final TimedSemaphoreTestImpl semaphore = new TimedSemaphoreTestImpl(\n                 PERIOD / 10, TimeUnit.MILLISECONDS, 1);\n         semaphore.setLimit(count / 4);\n-        CountDownLatch latch = new CountDownLatch(count);\n-        SemaphoreThread t = new SemaphoreThread(semaphore, latch, count, count);\n+        final CountDownLatch latch = new CountDownLatch(count);\n+        final SemaphoreThread t = new SemaphoreThread(semaphore, latch, count, count);\n         t.start();\n         latch.await();\n         semaphore.shutdown();\n      */\n     @Test\n     public void testGetAverageCallsPerPeriod() throws InterruptedException {\n-        ScheduledExecutorService service = EasyMock\n-                .createMock(ScheduledExecutorService.class);\n-        ScheduledFuture<?> future = EasyMock.createMock(ScheduledFuture.class);\n-        prepareStartTimer(service, future);\n-        EasyMock.replay(service, future);\n-        TimedSemaphore semaphore = new TimedSemaphore(service, PERIOD, UNIT,\n+        final ScheduledExecutorService service = EasyMock\n+                .createMock(ScheduledExecutorService.class);\n+        final ScheduledFuture<?> future = EasyMock.createMock(ScheduledFuture.class);\n+        prepareStartTimer(service, future);\n+        EasyMock.replay(service, future);\n+        final TimedSemaphore semaphore = new TimedSemaphore(service, PERIOD, UNIT,\n                 LIMIT);\n         semaphore.acquire();\n         semaphore.endOfPeriod();\n      */\n     @Test\n     public void testGetAvailablePermits() throws InterruptedException {\n-        ScheduledExecutorService service = EasyMock\n-                .createMock(ScheduledExecutorService.class);\n-        ScheduledFuture<?> future = EasyMock.createMock(ScheduledFuture.class);\n-        prepareStartTimer(service, future);\n-        EasyMock.replay(service, future);\n-        TimedSemaphore semaphore = new TimedSemaphore(service, PERIOD, UNIT,\n+        final ScheduledExecutorService service = EasyMock\n+                .createMock(ScheduledExecutorService.class);\n+        final ScheduledFuture<?> future = EasyMock.createMock(ScheduledFuture.class);\n+        prepareStartTimer(service, future);\n+        EasyMock.replay(service, future);\n+        final TimedSemaphore semaphore = new TimedSemaphore(service, PERIOD, UNIT,\n                 LIMIT);\n         for (int i = 0; i < LIMIT; i++) {\n             assertEquals(\"Wrong available count at \" + i, LIMIT - i, semaphore\n                         latch.countDown();\n                     }\n                 }\n-            } catch (InterruptedException iex) {\n+            } catch (final InterruptedException iex) {\n                 Thread.currentThread().interrupt();\n             }\n         }\n--- a/src/test/java/org/apache/commons/lang3/event/EventListenerSupportTest.java\n+++ b/src/test/java/org/apache/commons/lang3/event/EventListenerSupportTest.java\n     @Test(expected=NullPointerException.class)\n     public void testAddNullListener()\n     {\n-        EventListenerSupport<VetoableChangeListener> listenerSupport = EventListenerSupport.create(VetoableChangeListener.class);\n+        final EventListenerSupport<VetoableChangeListener> listenerSupport = EventListenerSupport.create(VetoableChangeListener.class);\n         listenerSupport.addListener(null);\n     }\n \n     @Test(expected=NullPointerException.class)\n     public void testRemoveNullListener()\n     {\n-        EventListenerSupport<VetoableChangeListener> listenerSupport = EventListenerSupport.create(VetoableChangeListener.class);\n+        final EventListenerSupport<VetoableChangeListener> listenerSupport = EventListenerSupport.create(VetoableChangeListener.class);\n         listenerSupport.removeListener(null);\n     }\n \n     @Test\n     public void testEventDispatchOrder() throws PropertyVetoException\n     {\n-        EventListenerSupport<VetoableChangeListener> listenerSupport = EventListenerSupport.create(VetoableChangeListener.class);\n+        final EventListenerSupport<VetoableChangeListener> listenerSupport = EventListenerSupport.create(VetoableChangeListener.class);\n         final List<VetoableChangeListener> calledListeners = new ArrayList<VetoableChangeListener>();\n \n         final VetoableChangeListener listener1 = createListener(calledListeners);\n     public void testGetListeners() {\n         final EventListenerSupport<VetoableChangeListener> listenerSupport = EventListenerSupport.create(VetoableChangeListener.class);\n \n-        VetoableChangeListener[] listeners = listenerSupport.getListeners();\n+        final VetoableChangeListener[] listeners = listenerSupport.getListeners();\n         assertEquals(0, listeners.length);\n         assertEquals(VetoableChangeListener.class, listeners.getClass().getComponentType());\n-        VetoableChangeListener[] empty = listeners;\n+        final VetoableChangeListener[] empty = listeners;\n         //for fun, show that the same empty instance is used \n         assertSame(empty, listenerSupport.getListeners());\n \n-        VetoableChangeListener listener1 = EasyMock.createNiceMock(VetoableChangeListener.class);\n+        final VetoableChangeListener listener1 = EasyMock.createNiceMock(VetoableChangeListener.class);\n         listenerSupport.addListener(listener1);\n         assertEquals(1, listenerSupport.getListeners().length);\n-        VetoableChangeListener listener2 = EasyMock.createNiceMock(VetoableChangeListener.class);\n+        final VetoableChangeListener listener2 = EasyMock.createNiceMock(VetoableChangeListener.class);\n         listenerSupport.addListener(listener2);\n         assertEquals(2, listenerSupport.getListeners().length);\n         listenerSupport.removeListener(listener1);\n \n     @Test\n     public void testSerialization() throws IOException, ClassNotFoundException, PropertyVetoException {\n-        EventListenerSupport<VetoableChangeListener> listenerSupport = EventListenerSupport.create(VetoableChangeListener.class);\n+        final EventListenerSupport<VetoableChangeListener> listenerSupport = EventListenerSupport.create(VetoableChangeListener.class);\n         listenerSupport.addListener(new VetoableChangeListener() {\n             \n             @Override\n         listenerSupport.addListener(EasyMock.createNiceMock(VetoableChangeListener.class));\n \n         //serialize:\n-        ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n-        ObjectOutputStream objectOutputStream = new ObjectOutputStream(outputStream);\n+        final ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n+        final ObjectOutputStream objectOutputStream = new ObjectOutputStream(outputStream);\n \n         objectOutputStream.writeObject(listenerSupport);\n         objectOutputStream.close();\n \n         //deserialize:\n         @SuppressWarnings(\"unchecked\")\n+        final\n         EventListenerSupport<VetoableChangeListener> deserializedListenerSupport = (EventListenerSupport<VetoableChangeListener>) new ObjectInputStream(\n                 new ByteArrayInputStream(outputStream.toByteArray())).readObject();\n \n         //make sure we get a listener array back, of the correct component type, and that it contains only the serializable mock\n-        VetoableChangeListener[] listeners = deserializedListenerSupport.getListeners();\n+        final VetoableChangeListener[] listeners = deserializedListenerSupport.getListeners();\n         assertEquals(VetoableChangeListener.class, listeners.getClass().getComponentType());\n         assertEquals(1, listeners.length);\n \n         //now verify that the mock still receives events; we can infer that the proxy was correctly reconstituted\n-        VetoableChangeListener listener = listeners[0];\n-        PropertyChangeEvent evt = new PropertyChangeEvent(new Date(), \"Day\", 7, 9);\n+        final VetoableChangeListener listener = listeners[0];\n+        final PropertyChangeEvent evt = new PropertyChangeEvent(new Date(), \"Day\", 7, 9);\n         listener.vetoableChange(evt);\n         EasyMock.replay(listener);\n         deserializedListenerSupport.fire().vetoableChange(evt);\n     public void testSubclassInvocationHandling() throws PropertyVetoException {\n \n         @SuppressWarnings(\"serial\")\n+        final\n         EventListenerSupport<VetoableChangeListener> eventListenerSupport = new EventListenerSupport<VetoableChangeListener>(\n                 VetoableChangeListener.class) {\n             @Override\n             }\n         };\n \n-        VetoableChangeListener listener = EasyMock.createNiceMock(VetoableChangeListener.class);\n+        final VetoableChangeListener listener = EasyMock.createNiceMock(VetoableChangeListener.class);\n         eventListenerSupport.addListener(listener);\n-        Object source = new Date();\n-        PropertyChangeEvent ignore = new PropertyChangeEvent(source, \"Hour\", 5, 6);\n-        PropertyChangeEvent respond = new PropertyChangeEvent(source, \"Day\", 6, 7);\n+        final Object source = new Date();\n+        final PropertyChangeEvent ignore = new PropertyChangeEvent(source, \"Hour\", 5, 6);\n+        final PropertyChangeEvent respond = new PropertyChangeEvent(source, \"Day\", 6, 7);\n         listener.vetoableChange(respond);\n         EasyMock.replay(listener);\n         eventListenerSupport.fire().vetoableChange(ignore);\n--- a/src/test/java/org/apache/commons/lang3/event/EventUtilsTest.java\n+++ b/src/test/java/org/apache/commons/lang3/event/EventUtilsTest.java\n     @Test\n     public void testConstructor() {\n         assertNotNull(new EventUtils());\n-        Constructor<?>[] cons = EventUtils.class.getDeclaredConstructors();\n+        final Constructor<?>[] cons = EventUtils.class.getDeclaredConstructors();\n         assertEquals(1, cons.length);\n         assertTrue(Modifier.isPublic(cons[0].getModifiers()));\n         assertTrue(Modifier.isPublic(EventUtils.class.getModifiers()));\n     public void testAddEventListener()\n     {\n         final PropertyChangeSource src = new PropertyChangeSource();\n-        EventCountingInvociationHandler handler = new EventCountingInvociationHandler();\n-        PropertyChangeListener listener = handler.createListener(PropertyChangeListener.class);\n+        final EventCountingInvociationHandler handler = new EventCountingInvociationHandler();\n+        final PropertyChangeListener listener = handler.createListener(PropertyChangeListener.class);\n         assertEquals(0, handler.getEventCount(\"propertyChange\"));\n         EventUtils.addEventListener(src, PropertyChangeListener.class, listener);\n         assertEquals(0, handler.getEventCount(\"propertyChange\"));\n     public void testAddEventListenerWithNoAddMethod()\n     {\n         final PropertyChangeSource src = new PropertyChangeSource();\n-        EventCountingInvociationHandler handler = new EventCountingInvociationHandler();\n-        ObjectChangeListener listener = handler.createListener(ObjectChangeListener.class);\n+        final EventCountingInvociationHandler handler = new EventCountingInvociationHandler();\n+        final ObjectChangeListener listener = handler.createListener(ObjectChangeListener.class);\n         try\n         {\n             EventUtils.addEventListener(src, ObjectChangeListener.class, listener);\n             fail(\"Should not be allowed to add a listener to an object that doesn't support it.\");\n         }\n-        catch (IllegalArgumentException e)\n+        catch (final IllegalArgumentException e)\n         {\n             assertEquals(\"Class \" + src.getClass().getName() + \" does not have a public add\" + ObjectChangeListener.class.getSimpleName() + \" method which takes a parameter of type \" + ObjectChangeListener.class.getName() + \".\", e.getMessage());\n         }\n             });\n             fail(\"Add method should have thrown an exception, so method should fail.\");\n         }\n-        catch (RuntimeException e)\n+        catch (final RuntimeException e)\n         {\n \n         }\n     public void testAddEventListenerWithPrivateAddMethod()\n     {\n         final PropertyChangeSource src = new PropertyChangeSource();\n-        EventCountingInvociationHandler handler = new EventCountingInvociationHandler();\n-        VetoableChangeListener listener = handler.createListener(VetoableChangeListener.class);\n+        final EventCountingInvociationHandler handler = new EventCountingInvociationHandler();\n+        final VetoableChangeListener listener = handler.createListener(VetoableChangeListener.class);\n         try\n         {\n             EventUtils.addEventListener(src, VetoableChangeListener.class, listener);\n             fail(\"Should not be allowed to add a listener to an object that doesn't support it.\");\n         }\n-        catch (IllegalArgumentException e)\n+        catch (final IllegalArgumentException e)\n         {\n             assertEquals(\"Class \" + src.getClass().getName() + \" does not have a public add\" + VetoableChangeListener.class.getSimpleName() + \" method which takes a parameter of type \" + VetoableChangeListener.class.getName() + \".\", e.getMessage());\n         }\n \n         public int getEventCount(final String eventName)\n         {\n-            Integer count = eventCounts.get(eventName);\n+            final Integer count = eventCounts.get(eventName);\n             return count == null ? 0 : count.intValue();\n         }\n \n         @Override\n         public Object invoke(final Object proxy, final Method method, final Object[] args) throws Throwable\n         {\n-            Integer count = eventCounts.get(method.getName());\n+            final Integer count = eventCounts.get(method.getName());\n             if (count == null)\n             {\n                 eventCounts.put(method.getName(), Integer.valueOf(1));\n \n         public void setProperty(final String property)\n         {\n-            String oldValue = this.property;\n+            final String oldValue = this.property;\n             this.property = property;\n             listeners.fire().propertyChange(new PropertyChangeEvent(this, \"property\", oldValue, property));\n         }\n--- a/src/test/java/org/apache/commons/lang3/exception/AbstractExceptionContextTest.java\n+++ b/src/test/java/org/apache/commons/lang3/exception/AbstractExceptionContextTest.java\n \n     @Test\n     public void testAddContextValue() {\n-        String message = exceptionContext.getFormattedExceptionMessage(TEST_MESSAGE);\n+        final String message = exceptionContext.getFormattedExceptionMessage(TEST_MESSAGE);\n         assertTrue(message.indexOf(TEST_MESSAGE) >= 0);\n         assertTrue(message.indexOf(\"test1\") >= 0);\n         assertTrue(message.indexOf(\"test2\") >= 0);\n         assertEquals(5, exceptionContext.getContextLabels().size());\n         assertTrue(exceptionContext.getContextLabels().contains(\"test2\"));\n \n-        String contextMessage = exceptionContext.getFormattedExceptionMessage(null);\n+        final String contextMessage = exceptionContext.getFormattedExceptionMessage(null);\n         assertTrue(contextMessage.indexOf(TEST_MESSAGE) == -1);\n     }\n \n         exceptionContext.addContextValue(\"test2\", \"different value\");\n         exceptionContext.setContextValue(\"test3\", \"3\");\n \n-        String message = exceptionContext.getFormattedExceptionMessage(TEST_MESSAGE);\n+        final String message = exceptionContext.getFormattedExceptionMessage(TEST_MESSAGE);\n         assertTrue(message.indexOf(TEST_MESSAGE) >= 0);\n         assertTrue(message.indexOf(\"test Poorly written obj\") >= 0);\n         assertTrue(message.indexOf(\"Crap\") >= 0);\n         assertEquals(6, exceptionContext.getContextEntries().size());\n         assertEquals(6, exceptionContext.getContextLabels().size());\n \n-        String contextMessage = exceptionContext.getFormattedExceptionMessage(null);\n+        final String contextMessage = exceptionContext.getFormattedExceptionMessage(null);\n         assertTrue(contextMessage.indexOf(TEST_MESSAGE) == -1);\n     }\n \n         \n         exceptionContext.addContextValue(\"test2\", \"different value\");\n \n-        Set<String> labels = exceptionContext.getContextLabels();\n+        final Set<String> labels = exceptionContext.getContextLabels();\n         assertEquals(6, exceptionContext.getContextEntries().size());\n         assertEquals(5, labels.size());\n         assertTrue(labels.contains(\"test1\"));\n         \n         exceptionContext.addContextValue(\"test2\", \"different value\");\n \n-        List<Pair<String, Object>> entries = exceptionContext.getContextEntries();\n+        final List<Pair<String, Object>> entries = exceptionContext.getContextEntries();\n         assertEquals(6, entries.size());\n         assertEquals(\"test1\", entries.get(0).getKey());\n         assertEquals(\"test2\", entries.get(1).getKey());\n     public void testJavaSerialization() {\n         exceptionContext.setContextValue(\"test Poorly written obj\", \"serializable replacement\");\n         \n-        T clone = SerializationUtils.deserialize(SerializationUtils.serialize(exceptionContext));\n+        final T clone = SerializationUtils.deserialize(SerializationUtils.serialize(exceptionContext));\n         assertEquals(exceptionContext.getFormattedExceptionMessage(null), clone.getFormattedExceptionMessage(null));\n     }\n }\n--- a/src/test/java/org/apache/commons/lang3/exception/ContextedExceptionTest.java\n+++ b/src/test/java/org/apache/commons/lang3/exception/ContextedExceptionTest.java\n     @Test\n     public void testContextedException() {\n         exceptionContext = new ContextedException();\n-        String message = exceptionContext.getMessage();\n-        String trace = ExceptionUtils.getStackTrace(exceptionContext);\n+        final String message = exceptionContext.getMessage();\n+        final String trace = ExceptionUtils.getStackTrace(exceptionContext);\n         assertTrue(trace.indexOf(\"ContextedException\")>=0);\n         assertTrue(StringUtils.isEmpty(message));\n     }\n         exceptionContext = new ContextedException(TEST_MESSAGE);\n         assertEquals(TEST_MESSAGE, exceptionContext.getMessage());\n         \n-        String trace = ExceptionUtils.getStackTrace(exceptionContext);\n+        final String trace = ExceptionUtils.getStackTrace(exceptionContext);\n         assertTrue(trace.indexOf(TEST_MESSAGE)>=0);\n     }\n \n     @Test\n     public void testContextedExceptionThrowable() {\n         exceptionContext = new ContextedException(new Exception(TEST_MESSAGE));\n-        String message = exceptionContext.getMessage();\n-        String trace = ExceptionUtils.getStackTrace(exceptionContext);\n+        final String message = exceptionContext.getMessage();\n+        final String trace = ExceptionUtils.getStackTrace(exceptionContext);\n         assertTrue(trace.indexOf(\"ContextedException\")>=0);\n         assertTrue(trace.indexOf(TEST_MESSAGE)>=0);\n         assertTrue(message.indexOf(TEST_MESSAGE)>=0);\n     @Test\n     public void testContextedExceptionStringThrowable() {\n         exceptionContext = new ContextedException(TEST_MESSAGE_2, new Exception(TEST_MESSAGE));\n-        String message = exceptionContext.getMessage();\n-        String trace = ExceptionUtils.getStackTrace(exceptionContext);\n+        final String message = exceptionContext.getMessage();\n+        final String trace = ExceptionUtils.getStackTrace(exceptionContext);\n         assertTrue(trace.indexOf(\"ContextedException\")>=0);\n         assertTrue(trace.indexOf(TEST_MESSAGE)>=0);\n         assertTrue(trace.indexOf(TEST_MESSAGE_2)>=0);\n     @Test\n     public void testContextedExceptionStringThrowableContext() {\n         exceptionContext = new ContextedException(TEST_MESSAGE_2, new Exception(TEST_MESSAGE), new DefaultExceptionContext());\n-        String message = exceptionContext.getMessage();\n-        String trace = ExceptionUtils.getStackTrace(exceptionContext);\n+        final String message = exceptionContext.getMessage();\n+        final String trace = ExceptionUtils.getStackTrace(exceptionContext);\n         assertTrue(trace.indexOf(\"ContextedException\")>=0);\n         assertTrue(trace.indexOf(TEST_MESSAGE)>=0);\n         assertTrue(trace.indexOf(TEST_MESSAGE_2)>=0);\n         .addContextValue(\"test Nbr\", Integer.valueOf(5))\n         .addContextValue(\"test Poorly written obj\", new ObjectWithFaultyToString());\n         \n-        String message = exceptionContext.getMessage();\n+        final String message = exceptionContext.getMessage();\n         assertTrue(message != null);\n     }\n \n--- a/src/test/java/org/apache/commons/lang3/exception/ContextedRuntimeExceptionTest.java\n+++ b/src/test/java/org/apache/commons/lang3/exception/ContextedRuntimeExceptionTest.java\n     @Test\n     public void testContextedException() {\n         exceptionContext = new ContextedRuntimeException();\n-        String message = exceptionContext.getMessage();\n-        String trace = ExceptionUtils.getStackTrace(exceptionContext);\n+        final String message = exceptionContext.getMessage();\n+        final String trace = ExceptionUtils.getStackTrace(exceptionContext);\n         assertTrue(trace.indexOf(\"ContextedException\")>=0);\n         assertTrue(StringUtils.isEmpty(message));\n     }\n         exceptionContext = new ContextedRuntimeException(TEST_MESSAGE);\n         assertEquals(TEST_MESSAGE, exceptionContext.getMessage());\n         \n-        String trace = ExceptionUtils.getStackTrace(exceptionContext);\n+        final String trace = ExceptionUtils.getStackTrace(exceptionContext);\n         assertTrue(trace.indexOf(TEST_MESSAGE)>=0);\n     }\n \n     @Test\n     public void testContextedExceptionThrowable() {\n         exceptionContext = new ContextedRuntimeException(new Exception(TEST_MESSAGE));\n-        String message = exceptionContext.getMessage();\n-        String trace = ExceptionUtils.getStackTrace(exceptionContext);\n+        final String message = exceptionContext.getMessage();\n+        final String trace = ExceptionUtils.getStackTrace(exceptionContext);\n         assertTrue(trace.indexOf(\"ContextedException\")>=0);\n         assertTrue(trace.indexOf(TEST_MESSAGE)>=0);\n         assertTrue(message.indexOf(TEST_MESSAGE)>=0);\n     @Test\n     public void testContextedExceptionStringThrowable() {\n         exceptionContext = new ContextedRuntimeException(TEST_MESSAGE_2, new Exception(TEST_MESSAGE));\n-        String message = exceptionContext.getMessage();\n-        String trace = ExceptionUtils.getStackTrace(exceptionContext);\n+        final String message = exceptionContext.getMessage();\n+        final String trace = ExceptionUtils.getStackTrace(exceptionContext);\n         assertTrue(trace.indexOf(\"ContextedException\")>=0);\n         assertTrue(trace.indexOf(TEST_MESSAGE)>=0);\n         assertTrue(trace.indexOf(TEST_MESSAGE_2)>=0);\n     @Test\n     public void testContextedExceptionStringThrowableContext() {\n         exceptionContext = new ContextedRuntimeException(TEST_MESSAGE_2, new Exception(TEST_MESSAGE), new DefaultExceptionContext() {});\n-        String message = exceptionContext.getMessage();\n-        String trace = ExceptionUtils.getStackTrace(exceptionContext);\n+        final String message = exceptionContext.getMessage();\n+        final String trace = ExceptionUtils.getStackTrace(exceptionContext);\n         assertTrue(trace.indexOf(\"ContextedException\")>=0);\n         assertTrue(trace.indexOf(TEST_MESSAGE)>=0);\n         assertTrue(trace.indexOf(TEST_MESSAGE_2)>=0);\n         .addContextValue(\"test Nbr\", Integer.valueOf(5))\n         .addContextValue(\"test Poorly written obj\", new ObjectWithFaultyToString());\n         \n-        String message = exceptionContext.getMessage();\n+        final String message = exceptionContext.getMessage();\n         assertTrue(message != null);\n     }\n \n--- a/src/test/java/org/apache/commons/lang3/exception/ExceptionUtilsTest.java\n+++ b/src/test/java/org/apache/commons/lang3/exception/ExceptionUtilsTest.java\n         nested = new NestableException(withoutCause);\n         withCause = new ExceptionWithCause(nested);\n         jdkNoCause = new NullPointerException();\n-        ExceptionWithCause a = new ExceptionWithCause(null);\n-        ExceptionWithCause b = new ExceptionWithCause(a);\n+        final ExceptionWithCause a = new ExceptionWithCause(null);\n+        final ExceptionWithCause b = new ExceptionWithCause(a);\n         a.setCause(b);\n         cyclicCause = new ExceptionWithCause(a);\n     }\n     private Throwable createExceptionWithoutCause() {\n         try {\n             throw new ExceptionWithoutCause();\n-        } catch (Throwable t) {\n+        } catch (final Throwable t) {\n             return t;\n         }\n     }\n         try {\n             try {\n                 throw new ExceptionWithCause(createExceptionWithoutCause());\n-            } catch (Throwable t) {\n+            } catch (final Throwable t) {\n                 throw new ExceptionWithCause(t);\n             }\n-        } catch (Throwable t) {\n+        } catch (final Throwable t) {\n             return t;\n         }\n     }\n     @Test\n     public void testConstructor() {\n         assertNotNull(new ExceptionUtils());\n-        Constructor<?>[] cons = ExceptionUtils.class.getDeclaredConstructors();\n+        final Constructor<?>[] cons = ExceptionUtils.class.getDeclaredConstructors();\n         assertEquals(1, cons.length);\n         assertTrue(Modifier.isPublic(cons[0].getModifiers()));\n         assertTrue(Modifier.isPublic(ExceptionUtils.class.getModifiers()));\n \n     @Test\n     public void testGetThrowables_Throwable_withoutCause() {\n-        Throwable[] throwables = ExceptionUtils.getThrowables(withoutCause);\n+        final Throwable[] throwables = ExceptionUtils.getThrowables(withoutCause);\n         assertEquals(1, throwables.length);\n         assertSame(withoutCause, throwables[0]);\n     }\n \n     @Test\n     public void testGetThrowables_Throwable_nested() {\n-        Throwable[] throwables = ExceptionUtils.getThrowables(nested);\n+        final Throwable[] throwables = ExceptionUtils.getThrowables(nested);\n         assertEquals(2, throwables.length);\n         assertSame(nested, throwables[0]);\n         assertSame(withoutCause, throwables[1]);\n \n     @Test\n     public void testGetThrowables_Throwable_withCause() {\n-        Throwable[] throwables = ExceptionUtils.getThrowables(withCause);\n+        final Throwable[] throwables = ExceptionUtils.getThrowables(withCause);\n         assertEquals(3, throwables.length);\n         assertSame(withCause, throwables[0]);\n         assertSame(nested, throwables[1]);\n \n     @Test\n     public void testGetThrowables_Throwable_jdkNoCause() {\n-        Throwable[] throwables = ExceptionUtils.getThrowables(jdkNoCause);\n+        final Throwable[] throwables = ExceptionUtils.getThrowables(jdkNoCause);\n         assertEquals(1, throwables.length);\n         assertSame(jdkNoCause, throwables[0]);\n     }\n \n     @Test\n     public void testGetThrowables_Throwable_recursiveCause() {\n-        Throwable[] throwables = ExceptionUtils.getThrowables(cyclicCause);\n+        final Throwable[] throwables = ExceptionUtils.getThrowables(cyclicCause);\n         assertEquals(3, throwables.length);\n         assertSame(cyclicCause, throwables[0]);\n         assertSame(cyclicCause.getCause(), throwables[1]);\n     //-----------------------------------------------------------------------\n     @Test\n     public void testGetThrowableList_Throwable_null() {\n-        List<?> throwables = ExceptionUtils.getThrowableList(null);\n+        final List<?> throwables = ExceptionUtils.getThrowableList(null);\n         assertEquals(0, throwables.size());\n     }\n \n     @Test\n     public void testGetThrowableList_Throwable_withoutCause() {\n-        List<?> throwables = ExceptionUtils.getThrowableList(withoutCause);\n+        final List<?> throwables = ExceptionUtils.getThrowableList(withoutCause);\n         assertEquals(1, throwables.size());\n         assertSame(withoutCause, throwables.get(0));\n     }\n \n     @Test\n     public void testGetThrowableList_Throwable_nested() {\n-        List<?> throwables = ExceptionUtils.getThrowableList(nested);\n+        final List<?> throwables = ExceptionUtils.getThrowableList(nested);\n         assertEquals(2, throwables.size());\n         assertSame(nested, throwables.get(0));\n         assertSame(withoutCause, throwables.get(1));\n \n     @Test\n     public void testGetThrowableList_Throwable_withCause() {\n-        List<?> throwables = ExceptionUtils.getThrowableList(withCause);\n+        final List<?> throwables = ExceptionUtils.getThrowableList(withCause);\n         assertEquals(3, throwables.size());\n         assertSame(withCause, throwables.get(0));\n         assertSame(nested, throwables.get(1));\n \n     @Test\n     public void testGetThrowableList_Throwable_jdkNoCause() {\n-        List<?> throwables = ExceptionUtils.getThrowableList(jdkNoCause);\n+        final List<?> throwables = ExceptionUtils.getThrowableList(jdkNoCause);\n         assertEquals(1, throwables.size());\n         assertSame(jdkNoCause, throwables.get(0));\n     }\n \n     @Test\n     public void testGetThrowableList_Throwable_recursiveCause() {\n-        List<?> throwables = ExceptionUtils.getThrowableList(cyclicCause);\n+        final List<?> throwables = ExceptionUtils.getThrowableList(cyclicCause);\n         assertEquals(3, throwables.size());\n         assertSame(cyclicCause, throwables.get(0));\n         assertSame(cyclicCause.getCause(), throwables.get(1));\n         try {\n             ExceptionUtils.printRootCauseStackTrace(withCause, (PrintStream) null);\n             fail();\n-        } catch (IllegalArgumentException ex) {\n+        } catch (final IllegalArgumentException ex) {\n         }\n         \n         out = new ByteArrayOutputStream(1024);\n-        Throwable withCause = createExceptionWithCause();\n+        final Throwable withCause = createExceptionWithCause();\n         ExceptionUtils.printRootCauseStackTrace(withCause, new PrintStream(out));\n         String stackTrace = out.toString();\n         assertTrue(stackTrace.indexOf(ExceptionUtils.WRAPPED_MARKER) != -1);\n         try {\n             ExceptionUtils.printRootCauseStackTrace(withCause, (PrintWriter) null);\n             fail();\n-        } catch (IllegalArgumentException ex) {\n+        } catch (final IllegalArgumentException ex) {\n         }\n         \n         writer = new StringWriter(1024);\n-        Throwable withCause = createExceptionWithCause();\n+        final Throwable withCause = createExceptionWithCause();\n         ExceptionUtils.printRootCauseStackTrace(withCause, new PrintWriter(writer));\n         String stackTrace = writer.toString();\n         assertTrue(stackTrace.indexOf(ExceptionUtils.WRAPPED_MARKER) != -1);\n     public void testGetRootCauseStackTrace_Throwable() throws Exception {\n         assertEquals(0, ExceptionUtils.getRootCauseStackTrace(null).length);\n         \n-        Throwable withCause = createExceptionWithCause();\n+        final Throwable withCause = createExceptionWithCause();\n         String[] stackTrace = ExceptionUtils.getRootCauseStackTrace(withCause);\n         boolean match = false;\n-        for (String element : stackTrace) {\n+        for (final String element : stackTrace) {\n             if (element.startsWith(ExceptionUtils.WRAPPED_MARKER)) {\n                 match = true;\n                 break;\n         \n         stackTrace = ExceptionUtils.getRootCauseStackTrace(withoutCause);\n         match = false;\n-        for (String element : stackTrace) {\n+        for (final String element : stackTrace) {\n             if (element.startsWith(ExceptionUtils.WRAPPED_MARKER)) {\n                 match = true;\n                 break;\n--- a/src/test/java/org/apache/commons/lang3/math/FractionTest.java\n+++ b/src/test/java/org/apache/commons/lang3/math/FractionTest.java\n         try {\n             f = Fraction.getFraction(1, 0);\n             fail(\"expecting ArithmeticException\");\n-        } catch (ArithmeticException ex) {}\n+        } catch (final ArithmeticException ex) {}\n         \n         try {\n             f = Fraction.getFraction(2, 0);\n             fail(\"expecting ArithmeticException\");\n-        } catch (ArithmeticException ex) {}\n+        } catch (final ArithmeticException ex) {}\n         \n         try {\n             f = Fraction.getFraction(-3, 0);\n             fail(\"expecting ArithmeticException\");\n-        } catch (ArithmeticException ex) {}\n+        } catch (final ArithmeticException ex) {}\n \n         // very large: can't represent as unsimplified fraction, although\n         try {\n             f = Fraction.getFraction(4, Integer.MIN_VALUE);\n             fail(\"expecting ArithmeticException\");\n-        } catch (ArithmeticException ex) {}\n+        } catch (final ArithmeticException ex) {}\n         try {\n             f = Fraction.getFraction(1, Integer.MIN_VALUE);\n             fail(\"expecting ArithmeticException\");\n-        } catch (ArithmeticException ex) {}\n+        } catch (final ArithmeticException ex) {}\n     }\n \n     @Test\n         try {\n             f = Fraction.getFraction(1, -6, -10);\n             fail(\"expecting ArithmeticException\");\n-        } catch (ArithmeticException ex) {}\n+        } catch (final ArithmeticException ex) {}\n \n         try {\n             f = Fraction.getFraction(1, -6, -10);\n             fail(\"expecting ArithmeticException\");\n-        } catch (ArithmeticException ex) {}\n+        } catch (final ArithmeticException ex) {}\n \n         try {\n             f = Fraction.getFraction(1, -6, -10);\n             fail(\"expecting ArithmeticException\");\n-        } catch (ArithmeticException ex) {}\n+        } catch (final ArithmeticException ex) {}\n         \n         // negative whole\n         f = Fraction.getFraction(-1, 6, 10);\n         try {\n             f = Fraction.getFraction(-1, -6, 10);\n             fail(\"expecting ArithmeticException\");\n-        } catch (ArithmeticException ex) {}\n+        } catch (final ArithmeticException ex) {}\n \n         try {\n             f = Fraction.getFraction(-1, 6, -10);\n             fail(\"expecting ArithmeticException\");\n-        } catch (ArithmeticException ex) {}\n+        } catch (final ArithmeticException ex) {}\n         \n         try {\n             f = Fraction.getFraction(-1, -6, -10);\n             fail(\"expecting ArithmeticException\");\n-        } catch (ArithmeticException ex) {}\n+        } catch (final ArithmeticException ex) {}\n         \n         // zero denominator\n         try {\n             f = Fraction.getFraction(0, 1, 0);\n             fail(\"expecting ArithmeticException\");\n-        } catch (ArithmeticException ex) {}\n+        } catch (final ArithmeticException ex) {}\n         \n         try {\n             f = Fraction.getFraction(1, 2, 0);\n             fail(\"expecting ArithmeticException\");\n-        } catch (ArithmeticException ex) {}\n+        } catch (final ArithmeticException ex) {}\n         \n         try {\n             f = Fraction.getFraction(-1, -3, 0);\n             fail(\"expecting ArithmeticException\");\n-        } catch (ArithmeticException ex) {}\n+        } catch (final ArithmeticException ex) {}\n         \n         try {\n             f = Fraction.getFraction(Integer.MAX_VALUE, 1, 2); \n             fail(\"expecting ArithmeticException\");\n-        } catch (ArithmeticException ex) {}\n+        } catch (final ArithmeticException ex) {}\n         \n         try {\n             f = Fraction.getFraction(-Integer.MAX_VALUE, 1, 2);\n             fail(\"expecting ArithmeticException\");\n-        } catch (ArithmeticException ex) {}\n+        } catch (final ArithmeticException ex) {}\n \n         // very large\n         f = Fraction.getFraction(-1, 0, Integer.MAX_VALUE);\n             // negative denominators not allowed in this constructor.\n             f = Fraction.getFraction(0, 4, Integer.MIN_VALUE);\n             fail(\"expecting ArithmeticException\");\n-        } catch (ArithmeticException ex) {}\n+        } catch (final ArithmeticException ex) {}\n         try {\n             f = Fraction.getFraction(1, 1, Integer.MAX_VALUE);\n             fail(\"expecting ArithmeticException\");\n-        } catch (ArithmeticException ex) {}\n+        } catch (final ArithmeticException ex) {}\n         try {\n             f = Fraction.getFraction(-1, 2, Integer.MAX_VALUE);\n             fail(\"expecting ArithmeticException\");\n-        } catch (ArithmeticException ex) {}\n+        } catch (final ArithmeticException ex) {}\n     }\n     @Test\n     public void testReducedFactory_int_int() {\n         try {\n             f = Fraction.getReducedFraction(1, 0);\n             fail(\"expecting ArithmeticException\");\n-        } catch (ArithmeticException ex) {}\n+        } catch (final ArithmeticException ex) {}\n         \n         try {\n             f = Fraction.getReducedFraction(2, 0);\n             fail(\"expecting ArithmeticException\");\n-        } catch (ArithmeticException ex) {}\n+        } catch (final ArithmeticException ex) {}\n         \n         try {\n             f = Fraction.getReducedFraction(-3, 0);\n             fail(\"expecting ArithmeticException\");\n-        } catch (ArithmeticException ex) {}\n+        } catch (final ArithmeticException ex) {}\n \n         // reduced        \n         f = Fraction.getReducedFraction(0, 2);\n         try { \n             f = Fraction.getReducedFraction(-7, Integer.MIN_VALUE);  \n             fail(\"Expecting ArithmeticException\");\n-        } catch (ArithmeticException ex) {}      \n+        } catch (final ArithmeticException ex) {}      \n \n         // LANG-662\n         f = Fraction.getReducedFraction(Integer.MIN_VALUE, 2);\n         try {\n             f = Fraction.getFraction(Double.NaN);\n             fail(\"expecting ArithmeticException\");\n-        } catch (ArithmeticException ex) {}\n+        } catch (final ArithmeticException ex) {}\n         \n         try {\n             f = Fraction.getFraction(Double.POSITIVE_INFINITY);\n             fail(\"expecting ArithmeticException\");\n-        } catch (ArithmeticException ex) {}\n+        } catch (final ArithmeticException ex) {}\n         \n         try {\n             f = Fraction.getFraction(Double.NEGATIVE_INFINITY);\n             fail(\"expecting ArithmeticException\");\n-        } catch (ArithmeticException ex) {}\n+        } catch (final ArithmeticException ex) {}\n         \n         try {\n             f = Fraction.getFraction((double) Integer.MAX_VALUE + 1);\n             fail(\"expecting ArithmeticException\");\n-        } catch (ArithmeticException ex) {}\n+        } catch (final ArithmeticException ex) {}\n         \n         // zero\n         f = Fraction.getFraction(0.0d);\n             for (int j = 1; j <= i; j++) {  // numerator\n                 try {\n                     f = Fraction.getFraction((double) j / (double) i);\n-                } catch (ArithmeticException ex) {\n+                } catch (final ArithmeticException ex) {\n                     System.err.println(j + \" \" + i);\n                     throw ex;\n                 }\n             for (int j = 1; j <= i; j++) {  // numerator\n                 try {\n                     f = Fraction.getFraction((double) j / (double) i);\n-                } catch (ArithmeticException ex) {\n+                } catch (final ArithmeticException ex) {\n                     System.err.println(j + \" \" + i);\n                     throw ex;\n                 }\n         try {\n             f = Fraction.getFraction(\"2.3R\");\n             fail(\"Expecting NumberFormatException\");\n-        } catch (NumberFormatException ex) {}\n+        } catch (final NumberFormatException ex) {}\n         \n         try {\n             f = Fraction.getFraction(\"2147483648\"); // too big\n             fail(\"Expecting NumberFormatException\");\n-        } catch (NumberFormatException ex) {}\n+        } catch (final NumberFormatException ex) {}\n         \n         try {\n             f = Fraction.getFraction(\".\");\n             fail(\"Expecting NumberFormatException\");\n-        } catch (NumberFormatException ex) {}\n+        } catch (final NumberFormatException ex) {}\n     }\n \n     @Test\n         try {\n             f = Fraction.getFraction(\"2 3\");\n             fail(\"expecting NumberFormatException\");\n-        } catch (NumberFormatException ex) {}\n+        } catch (final NumberFormatException ex) {}\n         \n         try {\n             f = Fraction.getFraction(\"a 3\");\n             fail(\"expecting NumberFormatException\");\n-        } catch (NumberFormatException ex) {}\n+        } catch (final NumberFormatException ex) {}\n         \n         try {\n             f = Fraction.getFraction(\"2 b/4\");\n             fail(\"expecting NumberFormatException\");\n-        } catch (NumberFormatException ex) {}\n+        } catch (final NumberFormatException ex) {}\n         \n         try {\n             f = Fraction.getFraction(\"2 \");\n             fail(\"expecting NumberFormatException\");\n-        } catch (NumberFormatException ex) {}\n+        } catch (final NumberFormatException ex) {}\n \n         try {\n             f = Fraction.getFraction(\" 3\");\n             fail(\"expecting NumberFormatException\");\n-        } catch (NumberFormatException ex) {}\n+        } catch (final NumberFormatException ex) {}\n         \n         try {\n             f = Fraction.getFraction(\" \");\n             fail(\"expecting NumberFormatException\");\n-        } catch (NumberFormatException ex) {}\n+        } catch (final NumberFormatException ex) {}\n     }\n \n     @Test\n         try {\n             f = Fraction.getFraction(\"2/d\");\n             fail(\"expecting NumberFormatException\");\n-        } catch (NumberFormatException ex) {}\n+        } catch (final NumberFormatException ex) {}\n         \n         try {\n             f = Fraction.getFraction(\"2e/3\");\n             fail(\"expecting NumberFormatException\");\n-        } catch (NumberFormatException ex) {}\n+        } catch (final NumberFormatException ex) {}\n         \n         try {\n             f = Fraction.getFraction(\"2/\");\n             fail(\"expecting NumberFormatException\");\n-        } catch (NumberFormatException ex) {}\n+        } catch (final NumberFormatException ex) {}\n         \n         try {\n             f = Fraction.getFraction(\"/\");\n             fail(\"expecting NumberFormatException\");\n-        } catch (NumberFormatException ex) {}\n+        } catch (final NumberFormatException ex) {}\n     }\n \n     @Test\n         try {\n             f = f.invert();\n             fail(\"expecting ArithmeticException\");\n-        } catch (ArithmeticException ex) {}\n+        } catch (final ArithmeticException ex) {}\n \n         // large values\n         f = Fraction.getFraction(Integer.MIN_VALUE, 1);\n         try {\n             f = f.invert();\n             fail(\"expecting ArithmeticException\");\n-        } catch (ArithmeticException ex) {}\n+        } catch (final ArithmeticException ex) {}\n \n         f = Fraction.getFraction(Integer.MAX_VALUE, 1);\n         f = f.invert();\n         try {\n             f = f.negate();\n             fail(\"expecting ArithmeticException\");\n-        } catch (ArithmeticException ex) {}\n+        } catch (final ArithmeticException ex) {}\n     }\n     \n     @Test\n         try {\n             f = f.abs();\n             fail(\"expecting ArithmeticException\");\n-        } catch (ArithmeticException ex) {}\n+        } catch (final ArithmeticException ex) {}\n     }\n     \n     @Test\n         try {\n             f = f.pow(-1);\n             fail(\"expecting ArithmeticException\");\n-        } catch (ArithmeticException ex) {}\n+        } catch (final ArithmeticException ex) {}\n         try {\n             f = f.pow(Integer.MIN_VALUE);\n             fail(\"expecting ArithmeticException\");\n-        } catch (ArithmeticException ex) {}\n+        } catch (final ArithmeticException ex) {}\n \n         // one to any power is still one.\n         f = Fraction.getFraction(1, 1);\n         try {\n             f = f.pow(2);\n             fail(\"expecting ArithmeticException\");\n-        } catch (ArithmeticException ex) {}\n+        } catch (final ArithmeticException ex) {}\n \n         // Numerator growing too negative during the pow operation.\n         f = Fraction.getFraction(Integer.MIN_VALUE, 1);\n         try {\n             f = f.pow(3);\n             fail(\"expecting ArithmeticException\");\n-        } catch (ArithmeticException ex) {}\n+        } catch (final ArithmeticException ex) {}\n \n         f = Fraction.getFraction(65536, 1);\n         try {\n             f = f.pow(2);\n             fail(\"expecting ArithmeticException\");\n-        } catch (ArithmeticException ex) {}\n+        } catch (final ArithmeticException ex) {}\n     }\n     \n     @Test\n         try {\n             f.add(null);\n             fail(\"expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {}\n+        } catch (final IllegalArgumentException ex) {}\n         \n         // if this fraction is added naively, it will overflow.\n         // check that it doesn't.\n         try {\n             f = f.add(Fraction.ONE); // should overflow\n             fail(\"expecting ArithmeticException but got: \" + f.toString());\n-        } catch (ArithmeticException ex) {}\n+        } catch (final ArithmeticException ex) {}\n         \n         // denominator should not be a multiple of 2 or 3 to trigger overflow\n         f1 = Fraction.getFraction(Integer.MIN_VALUE, 5);\n         try {\n             f = f1.add(f2); // should overflow\n             fail(\"expecting ArithmeticException but got: \" + f.toString());\n-        } catch (ArithmeticException ex) {}\n+        } catch (final ArithmeticException ex) {}\n         \n         try {\n             f= Fraction.getFraction(-Integer.MAX_VALUE, 1);\n             f = f.add(f);\n             fail(\"expecting ArithmeticException\");\n-        } catch (ArithmeticException ex) {}\n+        } catch (final ArithmeticException ex) {}\n             \n         try {\n             f= Fraction.getFraction(-Integer.MAX_VALUE, 1);\n             f = f.add(f);\n             fail(\"expecting ArithmeticException\");\n-        } catch (ArithmeticException ex) {}\n+        } catch (final ArithmeticException ex) {}\n             \n         f1 = Fraction.getFraction(3,327680);\n         f2 = Fraction.getFraction(2,59049);\n         try {\n             f = f1.add(f2); // should overflow\n             fail(\"expecting ArithmeticException but got: \" + f.toString());\n-        } catch (ArithmeticException ex) {}\n+        } catch (final ArithmeticException ex) {}\n     }\n             \n     @Test\n         try {\n             f.subtract(null);\n             fail(\"expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {}\n+        } catch (final IllegalArgumentException ex) {}\n         \n         // if this fraction is subtracted naively, it will overflow.\n         // check that it doesn't.\n             f2 = Fraction.getFraction(1, Integer.MAX_VALUE - 1);\n             f = f1.subtract(f2);\n             fail(\"expecting ArithmeticException\");  //should overflow\n-        } catch (ArithmeticException ex) {}\n+        } catch (final ArithmeticException ex) {}\n             \n         // denominator should not be a multiple of 2 or 3 to trigger overflow\n         f1 = Fraction.getFraction(Integer.MIN_VALUE, 5);\n         try {\n             f = f1.subtract(f2); // should overflow\n             fail(\"expecting ArithmeticException but got: \" + f.toString());\n-        } catch (ArithmeticException ex) {}\n+        } catch (final ArithmeticException ex) {}\n         \n         try {\n             f= Fraction.getFraction(Integer.MIN_VALUE, 1);\n             f = f.subtract(Fraction.ONE);\n             fail(\"expecting ArithmeticException\");\n-        } catch (ArithmeticException ex) {}\n+        } catch (final ArithmeticException ex) {}\n             \n         try {\n             f= Fraction.getFraction(Integer.MAX_VALUE, 1);\n             f = f.subtract(Fraction.ONE.negate());\n             fail(\"expecting ArithmeticException\");\n-        } catch (ArithmeticException ex) {}\n+        } catch (final ArithmeticException ex) {}\n             \n         f1 = Fraction.getFraction(3,327680);\n         f2 = Fraction.getFraction(2,59049);\n         try {\n             f = f1.subtract(f2); // should overflow\n             fail(\"expecting ArithmeticException but got: \" + f.toString());\n-        } catch (ArithmeticException ex) {}\n+        } catch (final ArithmeticException ex) {}\n     }\n             \n     @Test\n         try {\n             f.multiplyBy(null);\n             fail(\"expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {}\n+        } catch (final IllegalArgumentException ex) {}\n         \n         try {\n             f1 = Fraction.getFraction(1, Integer.MAX_VALUE);\n             f = f1.multiplyBy(f1);  // should overflow\n             fail(\"expecting ArithmeticException\");\n-        } catch (ArithmeticException ex) {}\n+        } catch (final ArithmeticException ex) {}\n             \n         try {\n             f1 = Fraction.getFraction(1, -Integer.MAX_VALUE);\n             f = f1.multiplyBy(f1);  // should overflow\n             fail(\"expecting ArithmeticException\");\n-        } catch (ArithmeticException ex) {}\n+        } catch (final ArithmeticException ex) {}\n     }\n             \n     @Test\n         try {\n             f = f1.divideBy(f2);\n             fail(\"expecting ArithmeticException\");\n-        } catch (ArithmeticException ex) {}\n+        } catch (final ArithmeticException ex) {}\n         \n         f1 = Fraction.getFraction(0, 5);\n         f2 = Fraction.getFraction(2, 7);\n         try {\n             f.divideBy(null);\n             fail(\"IllegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {}\n+        } catch (final IllegalArgumentException ex) {}\n         \n         try {\n             f1 = Fraction.getFraction(1, Integer.MAX_VALUE);\n             f = f1.divideBy(f1.invert());  // should overflow\n             fail(\"expecting ArithmeticException\");\n-        } catch (ArithmeticException ex) {}\n+        } catch (final ArithmeticException ex) {}\n         try {\n             f1 = Fraction.getFraction(1, -Integer.MAX_VALUE);\n             f = f1.divideBy(f1.invert());  // should overflow\n             fail(\"expecting ArithmeticException\");\n-        } catch (ArithmeticException ex) {}\n+        } catch (final ArithmeticException ex) {}\n     }\n             \n     @Test\n     \n     @Test\n     public void testHashCode() {\n-        Fraction f1 = Fraction.getFraction(3, 5);\n+        final Fraction f1 = Fraction.getFraction(3, 5);\n         Fraction f2 = Fraction.getFraction(3, 5);\n         \n         assertTrue(f1.hashCode() == f2.hashCode());\n         try {\n             f1.compareTo(null);\n             fail(\"expecting NullPointerException\");\n-        } catch (NullPointerException ex) {}\n+        } catch (final NullPointerException ex) {}\n         \n         f2 = Fraction.getFraction(2, 5);\n         assertTrue(f1.compareTo(f2) > 0);\n         Fraction f = null;\n \n         f = Fraction.getFraction(3, 5);\n-        String str = f.toString();\n+        final String str = f.toString();\n         assertEquals(\"3/5\", str);\n         assertSame(str, f.toString());\n         \n         Fraction f = null;\n \n         f = Fraction.getFraction(3, 5);\n-        String str = f.toProperString();\n+        final String str = f.toProperString();\n         assertEquals(\"3/5\", str);\n         assertSame(str, f.toProperString());\n         \n--- a/src/test/java/org/apache/commons/lang3/math/IEEE754rUtilsTest.java\n+++ b/src/test/java/org/apache/commons/lang3/math/IEEE754rUtilsTest.java\n         assertEquals(2.5f, IEEE754rUtils.max(1.2f, 2.5f, Float.NaN), 0.01);\n         assertTrue(Float.isNaN(IEEE754rUtils.max(Float.NaN, Float.NaN, Float.NaN)));\n \n-        double[] a = new double[] { 1.2, Double.NaN, 3.7, 27.0, 42.0, Double.NaN };\n+        final double[] a = new double[] { 1.2, Double.NaN, 3.7, 27.0, 42.0, Double.NaN };\n         assertEquals(42.0, IEEE754rUtils.max(a), 0.01);\n         assertEquals(1.2, IEEE754rUtils.min(a), 0.01);\n \n-        double[] b = new double[] { Double.NaN, 1.2, Double.NaN, 3.7, 27.0, 42.0, Double.NaN };\n+        final double[] b = new double[] { Double.NaN, 1.2, Double.NaN, 3.7, 27.0, 42.0, Double.NaN };\n         assertEquals(42.0, IEEE754rUtils.max(b), 0.01);\n         assertEquals(1.2, IEEE754rUtils.min(b), 0.01);\n \n-        float[] aF = new float[] { 1.2f, Float.NaN, 3.7f, 27.0f, 42.0f, Float.NaN };\n+        final float[] aF = new float[] { 1.2f, Float.NaN, 3.7f, 27.0f, 42.0f, Float.NaN };\n         assertEquals(1.2f, IEEE754rUtils.min(aF), 0.01);\n         assertEquals(42.0f, IEEE754rUtils.max(aF), 0.01);\n \n-        float[] bF = new float[] { Float.NaN, 1.2f, Float.NaN, 3.7f, 27.0f, 42.0f, Float.NaN };\n+        final float[] bF = new float[] { Float.NaN, 1.2f, Float.NaN, 3.7f, 27.0f, 42.0f, Float.NaN };\n         assertEquals(1.2f, IEEE754rUtils.min(bF), 0.01);\n         assertEquals(42.0f, IEEE754rUtils.max(bF), 0.01);\n     }\n         try {\n             IEEE754rUtils.min( (float[]) null);\n             fail(\"IllegalArgumentException expected for null input\");\n-        } catch(IllegalArgumentException iae) { /* expected */ }\n+        } catch(final IllegalArgumentException iae) { /* expected */ }\n \n         try {\n             IEEE754rUtils.min(new float[0]);\n             fail(\"IllegalArgumentException expected for empty input\");\n-        } catch(IllegalArgumentException iae) { /* expected */ }\n+        } catch(final IllegalArgumentException iae) { /* expected */ }\n \n         try {\n             IEEE754rUtils.max( (float[]) null);\n             fail(\"IllegalArgumentException expected for null input\");\n-        } catch(IllegalArgumentException iae) { /* expected */ }\n+        } catch(final IllegalArgumentException iae) { /* expected */ }\n \n         try {\n             IEEE754rUtils.max(new float[0]);\n             fail(\"IllegalArgumentException expected for empty input\");\n-        } catch(IllegalArgumentException iae) { /* expected */ }\n+        } catch(final IllegalArgumentException iae) { /* expected */ }\n \n         try {\n             IEEE754rUtils.min( (double[]) null);\n             fail(\"IllegalArgumentException expected for null input\");\n-        } catch(IllegalArgumentException iae) { /* expected */ }\n+        } catch(final IllegalArgumentException iae) { /* expected */ }\n \n         try {\n             IEEE754rUtils.min(new double[0]);\n             fail(\"IllegalArgumentException expected for empty input\");\n-        } catch(IllegalArgumentException iae) { /* expected */ }\n+        } catch(final IllegalArgumentException iae) { /* expected */ }\n \n         try {\n             IEEE754rUtils.max( (double[]) null);\n             fail(\"IllegalArgumentException expected for null input\");\n-        } catch(IllegalArgumentException iae) { /* expected */ }\n+        } catch(final IllegalArgumentException iae) { /* expected */ }\n \n         try {\n             IEEE754rUtils.max(new double[0]);\n             fail(\"IllegalArgumentException expected for empty input\");\n-        } catch(IllegalArgumentException iae) { /* expected */ }\n+        } catch(final IllegalArgumentException iae) { /* expected */ }\n \n     }\n \n--- a/src/test/java/org/apache/commons/lang3/math/NumberUtilsTest.java\n+++ b/src/test/java/org/apache/commons/lang3/math/NumberUtilsTest.java\n     @Test\n     public void testConstructor() {\n         assertNotNull(new NumberUtils());\n-        Constructor<?>[] cons = NumberUtils.class.getDeclaredConstructors();\n+        final Constructor<?>[] cons = NumberUtils.class.getDeclaredConstructors();\n         assertEquals(1, cons.length);\n         assertTrue(Modifier.isPublic(cons[0].getModifiers()));\n         assertTrue(Modifier.isPublic(NumberUtils.class.getModifiers()));\n         try {\n             NumberUtils.createNumber(\"--1.1E-700F\");\n             fail(\"Expected NumberFormatException\");\n-        } catch (NumberFormatException nfe) {\n+        } catch (final NumberFormatException nfe) {\n             // expected\n         }\n     }\n \n     protected void testCreateFloatFailure(final String str) {\n         try {\n-            Float value = NumberUtils.createFloat(str);\n+            final Float value = NumberUtils.createFloat(str);\n             fail(\"createFloat(blank) failed: \" + value);\n-        } catch (NumberFormatException ex) {\n+        } catch (final NumberFormatException ex) {\n             // empty\n         }\n     }\n \n     protected void testCreateDoubleFailure(final String str) {\n         try {\n-            Double value = NumberUtils.createDouble(str);\n+            final Double value = NumberUtils.createDouble(str);\n             fail(\"createDouble(blank) failed: \" + value);\n-        } catch (NumberFormatException ex) {\n+        } catch (final NumberFormatException ex) {\n             // empty\n         }\n     }\n \n     protected void testCreateIntegerFailure(final String str) {\n         try {\n-            Integer value = NumberUtils.createInteger(str);\n+            final Integer value = NumberUtils.createInteger(str);\n             fail(\"createInteger(blank) failed: \" + value);\n-        } catch (NumberFormatException ex) {\n+        } catch (final NumberFormatException ex) {\n             // empty\n         }\n     }\n \n     protected void testCreateLongFailure(final String str) {\n         try {\n-            Long value = NumberUtils.createLong(str);\n+            final Long value = NumberUtils.createLong(str);\n             fail(\"createLong(blank) failed: \" + value);\n-        } catch (NumberFormatException ex) {\n+        } catch (final NumberFormatException ex) {\n             // empty\n         }\n     }\n \n     protected void testCreateBigIntegerFailure(final String str) {\n         try {\n-            BigInteger value = NumberUtils.createBigInteger(str);\n+            final BigInteger value = NumberUtils.createBigInteger(str);\n             fail(\"createBigInteger(blank) failed: \" + value);\n-        } catch (NumberFormatException ex) {\n+        } catch (final NumberFormatException ex) {\n             // empty\n         }\n     }\n \n     protected void testCreateBigDecimalFailure(final String str) {\n         try {\n-            BigDecimal value = NumberUtils.createBigDecimal(str);\n+            final BigDecimal value = NumberUtils.createBigDecimal(str);\n             fail(\"createBigDecimal(blank) failed: \" + value);\n-        } catch (NumberFormatException ex) {\n+        } catch (final NumberFormatException ex) {\n             // empty\n         }\n     }\n         try {\n             NumberUtils.max(d);\n             fail(\"No exception was thrown for null input.\");\n-        } catch (IllegalArgumentException ex) {}\n+        } catch (final IllegalArgumentException ex) {}\n \n         try {\n             NumberUtils.max(new double[0]);\n             fail(\"No exception was thrown for empty input.\");\n-        } catch (IllegalArgumentException ex) {}\n+        } catch (final IllegalArgumentException ex) {}\n \n         assertEquals(\n             \"max(double[]) failed for array length 1\",\n \n     @Test\n     public void testMinimumShort() {\n-        short low = 1234;\n-        short mid = 1234 + 1;\n-        short high = 1234 + 2;\n+        final short low = 1234;\n+        final short mid = 1234 + 1;\n+        final short high = 1234 + 2;\n         assertEquals(\"minimum(short,short,short) 1 failed\", low, NumberUtils.min(low, mid, high));\n         assertEquals(\"minimum(short,short,short) 1 failed\", low, NumberUtils.min(mid, low, high));\n         assertEquals(\"minimum(short,short,short) 1 failed\", low, NumberUtils.min(mid, high, low));\n \n     @Test\n     public void testMinimumByte() {\n-        byte low = 123;\n-        byte mid = 123 + 1;\n-        byte high = 123 + 2;\n+        final byte low = 123;\n+        final byte mid = 123 + 1;\n+        final byte high = 123 + 2;\n         assertEquals(\"minimum(byte,byte,byte) 1 failed\", low, NumberUtils.min(low, mid, high));\n         assertEquals(\"minimum(byte,byte,byte) 1 failed\", low, NumberUtils.min(mid, low, high));\n         assertEquals(\"minimum(byte,byte,byte) 1 failed\", low, NumberUtils.min(mid, high, low));\n \n     @Test\n     public void testMinimumDouble() {\n-        double low = 12.3;\n-        double mid = 12.3 + 1;\n-        double high = 12.3 + 2;\n+        final double low = 12.3;\n+        final double mid = 12.3 + 1;\n+        final double high = 12.3 + 2;\n         assertEquals(low, NumberUtils.min(low, mid, high), 0.0001);\n         assertEquals(low, NumberUtils.min(mid, low, high), 0.0001);\n         assertEquals(low, NumberUtils.min(mid, high, low), 0.0001);\n \n     @Test\n     public void testMinimumFloat() {\n-        float low = 12.3f;\n-        float mid = 12.3f + 1;\n-        float high = 12.3f + 2;\n+        final float low = 12.3f;\n+        final float mid = 12.3f + 1;\n+        final float high = 12.3f + 2;\n         assertEquals(low, NumberUtils.min(low, mid, high), 0.0001f);\n         assertEquals(low, NumberUtils.min(mid, low, high), 0.0001f);\n         assertEquals(low, NumberUtils.min(mid, high, low), 0.0001f);\n \n     @Test\n     public void testMaximumShort() {\n-        short low = 1234;\n-        short mid = 1234 + 1;\n-        short high = 1234 + 2;\n+        final short low = 1234;\n+        final short mid = 1234 + 1;\n+        final short high = 1234 + 2;\n         assertEquals(\"maximum(short,short,short) 1 failed\", high, NumberUtils.max(low, mid, high));\n         assertEquals(\"maximum(short,short,short) 1 failed\", high, NumberUtils.max(mid, low, high));\n         assertEquals(\"maximum(short,short,short) 1 failed\", high, NumberUtils.max(mid, high, low));\n \n     @Test\n     public void testMaximumByte() {\n-        byte low = 123;\n-        byte mid = 123 + 1;\n-        byte high = 123 + 2;\n+        final byte low = 123;\n+        final byte mid = 123 + 1;\n+        final byte high = 123 + 2;\n         assertEquals(\"maximum(byte,byte,byte) 1 failed\", high, NumberUtils.max(low, mid, high));\n         assertEquals(\"maximum(byte,byte,byte) 1 failed\", high, NumberUtils.max(mid, low, high));\n         assertEquals(\"maximum(byte,byte,byte) 1 failed\", high, NumberUtils.max(mid, high, low));\n \n     @Test\n     public void testMaximumDouble() {\n-        double low = 12.3;\n-        double mid = 12.3 + 1;\n-        double high = 12.3 + 2;\n+        final double low = 12.3;\n+        final double mid = 12.3 + 1;\n+        final double high = 12.3 + 2;\n         assertEquals(high, NumberUtils.max(low, mid, high), 0.0001);\n         assertEquals(high, NumberUtils.max(mid, low, high), 0.0001);\n         assertEquals(high, NumberUtils.max(mid, high, low), 0.0001);\n \n     @Test\n     public void testMaximumFloat() {\n-        float low = 12.3f;\n-        float mid = 12.3f + 1;\n-        float high = 12.3f + 2;\n+        final float low = 12.3f;\n+        final float mid = 12.3f + 1;\n+        final float high = 12.3f + 2;\n         assertEquals(high, NumberUtils.max(low, mid, high), 0.0001f);\n         assertEquals(high, NumberUtils.max(mid, low, high), 0.0001f);\n         assertEquals(high, NumberUtils.max(mid, high, low), 0.0001f);\n \n     private boolean checkCreateNumber(final String val) {\n         try {\n-            Object obj = NumberUtils.createNumber(val);\n+            final Object obj = NumberUtils.createNumber(val);\n             if (obj == null) {\n                 return false;\n             }\n             return true;\n-        } catch (NumberFormatException e) {\n+        } catch (final NumberFormatException e) {\n             return false;\n        }\n     }\n         assertTrue(Float.isNaN(NumberUtils.min(1.2f, 2.5f, Float.NaN)));\n         assertTrue(Float.isNaN(NumberUtils.max(1.2f, 2.5f, Float.NaN)));\n \n-        double[] a = new double[] { 1.2, Double.NaN, 3.7, 27.0, 42.0, Double.NaN };\n+        final double[] a = new double[] { 1.2, Double.NaN, 3.7, 27.0, 42.0, Double.NaN };\n         assertTrue(Double.isNaN(NumberUtils.max(a)));\n         assertTrue(Double.isNaN(NumberUtils.min(a)));\n \n-        double[] b = new double[] { Double.NaN, 1.2, Double.NaN, 3.7, 27.0, 42.0, Double.NaN };\n+        final double[] b = new double[] { Double.NaN, 1.2, Double.NaN, 3.7, 27.0, 42.0, Double.NaN };\n         assertTrue(Double.isNaN(NumberUtils.max(b)));\n         assertTrue(Double.isNaN(NumberUtils.min(b)));\n \n-        float[] aF = new float[] { 1.2f, Float.NaN, 3.7f, 27.0f, 42.0f, Float.NaN };\n+        final float[] aF = new float[] { 1.2f, Float.NaN, 3.7f, 27.0f, 42.0f, Float.NaN };\n         assertTrue(Float.isNaN(NumberUtils.max(aF)));\n \n-        float[] bF = new float[] { Float.NaN, 1.2f, Float.NaN, 3.7f, 27.0f, 42.0f, Float.NaN };\n+        final float[] bF = new float[] { Float.NaN, 1.2f, Float.NaN, 3.7f, 27.0f, 42.0f, Float.NaN };\n         assertTrue(Float.isNaN(NumberUtils.max(bF)));\n     }\n \n--- a/src/test/java/org/apache/commons/lang3/mutable/MutableByteTest.java\n+++ b/src/test/java/org/apache/commons/lang3/mutable/MutableByteTest.java\n \n     @Test\n     public void testPrimitiveValues() {\n-        MutableByte mutNum = new MutableByte( (byte) 1 );\n+        final MutableByte mutNum = new MutableByte( (byte) 1 );\n         \n         assertEquals( 1.0F, mutNum.floatValue(), 0 );\n         assertEquals( 1.0, mutNum.doubleValue(), 0 );\n \n     @Test\n     public void testIncrement() {\n-        MutableByte mutNum = new MutableByte((byte) 1);\n+        final MutableByte mutNum = new MutableByte((byte) 1);\n         mutNum.increment();\n         \n         assertEquals(2, mutNum.intValue());\n \n     @Test\n     public void testDecrement() {\n-        MutableByte mutNum = new MutableByte((byte) 1);\n+        final MutableByte mutNum = new MutableByte((byte) 1);\n         mutNum.decrement();\n         \n         assertEquals(0, mutNum.intValue());\n \n     @Test\n     public void testAddValuePrimitive() {\n-        MutableByte mutNum = new MutableByte((byte) 1);\n+        final MutableByte mutNum = new MutableByte((byte) 1);\n         mutNum.add((byte)1);\n         \n         assertEquals((byte) 2, mutNum.byteValue());\n \n     @Test\n     public void testAddValueObject() {\n-        MutableByte mutNum = new MutableByte((byte) 1);\n+        final MutableByte mutNum = new MutableByte((byte) 1);\n         mutNum.add(Integer.valueOf(1));\n         \n         assertEquals((byte) 2, mutNum.byteValue());\n \n     @Test\n     public void testSubtractValuePrimitive() {\n-        MutableByte mutNum = new MutableByte((byte) 1);\n+        final MutableByte mutNum = new MutableByte((byte) 1);\n         mutNum.subtract((byte) 1);\n         \n         assertEquals((byte) 0, mutNum.byteValue());\n \n     @Test\n     public void testSubtractValueObject() {\n-        MutableByte mutNum = new MutableByte((byte) 1);\n+        final MutableByte mutNum = new MutableByte((byte) 1);\n         mutNum.subtract(Integer.valueOf(1));\n         \n         assertEquals((byte) 0, mutNum.byteValue());\n--- a/src/test/java/org/apache/commons/lang3/mutable/MutableDoubleTest.java\n+++ b/src/test/java/org/apache/commons/lang3/mutable/MutableDoubleTest.java\n \n     @Test\n     public void testPrimitiveValues() {\n-        MutableDouble mutNum = new MutableDouble(1.7);\n+        final MutableDouble mutNum = new MutableDouble(1.7);\n         \n         assertEquals( 1.7F, mutNum.floatValue(), 0 );\n         assertEquals( 1.7, mutNum.doubleValue(), 0 );\n \n     @Test\n     public void testIncrement() {\n-        MutableDouble mutNum = new MutableDouble(1);\n+        final MutableDouble mutNum = new MutableDouble(1);\n         mutNum.increment();\n         \n         assertEquals(2, mutNum.intValue());\n \n     @Test\n     public void testDecrement() {\n-        MutableDouble mutNum = new MutableDouble(1);\n+        final MutableDouble mutNum = new MutableDouble(1);\n         mutNum.decrement();\n         \n         assertEquals(0, mutNum.intValue());\n \n     @Test\n     public void testAddValuePrimitive() {\n-        MutableDouble mutNum = new MutableDouble(1);\n+        final MutableDouble mutNum = new MutableDouble(1);\n         mutNum.add(1.1d);\n         \n         assertEquals(2.1d, mutNum.doubleValue(), 0.01d);\n \n     @Test\n     public void testAddValueObject() {\n-        MutableDouble mutNum = new MutableDouble(1);\n+        final MutableDouble mutNum = new MutableDouble(1);\n         mutNum.add(Double.valueOf(1.1d));\n         \n         assertEquals(2.1d, mutNum.doubleValue(), 0.01d);\n \n     @Test\n     public void testSubtractValuePrimitive() {\n-        MutableDouble mutNum = new MutableDouble(1);\n+        final MutableDouble mutNum = new MutableDouble(1);\n         mutNum.subtract(0.9d);\n         \n         assertEquals(0.1d, mutNum.doubleValue(), 0.01d);\n \n     @Test\n     public void testSubtractValueObject() {\n-        MutableDouble mutNum = new MutableDouble(1);\n+        final MutableDouble mutNum = new MutableDouble(1);\n         mutNum.subtract(Double.valueOf(0.9d));\n         \n         assertEquals(0.1d, mutNum.doubleValue(), 0.01d);\n--- a/src/test/java/org/apache/commons/lang3/mutable/MutableFloatTest.java\n+++ b/src/test/java/org/apache/commons/lang3/mutable/MutableFloatTest.java\n \n     @Test\n     public void testPrimitiveValues() {\n-        MutableFloat mutNum = new MutableFloat(1.7F);\n+        final MutableFloat mutNum = new MutableFloat(1.7F);\n         \n         assertEquals( 1, mutNum.intValue() );\n         assertEquals( 1.7, mutNum.doubleValue(), 0.00001 );\n \n     @Test\n     public void testIncrement() {\n-        MutableFloat mutNum = new MutableFloat(1);\n+        final MutableFloat mutNum = new MutableFloat(1);\n         mutNum.increment();\n         \n         assertEquals(2, mutNum.intValue());\n \n     @Test\n     public void testDecrement() {\n-        MutableFloat mutNum = new MutableFloat(1);\n+        final MutableFloat mutNum = new MutableFloat(1);\n         mutNum.decrement();\n         \n         assertEquals(0, mutNum.intValue());\n \n     @Test\n     public void testAddValuePrimitive() {\n-        MutableFloat mutNum = new MutableFloat(1);\n+        final MutableFloat mutNum = new MutableFloat(1);\n         mutNum.add(1.1f);\n         \n         assertEquals(2.1f, mutNum.floatValue(), 0.01f);\n \n     @Test\n     public void testAddValueObject() {\n-        MutableFloat mutNum = new MutableFloat(1);\n+        final MutableFloat mutNum = new MutableFloat(1);\n         mutNum.add(Float.valueOf(1.1f));\n         \n         assertEquals(2.1f, mutNum.floatValue(), 0.01f);\n \n     @Test\n     public void testSubtractValuePrimitive() {\n-        MutableFloat mutNum = new MutableFloat(1);\n+        final MutableFloat mutNum = new MutableFloat(1);\n         mutNum.subtract(0.9f);\n         \n         assertEquals(0.1f, mutNum.floatValue(), 0.01f);\n \n     @Test\n     public void testSubtractValueObject() {\n-        MutableFloat mutNum = new MutableFloat(1);\n+        final MutableFloat mutNum = new MutableFloat(1);\n         mutNum.subtract(Float.valueOf(0.9f));\n         \n         assertEquals(0.1f, mutNum.floatValue(), 0.01f);\n--- a/src/test/java/org/apache/commons/lang3/mutable/MutableIntTest.java\n+++ b/src/test/java/org/apache/commons/lang3/mutable/MutableIntTest.java\n \n     @Test\n     public void testPrimitiveValues() {\n-        MutableInt mutNum = new MutableInt(1);\n+        final MutableInt mutNum = new MutableInt(1);\n         \n         assertEquals( (byte) 1, mutNum.byteValue() );\n         assertEquals( (short) 1, mutNum.shortValue() );\n \n     @Test\n     public void testIncrement() {\n-        MutableInt mutNum = new MutableInt(1);\n+        final MutableInt mutNum = new MutableInt(1);\n         mutNum.increment();\n         \n         assertEquals(2, mutNum.intValue());\n \n     @Test\n     public void testDecrement() {\n-        MutableInt mutNum = new MutableInt(1);\n+        final MutableInt mutNum = new MutableInt(1);\n         mutNum.decrement();\n         \n         assertEquals(0, mutNum.intValue());\n \n     @Test\n     public void testAddValuePrimitive() {\n-        MutableInt mutNum = new MutableInt(1);\n+        final MutableInt mutNum = new MutableInt(1);\n         mutNum.add(1);\n         \n         assertEquals(2, mutNum.intValue());\n \n     @Test\n     public void testAddValueObject() {\n-        MutableInt mutNum = new MutableInt(1);\n+        final MutableInt mutNum = new MutableInt(1);\n         mutNum.add(Integer.valueOf(1));\n         \n         assertEquals(2, mutNum.intValue());\n \n     @Test\n     public void testSubtractValuePrimitive() {\n-        MutableInt mutNum = new MutableInt(1);\n+        final MutableInt mutNum = new MutableInt(1);\n         mutNum.subtract(1);\n         \n         assertEquals(0, mutNum.intValue());\n \n     @Test\n     public void testSubtractValueObject() {\n-        MutableInt mutNum = new MutableInt(1);\n+        final MutableInt mutNum = new MutableInt(1);\n         mutNum.subtract(Integer.valueOf(1));\n         \n         assertEquals(0, mutNum.intValue());\n--- a/src/test/java/org/apache/commons/lang3/mutable/MutableLongTest.java\n+++ b/src/test/java/org/apache/commons/lang3/mutable/MutableLongTest.java\n \n     @Test\n     public void testPrimitiveValues() {\n-        MutableLong mutNum = new MutableLong(1L);\n+        final MutableLong mutNum = new MutableLong(1L);\n \n         assertEquals( 1.0F, mutNum.floatValue(), 0 );\n         assertEquals( 1.0, mutNum.doubleValue(), 0 );\n \n     @Test\n     public void testIncrement() {\n-        MutableLong mutNum = new MutableLong(1);\n+        final MutableLong mutNum = new MutableLong(1);\n         mutNum.increment();\n         \n         assertEquals(2, mutNum.intValue());\n \n     @Test\n     public void testDecrement() {\n-        MutableLong mutNum = new MutableLong(1);\n+        final MutableLong mutNum = new MutableLong(1);\n         mutNum.decrement();\n         \n         assertEquals(0, mutNum.intValue());\n \n     @Test\n     public void testAddValuePrimitive() {\n-        MutableLong mutNum = new MutableLong(1);\n+        final MutableLong mutNum = new MutableLong(1);\n         mutNum.add(1);\n         \n         assertEquals(2, mutNum.intValue());\n \n     @Test\n     public void testAddValueObject() {\n-        MutableLong mutNum = new MutableLong(1);\n+        final MutableLong mutNum = new MutableLong(1);\n         mutNum.add(Long.valueOf(1));\n         \n         assertEquals(2, mutNum.intValue());\n \n     @Test\n     public void testSubtractValuePrimitive() {\n-        MutableLong mutNum = new MutableLong(1);\n+        final MutableLong mutNum = new MutableLong(1);\n         mutNum.subtract(1);\n         \n         assertEquals(0, mutNum.intValue());\n \n     @Test\n     public void testSubtractValueObject() {\n-        MutableLong mutNum = new MutableLong(1);\n+        final MutableLong mutNum = new MutableLong(1);\n         mutNum.subtract(Long.valueOf(1));\n         \n         assertEquals(0, mutNum.intValue());\n--- a/src/test/java/org/apache/commons/lang3/mutable/MutableObjectTest.java\n+++ b/src/test/java/org/apache/commons/lang3/mutable/MutableObjectTest.java\n     public void testConstructors() {\n         assertEquals(null, new MutableObject<String>().getValue());\n         \n-        Integer i = Integer.valueOf(6);\n+        final Integer i = Integer.valueOf(6);\n         assertSame(i, new MutableObject<Integer>(i).getValue());\n         assertSame(\"HI\", new MutableObject<String>(\"HI\").getValue());\n         assertSame(null, new MutableObject<Object>(null).getValue());\n--- a/src/test/java/org/apache/commons/lang3/mutable/MutableShortTest.java\n+++ b/src/test/java/org/apache/commons/lang3/mutable/MutableShortTest.java\n         try {\n             new MutableShort((Number)null);\n             fail();\n-        } catch (NullPointerException ex) {}\n+        } catch (final NullPointerException ex) {}\n     }\n \n     @Test\n         try {\n             mutNum.setValue(null);\n             fail();\n-        } catch (NullPointerException ex) {}\n+        } catch (final NullPointerException ex) {}\n     }\n \n     @Test\n         try {\n             mutNum.compareTo(null);\n             fail();\n-        } catch (NullPointerException ex) {}\n+        } catch (final NullPointerException ex) {}\n     }\n \n     @Test\n     public void testPrimitiveValues() {\n-        MutableShort mutNum = new MutableShort( (short) 1 );\n+        final MutableShort mutNum = new MutableShort( (short) 1 );\n         \n         assertEquals( 1.0F, mutNum.floatValue(), 0 );\n         assertEquals( 1.0, mutNum.doubleValue(), 0 );\n \n     @Test\n     public void testIncrement() {\n-        MutableShort mutNum = new MutableShort((short) 1);\n+        final MutableShort mutNum = new MutableShort((short) 1);\n         mutNum.increment();\n         \n         assertEquals(2, mutNum.intValue());\n \n     @Test\n     public void testDecrement() {\n-        MutableShort mutNum = new MutableShort((short) 1);\n+        final MutableShort mutNum = new MutableShort((short) 1);\n         mutNum.decrement();\n         \n         assertEquals(0, mutNum.intValue());\n \n     @Test\n     public void testAddValuePrimitive() {\n-        MutableShort mutNum = new MutableShort((short) 1);\n+        final MutableShort mutNum = new MutableShort((short) 1);\n         mutNum.add((short) 1);\n         \n         assertEquals((short) 2, mutNum.shortValue());\n \n     @Test\n     public void testAddValueObject() {\n-        MutableShort mutNum = new MutableShort((short) 1);\n+        final MutableShort mutNum = new MutableShort((short) 1);\n         mutNum.add(Short.valueOf((short) 1));\n         \n         assertEquals((short) 2, mutNum.shortValue());\n \n     @Test\n     public void testSubtractValuePrimitive() {\n-        MutableShort mutNum = new MutableShort((short) 1);\n+        final MutableShort mutNum = new MutableShort((short) 1);\n         mutNum.subtract((short) 1);\n         \n         assertEquals((short) 0, mutNum.shortValue());\n \n     @Test\n     public void testSubtractValueObject() {\n-        MutableShort mutNum = new MutableShort((short) 1);\n+        final MutableShort mutNum = new MutableShort((short) 1);\n         mutNum.subtract(Short.valueOf((short) 1));\n         \n         assertEquals((short) 0, mutNum.shortValue());\n--- a/src/test/java/org/apache/commons/lang3/reflect/ConstructorUtilsTest.java\n+++ b/src/test/java/org/apache/commons/lang3/reflect/ConstructorUtilsTest.java\n             ConstructorUtils.invokeExactConstructor(TestBean.class,\n                     NumberUtils.BYTE_ONE);\n             fail(\"should throw NoSuchMethodException\");\n-        } catch (NoSuchMethodException e) {\n+        } catch (final NoSuchMethodException e) {\n         }\n         try {\n             ConstructorUtils.invokeExactConstructor(TestBean.class,\n                     NumberUtils.LONG_ONE);\n             fail(\"should throw NoSuchMethodException\");\n-        } catch (NoSuchMethodException e) {\n+        } catch (final NoSuchMethodException e) {\n         }\n         try {\n             ConstructorUtils.invokeExactConstructor(TestBean.class,\n                     Boolean.TRUE);\n             fail(\"should throw NoSuchMethodException\");\n-        } catch (NoSuchMethodException e) {\n+        } catch (final NoSuchMethodException e) {\n         }\n     }\n \n \n     private void expectMatchingAccessibleConstructorParameterTypes(final Class<?> cls,\n             final Class<?>[] requestTypes, final Class<?>[] actualTypes) {\n-        Constructor<?> c = ConstructorUtils.getMatchingAccessibleConstructor(cls,\n+        final Constructor<?> c = ConstructorUtils.getMatchingAccessibleConstructor(cls,\n                 requestTypes);\n         assertTrue(toString(c.getParameterTypes()) + \" not equals \"\n                 + toString(actualTypes), Arrays.equals(actualTypes, c\n--- a/src/test/java/org/apache/commons/lang3/reflect/FieldUtilsTest.java\n+++ b/src/test/java/org/apache/commons/lang3/reflect/FieldUtilsTest.java\n     @Test\n     public void testConstructor() {\n         assertNotNull(new FieldUtils());\n-        Constructor<?>[] cons = FieldUtils.class.getDeclaredConstructors();\n+        final Constructor<?>[] cons = FieldUtils.class.getDeclaredConstructors();\n         assertEquals(1, cons.length);\n         assertTrue(Modifier.isPublic(cons[0].getModifiers()));\n         assertTrue(Modifier.isPublic(FieldUtils.class.getModifiers()));\n     @Test(expected=IllegalArgumentException.class)\n     public void testReadStaticFieldIllegalArgumentException2() throws Exception {\n         assertEquals(Foo.VALUE, FieldUtils.readStaticField(FieldUtils.getField(Foo.class, \"VALUE\")));\n-        Field nonStaticField = FieldUtils.getField(PublicChild.class, \"s\");\n+        final Field nonStaticField = FieldUtils.getField(PublicChild.class, \"s\");\n         assumeNotNull(nonStaticField);\n         FieldUtils.readStaticField(nonStaticField);\n     }\n \n     @Test(expected=IllegalArgumentException.class)\n     public void testReadStaticFieldForceAccessIllegalArgumentException2() throws Exception {\n-        Field nonStaticField = FieldUtils.getField(PublicChild.class, \"s\", true);\n+        final Field nonStaticField = FieldUtils.getField(PublicChild.class, \"s\", true);\n         assumeNotNull(nonStaticField);\n         FieldUtils.readStaticField(nonStaticField);\n     }\n         try {\n             FieldUtils.readStaticField(null, \"none\");\n             fail(\"null class should cause an IllegalArgumentException\");\n-        } catch (IllegalArgumentException e) {\n+        } catch (final IllegalArgumentException e) {\n             // expected\n         }\n         \n         try {\n             FieldUtils.readStaticField(Foo.class, null);\n             fail(\"null field name should cause an IllegalArgumentException\");\n-        } catch (IllegalArgumentException e) {\n+        } catch (final IllegalArgumentException e) {\n             // expected\n         }\n         \n         try {\n             FieldUtils.readStaticField(Foo.class, \"does_not_exist\");\n             fail(\"a field that doesn't exist should cause an IllegalArgumentException\");\n-        } catch (IllegalArgumentException e) {\n+        } catch (final IllegalArgumentException e) {\n             // expected\n         }\n         \n         try {\n             FieldUtils.readStaticField(PublicChild.class, \"s\");\n             fail(\"non-static field should cause an IllegalArgumentException\");\n-        } catch (IllegalArgumentException e) {\n+        } catch (final IllegalArgumentException e) {\n             // expected\n         }\n     }\n         try {\n             FieldUtils.readStaticField(null, \"none\", true);\n             fail(\"null class should cause an IllegalArgumentException\");\n-        } catch (IllegalArgumentException e) {\n+        } catch (final IllegalArgumentException e) {\n             // expected\n         }\n         \n         try {\n             FieldUtils.readStaticField(Foo.class, null, true);\n             fail(\"null field name should cause an IllegalArgumentException\");\n-        } catch (IllegalArgumentException e) {\n+        } catch (final IllegalArgumentException e) {\n             // expected\n         }\n         \n         try {\n             FieldUtils.readStaticField(Foo.class, \"does_not_exist\", true);\n             fail(\"a field that doesn't exist should cause an IllegalArgumentException\");\n-        } catch (IllegalArgumentException e) {\n+        } catch (final IllegalArgumentException e) {\n             // expected\n         }\n         \n         try {\n             FieldUtils.readStaticField(PublicChild.class, \"s\", false);\n             fail(\"non-static field should cause an IllegalArgumentException\");\n-        } catch (IllegalArgumentException e) {\n+        } catch (final IllegalArgumentException e) {\n             // expected\n         }\n     }\n         try {\n             assertEquals(\"child\", FieldUtils.readDeclaredStaticField(PublicChild.class, \"VALUE\"));\n             fail(\"expected IllegalArgumentException\");\n-        } catch (IllegalArgumentException e) {\n+        } catch (final IllegalArgumentException e) {\n             // pass\n         }\n         try {\n             assertEquals(Foo.VALUE, FieldUtils.readDeclaredStaticField(PubliclyShadowedChild.class, \"VALUE\"));\n             fail(\"expected IllegalArgumentException\");\n-        } catch (IllegalArgumentException e) {\n+        } catch (final IllegalArgumentException e) {\n             // pass\n         }\n         try {\n             assertEquals(Foo.VALUE, FieldUtils.readDeclaredStaticField(PrivatelyShadowedChild.class, \"VALUE\"));\n             fail(\"expected IllegalArgumentException\");\n-        } catch (IllegalArgumentException e) {\n+        } catch (final IllegalArgumentException e) {\n             // pass\n         }\n     }\n         try {\n             assertEquals(Foo.VALUE, FieldUtils.readDeclaredStaticField(PubliclyShadowedChild.class, \"VALUE\", true));\n             fail(\"expected IllegalArgumentException\");\n-        } catch (IllegalArgumentException e) {\n+        } catch (final IllegalArgumentException e) {\n             // pass\n         }\n         try {\n             assertEquals(Foo.VALUE, FieldUtils.readDeclaredStaticField(PrivatelyShadowedChild.class, \"VALUE\", true));\n             fail(\"expected IllegalArgumentException\");\n-        } catch (IllegalArgumentException e) {\n+        } catch (final IllegalArgumentException e) {\n             // pass\n         }\n     }\n \n     @Test\n     public void testReadField() throws Exception {\n-        Field parentS = FieldUtils.getDeclaredField(parentClass, \"s\");\n+        final Field parentS = FieldUtils.getDeclaredField(parentClass, \"s\");\n         assertEquals(\"s\", FieldUtils.readField(parentS, publicChild));\n         assertEquals(\"s\", FieldUtils.readField(parentS, publiclyShadowedChild));\n         assertEquals(\"s\", FieldUtils.readField(parentS, privatelyShadowedChild));\n-        Field parentB = FieldUtils.getDeclaredField(parentClass, \"b\", true);\n+        final Field parentB = FieldUtils.getDeclaredField(parentClass, \"b\", true);\n         assertEquals(Boolean.FALSE, FieldUtils.readField(parentB, publicChild));\n         assertEquals(Boolean.FALSE, FieldUtils.readField(parentB, publiclyShadowedChild));\n         assertEquals(Boolean.FALSE, FieldUtils.readField(parentB, privatelyShadowedChild));\n-        Field parentI = FieldUtils.getDeclaredField(parentClass, \"i\", true);\n+        final Field parentI = FieldUtils.getDeclaredField(parentClass, \"i\", true);\n         assertEquals(I0, FieldUtils.readField(parentI, publicChild));\n         assertEquals(I0, FieldUtils.readField(parentI, publiclyShadowedChild));\n         assertEquals(I0, FieldUtils.readField(parentI, privatelyShadowedChild));\n-        Field parentD = FieldUtils.getDeclaredField(parentClass, \"d\", true);\n+        final Field parentD = FieldUtils.getDeclaredField(parentClass, \"d\", true);\n         assertEquals(D0, FieldUtils.readField(parentD, publicChild));\n         assertEquals(D0, FieldUtils.readField(parentD, publiclyShadowedChild));\n         assertEquals(D0, FieldUtils.readField(parentD, privatelyShadowedChild));\n         try {\n             FieldUtils.readField((Field)null, publicChild);\n             fail(\"a null field should cause an IllegalArgumentException\");\n-        } catch (IllegalArgumentException e) {\n+        } catch (final IllegalArgumentException e) {\n             // expected\n         }\n     }\n \n     @Test\n     public void testReadFieldForceAccess() throws Exception {\n-        Field parentS = FieldUtils.getDeclaredField(parentClass, \"s\");\n+        final Field parentS = FieldUtils.getDeclaredField(parentClass, \"s\");\n         parentS.setAccessible(false);\n         assertEquals(\"s\", FieldUtils.readField(parentS, publicChild, true));\n         assertEquals(\"s\", FieldUtils.readField(parentS, publiclyShadowedChild, true));\n         assertEquals(\"s\", FieldUtils.readField(parentS, privatelyShadowedChild, true));\n-        Field parentB = FieldUtils.getDeclaredField(parentClass, \"b\", true);\n+        final Field parentB = FieldUtils.getDeclaredField(parentClass, \"b\", true);\n         parentB.setAccessible(false);\n         assertEquals(Boolean.FALSE, FieldUtils.readField(parentB, publicChild, true));\n         assertEquals(Boolean.FALSE, FieldUtils.readField(parentB, publiclyShadowedChild, true));\n         assertEquals(Boolean.FALSE, FieldUtils.readField(parentB, privatelyShadowedChild, true));\n-        Field parentI = FieldUtils.getDeclaredField(parentClass, \"i\", true);\n+        final Field parentI = FieldUtils.getDeclaredField(parentClass, \"i\", true);\n         parentI.setAccessible(false);\n         assertEquals(I0, FieldUtils.readField(parentI, publicChild, true));\n         assertEquals(I0, FieldUtils.readField(parentI, publiclyShadowedChild, true));\n         assertEquals(I0, FieldUtils.readField(parentI, privatelyShadowedChild, true));\n-        Field parentD = FieldUtils.getDeclaredField(parentClass, \"d\", true);\n+        final Field parentD = FieldUtils.getDeclaredField(parentClass, \"d\", true);\n         parentD.setAccessible(false);\n         assertEquals(D0, FieldUtils.readField(parentD, publicChild, true));\n         assertEquals(D0, FieldUtils.readField(parentD, publiclyShadowedChild, true));\n         try {\n             FieldUtils.readField((Field)null, publicChild, true);\n             fail(\"a null field should cause an IllegalArgumentException\");\n-        } catch (IllegalArgumentException e) {\n+        } catch (final IllegalArgumentException e) {\n             // expected\n         }\n     }\n         try {\n             FieldUtils.readField(publicChild, null);\n             fail(\"a null field name should cause an IllegalArgumentException\");\n-        } catch (IllegalArgumentException e) {\n+        } catch (final IllegalArgumentException e) {\n             // expected\n         }\n         \n         try {\n             FieldUtils.readField((Object)null, \"none\");\n             fail(\"a null target should cause an IllegalArgumentException\");\n-        } catch (IllegalArgumentException e) {\n+        } catch (final IllegalArgumentException e) {\n             // expected\n         }\n         \n         try {\n             assertEquals(Boolean.FALSE, FieldUtils.readField(publicChild, \"b\"));\n             fail(\"expected IllegalArgumentException\");\n-        } catch (IllegalArgumentException e) {\n+        } catch (final IllegalArgumentException e) {\n             // pass\n         }\n         assertEquals(Boolean.TRUE, FieldUtils.readField(publiclyShadowedChild, \"b\"));\n         try {\n             assertEquals(Boolean.FALSE, FieldUtils.readField(privatelyShadowedChild, \"b\"));\n             fail(\"expected IllegalArgumentException\");\n-        } catch (IllegalArgumentException e) {\n+        } catch (final IllegalArgumentException e) {\n             // pass\n         }\n         try {\n             assertEquals(I0, FieldUtils.readField(publicChild, \"i\"));\n             fail(\"expected IllegalArgumentException\");\n-        } catch (IllegalArgumentException e) {\n+        } catch (final IllegalArgumentException e) {\n             // pass\n         }\n         assertEquals(I1, FieldUtils.readField(publiclyShadowedChild, \"i\"));\n         try {\n             assertEquals(I0, FieldUtils.readField(privatelyShadowedChild, \"i\"));\n             fail(\"expected IllegalArgumentException\");\n-        } catch (IllegalArgumentException e) {\n+        } catch (final IllegalArgumentException e) {\n             // pass\n         }\n         try {\n             assertEquals(D0, FieldUtils.readField(publicChild, \"d\"));\n             fail(\"expected IllegalArgumentException\");\n-        } catch (IllegalArgumentException e) {\n+        } catch (final IllegalArgumentException e) {\n             // pass\n         }\n         assertEquals(D1, FieldUtils.readField(publiclyShadowedChild, \"d\"));\n         try {\n             assertEquals(D0, FieldUtils.readField(privatelyShadowedChild, \"d\"));\n             fail(\"expected IllegalArgumentException\");\n-        } catch (IllegalArgumentException e) {\n+        } catch (final IllegalArgumentException e) {\n             // pass\n         }\n     }\n         try {\n             FieldUtils.readField(publicChild, null, true);\n             fail(\"a null field name should cause an IllegalArgumentException\");\n-        } catch (IllegalArgumentException e) {\n+        } catch (final IllegalArgumentException e) {\n             // expected\n         }\n         \n         try {\n             FieldUtils.readField((Object)null, \"none\", true);\n             fail(\"a null target should cause an IllegalArgumentException\");\n-        } catch (IllegalArgumentException e) {\n+        } catch (final IllegalArgumentException e) {\n             // expected\n         }\n     }\n         try {\n             FieldUtils.readDeclaredField(publicChild, null);\n             fail(\"a null field name should cause an IllegalArgumentException\");\n-        } catch (IllegalArgumentException e) {\n+        } catch (final IllegalArgumentException e) {\n             // expected\n         }\n         \n         try {\n             FieldUtils.readDeclaredField((Object)null, \"none\");\n             fail(\"a null target should cause an IllegalArgumentException\");\n-        } catch (IllegalArgumentException e) {\n+        } catch (final IllegalArgumentException e) {\n             // expected\n         }\n         \n         try {\n             assertEquals(\"s\", FieldUtils.readDeclaredField(publicChild, \"s\"));\n             fail(\"expected IllegalArgumentException\");\n-        } catch (IllegalArgumentException e) {\n+        } catch (final IllegalArgumentException e) {\n             // pass\n         }\n         assertEquals(\"ss\", FieldUtils.readDeclaredField(publiclyShadowedChild, \"s\"));\n         try {\n             assertEquals(\"s\", FieldUtils.readDeclaredField(privatelyShadowedChild, \"s\"));\n             fail(\"expected IllegalArgumentException\");\n-        } catch (IllegalArgumentException e) {\n+        } catch (final IllegalArgumentException e) {\n             // pass\n         }\n         try {\n             assertEquals(Boolean.FALSE, FieldUtils.readDeclaredField(publicChild, \"b\"));\n             fail(\"expected IllegalArgumentException\");\n-        } catch (IllegalArgumentException e) {\n+        } catch (final IllegalArgumentException e) {\n             // pass\n         }\n         assertEquals(Boolean.TRUE, FieldUtils.readDeclaredField(publiclyShadowedChild, \"b\"));\n         try {\n             assertEquals(Boolean.FALSE, FieldUtils.readDeclaredField(privatelyShadowedChild, \"b\"));\n             fail(\"expected IllegalArgumentException\");\n-        } catch (IllegalArgumentException e) {\n+        } catch (final IllegalArgumentException e) {\n             // pass\n         }\n         try {\n             assertEquals(I0, FieldUtils.readDeclaredField(publicChild, \"i\"));\n             fail(\"expected IllegalArgumentException\");\n-        } catch (IllegalArgumentException e) {\n+        } catch (final IllegalArgumentException e) {\n             // pass\n         }\n         assertEquals(I1, FieldUtils.readDeclaredField(publiclyShadowedChild, \"i\"));\n         try {\n             assertEquals(I0, FieldUtils.readDeclaredField(privatelyShadowedChild, \"i\"));\n             fail(\"expected IllegalArgumentException\");\n-        } catch (IllegalArgumentException e) {\n+        } catch (final IllegalArgumentException e) {\n             // pass\n         }\n         try {\n             assertEquals(D0, FieldUtils.readDeclaredField(publicChild, \"d\"));\n             fail(\"expected IllegalArgumentException\");\n-        } catch (IllegalArgumentException e) {\n+        } catch (final IllegalArgumentException e) {\n             // pass\n         }\n         assertEquals(D1, FieldUtils.readDeclaredField(publiclyShadowedChild, \"d\"));\n         try {\n             assertEquals(D0, FieldUtils.readDeclaredField(privatelyShadowedChild, \"d\"));\n             fail(\"expected IllegalArgumentException\");\n-        } catch (IllegalArgumentException e) {\n+        } catch (final IllegalArgumentException e) {\n             // pass\n         }\n     }\n         try {\n             FieldUtils.readDeclaredField(publicChild, null, true);\n             fail(\"a null field name should cause an IllegalArgumentException\");\n-        } catch (IllegalArgumentException e) {\n+        } catch (final IllegalArgumentException e) {\n             // expected\n         }\n         \n         try {\n             FieldUtils.readDeclaredField((Object)null, \"none\", true);\n             fail(\"a null target should cause an IllegalArgumentException\");\n-        } catch (IllegalArgumentException e) {\n+        } catch (final IllegalArgumentException e) {\n             // expected\n         }\n         \n         try {\n             assertEquals(\"s\", FieldUtils.readDeclaredField(publicChild, \"s\", true));\n             fail(\"expected IllegalArgumentException\");\n-        } catch (IllegalArgumentException e) {\n+        } catch (final IllegalArgumentException e) {\n             // pass\n         }\n         assertEquals(\"ss\", FieldUtils.readDeclaredField(publiclyShadowedChild, \"s\", true));\n         try {\n             assertEquals(Boolean.FALSE, FieldUtils.readDeclaredField(publicChild, \"b\", true));\n             fail(\"expected IllegalArgumentException\");\n-        } catch (IllegalArgumentException e) {\n+        } catch (final IllegalArgumentException e) {\n             // pass\n         }\n         assertEquals(Boolean.TRUE, FieldUtils.readDeclaredField(publiclyShadowedChild, \"b\", true));\n         try {\n             assertEquals(I0, FieldUtils.readDeclaredField(publicChild, \"i\", true));\n             fail(\"expected IllegalArgumentException\");\n-        } catch (IllegalArgumentException e) {\n+        } catch (final IllegalArgumentException e) {\n             // pass\n         }\n         assertEquals(I1, FieldUtils.readDeclaredField(publiclyShadowedChild, \"i\", true));\n         try {\n             assertEquals(D0, FieldUtils.readDeclaredField(publicChild, \"d\", true));\n             fail(\"expected IllegalArgumentException\");\n-        } catch (IllegalArgumentException e) {\n+        } catch (final IllegalArgumentException e) {\n             // pass\n         }\n         assertEquals(D1, FieldUtils.readDeclaredField(publiclyShadowedChild, \"d\", true));\n         try {\n             FieldUtils.writeStaticField(field, \"new\");\n             fail(\"Expected IllegalAccessException\");\n-        } catch (IllegalAccessException e) {\n+        } catch (final IllegalAccessException e) {\n             // pass\n         }\n         field = StaticContainer.class.getDeclaredField(\"mutablePackage\");\n         try {\n             FieldUtils.writeStaticField(field, \"new\");\n             fail(\"Expected IllegalAccessException\");\n-        } catch (IllegalAccessException e) {\n+        } catch (final IllegalAccessException e) {\n             // pass\n         }\n         field = StaticContainer.class.getDeclaredField(\"mutablePrivate\");\n         try {\n             FieldUtils.writeStaticField(field, \"new\");\n             fail(\"Expected IllegalAccessException\");\n-        } catch (IllegalAccessException e) {\n+        } catch (final IllegalAccessException e) {\n             // pass\n         }\n         field = StaticContainer.class.getDeclaredField(\"IMMUTABLE_PUBLIC\");\n         try {\n             FieldUtils.writeStaticField(field, \"new\");\n             fail(\"Expected IllegalAccessException\");\n-        } catch (IllegalAccessException e) {\n+        } catch (final IllegalAccessException e) {\n             // pass\n         }\n         field = StaticContainer.class.getDeclaredField(\"IMMUTABLE_PROTECTED\");\n         try {\n             FieldUtils.writeStaticField(field, \"new\");\n             fail(\"Expected IllegalAccessException\");\n-        } catch (IllegalAccessException e) {\n+        } catch (final IllegalAccessException e) {\n             // pass\n         }\n         field = StaticContainer.class.getDeclaredField(\"IMMUTABLE_PACKAGE\");\n         try {\n             FieldUtils.writeStaticField(field, \"new\");\n             fail(\"Expected IllegalAccessException\");\n-        } catch (IllegalAccessException e) {\n+        } catch (final IllegalAccessException e) {\n             // pass\n         }\n         field = StaticContainer.class.getDeclaredField(\"IMMUTABLE_PRIVATE\");\n         try {\n             FieldUtils.writeStaticField(field, \"new\");\n             fail(\"Expected IllegalAccessException\");\n-        } catch (IllegalAccessException e) {\n+        } catch (final IllegalAccessException e) {\n             // pass\n         }\n     }\n         try {\n             FieldUtils.writeStaticField(field, \"new\", true);\n             fail(\"Expected IllegalAccessException\");\n-        } catch (IllegalAccessException e) {\n+        } catch (final IllegalAccessException e) {\n             // pass\n         }\n         field = StaticContainer.class.getDeclaredField(\"IMMUTABLE_PROTECTED\");\n         try {\n             FieldUtils.writeStaticField(field, \"new\", true);\n             fail(\"Expected IllegalAccessException\");\n-        } catch (IllegalAccessException e) {\n+        } catch (final IllegalAccessException e) {\n             // pass\n         }\n         field = StaticContainer.class.getDeclaredField(\"IMMUTABLE_PACKAGE\");\n         try {\n             FieldUtils.writeStaticField(field, \"new\", true);\n             fail(\"Expected IllegalAccessException\");\n-        } catch (IllegalAccessException e) {\n+        } catch (final IllegalAccessException e) {\n             // pass\n         }\n         field = StaticContainer.class.getDeclaredField(\"IMMUTABLE_PRIVATE\");\n         try {\n             FieldUtils.writeStaticField(field, \"new\", true);\n             fail(\"Expected IllegalAccessException\");\n-        } catch (IllegalAccessException e) {\n+        } catch (final IllegalAccessException e) {\n             // pass\n         }\n     }\n         try {\n             FieldUtils.writeStaticField(StaticContainerChild.class, \"mutableProtected\", \"new\");\n             fail(\"Expected IllegalArgumentException\");\n-        } catch (IllegalArgumentException e) {\n+        } catch (final IllegalArgumentException e) {\n             // pass\n         }\n         try {\n             FieldUtils.writeStaticField(StaticContainerChild.class, \"mutablePackage\", \"new\");\n             fail(\"Expected IllegalArgumentException\");\n-        } catch (IllegalArgumentException e) {\n+        } catch (final IllegalArgumentException e) {\n             // pass\n         }\n         try {\n             FieldUtils.writeStaticField(StaticContainerChild.class, \"mutablePrivate\", \"new\");\n             fail(\"Expected IllegalArgumentException\");\n-        } catch (IllegalArgumentException e) {\n+        } catch (final IllegalArgumentException e) {\n             // pass\n         }\n         try {\n             FieldUtils.writeStaticField(StaticContainerChild.class, \"IMMUTABLE_PUBLIC\", \"new\");\n             fail(\"Expected IllegalAccessException\");\n-        } catch (IllegalAccessException e) {\n+        } catch (final IllegalAccessException e) {\n             // pass\n         }\n         try {\n             FieldUtils.writeStaticField(StaticContainerChild.class, \"IMMUTABLE_PROTECTED\", \"new\");\n             fail(\"Expected IllegalArgumentException\");\n-        } catch (IllegalArgumentException e) {\n+        } catch (final IllegalArgumentException e) {\n             // pass\n         }\n         try {\n             FieldUtils.writeStaticField(StaticContainerChild.class, \"IMMUTABLE_PACKAGE\", \"new\");\n             fail(\"Expected IllegalArgumentException\");\n-        } catch (IllegalArgumentException e) {\n+        } catch (final IllegalArgumentException e) {\n             // pass\n         }\n         try {\n             FieldUtils.writeStaticField(StaticContainerChild.class, \"IMMUTABLE_PRIVATE\", \"new\");\n             fail(\"Expected IllegalArgumentException\");\n-        } catch (IllegalArgumentException e) {\n+        } catch (final IllegalArgumentException e) {\n             // pass\n         }\n     }\n         try {\n             FieldUtils.writeStaticField(StaticContainerChild.class, \"IMMUTABLE_PUBLIC\", \"new\", true);\n             fail(\"Expected IllegalAccessException\");\n-        } catch (IllegalAccessException e) {\n+        } catch (final IllegalAccessException e) {\n             // pass\n         }\n         try {\n             FieldUtils.writeStaticField(StaticContainerChild.class, \"IMMUTABLE_PROTECTED\", \"new\", true);\n             fail(\"Expected IllegalAccessException\");\n-        } catch (IllegalAccessException e) {\n+        } catch (final IllegalAccessException e) {\n             // pass\n         }\n         try {\n             FieldUtils.writeStaticField(StaticContainerChild.class, \"IMMUTABLE_PACKAGE\", \"new\", true);\n             fail(\"Expected IllegalAccessException\");\n-        } catch (IllegalAccessException e) {\n+        } catch (final IllegalAccessException e) {\n             // pass\n         }\n         try {\n             FieldUtils.writeStaticField(StaticContainerChild.class, \"IMMUTABLE_PRIVATE\", \"new\", true);\n             fail(\"Expected IllegalAccessException\");\n-        } catch (IllegalAccessException e) {\n+        } catch (final IllegalAccessException e) {\n             // pass\n         }\n     }\n         try {\n             FieldUtils.writeDeclaredStaticField(StaticContainer.class, \"mutableProtected\", \"new\");\n             fail(\"Expected IllegalArgumentException\");\n-        } catch (IllegalArgumentException e) {\n+        } catch (final IllegalArgumentException e) {\n             // pass\n         }\n         try {\n             FieldUtils.writeDeclaredStaticField(StaticContainer.class, \"mutablePackage\", \"new\");\n             fail(\"Expected IllegalArgumentException\");\n-        } catch (IllegalArgumentException e) {\n+        } catch (final IllegalArgumentException e) {\n             // pass\n         }\n         try {\n             FieldUtils.writeDeclaredStaticField(StaticContainer.class, \"mutablePrivate\", \"new\");\n             fail(\"Expected IllegalArgumentException\");\n-        } catch (IllegalArgumentException e) {\n+        } catch (final IllegalArgumentException e) {\n             // pass\n         }\n         try {\n             FieldUtils.writeDeclaredStaticField(StaticContainer.class, \"IMMUTABLE_PUBLIC\", \"new\");\n             fail(\"Expected IllegalAccessException\");\n-        } catch (IllegalAccessException e) {\n+        } catch (final IllegalAccessException e) {\n             // pass\n         }\n         try {\n             FieldUtils.writeDeclaredStaticField(StaticContainer.class, \"IMMUTABLE_PROTECTED\", \"new\");\n             fail(\"Expected IllegalArgumentException\");\n-        } catch (IllegalArgumentException e) {\n+        } catch (final IllegalArgumentException e) {\n             // pass\n         }\n         try {\n             FieldUtils.writeDeclaredStaticField(StaticContainer.class, \"IMMUTABLE_PACKAGE\", \"new\");\n             fail(\"Expected IllegalArgumentException\");\n-        } catch (IllegalArgumentException e) {\n+        } catch (final IllegalArgumentException e) {\n             // pass\n         }\n         try {\n             FieldUtils.writeDeclaredStaticField(StaticContainer.class, \"IMMUTABLE_PRIVATE\", \"new\");\n             fail(\"Expected IllegalArgumentException\");\n-        } catch (IllegalArgumentException e) {\n+        } catch (final IllegalArgumentException e) {\n             // pass\n         }\n     }\n         try {\n             FieldUtils.writeDeclaredStaticField(StaticContainer.class, \"IMMUTABLE_PUBLIC\", \"new\", true);\n             fail(\"Expected IllegalAccessException\");\n-        } catch (IllegalAccessException e) {\n+        } catch (final IllegalAccessException e) {\n             // pass\n         }\n         try {\n             FieldUtils.writeDeclaredStaticField(StaticContainer.class, \"IMMUTABLE_PROTECTED\", \"new\", true);\n             fail(\"Expected IllegalAccessException\");\n-        } catch (IllegalAccessException e) {\n+        } catch (final IllegalAccessException e) {\n             // pass\n         }\n         try {\n             FieldUtils.writeDeclaredStaticField(StaticContainer.class, \"IMMUTABLE_PACKAGE\", \"new\", true);\n             fail(\"Expected IllegalAccessException\");\n-        } catch (IllegalAccessException e) {\n+        } catch (final IllegalAccessException e) {\n             // pass\n         }\n         try {\n             FieldUtils.writeDeclaredStaticField(StaticContainer.class, \"IMMUTABLE_PRIVATE\", \"new\", true);\n             fail(\"Expected IllegalAccessException\");\n-        } catch (IllegalAccessException e) {\n+        } catch (final IllegalAccessException e) {\n             // pass\n         }\n     }\n         try {\n             FieldUtils.writeField(field, publicChild, Boolean.TRUE);\n             fail(\"Expected IllegalAccessException\");\n-        } catch (IllegalAccessException e) {\n+        } catch (final IllegalAccessException e) {\n             // pass\n         }\n         field = parentClass.getDeclaredField(\"i\");\n         try {\n             FieldUtils.writeField(field, publicChild, Integer.valueOf(Integer.MAX_VALUE));\n-        } catch (IllegalAccessException e) {\n+        } catch (final IllegalAccessException e) {\n             // pass\n         }\n         field = parentClass.getDeclaredField(\"d\");\n         try {\n             FieldUtils.writeField(field, publicChild, Double.valueOf(Double.MAX_VALUE));\n-        } catch (IllegalAccessException e) {\n+        } catch (final IllegalAccessException e) {\n             // pass\n         }\n     }\n         try {\n             FieldUtils.writeField(publicChild, \"b\", Boolean.TRUE);\n             fail(\"Expected IllegalArgumentException\");\n-        } catch (IllegalArgumentException e) {\n+        } catch (final IllegalArgumentException e) {\n             // pass\n         }\n         try {\n             FieldUtils.writeField(publicChild, \"i\", Integer.valueOf(1));\n             fail(\"Expected IllegalArgumentException\");\n-        } catch (IllegalArgumentException e) {\n+        } catch (final IllegalArgumentException e) {\n             // pass\n         }\n         try {\n             FieldUtils.writeField(publicChild, \"d\", Double.valueOf(1.0));\n             fail(\"Expected IllegalArgumentException\");\n-        } catch (IllegalArgumentException e) {\n+        } catch (final IllegalArgumentException e) {\n             // pass\n         }\n \n         try {\n             FieldUtils.writeField(privatelyShadowedChild, \"b\", Boolean.TRUE);\n             fail(\"Expected IllegalArgumentException\");\n-        } catch (IllegalArgumentException e) {\n+        } catch (final IllegalArgumentException e) {\n             // pass\n         }\n         try {\n             FieldUtils.writeField(privatelyShadowedChild, \"i\", Integer.valueOf(1));\n             fail(\"Expected IllegalArgumentException\");\n-        } catch (IllegalArgumentException e) {\n+        } catch (final IllegalArgumentException e) {\n             // pass\n         }\n         try {\n             FieldUtils.writeField(privatelyShadowedChild, \"d\", Double.valueOf(1.0));\n             fail(\"Expected IllegalArgumentException\");\n-        } catch (IllegalArgumentException e) {\n+        } catch (final IllegalArgumentException e) {\n             // pass\n         }\n     }\n         try {\n             FieldUtils.writeDeclaredField(publicChild, \"s\", \"S\");\n             fail(\"Expected IllegalArgumentException\");\n-        } catch (IllegalArgumentException e) {\n+        } catch (final IllegalArgumentException e) {\n             // pass\n         }\n         try {\n             FieldUtils.writeDeclaredField(publicChild, \"b\", Boolean.TRUE);\n             fail(\"Expected IllegalArgumentException\");\n-        } catch (IllegalArgumentException e) {\n+        } catch (final IllegalArgumentException e) {\n             // pass\n         }\n         try {\n             FieldUtils.writeDeclaredField(publicChild, \"i\", Integer.valueOf(1));\n             fail(\"Expected IllegalArgumentException\");\n-        } catch (IllegalArgumentException e) {\n+        } catch (final IllegalArgumentException e) {\n             // pass\n         }\n         try {\n             FieldUtils.writeDeclaredField(publicChild, \"d\", Double.valueOf(1.0));\n             fail(\"Expected IllegalArgumentException\");\n-        } catch (IllegalArgumentException e) {\n+        } catch (final IllegalArgumentException e) {\n             // pass\n         }\n \n         try {\n             FieldUtils.writeDeclaredField(privatelyShadowedChild, \"s\", \"S\");\n             fail(\"Expected IllegalArgumentException\");\n-        } catch (IllegalArgumentException e) {\n+        } catch (final IllegalArgumentException e) {\n             // pass\n         }\n         try {\n             FieldUtils.writeDeclaredField(privatelyShadowedChild, \"b\", Boolean.TRUE);\n             fail(\"Expected IllegalArgumentException\");\n-        } catch (IllegalArgumentException e) {\n+        } catch (final IllegalArgumentException e) {\n             // pass\n         }\n         try {\n             FieldUtils.writeDeclaredField(privatelyShadowedChild, \"i\", Integer.valueOf(1));\n             fail(\"Expected IllegalArgumentException\");\n-        } catch (IllegalArgumentException e) {\n+        } catch (final IllegalArgumentException e) {\n             // pass\n         }\n         try {\n             FieldUtils.writeDeclaredField(privatelyShadowedChild, \"d\", Double.valueOf(1.0));\n             fail(\"Expected IllegalArgumentException\");\n-        } catch (IllegalArgumentException e) {\n+        } catch (final IllegalArgumentException e) {\n             // pass\n         }\n     }\n         try {\n             FieldUtils.writeDeclaredField(publicChild, \"s\", \"S\", true);\n             fail(\"Expected IllegalArgumentException\");\n-        } catch (IllegalArgumentException e) {\n+        } catch (final IllegalArgumentException e) {\n             // pass\n         }\n         try {\n             FieldUtils.writeDeclaredField(publicChild, \"b\", Boolean.TRUE, true);\n             fail(\"Expected IllegalArgumentException\");\n-        } catch (IllegalArgumentException e) {\n+        } catch (final IllegalArgumentException e) {\n             // pass\n         }\n         try {\n             FieldUtils.writeDeclaredField(publicChild, \"i\", Integer.valueOf(1), true);\n             fail(\"Expected IllegalArgumentException\");\n-        } catch (IllegalArgumentException e) {\n+        } catch (final IllegalArgumentException e) {\n             // pass\n         }\n         try {\n             FieldUtils.writeDeclaredField(publicChild, \"d\", Double.valueOf(1.0), true);\n             fail(\"Expected IllegalArgumentException\");\n-        } catch (IllegalArgumentException e) {\n+        } catch (final IllegalArgumentException e) {\n             // pass\n         }\n \n--- a/src/test/java/org/apache/commons/lang3/reflect/MethodUtilsTest.java\n+++ b/src/test/java/org/apache/commons/lang3/reflect/MethodUtilsTest.java\n             MethodUtils\n                     .invokeExactMethod(testBean, \"foo\", NumberUtils.BYTE_ONE);\n             fail(\"should throw NoSuchMethodException\");\n-        } catch (NoSuchMethodException e) {\n+        } catch (final NoSuchMethodException e) {\n         }\n         try {\n             MethodUtils\n                     .invokeExactMethod(testBean, \"foo\", NumberUtils.LONG_ONE);\n             fail(\"should throw NoSuchMethodException\");\n-        } catch (NoSuchMethodException e) {\n+        } catch (final NoSuchMethodException e) {\n         }\n         try {\n             MethodUtils.invokeExactMethod(testBean, \"foo\", Boolean.TRUE);\n             fail(\"should throw NoSuchMethodException\");\n-        } catch (NoSuchMethodException e) {\n+        } catch (final NoSuchMethodException e) {\n         }\n     }\n \n         try {\n             MethodUtils.invokeStaticMethod(TestBean.class, \"does_not_exist\");\n             fail(\"should throw NoSuchMethodException\");\n-        } catch (NoSuchMethodException e) {\n+        } catch (final NoSuchMethodException e) {\n         }\n     }\n \n             MethodUtils.invokeExactStaticMethod(TestBean.class, \"bar\",\n                     NumberUtils.BYTE_ONE);\n             fail(\"should throw NoSuchMethodException\");\n-        } catch (NoSuchMethodException e) {\n+        } catch (final NoSuchMethodException e) {\n         }\n         try {\n             MethodUtils.invokeExactStaticMethod(TestBean.class, \"bar\",\n                     NumberUtils.LONG_ONE);\n             fail(\"should throw NoSuchMethodException\");\n-        } catch (NoSuchMethodException e) {\n+        } catch (final NoSuchMethodException e) {\n         }\n         try {\n             MethodUtils.invokeExactStaticMethod(TestBean.class, \"bar\",\n                     Boolean.TRUE);\n             fail(\"should throw NoSuchMethodException\");\n-        } catch (NoSuchMethodException e) {\n+        } catch (final NoSuchMethodException e) {\n         }\n     }\n \n     @Test\n     public void testGetAccessibleInterfaceMethod() throws Exception {\n-        Class<?>[][] p = { ArrayUtils.EMPTY_CLASS_ARRAY, null };\n-        for (Class<?>[] element : p) {\n-            Method method = TestMutable.class.getMethod(\"getValue\", element);\n-            Method accessibleMethod = MethodUtils.getAccessibleMethod(method);\n+        final Class<?>[][] p = { ArrayUtils.EMPTY_CLASS_ARRAY, null };\n+        for (final Class<?>[] element : p) {\n+            final Method method = TestMutable.class.getMethod(\"getValue\", element);\n+            final Method accessibleMethod = MethodUtils.getAccessibleMethod(method);\n             assertNotSame(accessibleMethod, method);\n             assertSame(Mutable.class, accessibleMethod.getDeclaringClass());\n         }\n     \n     @Test\n     public void testGetAccessibleMethodPrivateInterface() throws Exception {\n-        Method expected = TestBeanWithInterfaces.class.getMethod(\"foo\");\n+        final Method expected = TestBeanWithInterfaces.class.getMethod(\"foo\");\n         assertNotNull(expected);\n-        Method actual = MethodUtils.getAccessibleMethod(TestBeanWithInterfaces.class, \"foo\");\n+        final Method actual = MethodUtils.getAccessibleMethod(TestBeanWithInterfaces.class, \"foo\");\n         assertNull(actual);\n     }\n \n     @Test\n     public void testGetAccessibleInterfaceMethodFromDescription()\n             throws Exception {\n-        Class<?>[][] p = { ArrayUtils.EMPTY_CLASS_ARRAY, null };\n-        for (Class<?>[] element : p) {\n-            Method accessibleMethod = MethodUtils.getAccessibleMethod(\n+        final Class<?>[][] p = { ArrayUtils.EMPTY_CLASS_ARRAY, null };\n+        for (final Class<?>[] element : p) {\n+            final Method accessibleMethod = MethodUtils.getAccessibleMethod(\n                     TestMutable.class, \"getValue\", element);\n             assertSame(Mutable.class, accessibleMethod.getDeclaringClass());\n         }\n     \n     @Test\n    public void testGetAccessibleMethodInaccessible() throws Exception {\n-        Method expected = TestBean.class.getDeclaredMethod(\"privateStuff\");\n-        Method actual = MethodUtils.getAccessibleMethod(expected);\n+        final Method expected = TestBean.class.getDeclaredMethod(\"privateStuff\");\n+        final Method actual = MethodUtils.getAccessibleMethod(expected);\n         assertNull(actual);\n     }\n \n \n     private void expectMatchingAccessibleMethodParameterTypes(final Class<?> cls,\n             final String methodName, final Class<?>[] requestTypes, final Class<?>[] actualTypes) {\n-        Method m = MethodUtils.getMatchingAccessibleMethod(cls, methodName,\n+        final Method m = MethodUtils.getMatchingAccessibleMethod(cls, methodName,\n                 requestTypes);\n         assertTrue(toString(m.getParameterTypes()) + \" not equals \"\n                 + toString(actualTypes), Arrays.equals(actualTypes, m\n--- a/src/test/java/org/apache/commons/lang3/reflect/TypeUtilsTest.java\n+++ b/src/test/java/org/apache/commons/lang3/reflect/TypeUtilsTest.java\n         List<String>[] list11 = null;\n         List<? extends String>[] list12 = null;\n         List<? super String>[] list13;\n-        Class<?> clazz = getClass();\n-        Method method = clazz.getMethod(\"dummyMethod\", List.class, List.class, List.class,\n+        final Class<?> clazz = getClass();\n+        final Method method = clazz.getMethod(\"dummyMethod\", List.class, List.class, List.class,\n                 List.class, List.class, List.class, List.class, List[].class, List[].class,\n                 List[].class, List[].class, List[].class, List[].class, List[].class);\n-        Type[] types = method.getGenericParameterTypes();\n+        final Type[] types = method.getGenericParameterTypes();\n //        list0 = list0;\n         delegateBooleanAssertion(types, 0, 0, true);\n         list1 = list0;\n         delegateBooleanAssertion(types, 13, 12, false);\n //        list13 = list13;\n         delegateBooleanAssertion(types, 13, 13, true);\n-        Type disType = getClass().getField(\"dis\").getGenericType();\n+        final Type disType = getClass().getField(\"dis\").getGenericType();\n         // Reporter.log( ( ( ParameterizedType ) disType\n         // ).getOwnerType().getClass().toString() );\n-        Type datType = getClass().getField(\"dat\").getGenericType();\n-        Type daType = getClass().getField(\"da\").getGenericType();\n-        Type uhderType = getClass().getField(\"uhder\").getGenericType();\n-        Type dingType = getClass().getField(\"ding\").getGenericType();\n-        Type testerType = getClass().getField(\"tester\").getGenericType();\n-        Type tester2Type = getClass().getField(\"tester2\").getGenericType();\n-        Type dat2Type = getClass().getField(\"dat2\").getGenericType();\n-        Type dat3Type = getClass().getField(\"dat3\").getGenericType();\n+        final Type datType = getClass().getField(\"dat\").getGenericType();\n+        final Type daType = getClass().getField(\"da\").getGenericType();\n+        final Type uhderType = getClass().getField(\"uhder\").getGenericType();\n+        final Type dingType = getClass().getField(\"ding\").getGenericType();\n+        final Type testerType = getClass().getField(\"tester\").getGenericType();\n+        final Type tester2Type = getClass().getField(\"tester2\").getGenericType();\n+        final Type dat2Type = getClass().getField(\"dat2\").getGenericType();\n+        final Type dat3Type = getClass().getField(\"dat3\").getGenericType();\n         dis = dat;\n         Assert.assertTrue(TypeUtils.isAssignable(datType, disType));\n         // dis = da;\n         Assert.assertFalse(TypeUtils.isAssignable(datType, dat2Type));\n         // dat = dat3;\n         Assert.assertFalse(TypeUtils.isAssignable(dat3Type, datType));\n-        char ch = 0;\n-        boolean bo = false;\n-        byte by = 0;\n-        short sh = 0;\n+        final char ch = 0;\n+        final boolean bo = false;\n+        final byte by = 0;\n+        final short sh = 0;\n         int in = 0;\n         long lo = 0;\n-        float fl = 0;\n+        final float fl = 0;\n         double du = 0;\n         du = ch;\n         Assert.assertTrue(TypeUtils.isAssignable(char.class, double.class));\n         Assert.assertFalse(TypeUtils.isAssignable(Integer.class, Long.class));\n         in = Integer.valueOf(0);\n         Assert.assertTrue(TypeUtils.isAssignable(Integer.class, int.class));\n-        Integer inte = in;\n+        final Integer inte = in;\n         Assert.assertTrue(TypeUtils.isAssignable(int.class, Integer.class));\n         Assert.assertTrue(TypeUtils.isAssignable(int.class, Number.class));\n         Assert.assertTrue(TypeUtils.isAssignable(int.class, Object.class));\n-        Type intComparableType = getClass().getField(\"intComparable\").getGenericType();\n+        final Type intComparableType = getClass().getField(\"intComparable\").getGenericType();\n         intComparable = 1;\n         Assert.assertTrue(TypeUtils.isAssignable(int.class, intComparableType));\n         Assert.assertTrue(TypeUtils.isAssignable(int.class, Comparable.class));\n-        Serializable ser = 1;\n+        final Serializable ser = 1;\n         Assert.assertTrue(TypeUtils.isAssignable(int.class, Serializable.class));\n-        Type longComparableType = getClass().getField(\"longComparable\").getGenericType();\n+        final Type longComparableType = getClass().getField(\"longComparable\").getGenericType();\n         // longComparable = 1;\n         Assert.assertFalse(TypeUtils.isAssignable(int.class, longComparableType));\n         // longComparable = Integer.valueOf( 0 );\n         // int[] ia;\n         // long[] la = ia;\n         Assert.assertFalse(TypeUtils.isAssignable(int[].class, long[].class));\n-        Integer[] ia = null;\n-        Type caType = getClass().getField(\"intWildcardComparable\").getGenericType();\n+        final Integer[] ia = null;\n+        final Type caType = getClass().getField(\"intWildcardComparable\").getGenericType();\n         intWildcardComparable = ia;\n         Assert.assertTrue(TypeUtils.isAssignable(Integer[].class, caType));\n         // int[] ina = ia;\n         Assert.assertFalse(TypeUtils.isAssignable(Integer[].class, int[].class));\n-        int[] ina = null;\n+        final int[] ina = null;\n         Object[] oa;\n         // oa = ina;\n         Assert.assertFalse(TypeUtils.isAssignable(int[].class, Object[].class));\n         oa = new Integer[0];\n         Assert.assertTrue(TypeUtils.isAssignable(Integer[].class, Object[].class));\n-        Type bClassType = AClass.class.getField(\"bClass\").getGenericType();\n-        Type cClassType = AClass.class.getField(\"cClass\").getGenericType();\n-        Type dClassType = AClass.class.getField(\"dClass\").getGenericType();\n-        Type eClassType = AClass.class.getField(\"eClass\").getGenericType();\n-        Type fClassType = AClass.class.getField(\"fClass\").getGenericType();\n-        AClass aClass = new AClass(new AAClass<String>());\n+        final Type bClassType = AClass.class.getField(\"bClass\").getGenericType();\n+        final Type cClassType = AClass.class.getField(\"cClass\").getGenericType();\n+        final Type dClassType = AClass.class.getField(\"dClass\").getGenericType();\n+        final Type eClassType = AClass.class.getField(\"eClass\").getGenericType();\n+        final Type fClassType = AClass.class.getField(\"fClass\").getGenericType();\n+        final AClass aClass = new AClass(new AAClass<String>());\n         aClass.bClass = aClass.cClass;\n         Assert.assertTrue(TypeUtils.isAssignable(cClassType, bClassType));\n         aClass.bClass = aClass.dClass;\n     }\n \n     public void delegateBooleanAssertion(final Type[] types, final int i2, final int i1, final boolean expected) {\n-        Type type1 = types[i1];\n-        Type type2 = types[i2];\n-        boolean isAssignable = TypeUtils.isAssignable(type2, type1);\n+        final Type type1 = types[i1];\n+        final Type type2 = types[i2];\n+        final boolean isAssignable = TypeUtils.isAssignable(type2, type1);\n \n         if (expected) {\n             Assert.assertTrue(\"[\" + i1 + \", \" + i2 + \"]: From \"\n     @SuppressWarnings(\"boxing\") // boxing is deliberate here\n     @Test\n     public void testIsInstance() throws SecurityException, NoSuchFieldException {\n-        Type intComparableType = getClass().getField(\"intComparable\").getGenericType();\n-        Type uriComparableType = getClass().getField(\"uriComparable\").getGenericType();\n+        final Type intComparableType = getClass().getField(\"intComparable\").getGenericType();\n+        final Type uriComparableType = getClass().getField(\"uriComparable\").getGenericType();\n         intComparable = 1;\n         Assert.assertTrue(TypeUtils.isInstance(1, intComparableType));\n         // uriComparable = 1;\n         Assert.assertEquals(\"Type argument of Comparable from int: \" + typeArg, Integer.class,\n                 typeVarAssigns.get(treeSetTypeVar));\n \n-        Collection<Integer> col = Arrays.asList(new Integer[0]);\n+        final Collection<Integer> col = Arrays.asList(new Integer[0]);\n         typeVarAssigns = TypeUtils.getTypeArguments(List.class, Collection.class);\n         treeSetTypeVar = Comparable.class.getTypeParameters()[0];\n         Assert.assertFalse(\"Type var assigns for Collection from List: \" + typeVarAssigns,\n     @Test\n     public void testTypesSatisfyVariables() throws SecurityException, NoSuchFieldException,\n             NoSuchMethodException {\n-        Map<TypeVariable<?>, Type> typeVarAssigns = new HashMap<TypeVariable<?>, Type>();\n-        Integer max = TypeUtilsTest.stub();\n+        final Map<TypeVariable<?>, Type> typeVarAssigns = new HashMap<TypeVariable<?>, Type>();\n+        final Integer max = TypeUtilsTest.stub();\n         typeVarAssigns.put(getClass().getMethod(\"stub\").getTypeParameters()[0], Integer.class);\n         Assert.assertTrue(TypeUtils.typesSatisfyVariables(typeVarAssigns));\n         typeVarAssigns.clear();\n     @Test\n     public void testDetermineTypeVariableAssignments() throws SecurityException,\n             NoSuchFieldException, NoSuchMethodException {\n-        ParameterizedType iterableType = (ParameterizedType) getClass().getField(\"iterable\")\n+        final ParameterizedType iterableType = (ParameterizedType) getClass().getField(\"iterable\")\n                 .getGenericType();\n-        Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.determineTypeArguments(TreeSet.class,\n+        final Map<TypeVariable<?>, Type> typeVarAssigns = TypeUtils.determineTypeArguments(TreeSet.class,\n                 iterableType);\n-        TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0];\n+        final TypeVariable<?> treeSetTypeVar = TreeSet.class.getTypeParameters()[0];\n         Assert.assertTrue(typeVarAssigns.containsKey(treeSetTypeVar));\n         Assert.assertEquals(iterableType.getActualTypeArguments()[0], typeVarAssigns\n                 .get(treeSetTypeVar));\n \n     @Test\n     public void testGetRawType() throws SecurityException, NoSuchFieldException {\n-        Type stringParentFieldType = GenericTypeHolder.class.getDeclaredField(\"stringParent\")\n+        final Type stringParentFieldType = GenericTypeHolder.class.getDeclaredField(\"stringParent\")\n                 .getGenericType();\n-        Type integerParentFieldType = GenericTypeHolder.class.getDeclaredField(\"integerParent\")\n+        final Type integerParentFieldType = GenericTypeHolder.class.getDeclaredField(\"integerParent\")\n                 .getGenericType();\n-        Type foosFieldType = GenericTypeHolder.class.getDeclaredField(\"foos\").getGenericType();\n-        Type genericParentT = GenericParent.class.getTypeParameters()[0];\n+        final Type foosFieldType = GenericTypeHolder.class.getDeclaredField(\"foos\").getGenericType();\n+        final Type genericParentT = GenericParent.class.getTypeParameters()[0];\n         Assert.assertEquals(GenericParent.class, TypeUtils.getRawType(stringParentFieldType, null));\n         Assert\n                 .assertEquals(GenericParent.class, TypeUtils.getRawType(integerParentFieldType,\n \n     @Test\n     public void testIsArrayGenericTypes() throws Exception {\n-        Method method = getClass().getMethod(\"dummyMethod\", List.class, List.class, List.class,\n+        final Method method = getClass().getMethod(\"dummyMethod\", List.class, List.class, List.class,\n                 List.class, List.class, List.class, List.class, List[].class, List[].class,\n                 List[].class, List[].class, List[].class, List[].class, List[].class);\n \n-        Type[] types = method.getGenericParameterTypes();\n+        final Type[] types = method.getGenericParameterTypes();\n \n         Assert.assertFalse(TypeUtils.isArrayType(types[0]));\n         Assert.assertFalse(TypeUtils.isArrayType(types[1]));\n \n     @Test\n     public void testGetArrayComponentType() throws Exception {\n-        Method method = getClass().getMethod(\"dummyMethod\", List.class, List.class, List.class,\n+        final Method method = getClass().getMethod(\"dummyMethod\", List.class, List.class, List.class,\n                 List.class, List.class, List.class, List.class, List[].class, List[].class,\n                 List[].class, List[].class, List[].class, List[].class, List[].class);\n \n-        Type[] types = method.getGenericParameterTypes();\n+        final Type[] types = method.getGenericParameterTypes();\n \n         Assert.assertNull(TypeUtils.getArrayComponentType(types[0]));\n         Assert.assertNull(TypeUtils.getArrayComponentType(types[1]));\n \n     @Test\n     public void testLang820() throws Exception {\n-        Type[] typeArray = {String.class, String.class};\n-        Type[] expectedArray = {String.class};\n+        final Type[] typeArray = {String.class, String.class};\n+        final Type[] expectedArray = {String.class};\n         Assert.assertArrayEquals(expectedArray, TypeUtils.normalizeUpperBounds(typeArray));\n     }\n \n--- a/src/test/java/org/apache/commons/lang3/text/CompositeFormatTest.java\n+++ b/src/test/java/org/apache/commons/lang3/text/CompositeFormatTest.java\n     @Test\n     public void testCompositeFormat() {\n \n-        Format parser = new Format() {\n+        final Format parser = new Format() {\n             @Override\n             public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos) {\n                 throw new UnsupportedOperationException(\"Not implemented\");\n             }\n         };\n \n-        Format formatter = new Format() {\n+        final Format formatter = new Format() {\n             @Override\n             public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos) {\n                 return null;    // do nothing\n             }\n         };\n \n-        CompositeFormat composite = new CompositeFormat(parser, formatter);\n+        final CompositeFormat composite = new CompositeFormat(parser, formatter);\n \n         composite.parseObject(\"\", null);\n         composite.format(new Object(), new StringBuffer(), null);\n \n     @Test\n     public void testUsage() throws Exception {\n-        Format f1 = new SimpleDateFormat(\"MMddyyyy\", Locale.ENGLISH);\n-        Format f2 = new SimpleDateFormat(\"MMMM d, yyyy\", Locale.ENGLISH);\n-        CompositeFormat c = new CompositeFormat(f1, f2);\n-        String testString = \"January 3, 2005\";\n+        final Format f1 = new SimpleDateFormat(\"MMddyyyy\", Locale.ENGLISH);\n+        final Format f2 = new SimpleDateFormat(\"MMMM d, yyyy\", Locale.ENGLISH);\n+        final CompositeFormat c = new CompositeFormat(f1, f2);\n+        final String testString = \"January 3, 2005\";\n         assertEquals(testString, c.format(c.parseObject(\"01032005\")));\n         assertEquals(testString, c.reformat(\"01032005\"));\n     }\n--- a/src/test/java/org/apache/commons/lang3/text/ExtendedMessageFormatTest.java\n+++ b/src/test/java/org/apache/commons/lang3/text/ExtendedMessageFormatTest.java\n      */\n     @Test\n     public void testExtendedFormats() {\n-        String pattern = \"Lower: {0,lower} Upper: {1,upper}\";\n-        ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry);\n+        final String pattern = \"Lower: {0,lower} Upper: {1,upper}\";\n+        final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry);\n         assertPatternsEqual(\"TOPATTERN\", pattern, emf.toPattern());\n         assertEquals(\"Lower: foo Upper: BAR\", emf.format(new Object[] {\"foo\", \"bar\"}));\n         assertEquals(\"Lower: foo Upper: BAR\", emf.format(new Object[] {\"Foo\", \"Bar\"}));\n      */\n     @Test\n     public void testEscapedQuote_LANG_477() {\n-        String pattern = \"it''s a {0,lower} 'test'!\";\n-        ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry);\n+        final String pattern = \"it''s a {0,lower} 'test'!\";\n+        final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry);\n         assertEquals(\"it's a dummy test!\", emf.format(new Object[] {\"DUMMY\"}));\n     }\n \n      */\n     @Test\n     public void testExtendedAndBuiltInFormats() {\n-        Calendar cal = Calendar.getInstance();\n+        final Calendar cal = Calendar.getInstance();\n         cal.set(2007, Calendar.JANUARY, 23, 18, 33, 05);\n-        Object[] args = new Object[] {\"John Doe\", cal.getTime(), Double.valueOf(\"12345.67\")};\n-        String builtinsPattern = \"DOB: {1,date,short} Salary: {2,number,currency}\";\n-        String extendedPattern = \"Name: {0,upper} \";\n-        String pattern = extendedPattern + builtinsPattern;\n-\n-        HashSet<Locale> testLocales = new HashSet<Locale>();\n+        final Object[] args = new Object[] {\"John Doe\", cal.getTime(), Double.valueOf(\"12345.67\")};\n+        final String builtinsPattern = \"DOB: {1,date,short} Salary: {2,number,currency}\";\n+        final String extendedPattern = \"Name: {0,upper} \";\n+        final String pattern = extendedPattern + builtinsPattern;\n+\n+        final HashSet<Locale> testLocales = new HashSet<Locale>();\n         testLocales.addAll(Arrays.asList(DateFormat.getAvailableLocales()));\n         testLocales.retainAll(Arrays.asList(NumberFormat.getAvailableLocales()));\n         testLocales.add(null);\n \n-        for (Locale locale : testLocales) {\n-            MessageFormat builtins = createMessageFormat(builtinsPattern, locale);\n-            String expectedPattern = extendedPattern + builtins.toPattern();\n+        for (final Locale locale : testLocales) {\n+            final MessageFormat builtins = createMessageFormat(builtinsPattern, locale);\n+            final String expectedPattern = extendedPattern + builtins.toPattern();\n             DateFormat df = null;\n             NumberFormat nf = null;\n             ExtendedMessageFormat emf = null;\n                 nf = NumberFormat.getCurrencyInstance(locale);\n                 emf = new ExtendedMessageFormat(pattern, locale, registry);\n             }\n-            StringBuilder expected = new StringBuilder();\n+            final StringBuilder expected = new StringBuilder();\n             expected.append(\"Name: \");\n             expected.append(args[0].toString().toUpperCase());\n             expected.append(\" DOB: \");\n      */\n     @Test\n     public void testBuiltInChoiceFormat() {\n-        Object[] values = new Number[] {Integer.valueOf(1), Double.valueOf(\"2.2\"), Double.valueOf(\"1234.5\")};\n+        final Object[] values = new Number[] {Integer.valueOf(1), Double.valueOf(\"2.2\"), Double.valueOf(\"1234.5\")};\n         String choicePattern = null;\n-        Locale[] availableLocales = ChoiceFormat.getAvailableLocales();\n+        final Locale[] availableLocales = ChoiceFormat.getAvailableLocales();\n \n         choicePattern = \"{0,choice,1#One|2#Two|3#Many {0,number}}\";\n-        for (Object value : values) {\n+        for (final Object value : values) {\n             checkBuiltInFormat(value + \": \" + choicePattern, new Object[] {value}, availableLocales);\n         }\n \n         choicePattern = \"{0,choice,1#''One''|2#\\\"Two\\\"|3#''{Many}'' {0,number}}\";\n-        for (Object value : values) {\n+        for (final Object value : values) {\n             checkBuiltInFormat(value + \": \" + choicePattern, new Object[] {value}, availableLocales);\n         }\n     }\n      */\n     @Test\n     public void testBuiltInDateTimeFormat() {\n-        Calendar cal = Calendar.getInstance();\n+        final Calendar cal = Calendar.getInstance();\n         cal.set(2007, Calendar.JANUARY, 23, 18, 33, 05);\n-        Object[] args = new Object[] {cal.getTime()};\n-        Locale[] availableLocales = DateFormat.getAvailableLocales();\n+        final Object[] args = new Object[] {cal.getTime()};\n+        final Locale[] availableLocales = DateFormat.getAvailableLocales();\n \n         checkBuiltInFormat(\"1: {0,date,short}\",    args, availableLocales);\n         checkBuiltInFormat(\"2: {0,date,medium}\",   args, availableLocales);\n \n     @Test\n     public void testOverriddenBuiltinFormat() {\n-        Calendar cal = Calendar.getInstance();\n+        final Calendar cal = Calendar.getInstance();\n         cal.set(2007, Calendar.JANUARY, 23);\n-        Object[] args = new Object[] {cal.getTime()};\n-        Locale[] availableLocales = DateFormat.getAvailableLocales();\n-        Map<String, ? extends FormatFactory> registry = Collections.singletonMap(\"date\", new OverrideShortDateFormatFactory());\n+        final Object[] args = new Object[] {cal.getTime()};\n+        final Locale[] availableLocales = DateFormat.getAvailableLocales();\n+        final Map<String, ? extends FormatFactory> registry = Collections.singletonMap(\"date\", new OverrideShortDateFormatFactory());\n \n         //check the non-overridden builtins:\n         checkBuiltInFormat(\"1: {0,date}\", registry,          args, availableLocales);\n \n         //check the overridden format:\n         for (int i = -1; i < availableLocales.length; i++) {\n-            Locale locale = i < 0 ? null : availableLocales[i];\n-            MessageFormat dateDefault = createMessageFormat(\"{0,date}\", locale);\n-            String pattern = \"{0,date,short}\";\n-            ExtendedMessageFormat dateShort = new ExtendedMessageFormat(pattern, locale, registry);\n+            final Locale locale = i < 0 ? null : availableLocales[i];\n+            final MessageFormat dateDefault = createMessageFormat(\"{0,date}\", locale);\n+            final String pattern = \"{0,date,short}\";\n+            final ExtendedMessageFormat dateShort = new ExtendedMessageFormat(pattern, locale, registry);\n             assertEquals(\"overridden date,short format\", dateDefault.format(args), dateShort.format(args));\n             assertEquals(\"overridden date,short pattern\", pattern, dateShort.toPattern());\n         }\n      */\n     @Test\n     public void testBuiltInNumberFormat() {\n-        Object[] args = new Object[] {Double.valueOf(\"6543.21\")};\n-        Locale[] availableLocales = NumberFormat.getAvailableLocales();\n+        final Object[] args = new Object[] {Double.valueOf(\"6543.21\")};\n+        final Locale[] availableLocales = NumberFormat.getAvailableLocales();\n         checkBuiltInFormat(\"1: {0,number}\",            args, availableLocales);\n         checkBuiltInFormat(\"2: {0,number,integer}\",    args, availableLocales);\n         checkBuiltInFormat(\"3: {0,number,currency}\",   args, availableLocales);\n      */\n     @Test\n     public void testEqualsHashcode() {\n-        Map<String, ? extends FormatFactory> registry = Collections.singletonMap(\"testfmt\", new LowerCaseFormatFactory());\n-        Map<String, ? extends FormatFactory> otherRegitry = Collections.singletonMap(\"testfmt\", new UpperCaseFormatFactory());\n-\n-        String pattern = \"Pattern: {0,testfmt}\";\n-        ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, Locale.US, registry);\n+        final Map<String, ? extends FormatFactory> registry = Collections.singletonMap(\"testfmt\", new LowerCaseFormatFactory());\n+        final Map<String, ? extends FormatFactory> otherRegitry = Collections.singletonMap(\"testfmt\", new UpperCaseFormatFactory());\n+\n+        final String pattern = \"Pattern: {0,testfmt}\";\n+        final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, Locale.US, registry);\n \n         ExtendedMessageFormat other = null;\n \n      */\n     private void checkBuiltInFormat(final String pattern, final Map<String, ?> registry, final Object[] args, final Locale[] locales) {\n         checkBuiltInFormat(pattern, registry, args, (Locale) null);\n-        for (Locale locale : locales) {\n+        for (final Locale locale : locales) {\n             checkBuiltInFormat(pattern, registry, args, locale);\n         }\n     }\n      * @param locale Locale\n      */\n     private void checkBuiltInFormat(final String pattern, final Map<String, ?> registry, final Object[] args, final Locale locale) {\n-        StringBuilder buffer = new StringBuilder();\n+        final StringBuilder buffer = new StringBuilder();\n         buffer.append(\"Pattern=[\");\n         buffer.append(pattern);\n         buffer.append(\"], locale=[\");\n         buffer.append(locale);\n         buffer.append(\"]\");\n-        MessageFormat mf = createMessageFormat(pattern, locale);\n+        final MessageFormat mf = createMessageFormat(pattern, locale);\n         // System.out.println(buffer + \", result=[\" + mf.format(args) +\"]\");\n         ExtendedMessageFormat emf = null;\n         if (locale == null) {\n      * @return MessageFormat\n      */\n     private MessageFormat createMessageFormat(final String pattern, final Locale locale) {\n-        MessageFormat result = new MessageFormat(pattern);\n+        final MessageFormat result = new MessageFormat(pattern);\n         if (locale != null) {\n             result.setLocale(locale);\n             result.applyPattern(pattern);\n--- a/src/test/java/org/apache/commons/lang3/text/FormattableUtilsTest.java\n+++ b/src/test/java/org/apache/commons/lang3/text/FormattableUtilsTest.java\n \n     @Test\n     public void testAlternatePadCharacter() {\n-        char pad='_';\n+        final char pad='_';\n         assertEquals(\"foo\", FormattableUtils.append(\"foo\", new Formatter(), 0, -1, -1, pad).toString());\n         assertEquals(\"fo\", FormattableUtils.append(\"foo\", new Formatter(), 0, -1, 2, pad).toString());\n         assertEquals(\"_foo\", FormattableUtils.append(\"foo\", new Formatter(), 0, 4, -1, pad).toString());\n--- a/src/test/java/org/apache/commons/lang3/text/StrBuilderAppendInsertTest.java\n+++ b/src/test/java/org/apache/commons/lang3/text/StrBuilderAppendInsertTest.java\n     //-----------------------------------------------------------------------\n     @Test\n     public void testAppendWithNullText() {\n-        StrBuilder sb = new StrBuilder();\n+        final StrBuilder sb = new StrBuilder();\n         sb.setNullText(\"NULL\");\n         assertEquals(\"\", sb.toString());\n \n     //-----------------------------------------------------------------------\n     @Test\n     public void testAppend_Object() {\n-        StrBuilder sb = new StrBuilder();\n+        final StrBuilder sb = new StrBuilder();\n         sb.appendNull();\n         assertEquals(\"\", sb.toString());\n \n         try {\n             sb.append(\"bar\", -1, 1);\n             fail(\"append(char[], -1,) expected IndexOutOfBoundsException\");\n-        } catch (IndexOutOfBoundsException e) {\n+        } catch (final IndexOutOfBoundsException e) {\n             // expected\n         }\n \n         try {\n             sb.append(\"bar\", 3, 1);\n             fail(\"append(char[], 3,) expected IndexOutOfBoundsException\");\n-        } catch (IndexOutOfBoundsException e) {\n+        } catch (final IndexOutOfBoundsException e) {\n             // expected\n         }\n \n         try {\n             sb.append(\"bar\", 1, -1);\n             fail(\"append(char[],, -1) expected IndexOutOfBoundsException\");\n-        } catch (IndexOutOfBoundsException e) {\n+        } catch (final IndexOutOfBoundsException e) {\n             // expected\n         }\n \n         try {\n             sb.append(\"bar\", 1, 3);\n             fail(\"append(char[], 1, 3) expected IndexOutOfBoundsException\");\n-        } catch (IndexOutOfBoundsException e) {\n+        } catch (final IndexOutOfBoundsException e) {\n             // expected\n         }\n \n         try {\n             sb.append(\"bar\", -1, 3);\n             fail(\"append(char[], -1, 3) expected IndexOutOfBoundsException\");\n-        } catch (IndexOutOfBoundsException e) {\n+        } catch (final IndexOutOfBoundsException e) {\n             // expected\n         }\n \n         try {\n             sb.append(\"bar\", 4, 0);\n             fail(\"append(char[], 4, 0) expected IndexOutOfBoundsException\");\n-        } catch (IndexOutOfBoundsException e) {\n+        } catch (final IndexOutOfBoundsException e) {\n             // expected\n         }\n \n         try {\n             sb.append(new StringBuilder(\"bar\"), -1, 1);\n             fail(\"append(StringBuilder, -1,) expected IndexOutOfBoundsException\");\n-        } catch (IndexOutOfBoundsException e) {\n+        } catch (final IndexOutOfBoundsException e) {\n             // expected\n         }\n \n         try {\n             sb.append(new StringBuilder(\"bar\"), 3, 1);\n             fail(\"append(StringBuilder, 3,) expected IndexOutOfBoundsException\");\n-        } catch (IndexOutOfBoundsException e) {\n+        } catch (final IndexOutOfBoundsException e) {\n             // expected\n         }\n \n         try {\n             sb.append(new StringBuilder(\"bar\"), 1, -1);\n             fail(\"append(StringBuilder,, -1) expected IndexOutOfBoundsException\");\n-        } catch (IndexOutOfBoundsException e) {\n+        } catch (final IndexOutOfBoundsException e) {\n             // expected\n         }\n \n         try {\n             sb.append(new StringBuilder(\"bar\"), 1, 3);\n             fail(\"append(StringBuilder, 1, 3) expected IndexOutOfBoundsException\");\n-        } catch (IndexOutOfBoundsException e) {\n+        } catch (final IndexOutOfBoundsException e) {\n             // expected\n         }\n \n         try {\n             sb.append(new StringBuilder(\"bar\"), -1, 3);\n             fail(\"append(StringBuilder, -1, 3) expected IndexOutOfBoundsException\");\n-        } catch (IndexOutOfBoundsException e) {\n+        } catch (final IndexOutOfBoundsException e) {\n             // expected\n         }\n \n         try {\n             sb.append(new StringBuilder(\"bar\"), 4, 0);\n             fail(\"append(StringBuilder, 4, 0) expected IndexOutOfBoundsException\");\n-        } catch (IndexOutOfBoundsException e) {\n+        } catch (final IndexOutOfBoundsException e) {\n             // expected\n         }\n \n         try {\n             sb.append(new StringBuffer(\"bar\"), -1, 1);\n             fail(\"append(char[], -1,) expected IndexOutOfBoundsException\");\n-        } catch (IndexOutOfBoundsException e) {\n+        } catch (final IndexOutOfBoundsException e) {\n             // expected\n         }\n \n         try {\n             sb.append(new StringBuffer(\"bar\"), 3, 1);\n             fail(\"append(char[], 3,) expected IndexOutOfBoundsException\");\n-        } catch (IndexOutOfBoundsException e) {\n+        } catch (final IndexOutOfBoundsException e) {\n             // expected\n         }\n \n         try {\n             sb.append(new StringBuffer(\"bar\"), 1, -1);\n             fail(\"append(char[],, -1) expected IndexOutOfBoundsException\");\n-        } catch (IndexOutOfBoundsException e) {\n+        } catch (final IndexOutOfBoundsException e) {\n             // expected\n         }\n \n         try {\n             sb.append(new StringBuffer(\"bar\"), 1, 3);\n             fail(\"append(char[], 1, 3) expected IndexOutOfBoundsException\");\n-        } catch (IndexOutOfBoundsException e) {\n+        } catch (final IndexOutOfBoundsException e) {\n             // expected\n         }\n \n         try {\n             sb.append(new StringBuffer(\"bar\"), -1, 3);\n             fail(\"append(char[], -1, 3) expected IndexOutOfBoundsException\");\n-        } catch (IndexOutOfBoundsException e) {\n+        } catch (final IndexOutOfBoundsException e) {\n             // expected\n         }\n \n         try {\n             sb.append(new StringBuffer(\"bar\"), 4, 0);\n             fail(\"append(char[], 4, 0) expected IndexOutOfBoundsException\");\n-        } catch (IndexOutOfBoundsException e) {\n+        } catch (final IndexOutOfBoundsException e) {\n             // expected\n         }\n \n         try {\n             sb.append(new StrBuilder(\"bar\"), -1, 1);\n             fail(\"append(char[], -1,) expected IndexOutOfBoundsException\");\n-        } catch (IndexOutOfBoundsException e) {\n+        } catch (final IndexOutOfBoundsException e) {\n             // expected\n         }\n \n         try {\n             sb.append(new StrBuilder(\"bar\"), 3, 1);\n             fail(\"append(char[], 3,) expected IndexOutOfBoundsException\");\n-        } catch (IndexOutOfBoundsException e) {\n+        } catch (final IndexOutOfBoundsException e) {\n             // expected\n         }\n \n         try {\n             sb.append(new StrBuilder(\"bar\"), 1, -1);\n             fail(\"append(char[],, -1) expected IndexOutOfBoundsException\");\n-        } catch (IndexOutOfBoundsException e) {\n+        } catch (final IndexOutOfBoundsException e) {\n             // expected\n         }\n \n         try {\n             sb.append(new StrBuilder(\"bar\"), 1, 3);\n             fail(\"append(char[], 1, 3) expected IndexOutOfBoundsException\");\n-        } catch (IndexOutOfBoundsException e) {\n+        } catch (final IndexOutOfBoundsException e) {\n             // expected\n         }\n \n         try {\n             sb.append(new StrBuilder(\"bar\"), -1, 3);\n             fail(\"append(char[], -1, 3) expected IndexOutOfBoundsException\");\n-        } catch (IndexOutOfBoundsException e) {\n+        } catch (final IndexOutOfBoundsException e) {\n             // expected\n         }\n \n         try {\n             sb.append(new StrBuilder(\"bar\"), 4, 0);\n             fail(\"append(char[], 4, 0) expected IndexOutOfBoundsException\");\n-        } catch (IndexOutOfBoundsException e) {\n+        } catch (final IndexOutOfBoundsException e) {\n             // expected\n         }\n \n         try {\n             sb.append(new char[]{'b', 'a', 'r'}, -1, 1);\n             fail(\"append(char[], -1,) expected IndexOutOfBoundsException\");\n-        } catch (IndexOutOfBoundsException e) {\n+        } catch (final IndexOutOfBoundsException e) {\n             // expected\n         }\n \n         try {\n             sb.append(new char[]{'b', 'a', 'r'}, 3, 1);\n             fail(\"append(char[], 3,) expected IndexOutOfBoundsException\");\n-        } catch (IndexOutOfBoundsException e) {\n+        } catch (final IndexOutOfBoundsException e) {\n             // expected\n         }\n \n         try {\n             sb.append(new char[]{'b', 'a', 'r'}, 1, -1);\n             fail(\"append(char[],, -1) expected IndexOutOfBoundsException\");\n-        } catch (IndexOutOfBoundsException e) {\n+        } catch (final IndexOutOfBoundsException e) {\n             // expected\n         }\n \n         try {\n             sb.append(new char[]{'b', 'a', 'r'}, 1, 3);\n             fail(\"append(char[], 1, 3) expected IndexOutOfBoundsException\");\n-        } catch (IndexOutOfBoundsException e) {\n+        } catch (final IndexOutOfBoundsException e) {\n             // expected\n         }\n \n         try {\n             sb.append(new char[]{'b', 'a', 'r'}, -1, 3);\n             fail(\"append(char[], -1, 3) expected IndexOutOfBoundsException\");\n-        } catch (IndexOutOfBoundsException e) {\n+        } catch (final IndexOutOfBoundsException e) {\n             // expected\n         }\n \n         try {\n             sb.append(new char[]{'b', 'a', 'r'}, 4, 0);\n             fail(\"append(char[], 4, 0) expected IndexOutOfBoundsException\");\n-        } catch (IndexOutOfBoundsException e) {\n+        } catch (final IndexOutOfBoundsException e) {\n             // expected\n         }\n \n     //-----------------------------------------------------------------------\n     @Test\n     public void testAppend_Boolean() {\n-        StrBuilder sb = new StrBuilder();\n+        final StrBuilder sb = new StrBuilder();\n         sb.append(true);\n         assertEquals(\"true\", sb.toString());\n \n     //-----------------------------------------------------------------------\n     @Test\n     public void testAppend_PrimitiveNumber() {\n-        StrBuilder sb = new StrBuilder();\n+        final StrBuilder sb = new StrBuilder();\n         sb.append(0);\n         assertEquals(\"0\", sb.toString());\n \n     @Test\n     public void testAppendln_FormattedString() {\n         final int[] count = new int[2];\n-        StrBuilder sb = new StrBuilder() {\n+        final StrBuilder sb = new StrBuilder() {\n             @Override\n             public StrBuilder append(final String str) {\n                 count[0]++;\n     //-----------------------------------------------------------------------\n     @Test\n     public void testAppendln_Object() {\n-        StrBuilder sb = new StrBuilder();\n+        final StrBuilder sb = new StrBuilder();\n         sb.appendln((Object) null);\n         assertEquals(\"\" + SEP, sb.toString());\n \n     @Test\n     public void testAppendln_String() {\n         final int[] count = new int[2];\n-        StrBuilder sb = new StrBuilder() {\n+        final StrBuilder sb = new StrBuilder() {\n             @Override\n             public StrBuilder append(final String str) {\n                 count[0]++;\n     @Test\n     public void testAppendln_String_int_int() {\n         final int[] count = new int[2];\n-        StrBuilder sb = new StrBuilder() {\n+        final StrBuilder sb = new StrBuilder() {\n             @Override\n             public StrBuilder append(final String str, final int startIndex, final int length) {\n                 count[0]++;\n     @Test\n     public void testAppendln_StringBuffer() {\n         final int[] count = new int[2];\n-        StrBuilder sb = new StrBuilder() {\n+        final StrBuilder sb = new StrBuilder() {\n             @Override\n             public StrBuilder append(final StringBuffer str) {\n                 count[0]++;\n     @Test\n     public void testAppendln_StringBuilder() {\n         final int[] count = new int[2];\n-        StrBuilder sb = new StrBuilder() {\n+        final StrBuilder sb = new StrBuilder() {\n             @Override\n             public StrBuilder append(final StringBuilder str) {\n                 count[0]++;\n     @Test\n     public void testAppendln_StringBuffer_int_int() {\n         final int[] count = new int[2];\n-        StrBuilder sb = new StrBuilder() {\n+        final StrBuilder sb = new StrBuilder() {\n             @Override\n             public StrBuilder append(final StringBuffer str, final int startIndex, final int length) {\n                 count[0]++;\n     @Test\n     public void testAppendln_StringBuilder_int_int() {\n         final int[] count = new int[2];\n-        StrBuilder sb = new StrBuilder() {\n+        final StrBuilder sb = new StrBuilder() {\n             @Override\n             public StrBuilder append(final StringBuilder str, final int startIndex, final int length) {\n                 count[0]++;\n     @Test\n     public void testAppendln_StrBuilder() {\n         final int[] count = new int[2];\n-        StrBuilder sb = new StrBuilder() {\n+        final StrBuilder sb = new StrBuilder() {\n             @Override\n             public StrBuilder append(final StrBuilder str) {\n                 count[0]++;\n     @Test\n     public void testAppendln_StrBuilder_int_int() {\n         final int[] count = new int[2];\n-        StrBuilder sb = new StrBuilder() {\n+        final StrBuilder sb = new StrBuilder() {\n             @Override\n             public StrBuilder append(final StrBuilder str, final int startIndex, final int length) {\n                 count[0]++;\n     @Test\n     public void testAppendln_CharArray() {\n         final int[] count = new int[2];\n-        StrBuilder sb = new StrBuilder() {\n+        final StrBuilder sb = new StrBuilder() {\n             @Override\n             public StrBuilder append(final char[] str) {\n                 count[0]++;\n     @Test\n     public void testAppendln_CharArray_int_int() {\n         final int[] count = new int[2];\n-        StrBuilder sb = new StrBuilder() {\n+        final StrBuilder sb = new StrBuilder() {\n             @Override\n             public StrBuilder append(final char[] str, final int startIndex, final int length) {\n                 count[0]++;\n     //-----------------------------------------------------------------------\n     @Test\n     public void testAppendln_Boolean() {\n-        StrBuilder sb = new StrBuilder();\n+        final StrBuilder sb = new StrBuilder();\n         sb.appendln(true);\n         assertEquals(\"true\" + SEP, sb.toString());\n         \n     //-----------------------------------------------------------------------\n     @Test\n     public void testAppendln_PrimitiveNumber() {\n-        StrBuilder sb = new StrBuilder();\n+        final StrBuilder sb = new StrBuilder();\n         sb.appendln(0);\n         assertEquals(\"0\" + SEP, sb.toString());\n         \n     //-----------------------------------------------------------------------\n     @Test\n     public void testAppendPadding() {\n-        StrBuilder sb = new StrBuilder();\n+        final StrBuilder sb = new StrBuilder();\n         sb.append(\"foo\");\n         assertEquals(\"foo\", sb.toString());\n \n     //-----------------------------------------------------------------------\n     @Test\n     public void testAppendFixedWidthPadLeft() {\n-        StrBuilder sb = new StrBuilder();\n+        final StrBuilder sb = new StrBuilder();\n         sb.appendFixedWidthPadLeft(\"foo\", -1, '-');\n         assertEquals(\"\", sb.toString());\n \n     //-----------------------------------------------------------------------\n     @Test\n     public void testAppendFixedWidthPadLeft_int() {\n-        StrBuilder sb = new StrBuilder();\n+        final StrBuilder sb = new StrBuilder();\n         sb.appendFixedWidthPadLeft(123, -1, '-');\n         assertEquals(\"\", sb.toString());\n \n     //-----------------------------------------------------------------------\n     @Test\n     public void testAppendFixedWidthPadRight() {\n-        StrBuilder sb = new StrBuilder();\n+        final StrBuilder sb = new StrBuilder();\n         sb.appendFixedWidthPadRight(\"foo\", -1, '-');\n         assertEquals(\"\", sb.toString());\n \n     // See: http://issues.apache.org/jira/browse/LANG-299\n     @Test\n     public void testLang299() {\n-        StrBuilder sb = new StrBuilder(1);\n+        final StrBuilder sb = new StrBuilder(1);\n         sb.appendFixedWidthPadRight(\"foo\", 1, '-');\n         assertEquals(\"f\", sb.toString());\n     }\n     //-----------------------------------------------------------------------\n     @Test\n     public void testAppendFixedWidthPadRight_int() {\n-        StrBuilder sb = new StrBuilder();\n+        final StrBuilder sb = new StrBuilder();\n         sb.appendFixedWidthPadRight(123, -1, '-');\n         assertEquals(\"\", sb.toString());\n \n     //-----------------------------------------------------------------------\n     @Test\n     public void testAppendAll_Array() {\n-        StrBuilder sb = new StrBuilder();\n+        final StrBuilder sb = new StrBuilder();\n         sb.appendAll((Object[]) null);\n         assertEquals(\"\", sb.toString());\n \n     //-----------------------------------------------------------------------\n     @Test\n     public void testAppendAll_Collection() {\n-        StrBuilder sb = new StrBuilder();\n+        final StrBuilder sb = new StrBuilder();\n         sb.appendAll((Collection<?>) null);\n         assertEquals(\"\", sb.toString());\n \n     //-----------------------------------------------------------------------\n     @Test\n     public void testAppendAll_Iterator() {\n-        StrBuilder sb = new StrBuilder();\n+        final StrBuilder sb = new StrBuilder();\n         sb.appendAll((Iterator<?>) null);\n         assertEquals(\"\", sb.toString());\n \n     //-----------------------------------------------------------------------\n     @Test\n     public void testAppendWithSeparators_Array() {\n-        StrBuilder sb = new StrBuilder();\n+        final StrBuilder sb = new StrBuilder();\n         sb.appendWithSeparators((Object[]) null, \",\");\n         assertEquals(\"\", sb.toString());\n \n     //-----------------------------------------------------------------------\n     @Test\n     public void testAppendWithSeparators_Collection() {\n-        StrBuilder sb = new StrBuilder();\n+        final StrBuilder sb = new StrBuilder();\n         sb.appendWithSeparators((Collection<?>) null, \",\");\n         assertEquals(\"\", sb.toString());\n \n     //-----------------------------------------------------------------------\n     @Test\n     public void testAppendWithSeparators_Iterator() {\n-        StrBuilder sb = new StrBuilder();\n+        final StrBuilder sb = new StrBuilder();\n         sb.appendWithSeparators((Iterator<?>) null, \",\");\n         assertEquals(\"\", sb.toString());\n \n     //-----------------------------------------------------------------------\n     @Test\n     public void testAppendWithSeparatorsWithNullText() {\n-        StrBuilder sb = new StrBuilder();\n+        final StrBuilder sb = new StrBuilder();\n         sb.setNullText(\"null\");\n         sb.appendWithSeparators(new Object[]{\"foo\", null, \"baz\"}, \",\");\n         assertEquals(\"foo,null,baz\", sb.toString());\n     //-----------------------------------------------------------------------\n     @Test\n     public void testAppendSeparator_String() {\n-        StrBuilder sb = new StrBuilder();\n+        final StrBuilder sb = new StrBuilder();\n         sb.appendSeparator(\",\");  // no effect\n         assertEquals(\"\", sb.toString());\n         sb.append(\"foo\");\n     //-----------------------------------------------------------------------\n     @Test\n     public void testAppendSeparator_String_String() {\n-        StrBuilder sb = new StrBuilder();\n+        final StrBuilder sb = new StrBuilder();\n         final String startSeparator = \"order by \";\n         final String standardSeparator = \",\";\n         final String foo = \"foo\";\n     //-----------------------------------------------------------------------\n     @Test\n     public void testAppendSeparator_char() {\n-        StrBuilder sb = new StrBuilder();\n+        final StrBuilder sb = new StrBuilder();\n         sb.appendSeparator(',');  // no effect\n         assertEquals(\"\", sb.toString());\n         sb.append(\"foo\");\n     }\n     @Test\n     public void testAppendSeparator_char_char() {\n-        StrBuilder sb = new StrBuilder();\n+        final StrBuilder sb = new StrBuilder();\n         final char startSeparator = ':';\n         final char standardSeparator = ',';\n         final String foo = \"foo\";\n     //-----------------------------------------------------------------------\n     @Test\n     public void testAppendSeparator_String_int() {\n-        StrBuilder sb = new StrBuilder();\n+        final StrBuilder sb = new StrBuilder();\n         sb.appendSeparator(\",\", 0);  // no effect\n         assertEquals(\"\", sb.toString());\n         sb.append(\"foo\");\n     //-----------------------------------------------------------------------\n     @Test\n     public void testAppendSeparator_char_int() {\n-        StrBuilder sb = new StrBuilder();\n+        final StrBuilder sb = new StrBuilder();\n         sb.appendSeparator(',', 0);  // no effect\n         assertEquals(\"\", sb.toString());\n         sb.append(\"foo\");\n     @Test\n     public void testInsert() {\n \n-        StrBuilder sb = new StrBuilder();\n+        final StrBuilder sb = new StrBuilder();\n         sb.append(\"barbaz\");\n         assertEquals(\"barbaz\", sb.toString());\n \n         try {\n             sb.insert(-1, FOO);\n             fail(\"insert(-1, Object) expected StringIndexOutOfBoundsException\");\n-        } catch (IndexOutOfBoundsException e) {\n+        } catch (final IndexOutOfBoundsException e) {\n             // expected\n         }\n \n         try {\n             sb.insert(7, FOO);\n             fail(\"insert(7, Object) expected StringIndexOutOfBoundsException\");\n-        } catch (IndexOutOfBoundsException e) {\n+        } catch (final IndexOutOfBoundsException e) {\n             // expected\n         }\n \n         try {\n             sb.insert(-1, \"foo\");\n             fail(\"insert(-1, String) expected StringIndexOutOfBoundsException\");\n-        } catch (IndexOutOfBoundsException e) {\n+        } catch (final IndexOutOfBoundsException e) {\n             // expected\n         }\n \n         try {\n             sb.insert(7, \"foo\");\n             fail(\"insert(7, String) expected StringIndexOutOfBoundsException\");\n-        } catch (IndexOutOfBoundsException e) {\n+        } catch (final IndexOutOfBoundsException e) {\n             // expected\n         }\n \n         try {\n             sb.insert(-1, new char[]{'f', 'o', 'o'});\n             fail(\"insert(-1, char[]) expected StringIndexOutOfBoundsException\");\n-        } catch (IndexOutOfBoundsException e) {\n+        } catch (final IndexOutOfBoundsException e) {\n             // expected\n         }\n \n         try {\n             sb.insert(7, new char[]{'f', 'o', 'o'});\n             fail(\"insert(7, char[]) expected StringIndexOutOfBoundsException\");\n-        } catch (IndexOutOfBoundsException e) {\n+        } catch (final IndexOutOfBoundsException e) {\n             // expected\n         }\n \n         try {\n             sb.insert(-1, new char[]{'a', 'b', 'c', 'f', 'o', 'o', 'd', 'e', 'f'}, 3, 3);\n             fail(\"insert(-1, char[], 3, 3) expected StringIndexOutOfBoundsException\");\n-        } catch (IndexOutOfBoundsException e) {\n+        } catch (final IndexOutOfBoundsException e) {\n             // expected\n         }\n \n         try {\n             sb.insert(7, new char[]{'a', 'b', 'c', 'f', 'o', 'o', 'd', 'e', 'f'}, 3, 3);\n             fail(\"insert(7, char[], 3, 3) expected StringIndexOutOfBoundsException\");\n-        } catch (IndexOutOfBoundsException e) {\n+        } catch (final IndexOutOfBoundsException e) {\n             // expected\n         }\n \n         try {\n             sb.insert(0, new char[]{'a', 'b', 'c', 'f', 'o', 'o', 'd', 'e', 'f'}, -1, 3);\n             fail(\"insert(0, char[], -1, 3) expected StringIndexOutOfBoundsException\");\n-        } catch (IndexOutOfBoundsException e) {\n+        } catch (final IndexOutOfBoundsException e) {\n             // expected\n         }\n \n         try {\n             sb.insert(0, new char[]{'a', 'b', 'c', 'f', 'o', 'o', 'd', 'e', 'f'}, 10, 3);\n             fail(\"insert(0, char[], 10, 3) expected StringIndexOutOfBoundsException\");\n-        } catch (IndexOutOfBoundsException e) {\n+        } catch (final IndexOutOfBoundsException e) {\n             // expected\n         }\n \n         try {\n             sb.insert(0, new char[]{'a', 'b', 'c', 'f', 'o', 'o', 'd', 'e', 'f'}, 0, -1);\n             fail(\"insert(0, char[], 0, -1) expected StringIndexOutOfBoundsException\");\n-        } catch (IndexOutOfBoundsException e) {\n+        } catch (final IndexOutOfBoundsException e) {\n             // expected\n         }\n \n         try {\n             sb.insert(0, new char[]{'a', 'b', 'c', 'f', 'o', 'o', 'd', 'e', 'f'}, 0, 10);\n             fail(\"insert(0, char[], 0, 10) expected StringIndexOutOfBoundsException\");\n-        } catch (IndexOutOfBoundsException e) {\n+        } catch (final IndexOutOfBoundsException e) {\n             // expected\n         }\n \n         try {\n             sb.insert(-1, true);\n             fail(\"insert(-1, boolean) expected StringIndexOutOfBoundsException\");\n-        } catch (IndexOutOfBoundsException e) {\n+        } catch (final IndexOutOfBoundsException e) {\n             // expected\n         }\n \n         try {\n             sb.insert(7, true);\n             fail(\"insert(7, boolean) expected StringIndexOutOfBoundsException\");\n-        } catch (IndexOutOfBoundsException e) {\n+        } catch (final IndexOutOfBoundsException e) {\n             // expected\n         }\n \n         try {\n             sb.insert(-1, '!');\n             fail(\"insert(-1, char) expected StringIndexOutOfBoundsException\");\n-        } catch (IndexOutOfBoundsException e) {\n+        } catch (final IndexOutOfBoundsException e) {\n             // expected\n         }\n \n         try {\n             sb.insert(7, '!');\n             fail(\"insert(7, char) expected StringIndexOutOfBoundsException\");\n-        } catch (IndexOutOfBoundsException e) {\n+        } catch (final IndexOutOfBoundsException e) {\n             // expected\n         }\n \n         try {\n             sb.insert(-1, 0);\n             fail(\"insert(-1, int) expected StringIndexOutOfBoundsException\");\n-        } catch (IndexOutOfBoundsException e) {\n+        } catch (final IndexOutOfBoundsException e) {\n             // expected\n         }\n \n         try {\n             sb.insert(7, 0);\n             fail(\"insert(7, int) expected StringIndexOutOfBoundsException\");\n-        } catch (IndexOutOfBoundsException e) {\n+        } catch (final IndexOutOfBoundsException e) {\n             // expected\n         }\n \n         try {\n             sb.insert(-1, 1L);\n             fail(\"insert(-1, long) expected StringIndexOutOfBoundsException\");\n-        } catch (IndexOutOfBoundsException e) {\n+        } catch (final IndexOutOfBoundsException e) {\n             // expected\n         }\n \n         try {\n             sb.insert(7, 1L);\n             fail(\"insert(7, long) expected StringIndexOutOfBoundsException\");\n-        } catch (IndexOutOfBoundsException e) {\n+        } catch (final IndexOutOfBoundsException e) {\n             // expected\n         }\n \n         try {\n             sb.insert(-1, 2.3F);\n             fail(\"insert(-1, float) expected StringIndexOutOfBoundsException\");\n-        } catch (IndexOutOfBoundsException e) {\n+        } catch (final IndexOutOfBoundsException e) {\n             // expected\n         }\n \n         try {\n             sb.insert(7, 2.3F);\n             fail(\"insert(7, float) expected StringIndexOutOfBoundsException\");\n-        } catch (IndexOutOfBoundsException e) {\n+        } catch (final IndexOutOfBoundsException e) {\n             // expected\n         }\n \n         try {\n             sb.insert(-1, 4.5D);\n             fail(\"insert(-1, double) expected StringIndexOutOfBoundsException\");\n-        } catch (IndexOutOfBoundsException e) {\n+        } catch (final IndexOutOfBoundsException e) {\n             // expected\n         }\n \n         try {\n             sb.insert(7, 4.5D);\n             fail(\"insert(7, double) expected StringIndexOutOfBoundsException\");\n-        } catch (IndexOutOfBoundsException e) {\n+        } catch (final IndexOutOfBoundsException e) {\n             // expected\n         }\n \n     //-----------------------------------------------------------------------\n     @Test\n     public void testInsertWithNullText() {\n-        StrBuilder sb = new StrBuilder();\n+        final StrBuilder sb = new StrBuilder();\n         sb.setNullText(\"null\");\n         sb.append(\"barbaz\");\n         assertEquals(\"barbaz\", sb.toString());\n         try {\n             sb.insert(-1, FOO);\n             fail(\"insert(-1, Object) expected StringIndexOutOfBoundsException\");\n-        } catch (IndexOutOfBoundsException e) {\n+        } catch (final IndexOutOfBoundsException e) {\n             // expected\n         }\n \n         try {\n             sb.insert(7, FOO);\n             fail(\"insert(7, Object) expected StringIndexOutOfBoundsException\");\n-        } catch (IndexOutOfBoundsException e) {\n+        } catch (final IndexOutOfBoundsException e) {\n             // expected\n         }\n \n         try {\n             sb.insert(-1, \"foo\");\n             fail(\"insert(-1, String) expected StringIndexOutOfBoundsException\");\n-        } catch (IndexOutOfBoundsException e) {\n+        } catch (final IndexOutOfBoundsException e) {\n             // expected\n         }\n \n         try {\n             sb.insert(7, \"foo\");\n             fail(\"insert(7, String) expected StringIndexOutOfBoundsException\");\n-        } catch (IndexOutOfBoundsException e) {\n+        } catch (final IndexOutOfBoundsException e) {\n             // expected\n         }\n \n--- a/src/test/java/org/apache/commons/lang3/text/StrBuilderTest.java\n+++ b/src/test/java/org/apache/commons/lang3/text/StrBuilderTest.java\n     //-----------------------------------------------------------------------\n     @Test\n     public void testConstructors() {\n-        StrBuilder sb0 = new StrBuilder();\n+        final StrBuilder sb0 = new StrBuilder();\n         assertEquals(32, sb0.capacity());\n         assertEquals(0, sb0.length());\n         assertEquals(0, sb0.size());\n \n-        StrBuilder sb1 = new StrBuilder(32);\n+        final StrBuilder sb1 = new StrBuilder(32);\n         assertEquals(32, sb1.capacity());\n         assertEquals(0, sb1.length());\n         assertEquals(0, sb1.size());\n \n-        StrBuilder sb2 = new StrBuilder(0);\n+        final StrBuilder sb2 = new StrBuilder(0);\n         assertEquals(32, sb2.capacity());\n         assertEquals(0, sb2.length());\n         assertEquals(0, sb2.size());\n \n-        StrBuilder sb3 = new StrBuilder(-1);\n+        final StrBuilder sb3 = new StrBuilder(-1);\n         assertEquals(32, sb3.capacity());\n         assertEquals(0, sb3.length());\n         assertEquals(0, sb3.size());\n \n-        StrBuilder sb4 = new StrBuilder(1);\n+        final StrBuilder sb4 = new StrBuilder(1);\n         assertEquals(1, sb4.capacity());\n         assertEquals(0, sb4.length());\n         assertEquals(0, sb4.size());\n \n-        StrBuilder sb5 = new StrBuilder((String) null);\n+        final StrBuilder sb5 = new StrBuilder((String) null);\n         assertEquals(32, sb5.capacity());\n         assertEquals(0, sb5.length());\n         assertEquals(0, sb5.size());\n \n-        StrBuilder sb6 = new StrBuilder(\"\");\n+        final StrBuilder sb6 = new StrBuilder(\"\");\n         assertEquals(32, sb6.capacity());\n         assertEquals(0, sb6.length());\n         assertEquals(0, sb6.size());\n \n-        StrBuilder sb7 = new StrBuilder(\"foo\");\n+        final StrBuilder sb7 = new StrBuilder(\"foo\");\n         assertEquals(35, sb7.capacity());\n         assertEquals(3, sb7.length());\n         assertEquals(3, sb7.size());\n     //-----------------------------------------------------------------------\n     @Test\n     public void testChaining() {\n-        StrBuilder sb = new StrBuilder();\n+        final StrBuilder sb = new StrBuilder();\n         assertSame(sb, sb.setNewLineText(null));\n         assertSame(sb, sb.setNullText(null));\n         assertSame(sb, sb.setLength(1));\n     //-----------------------------------------------------------------------\n     @Test\n     public void testGetSetNewLineText() {\n-        StrBuilder sb = new StrBuilder();\n+        final StrBuilder sb = new StrBuilder();\n         assertEquals(null, sb.getNewLineText());\n \n         sb.setNewLineText(\"#\");\n     //-----------------------------------------------------------------------\n     @Test\n     public void testGetSetNullText() {\n-        StrBuilder sb = new StrBuilder();\n+        final StrBuilder sb = new StrBuilder();\n         assertEquals(null, sb.getNullText());\n \n         sb.setNullText(\"null\");\n     //-----------------------------------------------------------------------\n     @Test\n     public void testCapacityAndLength() {\n-        StrBuilder sb = new StrBuilder();\n+        final StrBuilder sb = new StrBuilder();\n         assertEquals(32, sb.capacity());\n         assertEquals(0, sb.length());\n         assertEquals(0, sb.size());\n         try {\n             sb.setLength(-1);\n             fail(\"setLength(-1) expected StringIndexOutOfBoundsException\");\n-        } catch (IndexOutOfBoundsException e) {\n+        } catch (final IndexOutOfBoundsException e) {\n             // expected\n         }\n \n     //-----------------------------------------------------------------------\n     @Test\n     public void testLength() {\n-        StrBuilder sb = new StrBuilder();\n+        final StrBuilder sb = new StrBuilder();\n         assertEquals(0, sb.length());\n         \n         sb.append(\"Hello\");\n \n     @Test\n     public void testSetLength() {\n-        StrBuilder sb = new StrBuilder();\n+        final StrBuilder sb = new StrBuilder();\n         sb.append(\"Hello\");\n         sb.setLength(2);  // shorten\n         assertEquals(\"He\", sb.toString());\n         try {\n             sb.setLength(-1);\n             fail(\"setLength(-1) expected StringIndexOutOfBoundsException\");\n-        } catch (IndexOutOfBoundsException e) {\n+        } catch (final IndexOutOfBoundsException e) {\n             // expected\n         }\n     }\n     //-----------------------------------------------------------------------\n     @Test\n     public void testCapacity() {\n-        StrBuilder sb = new StrBuilder();\n+        final StrBuilder sb = new StrBuilder();\n         assertEquals(sb.buffer.length, sb.capacity());\n         \n         sb.append(\"HelloWorldHelloWorldHelloWorldHelloWorld\");\n \n     @Test\n     public void testEnsureCapacity() {\n-        StrBuilder sb = new StrBuilder();\n+        final StrBuilder sb = new StrBuilder();\n         sb.ensureCapacity(2);\n         assertTrue(sb.capacity() >= 2);\n         \n \n     @Test\n     public void testMinimizeCapacity() {\n-        StrBuilder sb = new StrBuilder();\n+        final StrBuilder sb = new StrBuilder();\n         sb.minimizeCapacity();\n         assertEquals(0, sb.capacity());\n         \n     //-----------------------------------------------------------------------\n     @Test\n     public void testSize() {\n-        StrBuilder sb = new StrBuilder();\n+        final StrBuilder sb = new StrBuilder();\n         assertEquals(0, sb.size());\n         \n         sb.append(\"Hello\");\n \n     @Test\n     public void testIsEmpty() {\n-        StrBuilder sb = new StrBuilder();\n+        final StrBuilder sb = new StrBuilder();\n         assertTrue(sb.isEmpty());\n         \n         sb.append(\"Hello\");\n \n     @Test\n     public void testClear() {\n-        StrBuilder sb = new StrBuilder();\n+        final StrBuilder sb = new StrBuilder();\n         sb.append(\"Hello\");\n         sb.clear();\n         assertEquals(0, sb.length());\n     //-----------------------------------------------------------------------\n     @Test\n     public void testCharAt() {\n-        StrBuilder sb = new StrBuilder();\n+        final StrBuilder sb = new StrBuilder();\n         try {\n             sb.charAt(0);\n             fail(\"charAt(0) expected IndexOutOfBoundsException\");\n-        } catch (IndexOutOfBoundsException e) {\n+        } catch (final IndexOutOfBoundsException e) {\n             // expected\n         }\n         try {\n             sb.charAt(-1);\n             fail(\"charAt(-1) expected IndexOutOfBoundsException\");\n-        } catch (IndexOutOfBoundsException e) {\n+        } catch (final IndexOutOfBoundsException e) {\n             // expected\n         }\n         sb.append(\"foo\");\n         try {\n             sb.charAt(-1);\n             fail(\"charAt(-1) expected IndexOutOfBoundsException\");\n-        } catch (IndexOutOfBoundsException e) {\n+        } catch (final IndexOutOfBoundsException e) {\n             // expected\n         }\n         try {\n             sb.charAt(3);\n             fail(\"charAt(3) expected IndexOutOfBoundsException\");\n-        } catch (IndexOutOfBoundsException e) {\n+        } catch (final IndexOutOfBoundsException e) {\n             // expected\n         }\n     }\n     //-----------------------------------------------------------------------\n     @Test\n     public void testSetCharAt() {\n-        StrBuilder sb = new StrBuilder();\n+        final StrBuilder sb = new StrBuilder();\n         try {\n             sb.setCharAt(0, 'f');\n             fail(\"setCharAt(0,) expected IndexOutOfBoundsException\");\n-        } catch (IndexOutOfBoundsException e) {\n+        } catch (final IndexOutOfBoundsException e) {\n             // expected\n         }\n         try {\n             sb.setCharAt(-1, 'f');\n             fail(\"setCharAt(-1,) expected IndexOutOfBoundsException\");\n-        } catch (IndexOutOfBoundsException e) {\n+        } catch (final IndexOutOfBoundsException e) {\n             // expected\n         }\n         sb.append(\"foo\");\n         try {\n             sb.setCharAt(3, '!');\n             fail(\"setCharAt(3,) expected IndexOutOfBoundsException\");\n-        } catch (IndexOutOfBoundsException e) {\n+        } catch (final IndexOutOfBoundsException e) {\n             // expected\n         }\n         assertEquals(\"bar\", sb.toString());\n     //-----------------------------------------------------------------------\n     @Test\n     public void testDeleteCharAt() {\n-        StrBuilder sb = new StrBuilder(\"abc\");\n+        final StrBuilder sb = new StrBuilder(\"abc\");\n         sb.deleteCharAt(0);\n         assertEquals(\"bc\", sb.toString()); \n         \n         try {\n             sb.deleteCharAt(1000);\n             fail(\"Expected IndexOutOfBoundsException\");\n-        } catch (IndexOutOfBoundsException e) {}\n+        } catch (final IndexOutOfBoundsException e) {}\n     }\n \n     //-----------------------------------------------------------------------\n     @Test\n     public void testToCharArray() {\n-        StrBuilder sb = new StrBuilder();\n+        final StrBuilder sb = new StrBuilder();\n         assertEquals(ArrayUtils.EMPTY_CHAR_ARRAY, sb.toCharArray());\n \n         char[] a = sb.toCharArray();\n \n     @Test\n     public void testToCharArrayIntInt() {\n-        StrBuilder sb = new StrBuilder();\n+        final StrBuilder sb = new StrBuilder();\n         assertEquals(ArrayUtils.EMPTY_CHAR_ARRAY, sb.toCharArray(0, 0));\n \n         sb.append(\"junit\");\n         try {\n             sb.toCharArray(-1, 5);\n             fail(\"no string index out of bound on -1\");\n-        } catch (IndexOutOfBoundsException e) {\n+        } catch (final IndexOutOfBoundsException e) {\n         }\n \n         try {\n             sb.toCharArray(6, 5);\n             fail(\"no string index out of bound on -1\");\n-        } catch (IndexOutOfBoundsException e) {\n+        } catch (final IndexOutOfBoundsException e) {\n         }\n     }\n \n     @Test\n     public void testGetChars ( ) {\n-        StrBuilder sb = new StrBuilder();\n+        final StrBuilder sb = new StrBuilder();\n         \n         char[] input = new char[10];\n         char[] a = sb.getChars(input);\n \n     @Test\n     public void testGetCharsIntIntCharArrayInt( ) {\n-        StrBuilder sb = new StrBuilder();\n+        final StrBuilder sb = new StrBuilder();\n                \n         sb.append(\"junit\");\n         char[] a = new char[5];\n             sb.getChars(-1,0,a,0);\n             fail(\"no exception\");\n         }\n-        catch (IndexOutOfBoundsException e) {\n+        catch (final IndexOutOfBoundsException e) {\n         }\n         \n         try {\n             sb.getChars(0,-1,a,0);\n             fail(\"no exception\");\n         }\n-        catch (IndexOutOfBoundsException e) {\n+        catch (final IndexOutOfBoundsException e) {\n         }\n         \n         try {\n             sb.getChars(0,20,a,0);\n             fail(\"no exception\");\n         }\n-        catch (IndexOutOfBoundsException e) {\n+        catch (final IndexOutOfBoundsException e) {\n         }\n         \n         try {\n             sb.getChars(4,2,a,0);\n             fail(\"no exception\");\n         }\n-        catch (IndexOutOfBoundsException e) {\n+        catch (final IndexOutOfBoundsException e) {\n         }\n     }\n \n         try {\n             sb.delete(1, 2);\n             fail(\"Expected IndexOutOfBoundsException\");\n-        } catch (IndexOutOfBoundsException e) {}\n+        } catch (final IndexOutOfBoundsException e) {}\n         try {\n             sb.delete(-1, 1);\n             fail(\"Expected IndexOutOfBoundsException\");\n-        } catch (IndexOutOfBoundsException e) {}\n+        } catch (final IndexOutOfBoundsException e) {}\n         \n         sb = new StrBuilder(\"anything\");\n         try {\n             sb.delete(2, 1);\n             fail(\"Expected IndexOutOfBoundsException\");\n-        } catch (IndexOutOfBoundsException e) {}\n+        } catch (final IndexOutOfBoundsException e) {}\n     }\n \n     //-----------------------------------------------------------------------\n         try {\n             sb.replace(2, 1, \"anything\");\n             fail(\"Expected IndexOutOfBoundsException\");\n-        } catch (IndexOutOfBoundsException e) {}\n+        } catch (final IndexOutOfBoundsException e) {}\n         \n         sb = new StrBuilder();\n         try {\n             sb.replace(1, 2, \"anything\");\n             fail(\"Expected IndexOutOfBoundsException\");\n-        } catch (IndexOutOfBoundsException e) {}\n+        } catch (final IndexOutOfBoundsException e) {}\n         try {\n             sb.replace(-1, 1, \"anything\");\n             fail(\"Expected IndexOutOfBoundsException\");\n-        } catch (IndexOutOfBoundsException e) {}\n+        } catch (final IndexOutOfBoundsException e) {}\n     }\n \n     //-----------------------------------------------------------------------\n     @Test\n     public void testReplaceAll_char_char() {\n-        StrBuilder sb = new StrBuilder(\"abcbccba\");\n+        final StrBuilder sb = new StrBuilder(\"abcbccba\");\n         sb.replaceAll('x', 'y');\n         assertEquals(\"abcbccba\", sb.toString());\n         sb.replaceAll('a', 'd');\n     //-----------------------------------------------------------------------\n     @Test\n     public void testReplaceFirst_char_char() {\n-        StrBuilder sb = new StrBuilder(\"abcbccba\");\n+        final StrBuilder sb = new StrBuilder(\"abcbccba\");\n         sb.replaceFirst('x', 'y');\n         assertEquals(\"abcbccba\", sb.toString());\n         sb.replaceFirst('a', 'd');\n         try {\n             sb.replace(StrMatcher.stringMatcher(\"aa\"), \"-\", 11, sb.length(), -1);\n             fail();\n-        } catch (IndexOutOfBoundsException ex) {}\n+        } catch (final IndexOutOfBoundsException ex) {}\n         assertEquals(\"aaxaaaayaa\", sb.toString());\n         \n         sb = new StrBuilder(\"aaxaaaayaa\");\n         try {\n             sb.replace(StrMatcher.stringMatcher(\"aa\"), \"-\", -1, sb.length(), -1);\n             fail();\n-        } catch (IndexOutOfBoundsException ex) {}\n+        } catch (final IndexOutOfBoundsException ex) {}\n         assertEquals(\"aaxaaaayaa\", sb.toString());\n     }\n \n         try {\n             sb.replace(StrMatcher.stringMatcher(\"aa\"), \"-\", 2, 1, -1);\n             fail();\n-        } catch (IndexOutOfBoundsException ex) {}\n+        } catch (final IndexOutOfBoundsException ex) {}\n         assertEquals(\"aaxaaaayaa\", sb.toString());\n     }\n \n     //-----------------------------------------------------------------------\n     @Test\n     public void testReverse() {\n-        StrBuilder sb = new StrBuilder();\n+        final StrBuilder sb = new StrBuilder();\n         assertEquals(\"\", sb.reverse().toString());\n         \n         sb.clear().append(true);\n     //-----------------------------------------------------------------------\n     @Test\n     public void testTrim() {\n-        StrBuilder sb = new StrBuilder();\n+        final StrBuilder sb = new StrBuilder();\n         assertEquals(\"\", sb.reverse().toString());\n         \n         sb.clear().append(\" \\u0000 \");\n     //-----------------------------------------------------------------------\n     @Test\n     public void testStartsWith() {\n-        StrBuilder sb = new StrBuilder();\n+        final StrBuilder sb = new StrBuilder();\n         assertFalse(sb.startsWith(\"a\"));\n         assertFalse(sb.startsWith(null));\n         assertTrue(sb.startsWith(\"\"));\n \n     @Test\n     public void testEndsWith() {\n-        StrBuilder sb = new StrBuilder();\n+        final StrBuilder sb = new StrBuilder();\n         assertFalse(sb.endsWith(\"a\"));\n         assertFalse(sb.endsWith(\"c\"));\n         assertTrue(sb.endsWith(\"\"));\n     //-----------------------------------------------------------------------\n     @Test\n     public void testSubSequenceIntInt() {\n-       StrBuilder sb = new StrBuilder (\"hello goodbye\");\n+       final StrBuilder sb = new StrBuilder (\"hello goodbye\");\n        // Start index is negative\n        try {\n             sb.subSequence(-1, 5);\n             fail();\n-        } catch (IndexOutOfBoundsException e) {}\n+        } catch (final IndexOutOfBoundsException e) {}\n         \n         // End index is negative\n        try {\n             sb.subSequence(2, -1);\n             fail();\n-        } catch (IndexOutOfBoundsException e) {}\n+        } catch (final IndexOutOfBoundsException e) {}\n         \n         // End index greater than length()\n         try {\n             sb.subSequence(2, sb.length() + 1);\n             fail();\n-        } catch (IndexOutOfBoundsException e) {}\n+        } catch (final IndexOutOfBoundsException e) {}\n         \n         // Start index greater then end index\n         try {\n             sb.subSequence(3, 2);\n             fail();\n-        } catch (IndexOutOfBoundsException e) {}\n+        } catch (final IndexOutOfBoundsException e) {}\n         \n         // Normal cases\n         assertEquals (\"hello\", sb.subSequence(0, 5));\n \n     @Test\n     public void testSubstringInt() {\n-        StrBuilder sb = new StrBuilder (\"hello goodbye\");\n+        final StrBuilder sb = new StrBuilder (\"hello goodbye\");\n         assertEquals (\"goodbye\", sb.substring(6));\n         assertEquals (\"hello goodbye\".substring(6), sb.substring(6));\n         assertEquals (\"hello goodbye\", sb.substring(0));\n         try {\n             sb.substring(-1);\n             fail ();\n-        } catch (IndexOutOfBoundsException e) {}\n+        } catch (final IndexOutOfBoundsException e) {}\n         \n         try {\n             sb.substring(15);\n             fail ();\n-        } catch (IndexOutOfBoundsException e) {}\n+        } catch (final IndexOutOfBoundsException e) {}\n     \n     }\n     \n     @Test\n     public void testSubstringIntInt() {\n-        StrBuilder sb = new StrBuilder (\"hello goodbye\");\n+        final StrBuilder sb = new StrBuilder (\"hello goodbye\");\n         assertEquals (\"hello\", sb.substring(0, 5));\n         assertEquals (\"hello goodbye\".substring(0, 6), sb.substring(0, 6));\n         \n         try {\n             sb.substring(-1, 5);\n             fail();\n-        } catch (IndexOutOfBoundsException e) {}\n+        } catch (final IndexOutOfBoundsException e) {}\n         \n         try {\n             sb.substring(15, 20);\n             fail();\n-        } catch (IndexOutOfBoundsException e) {}\n+        } catch (final IndexOutOfBoundsException e) {}\n     }\n \n     // -----------------------------------------------------------------------\n     @Test\n     public void testMidString() {\n-        StrBuilder sb = new StrBuilder(\"hello goodbye hello\");\n+        final StrBuilder sb = new StrBuilder(\"hello goodbye hello\");\n         assertEquals(\"goodbye\", sb.midString(6, 7));\n         assertEquals(\"hello\", sb.midString(0, 5));\n         assertEquals(\"hello\", sb.midString(-5, 5));\n \n     @Test\n     public void testRightString() {\n-        StrBuilder sb = new StrBuilder(\"left right\");\n+        final StrBuilder sb = new StrBuilder(\"left right\");\n         assertEquals(\"right\", sb.rightString(5));\n         assertEquals(\"\", sb.rightString(0));\n         assertEquals(\"\", sb.rightString(-5));\n \n     @Test\n     public void testLeftString() {\n-        StrBuilder sb = new StrBuilder(\"left right\");\n+        final StrBuilder sb = new StrBuilder(\"left right\");\n         assertEquals(\"left\", sb.leftString(4));\n         assertEquals(\"\", sb.leftString(0));\n         assertEquals(\"\", sb.leftString(-5));\n     // -----------------------------------------------------------------------\n     @Test\n     public void testContains_char() {\n-        StrBuilder sb = new StrBuilder(\"abcdefghijklmnopqrstuvwxyz\");\n+        final StrBuilder sb = new StrBuilder(\"abcdefghijklmnopqrstuvwxyz\");\n         assertTrue(sb.contains('a'));\n         assertTrue(sb.contains('o'));\n         assertTrue(sb.contains('z'));\n \n     @Test\n     public void testContains_String() {\n-        StrBuilder sb = new StrBuilder(\"abcdefghijklmnopqrstuvwxyz\");\n+        final StrBuilder sb = new StrBuilder(\"abcdefghijklmnopqrstuvwxyz\");\n         assertTrue(sb.contains(\"a\"));\n         assertTrue(sb.contains(\"pq\"));\n         assertTrue(sb.contains(\"z\"));\n     // -----------------------------------------------------------------------\n     @Test\n     public void testIndexOf_char() {\n-        StrBuilder sb = new StrBuilder(\"abab\");\n+        final StrBuilder sb = new StrBuilder(\"abab\");\n         assertEquals(0, sb.indexOf('a'));\n         \n         // should work like String#indexOf\n \n     @Test\n     public void testLastIndexOf_char() {\n-        StrBuilder sb = new StrBuilder(\"abab\");\n+        final StrBuilder sb = new StrBuilder(\"abab\");\n         \n         assertEquals (2, sb.lastIndexOf('a'));\n         //should work like String#lastIndexOf\n     // -----------------------------------------------------------------------\n     @Test\n     public void testIndexOf_String() {\n-        StrBuilder sb = new StrBuilder(\"abab\");\n+        final StrBuilder sb = new StrBuilder(\"abab\");\n         \n         assertEquals(0, sb.indexOf(\"a\"));\n         //should work like String#indexOf\n \n     @Test\n     public void testLastIndexOf_String() {\n-        StrBuilder sb = new StrBuilder(\"abab\");\n+        final StrBuilder sb = new StrBuilder(\"abab\");\n         \n         assertEquals(2, sb.lastIndexOf(\"a\"));\n         //should work like String#lastIndexOf\n     // -----------------------------------------------------------------------\n     @Test\n     public void testIndexOf_StrMatcher() {\n-        StrBuilder sb = new StrBuilder();\n+        final StrBuilder sb = new StrBuilder();\n         assertEquals(-1, sb.indexOf((StrMatcher) null));\n         assertEquals(-1, sb.indexOf(StrMatcher.charMatcher('a')));\n         \n \n     @Test\n     public void testIndexOf_StrMatcher_int() {\n-        StrBuilder sb = new StrBuilder();\n+        final StrBuilder sb = new StrBuilder();\n         assertEquals(-1, sb.indexOf((StrMatcher) null, 2));\n         assertEquals(-1, sb.indexOf(StrMatcher.charMatcher('a'), 2));\n         assertEquals(-1, sb.indexOf(StrMatcher.charMatcher('a'), 0));\n \n     @Test\n     public void testLastIndexOf_StrMatcher() {\n-        StrBuilder sb = new StrBuilder();\n+        final StrBuilder sb = new StrBuilder();\n         assertEquals(-1, sb.lastIndexOf((StrMatcher) null));\n         assertEquals(-1, sb.lastIndexOf(StrMatcher.charMatcher('a')));\n         \n \n     @Test\n     public void testLastIndexOf_StrMatcher_int() {\n-        StrBuilder sb = new StrBuilder();\n+        final StrBuilder sb = new StrBuilder();\n         assertEquals(-1, sb.lastIndexOf((StrMatcher) null, 2));\n         assertEquals(-1, sb.lastIndexOf(StrMatcher.charMatcher('a'), 2));\n         assertEquals(-1, sb.lastIndexOf(StrMatcher.charMatcher('a'), 0));\n     @Test\n     public void testAsTokenizer() throws Exception {\n         // from Javadoc\n-        StrBuilder b = new StrBuilder();\n+        final StrBuilder b = new StrBuilder();\n         b.append(\"a b \");\n-        StrTokenizer t = b.asTokenizer();\n-        \n-        String[] tokens1 = t.getTokenArray();\n+        final StrTokenizer t = b.asTokenizer();\n+        \n+        final String[] tokens1 = t.getTokenArray();\n         assertEquals(2, tokens1.length);\n         assertEquals(\"a\", tokens1[0]);\n         assertEquals(\"b\", tokens1[1]);\n         assertEquals(2, t.size());\n         \n         b.append(\"c d \");\n-        String[] tokens2 = t.getTokenArray();\n+        final String[] tokens2 = t.getTokenArray();\n         assertEquals(2, tokens2.length);\n         assertEquals(\"a\", tokens2[0]);\n         assertEquals(\"b\", tokens2[1]);\n         assertEquals(\"b\", t.next());\n         \n         t.reset();\n-        String[] tokens3 = t.getTokenArray();\n+        final String[] tokens3 = t.getTokenArray();\n         assertEquals(4, tokens3.length);\n         assertEquals(\"a\", tokens3[0]);\n         assertEquals(\"b\", tokens3[1]);\n     // -----------------------------------------------------------------------\n     @Test\n     public void testAsReader() throws Exception {\n-        StrBuilder sb = new StrBuilder(\"some text\");\n+        final StrBuilder sb = new StrBuilder(\"some text\");\n         Reader reader = sb.asReader();\n         assertTrue(reader.ready());\n-        char[] buf = new char[40];\n+        final char[] buf = new char[40];\n         assertEquals(9, reader.read(buf));\n         assertEquals(\"some text\", new String(buf, 0, 9));\n         \n         try {\n             reader.read(array, -1, 0);\n             fail();\n-        } catch (IndexOutOfBoundsException ex) {}\n+        } catch (final IndexOutOfBoundsException ex) {}\n         try {\n             reader.read(array, 0, -1);\n             fail();\n-        } catch (IndexOutOfBoundsException ex) {}\n+        } catch (final IndexOutOfBoundsException ex) {}\n         try {\n             reader.read(array, 100, 1);\n             fail();\n-        } catch (IndexOutOfBoundsException ex) {}\n+        } catch (final IndexOutOfBoundsException ex) {}\n         try {\n             reader.read(array, 0, 100);\n             fail();\n-        } catch (IndexOutOfBoundsException ex) {}\n+        } catch (final IndexOutOfBoundsException ex) {}\n         try {\n             reader.read(array, Integer.MAX_VALUE, Integer.MAX_VALUE);\n             fail();\n-        } catch (IndexOutOfBoundsException ex) {}\n+        } catch (final IndexOutOfBoundsException ex) {}\n         \n         assertEquals(0, reader.read(array, 0, 0));\n         assertEquals(0, array[0]);\n     //-----------------------------------------------------------------------\n     @Test\n     public void testAsWriter() throws Exception {\n-        StrBuilder sb = new StrBuilder(\"base\");\n-        Writer writer = sb.asWriter();\n+        final StrBuilder sb = new StrBuilder(\"base\");\n+        final Writer writer = sb.asWriter();\n         \n         writer.write('l');\n         assertEquals(\"basel\", sb.toString());\n     //-----------------------------------------------------------------------\n     @Test\n     public void testEqualsIgnoreCase() {\n-        StrBuilder sb1 = new StrBuilder();\n-        StrBuilder sb2 = new StrBuilder();\n+        final StrBuilder sb1 = new StrBuilder();\n+        final StrBuilder sb2 = new StrBuilder();\n         assertTrue(sb1.equalsIgnoreCase(sb1));\n         assertTrue(sb1.equalsIgnoreCase(sb2));\n         assertTrue(sb2.equalsIgnoreCase(sb2));\n     //-----------------------------------------------------------------------\n     @Test\n     public void testEquals() {\n-        StrBuilder sb1 = new StrBuilder();\n-        StrBuilder sb2 = new StrBuilder();\n+        final StrBuilder sb1 = new StrBuilder();\n+        final StrBuilder sb2 = new StrBuilder();\n         assertTrue(sb1.equals(sb2));\n         assertTrue(sb1.equals(sb1));\n         assertTrue(sb2.equals(sb2));\n     //-----------------------------------------------------------------------\n     @Test\n     public void testHashCode() {\n-        StrBuilder sb = new StrBuilder();\n-        int hc1a = sb.hashCode();\n-        int hc1b = sb.hashCode();\n+        final StrBuilder sb = new StrBuilder();\n+        final int hc1a = sb.hashCode();\n+        final int hc1b = sb.hashCode();\n         assertEquals(0, hc1a);\n         assertEquals(hc1a, hc1b);\n         \n         sb.append(\"abc\");\n-        int hc2a = sb.hashCode();\n-        int hc2b = sb.hashCode();\n+        final int hc2a = sb.hashCode();\n+        final int hc2b = sb.hashCode();\n         assertTrue(hc2a != 0);\n         assertEquals(hc2a, hc2b);\n     }\n     //-----------------------------------------------------------------------\n     @Test\n     public void testToString() {\n-        StrBuilder sb = new StrBuilder(\"abc\");\n+        final StrBuilder sb = new StrBuilder(\"abc\");\n         assertEquals(\"abc\", sb.toString());\n     }\n \n     //-----------------------------------------------------------------------\n     @Test\n     public void testToStringBuffer() {\n-        StrBuilder sb = new StrBuilder();\n+        final StrBuilder sb = new StrBuilder();\n         assertEquals(new StringBuffer().toString(), sb.toStringBuffer().toString());\n         \n         sb.append(\"junit\");\n     //-----------------------------------------------------------------------\n     @Test\n     public void testToStringBuilder() {\n-        StrBuilder sb = new StrBuilder();\n+        final StrBuilder sb = new StrBuilder();\n         assertEquals(new StringBuilder().toString(), sb.toStringBuilder().toString());\n         \n         sb.append(\"junit\");\n     //-----------------------------------------------------------------------\n     @Test\n     public void testLang294() {\n-        StrBuilder sb = new StrBuilder(\"\\n%BLAH%\\nDo more stuff\\neven more stuff\\n%BLAH%\\n\");\n+        final StrBuilder sb = new StrBuilder(\"\\n%BLAH%\\nDo more stuff\\neven more stuff\\n%BLAH%\\n\");\n         sb.deleteAll(\"\\n%BLAH%\");\n         assertEquals(\"\\nDo more stuff\\neven more stuff\\n\", sb.toString()); \n     }\n \n     @Test\n     public void testIndexOfLang294() {\n-        StrBuilder sb = new StrBuilder(\"onetwothree\");\n+        final StrBuilder sb = new StrBuilder(\"onetwothree\");\n         sb.deleteFirst(\"three\");\n         assertEquals(-1, sb.indexOf(\"three\"));\n     }\n     //-----------------------------------------------------------------------\n     @Test\n     public void testLang295() {\n-        StrBuilder sb = new StrBuilder(\"onetwothree\");\n+        final StrBuilder sb = new StrBuilder(\"onetwothree\");\n         sb.deleteFirst(\"three\");\n         assertFalse( \"The contains(char) method is looking beyond the end of the string\", sb.contains('h'));\n         assertEquals( \"The indexOf(char) method is looking beyond the end of the string\", -1, sb.indexOf('h'));\n     //-----------------------------------------------------------------------\n     @Test\n     public void testLang412Right() {\n-        StrBuilder sb = new StrBuilder();\n+        final StrBuilder sb = new StrBuilder();\n         sb.appendFixedWidthPadRight(null, 10, '*');\n         assertEquals( \"Failed to invoke appendFixedWidthPadRight correctly\", \"**********\", sb.toString());\n     }\n \n     @Test\n     public void testLang412Left() {\n-        StrBuilder sb = new StrBuilder();\n+        final StrBuilder sb = new StrBuilder();\n         sb.appendFixedWidthPadLeft(null, 10, '*');\n         assertEquals( \"Failed to invoke appendFixedWidthPadLeft correctly\", \"**********\", sb.toString());\n     }\n \n     @Test\n     public void testAsBuilder() {\n-        StrBuilder sb = new StrBuilder().appendAll(\"Lorem\", \" \", \"ipsum\", \" \", \"dolor\");\n+        final StrBuilder sb = new StrBuilder().appendAll(\"Lorem\", \" \", \"ipsum\", \" \", \"dolor\");\n         assertEquals(sb.toString(), sb.build());\n     }\n \n--- a/src/test/java/org/apache/commons/lang3/text/StrLookupTest.java\n+++ b/src/test/java/org/apache/commons/lang3/text/StrLookupTest.java\n         try {\n             StrLookup.systemPropertiesLookup().lookup(null);\n             fail();\n-        } catch (NullPointerException ex) {\n+        } catch (final NullPointerException ex) {\n             // expected\n         }\n     }\n \n     @Test\n     public void testMapLookup() {\n-        Map<String, Object> map = new HashMap<String, Object>();\n+        final Map<String, Object> map = new HashMap<String, Object>();\n         map.put(\"key\", \"value\");\n         map.put(\"number\", Integer.valueOf(2));\n         assertEquals(\"value\", StrLookup.mapLookup(map).lookup(\"key\"));\n \n     @Test\n     public void testMapLookup_nullMap() {\n-        Map<String, ?> map = null;\n+        final Map<String, ?> map = null;\n         assertEquals(null, StrLookup.mapLookup(map).lookup(null));\n         assertEquals(null, StrLookup.mapLookup(map).lookup(\"\"));\n         assertEquals(null, StrLookup.mapLookup(map).lookup(\"any\"));\n--- a/src/test/java/org/apache/commons/lang3/text/StrMatcherTest.java\n+++ b/src/test/java/org/apache/commons/lang3/text/StrMatcherTest.java\n     //-----------------------------------------------------------------------\n     @Test\n     public void testCommaMatcher() {\n-        StrMatcher matcher = StrMatcher.commaMatcher();\n+        final StrMatcher matcher = StrMatcher.commaMatcher();\n         assertSame(matcher, StrMatcher.commaMatcher());\n         assertEquals(0, matcher.isMatch(BUFFER1, 0));\n         assertEquals(1, matcher.isMatch(BUFFER1, 1));\n     //-----------------------------------------------------------------------\n     @Test\n     public void testTabMatcher() {\n-        StrMatcher matcher = StrMatcher.tabMatcher();\n+        final StrMatcher matcher = StrMatcher.tabMatcher();\n         assertSame(matcher, StrMatcher.tabMatcher());\n         assertEquals(0, matcher.isMatch(BUFFER1, 2));\n         assertEquals(1, matcher.isMatch(BUFFER1, 3));\n     //-----------------------------------------------------------------------\n     @Test\n     public void testSpaceMatcher() {\n-        StrMatcher matcher = StrMatcher.spaceMatcher();\n+        final StrMatcher matcher = StrMatcher.spaceMatcher();\n         assertSame(matcher, StrMatcher.spaceMatcher());\n         assertEquals(0, matcher.isMatch(BUFFER1, 4));\n         assertEquals(1, matcher.isMatch(BUFFER1, 5));\n     //-----------------------------------------------------------------------\n     @Test\n     public void testSplitMatcher() {\n-        StrMatcher matcher = StrMatcher.splitMatcher();\n+        final StrMatcher matcher = StrMatcher.splitMatcher();\n         assertSame(matcher, StrMatcher.splitMatcher());\n         assertEquals(0, matcher.isMatch(BUFFER1, 2));\n         assertEquals(1, matcher.isMatch(BUFFER1, 3));\n     //-----------------------------------------------------------------------\n     @Test\n     public void testTrimMatcher() {\n-        StrMatcher matcher = StrMatcher.trimMatcher();\n+        final StrMatcher matcher = StrMatcher.trimMatcher();\n         assertSame(matcher, StrMatcher.trimMatcher());\n         assertEquals(0, matcher.isMatch(BUFFER1, 2));\n         assertEquals(1, matcher.isMatch(BUFFER1, 3));\n     //-----------------------------------------------------------------------\n     @Test\n     public void testSingleQuoteMatcher() {\n-        StrMatcher matcher = StrMatcher.singleQuoteMatcher();\n+        final StrMatcher matcher = StrMatcher.singleQuoteMatcher();\n         assertSame(matcher, StrMatcher.singleQuoteMatcher());\n         assertEquals(0, matcher.isMatch(BUFFER1, 10));\n         assertEquals(1, matcher.isMatch(BUFFER1, 11));\n     //-----------------------------------------------------------------------\n     @Test\n     public void testDoubleQuoteMatcher() {\n-        StrMatcher matcher = StrMatcher.doubleQuoteMatcher();\n+        final StrMatcher matcher = StrMatcher.doubleQuoteMatcher();\n         assertSame(matcher, StrMatcher.doubleQuoteMatcher());\n         assertEquals(0, matcher.isMatch(BUFFER1, 11));\n         assertEquals(1, matcher.isMatch(BUFFER1, 12));\n     //-----------------------------------------------------------------------\n     @Test\n     public void testQuoteMatcher() {\n-        StrMatcher matcher = StrMatcher.quoteMatcher();\n+        final StrMatcher matcher = StrMatcher.quoteMatcher();\n         assertSame(matcher, StrMatcher.quoteMatcher());\n         assertEquals(0, matcher.isMatch(BUFFER1, 10));\n         assertEquals(1, matcher.isMatch(BUFFER1, 11));\n     //-----------------------------------------------------------------------\n     @Test\n     public void testNoneMatcher() {\n-        StrMatcher matcher = StrMatcher.noneMatcher();\n+        final StrMatcher matcher = StrMatcher.noneMatcher();\n         assertSame(matcher, StrMatcher.noneMatcher());\n         assertEquals(0, matcher.isMatch(BUFFER1, 0));\n         assertEquals(0, matcher.isMatch(BUFFER1, 1));\n     //-----------------------------------------------------------------------\n     @Test\n     public void testCharMatcher_char() {\n-        StrMatcher matcher = StrMatcher.charMatcher('c');\n+        final StrMatcher matcher = StrMatcher.charMatcher('c');\n         assertEquals(0, matcher.isMatch(BUFFER2, 0));\n         assertEquals(0, matcher.isMatch(BUFFER2, 1));\n         assertEquals(1, matcher.isMatch(BUFFER2, 2));\n     //-----------------------------------------------------------------------\n     @Test\n     public void testCharSetMatcher_String() {\n-        StrMatcher matcher = StrMatcher.charSetMatcher(\"ace\");\n+        final StrMatcher matcher = StrMatcher.charSetMatcher(\"ace\");\n         assertEquals(1, matcher.isMatch(BUFFER2, 0));\n         assertEquals(0, matcher.isMatch(BUFFER2, 1));\n         assertEquals(1, matcher.isMatch(BUFFER2, 2));\n     //-----------------------------------------------------------------------\n     @Test\n     public void testCharSetMatcher_charArray() {\n-        StrMatcher matcher = StrMatcher.charSetMatcher(\"ace\".toCharArray());\n+        final StrMatcher matcher = StrMatcher.charSetMatcher(\"ace\".toCharArray());\n         assertEquals(1, matcher.isMatch(BUFFER2, 0));\n         assertEquals(0, matcher.isMatch(BUFFER2, 1));\n         assertEquals(1, matcher.isMatch(BUFFER2, 2));\n     //-----------------------------------------------------------------------\n     @Test\n     public void testStringMatcher_String() {\n-        StrMatcher matcher = StrMatcher.stringMatcher(\"bc\");\n+        final StrMatcher matcher = StrMatcher.stringMatcher(\"bc\");\n         assertEquals(0, matcher.isMatch(BUFFER2, 0));\n         assertEquals(2, matcher.isMatch(BUFFER2, 1));\n         assertEquals(0, matcher.isMatch(BUFFER2, 2));\n         // remember that the API contract is tight for the isMatch() method\n         // all the onus is on the caller, so invalid inputs are not\n         // the concern of StrMatcher, and are not bugs\n-        StrMatcher matcher = StrMatcher.stringMatcher(\"bc\");\n+        final StrMatcher matcher = StrMatcher.stringMatcher(\"bc\");\n         assertEquals(2, matcher.isMatch(BUFFER2, 1, 1, BUFFER2.length));\n         assertEquals(2, matcher.isMatch(BUFFER2, 1, 0, 3));\n         assertEquals(0, matcher.isMatch(BUFFER2, 1, 0, 2));\n--- a/src/test/java/org/apache/commons/lang3/text/StrSubstitutorTest.java\n+++ b/src/test/java/org/apache/commons/lang3/text/StrSubstitutorTest.java\n      */\n     @Test\n     public void testReplaceChangedMap() {\n-        StrSubstitutor sub = new StrSubstitutor(values);\n+        final StrSubstitutor sub = new StrSubstitutor(values);\n         values.put(\"target\", \"moon\");\n         assertEquals(\"The quick brown fox jumps over the moon.\", sub.replace(\"The ${animal} jumps over the ${target}.\"));\n     }\n     public void testReplaceAdjacentAtStart() {\n         values.put(\"code\", \"GBP\");\n         values.put(\"amount\", \"12.50\");\n-        StrSubstitutor sub = new StrSubstitutor(values);\n+        final StrSubstitutor sub = new StrSubstitutor(values);\n         assertEquals(\"GBP12.50 charged\", sub.replace(\"${code}${amount} charged\"));\n     }\n \n     public void testReplaceAdjacentAtEnd() {\n         values.put(\"code\", \"GBP\");\n         values.put(\"amount\", \"12.50\");\n-        StrSubstitutor sub = new StrSubstitutor(values);\n+        final StrSubstitutor sub = new StrSubstitutor(values);\n         assertEquals(\"Amount is GBP12.50\", sub.replace(\"Amount is ${code}${amount}\"));\n     }\n \n      */\n     @Test\n     public void testCyclicReplacement() {\n-        Map<String, String> map = new HashMap<String, String>();\n+        final Map<String, String> map = new HashMap<String, String>();\n         map.put(\"animal\", \"${critter}\");\n         map.put(\"target\", \"${pet}\");\n         map.put(\"pet\", \"${petCharacteristic} dog\");\n         map.put(\"critterSpeed\", \"quick\");\n         map.put(\"critterColor\", \"brown\");\n         map.put(\"critterType\", \"${animal}\");\n-        StrSubstitutor sub = new StrSubstitutor(map);\n+        final StrSubstitutor sub = new StrSubstitutor(map);\n         try {\n             sub.replace(\"The ${animal} jumps over the ${target}.\");\n             fail(\"Cyclic replacement was not detected!\");\n-        } catch (IllegalStateException ex) {\n+        } catch (final IllegalStateException ex) {\n             // expected\n         }\n     }\n      */\n     @Test\n     public void testReplacePartialString_noReplace() {\n-        StrSubstitutor sub = new StrSubstitutor();\n+        final StrSubstitutor sub = new StrSubstitutor();\n         assertEquals(\"${animal} jumps\", sub.replace(\"The ${animal} jumps over the ${target}.\", 4, 15));\n     }\n \n         values.put(\"animal.1\", \"fox\");\n         values.put(\"animal.2\", \"mouse\");\n         values.put(\"species\", \"2\");\n-        StrSubstitutor sub = new StrSubstitutor(values);\n+        final StrSubstitutor sub = new StrSubstitutor(values);\n         sub.setEnableSubstitutionInVariables(true);\n         assertEquals(\n                 \"Wrong result (1)\",\n         values.put(\"animal.1\", \"fox\");\n         values.put(\"animal.2\", \"mouse\");\n         values.put(\"species\", \"2\");\n-        StrSubstitutor sub = new StrSubstitutor(values);\n+        final StrSubstitutor sub = new StrSubstitutor(values);\n         assertEquals(\n                 \"Wrong result\",\n                 \"The ${animal.${species}} jumps over the lazy dog.\",\n         values.put(\"color\", \"white\");\n         values.put(\"species.white\", \"1\");\n         values.put(\"species.brown\", \"2\");\n-        StrSubstitutor sub = new StrSubstitutor(values);\n+        final StrSubstitutor sub = new StrSubstitutor(values);\n         sub.setEnableSubstitutionInVariables(true);\n         assertEquals(\n                 \"Wrong result\",\n     @Test\n     public void testResolveVariable() {\n         final StrBuilder builder = new StrBuilder(\"Hi ${name}!\");\n-        Map<String, String> map = new HashMap<String, String>();\n+        final Map<String, String> map = new HashMap<String, String>();\n         map.put(\"name\", \"commons\");\n-        StrSubstitutor sub = new StrSubstitutor(map) {\n+        final StrSubstitutor sub = new StrSubstitutor(map) {\n             @Override\n             protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos) {\n                 assertEquals(\"name\", variableName);\n      */\n     @Test\n     public void testConstructorNoArgs() {\n-        StrSubstitutor sub = new StrSubstitutor();\n+        final StrSubstitutor sub = new StrSubstitutor();\n         assertEquals(\"Hi ${name}\", sub.replace(\"Hi ${name}\"));\n     }\n \n      */\n     @Test\n     public void testConstructorMapPrefixSuffix() {\n-        Map<String, String> map = new HashMap<String, String>();\n+        final Map<String, String> map = new HashMap<String, String>();\n         map.put(\"name\", \"commons\");\n-        StrSubstitutor sub = new StrSubstitutor(map, \"<\", \">\");\n+        final StrSubstitutor sub = new StrSubstitutor(map, \"<\", \">\");\n         assertEquals(\"Hi < commons\", sub.replace(\"Hi $< <name>\"));\n     }\n \n      */\n     @Test\n     public void testConstructorMapFull() {\n-        Map<String, String> map = new HashMap<String, String>();\n+        final Map<String, String> map = new HashMap<String, String>();\n         map.put(\"name\", \"commons\");\n-        StrSubstitutor sub = new StrSubstitutor(map, \"<\", \">\", '!');\n+        final StrSubstitutor sub = new StrSubstitutor(map, \"<\", \">\", '!');\n         assertEquals(\"Hi < commons\", sub.replace(\"Hi !< <name>\"));\n     }\n \n      */\n     @Test\n     public void testGetSetEscape() {\n-        StrSubstitutor sub = new StrSubstitutor();\n+        final StrSubstitutor sub = new StrSubstitutor();\n         assertEquals('$', sub.getEscapeChar());\n         sub.setEscapeChar('<');\n         assertEquals('<', sub.getEscapeChar());\n      */\n     @Test\n     public void testGetSetPrefix() {\n-        StrSubstitutor sub = new StrSubstitutor();\n+        final StrSubstitutor sub = new StrSubstitutor();\n         assertTrue(sub.getVariablePrefixMatcher() instanceof StrMatcher.StringMatcher);\n         sub.setVariablePrefix('<');\n         assertTrue(sub.getVariablePrefixMatcher() instanceof StrMatcher.CharMatcher);\n         try {\n             sub.setVariablePrefix((String) null);\n             fail();\n-        } catch (IllegalArgumentException ex) {\n+        } catch (final IllegalArgumentException ex) {\n             // expected\n         }\n         assertTrue(sub.getVariablePrefixMatcher() instanceof StrMatcher.StringMatcher);\n \n-        StrMatcher matcher = StrMatcher.commaMatcher();\n+        final StrMatcher matcher = StrMatcher.commaMatcher();\n         sub.setVariablePrefixMatcher(matcher);\n         assertSame(matcher, sub.getVariablePrefixMatcher());\n         try {\n             sub.setVariablePrefixMatcher((StrMatcher) null);\n             fail();\n-        } catch (IllegalArgumentException ex) {\n+        } catch (final IllegalArgumentException ex) {\n             // expected\n         }\n         assertSame(matcher, sub.getVariablePrefixMatcher());\n      */\n     @Test\n     public void testGetSetSuffix() {\n-        StrSubstitutor sub = new StrSubstitutor();\n+        final StrSubstitutor sub = new StrSubstitutor();\n         assertTrue(sub.getVariableSuffixMatcher() instanceof StrMatcher.StringMatcher);\n         sub.setVariableSuffix('<');\n         assertTrue(sub.getVariableSuffixMatcher() instanceof StrMatcher.CharMatcher);\n         try {\n             sub.setVariableSuffix((String) null);\n             fail();\n-        } catch (IllegalArgumentException ex) {\n+        } catch (final IllegalArgumentException ex) {\n             // expected\n         }\n         assertTrue(sub.getVariableSuffixMatcher() instanceof StrMatcher.StringMatcher);\n \n-        StrMatcher matcher = StrMatcher.commaMatcher();\n+        final StrMatcher matcher = StrMatcher.commaMatcher();\n         sub.setVariableSuffixMatcher(matcher);\n         assertSame(matcher, sub.getVariableSuffixMatcher());\n         try {\n             sub.setVariableSuffixMatcher((StrMatcher) null);\n             fail();\n-        } catch (IllegalArgumentException ex) {\n+        } catch (final IllegalArgumentException ex) {\n             // expected\n         }\n         assertSame(matcher, sub.getVariableSuffixMatcher());\n      */\n     @Test\n     public void testStaticReplace() {\n-        Map<String, String> map = new HashMap<String, String>();\n+        final Map<String, String> map = new HashMap<String, String>();\n         map.put(\"name\", \"commons\");\n         assertEquals(\"Hi commons!\", StrSubstitutor.replace(\"Hi ${name}!\", map));\n     }\n      */\n     @Test\n     public void testStaticReplacePrefixSuffix() {\n-        Map<String, String> map = new HashMap<String, String>();\n+        final Map<String, String> map = new HashMap<String, String>();\n         map.put(\"name\", \"commons\");\n         assertEquals(\"Hi commons!\", StrSubstitutor.replace(\"Hi <name>!\", map, \"<\", \">\"));\n     }\n      */\n     @Test\n     public void testStaticReplaceSystemProperties() {\n-        StrBuilder buf = new StrBuilder();\n+        final StrBuilder buf = new StrBuilder();\n         buf.append(\"Hi \").append(System.getProperty(\"user.name\"));\n         buf.append(\", you are working with \");\n         buf.append(System.getProperty(\"os.name\"));\n      */\n     @Test\n     public void testSubstituteDefaultProperties(){\n-        String org = \"${doesnotwork}\";\n+        final String org = \"${doesnotwork}\";\n         System.setProperty(\"doesnotwork\", \"It works!\");\n \n         // create a new Properties object with the System.getProperties as default\n-        Properties props = new Properties(System.getProperties());\n+        final Properties props = new Properties(System.getProperties());\n \n         assertEquals(\"It works!\", StrSubstitutor.replace(org, props));\n     }\n     \n     @Test\n     public void testSamePrefixAndSuffix() {\n-        Map<String, String> map = new HashMap<String, String>();\n+        final Map<String, String> map = new HashMap<String, String>();\n         map.put(\"greeting\", \"Hello\");\n         map.put(\" there \", \"XXX\");\n         map.put(\"name\", \"commons\");\n \n     //-----------------------------------------------------------------------\n     private void doTestReplace(final String expectedResult, final String replaceTemplate, final boolean substring) {\n-        String expectedShortResult = expectedResult.substring(1, expectedResult.length() - 1);\n-        StrSubstitutor sub = new StrSubstitutor(values);\n+        final String expectedShortResult = expectedResult.substring(1, expectedResult.length() - 1);\n+        final StrSubstitutor sub = new StrSubstitutor(values);\n \n         // replace using String\n         assertEquals(expectedResult, sub.replace(replaceTemplate));\n         }\n \n         // replace using char[]\n-        char[] chars = replaceTemplate.toCharArray();\n+        final char[] chars = replaceTemplate.toCharArray();\n         assertEquals(expectedResult, sub.replace(chars));\n         if (substring) {\n             assertEquals(expectedShortResult, sub.replace(chars, 1, chars.length - 2));\n         }\n \n         // replace using object\n-        MutableObject<String> obj = new MutableObject<String>(replaceTemplate);  // toString returns template\n+        final MutableObject<String> obj = new MutableObject<String>(replaceTemplate);  // toString returns template\n         assertEquals(expectedResult, sub.replace(obj));\n \n         // replace in StringBuffer\n     }\n \n     private void doTestNoReplace(final String replaceTemplate) {\n-        StrSubstitutor sub = new StrSubstitutor(values);\n+        final StrSubstitutor sub = new StrSubstitutor(values);\n \n         if (replaceTemplate == null) {\n             assertEquals(null, sub.replace((String) null));\n             assertFalse(sub.replaceIn((StrBuilder) null, 0, 100));\n         } else {\n             assertEquals(replaceTemplate, sub.replace(replaceTemplate));\n-            StrBuilder bld = new StrBuilder(replaceTemplate);\n+            final StrBuilder bld = new StrBuilder(replaceTemplate);\n             assertFalse(sub.replaceIn(bld));\n             assertEquals(replaceTemplate, bld.toString());\n         }\n--- a/src/test/java/org/apache/commons/lang3/text/StrTokenizerTest.java\n+++ b/src/test/java/org/apache/commons/lang3/text/StrTokenizerTest.java\n     @Test\n     public void test1() {\n \n-        String input = \"a;b;c;\\\"d;\\\"\\\"e\\\";f; ; ;  \";\n-        StrTokenizer tok = new StrTokenizer(input);\n+        final String input = \"a;b;c;\\\"d;\\\"\\\"e\\\";f; ; ;  \";\n+        final StrTokenizer tok = new StrTokenizer(input);\n         tok.setDelimiterChar(';');\n         tok.setQuoteChar('\"');\n         tok.setIgnoredMatcher(StrMatcher.trimMatcher());\n         tok.setIgnoreEmptyTokens(false);\n-        String tokens[] = tok.getTokenArray();\n-\n-        String expected[] = new String[]{\"a\", \"b\", \"c\", \"d;\\\"e\", \"f\", \"\", \"\", \"\",};\n+        final String tokens[] = tok.getTokenArray();\n+\n+        final String expected[] = new String[]{\"a\", \"b\", \"c\", \"d;\\\"e\", \"f\", \"\", \"\", \"\",};\n \n         assertEquals(ArrayUtils.toString(tokens), expected.length, tokens.length);\n         for (int i = 0; i < expected.length; i++) {\n     @Test\n     public void test2() {\n \n-        String input = \"a;b;c ;\\\"d;\\\"\\\"e\\\";f; ; ;\";\n-        StrTokenizer tok = new StrTokenizer(input);\n+        final String input = \"a;b;c ;\\\"d;\\\"\\\"e\\\";f; ; ;\";\n+        final StrTokenizer tok = new StrTokenizer(input);\n         tok.setDelimiterChar(';');\n         tok.setQuoteChar('\"');\n         tok.setIgnoredMatcher(StrMatcher.noneMatcher());\n         tok.setIgnoreEmptyTokens(false);\n-        String tokens[] = tok.getTokenArray();\n-\n-        String expected[] = new String[]{\"a\", \"b\", \"c \", \"d;\\\"e\", \"f\", \" \", \" \", \"\",};\n+        final String tokens[] = tok.getTokenArray();\n+\n+        final String expected[] = new String[]{\"a\", \"b\", \"c \", \"d;\\\"e\", \"f\", \" \", \" \", \"\",};\n \n         assertEquals(ArrayUtils.toString(tokens), expected.length, tokens.length);\n         for (int i = 0; i < expected.length; i++) {\n     @Test\n     public void test3() {\n \n-        String input = \"a;b; c;\\\"d;\\\"\\\"e\\\";f; ; ;\";\n-        StrTokenizer tok = new StrTokenizer(input);\n+        final String input = \"a;b; c;\\\"d;\\\"\\\"e\\\";f; ; ;\";\n+        final StrTokenizer tok = new StrTokenizer(input);\n         tok.setDelimiterChar(';');\n         tok.setQuoteChar('\"');\n         tok.setIgnoredMatcher(StrMatcher.noneMatcher());\n         tok.setIgnoreEmptyTokens(false);\n-        String tokens[] = tok.getTokenArray();\n-\n-        String expected[] = new String[]{\"a\", \"b\", \" c\", \"d;\\\"e\", \"f\", \" \", \" \", \"\",};\n+        final String tokens[] = tok.getTokenArray();\n+\n+        final String expected[] = new String[]{\"a\", \"b\", \" c\", \"d;\\\"e\", \"f\", \" \", \" \", \"\",};\n \n         assertEquals(ArrayUtils.toString(tokens), expected.length, tokens.length);\n         for (int i = 0; i < expected.length; i++) {\n     @Test\n     public void test4() {\n \n-        String input = \"a;b; c;\\\"d;\\\"\\\"e\\\";f; ; ;\";\n-        StrTokenizer tok = new StrTokenizer(input);\n+        final String input = \"a;b; c;\\\"d;\\\"\\\"e\\\";f; ; ;\";\n+        final StrTokenizer tok = new StrTokenizer(input);\n         tok.setDelimiterChar(';');\n         tok.setQuoteChar('\"');\n         tok.setIgnoredMatcher(StrMatcher.trimMatcher());\n         tok.setIgnoreEmptyTokens(true);\n-        String tokens[] = tok.getTokenArray();\n-\n-        String expected[] = new String[]{\"a\", \"b\", \"c\", \"d;\\\"e\", \"f\",};\n+        final String tokens[] = tok.getTokenArray();\n+\n+        final String expected[] = new String[]{\"a\", \"b\", \"c\", \"d;\\\"e\", \"f\",};\n \n         assertEquals(ArrayUtils.toString(tokens), expected.length, tokens.length);\n         for (int i = 0; i < expected.length; i++) {\n     @Test\n     public void test5() {\n \n-        String input = \"a;b; c;\\\"d;\\\"\\\"e\\\";f; ; ;\";\n-        StrTokenizer tok = new StrTokenizer(input);\n+        final String input = \"a;b; c;\\\"d;\\\"\\\"e\\\";f; ; ;\";\n+        final StrTokenizer tok = new StrTokenizer(input);\n         tok.setDelimiterChar(';');\n         tok.setQuoteChar('\"');\n         tok.setIgnoredMatcher(StrMatcher.trimMatcher());\n         tok.setIgnoreEmptyTokens(false);\n         tok.setEmptyTokenAsNull(true);\n-        String tokens[] = tok.getTokenArray();\n-\n-        String expected[] = new String[]{\"a\", \"b\", \"c\", \"d;\\\"e\", \"f\", null, null, null,};\n+        final String tokens[] = tok.getTokenArray();\n+\n+        final String expected[] = new String[]{\"a\", \"b\", \"c\", \"d;\\\"e\", \"f\", null, null, null,};\n \n         assertEquals(ArrayUtils.toString(tokens), expected.length, tokens.length);\n         for (int i = 0; i < expected.length; i++) {\n     @Test\n     public void test6() {\n \n-        String input = \"a;b; c;\\\"d;\\\"\\\"e\\\";f; ; ;\";\n-        StrTokenizer tok = new StrTokenizer(input);\n+        final String input = \"a;b; c;\\\"d;\\\"\\\"e\\\";f; ; ;\";\n+        final StrTokenizer tok = new StrTokenizer(input);\n         tok.setDelimiterChar(';');\n         tok.setQuoteChar('\"');\n         tok.setIgnoredMatcher(StrMatcher.trimMatcher());\n         tok.setIgnoreEmptyTokens(false);\n         // tok.setTreatingEmptyAsNull(true);\n-        String tokens[] = tok.getTokenArray();\n-\n-        String expected[] = new String[]{\"a\", \"b\", \" c\", \"d;\\\"e\", \"f\", null, null, null,};\n+        final String tokens[] = tok.getTokenArray();\n+\n+        final String expected[] = new String[]{\"a\", \"b\", \" c\", \"d;\\\"e\", \"f\", null, null, null,};\n \n         int nextCount = 0;\n         while (tok.hasNext()) {\n     @Test\n     public void test7() {\n \n-        String input = \"a   b c \\\"d e\\\" f \";\n-        StrTokenizer tok = new StrTokenizer(input);\n+        final String input = \"a   b c \\\"d e\\\" f \";\n+        final StrTokenizer tok = new StrTokenizer(input);\n         tok.setDelimiterMatcher(StrMatcher.spaceMatcher());\n         tok.setQuoteMatcher(StrMatcher.doubleQuoteMatcher());\n         tok.setIgnoredMatcher(StrMatcher.noneMatcher());\n         tok.setIgnoreEmptyTokens(false);\n-        String tokens[] = tok.getTokenArray();\n-\n-        String expected[] = new String[]{\"a\", \"\", \"\", \"b\", \"c\", \"d e\", \"f\", \"\",};\n+        final String tokens[] = tok.getTokenArray();\n+\n+        final String expected[] = new String[]{\"a\", \"\", \"\", \"b\", \"c\", \"d e\", \"f\", \"\",};\n \n         assertEquals(ArrayUtils.toString(tokens), expected.length, tokens.length);\n         for (int i = 0; i < expected.length; i++) {\n     @Test\n     public void test8() {\n \n-        String input = \"a   b c \\\"d e\\\" f \";\n-        StrTokenizer tok = new StrTokenizer(input);\n+        final String input = \"a   b c \\\"d e\\\" f \";\n+        final StrTokenizer tok = new StrTokenizer(input);\n         tok.setDelimiterMatcher(StrMatcher.spaceMatcher());\n         tok.setQuoteMatcher(StrMatcher.doubleQuoteMatcher());\n         tok.setIgnoredMatcher(StrMatcher.noneMatcher());\n         tok.setIgnoreEmptyTokens(true);\n-        String tokens[] = tok.getTokenArray();\n-\n-        String expected[] = new String[]{\"a\", \"b\", \"c\", \"d e\", \"f\",};\n+        final String tokens[] = tok.getTokenArray();\n+\n+        final String expected[] = new String[]{\"a\", \"b\", \"c\", \"d e\", \"f\",};\n \n         assertEquals(ArrayUtils.toString(tokens), expected.length, tokens.length);\n         for (int i = 0; i < expected.length; i++) {\n \n     @Test\n     public void testBasic1() {\n-        String input = \"a  b c\";\n-        StrTokenizer tok = new StrTokenizer(input);\n+        final String input = \"a  b c\";\n+        final StrTokenizer tok = new StrTokenizer(input);\n         assertEquals(\"a\", tok.next());\n         assertEquals(\"b\", tok.next());\n         assertEquals(\"c\", tok.next());\n \n     @Test\n     public void testBasic2() {\n-        String input = \"a \\nb\\fc\";\n-        StrTokenizer tok = new StrTokenizer(input);\n+        final String input = \"a \\nb\\fc\";\n+        final StrTokenizer tok = new StrTokenizer(input);\n         assertEquals(\"a\", tok.next());\n         assertEquals(\"b\", tok.next());\n         assertEquals(\"c\", tok.next());\n \n     @Test\n     public void testBasic3() {\n-        String input = \"a \\nb\\u0001\\fc\";\n-        StrTokenizer tok = new StrTokenizer(input);\n+        final String input = \"a \\nb\\u0001\\fc\";\n+        final StrTokenizer tok = new StrTokenizer(input);\n         assertEquals(\"a\", tok.next());\n         assertEquals(\"b\\u0001\", tok.next());\n         assertEquals(\"c\", tok.next());\n \n     @Test\n     public void testBasic4() {\n-        String input = \"a \\\"b\\\" c\";\n-        StrTokenizer tok = new StrTokenizer(input);\n+        final String input = \"a \\\"b\\\" c\";\n+        final StrTokenizer tok = new StrTokenizer(input);\n         assertEquals(\"a\", tok.next());\n         assertEquals(\"\\\"b\\\"\", tok.next());\n         assertEquals(\"c\", tok.next());\n \n     @Test\n     public void testBasic5() {\n-        String input = \"a:b':c\";\n-        StrTokenizer tok = new StrTokenizer(input, ':', '\\'');\n+        final String input = \"a:b':c\";\n+        final StrTokenizer tok = new StrTokenizer(input, ':', '\\'');\n         assertEquals(\"a\", tok.next());\n         assertEquals(\"b'\", tok.next());\n         assertEquals(\"c\", tok.next());\n \n     @Test\n     public void testBasicDelim1() {\n-        String input = \"a:b:c\";\n-        StrTokenizer tok = new StrTokenizer(input, ':');\n+        final String input = \"a:b:c\";\n+        final StrTokenizer tok = new StrTokenizer(input, ':');\n         assertEquals(\"a\", tok.next());\n         assertEquals(\"b\", tok.next());\n         assertEquals(\"c\", tok.next());\n \n     @Test\n     public void testBasicDelim2() {\n-        String input = \"a:b:c\";\n-        StrTokenizer tok = new StrTokenizer(input, ',');\n+        final String input = \"a:b:c\";\n+        final StrTokenizer tok = new StrTokenizer(input, ',');\n         assertEquals(\"a:b:c\", tok.next());\n         assertFalse(tok.hasNext());\n     }\n \n     @Test\n     public void testBasicEmpty1() {\n-        String input = \"a  b c\";\n-        StrTokenizer tok = new StrTokenizer(input);\n+        final String input = \"a  b c\";\n+        final StrTokenizer tok = new StrTokenizer(input);\n         tok.setIgnoreEmptyTokens(false);\n         assertEquals(\"a\", tok.next());\n         assertEquals(\"\", tok.next());\n \n     @Test\n     public void testBasicEmpty2() {\n-        String input = \"a  b c\";\n-        StrTokenizer tok = new StrTokenizer(input);\n+        final String input = \"a  b c\";\n+        final StrTokenizer tok = new StrTokenizer(input);\n         tok.setIgnoreEmptyTokens(false);\n         tok.setEmptyTokenAsNull(true);\n         assertEquals(\"a\", tok.next());\n \n     @Test\n     public void testBasicQuoted1() {\n-        String input = \"a 'b' c\";\n-        StrTokenizer tok = new StrTokenizer(input, ' ', '\\'');\n+        final String input = \"a 'b' c\";\n+        final StrTokenizer tok = new StrTokenizer(input, ' ', '\\'');\n         assertEquals(\"a\", tok.next());\n         assertEquals(\"b\", tok.next());\n         assertEquals(\"c\", tok.next());\n \n     @Test\n     public void testBasicQuoted2() {\n-        String input = \"a:'b':\";\n-        StrTokenizer tok = new StrTokenizer(input, ':', '\\'');\n+        final String input = \"a:'b':\";\n+        final StrTokenizer tok = new StrTokenizer(input, ':', '\\'');\n         tok.setIgnoreEmptyTokens(false);\n         tok.setEmptyTokenAsNull(true);\n         assertEquals(\"a\", tok.next());\n \n     @Test\n     public void testBasicQuoted3() {\n-        String input = \"a:'b''c'\";\n-        StrTokenizer tok = new StrTokenizer(input, ':', '\\'');\n+        final String input = \"a:'b''c'\";\n+        final StrTokenizer tok = new StrTokenizer(input, ':', '\\'');\n         tok.setIgnoreEmptyTokens(false);\n         tok.setEmptyTokenAsNull(true);\n         assertEquals(\"a\", tok.next());\n \n     @Test\n     public void testBasicQuoted4() {\n-        String input = \"a: 'b' 'c' :d\";\n-        StrTokenizer tok = new StrTokenizer(input, ':', '\\'');\n+        final String input = \"a: 'b' 'c' :d\";\n+        final StrTokenizer tok = new StrTokenizer(input, ':', '\\'');\n         tok.setTrimmerMatcher(StrMatcher.trimMatcher());\n         tok.setIgnoreEmptyTokens(false);\n         tok.setEmptyTokenAsNull(true);\n \n     @Test\n     public void testBasicQuoted5() {\n-        String input = \"a: 'b'x'c' :d\";\n-        StrTokenizer tok = new StrTokenizer(input, ':', '\\'');\n+        final String input = \"a: 'b'x'c' :d\";\n+        final StrTokenizer tok = new StrTokenizer(input, ':', '\\'');\n         tok.setTrimmerMatcher(StrMatcher.trimMatcher());\n         tok.setIgnoreEmptyTokens(false);\n         tok.setEmptyTokenAsNull(true);\n \n     @Test\n     public void testBasicQuoted6() {\n-        String input = \"a:'b'\\\"c':d\";\n-        StrTokenizer tok = new StrTokenizer(input, ':');\n+        final String input = \"a:'b'\\\"c':d\";\n+        final StrTokenizer tok = new StrTokenizer(input, ':');\n         tok.setQuoteMatcher(StrMatcher.quoteMatcher());\n         assertEquals(\"a\", tok.next());\n         assertEquals(\"b\\\"c:d\", tok.next());\n \n     @Test\n     public void testBasicQuoted7() {\n-        String input = \"a:\\\"There's a reason here\\\":b\";\n-        StrTokenizer tok = new StrTokenizer(input, ':');\n+        final String input = \"a:\\\"There's a reason here\\\":b\";\n+        final StrTokenizer tok = new StrTokenizer(input, ':');\n         tok.setQuoteMatcher(StrMatcher.quoteMatcher());\n         assertEquals(\"a\", tok.next());\n         assertEquals(\"There's a reason here\", tok.next());\n \n     @Test\n     public void testBasicQuotedTrimmed1() {\n-        String input = \"a: 'b' :\";\n-        StrTokenizer tok = new StrTokenizer(input, ':', '\\'');\n+        final String input = \"a: 'b' :\";\n+        final StrTokenizer tok = new StrTokenizer(input, ':', '\\'');\n         tok.setTrimmerMatcher(StrMatcher.trimMatcher());\n         tok.setIgnoreEmptyTokens(false);\n         tok.setEmptyTokenAsNull(true);\n \n     @Test\n     public void testBasicTrimmed1() {\n-        String input = \"a: b :  \";\n-        StrTokenizer tok = new StrTokenizer(input, ':');\n+        final String input = \"a: b :  \";\n+        final StrTokenizer tok = new StrTokenizer(input, ':');\n         tok.setTrimmerMatcher(StrMatcher.trimMatcher());\n         tok.setIgnoreEmptyTokens(false);\n         tok.setEmptyTokenAsNull(true);\n \n     @Test\n     public void testBasicTrimmed2() {\n-        String input = \"a:  b  :\";\n-        StrTokenizer tok = new StrTokenizer(input, ':');\n+        final String input = \"a:  b  :\";\n+        final StrTokenizer tok = new StrTokenizer(input, ':');\n         tok.setTrimmerMatcher(StrMatcher.stringMatcher(\"  \"));\n         tok.setIgnoreEmptyTokens(false);\n         tok.setEmptyTokenAsNull(true);\n \n     @Test\n     public void testBasicIgnoreTrimmed1() {\n-        String input = \"a: bIGNOREc : \";\n-        StrTokenizer tok = new StrTokenizer(input, ':');\n+        final String input = \"a: bIGNOREc : \";\n+        final StrTokenizer tok = new StrTokenizer(input, ':');\n         tok.setIgnoredMatcher(StrMatcher.stringMatcher(\"IGNORE\"));\n         tok.setTrimmerMatcher(StrMatcher.trimMatcher());\n         tok.setIgnoreEmptyTokens(false);\n \n     @Test\n     public void testBasicIgnoreTrimmed2() {\n-        String input = \"IGNOREaIGNORE: IGNORE bIGNOREc IGNORE : IGNORE \";\n-        StrTokenizer tok = new StrTokenizer(input, ':');\n+        final String input = \"IGNOREaIGNORE: IGNORE bIGNOREc IGNORE : IGNORE \";\n+        final StrTokenizer tok = new StrTokenizer(input, ':');\n         tok.setIgnoredMatcher(StrMatcher.stringMatcher(\"IGNORE\"));\n         tok.setTrimmerMatcher(StrMatcher.trimMatcher());\n         tok.setIgnoreEmptyTokens(false);\n \n     @Test\n     public void testBasicIgnoreTrimmed3() {\n-        String input = \"IGNOREaIGNORE: IGNORE bIGNOREc IGNORE : IGNORE \";\n-        StrTokenizer tok = new StrTokenizer(input, ':');\n+        final String input = \"IGNOREaIGNORE: IGNORE bIGNOREc IGNORE : IGNORE \";\n+        final StrTokenizer tok = new StrTokenizer(input, ':');\n         tok.setIgnoredMatcher(StrMatcher.stringMatcher(\"IGNORE\"));\n         tok.setIgnoreEmptyTokens(false);\n         tok.setEmptyTokenAsNull(true);\n \n     @Test\n     public void testBasicIgnoreTrimmed4() {\n-        String input = \"IGNOREaIGNORE: IGNORE 'bIGNOREc'IGNORE'd' IGNORE : IGNORE \";\n-        StrTokenizer tok = new StrTokenizer(input, ':', '\\'');\n+        final String input = \"IGNOREaIGNORE: IGNORE 'bIGNOREc'IGNORE'd' IGNORE : IGNORE \";\n+        final StrTokenizer tok = new StrTokenizer(input, ':', '\\'');\n         tok.setIgnoredMatcher(StrMatcher.stringMatcher(\"IGNORE\"));\n         tok.setTrimmerMatcher(StrMatcher.trimMatcher());\n         tok.setIgnoreEmptyTokens(false);\n     //-----------------------------------------------------------------------\n     @Test\n     public void testListArray() {\n-        String input = \"a  b c\";\n-        StrTokenizer tok = new StrTokenizer(input);\n-        String[] array = tok.getTokenArray();\n-        List<?> list = tok.getTokenList();\n+        final String input = \"a  b c\";\n+        final StrTokenizer tok = new StrTokenizer(input);\n+        final String[] array = tok.getTokenArray();\n+        final List<?> list = tok.getTokenList();\n         \n         assertEquals(Arrays.asList(array), list);\n         assertEquals(3, list.size());\n         try {\n             tokenizer.next();\n             fail();\n-        } catch (NoSuchElementException ex) {}\n+        } catch (final NoSuchElementException ex) {}\n     }\n \n     @Test\n     public void testGetContent() {\n-        String input = \"a   b c \\\"d e\\\" f \";\n+        final String input = \"a   b c \\\"d e\\\" f \";\n         StrTokenizer tok = new StrTokenizer(input);\n         assertEquals(input, tok.getContent());\n \n     //-----------------------------------------------------------------------\n     @Test\n     public void testChaining() {\n-        StrTokenizer tok = new StrTokenizer();\n+        final StrTokenizer tok = new StrTokenizer();\n         assertEquals(tok, tok.reset());\n         assertEquals(tok, tok.reset(\"\"));\n         assertEquals(tok, tok.reset(new char[0]));\n      */\n     @Test\n     public void testCloneNotSupportedException() {\n-        Object notCloned = new StrTokenizer() {\n+        final Object notCloned = new StrTokenizer() {\n             @Override\n             Object cloneReset() throws CloneNotSupportedException {\n                 throw new CloneNotSupportedException(\"test\");\n \n     @Test\n     public void testCloneNull() {\n-        StrTokenizer tokenizer = new StrTokenizer((char[]) null);\n+        final StrTokenizer tokenizer = new StrTokenizer((char[]) null);\n         // Start sanity check\n         assertEquals(null, tokenizer.nextToken());\n         tokenizer.reset();\n         assertEquals(null, tokenizer.nextToken());\n         // End sanity check\n-        StrTokenizer clonedTokenizer = (StrTokenizer) tokenizer.clone();\n+        final StrTokenizer clonedTokenizer = (StrTokenizer) tokenizer.clone();\n         tokenizer.reset();\n         assertEquals(null, tokenizer.nextToken());\n         assertEquals(null, clonedTokenizer.nextToken());\n \n     @Test\n     public void testCloneReset() {\n-        char[] input = new char[]{'a'};\n-        StrTokenizer tokenizer = new StrTokenizer(input);\n+        final char[] input = new char[]{'a'};\n+        final StrTokenizer tokenizer = new StrTokenizer(input);\n         // Start sanity check\n         assertEquals(\"a\", tokenizer.nextToken());\n         tokenizer.reset(input);\n         assertEquals(\"a\", tokenizer.nextToken());\n         // End sanity check\n-        StrTokenizer clonedTokenizer = (StrTokenizer) tokenizer.clone();\n+        final StrTokenizer clonedTokenizer = (StrTokenizer) tokenizer.clone();\n         input[0] = 'b';\n         tokenizer.reset(input);\n         assertEquals(\"b\", tokenizer.nextToken());\n     //-----------------------------------------------------------------------\n     @Test\n     public void testReset() {\n-        StrTokenizer tok = new StrTokenizer(\"a b c\");\n+        final StrTokenizer tok = new StrTokenizer(\"a b c\");\n         assertEquals(\"a\", tok.next());\n         assertEquals(\"b\", tok.next());\n         assertEquals(\"c\", tok.next());\n     //-----------------------------------------------------------------------\n     @Test\n     public void testReset_String() {\n-        StrTokenizer tok = new StrTokenizer(\"x x x\");\n+        final StrTokenizer tok = new StrTokenizer(\"x x x\");\n         tok.reset(\"d e\");\n         assertEquals(\"d\", tok.next());\n         assertEquals(\"e\", tok.next());\n     //-----------------------------------------------------------------------\n     @Test\n     public void testReset_charArray() {\n-        StrTokenizer tok = new StrTokenizer(\"x x x\");\n-        \n-        char[] array = new char[] {'a', 'b', 'c'};\n+        final StrTokenizer tok = new StrTokenizer(\"x x x\");\n+        \n+        final char[] array = new char[] {'a', 'b', 'c'};\n         tok.reset(array);\n         assertEquals(\"abc\", tok.next());\n         assertFalse(tok.hasNext());\n \n     @Test\n     public void testIteration() {\n-        StrTokenizer tkn = new StrTokenizer(\"a b c\");\n+        final StrTokenizer tkn = new StrTokenizer(\"a b c\");\n         assertFalse(tkn.hasPrevious());\n         try {\n             tkn.previous();\n             fail();\n-        } catch (NoSuchElementException ex) {}\n+        } catch (final NoSuchElementException ex) {}\n         assertTrue(tkn.hasNext());\n         \n         assertEquals(\"a\", tkn.next());\n         try {\n             tkn.remove();\n             fail();\n-        } catch (UnsupportedOperationException ex) {}\n+        } catch (final UnsupportedOperationException ex) {}\n         try {\n             tkn.set(\"x\");\n             fail();\n-        } catch (UnsupportedOperationException ex) {}\n+        } catch (final UnsupportedOperationException ex) {}\n         try {\n             tkn.add(\"y\");\n             fail();\n-        } catch (UnsupportedOperationException ex) {}\n+        } catch (final UnsupportedOperationException ex) {}\n         assertTrue(tkn.hasPrevious());\n         assertTrue(tkn.hasNext());\n         \n         try {\n             tkn.next();\n             fail();\n-        } catch (NoSuchElementException ex) {}\n+        } catch (final NoSuchElementException ex) {}\n         assertTrue(tkn.hasPrevious());\n         assertFalse(tkn.hasNext());\n     }\n     //-----------------------------------------------------------------------\n     @Test\n     public void testTokenizeSubclassInputChange() {\n-        StrTokenizer tkn = new StrTokenizer(\"a b c d e\") {\n+        final StrTokenizer tkn = new StrTokenizer(\"a b c d e\") {\n             @Override\n             protected List<String> tokenize(final char[] chars, final int offset, final int count) {\n                 return super.tokenize(\"w x y z\".toCharArray(), 2, 5);\n     //-----------------------------------------------------------------------\n     @Test\n     public void testTokenizeSubclassOutputChange() {\n-        StrTokenizer tkn = new StrTokenizer(\"a b c\") {\n+        final StrTokenizer tkn = new StrTokenizer(\"a b c\") {\n             @Override\n             protected List<String> tokenize(final char[] chars, final int offset, final int count) {\n-                List<String> list = super.tokenize(chars, offset, count);\n+                final List<String> list = super.tokenize(chars, offset, count);\n                 Collections.reverse(list);\n                 return list;\n             }\n     //-----------------------------------------------------------------------\n     @Test\n     public void testToString() {\n-        StrTokenizer tkn = new StrTokenizer(\"a b c d e\");\n+        final StrTokenizer tkn = new StrTokenizer(\"a b c d e\");\n         assertEquals(\"StrTokenizer[not tokenized yet]\", tkn.toString());\n         tkn.next();\n         assertEquals(\"StrTokenizer[a, b, c, d, e]\", tkn.toString());\n--- a/src/test/java/org/apache/commons/lang3/text/WordUtilsTest.java\n+++ b/src/test/java/org/apache/commons/lang3/text/WordUtilsTest.java\n     @Test\n     public void testConstructor() {\n         assertNotNull(new WordUtils());\n-        Constructor<?>[] cons = WordUtils.class.getDeclaredConstructors();\n+        final Constructor<?>[] cons = WordUtils.class.getDeclaredConstructors();\n         assertEquals(1, cons.length);\n         assertTrue(Modifier.isPublic(cons[0].getModifiers()));\n         assertTrue(Modifier.isPublic(WordUtils.class.getModifiers()));\n         assertEquals(\"\", WordUtils.wrap(\"\", -1));\n         \n         // normal\n-        String systemNewLine = System.getProperty(\"line.separator\");\n+        final String systemNewLine = System.getProperty(\"line.separator\");\n         String input = \"Here is one line of text that is going to be wrapped after 20 columns.\";\n         String expected = \"Here is one line of\" + systemNewLine + \"text that is going\" \n             + systemNewLine + \"to be wrapped after\" + systemNewLine + \"20 columns.\";\n         assertEquals(expected, WordUtils.wrap(input, -1, \"\\n\", false));\n \n         // system newline char\n-        String systemNewLine = System.getProperty(\"line.separator\");\n+        final String systemNewLine = System.getProperty(\"line.separator\");\n         input = \"Here is one line of text that is going to be wrapped after 20 columns.\";\n         expected = \"Here is one line of\" + systemNewLine + \"text that is going\" + systemNewLine \n             + \"to be wrapped after\" + systemNewLine + \"20 columns.\";\n         assertEquals(\"I AM here 123\", WordUtils.swapCase(\"i am HERE 123\") );\n         assertEquals(\"i am here 123\", WordUtils.swapCase(\"I AM HERE 123\") );\n \n-        String test = \"This String contains a TitleCase character: \\u01C8\";\n-        String expect = \"tHIS sTRING CONTAINS A tITLEcASE CHARACTER: \\u01C9\";\n+        final String test = \"This String contains a TitleCase character: \\u01C8\";\n+        final String expect = \"tHIS sTRING CONTAINS A tITLEcASE CHARACTER: \\u01C9\";\n         assertEquals(expect, WordUtils.swapCase(test));\n     }\n \n--- a/src/test/java/org/apache/commons/lang3/text/translate/EntityArraysTest.java\n+++ b/src/test/java/org/apache/commons/lang3/text/translate/EntityArraysTest.java\n     // LANG-659 - check arrays for duplicate entries\n     @Test\n     public void testHTML40_EXTENDED_ESCAPE(){\n-        Set<String> col0 = new HashSet<String>();\n-        Set<String> col1 = new HashSet<String>();\n-        String [][] sa = EntityArrays.HTML40_EXTENDED_ESCAPE();\n+        final Set<String> col0 = new HashSet<String>();\n+        final Set<String> col1 = new HashSet<String>();\n+        final String [][] sa = EntityArrays.HTML40_EXTENDED_ESCAPE();\n         for(int i =0; i <sa.length; i++){\n             assertTrue(\"Already added entry 0: \"+i+\" \"+sa[i][0],col0.add(sa[i][0]));\n             assertTrue(\"Already added entry 1: \"+i+\" \"+sa[i][1],col1.add(sa[i][1]));\n    // LANG-658 - check arrays for duplicate entries\n     @Test\n     public void testISO8859_1_ESCAPE(){\n-        Set<String> col0 = new HashSet<String>();\n-        Set<String> col1 = new HashSet<String>();\n-        String [][] sa = EntityArrays.ISO8859_1_ESCAPE();\n+        final Set<String> col0 = new HashSet<String>();\n+        final Set<String> col1 = new HashSet<String>();\n+        final String [][] sa = EntityArrays.ISO8859_1_ESCAPE();\n         boolean success = true;\n         for(int i =0; i <sa.length; i++){\n-            boolean add0 = col0.add(sa[i][0]);\n-            boolean add1 = col1.add(sa[i][1]);\n+            final boolean add0 = col0.add(sa[i][0]);\n+            final boolean add1 = col1.add(sa[i][1]);\n             if (!add0) { \n                 success = false;\n                 System.out.println(\"Already added entry 0: \"+i+\" \"+sa[i][0]+\" \"+sa[i][1]);\n--- a/src/test/java/org/apache/commons/lang3/text/translate/LookupTranslatorTest.java\n+++ b/src/test/java/org/apache/commons/lang3/text/translate/LookupTranslatorTest.java\n \n     @Test\n     public void testBasicLookup() throws IOException {\n-        LookupTranslator lt = new LookupTranslator(new CharSequence[][] { { \"one\", \"two\" } });\n-        StringWriter out = new StringWriter();\n-        int result = lt.translate(\"one\", 0, out);\n+        final LookupTranslator lt = new LookupTranslator(new CharSequence[][] { { \"one\", \"two\" } });\n+        final StringWriter out = new StringWriter();\n+        final int result = lt.translate(\"one\", 0, out);\n         assertEquals(\"Incorrect codepoint consumption\", 3, result);\n         assertEquals(\"Incorrect value\", \"two\", out.toString());\n     }\n--- a/src/test/java/org/apache/commons/lang3/text/translate/NumericEntityEscaperTest.java\n+++ b/src/test/java/org/apache/commons/lang3/text/translate/NumericEntityEscaperTest.java\n \n     @Test\n     public void testBelow() {\n-        NumericEntityEscaper nee = NumericEntityEscaper.below('F');\n+        final NumericEntityEscaper nee = NumericEntityEscaper.below('F');\n \n-        String input = \"ADFGZ\";\n-        String result = nee.translate(input);\n+        final String input = \"ADFGZ\";\n+        final String result = nee.translate(input);\n         assertEquals(\"Failed to escape numeric entities via the below method\", \"&#65;&#68;FGZ\", result);\n     }\n \n     @Test\n     public void testBetween() {\n-        NumericEntityEscaper nee = NumericEntityEscaper.between('F', 'L');\n+        final NumericEntityEscaper nee = NumericEntityEscaper.between('F', 'L');\n \n-        String input = \"ADFGZ\";\n-        String result = nee.translate(input);\n+        final String input = \"ADFGZ\";\n+        final String result = nee.translate(input);\n         assertEquals(\"Failed to escape numeric entities via the between method\", \"AD&#70;&#71;Z\", result);\n     }\n \n     @Test\n     public void testAbove() {\n-        NumericEntityEscaper nee = NumericEntityEscaper.above('F');\n+        final NumericEntityEscaper nee = NumericEntityEscaper.above('F');\n \n-        String input = \"ADFGZ\";\n-        String result = nee.translate(input);\n+        final String input = \"ADFGZ\";\n+        final String result = nee.translate(input);\n         assertEquals(\"Failed to escape numeric entities via the above method\", \"ADF&#71;&#90;\", result);\n     }\n \n     // See LANG-617\n     @Test\n     public void testSupplementary() {\n-        NumericEntityEscaper nee = new NumericEntityEscaper();\n-        String input = \"\\uD803\\uDC22\";\n-        String expected = \"&#68642;\";\n+        final NumericEntityEscaper nee = new NumericEntityEscaper();\n+        final String input = \"\\uD803\\uDC22\";\n+        final String expected = \"&#68642;\";\n \n-        String result = nee.translate(input);\n+        final String result = nee.translate(input);\n         assertEquals(\"Failed to escape numeric entities supplementary characters\", expected, result);\n \n     }\n--- a/src/test/java/org/apache/commons/lang3/text/translate/NumericEntityUnescaperTest.java\n+++ b/src/test/java/org/apache/commons/lang3/text/translate/NumericEntityUnescaperTest.java\n \n     @Test\n     public void testSupplementaryUnescaping() {\n-        NumericEntityUnescaper neu = new NumericEntityUnescaper();\n-        String input = \"&#68642;\";\n-        String expected = \"\\uD803\\uDC22\";\n+        final NumericEntityUnescaper neu = new NumericEntityUnescaper();\n+        final String input = \"&#68642;\";\n+        final String expected = \"\\uD803\\uDC22\";\n \n-        String result = neu.translate(input);\n+        final String result = neu.translate(input);\n         assertEquals(\"Failed to unescape numeric entities supplementary characters\", expected, result);\n     }\n \n     @Test\n     public void testOutOfBounds() {\n-        NumericEntityUnescaper neu = new NumericEntityUnescaper();\n+        final NumericEntityUnescaper neu = new NumericEntityUnescaper();\n \n         assertEquals(\"Failed to ignore when last character is &\", \"Test &\", neu.translate(\"Test &\"));\n         assertEquals(\"Failed to ignore when last character is &\", \"Test &#\", neu.translate(\"Test &#\"));\n         try {\n             result = neu.translate(input);\n             fail(\"IllegalArgumentException expected\");\n-        } catch(IllegalArgumentException iae) {\n+        } catch(final IllegalArgumentException iae) {\n             // expected\n         }\n     }\n--- a/src/test/java/org/apache/commons/lang3/text/translate/OctalUnescaperTest.java\n+++ b/src/test/java/org/apache/commons/lang3/text/translate/OctalUnescaperTest.java\n \n     @Test\n     public void testBetween() {\n-        OctalUnescaper oue = new OctalUnescaper();   //.between(\"1\", \"377\");\n+        final OctalUnescaper oue = new OctalUnescaper();   //.between(\"1\", \"377\");\n \n         String input = \"\\\\45\";\n         String result = oue.translate(input);\n--- a/src/test/java/org/apache/commons/lang3/text/translate/UnicodeEscaperTest.java\n+++ b/src/test/java/org/apache/commons/lang3/text/translate/UnicodeEscaperTest.java\n \n     @Test\n     public void testBelow() {\n-        UnicodeEscaper ue = UnicodeEscaper.below('F');\n+        final UnicodeEscaper ue = UnicodeEscaper.below('F');\n \n-        String input = \"ADFGZ\";\n-        String result = ue.translate(input);\n+        final String input = \"ADFGZ\";\n+        final String result = ue.translate(input);\n         assertEquals(\"Failed to escape Unicode characters via the below method\", \"\\\\u0041\\\\u0044FGZ\", result);\n     }\n \n     @Test\n     public void testBetween() {\n-        UnicodeEscaper ue = UnicodeEscaper.between('F', 'L');\n+        final UnicodeEscaper ue = UnicodeEscaper.between('F', 'L');\n \n-        String input = \"ADFGZ\";\n-        String result = ue.translate(input);\n+        final String input = \"ADFGZ\";\n+        final String result = ue.translate(input);\n         assertEquals(\"Failed to escape Unicode characters via the between method\", \"AD\\\\u0046\\\\u0047Z\", result);\n     }\n \n     @Test\n     public void testAbove() {\n-        UnicodeEscaper ue = UnicodeEscaper.above('F');\n+        final UnicodeEscaper ue = UnicodeEscaper.above('F');\n \n-        String input = \"ADFGZ\";\n-        String result = ue.translate(input);\n+        final String input = \"ADFGZ\";\n+        final String result = ue.translate(input);\n         assertEquals(\"Failed to escape Unicode characters via the above method\", \"ADF\\\\u0047\\\\u005A\", result);\n     }\n }\n--- a/src/test/java/org/apache/commons/lang3/text/translate/UnicodeUnescaperTest.java\n+++ b/src/test/java/org/apache/commons/lang3/text/translate/UnicodeUnescaperTest.java\n     // Requested in LANG-507\n     @Test\n     public void testUPlus() {\n-        UnicodeUnescaper uu = new UnicodeUnescaper();\n+        final UnicodeUnescaper uu = new UnicodeUnescaper();\n \n-        String input = \"\\\\u+0047\";\n+        final String input = \"\\\\u+0047\";\n         assertEquals(\"Failed to unescape Unicode characters with 'u+' notation\", \"G\", uu.translate(input));\n     }\n \n     @Test\n     public void testUuuuu() {\n-        UnicodeUnescaper uu = new UnicodeUnescaper();\n+        final UnicodeUnescaper uu = new UnicodeUnescaper();\n \n-        String input = \"\\\\uuuuuuuu0047\";\n-        String result = uu.translate(input);\n+        final String input = \"\\\\uuuuuuuu0047\";\n+        final String result = uu.translate(input);\n         assertEquals(\"Failed to unescape Unicode characters with many 'u' characters\", \"G\", result);\n     }\n \n     @Test\n     public void testLessThanFour() {\n-        UnicodeUnescaper uu = new UnicodeUnescaper();\n+        final UnicodeUnescaper uu = new UnicodeUnescaper();\n \n-        String input = \"\\\\0047\\\\u006\";\n+        final String input = \"\\\\0047\\\\u006\";\n         try {\n             uu.translate(input);\n             fail(\"A lack of digits in a Unicode escape sequence failed to throw an exception\");\n-        } catch(IllegalArgumentException iae) {\n+        } catch(final IllegalArgumentException iae) {\n             // expected\n         }\n     }\n--- a/src/test/java/org/apache/commons/lang3/time/DateFormatUtilsTest.java\n+++ b/src/test/java/org/apache/commons/lang3/time/DateFormatUtilsTest.java\n     @Test\n     public void testConstructor() {\n         assertNotNull(new DateFormatUtils());\n-        Constructor<?>[] cons = DateFormatUtils.class.getDeclaredConstructors();\n+        final Constructor<?>[] cons = DateFormatUtils.class.getDeclaredConstructors();\n         assertEquals(1, cons.length);\n         assertTrue(Modifier.isPublic(cons[0].getModifiers()));\n         assertTrue(Modifier.isPublic(DateFormatUtils.class.getModifiers()));\n     //-----------------------------------------------------------------------\n     @Test\n     public void testFormat() {\n-        Calendar c = Calendar.getInstance(TimeZone.getTimeZone(\"UTC\"));\n+        final Calendar c = Calendar.getInstance(TimeZone.getTimeZone(\"UTC\"));\n         c.set(2005,0,1,12,0,0);\n         c.setTimeZone(TimeZone.getDefault());\n-        StringBuilder buffer = new StringBuilder ();\n-        int year = c.get(Calendar.YEAR);\n-        int month = c.get(Calendar.MONTH) + 1;\n-        int day = c.get(Calendar.DAY_OF_MONTH);\n-        int hour = c.get(Calendar.HOUR_OF_DAY);\n+        final StringBuilder buffer = new StringBuilder ();\n+        final int year = c.get(Calendar.YEAR);\n+        final int month = c.get(Calendar.MONTH) + 1;\n+        final int day = c.get(Calendar.DAY_OF_MONTH);\n+        final int hour = c.get(Calendar.HOUR_OF_DAY);\n         buffer.append (year);\n         buffer.append(month);\n         buffer.append(day);\n     //-----------------------------------------------------------------------\n     @Test\n     public void testFormatCalendar() {\n-        Calendar c = Calendar.getInstance(TimeZone.getTimeZone(\"UTC\"));\n+        final Calendar c = Calendar.getInstance(TimeZone.getTimeZone(\"UTC\"));\n         c.set(2005,0,1,12,0,0);\n         c.setTimeZone(TimeZone.getDefault());\n-        StringBuilder buffer = new StringBuilder ();\n-        int year = c.get(Calendar.YEAR);\n-        int month = c.get(Calendar.MONTH) + 1;\n-        int day = c.get(Calendar.DAY_OF_MONTH);\n-        int hour = c.get(Calendar.HOUR_OF_DAY);\n+        final StringBuilder buffer = new StringBuilder ();\n+        final int year = c.get(Calendar.YEAR);\n+        final int month = c.get(Calendar.MONTH) + 1;\n+        final int day = c.get(Calendar.DAY_OF_MONTH);\n+        final int hour = c.get(Calendar.HOUR_OF_DAY);\n         buffer.append (year);\n         buffer.append(month);\n         buffer.append(day);\n     \n     @Test\n     public void testFormatUTC() {\n-        Calendar c = Calendar.getInstance(TimeZone.getTimeZone(\"UTC\"));\n+        final Calendar c = Calendar.getInstance(TimeZone.getTimeZone(\"UTC\"));\n         c.set(2005,0,1,12,0,0);\n         assertEquals (\"2005-01-01T12:00:00\", DateFormatUtils.formatUTC(c.getTime(), DateFormatUtils.ISO_DATETIME_FORMAT.getPattern()));\n         \n     \n     @Test\n     public void testDateTimeISO(){\n-        TimeZone timeZone = TimeZone.getTimeZone(\"GMT-3\");\n-        Calendar cal = Calendar.getInstance(timeZone);\n+        final TimeZone timeZone = TimeZone.getTimeZone(\"GMT-3\");\n+        final Calendar cal = Calendar.getInstance(timeZone);\n         cal.set(2002,1,23,9,11,12);\n         String text = DateFormatUtils.format(cal.getTime(), \n                         DateFormatUtils.ISO_DATETIME_FORMAT.getPattern(), timeZone);\n \n     @Test\n     public void testDateISO(){\n-        TimeZone timeZone = TimeZone.getTimeZone(\"GMT-3\");\n-        Calendar cal = Calendar.getInstance(timeZone);\n+        final TimeZone timeZone = TimeZone.getTimeZone(\"GMT-3\");\n+        final Calendar cal = Calendar.getInstance(timeZone);\n         cal.set(2002,1,23,10,11,12);\n         String text = DateFormatUtils.format(cal.getTime(), \n                         DateFormatUtils.ISO_DATE_FORMAT.getPattern(), timeZone);\n \n     @Test\n     public void testTimeISO(){\n-        TimeZone timeZone = TimeZone.getTimeZone(\"GMT-3\");\n-        Calendar cal = Calendar.getInstance(timeZone);\n+        final TimeZone timeZone = TimeZone.getTimeZone(\"GMT-3\");\n+        final Calendar cal = Calendar.getInstance(timeZone);\n         cal.set(2002,1,23,10,11,12);\n         String text = DateFormatUtils.format(cal.getTime(), \n                         DateFormatUtils.ISO_TIME_FORMAT.getPattern(), timeZone);\n \n     @Test\n     public void testTimeNoTISO(){\n-        TimeZone timeZone = TimeZone.getTimeZone(\"GMT-3\");\n-        Calendar cal = Calendar.getInstance(timeZone);\n+        final TimeZone timeZone = TimeZone.getTimeZone(\"GMT-3\");\n+        final Calendar cal = Calendar.getInstance(timeZone);\n         cal.set(2002,1,23,10,11,12);\n         String text = DateFormatUtils.format(cal.getTime(), \n                         DateFormatUtils.ISO_TIME_NO_T_FORMAT.getPattern(), timeZone);\n \n     @Test\n     public void testSMTP(){\n-        TimeZone timeZone = TimeZone.getTimeZone(\"GMT-3\");\n-        Calendar cal = Calendar.getInstance(timeZone);\n+        final TimeZone timeZone = TimeZone.getTimeZone(\"GMT-3\");\n+        final Calendar cal = Calendar.getInstance(timeZone);\n         cal.set(2003,5,8,10,11,12);\n         String text = DateFormatUtils.format(cal.getTime(), \n                         DateFormatUtils.SMTP_DATETIME_FORMAT.getPattern(), timeZone,\n--- a/src/test/java/org/apache/commons/lang3/time/DateUtilsFragmentTest.java\n+++ b/src/test/java/org/apache/commons/lang3/time/DateUtilsFragmentTest.java\n         try {\n             DateUtils.getFragmentInMilliseconds((Date) null, Calendar.MILLISECOND);\n             fail();\n-        } catch(IllegalArgumentException iae) {}\n+        } catch(final IllegalArgumentException iae) {}\n \n         try {\n             DateUtils.getFragmentInSeconds((Date) null, Calendar.MILLISECOND);\n             fail();\n-        } catch(IllegalArgumentException iae) {}\n+        } catch(final IllegalArgumentException iae) {}\n \n         try {\n             DateUtils.getFragmentInMinutes((Date) null, Calendar.MILLISECOND);\n             fail();\n-        } catch(IllegalArgumentException iae) {}\n+        } catch(final IllegalArgumentException iae) {}\n \n         try {\n             DateUtils.getFragmentInHours((Date) null, Calendar.MILLISECOND);\n             fail();\n-        } catch(IllegalArgumentException iae) {}\n+        } catch(final IllegalArgumentException iae) {}\n \n         try {\n             DateUtils.getFragmentInDays((Date) null, Calendar.MILLISECOND);\n             fail();\n-        } catch(IllegalArgumentException iae) {}\n+        } catch(final IllegalArgumentException iae) {}\n     }\n \n     @Test\n         try {\n             DateUtils.getFragmentInMilliseconds((Calendar) null, Calendar.MILLISECOND);\n             fail();\n-        } catch(IllegalArgumentException iae) {}\n+        } catch(final IllegalArgumentException iae) {}\n \n         try {\n             DateUtils.getFragmentInSeconds((Calendar) null, Calendar.MILLISECOND);\n             fail();\n-        } catch(IllegalArgumentException iae) {}\n+        } catch(final IllegalArgumentException iae) {}\n \n         try {\n             DateUtils.getFragmentInMinutes((Calendar) null, Calendar.MILLISECOND);\n             fail();\n-        } catch(IllegalArgumentException iae) {}\n+        } catch(final IllegalArgumentException iae) {}\n \n         try {\n             DateUtils.getFragmentInHours((Calendar) null, Calendar.MILLISECOND);\n             fail();\n-        } catch(IllegalArgumentException iae) {}\n+        } catch(final IllegalArgumentException iae) {}\n \n         try {\n             DateUtils.getFragmentInDays((Calendar) null, Calendar.MILLISECOND);\n             fail();\n-        } catch(IllegalArgumentException iae) {}\n+        } catch(final IllegalArgumentException iae) {}\n     }\n     \n     @Test\n         try {\n             DateUtils.getFragmentInMilliseconds(aDate, 0);\n             fail();\n-        } catch(IllegalArgumentException iae) {}\n+        } catch(final IllegalArgumentException iae) {}\n \n         try {\n             DateUtils.getFragmentInSeconds(aDate, 0);\n             fail();\n-        } catch(IllegalArgumentException iae) {}\n+        } catch(final IllegalArgumentException iae) {}\n \n         try {\n             DateUtils.getFragmentInMinutes(aDate, 0);\n             fail();\n-        } catch(IllegalArgumentException iae) {}\n+        } catch(final IllegalArgumentException iae) {}\n \n         try {\n             DateUtils.getFragmentInHours(aDate, 0);\n             fail();\n-        } catch(IllegalArgumentException iae) {}\n+        } catch(final IllegalArgumentException iae) {}\n \n         try {\n             DateUtils.getFragmentInDays(aDate, 0);\n             fail();\n-        } catch(IllegalArgumentException iae) {}\n+        } catch(final IllegalArgumentException iae) {}\n     }\n \n     @Test\n         try {\n             DateUtils.getFragmentInMilliseconds(aCalendar, 0);\n             fail();\n-        } catch(IllegalArgumentException iae) {}\n+        } catch(final IllegalArgumentException iae) {}\n \n         try {\n             DateUtils.getFragmentInSeconds(aCalendar, 0);\n             fail();\n-        } catch(IllegalArgumentException iae) {}\n+        } catch(final IllegalArgumentException iae) {}\n \n         try {\n             DateUtils.getFragmentInMinutes(aCalendar, 0);\n             fail();\n-        } catch(IllegalArgumentException iae) {}\n+        } catch(final IllegalArgumentException iae) {}\n \n         try {\n             DateUtils.getFragmentInHours(aCalendar, 0);\n             fail();\n-        } catch(IllegalArgumentException iae) {}\n+        } catch(final IllegalArgumentException iae) {}\n \n         try {\n             DateUtils.getFragmentInDays(aCalendar, 0);\n             fail();\n-        } catch(IllegalArgumentException iae) {}\n+        } catch(final IllegalArgumentException iae) {}\n     }\n \n     @Test\n     \n     @Test\n     public void testMillisecondsOfSecondWithDate() {\n-        long testResult = DateUtils.getFragmentInMilliseconds(aDate, Calendar.SECOND);\n+        final long testResult = DateUtils.getFragmentInMilliseconds(aDate, Calendar.SECOND);\n         assertEquals(millis, testResult);\n     }\n \n     @Test\n     public void testMillisecondsOfSecondWithCalendar() {\n-        long testResult = DateUtils.getFragmentInMilliseconds(aCalendar, Calendar.SECOND);\n+        final long testResult = DateUtils.getFragmentInMilliseconds(aCalendar, Calendar.SECOND);\n         assertEquals(millis, testResult);\n         assertEquals(aCalendar.get(Calendar.MILLISECOND), testResult);\n     }\n \n     @Test\n     public void testMillisecondsOfMinuteWithDate() {\n-        long testResult = DateUtils.getFragmentInMilliseconds(aDate, Calendar.MINUTE);\n+        final long testResult = DateUtils.getFragmentInMilliseconds(aDate, Calendar.MINUTE);\n         assertEquals(millis + (seconds * DateUtils.MILLIS_PER_SECOND), testResult);\n     }\n \n     @Test\n     public void testMillisecondsOfMinuteWithCalender() {\n-        long testResult = DateUtils.getFragmentInMilliseconds(aCalendar, Calendar.MINUTE);\n+        final long testResult = DateUtils.getFragmentInMilliseconds(aCalendar, Calendar.MINUTE);\n         assertEquals(millis + (seconds * DateUtils.MILLIS_PER_SECOND), testResult);\n     }\n \n     @Test\n     public void testSecondsofMinuteWithDate() {\n-        long testResult = DateUtils.getFragmentInSeconds(aDate, Calendar.MINUTE);\n+        final long testResult = DateUtils.getFragmentInSeconds(aDate, Calendar.MINUTE);\n         assertEquals(seconds, testResult);\n     }\n \n     @Test\n     public void testSecondsofMinuteWithCalendar() {\n-        long testResult = DateUtils.getFragmentInSeconds(aCalendar, Calendar.MINUTE);\n+        final long testResult = DateUtils.getFragmentInSeconds(aCalendar, Calendar.MINUTE);\n         assertEquals(seconds, testResult);\n         assertEquals(aCalendar.get(Calendar.SECOND), testResult);\n     }\n     \n     @Test\n     public void testMillisecondsOfHourWithDate() {\n-        long testResult = DateUtils.getFragmentInMilliseconds(aDate, Calendar.HOUR_OF_DAY);\n+        final long testResult = DateUtils.getFragmentInMilliseconds(aDate, Calendar.HOUR_OF_DAY);\n         assertEquals(millis + (seconds * DateUtils.MILLIS_PER_SECOND) + (minutes * DateUtils.MILLIS_PER_MINUTE), testResult);\n     }\n     \n     @Test\n     public void testMillisecondsOfHourWithCalendar() {\n-        long testResult = DateUtils.getFragmentInMilliseconds(aCalendar, Calendar.HOUR_OF_DAY);\n+        final long testResult = DateUtils.getFragmentInMilliseconds(aCalendar, Calendar.HOUR_OF_DAY);\n         assertEquals(millis + (seconds * DateUtils.MILLIS_PER_SECOND) + (minutes * DateUtils.MILLIS_PER_MINUTE), testResult);\n     }\n \n     @Test\n     public void testSecondsofHourWithDate() {\n-        long testResult = DateUtils.getFragmentInSeconds(aDate, Calendar.HOUR_OF_DAY);\n+        final long testResult = DateUtils.getFragmentInSeconds(aDate, Calendar.HOUR_OF_DAY);\n         assertEquals(\n                 seconds\n                         + (minutes\n \n     @Test\n     public void testSecondsofHourWithCalendar() {\n-        long testResult = DateUtils.getFragmentInSeconds(aCalendar, Calendar.HOUR_OF_DAY);\n+        final long testResult = DateUtils.getFragmentInSeconds(aCalendar, Calendar.HOUR_OF_DAY);\n         assertEquals(\n                 seconds\n                         + (minutes\n \n     @Test\n     public void testMinutesOfHourWithDate() {\n-        long testResult = DateUtils.getFragmentInMinutes(aDate, Calendar.HOUR_OF_DAY);\n+        final long testResult = DateUtils.getFragmentInMinutes(aDate, Calendar.HOUR_OF_DAY);\n         assertEquals(minutes, testResult);\n     }\n \n     @Test\n     public void testMinutesOfHourWithCalendar() {\n-        long testResult = DateUtils.getFragmentInMinutes(aCalendar, Calendar.HOUR_OF_DAY);\n+        final long testResult = DateUtils.getFragmentInMinutes(aCalendar, Calendar.HOUR_OF_DAY);\n         assertEquals(minutes, testResult);\n     }\n \n     @Test\n     public void testMillisecondsOfDayWithDate() {\n         long testresult = DateUtils.getFragmentInMilliseconds(aDate, Calendar.DATE);\n-        long expectedValue = millis + (seconds * DateUtils.MILLIS_PER_SECOND) + (minutes * DateUtils.MILLIS_PER_MINUTE) + (hours * DateUtils.MILLIS_PER_HOUR); \n+        final long expectedValue = millis + (seconds * DateUtils.MILLIS_PER_SECOND) + (minutes * DateUtils.MILLIS_PER_MINUTE) + (hours * DateUtils.MILLIS_PER_HOUR); \n         assertEquals(expectedValue, testresult);\n         testresult = DateUtils.getFragmentInMilliseconds(aDate, Calendar.DAY_OF_YEAR);\n         assertEquals(expectedValue, testresult);\n     @Test\n     public void testMillisecondsOfDayWithCalendar() {\n         long testresult = DateUtils.getFragmentInMilliseconds(aCalendar, Calendar.DATE);\n-        long expectedValue = millis + (seconds * DateUtils.MILLIS_PER_SECOND) + (minutes * DateUtils.MILLIS_PER_MINUTE) + (hours * DateUtils.MILLIS_PER_HOUR); \n+        final long expectedValue = millis + (seconds * DateUtils.MILLIS_PER_SECOND) + (minutes * DateUtils.MILLIS_PER_MINUTE) + (hours * DateUtils.MILLIS_PER_HOUR); \n         assertEquals(expectedValue, testresult);\n         testresult = DateUtils.getFragmentInMilliseconds(aCalendar, Calendar.DAY_OF_YEAR);\n         assertEquals(expectedValue, testresult);\n     @Test\n     public void testSecondsOfDayWithDate() {\n         long testresult = DateUtils.getFragmentInSeconds(aDate, Calendar.DATE);\n-        long expectedValue = seconds + ((minutes * DateUtils.MILLIS_PER_MINUTE) + (hours * DateUtils.MILLIS_PER_HOUR))/ DateUtils.MILLIS_PER_SECOND;\n+        final long expectedValue = seconds + ((minutes * DateUtils.MILLIS_PER_MINUTE) + (hours * DateUtils.MILLIS_PER_HOUR))/ DateUtils.MILLIS_PER_SECOND;\n         assertEquals(expectedValue, testresult);\n         testresult = DateUtils.getFragmentInSeconds(aDate, Calendar.DAY_OF_YEAR);\n         assertEquals(expectedValue, testresult);\n     @Test\n     public void testSecondsOfDayWithCalendar() {\n         long testresult = DateUtils.getFragmentInSeconds(aCalendar, Calendar.DATE);\n-        long expectedValue = seconds + ((minutes * DateUtils.MILLIS_PER_MINUTE) + (hours * DateUtils.MILLIS_PER_HOUR))/ DateUtils.MILLIS_PER_SECOND;\n+        final long expectedValue = seconds + ((minutes * DateUtils.MILLIS_PER_MINUTE) + (hours * DateUtils.MILLIS_PER_HOUR))/ DateUtils.MILLIS_PER_SECOND;\n         assertEquals(expectedValue, testresult);\n         testresult = DateUtils.getFragmentInSeconds(aCalendar, Calendar.DAY_OF_YEAR);\n         assertEquals(expectedValue, testresult);\n     @Test\n     public void testMinutesOfDayWithDate() {\n         long testResult = DateUtils.getFragmentInMinutes(aDate, Calendar.DATE);\n-        long expectedValue = minutes + ((hours * DateUtils.MILLIS_PER_HOUR))/ DateUtils.MILLIS_PER_MINUTE; \n+        final long expectedValue = minutes + ((hours * DateUtils.MILLIS_PER_HOUR))/ DateUtils.MILLIS_PER_MINUTE; \n         assertEquals(expectedValue,testResult);\n         testResult = DateUtils.getFragmentInMinutes(aDate, Calendar.DAY_OF_YEAR);\n         assertEquals(expectedValue,testResult);\n     @Test\n     public void testMinutesOfDayWithCalendar() {\n         long testResult = DateUtils.getFragmentInMinutes(aCalendar, Calendar.DATE);\n-        long expectedValue = minutes + ((hours * DateUtils.MILLIS_PER_HOUR))/ DateUtils.MILLIS_PER_MINUTE; \n+        final long expectedValue = minutes + ((hours * DateUtils.MILLIS_PER_HOUR))/ DateUtils.MILLIS_PER_MINUTE; \n         assertEquals(expectedValue, testResult);\n         testResult = DateUtils.getFragmentInMinutes(aCalendar, Calendar.DAY_OF_YEAR);\n         assertEquals(expectedValue, testResult);\n     @Test\n     public void testHoursOfDayWithDate() {\n         long testResult = DateUtils.getFragmentInHours(aDate, Calendar.DATE);\n-        long expectedValue = hours; \n+        final long expectedValue = hours; \n         assertEquals(expectedValue,testResult);\n         testResult = DateUtils.getFragmentInHours(aDate, Calendar.DAY_OF_YEAR);\n         assertEquals(expectedValue,testResult);\n     @Test\n     public void testHoursOfDayWithCalendar() {\n         long testResult = DateUtils.getFragmentInHours(aCalendar, Calendar.DATE);\n-        long expectedValue = hours; \n+        final long expectedValue = hours; \n         assertEquals(expectedValue, testResult);\n         testResult = DateUtils.getFragmentInHours(aCalendar, Calendar.DAY_OF_YEAR);\n         assertEquals(expectedValue, testResult);\n     //Calendar.MONTH as useful fragment\n     @Test\n     public void testMillisecondsOfMonthWithDate() {\n-        long testResult = DateUtils.getFragmentInMilliseconds(aDate, Calendar.MONTH);\n+        final long testResult = DateUtils.getFragmentInMilliseconds(aDate, Calendar.MONTH);\n         assertEquals(millis + (seconds * DateUtils.MILLIS_PER_SECOND) + (minutes * DateUtils.MILLIS_PER_MINUTE)\n                                 + (hours * DateUtils.MILLIS_PER_HOUR) + (days * DateUtils.MILLIS_PER_DAY),\n                 testResult);\n \n     @Test\n     public void testMillisecondsOfMonthWithCalendar() {\n-        long testResult = DateUtils.getFragmentInMilliseconds(aCalendar, Calendar.MONTH);\n+        final long testResult = DateUtils.getFragmentInMilliseconds(aCalendar, Calendar.MONTH);\n         assertEquals(millis + (seconds * DateUtils.MILLIS_PER_SECOND) + (minutes * DateUtils.MILLIS_PER_MINUTE)\n                 + (hours * DateUtils.MILLIS_PER_HOUR) + (days * DateUtils.MILLIS_PER_DAY),\n testResult);\n     \n     @Test\n     public void testSecondsOfMonthWithDate() {\n-        long testResult = DateUtils.getFragmentInSeconds(aDate, Calendar.MONTH);\n+        final long testResult = DateUtils.getFragmentInSeconds(aDate, Calendar.MONTH);\n         assertEquals(\n                 seconds\n                         + ((minutes * DateUtils.MILLIS_PER_MINUTE)\n \n     @Test\n     public void testSecondsOfMonthWithCalendar() {\n-        long testResult = DateUtils.getFragmentInSeconds(aCalendar, Calendar.MONTH);\n+        final long testResult = DateUtils.getFragmentInSeconds(aCalendar, Calendar.MONTH);\n         assertEquals(\n                 seconds\n                         + ((minutes * DateUtils.MILLIS_PER_MINUTE)\n \n     @Test\n     public void testMinutesOfMonthWithDate() {\n-        long testResult = DateUtils.getFragmentInMinutes(aDate, Calendar.MONTH);\n+        final long testResult = DateUtils.getFragmentInMinutes(aDate, Calendar.MONTH);\n         assertEquals(minutes\n                                 + ((hours * DateUtils.MILLIS_PER_HOUR) + (days * DateUtils.MILLIS_PER_DAY))\n                         / DateUtils.MILLIS_PER_MINUTE,\n \n     @Test\n     public void testMinutesOfMonthWithCalendar() {\n-        long testResult = DateUtils.getFragmentInMinutes(aCalendar, Calendar.MONTH);\n+        final long testResult = DateUtils.getFragmentInMinutes(aCalendar, Calendar.MONTH);\n         assertEquals( minutes  +((hours * DateUtils.MILLIS_PER_HOUR) + (days * DateUtils.MILLIS_PER_DAY))\n                         / DateUtils.MILLIS_PER_MINUTE,\n                 testResult);\n \n     @Test\n     public void testHoursOfMonthWithDate() {\n-        long testResult = DateUtils.getFragmentInHours(aDate, Calendar.MONTH);\n+        final long testResult = DateUtils.getFragmentInHours(aDate, Calendar.MONTH);\n         assertEquals(hours + ((days * DateUtils.MILLIS_PER_DAY))\n                         / DateUtils.MILLIS_PER_HOUR,\n                 testResult);\n \n     @Test\n     public void testHoursOfMonthWithCalendar() {\n-        long testResult = DateUtils.getFragmentInHours(aCalendar, Calendar.MONTH);\n+        final long testResult = DateUtils.getFragmentInHours(aCalendar, Calendar.MONTH);\n         assertEquals( hours +((days * DateUtils.MILLIS_PER_DAY))\n                         / DateUtils.MILLIS_PER_HOUR,\n                 testResult);\n     //Calendar.YEAR as useful fragment\n     @Test\n     public void testMillisecondsOfYearWithDate() {\n-        long testResult = DateUtils.getFragmentInMilliseconds(aDate, Calendar.YEAR);\n-        Calendar cal = Calendar.getInstance();\n+        final long testResult = DateUtils.getFragmentInMilliseconds(aDate, Calendar.YEAR);\n+        final Calendar cal = Calendar.getInstance();\n         cal.setTime(aDate);\n         assertEquals(millis + (seconds * DateUtils.MILLIS_PER_SECOND) + (minutes * DateUtils.MILLIS_PER_MINUTE)\n                                 + (hours * DateUtils.MILLIS_PER_HOUR) + (cal.get(Calendar.DAY_OF_YEAR) * DateUtils.MILLIS_PER_DAY),\n \n     @Test\n     public void testMillisecondsOfYearWithCalendar() {\n-        long testResult = DateUtils.getFragmentInMilliseconds(aCalendar, Calendar.YEAR);\n+        final long testResult = DateUtils.getFragmentInMilliseconds(aCalendar, Calendar.YEAR);\n         assertEquals(millis + (seconds * DateUtils.MILLIS_PER_SECOND) + (minutes * DateUtils.MILLIS_PER_MINUTE)\n                 + (hours * DateUtils.MILLIS_PER_HOUR) + (aCalendar.get(Calendar.DAY_OF_YEAR) * DateUtils.MILLIS_PER_DAY),\n testResult);\n     \n     @Test\n     public void testSecondsOfYearWithDate() {\n-        long testResult = DateUtils.getFragmentInSeconds(aDate, Calendar.YEAR);\n-        Calendar cal = Calendar.getInstance();\n+        final long testResult = DateUtils.getFragmentInSeconds(aDate, Calendar.YEAR);\n+        final Calendar cal = Calendar.getInstance();\n         cal.setTime(aDate);\n         assertEquals(\n                 seconds\n \n     @Test\n     public void testSecondsOfYearWithCalendar() {\n-        long testResult = DateUtils.getFragmentInSeconds(aCalendar, Calendar.YEAR);\n+        final long testResult = DateUtils.getFragmentInSeconds(aCalendar, Calendar.YEAR);\n         assertEquals(\n                 seconds\n                         + ((minutes * DateUtils.MILLIS_PER_MINUTE)\n \n     @Test\n     public void testMinutesOfYearWithDate() {\n-        long testResult = DateUtils.getFragmentInMinutes(aDate, Calendar.YEAR);\n-        Calendar cal = Calendar.getInstance();\n+        final long testResult = DateUtils.getFragmentInMinutes(aDate, Calendar.YEAR);\n+        final Calendar cal = Calendar.getInstance();\n         cal.setTime(aDate);\n         assertEquals(minutes\n                                 + ((hours * DateUtils.MILLIS_PER_HOUR) + (cal.get(Calendar.DAY_OF_YEAR) * DateUtils.MILLIS_PER_DAY))\n \n     @Test\n     public void testMinutesOfYearWithCalendar() {\n-        long testResult = DateUtils.getFragmentInMinutes(aCalendar, Calendar.YEAR);\n+        final long testResult = DateUtils.getFragmentInMinutes(aCalendar, Calendar.YEAR);\n         assertEquals( minutes  +((hours * DateUtils.MILLIS_PER_HOUR) + (aCalendar.get(Calendar.DAY_OF_YEAR) * DateUtils.MILLIS_PER_DAY))\n                         / DateUtils.MILLIS_PER_MINUTE,\n                 testResult);\n \n     @Test\n     public void testHoursOfYearWithDate() {\n-        long testResult = DateUtils.getFragmentInHours(aDate, Calendar.YEAR);\n-        Calendar cal = Calendar.getInstance();\n+        final long testResult = DateUtils.getFragmentInHours(aDate, Calendar.YEAR);\n+        final Calendar cal = Calendar.getInstance();\n         cal.setTime(aDate);\n         assertEquals(hours + ((cal.get(Calendar.DAY_OF_YEAR) * DateUtils.MILLIS_PER_DAY))\n                         / DateUtils.MILLIS_PER_HOUR,\n \n     @Test\n     public void testHoursOfYearWithCalendar() {\n-        long testResult = DateUtils.getFragmentInHours(aCalendar, Calendar.YEAR);\n+        final long testResult = DateUtils.getFragmentInHours(aCalendar, Calendar.YEAR);\n         assertEquals( hours +((aCalendar.get(Calendar.DAY_OF_YEAR) * DateUtils.MILLIS_PER_DAY))\n                         / DateUtils.MILLIS_PER_HOUR,\n                 testResult);\n--- a/src/test/java/org/apache/commons/lang3/time/DateUtilsRoundingTest.java\n+++ b/src/test/java/org/apache/commons/lang3/time/DateUtilsRoundingTest.java\n     @Test\n     public void testRoundYear() throws Exception {\n         final int calendarField = Calendar.YEAR;\n-        Date roundedUpDate = dateTimeParser.parse(\"January 1, 2008 0:00:00.000\");\n-        Date roundedDownDate = targetYearDate;\n-        Date lastRoundedDownDate = dateTimeParser.parse(\"June 30, 2007 23:59:59.999\");\n+        final Date roundedUpDate = dateTimeParser.parse(\"January 1, 2008 0:00:00.000\");\n+        final Date roundedDownDate = targetYearDate;\n+        final Date lastRoundedDownDate = dateTimeParser.parse(\"June 30, 2007 23:59:59.999\");\n         baseRoundTest(roundedUpDate, roundedDownDate, lastRoundedDownDate,  calendarField);\n     }\n     \n     @Test\n     public void testTruncateYear() throws Exception {\n         final int calendarField = Calendar.YEAR;\n-        Date lastTruncateDate = dateTimeParser.parse(\"December 31, 2007 23:59:59.999\");\n+        final Date lastTruncateDate = dateTimeParser.parse(\"December 31, 2007 23:59:59.999\");\n         baseTruncateTest(targetYearDate, lastTruncateDate, calendarField);\n     }\n \n     @Test\n     public void testTruncateMonth() throws Exception {\n         final int calendarField = Calendar.MONTH;\n-        Date truncatedDate = dateTimeParser.parse(\"March 1, 2008 0:00:00.000\");\n-        Date lastTruncateDate = dateTimeParser.parse(\"March 31, 2008 23:59:59.999\");\n+        final Date truncatedDate = dateTimeParser.parse(\"March 1, 2008 0:00:00.000\");\n+        final Date lastTruncateDate = dateTimeParser.parse(\"March 31, 2008 23:59:59.999\");\n         baseTruncateTest(truncatedDate, lastTruncateDate, calendarField);\n     }\n \n     @Test\n     public void testTruncateDate() throws Exception {\n         final int calendarField = Calendar.DATE;\n-        Date lastTruncateDate = dateTimeParser.parse(\"June 1, 2008 23:59:59.999\");\n+        final Date lastTruncateDate = dateTimeParser.parse(\"June 1, 2008 23:59:59.999\");\n         baseTruncateTest(targetDateDate, lastTruncateDate, calendarField);\n     }\n     \n     @Test\n     public void testTruncateDayOfMonth() throws Exception {\n         final int calendarField = Calendar.DAY_OF_MONTH;\n-        Date lastTruncateDate = dateTimeParser.parse(\"June 1, 2008 23:59:59.999\");\n+        final Date lastTruncateDate = dateTimeParser.parse(\"June 1, 2008 23:59:59.999\");\n         baseTruncateTest(targetDayOfMonthDate, lastTruncateDate, calendarField);\n     }\n     \n     @Test\n     public void testTruncateHour() throws Exception {\n         final int calendarField = Calendar.HOUR;\n-        Date lastTruncateDate = dateTimeParser.parse(\"June 1, 2008 8:59:59.999\");\n+        final Date lastTruncateDate = dateTimeParser.parse(\"June 1, 2008 8:59:59.999\");\n         baseTruncateTest(targetHourDate, lastTruncateDate, calendarField);\n     }\n     \n     @Test\n     public void testTruncateHourOfDay() throws Exception {\n         final int calendarField = Calendar.HOUR_OF_DAY;\n-        Date lastTruncateDate = dateTimeParser.parse(\"June 1, 2008 8:59:59.999\");\n+        final Date lastTruncateDate = dateTimeParser.parse(\"June 1, 2008 8:59:59.999\");\n         baseTruncateTest(targetHourOfDayDate, lastTruncateDate, calendarField);\n     }\n     \n     @Test\n     public void testTruncateMinute() throws Exception {\n         final int calendarField = Calendar.MINUTE;\n-        Date lastTruncateDate = dateTimeParser.parse(\"June 1, 2008 8:15:59.999\");\n+        final Date lastTruncateDate = dateTimeParser.parse(\"June 1, 2008 8:15:59.999\");\n         baseTruncateTest(targetMinuteDate, lastTruncateDate, calendarField);\n     }\n     \n     @Test\n     public void testTruncateSecond() throws Exception {\n         final int calendarField = Calendar.SECOND;\n-        Date lastTruncateDate = dateTimeParser.parse(\"June 1, 2008 8:15:14.999\");\n+        final Date lastTruncateDate = dateTimeParser.parse(\"June 1, 2008 8:15:14.999\");\n         baseTruncateTest(targetSecondDate, lastTruncateDate, calendarField);\n     }\n     \n      * @since 3.0\n      */\n     protected void baseRoundTest(final Date roundedUpDate, final Date roundedDownDate, final Date lastRoundDownDate, final int calendarField) {\n-        Date firstRoundUpDate = DateUtils.addMilliseconds(lastRoundDownDate, 1);\n+        final Date firstRoundUpDate = DateUtils.addMilliseconds(lastRoundDownDate, 1);\n         \n         //Date-comparison\n         assertEquals(roundedDownDate, DateUtils.round(roundedDownDate, calendarField));\n      * @since 3.0\n      */\n     protected void baseTruncateTest(final Date truncatedDate, final Date lastTruncateDate, final int calendarField) {\n-        Date nextTruncateDate = DateUtils.addMilliseconds(lastTruncateDate, 1);\n+        final Date nextTruncateDate = DateUtils.addMilliseconds(lastTruncateDate, 1);\n         \n         //Date-comparison\n         assertEquals(\"Truncating \"+ fdf.format(truncatedDate) +\" as Date with CalendarField-value \"+ calendarField +\" must return itself\", truncatedDate, DateUtils.truncate(truncatedDate, calendarField));\n         assertEquals(januaryOneDate, DateUtils.round(minDate, calendarField));\n         assertEquals(januaryOneDate, DateUtils.round(maxDate, calendarField));\n         \n-        Calendar minCalendar = Calendar.getInstance();\n+        final Calendar minCalendar = Calendar.getInstance();\n         minCalendar.setTime(minDate);\n-        Calendar maxCalendar = Calendar.getInstance();\n+        final Calendar maxCalendar = Calendar.getInstance();\n         maxCalendar.setTime(maxDate);\n         assertEquals(\"Rounding \"+ fdf.format(januaryOneCalendar) +\" as Date with CalendarField-value \"+ calendarField +\" must return itself\", januaryOneCalendar, DateUtils.round(januaryOneCalendar, calendarField));\n         assertEquals(januaryOneCalendar, DateUtils.round(minCalendar, calendarField));\n         assertEquals(januaryOneCalendar, DateUtils.round(maxCalendar, calendarField));\n \n-        Date toPrevRoundDate = DateUtils.addMilliseconds(minDate, -1);\n-        Date toNextRoundDate = DateUtils.addMilliseconds(maxDate, 1);\n+        final Date toPrevRoundDate = DateUtils.addMilliseconds(minDate, -1);\n+        final Date toNextRoundDate = DateUtils.addMilliseconds(maxDate, 1);\n         assertFalse(fdf.format(minDate) +\" is not an lower-extreme when rounding as Date with CalendarField-value \"+ calendarField, januaryOneDate.equals(DateUtils.round(toPrevRoundDate, calendarField)));\n         assertFalse(fdf.format(maxDate) +\" is not an upper-extreme when rounding as Date with CalendarField-value \"+ calendarField, januaryOneDate.equals(DateUtils.round(toNextRoundDate, calendarField)));\n         \n-        Calendar toPrevRoundCalendar = Calendar.getInstance();\n+        final Calendar toPrevRoundCalendar = Calendar.getInstance();\n         toPrevRoundCalendar.setTime(toPrevRoundDate);\n-        Calendar toNextRoundCalendar = Calendar.getInstance();\n+        final Calendar toNextRoundCalendar = Calendar.getInstance();\n         toNextRoundCalendar.setTime(toNextRoundDate);\n         assertFalse(fdf.format(minCalendar) +\" is not an lower-extreme when rounding as Date with CalendarField-value \"+ calendarField, januaryOneDate.equals(DateUtils.round(toPrevRoundDate, calendarField)));\n         assertFalse(fdf.format(maxCalendar) +\" is not an upper-extreme when rounding as Date with CalendarField-value \"+ calendarField, januaryOneDate.equals(DateUtils.round(toNextRoundDate, calendarField)));\n--- a/src/test/java/org/apache/commons/lang3/time/DateUtilsTest.java\n+++ b/src/test/java/org/apache/commons/lang3/time/DateUtilsTest.java\n \n     private static final long MILLIS_TEST;\n     static {\n-        GregorianCalendar cal = new GregorianCalendar(2000, 6, 5, 4, 3, 2);\n+        final GregorianCalendar cal = new GregorianCalendar(2000, 6, 5, 4, 3, 2);\n         cal.set(Calendar.MILLISECOND, 1);\n         MILLIS_TEST = cal.getTime().getTime();\n         System.out.println(\"DateUtilsTest: Default Locale=\"+Locale.getDefault());\n     @Test\n     public void testConstructor() {\n         assertNotNull(new DateUtils());\n-        Constructor<?>[] cons = DateUtils.class.getDeclaredConstructors();\n+        final Constructor<?>[] cons = DateUtils.class.getDeclaredConstructors();\n         assertEquals(1, cons.length);\n         assertTrue(Modifier.isPublic(cons[0].getModifiers()));\n         assertTrue(Modifier.isPublic(DateUtils.class.getModifiers()));\n         try {\n             DateUtils.isSameDay((Date) null, (Date) null);\n             fail();\n-        } catch (IllegalArgumentException ex) {}\n+        } catch (final IllegalArgumentException ex) {}\n     }\n     \n     //-----------------------------------------------------------------------\n     @Test\n     public void testIsSameDay_Cal() {\n-        GregorianCalendar cal1 = new GregorianCalendar(2004, 6, 9, 13, 45);\n-        GregorianCalendar cal2 = new GregorianCalendar(2004, 6, 9, 13, 45);\n+        final GregorianCalendar cal1 = new GregorianCalendar(2004, 6, 9, 13, 45);\n+        final GregorianCalendar cal2 = new GregorianCalendar(2004, 6, 9, 13, 45);\n         assertTrue(DateUtils.isSameDay(cal1, cal2));\n         cal2.add(Calendar.DAY_OF_YEAR, 1);\n         assertFalse(DateUtils.isSameDay(cal1, cal2));\n         try {\n             DateUtils.isSameDay((Calendar) null, (Calendar) null);\n             fail();\n-        } catch (IllegalArgumentException ex) {}\n+        } catch (final IllegalArgumentException ex) {}\n     }\n     \n     //-----------------------------------------------------------------------\n         try {\n             DateUtils.isSameInstant((Date) null, (Date) null);\n             fail();\n-        } catch (IllegalArgumentException ex) {}\n+        } catch (final IllegalArgumentException ex) {}\n     }\n     \n     //-----------------------------------------------------------------------\n     @Test\n     public void testIsSameInstant_Cal() {\n-        GregorianCalendar cal1 = new GregorianCalendar(TimeZone.getTimeZone(\"GMT+1\"));\n-        GregorianCalendar cal2 = new GregorianCalendar(TimeZone.getTimeZone(\"GMT-1\"));\n+        final GregorianCalendar cal1 = new GregorianCalendar(TimeZone.getTimeZone(\"GMT+1\"));\n+        final GregorianCalendar cal2 = new GregorianCalendar(TimeZone.getTimeZone(\"GMT-1\"));\n         cal1.set(2004, 6, 9, 13, 45, 0);\n         cal1.set(Calendar.MILLISECOND, 0);\n         cal2.set(2004, 6, 9, 13, 45, 0);\n         try {\n             DateUtils.isSameInstant((Calendar) null, (Calendar) null);\n             fail();\n-        } catch (IllegalArgumentException ex) {}\n+        } catch (final IllegalArgumentException ex) {}\n     }\n     \n     //-----------------------------------------------------------------------\n     @Test\n     public void testIsSameLocalTime_Cal() {\n-        GregorianCalendar cal1 = new GregorianCalendar(TimeZone.getTimeZone(\"GMT+1\"));\n-        GregorianCalendar cal2 = new GregorianCalendar(TimeZone.getTimeZone(\"GMT-1\"));\n+        final GregorianCalendar cal1 = new GregorianCalendar(TimeZone.getTimeZone(\"GMT+1\"));\n+        final GregorianCalendar cal2 = new GregorianCalendar(TimeZone.getTimeZone(\"GMT-1\"));\n         cal1.set(2004, 6, 9, 13, 45, 0);\n         cal1.set(Calendar.MILLISECOND, 0);\n         cal2.set(2004, 6, 9, 13, 45, 0);\n         cal2.set(Calendar.MILLISECOND, 0);\n         assertTrue(DateUtils.isSameLocalTime(cal1, cal2));\n \n-        Calendar cal3 = Calendar.getInstance();\n-        Calendar cal4 = Calendar.getInstance();\n+        final Calendar cal3 = Calendar.getInstance();\n+        final Calendar cal4 = Calendar.getInstance();\n         cal3.set(2004, 6, 9, 4,  0, 0);\n         cal4.set(2004, 6, 9, 16, 0, 0);\n         cal3.set(Calendar.MILLISECOND, 0);\n         try {\n             DateUtils.isSameLocalTime((Calendar) null, (Calendar) null);\n             fail();\n-        } catch (IllegalArgumentException ex) {}\n+        } catch (final IllegalArgumentException ex) {}\n     }\n     \n     //-----------------------------------------------------------------------\n     @Test\n     public void testParseDate() throws Exception {\n-        GregorianCalendar cal = new GregorianCalendar(1972, 11, 3);\n+        final GregorianCalendar cal = new GregorianCalendar(1972, 11, 3);\n         String dateStr = \"1972-12-03\";\n-        String[] parsers = new String[] {\"yyyy'-'DDD\", \"yyyy'-'MM'-'dd\", \"yyyyMMdd\"};\n+        final String[] parsers = new String[] {\"yyyy'-'DDD\", \"yyyy'-'MM'-'dd\", \"yyyyMMdd\"};\n         Date date = DateUtils.parseDate(dateStr, parsers);\n         assertEquals(cal.getTime(), date);\n         \n         try {\n             DateUtils.parseDate(\"PURPLE\", parsers);\n             fail();\n-        } catch (ParseException ex) {}\n+        } catch (final ParseException ex) {}\n         try {\n             DateUtils.parseDate(\"197212AB\", parsers);\n             fail();\n-        } catch (ParseException ex) {}\n+        } catch (final ParseException ex) {}\n         try {\n             DateUtils.parseDate(null, parsers);\n             fail();\n-        } catch (IllegalArgumentException ex) {}\n+        } catch (final IllegalArgumentException ex) {}\n         try {\n             DateUtils.parseDate(dateStr, (String[]) null);\n             fail();\n-        } catch (IllegalArgumentException ex) {}\n+        } catch (final IllegalArgumentException ex) {}\n         try {\n             DateUtils.parseDate(dateStr, new String[0]);\n             fail();\n-        } catch (ParseException ex) {}\n+        } catch (final ParseException ex) {}\n     }\n     // LANG-486\n     @Test\n     public void testParseDateWithLeniency() throws Exception {\n-        GregorianCalendar cal = new GregorianCalendar(1998, 6, 30);\n-        String dateStr = \"02 942, 1996\";\n-        String[] parsers = new String[] {\"MM DDD, yyyy\"};\n+        final GregorianCalendar cal = new GregorianCalendar(1998, 6, 30);\n+        final String dateStr = \"02 942, 1996\";\n+        final String[] parsers = new String[] {\"MM DDD, yyyy\"};\n         \n         Date date = DateUtils.parseDate(dateStr, parsers);\n         assertEquals(cal.getTime(), date);\n         try {\n             date = DateUtils.parseDateStrictly(dateStr, parsers);\n             fail();\n-        } catch (ParseException ex) {}\n+        } catch (final ParseException ex) {}\n     }\n \n     //-----------------------------------------------------------------------\n     @Test\n     public void testAddYears() throws Exception {\n-        Date base = new Date(MILLIS_TEST);\n+        final Date base = new Date(MILLIS_TEST);\n         Date result = DateUtils.addYears(base, 0);\n         assertNotSame(base, result);\n         assertDate(base, 2000, 6, 5, 4, 3, 2, 1);\n     //-----------------------------------------------------------------------\n     @Test\n     public void testAddMonths() throws Exception {\n-        Date base = new Date(MILLIS_TEST);\n+        final Date base = new Date(MILLIS_TEST);\n         Date result = DateUtils.addMonths(base, 0);\n         assertNotSame(base, result);\n         assertDate(base, 2000, 6, 5, 4, 3, 2, 1);\n     //-----------------------------------------------------------------------\n     @Test\n     public void testAddWeeks() throws Exception {\n-        Date base = new Date(MILLIS_TEST);\n+        final Date base = new Date(MILLIS_TEST);\n         Date result = DateUtils.addWeeks(base, 0);\n         assertNotSame(base, result);\n         assertDate(base, 2000, 6, 5, 4, 3, 2, 1);\n     //-----------------------------------------------------------------------\n     @Test\n     public void testAddDays() throws Exception {\n-        Date base = new Date(MILLIS_TEST);\n+        final Date base = new Date(MILLIS_TEST);\n         Date result = DateUtils.addDays(base, 0);\n         assertNotSame(base, result);\n         assertDate(base, 2000, 6, 5, 4, 3, 2, 1);\n     //-----------------------------------------------------------------------\n     @Test\n     public void testAddHours() throws Exception {\n-        Date base = new Date(MILLIS_TEST);\n+        final Date base = new Date(MILLIS_TEST);\n         Date result = DateUtils.addHours(base, 0);\n         assertNotSame(base, result);\n         assertDate(base, 2000, 6, 5, 4, 3, 2, 1);\n     //-----------------------------------------------------------------------\n     @Test\n     public void testAddMinutes() throws Exception {\n-        Date base = new Date(MILLIS_TEST);\n+        final Date base = new Date(MILLIS_TEST);\n         Date result = DateUtils.addMinutes(base, 0);\n         assertNotSame(base, result);\n         assertDate(base, 2000, 6, 5, 4, 3, 2, 1);\n     //-----------------------------------------------------------------------\n     @Test\n     public void testAddSeconds() throws Exception {\n-        Date base = new Date(MILLIS_TEST);\n+        final Date base = new Date(MILLIS_TEST);\n         Date result = DateUtils.addSeconds(base, 0);\n         assertNotSame(base, result);\n         assertDate(base, 2000, 6, 5, 4, 3, 2, 1);\n     //-----------------------------------------------------------------------\n     @Test\n     public void testAddMilliseconds() throws Exception {\n-        Date base = new Date(MILLIS_TEST);\n+        final Date base = new Date(MILLIS_TEST);\n         Date result = DateUtils.addMilliseconds(base, 0);\n         assertNotSame(base, result);\n         assertDate(base, 2000, 6, 5, 4, 3, 2, 1);\n     // -----------------------------------------------------------------------\n     @Test\n     public void testSetYears() throws Exception {\n-        Date base = new Date(MILLIS_TEST);\n+        final Date base = new Date(MILLIS_TEST);\n         Date result = DateUtils.setYears(base, 2000);\n         assertNotSame(base, result);\n         assertDate(base, 2000, 6, 5, 4, 3, 2, 1);\n     // -----------------------------------------------------------------------\n     @Test\n     public void testSetMonths() throws Exception {\n-        Date base = new Date(MILLIS_TEST);\n+        final Date base = new Date(MILLIS_TEST);\n         Date result = DateUtils.setMonths(base, 5);\n         assertNotSame(base, result);\n         assertDate(base, 2000, 6, 5, 4, 3, 2, 1);\n         try {\n             result = DateUtils.setMonths(base, 12);\n             fail(\"DateUtils.setMonths did not throw an expected IllegalArguementException.\");\n-        } catch (IllegalArgumentException e) {\n+        } catch (final IllegalArgumentException e) {\n \n         }\n     }\n     // -----------------------------------------------------------------------\n     @Test\n     public void testSetDays() throws Exception {\n-        Date base = new Date(MILLIS_TEST);\n+        final Date base = new Date(MILLIS_TEST);\n         Date result = DateUtils.setDays(base, 1);\n         assertNotSame(base, result);\n         assertDate(base, 2000, 6, 5, 4, 3, 2, 1);\n         try {\n             result = DateUtils.setDays(base, 32);\n             fail(\"DateUtils.setDays did not throw an expected IllegalArguementException.\");\n-        } catch (IllegalArgumentException e) {\n+        } catch (final IllegalArgumentException e) {\n \n         }\n     }\n     // -----------------------------------------------------------------------\n     @Test\n     public void testSetHours() throws Exception {\n-        Date base = new Date(MILLIS_TEST);\n+        final Date base = new Date(MILLIS_TEST);\n         Date result = DateUtils.setHours(base, 0);\n         assertNotSame(base, result);\n         assertDate(base, 2000, 6, 5, 4, 3, 2, 1);\n         try {\n             result = DateUtils.setHours(base, 24);\n             fail(\"DateUtils.setHours did not throw an expected IllegalArguementException.\");\n-        } catch (IllegalArgumentException e) {\n+        } catch (final IllegalArgumentException e) {\n \n         }\n     }\n     // -----------------------------------------------------------------------\n     @Test\n     public void testSetMinutes() throws Exception {\n-        Date base = new Date(MILLIS_TEST);\n+        final Date base = new Date(MILLIS_TEST);\n         Date result = DateUtils.setMinutes(base, 0);\n         assertNotSame(base, result);\n         assertDate(base, 2000, 6, 5, 4, 3, 2, 1);\n         try {\n             result = DateUtils.setMinutes(base, 60);\n             fail(\"DateUtils.setMinutes did not throw an expected IllegalArguementException.\");\n-        } catch (IllegalArgumentException e) {\n+        } catch (final IllegalArgumentException e) {\n \n         }\n     }\n     // -----------------------------------------------------------------------\n     @Test\n     public void testSetSeconds() throws Exception {\n-        Date base = new Date(MILLIS_TEST);\n+        final Date base = new Date(MILLIS_TEST);\n         Date result = DateUtils.setSeconds(base, 0);\n         assertNotSame(base, result);\n         assertDate(base, 2000, 6, 5, 4, 3, 2, 1);\n         try {\n             result = DateUtils.setSeconds(base, 60);\n             fail(\"DateUtils.setSeconds did not throw an expected IllegalArguementException.\");\n-        } catch (IllegalArgumentException e) {\n+        } catch (final IllegalArgumentException e) {\n \n         }\n     }\n     // -----------------------------------------------------------------------\n     @Test\n     public void testSetMilliseconds() throws Exception {\n-        Date base = new Date(MILLIS_TEST);\n+        final Date base = new Date(MILLIS_TEST);\n         Date result = DateUtils.setMilliseconds(base, 0);\n         assertNotSame(base, result);\n         assertDate(base, 2000, 6, 5, 4, 3, 2, 1);\n         try {\n             result = DateUtils.setMilliseconds(base, 1000);\n             fail(\"DateUtils.setMilliseconds did not throw an expected IllegalArguementException.\");\n-        } catch (IllegalArgumentException e) {\n+        } catch (final IllegalArgumentException e) {\n \n         }\n     }\n \n     //-----------------------------------------------------------------------\n     private void assertDate(final Date date, final int year, final int month, final int day, final int hour, final int min, final int sec, final int mil) throws Exception {\n-        GregorianCalendar cal = new GregorianCalendar();\n+        final GregorianCalendar cal = new GregorianCalendar();\n         cal.setTime(date);\n         assertEquals(year, cal.get(Calendar.YEAR));\n         assertEquals(month, cal.get(Calendar.MONTH));\n         try {\n             DateUtils.toCalendar(null);\n             fail(\"Expected NullPointerException to be thrown\");\n-        } catch(NullPointerException npe) {\n+        } catch(final NullPointerException npe) {\n             // expected\n         }\n     }\n         try {\n             DateUtils.round((Date) null, Calendar.SECOND);\n             fail();\n-        } catch (IllegalArgumentException ex) {}\n+        } catch (final IllegalArgumentException ex) {}\n         try {\n             DateUtils.round((Calendar) null, Calendar.SECOND);\n             fail();\n-        } catch (IllegalArgumentException ex) {}\n+        } catch (final IllegalArgumentException ex) {}\n         try {\n             DateUtils.round((Object) null, Calendar.SECOND);\n             fail();\n-        } catch (IllegalArgumentException ex) {}\n+        } catch (final IllegalArgumentException ex) {}\n         try {\n             DateUtils.round(\"\", Calendar.SECOND);\n             fail();\n-        } catch (ClassCastException ex) {}\n+        } catch (final ClassCastException ex) {}\n         try {\n             DateUtils.round(date1, -9999);\n             fail();\n-        } catch(IllegalArgumentException ex) {}\n+        } catch(final IllegalArgumentException ex) {}\n \n         assertEquals(\"round ampm-1 failed\",\n                 dateTimeParser.parse(\"February 3, 2002 00:00:00.000\"),\n     {\n         TimeZone.setDefault(defaultZone);\n         dateTimeParser.setTimeZone(defaultZone);\n-        Calendar testCalendar = Calendar.getInstance();\n+        final Calendar testCalendar = Calendar.getInstance();\n         testCalendar.set(2007, 6, 2, 8, 8, 50);\n         Date date = testCalendar.getTime();\n         assertEquals(\"Minute Round Up Failed\",\n         try {\n             DateUtils.truncate((Date) null, Calendar.SECOND);\n             fail();\n-        } catch (IllegalArgumentException ex) {}\n+        } catch (final IllegalArgumentException ex) {}\n         try {\n             DateUtils.truncate((Calendar) null, Calendar.SECOND);\n             fail();\n-        } catch (IllegalArgumentException ex) {}\n+        } catch (final IllegalArgumentException ex) {}\n         try {\n             DateUtils.truncate((Object) null, Calendar.SECOND);\n             fail();\n-        } catch (IllegalArgumentException ex) {}\n+        } catch (final IllegalArgumentException ex) {}\n         try {\n             DateUtils.truncate(\"\", Calendar.SECOND);\n             fail();\n-        } catch (ClassCastException ex) {}\n+        } catch (final ClassCastException ex) {}\n \n         // Fix for http://issues.apache.org/bugzilla/show_bug.cgi?id=25560\n         // Test truncate across beginning of daylight saving time\n         dateTimeParser.setTimeZone(defaultZone);\n         \n         // Bug 31395, large dates\n-        Date endOfTime = new Date(Long.MAX_VALUE); // fyi: Sun Aug 17 07:12:55 CET 292278994 -- 807 millis\n-        GregorianCalendar endCal = new GregorianCalendar();\n+        final Date endOfTime = new Date(Long.MAX_VALUE); // fyi: Sun Aug 17 07:12:55 CET 292278994 -- 807 millis\n+        final GregorianCalendar endCal = new GregorianCalendar();\n         endCal.setTime(endOfTime);\n         try {\n             DateUtils.truncate(endCal, Calendar.DATE);\n             fail();\n-        } catch (ArithmeticException ex) {}\n+        } catch (final ArithmeticException ex) {}\n         endCal.set(Calendar.YEAR, 280000001);\n         try {\n             DateUtils.truncate(endCal, Calendar.DATE);\n             fail();\n-        } catch (ArithmeticException ex) {}\n+        } catch (final ArithmeticException ex) {}\n         endCal.set(Calendar.YEAR, 280000000);\n-        Calendar cal = DateUtils.truncate(endCal, Calendar.DATE);\n+        final Calendar cal = DateUtils.truncate(endCal, Calendar.DATE);\n         assertEquals(0, cal.get(Calendar.HOUR));\n     }\n \n         }\n \n         // Set TimeZone to Mountain Time\n-        TimeZone MST_MDT = TimeZone.getTimeZone(\"MST7MDT\");\n+        final TimeZone MST_MDT = TimeZone.getTimeZone(\"MST7MDT\");\n         TimeZone.setDefault(MST_MDT);\n-        DateFormat format = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss.SSS z\");\n+        final DateFormat format = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss.SSS z\");\n         format.setTimeZone(MST_MDT);\n \n-        Date oct31_01MDT = new Date(1099206000000L); \n-\n-        Date oct31MDT             = new Date(oct31_01MDT.getTime()       - 3600000L); // - 1 hour\n-        Date oct31_01_02MDT       = new Date(oct31_01MDT.getTime()       + 120000L);  // + 2 minutes\n-        Date oct31_01_02_03MDT    = new Date(oct31_01_02MDT.getTime()    + 3000L);    // + 3 seconds\n-        Date oct31_01_02_03_04MDT = new Date(oct31_01_02_03MDT.getTime() + 4L);       // + 4 milliseconds\n+        final Date oct31_01MDT = new Date(1099206000000L); \n+\n+        final Date oct31MDT             = new Date(oct31_01MDT.getTime()       - 3600000L); // - 1 hour\n+        final Date oct31_01_02MDT       = new Date(oct31_01MDT.getTime()       + 120000L);  // + 2 minutes\n+        final Date oct31_01_02_03MDT    = new Date(oct31_01_02MDT.getTime()    + 3000L);    // + 3 seconds\n+        final Date oct31_01_02_03_04MDT = new Date(oct31_01_02_03MDT.getTime() + 4L);       // + 4 milliseconds\n \n         assertEquals(\"Check 00:00:00.000\", \"2004-10-31 00:00:00.000 MDT\", format.format(oct31MDT));\n         assertEquals(\"Check 01:00:00.000\", \"2004-10-31 01:00:00.000 MDT\", format.format(oct31_01MDT));\n         assertEquals(\"Check 01:02:03.004\", \"2004-10-31 01:02:03.004 MDT\", format.format(oct31_01_02_03_04MDT));\n \n         // ------- Demonstrate Problem -------\n-        Calendar gval = Calendar.getInstance();\n+        final Calendar gval = Calendar.getInstance();\n         gval.setTime(new Date(oct31_01MDT.getTime()));\n         gval.set(Calendar.MINUTE, gval.get(Calendar.MINUTE)); // set minutes to the same value\n         assertEquals(\"Demonstrate Problem\", gval.getTime().getTime(), oct31_01MDT.getTime() + 3600000L);\n     // http://issues.apache.org/jira/browse/LANG-530\n     @Test\n     public void testLang530() throws ParseException {\n-        Date d = new Date();\n-        String isoDateStr = DateFormatUtils.ISO_DATETIME_TIME_ZONE_FORMAT.format(d);\n-        Date d2 = DateUtils.parseDate(isoDateStr, new String[] { DateFormatUtils.ISO_DATETIME_TIME_ZONE_FORMAT.getPattern() });\n+        final Date d = new Date();\n+        final String isoDateStr = DateFormatUtils.ISO_DATETIME_TIME_ZONE_FORMAT.format(d);\n+        final Date d2 = DateUtils.parseDate(isoDateStr, new String[] { DateFormatUtils.ISO_DATETIME_TIME_ZONE_FORMAT.getPattern() });\n         // the format loses milliseconds so have to reintroduce them\n         assertEquals(\"Date not equal to itself ISO formatted and parsed\", d.getTime(), d2.getTime() + d.getTime() % 1000); \n     }\n         try {\n             DateUtils.ceiling((Date) null, Calendar.SECOND);\n             fail();\n-        } catch (IllegalArgumentException ex) {}\n+        } catch (final IllegalArgumentException ex) {}\n         try {\n             DateUtils.ceiling((Calendar) null, Calendar.SECOND);\n             fail();\n-        } catch (IllegalArgumentException ex) {}\n+        } catch (final IllegalArgumentException ex) {}\n         try {\n             DateUtils.ceiling((Object) null, Calendar.SECOND);\n             fail();\n-        } catch (IllegalArgumentException ex) {}\n+        } catch (final IllegalArgumentException ex) {}\n         try {\n             DateUtils.ceiling(\"\", Calendar.SECOND);\n             fail();\n-        } catch (ClassCastException ex) {}\n+        } catch (final ClassCastException ex) {}\n         try {\n             DateUtils.ceiling(date1, -9999);\n             fail();\n-        } catch(IllegalArgumentException ex) {}\n+        } catch(final IllegalArgumentException ex) {}\n \n         \n         // Fix for http://issues.apache.org/bugzilla/show_bug.cgi?id=25560\n         dateTimeParser.setTimeZone(defaultZone);\n         \n      // Bug 31395, large dates\n-        Date endOfTime = new Date(Long.MAX_VALUE); // fyi: Sun Aug 17 07:12:55 CET 292278994 -- 807 millis\n-        GregorianCalendar endCal = new GregorianCalendar();\n+        final Date endOfTime = new Date(Long.MAX_VALUE); // fyi: Sun Aug 17 07:12:55 CET 292278994 -- 807 millis\n+        final GregorianCalendar endCal = new GregorianCalendar();\n         endCal.setTime(endOfTime);\n         try {\n             DateUtils.ceiling(endCal, Calendar.DATE);\n             fail();\n-        } catch (ArithmeticException ex) {}\n+        } catch (final ArithmeticException ex) {}\n         endCal.set(Calendar.YEAR, 280000001);\n         try {\n             DateUtils.ceiling(endCal, Calendar.DATE);\n             fail();\n-        } catch (ArithmeticException ex) {}\n+        } catch (final ArithmeticException ex) {}\n         endCal.set(Calendar.YEAR, 280000000);\n-        Calendar cal = DateUtils.ceiling(endCal, Calendar.DATE);\n+        final Calendar cal = DateUtils.ceiling(endCal, Calendar.DATE);\n         assertEquals(0, cal.get(Calendar.HOUR));\n     }\n \n     public void testIteratorEx() throws Exception {\n         try {\n             DateUtils.iterator(Calendar.getInstance(), -9999);\n-        } catch (IllegalArgumentException ex) {}\n+        } catch (final IllegalArgumentException ex) {}\n         try {\n             DateUtils.iterator((Date) null, DateUtils.RANGE_WEEK_CENTER);\n             fail();\n-        } catch (IllegalArgumentException ex) {}\n+        } catch (final IllegalArgumentException ex) {}\n         try {\n             DateUtils.iterator((Calendar) null, DateUtils.RANGE_WEEK_CENTER);\n             fail();\n-        } catch (IllegalArgumentException ex) {}\n+        } catch (final IllegalArgumentException ex) {}\n         try {\n             DateUtils.iterator((Object) null, DateUtils.RANGE_WEEK_CENTER);\n             fail();\n-        } catch (IllegalArgumentException ex) {}\n+        } catch (final IllegalArgumentException ex) {}\n         try {\n             DateUtils.iterator(\"\", DateUtils.RANGE_WEEK_CENTER);\n             fail();\n-        } catch (ClassCastException ex) {}\n+        } catch (final ClassCastException ex) {}\n     }\n \n     /**\n      */\n     @Test\n     public void testWeekIterator() throws Exception {\n-        Calendar now = Calendar.getInstance();\n+        final Calendar now = Calendar.getInstance();\n         for (int i = 0; i< 7; i++) {\n-            Calendar today = DateUtils.truncate(now, Calendar.DATE);\n-            Calendar sunday = DateUtils.truncate(now, Calendar.DATE);\n+            final Calendar today = DateUtils.truncate(now, Calendar.DATE);\n+            final Calendar sunday = DateUtils.truncate(now, Calendar.DATE);\n             sunday.add(Calendar.DATE, 1 - sunday.get(Calendar.DAY_OF_WEEK));\n-            Calendar monday = DateUtils.truncate(now, Calendar.DATE);\n+            final Calendar monday = DateUtils.truncate(now, Calendar.DATE);\n             if (monday.get(Calendar.DAY_OF_WEEK) == 1) {\n                 //This is sunday... roll back 6 days\n                 monday.add(Calendar.DATE, -6);\n             } else {\n                 monday.add(Calendar.DATE, 2 - monday.get(Calendar.DAY_OF_WEEK));\n             }\n-            Calendar centered = DateUtils.truncate(now, Calendar.DATE);\n+            final Calendar centered = DateUtils.truncate(now, Calendar.DATE);\n             centered.add(Calendar.DATE, -3);\n             \n             Iterator<?> it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_SUNDAY);\n             try {\n                 it.next();\n                 fail();\n-            } catch (NoSuchElementException ex) {}\n+            } catch (final NoSuchElementException ex) {}\n             it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_CENTER);\n             it.next();\n             try {\n                 it.remove();\n-            } catch( UnsupportedOperationException ex) {}\n+            } catch( final UnsupportedOperationException ex) {}\n             \n             now.add(Calendar.DATE,1);\n         }\n \n     @Test\n     public void testLANG799_EN_OK() throws ParseException {\n-        Locale dflt = Locale.getDefault();\n+        final Locale dflt = Locale.getDefault();\n         Locale.setDefault(Locale.ENGLISH);\n         try {\n             DateUtils.parseDate(\"Wed, 09 Apr 2008 23:55:38 GMT\", \"EEE, dd MMM yyyy HH:mm:ss zzz\");\n     // Parse German date with English Locale\n     @Test(expected=ParseException.class)\n     public void testLANG799_EN_FAIL() throws ParseException {\n-        Locale dflt = Locale.getDefault();\n+        final Locale dflt = Locale.getDefault();\n         Locale.setDefault(Locale.ENGLISH);\n         try {\n             DateUtils.parseDate(\"Mi, 09 Apr 2008 23:55:38 GMT\", \"EEE, dd MMM yyyy HH:mm:ss zzz\");\n \n     @Test\n     public void testLANG799_DE_OK() throws ParseException {\n-        Locale dflt = Locale.getDefault();\n+        final Locale dflt = Locale.getDefault();\n         Locale.setDefault(Locale.GERMAN);\n         try {\n             DateUtils.parseDate(\"Mi, 09 Apr 2008 23:55:38 GMT\", \"EEE, dd MMM yyyy HH:mm:ss zzz\");\n     // Parse English date with German Locale\n     @Test(expected=ParseException.class)\n     public void testLANG799_DE_FAIL() throws ParseException {\n-        Locale dflt = Locale.getDefault();\n+        final Locale dflt = Locale.getDefault();\n         Locale.setDefault(Locale.GERMAN);\n         try {\n             DateUtils.parseDate(\"Wed, 09 Apr 2008 23:55:38 GMT\", \"EEE, dd MMM yyyy HH:mm:ss zzz\");\n     // Parse German date with English Locale, specifying German Locale override\n     @Test\n     public void testLANG799_EN_WITH_DE_LOCALE() throws ParseException {\n-        Locale dflt = Locale.getDefault();\n+        final Locale dflt = Locale.getDefault();\n         Locale.setDefault(Locale.ENGLISH);\n         try {\n             DateUtils.parseDate(\"Mi, 09 Apr 2008 23:55:38 GMT\", Locale.GERMAN, \"EEE, dd MMM yyyy HH:mm:ss zzz\");\n      * that are dates (no time), and exactly 1 day spaced after each other.\n      */\n     private static void assertWeekIterator(final Iterator<?> it, final Calendar start) {\n-        Calendar end = (Calendar) start.clone();\n+        final Calendar end = (Calendar) start.clone();\n         end.add(Calendar.DATE, 6);\n \n         assertWeekIterator(it, start, end);\n      * Convenience method for when working with Date objects\n      */\n     private static void assertWeekIterator(final Iterator<?> it, final Date start, final Date end) {\n-        Calendar calStart = Calendar.getInstance();\n+        final Calendar calStart = Calendar.getInstance();\n         calStart.setTime(start);\n-        Calendar calEnd = Calendar.getInstance();\n+        final Calendar calEnd = Calendar.getInstance();\n         calEnd.setTime(end);\n \n         assertWeekIterator(it, calStart, calEnd);\n--- a/src/test/java/org/apache/commons/lang3/time/DurationFormatUtilsTest.java\n+++ b/src/test/java/org/apache/commons/lang3/time/DurationFormatUtilsTest.java\n     @Test\n     public void testConstructor() {\n         assertNotNull(new DurationFormatUtils());\n-        Constructor<?>[] cons = DurationFormatUtils.class.getDeclaredConstructors();\n+        final Constructor<?>[] cons = DurationFormatUtils.class.getDeclaredConstructors();\n         assertEquals(1, cons.length);\n         assertTrue(Modifier.isPublic(cons[0].getModifiers()));\n         assertTrue(Modifier.isPublic(DurationFormatUtils.class.getModifiers()));\n      */\n     @Test\n     public void testFormatDurationPluralWords() {\n-        long oneSecond = 1000;\n-        long oneMinute = oneSecond * 60;\n-        long oneHour = oneMinute * 60;\n-        long oneDay = oneHour * 24;\n+        final long oneSecond = 1000;\n+        final long oneMinute = oneSecond * 60;\n+        final long oneHour = oneMinute * 60;\n+        final long oneDay = oneHour * 24;\n         String text = null;\n \n         text = DurationFormatUtils.formatDurationWords(oneSecond, false, false);\n         assertEquals(\"60000\", DurationFormatUtils.formatDuration(duration, \"S\"));\n         assertEquals(\"01:00\", DurationFormatUtils.formatDuration(duration, \"mm:ss\"));\n \n-        Calendar base = Calendar.getInstance();\n+        final Calendar base = Calendar.getInstance();\n         base.set(2000, 0, 1, 0, 0, 0);\n         base.set(Calendar.MILLISECOND, 0);\n \n-        Calendar cal = Calendar.getInstance();\n+        final Calendar cal = Calendar.getInstance();\n         cal.set(2003, 1, 1, 0, 0, 0);\n         cal.set(Calendar.MILLISECOND, 0);\n         duration = cal.getTime().getTime() - base.getTime().getTime(); // duration from 2000-01-01 to cal\n         // don't use 1970 in test as time zones were less reliable in 1970 than now\n         // remember that duration formatting ignores time zones, working on strict hour lengths\n-        int days = 366 + 365 + 365 + 31;\n+        final int days = 366 + 365 + 365 + 31;\n         assertEquals(\"0 0 \" + days, DurationFormatUtils.formatDuration(duration, \"y M d\"));\n     }\n \n     @Test\n     public void testFormatPeriodISO() {\n-        TimeZone timeZone = TimeZone.getTimeZone(\"GMT-3\");\n-        Calendar base = Calendar.getInstance(timeZone);\n+        final TimeZone timeZone = TimeZone.getTimeZone(\"GMT-3\");\n+        final Calendar base = Calendar.getInstance(timeZone);\n         base.set(1970, 0, 1, 0, 0, 0);\n         base.set(Calendar.MILLISECOND, 0);\n \n-        Calendar cal = Calendar.getInstance(timeZone);\n+        final Calendar cal = Calendar.getInstance(timeZone);\n         cal.set(2002, 1, 23, 9, 11, 12);\n         cal.set(Calendar.MILLISECOND, 1);\n         String text;\n \n     @Test\n     public void testFormatPeriod() {\n-        Calendar cal1970 = Calendar.getInstance();\n+        final Calendar cal1970 = Calendar.getInstance();\n         cal1970.set(1970, 0, 1, 0, 0, 0);\n         cal1970.set(Calendar.MILLISECOND, 0);\n-        long time1970 = cal1970.getTime().getTime();\n+        final long time1970 = cal1970.getTime().getTime();\n \n         assertEquals(\"0\", DurationFormatUtils.formatPeriod(time1970, time1970, \"y\"));\n         assertEquals(\"0\", DurationFormatUtils.formatPeriod(time1970, time1970, \"M\"));\n         assertEquals(\"60000\", DurationFormatUtils.formatPeriod(time1970, time, \"S\"));\n         assertEquals(\"01:00\", DurationFormatUtils.formatPeriod(time1970, time, \"mm:ss\"));\n \n-        Calendar cal = Calendar.getInstance();\n+        final Calendar cal = Calendar.getInstance();\n         cal.set(1973, 6, 1, 0, 0, 0);\n         cal.set(Calendar.MILLISECOND, 0);\n         time = cal.getTime().getTime();\n                 .lexx(DurationFormatUtils.ISO_EXTENDED_FORMAT_PATTERN));\n \n         // test failures in equals\n-        DurationFormatUtils.Token token = new DurationFormatUtils.Token(DurationFormatUtils.y, 4);\n+        final DurationFormatUtils.Token token = new DurationFormatUtils.Token(DurationFormatUtils.y, 4);\n         assertFalse(\"Token equal to non-Token class. \", token.equals(new Object()));\n         assertFalse(\"Token equal to Token with wrong value class. \", token.equals(new DurationFormatUtils.Token(\n                 new Object())));\n         assertFalse(\"Token equal to Token with different count. \", token.equals(new DurationFormatUtils.Token(\n                 DurationFormatUtils.y, 1)));\n-        DurationFormatUtils.Token numToken = new DurationFormatUtils.Token(Integer.valueOf(1), 4);\n+        final DurationFormatUtils.Token numToken = new DurationFormatUtils.Token(Integer.valueOf(1), 4);\n         assertTrue(\"Token with Number value not equal to itself. \", numToken.equals(numToken));\n     }\n \n \n     @Test\n     public void testLANG815() {\n-        Calendar calendar = Calendar.getInstance();\n+        final Calendar calendar = Calendar.getInstance();\n         calendar.set(2012, 6, 30, 0, 0, 0);\n-        long startMillis = calendar.getTimeInMillis();\n+        final long startMillis = calendar.getTimeInMillis();\n \n         calendar.set(2012, 8, 8);\n-        long endMillis = calendar.getTimeInMillis();\n+        final long endMillis = calendar.getTimeInMillis();\n \n         assertEquals(\"1 9\", DurationFormatUtils.formatPeriod(startMillis, endMillis, \"M d\"));\n     }\n //    }        \n     \n     private void bruteForce(final int year, final int month, final int day, final String format, final int calendarType) {\n-        String msg = year + \"-\" + month + \"-\" + day + \" to \";\n-        Calendar c = Calendar.getInstance();\n+        final String msg = year + \"-\" + month + \"-\" + day + \" to \";\n+        final Calendar c = Calendar.getInstance();\n         c.set(year, month, day, 0, 0, 0);\n-        int[] array1 = new int[] { year, month, day, 0, 0, 0 };\n-        int[] array2 = new int[] { year, month, day, 0, 0, 0 };\n+        final int[] array1 = new int[] { year, month, day, 0, 0, 0 };\n+        final int[] array2 = new int[] { year, month, day, 0, 0, 0 };\n         for (int i=0; i < FOUR_YEARS; i++) {\n             array2[0] = c.get(Calendar.YEAR);\n             array2[1] = c.get(Calendar.MONTH);\n             array2[2] = c.get(Calendar.DAY_OF_MONTH);\n-            String tmpMsg = msg + array2[0] + \"-\" + array2[1] + \"-\" + array2[2] + \" at \";\n+            final String tmpMsg = msg + array2[0] + \"-\" + array2[1] + \"-\" + array2[2] + \" at \";\n             assertEqualDuration( tmpMsg + i, Integer.toString(i), array1, array2, format );\n             c.add(calendarType, 1);\n         }\n         assertEqualDuration(null, expected, start, end, format);\n     }\n     private void assertEqualDuration(final String message, final String expected, final int[] start, final int[] end, final String format) {\n-        Calendar cal1 = Calendar.getInstance();\n+        final Calendar cal1 = Calendar.getInstance();\n         cal1.set(start[0], start[1], start[2], start[3], start[4], start[5]);\n         cal1.set(Calendar.MILLISECOND, 0);\n-        Calendar cal2 = Calendar.getInstance();\n+        final Calendar cal2 = Calendar.getInstance();\n         cal2.set(end[0], end[1], end[2], end[3], end[4], end[5]);\n         cal2.set(Calendar.MILLISECOND, 0);\n-        long milli1 = cal1.getTime().getTime();\n-        long milli2 = cal2.getTime().getTime();\n-        String result = DurationFormatUtils.formatPeriod(milli1, milli2, format);\n+        final long milli1 = cal1.getTime().getTime();\n+        final long milli2 = cal2.getTime().getTime();\n+        final String result = DurationFormatUtils.formatPeriod(milli1, milli2, format);\n         if (message == null) {\n             assertEquals(expected, result);\n         } else {\n--- a/src/test/java/org/apache/commons/lang3/time/FastDateFormatTest.java\n+++ b/src/test/java/org/apache/commons/lang3/time/FastDateFormatTest.java\n      */\n     @Test\n     public void test_getInstance() {\n-        FastDateFormat format1 = FastDateFormat.getInstance();\n-        FastDateFormat format2 = FastDateFormat.getInstance();\n+        final FastDateFormat format1 = FastDateFormat.getInstance();\n+        final FastDateFormat format2 = FastDateFormat.getInstance();\n         assertSame(format1, format2);\n     }\n \n     @Test\n     public void test_getInstance_String() {\n-        FastDateFormat format1 = FastDateFormat.getInstance(\"MM/DD/yyyy\");\n-        FastDateFormat format2 = FastDateFormat.getInstance(\"MM-DD-yyyy\");\n-        FastDateFormat format3 = FastDateFormat.getInstance(\"MM-DD-yyyy\");\n+        final FastDateFormat format1 = FastDateFormat.getInstance(\"MM/DD/yyyy\");\n+        final FastDateFormat format2 = FastDateFormat.getInstance(\"MM-DD-yyyy\");\n+        final FastDateFormat format3 = FastDateFormat.getInstance(\"MM-DD-yyyy\");\n \n         assertTrue(format1 != format2); // -- junit 3.8 version -- assertFalse(format1 == format2);\n         assertSame(format2, format3);\n \n     @Test\n     public void test_getInstance_String_TimeZone() {\n-        Locale realDefaultLocale = Locale.getDefault();\n-        TimeZone realDefaultZone = TimeZone.getDefault();\n+        final Locale realDefaultLocale = Locale.getDefault();\n+        final TimeZone realDefaultZone = TimeZone.getDefault();\n         try {\n             Locale.setDefault(Locale.US);\n             TimeZone.setDefault(TimeZone.getTimeZone(\"America/New_York\"));\n \n-            FastDateFormat format1 = FastDateFormat.getInstance(\"MM/DD/yyyy\",\n+            final FastDateFormat format1 = FastDateFormat.getInstance(\"MM/DD/yyyy\",\n                     TimeZone.getTimeZone(\"Atlantic/Reykjavik\"));\n-            FastDateFormat format2 = FastDateFormat.getInstance(\"MM/DD/yyyy\");\n-            FastDateFormat format3 = FastDateFormat.getInstance(\"MM/DD/yyyy\", TimeZone.getDefault());\n-            FastDateFormat format4 = FastDateFormat.getInstance(\"MM/DD/yyyy\", TimeZone.getDefault());\n-            FastDateFormat format5 = FastDateFormat.getInstance(\"MM-DD-yyyy\", TimeZone.getDefault());\n-            FastDateFormat format6 = FastDateFormat.getInstance(\"MM-DD-yyyy\");\n+            final FastDateFormat format2 = FastDateFormat.getInstance(\"MM/DD/yyyy\");\n+            final FastDateFormat format3 = FastDateFormat.getInstance(\"MM/DD/yyyy\", TimeZone.getDefault());\n+            final FastDateFormat format4 = FastDateFormat.getInstance(\"MM/DD/yyyy\", TimeZone.getDefault());\n+            final FastDateFormat format5 = FastDateFormat.getInstance(\"MM-DD-yyyy\", TimeZone.getDefault());\n+            final FastDateFormat format6 = FastDateFormat.getInstance(\"MM-DD-yyyy\");\n \n             assertTrue(format1 != format2); // -- junit 3.8 version -- assertFalse(format1 == format2);\n             assertEquals(TimeZone.getTimeZone(\"Atlantic/Reykjavik\"), format1.getTimeZone());\n \n     @Test\n     public void test_getInstance_String_Locale() {\n-        Locale realDefaultLocale = Locale.getDefault();\n-        try {\n-            Locale.setDefault(Locale.US);\n-            FastDateFormat format1 = FastDateFormat.getInstance(\"MM/DD/yyyy\", Locale.GERMANY);\n-            FastDateFormat format2 = FastDateFormat.getInstance(\"MM/DD/yyyy\");\n-            FastDateFormat format3 = FastDateFormat.getInstance(\"MM/DD/yyyy\", Locale.GERMANY);\n+        final Locale realDefaultLocale = Locale.getDefault();\n+        try {\n+            Locale.setDefault(Locale.US);\n+            final FastDateFormat format1 = FastDateFormat.getInstance(\"MM/DD/yyyy\", Locale.GERMANY);\n+            final FastDateFormat format2 = FastDateFormat.getInstance(\"MM/DD/yyyy\");\n+            final FastDateFormat format3 = FastDateFormat.getInstance(\"MM/DD/yyyy\", Locale.GERMANY);\n \n             assertTrue(format1 != format2); // -- junit 3.8 version -- assertFalse(format1 == format2);\n             assertSame(format1, format3);\n \n     @Test\n     public void test_changeDefault_Locale_DateInstance() {\n-        Locale realDefaultLocale = Locale.getDefault();\n-        try {\n-            Locale.setDefault(Locale.US);\n-            FastDateFormat format1 = FastDateFormat.getDateInstance(FastDateFormat.FULL, Locale.GERMANY);\n-            FastDateFormat format2 = FastDateFormat.getDateInstance(FastDateFormat.FULL);\n+        final Locale realDefaultLocale = Locale.getDefault();\n+        try {\n+            Locale.setDefault(Locale.US);\n+            final FastDateFormat format1 = FastDateFormat.getDateInstance(FastDateFormat.FULL, Locale.GERMANY);\n+            final FastDateFormat format2 = FastDateFormat.getDateInstance(FastDateFormat.FULL);\n             Locale.setDefault(Locale.GERMANY);\n-            FastDateFormat format3 = FastDateFormat.getDateInstance(FastDateFormat.FULL);\n+            final FastDateFormat format3 = FastDateFormat.getDateInstance(FastDateFormat.FULL);\n \n             assertSame(Locale.GERMANY, format1.getLocale());\n             assertSame(Locale.US, format2.getLocale());\n \n     @Test\n     public void test_changeDefault_Locale_DateTimeInstance() {\n-        Locale realDefaultLocale = Locale.getDefault();\n-        try {\n-            Locale.setDefault(Locale.US);\n-            FastDateFormat format1 = FastDateFormat.getDateTimeInstance(FastDateFormat.FULL, FastDateFormat.FULL, Locale.GERMANY);\n-            FastDateFormat format2 = FastDateFormat.getDateTimeInstance(FastDateFormat.FULL, FastDateFormat.FULL);\n+        final Locale realDefaultLocale = Locale.getDefault();\n+        try {\n+            Locale.setDefault(Locale.US);\n+            final FastDateFormat format1 = FastDateFormat.getDateTimeInstance(FastDateFormat.FULL, FastDateFormat.FULL, Locale.GERMANY);\n+            final FastDateFormat format2 = FastDateFormat.getDateTimeInstance(FastDateFormat.FULL, FastDateFormat.FULL);\n             Locale.setDefault(Locale.GERMANY);\n-            FastDateFormat format3 = FastDateFormat.getDateTimeInstance(FastDateFormat.FULL, FastDateFormat.FULL);\n+            final FastDateFormat format3 = FastDateFormat.getDateTimeInstance(FastDateFormat.FULL, FastDateFormat.FULL);\n \n             assertSame(Locale.GERMANY, format1.getLocale());\n             assertSame(Locale.US, format2.getLocale());\n \n     @Test\n     public void test_getInstance_String_TimeZone_Locale() {\n-        Locale realDefaultLocale = Locale.getDefault();\n-        TimeZone realDefaultZone = TimeZone.getDefault();\n+        final Locale realDefaultLocale = Locale.getDefault();\n+        final TimeZone realDefaultZone = TimeZone.getDefault();\n         try {\n             Locale.setDefault(Locale.US);\n             TimeZone.setDefault(TimeZone.getTimeZone(\"America/New_York\"));\n \n-            FastDateFormat format1 = FastDateFormat.getInstance(\"MM/DD/yyyy\",\n+            final FastDateFormat format1 = FastDateFormat.getInstance(\"MM/DD/yyyy\",\n                     TimeZone.getTimeZone(\"Atlantic/Reykjavik\"), Locale.GERMANY);\n-            FastDateFormat format2 = FastDateFormat.getInstance(\"MM/DD/yyyy\", Locale.GERMANY);\n-            FastDateFormat format3 = FastDateFormat.getInstance(\"MM/DD/yyyy\",\n+            final FastDateFormat format2 = FastDateFormat.getInstance(\"MM/DD/yyyy\", Locale.GERMANY);\n+            final FastDateFormat format3 = FastDateFormat.getInstance(\"MM/DD/yyyy\",\n                     TimeZone.getDefault(), Locale.GERMANY);\n \n             assertTrue(format1 != format2); // -- junit 3.8 version -- assertNotSame(format1, format2);\n \n     @Test\n     public void testCheckDefaults() {\n-        FastDateFormat format = FastDateFormat.getInstance();\n-        FastDateFormat medium = FastDateFormat.getDateTimeInstance(FastDateFormat.SHORT, FastDateFormat.SHORT);\n+        final FastDateFormat format = FastDateFormat.getInstance();\n+        final FastDateFormat medium = FastDateFormat.getDateTimeInstance(FastDateFormat.SHORT, FastDateFormat.SHORT);\n         assertEquals(medium, format);\n         \n-        SimpleDateFormat sdf = new SimpleDateFormat();\n+        final SimpleDateFormat sdf = new SimpleDateFormat();\n         assertEquals(sdf.toPattern(), format.getPattern());\n         \n         assertEquals(Locale.getDefault(), format.getLocale());\n \n     @Test\n     public void testCheckDifferingStyles() {\n-        FastDateFormat shortShort = FastDateFormat.getDateTimeInstance(FastDateFormat.SHORT, FastDateFormat.SHORT, Locale.US);\n-        FastDateFormat shortLong = FastDateFormat.getDateTimeInstance(FastDateFormat.SHORT, FastDateFormat.LONG, Locale.US);\n-        FastDateFormat longShort = FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.SHORT, Locale.US);\n-        FastDateFormat longLong = FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.LONG, Locale.US);\n+        final FastDateFormat shortShort = FastDateFormat.getDateTimeInstance(FastDateFormat.SHORT, FastDateFormat.SHORT, Locale.US);\n+        final FastDateFormat shortLong = FastDateFormat.getDateTimeInstance(FastDateFormat.SHORT, FastDateFormat.LONG, Locale.US);\n+        final FastDateFormat longShort = FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.SHORT, Locale.US);\n+        final FastDateFormat longLong = FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.LONG, Locale.US);\n         \n         assertFalse(shortShort.equals(shortLong));\n         assertFalse(shortShort.equals(longShort));\n         final String pattern = \"yyyy-MM-dd'T'HH:mm:ss.SSS Z\";\n         final FastDateFormat formatter= FastDateFormat.getInstance(pattern);\n         \n-        long sdfTime= measureTime(formatter, new SimpleDateFormat(pattern) {\n+        final long sdfTime= measureTime(formatter, new SimpleDateFormat(pattern) {\n                         private static final long serialVersionUID = 1L;  // because SimpleDateFormat is serializable\n \n                         @Override\n                         }\n         });\n         \n-        long fdfTime= measureTime(formatter, FastDateFormat.getInstance(pattern));\n-        \n-        String times= \">>FastDateFormatTest: FastDateParser:\"+fdfTime+\"  SimpleDateFormat:\"+sdfTime;\n+        final long fdfTime= measureTime(formatter, FastDateFormat.getInstance(pattern));\n+        \n+        final String times= \">>FastDateFormatTest: FastDateParser:\"+fdfTime+\"  SimpleDateFormat:\"+sdfTime;\n         System.out.println(times);\n     }\n \n                 public void run() {\n                     for(int i= 0; i<NROUNDS; ++i) {\n                         try {\n-                            Date date= new Date();\n-                            String formattedDate= formatter.format(date);\n-                            long start= System.currentTimeMillis();        \n-                            Object pd= parser.parseObject(formattedDate);\n+                            final Date date= new Date();\n+                            final String formattedDate= formatter.format(date);\n+                            final long start= System.currentTimeMillis();        \n+                            final Object pd= parser.parseObject(formattedDate);\n                             totalElapsed.addAndGet(System.currentTimeMillis()-start);\n                             if(!date.equals(pd)) {\n                                 failures.incrementAndGet();\n                             }\n-                        } catch (Exception e) {\n+                        } catch (final Exception e) {\n                             failures.incrementAndGet();\n                             e.printStackTrace();\n                         }\n--- a/src/test/java/org/apache/commons/lang3/time/FastDateParserTest.java\n+++ b/src/test/java/org/apache/commons/lang3/time/FastDateParserTest.java\n \n     @Test\n     public void test_Equality_Hash() {\n-        DateParser[] parsers= {\n+        final DateParser[] parsers= {\n             getInstance(yMdHmsSZ, NEW_YORK, Locale.US),\n             getInstance(DMY_DOT, NEW_YORK, Locale.US),\n             getInstance(YMD_SLASH, NEW_YORK, Locale.US),\n             getInstance(MDY_SLASH, REYKJAVIK, SWEDEN)\n         };\n \n-        Map<DateParser,Integer> map= new HashMap<DateParser,Integer>();\n+        final Map<DateParser,Integer> map= new HashMap<DateParser,Integer>();\n         int i= 0;\n-        for(DateParser parser:parsers) {\n+        for(final DateParser parser:parsers) {\n             map.put(parser, Integer.valueOf(i++));\n         }\n \n         i= 0;\n-        for(DateParser parser:parsers) {\n+        for(final DateParser parser:parsers) {\n             assertEquals(i++, map.get(parser).intValue());\n         }\n     }\n \n     @Test\n     public void testParseZone() throws ParseException {\n-        Calendar cal= Calendar.getInstance(NEW_YORK, Locale.US);\n+        final Calendar cal= Calendar.getInstance(NEW_YORK, Locale.US);\n         cal.clear();\n         cal.set(2003, 6, 10, 16, 33, 20);\n \n-        DateParser fdf = getInstance(yMdHmsSZ, NEW_YORK, Locale.US);\n+        final DateParser fdf = getInstance(yMdHmsSZ, NEW_YORK, Locale.US);\n \n         assertEquals(cal.getTime(), fdf.parse(\"2003-07-10T15:33:20.000 -0500\"));\n         assertEquals(cal.getTime(), fdf.parse(\"2003-07-10T15:33:20.000 GMT-05:00\"));\n \n     @Test\n     public void testParseLongShort() throws ParseException {\n-        Calendar cal= Calendar.getInstance(NEW_YORK, Locale.US);\n+        final Calendar cal= Calendar.getInstance(NEW_YORK, Locale.US);\n         cal.clear();\n         cal.set(2003, 1, 10, 15, 33, 20);\n         cal.set(Calendar.MILLISECOND, 989);\n         assertEquals(cal.getTime(), fdf.parse(\"2003 AD February 0010 PM Monday 0015 0033 0020 0989 GMT-05:00\"));\n         cal.set(Calendar.ERA, GregorianCalendar.BC);\n \n-        Date parse = fdf.parse(\"2003 BC February 0010 PM Saturday 0015 0033 0020 0989 GMT-05:00\");\n+        final Date parse = fdf.parse(\"2003 BC February 0010 PM Saturday 0015 0033 0020 0989 GMT-05:00\");\n                 assertEquals(cal.getTime(), parse);\n \n         fdf = getInstance(\"y G M d a E H m s S Z\", NEW_YORK, Locale.US);\n \n     @Test\n     public void testAmPm() throws ParseException {\n-        Calendar cal= Calendar.getInstance(NEW_YORK, Locale.US);\n-        cal.clear();\n-\n-        DateParser h = getInstance(\"yyyy-MM-dd hh a mm:ss\", NEW_YORK, Locale.US);\n-        DateParser K = getInstance(\"yyyy-MM-dd KK a mm:ss\", NEW_YORK, Locale.US);\n-        DateParser k = getInstance(\"yyyy-MM-dd kk:mm:ss\", NEW_YORK, Locale.US);\n-        DateParser H = getInstance(\"yyyy-MM-dd HH:mm:ss\", NEW_YORK, Locale.US);\n+        final Calendar cal= Calendar.getInstance(NEW_YORK, Locale.US);\n+        cal.clear();\n+\n+        final DateParser h = getInstance(\"yyyy-MM-dd hh a mm:ss\", NEW_YORK, Locale.US);\n+        final DateParser K = getInstance(\"yyyy-MM-dd KK a mm:ss\", NEW_YORK, Locale.US);\n+        final DateParser k = getInstance(\"yyyy-MM-dd kk:mm:ss\", NEW_YORK, Locale.US);\n+        final DateParser H = getInstance(\"yyyy-MM-dd HH:mm:ss\", NEW_YORK, Locale.US);\n \n         cal.set(2010, 7, 1, 0, 33, 20);\n         assertEquals(cal.getTime(), h.parse(\"2010-08-01 12 AM 33:20\"));\n     @Test\n     // Check that all Locales can parse the formats we use\n     public void testParses() throws Exception {\n-        for(Locale locale : Locale.getAvailableLocales()) {\n-            for(TimeZone tz : new TimeZone[]{NEW_YORK, GMT}) {\n-                Calendar cal = Calendar.getInstance(tz);\n-                for(int year : new int[]{2003, 1940, 1868, 1867, 0, -1940}) {\n+        for(final Locale locale : Locale.getAvailableLocales()) {\n+            for(final TimeZone tz : new TimeZone[]{NEW_YORK, GMT}) {\n+                final Calendar cal = Calendar.getInstance(tz);\n+                for(final int year : new int[]{2003, 1940, 1868, 1867, 0, -1940}) {\n                     // http://docs.oracle.com/javase/6/docs/technotes/guides/intl/calendar.doc.html\n                     if (year < 1868 && locale.equals(FastDateParser.JAPANESE_IMPERIAL)) {\n                         continue; // Japanese imperial calendar does not support eras before 1868\n                     } else {\n                         cal.set(year, 1, 10);\n                     }\n-                    Date in = cal.getTime();\n-                    for(String format : new String[]{LONG_FORMAT, SHORT_FORMAT}) {\n-                        SimpleDateFormat sdf = new SimpleDateFormat(format, locale);\n+                    final Date in = cal.getTime();\n+                    for(final String format : new String[]{LONG_FORMAT, SHORT_FORMAT}) {\n+                        final SimpleDateFormat sdf = new SimpleDateFormat(format, locale);\n                         if (format.equals(SHORT_FORMAT)) {\n                             if (year < 1930) {\n                                 sdf.set2DigitYearStart(cal.getTime());\n                             }\n                         }\n-                        String fmt = sdf.format(in);\n+                        final String fmt = sdf.format(in);\n                         try {\n-                            Date out = sdf.parse(fmt);\n+                            final Date out = sdf.parse(fmt);\n \n                             assertEquals(locale.toString()+\" \"+year+\" \"+ format+ \" \"+tz.getID(), in, out);\n-                        } catch (ParseException pe) {\n+                        } catch (final ParseException pe) {\n                             System.out.println(fmt+\" \"+locale.toString()+\" \"+year+\" \"+ format+ \" \"+tz.getID());\n                             throw pe;\n                         }\n \n     private void testLocales(final String format, final boolean eraBC) throws Exception {\n \n-        Calendar cal= Calendar.getInstance(GMT);\n+        final Calendar cal= Calendar.getInstance(GMT);\n         cal.clear();\n         cal.set(2003, 1, 10);\n         if (eraBC) {\n             cal.set(Calendar.ERA, GregorianCalendar.BC);\n         }\n-        for(Locale locale : Locale.getAvailableLocales()) {\n+        for(final Locale locale : Locale.getAvailableLocales()) {\n             // ja_JP_JP cannot handle dates before 1868 properly\n             if (eraBC && locale.equals(FastDateParser.JAPANESE_IMPERIAL)) {\n                 continue;\n             }\n-            SimpleDateFormat sdf = new SimpleDateFormat(format, locale);\n-            DateParser fdf = getInstance(format, locale);\n+            final SimpleDateFormat sdf = new SimpleDateFormat(format, locale);\n+            final DateParser fdf = getInstance(format, locale);\n \n             try {\n                 checkParse(locale, cal, sdf, fdf);\n-            } catch(ParseException ex) {\n+            } catch(final ParseException ex) {\n                 Assert.fail(\"Locale \"+locale+ \" failed with \"+format+\" era \"+(eraBC?\"BC\":\"AD\")+\"\\n\" + trimMessage(ex.toString()));\n             }\n         }\n         if (msg.length() < 100) {\n             return msg;\n         }\n-        int gmt = msg.indexOf(\"(GMT\");\n+        final int gmt = msg.indexOf(\"(GMT\");\n         if (gmt > 0) {\n             return msg.substring(0, gmt+4)+\"...)\";\n         }\n     }\n \n     private void checkParse(final Locale locale, final Calendar cal, final SimpleDateFormat sdf, final DateParser fdf) throws ParseException {\n-        String formattedDate= sdf.format(cal.getTime());\n-        Date expectedTime = sdf.parse(formattedDate);\n-        Date actualTime = fdf.parse(formattedDate);\n+        final String formattedDate= sdf.format(cal.getTime());\n+        final Date expectedTime = sdf.parse(formattedDate);\n+        final Date actualTime = fdf.parse(formattedDate);\n         assertEquals(locale.toString()+\" \"+formattedDate\n                 +\"\\n\",expectedTime, actualTime);\n     }\n \n     @Test\n     public void testParseNumerics() throws ParseException {\n-        Calendar cal= Calendar.getInstance(NEW_YORK, Locale.US);\n+        final Calendar cal= Calendar.getInstance(NEW_YORK, Locale.US);\n         cal.clear();\n         cal.set(2003, 1, 10, 15, 33, 20);\n         cal.set(Calendar.MILLISECOND, 989);\n \n-        DateParser fdf = getInstance(\"yyyyMMddHHmmssSSS\", NEW_YORK, Locale.US);\n+        final DateParser fdf = getInstance(\"yyyyMMddHHmmssSSS\", NEW_YORK, Locale.US);\n         assertEquals(cal.getTime(), fdf.parse(\"20030210153320989\"));\n     }\n \n     @Test\n     public void testQuotes() throws ParseException {\n-        Calendar cal= Calendar.getInstance(NEW_YORK, Locale.US);\n+        final Calendar cal= Calendar.getInstance(NEW_YORK, Locale.US);\n         cal.clear();\n         cal.set(2003, 1, 10, 15, 33, 20);\n         cal.set(Calendar.MILLISECOND, 989);\n \n-        DateParser fdf = getInstance(\"''yyyyMMdd'A''B'HHmmssSSS''\", NEW_YORK, Locale.US);\n+        final DateParser fdf = getInstance(\"''yyyyMMdd'A''B'HHmmssSSS''\", NEW_YORK, Locale.US);\n         assertEquals(cal.getTime(), fdf.parse(\"'20030210A'B153320989'\"));\n     }\n \n         Throwable s = null;\n \n         try {\n-            SimpleDateFormat sdf = new SimpleDateFormat(format, Locale.US);\n+            final SimpleDateFormat sdf = new SimpleDateFormat(format, Locale.US);\n             sdf.setTimeZone(NEW_YORK);\n             dsdf = sdf.parse(date);\n             if (shouldFail) {\n                 Assert.fail(\"Expected SDF failure, but got \" + dsdf + \" for [\"+format+\",\"+date+\"]\");\n             }\n-        } catch (Exception e) {\n+        } catch (final Exception e) {\n             s = e;\n             if (!shouldFail) {\n                 throw e;\n         }\n \n         try {\n-            DateParser fdp = getInstance(format, NEW_YORK, Locale.US);\n+            final DateParser fdp = getInstance(format, NEW_YORK, Locale.US);\n             dfdp = fdp.parse(date);\n             if (shouldFail) {\n                 Assert.fail(\"Expected FDF failure, but got \" + dfdp + \" for [\"+format+\",\"+date+\"] using \"+((FastDateParser)fdp).getParsePattern());\n             }\n-        } catch (Exception e) {\n+        } catch (final Exception e) {\n             f = e;\n             if (!shouldFail) {\n                 throw e;\n \n     @Test\n     public void testDayOf() throws ParseException {\n-        Calendar cal= Calendar.getInstance(NEW_YORK, Locale.US);\n+        final Calendar cal= Calendar.getInstance(NEW_YORK, Locale.US);\n         cal.clear();\n         cal.set(2003, 1, 10);\n \n-        DateParser fdf = getInstance(\"W w F D y\", NEW_YORK, Locale.US);\n+        final DateParser fdf = getInstance(\"W w F D y\", NEW_YORK, Locale.US);\n         assertEquals(cal.getTime(), fdf.parse(\"3 7 2 41 03\"));\n     }\n \n     @Test\n     public void testShortDateStyleWithLocales() throws ParseException {\n         DateParser fdf = getDateInstance(FastDateFormat.SHORT, Locale.US);\n-        Calendar cal = Calendar.getInstance();\n+        final Calendar cal = Calendar.getInstance();\n         cal.clear();\n \n         cal.set(2004, 1, 3);\n      */\n     @Test\n     public void testLowYearPadding() throws ParseException {\n-        DateParser parser = getInstance(YMD_SLASH);\n-        Calendar cal = Calendar.getInstance();\n+        final DateParser parser = getInstance(YMD_SLASH);\n+        final Calendar cal = Calendar.getInstance();\n         cal.clear();\n \n         cal.set(1,0,1);\n      */\n     @Test\n     public void testMilleniumBug() throws ParseException {\n-        DateParser parser = getInstance(DMY_DOT);\n-        Calendar cal = Calendar.getInstance();\n+        final DateParser parser = getInstance(DMY_DOT);\n+        final Calendar cal = Calendar.getInstance();\n         cal.clear();\n \n         cal.set(1000,0,1);\n     @Test\n     public void testLang303() throws ParseException {\n         DateParser parser = getInstance(YMD_SLASH);\n-        Calendar cal = Calendar.getInstance();\n+        final Calendar cal = Calendar.getInstance();\n         cal.set(2004, 11, 31);\n \n-        Date date = parser.parse(\"2004/11/31\");\n+        final Date date = parser.parse(\"2004/11/31\");\n \n         parser = SerializationUtils.deserialize(SerializationUtils.serialize((Serializable) parser));\n         assertEquals(date, parser.parse(\"2004/11/31\"));\n \n     @Test\n     public void testLang538() throws ParseException {\n-        DateParser parser = getInstance(\"yyyy-MM-dd'T'HH:mm:ss.SSS'Z'\", GMT);\n-\n-        Calendar cal = Calendar.getInstance(TimeZone.getTimeZone(\"GMT-8\"));\n+        final DateParser parser = getInstance(\"yyyy-MM-dd'T'HH:mm:ss.SSS'Z'\", GMT);\n+\n+        final Calendar cal = Calendar.getInstance(TimeZone.getTimeZone(\"GMT-8\"));\n         cal.clear();\n         cal.set(2009, 9, 16, 8, 42, 16);\n \n \n     @Test\n     public void testEquals() {\n-        DateParser parser1= getInstance(YMD_SLASH);\n-        DateParser parser2= getInstance(YMD_SLASH);\n+        final DateParser parser1= getInstance(YMD_SLASH);\n+        final DateParser parser2= getInstance(YMD_SLASH);\n \n         assertEquals(parser1, parser2);\n         assertEquals(parser1.hashCode(), parser2.hashCode());\n \n     @Test\n     public void testToStringContainsName() {\n-        DateParser parser= getInstance(YMD_SLASH);\n+        final DateParser parser= getInstance(YMD_SLASH);\n         assertTrue(parser.toString().startsWith(\"FastDate\"));\n     }\n \n     @Test\n     public void testPatternMatches() {\n-        DateParser parser= getInstance(yMdHmsSZ);\n+        final DateParser parser= getInstance(yMdHmsSZ);\n         assertEquals(yMdHmsSZ, parser.getPattern());\n     }\n \n     @Test\n     public void testLocaleMatches() {\n-        DateParser parser= getInstance(yMdHmsSZ, SWEDEN);\n+        final DateParser parser= getInstance(yMdHmsSZ, SWEDEN);\n         assertEquals(SWEDEN, parser.getLocale());\n     }\n \n     @Test\n     public void testTimeZoneMatches() {\n-        DateParser parser= getInstance(yMdHmsSZ, REYKJAVIK);\n+        final DateParser parser= getInstance(yMdHmsSZ, REYKJAVIK);\n         assertEquals(REYKJAVIK, parser.getTimeZone());\n     }\n }\n--- a/src/test/java/org/apache/commons/lang3/time/FastDatePrinterTest.java\n+++ b/src/test/java/org/apache/commons/lang3/time/FastDatePrinterTest.java\n \n     @Test\n     public void testFormat() {\n-        Locale realDefaultLocale = Locale.getDefault();\n-        TimeZone realDefaultZone = TimeZone.getDefault();\n+        final Locale realDefaultLocale = Locale.getDefault();\n+        final TimeZone realDefaultZone = TimeZone.getDefault();\n         try {\n             Locale.setDefault(Locale.US);\n             TimeZone.setDefault(NEW_YORK);\n \n-            GregorianCalendar cal1 = new GregorianCalendar(2003, 0, 10, 15, 33, 20);\n-            GregorianCalendar cal2 = new GregorianCalendar(2003, 6, 10, 9, 00, 00);\n-            Date date1 = cal1.getTime();\n-            Date date2 = cal2.getTime();\n-            long millis1 = date1.getTime();\n-            long millis2 = date2.getTime();\n+            final GregorianCalendar cal1 = new GregorianCalendar(2003, 0, 10, 15, 33, 20);\n+            final GregorianCalendar cal2 = new GregorianCalendar(2003, 6, 10, 9, 00, 00);\n+            final Date date1 = cal1.getTime();\n+            final Date date2 = cal2.getTime();\n+            final long millis1 = date1.getTime();\n+            final long millis2 = date2.getTime();\n \n             DatePrinter fdf = getInstance(\"yyyy-MM-dd'T'HH:mm:ss\");\n             SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ss\");\n             assertEquals(\"-04:00\", fdf.format(cal2));\n             assertEquals(\"-04:00\", fdf.format(millis2));\n \n-            String pattern = \"GGGG GGG GG G yyyy yyy yy y MMMM MMM MM M\" +\n+            final String pattern = \"GGGG GGG GG G yyyy yyy yy y MMMM MMM MM M\" +\n                 \" dddd ddd dd d DDDD DDD DD D EEEE EEE EE E aaaa aaa aa a zzzz zzz zz z\";\n             fdf = getInstance(pattern);\n             sdf = new SimpleDateFormat(pattern);\n      */\n     @Test\n     public void testShortDateStyleWithLocales() {\n-        Locale usLocale = Locale.US;\n-        Locale swedishLocale = new Locale(\"sv\", \"SE\");\n-        Calendar cal = Calendar.getInstance();\n+        final Locale usLocale = Locale.US;\n+        final Locale swedishLocale = new Locale(\"sv\", \"SE\");\n+        final Calendar cal = Calendar.getInstance();\n         cal.set(2004, 1, 3);\n         DatePrinter fdf = getDateInstance(FastDateFormat.SHORT, usLocale);\n         assertEquals(\"2/3/04\", fdf.format(cal));\n      */\n     @Test\n     public void testLowYearPadding() {\n-        Calendar cal = Calendar.getInstance();\n-        DatePrinter format = getInstance(YYYY_MM_DD);\n+        final Calendar cal = Calendar.getInstance();\n+        final DatePrinter format = getInstance(YYYY_MM_DD);\n \n         cal.set(1,0,1);\n         assertEquals(\"0001/01/01\", format.format(cal));\n      */\n     @Test\n     public void testMilleniumBug() {\n-        Calendar cal = Calendar.getInstance();\n-        DatePrinter format = getInstance(\"dd.MM.yyyy\");\n+        final Calendar cal = Calendar.getInstance();\n+        final DatePrinter format = getInstance(\"dd.MM.yyyy\");\n \n         cal.set(1000,0,1);\n         assertEquals(\"01.01.1000\", format.format(cal));\n      */\n     @Test\n     public void testSimpleDate() {\n-        Calendar cal = Calendar.getInstance();\n-        DatePrinter format = getInstance(YYYY_MM_DD);\n+        final Calendar cal = Calendar.getInstance();\n+        final DatePrinter format = getInstance(YYYY_MM_DD);\n \n         cal.set(2004,11,31);\n         assertEquals(\"2004/12/31\", format.format(cal));\n \n     @Test\n     public void testLang303() {\n-        Calendar cal = Calendar.getInstance();\n+        final Calendar cal = Calendar.getInstance();\n         cal.set(2004, 11, 31);\n \n         DatePrinter format = getInstance(YYYY_MM_DD);\n-        String output = format.format(cal);\n+        final String output = format.format(cal);\n \n         format = SerializationUtils.deserialize(SerializationUtils.serialize((Serializable) format));\n         assertEquals(output, format.format(cal));\n     public void testLang538() {\n         // more commonly constructed with: cal = new GregorianCalendar(2009, 9, 16, 8, 42, 16)\n         // for the unit test to work in any time zone, constructing with GMT-8 rather than default locale time zone\n-        GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone(\"GMT-8\"));\n+        final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone(\"GMT-8\"));\n         cal.clear();\n         cal.set(2009, 9, 16, 8, 42, 16);\n \n-        DatePrinter format = getInstance(\"yyyy-MM-dd'T'HH:mm:ss.SSS'Z'\", TimeZone.getTimeZone(\"GMT\"));\n+        final DatePrinter format = getInstance(\"yyyy-MM-dd'T'HH:mm:ss.SSS'Z'\", TimeZone.getTimeZone(\"GMT\"));\n         assertEquals(\"dateTime\", \"2009-10-16T16:42:16.000Z\", format.format(cal.getTime()));\n         assertEquals(\"dateTime\", \"2009-10-16T08:42:16.000Z\", format.format(cal));\n     }\n \n     @Test\n     public void testLang645() {\n-        Locale locale = new Locale(\"sv\", \"SE\");\n-\n-        Calendar cal = Calendar.getInstance();\n+        final Locale locale = new Locale(\"sv\", \"SE\");\n+\n+        final Calendar cal = Calendar.getInstance();\n         cal.set(2010, 0, 1, 12, 0, 0);\n-        Date d = cal.getTime();\n-\n-        DatePrinter fdf = getInstance(\"EEEE', week 'ww\", locale);\n+        final Date d = cal.getTime();\n+\n+        final DatePrinter fdf = getInstance(\"EEEE', week 'ww\", locale);\n \n         assertEquals(\"fredag, week 53\", fdf.format(d));\n     }\n     \n     @Test\n     public void testEquals() {\n-        DatePrinter printer1= getInstance(YYYY_MM_DD);\n-        DatePrinter printer2= getInstance(YYYY_MM_DD);\n+        final DatePrinter printer1= getInstance(YYYY_MM_DD);\n+        final DatePrinter printer2= getInstance(YYYY_MM_DD);\n \n         assertEquals(printer1, printer2);\n         assertEquals(printer1.hashCode(), printer2.hashCode());        \n     \n     @Test\n     public void testToStringContainsName() {\n-        DatePrinter printer= getInstance(YYYY_MM_DD);\n+        final DatePrinter printer= getInstance(YYYY_MM_DD);\n         assertTrue(printer.toString().startsWith(\"FastDate\"));\n     }\n     \n     @Test\n     public void testPatternMatches() {\n-        DatePrinter printer= getInstance(YYYY_MM_DD);\n+        final DatePrinter printer= getInstance(YYYY_MM_DD);\n         assertEquals(YYYY_MM_DD, printer.getPattern());\n     }\n     \n     @Test\n     public void testLocaleMatches() {\n-        DatePrinter printer= getInstance(YYYY_MM_DD, SWEDEN);\n+        final DatePrinter printer= getInstance(YYYY_MM_DD, SWEDEN);\n         assertEquals(SWEDEN, printer.getLocale());\n     }\n     \n     @Test\n     public void testTimeZoneMatches() {\n-        DatePrinter printer= getInstance(YYYY_MM_DD, NEW_YORK);\n+        final DatePrinter printer= getInstance(YYYY_MM_DD, NEW_YORK);\n         assertEquals(NEW_YORK, printer.getTimeZone());\n     }\n     \n     @Test\n     public void testCalendarTimezoneRespected() {\n-        String[] availableZones = TimeZone.getAvailableIDs();\n-        TimeZone currentZone = TimeZone.getDefault();\n+        final String[] availableZones = TimeZone.getAvailableIDs();\n+        final TimeZone currentZone = TimeZone.getDefault();\n         \n         TimeZone anotherZone = null;\n-        for (String zone : availableZones) {\n+        for (final String zone : availableZones) {\n             if (!zone.equals(currentZone.getID())) {\n                 anotherZone = TimeZone.getTimeZone(zone);\n             }\n         final String pattern = \"h:mma z\";\n         final Calendar cal = Calendar.getInstance(anotherZone);\n         \n-        SimpleDateFormat sdf = new SimpleDateFormat(pattern);\n+        final SimpleDateFormat sdf = new SimpleDateFormat(pattern);\n         sdf.setTimeZone(anotherZone);\n-        String expectedValue = sdf.format(cal.getTime());\n-        String actualValue = FastDateFormat.getInstance(pattern).format(cal);\n+        final String expectedValue = sdf.format(cal.getTime());\n+        final String actualValue = FastDateFormat.getInstance(pattern).format(cal);\n         assertEquals(expectedValue, actualValue);\n     }\n }\n--- a/src/test/java/org/apache/commons/lang3/time/StopWatchTest.java\n+++ b/src/test/java/org/apache/commons/lang3/time/StopWatchTest.java\n     //-----------------------------------------------------------------------\n     @Test\n     public void testStopWatchSimple(){\n-        StopWatch watch = new StopWatch();\n-        watch.start();\n-            try {Thread.sleep(550);} catch (InterruptedException ex) {}\n-        watch.stop();\n-        long time = watch.getTime();\n+        final StopWatch watch = new StopWatch();\n+        watch.start();\n+            try {Thread.sleep(550);} catch (final InterruptedException ex) {}\n+        watch.stop();\n+        final long time = watch.getTime();\n         assertEquals(time, watch.getTime());\n         \n         assertTrue(time >= 500);\n     \n     @Test\n     public void testStopWatchSimpleGet(){\n-        StopWatch watch = new StopWatch();\n+        final StopWatch watch = new StopWatch();\n         assertEquals(0, watch.getTime());\n         assertEquals(\"0:00:00.000\", watch.toString());\n         \n         watch.start();\n-            try {Thread.sleep(500);} catch (InterruptedException ex) {}\n+            try {Thread.sleep(500);} catch (final InterruptedException ex) {}\n         assertTrue(watch.getTime() < 2000);\n     }\n     \n     @Test\n     public void testStopWatchSplit(){\n-        StopWatch watch = new StopWatch();\n-        watch.start();\n-            try {Thread.sleep(550);} catch (InterruptedException ex) {}\n+        final StopWatch watch = new StopWatch();\n+        watch.start();\n+            try {Thread.sleep(550);} catch (final InterruptedException ex) {}\n         watch.split();\n-        long splitTime = watch.getSplitTime();\n-        String splitStr = watch.toSplitString();\n-            try {Thread.sleep(550);} catch (InterruptedException ex) {}\n+        final long splitTime = watch.getSplitTime();\n+        final String splitStr = watch.toSplitString();\n+            try {Thread.sleep(550);} catch (final InterruptedException ex) {}\n         watch.unsplit();\n-            try {Thread.sleep(550);} catch (InterruptedException ex) {}\n-        watch.stop();\n-        long totalTime = watch.getTime();\n+            try {Thread.sleep(550);} catch (final InterruptedException ex) {}\n+        watch.stop();\n+        final long totalTime = watch.getTime();\n \n         assertEquals(\"Formatted split string not the correct length\", \n                      splitStr.length(), 11);\n     \n     @Test\n     public void testStopWatchSuspend(){\n-        StopWatch watch = new StopWatch();\n-        watch.start();\n-            try {Thread.sleep(550);} catch (InterruptedException ex) {}\n+        final StopWatch watch = new StopWatch();\n+        watch.start();\n+            try {Thread.sleep(550);} catch (final InterruptedException ex) {}\n         watch.suspend();\n-        long suspendTime = watch.getTime();\n-            try {Thread.sleep(550);} catch (InterruptedException ex) {}\n+        final long suspendTime = watch.getTime();\n+            try {Thread.sleep(550);} catch (final InterruptedException ex) {}\n         watch.resume();\n-            try {Thread.sleep(550);} catch (InterruptedException ex) {}\n-        watch.stop();\n-        long totalTime = watch.getTime();\n+            try {Thread.sleep(550);} catch (final InterruptedException ex) {}\n+        watch.stop();\n+        final long totalTime = watch.getTime();\n         \n         assertTrue(suspendTime >= 500);\n         assertTrue(suspendTime < 700);\n \n     @Test\n     public void testLang315() {\n-        StopWatch watch = new StopWatch();\n-        watch.start();\n-            try {Thread.sleep(200);} catch (InterruptedException ex) {}\n+        final StopWatch watch = new StopWatch();\n+        watch.start();\n+            try {Thread.sleep(200);} catch (final InterruptedException ex) {}\n         watch.suspend();\n-        long suspendTime = watch.getTime();\n-            try {Thread.sleep(200);} catch (InterruptedException ex) {}\n-        watch.stop();\n-        long totalTime = watch.getTime();\n+        final long suspendTime = watch.getTime();\n+            try {Thread.sleep(200);} catch (final InterruptedException ex) {}\n+        watch.stop();\n+        final long totalTime = watch.getTime();\n         assertTrue( suspendTime == totalTime );\n     }\n \n     // test bad states\n     @Test\n     public void testBadStates() {\n-        StopWatch watch = new StopWatch();\n+        final StopWatch watch = new StopWatch();\n         try {\n             watch.stop();\n             fail(\"Calling stop on an unstarted StopWatch should throw an exception. \");\n-        } catch(IllegalStateException ise) {\n+        } catch(final IllegalStateException ise) {\n             // expected\n         }\n \n         try {\n             watch.stop();\n             fail(\"Calling stop on an unstarted StopWatch should throw an exception. \");\n-        } catch(IllegalStateException ise) {\n+        } catch(final IllegalStateException ise) {\n             // expected\n         }\n \n         try {\n             watch.suspend();\n             fail(\"Calling suspend on an unstarted StopWatch should throw an exception. \");\n-        } catch(IllegalStateException ise) {\n+        } catch(final IllegalStateException ise) {\n             // expected\n         }\n \n         try {\n             watch.split();\n             fail(\"Calling split on a non-running StopWatch should throw an exception. \");\n-        } catch(IllegalStateException ise) {\n+        } catch(final IllegalStateException ise) {\n             // expected\n         }\n \n         try {\n             watch.unsplit();\n             fail(\"Calling unsplit on an unsplit StopWatch should throw an exception. \");\n-        } catch(IllegalStateException ise) {\n+        } catch(final IllegalStateException ise) {\n             // expected\n         }\n \n         try {\n             watch.resume();\n             fail(\"Calling resume on an unsuspended StopWatch should throw an exception. \");\n-        } catch(IllegalStateException ise) {\n+        } catch(final IllegalStateException ise) {\n             // expected\n         }\n \n         try {\n             watch.start();\n             fail(\"Calling start on a started StopWatch should throw an exception. \");\n-        } catch(IllegalStateException ise) {\n+        } catch(final IllegalStateException ise) {\n             // expected\n         }\n \n         try {\n             watch.unsplit();\n             fail(\"Calling unsplit on an unsplit StopWatch should throw an exception. \");\n-        } catch(IllegalStateException ise) {\n+        } catch(final IllegalStateException ise) {\n             // expected\n         }\n \n         try {\n             watch.getSplitTime();\n             fail(\"Calling getSplitTime on an unsplit StopWatch should throw an exception. \");\n-        } catch(IllegalStateException ise) {\n+        } catch(final IllegalStateException ise) {\n             // expected\n         }\n \n         try {\n             watch.resume();\n             fail(\"Calling resume on an unsuspended StopWatch should throw an exception. \");\n-        } catch(IllegalStateException ise) {\n+        } catch(final IllegalStateException ise) {\n             // expected\n         }\n \n         try {\n             watch.start();\n             fail(\"Calling start on a stopped StopWatch should throw an exception as it needs to be reset. \");\n-        } catch(IllegalStateException ise) {\n+        } catch(final IllegalStateException ise) {\n             // expected\n         }\n     }\n \n     @Test\n     public void testGetStartTime() {\n-        long beforeStopWatch = System.currentTimeMillis();\n-        StopWatch watch = new StopWatch();\n+        final long beforeStopWatch = System.currentTimeMillis();\n+        final StopWatch watch = new StopWatch();\n         try {\n             watch.getStartTime();\n             fail(\"Calling getStartTime on an unstarted StopWatch should throw an exception\");\n-        } catch (IllegalStateException expected) {\n+        } catch (final IllegalStateException expected) {\n             // expected\n         }\n         watch.start();\n         try {\n             watch.getStartTime();\n             Assert.assertTrue(watch.getStartTime() >= beforeStopWatch);\n-        } catch (IllegalStateException ex) {\n+        } catch (final IllegalStateException ex) {\n             fail(\"Start time should be available: \" + ex.getMessage());\n         }\n         watch.reset();\n         try {\n             watch.getStartTime();\n             fail(\"Calling getStartTime on a reset, but unstarted StopWatch should throw an exception\");\n-        } catch (IllegalStateException expected) {\n+        } catch (final IllegalStateException expected) {\n             // expected\n         }\n     }\n--- a/src/test/java/org/apache/commons/lang3/tuple/ImmutablePairTest.java\n+++ b/src/test/java/org/apache/commons/lang3/tuple/ImmutablePairTest.java\n \n     @Test\n     public void testBasic() throws Exception {\n-        ImmutablePair<Integer, String> pair = new ImmutablePair<Integer, String>(0, \"foo\");\n+        final ImmutablePair<Integer, String> pair = new ImmutablePair<Integer, String>(0, \"foo\");\n         assertEquals(0, pair.left.intValue());\n         assertEquals(0, pair.getLeft().intValue());\n         assertEquals(\"foo\", pair.right);\n         assertEquals(\"foo\", pair.getRight());\n-        ImmutablePair<Object, String> pair2 = new ImmutablePair<Object, String>(null, \"bar\");\n+        final ImmutablePair<Object, String> pair2 = new ImmutablePair<Object, String>(null, \"bar\");\n         assertNull(pair2.left);\n         assertNull(pair2.getLeft());\n         assertEquals(\"bar\", pair2.right);\n \n     @Test\n     public void testPairOf() throws Exception {\n-        ImmutablePair<Integer, String> pair = ImmutablePair.of(0, \"foo\");\n+        final ImmutablePair<Integer, String> pair = ImmutablePair.of(0, \"foo\");\n         assertEquals(0, pair.left.intValue());\n         assertEquals(0, pair.getLeft().intValue());\n         assertEquals(\"foo\", pair.right);\n         assertEquals(\"foo\", pair.getRight());\n-        ImmutablePair<Object, String> pair2 = ImmutablePair.of(null, \"bar\");\n+        final ImmutablePair<Object, String> pair2 = ImmutablePair.of(null, \"bar\");\n         assertNull(pair2.left);\n         assertNull(pair2.getLeft());\n         assertEquals(\"bar\", pair2.right);\n         assertFalse(ImmutablePair.of(\"foo\", 0).equals(ImmutablePair.of(\"foo\", null)));\n         assertFalse(ImmutablePair.of(\"foo\", \"bar\").equals(ImmutablePair.of(\"xyz\", \"bar\")));\n \n-        ImmutablePair<String, String> p = ImmutablePair.of(\"foo\", \"bar\");\n+        final ImmutablePair<String, String> p = ImmutablePair.of(\"foo\", \"bar\");\n         assertTrue(p.equals(p));\n         assertFalse(p.equals(new Object()));\n     }\n     @Test\n     @SuppressWarnings(\"unchecked\")\n     public void testSerialization() throws Exception {\n-        ImmutablePair<Integer, String> origPair = ImmutablePair.of(0, \"foo\");\n-        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n-        ObjectOutputStream out = new ObjectOutputStream(baos);\n+        final ImmutablePair<Integer, String> origPair = ImmutablePair.of(0, \"foo\");\n+        final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+        final ObjectOutputStream out = new ObjectOutputStream(baos);\n         out.writeObject(origPair);\n-        ImmutablePair<Integer, String> deserializedPair = (ImmutablePair<Integer, String>) new ObjectInputStream(\n+        final ImmutablePair<Integer, String> deserializedPair = (ImmutablePair<Integer, String>) new ObjectInputStream(\n                 new ByteArrayInputStream(baos.toByteArray())).readObject();\n         assertEquals(origPair, deserializedPair);\n         assertEquals(origPair.hashCode(), deserializedPair.hashCode());\n--- a/src/test/java/org/apache/commons/lang3/tuple/ImmutableTripleTest.java\n+++ b/src/test/java/org/apache/commons/lang3/tuple/ImmutableTripleTest.java\n \n     @Test\n     public void testBasic() throws Exception {\n-        ImmutableTriple<Integer, String, Boolean> triple = new ImmutableTriple<Integer, String, Boolean>(0, \"foo\", Boolean.TRUE);\n+        final ImmutableTriple<Integer, String, Boolean> triple = new ImmutableTriple<Integer, String, Boolean>(0, \"foo\", Boolean.TRUE);\n         assertEquals(0, triple.left.intValue());\n         assertEquals(0, triple.getLeft().intValue());\n         assertEquals(\"foo\", triple.middle);\n         assertEquals(\"foo\", triple.getMiddle());\n         assertEquals(Boolean.TRUE, triple.right);\n         assertEquals(Boolean.TRUE, triple.getRight());\n-        ImmutableTriple<Object, String, Integer> triple2 = new ImmutableTriple<Object, String, Integer>(null, \"bar\", 42);\n+        final ImmutableTriple<Object, String, Integer> triple2 = new ImmutableTriple<Object, String, Integer>(null, \"bar\", 42);\n         assertNull(triple2.left);\n         assertNull(triple2.getLeft());\n         assertEquals(\"bar\", triple2.middle);\n \n     @Test\n     public void testTripleOf() throws Exception {\n-        ImmutableTriple<Integer, String, Boolean> triple = ImmutableTriple.of(0, \"foo\", Boolean.FALSE);\n+        final ImmutableTriple<Integer, String, Boolean> triple = ImmutableTriple.of(0, \"foo\", Boolean.FALSE);\n         assertEquals(0, triple.left.intValue());\n         assertEquals(0, triple.getLeft().intValue());\n         assertEquals(\"foo\", triple.middle);\n         assertEquals(\"foo\", triple.getMiddle());\n         assertEquals(Boolean.FALSE, triple.right);\n         assertEquals(Boolean.FALSE, triple.getRight());\n-        ImmutableTriple<Object, String, Boolean> triple2 = ImmutableTriple.of(null, \"bar\", Boolean.TRUE);\n+        final ImmutableTriple<Object, String, Boolean> triple2 = ImmutableTriple.of(null, \"bar\", Boolean.TRUE);\n         assertNull(triple2.left);\n         assertNull(triple2.getLeft());\n         assertEquals(\"bar\", triple2.middle);\n         assertFalse(ImmutableTriple.of(\"foo\", 0, Boolean.TRUE).equals(ImmutableTriple.of(\"foo\", null, null)));\n         assertFalse(ImmutableTriple.of(\"foo\", \"bar\", \"baz\").equals(ImmutableTriple.of(\"xyz\", \"bar\", \"blo\")));\n \n-        ImmutableTriple<String, String, String> p = ImmutableTriple.of(\"foo\", \"bar\", \"baz\");\n+        final ImmutableTriple<String, String, String> p = ImmutableTriple.of(\"foo\", \"bar\", \"baz\");\n         assertTrue(p.equals(p));\n         assertFalse(p.equals(new Object()));\n     }\n     @Test\n     @SuppressWarnings(\"unchecked\")\n     public void testSerialization() throws Exception {\n-        ImmutableTriple<Integer, String, Boolean> origTriple = ImmutableTriple.of(0, \"foo\", Boolean.TRUE);\n-        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n-        ObjectOutputStream out = new ObjectOutputStream(baos);\n+        final ImmutableTriple<Integer, String, Boolean> origTriple = ImmutableTriple.of(0, \"foo\", Boolean.TRUE);\n+        final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+        final ObjectOutputStream out = new ObjectOutputStream(baos);\n         out.writeObject(origTriple);\n-        ImmutableTriple<Integer, String, Boolean> deserializedTriple = (ImmutableTriple<Integer, String, Boolean>) new ObjectInputStream(\n+        final ImmutableTriple<Integer, String, Boolean> deserializedTriple = (ImmutableTriple<Integer, String, Boolean>) new ObjectInputStream(\n                 new ByteArrayInputStream(baos.toByteArray())).readObject();\n         assertEquals(origTriple, deserializedTriple);\n         assertEquals(origTriple.hashCode(), deserializedTriple.hashCode());\n--- a/src/test/java/org/apache/commons/lang3/tuple/MutablePairTest.java\n+++ b/src/test/java/org/apache/commons/lang3/tuple/MutablePairTest.java\n \n     @Test\n     public void testBasic() throws Exception {\n-        MutablePair<Integer, String> pair = new MutablePair<Integer, String>(0, \"foo\");\n+        final MutablePair<Integer, String> pair = new MutablePair<Integer, String>(0, \"foo\");\n         assertEquals(0, pair.getLeft().intValue());\n         assertEquals(\"foo\", pair.getRight());\n-        MutablePair<Object, String> pair2 = new MutablePair<Object, String>(null, \"bar\");\n+        final MutablePair<Object, String> pair2 = new MutablePair<Object, String>(null, \"bar\");\n         assertNull(pair2.getLeft());\n         assertEquals(\"bar\", pair2.getRight());\n     }\n \n     @Test\n     public void testDefault() throws Exception {\n-        MutablePair<Integer, String> pair = new MutablePair<Integer, String>();\n+        final MutablePair<Integer, String> pair = new MutablePair<Integer, String>();\n         assertNull(pair.getLeft());\n         assertNull(pair.getRight());\n     }\n     \n     @Test\n     public void testMutate() throws Exception {\n-        MutablePair<Integer, String> pair = new MutablePair<Integer, String>(0, \"foo\");\n+        final MutablePair<Integer, String> pair = new MutablePair<Integer, String>(0, \"foo\");\n         pair.setLeft(42);\n         pair.setRight(\"bar\");\n         assertEquals(42, pair.getLeft().intValue());\n \n     @Test\n     public void testPairOf() throws Exception {\n-        MutablePair<Integer, String> pair = MutablePair.of(0, \"foo\");\n+        final MutablePair<Integer, String> pair = MutablePair.of(0, \"foo\");\n         assertEquals(0, pair.getLeft().intValue());\n         assertEquals(\"foo\", pair.getRight());\n-        MutablePair<Object, String> pair2 = MutablePair.of(null, \"bar\");\n+        final MutablePair<Object, String> pair2 = MutablePair.of(null, \"bar\");\n         assertNull(pair2.getLeft());\n         assertEquals(\"bar\", pair2.getRight());\n     }\n         assertFalse(MutablePair.of(\"foo\", 0).equals(MutablePair.of(\"foo\", null)));\n         assertFalse(MutablePair.of(\"foo\", \"bar\").equals(MutablePair.of(\"xyz\", \"bar\")));\n \n-        MutablePair<String, String> p = MutablePair.of(\"foo\", \"bar\");\n+        final MutablePair<String, String> p = MutablePair.of(\"foo\", \"bar\");\n         assertTrue(p.equals(p));\n         assertFalse(p.equals(new Object()));\n     }\n     @Test\n     @SuppressWarnings(\"unchecked\")\n     public void testSerialization() throws Exception {\n-        MutablePair<Integer, String> origPair = MutablePair.of(0, \"foo\");\n-        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n-        ObjectOutputStream out = new ObjectOutputStream(baos);\n+        final MutablePair<Integer, String> origPair = MutablePair.of(0, \"foo\");\n+        final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+        final ObjectOutputStream out = new ObjectOutputStream(baos);\n         out.writeObject(origPair);\n-        MutablePair<Integer, String> deserializedPair = (MutablePair<Integer, String>) new ObjectInputStream(\n+        final MutablePair<Integer, String> deserializedPair = (MutablePair<Integer, String>) new ObjectInputStream(\n                 new ByteArrayInputStream(baos.toByteArray())).readObject();\n         assertEquals(origPair, deserializedPair);\n         assertEquals(origPair.hashCode(), deserializedPair.hashCode());\n--- a/src/test/java/org/apache/commons/lang3/tuple/MutableTripleTest.java\n+++ b/src/test/java/org/apache/commons/lang3/tuple/MutableTripleTest.java\n \n     @Test\n     public void testBasic() throws Exception {\n-        MutableTriple<Integer, String, Boolean> triple = new MutableTriple<Integer, String, Boolean>(0, \"foo\", Boolean.FALSE);\n+        final MutableTriple<Integer, String, Boolean> triple = new MutableTriple<Integer, String, Boolean>(0, \"foo\", Boolean.FALSE);\n         assertEquals(0, triple.getLeft().intValue());\n         assertEquals(\"foo\", triple.getMiddle());\n         assertEquals(Boolean.FALSE, triple.getRight());\n-        MutableTriple<Object, String, String> triple2 = new MutableTriple<Object, String, String>(null, \"bar\", \"hello\");\n+        final MutableTriple<Object, String, String> triple2 = new MutableTriple<Object, String, String>(null, \"bar\", \"hello\");\n         assertNull(triple2.getLeft());\n         assertEquals(\"bar\", triple2.getMiddle());\n         assertEquals(\"hello\", triple2.getRight());\n \n     @Test\n     public void testDefault() throws Exception {\n-        MutableTriple<Integer, String, Boolean> triple = new MutableTriple<Integer, String, Boolean>();\n+        final MutableTriple<Integer, String, Boolean> triple = new MutableTriple<Integer, String, Boolean>();\n         assertNull(triple.getLeft());\n         assertNull(triple.getMiddle());\n         assertNull(triple.getRight());\n     \n     @Test\n     public void testMutate() throws Exception {\n-        MutableTriple<Integer, String, Boolean> triple = new MutableTriple<Integer, String, Boolean>(0, \"foo\", Boolean.TRUE);\n+        final MutableTriple<Integer, String, Boolean> triple = new MutableTriple<Integer, String, Boolean>(0, \"foo\", Boolean.TRUE);\n         triple.setLeft(42);\n         triple.setMiddle(\"bar\");\n         triple.setRight(Boolean.FALSE);\n \n     @Test\n     public void testTripleOf() throws Exception {\n-        MutableTriple<Integer, String, Boolean> triple = MutableTriple.of(0, \"foo\", Boolean.TRUE);\n+        final MutableTriple<Integer, String, Boolean> triple = MutableTriple.of(0, \"foo\", Boolean.TRUE);\n         assertEquals(0, triple.getLeft().intValue());\n         assertEquals(\"foo\", triple.getMiddle());\n         assertEquals(Boolean.TRUE, triple.getRight());\n-        MutableTriple<Object, String, String> triple2 = MutableTriple.of(null, \"bar\", \"hello\");\n+        final MutableTriple<Object, String, String> triple2 = MutableTriple.of(null, \"bar\", \"hello\");\n         assertNull(triple2.getLeft());\n         assertEquals(\"bar\", triple2.getMiddle());\n         assertEquals(\"hello\", triple2.getRight());\n         assertFalse(MutableTriple.of(\"foo\", \"bar\", \"baz\").equals(MutableTriple.of(\"xyz\", \"bar\", \"baz\")));\n         assertFalse(MutableTriple.of(\"foo\", \"bar\", \"baz\").equals(MutableTriple.of(\"foo\", \"bar\", \"blo\")));\n \n-        MutableTriple<String, String, String> p = MutableTriple.of(\"foo\", \"bar\", \"baz\");\n+        final MutableTriple<String, String, String> p = MutableTriple.of(\"foo\", \"bar\", \"baz\");\n         assertTrue(p.equals(p));\n         assertFalse(p.equals(new Object()));\n     }\n     @Test\n     @SuppressWarnings(\"unchecked\")\n     public void testSerialization() throws Exception {\n-        MutableTriple<Integer, String, Boolean> origTriple = MutableTriple.of(0, \"foo\", Boolean.TRUE);\n-        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n-        ObjectOutputStream out = new ObjectOutputStream(baos);\n+        final MutableTriple<Integer, String, Boolean> origTriple = MutableTriple.of(0, \"foo\", Boolean.TRUE);\n+        final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+        final ObjectOutputStream out = new ObjectOutputStream(baos);\n         out.writeObject(origTriple);\n-        MutableTriple<Integer, String, Boolean> deserializedTriple = (MutableTriple<Integer, String, Boolean>) new ObjectInputStream(\n+        final MutableTriple<Integer, String, Boolean> deserializedTriple = (MutableTriple<Integer, String, Boolean>) new ObjectInputStream(\n                 new ByteArrayInputStream(baos.toByteArray())).readObject();\n         assertEquals(origTriple, deserializedTriple);\n         assertEquals(origTriple.hashCode(), deserializedTriple.hashCode());\n--- a/src/test/java/org/apache/commons/lang3/tuple/PairTest.java\n+++ b/src/test/java/org/apache/commons/lang3/tuple/PairTest.java\n \n     @Test\n     public void testPairOf() throws Exception {\n-        Pair<Integer, String> pair = Pair.of(0, \"foo\");\n+        final Pair<Integer, String> pair = Pair.of(0, \"foo\");\n         assertTrue(pair instanceof ImmutablePair<?, ?>);\n         assertEquals(0, ((ImmutablePair<Integer, String>) pair).left.intValue());\n         assertEquals(\"foo\", ((ImmutablePair<Integer, String>) pair).right);\n-        Pair<Object, String> pair2 = Pair.of(null, \"bar\");\n+        final Pair<Object, String> pair2 = Pair.of(null, \"bar\");\n         assertTrue(pair2 instanceof ImmutablePair<?, ?>);\n         assertNull(((ImmutablePair<Object, String>) pair2).left);\n         assertEquals(\"bar\", ((ImmutablePair<Object, String>) pair2).right);\n \n     @Test\n     public void testCompatibilityBetweenPairs() throws Exception {\n-        Pair<Integer, String> pair = ImmutablePair.of(0, \"foo\");\n-        Pair<Integer, String> pair2 = MutablePair.of(0, \"foo\");\n+        final Pair<Integer, String> pair = ImmutablePair.of(0, \"foo\");\n+        final Pair<Integer, String> pair2 = MutablePair.of(0, \"foo\");\n         assertEquals(pair, pair2);\n         assertEquals(pair.hashCode(), pair2.hashCode());\n-        HashSet<Pair<Integer, String>> set = new HashSet<Pair<Integer, String>>();\n+        final HashSet<Pair<Integer, String>> set = new HashSet<Pair<Integer, String>>();\n         set.add(pair);\n         assertTrue(set.contains(pair2));\n \n \n     @Test\n     public void testMapEntry() throws Exception {\n-        Pair<Integer, String> pair = ImmutablePair.of(0, \"foo\");\n-        HashMap<Integer, String> map = new HashMap<Integer, String>();\n+        final Pair<Integer, String> pair = ImmutablePair.of(0, \"foo\");\n+        final HashMap<Integer, String> map = new HashMap<Integer, String>();\n         map.put(0, \"foo\");\n-        Entry<Integer, String> entry = map.entrySet().iterator().next();\n+        final Entry<Integer, String> entry = map.entrySet().iterator().next();\n         assertEquals(pair, entry);\n         assertEquals(pair.hashCode(), entry.hashCode());\n     }\n \n     @Test\n     public void testComparable1() throws Exception {\n-        Pair<String, String> pair1 = Pair.of(\"A\", \"D\");\n-        Pair<String, String> pair2 = Pair.of(\"B\", \"C\");\n+        final Pair<String, String> pair1 = Pair.of(\"A\", \"D\");\n+        final Pair<String, String> pair2 = Pair.of(\"B\", \"C\");\n         assertTrue(pair1.compareTo(pair1) == 0);\n         assertTrue(pair1.compareTo(pair2) < 0);\n         assertTrue(pair2.compareTo(pair2) == 0);\n \n     @Test\n     public void testComparable2() throws Exception {\n-        Pair<String, String> pair1 = Pair.of(\"A\", \"C\");\n-        Pair<String, String> pair2 = Pair.of(\"A\", \"D\");\n+        final Pair<String, String> pair1 = Pair.of(\"A\", \"C\");\n+        final Pair<String, String> pair2 = Pair.of(\"A\", \"D\");\n         assertTrue(pair1.compareTo(pair1) == 0);\n         assertTrue(pair1.compareTo(pair2) < 0);\n         assertTrue(pair2.compareTo(pair2) == 0);\n \n     @Test\n     public void testToString() throws Exception {\n-        Pair<String, String> pair = Pair.of(\"Key\", \"Value\");\n+        final Pair<String, String> pair = Pair.of(\"Key\", \"Value\");\n         assertEquals(\"(Key,Value)\", pair.toString());\n     }\n \n     @Test\n     public void testToStringCustom() throws Exception {\n-        Calendar date = Calendar.getInstance();\n+        final Calendar date = Calendar.getInstance();\n         date.set(2011, Calendar.APRIL, 25);\n-        Pair<String, Calendar> pair = Pair.of(\"DOB\", date);\n+        final Pair<String, Calendar> pair = Pair.of(\"DOB\", date);\n         assertEquals(\"Test created on \" + \"04-25-2011\", pair.toString(\"Test created on %2$tm-%2$td-%2$tY\"));\n     }\n \n     @Test\n     public void testFormattable_simple() throws Exception {\n-        Pair<String, String> pair = Pair.of(\"Key\", \"Value\");\n+        final Pair<String, String> pair = Pair.of(\"Key\", \"Value\");\n         assertEquals(\"(Key,Value)\", String.format(\"%1$s\", pair));\n     }\n \n     @Test\n     public void testFormattable_padded() throws Exception {\n-        Pair<String, String> pair = Pair.of(\"Key\", \"Value\");\n+        final Pair<String, String> pair = Pair.of(\"Key\", \"Value\");\n         assertEquals(\"         (Key,Value)\", String.format(\"%1$20s\", pair));\n     }\n \n--- a/src/test/java/org/apache/commons/lang3/tuple/TripleTest.java\n+++ b/src/test/java/org/apache/commons/lang3/tuple/TripleTest.java\n \n     @Test\n     public void testTripleOf() throws Exception {\n-        Triple<Integer, String, Boolean> triple = Triple.of(0, \"foo\", Boolean.TRUE);\n+        final Triple<Integer, String, Boolean> triple = Triple.of(0, \"foo\", Boolean.TRUE);\n         assertTrue(triple instanceof ImmutableTriple<?, ?, ?>);\n         assertEquals(0, ((ImmutableTriple<Integer, String, Boolean>) triple).left.intValue());\n         assertEquals(\"foo\", ((ImmutableTriple<Integer, String, Boolean>) triple).middle);\n         assertEquals(Boolean.TRUE, ((ImmutableTriple<Integer, String, Boolean>) triple).right);\n-        Triple<Object, String, Long> triple2 = Triple.of(null, \"bar\", Long.valueOf(200L));\n+        final Triple<Object, String, Long> triple2 = Triple.of(null, \"bar\", Long.valueOf(200L));\n         assertTrue(triple2 instanceof ImmutableTriple<?, ?, ?>);\n         assertNull(((ImmutableTriple<Object, String, Long>) triple2).left);\n         assertEquals(\"bar\", ((ImmutableTriple<Object, String, Long>) triple2).middle);\n \n     @Test\n     public void testCompatibilityBetweenTriples() throws Exception {\n-        Triple<Integer, String, Boolean> triple = ImmutableTriple.of(0, \"foo\", Boolean.TRUE);\n-        Triple<Integer, String, Boolean> triple2 = MutableTriple.of(0, \"foo\", Boolean.TRUE);\n+        final Triple<Integer, String, Boolean> triple = ImmutableTriple.of(0, \"foo\", Boolean.TRUE);\n+        final Triple<Integer, String, Boolean> triple2 = MutableTriple.of(0, \"foo\", Boolean.TRUE);\n         assertEquals(triple, triple2);\n         assertEquals(triple.hashCode(), triple2.hashCode());\n-        HashSet<Triple<Integer, String, Boolean>> set = new HashSet<Triple<Integer, String, Boolean>>();\n+        final HashSet<Triple<Integer, String, Boolean>> set = new HashSet<Triple<Integer, String, Boolean>>();\n         set.add(triple);\n         assertTrue(set.contains(triple2));\n     }\n \n     @Test\n     public void testComparable1() throws Exception {\n-        Triple<String, String, String> triple1 = Triple.of(\"A\", \"D\", \"A\");\n-        Triple<String, String, String> triple2 = Triple.of(\"B\", \"C\", \"A\");\n+        final Triple<String, String, String> triple1 = Triple.of(\"A\", \"D\", \"A\");\n+        final Triple<String, String, String> triple2 = Triple.of(\"B\", \"C\", \"A\");\n         assertTrue(triple1.compareTo(triple1) == 0);\n         assertTrue(triple1.compareTo(triple2) < 0);\n         assertTrue(triple2.compareTo(triple2) == 0);\n \n     @Test\n     public void testComparable2() throws Exception {\n-        Triple<String, String, String> triple1 = Triple.of(\"A\", \"C\", \"B\");\n-        Triple<String, String, String> triple2 = Triple.of(\"A\", \"D\", \"B\");\n+        final Triple<String, String, String> triple1 = Triple.of(\"A\", \"C\", \"B\");\n+        final Triple<String, String, String> triple2 = Triple.of(\"A\", \"D\", \"B\");\n         assertTrue(triple1.compareTo(triple1) == 0);\n         assertTrue(triple1.compareTo(triple2) < 0);\n         assertTrue(triple2.compareTo(triple2) == 0);\n \n     @Test\n     public void testComparable3() throws Exception {\n-        Triple<String, String, String> triple1 = Triple.of(\"A\", \"A\", \"D\");\n-        Triple<String, String, String> triple2 = Triple.of(\"A\", \"B\", \"C\");\n+        final Triple<String, String, String> triple1 = Triple.of(\"A\", \"A\", \"D\");\n+        final Triple<String, String, String> triple2 = Triple.of(\"A\", \"B\", \"C\");\n         assertTrue(triple1.compareTo(triple1) == 0);\n         assertTrue(triple1.compareTo(triple2) < 0);\n         assertTrue(triple2.compareTo(triple2) == 0);\n \n     @Test\n     public void testComparable4() throws Exception {\n-        Triple<String, String, String> triple1 = Triple.of(\"B\", \"A\", \"C\");\n-        Triple<String, String, String> triple2 = Triple.of(\"B\", \"A\", \"D\");\n+        final Triple<String, String, String> triple1 = Triple.of(\"B\", \"A\", \"C\");\n+        final Triple<String, String, String> triple2 = Triple.of(\"B\", \"A\", \"D\");\n         assertTrue(triple1.compareTo(triple1) == 0);\n         assertTrue(triple1.compareTo(triple2) < 0);\n         assertTrue(triple2.compareTo(triple2) == 0);\n \n     @Test\n     public void testToString() throws Exception {\n-        Triple<String, String, String> triple = Triple.of(\"Key\", \"Something\", \"Value\");\n+        final Triple<String, String, String> triple = Triple.of(\"Key\", \"Something\", \"Value\");\n         assertEquals(\"(Key,Something,Value)\", triple.toString());\n     }\n \n     @Test\n     public void testToStringCustom() throws Exception {\n-        Calendar date = Calendar.getInstance();\n+        final Calendar date = Calendar.getInstance();\n         date.set(2011, Calendar.APRIL, 25);\n-        Triple<String, String, Calendar> triple = Triple.of(\"DOB\", \"string\", date);\n+        final Triple<String, String, Calendar> triple = Triple.of(\"DOB\", \"string\", date);\n         assertEquals(\"Test created on \" + \"04-25-2011\", triple.toString(\"Test created on %3$tm-%3$td-%3$tY\"));\n     }\n \n     @Test\n     public void testFormattable_simple() throws Exception {\n-        Triple<String, String, String> triple = Triple.of(\"Key\", \"Something\", \"Value\");\n+        final Triple<String, String, String> triple = Triple.of(\"Key\", \"Something\", \"Value\");\n         assertEquals(\"(Key,Something,Value)\", String.format(\"%1$s\", triple));\n     }\n \n     @Test\n     public void testFormattable_padded() throws Exception {\n-        Triple<String, String, String> triple = Triple.of(\"Key\", \"Something\", \"Value\");\n+        final Triple<String, String, String> triple = Triple.of(\"Key\", \"Something\", \"Value\");\n         assertEquals(\"         (Key,Something,Value)\", String.format(\"%1$30s\", triple));\n     }\n ", "timestamp": 1358838585, "metainfo": ""}