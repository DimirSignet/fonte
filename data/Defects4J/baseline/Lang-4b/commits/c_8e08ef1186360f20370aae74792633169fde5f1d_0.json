{"sha": "8e08ef1186360f20370aae74792633169fde5f1d", "log": "Add final modifier to method parameters.  ", "commit": "\n--- a/src/main/java/org/apache/commons/lang3/AnnotationUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/AnnotationUtils.java\n          * {@inheritDoc}\n          */\n         @Override\n-        protected String getShortClassName(java.lang.Class<?> cls) {\n+        protected String getShortClassName(final java.lang.Class<?> cls) {\n             Class<? extends Annotation> annotationType = null;\n             for (Class<?> iface : ClassUtils.getAllInterfaces(cls)) {\n                 if (Annotation.class.isAssignableFrom(iface)) {\n          * {@inheritDoc}\n          */\n         @Override\n-        protected void appendDetail(StringBuffer buffer, String fieldName, Object value) {\n+        protected void appendDetail(final StringBuffer buffer, final String fieldName, Object value) {\n             if (value instanceof Annotation) {\n                 value = AnnotationUtils.toString((Annotation) value);\n             }\n      * @return {@code true} if the two annotations are {@code equal} or both\n      * {@code null}\n      */\n-    public static boolean equals(Annotation a1, Annotation a2) {\n+    public static boolean equals(final Annotation a1, final Annotation a2) {\n         if (a1 == a2) {\n             return true;\n         }\n      * @throws IllegalStateException if an annotation method invocation returns\n      * {@code null}\n      */\n-    public static int hashCode(Annotation a) {\n+    public static int hashCode(final Annotation a) {\n         int result = 0;\n         Class<? extends Annotation> type = a.annotationType();\n         for (Method m : type.getDeclaredMethods()) {\n      * @param value the value of the member\n      * @return a hash code for this member\n      */\n-    private static int hashMember(String name, Object value) {\n+    private static int hashMember(final String name, final Object value) {\n         int part1 = name.hashCode() * 127;\n         if (value.getClass().isArray()) {\n             return part1 ^ arrayMemberHash(value.getClass().getComponentType(), value);\n      * @param o2 the second object\n      * @return a flag whether these objects are equal\n      */\n-    private static boolean memberEquals(Class<?> type, Object o1, Object o2) {\n+    private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2) {\n         if (o1 == o2) {\n             return true;\n         }\n      * @param o2 the second object\n      * @return a flag whether these objects are equal\n      */\n-    private static boolean arrayMemberEquals(Class<?> componentType, Object o1, Object o2) {\n+    private static boolean arrayMemberEquals(final Class<?> componentType, final Object o1, final Object o2) {\n         if (componentType.isAnnotation()) {\n             return annotationArrayMemberEquals((Annotation[]) o1, (Annotation[]) o2);\n         }\n      * @param a2 the second array\n      * @return a flag whether these arrays are equal\n      */\n-    private static boolean annotationArrayMemberEquals(Annotation[] a1, Annotation[] a2) {\n+    private static boolean annotationArrayMemberEquals(final Annotation[] a1, final Annotation[] a2) {\n         if (a1.length != a2.length) {\n             return false;\n         }\n      * @param o the array\n      * @return a hash code for the specified array\n      */\n-    private static int arrayMemberHash(Class<?> componentType, Object o) {\n+    private static int arrayMemberHash(final Class<?> componentType, final Object o) {\n         if (componentType.equals(Byte.TYPE)) {\n             return Arrays.hashCode((byte[]) o);\n         }\n--- a/src/main/java/org/apache/commons/lang3/ArrayUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/ArrayUtils.java\n      * @param array  the array to get a toString for, may be {@code null}\n      * @return a String representation of the array, '{}' if null array input\n      */\n-    public static String toString(Object array) {\n+    public static String toString(final Object array) {\n         return toString(array, \"{}\");\n     }\n \n      * @param stringIfNull  the String to return if the array is {@code null}\n      * @return a String representation of the array\n      */\n-    public static String toString(Object array, String stringIfNull) {\n+    public static String toString(final Object array, final String stringIfNull) {\n         if (array == null) {\n             return stringIfNull;\n         }\n      * @param array  the array to get a hash code for, {@code null} returns zero\n      * @return a hash code for the array\n      */\n-    public static int hashCode(Object array) {\n+    public static int hashCode(final Object array) {\n         return new HashCodeBuilder().append(array).toHashCode();\n     }\n \n      * @param array2  the right hand array to compare, may be {@code null}\n      * @return {@code true} if the arrays are equal\n      */\n-    public static boolean isEquals(Object array1, Object array2) {\n+    public static boolean isEquals(final Object array1, final Object array2) {\n         return new EqualsBuilder().append(array1, array2).isEquals();\n     }\n \n      * @throws IllegalArgumentException  if the array contains elements other\n      *  than {@link java.util.Map.Entry} and an Array\n      */\n-    public static Map<Object, Object> toMap(Object[] array) {\n+    public static Map<Object, Object> toMap(final Object[] array) {\n         if (array == null) {\n             return null;\n         }\n      * @param array  the array to shallow clone, may be {@code null}\n      * @return the cloned array, {@code null} if {@code null} input\n      */\n-    public static <T> T[] clone(T[] array) {\n+    public static <T> T[] clone(final T[] array) {\n         if (array == null) {\n             return null;\n         }\n      * @param array  the array to clone, may be {@code null}\n      * @return the cloned array, {@code null} if {@code null} input\n      */\n-    public static long[] clone(long[] array) {\n+    public static long[] clone(final long[] array) {\n         if (array == null) {\n             return null;\n         }\n      * @param array  the array to clone, may be {@code null}\n      * @return the cloned array, {@code null} if {@code null} input\n      */\n-    public static int[] clone(int[] array) {\n+    public static int[] clone(final int[] array) {\n         if (array == null) {\n             return null;\n         }\n      * @param array  the array to clone, may be {@code null}\n      * @return the cloned array, {@code null} if {@code null} input\n      */\n-    public static short[] clone(short[] array) {\n+    public static short[] clone(final short[] array) {\n         if (array == null) {\n             return null;\n         }\n      * @param array  the array to clone, may be {@code null}\n      * @return the cloned array, {@code null} if {@code null} input\n      */\n-    public static char[] clone(char[] array) {\n+    public static char[] clone(final char[] array) {\n         if (array == null) {\n             return null;\n         }\n      * @param array  the array to clone, may be {@code null}\n      * @return the cloned array, {@code null} if {@code null} input\n      */\n-    public static byte[] clone(byte[] array) {\n+    public static byte[] clone(final byte[] array) {\n         if (array == null) {\n             return null;\n         }\n      * @param array  the array to clone, may be {@code null}\n      * @return the cloned array, {@code null} if {@code null} input\n      */\n-    public static double[] clone(double[] array) {\n+    public static double[] clone(final double[] array) {\n         if (array == null) {\n             return null;\n         }\n      * @param array  the array to clone, may be {@code null}\n      * @return the cloned array, {@code null} if {@code null} input\n      */\n-    public static float[] clone(float[] array) {\n+    public static float[] clone(final float[] array) {\n         if (array == null) {\n             return null;\n         }\n      * @param array  the array to clone, may be {@code null}\n      * @return the cloned array, {@code null} if {@code null} input\n      */\n-    public static boolean[] clone(boolean[] array) {\n+    public static boolean[] clone(final boolean[] array) {\n         if (array == null) {\n             return null;\n         }\n      * @return the same array, {@code public static} empty array if {@code null} or empty input\n      * @since 2.5\n      */\n-    public static Object[] nullToEmpty(Object[] array) {\n+    public static Object[] nullToEmpty(final Object[] array) {\n         if (array == null || array.length == 0) {\n             return EMPTY_OBJECT_ARRAY;\n         }\n      * @return the same array, {@code public static} empty array if {@code null} or empty input\n      * @since 2.5\n      */\n-    public static String[] nullToEmpty(String[] array) {\n+    public static String[] nullToEmpty(final String[] array) {\n         if (array == null || array.length == 0) {\n             return EMPTY_STRING_ARRAY;\n         }\n      * @return the same array, {@code public static} empty array if {@code null} or empty input\n      * @since 2.5\n      */\n-    public static long[] nullToEmpty(long[] array) {\n+    public static long[] nullToEmpty(final long[] array) {\n         if (array == null || array.length == 0) {\n             return EMPTY_LONG_ARRAY;\n         }\n      * @return the same array, {@code public static} empty array if {@code null} or empty input\n      * @since 2.5\n      */\n-    public static int[] nullToEmpty(int[] array) {\n+    public static int[] nullToEmpty(final int[] array) {\n         if (array == null || array.length == 0) {\n             return EMPTY_INT_ARRAY;\n         }\n      * @return the same array, {@code public static} empty array if {@code null} or empty input\n      * @since 2.5\n      */\n-    public static short[] nullToEmpty(short[] array) {\n+    public static short[] nullToEmpty(final short[] array) {\n         if (array == null || array.length == 0) {\n             return EMPTY_SHORT_ARRAY;\n         }\n      * @return the same array, {@code public static} empty array if {@code null} or empty input\n      * @since 2.5\n      */\n-    public static char[] nullToEmpty(char[] array) {\n+    public static char[] nullToEmpty(final char[] array) {\n         if (array == null || array.length == 0) {\n             return EMPTY_CHAR_ARRAY;\n         }\n      * @return the same array, {@code public static} empty array if {@code null} or empty input\n      * @since 2.5\n      */\n-    public static byte[] nullToEmpty(byte[] array) {\n+    public static byte[] nullToEmpty(final byte[] array) {\n         if (array == null || array.length == 0) {\n             return EMPTY_BYTE_ARRAY;\n         }\n      * @return the same array, {@code public static} empty array if {@code null} or empty input\n      * @since 2.5\n      */\n-    public static double[] nullToEmpty(double[] array) {\n+    public static double[] nullToEmpty(final double[] array) {\n         if (array == null || array.length == 0) {\n             return EMPTY_DOUBLE_ARRAY;\n         }\n      * @return the same array, {@code public static} empty array if {@code null} or empty input\n      * @since 2.5\n      */\n-    public static float[] nullToEmpty(float[] array) {\n+    public static float[] nullToEmpty(final float[] array) {\n         if (array == null || array.length == 0) {\n             return EMPTY_FLOAT_ARRAY;\n         }\n      * @return the same array, {@code public static} empty array if {@code null} or empty input\n      * @since 2.5\n      */\n-    public static boolean[] nullToEmpty(boolean[] array) {\n+    public static boolean[] nullToEmpty(final boolean[] array) {\n         if (array == null || array.length == 0) {\n             return EMPTY_BOOLEAN_ARRAY;\n         }\n      * @return the same array, {@code public static} empty array if {@code null} or empty input\n      * @since 2.5\n      */\n-    public static Long[] nullToEmpty(Long[] array) {\n+    public static Long[] nullToEmpty(final Long[] array) {\n         if (array == null || array.length == 0) {\n             return EMPTY_LONG_OBJECT_ARRAY;\n         }\n      * @return the same array, {@code public static} empty array if {@code null} or empty input\n      * @since 2.5\n      */\n-    public static Integer[] nullToEmpty(Integer[] array) {\n+    public static Integer[] nullToEmpty(final Integer[] array) {\n         if (array == null || array.length == 0) {\n             return EMPTY_INTEGER_OBJECT_ARRAY;\n         }\n      * @return the same array, {@code public static} empty array if {@code null} or empty input\n      * @since 2.5\n      */\n-    public static Short[] nullToEmpty(Short[] array) {\n+    public static Short[] nullToEmpty(final Short[] array) {\n         if (array == null || array.length == 0) {\n             return EMPTY_SHORT_OBJECT_ARRAY;\n         }\n      * @return the same array, {@code public static} empty array if {@code null} or empty input\n      * @since 2.5\n      */\n-    public static Character[] nullToEmpty(Character[] array) {\n+    public static Character[] nullToEmpty(final Character[] array) {\n         if (array == null || array.length == 0) {\n             return EMPTY_CHARACTER_OBJECT_ARRAY;\n         }\n      * @return the same array, {@code public static} empty array if {@code null} or empty input\n      * @since 2.5\n      */\n-    public static Byte[] nullToEmpty(Byte[] array) {\n+    public static Byte[] nullToEmpty(final Byte[] array) {\n         if (array == null || array.length == 0) {\n             return EMPTY_BYTE_OBJECT_ARRAY;\n         }\n      * @return the same array, {@code public static} empty array if {@code null} or empty input\n      * @since 2.5\n      */\n-    public static Double[] nullToEmpty(Double[] array) {\n+    public static Double[] nullToEmpty(final Double[] array) {\n         if (array == null || array.length == 0) {\n             return EMPTY_DOUBLE_OBJECT_ARRAY;\n         }\n      * @return the same array, {@code public static} empty array if {@code null} or empty input\n      * @since 2.5\n      */\n-    public static Float[] nullToEmpty(Float[] array) {\n+    public static Float[] nullToEmpty(final Float[] array) {\n         if (array == null || array.length == 0) {\n             return EMPTY_FLOAT_OBJECT_ARRAY;\n         }\n      * @return the same array, {@code public static} empty array if {@code null} or empty input\n      * @since 2.5\n      */\n-    public static Boolean[] nullToEmpty(Boolean[] array) {\n+    public static Boolean[] nullToEmpty(final Boolean[] array) {\n         if (array == null || array.length == 0) {\n             return EMPTY_BOOLEAN_OBJECT_ARRAY;\n         }\n      *      the start and end indices.\n      * @since 2.1\n      */\n-    public static <T> T[] subarray(T[] array, int startIndexInclusive, int endIndexExclusive) {\n+    public static <T> T[] subarray(final T[] array, int startIndexInclusive, int endIndexExclusive) {\n         if (array == null) {\n             return null;\n         }\n      *      the start and end indices.\n      * @since 2.1\n      */\n-    public static long[] subarray(long[] array, int startIndexInclusive, int endIndexExclusive) {\n+    public static long[] subarray(final long[] array, int startIndexInclusive, int endIndexExclusive) {\n         if (array == null) {\n             return null;\n         }\n      *      the start and end indices.\n      * @since 2.1\n      */\n-    public static int[] subarray(int[] array, int startIndexInclusive, int endIndexExclusive) {\n+    public static int[] subarray(final int[] array, int startIndexInclusive, int endIndexExclusive) {\n         if (array == null) {\n             return null;\n         }\n      *      the start and end indices.\n      * @since 2.1\n      */\n-    public static short[] subarray(short[] array, int startIndexInclusive, int endIndexExclusive) {\n+    public static short[] subarray(final short[] array, int startIndexInclusive, int endIndexExclusive) {\n         if (array == null) {\n             return null;\n         }\n      *      the start and end indices.\n      * @since 2.1\n      */\n-    public static char[] subarray(char[] array, int startIndexInclusive, int endIndexExclusive) {\n+    public static char[] subarray(final char[] array, int startIndexInclusive, int endIndexExclusive) {\n         if (array == null) {\n             return null;\n         }\n      *      the start and end indices.\n      * @since 2.1\n      */\n-    public static byte[] subarray(byte[] array, int startIndexInclusive, int endIndexExclusive) {\n+    public static byte[] subarray(final byte[] array, int startIndexInclusive, int endIndexExclusive) {\n         if (array == null) {\n             return null;\n         }\n      *      the start and end indices.\n      * @since 2.1\n      */\n-    public static double[] subarray(double[] array, int startIndexInclusive, int endIndexExclusive) {\n+    public static double[] subarray(final double[] array, int startIndexInclusive, int endIndexExclusive) {\n         if (array == null) {\n             return null;\n         }\n      *      the start and end indices.\n      * @since 2.1\n      */\n-    public static float[] subarray(float[] array, int startIndexInclusive, int endIndexExclusive) {\n+    public static float[] subarray(final float[] array, int startIndexInclusive, int endIndexExclusive) {\n         if (array == null) {\n             return null;\n         }\n      *      the start and end indices.\n      * @since 2.1\n      */\n-    public static boolean[] subarray(boolean[] array, int startIndexInclusive, int endIndexExclusive) {\n+    public static boolean[] subarray(final boolean[] array, int startIndexInclusive, int endIndexExclusive) {\n         if (array == null) {\n             return null;\n         }\n      * @return {@code true} if length of arrays matches, treating\n      *  {@code null} as an empty array\n      */\n-    public static boolean isSameLength(Object[] array1, Object[] array2) {\n+    public static boolean isSameLength(final Object[] array1, final Object[] array2) {\n         if ((array1 == null && array2 != null && array2.length > 0) ||\n             (array2 == null && array1 != null && array1.length > 0) ||\n             (array1 != null && array2 != null && array1.length != array2.length)) {\n      * @return {@code true} if length of arrays matches, treating\n      *  {@code null} as an empty array\n      */\n-    public static boolean isSameLength(long[] array1, long[] array2) {\n+    public static boolean isSameLength(final long[] array1, final long[] array2) {\n         if ((array1 == null && array2 != null && array2.length > 0) ||\n             (array2 == null && array1 != null && array1.length > 0) ||\n             (array1 != null && array2 != null && array1.length != array2.length)) {\n      * @return {@code true} if length of arrays matches, treating\n      *  {@code null} as an empty array\n      */\n-    public static boolean isSameLength(int[] array1, int[] array2) {\n+    public static boolean isSameLength(final int[] array1, final int[] array2) {\n         if ((array1 == null && array2 != null && array2.length > 0) ||\n             (array2 == null && array1 != null && array1.length > 0) ||\n             (array1 != null && array2 != null && array1.length != array2.length)) {\n      * @return {@code true} if length of arrays matches, treating\n      *  {@code null} as an empty array\n      */\n-    public static boolean isSameLength(short[] array1, short[] array2) {\n+    public static boolean isSameLength(final short[] array1, final short[] array2) {\n         if ((array1 == null && array2 != null && array2.length > 0) ||\n             (array2 == null && array1 != null && array1.length > 0) ||\n             (array1 != null && array2 != null && array1.length != array2.length)) {\n      * @return {@code true} if length of arrays matches, treating\n      *  {@code null} as an empty array\n      */\n-    public static boolean isSameLength(char[] array1, char[] array2) {\n+    public static boolean isSameLength(final char[] array1, final char[] array2) {\n         if ((array1 == null && array2 != null && array2.length > 0) ||\n             (array2 == null && array1 != null && array1.length > 0) ||\n             (array1 != null && array2 != null && array1.length != array2.length)) {\n      * @return {@code true} if length of arrays matches, treating\n      *  {@code null} as an empty array\n      */\n-    public static boolean isSameLength(byte[] array1, byte[] array2) {\n+    public static boolean isSameLength(final byte[] array1, final byte[] array2) {\n         if ((array1 == null && array2 != null && array2.length > 0) ||\n             (array2 == null && array1 != null && array1.length > 0) ||\n             (array1 != null && array2 != null && array1.length != array2.length)) {\n      * @return {@code true} if length of arrays matches, treating\n      *  {@code null} as an empty array\n      */\n-    public static boolean isSameLength(double[] array1, double[] array2) {\n+    public static boolean isSameLength(final double[] array1, final double[] array2) {\n         if ((array1 == null && array2 != null && array2.length > 0) ||\n             (array2 == null && array1 != null && array1.length > 0) ||\n             (array1 != null && array2 != null && array1.length != array2.length)) {\n      * @return {@code true} if length of arrays matches, treating\n      *  {@code null} as an empty array\n      */\n-    public static boolean isSameLength(float[] array1, float[] array2) {\n+    public static boolean isSameLength(final float[] array1, final float[] array2) {\n         if ((array1 == null && array2 != null && array2.length > 0) ||\n             (array2 == null && array1 != null && array1.length > 0) ||\n             (array1 != null && array2 != null && array1.length != array2.length)) {\n      * @return {@code true} if length of arrays matches, treating\n      *  {@code null} as an empty array\n      */\n-    public static boolean isSameLength(boolean[] array1, boolean[] array2) {\n+    public static boolean isSameLength(final boolean[] array1, final boolean[] array2) {\n         if ((array1 == null && array2 != null && array2.length > 0) ||\n             (array2 == null && array1 != null && array1.length > 0) ||\n             (array1 != null && array2 != null && array1.length != array2.length)) {\n      * @throws IllegalArgumentException if the object argument is not an array.\n      * @since 2.1\n      */\n-    public static int getLength(Object array) {\n+    public static int getLength(final Object array) {\n         if (array == null) {\n             return 0;\n         }\n      * @return {@code true} if type of arrays matches\n      * @throws IllegalArgumentException if either array is {@code null}\n      */\n-    public static boolean isSameType(Object array1, Object array2) {\n+    public static boolean isSameType(final Object array1, final Object array2) {\n         if (array1 == null || array2 == null) {\n             throw new IllegalArgumentException(\"The Array must not be null\");\n         }\n      *\n      * @param array  the array to reverse, may be {@code null}\n      */\n-    public static void reverse(Object[] array) {\n+    public static void reverse(final Object[] array) {\n         if (array == null) {\n             return;\n         }\n      *\n      * @param array  the array to reverse, may be {@code null}\n      */\n-    public static void reverse(long[] array) {\n+    public static void reverse(final long[] array) {\n         if (array == null) {\n             return;\n         }\n      *\n      * @param array  the array to reverse, may be {@code null}\n      */\n-    public static void reverse(int[] array) {\n+    public static void reverse(final int[] array) {\n         if (array == null) {\n             return;\n         }\n      *\n      * @param array  the array to reverse, may be {@code null}\n      */\n-    public static void reverse(short[] array) {\n+    public static void reverse(final short[] array) {\n         if (array == null) {\n             return;\n         }\n      *\n      * @param array  the array to reverse, may be {@code null}\n      */\n-    public static void reverse(char[] array) {\n+    public static void reverse(final char[] array) {\n         if (array == null) {\n             return;\n         }\n      *\n      * @param array  the array to reverse, may be {@code null}\n      */\n-    public static void reverse(byte[] array) {\n+    public static void reverse(final byte[] array) {\n         if (array == null) {\n             return;\n         }\n      *\n      * @param array  the array to reverse, may be {@code null}\n      */\n-    public static void reverse(double[] array) {\n+    public static void reverse(final double[] array) {\n         if (array == null) {\n             return;\n         }\n      *\n      * @param array  the array to reverse, may be {@code null}\n      */\n-    public static void reverse(float[] array) {\n+    public static void reverse(final float[] array) {\n         if (array == null) {\n             return;\n         }\n      *\n      * @param array  the array to reverse, may be {@code null}\n      */\n-    public static void reverse(boolean[] array) {\n+    public static void reverse(final boolean[] array) {\n         if (array == null) {\n             return;\n         }\n      * @return the index of the object within the array,\n      *  {@link #INDEX_NOT_FOUND} ({@code -1}) if not found or {@code null} array input\n      */\n-    public static int indexOf(Object[] array, Object objectToFind) {\n+    public static int indexOf(final Object[] array, final Object objectToFind) {\n         return indexOf(array, objectToFind, 0);\n     }\n \n      * @return the index of the object within the array starting at the index,\n      *  {@link #INDEX_NOT_FOUND} ({@code -1}) if not found or {@code null} array input\n      */\n-    public static int indexOf(Object[] array, Object objectToFind, int startIndex) {\n+    public static int indexOf(final Object[] array, final Object objectToFind, int startIndex) {\n         if (array == null) {\n             return INDEX_NOT_FOUND;\n         }\n      * @return the last index of the object within the array,\n      *  {@link #INDEX_NOT_FOUND} ({@code -1}) if not found or {@code null} array input\n      */\n-    public static int lastIndexOf(Object[] array, Object objectToFind) {\n+    public static int lastIndexOf(final Object[] array, final Object objectToFind) {\n         return lastIndexOf(array, objectToFind, Integer.MAX_VALUE);\n     }\n \n      * @return the last index of the object within the array,\n      *  {@link #INDEX_NOT_FOUND} ({@code -1}) if not found or {@code null} array input\n      */\n-    public static int lastIndexOf(Object[] array, Object objectToFind, int startIndex) {\n+    public static int lastIndexOf(final Object[] array, final Object objectToFind, int startIndex) {\n         if (array == null) {\n             return INDEX_NOT_FOUND;\n         }\n      * @param objectToFind  the object to find\n      * @return {@code true} if the array contains the object\n      */\n-    public static boolean contains(Object[] array, Object objectToFind) {\n+    public static boolean contains(final Object[] array, final Object objectToFind) {\n         return indexOf(array, objectToFind) != INDEX_NOT_FOUND;\n     }\n \n      * @return the index of the value within the array,\n      *  {@link #INDEX_NOT_FOUND} ({@code -1}) if not found or {@code null} array input\n      */\n-    public static int indexOf(long[] array, long valueToFind) {\n+    public static int indexOf(final long[] array, final long valueToFind) {\n         return indexOf(array, valueToFind, 0);\n     }\n \n      * @return the index of the value within the array,\n      *  {@link #INDEX_NOT_FOUND} ({@code -1}) if not found or {@code null} array input\n      */\n-    public static int indexOf(long[] array, long valueToFind, int startIndex) {\n+    public static int indexOf(final long[] array, final long valueToFind, int startIndex) {\n         if (array == null) {\n             return INDEX_NOT_FOUND;\n         }\n      * @return the last index of the value within the array,\n      *  {@link #INDEX_NOT_FOUND} ({@code -1}) if not found or {@code null} array input\n      */\n-    public static int lastIndexOf(long[] array, long valueToFind) {\n+    public static int lastIndexOf(final long[] array, final long valueToFind) {\n         return lastIndexOf(array, valueToFind, Integer.MAX_VALUE);\n     }\n \n      * @return the last index of the value within the array,\n      *  {@link #INDEX_NOT_FOUND} ({@code -1}) if not found or {@code null} array input\n      */\n-    public static int lastIndexOf(long[] array, long valueToFind, int startIndex) {\n+    public static int lastIndexOf(final long[] array, final long valueToFind, int startIndex) {\n         if (array == null) {\n             return INDEX_NOT_FOUND;\n         }\n      * @param valueToFind  the value to find\n      * @return {@code true} if the array contains the object\n      */\n-    public static boolean contains(long[] array, long valueToFind) {\n+    public static boolean contains(final long[] array, final long valueToFind) {\n         return indexOf(array, valueToFind) != INDEX_NOT_FOUND;\n     }\n \n      * @return the index of the value within the array,\n      *  {@link #INDEX_NOT_FOUND} ({@code -1}) if not found or {@code null} array input\n      */\n-    public static int indexOf(int[] array, int valueToFind) {\n+    public static int indexOf(final int[] array, final int valueToFind) {\n         return indexOf(array, valueToFind, 0);\n     }\n \n      * @return the index of the value within the array,\n      *  {@link #INDEX_NOT_FOUND} ({@code -1}) if not found or {@code null} array input\n      */\n-    public static int indexOf(int[] array, int valueToFind, int startIndex) {\n+    public static int indexOf(final int[] array, final int valueToFind, int startIndex) {\n         if (array == null) {\n             return INDEX_NOT_FOUND;\n         }\n      * @return the last index of the value within the array,\n      *  {@link #INDEX_NOT_FOUND} ({@code -1}) if not found or {@code null} array input\n      */\n-    public static int lastIndexOf(int[] array, int valueToFind) {\n+    public static int lastIndexOf(final int[] array, final int valueToFind) {\n         return lastIndexOf(array, valueToFind, Integer.MAX_VALUE);\n     }\n \n      * @return the last index of the value within the array,\n      *  {@link #INDEX_NOT_FOUND} ({@code -1}) if not found or {@code null} array input\n      */\n-    public static int lastIndexOf(int[] array, int valueToFind, int startIndex) {\n+    public static int lastIndexOf(final int[] array, final int valueToFind, int startIndex) {\n         if (array == null) {\n             return INDEX_NOT_FOUND;\n         }\n      * @param valueToFind  the value to find\n      * @return {@code true} if the array contains the object\n      */\n-    public static boolean contains(int[] array, int valueToFind) {\n+    public static boolean contains(final int[] array, final int valueToFind) {\n         return indexOf(array, valueToFind) != INDEX_NOT_FOUND;\n     }\n \n      * @return the index of the value within the array,\n      *  {@link #INDEX_NOT_FOUND} ({@code -1}) if not found or {@code null} array input\n      */\n-    public static int indexOf(short[] array, short valueToFind) {\n+    public static int indexOf(final short[] array, final short valueToFind) {\n         return indexOf(array, valueToFind, 0);\n     }\n \n      * @return the index of the value within the array,\n      *  {@link #INDEX_NOT_FOUND} ({@code -1}) if not found or {@code null} array input\n      */\n-    public static int indexOf(short[] array, short valueToFind, int startIndex) {\n+    public static int indexOf(final short[] array, final short valueToFind, int startIndex) {\n         if (array == null) {\n             return INDEX_NOT_FOUND;\n         }\n      * @return the last index of the value within the array,\n      *  {@link #INDEX_NOT_FOUND} ({@code -1}) if not found or {@code null} array input\n      */\n-    public static int lastIndexOf(short[] array, short valueToFind) {\n+    public static int lastIndexOf(final short[] array, final short valueToFind) {\n         return lastIndexOf(array, valueToFind, Integer.MAX_VALUE);\n     }\n \n      * @return the last index of the value within the array,\n      *  {@link #INDEX_NOT_FOUND} ({@code -1}) if not found or {@code null} array input\n      */\n-    public static int lastIndexOf(short[] array, short valueToFind, int startIndex) {\n+    public static int lastIndexOf(final short[] array, final short valueToFind, int startIndex) {\n         if (array == null) {\n             return INDEX_NOT_FOUND;\n         }\n      * @param valueToFind  the value to find\n      * @return {@code true} if the array contains the object\n      */\n-    public static boolean contains(short[] array, short valueToFind) {\n+    public static boolean contains(final short[] array, final short valueToFind) {\n         return indexOf(array, valueToFind) != INDEX_NOT_FOUND;\n     }\n \n      *  {@link #INDEX_NOT_FOUND} ({@code -1}) if not found or {@code null} array input\n      * @since 2.1\n      */\n-    public static int indexOf(char[] array, char valueToFind) {\n+    public static int indexOf(final char[] array, final char valueToFind) {\n         return indexOf(array, valueToFind, 0);\n     }\n \n      *  {@link #INDEX_NOT_FOUND} ({@code -1}) if not found or {@code null} array input\n      * @since 2.1\n      */\n-    public static int indexOf(char[] array, char valueToFind, int startIndex) {\n+    public static int indexOf(final char[] array, final char valueToFind, int startIndex) {\n         if (array == null) {\n             return INDEX_NOT_FOUND;\n         }\n      *  {@link #INDEX_NOT_FOUND} ({@code -1}) if not found or {@code null} array input\n      * @since 2.1\n      */\n-    public static int lastIndexOf(char[] array, char valueToFind) {\n+    public static int lastIndexOf(final char[] array, final char valueToFind) {\n         return lastIndexOf(array, valueToFind, Integer.MAX_VALUE);\n     }\n \n      *  {@link #INDEX_NOT_FOUND} ({@code -1}) if not found or {@code null} array input\n      * @since 2.1\n      */\n-    public static int lastIndexOf(char[] array, char valueToFind, int startIndex) {\n+    public static int lastIndexOf(final char[] array, final char valueToFind, int startIndex) {\n         if (array == null) {\n             return INDEX_NOT_FOUND;\n         }\n      * @return {@code true} if the array contains the object\n      * @since 2.1\n      */\n-    public static boolean contains(char[] array, char valueToFind) {\n+    public static boolean contains(final char[] array, final char valueToFind) {\n         return indexOf(array, valueToFind) != INDEX_NOT_FOUND;\n     }\n \n      * @return the index of the value within the array,\n      *  {@link #INDEX_NOT_FOUND} ({@code -1}) if not found or {@code null} array input\n      */\n-    public static int indexOf(byte[] array, byte valueToFind) {\n+    public static int indexOf(final byte[] array, final byte valueToFind) {\n         return indexOf(array, valueToFind, 0);\n     }\n \n      * @return the index of the value within the array,\n      *  {@link #INDEX_NOT_FOUND} ({@code -1}) if not found or {@code null} array input\n      */\n-    public static int indexOf(byte[] array, byte valueToFind, int startIndex) {\n+    public static int indexOf(final byte[] array, final byte valueToFind, int startIndex) {\n         if (array == null) {\n             return INDEX_NOT_FOUND;\n         }\n      * @return the last index of the value within the array,\n      *  {@link #INDEX_NOT_FOUND} ({@code -1}) if not found or {@code null} array input\n      */\n-    public static int lastIndexOf(byte[] array, byte valueToFind) {\n+    public static int lastIndexOf(final byte[] array, final byte valueToFind) {\n         return lastIndexOf(array, valueToFind, Integer.MAX_VALUE);\n     }\n \n      * @return the last index of the value within the array,\n      *  {@link #INDEX_NOT_FOUND} ({@code -1}) if not found or {@code null} array input\n      */\n-    public static int lastIndexOf(byte[] array, byte valueToFind, int startIndex) {\n+    public static int lastIndexOf(final byte[] array, final byte valueToFind, int startIndex) {\n         if (array == null) {\n             return INDEX_NOT_FOUND;\n         }\n      * @param valueToFind  the value to find\n      * @return {@code true} if the array contains the object\n      */\n-    public static boolean contains(byte[] array, byte valueToFind) {\n+    public static boolean contains(final byte[] array, final byte valueToFind) {\n         return indexOf(array, valueToFind) != INDEX_NOT_FOUND;\n     }\n \n      * @return the index of the value within the array,\n      *  {@link #INDEX_NOT_FOUND} ({@code -1}) if not found or {@code null} array input\n      */\n-    public static int indexOf(double[] array, double valueToFind) {\n+    public static int indexOf(final double[] array, final double valueToFind) {\n         return indexOf(array, valueToFind, 0);\n     }\n \n      * @return the index of the value within the array,\n      *  {@link #INDEX_NOT_FOUND} ({@code -1}) if not found or {@code null} array input\n      */\n-    public static int indexOf(double[] array, double valueToFind, double tolerance) {\n+    public static int indexOf(final double[] array, final double valueToFind, final double tolerance) {\n         return indexOf(array, valueToFind, 0, tolerance);\n     }\n \n      * @return the index of the value within the array,\n      *  {@link #INDEX_NOT_FOUND} ({@code -1}) if not found or {@code null} array input\n      */\n-    public static int indexOf(double[] array, double valueToFind, int startIndex) {\n+    public static int indexOf(final double[] array, final double valueToFind, int startIndex) {\n         if (ArrayUtils.isEmpty(array)) {\n             return INDEX_NOT_FOUND;\n         }\n      * @return the index of the value within the array,\n      *  {@link #INDEX_NOT_FOUND} ({@code -1}) if not found or {@code null} array input\n      */\n-    public static int indexOf(double[] array, double valueToFind, int startIndex, double tolerance) {\n+    public static int indexOf(final double[] array, final double valueToFind, int startIndex, final double tolerance) {\n         if (ArrayUtils.isEmpty(array)) {\n             return INDEX_NOT_FOUND;\n         }\n      * @return the last index of the value within the array,\n      *  {@link #INDEX_NOT_FOUND} ({@code -1}) if not found or {@code null} array input\n      */\n-    public static int lastIndexOf(double[] array, double valueToFind) {\n+    public static int lastIndexOf(final double[] array, final double valueToFind) {\n         return lastIndexOf(array, valueToFind, Integer.MAX_VALUE);\n     }\n \n      * @return the index of the value within the array,\n      *  {@link #INDEX_NOT_FOUND} ({@code -1}) if not found or {@code null} array input\n      */\n-    public static int lastIndexOf(double[] array, double valueToFind, double tolerance) {\n+    public static int lastIndexOf(final double[] array, final double valueToFind, final double tolerance) {\n         return lastIndexOf(array, valueToFind, Integer.MAX_VALUE, tolerance);\n     }\n \n      * @return the last index of the value within the array,\n      *  {@link #INDEX_NOT_FOUND} ({@code -1}) if not found or {@code null} array input\n      */\n-    public static int lastIndexOf(double[] array, double valueToFind, int startIndex) {\n+    public static int lastIndexOf(final double[] array, final double valueToFind, int startIndex) {\n         if (ArrayUtils.isEmpty(array)) {\n             return INDEX_NOT_FOUND;\n         }\n      * @return the last index of the value within the array,\n      *  {@link #INDEX_NOT_FOUND} ({@code -1}) if not found or {@code null} array input\n      */\n-    public static int lastIndexOf(double[] array, double valueToFind, int startIndex, double tolerance) {\n+    public static int lastIndexOf(final double[] array, final double valueToFind, int startIndex, final double tolerance) {\n         if (ArrayUtils.isEmpty(array)) {\n             return INDEX_NOT_FOUND;\n         }\n      * @param valueToFind  the value to find\n      * @return {@code true} if the array contains the object\n      */\n-    public static boolean contains(double[] array, double valueToFind) {\n+    public static boolean contains(final double[] array, final double valueToFind) {\n         return indexOf(array, valueToFind) != INDEX_NOT_FOUND;\n     }\n \n      * @param tolerance  the array contains the tolerance of the search\n      * @return true if value falling within tolerance is in array\n      */\n-    public static boolean contains(double[] array, double valueToFind, double tolerance) {\n+    public static boolean contains(final double[] array, final double valueToFind, final double tolerance) {\n         return indexOf(array, valueToFind, 0, tolerance) != INDEX_NOT_FOUND;\n     }\n \n      * @return the index of the value within the array,\n      *  {@link #INDEX_NOT_FOUND} ({@code -1}) if not found or {@code null} array input\n      */\n-    public static int indexOf(float[] array, float valueToFind) {\n+    public static int indexOf(final float[] array, final float valueToFind) {\n         return indexOf(array, valueToFind, 0);\n     }\n \n      * @return the index of the value within the array,\n      *  {@link #INDEX_NOT_FOUND} ({@code -1}) if not found or {@code null} array input\n      */\n-    public static int indexOf(float[] array, float valueToFind, int startIndex) {\n+    public static int indexOf(final float[] array, final float valueToFind, int startIndex) {\n         if (ArrayUtils.isEmpty(array)) {\n             return INDEX_NOT_FOUND;\n         }\n      * @return the last index of the value within the array,\n      *  {@link #INDEX_NOT_FOUND} ({@code -1}) if not found or {@code null} array input\n      */\n-    public static int lastIndexOf(float[] array, float valueToFind) {\n+    public static int lastIndexOf(final float[] array, final float valueToFind) {\n         return lastIndexOf(array, valueToFind, Integer.MAX_VALUE);\n     }\n \n      * @return the last index of the value within the array,\n      *  {@link #INDEX_NOT_FOUND} ({@code -1}) if not found or {@code null} array input\n      */\n-    public static int lastIndexOf(float[] array, float valueToFind, int startIndex) {\n+    public static int lastIndexOf(final float[] array, final float valueToFind, int startIndex) {\n         if (ArrayUtils.isEmpty(array)) {\n             return INDEX_NOT_FOUND;\n         }\n      * @param valueToFind  the value to find\n      * @return {@code true} if the array contains the object\n      */\n-    public static boolean contains(float[] array, float valueToFind) {\n+    public static boolean contains(final float[] array, final float valueToFind) {\n         return indexOf(array, valueToFind) != INDEX_NOT_FOUND;\n     }\n \n      * @return the index of the value within the array,\n      *  {@link #INDEX_NOT_FOUND} ({@code -1}) if not found or {@code null} array input\n      */\n-    public static int indexOf(boolean[] array, boolean valueToFind) {\n+    public static int indexOf(final boolean[] array, final boolean valueToFind) {\n         return indexOf(array, valueToFind, 0);\n     }\n \n      *  {@link #INDEX_NOT_FOUND} ({@code -1}) if not found or {@code null}\n      *  array input\n      */\n-    public static int indexOf(boolean[] array, boolean valueToFind, int startIndex) {\n+    public static int indexOf(final boolean[] array, final boolean valueToFind, int startIndex) {\n         if (ArrayUtils.isEmpty(array)) {\n             return INDEX_NOT_FOUND;\n         }\n      * @return the last index of the value within the array,\n      *  {@link #INDEX_NOT_FOUND} ({@code -1}) if not found or {@code null} array input\n      */\n-    public static int lastIndexOf(boolean[] array, boolean valueToFind) {\n+    public static int lastIndexOf(final boolean[] array, final boolean valueToFind) {\n         return lastIndexOf(array, valueToFind, Integer.MAX_VALUE);\n     }\n \n      * @return the last index of the value within the array,\n      *  {@link #INDEX_NOT_FOUND} ({@code -1}) if not found or {@code null} array input\n      */\n-    public static int lastIndexOf(boolean[] array, boolean valueToFind, int startIndex) {\n+    public static int lastIndexOf(final boolean[] array, final boolean valueToFind, int startIndex) {\n         if (ArrayUtils.isEmpty(array)) {\n             return INDEX_NOT_FOUND;\n         }\n      * @param valueToFind  the value to find\n      * @return {@code true} if the array contains the object\n      */\n-    public static boolean contains(boolean[] array, boolean valueToFind) {\n+    public static boolean contains(final boolean[] array, final boolean valueToFind) {\n         return indexOf(array, valueToFind) != INDEX_NOT_FOUND;\n     }\n \n      * @return a {@code char} array, {@code null} if null array input\n      * @throws NullPointerException if array content is {@code null}\n      */\n-    public static char[] toPrimitive(Character[] array) {\n+    public static char[] toPrimitive(final Character[] array) {\n         if (array == null) {\n             return null;\n         } else if (array.length == 0) {\n      * @param valueForNull  the value to insert if {@code null} found\n      * @return a {@code char} array, {@code null} if null array input\n      */\n-    public static char[] toPrimitive(Character[] array, char valueForNull) {\n+    public static char[] toPrimitive(final Character[] array, final char valueForNull) {\n         if (array == null) {\n             return null;\n         } else if (array.length == 0) {\n      * @param array a {@code char} array\n      * @return a {@code Character} array, {@code null} if null array input\n      */\n-    public static Character[] toObject(char[] array) {\n+    public static Character[] toObject(final char[] array) {\n         if (array == null) {\n             return null;\n         } else if (array.length == 0) {\n      * @return a {@code long} array, {@code null} if null array input\n      * @throws NullPointerException if array content is {@code null}\n      */\n-    public static long[] toPrimitive(Long[] array) {\n+    public static long[] toPrimitive(final Long[] array) {\n         if (array == null) {\n             return null;\n         } else if (array.length == 0) {\n      * @param valueForNull  the value to insert if {@code null} found\n      * @return a {@code long} array, {@code null} if null array input\n      */\n-    public static long[] toPrimitive(Long[] array, long valueForNull) {\n+    public static long[] toPrimitive(final Long[] array, final long valueForNull) {\n         if (array == null) {\n             return null;\n         } else if (array.length == 0) {\n      * @param array  a {@code long} array\n      * @return a {@code Long} array, {@code null} if null array input\n      */\n-    public static Long[] toObject(long[] array) {\n+    public static Long[] toObject(final long[] array) {\n         if (array == null) {\n             return null;\n         } else if (array.length == 0) {\n      * @return an {@code int} array, {@code null} if null array input\n      * @throws NullPointerException if array content is {@code null}\n      */\n-    public static int[] toPrimitive(Integer[] array) {\n+    public static int[] toPrimitive(final Integer[] array) {\n         if (array == null) {\n             return null;\n         } else if (array.length == 0) {\n      * @param valueForNull  the value to insert if {@code null} found\n      * @return an {@code int} array, {@code null} if null array input\n      */\n-    public static int[] toPrimitive(Integer[] array, int valueForNull) {\n+    public static int[] toPrimitive(final Integer[] array, final int valueForNull) {\n         if (array == null) {\n             return null;\n         } else if (array.length == 0) {\n      * @param array  an {@code int} array\n      * @return an {@code Integer} array, {@code null} if null array input\n      */\n-    public static Integer[] toObject(int[] array) {\n+    public static Integer[] toObject(final int[] array) {\n         if (array == null) {\n             return null;\n         } else if (array.length == 0) {\n      * @return a {@code byte} array, {@code null} if null array input\n      * @throws NullPointerException if array content is {@code null}\n      */\n-    public static short[] toPrimitive(Short[] array) {\n+    public static short[] toPrimitive(final Short[] array) {\n         if (array == null) {\n             return null;\n         } else if (array.length == 0) {\n      * @param valueForNull  the value to insert if {@code null} found\n      * @return a {@code byte} array, {@code null} if null array input\n      */\n-    public static short[] toPrimitive(Short[] array, short valueForNull) {\n+    public static short[] toPrimitive(final Short[] array, final short valueForNull) {\n         if (array == null) {\n             return null;\n         } else if (array.length == 0) {\n      * @param array  a {@code short} array\n      * @return a {@code Short} array, {@code null} if null array input\n      */\n-    public static Short[] toObject(short[] array) {\n+    public static Short[] toObject(final short[] array) {\n         if (array == null) {\n             return null;\n         } else if (array.length == 0) {\n      * @return a {@code byte} array, {@code null} if null array input\n      * @throws NullPointerException if array content is {@code null}\n      */\n-    public static byte[] toPrimitive(Byte[] array) {\n+    public static byte[] toPrimitive(final Byte[] array) {\n         if (array == null) {\n             return null;\n         } else if (array.length == 0) {\n      * @param valueForNull  the value to insert if {@code null} found\n      * @return a {@code byte} array, {@code null} if null array input\n      */\n-    public static byte[] toPrimitive(Byte[] array, byte valueForNull) {\n+    public static byte[] toPrimitive(final Byte[] array, final byte valueForNull) {\n         if (array == null) {\n             return null;\n         } else if (array.length == 0) {\n      * @param array  a {@code byte} array\n      * @return a {@code Byte} array, {@code null} if null array input\n      */\n-    public static Byte[] toObject(byte[] array) {\n+    public static Byte[] toObject(final byte[] array) {\n         if (array == null) {\n             return null;\n         } else if (array.length == 0) {\n      * @return a {@code double} array, {@code null} if null array input\n      * @throws NullPointerException if array content is {@code null}\n      */\n-    public static double[] toPrimitive(Double[] array) {\n+    public static double[] toPrimitive(final Double[] array) {\n         if (array == null) {\n             return null;\n         } else if (array.length == 0) {\n      * @param valueForNull  the value to insert if {@code null} found\n      * @return a {@code double} array, {@code null} if null array input\n      */\n-    public static double[] toPrimitive(Double[] array, double valueForNull) {\n+    public static double[] toPrimitive(final Double[] array, final double valueForNull) {\n         if (array == null) {\n             return null;\n         } else if (array.length == 0) {\n      * @param array  a {@code double} array\n      * @return a {@code Double} array, {@code null} if null array input\n      */\n-    public static Double[] toObject(double[] array) {\n+    public static Double[] toObject(final double[] array) {\n         if (array == null) {\n             return null;\n         } else if (array.length == 0) {\n      * @return a {@code float} array, {@code null} if null array input\n      * @throws NullPointerException if array content is {@code null}\n      */\n-    public static float[] toPrimitive(Float[] array) {\n+    public static float[] toPrimitive(final Float[] array) {\n         if (array == null) {\n             return null;\n         } else if (array.length == 0) {\n      * @param valueForNull  the value to insert if {@code null} found\n      * @return a {@code float} array, {@code null} if null array input\n      */\n-    public static float[] toPrimitive(Float[] array, float valueForNull) {\n+    public static float[] toPrimitive(final Float[] array, final float valueForNull) {\n         if (array == null) {\n             return null;\n         } else if (array.length == 0) {\n      * @param array  a {@code float} array\n      * @return a {@code Float} array, {@code null} if null array input\n      */\n-    public static Float[] toObject(float[] array) {\n+    public static Float[] toObject(final float[] array) {\n         if (array == null) {\n             return null;\n         } else if (array.length == 0) {\n      * @return a {@code boolean} array, {@code null} if null array input\n      * @throws NullPointerException if array content is {@code null}\n      */\n-    public static boolean[] toPrimitive(Boolean[] array) {\n+    public static boolean[] toPrimitive(final Boolean[] array) {\n         if (array == null) {\n             return null;\n         } else if (array.length == 0) {\n      * @param valueForNull  the value to insert if {@code null} found\n      * @return a {@code boolean} array, {@code null} if null array input\n      */\n-    public static boolean[] toPrimitive(Boolean[] array, boolean valueForNull) {\n+    public static boolean[] toPrimitive(final Boolean[] array, final boolean valueForNull) {\n         if (array == null) {\n             return null;\n         } else if (array.length == 0) {\n      * @param array  a {@code boolean} array\n      * @return a {@code Boolean} array, {@code null} if null array input\n      */\n-    public static Boolean[] toObject(boolean[] array) {\n+    public static Boolean[] toObject(final boolean[] array) {\n         if (array == null) {\n             return null;\n         } else if (array.length == 0) {\n      * @return {@code true} if the array is empty or {@code null}\n      * @since 2.1\n      */\n-    public static boolean isEmpty(Object[] array) {\n+    public static boolean isEmpty(final Object[] array) {\n         return array == null || array.length == 0;\n     }\n \n      * @return {@code true} if the array is empty or {@code null}\n      * @since 2.1\n      */\n-    public static boolean isEmpty(long[] array) {\n+    public static boolean isEmpty(final long[] array) {\n         return array == null || array.length == 0;\n     }\n \n      * @return {@code true} if the array is empty or {@code null}\n      * @since 2.1\n      */\n-    public static boolean isEmpty(int[] array) {\n+    public static boolean isEmpty(final int[] array) {\n         return array == null || array.length == 0;\n     }\n \n      * @return {@code true} if the array is empty or {@code null}\n      * @since 2.1\n      */\n-    public static boolean isEmpty(short[] array) {\n+    public static boolean isEmpty(final short[] array) {\n         return array == null || array.length == 0;\n     }\n \n      * @return {@code true} if the array is empty or {@code null}\n      * @since 2.1\n      */\n-    public static boolean isEmpty(char[] array) {\n+    public static boolean isEmpty(final char[] array) {\n         return array == null || array.length == 0;\n     }\n \n      * @return {@code true} if the array is empty or {@code null}\n      * @since 2.1\n      */\n-    public static boolean isEmpty(byte[] array) {\n+    public static boolean isEmpty(final byte[] array) {\n         return array == null || array.length == 0;\n     }\n \n      * @return {@code true} if the array is empty or {@code null}\n      * @since 2.1\n      */\n-    public static boolean isEmpty(double[] array) {\n+    public static boolean isEmpty(final double[] array) {\n         return array == null || array.length == 0;\n     }\n \n      * @return {@code true} if the array is empty or {@code null}\n      * @since 2.1\n      */\n-    public static boolean isEmpty(float[] array) {\n+    public static boolean isEmpty(final float[] array) {\n         return array == null || array.length == 0;\n     }\n \n      * @return {@code true} if the array is empty or {@code null}\n      * @since 2.1\n      */\n-    public static boolean isEmpty(boolean[] array) {\n+    public static boolean isEmpty(final boolean[] array) {\n         return array == null || array.length == 0;\n     }\n \n      * @return {@code true} if the array is not empty or not {@code null}\n      * @since 2.5\n      */\n-     public static <T> boolean isNotEmpty(T[] array) {\n+     public static <T> boolean isNotEmpty(final T[] array) {\n          return (array != null && array.length != 0);\n      }\n \n      * @return {@code true} if the array is not empty or not {@code null}\n      * @since 2.5\n      */\n-    public static boolean isNotEmpty(long[] array) {\n+    public static boolean isNotEmpty(final long[] array) {\n         return (array != null && array.length != 0);\n     }\n \n      * @return {@code true} if the array is not empty or not {@code null}\n      * @since 2.5\n      */\n-    public static boolean isNotEmpty(int[] array) {\n+    public static boolean isNotEmpty(final int[] array) {\n         return (array != null && array.length != 0);\n     }\n \n      * @return {@code true} if the array is not empty or not {@code null}\n      * @since 2.5\n      */\n-    public static boolean isNotEmpty(short[] array) {\n+    public static boolean isNotEmpty(final short[] array) {\n         return (array != null && array.length != 0);\n     }\n \n      * @return {@code true} if the array is not empty or not {@code null}\n      * @since 2.5\n      */\n-    public static boolean isNotEmpty(char[] array) {\n+    public static boolean isNotEmpty(final char[] array) {\n         return (array != null && array.length != 0);\n     }\n \n      * @return {@code true} if the array is not empty or not {@code null}\n      * @since 2.5\n      */\n-    public static boolean isNotEmpty(byte[] array) {\n+    public static boolean isNotEmpty(final byte[] array) {\n         return (array != null && array.length != 0);\n     }\n \n      * @return {@code true} if the array is not empty or not {@code null}\n      * @since 2.5\n      */\n-    public static boolean isNotEmpty(double[] array) {\n+    public static boolean isNotEmpty(final double[] array) {\n         return (array != null && array.length != 0);\n     }\n \n      * @return {@code true} if the array is not empty or not {@code null}\n      * @since 2.5\n      */\n-    public static boolean isNotEmpty(float[] array) {\n+    public static boolean isNotEmpty(final float[] array) {\n         return (array != null && array.length != 0);\n     }\n \n      * @return {@code true} if the array is not empty or not {@code null}\n      * @since 2.5\n      */\n-    public static boolean isNotEmpty(boolean[] array) {\n+    public static boolean isNotEmpty(final boolean[] array) {\n         return (array != null && array.length != 0);\n     }\n \n      * @since 2.1\n      * @throws IllegalArgumentException if the array types are incompatible\n      */\n-    public static <T> T[] addAll(T[] array1, T... array2) {\n+    public static <T> T[] addAll(final T[] array1, final T... array2) {\n         if (array1 == null) {\n             return clone(array2);\n         } else if (array2 == null) {\n      * @return The new boolean[] array.\n      * @since 2.1\n      */\n-    public static boolean[] addAll(boolean[] array1, boolean... array2) {\n+    public static boolean[] addAll(final boolean[] array1, final boolean... array2) {\n         if (array1 == null) {\n             return clone(array2);\n         } else if (array2 == null) {\n      * @return The new char[] array.\n      * @since 2.1\n      */\n-    public static char[] addAll(char[] array1, char... array2) {\n+    public static char[] addAll(final char[] array1, final char... array2) {\n         if (array1 == null) {\n             return clone(array2);\n         } else if (array2 == null) {\n      * @return The new byte[] array.\n      * @since 2.1\n      */\n-    public static byte[] addAll(byte[] array1, byte... array2) {\n+    public static byte[] addAll(final byte[] array1, final byte... array2) {\n         if (array1 == null) {\n             return clone(array2);\n         } else if (array2 == null) {\n      * @return The new short[] array.\n      * @since 2.1\n      */\n-    public static short[] addAll(short[] array1, short... array2) {\n+    public static short[] addAll(final short[] array1, final short... array2) {\n         if (array1 == null) {\n             return clone(array2);\n         } else if (array2 == null) {\n      * @return The new int[] array.\n      * @since 2.1\n      */\n-    public static int[] addAll(int[] array1, int... array2) {\n+    public static int[] addAll(final int[] array1, final int... array2) {\n         if (array1 == null) {\n             return clone(array2);\n         } else if (array2 == null) {\n      * @return The new long[] array.\n      * @since 2.1\n      */\n-    public static long[] addAll(long[] array1, long... array2) {\n+    public static long[] addAll(final long[] array1, final long... array2) {\n         if (array1 == null) {\n             return clone(array2);\n         } else if (array2 == null) {\n      * @return The new float[] array.\n      * @since 2.1\n      */\n-    public static float[] addAll(float[] array1, float... array2) {\n+    public static float[] addAll(final float[] array1, final float... array2) {\n         if (array1 == null) {\n             return clone(array2);\n         } else if (array2 == null) {\n      * @return The new double[] array.\n      * @since 2.1\n      */\n-    public static double[] addAll(double[] array1, double... array2) {\n+    public static double[] addAll(final double[] array1, final double... array2) {\n         if (array1 == null) {\n             return clone(array2);\n         } else if (array2 == null) {\n      * @since 2.1\n      * @throws IllegalArgumentException if both arguments are null\n      */\n-    public static <T> T[] add(T[] array, T element) {\n+    public static <T> T[] add(final T[] array, final T element) {\n         Class<?> type;\n         if (array != null){\n             type = array.getClass();\n      * @return A new array containing the existing elements plus the new element\n      * @since 2.1\n      */\n-    public static boolean[] add(boolean[] array, boolean element) {\n+    public static boolean[] add(final boolean[] array, final boolean element) {\n         boolean[] newArray = (boolean[])copyArrayGrow1(array, Boolean.TYPE);\n         newArray[newArray.length - 1] = element;\n         return newArray;\n      * @return A new array containing the existing elements plus the new element\n      * @since 2.1\n      */\n-    public static byte[] add(byte[] array, byte element) {\n+    public static byte[] add(final byte[] array, final byte element) {\n         byte[] newArray = (byte[])copyArrayGrow1(array, Byte.TYPE);\n         newArray[newArray.length - 1] = element;\n         return newArray;\n      * @return A new array containing the existing elements plus the new element\n      * @since 2.1\n      */\n-    public static char[] add(char[] array, char element) {\n+    public static char[] add(final char[] array, final char element) {\n         char[] newArray = (char[])copyArrayGrow1(array, Character.TYPE);\n         newArray[newArray.length - 1] = element;\n         return newArray;\n      * @return A new array containing the existing elements plus the new element\n      * @since 2.1\n      */\n-    public static double[] add(double[] array, double element) {\n+    public static double[] add(final double[] array, final double element) {\n         double[] newArray = (double[])copyArrayGrow1(array, Double.TYPE);\n         newArray[newArray.length - 1] = element;\n         return newArray;\n      * @return A new array containing the existing elements plus the new element\n      * @since 2.1\n      */\n-    public static float[] add(float[] array, float element) {\n+    public static float[] add(final float[] array, final float element) {\n         float[] newArray = (float[])copyArrayGrow1(array, Float.TYPE);\n         newArray[newArray.length - 1] = element;\n         return newArray;\n      * @return A new array containing the existing elements plus the new element\n      * @since 2.1\n      */\n-    public static int[] add(int[] array, int element) {\n+    public static int[] add(final int[] array, final int element) {\n         int[] newArray = (int[])copyArrayGrow1(array, Integer.TYPE);\n         newArray[newArray.length - 1] = element;\n         return newArray;\n      * @return A new array containing the existing elements plus the new element\n      * @since 2.1\n      */\n-    public static long[] add(long[] array, long element) {\n+    public static long[] add(final long[] array, final long element) {\n         long[] newArray = (long[])copyArrayGrow1(array, Long.TYPE);\n         newArray[newArray.length - 1] = element;\n         return newArray;\n      * @return A new array containing the existing elements plus the new element\n      * @since 2.1\n      */\n-    public static short[] add(short[] array, short element) {\n+    public static short[] add(final short[] array, final short element) {\n         short[] newArray = (short[])copyArrayGrow1(array, Short.TYPE);\n         newArray[newArray.length - 1] = element;\n         return newArray;\n      * size 1 array of this type.\n      * @return A new copy of the array of size 1 greater than the input.\n      */\n-    private static Object copyArrayGrow1(Object array, Class<?> newArrayComponentType) {\n+    private static Object copyArrayGrow1(final Object array, final Class<?> newArrayComponentType) {\n         if (array != null) {\n             int arrayLength = Array.getLength(array);\n             Object newArray = Array.newInstance(array.getClass().getComponentType(), arrayLength + 1);\n      * (index < 0 || index > array.length).\n      * @throws IllegalArgumentException if both array and element are null\n      */\n-    public static <T> T[] add(T[] array, int index, T element) {\n+    public static <T> T[] add(final T[] array, final int index, final T element) {\n         Class<?> clss = null;\n         if (array != null) {\n             clss = array.getClass().getComponentType();\n      * @throws IndexOutOfBoundsException if the index is out of range\n      * (index < 0 || index > array.length).\n      */\n-    public static boolean[] add(boolean[] array, int index, boolean element) {\n+    public static boolean[] add(final boolean[] array, final int index, final boolean element) {\n         return (boolean[]) add(array, index, Boolean.valueOf(element), Boolean.TYPE);\n     }\n \n      * @throws IndexOutOfBoundsException if the index is out of range\n      * (index < 0 || index > array.length).\n      */\n-    public static char[] add(char[] array, int index, char element) {\n+    public static char[] add(final char[] array, final int index, final char element) {\n         return (char[]) add(array, index, Character.valueOf(element), Character.TYPE);\n     }\n \n      * @throws IndexOutOfBoundsException if the index is out of range\n      * (index < 0 || index > array.length).\n      */\n-    public static byte[] add(byte[] array, int index, byte element) {\n+    public static byte[] add(final byte[] array, final int index, final byte element) {\n         return (byte[]) add(array, index, Byte.valueOf(element), Byte.TYPE);\n     }\n \n      * @throws IndexOutOfBoundsException if the index is out of range\n      * (index < 0 || index > array.length).\n      */\n-    public static short[] add(short[] array, int index, short element) {\n+    public static short[] add(final short[] array, final int index, final short element) {\n         return (short[]) add(array, index, Short.valueOf(element), Short.TYPE);\n     }\n \n      * @throws IndexOutOfBoundsException if the index is out of range\n      * (index < 0 || index > array.length).\n      */\n-    public static int[] add(int[] array, int index, int element) {\n+    public static int[] add(final int[] array, final int index, final int element) {\n         return (int[]) add(array, index, Integer.valueOf(element), Integer.TYPE);\n     }\n \n      * @throws IndexOutOfBoundsException if the index is out of range\n      * (index < 0 || index > array.length).\n      */\n-    public static long[] add(long[] array, int index, long element) {\n+    public static long[] add(final long[] array, final int index, final long element) {\n         return (long[]) add(array, index, Long.valueOf(element), Long.TYPE);\n     }\n \n      * @throws IndexOutOfBoundsException if the index is out of range\n      * (index < 0 || index > array.length).\n      */\n-    public static float[] add(float[] array, int index, float element) {\n+    public static float[] add(final float[] array, final int index, final float element) {\n         return (float[]) add(array, index, Float.valueOf(element), Float.TYPE);\n     }\n \n      * @throws IndexOutOfBoundsException if the index is out of range\n      * (index < 0 || index > array.length).\n      */\n-    public static double[] add(double[] array, int index, double element) {\n+    public static double[] add(final double[] array, final int index, final double element) {\n         return (double[]) add(array, index, Double.valueOf(element), Double.TYPE);\n     }\n \n      * @param clss the type of the element being added\n      * @return A new array containing the existing elements and the new element\n      */\n-    private static Object add(Object array, int index, Object element, Class<?> clss) {\n+    private static Object add(final Object array, final int index, final Object element, final Class<?> clss) {\n         if (array == null) {\n             if (index != 0) {\n                 throw new IndexOutOfBoundsException(\"Index: \" + index + \", Length: 0\");\n      * @since 2.1\n      */\n     @SuppressWarnings(\"unchecked\") // remove() always creates an array of the same type as its input\n-    public static <T> T[] remove(T[] array, int index) {\n+    public static <T> T[] remove(final T[] array, final int index) {\n         return (T[]) remove((Object) array, index);\n     }\n \n      *         occurrence of the specified element.\n      * @since 2.1\n      */\n-    public static <T> T[] removeElement(T[] array, Object element) {\n+    public static <T> T[] removeElement(final T[] array, final Object element) {\n         int index = indexOf(array, element);\n         if (index == INDEX_NOT_FOUND) {\n             return clone(array);\n      * (index < 0 || index >= array.length), or if the array is {@code null}.\n      * @since 2.1\n      */\n-    public static boolean[] remove(boolean[] array, int index) {\n+    public static boolean[] remove(final boolean[] array, final int index) {\n         return (boolean[]) remove((Object) array, index);\n     }\n \n      *         occurrence of the specified element.\n      * @since 2.1\n      */\n-    public static boolean[] removeElement(boolean[] array, boolean element) {\n+    public static boolean[] removeElement(final boolean[] array, final boolean element) {\n         int index = indexOf(array, element);\n         if (index == INDEX_NOT_FOUND) {\n             return clone(array);\n      * (index < 0 || index >= array.length), or if the array is {@code null}.\n      * @since 2.1\n      */\n-    public static byte[] remove(byte[] array, int index) {\n+    public static byte[] remove(final byte[] array, final int index) {\n         return (byte[]) remove((Object) array, index);\n     }\n \n      *         occurrence of the specified element.\n      * @since 2.1\n      */\n-    public static byte[] removeElement(byte[] array, byte element) {\n+    public static byte[] removeElement(final byte[] array, final byte element) {\n         int index = indexOf(array, element);\n         if (index == INDEX_NOT_FOUND) {\n             return clone(array);\n      * (index < 0 || index >= array.length), or if the array is {@code null}.\n      * @since 2.1\n      */\n-    public static char[] remove(char[] array, int index) {\n+    public static char[] remove(final char[] array, final int index) {\n         return (char[]) remove((Object) array, index);\n     }\n \n      *         occurrence of the specified element.\n      * @since 2.1\n      */\n-    public static char[] removeElement(char[] array, char element) {\n+    public static char[] removeElement(final char[] array, final char element) {\n         int index = indexOf(array, element);\n         if (index == INDEX_NOT_FOUND) {\n             return clone(array);\n      * (index < 0 || index >= array.length), or if the array is {@code null}.\n      * @since 2.1\n      */\n-    public static double[] remove(double[] array, int index) {\n+    public static double[] remove(final double[] array, final int index) {\n         return (double[]) remove((Object) array, index);\n     }\n \n      *         occurrence of the specified element.\n      * @since 2.1\n      */\n-    public static double[] removeElement(double[] array, double element) {\n+    public static double[] removeElement(final double[] array, final double element) {\n         int index = indexOf(array, element);\n         if (index == INDEX_NOT_FOUND) {\n             return clone(array);\n      * (index < 0 || index >= array.length), or if the array is {@code null}.\n      * @since 2.1\n      */\n-    public static float[] remove(float[] array, int index) {\n+    public static float[] remove(final float[] array, final int index) {\n         return (float[]) remove((Object) array, index);\n     }\n \n      *         occurrence of the specified element.\n      * @since 2.1\n      */\n-    public static float[] removeElement(float[] array, float element) {\n+    public static float[] removeElement(final float[] array, final float element) {\n         int index = indexOf(array, element);\n         if (index == INDEX_NOT_FOUND) {\n             return clone(array);\n      * (index < 0 || index >= array.length), or if the array is {@code null}.\n      * @since 2.1\n      */\n-    public static int[] remove(int[] array, int index) {\n+    public static int[] remove(final int[] array, final int index) {\n         return (int[]) remove((Object) array, index);\n     }\n \n      *         occurrence of the specified element.\n      * @since 2.1\n      */\n-    public static int[] removeElement(int[] array, int element) {\n+    public static int[] removeElement(final int[] array, final int element) {\n         int index = indexOf(array, element);\n         if (index == INDEX_NOT_FOUND) {\n             return clone(array);\n      * (index < 0 || index >= array.length), or if the array is {@code null}.\n      * @since 2.1\n      */\n-    public static long[] remove(long[] array, int index) {\n+    public static long[] remove(final long[] array, final int index) {\n         return (long[]) remove((Object) array, index);\n     }\n \n      *         occurrence of the specified element.\n      * @since 2.1\n      */\n-    public static long[] removeElement(long[] array, long element) {\n+    public static long[] removeElement(final long[] array, final long element) {\n         int index = indexOf(array, element);\n         if (index == INDEX_NOT_FOUND) {\n             return clone(array);\n      * (index < 0 || index >= array.length), or if the array is {@code null}.\n      * @since 2.1\n      */\n-    public static short[] remove(short[] array, int index) {\n+    public static short[] remove(final short[] array, final int index) {\n         return (short[]) remove((Object) array, index);\n     }\n \n      *         occurrence of the specified element.\n      * @since 2.1\n      */\n-    public static short[] removeElement(short[] array, short element) {\n+    public static short[] removeElement(final short[] array, final short element) {\n         int index = indexOf(array, element);\n         if (index == INDEX_NOT_FOUND) {\n             return clone(array);\n      * (index < 0 || index >= array.length), or if the array is {@code null}.\n      * @since 2.1\n      */\n-    private static Object remove(Object array, int index) {\n+    private static Object remove(final Object array, final int index) {\n         int length = getLength(array);\n         if (index < 0 || index >= length) {\n             throw new IndexOutOfBoundsException(\"Index: \" + index + \", Length: \" + length);\n      * @since 3.0.1\n      */\n     @SuppressWarnings(\"unchecked\") // removeAll() always creates an array of the same type as its input\n-    public static <T> T[] removeAll(T[] array, int... indices) {\n+    public static <T> T[] removeAll(final T[] array, final int... indices) {\n         return (T[]) removeAll((Object) array, clone(indices));\n     }\n \n      *         earliest-encountered occurrences of the specified elements.\n      * @since 3.0.1\n      */\n-    public static <T> T[] removeElements(T[] array, T... values) {\n+    public static <T> T[] removeElements(final T[] array, final T... values) {\n         if (isEmpty(array) || isEmpty(values)) {\n             return clone(array);\n         }\n      * (index < 0 || index >= array.length), or if the array is {@code null}.\n      * @since 3.0.1\n      */\n-    public static byte[] removeAll(byte[] array, int... indices) {\n+    public static byte[] removeAll(final byte[] array, final int... indices) {\n         return (byte[]) removeAll((Object) array, clone(indices));\n     }\n \n      *         earliest-encountered occurrences of the specified elements.\n      * @since 3.0.1\n      */\n-    public static byte[] removeElements(byte[] array, byte... values) {\n+    public static byte[] removeElements(final byte[] array, final byte... values) {\n         if (isEmpty(array) || isEmpty(values)) {\n             return clone(array);\n         }\n      * (index < 0 || index >= array.length), or if the array is {@code null}.\n      * @since 3.0.1\n      */\n-    public static short[] removeAll(short[] array, int... indices) {\n+    public static short[] removeAll(final short[] array, final int... indices) {\n         return (short[]) removeAll((Object) array, clone(indices));\n     }\n \n      *         earliest-encountered occurrences of the specified elements.\n      * @since 3.0.1\n      */\n-    public static short[] removeElements(short[] array, short... values) {\n+    public static short[] removeElements(final short[] array, final short... values) {\n         if (isEmpty(array) || isEmpty(values)) {\n             return clone(array);\n         }\n      * (index < 0 || index >= array.length), or if the array is {@code null}.\n      * @since 3.0.1\n      */\n-    public static int[] removeAll(int[] array, int... indices) {\n+    public static int[] removeAll(final int[] array, final int... indices) {\n         return (int[]) removeAll((Object) array, clone(indices));\n     }\n \n      *         earliest-encountered occurrences of the specified elements.\n      * @since 3.0.1\n      */\n-    public static int[] removeElements(int[] array, int... values) {\n+    public static int[] removeElements(final int[] array, final int... values) {\n         if (isEmpty(array) || isEmpty(values)) {\n             return clone(array);\n         }\n      * (index < 0 || index >= array.length), or if the array is {@code null}.\n      * @since 3.0.1\n      */\n-    public static char[] removeAll(char[] array, int... indices) {\n+    public static char[] removeAll(final char[] array, final int... indices) {\n         return (char[]) removeAll((Object) array, clone(indices));\n     }\n \n      *         earliest-encountered occurrences of the specified elements.\n      * @since 3.0.1\n      */\n-    public static char[] removeElements(char[] array, char... values) {\n+    public static char[] removeElements(final char[] array, final char... values) {\n         if (isEmpty(array) || isEmpty(values)) {\n             return clone(array);\n         }\n      * (index < 0 || index >= array.length), or if the array is {@code null}.\n      * @since 3.0.1\n      */\n-    public static long[] removeAll(long[] array, int... indices) {\n+    public static long[] removeAll(final long[] array, final int... indices) {\n         return (long[]) removeAll((Object) array, clone(indices));\n     }\n \n      *         earliest-encountered occurrences of the specified elements.\n      * @since 3.0.1\n      */\n-    public static long[] removeElements(long[] array, long... values) {\n+    public static long[] removeElements(final long[] array, final long... values) {\n         if (isEmpty(array) || isEmpty(values)) {\n             return clone(array);\n         }\n      * (index < 0 || index >= array.length), or if the array is {@code null}.\n      * @since 3.0.1\n      */\n-    public static float[] removeAll(float[] array, int... indices) {\n+    public static float[] removeAll(final float[] array, final int... indices) {\n         return (float[]) removeAll((Object) array, clone(indices));\n     }\n \n      *         earliest-encountered occurrences of the specified elements.\n      * @since 3.0.1\n      */\n-    public static float[] removeElements(float[] array, float... values) {\n+    public static float[] removeElements(final float[] array, final float... values) {\n         if (isEmpty(array) || isEmpty(values)) {\n             return clone(array);\n         }\n      * (index < 0 || index >= array.length), or if the array is {@code null}.\n      * @since 3.0.1\n      */\n-    public static double[] removeAll(double[] array, int... indices) {\n+    public static double[] removeAll(final double[] array, final int... indices) {\n         return (double[]) removeAll((Object) array, clone(indices));\n     }\n \n      *         earliest-encountered occurrences of the specified elements.\n      * @since 3.0.1\n      */\n-    public static double[] removeElements(double[] array, double... values) {\n+    public static double[] removeElements(final double[] array, final double... values) {\n         if (isEmpty(array) || isEmpty(values)) {\n             return clone(array);\n         }\n      * (index < 0 || index >= array.length), or if the array is {@code null}.\n      * @since 3.0.1\n      */\n-    public static boolean[] removeAll(boolean[] array, int... indices) {\n+    public static boolean[] removeAll(final boolean[] array, final int... indices) {\n         return (boolean[]) removeAll((Object) array, clone(indices));\n     }\n \n      *         earliest-encountered occurrences of the specified elements.\n      * @since 3.0.1\n      */\n-    public static boolean[] removeElements(boolean[] array, boolean... values) {\n+    public static boolean[] removeElements(final boolean[] array, final boolean... values) {\n         if (isEmpty(array) || isEmpty(values)) {\n             return clone(array);\n         }\n      * @since 3.0.1\n      */\n     // package protected for access by unit tests\n-    static Object removeAll(Object array, int... indices) {\n+    static Object removeAll(final Object array, final int... indices) {\n         int length = getLength(array);\n         int diff = 0; // number of distinct indexes, i.e. number of entries that will be removed\n \n      * @since 3.2\n      */\n     // package protected for access by unit tests\n-    static Object removeAll(Object array, BitSet indices) {\n+    static Object removeAll(final Object array, final BitSet indices) {\n         final int srcLength = ArrayUtils.getLength(array);\n         // No need to check maxIndex here, because method only currently called from removeElements()\n         // which guarantee to generate on;y valid bit entries.\n--- a/src/main/java/org/apache/commons/lang3/BitField.java\n+++ b/src/main/java/org/apache/commons/lang3/BitField.java\n      *  BitField. Bits that are set in this mask are the bits\n      *  that this BitField operates on\n      */\n-    public BitField(int mask) {\n+    public BitField(final int mask) {\n         _mask = mask;\n         int count = 0;\n         int bit_pattern = mask;\n      *  in\n      * @return the selected bits, shifted right appropriately\n      */\n-    public int getValue(int holder) {\n+    public int getValue(final int holder) {\n         return getRawValue(holder) >> _shift_count;\n     }\n \n      *  interested in\n      * @return the selected bits, shifted right appropriately\n      */\n-    public short getShortValue(short holder) {\n+    public short getShortValue(final short holder) {\n         return (short) getValue(holder);\n     }\n \n      *  interested in\n      * @return the selected bits\n      */\n-    public int getRawValue(int holder) {\n+    public int getRawValue(final int holder) {\n         return holder & _mask;\n     }\n \n      *  interested in\n      * @return the selected bits\n      */\n-    public short getShortRawValue(short holder) {\n+    public short getShortRawValue(final short holder) {\n         return (short) getRawValue(holder);\n     }\n \n      * @return {@code true} if any of the bits are set,\n      *  else {@code false}\n      */\n-    public boolean isSet(int holder) {\n+    public boolean isSet(final int holder) {\n         return (holder & _mask) != 0;\n     }\n \n      * @return {@code true} if all of the bits are set,\n      *  else {@code false}\n      */\n-    public boolean isAllSet(int holder) {\n+    public boolean isAllSet(final int holder) {\n         return (holder & _mask) == _mask;\n     }\n \n      * @return the value of holder with the bits from the value\n      *  parameter replacing the old bits\n      */\n-    public int setValue(int holder, int value) {\n+    public int setValue(final int holder, final int value) {\n         return (holder & ~_mask) | ((value << _shift_count) & _mask);\n     }\n \n      * @return the value of holder with the bits from the value\n      *  parameter replacing the old bits\n      */\n-    public short setShortValue(short holder, short value) {\n+    public short setShortValue(final short holder, final short value) {\n         return (short) setValue(holder, value);\n     }\n \n      * @return the value of holder with the specified bits cleared\n      *  (set to {@code 0})\n      */\n-    public int clear(int holder) {\n+    public int clear(final int holder) {\n         return holder & ~_mask;\n     }\n \n      * @return the value of holder with the specified bits cleared\n      *  (set to {@code 0})\n      */\n-    public short clearShort(short holder) {\n+    public short clearShort(final short holder) {\n         return (short) clear(holder);\n     }\n \n      * @return the value of holder with the specified bits cleared\n      *  (set to {@code 0})\n      */\n-    public byte clearByte(byte holder) {\n+    public byte clearByte(final byte holder) {\n         return (byte) clear(holder);\n     }\n \n      * @return the value of holder with the specified bits set\n      *  to {@code 1}\n      */\n-    public int set(int holder) {\n+    public int set(final int holder) {\n         return holder | _mask;\n     }\n \n      * @return the value of holder with the specified bits set\n      *  to {@code 1}\n      */\n-    public short setShort(short holder) {\n+    public short setShort(final short holder) {\n         return (short) set(holder);\n     }\n \n      * @return the value of holder with the specified bits set\n      *  to {@code 1}\n      */\n-    public byte setByte(byte holder) {\n+    public byte setByte(final byte holder) {\n         return (byte) set(holder);\n     }\n \n      * @return the value of holder with the specified bits set or\n      *         cleared\n      */\n-    public int setBoolean(int holder, boolean flag) {\n+    public int setBoolean(final int holder, final boolean flag) {\n         return flag ? set(holder) : clear(holder);\n     }\n \n      * @return the value of holder with the specified bits set or\n      *  cleared\n      */\n-    public short setShortBoolean(short holder, boolean flag) {\n+    public short setShortBoolean(final short holder, final boolean flag) {\n         return flag ? setShort(holder) : clearShort(holder);\n     }\n \n      * @return the value of holder with the specified bits set or\n      *  cleared\n      */\n-    public byte setByteBoolean(byte holder, boolean flag) {\n+    public byte setByteBoolean(final byte holder, final boolean flag) {\n         return flag ? setByte(holder) : clearByte(holder);\n     }\n \n--- a/src/main/java/org/apache/commons/lang3/BooleanUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/BooleanUtils.java\n      * @param bool  the Boolean to negate, may be null\n      * @return the negated Boolean, or {@code null} if {@code null} input\n      */\n-    public static Boolean negate(Boolean bool) {\n+    public static Boolean negate(final Boolean bool) {\n         if (bool == null) {\n             return null;\n         }\n      * @return {@code true} only if the input is non-null and true\n      * @since 2.1\n      */\n-    public static boolean isTrue(Boolean bool) {\n+    public static boolean isTrue(final Boolean bool) {\n         return Boolean.TRUE.equals(bool);\n     }\n \n      * @return {@code true} if the input is null or false\n      * @since 2.3\n      */\n-    public static boolean isNotTrue(Boolean bool) {\n+    public static boolean isNotTrue(final Boolean bool) {\n         return !isTrue(bool);\n     }\n \n      * @return {@code true} only if the input is non-null and false\n      * @since 2.1\n      */\n-    public static boolean isFalse(Boolean bool) {\n+    public static boolean isFalse(final Boolean bool) {\n         return Boolean.FALSE.equals(bool);\n     }\n \n      * @return {@code true} if the input is null or true\n      * @since 2.3\n      */\n-    public static boolean isNotFalse(Boolean bool) {\n+    public static boolean isNotFalse(final Boolean bool) {\n         return !isFalse(bool);\n     }\n \n      * @param bool  the boolean to convert\n      * @return {@code true} or {@code false}, {@code null} returns {@code false}\n      */\n-    public static boolean toBoolean(Boolean bool) {\n+    public static boolean toBoolean(final Boolean bool) {\n         return bool != null && bool.booleanValue();\n     }\n \n      * @param valueIfNull  the boolean value to return if {@code null}\n      * @return {@code true} or {@code false}\n      */\n-    public static boolean toBooleanDefaultIfNull(Boolean bool, boolean valueIfNull) {\n+    public static boolean toBooleanDefaultIfNull(final Boolean bool, final boolean valueIfNull) {\n         if (bool == null) {\n             return valueIfNull;\n         }\n      * @return {@code true} if non-zero, {@code false}\n      *  if zero\n      */\n-    public static boolean toBoolean(int value) {\n+    public static boolean toBoolean(final int value) {\n         return value != 0;\n     }\n \n      * @return Boolean.TRUE if non-zero, Boolean.FALSE if zero,\n      *  {@code null} if {@code null}\n      */\n-    public static Boolean toBooleanObject(int value) {\n+    public static Boolean toBooleanObject(final int value) {\n         return value == 0 ? Boolean.FALSE : Boolean.TRUE;\n     }\n \n      * @return Boolean.TRUE if non-zero, Boolean.FALSE if zero,\n      *  {@code null} if {@code null} input\n      */\n-    public static Boolean toBooleanObject(Integer value) {\n+    public static Boolean toBooleanObject(final Integer value) {\n         if (value == null) {\n             return null;\n         }\n      * @return {@code true} or {@code false}\n      * @throws IllegalArgumentException if no match\n      */\n-    public static boolean toBoolean(int value, int trueValue, int falseValue) {\n+    public static boolean toBoolean(final int value, final int trueValue, final int falseValue) {\n         if (value == trueValue) {\n             return true;\n         }\n      * @return {@code true} or {@code false}\n      * @throws IllegalArgumentException if no match\n      */\n-    public static boolean toBoolean(Integer value, Integer trueValue, Integer falseValue) {\n+    public static boolean toBoolean(final Integer value, final Integer trueValue, final Integer falseValue) {\n         if (value == null) {\n             if (trueValue == null) {\n                 return true;\n      * @return Boolean.TRUE, Boolean.FALSE, or {@code null}\n      * @throws IllegalArgumentException if no match\n      */\n-    public static Boolean toBooleanObject(int value, int trueValue, int falseValue, int nullValue) {\n+    public static Boolean toBooleanObject(final int value, final int trueValue, final int falseValue, final int nullValue) {\n         if (value == trueValue) {\n             return Boolean.TRUE;\n         }\n      * @return Boolean.TRUE, Boolean.FALSE, or {@code null}\n      * @throws IllegalArgumentException if no match\n      */\n-    public static Boolean toBooleanObject(Integer value, Integer trueValue, Integer falseValue, Integer nullValue) {\n+    public static Boolean toBooleanObject(final Integer value, final Integer trueValue, final Integer falseValue, final Integer nullValue) {\n         if (value == null) {\n             if (trueValue == null) {\n                 return Boolean.TRUE;\n      * @param bool  the boolean to convert\n      * @return one if {@code true}, zero if {@code false}\n      */\n-    public static int toInteger(boolean bool) {\n+    public static int toInteger(final boolean bool) {\n         return bool ? 1 : 0;\n     }\n \n      * @param bool  the boolean to convert\n      * @return one if {@code true}, zero if {@code false}\n      */\n-    public static Integer toIntegerObject(boolean bool) {\n+    public static Integer toIntegerObject(final boolean bool) {\n         return bool ? NumberUtils.INTEGER_ONE : NumberUtils.INTEGER_ZERO;\n     }\n \n      * @param bool  the Boolean to convert\n      * @return one if Boolean.TRUE, zero if Boolean.FALSE, {@code null} if {@code null}\n      */\n-    public static Integer toIntegerObject(Boolean bool) {\n+    public static Integer toIntegerObject(final Boolean bool) {\n         if (bool == null) {\n             return null;\n         }\n      * @param falseValue  the value to return if {@code false}\n      * @return the appropriate value\n      */\n-    public static int toInteger(boolean bool, int trueValue, int falseValue) {\n+    public static int toInteger(final boolean bool, final int trueValue, final int falseValue) {\n         return bool ? trueValue : falseValue;\n     }\n \n      * @param nullValue  the value to return if {@code null}\n      * @return the appropriate value\n      */\n-    public static int toInteger(Boolean bool, int trueValue, int falseValue, int nullValue) {\n+    public static int toInteger(final Boolean bool, final int trueValue, final int falseValue, final int nullValue) {\n         if (bool == null) {\n             return nullValue;\n         }\n      * @param falseValue  the value to return if {@code false}, may be {@code null}\n      * @return the appropriate value\n      */\n-    public static Integer toIntegerObject(boolean bool, Integer trueValue, Integer falseValue) {\n+    public static Integer toIntegerObject(final boolean bool, final Integer trueValue, final Integer falseValue) {\n         return bool ? trueValue : falseValue;\n     }\n \n      * @param nullValue  the value to return if {@code null}, may be {@code null}\n      * @return the appropriate value\n      */\n-    public static Integer toIntegerObject(Boolean bool, Integer trueValue, Integer falseValue, Integer nullValue) {\n+    public static Integer toIntegerObject(final Boolean bool, final Integer trueValue, final Integer falseValue, final Integer nullValue) {\n         if (bool == null) {\n             return nullValue;\n         }\n      * @param str  the String to check\n      * @return the Boolean value of the string, {@code null} if no match or {@code null} input\n      */\n-    public static Boolean toBooleanObject(String str) {\n+    public static Boolean toBooleanObject(final String str) {\n         // Previously used equalsIgnoreCase, which was fast for interned 'true'.\n         // Non interned 'true' matched 15 times slower.\n         //\n      *  or if {@code null} input and {@code nullString} is {@code null}\n      * @throws IllegalArgumentException if the String doesn't match\n      */\n-    public static Boolean toBooleanObject(String str, String trueString, String falseString, String nullString) {\n+    public static Boolean toBooleanObject(final String str, final String trueString, final String falseString, final String nullString) {\n         if (str == null) {\n             if (trueString == null) {\n                 return Boolean.TRUE;\n      * @param str  the String to check\n      * @return the boolean value of the string, {@code false} if no match or the String is null\n      */\n-    public static boolean toBoolean(String str) {\n+    public static boolean toBoolean(final String str) {\n         return toBooleanObject(str) == Boolean.TRUE;\n     }\n \n      * @return the boolean value of the string\n      * @throws IllegalArgumentException if the String doesn't match\n      */\n-    public static boolean toBoolean(String str, String trueString, String falseString) {\n+    public static boolean toBoolean(final String str, final String trueString, final String falseString) {\n         if (str == trueString) {\n             return true;\n         } else if (str == falseString) {\n      * @param bool  the Boolean to check\n      * @return {@code 'true'}, {@code 'false'}, or {@code null}\n      */\n-    public static String toStringTrueFalse(Boolean bool) {\n+    public static String toStringTrueFalse(final Boolean bool) {\n         return toString(bool, \"true\", \"false\", null);\n     }\n \n      * @param bool  the Boolean to check\n      * @return {@code 'on'}, {@code 'off'}, or {@code null}\n      */\n-    public static String toStringOnOff(Boolean bool) {\n+    public static String toStringOnOff(final Boolean bool) {\n         return toString(bool, \"on\", \"off\", null);\n     }\n \n      * @param bool  the Boolean to check\n      * @return {@code 'yes'}, {@code 'no'}, or {@code null}\n      */\n-    public static String toStringYesNo(Boolean bool) {\n+    public static String toStringYesNo(final Boolean bool) {\n         return toString(bool, \"yes\", \"no\", null);\n     }\n \n      * @param nullString  the String to return if {@code null}, may be {@code null}\n      * @return one of the three input Strings\n      */\n-    public static String toString(Boolean bool, String trueString, String falseString, String nullString) {\n+    public static String toString(final Boolean bool, final String trueString, final String falseString, final String nullString) {\n         if (bool == null) {\n             return nullString;\n         }\n      * @param bool  the Boolean to check\n      * @return {@code 'true'}, {@code 'false'}, or {@code null}\n      */\n-    public static String toStringTrueFalse(boolean bool) {\n+    public static String toStringTrueFalse(final boolean bool) {\n         return toString(bool, \"true\", \"false\");\n     }\n \n      * @param bool  the Boolean to check\n      * @return {@code 'on'}, {@code 'off'}, or {@code null}\n      */\n-    public static String toStringOnOff(boolean bool) {\n+    public static String toStringOnOff(final boolean bool) {\n         return toString(bool, \"on\", \"off\");\n     }\n \n      * @param bool  the Boolean to check\n      * @return {@code 'yes'}, {@code 'no'}, or {@code null}\n      */\n-    public static String toStringYesNo(boolean bool) {\n+    public static String toStringYesNo(final boolean bool) {\n         return toString(bool, \"yes\", \"no\");\n     }\n \n      * @param falseString  the String to return if {@code false}, may be {@code null}\n      * @return one of the two input Strings\n      */\n-    public static String toString(boolean bool, String trueString, String falseString) {\n+    public static String toString(final boolean bool, final String trueString, final String falseString) {\n         return bool ? trueString : falseString;\n     }\n \n      * @throws IllegalArgumentException if {@code array} is empty.\n      * @since 3.0.1\n      */\n-    public static boolean and(boolean... array) {\n+    public static boolean and(final boolean... array) {\n         // Validates input\n         if (array == null) {\n             throw new IllegalArgumentException(\"The Array must not be null\");\n      * @throws IllegalArgumentException if {@code array} contains a {@code null}\n      * @since 3.0.1\n      */\n-    public static Boolean and(Boolean... array) {\n+    public static Boolean and(final Boolean... array) {\n         if (array == null) {\n             throw new IllegalArgumentException(\"The Array must not be null\");\n         }\n      * @throws IllegalArgumentException if {@code array} is empty.\n      * @since 3.0.1\n      */\n-    public static boolean or(boolean... array) {\n+    public static boolean or(final boolean... array) {\n         // Validates input\n         if (array == null) {\n             throw new IllegalArgumentException(\"The Array must not be null\");\n      * @throws IllegalArgumentException if {@code array} contains a {@code null}\n      * @since 3.0.1\n      */\n-    public static Boolean or(Boolean... array) {\n+    public static Boolean or(final Boolean... array) {\n         if (array == null) {\n             throw new IllegalArgumentException(\"The Array must not be null\");\n         }\n      * @throws IllegalArgumentException if {@code array} is {@code null}\n      * @throws IllegalArgumentException if {@code array} is empty.\n      */\n-    public static boolean xor(boolean... array) {\n+    public static boolean xor(final boolean... array) {\n         // Validates input\n         if (array == null) {\n             throw new IllegalArgumentException(\"The Array must not be null\");\n      * @throws IllegalArgumentException if {@code array} is empty.\n      * @throws IllegalArgumentException if {@code array} contains a {@code null}\n      */\n-    public static Boolean xor(Boolean... array) {\n+    public static Boolean xor(final Boolean... array) {\n         if (array == null) {\n             throw new IllegalArgumentException(\"The Array must not be null\");\n         }\n--- a/src/main/java/org/apache/commons/lang3/CharEncoding.java\n+++ b/src/main/java/org/apache/commons/lang3/CharEncoding.java\n      * @param name  the name of the requested charset; may be either a canonical name or an alias, null returns false\n      * @return {@code true} if the charset is available in the current Java virtual machine\n      */\n-    public static boolean isSupported(String name) {\n+    public static boolean isSupported(final String name) {\n         if (name == null) {\n             return false;\n         }\n--- a/src/main/java/org/apache/commons/lang3/CharRange.java\n+++ b/src/main/java/org/apache/commons/lang3/CharRange.java\n      * @param end  last character, inclusive, in this range\n      * @param negated  true to express everything except the range\n      */\n-    private CharRange(char start, char end, boolean negated) {\n+    private CharRange(char start, char end, final boolean negated) {\n         super();\n         if (start > end) {\n             char temp = start;\n      * @see CharRange#CharRange(char, char, boolean)\n      * @since 2.5\n      */\n-    public static CharRange is(char ch) {\n+    public static CharRange is(final char ch) {\n         return new CharRange(ch, ch, false);\n     }\n \n      * @see CharRange#CharRange(char, char, boolean)\n      * @since 2.5\n      */\n-    public static CharRange isNot(char ch) {\n+    public static CharRange isNot(final char ch) {\n         return new CharRange(ch, ch, true);\n     }\n \n      * @see CharRange#CharRange(char, char, boolean)\n      * @since 2.5\n      */\n-    public static CharRange isIn(char start, char end) {\n+    public static CharRange isIn(final char start, final char end) {\n         return new CharRange(start, end, false);\n     }\n \n      * @see CharRange#CharRange(char, char, boolean)\n      * @since 2.5\n      */\n-    public static CharRange isNotIn(char start, char end) {\n+    public static CharRange isNotIn(final char start, final char end) {\n         return new CharRange(start, end, true);\n     }\n \n      * @param ch  the character to check\n      * @return {@code true} if this range contains the input character\n      */\n-    public boolean contains(char ch) {\n+    public boolean contains(final char ch) {\n         return (ch >= start && ch <= end) != negated;\n     }\n \n      * @return {@code true} if this range entirely contains the input range\n      * @throws IllegalArgumentException if {@code null} input\n      */\n-    public boolean contains(CharRange range) {\n+    public boolean contains(final CharRange range) {\n         if (range == null) {\n             throw new IllegalArgumentException(\"The Range must not be null\");\n         }\n      * @return true if equal\n      */\n     @Override\n-    public boolean equals(Object obj) {\n+    public boolean equals(final Object obj) {\n         if (obj == this) {\n             return true;\n         }\n          *\n          * @param r The character range\n          */\n-        private CharacterIterator(CharRange r) {\n+        private CharacterIterator(final CharRange r) {\n             range = r;\n             hasNext = true;\n \n--- a/src/main/java/org/apache/commons/lang3/CharSequenceUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/CharSequenceUtils.java\n      * @throws IndexOutOfBoundsException if {@code start} is negative or if \n      *  {@code start} is greater than {@code length()}\n      */\n-    public static CharSequence subSequence(CharSequence cs, int start) {\n+    public static CharSequence subSequence(final CharSequence cs, final int start) {\n         return cs == null ? null : cs.subSequence(start, cs.length());\n     }\n \n      * @param start  the start index, negative starts at the string start\n      * @return the index where the search char was found, -1 if not found\n      */\n-    static int indexOf(CharSequence cs, int searchChar, int start) {\n+    static int indexOf(final CharSequence cs, final int searchChar, int start) {\n         if (cs instanceof String) {\n             return ((String) cs).indexOf(searchChar, start);\n         } else {\n      * @param start the start index\n      * @return the index where the search sequence was found\n      */\n-    static int indexOf(CharSequence cs, CharSequence searchChar, int start) {\n+    static int indexOf(final CharSequence cs, final CharSequence searchChar, final int start) {\n         return cs.toString().indexOf(searchChar.toString(), start);\n //        if (cs instanceof String && searchChar instanceof String) {\n //            // TODO: Do we assume searchChar is usually relatively small;\n      * @param start  the start index, negative returns -1, beyond length starts at end\n      * @return the index where the search char was found, -1 if not found\n      */\n-    static int lastIndexOf(CharSequence cs, int searchChar, int start) {\n+    static int lastIndexOf(final CharSequence cs, final int searchChar, int start) {\n         if (cs instanceof String) {\n             return ((String) cs).lastIndexOf(searchChar, start);\n         } else {\n      * @param start the start index\n      * @return the index where the search sequence was found\n      */\n-    static int lastIndexOf(CharSequence cs, CharSequence searchChar, int start) {\n+    static int lastIndexOf(final CharSequence cs, final CharSequence searchChar, final int start) {\n         return cs.toString().lastIndexOf(searchChar.toString(), start);\n //        if (cs instanceof String && searchChar instanceof String) {\n //            // TODO: Do we assume searchChar is usually relatively small;\n      * @param cs the {@code CharSequence} to be processed\n      * @return the resulting char array\n      */\n-    static char[] toCharArray(CharSequence cs) {\n+    static char[] toCharArray(final CharSequence cs) {\n         if (cs instanceof String) {\n             return ((String) cs).toCharArray();\n         } else {\n      * @param length character length of the region\n      * @return whether the region matched\n      */\n-    static boolean regionMatches(CharSequence cs, boolean ignoreCase, int thisStart,\n-            CharSequence substring, int start, int length)    {\n+    static boolean regionMatches(final CharSequence cs, final boolean ignoreCase, final int thisStart,\n+            final CharSequence substring, final int start, final int length)    {\n         if (cs instanceof String && substring instanceof String) {\n             return ((String) cs).regionMatches(ignoreCase, thisStart, (String) substring, start, length);\n         } else {\n--- a/src/main/java/org/apache/commons/lang3/CharSet.java\n+++ b/src/main/java/org/apache/commons/lang3/CharSet.java\n      * @return a CharSet instance\n      * @since 2.4\n      */\n-    public static CharSet getInstance(String... setStrs) {\n+    public static CharSet getInstance(final String... setStrs) {\n         if (setStrs == null) {\n             return null;\n         }\n      * @param set  Strings to merge into the initial set\n      * @throws NullPointerException if set is {@code null}\n      */\n-    protected CharSet(String... set) {\n+    protected CharSet(final String... set) {\n         super();\n         int sz = set.length;\n         for (int i = 0; i < sz; i++) {\n      *\n      * @param str  set definition string\n      */\n-    protected void add(String str) {\n+    protected void add(final String str) {\n         if (str == null) {\n             return;\n         }\n      * @param ch  the character to check for\n      * @return {@code true} if the set contains the characters\n      */\n-    public boolean contains(char ch) {\n+    public boolean contains(final char ch) {\n         for (CharRange range : set) {\n             if (range.contains(ch)) {\n                 return true;\n      * @since 2.0\n      */\n     @Override\n-    public boolean equals(Object obj) {\n+    public boolean equals(final Object obj) {\n         if (obj == this) {\n             return true;\n         }\n--- a/src/main/java/org/apache/commons/lang3/CharSetUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/CharSetUtils.java\n      * @param set  the character set to use for manipulation, may be null\n      * @return the modified String, {@code null} if null string input\n      */\n-    public static String squeeze(String str, String... set) {\n+    public static String squeeze(final String str, final String... set) {\n         if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n             return str;\n         }\n      * @param set  String[] set of characters to count, may be null\n      * @return the character count, zero if null string input\n      */\n-    public static int count(String str, String... set) {\n+    public static int count(final String str, final String... set) {\n         if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n             return 0;\n         }\n      * @return the modified String, {@code null} if null string input\n      * @since 2.0\n      */\n-    public static String keep(String str, String... set) {\n+    public static String keep(final String str, final String... set) {\n         if (str == null) {\n             return null;\n         }\n      * @param set  String[] set of characters to delete, may be null\n      * @return the modified String, {@code null} if null string input\n      */\n-    public static String delete(String str, String... set) {\n+    public static String delete(final String str, final String... set) {\n         if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n             return str;\n         }\n      * @param expect whether to evaluate on match, or non-match\n      * @return the modified String, not null\n      */\n-    private static String modify(String str, String[] set, boolean expect) {\n+    private static String modify(final String str, final String[] set, final boolean expect) {\n         CharSet chars = CharSet.getInstance(set);\n         StringBuilder buffer = new StringBuilder(str.length());\n         char[] chrs = str.toCharArray();\n      * @param strings String[] whose elements are being checked for emptiness\n      * @return whether or not the String is empty\n      */\n-    private static boolean deepEmpty(String[] strings) {\n+    private static boolean deepEmpty(final String[] strings) {\n         if (strings != null) {\n             for (String s : strings) {\n                 if (StringUtils.isNotEmpty(s)) {\n--- a/src/main/java/org/apache/commons/lang3/CharUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/CharUtils.java\n      * @return a Character of the specified character\n      */\n     @Deprecated\n-    public static Character toCharacterObject(char ch) {\n+    public static Character toCharacterObject(final char ch) {\n         return Character.valueOf(ch);\n     }\n     \n      * @param str  the character to convert\n      * @return the Character value of the first letter of the String\n      */\n-    public static Character toCharacterObject(String str) {\n+    public static Character toCharacterObject(final String str) {\n         if (StringUtils.isEmpty(str)) {\n             return null;\n         }\n      * @return the char value of the Character\n      * @throws IllegalArgumentException if the Character is null\n      */\n-    public static char toChar(Character ch) {\n+    public static char toChar(final Character ch) {\n         if (ch == null) {\n             throw new IllegalArgumentException(\"The Character must not be null\");\n         }\n      * @param defaultValue  the value to use if the  Character is null\n      * @return the char value of the Character or the default if null\n      */\n-    public static char toChar(Character ch, char defaultValue) {\n+    public static char toChar(final Character ch, final char defaultValue) {\n         if (ch == null) {\n             return defaultValue;\n         }\n      * @return the char value of the first letter of the String\n      * @throws IllegalArgumentException if the String is empty\n      */\n-    public static char toChar(String str) {\n+    public static char toChar(final String str) {\n         if (StringUtils.isEmpty(str)) {\n             throw new IllegalArgumentException(\"The String must not be empty\");\n         }\n      * @param defaultValue  the value to use if the  Character is null\n      * @return the char value of the first letter of the String or the default if null\n      */\n-    public static char toChar(String str, char defaultValue) {\n+    public static char toChar(final String str, final char defaultValue) {\n         if (StringUtils.isEmpty(str)) {\n             return defaultValue;\n         }\n      * @return the int value of the character\n      * @throws IllegalArgumentException if the character is not ASCII numeric\n      */\n-    public static int toIntValue(char ch) {\n+    public static int toIntValue(final char ch) {\n         if (isAsciiNumeric(ch) == false) {\n             throw new IllegalArgumentException(\"The character \" + ch + \" is not in the range '0' - '9'\");\n         }\n      * @param defaultValue  the default value to use if the character is not numeric\n      * @return the int value of the character\n      */\n-    public static int toIntValue(char ch, int defaultValue) {\n+    public static int toIntValue(final char ch, final int defaultValue) {\n         if (isAsciiNumeric(ch) == false) {\n             return defaultValue;\n         }\n      * @return the int value of the character\n      * @throws IllegalArgumentException if the Character is not ASCII numeric or is null\n      */\n-    public static int toIntValue(Character ch) {\n+    public static int toIntValue(final Character ch) {\n         if (ch == null) {\n             throw new IllegalArgumentException(\"The character must not be null\");\n         }\n      * @param defaultValue  the default value to use if the character is not numeric\n      * @return the int value of the character\n      */\n-    public static int toIntValue(Character ch, int defaultValue) {\n+    public static int toIntValue(final Character ch, final int defaultValue) {\n         if (ch == null) {\n             return defaultValue;\n         }\n      * @param ch  the character to convert\n      * @return a String containing the one specified character\n      */\n-    public static String toString(char ch) {\n+    public static String toString(final char ch) {\n         if (ch < 128) {\n             return CHAR_STRING_ARRAY[ch];\n         }\n      * @param ch  the character to convert\n      * @return a String containing the one specified character\n      */\n-    public static String toString(Character ch) {\n+    public static String toString(final Character ch) {\n         if (ch == null) {\n             return null;\n         }\n      * @param ch  the character to convert\n      * @return the escaped Unicode string\n      */\n-    public static String unicodeEscaped(char ch) {\n+    public static String unicodeEscaped(final char ch) {\n         if (ch < 0x10) {\n             return \"\\\\u000\" + Integer.toHexString(ch);\n         } else if (ch < 0x100) {\n      * @param ch  the character to convert, may be null\n      * @return the escaped Unicode string, null if null input\n      */\n-    public static String unicodeEscaped(Character ch) {\n+    public static String unicodeEscaped(final Character ch) {\n         if (ch == null) {\n             return null;\n         }\n      * @param ch  the character to check\n      * @return true if less than 128\n      */\n-    public static boolean isAscii(char ch) {\n+    public static boolean isAscii(final char ch) {\n         return ch < 128;\n     }\n     \n      * @param ch  the character to check\n      * @return true if between 32 and 126 inclusive\n      */\n-    public static boolean isAsciiPrintable(char ch) {\n+    public static boolean isAsciiPrintable(final char ch) {\n         return ch >= 32 && ch < 127;\n     }\n     \n      * @param ch  the character to check\n      * @return true if less than 32 or equals 127\n      */\n-    public static boolean isAsciiControl(char ch) {\n+    public static boolean isAsciiControl(final char ch) {\n         return ch < 32 || ch == 127;\n     }\n     \n      * @param ch  the character to check\n      * @return true if between 65 and 90 or 97 and 122 inclusive\n      */\n-    public static boolean isAsciiAlpha(char ch) {\n+    public static boolean isAsciiAlpha(final char ch) {\n         return (ch >= 'A' && ch <= 'Z') || (ch >= 'a' && ch <= 'z');\n     }\n     \n      * @param ch  the character to check\n      * @return true if between 65 and 90 inclusive\n      */\n-    public static boolean isAsciiAlphaUpper(char ch) {\n+    public static boolean isAsciiAlphaUpper(final char ch) {\n         return ch >= 'A' && ch <= 'Z';\n     }\n     \n      * @param ch  the character to check\n      * @return true if between 97 and 122 inclusive\n      */\n-    public static boolean isAsciiAlphaLower(char ch) {\n+    public static boolean isAsciiAlphaLower(final char ch) {\n         return ch >= 'a' && ch <= 'z';\n     }\n     \n      * @param ch  the character to check\n      * @return true if between 48 and 57 inclusive\n      */\n-    public static boolean isAsciiNumeric(char ch) {\n+    public static boolean isAsciiNumeric(final char ch) {\n         return ch >= '0' && ch <= '9';\n     }\n     \n      * @param ch  the character to check\n      * @return true if between 48 and 57 or 65 and 90 or 97 and 122 inclusive\n      */\n-    public static boolean isAsciiAlphanumeric(char ch) {\n+    public static boolean isAsciiAlphanumeric(final char ch) {\n         return (ch >= 'A' && ch <= 'Z') || (ch >= 'a' && ch <= 'z') || (ch >= '0' && ch <= '9');\n     }\n     \n--- a/src/main/java/org/apache/commons/lang3/ClassUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/ClassUtils.java\n      * @param primitive Canonical name of primitive type\n      * @param abbreviation Corresponding abbreviation of primitive type\n      */\n-    private static void addAbbreviation(String primitive, String abbreviation) {\n+    private static void addAbbreviation(final String primitive, final String abbreviation) {\n         abbreviationMap.put(primitive, abbreviation);\n         reverseAbbreviationMap.put(abbreviation, primitive);\n     }\n      * @param valueIfNull  the value to return if null\n      * @return the class name of the object without the package name, or the null value\n      */\n-    public static String getShortClassName(Object object, String valueIfNull) {\n+    public static String getShortClassName(final Object object, final String valueIfNull) {\n         if (object == null) {\n             return valueIfNull;\n         }\n      * @param cls  the class to get the short name for.\n      * @return the class name without the package name or an empty string\n      */\n-    public static String getShortClassName(Class<?> cls) {\n+    public static String getShortClassName(final Class<?> cls) {\n         if (cls == null) {\n             return StringUtils.EMPTY;\n         }\n      * @since 3.0\n      * @see Class#getSimpleName()\n      */\n-    public static String getSimpleName(Class<?> cls) {\n+    public static String getSimpleName(final Class<?> cls) {\n         if (cls == null) {\n             return StringUtils.EMPTY;\n         }\n      * @since 3.0\n      * @see Class#getSimpleName()\n      */\n-    public static String getSimpleName(Object object, String valueIfNull) {\n+    public static String getSimpleName(final Object object, final String valueIfNull) {\n         if (object == null) {\n             return valueIfNull;\n         }\n      * @param valueIfNull  the value to return if null\n      * @return the package name of the object, or the null value\n      */\n-    public static String getPackageName(Object object, String valueIfNull) {\n+    public static String getPackageName(final Object object, final String valueIfNull) {\n         if (object == null) {\n             return valueIfNull;\n         }\n      * @param cls  the class to get the package name for, may be {@code null}.\n      * @return the package name or an empty string\n      */\n-    public static String getPackageName(Class<?> cls) {\n+    public static String getPackageName(final Class<?> cls) {\n         if (cls == null) {\n             return StringUtils.EMPTY;\n         }\n      * @return the {@code List} of superclasses in order going up from this one\n      *  {@code null} if null input\n      */\n-    public static List<Class<?>> getAllSuperclasses(Class<?> cls) {\n+    public static List<Class<?>> getAllSuperclasses(final Class<?> cls) {\n         if (cls == null) {\n             return null;\n         }\n      * @return the {@code List} of interfaces in order,\n      *  {@code null} if null input\n      */\n-    public static List<Class<?>> getAllInterfaces(Class<?> cls) {\n+    public static List<Class<?>> getAllInterfaces(final Class<?> cls) {\n         if (cls == null) {\n             return null;\n         }\n      * @param cls  the class to look up, may be {@code null}\n      * @param interfacesFound the {@code Set} of interfaces for the class\n      */\n-    private static void getAllInterfaces(Class<?> cls, HashSet<Class<?>> interfacesFound) {\n+    private static void getAllInterfaces(Class<?> cls, final HashSet<Class<?>> interfacesFound) {\n         while (cls != null) {\n             Class<?>[] interfaces = cls.getInterfaces();\n \n      *  {@code null} if null input\n      * @throws ClassCastException if classNames contains a non String entry\n      */\n-    public static List<Class<?>> convertClassNamesToClasses(List<String> classNames) {\n+    public static List<Class<?>> convertClassNamesToClasses(final List<String> classNames) {\n         if (classNames == null) {\n             return null;\n         }\n      *  {@code null} if null input\n      * @throws ClassCastException if {@code classes} contains a non-{@code Class} entry\n      */\n-    public static List<String> convertClassesToClassNames(List<Class<?>> classes) {\n+    public static List<String> convertClassesToClassNames(final List<Class<?>> classes) {\n         if (classes == null) {\n             return null;\n         }\n      * @param toClassArray  the array of Classes to try to assign into, may be {@code null}\n      * @return {@code true} if assignment possible\n      */\n-    public static boolean isAssignable(Class<?>[] classArray, Class<?>... toClassArray) {\n+    public static boolean isAssignable(final Class<?>[] classArray, final Class<?>... toClassArray) {\n         return isAssignable(classArray, toClassArray, SystemUtils.isJavaVersionAtLeast(JavaVersion.JAVA_1_5));\n     }\n \n      * @param autoboxing  whether to use implicit autoboxing/unboxing between primitives and wrappers\n      * @return {@code true} if assignment possible\n      */\n-    public static boolean isAssignable(Class<?>[] classArray, Class<?>[] toClassArray, boolean autoboxing) {\n+    public static boolean isAssignable(Class<?>[] classArray, Class<?>[] toClassArray, final boolean autoboxing) {\n         if (ArrayUtils.isSameLength(classArray, toClassArray) == false) {\n             return false;\n         }\n      *         {@link Short}, {@link Integer}, {@link Long}, {@link Double}, {@link Float}).\n      * @since 3.1\n      */\n-    public static boolean isPrimitiveOrWrapper(Class<?> type) {\n+    public static boolean isPrimitiveOrWrapper(final Class<?> type) {\n         if (type == null) {\n             return false;\n         }\n      *         {@link Integer}, {@link Long}, {@link Double}, {@link Float}).\n      * @since 3.1\n      */\n-    public static boolean isPrimitiveWrapper(Class<?> type) {\n+    public static boolean isPrimitiveWrapper(final Class<?> type) {\n         return wrapperPrimitiveMap.containsKey(type);\n     }\n \n      * @param toClass  the Class to try to assign into, returns false if null\n      * @return {@code true} if assignment possible\n      */\n-    public static boolean isAssignable(Class<?> cls, Class<?> toClass) {\n+    public static boolean isAssignable(final Class<?> cls, final Class<?> toClass) {\n         return isAssignable(cls, toClass, SystemUtils.isJavaVersionAtLeast(JavaVersion.JAVA_1_5));\n     }\n \n      * @param autoboxing  whether to use implicit autoboxing/unboxing between primitives and wrappers\n      * @return {@code true} if assignment possible\n      */\n-    public static boolean isAssignable(Class<?> cls, Class<?> toClass, boolean autoboxing) {\n+    public static boolean isAssignable(Class<?> cls, final Class<?> toClass, final boolean autoboxing) {\n         if (toClass == null) {\n             return false;\n         }\n      * {@code cls} is not a primitive. {@code null} if null input.\n      * @since 2.1\n      */\n-    public static Class<?> primitiveToWrapper(Class<?> cls) {\n+    public static Class<?> primitiveToWrapper(final Class<?> cls) {\n         Class<?> convertedClass = cls;\n         if (cls != null && cls.isPrimitive()) {\n             convertedClass = primitiveWrapperMap.get(cls);\n      * Empty array if an empty array passed in.\n      * @since 2.1\n      */\n-    public static Class<?>[] primitivesToWrappers(Class<?>... classes) {\n+    public static Class<?>[] primitivesToWrappers(final Class<?>... classes) {\n         if (classes == null) {\n             return null;\n         }\n      * @see #primitiveToWrapper(Class)\n      * @since 2.4\n      */\n-    public static Class<?> wrapperToPrimitive(Class<?> cls) {\n+    public static Class<?> wrapperToPrimitive(final Class<?> cls) {\n         return wrapperPrimitiveMap.get(cls);\n     }\n \n      * @see #wrapperToPrimitive(Class)\n      * @since 2.4\n      */\n-    public static Class<?>[] wrappersToPrimitives(Class<?>... classes) {\n+    public static Class<?>[] wrappersToPrimitives(final Class<?>... classes) {\n         if (classes == null) {\n             return null;\n         }\n      * @return {@code true} if the class is an inner or static nested class,\n      *  false if not or {@code null}\n      */\n-    public static boolean isInnerClass(Class<?> cls) {\n+    public static boolean isInnerClass(final Class<?> cls) {\n         return cls != null && cls.getEnclosingClass() != null;\n     }\n \n      * @throws ClassNotFoundException if the class is not found\n      */\n     public static Class<?> getClass(\n-            ClassLoader classLoader, String className, boolean initialize) throws ClassNotFoundException {\n+            final ClassLoader classLoader, final String className, final boolean initialize) throws ClassNotFoundException {\n         try {\n             Class<?> clazz;\n             if (abbreviationMap.containsKey(className)) {\n      * @return the class represented by {@code className} using the {@code classLoader}\n      * @throws ClassNotFoundException if the class is not found\n      */\n-    public static Class<?> getClass(ClassLoader classLoader, String className) throws ClassNotFoundException {\n+    public static Class<?> getClass(final ClassLoader classLoader, final String className) throws ClassNotFoundException {\n         return getClass(classLoader, className, true);\n     }\n \n      * @return the class represented by {@code className} using the current thread's context class loader\n      * @throws ClassNotFoundException if the class is not found\n      */\n-    public static Class<?> getClass(String className) throws ClassNotFoundException {\n+    public static Class<?> getClass(final String className) throws ClassNotFoundException {\n         return getClass(className, true);\n     }\n \n      * @return the class represented by {@code className} using the current thread's context class loader\n      * @throws ClassNotFoundException if the class is not found\n      */\n-    public static Class<?> getClass(String className, boolean initialize) throws ClassNotFoundException {\n+    public static Class<?> getClass(final String className, final boolean initialize) throws ClassNotFoundException {\n         ClassLoader contextCL = Thread.currentThread().getContextClassLoader();\n         ClassLoader loader = contextCL == null ? ClassUtils.class.getClassLoader() : contextCL;\n         return getClass(loader, className, initialize);\n      * @throws NoSuchMethodException if the method is not found in the given class\n      *  or if the metothod doen't conform with the requirements\n      */\n-    public static Method getPublicMethod(Class<?> cls, String methodName, Class<?>... parameterTypes)\n+    public static Method getPublicMethod(final Class<?> cls, final String methodName, final Class<?>... parameterTypes)\n             throws SecurityException, NoSuchMethodException {\n \n         Method declaredMethod = cls.getMethod(methodName, parameterTypes);\n      * @return a {@code Class} array, {@code null} if null array input\n      * @since 2.4\n      */\n-    public static Class<?>[] toClass(Object... array) {\n+    public static Class<?>[] toClass(final Object... array) {\n         if (array == null) {\n             return null;\n         } else if (array.length == 0) {\n      * @return the canonical name of the object without the package name, or the null value\n      * @since 2.4\n      */\n-    public static String getShortCanonicalName(Object object, String valueIfNull) {\n+    public static String getShortCanonicalName(final Object object, final String valueIfNull) {\n         if (object == null) {\n             return valueIfNull;\n         }\n      * @return the canonical name without the package name or an empty string\n      * @since 2.4\n      */\n-    public static String getShortCanonicalName(Class<?> cls) {\n+    public static String getShortCanonicalName(final Class<?> cls) {\n         if (cls == null) {\n             return StringUtils.EMPTY;\n         }\n      * @return the canonical name of the class without the package name or an empty string\n      * @since 2.4\n      */\n-    public static String getShortCanonicalName(String canonicalName) {\n+    public static String getShortCanonicalName(final String canonicalName) {\n         return ClassUtils.getShortClassName(getCanonicalName(canonicalName));\n     }\n \n      * @return the package name of the object, or the null value\n      * @since 2.4\n      */\n-    public static String getPackageCanonicalName(Object object, String valueIfNull) {\n+    public static String getPackageCanonicalName(final Object object, final String valueIfNull) {\n         if (object == null) {\n             return valueIfNull;\n         }\n      * @return the package name or an empty string\n      * @since 2.4\n      */\n-    public static String getPackageCanonicalName(Class<?> cls) {\n+    public static String getPackageCanonicalName(final Class<?> cls) {\n         if (cls == null) {\n             return StringUtils.EMPTY;\n         }\n      * @return the package name or an empty string\n      * @since 2.4\n      */\n-    public static String getPackageCanonicalName(String canonicalName) {\n+    public static String getPackageCanonicalName(final String canonicalName) {\n         return ClassUtils.getPackageName(getCanonicalName(canonicalName));\n     }\n \n--- a/src/main/java/org/apache/commons/lang3/Conversion.java\n+++ b/src/main/java/org/apache/commons/lang3/Conversion.java\n      * @return an int equals to {@code hexDigit}\n      * @throws IllegalArgumentException if {@code hexDigit} is not a hexadecimal digit\n      */\n-    public static int hexDigitToInt(char hexDigit) {\n+    public static int hexDigitToInt(final char hexDigit) {\n         final int digit = Character.digit(hexDigit, 16);\n         if (digit < 0) {\n             throw new IllegalArgumentException(\"Cannot interpret '\"\n      * @return an int equals to {@code hexDigit}\n      * @throws IllegalArgumentException if {@code hexDigit} is not a hexadecimal digit\n      */\n-    public static int hexDigitMsb0ToInt(char hexDigit) {\n+    public static int hexDigitMsb0ToInt(final char hexDigit) {\n         switch (hexDigit) {\n         case '0':\n             return 0x0;\n      * @return a boolean array with the binary representation of {@code hexDigit}\n      * @throws IllegalArgumentException if {@code hexDigit} is not a hexadecimal digit\n      */\n-    public static boolean[] hexDigitToBinary(char hexDigit) {\n+    public static boolean[] hexDigitToBinary(final char hexDigit) {\n         switch (hexDigit) {\n         case '0':\n             return new boolean[]{false, false, false, false};\n      * @return a boolean array with the binary representation of {@code hexDigit}\n      * @throws IllegalArgumentException if {@code hexDigit} is not a hexadecimal digit\n      */\n-    public static boolean[] hexDigitMsb0ToBinary(char hexDigit) {\n+    public static boolean[] hexDigitMsb0ToBinary(final char hexDigit) {\n         switch (hexDigit) {\n         case '0':\n             return new boolean[]{false, false, false, false};\n      * @throws IllegalArgumentException if {@code src} is empty\n      * @throws NullPointerException if {@code src} is {@code null}\n      */\n-    public static char binaryToHexDigit(boolean[] src) {\n+    public static char binaryToHexDigit(final boolean[] src) {\n         return binaryToHexDigit(src, 0);\n     }\n \n      * @throws IllegalArgumentException if {@code src} is empty\n      * @throws NullPointerException if {@code src} is {@code null}\n      */\n-    public static char binaryToHexDigit(boolean[] src, int srcPos) {\n+    public static char binaryToHexDigit(final boolean[] src, final int srcPos) {\n         if (src.length == 0) {\n             throw new IllegalArgumentException(\"Cannot convert an empty array.\");\n         }\n      *             {@code src.length > 8}\n      * @throws NullPointerException if {@code src} is {@code null}\n      */\n-    public static char binaryToHexDigitMsb0_4bits(boolean[] src) {\n+    public static char binaryToHexDigitMsb0_4bits(final boolean[] src) {\n         return binaryToHexDigitMsb0_4bits(src, 0);\n     }\n \n      *             {@code src.length - srcPos < 4}\n      * @throws NullPointerException if {@code src} is {@code null}\n      */\n-    public static char binaryToHexDigitMsb0_4bits(boolean[] src, int srcPos) {\n+    public static char binaryToHexDigitMsb0_4bits(final boolean[] src, final int srcPos) {\n         if (src.length > 8) {\n             throw new IllegalArgumentException(\"src.length>8: src.length=\" + src.length);\n         }\n      * @throws IllegalArgumentException if {@code src} is empty\n      * @throws NullPointerException if {@code src} is {@code null}\n      */\n-    public static char binaryBeMsb0ToHexDigit(boolean[] src) {\n+    public static char binaryBeMsb0ToHexDigit(final boolean[] src) {\n         return binaryBeMsb0ToHexDigit(src, 0);\n     }\n \n      * @return a hexadecimal digit representing the 4 lsb of {@code nibble}\n      * @throws IllegalArgumentException if {@code nibble < 0} or {@code nibble > 15}\n      */\n-    public static char intToHexDigit(int nibble) {\n+    public static char intToHexDigit(final int nibble) {\n         char c = Character.forDigit(nibble, 16);\n         if (c == Character.MIN_VALUE) {\n             throw new IllegalArgumentException(\"nibble value not between 0 and 15: \" + nibble);\n      * @return a hexadecimal digit representing the 4 lsb of {@code nibble}\n      * @throws IllegalArgumentException if {@code nibble < 0} or {@code nibble > 15}\n      */\n-    public static char intToHexDigitMsb0(int nibble) {\n+    public static char intToHexDigitMsb0(final int nibble) {\n         switch (nibble) {\n         case 0x0:\n             return '0';\n      * @throws NullPointerException if {@code src} is {@code null}\n      * @throws ArrayIndexOutOfBoundsException if {@code srcPos + nInts > src.length}\n      */\n-    public static long intArrayToLong(int[] src, int srcPos, long dstInit, int dstPos, int nInts) {\n+    public static long intArrayToLong(final int[] src, final int srcPos, final long dstInit, final int dstPos, final int nInts) {\n         if ((src.length == 0 && srcPos == 0) || 0 == nInts) {\n             return dstInit;\n         }\n      * @throws IllegalArgumentException if {@code (nShorts-1)*16+dstPos >= 64}\n      * @throws ArrayIndexOutOfBoundsException if {@code srcPos + nShorts > src.length}\n      */\n-    public static long shortArrayToLong(short[] src, int srcPos, long dstInit, int dstPos,\n-        int nShorts) {\n+    public static long shortArrayToLong(final short[] src, final int srcPos, final long dstInit, final int dstPos,\n+        final int nShorts) {\n         if ((src.length == 0 && srcPos == 0) || 0 == nShorts) {\n             return dstInit;\n         }\n      * @throws IllegalArgumentException if {@code (nShorts-1)*16+dstPos >= 32}\n      * @throws ArrayIndexOutOfBoundsException if {@code srcPos + nShorts > src.length}\n      */\n-    public static int shortArrayToInt(short[] src, int srcPos, int dstInit, int dstPos,\n-        int nShorts) {\n+    public static int shortArrayToInt(final short[] src, final int srcPos, final int dstInit, final int dstPos,\n+        final int nShorts) {\n         if ((src.length == 0 && srcPos == 0) || 0 == nShorts) {\n             return dstInit;\n         }\n      * @throws IllegalArgumentException if {@code (nBytes-1)*8+dstPos >= 64}\n      * @throws ArrayIndexOutOfBoundsException if {@code srcPos + nBytes > src.length}\n      */\n-    public static long byteArrayToLong(byte[] src, int srcPos, long dstInit, int dstPos,\n-        int nBytes) {\n+    public static long byteArrayToLong(final byte[] src, final int srcPos, final long dstInit, final int dstPos,\n+        final int nBytes) {\n         if ((src.length == 0 && srcPos == 0) || 0 == nBytes) {\n             return dstInit;\n         }\n      * @throws IllegalArgumentException if {@code (nBytes-1)*8+dstPos >= 32}\n      * @throws ArrayIndexOutOfBoundsException if {@code srcPos + nBytes > src.length}\n      */\n-    public static int byteArrayToInt(byte[] src, int srcPos, int dstInit, int dstPos, int nBytes) {\n+    public static int byteArrayToInt(final byte[] src, final int srcPos, final int dstInit, final int dstPos, final int nBytes) {\n         if ((src.length == 0 && srcPos == 0) || 0 == nBytes) {\n             return dstInit;\n         }\n      * @throws IllegalArgumentException if {@code (nBytes-1)*8+dstPos >= 16}\n      * @throws ArrayIndexOutOfBoundsException if {@code srcPos + nBytes > src.length}\n      */\n-    public static short byteArrayToShort(byte[] src, int srcPos, short dstInit, int dstPos,\n-        int nBytes) {\n+    public static short byteArrayToShort(final byte[] src, final int srcPos, final short dstInit, final int dstPos,\n+        final int nBytes) {\n         if ((src.length == 0 && srcPos == 0) || 0 == nBytes) {\n             return dstInit;\n         }\n      * @return a long containing the selected bits\n      * @throws IllegalArgumentException if {@code (nHexs-1)*4+dstPos >= 64}\n      */\n-    public static long hexToLong(String src, int srcPos, long dstInit, int dstPos, int nHex) {\n+    public static long hexToLong(final String src, final int srcPos, final long dstInit, final int dstPos, final int nHex) {\n         if (0 == nHex) {\n             return dstInit;\n         }\n      * @return a int containing the selected bits\n      * @throws IllegalArgumentException if {@code (nHexs-1)*4+dstPos >= 32}\n      */\n-    public static int hexToInt(String src, int srcPos, int dstInit, int dstPos, int nHex) {\n+    public static int hexToInt(final String src, final int srcPos, final int dstInit, final int dstPos, final int nHex) {\n         if (0 == nHex) {\n             return dstInit;\n         }\n      * @return a short containing the selected bits\n      * @throws IllegalArgumentException if {@code (nHexs-1)*4+dstPos >= 16}\n      */\n-    public static short hexToShort(String src, int srcPos, short dstInit, int dstPos, int nHex) {\n+    public static short hexToShort(final String src, final int srcPos, final short dstInit, final int dstPos, final int nHex) {\n         if (0 == nHex) {\n             return dstInit;\n         }\n      * @return a byte containing the selected bits\n      * @throws IllegalArgumentException if {@code (nHexs-1)*4+dstPos >= 8}\n      */\n-    public static byte hexToByte(String src, int srcPos, byte dstInit, int dstPos, int nHex) {\n+    public static byte hexToByte(final String src, final int srcPos, final byte dstInit, final int dstPos, final int nHex) {\n         if (0 == nHex) {\n             return dstInit;\n         }\n      * @throws IllegalArgumentException if {@code nBools-1+dstPos >= 64}\n      * @throws ArrayIndexOutOfBoundsException if {@code srcPos + nBools > src.length}\n      */\n-    public static long binaryToLong(boolean[] src, int srcPos, long dstInit, int dstPos,\n-        int nBools) {\n+    public static long binaryToLong(final boolean[] src, final int srcPos, final long dstInit, final int dstPos,\n+        final int nBools) {\n         if ((src.length == 0 && srcPos == 0) || 0 == nBools) {\n             return dstInit;\n         }\n      * @throws IllegalArgumentException if {@code nBools-1+dstPos >= 32}\n      * @throws ArrayIndexOutOfBoundsException if {@code srcPos + nBools > src.length}\n      */\n-    public static int binaryToInt(boolean[] src, int srcPos, int dstInit, int dstPos, int nBools) {\n+    public static int binaryToInt(final boolean[] src, final int srcPos, final int dstInit, final int dstPos, final int nBools) {\n         if ((src.length == 0 && srcPos == 0) || 0 == nBools) {\n             return dstInit;\n         }\n      * @throws IllegalArgumentException if {@code nBools-1+dstPos >= 16}\n      * @throws ArrayIndexOutOfBoundsException if {@code srcPos + nBools > src.length}\n      */\n-    public static short binaryToShort(boolean[] src, int srcPos, short dstInit, int dstPos,\n-        int nBools) {\n+    public static short binaryToShort(final boolean[] src, final int srcPos, final short dstInit, final int dstPos,\n+        final int nBools) {\n         if ((src.length == 0 && srcPos == 0) || 0 == nBools) {\n             return dstInit;\n         }\n      * @throws IllegalArgumentException if {@code nBools-1+dstPos >= 8}\n      * @throws ArrayIndexOutOfBoundsException if {@code srcPos + nBools > src.length}\n      */\n-    public static byte binaryToByte(boolean[] src, int srcPos, byte dstInit, int dstPos,\n-        int nBools) {\n+    public static byte binaryToByte(final boolean[] src, final int srcPos, final byte dstInit, final int dstPos,\n+        final int nBools) {\n         if ((src.length == 0 && srcPos == 0) || 0 == nBools) {\n             return dstInit;\n         }\n      * @throws IllegalArgumentException if {@code (nInts-1)*32+srcPos >= 64}\n      * @throws ArrayIndexOutOfBoundsException if {@code dstPos + nInts > dst.length}\n      */\n-    public static int[] longToIntArray(long src, int srcPos, int[] dst, int dstPos, int nInts) {\n+    public static int[] longToIntArray(final long src, final int srcPos, final int[] dst, final int dstPos, final int nInts) {\n         if (0 == nInts) {\n             return dst;\n         }\n      * @throws IllegalArgumentException if {@code (nShorts-1)*16+srcPos >= 64}\n      * @throws ArrayIndexOutOfBoundsException if {@code dstPos + nShorts > dst.length}\n      */\n-    public static short[] longToShortArray(long src, int srcPos, short[] dst, int dstPos,\n-        int nShorts) {\n+    public static short[] longToShortArray(final long src, final int srcPos, final short[] dst, final int dstPos,\n+        final int nShorts) {\n         if (0 == nShorts) {\n             return dst;\n         }\n      * @throws IllegalArgumentException if {@code (nShorts-1)*16+srcPos >= 32}\n      * @throws ArrayIndexOutOfBoundsException if {@code dstPos + nShorts > dst.length}\n      */\n-    public static short[] intToShortArray(int src, int srcPos, short[] dst, int dstPos,\n-        int nShorts) {\n+    public static short[] intToShortArray(final int src, final int srcPos, final short[] dst, final int dstPos,\n+        final int nShorts) {\n         if (0 == nShorts) {\n             return dst;\n         }\n      * @throws IllegalArgumentException if {@code (nBytes-1)*8+srcPos >= 64}\n      * @throws ArrayIndexOutOfBoundsException if {@code dstPos + nBytes > dst.length}\n      */\n-    public static byte[] longToByteArray(long src, int srcPos, byte[] dst, int dstPos,\n-        int nBytes) {\n+    public static byte[] longToByteArray(final long src, final int srcPos, final byte[] dst, final int dstPos,\n+        final int nBytes) {\n         if (0 == nBytes) {\n             return dst;\n         }\n      * @throws IllegalArgumentException if {@code (nBytes-1)*8+srcPos >= 32}\n      * @throws ArrayIndexOutOfBoundsException if {@code dstPos + nBytes > dst.length}\n      */\n-    public static byte[] intToByteArray(int src, int srcPos, byte[] dst, int dstPos, int nBytes) {\n+    public static byte[] intToByteArray(final int src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes) {\n         if (0 == nBytes) {\n             return dst;\n         }\n      * @throws IllegalArgumentException if {@code (nBytes-1)*8+srcPos >= 16}\n      * @throws ArrayIndexOutOfBoundsException if {@code dstPos + nBytes > dst.length}\n      */\n-    public static byte[] shortToByteArray(short src, int srcPos, byte[] dst, int dstPos,\n-        int nBytes) {\n+    public static byte[] shortToByteArray(final short src, final int srcPos, final byte[] dst, final int dstPos,\n+        final int nBytes) {\n         if (0 == nBytes) {\n             return dst;\n         }\n      * @throws IllegalArgumentException if {@code (nHexs-1)*4+srcPos >= 64}\n      * @throws StringIndexOutOfBoundsException if {@code dst.init.length() < dstPos}\n      */\n-    public static String longToHex(long src, int srcPos, String dstInit, int dstPos, int nHexs) {\n+    public static String longToHex(final long src, final int srcPos, final String dstInit, final int dstPos, final int nHexs) {\n         if (0 == nHexs) {\n             return dstInit;\n         }\n      * @throws IllegalArgumentException if {@code (nHexs-1)*4+srcPos >= 32}\n      * @throws StringIndexOutOfBoundsException if {@code dst.init.length() < dstPos}\n      */\n-    public static String intToHex(int src, int srcPos, String dstInit, int dstPos, int nHexs) {\n+    public static String intToHex(final int src, final int srcPos, final String dstInit, final int dstPos, final int nHexs) {\n         if (0 == nHexs) {\n             return dstInit;\n         }\n      * @throws IllegalArgumentException if {@code (nHexs-1)*4+srcPos >= 16}\n      * @throws StringIndexOutOfBoundsException if {@code dst.init.length() < dstPos}\n      */\n-    public static String shortToHex(short src, int srcPos, String dstInit, int dstPos, int nHexs) {\n+    public static String shortToHex(final short src, final int srcPos, final String dstInit, final int dstPos, final int nHexs) {\n         if (0 == nHexs) {\n             return dstInit;\n         }\n      * @throws IllegalArgumentException if {@code (nHexs-1)*4+srcPos >= 8}\n      * @throws StringIndexOutOfBoundsException if {@code dst.init.length() < dstPos}\n      */\n-    public static String byteToHex(byte src, int srcPos, String dstInit, int dstPos, int nHexs) {\n+    public static String byteToHex(final byte src, final int srcPos, final String dstInit, final int dstPos, final int nHexs) {\n         if (0 == nHexs) {\n             return dstInit;\n         }\n      * @throws IllegalArgumentException if {@code nBools-1+srcPos >= 64}\n      * @throws ArrayIndexOutOfBoundsException if {@code dstPos + nBools > dst.length}\n      */\n-    public static boolean[] longToBinary(long src, int srcPos, boolean[] dst, int dstPos,\n-        int nBools) {\n+    public static boolean[] longToBinary(final long src, final int srcPos, final boolean[] dst, final int dstPos,\n+        final int nBools) {\n         if (0 == nBools) {\n             return dst;\n         }\n      * @throws IllegalArgumentException if {@code nBools-1+srcPos >= 32}\n      * @throws ArrayIndexOutOfBoundsException if {@code dstPos + nBools > dst.length}\n      */\n-    public static boolean[] intToBinary(int src, int srcPos, boolean[] dst, int dstPos,\n-        int nBools) {\n+    public static boolean[] intToBinary(final int src, final int srcPos, final boolean[] dst, final int dstPos,\n+        final int nBools) {\n         if (0 == nBools) {\n             return dst;\n         }\n      * @throws IllegalArgumentException if {@code nBools-1+srcPos >= 16}\n      * @throws ArrayIndexOutOfBoundsException if {@code dstPos + nBools > dst.length}\n      */\n-    public static boolean[] shortToBinary(short src, int srcPos, boolean[] dst, int dstPos,\n-        int nBools) {\n+    public static boolean[] shortToBinary(final short src, final int srcPos, final boolean[] dst, final int dstPos,\n+        final int nBools) {\n         if (0 == nBools) {\n             return dst;\n         }\n      * @throws IllegalArgumentException if {@code nBools-1+srcPos >= 8}\n      * @throws ArrayIndexOutOfBoundsException if {@code dstPos + nBools > dst.length}\n      */\n-    public static boolean[] byteToBinary(byte src, int srcPos, boolean[] dst, int dstPos,\n-        int nBools) {\n+    public static boolean[] byteToBinary(final byte src, final int srcPos, final boolean[] dst, final int dstPos,\n+        final int nBools) {\n         if (0 == nBools) {\n             return dst;\n         }\n      * @throws IllegalArgumentException if {@code nBytes > 16}\n      * @throws ArrayIndexOutOfBoundsException if {@code dstPos + nBytes > dst.length}\n      */\n-    public static byte[] uuidToByteArray(UUID src, byte[] dst, int dstPos, int nBytes) {\n+    public static byte[] uuidToByteArray(final UUID src, final byte[] dst, final int dstPos, final int nBytes) {\n         if (0 == nBytes) {\n             return dst;\n         }\n      * @throws IllegalArgumentException if array does not contain at least 16 bytes beginning\n      *             with {@code srcPos}\n      */\n-    public static UUID byteArrayToUuid(byte[] src, int srcPos) {\n+    public static UUID byteArrayToUuid(final byte[] src, final int srcPos) {\n         if (src.length - srcPos < 16) {\n             throw new IllegalArgumentException(\"Need at least 16 bytes for UUID\");\n         }\n--- a/src/main/java/org/apache/commons/lang3/EnumUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/EnumUtils.java\n      * @param enumClass  the class of the enum to query, not null\n      * @return the modifiable map of enum names to enums, never null\n      */\n-    public static <E extends Enum<E>> Map<String, E> getEnumMap(Class<E> enumClass) {\n+    public static <E extends Enum<E>> Map<String, E> getEnumMap(final Class<E> enumClass) {\n         Map<String, E> map = new LinkedHashMap<String, E>();\n         for (E e: enumClass.getEnumConstants()) {\n             map.put(e.name(), e);\n      * @param enumClass  the class of the enum to query, not null\n      * @return the modifiable list of enums, never null\n      */\n-    public static <E extends Enum<E>> List<E> getEnumList(Class<E> enumClass) {\n+    public static <E extends Enum<E>> List<E> getEnumList(final Class<E> enumClass) {\n         return new ArrayList<E>(Arrays.asList(enumClass.getEnumConstants()));\n     }\n \n      * @param enumName   the enum name, null returns false\n      * @return true if the enum name is valid, otherwise false\n      */\n-    public static <E extends Enum<E>> boolean isValidEnum(Class<E> enumClass, String enumName) {\n+    public static <E extends Enum<E>> boolean isValidEnum(final Class<E> enumClass, final String enumName) {\n         if (enumName == null) {\n             return false;\n         }\n      * @param enumName   the enum name, null returns null\n      * @return the enum, null if not found\n      */\n-    public static <E extends Enum<E>> E getEnum(Class<E> enumClass, String enumName) {\n+    public static <E extends Enum<E>> E getEnum(final Class<E> enumClass, final String enumName) {\n         if (enumName == null) {\n             return null;\n         }\n      * @since 3.0.1\n      * @see #generateBitVectors(Class, Iterable)\n      */\n-    public static <E extends Enum<E>> long generateBitVector(Class<E> enumClass, Iterable<E> values) {\n+    public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values) {\n         checkBitVectorable(enumClass);\n         Validate.notNull(values);\n         long total = 0;\n      * @throws IllegalArgumentException if {@code enumClass} is not an enum class, or if any {@code values} {@code null}\n      * @since 3.2\n      */\n-    public static <E extends Enum<E>> long[] generateBitVectors(Class<E> enumClass, Iterable<E> values) {\n+    public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values) {\n         asEnum(enumClass);\n         Validate.notNull(values);\n         final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n      * @since 3.0.1\n      * @see #generateBitVectors(Class, Iterable)\n      */\n-    public static <E extends Enum<E>> long generateBitVector(Class<E> enumClass, E... values) {\n+    public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final E... values) {\n         Validate.noNullElements(values);\n         return generateBitVector(enumClass, Arrays.<E> asList(values));\n     }\n      * @throws IllegalArgumentException if {@code enumClass} is not an enum class, or if any {@code values} {@code null}\n      * @since 3.2\n      */\n-    public static <E extends Enum<E>> long[] generateBitVectors(Class<E> enumClass, E... values) {\n+    public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final E... values) {\n         asEnum(enumClass);\n         Validate.noNullElements(values);\n         final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n      * @throws IllegalArgumentException if {@code enumClass} is not an enum class or has more than 64 values\n      * @since 3.0.1\n      */\n-    public static <E extends Enum<E>> EnumSet<E> processBitVector(Class<E> enumClass, long value) {\n+    public static <E extends Enum<E>> EnumSet<E> processBitVector(final Class<E> enumClass, final long value) {\n         checkBitVectorable(enumClass).getEnumConstants();\n         return processBitVectors(enumClass, value);\n     }\n      * @throws IllegalArgumentException if {@code enumClass} is not an enum class\n      * @since 3.2\n      */\n-    public static <E extends Enum<E>> EnumSet<E> processBitVectors(Class<E> enumClass, long... values) {\n+    public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values) {\n         final EnumSet<E> results = EnumSet.noneOf(asEnum(enumClass));\n         values = ArrayUtils.clone(Validate.notNull(values));\n         ArrayUtils.reverse(values);\n      * @throws IllegalArgumentException if {@code enumClass} is not an enum class or has more than 64 values\n      * @since 3.0.1\n      */\n-    private static <E extends Enum<E>> Class<E> checkBitVectorable(Class<E> enumClass) {\n+    private static <E extends Enum<E>> Class<E> checkBitVectorable(final Class<E> enumClass) {\n         final E[] constants = asEnum(enumClass).getEnumConstants();\n         Validate.isTrue(constants.length <= Long.SIZE, CANNOT_STORE_S_S_VALUES_IN_S_BITS, constants.length,\n             enumClass.getSimpleName(), Long.SIZE);\n      * @throws IllegalArgumentException if {@code enumClass} is not an enum class\n      * @since 3.2\n      */\n-    private static <E extends Enum<E>> Class<E> asEnum(Class<E> enumClass) {\n+    private static <E extends Enum<E>> Class<E> asEnum(final Class<E> enumClass) {\n         Validate.notNull(enumClass, ENUM_CLASS_MUST_BE_DEFINED);\n         Validate.isTrue(enumClass.isEnum(), S_DOES_NOT_SEEM_TO_BE_AN_ENUM_TYPE, enumClass);\n         return enumClass;\n--- a/src/main/java/org/apache/commons/lang3/JavaVersion.java\n+++ b/src/main/java/org/apache/commons/lang3/JavaVersion.java\n      * @param requiredVersion  the version to check against, not null\n      * @return true if this version is equal to or greater than the specified version\n      */\n-    public boolean atLeast(JavaVersion requiredVersion) {\n+    public boolean atLeast(final JavaVersion requiredVersion) {\n         return this.value >= requiredVersion.value;\n     }\n \n--- a/src/main/java/org/apache/commons/lang3/LocaleUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/LocaleUtils.java\n      * @param locale  the locale to start from\n      * @return the unmodifiable list of Locale objects, 0 being locale, not null\n      */\n-    public static List<Locale> localeLookupList(Locale locale) {\n+    public static List<Locale> localeLookupList(final Locale locale) {\n         return localeLookupList(locale, locale);\n     }\n \n      * @param defaultLocale  the default locale to use if no other is found\n      * @return the unmodifiable list of Locale objects, 0 being locale, not null\n      */\n-    public static List<Locale> localeLookupList(Locale locale, Locale defaultLocale) {\n+    public static List<Locale> localeLookupList(final Locale locale, final Locale defaultLocale) {\n         List<Locale> list = new ArrayList<Locale>(4);\n         if (locale != null) {\n             list.add(locale);\n      * @param locale the Locale object to check if it is available\n      * @return true if the locale is a known locale\n      */\n-    public static boolean isAvailableLocale(Locale locale) {\n+    public static boolean isAvailableLocale(final Locale locale) {\n         return availableLocaleList().contains(locale);\n     }\n \n      * @param countryCode  the 2 letter country code, null returns empty\n      * @return an unmodifiable List of Locale objects, not null\n      */\n-    public static List<Locale> languagesByCountry(String countryCode) {\n+    public static List<Locale> languagesByCountry(final String countryCode) {\n         if (countryCode == null) {\n             return Collections.emptyList();\n         }\n      * @param languageCode  the 2 letter language code, null returns empty\n      * @return an unmodifiable List of Locale objects, not null\n      */\n-    public static List<Locale> countriesByLanguage(String languageCode) {\n+    public static List<Locale> countriesByLanguage(final String languageCode) {\n         if (languageCode == null) {\n             return Collections.emptyList();\n         }\n--- a/src/main/java/org/apache/commons/lang3/ObjectUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/ObjectUtils.java\n      * @param defaultValue  the default value to return, may be {@code null}\n      * @return {@code object} if it is not {@code null}, defaultValue otherwise\n      */\n-    public static <T> T defaultIfNull(T object, T defaultValue) {\n+    public static <T> T defaultIfNull(final T object, final T defaultValue) {\n         return object != null ? object : defaultValue;\n     }\n \n      *  or {@code null} if there are no non-null values\n      * @since 3.0\n      */\n-    public static <T> T firstNonNull(T... values) {\n+    public static <T> T firstNonNull(final T... values) {\n         if (values != null) {\n             for (T val : values) {\n                 if (val != null) {\n      * @param object2  the second object, may be {@code null}\n      * @return {@code true} if the values of both objects are the same\n      */\n-    public static boolean equals(Object object1, Object object2) {\n+    public static boolean equals(final Object object1, final Object object2) {\n         if (object1 == object2) {\n             return true;\n         }\n      * @param object2  the second object, may be {@code null}\n      * @return {@code false} if the values of both objects are the same\n      */\n-    public static boolean notEqual(Object object1, Object object2) {\n+    public static boolean notEqual(final Object object1, final Object object2) {\n         return ObjectUtils.equals(object1, object2) == false;\n     }\n \n      * @return the hash code of the object, or zero if null\n      * @since 2.1\n      */\n-    public static int hashCode(Object obj) {\n+    public static int hashCode(final Object obj) {\n         // hashCode(Object) retained for performance, as hash code is often critical\n         return obj == null ? 0 : obj.hashCode();\n     }\n      * @return the hash code of the objects, or zero if null\n      * @since 3.0\n      */\n-    public static int hashCodeMulti(Object... objects) {\n+    public static int hashCodeMulti(final Object... objects) {\n         int hash = 1;\n         if (objects != null) {\n             for (Object object : objects) {\n      * @return the default toString text, or {@code null} if\n      *  {@code null} passed in\n      */\n-    public static String identityToString(Object object) {\n+    public static String identityToString(final Object object) {\n         if (object == null) {\n             return null;\n         }\n      * @param object  the object to create a toString for\n      * @since 2.4\n      */\n-    public static void identityToString(StringBuffer buffer, Object object) {\n+    public static void identityToString(final StringBuffer buffer, final Object object) {\n         if (object == null) {\n             throw new NullPointerException(\"Cannot get the toString of a null identity\");\n         }\n      * @return the passed in Object's toString, or {@code \"\"} if {@code null} input\n      * @since 2.0\n      */\n-    public static String toString(Object obj) {\n+    public static String toString(final Object obj) {\n         return obj == null ? \"\" : obj.toString();\n     }\n \n      * @return the passed in Object's toString, or {@code nullStr} if {@code null} input\n      * @since 2.0\n      */\n-    public static String toString(Object obj, String nullStr) {\n+    public static String toString(final Object obj, final String nullStr) {\n         return obj == null ? nullStr : obj.toString();\n     }\n \n      *   <li>If all the comparables are null, null is returned.\n      *  </ul>\n      */\n-    public static <T extends Comparable<? super T>> T min(T... values) {\n+    public static <T extends Comparable<? super T>> T min(final T... values) {\n         T result = null;\n         if (values != null) {\n             for (T value : values) {\n      *   <li>If all the comparables are null, null is returned.\n      *  </ul>\n      */\n-    public static <T extends Comparable<? super T>> T max(T... values) {\n+    public static <T extends Comparable<? super T>> T max(final T... values) {\n         T result = null;\n         if (values != null) {\n             for (T value : values) {\n      * @return a negative value if c1 < c2, zero if c1 = c2\n      *  and a positive value if c1 > c2\n      */\n-    public static <T extends Comparable<? super T>> int compare(T c1, T c2) {\n+    public static <T extends Comparable<? super T>> int compare(final T c1, final T c2) {\n         return compare(c1, c2, false);\n     }\n \n      *  and a positive value if c1 > c2\n      * @see java.util.Comparator#compare(Object, Object)\n      */\n-    public static <T extends Comparable<? super T>> int compare(T c1, T c2, boolean nullGreater) {\n+    public static <T extends Comparable<? super T>> int compare(final T c1, final T c2, final boolean nullGreater) {\n         if (c1 == c2) {\n             return 0;\n         } else if (c1 == null) {\n      * @throws IllegalArgumentException if items is empty or contains {@code null} values\n      * @since 3.0.1\n      */\n-    public static <T extends Comparable<? super T>> T median(T... items) {\n+    public static <T extends Comparable<? super T>> T median(final T... items) {\n         Validate.notEmpty(items);\n         Validate.noNullElements(items);\n         TreeSet<T> sort = new TreeSet<T>();\n      * @throws IllegalArgumentException if items is empty or contains {@code null} values\n      * @since 3.0.1\n      */\n-    public static <T> T median(Comparator<T> comparator, T... items) {\n+    public static <T> T median(final Comparator<T> comparator, final T... items) {\n         Validate.notEmpty(items, \"null/empty items\");\n         Validate.noNullElements(items);\n         Validate.notNull(comparator, \"null comparator\");\n      * @return most populous T, {@code null} if non-unique or no items supplied\n      * @since 3.0.1\n      */\n-    public static <T> T mode(T... items) {\n+    public static <T> T mode(final T... items) {\n         if (ArrayUtils.isNotEmpty(items)) {\n             HashMap<T, MutableInt> occurrences = new HashMap<T, MutableInt>(items.length);\n             for (T t : items) {\n--- a/src/main/java/org/apache/commons/lang3/RandomStringUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/RandomStringUtils.java\n      * @param count  the length of random string to create\n      * @return the random string\n      */\n-    public static String random(int count) {\n+    public static String random(final int count) {\n         return random(count, false, false);\n     }\n \n      * @param count  the length of random string to create\n      * @return the random string\n      */\n-    public static String randomAscii(int count) {\n+    public static String randomAscii(final int count) {\n         return random(count, 32, 127, false, false);\n     }\n     \n      * @param count  the length of random string to create\n      * @return the random string\n      */\n-    public static String randomAlphabetic(int count) {\n+    public static String randomAlphabetic(final int count) {\n         return random(count, true, false);\n     }\n     \n      * @param count  the length of random string to create\n      * @return the random string\n      */\n-    public static String randomAlphanumeric(int count) {\n+    public static String randomAlphanumeric(final int count) {\n         return random(count, true, true);\n     }\n     \n      * @param count  the length of random string to create\n      * @return the random string\n      */\n-    public static String randomNumeric(int count) {\n+    public static String randomNumeric(final int count) {\n         return random(count, false, true);\n     }\n \n      *  numeric characters\n      * @return the random string\n      */\n-    public static String random(int count, boolean letters, boolean numbers) {\n+    public static String random(final int count, final boolean letters, final boolean numbers) {\n         return random(count, 0, 0, letters, numbers);\n     }\n     \n      *  numeric characters\n      * @return the random string\n      */\n-    public static String random(int count, int start, int end, boolean letters, boolean numbers) {\n+    public static String random(final int count, final int start, final int end, final boolean letters, final boolean numbers) {\n         return random(count, start, end, letters, numbers, null, RANDOM);\n     }\n \n      * @throws ArrayIndexOutOfBoundsException if there are not\n      *  {@code (end - start) + 1} characters in the set array.\n      */\n-    public static String random(int count, int start, int end, boolean letters, boolean numbers, char... chars) {\n+    public static String random(final int count, final int start, final int end, final boolean letters, final boolean numbers, final char... chars) {\n         return random(count, start, end, letters, numbers, chars, RANDOM);\n     }\n \n      * @throws IllegalArgumentException if {@code count} &lt; 0 or the provided chars array is empty.\n      * @since 2.0\n      */\n-    public static String random(int count, int start, int end, boolean letters, boolean numbers,\n-                                char[] chars, Random random) {\n+    public static String random(int count, int start, int end, final boolean letters, final boolean numbers,\n+                                final char[] chars, final Random random) {\n         if (count == 0) {\n             return \"\";\n         } else if (count < 0) {\n      * @return the random string\n      * @throws IllegalArgumentException if {@code count} &lt; 0 or the string is empty.\n      */\n-    public static String random(int count, String chars) {\n+    public static String random(final int count, final String chars) {\n         if (chars == null) {\n             return random(count, 0, 0, false, false, null, RANDOM);\n         }\n      * @return the random string\n      * @throws IllegalArgumentException if {@code count} &lt; 0.\n      */\n-    public static String random(int count, char... chars) {\n+    public static String random(final int count, final char... chars) {\n         if (chars == null) {\n             return random(count, 0, 0, false, false, null, RANDOM);\n         }\n--- a/src/main/java/org/apache/commons/lang3/Range.java\n+++ b/src/main/java/org/apache/commons/lang3/Range.java\n      * @throws IllegalArgumentException if the element is null\n      * @throws ClassCastException if the element is not {@code Comparable}\n      */\n-    public static <T extends Comparable<T>> Range<T> is(T element) {\n+    public static <T extends Comparable<T>> Range<T> is(final T element) {\n         return between(element, element, null);\n     }\n \n      * @throws IllegalArgumentException if the element is null\n      * @throws ClassCastException if using natural ordering and the elements are not {@code Comparable}\n      */\n-    public static <T> Range<T> is(T element, Comparator<T> comparator) {\n+    public static <T> Range<T> is(final T element, final Comparator<T> comparator) {\n         return between(element, element, comparator);\n     }\n \n      * @throws IllegalArgumentException if either element is null\n      * @throws ClassCastException if the elements are not {@code Comparable}\n      */\n-    public static <T extends Comparable<T>> Range<T> between(T fromInclusive, T toInclusive) {\n+    public static <T extends Comparable<T>> Range<T> between(final T fromInclusive, final T toInclusive) {\n         return between(fromInclusive, toInclusive, null);\n     }\n \n      * @throws IllegalArgumentException if either element is null\n      * @throws ClassCastException if using natural ordering and the elements are not {@code Comparable}\n      */\n-    public static <T> Range<T> between(T fromInclusive, T toInclusive, Comparator<T> comparator) {\n+    public static <T> Range<T> between(final T fromInclusive, final T toInclusive, final Comparator<T> comparator) {\n         return new Range<T>(fromInclusive, toInclusive, comparator);\n     }\n \n      * @param comparator  the comparator to be used, null for natural ordering\n      */\n     @SuppressWarnings(\"unchecked\")\n-    private Range(T element1, T element2, Comparator<T> comparator) {\n+    private Range(final T element1, final T element2, Comparator<T> comparator) {\n         if (element1 == null || element2 == null) {\n             throw new IllegalArgumentException(\"Elements in a range must not be null: element1=\" +\n                                                element1 + \", element2=\" + element2);\n      * @param element  the element to check for, null returns false\n      * @return true if the specified element occurs within this range\n      */\n-    public boolean contains(T element) {\n+    public boolean contains(final T element) {\n         if (element == null) {\n             return false;\n         }\n      * @param element  the element to check for, null returns false\n      * @return true if this range is entirely after the specified element\n      */\n-    public boolean isAfter(T element) {\n+    public boolean isAfter(final T element) {\n         if (element == null) {\n             return false;\n         }\n      * @param element  the element to check for, null returns false\n      * @return true if the specified element occurs within this range\n      */\n-    public boolean isStartedBy(T element) {\n+    public boolean isStartedBy(final T element) {\n         if (element == null) {\n             return false;\n         }\n      * @param element  the element to check for, null returns false\n      * @return true if the specified element occurs within this range\n      */\n-    public boolean isEndedBy(T element) {\n+    public boolean isEndedBy(final T element) {\n         if (element == null) {\n             return false;\n         }\n      * @param element  the element to check for, null returns false\n      * @return true if this range is entirely before the specified element\n      */\n-    public boolean isBefore(T element) {\n+    public boolean isBefore(final T element) {\n         if (element == null) {\n             return false;\n         }\n      * @param element  the element to check for, not null\n      * @return -1, 0 or +1 depending on the element's location relative to the range\n      */\n-    public int elementCompareTo(T element) {\n+    public int elementCompareTo(final T element) {\n         if (element == null) {\n             // Comparable API says throw NPE on null\n             throw new NullPointerException(\"Element is null\");\n      * @return true if this range contains the specified range\n      * @throws RuntimeException if ranges cannot be compared\n      */\n-    public boolean containsRange(Range<T> otherRange) {\n+    public boolean containsRange(final Range<T> otherRange) {\n         if (otherRange == null) {\n             return false;\n         }\n      * @return true if this range is completely after the specified range\n      * @throws RuntimeException if ranges cannot be compared\n      */\n-    public boolean isAfterRange(Range<T> otherRange) {\n+    public boolean isAfterRange(final Range<T> otherRange) {\n         if (otherRange == null) {\n             return false;\n         }\n      *  range; otherwise, {@code false}\n      * @throws RuntimeException if ranges cannot be compared\n      */\n-    public boolean isOverlappedBy(Range<T> otherRange) {\n+    public boolean isOverlappedBy(final Range<T> otherRange) {\n         if (otherRange == null) {\n             return false;\n         }\n      * @return true if this range is completely before the specified range\n      * @throws RuntimeException if ranges cannot be compared\n      */\n-    public boolean isBeforeRange(Range<T> otherRange) {\n+    public boolean isBeforeRange(final Range<T> otherRange) {\n         if (otherRange == null) {\n             return false;\n         }\n      * @throws IllegalArgumentException if {@code other} does not overlap {@code this}\n      * @since 3.0.1\n      */\n-    public Range<T> intersectionWith(Range<T> other) {\n+    public Range<T> intersectionWith(final Range<T> other) {\n         if (!this.isOverlappedBy(other)) {\n             throw new IllegalArgumentException(String.format(\n                 \"Cannot calculate intersection with non-overlapping range %s\", other));\n      * @return true if this object is equal\n      */\n     @Override\n-    public boolean equals(Object obj) {\n+    public boolean equals(final Object obj) {\n         if (obj == this) {\n             return true;\n         } else if (obj == null || obj.getClass() != getClass()) {\n      * @param format  the format string, optionally containing {@code %1$s}, {@code %2$s} and  {@code %3$s}, not null\n      * @return the formatted string, not null\n      */\n-    public String toString(String format) {\n+    public String toString(final String format) {\n         return String.format(format, minimum, maximum, comparator);\n     }\n \n          * @return negative, 0, positive comparison value\n          */\n         @Override\n-        public int compare(Object obj1, Object obj2) {\n+        public int compare(final Object obj1, final Object obj2) {\n             return ((Comparable) obj1).compareTo(obj2);\n         }\n     }\n--- a/src/main/java/org/apache/commons/lang3/SerializationException.java\n+++ b/src/main/java/org/apache/commons/lang3/SerializationException.java\n      *\n      * @param msg  The error message.\n      */\n-    public SerializationException(String msg) {\n+    public SerializationException(final String msg) {\n         super(msg);\n     }\n \n      * @param cause  The {@code Exception} or {@code Error}\n      *  that caused this exception to be thrown.\n      */\n-    public SerializationException(Throwable cause) {\n+    public SerializationException(final Throwable cause) {\n         super(cause);\n     }\n \n      * @param cause  The {@code Exception} or {@code Error}\n      *  that caused this exception to be thrown.\n      */\n-    public SerializationException(String msg, Throwable cause) {\n+    public SerializationException(final String msg, final Throwable cause) {\n         super(msg, cause);\n     }\n \n--- a/src/main/java/org/apache/commons/lang3/SerializationUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/SerializationUtils.java\n      * @return the cloned object\n      * @throws SerializationException (runtime) if the serialization fails\n      */\n-    public static <T extends Serializable> T clone(T object) {\n+    public static <T extends Serializable> T clone(final T object) {\n         if (object == null) {\n             return null;\n         }\n      * @throws IllegalArgumentException if {@code outputStream} is {@code null}\n      * @throws SerializationException (runtime) if the serialization fails\n      */\n-    public static void serialize(Serializable obj, OutputStream outputStream) {\n+    public static void serialize(final Serializable obj, final OutputStream outputStream) {\n         if (outputStream == null) {\n             throw new IllegalArgumentException(\"The OutputStream must not be null\");\n         }\n      * @return a byte[] with the converted Serializable\n      * @throws SerializationException (runtime) if the serialization fails\n      */\n-    public static byte[] serialize(Serializable obj) {\n+    public static byte[] serialize(final Serializable obj) {\n         ByteArrayOutputStream baos = new ByteArrayOutputStream(512);\n         serialize(obj, baos);\n         return baos.toByteArray();\n      */\n     @SuppressWarnings(\"unchecked\")\n     // Don't warn about \"(T) deserialize\" because we want the avoid type casting call sites.\n-    public static <T> T deserialize(InputStream inputStream) {\n+    public static <T> T deserialize(final InputStream inputStream) {\n         if (inputStream == null) {\n             throw new IllegalArgumentException(\"The InputStream must not be null\");\n         }\n      */\n     @SuppressWarnings(\"unchecked\")\n     // Don't warn about \"(T) deserialize\" because we want the avoid type casting call sites.\n-    public static <T> T deserialize(byte[] objectData) {\n+    public static <T> T deserialize(final byte[] objectData) {\n         if (objectData == null) {\n             throw new IllegalArgumentException(\"The byte[] must not be null\");\n         }\n          * @throws IOException if an I/O error occurs while reading stream header.\n          * @see java.io.ObjectInputStream\n          */\n-        public ClassLoaderAwareObjectInputStream(InputStream in, ClassLoader classLoader) throws IOException {\n+        public ClassLoaderAwareObjectInputStream(final InputStream in, final ClassLoader classLoader) throws IOException {\n             super(in);\n             this.classLoader = classLoader;\n \n          * @throws ClassNotFoundException If class of a serialized object cannot be found.\n          */\n         @Override\n-        protected Class<?> resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException {\n+        protected Class<?> resolveClass(final ObjectStreamClass desc) throws IOException, ClassNotFoundException {\n             String name = desc.getName();\n             try {\n                 return Class.forName(name, false, classLoader);\n--- a/src/main/java/org/apache/commons/lang3/StringEscapeUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/StringEscapeUtils.java\n             new char[] {CSV_DELIMITER, CSV_QUOTE, CharUtils.CR, CharUtils.LF};\n \n         @Override\n-        public int translate(CharSequence input, int index, Writer out) throws IOException {\n+        public int translate(final CharSequence input, final int index, final Writer out) throws IOException {\n \n             if(index != 0) {\n                 throw new IllegalStateException(\"CsvEscaper should never reach the [1] index\");\n             new char[] {CSV_DELIMITER, CSV_QUOTE, CharUtils.CR, CharUtils.LF};\n \n         @Override\n-        public int translate(CharSequence input, int index, Writer out) throws IOException {\n+        public int translate(final CharSequence input, final int index, final Writer out) throws IOException {\n \n             if(index != 0) {\n                 throw new IllegalStateException(\"CsvUnescaper should never reach the [1] index\");\n      * @param input  String to escape values in, may be null\n      * @return String with escaped values, {@code null} if null string input\n      */\n-    public static final String escapeJava(String input) {\n+    public static final String escapeJava(final String input) {\n         return ESCAPE_JAVA.translate(input);\n     }\n \n      *\n      * @since 3.0\n      */\n-    public static final String escapeEcmaScript(String input) {\n+    public static final String escapeEcmaScript(final String input) {\n         return ESCAPE_ECMASCRIPT.translate(input);\n     }\n \n      * @param input  the {@code String} to unescape, may be null\n      * @return a new unescaped {@code String}, {@code null} if null string input\n      */\n-    public static final String unescapeJava(String input) {\n+    public static final String unescapeJava(final String input) {\n         return UNESCAPE_JAVA.translate(input);\n     }\n \n      *\n      * @since 3.0\n      */\n-    public static final String unescapeEcmaScript(String input) {\n+    public static final String unescapeEcmaScript(final String input) {\n         return UNESCAPE_ECMASCRIPT.translate(input);\n     }\n \n      * \n      * @since 3.0\n      */\n-    public static final String escapeHtml4(String input) {\n+    public static final String escapeHtml4(final String input) {\n         return ESCAPE_HTML4.translate(input);\n     }\n \n      * \n      * @since 3.0\n      */\n-    public static final String escapeHtml3(String input) {\n+    public static final String escapeHtml3(final String input) {\n         return ESCAPE_HTML3.translate(input);\n     }\n                 \n      * \n      * @since 3.0\n      */\n-    public static final String unescapeHtml4(String input) {\n+    public static final String unescapeHtml4(final String input) {\n         return UNESCAPE_HTML4.translate(input);\n     }\n \n      * \n      * @since 3.0\n      */\n-    public static final String unescapeHtml3(String input) {\n+    public static final String unescapeHtml3(final String input) {\n         return UNESCAPE_HTML3.translate(input);\n     }\n \n      * @return a new escaped {@code String}, {@code null} if null string input\n      * @see #unescapeXml(java.lang.String)\n      */\n-    public static final String escapeXml(String input) {\n+    public static final String escapeXml(final String input) {\n         return ESCAPE_XML.translate(input);\n     }\n                 \n      * @return a new unescaped {@code String}, {@code null} if null string input\n      * @see #escapeXml(String)\n      */\n-    public static final String unescapeXml(String input) {\n+    public static final String unescapeXml(final String input) {\n         return UNESCAPE_XML.translate(input);\n     }\n                 \n      * newline or double quote, {@code null} if null string input\n      * @since 2.4\n      */\n-    public static final String escapeCsv(String input) {\n+    public static final String escapeCsv(final String input) {\n         return ESCAPE_CSV.translate(input);\n     }\n \n      * quotes unescaped, {@code null} if null string input\n      * @since 2.4\n      */\n-    public static final String unescapeCsv(String input) {\n+    public static final String unescapeCsv(final String input) {\n         return UNESCAPE_CSV.translate(input);\n     }\n \n--- a/src/main/java/org/apache/commons/lang3/StringUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/StringUtils.java\n      * @return {@code true} if the CharSequence is empty or null\n      * @since 3.0 Changed signature from isEmpty(String) to isEmpty(CharSequence)\n      */\n-    public static boolean isEmpty(CharSequence cs) {\n+    public static boolean isEmpty(final CharSequence cs) {\n         return cs == null || cs.length() == 0;\n     }\n \n      * @return {@code true} if the CharSequence is not empty and not null\n      * @since 3.0 Changed signature from isNotEmpty(String) to isNotEmpty(CharSequence)\n      */\n-    public static boolean isNotEmpty(CharSequence cs) {\n+    public static boolean isNotEmpty(final CharSequence cs) {\n         return !StringUtils.isEmpty(cs);\n     }\n \n      * @since 2.0\n      * @since 3.0 Changed signature from isBlank(String) to isBlank(CharSequence)\n      */\n-    public static boolean isBlank(CharSequence cs) {\n+    public static boolean isBlank(final CharSequence cs) {\n         int strLen;\n         if (cs == null || (strLen = cs.length()) == 0) {\n             return true;\n      * @since 2.0\n      * @since 3.0 Changed signature from isNotBlank(String) to isNotBlank(CharSequence)\n      */\n-    public static boolean isNotBlank(CharSequence cs) {\n+    public static boolean isNotBlank(final CharSequence cs) {\n         return !StringUtils.isBlank(cs);\n     }\n \n      * @param str  the String to be trimmed, may be null\n      * @return the trimmed string, {@code null} if null String input\n      */\n-    public static String trim(String str) {\n+    public static String trim(final String str) {\n         return str == null ? null : str.trim();\n     }\n \n      *  {@code null} if only chars &lt;= 32, empty or null String input\n      * @since 2.0\n      */\n-    public static String trimToNull(String str) {\n+    public static String trimToNull(final String str) {\n         String ts = trim(str);\n         return isEmpty(ts) ? null : ts;\n     }\n      * @return the trimmed String, or an empty String if {@code null} input\n      * @since 2.0\n      */\n-    public static String trimToEmpty(String str) {\n+    public static String trimToEmpty(final String str) {\n         return str == null ? EMPTY : str.trim();\n     }\n \n      * @param str  the String to remove whitespace from, may be null\n      * @return the stripped String, {@code null} if null String input\n      */\n-    public static String strip(String str) {\n+    public static String strip(final String str) {\n         return strip(str, null);\n     }\n \n      * @return the trimmed String, or an empty String if {@code null} input\n      * @since 2.0\n      */\n-    public static String stripToEmpty(String str) {\n+    public static String stripToEmpty(final String str) {\n         return str == null ? EMPTY : strip(str, null);\n     }\n \n      * @param stripChars  the characters to remove, null treated as whitespace\n      * @return the stripped String, {@code null} if null String input\n      */\n-    public static String strip(String str, String stripChars) {\n+    public static String strip(String str, final String stripChars) {\n         if (isEmpty(str)) {\n             return str;\n         }\n      * @param stripChars  the characters to remove, null treated as whitespace\n      * @return the stripped String, {@code null} if null String input\n      */\n-    public static String stripStart(String str, String stripChars) {\n+    public static String stripStart(final String str, final String stripChars) {\n         int strLen;\n         if (str == null || (strLen = str.length()) == 0) {\n             return str;\n      * @param stripChars  the set of characters to remove, null treated as whitespace\n      * @return the stripped String, {@code null} if null String input\n      */\n-    public static String stripEnd(String str, String stripChars) {\n+    public static String stripEnd(final String str, final String stripChars) {\n         int end;\n         if (str == null || (end = str.length()) == 0) {\n             return str;\n      * @param strs  the array to remove whitespace from, may be null\n      * @return the stripped Strings, {@code null} if null array input\n      */\n-    public static String[] stripAll(String... strs) {\n+    public static String[] stripAll(final String... strs) {\n         return stripAll(strs, null);\n     }\n \n      * @param stripChars  the characters to remove, null treated as whitespace\n      * @return the stripped Strings, {@code null} if null array input\n      */\n-    public static String[] stripAll(String[] strs, String stripChars) {\n+    public static String[] stripAll(final String[] strs, final String stripChars) {\n         int strsLen;\n         if (strs == null || (strsLen = strs.length) == 0) {\n             return strs;\n      * @since 3.0\n      */\n     // See also Lucene's ASCIIFoldingFilter (Lucene 2.9) that replaces accented characters by their unaccented equivalent (and uncommitted bug fix: https://issues.apache.org/jira/browse/LUCENE-1343?focusedCommentId=12858907&page=com.atlassian.jira.plugin.system.issuetabpanels%3Acomment-tabpanel#action_12858907).\n-    public static String stripAccents(String input) {\n+    public static String stripAccents(final String input) {\n         if(input == null) {\n             return null;\n         }\n      * @return {@code true} if the CharSequences are equal (case-sensitive), or both {@code null}\n      * @since 3.0 Changed signature from equals(String, String) to equals(CharSequence, CharSequence)\n      */\n-    public static boolean equals(CharSequence cs1, CharSequence cs2) {\n+    public static boolean equals(final CharSequence cs1, final CharSequence cs2) {\n         if (cs1 == cs2) {\n             return true;\n         }\n      *  both {@code null}\n      * @since 3.0 Changed signature from equalsIgnoreCase(String, String) to equalsIgnoreCase(CharSequence, CharSequence)\n      */\n-    public static boolean equalsIgnoreCase(CharSequence str1, CharSequence str2) {\n+    public static boolean equalsIgnoreCase(final CharSequence str1, final CharSequence str2) {\n         if (str1 == null || str2 == null) {\n             return str1 == str2;\n         } else if (str1 == str2) {\n      * @since 2.0\n      * @since 3.0 Changed signature from indexOf(String, int) to indexOf(CharSequence, int)\n      */\n-    public static int indexOf(CharSequence seq, int searchChar) {\n+    public static int indexOf(final CharSequence seq, final int searchChar) {\n         if (isEmpty(seq)) {\n             return INDEX_NOT_FOUND;\n         }\n      * @since 2.0\n      * @since 3.0 Changed signature from indexOf(String, int, int) to indexOf(CharSequence, int, int)\n      */\n-    public static int indexOf(CharSequence seq, int searchChar, int startPos) {\n+    public static int indexOf(final CharSequence seq, final int searchChar, final int startPos) {\n         if (isEmpty(seq)) {\n             return INDEX_NOT_FOUND;\n         }\n      * @since 2.0\n      * @since 3.0 Changed signature from indexOf(String, String) to indexOf(CharSequence, CharSequence)\n      */\n-    public static int indexOf(CharSequence seq, CharSequence searchSeq) {\n+    public static int indexOf(final CharSequence seq, final CharSequence searchSeq) {\n         if (seq == null || searchSeq == null) {\n             return INDEX_NOT_FOUND;\n         }\n      * @since 2.0\n      * @since 3.0 Changed signature from indexOf(String, String, int) to indexOf(CharSequence, CharSequence, int)\n      */\n-    public static int indexOf(CharSequence seq, CharSequence searchSeq, int startPos) {\n+    public static int indexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {\n         if (seq == null || searchSeq == null) {\n             return INDEX_NOT_FOUND;\n         }\n      * @since 2.1\n      * @since 3.0 Changed signature from ordinalIndexOf(String, String, int) to ordinalIndexOf(CharSequence, CharSequence, int)\n      */\n-    public static int ordinalIndexOf(CharSequence str, CharSequence searchStr, int ordinal) {\n+    public static int ordinalIndexOf(final CharSequence str, final CharSequence searchStr, final int ordinal) {\n         return ordinalIndexOf(str, searchStr, ordinal, false);\n     }\n \n      *  {@code -1} ({@code INDEX_NOT_FOUND}) if no match or {@code null} string input\n      */\n     // Shared code between ordinalIndexOf(String,String,int) and lastOrdinalIndexOf(String,String,int)\n-    private static int ordinalIndexOf(CharSequence str, CharSequence searchStr, int ordinal, boolean lastIndex) {\n+    private static int ordinalIndexOf(final CharSequence str, final CharSequence searchStr, final int ordinal, final boolean lastIndex) {\n         if (str == null || searchStr == null || ordinal <= 0) {\n             return INDEX_NOT_FOUND;\n         }\n      * @since 2.5\n      * @since 3.0 Changed signature from indexOfIgnoreCase(String, String) to indexOfIgnoreCase(CharSequence, CharSequence)\n      */\n-    public static int indexOfIgnoreCase(CharSequence str, CharSequence searchStr) {\n+    public static int indexOfIgnoreCase(final CharSequence str, final CharSequence searchStr) {\n         return indexOfIgnoreCase(str, searchStr, 0);\n     }\n \n      * @since 2.5\n      * @since 3.0 Changed signature from indexOfIgnoreCase(String, String, int) to indexOfIgnoreCase(CharSequence, CharSequence, int)\n      */\n-    public static int indexOfIgnoreCase(CharSequence str, CharSequence searchStr, int startPos) {\n+    public static int indexOfIgnoreCase(final CharSequence str, final CharSequence searchStr, int startPos) {\n         if (str == null || searchStr == null) {\n             return INDEX_NOT_FOUND;\n         }\n      * @since 2.0\n      * @since 3.0 Changed signature from lastIndexOf(String, int) to lastIndexOf(CharSequence, int)\n      */\n-    public static int lastIndexOf(CharSequence seq, int searchChar) {\n+    public static int lastIndexOf(final CharSequence seq, final int searchChar) {\n         if (isEmpty(seq)) {\n             return INDEX_NOT_FOUND;\n         }\n      * @since 2.0\n      * @since 3.0 Changed signature from lastIndexOf(String, int, int) to lastIndexOf(CharSequence, int, int)\n      */\n-    public static int lastIndexOf(CharSequence seq, int searchChar, int startPos) {\n+    public static int lastIndexOf(final CharSequence seq, final int searchChar, final int startPos) {\n         if (isEmpty(seq)) {\n             return INDEX_NOT_FOUND;\n         }\n      * @since 2.0\n      * @since 3.0 Changed signature from lastIndexOf(String, String) to lastIndexOf(CharSequence, CharSequence)\n      */\n-    public static int lastIndexOf(CharSequence seq, CharSequence searchSeq) {\n+    public static int lastIndexOf(final CharSequence seq, final CharSequence searchSeq) {\n         if (seq == null || searchSeq == null) {\n             return INDEX_NOT_FOUND;\n         }\n      * @since 2.5\n      * @since 3.0 Changed signature from lastOrdinalIndexOf(String, String, int) to lastOrdinalIndexOf(CharSequence, CharSequence, int)\n      */\n-    public static int lastOrdinalIndexOf(CharSequence str, CharSequence searchStr, int ordinal) {\n+    public static int lastOrdinalIndexOf(final CharSequence str, final CharSequence searchStr, final int ordinal) {\n         return ordinalIndexOf(str, searchStr, ordinal, true);\n     }\n \n      * @since 2.0\n      * @since 3.0 Changed signature from lastIndexOf(String, String, int) to lastIndexOf(CharSequence, CharSequence, int)\n      */\n-    public static int lastIndexOf(CharSequence seq, CharSequence searchSeq, int startPos) {\n+    public static int lastIndexOf(final CharSequence seq, final CharSequence searchSeq, final int startPos) {\n         if (seq == null || searchSeq == null) {\n             return INDEX_NOT_FOUND;\n         }\n      * @since 2.5\n      * @since 3.0 Changed signature from lastIndexOfIgnoreCase(String, String) to lastIndexOfIgnoreCase(CharSequence, CharSequence)\n      */\n-    public static int lastIndexOfIgnoreCase(CharSequence str, CharSequence searchStr) {\n+    public static int lastIndexOfIgnoreCase(final CharSequence str, final CharSequence searchStr) {\n         if (str == null || searchStr == null) {\n             return INDEX_NOT_FOUND;\n         }\n      * @since 2.5\n      * @since 3.0 Changed signature from lastIndexOfIgnoreCase(String, String, int) to lastIndexOfIgnoreCase(CharSequence, CharSequence, int)\n      */\n-    public static int lastIndexOfIgnoreCase(CharSequence str, CharSequence searchStr, int startPos) {\n+    public static int lastIndexOfIgnoreCase(final CharSequence str, final CharSequence searchStr, int startPos) {\n         if (str == null || searchStr == null) {\n             return INDEX_NOT_FOUND;\n         }\n      * @since 2.0\n      * @since 3.0 Changed signature from contains(String, int) to contains(CharSequence, int)\n      */\n-    public static boolean contains(CharSequence seq, int searchChar) {\n+    public static boolean contains(final CharSequence seq, final int searchChar) {\n         if (isEmpty(seq)) {\n             return false;\n         }\n      * @since 2.0\n      * @since 3.0 Changed signature from contains(String, String) to contains(CharSequence, CharSequence)\n      */\n-    public static boolean contains(CharSequence seq, CharSequence searchSeq) {\n+    public static boolean contains(final CharSequence seq, final CharSequence searchSeq) {\n         if (seq == null || searchSeq == null) {\n             return false;\n         }\n      * case or false if not or {@code null} string input\n      * @since 3.0 Changed signature from containsIgnoreCase(String, String) to containsIgnoreCase(CharSequence, CharSequence)\n      */\n-    public static boolean containsIgnoreCase(CharSequence str, CharSequence searchStr) {\n+    public static boolean containsIgnoreCase(final CharSequence str, final CharSequence searchStr) {\n         if (str == null || searchStr == null) {\n             return false;\n         }\n      * @since 3.0\n      */\n     // From org.springframework.util.StringUtils, under Apache License 2.0\n-    public static boolean containsWhitespace(CharSequence seq) {\n+    public static boolean containsWhitespace(final CharSequence seq) {\n         if (isEmpty(seq)) {\n             return false;\n         }\n      * @since 2.0\n      * @since 3.0 Changed signature from indexOfAny(String, char[]) to indexOfAny(CharSequence, char...)\n      */\n-    public static int indexOfAny(CharSequence cs, char... searchChars) {\n+    public static int indexOfAny(final CharSequence cs, final char... searchChars) {\n         if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {\n             return INDEX_NOT_FOUND;\n         }\n      * @since 2.0\n      * @since 3.0 Changed signature from indexOfAny(String, String) to indexOfAny(CharSequence, String)\n      */\n-    public static int indexOfAny(CharSequence cs, String searchChars) {\n+    public static int indexOfAny(final CharSequence cs, final String searchChars) {\n         if (isEmpty(cs) || isEmpty(searchChars)) {\n             return INDEX_NOT_FOUND;\n         }\n      * @since 2.4\n      * @since 3.0 Changed signature from containsAny(String, char[]) to containsAny(CharSequence, char...)\n      */\n-    public static boolean containsAny(CharSequence cs, char... searchChars) {\n+    public static boolean containsAny(final CharSequence cs, final char... searchChars) {\n         if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {\n             return false;\n         }\n      * @since 2.4\n      * @since 3.0 Changed signature from containsAny(String, String) to containsAny(CharSequence, CharSequence)\n      */\n-    public static boolean containsAny(CharSequence cs, CharSequence searchChars) {\n+    public static boolean containsAny(final CharSequence cs, final CharSequence searchChars) {\n         if (searchChars == null) {\n             return false;\n         }\n      * @since 2.0\n      * @since 3.0 Changed signature from indexOfAnyBut(String, char[]) to indexOfAnyBut(CharSequence, char...)\n      */\n-    public static int indexOfAnyBut(CharSequence cs, char... searchChars) {\n+    public static int indexOfAnyBut(final CharSequence cs, final char... searchChars) {\n         if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {\n             return INDEX_NOT_FOUND;\n         }\n      * @since 2.0\n      * @since 3.0 Changed signature from indexOfAnyBut(String, String) to indexOfAnyBut(CharSequence, CharSequence)\n      */\n-    public static int indexOfAnyBut(CharSequence seq, CharSequence searchChars) {\n+    public static int indexOfAnyBut(final CharSequence seq, final CharSequence searchChars) {\n         if (isEmpty(seq) || isEmpty(searchChars)) {\n             return INDEX_NOT_FOUND;\n         }\n      * @return true if it only contains valid chars and is non-null\n      * @since 3.0 Changed signature from containsOnly(String, char[]) to containsOnly(CharSequence, char...)\n      */\n-    public static boolean containsOnly(CharSequence cs, char... valid) {\n+    public static boolean containsOnly(final CharSequence cs, final char... valid) {\n         // All these pre-checks are to maintain API with an older version\n         if (valid == null || cs == null) {\n             return false;\n      * @since 2.0\n      * @since 3.0 Changed signature from containsOnly(String, String) to containsOnly(CharSequence, String)\n      */\n-    public static boolean containsOnly(CharSequence cs, String validChars) {\n+    public static boolean containsOnly(final CharSequence cs, final String validChars) {\n         if (cs == null || validChars == null) {\n             return false;\n         }\n      * @since 2.0\n      * @since 3.0 Changed signature from containsNone(String, char[]) to containsNone(CharSequence, char...)\n      */\n-    public static boolean containsNone(CharSequence cs, char... searchChars) {\n+    public static boolean containsNone(final CharSequence cs, final char... searchChars) {\n         if (cs == null || searchChars == null) {\n             return true;\n         }\n      * @since 2.0\n      * @since 3.0 Changed signature from containsNone(String, String) to containsNone(CharSequence, String)\n      */\n-    public static boolean containsNone(CharSequence cs, String invalidChars) {\n+    public static boolean containsNone(final CharSequence cs, final String invalidChars) {\n         if (cs == null || invalidChars == null) {\n             return true;\n         }\n      * @return the first index of any of the searchStrs in str, -1 if no match\n      * @since 3.0 Changed signature from indexOfAny(String, String[]) to indexOfAny(CharSequence, CharSequence...)\n      */\n-    public static int indexOfAny(CharSequence str, CharSequence... searchStrs) {\n+    public static int indexOfAny(final CharSequence str, final CharSequence... searchStrs) {\n         if (str == null || searchStrs == null) {\n             return INDEX_NOT_FOUND;\n         }\n      * @return the last index of any of the CharSequences, -1 if no match\n      * @since 3.0 Changed signature from lastIndexOfAny(String, String[]) to lastIndexOfAny(CharSequence, CharSequence)\n      */\n-    public static int lastIndexOfAny(CharSequence str, CharSequence... searchStrs) {\n+    public static int lastIndexOfAny(final CharSequence str, final CharSequence... searchStrs) {\n         if (str == null || searchStrs == null) {\n             return INDEX_NOT_FOUND;\n         }\n      *  count back from the end of the String by this many characters\n      * @return substring from start position, {@code null} if null String input\n      */\n-    public static String substring(String str, int start) {\n+    public static String substring(final String str, int start) {\n         if (str == null) {\n             return null;\n         }\n      * @return substring from start position to end position,\n      *  {@code null} if null String input\n      */\n-    public static String substring(String str, int start, int end) {\n+    public static String substring(final String str, int start, int end) {\n         if (str == null) {\n             return null;\n         }\n      * @param len  the length of the required String\n      * @return the leftmost characters, {@code null} if null String input\n      */\n-    public static String left(String str, int len) {\n+    public static String left(final String str, final int len) {\n         if (str == null) {\n             return null;\n         }\n      * @param len  the length of the required String\n      * @return the rightmost characters, {@code null} if null String input\n      */\n-    public static String right(String str, int len) {\n+    public static String right(final String str, final int len) {\n         if (str == null) {\n             return null;\n         }\n      * @param len  the length of the required String\n      * @return the middle characters, {@code null} if null String input\n      */\n-    public static String mid(String str, int pos, int len) {\n+    public static String mid(final String str, int pos, final int len) {\n         if (str == null) {\n             return null;\n         }\n      *  {@code null} if null String input\n      * @since 2.0\n      */\n-    public static String substringBefore(String str, String separator) {\n+    public static String substringBefore(final String str, final String separator) {\n         if (isEmpty(str) || separator == null) {\n             return str;\n         }\n      *  {@code null} if null String input\n      * @since 2.0\n      */\n-    public static String substringAfter(String str, String separator) {\n+    public static String substringAfter(final String str, final String separator) {\n         if (isEmpty(str)) {\n             return str;\n         }\n      *  {@code null} if null String input\n      * @since 2.0\n      */\n-    public static String substringBeforeLast(String str, String separator) {\n+    public static String substringBeforeLast(final String str, final String separator) {\n         if (isEmpty(str) || isEmpty(separator)) {\n             return str;\n         }\n      *  {@code null} if null String input\n      * @since 2.0\n      */\n-    public static String substringAfterLast(String str, String separator) {\n+    public static String substringAfterLast(final String str, final String separator) {\n         if (isEmpty(str)) {\n             return str;\n         }\n      * @return the substring, {@code null} if no match\n      * @since 2.0\n      */\n-    public static String substringBetween(String str, String tag) {\n+    public static String substringBetween(final String str, final String tag) {\n         return substringBetween(str, tag, tag);\n     }\n \n      * @return the substring, {@code null} if no match\n      * @since 2.0\n      */\n-    public static String substringBetween(String str, String open, String close) {\n+    public static String substringBetween(final String str, final String open, final String close) {\n         if (str == null || open == null || close == null) {\n             return null;\n         }\n      * @return a String Array of substrings, or {@code null} if no match\n      * @since 2.3\n      */\n-    public static String[] substringsBetween(String str, String open, String close) {\n+    public static String[] substringsBetween(final String str, final String open, final String close) {\n         if (str == null || isEmpty(open) || isEmpty(close)) {\n             return null;\n         }\n      * @param str  the String to parse, may be null\n      * @return an array of parsed Strings, {@code null} if null String input\n      */\n-    public static String[] split(String str) {\n+    public static String[] split(final String str) {\n         return split(str, null, -1);\n     }\n \n      * @return an array of parsed Strings, {@code null} if null String input\n      * @since 2.0\n      */\n-    public static String[] split(String str, char separatorChar) {\n+    public static String[] split(final String str, final char separatorChar) {\n         return splitWorker(str, separatorChar, false);\n     }\n \n      *  {@code null} splits on whitespace\n      * @return an array of parsed Strings, {@code null} if null String input\n      */\n-    public static String[] split(String str, String separatorChars) {\n+    public static String[] split(final String str, final String separatorChars) {\n         return splitWorker(str, separatorChars, -1, false);\n     }\n \n      *  array. A zero or negative value implies no limit\n      * @return an array of parsed Strings, {@code null} if null String input\n      */\n-    public static String[] split(String str, String separatorChars, int max) {\n+    public static String[] split(final String str, final String separatorChars, final int max) {\n         return splitWorker(str, separatorChars, max, false);\n     }\n \n      *  {@code null} splits on whitespace\n      * @return an array of parsed Strings, {@code null} if null String was input\n      */\n-    public static String[] splitByWholeSeparator(String str, String separator) {\n+    public static String[] splitByWholeSeparator(final String str, final String separator) {\n         return splitByWholeSeparatorWorker( str, separator, -1, false ) ;\n     }\n \n      *  array. A zero or negative value implies no limit.\n      * @return an array of parsed Strings, {@code null} if null String was input\n      */\n-    public static String[] splitByWholeSeparator( String str, String separator, int max ) {\n+    public static String[] splitByWholeSeparator( final String str, final String separator, final int max ) {\n         return splitByWholeSeparatorWorker(str, separator, max, false);\n     }\n \n      * @return an array of parsed Strings, {@code null} if null String was input\n      * @since 2.4\n      */\n-    public static String[] splitByWholeSeparatorPreserveAllTokens(String str, String separator) {\n+    public static String[] splitByWholeSeparatorPreserveAllTokens(final String str, final String separator) {\n         return splitByWholeSeparatorWorker(str, separator, -1, true);\n     }\n \n      * @return an array of parsed Strings, {@code null} if null String was input\n      * @since 2.4\n      */\n-    public static String[] splitByWholeSeparatorPreserveAllTokens(String str, String separator, int max) {\n+    public static String[] splitByWholeSeparatorPreserveAllTokens(final String str, final String separator, final int max) {\n         return splitByWholeSeparatorWorker(str, separator, max, true);\n     }\n \n      * @since 2.4\n      */\n     private static String[] splitByWholeSeparatorWorker(\n-            String str, String separator, int max, boolean preserveAllTokens) {\n+            final String str, final String separator, final int max, final boolean preserveAllTokens) {\n         if (str == null) {\n             return null;\n         }\n      * @return an array of parsed Strings, {@code null} if null String input\n      * @since 2.1\n      */\n-    public static String[] splitPreserveAllTokens(String str) {\n+    public static String[] splitPreserveAllTokens(final String str) {\n         return splitWorker(str, null, -1, true);\n     }\n \n      * @return an array of parsed Strings, {@code null} if null String input\n      * @since 2.1\n      */\n-    public static String[] splitPreserveAllTokens(String str, char separatorChar) {\n+    public static String[] splitPreserveAllTokens(final String str, final char separatorChar) {\n         return splitWorker(str, separatorChar, true);\n     }\n \n      * separators are treated as one separator.\n      * @return an array of parsed Strings, {@code null} if null String input\n      */\n-    private static String[] splitWorker(String str, char separatorChar, boolean preserveAllTokens) {\n+    private static String[] splitWorker(final String str, final char separatorChar, final boolean preserveAllTokens) {\n         // Performance tuned for 2.0 (JDK1.4)\n \n         if (str == null) {\n      * @return an array of parsed Strings, {@code null} if null String input\n      * @since 2.1\n      */\n-    public static String[] splitPreserveAllTokens(String str, String separatorChars) {\n+    public static String[] splitPreserveAllTokens(final String str, final String separatorChars) {\n         return splitWorker(str, separatorChars, -1, true);\n     }\n \n      * @return an array of parsed Strings, {@code null} if null String input\n      * @since 2.1\n      */\n-    public static String[] splitPreserveAllTokens(String str, String separatorChars, int max) {\n+    public static String[] splitPreserveAllTokens(final String str, final String separatorChars, final int max) {\n         return splitWorker(str, separatorChars, max, true);\n     }\n \n      * separators are treated as one separator.\n      * @return an array of parsed Strings, {@code null} if null String input\n      */\n-    private static String[] splitWorker(String str, String separatorChars, int max, boolean preserveAllTokens) {\n+    private static String[] splitWorker(final String str, final String separatorChars, final int max, final boolean preserveAllTokens) {\n         // Performance tuned for 2.0 (JDK1.4)\n         // Direct code is quicker than StringTokenizer.\n         // Also, StringTokenizer uses isSpace() not isWhitespace()\n      * @return an array of parsed Strings, {@code null} if null String input\n      * @since 2.4\n      */\n-    public static String[] splitByCharacterType(String str) {\n+    public static String[] splitByCharacterType(final String str) {\n         return splitByCharacterType(str, false);\n     }\n \n      * @return an array of parsed Strings, {@code null} if null String input\n      * @since 2.4\n      */\n-    public static String[] splitByCharacterTypeCamelCase(String str) {\n+    public static String[] splitByCharacterTypeCamelCase(final String str) {\n         return splitByCharacterType(str, true);\n     }\n \n      * @return an array of parsed Strings, {@code null} if null String input\n      * @since 2.4\n      */\n-    private static String[] splitByCharacterType(String str, boolean camelCase) {\n+    private static String[] splitByCharacterType(final String str, final boolean camelCase) {\n         if (str == null) {\n             return null;\n         }\n      * @since 2.0\n      * @since 3.0 Changed signature to use varargs\n      */\n-    public static <T> String join(T... elements) {\n+    public static <T> String join(final T... elements) {\n         return join(elements, null);\n     }\n \n      * @return the joined String, {@code null} if null array input\n      * @since 2.0\n      */\n-    public static String join(Object[] array, char separator) {\n+    public static String join(final Object[] array, final char separator) {\n         if (array == null) {\n             return null;\n         }\n      * @return the joined String, {@code null} if null array input\n      * @since 3.2\n      */\n-    public static String join(long[] array, char separator) {\n+    public static String join(final long[] array, final char separator) {\n         if (array == null) {\n             return null;\n         }\n      * @return the joined String, {@code null} if null array input\n      * @since 3.2\n      */\n-    public static String join(int[] array, char separator) {\n+    public static String join(final int[] array, final char separator) {\n         if (array == null) {\n             return null;\n         }\n      * @return the joined String, {@code null} if null array input\n      * @since 3.2\n      */\n-    public static String join(short[] array, char separator) {\n+    public static String join(final short[] array, final char separator) {\n         if (array == null) {\n             return null;\n         }\n      * @return the joined String, {@code null} if null array input\n      * @since 3.2\n      */\n-    public static String join(byte[] array, char separator) {\n+    public static String join(final byte[] array, final char separator) {\n         if (array == null) {\n             return null;\n         }\n      * @return the joined String, {@code null} if null array input\n      * @since 3.2\n      */\n-    public static String join(char[] array, char separator) {\n+    public static String join(final char[] array, final char separator) {\n         if (array == null) {\n             return null;\n         }\n      * @return the joined String, {@code null} if null array input\n      * @since 3.2\n      */\n-    public static String join(float[] array, char separator) {\n+    public static String join(final float[] array, final char separator) {\n         if (array == null) {\n             return null;\n         }\n      * @return the joined String, {@code null} if null array input\n      * @since 3.2\n      */\n-    public static String join(double[] array, char separator) {\n+    public static String join(final double[] array, final char separator) {\n         if (array == null) {\n             return null;\n         }\n      * @return the joined String, {@code null} if null array input\n      * @since 2.0\n      */\n-    public static String join(Object[] array, char separator, int startIndex, int endIndex) {\n+    public static String join(final Object[] array, final char separator, final int startIndex, final int endIndex) {\n         if (array == null) {\n             return null;\n         }\n      * @return the joined String, {@code null} if null array input\n      * @since 3.2\n      */\n-    public static String join(long[] array, char separator, int startIndex, int endIndex) {\n+    public static String join(final long[] array, final char separator, final int startIndex, final int endIndex) {\n         if (array == null) {\n             return null;\n         }\n      * @return the joined String, {@code null} if null array input\n      * @since 3.2\n      */\n-    public static String join(int[] array, char separator, int startIndex, int endIndex) {\n+    public static String join(final int[] array, final char separator, final int startIndex, final int endIndex) {\n         if (array == null) {\n             return null;\n         }\n      * @return the joined String, {@code null} if null array input\n      * @since 3.2\n      */\n-    public static String join(byte[] array, char separator, int startIndex, int endIndex) {\n+    public static String join(final byte[] array, final char separator, final int startIndex, final int endIndex) {\n         if (array == null) {\n             return null;\n         }\n      * @return the joined String, {@code null} if null array input\n      * @since 3.2\n      */\n-    public static String join(short[] array, char separator, int startIndex, int endIndex) {\n+    public static String join(final short[] array, final char separator, final int startIndex, final int endIndex) {\n         if (array == null) {\n             return null;\n         }\n      * @return the joined String, {@code null} if null array input\n      * @since 3.2\n      */\n-    public static String join(char[] array, char separator, int startIndex, int endIndex) {\n+    public static String join(final char[] array, final char separator, final int startIndex, final int endIndex) {\n         if (array == null) {\n             return null;\n         }\n      * @return the joined String, {@code null} if null array input\n      * @since 3.2\n      */\n-    public static String join(double[] array, char separator, int startIndex, int endIndex) {\n+    public static String join(final double[] array, final char separator, final int startIndex, final int endIndex) {\n         if (array == null) {\n             return null;\n         }\n      * @return the joined String, {@code null} if null array input\n      * @since 3.2\n      */\n-    public static String join(float[] array, char separator, int startIndex, int endIndex) {\n+    public static String join(final float[] array, final char separator, final int startIndex, final int endIndex) {\n         if (array == null) {\n             return null;\n         }\n      * @param separator  the separator character to use, null treated as \"\"\n      * @return the joined String, {@code null} if null array input\n      */\n-    public static String join(Object[] array, String separator) {\n+    public static String join(final Object[] array, final String separator) {\n         if (array == null) {\n             return null;\n         }\n      * {@code endIndex < 0} or <br/>\n      * {@code endIndex > array.length()} \n      */\n-    public static String join(Object[] array, String separator, int startIndex, int endIndex) {\n+    public static String join(final Object[] array, String separator, final int startIndex, final int endIndex) {\n         if (array == null) {\n             return null;\n         }\n      * @return the joined String, {@code null} if null iterator input\n      * @since 2.0\n      */\n-    public static String join(Iterator<?> iterator, char separator) {\n+    public static String join(final Iterator<?> iterator, final char separator) {\n \n         // handle null, zero and one elements before building a buffer\n         if (iterator == null) {\n      * @param separator  the separator character to use, null treated as \"\"\n      * @return the joined String, {@code null} if null iterator input\n      */\n-    public static String join(Iterator<?> iterator, String separator) {\n+    public static String join(final Iterator<?> iterator, final String separator) {\n \n         // handle null, zero and one elements before building a buffer\n         if (iterator == null) {\n      * @return the joined String, {@code null} if null iterator input\n      * @since 2.3\n      */\n-    public static String join(Iterable<?> iterable, char separator) {\n+    public static String join(final Iterable<?> iterable, final char separator) {\n         if (iterable == null) {\n             return null;\n         }\n      * @return the joined String, {@code null} if null iterator input\n      * @since 2.3\n      */\n-    public static String join(Iterable<?> iterable, String separator) {\n+    public static String join(final Iterable<?> iterable, final String separator) {\n         if (iterable == null) {\n             return null;\n         }\n      * @param str  the String to delete whitespace from, may be null\n      * @return the String without whitespaces, {@code null} if null String input\n      */\n-    public static String deleteWhitespace(String str) {\n+    public static String deleteWhitespace(final String str) {\n         if (isEmpty(str)) {\n             return str;\n         }\n      *  {@code null} if null String input\n      * @since 2.1\n      */\n-    public static String removeStart(String str, String remove) {\n+    public static String removeStart(final String str, final String remove) {\n         if (isEmpty(str) || isEmpty(remove)) {\n             return str;\n         }\n      *  {@code null} if null String input\n      * @since 2.4\n      */\n-    public static String removeStartIgnoreCase(String str, String remove) {\n+    public static String removeStartIgnoreCase(final String str, final String remove) {\n         if (isEmpty(str) || isEmpty(remove)) {\n             return str;\n         }\n      *  {@code null} if null String input\n      * @since 2.1\n      */\n-    public static String removeEnd(String str, String remove) {\n+    public static String removeEnd(final String str, final String remove) {\n         if (isEmpty(str) || isEmpty(remove)) {\n             return str;\n         }\n      *  {@code null} if null String input\n      * @since 2.4\n      */\n-    public static String removeEndIgnoreCase(String str, String remove) {\n+    public static String removeEndIgnoreCase(final String str, final String remove) {\n         if (isEmpty(str) || isEmpty(remove)) {\n             return str;\n         }\n      *  {@code null} if null String input\n      * @since 2.1\n      */\n-    public static String remove(String str, String remove) {\n+    public static String remove(final String str, final String remove) {\n         if (isEmpty(str) || isEmpty(remove)) {\n             return str;\n         }\n      *  {@code null} if null String input\n      * @since 2.1\n      */\n-    public static String remove(String str, char remove) {\n+    public static String remove(final String str, final char remove) {\n         if (isEmpty(str) || str.indexOf(remove) == INDEX_NOT_FOUND) {\n             return str;\n         }\n      * @return the text with any replacements processed,\n      *  {@code null} if null String input\n      */\n-    public static String replaceOnce(String text, String searchString, String replacement) {\n+    public static String replaceOnce(final String text, final String searchString, final String replacement) {\n         return replace(text, searchString, replacement, 1);\n     }\n \n      * @see Pattern#DOTALL\n      * @since 3.2\n      */\n-    public static String replacePattern(String source, String regex, String replacement) {\n+    public static String replacePattern(final String source, final String regex, final String replacement) {\n         return Pattern.compile(regex, Pattern.DOTALL).matcher(source).replaceAll(replacement);\n     }\n \n      * @see Pattern#DOTALL\n      * @since 3.2\n      */\n-    public static String removePattern(String source, String regex) {\n+    public static String removePattern(final String source, final String regex) {\n         return replacePattern(source, regex, StringUtils.EMPTY);\n     }\n \n      * @return the text with any replacements processed,\n      *  {@code null} if null String input\n      */\n-    public static String replace(String text, String searchString, String replacement) {\n+    public static String replace(final String text, final String searchString, final String replacement) {\n         return replace(text, searchString, replacement, -1);\n     }\n \n      * @return the text with any replacements processed,\n      *  {@code null} if null String input\n      */\n-    public static String replace(String text, String searchString, String replacement, int max) {\n+    public static String replace(final String text, final String searchString, final String replacement, int max) {\n         if (isEmpty(text) || isEmpty(searchString) || replacement == null || max == 0) {\n             return text;\n         }\n      *             and/or size 0)\n      * @since 2.4\n      */\n-    public static String replaceEach(String text, String[] searchList, String[] replacementList) {\n+    public static String replaceEach(final String text, final String[] searchList, final String[] replacementList) {\n         return replaceEach(text, searchList, replacementList, false, 0);\n     }\n \n      *             and/or size 0)\n      * @since 2.4\n      */\n-    public static String replaceEachRepeatedly(String text, String[] searchList, String[] replacementList) {\n+    public static String replaceEachRepeatedly(final String text, final String[] searchList, final String[] replacementList) {\n         // timeToLive should be 0 if not used or nothing to replace, else it's\n         // the length of the replace array\n         int timeToLive = searchList == null ? 0 : searchList.length;\n      * @since 2.4\n      */\n     private static String replaceEach(\n-            String text, String[] searchList, String[] replacementList, boolean repeat, int timeToLive) {\n+            final String text, final String[] searchList, final String[] replacementList, final boolean repeat, final int timeToLive) {\n \n         // mchyzer Performance note: This creates very few new objects (one major goal)\n         // let me know if there are performance requests, we can create a harness to measure\n      * @return modified String, {@code null} if null string input\n      * @since 2.0\n      */\n-    public static String replaceChars(String str, char searchChar, char replaceChar) {\n+    public static String replaceChars(final String str, final char searchChar, final char replaceChar) {\n         if (str == null) {\n             return null;\n         }\n      * @return modified String, {@code null} if null string input\n      * @since 2.0\n      */\n-    public static String replaceChars(String str, String searchChars, String replaceChars) {\n+    public static String replaceChars(final String str, final String searchChars, String replaceChars) {\n         if (isEmpty(str) || isEmpty(searchChars)) {\n             return str;\n         }\n      * @return overlayed String, {@code null} if null String input\n      * @since 2.0\n      */\n-    public static String overlay(String str, String overlay, int start, int end) {\n+    public static String overlay(final String str, String overlay, int start, int end) {\n         if (str == null) {\n             return null;\n         }\n      * @param str  the String to chomp a newline from, may be null\n      * @return String without newline, {@code null} if null String input\n      */\n-    public static String chomp(String str) {\n+    public static String chomp(final String str) {\n         if (isEmpty(str)) {\n             return str;\n         }\n      * @deprecated This feature will be removed in Lang 4.0, use {@link StringUtils#removeEnd(String, String)} instead\n      */\n     @Deprecated\n-    public static String chomp(String str, String separator) {\n+    public static String chomp(final String str, final String separator) {\n         return removeEnd(str,separator);\n     }\n \n      * @param str  the String to chop last character from, may be null\n      * @return String without last character, {@code null} if null String input\n      */\n-    public static String chop(String str) {\n+    public static String chop(final String str) {\n         if (str == null) {\n             return null;\n         }\n      * @return a new String consisting of the original String repeated,\n      *  {@code null} if null String input\n      */\n-    public static String repeat(String str, int repeat) {\n+    public static String repeat(final String str, final int repeat) {\n         // Performance tuned for 2.0 (JDK1.4)\n \n         if (str == null) {\n      *  {@code null} if null String input\n      * @since 2.5\n      */\n-    public static String repeat(String str, String separator, int repeat) {\n+    public static String repeat(final String str, final String separator, final int repeat) {\n         if(str == null || separator == null) {\n             return repeat(str, repeat);\n         } else {\n      * @return String with repeated character\n      * @see #repeat(String, int)\n      */\n-    public static String repeat(char ch, int repeat) {\n+    public static String repeat(final char ch, final int repeat) {\n         char[] buf = new char[repeat];\n         for (int i = repeat - 1; i >= 0; i--) {\n             buf[i] = ch;\n      * @return right padded String or original String if no padding is necessary,\n      *  {@code null} if null String input\n      */\n-    public static String rightPad(String str, int size) {\n+    public static String rightPad(final String str, final int size) {\n         return rightPad(str, size, ' ');\n     }\n \n      *  {@code null} if null String input\n      * @since 2.0\n      */\n-    public static String rightPad(String str, int size, char padChar) {\n+    public static String rightPad(final String str, final int size, final char padChar) {\n         if (str == null) {\n             return null;\n         }\n      * @return right padded String or original String if no padding is necessary,\n      *  {@code null} if null String input\n      */\n-    public static String rightPad(String str, int size, String padStr) {\n+    public static String rightPad(final String str, final int size, String padStr) {\n         if (str == null) {\n             return null;\n         }\n      * @return left padded String or original String if no padding is necessary,\n      *  {@code null} if null String input\n      */\n-    public static String leftPad(String str, int size) {\n+    public static String leftPad(final String str, final int size) {\n         return leftPad(str, size, ' ');\n     }\n \n      *  {@code null} if null String input\n      * @since 2.0\n      */\n-    public static String leftPad(String str, int size, char padChar) {\n+    public static String leftPad(final String str, final int size, final char padChar) {\n         if (str == null) {\n             return null;\n         }\n      * @return left padded String or original String if no padding is necessary,\n      *  {@code null} if null String input\n      */\n-    public static String leftPad(String str, int size, String padStr) {\n+    public static String leftPad(final String str, final int size, String padStr) {\n         if (str == null) {\n             return null;\n         }\n      * @since 2.4\n      * @since 3.0 Changed signature from length(String) to length(CharSequence)\n      */\n-    public static int length(CharSequence cs) {\n+    public static int length(final CharSequence cs) {\n         return cs == null ? 0 : cs.length();\n     }\n \n      * @param size  the int size of new String, negative treated as zero\n      * @return centered String, {@code null} if null String input\n      */\n-    public static String center(String str, int size) {\n+    public static String center(final String str, final int size) {\n         return center(str, size, ' ');\n     }\n \n      * @return centered String, {@code null} if null String input\n      * @since 2.0\n      */\n-    public static String center(String str, int size, char padChar) {\n+    public static String center(String str, final int size, final char padChar) {\n         if (str == null || size <= 0) {\n             return str;\n         }\n      * @return centered String, {@code null} if null String input\n      * @throws IllegalArgumentException if padStr is {@code null} or empty\n      */\n-    public static String center(String str, int size, String padStr) {\n+    public static String center(String str, final int size, String padStr) {\n         if (str == null || size <= 0) {\n             return str;\n         }\n      * @param str  the String to upper case, may be null\n      * @return the upper cased String, {@code null} if null String input\n      */\n-    public static String upperCase(String str) {\n+    public static String upperCase(final String str) {\n         if (str == null) {\n             return null;\n         }\n      * @return the upper cased String, {@code null} if null String input\n      * @since 2.5\n      */\n-    public static String upperCase(String str, Locale locale) {\n+    public static String upperCase(final String str, final Locale locale) {\n         if (str == null) {\n             return null;\n         }\n      * @param str  the String to lower case, may be null\n      * @return the lower cased String, {@code null} if null String input\n      */\n-    public static String lowerCase(String str) {\n+    public static String lowerCase(final String str) {\n         if (str == null) {\n             return null;\n         }\n      * @return the lower cased String, {@code null} if null String input\n      * @since 2.5\n      */\n-    public static String lowerCase(String str, Locale locale) {\n+    public static String lowerCase(final String str, final Locale locale) {\n         if (str == null) {\n             return null;\n         }\n      * @see #uncapitalize(String)\n      * @since 2.0\n      */\n-    public static String capitalize(String str) {\n+    public static String capitalize(final String str) {\n         int strLen;\n         if (str == null || (strLen = str.length()) == 0) {\n             return str;\n      * @see #capitalize(String)\n      * @since 2.0\n      */\n-    public static String uncapitalize(String str) {\n+    public static String uncapitalize(final String str) {\n         int strLen;\n         if (str == null || (strLen = str.length()) == 0) {\n             return str;\n      * @param str  the String to swap case, may be null\n      * @return the changed String, {@code null} if null String input\n      */\n-    public static String swapCase(String str) {\n+    public static String swapCase(final String str) {\n         if (StringUtils.isEmpty(str)) {\n             return str;\n         }\n      * @return the number of occurrences, 0 if either CharSequence is {@code null}\n      * @since 3.0 Changed signature from countMatches(String, String) to countMatches(CharSequence, CharSequence)\n      */\n-    public static int countMatches(CharSequence str, CharSequence sub) {\n+    public static int countMatches(final CharSequence str, final CharSequence sub) {\n         if (isEmpty(str) || isEmpty(sub)) {\n             return 0;\n         }\n      * @since 3.0 Changed signature from isAlpha(String) to isAlpha(CharSequence)\n      * @since 3.0 Changed \"\" to return false and not true\n      */\n-    public static boolean isAlpha(CharSequence cs) {\n+    public static boolean isAlpha(final CharSequence cs) {\n         if (cs == null || cs.length() == 0) {\n             return false;\n         }\n      *  and is non-null\n      * @since 3.0 Changed signature from isAlphaSpace(String) to isAlphaSpace(CharSequence)\n      */\n-    public static boolean isAlphaSpace(CharSequence cs) {\n+    public static boolean isAlphaSpace(final CharSequence cs) {\n         if (cs == null) {\n             return false;\n         }\n      * @since 3.0 Changed signature from isAlphanumeric(String) to isAlphanumeric(CharSequence)\n      * @since 3.0 Changed \"\" to return false and not true\n      */\n-    public static boolean isAlphanumeric(CharSequence cs) {\n+    public static boolean isAlphanumeric(final CharSequence cs) {\n         if (cs == null || cs.length() == 0) {\n             return false;\n         }\n      *  and is non-null\n      * @since 3.0 Changed signature from isAlphanumericSpace(String) to isAlphanumericSpace(CharSequence)\n      */\n-    public static boolean isAlphanumericSpace(CharSequence cs) {\n+    public static boolean isAlphanumericSpace(final CharSequence cs) {\n         if (cs == null) {\n             return false;\n         }\n      * @since 2.1\n      * @since 3.0 Changed signature from isAsciiPrintable(String) to isAsciiPrintable(CharSequence)\n      */\n-    public static boolean isAsciiPrintable(CharSequence cs) {\n+    public static boolean isAsciiPrintable(final CharSequence cs) {\n         if (cs == null) {\n             return false;\n         }\n      * @since 3.0 Changed signature from isNumeric(String) to isNumeric(CharSequence)\n      * @since 3.0 Changed \"\" to return false and not true\n      */\n-    public static boolean isNumeric(CharSequence cs) {\n+    public static boolean isNumeric(final CharSequence cs) {\n         if (cs == null || cs.length() == 0) {\n             return false;\n         }\n      *  and is non-null\n      * @since 3.0 Changed signature from isNumericSpace(String) to isNumericSpace(CharSequence)\n      */\n-    public static boolean isNumericSpace(CharSequence cs) {\n+    public static boolean isNumericSpace(final CharSequence cs) {\n         if (cs == null) {\n             return false;\n         }\n      * @since 2.0\n      * @since 3.0 Changed signature from isWhitespace(String) to isWhitespace(CharSequence)\n      */\n-    public static boolean isWhitespace(CharSequence cs) {\n+    public static boolean isWhitespace(final CharSequence cs) {\n         if (cs == null) {\n             return false;\n         }\n      * @since 2.5\n      * @since 3.0 Changed signature from isAllLowerCase(String) to isAllLowerCase(CharSequence)\n      */\n-    public static boolean isAllLowerCase(CharSequence cs) {\n+    public static boolean isAllLowerCase(final CharSequence cs) {\n         if (cs == null || isEmpty(cs)) {\n             return false;\n         }\n      * @since 2.5\n      * @since 3.0 Changed signature from isAllUpperCase(String) to isAllUpperCase(CharSequence)\n      */\n-    public static boolean isAllUpperCase(CharSequence cs) {\n+    public static boolean isAllUpperCase(final CharSequence cs) {\n         if (cs == null || isEmpty(cs)) {\n             return false;\n         }\n      * @return the passed in String, or the empty String if it\n      *  was {@code null}\n      */\n-    public static String defaultString(String str) {\n+    public static String defaultString(final String str) {\n         return str == null ? EMPTY : str;\n     }\n \n      *  if the input is {@code null}, may be null\n      * @return the passed in String, or the default if it was {@code null}\n      */\n-    public static String defaultString(String str, String defaultStr) {\n+    public static String defaultString(final String str, final String defaultStr) {\n         return str == null ? defaultStr : str;\n     }\n \n      * @return the passed in CharSequence, or the default\n      * @see StringUtils#defaultString(String, String)\n      */\n-    public static <T extends CharSequence> T defaultIfBlank(T str, T defaultStr) {\n+    public static <T extends CharSequence> T defaultIfBlank(final T str, final T defaultStr) {\n         return StringUtils.isBlank(str) ? defaultStr : str;\n     }\n \n      * @return the passed in CharSequence, or the default\n      * @see StringUtils#defaultString(String, String)\n      */\n-    public static <T extends CharSequence> T defaultIfEmpty(T str, T defaultStr) {\n+    public static <T extends CharSequence> T defaultIfEmpty(final T str, final T defaultStr) {\n         return StringUtils.isEmpty(str) ? defaultStr : str;\n     }\n \n      * @param str  the String to reverse, may be null\n      * @return the reversed String, {@code null} if null String input\n      */\n-    public static String reverse(String str) {\n+    public static String reverse(final String str) {\n         if (str == null) {\n             return null;\n         }\n      * @return the reversed String, {@code null} if null String input\n      * @since 2.0\n      */\n-    public static String reverseDelimited(String str, char separatorChar) {\n+    public static String reverseDelimited(final String str, final char separatorChar) {\n         if (str == null) {\n             return null;\n         }\n      * @throws IllegalArgumentException if the width is too small\n      * @since 2.0\n      */\n-    public static String abbreviate(String str, int maxWidth) {\n+    public static String abbreviate(final String str, final int maxWidth) {\n         return abbreviate(str, 0, maxWidth);\n     }\n \n      * @throws IllegalArgumentException if the width is too small\n      * @since 2.0\n      */\n-    public static String abbreviate(String str, int offset, int maxWidth) {\n+    public static String abbreviate(final String str, int offset, final int maxWidth) {\n         if (str == null) {\n             return null;\n         }\n      * @return the abbreviated String if the above criteria is met, or the original String supplied for abbreviation.\n      * @since 2.5\n      */\n-    public static String abbreviateMiddle(String str, String middle, int length) {\n+    public static String abbreviateMiddle(final String str, final String middle, final int length) {\n         if (isEmpty(str) || isEmpty(middle)) {\n             return str;\n         }\n      * empty String if they are equal\n      * @since 2.0\n      */\n-    public static String difference(String str1, String str2) {\n+    public static String difference(final String str1, final String str2) {\n         if (str1 == null) {\n             return str2;\n         }\n      * @since 3.0 Changed signature from indexOfDifference(String, String) to\n      * indexOfDifference(CharSequence, CharSequence)\n      */\n-    public static int indexOfDifference(CharSequence cs1, CharSequence cs2) {\n+    public static int indexOfDifference(final CharSequence cs1, final CharSequence cs2) {\n         if (cs1 == cs2) {\n             return INDEX_NOT_FOUND;\n         }\n      * @since 2.4\n      * @since 3.0 Changed signature from indexOfDifference(String...) to indexOfDifference(CharSequence...)\n      */\n-    public static int indexOfDifference(CharSequence... css) {\n+    public static int indexOfDifference(final CharSequence... css) {\n         if (css == null || css.length <= 1) {\n             return INDEX_NOT_FOUND;\n         }\n      * or if there is no common prefix.\n      * @since 2.4\n      */\n-    public static String getCommonPrefix(String... strs) {\n+    public static String getCommonPrefix(final String... strs) {\n         if (strs == null || strs.length == 0) {\n             return EMPTY;\n         }\n      * @return result distance, or {@code -1} if the distance would be greater than the threshold\n      * @throws IllegalArgumentException if either String input {@code null} or negative threshold\n      */\n-    public static int getLevenshteinDistance(CharSequence s, CharSequence t, int threshold) {\n+    public static int getLevenshteinDistance(CharSequence s, CharSequence t, final int threshold) {\n         if (s == null || t == null) {\n             throw new IllegalArgumentException(\"Strings must not be null\");\n         }\n      * @since 2.4\n      * @since 3.0 Changed signature from startsWith(String, String) to startsWith(CharSequence, CharSequence)\n      */\n-    public static boolean startsWith(CharSequence str, CharSequence prefix) {\n+    public static boolean startsWith(final CharSequence str, final CharSequence prefix) {\n         return startsWith(str, prefix, false);\n     }\n \n      * @since 2.4\n      * @since 3.0 Changed signature from startsWithIgnoreCase(String, String) to startsWithIgnoreCase(CharSequence, CharSequence)\n      */\n-    public static boolean startsWithIgnoreCase(CharSequence str, CharSequence prefix) {\n+    public static boolean startsWithIgnoreCase(final CharSequence str, final CharSequence prefix) {\n         return startsWith(str, prefix, true);\n     }\n \n      * @return {@code true} if the CharSequence starts with the prefix or\n      *  both {@code null}\n      */\n-    private static boolean startsWith(CharSequence str, CharSequence prefix, boolean ignoreCase) {\n+    private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase) {\n         if (str == null || prefix == null) {\n             return str == null && prefix == null;\n         }\n      * @since 2.5\n      * @since 3.0 Changed signature from startsWithAny(String, String[]) to startsWithAny(CharSequence, CharSequence...)\n      */\n-    public static boolean startsWithAny(CharSequence string, CharSequence... searchStrings) {\n+    public static boolean startsWithAny(final CharSequence string, final CharSequence... searchStrings) {\n         if (isEmpty(string) || ArrayUtils.isEmpty(searchStrings)) {\n             return false;\n         }\n      * @since 2.4\n      * @since 3.0 Changed signature from endsWith(String, String) to endsWith(CharSequence, CharSequence)\n      */\n-    public static boolean endsWith(CharSequence str, CharSequence suffix) {\n+    public static boolean endsWith(final CharSequence str, final CharSequence suffix) {\n         return endsWith(str, suffix, false);\n     }\n \n      * @since 2.4\n      * @since 3.0 Changed signature from endsWithIgnoreCase(String, String) to endsWithIgnoreCase(CharSequence, CharSequence)\n      */\n-    public static boolean endsWithIgnoreCase(CharSequence str, CharSequence suffix) {\n+    public static boolean endsWithIgnoreCase(final CharSequence str, final CharSequence suffix) {\n         return endsWith(str, suffix, true);\n     }\n \n      * @return {@code true} if the CharSequence starts with the prefix or\n      *  both {@code null}\n      */\n-    private static boolean endsWith(CharSequence str, CharSequence suffix, boolean ignoreCase) {\n+    private static boolean endsWith(final CharSequence str, final CharSequence suffix, final boolean ignoreCase) {\n         if (str == null || suffix == null) {\n             return str == null && suffix == null;\n         }\n      *\n      * @since 3.0\n      */\n-    public static String normalizeSpace(String str) {\n+    public static String normalizeSpace(final String str) {\n         if (str == null) {\n             return null;\n         }\n      *  both {@code null}\n      * @since 3.0\n      */\n-    public static boolean endsWithAny(CharSequence string, CharSequence... searchStrings) {\n+    public static boolean endsWithAny(final CharSequence string, final CharSequence... searchStrings) {\n         if (isEmpty(string) || ArrayUtils.isEmpty(searchStrings)) {\n             return false;\n         }\n      *             if the input is null\n      * @since 3.1\n      */\n-    public static String toString(byte[] bytes, String charsetName) throws UnsupportedEncodingException {\n+    public static String toString(final byte[] bytes, final String charsetName) throws UnsupportedEncodingException {\n         return charsetName == null ? new String(bytes) : new String(bytes, charsetName);\n     }\n \n--- a/src/main/java/org/apache/commons/lang3/SystemUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/SystemUtils.java\n      * @param versionPrefix the prefix for the java version\n      * @return true if matches, or false if not or can't determine\n      */\n-    private static boolean getJavaVersionMatches(String versionPrefix) {\n+    private static boolean getJavaVersionMatches(final String versionPrefix) {\n         return isJavaVersionMatch(JAVA_SPECIFICATION_VERSION, versionPrefix);\n     }\n \n      * @param osVersionPrefix the prefix for the version\n      * @return true if matches, or false if not or can't determine\n      */\n-    private static boolean getOSMatches(String osNamePrefix, String osVersionPrefix) {\n+    private static boolean getOSMatches(final String osNamePrefix, final String osVersionPrefix) {\n         return isOSMatch(OS_NAME, OS_VERSION, osNamePrefix, osVersionPrefix);\n     }\n \n      * @param osNamePrefix the prefix for the os name\n      * @return true if matches, or false if not or can't determine\n      */\n-    private static boolean getOSMatchesName(String osNamePrefix) {\n+    private static boolean getOSMatchesName(final String osNamePrefix) {\n         return isOSNameMatch(OS_NAME, osNamePrefix);\n     }\n \n      * @param property the system property name\n      * @return the system property value or {@code null} if a security problem occurs\n      */\n-    private static String getSystemProperty(String property) {\n+    private static String getSystemProperty(final String property) {\n         try {\n             return System.getProperty(property);\n         } catch (SecurityException ex) {\n      * @param requiredVersion the required version, for example 1.31f\n      * @return {@code true} if the actual version is equal or greater than the required version\n      */\n-    public static boolean isJavaVersionAtLeast(JavaVersion requiredVersion) {\n+    public static boolean isJavaVersionAtLeast(final JavaVersion requiredVersion) {\n         return JAVA_SPECIFICATION_VERSION_AS_ENUM.atLeast(requiredVersion);\n     }\n \n      * @param versionPrefix the prefix for the expected Java version\n      * @return true if matches, or false if not or can't determine\n      */\n-    static boolean isJavaVersionMatch(String version, String versionPrefix) {\n+    static boolean isJavaVersionMatch(final String version, final String versionPrefix) {\n         if (version == null) {\n             return false;\n         }\n      * @param osVersionPrefix the prefix for the expected OS version\n      * @return true if matches, or false if not or can't determine\n      */\n-    static boolean isOSMatch(String osName, String osVersion, String osNamePrefix, String osVersionPrefix) {\n+    static boolean isOSMatch(final String osName, final String osVersion, final String osNamePrefix, final String osVersionPrefix) {\n         if (osName == null || osVersion == null) {\n             return false;\n         }\n      * @param osNamePrefix the prefix for the expected OS name\n      * @return true if matches, or false if not or can't determine\n      */\n-    static boolean isOSNameMatch(String osName, String osNamePrefix) {\n+    static boolean isOSNameMatch(final String osName, final String osNamePrefix) {\n         if (osName == null) {\n             return false;\n         }\n--- a/src/main/java/org/apache/commons/lang3/Validate.java\n+++ b/src/main/java/org/apache/commons/lang3/Validate.java\n      * @see #isTrue(boolean, String, double)\n      * @see #isTrue(boolean, String, Object...)\n      */\n-    public static void isTrue(boolean expression, String message, long value) {\n+    public static void isTrue(final boolean expression, final String message, final long value) {\n         if (expression == false) {\n             throw new IllegalArgumentException(String.format(message, Long.valueOf(value)));\n         }\n      * @see #isTrue(boolean, String, long)\n      * @see #isTrue(boolean, String, Object...)\n      */\n-    public static void isTrue(boolean expression, String message, double value) {\n+    public static void isTrue(final boolean expression, final String message, final double value) {\n         if (expression == false) {\n             throw new IllegalArgumentException(String.format(message, Double.valueOf(value)));\n         }\n      * @see #isTrue(boolean, String, long)\n      * @see #isTrue(boolean, String, double)\n      */\n-    public static void isTrue(boolean expression, String message, Object... values) {\n+    public static void isTrue(final boolean expression, final String message, final Object... values) {\n         if (expression == false) {\n             throw new IllegalArgumentException(String.format(message, values));\n         }\n      * @see #isTrue(boolean, String, double)\n      * @see #isTrue(boolean, String, Object...)\n      */\n-    public static void isTrue(boolean expression) {\n+    public static void isTrue(final boolean expression) {\n         if (expression == false) {\n             throw new IllegalArgumentException(DEFAULT_IS_TRUE_EX_MESSAGE);\n         }\n      * @throws NullPointerException if the object is {@code null}\n      * @see #notNull(Object, String, Object...)\n      */\n-    public static <T> T notNull(T object) {\n+    public static <T> T notNull(final T object) {\n         return notNull(object, DEFAULT_IS_NULL_EX_MESSAGE);\n     }\n \n      * @throws NullPointerException if the object is {@code null}\n      * @see #notNull(Object)\n      */\n-    public static <T> T notNull(T object, String message, Object... values) {\n+    public static <T> T notNull(final T object, final String message, final Object... values) {\n         if (object == null) {\n             throw new NullPointerException(String.format(message, values));\n         }\n      * @throws IllegalArgumentException if the array is empty\n      * @see #notEmpty(Object[])\n      */\n-    public static <T> T[] notEmpty(T[] array, String message, Object... values) {\n+    public static <T> T[] notEmpty(final T[] array, final String message, final Object... values) {\n         if (array == null) {\n             throw new NullPointerException(String.format(message, values));\n         }\n      * @throws IllegalArgumentException if the array is empty\n      * @see #notEmpty(Object[], String, Object...)\n      */\n-    public static <T> T[] notEmpty(T[] array) {\n+    public static <T> T[] notEmpty(final T[] array) {\n         return notEmpty(array, DEFAULT_NOT_EMPTY_ARRAY_EX_MESSAGE);\n     }\n \n      * @throws IllegalArgumentException if the collection is empty\n      * @see #notEmpty(Object[])\n      */\n-    public static <T extends Collection<?>> T notEmpty(T collection, String message, Object... values) {\n+    public static <T extends Collection<?>> T notEmpty(final T collection, final String message, final Object... values) {\n         if (collection == null) {\n             throw new NullPointerException(String.format(message, values));\n         }\n      * @throws IllegalArgumentException if the collection is empty\n      * @see #notEmpty(Collection, String, Object...)\n      */\n-    public static <T extends Collection<?>> T notEmpty(T collection) {\n+    public static <T extends Collection<?>> T notEmpty(final T collection) {\n         return notEmpty(collection, DEFAULT_NOT_EMPTY_COLLECTION_EX_MESSAGE);\n     }\n \n      * @throws IllegalArgumentException if the map is empty\n      * @see #notEmpty(Object[])\n      */\n-    public static <T extends Map<?, ?>> T notEmpty(T map, String message, Object... values) {\n+    public static <T extends Map<?, ?>> T notEmpty(final T map, final String message, final Object... values) {\n         if (map == null) {\n             throw new NullPointerException(String.format(message, values));\n         }\n      * @throws IllegalArgumentException if the map is empty\n      * @see #notEmpty(Map, String, Object...)\n      */\n-    public static <T extends Map<?, ?>> T notEmpty(T map) {\n+    public static <T extends Map<?, ?>> T notEmpty(final T map) {\n         return notEmpty(map, DEFAULT_NOT_EMPTY_MAP_EX_MESSAGE);\n     }\n \n      * @throws IllegalArgumentException if the character sequence is empty\n      * @see #notEmpty(CharSequence)\n      */\n-    public static <T extends CharSequence> T notEmpty(T chars, String message, Object... values) {\n+    public static <T extends CharSequence> T notEmpty(final T chars, final String message, final Object... values) {\n         if (chars == null) {\n             throw new NullPointerException(String.format(message, values));\n         }\n      * @throws IllegalArgumentException if the character sequence is empty\n      * @see #notEmpty(CharSequence, String, Object...)\n      */\n-    public static <T extends CharSequence> T notEmpty(T chars) {\n+    public static <T extends CharSequence> T notEmpty(final T chars) {\n         return notEmpty(chars, DEFAULT_NOT_EMPTY_CHAR_SEQUENCE_EX_MESSAGE);\n     }\n \n      *\n      * @since 3.0\n      */\n-    public static <T extends CharSequence> T notBlank(T chars, String message, Object... values) {\n+    public static <T extends CharSequence> T notBlank(final T chars, final String message, final Object... values) {\n         if (chars == null) {\n             throw new NullPointerException(String.format(message, values));\n         }\n      *\n      * @since 3.0\n      */\n-    public static <T extends CharSequence> T notBlank(T chars) {\n+    public static <T extends CharSequence> T notBlank(final T chars) {\n         return notBlank(chars, DEFAULT_NOT_BLANK_EX_MESSAGE);\n     }\n \n      * @throws IllegalArgumentException if an element is {@code null}\n      * @see #noNullElements(Object[])\n      */\n-    public static <T> T[] noNullElements(T[] array, String message, Object... values) {\n+    public static <T> T[] noNullElements(final T[] array, final String message, final Object... values) {\n         Validate.notNull(array);\n         for (int i = 0; i < array.length; i++) {\n             if (array[i] == null) {\n      * @throws IllegalArgumentException if an element is {@code null}\n      * @see #noNullElements(Object[], String, Object...)\n      */\n-    public static <T> T[] noNullElements(T[] array) {\n+    public static <T> T[] noNullElements(final T[] array) {\n         return noNullElements(array, DEFAULT_NO_NULL_ELEMENTS_ARRAY_EX_MESSAGE);\n     }\n \n      * @throws IllegalArgumentException if an element is {@code null}\n      * @see #noNullElements(Iterable)\n      */\n-    public static <T extends Iterable<?>> T noNullElements(T iterable, String message, Object... values) {\n+    public static <T extends Iterable<?>> T noNullElements(final T iterable, final String message, final Object... values) {\n         Validate.notNull(iterable);\n         int i = 0;\n         for (Iterator<?> it = iterable.iterator(); it.hasNext(); i++) {\n      * @throws IllegalArgumentException if an element is {@code null}\n      * @see #noNullElements(Iterable, String, Object...)\n      */\n-    public static <T extends Iterable<?>> T noNullElements(T iterable) {\n+    public static <T extends Iterable<?>> T noNullElements(final T iterable) {\n         return noNullElements(iterable, DEFAULT_NO_NULL_ELEMENTS_COLLECTION_EX_MESSAGE);\n     }\n \n      *\n      * @since 3.0\n      */\n-    public static <T> T[] validIndex(T[] array, int index, String message, Object... values) {\n+    public static <T> T[] validIndex(final T[] array, final int index, final String message, final Object... values) {\n         Validate.notNull(array);\n         if (index < 0 || index >= array.length) {\n             throw new IndexOutOfBoundsException(String.format(message, values));\n      *\n      * @since 3.0\n      */\n-    public static <T> T[] validIndex(T[] array, int index) {\n+    public static <T> T[] validIndex(final T[] array, final int index) {\n         return validIndex(array, index, DEFAULT_VALID_INDEX_ARRAY_EX_MESSAGE, Integer.valueOf(index));\n     }\n \n      *\n      * @since 3.0\n      */\n-    public static <T extends Collection<?>> T validIndex(T collection, int index, String message, Object... values) {\n+    public static <T extends Collection<?>> T validIndex(final T collection, final int index, final String message, final Object... values) {\n         Validate.notNull(collection);\n         if (index < 0 || index >= collection.size()) {\n             throw new IndexOutOfBoundsException(String.format(message, values));\n      *\n      * @since 3.0\n      */\n-    public static <T extends Collection<?>> T validIndex(T collection, int index) {\n+    public static <T extends Collection<?>> T validIndex(final T collection, final int index) {\n         return validIndex(collection, index, DEFAULT_VALID_INDEX_COLLECTION_EX_MESSAGE, Integer.valueOf(index));\n     }\n \n      *\n      * @since 3.0\n      */\n-    public static <T extends CharSequence> T validIndex(T chars, int index, String message, Object... values) {\n+    public static <T extends CharSequence> T validIndex(final T chars, final int index, final String message, final Object... values) {\n         Validate.notNull(chars);\n         if (index < 0 || index >= chars.length()) {\n             throw new IndexOutOfBoundsException(String.format(message, values));\n      *\n      * @since 3.0\n      */\n-    public static <T extends CharSequence> T validIndex(T chars, int index) {\n+    public static <T extends CharSequence> T validIndex(final T chars, final int index) {\n         return validIndex(chars, index, DEFAULT_VALID_INDEX_CHAR_SEQUENCE_EX_MESSAGE, Integer.valueOf(index));\n     }\n \n      *\n      * @since 3.0\n      */\n-    public static void validState(boolean expression) {\n+    public static void validState(final boolean expression) {\n         if (expression == false) {\n             throw new IllegalStateException(DEFAULT_VALID_STATE_EX_MESSAGE);\n         }\n      *\n      * @since 3.0\n      */\n-    public static void validState(boolean expression, String message, Object... values) {\n+    public static void validState(final boolean expression, final String message, final Object... values) {\n         if (expression == false) {\n             throw new IllegalStateException(String.format(message, values));\n         }\n      *\n      * @since 3.0\n      */\n-    public static void matchesPattern(CharSequence input, String pattern) {\n+    public static void matchesPattern(final CharSequence input, final String pattern) {\n         // TODO when breaking BC, consider returning input\n         if (Pattern.matches(pattern, input) == false) {\n             throw new IllegalArgumentException(String.format(DEFAULT_MATCHES_PATTERN_EX, input, pattern));\n      *\n      * @since 3.0\n      */\n-    public static void matchesPattern(CharSequence input, String pattern, String message, Object... values) {\n+    public static void matchesPattern(final CharSequence input, final String pattern, final String message, final Object... values) {\n         // TODO when breaking BC, consider returning input\n         if (Pattern.matches(pattern, input) == false) {\n             throw new IllegalArgumentException(String.format(message, values));\n      *\n      * @since 3.0\n      */\n-    public static <T> void inclusiveBetween(T start, T end, Comparable<T> value) {\n+    public static <T> void inclusiveBetween(final T start, final T end, final Comparable<T> value) {\n         // TODO when breaking BC, consider returning value\n         if (value.compareTo(start) < 0 || value.compareTo(end) > 0) {\n             throw new IllegalArgumentException(String.format(DEFAULT_INCLUSIVE_BETWEEN_EX_MESSAGE, value, start, end));\n      *\n      * @since 3.0\n      */\n-    public static <T> void inclusiveBetween(T start, T end, Comparable<T> value, String message, Object... values) {\n+    public static <T> void inclusiveBetween(final T start, final T end, final Comparable<T> value, final String message, final Object... values) {\n         // TODO when breaking BC, consider returning value\n         if (value.compareTo(start) < 0 || value.compareTo(end) > 0) {\n             throw new IllegalArgumentException(String.format(message, values));\n      *\n      * @since 3.0\n      */\n-    public static <T> void exclusiveBetween(T start, T end, Comparable<T> value) {\n+    public static <T> void exclusiveBetween(final T start, final T end, final Comparable<T> value) {\n         // TODO when breaking BC, consider returning value\n         if (value.compareTo(start) <= 0 || value.compareTo(end) >= 0) {\n             throw new IllegalArgumentException(String.format(DEFAULT_EXCLUSIVE_BETWEEN_EX_MESSAGE, value, start, end));\n      *\n      * @since 3.0\n      */\n-    public static <T> void exclusiveBetween(T start, T end, Comparable<T> value, String message, Object... values) {\n+    public static <T> void exclusiveBetween(final T start, final T end, final Comparable<T> value, final String message, final Object... values) {\n         // TODO when breaking BC, consider returning value\n         if (value.compareTo(start) <= 0 || value.compareTo(end) >= 0) {\n             throw new IllegalArgumentException(String.format(message, values));\n      *\n      * @since 3.0\n      */\n-    public static void isInstanceOf(Class<?> type, Object obj) {\n+    public static void isInstanceOf(final Class<?> type, final Object obj) {\n         // TODO when breaking BC, consider returning obj\n         if (type.isInstance(obj) == false) {\n             throw new IllegalArgumentException(String.format(DEFAULT_IS_INSTANCE_OF_EX_MESSAGE, type.getName(),\n      *\n      * @since 3.0\n      */\n-    public static void isInstanceOf(Class<?> type, Object obj, String message, Object... values) {\n+    public static void isInstanceOf(final Class<?> type, final Object obj, final String message, final Object... values) {\n         // TODO when breaking BC, consider returning obj\n         if (type.isInstance(obj) == false) {\n             throw new IllegalArgumentException(String.format(message, values));\n      *\n      * @since 3.0\n      */\n-    public static void isAssignableFrom(Class<?> superType, Class<?> type) {\n+    public static void isAssignableFrom(final Class<?> superType, final Class<?> type) {\n         // TODO when breaking BC, consider returning type\n         if (superType.isAssignableFrom(type) == false) {\n             throw new IllegalArgumentException(String.format(DEFAULT_IS_ASSIGNABLE_EX_MESSAGE, type == null ? \"null\" : type.getName(),\n      * @throws IllegalArgumentException if argument can not be converted to the specified class\n      * @see #isAssignableFrom(Class, Class)\n      */\n-    public static void isAssignableFrom(Class<?> superType, Class<?> type, String message, Object... values) {\n+    public static void isAssignableFrom(final Class<?> superType, final Class<?> type, final String message, final Object... values) {\n         // TODO when breaking BC, consider returning type\n         if (superType.isAssignableFrom(type) == false) {\n             throw new IllegalArgumentException(String.format(message, values));\n--- a/src/main/java/org/apache/commons/lang3/builder/CompareToBuilder.java\n+++ b/src/main/java/org/apache/commons/lang3/builder/CompareToBuilder.java\n      * @throws ClassCastException  if <code>rhs</code> is not assignment-compatible\n      *  with <code>lhs</code>\n      */\n-    public static int reflectionCompare(Object lhs, Object rhs) {\n+    public static int reflectionCompare(final Object lhs, final Object rhs) {\n         return reflectionCompare(lhs, rhs, false, null);\n     }\n \n      * @throws ClassCastException  if <code>rhs</code> is not assignment-compatible\n      *  with <code>lhs</code>\n      */\n-    public static int reflectionCompare(Object lhs, Object rhs, boolean compareTransients) {\n+    public static int reflectionCompare(final Object lhs, final Object rhs, final boolean compareTransients) {\n         return reflectionCompare(lhs, rhs, compareTransients, null);\n     }\n \n      *  with <code>lhs</code>\n      * @since 2.2\n      */\n-    public static int reflectionCompare(Object lhs, Object rhs, Collection<String> excludeFields) {\n+    public static int reflectionCompare(final Object lhs, final Object rhs, final Collection<String> excludeFields) {\n         return reflectionCompare(lhs, rhs, ReflectionToStringBuilder.toNoNullStringArray(excludeFields));\n     }\n \n      *  with <code>lhs</code>\n      * @since 2.2\n      */\n-    public static int reflectionCompare(Object lhs, Object rhs, String... excludeFields) {\n+    public static int reflectionCompare(final Object lhs, final Object rhs, final String... excludeFields) {\n         return reflectionCompare(lhs, rhs, false, null, excludeFields);\n     }\n \n      * @since 2.2 (2.0 as <code>reflectionCompare(Object, Object, boolean, Class)</code>)\n      */\n     public static int reflectionCompare(\n-        Object lhs, \n-        Object rhs, \n-        boolean compareTransients, \n-        Class<?> reflectUpToClass, \n-        String... excludeFields) {\n+        final Object lhs, \n+        final Object rhs, \n+        final boolean compareTransients, \n+        final Class<?> reflectUpToClass, \n+        final String... excludeFields) {\n \n         if (lhs == rhs) {\n             return 0;\n      * @param excludeFields  fields to exclude\n      */\n     private static void reflectionAppend(\n-        Object lhs,\n-        Object rhs,\n-        Class<?> clazz,\n-        CompareToBuilder builder,\n-        boolean useTransients,\n-        String[] excludeFields) {\n+        final Object lhs,\n+        final Object rhs,\n+        final Class<?> clazz,\n+        final CompareToBuilder builder,\n+        final boolean useTransients,\n+        final String[] excludeFields) {\n         \n         Field[] fields = clazz.getDeclaredFields();\n         AccessibleObject.setAccessible(fields, true);\n      * @return this - used to chain append calls\n      * @since 2.0\n      */\n-    public CompareToBuilder appendSuper(int superCompareTo) {\n+    public CompareToBuilder appendSuper(final int superCompareTo) {\n         if (comparison != 0) {\n             return this;\n         }\n      * @throws ClassCastException  if <code>rhs</code> is not assignment-compatible\n      *  with <code>lhs</code>\n      */\n-    public CompareToBuilder append(Object lhs, Object rhs) {\n+    public CompareToBuilder append(final Object lhs, final Object rhs) {\n         return append(lhs, rhs, null);\n     }\n \n      *  with <code>lhs</code>\n      * @since 2.0\n      */\n-    public CompareToBuilder append(Object lhs, Object rhs, Comparator<?> comparator) {\n+    public CompareToBuilder append(final Object lhs, final Object rhs, final Comparator<?> comparator) {\n         if (comparison != 0) {\n             return this;\n         }\n      * @param rhs  right-hand value\n      * @return this - used to chain append calls\n      */\n-    public CompareToBuilder append(long lhs, long rhs) {\n+    public CompareToBuilder append(final long lhs, final long rhs) {\n         if (comparison != 0) {\n             return this;\n         }\n      * @param rhs  right-hand value\n      * @return this - used to chain append calls\n      */\n-    public CompareToBuilder append(int lhs, int rhs) {\n+    public CompareToBuilder append(final int lhs, final int rhs) {\n         if (comparison != 0) {\n             return this;\n         }\n      * @param rhs  right-hand value\n      * @return this - used to chain append calls\n      */\n-    public CompareToBuilder append(short lhs, short rhs) {\n+    public CompareToBuilder append(final short lhs, final short rhs) {\n         if (comparison != 0) {\n             return this;\n         }\n      * @param rhs  right-hand value\n      * @return this - used to chain append calls\n      */\n-    public CompareToBuilder append(char lhs, char rhs) {\n+    public CompareToBuilder append(final char lhs, final char rhs) {\n         if (comparison != 0) {\n             return this;\n         }\n      * @param rhs  right-hand value\n      * @return this - used to chain append calls\n      */\n-    public CompareToBuilder append(byte lhs, byte rhs) {\n+    public CompareToBuilder append(final byte lhs, final byte rhs) {\n         if (comparison != 0) {\n             return this;\n         }\n      * @param rhs  right-hand value\n      * @return this - used to chain append calls\n      */\n-    public CompareToBuilder append(double lhs, double rhs) {\n+    public CompareToBuilder append(final double lhs, final double rhs) {\n         if (comparison != 0) {\n             return this;\n         }\n      * @param rhs  right-hand value\n      * @return this - used to chain append calls\n      */\n-    public CompareToBuilder append(float lhs, float rhs) {\n+    public CompareToBuilder append(final float lhs, final float rhs) {\n         if (comparison != 0) {\n             return this;\n         }\n      * @param rhs  right-hand value\n      * @return this - used to chain append calls\n       */\n-    public CompareToBuilder append(boolean lhs, boolean rhs) {\n+    public CompareToBuilder append(final boolean lhs, final boolean rhs) {\n         if (comparison != 0) {\n             return this;\n         }\n      * @throws ClassCastException  if <code>rhs</code> is not assignment-compatible\n      *  with <code>lhs</code>\n      */\n-    public CompareToBuilder append(Object[] lhs, Object[] rhs) {\n+    public CompareToBuilder append(final Object[] lhs, final Object[] rhs) {\n         return append(lhs, rhs, null);\n     }\n     \n      *  with <code>lhs</code>\n      * @since 2.0\n      */\n-    public CompareToBuilder append(Object[] lhs, Object[] rhs, Comparator<?> comparator) {\n+    public CompareToBuilder append(final Object[] lhs, final Object[] rhs, final Comparator<?> comparator) {\n         if (comparison != 0) {\n             return this;\n         }\n      * @param rhs  right-hand array\n      * @return this - used to chain append calls\n      */\n-    public CompareToBuilder append(long[] lhs, long[] rhs) {\n+    public CompareToBuilder append(final long[] lhs, final long[] rhs) {\n         if (comparison != 0) {\n             return this;\n         }\n      * @param rhs  right-hand array\n      * @return this - used to chain append calls\n      */\n-    public CompareToBuilder append(int[] lhs, int[] rhs) {\n+    public CompareToBuilder append(final int[] lhs, final int[] rhs) {\n         if (comparison != 0) {\n             return this;\n         }\n      * @param rhs  right-hand array\n      * @return this - used to chain append calls\n      */\n-    public CompareToBuilder append(short[] lhs, short[] rhs) {\n+    public CompareToBuilder append(final short[] lhs, final short[] rhs) {\n         if (comparison != 0) {\n             return this;\n         }\n      * @param rhs  right-hand array\n      * @return this - used to chain append calls\n      */\n-    public CompareToBuilder append(char[] lhs, char[] rhs) {\n+    public CompareToBuilder append(final char[] lhs, final char[] rhs) {\n         if (comparison != 0) {\n             return this;\n         }\n      * @param rhs  right-hand array\n      * @return this - used to chain append calls\n      */\n-    public CompareToBuilder append(byte[] lhs, byte[] rhs) {\n+    public CompareToBuilder append(final byte[] lhs, final byte[] rhs) {\n         if (comparison != 0) {\n             return this;\n         }\n      * @param rhs  right-hand array\n      * @return this - used to chain append calls\n      */\n-    public CompareToBuilder append(double[] lhs, double[] rhs) {\n+    public CompareToBuilder append(final double[] lhs, final double[] rhs) {\n         if (comparison != 0) {\n             return this;\n         }\n      * @param rhs  right-hand array\n      * @return this - used to chain append calls\n      */\n-    public CompareToBuilder append(float[] lhs, float[] rhs) {\n+    public CompareToBuilder append(final float[] lhs, final float[] rhs) {\n         if (comparison != 0) {\n             return this;\n         }\n      * @param rhs  right-hand array\n      * @return this - used to chain append calls\n      */\n-    public CompareToBuilder append(boolean[] lhs, boolean[] rhs) {\n+    public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) {\n         if (comparison != 0) {\n             return this;\n         }\n--- a/src/main/java/org/apache/commons/lang3/builder/EqualsBuilder.java\n+++ b/src/main/java/org/apache/commons/lang3/builder/EqualsBuilder.java\n      *\n      * @return the pair\n      */\n-    static Pair<IDKey, IDKey> getRegisterPair(Object lhs, Object rhs) {\n+    static Pair<IDKey, IDKey> getRegisterPair(final Object lhs, final Object rhs) {\n         IDKey left = new IDKey(lhs);\n         IDKey right = new IDKey(rhs);\n         return Pair.of(left, right);\n      * @return boolean <code>true</code> if the registry contains the given object.\n      * @since 3.0\n      */\n-    static boolean isRegistered(Object lhs, Object rhs) {\n+    static boolean isRegistered(final Object lhs, final Object rhs) {\n         Set<Pair<IDKey, IDKey>> registry = getRegistry();\n         Pair<IDKey, IDKey> pair = getRegisterPair(lhs, rhs);\n         Pair<IDKey, IDKey> swappedPair = Pair.of(pair.getLeft(), pair.getRight());\n      * @param lhs <code>this</code> object to register\n      * @param rhs the other object to register\n      */\n-    static void register(Object lhs, Object rhs) {\n+    static void register(final Object lhs, final Object rhs) {\n         synchronized (EqualsBuilder.class) {\n             if (getRegistry() == null) {\n                 REGISTRY.set(new HashSet<Pair<IDKey, IDKey>>());\n      * @param rhs the other object to unregister\n      * @since 3.0\n      */\n-    static void unregister(Object lhs, Object rhs) {\n+    static void unregister(final Object lhs, final Object rhs) {\n         Set<Pair<IDKey, IDKey>> registry = getRegistry();\n         if (registry != null) {\n             Pair<IDKey, IDKey> pair = getRegisterPair(lhs, rhs);\n      * @param excludeFields  Collection of String field names to exclude from testing\n      * @return <code>true</code> if the two Objects have tested equals.\n      */\n-    public static boolean reflectionEquals(Object lhs, Object rhs, Collection<String> excludeFields) {\n+    public static boolean reflectionEquals(final Object lhs, final Object rhs, final Collection<String> excludeFields) {\n         return reflectionEquals(lhs, rhs, ReflectionToStringBuilder.toNoNullStringArray(excludeFields));\n     }\n \n      * @param excludeFields  array of field names to exclude from testing\n      * @return <code>true</code> if the two Objects have tested equals.\n      */\n-    public static boolean reflectionEquals(Object lhs, Object rhs, String... excludeFields) {\n+    public static boolean reflectionEquals(final Object lhs, final Object rhs, final String... excludeFields) {\n         return reflectionEquals(lhs, rhs, false, null, excludeFields);\n     }\n \n      * @param testTransients  whether to include transient fields\n      * @return <code>true</code> if the two Objects have tested equals.\n      */\n-    public static boolean reflectionEquals(Object lhs, Object rhs, boolean testTransients) {\n+    public static boolean reflectionEquals(final Object lhs, final Object rhs, final boolean testTransients) {\n         return reflectionEquals(lhs, rhs, testTransients, null);\n     }\n \n      * @return <code>true</code> if the two Objects have tested equals.\n      * @since 2.0\n      */\n-    public static boolean reflectionEquals(Object lhs, Object rhs, boolean testTransients, Class<?> reflectUpToClass,\n-            String... excludeFields) {\n+    public static boolean reflectionEquals(final Object lhs, final Object rhs, final boolean testTransients, final Class<?> reflectUpToClass,\n+            final String... excludeFields) {\n         if (lhs == rhs) {\n             return true;\n         }\n      * @param excludeFields  array of field names to exclude from testing\n      */\n     private static void reflectionAppend(\n-        Object lhs,\n-        Object rhs,\n-        Class<?> clazz,\n-        EqualsBuilder builder,\n-        boolean useTransients,\n-        String[] excludeFields) {\n+        final Object lhs,\n+        final Object rhs,\n+        final Class<?> clazz,\n+        final EqualsBuilder builder,\n+        final boolean useTransients,\n+        final String[] excludeFields) {\n \n         if (isRegistered(lhs, rhs)) {\n             return;\n      * @return EqualsBuilder - used to chain calls.\n      * @since 2.0\n      */\n-    public EqualsBuilder appendSuper(boolean superEquals) {\n+    public EqualsBuilder appendSuper(final boolean superEquals) {\n         if (isEquals == false) {\n             return this;\n         }\n      * @param rhs  the right hand object\n      * @return EqualsBuilder - used to chain calls.\n      */\n-    public EqualsBuilder append(Object lhs, Object rhs) {\n+    public EqualsBuilder append(final Object lhs, final Object rhs) {\n         if (isEquals == false) {\n             return this;\n         }\n      *                  the right hand <code>long</code>\n      * @return EqualsBuilder - used to chain calls.\n      */\n-    public EqualsBuilder append(long lhs, long rhs) {\n+    public EqualsBuilder append(final long lhs, final long rhs) {\n         if (isEquals == false) {\n             return this;\n         }\n      * @param rhs  the right hand <code>int</code>\n      * @return EqualsBuilder - used to chain calls.\n      */\n-    public EqualsBuilder append(int lhs, int rhs) {\n+    public EqualsBuilder append(final int lhs, final int rhs) {\n         if (isEquals == false) {\n             return this;\n         }\n      * @param rhs  the right hand <code>short</code>\n      * @return EqualsBuilder - used to chain calls.\n      */\n-    public EqualsBuilder append(short lhs, short rhs) {\n+    public EqualsBuilder append(final short lhs, final short rhs) {\n         if (isEquals == false) {\n             return this;\n         }\n      * @param rhs  the right hand <code>char</code>\n      * @return EqualsBuilder - used to chain calls.\n      */\n-    public EqualsBuilder append(char lhs, char rhs) {\n+    public EqualsBuilder append(final char lhs, final char rhs) {\n         if (isEquals == false) {\n             return this;\n         }\n      * @param rhs  the right hand <code>byte</code>\n      * @return EqualsBuilder - used to chain calls.\n      */\n-    public EqualsBuilder append(byte lhs, byte rhs) {\n+    public EqualsBuilder append(final byte lhs, final byte rhs) {\n         if (isEquals == false) {\n             return this;\n         }\n      * @param rhs  the right hand <code>double</code>\n      * @return EqualsBuilder - used to chain calls.\n      */\n-    public EqualsBuilder append(double lhs, double rhs) {\n+    public EqualsBuilder append(final double lhs, final double rhs) {\n         if (isEquals == false) {\n             return this;\n         }\n      * @param rhs  the right hand <code>float</code>\n      * @return EqualsBuilder - used to chain calls.\n      */\n-    public EqualsBuilder append(float lhs, float rhs) {\n+    public EqualsBuilder append(final float lhs, final float rhs) {\n         if (isEquals == false) {\n             return this;\n         }\n      * @param rhs  the right hand <code>boolean</code>\n      * @return EqualsBuilder - used to chain calls.\n       */\n-    public EqualsBuilder append(boolean lhs, boolean rhs) {\n+    public EqualsBuilder append(final boolean lhs, final boolean rhs) {\n         if (isEquals == false) {\n             return this;\n         }\n      * @param rhs  the right hand <code>Object[]</code>\n      * @return EqualsBuilder - used to chain calls.\n      */\n-    public EqualsBuilder append(Object[] lhs, Object[] rhs) {\n+    public EqualsBuilder append(final Object[] lhs, final Object[] rhs) {\n         if (isEquals == false) {\n             return this;\n         }\n      * @param rhs  the right hand <code>long[]</code>\n      * @return EqualsBuilder - used to chain calls.\n      */\n-    public EqualsBuilder append(long[] lhs, long[] rhs) {\n+    public EqualsBuilder append(final long[] lhs, final long[] rhs) {\n         if (isEquals == false) {\n             return this;\n         }\n      * @param rhs  the right hand <code>int[]</code>\n      * @return EqualsBuilder - used to chain calls.\n      */\n-    public EqualsBuilder append(int[] lhs, int[] rhs) {\n+    public EqualsBuilder append(final int[] lhs, final int[] rhs) {\n         if (isEquals == false) {\n             return this;\n         }\n      * @param rhs  the right hand <code>short[]</code>\n      * @return EqualsBuilder - used to chain calls.\n      */\n-    public EqualsBuilder append(short[] lhs, short[] rhs) {\n+    public EqualsBuilder append(final short[] lhs, final short[] rhs) {\n         if (isEquals == false) {\n             return this;\n         }\n      * @param rhs  the right hand <code>char[]</code>\n      * @return EqualsBuilder - used to chain calls.\n      */\n-    public EqualsBuilder append(char[] lhs, char[] rhs) {\n+    public EqualsBuilder append(final char[] lhs, final char[] rhs) {\n         if (isEquals == false) {\n             return this;\n         }\n      * @param rhs  the right hand <code>byte[]</code>\n      * @return EqualsBuilder - used to chain calls.\n      */\n-    public EqualsBuilder append(byte[] lhs, byte[] rhs) {\n+    public EqualsBuilder append(final byte[] lhs, final byte[] rhs) {\n         if (isEquals == false) {\n             return this;\n         }\n      * @param rhs  the right hand <code>double[]</code>\n      * @return EqualsBuilder - used to chain calls.\n      */\n-    public EqualsBuilder append(double[] lhs, double[] rhs) {\n+    public EqualsBuilder append(final double[] lhs, final double[] rhs) {\n         if (isEquals == false) {\n             return this;\n         }\n      * @param rhs  the right hand <code>float[]</code>\n      * @return EqualsBuilder - used to chain calls.\n      */\n-    public EqualsBuilder append(float[] lhs, float[] rhs) {\n+    public EqualsBuilder append(final float[] lhs, final float[] rhs) {\n         if (isEquals == false) {\n             return this;\n         }\n      * @param rhs  the right hand <code>boolean[]</code>\n      * @return EqualsBuilder - used to chain calls.\n      */\n-    public EqualsBuilder append(boolean[] lhs, boolean[] rhs) {\n+    public EqualsBuilder append(final boolean[] lhs, final boolean[] rhs) {\n         if (isEquals == false) {\n             return this;\n         }\n      * @param isEquals The value to set.\n      * @since 2.1\n      */\n-    protected void setEquals(boolean isEquals) {\n+    protected void setEquals(final boolean isEquals) {\n         this.isEquals = isEquals;\n     }\n \n--- a/src/main/java/org/apache/commons/lang3/builder/HashCodeBuilder.java\n+++ b/src/main/java/org/apache/commons/lang3/builder/HashCodeBuilder.java\n      * @return boolean <code>true</code> if the registry contains the given object.\n      * @since 2.3\n      */\n-    static boolean isRegistered(Object value) {\n+    static boolean isRegistered(final Object value) {\n         Set<IDKey> registry = getRegistry();\n         return registry != null && registry.contains(new IDKey(value));\n     }\n      * @param excludeFields\n      *            Collection of String field names to exclude from use in calculation of hash code\n      */\n-    private static void reflectionAppend(Object object, Class<?> clazz, HashCodeBuilder builder, boolean useTransients,\n-            String[] excludeFields) {\n+    private static void reflectionAppend(final Object object, final Class<?> clazz, final HashCodeBuilder builder, final boolean useTransients,\n+            final String[] excludeFields) {\n         if (isRegistered(object)) {\n             return;\n         }\n      * @throws IllegalArgumentException\n      *             if the number is zero or even\n      */\n-    public static int reflectionHashCode(int initialNonZeroOddNumber, int multiplierNonZeroOddNumber, Object object) {\n+    public static int reflectionHashCode(final int initialNonZeroOddNumber, final int multiplierNonZeroOddNumber, final Object object) {\n         return reflectionHashCode(initialNonZeroOddNumber, multiplierNonZeroOddNumber, object, false, null);\n     }\n \n      * @throws IllegalArgumentException\n      *             if the number is zero or even\n      */\n-    public static int reflectionHashCode(int initialNonZeroOddNumber, int multiplierNonZeroOddNumber, Object object,\n-            boolean testTransients) {\n+    public static int reflectionHashCode(final int initialNonZeroOddNumber, final int multiplierNonZeroOddNumber, final Object object,\n+            final boolean testTransients) {\n         return reflectionHashCode(initialNonZeroOddNumber, multiplierNonZeroOddNumber, object, testTransients, null);\n     }\n \n      *             if the number is zero or even\n      * @since 2.0\n      */\n-    public static <T> int reflectionHashCode(int initialNonZeroOddNumber, int multiplierNonZeroOddNumber, T object,\n-            boolean testTransients, Class<? super T> reflectUpToClass, String... excludeFields) {\n+    public static <T> int reflectionHashCode(final int initialNonZeroOddNumber, final int multiplierNonZeroOddNumber, final T object,\n+            final boolean testTransients, final Class<? super T> reflectUpToClass, final String... excludeFields) {\n \n         if (object == null) {\n             throw new IllegalArgumentException(\"The object to build a hash code for must not be null\");\n      * @throws IllegalArgumentException\n      *             if the object is <code>null</code>\n      */\n-    public static int reflectionHashCode(Object object, boolean testTransients) {\n+    public static int reflectionHashCode(final Object object, final boolean testTransients) {\n         return reflectionHashCode(17, 37, object, testTransients, null);\n     }\n \n      * @throws IllegalArgumentException\n      *             if the object is <code>null</code>\n      */\n-    public static int reflectionHashCode(Object object, Collection<String> excludeFields) {\n+    public static int reflectionHashCode(final Object object, final Collection<String> excludeFields) {\n         return reflectionHashCode(object, ReflectionToStringBuilder.toNoNullStringArray(excludeFields));\n     }\n \n      * @throws IllegalArgumentException\n      *             if the object is <code>null</code>\n      */\n-    public static int reflectionHashCode(Object object, String... excludeFields) {\n+    public static int reflectionHashCode(final Object object, final String... excludeFields) {\n         return reflectionHashCode(17, 37, object, false, null, excludeFields);\n     }\n \n      * @param value\n      *            The object to register.\n      */\n-    static void register(Object value) {\n+    static void register(final Object value) {\n         synchronized (HashCodeBuilder.class) {\n             if (getRegistry() == null) {\n                 REGISTRY.set(new HashSet<IDKey>());\n      *            The object to unregister.\n      * @since 2.3\n      */\n-    static void unregister(Object value) {\n+    static void unregister(final Object value) {\n         Set<IDKey> registry = getRegistry();\n         if (registry != null) {\n             registry.remove(new IDKey(value));\n      * @throws IllegalArgumentException\n      *             if the number is zero or even\n      */\n-    public HashCodeBuilder(int initialNonZeroOddNumber, int multiplierNonZeroOddNumber) {\n+    public HashCodeBuilder(final int initialNonZeroOddNumber, final int multiplierNonZeroOddNumber) {\n         if (initialNonZeroOddNumber == 0) {\n             throw new IllegalArgumentException(\"HashCodeBuilder requires a non zero initial value\");\n         }\n      *            the boolean to add to the <code>hashCode</code>\n      * @return this\n      */\n-    public HashCodeBuilder append(boolean value) {\n+    public HashCodeBuilder append(final boolean value) {\n         iTotal = iTotal * iConstant + (value ? 0 : 1);\n         return this;\n     }\n      *            the array to add to the <code>hashCode</code>\n      * @return this\n      */\n-    public HashCodeBuilder append(boolean[] array) {\n+    public HashCodeBuilder append(final boolean[] array) {\n         if (array == null) {\n             iTotal = iTotal * iConstant;\n         } else {\n      *            the byte to add to the <code>hashCode</code>\n      * @return this\n      */\n-    public HashCodeBuilder append(byte value) {\n+    public HashCodeBuilder append(final byte value) {\n         iTotal = iTotal * iConstant + value;\n         return this;\n     }\n      *            the array to add to the <code>hashCode</code>\n      * @return this\n      */\n-    public HashCodeBuilder append(byte[] array) {\n+    public HashCodeBuilder append(final byte[] array) {\n         if (array == null) {\n             iTotal = iTotal * iConstant;\n         } else {\n      *            the char to add to the <code>hashCode</code>\n      * @return this\n      */\n-    public HashCodeBuilder append(char value) {\n+    public HashCodeBuilder append(final char value) {\n         iTotal = iTotal * iConstant + value;\n         return this;\n     }\n      *            the array to add to the <code>hashCode</code>\n      * @return this\n      */\n-    public HashCodeBuilder append(char[] array) {\n+    public HashCodeBuilder append(final char[] array) {\n         if (array == null) {\n             iTotal = iTotal * iConstant;\n         } else {\n      *            the double to add to the <code>hashCode</code>\n      * @return this\n      */\n-    public HashCodeBuilder append(double value) {\n+    public HashCodeBuilder append(final double value) {\n         return append(Double.doubleToLongBits(value));\n     }\n \n      *            the array to add to the <code>hashCode</code>\n      * @return this\n      */\n-    public HashCodeBuilder append(double[] array) {\n+    public HashCodeBuilder append(final double[] array) {\n         if (array == null) {\n             iTotal = iTotal * iConstant;\n         } else {\n      *            the float to add to the <code>hashCode</code>\n      * @return this\n      */\n-    public HashCodeBuilder append(float value) {\n+    public HashCodeBuilder append(final float value) {\n         iTotal = iTotal * iConstant + Float.floatToIntBits(value);\n         return this;\n     }\n      *            the array to add to the <code>hashCode</code>\n      * @return this\n      */\n-    public HashCodeBuilder append(float[] array) {\n+    public HashCodeBuilder append(final float[] array) {\n         if (array == null) {\n             iTotal = iTotal * iConstant;\n         } else {\n      *            the int to add to the <code>hashCode</code>\n      * @return this\n      */\n-    public HashCodeBuilder append(int value) {\n+    public HashCodeBuilder append(final int value) {\n         iTotal = iTotal * iConstant + value;\n         return this;\n     }\n      *            the array to add to the <code>hashCode</code>\n      * @return this\n      */\n-    public HashCodeBuilder append(int[] array) {\n+    public HashCodeBuilder append(final int[] array) {\n         if (array == null) {\n             iTotal = iTotal * iConstant;\n         } else {\n     //       Long.hashCode do. Ideally we should switch to >>> at\n     //       some stage. There are backwards compat issues, so\n     //       that will have to wait for the time being. cf LANG-342.\n-    public HashCodeBuilder append(long value) {\n+    public HashCodeBuilder append(final long value) {\n         iTotal = iTotal * iConstant + ((int) (value ^ (value >> 32)));\n         return this;\n     }\n      *            the array to add to the <code>hashCode</code>\n      * @return this\n      */\n-    public HashCodeBuilder append(long[] array) {\n+    public HashCodeBuilder append(final long[] array) {\n         if (array == null) {\n             iTotal = iTotal * iConstant;\n         } else {\n      *            the Object to add to the <code>hashCode</code>\n      * @return this\n      */\n-    public HashCodeBuilder append(Object object) {\n+    public HashCodeBuilder append(final Object object) {\n         if (object == null) {\n             iTotal = iTotal * iConstant;\n \n      *            the array to add to the <code>hashCode</code>\n      * @return this\n      */\n-    public HashCodeBuilder append(Object[] array) {\n+    public HashCodeBuilder append(final Object[] array) {\n         if (array == null) {\n             iTotal = iTotal * iConstant;\n         } else {\n      *            the short to add to the <code>hashCode</code>\n      * @return this\n      */\n-    public HashCodeBuilder append(short value) {\n+    public HashCodeBuilder append(final short value) {\n         iTotal = iTotal * iConstant + value;\n         return this;\n     }\n      *            the array to add to the <code>hashCode</code>\n      * @return this\n      */\n-    public HashCodeBuilder append(short[] array) {\n+    public HashCodeBuilder append(final short[] array) {\n         if (array == null) {\n             iTotal = iTotal * iConstant;\n         } else {\n      * @return this HashCodeBuilder, used to chain calls.\n      * @since 2.0\n      */\n-    public HashCodeBuilder appendSuper(int superHashCode) {\n+    public HashCodeBuilder appendSuper(final int superHashCode) {\n         iTotal = iTotal * iConstant + superHashCode;\n         return this;\n     }\n--- a/src/main/java/org/apache/commons/lang3/builder/IDKey.java\n+++ b/src/main/java/org/apache/commons/lang3/builder/IDKey.java\n          * Constructor for IDKey\n          * @param _value The value\n          */ \n-        public IDKey(Object _value) {\n+        public IDKey(final Object _value) {\n             // This is the Object hashcode \n             id = System.identityHashCode(_value);  \n             // There have been some cases (LANG-459) that return the \n          * @return if the instances are for the same object\n          */ \n         @Override\n-        public boolean equals(Object other) {\n+        public boolean equals(final Object other) {\n             if (!(other instanceof IDKey)) {\n                 return false;\n             }\n--- a/src/main/java/org/apache/commons/lang3/builder/ReflectionToStringBuilder.java\n+++ b/src/main/java/org/apache/commons/lang3/builder/ReflectionToStringBuilder.java\n      * @throws IllegalArgumentException\n      *             if the Object is <code>null</code>\n      */\n-    public static String toString(Object object) {\n+    public static String toString(final Object object) {\n         return toString(object, null, false, false, null);\n     }\n \n      * @throws IllegalArgumentException\n      *             if the Object or <code>ToStringStyle</code> is <code>null</code>\n      */\n-    public static String toString(Object object, ToStringStyle style) {\n+    public static String toString(final Object object, final ToStringStyle style) {\n         return toString(object, style, false, false, null);\n     }\n \n      * @throws IllegalArgumentException\n      *             if the Object is <code>null</code>\n      */\n-    public static String toString(Object object, ToStringStyle style, boolean outputTransients) {\n+    public static String toString(final Object object, final ToStringStyle style, final boolean outputTransients) {\n         return toString(object, style, outputTransients, false, null);\n     }\n \n      *             if the Object is <code>null</code>\n      * @since 2.1\n      */\n-    public static String toString(Object object, ToStringStyle style, boolean outputTransients, boolean outputStatics) {\n+    public static String toString(final Object object, final ToStringStyle style, final boolean outputTransients, final boolean outputStatics) {\n         return toString(object, style, outputTransients, outputStatics, null);\n     }\n \n      * @since 2.1\n      */\n     public static <T> String toString(\n-            T object, ToStringStyle style, boolean outputTransients,\n-            boolean outputStatics, Class<? super T> reflectUpToClass) {\n+            final T object, final ToStringStyle style, final boolean outputTransients,\n+            final boolean outputStatics, final Class<? super T> reflectUpToClass) {\n         return new ReflectionToStringBuilder(object, style, null, reflectUpToClass, outputTransients, outputStatics)\n                 .toString();\n     }\n      *            The field names to exclude. Null excludes nothing.\n      * @return The toString value.\n      */\n-    public static String toStringExclude(Object object, Collection<String> excludeFieldNames) {\n+    public static String toStringExclude(final Object object, final Collection<String> excludeFieldNames) {\n         return toStringExclude(object, toNoNullStringArray(excludeFieldNames));\n     }\n \n      *            The collection to convert\n      * @return A new array of Strings.\n      */\n-    static String[] toNoNullStringArray(Collection<String> collection) {\n+    static String[] toNoNullStringArray(final Collection<String> collection) {\n         if (collection == null) {\n             return ArrayUtils.EMPTY_STRING_ARRAY;\n         }\n      *            The array to check\n      * @return The given array or a new array without null.\n      */\n-    static String[] toNoNullStringArray(Object[] array) {\n+    static String[] toNoNullStringArray(final Object[] array) {\n         List<String> list = new ArrayList<String>(array.length);\n         for (Object e : array) {\n             if (e != null) {\n      *            The field names to exclude\n      * @return The toString value.\n      */\n-    public static String toStringExclude(Object object, String... excludeFieldNames) {\n+    public static String toStringExclude(final Object object, final String... excludeFieldNames) {\n         return new ReflectionToStringBuilder(object).setExcludeFieldNames(excludeFieldNames).toString();\n     }\n \n      * @throws IllegalArgumentException\n      *             if the Object passed in is <code>null</code>\n      */\n-    public ReflectionToStringBuilder(Object object) {\n+    public ReflectionToStringBuilder(final Object object) {\n         super(object);\n     }\n \n      * @throws IllegalArgumentException\n      *             if the Object passed in is <code>null</code>\n      */\n-    public ReflectionToStringBuilder(Object object, ToStringStyle style) {\n+    public ReflectionToStringBuilder(final Object object, final ToStringStyle style) {\n         super(object, style);\n     }\n \n      * @throws IllegalArgumentException\n      *             if the Object passed in is <code>null</code>\n      */\n-    public ReflectionToStringBuilder(Object object, ToStringStyle style, StringBuffer buffer) {\n+    public ReflectionToStringBuilder(final Object object, final ToStringStyle style, final StringBuffer buffer) {\n         super(object, style, buffer);\n     }\n \n      * @since 2.1\n      */\n     public <T> ReflectionToStringBuilder(\n-            T object, ToStringStyle style, StringBuffer buffer,\n-            Class<? super T> reflectUpToClass, boolean outputTransients, boolean outputStatics) {\n+            final T object, final ToStringStyle style, final StringBuffer buffer,\n+            final Class<? super T> reflectUpToClass, final boolean outputTransients, final boolean outputStatics) {\n         super(object, style, buffer);\n         this.setUpToClass(reflectUpToClass);\n         this.setAppendTransients(outputTransients);\n      *            The Field to test.\n      * @return Whether or not to append the given <code>Field</code>.\n      */\n-    protected boolean accept(Field field) {\n+    protected boolean accept(final Field field) {\n         if (field.getName().indexOf(ClassUtils.INNER_CLASS_SEPARATOR_CHAR) != -1) {\n             // Reject field from inner class.\n             return false;\n      * @param clazz\n      *            The class of object parameter\n      */\n-    protected void appendFieldsIn(Class<?> clazz) {\n+    protected void appendFieldsIn(final Class<?> clazz) {\n         if (clazz.isArray()) {\n             this.reflectionAppendArray(this.getObject());\n             return;\n      *\n      * @see java.lang.reflect.Field#get(Object)\n      */\n-    protected Object getValue(Field field) throws IllegalArgumentException, IllegalAccessException {\n+    protected Object getValue(final Field field) throws IllegalArgumentException, IllegalAccessException {\n         return field.get(this.getObject());\n     }\n \n      *            the array to add to the <code>toString</code>\n      * @return this\n      */\n-    public ReflectionToStringBuilder reflectionAppendArray(Object array) {\n+    public ReflectionToStringBuilder reflectionAppendArray(final Object array) {\n         this.getStyle().reflectionAppendArrayDetail(this.getStringBuffer(), null, array);\n         return this;\n     }\n      *            Whether or not to append static fields.\n      * @since 2.1\n      */\n-    public void setAppendStatics(boolean appendStatics) {\n+    public void setAppendStatics(final boolean appendStatics) {\n         this.appendStatics = appendStatics;\n     }\n \n      * @param appendTransients\n      *            Whether or not to append transient fields.\n      */\n-    public void setAppendTransients(boolean appendTransients) {\n+    public void setAppendTransients(final boolean appendTransients) {\n         this.appendTransients = appendTransients;\n     }\n \n      *            The excludeFieldNames to excluding from toString or <code>null</code>.\n      * @return <code>this</code>\n      */\n-    public ReflectionToStringBuilder setExcludeFieldNames(String... excludeFieldNamesParam) {\n+    public ReflectionToStringBuilder setExcludeFieldNames(final String... excludeFieldNamesParam) {\n         if (excludeFieldNamesParam == null) {\n             this.excludeFieldNames = null;\n         } else {\n      * @param clazz\n      *            The last super class to stop appending fields for.\n      */\n-    public void setUpToClass(Class<?> clazz) {\n+    public void setUpToClass(final Class<?> clazz) {\n         if (clazz != null) {\n             Object object = getObject();\n             if (object != null && clazz.isInstance(object) == false) {\n--- a/src/main/java/org/apache/commons/lang3/builder/StandardToStringStyle.java\n+++ b/src/main/java/org/apache/commons/lang3/builder/StandardToStringStyle.java\n      * @param useClassName  the new useClassName flag\n      */\n     @Override\n-    public void setUseClassName(boolean useClassName) { // NOPMD as this is implementing the abstract class\n+    public void setUseClassName(final boolean useClassName) { // NOPMD as this is implementing the abstract class\n         super.setUseClassName(useClassName);\n     }\n \n      * @since 2.0\n      */\n     @Override\n-    public void setUseShortClassName(boolean useShortClassName) { // NOPMD as this is implementing the abstract class\n+    public void setUseShortClassName(final boolean useShortClassName) { // NOPMD as this is implementing the abstract class\n         super.setUseShortClassName(useShortClassName);\n     }\n \n      * @param useIdentityHashCode  the new useIdentityHashCode flag\n      */\n     @Override\n-    public void setUseIdentityHashCode(boolean useIdentityHashCode) { // NOPMD as this is implementing the abstract class\n+    public void setUseIdentityHashCode(final boolean useIdentityHashCode) { // NOPMD as this is implementing the abstract class\n         super.setUseIdentityHashCode(useIdentityHashCode);\n     }\n \n      * @param useFieldNames  the new useFieldNames flag\n      */\n     @Override\n-    public void setUseFieldNames(boolean useFieldNames) { // NOPMD as this is implementing the abstract class\n+    public void setUseFieldNames(final boolean useFieldNames) { // NOPMD as this is implementing the abstract class\n         super.setUseFieldNames(useFieldNames);\n     }\n \n      * @param defaultFullDetail  the new defaultFullDetail flag\n      */\n     @Override\n-    public void setDefaultFullDetail(boolean defaultFullDetail) { // NOPMD as this is implementing the abstract class\n+    public void setDefaultFullDetail(final boolean defaultFullDetail) { // NOPMD as this is implementing the abstract class\n         super.setDefaultFullDetail(defaultFullDetail);\n     }\n \n      * @param arrayContentDetail  the new arrayContentDetail flag\n      */\n     @Override\n-    public void setArrayContentDetail(boolean arrayContentDetail) { // NOPMD as this is implementing the abstract class\n+    public void setArrayContentDetail(final boolean arrayContentDetail) { // NOPMD as this is implementing the abstract class\n         super.setArrayContentDetail(arrayContentDetail);\n     }\n \n      * @param arrayStart  the new array start text\n      */\n     @Override\n-    public void setArrayStart(String arrayStart) { // NOPMD as this is implementing the abstract class\n+    public void setArrayStart(final String arrayStart) { // NOPMD as this is implementing the abstract class\n         super.setArrayStart(arrayStart);\n     }\n \n      * @param arrayEnd  the new array end text\n      */\n     @Override\n-    public void setArrayEnd(String arrayEnd) { // NOPMD as this is implementing the abstract class\n+    public void setArrayEnd(final String arrayEnd) { // NOPMD as this is implementing the abstract class\n         super.setArrayEnd(arrayEnd);\n     }\n \n      * @param arraySeparator  the new array separator text\n      */\n     @Override\n-    public void setArraySeparator(String arraySeparator) { // NOPMD as this is implementing the abstract class\n+    public void setArraySeparator(final String arraySeparator) { // NOPMD as this is implementing the abstract class\n         super.setArraySeparator(arraySeparator);\n     }\n \n      * @param contentStart  the new content start text\n      */\n     @Override\n-    public void setContentStart(String contentStart) { // NOPMD as this is implementing the abstract class\n+    public void setContentStart(final String contentStart) { // NOPMD as this is implementing the abstract class\n         super.setContentStart(contentStart);\n     }\n \n      * @param contentEnd  the new content end text\n      */\n     @Override\n-    public void setContentEnd(String contentEnd) { // NOPMD as this is implementing the abstract class\n+    public void setContentEnd(final String contentEnd) { // NOPMD as this is implementing the abstract class\n         super.setContentEnd(contentEnd);\n     }\n \n      * @param fieldNameValueSeparator  the new field name value separator text\n      */\n     @Override\n-    public void setFieldNameValueSeparator(String fieldNameValueSeparator) { // NOPMD as this is implementing the abstract class\n+    public void setFieldNameValueSeparator(final String fieldNameValueSeparator) { // NOPMD as this is implementing the abstract class\n         super.setFieldNameValueSeparator(fieldNameValueSeparator);\n     }\n \n      * @param fieldSeparator  the new field separator text\n      */\n     @Override\n-    public void setFieldSeparator(String fieldSeparator) { // NOPMD as this is implementing the abstract class\n+    public void setFieldSeparator(final String fieldSeparator) { // NOPMD as this is implementing the abstract class\n         super.setFieldSeparator(fieldSeparator);\n     }\n \n      * @since 2.0\n      */\n     @Override\n-    public void setFieldSeparatorAtStart(boolean fieldSeparatorAtStart) { // NOPMD as this is implementing the abstract class\n+    public void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart) { // NOPMD as this is implementing the abstract class\n         super.setFieldSeparatorAtStart(fieldSeparatorAtStart);\n     }\n \n      * @since 2.0\n      */\n     @Override\n-    public void setFieldSeparatorAtEnd(boolean fieldSeparatorAtEnd) { // NOPMD as this is implementing the abstract class\n+    public void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd) { // NOPMD as this is implementing the abstract class\n         super.setFieldSeparatorAtEnd(fieldSeparatorAtEnd);\n     }\n \n      * @param nullText  the new text to output when <code>null</code> found\n      */\n     @Override\n-    public void setNullText(String nullText) { // NOPMD as this is implementing the abstract class\n+    public void setNullText(final String nullText) { // NOPMD as this is implementing the abstract class\n         super.setNullText(nullText);\n     }\n \n      * @param sizeStartText  the new start of size text\n      */\n     @Override\n-    public void setSizeStartText(String sizeStartText) { // NOPMD as this is implementing the abstract class\n+    public void setSizeStartText(final String sizeStartText) { // NOPMD as this is implementing the abstract class\n         super.setSizeStartText(sizeStartText);\n     }\n \n      * @param sizeEndText  the new end of size text\n      */\n     @Override\n-    public void setSizeEndText(String sizeEndText) { // NOPMD as this is implementing the abstract class\n+    public void setSizeEndText(final String sizeEndText) { // NOPMD as this is implementing the abstract class\n         super.setSizeEndText(sizeEndText);\n     }\n \n      * @param summaryObjectStartText  the new start of summary text\n      */\n     @Override\n-    public void setSummaryObjectStartText(String summaryObjectStartText) { // NOPMD as this is implementing the abstract class\n+    public void setSummaryObjectStartText(final String summaryObjectStartText) { // NOPMD as this is implementing the abstract class\n         super.setSummaryObjectStartText(summaryObjectStartText);\n     }\n \n      * @param summaryObjectEndText  the new end of summary text\n      */\n     @Override\n-    public void setSummaryObjectEndText(String summaryObjectEndText) { // NOPMD as this is implementing the abstract class\n+    public void setSummaryObjectEndText(final String summaryObjectEndText) { // NOPMD as this is implementing the abstract class\n         super.setSummaryObjectEndText(summaryObjectEndText);\n     }\n \n--- a/src/main/java/org/apache/commons/lang3/builder/ToStringBuilder.java\n+++ b/src/main/java/org/apache/commons/lang3/builder/ToStringBuilder.java\n      * @param style  the default <code>ToStringStyle</code>\n      * @throws IllegalArgumentException if the style is <code>null</code>\n      */\n-    public static void setDefaultStyle(ToStringStyle style) {\n+    public static void setDefaultStyle(final ToStringStyle style) {\n         if (style == null) {\n             throw new IllegalArgumentException(\"The style must not be null\");\n         }\n      * @return the String result\n      * @see ReflectionToStringBuilder#toString(Object)\n      */\n-    public static String reflectionToString(Object object) {\n+    public static String reflectionToString(final Object object) {\n         return ReflectionToStringBuilder.toString(object);\n     }\n \n      * @return the String result\n      * @see ReflectionToStringBuilder#toString(Object,ToStringStyle)\n      */\n-    public static String reflectionToString(Object object, ToStringStyle style) {\n+    public static String reflectionToString(final Object object, final ToStringStyle style) {\n         return ReflectionToStringBuilder.toString(object, style);\n     }\n \n      * @return the String result\n      * @see ReflectionToStringBuilder#toString(Object,ToStringStyle,boolean)\n      */\n-    public static String reflectionToString(Object object, ToStringStyle style, boolean outputTransients) {\n+    public static String reflectionToString(final Object object, final ToStringStyle style, final boolean outputTransients) {\n         return ReflectionToStringBuilder.toString(object, style, outputTransients, false, null);\n     }\n \n      * @since 2.0\n      */\n     public static <T> String reflectionToString(\n-        T object,\n-        ToStringStyle style,\n-        boolean outputTransients,\n-        Class<? super T> reflectUpToClass) {\n+        final T object,\n+        final ToStringStyle style,\n+        final boolean outputTransients,\n+        final Class<? super T> reflectUpToClass) {\n         return ReflectionToStringBuilder.toString(object, style, outputTransients, false, reflectUpToClass);\n     }\n \n      *\n      * @param object  the Object to build a <code>toString</code> for, not recommended to be null\n      */\n-    public ToStringBuilder(Object object) {\n+    public ToStringBuilder(final Object object) {\n         this(object, null, null);\n     }\n \n      * @param object  the Object to build a <code>toString</code> for, not recommended to be null\n      * @param style  the style of the <code>toString</code> to create, null uses the default style\n      */\n-    public ToStringBuilder(Object object, ToStringStyle style) {\n+    public ToStringBuilder(final Object object, final ToStringStyle style) {\n         this(object, style, null);\n     }\n \n      * @param style  the style of the <code>toString</code> to create, null uses the default style\n      * @param buffer  the <code>StringBuffer</code> to populate, may be null\n      */\n-    public ToStringBuilder(Object object, ToStringStyle style, StringBuffer buffer) {\n+    public ToStringBuilder(final Object object, ToStringStyle style, StringBuffer buffer) {\n         if (style == null) {\n             style = getDefaultStyle();\n         }\n      * @param value  the value to add to the <code>toString</code>\n      * @return this\n      */\n-    public ToStringBuilder append(boolean value) {\n+    public ToStringBuilder append(final boolean value) {\n         style.append(buffer, null, value);\n         return this;\n     }\n      * @param array  the array to add to the <code>toString</code>\n      * @return this\n      */\n-    public ToStringBuilder append(boolean[] array) {\n+    public ToStringBuilder append(final boolean[] array) {\n         style.append(buffer, null, array, null);\n         return this;\n     }\n      * @param value  the value to add to the <code>toString</code>\n      * @return this\n      */\n-    public ToStringBuilder append(byte value) {\n+    public ToStringBuilder append(final byte value) {\n         style.append(buffer, null, value);\n         return this;\n     }\n      * @param array  the array to add to the <code>toString</code>\n      * @return this\n      */\n-    public ToStringBuilder append(byte[] array) {\n+    public ToStringBuilder append(final byte[] array) {\n         style.append(buffer, null, array, null);\n         return this;\n     }\n      * @param value  the value to add to the <code>toString</code>\n      * @return this\n      */\n-    public ToStringBuilder append(char value) {\n+    public ToStringBuilder append(final char value) {\n         style.append(buffer, null, value);\n         return this;\n     }\n      * @param array  the array to add to the <code>toString</code>\n      * @return this\n      */\n-    public ToStringBuilder append(char[] array) {\n+    public ToStringBuilder append(final char[] array) {\n         style.append(buffer, null, array, null);\n         return this;\n     }\n      * @param value  the value to add to the <code>toString</code>\n      * @return this\n      */\n-    public ToStringBuilder append(double value) {\n+    public ToStringBuilder append(final double value) {\n         style.append(buffer, null, value);\n         return this;\n     }\n      * @param array  the array to add to the <code>toString</code>\n      * @return this\n      */\n-    public ToStringBuilder append(double[] array) {\n+    public ToStringBuilder append(final double[] array) {\n         style.append(buffer, null, array, null);\n         return this;\n     }\n      * @param value  the value to add to the <code>toString</code>\n      * @return this\n      */\n-    public ToStringBuilder append(float value) {\n+    public ToStringBuilder append(final float value) {\n         style.append(buffer, null, value);\n         return this;\n     }\n      * @param array  the array to add to the <code>toString</code>\n      * @return this\n      */\n-    public ToStringBuilder append(float[] array) {\n+    public ToStringBuilder append(final float[] array) {\n         style.append(buffer, null, array, null);\n         return this;\n     }\n      * @param value  the value to add to the <code>toString</code>\n      * @return this\n      */\n-    public ToStringBuilder append(int value) {\n+    public ToStringBuilder append(final int value) {\n         style.append(buffer, null, value);\n         return this;\n     }\n      * @param array  the array to add to the <code>toString</code>\n      * @return this\n      */\n-    public ToStringBuilder append(int[] array) {\n+    public ToStringBuilder append(final int[] array) {\n         style.append(buffer, null, array, null);\n         return this;\n     }\n      * @param value  the value to add to the <code>toString</code>\n      * @return this\n      */\n-    public ToStringBuilder append(long value) {\n+    public ToStringBuilder append(final long value) {\n         style.append(buffer, null, value);\n         return this;\n     }\n      * @param array  the array to add to the <code>toString</code>\n      * @return this\n      */\n-    public ToStringBuilder append(long[] array) {\n+    public ToStringBuilder append(final long[] array) {\n         style.append(buffer, null, array, null);\n         return this;\n     }\n      * @param obj  the value to add to the <code>toString</code>\n      * @return this\n      */\n-    public ToStringBuilder append(Object obj) {\n+    public ToStringBuilder append(final Object obj) {\n         style.append(buffer, null, obj, null);\n         return this;\n     }\n      * @param array  the array to add to the <code>toString</code>\n      * @return this\n      */\n-    public ToStringBuilder append(Object[] array) {\n+    public ToStringBuilder append(final Object[] array) {\n         style.append(buffer, null, array, null);\n         return this;\n     }\n      * @param value  the value to add to the <code>toString</code>\n      * @return this\n      */\n-    public ToStringBuilder append(short value) {\n+    public ToStringBuilder append(final short value) {\n         style.append(buffer, null, value);\n         return this;\n     }\n      * @param array  the array to add to the <code>toString</code>\n      * @return this\n      */\n-    public ToStringBuilder append(short[] array) {\n+    public ToStringBuilder append(final short[] array) {\n         style.append(buffer, null, array, null);\n         return this;\n     }\n      * @param value  the value to add to the <code>toString</code>\n      * @return this\n      */\n-    public ToStringBuilder append(String fieldName, boolean value) {\n+    public ToStringBuilder append(final String fieldName, final boolean value) {\n         style.append(buffer, fieldName, value);\n         return this;\n     }\n      * @param array  the array to add to the <code>hashCode</code>\n      * @return this\n      */\n-    public ToStringBuilder append(String fieldName, boolean[] array) {\n+    public ToStringBuilder append(final String fieldName, final boolean[] array) {\n         style.append(buffer, fieldName, array, null);\n         return this;\n     }\n      *  for summary info\n      * @return this\n      */\n-    public ToStringBuilder append(String fieldName, boolean[] array, boolean fullDetail) {\n+    public ToStringBuilder append(final String fieldName, final boolean[] array, final boolean fullDetail) {\n         style.append(buffer, fieldName, array, Boolean.valueOf(fullDetail));\n         return this;\n     }\n      * @param value  the value to add to the <code>toString</code>\n      * @return this\n      */\n-    public ToStringBuilder append(String fieldName, byte value) {\n+    public ToStringBuilder append(final String fieldName, final byte value) {\n         style.append(buffer, fieldName, value);\n         return this;\n     }\n      * @param array  the array to add to the <code>toString</code>\n      * @return this\n      */\n-    public ToStringBuilder append(String fieldName, byte[] array) {\n+    public ToStringBuilder append(final String fieldName, final byte[] array) {\n         style.append(buffer, fieldName, array, null);\n         return this;\n     }\n      *  for summary info\n      * @return this\n      */\n-    public ToStringBuilder append(String fieldName, byte[] array, boolean fullDetail) {\n+    public ToStringBuilder append(final String fieldName, final byte[] array, final boolean fullDetail) {\n         style.append(buffer, fieldName, array, Boolean.valueOf(fullDetail));\n         return this;\n     }\n      * @param value  the value to add to the <code>toString</code>\n      * @return this\n      */\n-    public ToStringBuilder append(String fieldName, char value) {\n+    public ToStringBuilder append(final String fieldName, final char value) {\n         style.append(buffer, fieldName, value);\n         return this;\n     }\n      * @param array  the array to add to the <code>toString</code>\n      * @return this\n      */\n-    public ToStringBuilder append(String fieldName, char[] array) {\n+    public ToStringBuilder append(final String fieldName, final char[] array) {\n         style.append(buffer, fieldName, array, null);\n         return this;\n     }\n      *  for summary info\n      * @return this\n      */\n-    public ToStringBuilder append(String fieldName, char[] array, boolean fullDetail) {\n+    public ToStringBuilder append(final String fieldName, final char[] array, final boolean fullDetail) {\n         style.append(buffer, fieldName, array, Boolean.valueOf(fullDetail));\n         return this;\n     }\n      * @param value  the value to add to the <code>toString</code>\n      * @return this\n      */\n-    public ToStringBuilder append(String fieldName, double value) {\n+    public ToStringBuilder append(final String fieldName, final double value) {\n         style.append(buffer, fieldName, value);\n         return this;\n     }\n      * @param array  the array to add to the <code>toString</code>\n      * @return this\n      */\n-    public ToStringBuilder append(String fieldName, double[] array) {\n+    public ToStringBuilder append(final String fieldName, final double[] array) {\n         style.append(buffer, fieldName, array, null);\n         return this;\n     }\n      *  for summary info\n      * @return this\n      */\n-    public ToStringBuilder append(String fieldName, double[] array, boolean fullDetail) {\n+    public ToStringBuilder append(final String fieldName, final double[] array, final boolean fullDetail) {\n         style.append(buffer, fieldName, array, Boolean.valueOf(fullDetail));\n         return this;\n     }\n      * @param value  the value to add to the <code>toString</code>\n      * @return this\n      */\n-    public ToStringBuilder append(String fieldName, float value) {\n+    public ToStringBuilder append(final String fieldName, final float value) {\n         style.append(buffer, fieldName, value);\n         return this;\n     }\n      * @param array  the array to add to the <code>toString</code>\n      * @return this\n      */\n-    public ToStringBuilder append(String fieldName, float[] array) {\n+    public ToStringBuilder append(final String fieldName, final float[] array) {\n         style.append(buffer, fieldName, array, null);\n         return this;\n     }\n      *  for summary info\n      * @return this\n      */\n-    public ToStringBuilder append(String fieldName, float[] array, boolean fullDetail) {\n+    public ToStringBuilder append(final String fieldName, final float[] array, final boolean fullDetail) {\n         style.append(buffer, fieldName, array, Boolean.valueOf(fullDetail));\n         return this;\n     }\n      * @param value  the value to add to the <code>toString</code>\n      * @return this\n      */\n-    public ToStringBuilder append(String fieldName, int value) {\n+    public ToStringBuilder append(final String fieldName, final int value) {\n         style.append(buffer, fieldName, value);\n         return this;\n     }\n      * @param array  the array to add to the <code>toString</code>\n      * @return this\n      */\n-    public ToStringBuilder append(String fieldName, int[] array) {\n+    public ToStringBuilder append(final String fieldName, final int[] array) {\n         style.append(buffer, fieldName, array, null);\n         return this;\n     }\n      *  for summary info\n      * @return this\n      */\n-    public ToStringBuilder append(String fieldName, int[] array, boolean fullDetail) {\n+    public ToStringBuilder append(final String fieldName, final int[] array, final boolean fullDetail) {\n         style.append(buffer, fieldName, array, Boolean.valueOf(fullDetail));\n         return this;\n     }\n      * @param value  the value to add to the <code>toString</code>\n      * @return this\n      */\n-    public ToStringBuilder append(String fieldName, long value) {\n+    public ToStringBuilder append(final String fieldName, final long value) {\n         style.append(buffer, fieldName, value);\n         return this;\n     }\n      * @param array  the array to add to the <code>toString</code>\n      * @return this\n      */\n-    public ToStringBuilder append(String fieldName, long[] array) {\n+    public ToStringBuilder append(final String fieldName, final long[] array) {\n         style.append(buffer, fieldName, array, null);\n         return this;\n     }\n      *  for summary info\n      * @return this\n      */\n-    public ToStringBuilder append(String fieldName, long[] array, boolean fullDetail) {\n+    public ToStringBuilder append(final String fieldName, final long[] array, final boolean fullDetail) {\n         style.append(buffer, fieldName, array, Boolean.valueOf(fullDetail));\n         return this;\n     }\n      * @param obj  the value to add to the <code>toString</code>\n      * @return this\n      */\n-    public ToStringBuilder append(String fieldName, Object obj) {\n+    public ToStringBuilder append(final String fieldName, final Object obj) {\n         style.append(buffer, fieldName, obj, null);\n         return this;\n     }\n      *  <code>false</code> for summary info\n      * @return this\n      */\n-    public ToStringBuilder append(String fieldName, Object obj, boolean fullDetail) {\n+    public ToStringBuilder append(final String fieldName, final Object obj, final boolean fullDetail) {\n         style.append(buffer, fieldName, obj, Boolean.valueOf(fullDetail));\n         return this;\n     }\n      * @param array  the array to add to the <code>toString</code>\n      * @return this\n      */\n-    public ToStringBuilder append(String fieldName, Object[] array) {\n+    public ToStringBuilder append(final String fieldName, final Object[] array) {\n         style.append(buffer, fieldName, array, null);\n         return this;\n     }\n      *  for summary info\n      * @return this\n      */\n-    public ToStringBuilder append(String fieldName, Object[] array, boolean fullDetail) {\n+    public ToStringBuilder append(final String fieldName, final Object[] array, final boolean fullDetail) {\n         style.append(buffer, fieldName, array, Boolean.valueOf(fullDetail));\n         return this;\n     }\n      * @param value  the value to add to the <code>toString</code>\n      * @return this\n      */\n-    public ToStringBuilder append(String fieldName, short value) {\n+    public ToStringBuilder append(final String fieldName, final short value) {\n         style.append(buffer, fieldName, value);\n         return this;\n     }\n      * @param array  the array to add to the <code>toString</code>\n      * @return this\n      */\n-    public ToStringBuilder append(String fieldName, short[] array) {\n+    public ToStringBuilder append(final String fieldName, final short[] array) {\n         style.append(buffer, fieldName, array, null);\n         return this;\n     }\n      *  for summary info\n      * @return this\n      */\n-    public ToStringBuilder append(String fieldName, short[] array, boolean fullDetail) {\n+    public ToStringBuilder append(final String fieldName, final short[] array, final boolean fullDetail) {\n         style.append(buffer, fieldName, array, Boolean.valueOf(fullDetail));\n         return this;\n     }\n      * @return this\n      * @since 2.0\n      */\n-    public ToStringBuilder appendAsObjectToString(Object object) {\n+    public ToStringBuilder appendAsObjectToString(final Object object) {\n         ObjectUtils.identityToString(this.getStringBuffer(), object);\n         return this;\n     }\n      * @return this\n      * @since 2.0\n      */\n-    public ToStringBuilder appendSuper(String superToString) {\n+    public ToStringBuilder appendSuper(final String superToString) {\n         if (superToString != null) {\n             style.appendSuper(buffer, superToString);\n         }\n      * @return this\n      * @since 2.0\n      */\n-    public ToStringBuilder appendToString(String toString) {\n+    public ToStringBuilder appendToString(final String toString) {\n         if (toString != null) {\n             style.appendToString(buffer, toString);\n         }\n--- a/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java\n+++ b/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java\n      * @return boolean <code>true</code> if the registry contains the given\n      *             object.\n      */\n-    static boolean isRegistered(Object value) {\n+    static boolean isRegistered(final Object value) {\n         Map<Object, Object> m = getRegistry();\n         return m != null && m.containsKey(value);\n     }\n      * @param value\n      *                  The object to register.\n      */\n-    static void register(Object value) {\n+    static void register(final Object value) {\n         if (value != null) {\n             Map<Object, Object> m = getRegistry();\n             if (m == null) {\n      * @param value\n      *                  The object to unregister.\n      */\n-    static void unregister(Object value) {\n+    static void unregister(final Object value) {\n         if (value != null) {\n             Map<Object, Object> m = getRegistry();\n             if (m != null) {\n      * @param superToString  the <code>super.toString()</code>\n      * @since 2.0\n      */\n-    public void appendSuper(StringBuffer buffer, String superToString) {\n+    public void appendSuper(final StringBuffer buffer, final String superToString) {\n         appendToString(buffer, superToString);\n     }\n \n      * @param toString  the additional <code>toString</code>\n      * @since 2.0\n      */\n-    public void appendToString(StringBuffer buffer, String toString) {\n+    public void appendToString(final StringBuffer buffer, final String toString) {\n         if (toString != null) {\n             int pos1 = toString.indexOf(contentStart) + contentStart.length();\n             int pos2 = toString.lastIndexOf(contentEnd);\n      * @param buffer  the <code>StringBuffer</code> to populate\n      * @param object  the <code>Object</code> to build a <code>toString</code> for\n      */\n-    public void appendStart(StringBuffer buffer, Object object) {\n+    public void appendStart(final StringBuffer buffer, final Object object) {\n         if (object != null) {\n             appendClassName(buffer, object);\n             appendIdentityHashCode(buffer, object);\n      * @param object  the <code>Object</code> to build a\n      *  <code>toString</code> for.\n      */\n-    public void appendEnd(StringBuffer buffer, Object object) {\n+    public void appendEnd(final StringBuffer buffer, final Object object) {\n         if (this.fieldSeparatorAtEnd == false) {\n             removeLastFieldSeparator(buffer);\n         }\n      * @param buffer  the <code>StringBuffer</code> to populate\n      * @since 2.0\n      */\n-    protected void removeLastFieldSeparator(StringBuffer buffer) {\n+    protected void removeLastFieldSeparator(final StringBuffer buffer) {\n         int len = buffer.length();\n         int sepLen = fieldSeparator.length();\n         if (len > 0 && sepLen > 0 && len >= sepLen) {\n      * @param fullDetail  <code>true</code> for detail, <code>false</code>\n      *  for summary info, <code>null</code> for style decides\n      */\n-    public void append(StringBuffer buffer, String fieldName, Object value, Boolean fullDetail) {\n+    public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail) {\n         appendFieldStart(buffer, fieldName);\n \n         if (value == null) {\n      *  not <code>null</code>\n      * @param detail  output detail or not\n      */\n-    protected void appendInternal(StringBuffer buffer, String fieldName, Object value, boolean detail) {\n+    protected void appendInternal(final StringBuffer buffer, final String fieldName, final Object value, final boolean detail) {\n         if (isRegistered(value)\n             && !(value instanceof Number || value instanceof Boolean || value instanceof Character)) {\n            appendCyclicObject(buffer, fieldName, value);\n      *\n      * @since 2.2\n      */\n-    protected void appendCyclicObject(StringBuffer buffer, String fieldName, Object value) {\n+    protected void appendCyclicObject(final StringBuffer buffer, final String fieldName, final Object value) {\n        ObjectUtils.identityToString(buffer, value);\n     }\n \n      * @param value  the value to add to the <code>toString</code>,\n      *  not <code>null</code>\n      */\n-    protected void appendDetail(StringBuffer buffer, String fieldName, Object value) {\n+    protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object value) {\n         buffer.append(value);\n     }\n \n      * @param coll  the <code>Collection</code> to add to the\n      *  <code>toString</code>, not <code>null</code>\n      */\n-    protected void appendDetail(StringBuffer buffer, String fieldName, Collection<?> coll) {\n+    protected void appendDetail(final StringBuffer buffer, final String fieldName, final Collection<?> coll) {\n         buffer.append(coll);\n     }\n \n      * @param map  the <code>Map</code> to add to the <code>toString</code>,\n      *  not <code>null</code>\n      */\n-    protected void appendDetail(StringBuffer buffer, String fieldName, Map<?, ?> map) {\n+    protected void appendDetail(final StringBuffer buffer, final String fieldName, final Map<?, ?> map) {\n         buffer.append(map);\n     }\n \n      * @param value  the value to add to the <code>toString</code>,\n      *  not <code>null</code>\n      */\n-    protected void appendSummary(StringBuffer buffer, String fieldName, Object value) {\n+    protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object value) {\n         buffer.append(summaryObjectStartText);\n         buffer.append(getShortClassName(value.getClass()));\n         buffer.append(summaryObjectEndText);\n      * @param fieldName  the field name\n      * @param value  the value to add to the <code>toString</code>\n      */\n-    public void append(StringBuffer buffer, String fieldName, long value) {\n+    public void append(final StringBuffer buffer, final String fieldName, final long value) {\n         appendFieldStart(buffer, fieldName);\n         appendDetail(buffer, fieldName, value);\n         appendFieldEnd(buffer, fieldName);\n      * @param fieldName  the field name, typically not used as already appended\n      * @param value  the value to add to the <code>toString</code>\n      */\n-    protected void appendDetail(StringBuffer buffer, String fieldName, long value) {\n+    protected void appendDetail(final StringBuffer buffer, final String fieldName, final long value) {\n         buffer.append(value);\n     }\n \n      * @param fieldName  the field name\n      * @param value  the value to add to the <code>toString</code>\n      */\n-    public void append(StringBuffer buffer, String fieldName, int value) {\n+    public void append(final StringBuffer buffer, final String fieldName, final int value) {\n         appendFieldStart(buffer, fieldName);\n         appendDetail(buffer, fieldName, value);\n         appendFieldEnd(buffer, fieldName);\n      * @param fieldName  the field name, typically not used as already appended\n      * @param value  the value to add to the <code>toString</code>\n      */\n-    protected void appendDetail(StringBuffer buffer, String fieldName, int value) {\n+    protected void appendDetail(final StringBuffer buffer, final String fieldName, final int value) {\n         buffer.append(value);\n     }\n \n      * @param fieldName  the field name\n      * @param value  the value to add to the <code>toString</code>\n      */\n-    public void append(StringBuffer buffer, String fieldName, short value) {\n+    public void append(final StringBuffer buffer, final String fieldName, final short value) {\n         appendFieldStart(buffer, fieldName);\n         appendDetail(buffer, fieldName, value);\n         appendFieldEnd(buffer, fieldName);\n      * @param fieldName  the field name, typically not used as already appended\n      * @param value  the value to add to the <code>toString</code>\n      */\n-    protected void appendDetail(StringBuffer buffer, String fieldName, short value) {\n+    protected void appendDetail(final StringBuffer buffer, final String fieldName, final short value) {\n         buffer.append(value);\n     }\n \n      * @param fieldName  the field name\n      * @param value  the value to add to the <code>toString</code>\n      */\n-    public void append(StringBuffer buffer, String fieldName, byte value) {\n+    public void append(final StringBuffer buffer, final String fieldName, final byte value) {\n         appendFieldStart(buffer, fieldName);\n         appendDetail(buffer, fieldName, value);\n         appendFieldEnd(buffer, fieldName);\n      * @param fieldName  the field name, typically not used as already appended\n      * @param value  the value to add to the <code>toString</code>\n      */\n-    protected void appendDetail(StringBuffer buffer, String fieldName, byte value) {\n+    protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte value) {\n         buffer.append(value);\n     }\n \n      * @param fieldName  the field name\n      * @param value  the value to add to the <code>toString</code>\n      */\n-    public void append(StringBuffer buffer, String fieldName, char value) {\n+    public void append(final StringBuffer buffer, final String fieldName, final char value) {\n         appendFieldStart(buffer, fieldName);\n         appendDetail(buffer, fieldName, value);\n         appendFieldEnd(buffer, fieldName);\n      * @param fieldName  the field name, typically not used as already appended\n      * @param value  the value to add to the <code>toString</code>\n      */\n-    protected void appendDetail(StringBuffer buffer, String fieldName, char value) {\n+    protected void appendDetail(final StringBuffer buffer, final String fieldName, final char value) {\n         buffer.append(value);\n     }\n \n      * @param fieldName  the field name\n      * @param value  the value to add to the <code>toString</code>\n      */\n-    public void append(StringBuffer buffer, String fieldName, double value) {\n+    public void append(final StringBuffer buffer, final String fieldName, final double value) {\n         appendFieldStart(buffer, fieldName);\n         appendDetail(buffer, fieldName, value);\n         appendFieldEnd(buffer, fieldName);\n      * @param fieldName  the field name, typically not used as already appended\n      * @param value  the value to add to the <code>toString</code>\n      */\n-    protected void appendDetail(StringBuffer buffer, String fieldName, double value) {\n+    protected void appendDetail(final StringBuffer buffer, final String fieldName, final double value) {\n         buffer.append(value);\n     }\n \n      * @param fieldName  the field name\n      * @param value  the value to add to the <code>toString</code>\n      */\n-    public void append(StringBuffer buffer, String fieldName, float value) {\n+    public void append(final StringBuffer buffer, final String fieldName, final float value) {\n         appendFieldStart(buffer, fieldName);\n         appendDetail(buffer, fieldName, value);\n         appendFieldEnd(buffer, fieldName);\n      * @param fieldName  the field name, typically not used as already appended\n      * @param value  the value to add to the <code>toString</code>\n      */\n-    protected void appendDetail(StringBuffer buffer, String fieldName, float value) {\n+    protected void appendDetail(final StringBuffer buffer, final String fieldName, final float value) {\n         buffer.append(value);\n     }\n \n      * @param fieldName  the field name\n      * @param value  the value to add to the <code>toString</code>\n      */\n-    public void append(StringBuffer buffer, String fieldName, boolean value) {\n+    public void append(final StringBuffer buffer, final String fieldName, final boolean value) {\n         appendFieldStart(buffer, fieldName);\n         appendDetail(buffer, fieldName, value);\n         appendFieldEnd(buffer, fieldName);\n      * @param fieldName  the field name, typically not used as already appended\n      * @param value  the value to add to the <code>toString</code>\n      */\n-    protected void appendDetail(StringBuffer buffer, String fieldName, boolean value) {\n+    protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean value) {\n         buffer.append(value);\n     }\n \n      * @param fullDetail  <code>true</code> for detail, <code>false</code>\n      *  for summary info, <code>null</code> for style decides\n      */\n-    public void append(StringBuffer buffer, String fieldName, Object[] array, Boolean fullDetail) {\n+    public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail) {\n         appendFieldStart(buffer, fieldName);\n \n         if (array == null) {\n      * @param array  the array to add to the <code>toString</code>,\n      *  not <code>null</code>\n      */\n-    protected void appendDetail(StringBuffer buffer, String fieldName, Object[] array) {\n+    protected void appendDetail(final StringBuffer buffer, final String fieldName, final Object[] array) {\n         buffer.append(arrayStart);\n         for (int i = 0; i < array.length; i++) {\n             Object item = array[i];\n      *  not <code>null</code>\n      * @since 2.0\n      */\n-    protected void reflectionAppendArrayDetail(StringBuffer buffer, String fieldName, Object array) {\n+    protected void reflectionAppendArrayDetail(final StringBuffer buffer, final String fieldName, final Object array) {\n         buffer.append(arrayStart);\n         int length = Array.getLength(array);\n         for (int i = 0; i < length; i++) {\n      * @param array  the array to add to the <code>toString</code>,\n      *  not <code>null</code>\n      */\n-    protected void appendSummary(StringBuffer buffer, String fieldName, Object[] array) {\n+    protected void appendSummary(final StringBuffer buffer, final String fieldName, final Object[] array) {\n         appendSummarySize(buffer, fieldName, array.length);\n     }\n \n      * @param fullDetail  <code>true</code> for detail, <code>false</code>\n      *  for summary info, <code>null</code> for style decides\n      */\n-    public void append(StringBuffer buffer, String fieldName, long[] array, Boolean fullDetail) {\n+    public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail) {\n         appendFieldStart(buffer, fieldName);\n \n         if (array == null) {\n      * @param array  the array to add to the <code>toString</code>,\n      *  not <code>null</code>\n      */\n-    protected void appendDetail(StringBuffer buffer, String fieldName, long[] array) {\n+    protected void appendDetail(final StringBuffer buffer, final String fieldName, final long[] array) {\n         buffer.append(arrayStart);\n         for (int i = 0; i < array.length; i++) {\n             if (i > 0) {\n      * @param array  the array to add to the <code>toString</code>,\n      *  not <code>null</code>\n      */\n-    protected void appendSummary(StringBuffer buffer, String fieldName, long[] array) {\n+    protected void appendSummary(final StringBuffer buffer, final String fieldName, final long[] array) {\n         appendSummarySize(buffer, fieldName, array.length);\n     }\n \n      * @param fullDetail  <code>true</code> for detail, <code>false</code>\n      *  for summary info, <code>null</code> for style decides\n      */\n-    public void append(StringBuffer buffer, String fieldName, int[] array, Boolean fullDetail) {\n+    public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail) {\n         appendFieldStart(buffer, fieldName);\n \n         if (array == null) {\n      * @param array  the array to add to the <code>toString</code>,\n      *  not <code>null</code>\n      */\n-    protected void appendDetail(StringBuffer buffer, String fieldName, int[] array) {\n+    protected void appendDetail(final StringBuffer buffer, final String fieldName, final int[] array) {\n         buffer.append(arrayStart);\n         for (int i = 0; i < array.length; i++) {\n             if (i > 0) {\n      * @param array  the array to add to the <code>toString</code>,\n      *  not <code>null</code>\n      */\n-    protected void appendSummary(StringBuffer buffer, String fieldName, int[] array) {\n+    protected void appendSummary(final StringBuffer buffer, final String fieldName, final int[] array) {\n         appendSummarySize(buffer, fieldName, array.length);\n     }\n \n      * @param fullDetail  <code>true</code> for detail, <code>false</code>\n      *  for summary info, <code>null</code> for style decides\n      */\n-    public void append(StringBuffer buffer, String fieldName, short[] array, Boolean fullDetail) {\n+    public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail) {\n         appendFieldStart(buffer, fieldName);\n \n         if (array == null) {\n      * @param array  the array to add to the <code>toString</code>,\n      *  not <code>null</code>\n      */\n-    protected void appendDetail(StringBuffer buffer, String fieldName, short[] array) {\n+    protected void appendDetail(final StringBuffer buffer, final String fieldName, final short[] array) {\n         buffer.append(arrayStart);\n         for (int i = 0; i < array.length; i++) {\n             if (i > 0) {\n      * @param array  the array to add to the <code>toString</code>,\n      *  not <code>null</code>\n      */\n-    protected void appendSummary(StringBuffer buffer, String fieldName, short[] array) {\n+    protected void appendSummary(final StringBuffer buffer, final String fieldName, final short[] array) {\n         appendSummarySize(buffer, fieldName, array.length);\n     }\n \n      * @param fullDetail  <code>true</code> for detail, <code>false</code>\n      *  for summary info, <code>null</code> for style decides\n      */\n-    public void append(StringBuffer buffer, String fieldName, byte[] array, Boolean fullDetail) {\n+    public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail) {\n         appendFieldStart(buffer, fieldName);\n \n         if (array == null) {\n      * @param array  the array to add to the <code>toString</code>,\n      *  not <code>null</code>\n      */\n-    protected void appendDetail(StringBuffer buffer, String fieldName, byte[] array) {\n+    protected void appendDetail(final StringBuffer buffer, final String fieldName, final byte[] array) {\n         buffer.append(arrayStart);\n         for (int i = 0; i < array.length; i++) {\n             if (i > 0) {\n      * @param array  the array to add to the <code>toString</code>,\n      *  not <code>null</code>\n      */\n-    protected void appendSummary(StringBuffer buffer, String fieldName, byte[] array) {\n+    protected void appendSummary(final StringBuffer buffer, final String fieldName, final byte[] array) {\n         appendSummarySize(buffer, fieldName, array.length);\n     }\n \n      * @param fullDetail  <code>true</code> for detail, <code>false</code>\n      *  for summary info, <code>null</code> for style decides\n      */\n-    public void append(StringBuffer buffer, String fieldName, char[] array, Boolean fullDetail) {\n+    public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail) {\n         appendFieldStart(buffer, fieldName);\n \n         if (array == null) {\n      * @param array  the array to add to the <code>toString</code>,\n      *  not <code>null</code>\n      */\n-    protected void appendDetail(StringBuffer buffer, String fieldName, char[] array) {\n+    protected void appendDetail(final StringBuffer buffer, final String fieldName, final char[] array) {\n         buffer.append(arrayStart);\n         for (int i = 0; i < array.length; i++) {\n             if (i > 0) {\n      * @param array  the array to add to the <code>toString</code>,\n      *  not <code>null</code>\n      */\n-    protected void appendSummary(StringBuffer buffer, String fieldName, char[] array) {\n+    protected void appendSummary(final StringBuffer buffer, final String fieldName, final char[] array) {\n         appendSummarySize(buffer, fieldName, array.length);\n     }\n \n      * @param fullDetail  <code>true</code> for detail, <code>false</code>\n      *  for summary info, <code>null</code> for style decides\n      */\n-    public void append(StringBuffer buffer, String fieldName, double[] array, Boolean fullDetail) {\n+    public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail) {\n         appendFieldStart(buffer, fieldName);\n \n         if (array == null) {\n      * @param array  the array to add to the <code>toString</code>,\n      *  not <code>null</code>\n      */\n-    protected void appendDetail(StringBuffer buffer, String fieldName, double[] array) {\n+    protected void appendDetail(final StringBuffer buffer, final String fieldName, final double[] array) {\n         buffer.append(arrayStart);\n         for (int i = 0; i < array.length; i++) {\n             if (i > 0) {\n      * @param array  the array to add to the <code>toString</code>,\n      *  not <code>null</code>\n      */\n-    protected void appendSummary(StringBuffer buffer, String fieldName, double[] array) {\n+    protected void appendSummary(final StringBuffer buffer, final String fieldName, final double[] array) {\n         appendSummarySize(buffer, fieldName, array.length);\n     }\n \n      * @param fullDetail  <code>true</code> for detail, <code>false</code>\n      *  for summary info, <code>null</code> for style decides\n      */\n-    public void append(StringBuffer buffer, String fieldName, float[] array, Boolean fullDetail) {\n+    public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail) {\n         appendFieldStart(buffer, fieldName);\n \n         if (array == null) {\n      * @param array  the array to add to the <code>toString</code>,\n      *  not <code>null</code>\n      */\n-    protected void appendDetail(StringBuffer buffer, String fieldName, float[] array) {\n+    protected void appendDetail(final StringBuffer buffer, final String fieldName, final float[] array) {\n         buffer.append(arrayStart);\n         for (int i = 0; i < array.length; i++) {\n             if (i > 0) {\n      * @param array  the array to add to the <code>toString</code>,\n      *  not <code>null</code>\n      */\n-    protected void appendSummary(StringBuffer buffer, String fieldName, float[] array) {\n+    protected void appendSummary(final StringBuffer buffer, final String fieldName, final float[] array) {\n         appendSummarySize(buffer, fieldName, array.length);\n     }\n \n      * @param fullDetail  <code>true</code> for detail, <code>false</code>\n      *  for summary info, <code>null</code> for style decides\n      */\n-    public void append(StringBuffer buffer, String fieldName, boolean[] array, Boolean fullDetail) {\n+    public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail) {\n         appendFieldStart(buffer, fieldName);\n \n         if (array == null) {\n      * @param array  the array to add to the <code>toString</code>,\n      *  not <code>null</code>\n      */\n-    protected void appendDetail(StringBuffer buffer, String fieldName, boolean[] array) {\n+    protected void appendDetail(final StringBuffer buffer, final String fieldName, final boolean[] array) {\n         buffer.append(arrayStart);\n         for (int i = 0; i < array.length; i++) {\n             if (i > 0) {\n      * @param array  the array to add to the <code>toString</code>,\n      *  not <code>null</code>\n      */\n-    protected void appendSummary(StringBuffer buffer, String fieldName, boolean[] array) {\n+    protected void appendSummary(final StringBuffer buffer, final String fieldName, final boolean[] array) {\n         appendSummarySize(buffer, fieldName, array.length);\n     }\n \n      * @param buffer  the <code>StringBuffer</code> to populate\n      * @param object  the <code>Object</code> whose name to output\n      */\n-    protected void appendClassName(StringBuffer buffer, Object object) {\n+    protected void appendClassName(final StringBuffer buffer, final Object object) {\n         if (useClassName && object != null) {\n             register(object);\n             if (useShortClassName) {\n      * @param buffer  the <code>StringBuffer</code> to populate\n      * @param object  the <code>Object</code> whose id to output\n      */\n-    protected void appendIdentityHashCode(StringBuffer buffer, Object object) {\n+    protected void appendIdentityHashCode(final StringBuffer buffer, final Object object) {\n         if (this.isUseIdentityHashCode() && object!=null) {\n             register(object);\n             buffer.append('@');\n      *\n      * @param buffer  the <code>StringBuffer</code> to populate\n      */\n-    protected void appendContentStart(StringBuffer buffer) {\n+    protected void appendContentStart(final StringBuffer buffer) {\n         buffer.append(contentStart);\n     }\n \n      *\n      * @param buffer  the <code>StringBuffer</code> to populate\n      */\n-    protected void appendContentEnd(StringBuffer buffer) {\n+    protected void appendContentEnd(final StringBuffer buffer) {\n         buffer.append(contentEnd);\n     }\n \n      * @param buffer  the <code>StringBuffer</code> to populate\n      * @param fieldName  the field name, typically not used as already appended\n      */\n-    protected void appendNullText(StringBuffer buffer, String fieldName) {\n+    protected void appendNullText(final StringBuffer buffer, final String fieldName) {\n         buffer.append(nullText);\n     }\n \n      *\n      * @param buffer  the <code>StringBuffer</code> to populate\n      */\n-    protected void appendFieldSeparator(StringBuffer buffer) {\n+    protected void appendFieldSeparator(final StringBuffer buffer) {\n         buffer.append(fieldSeparator);\n     }\n \n      * @param buffer  the <code>StringBuffer</code> to populate\n      * @param fieldName  the field name\n      */\n-    protected void appendFieldStart(StringBuffer buffer, String fieldName) {\n+    protected void appendFieldStart(final StringBuffer buffer, final String fieldName) {\n         if (useFieldNames && fieldName != null) {\n             buffer.append(fieldName);\n             buffer.append(fieldNameValueSeparator);\n      * @param buffer  the <code>StringBuffer</code> to populate\n      * @param fieldName  the field name, typically not used as already appended\n      */\n-    protected void appendFieldEnd(StringBuffer buffer, String fieldName) {\n+    protected void appendFieldEnd(final StringBuffer buffer, final String fieldName) {\n         appendFieldSeparator(buffer);\n     }\n \n      * @param fieldName  the field name, typically not used as already appended\n      * @param size  the size to append\n      */\n-    protected void appendSummarySize(StringBuffer buffer, String fieldName, int size) {\n+    protected void appendSummarySize(final StringBuffer buffer, final String fieldName, final int size) {\n         buffer.append(sizeStartText);\n         buffer.append(size);\n         buffer.append(sizeEndText);\n      * @param fullDetailRequest  the detail level requested\n      * @return whether full detail is to be shown\n      */\n-    protected boolean isFullDetail(Boolean fullDetailRequest) {\n+    protected boolean isFullDetail(final Boolean fullDetailRequest) {\n         if (fullDetailRequest == null) {\n             return defaultFullDetail;\n         }\n      * @param cls  the <code>Class</code> to get the short name of\n      * @return the short name\n      */\n-    protected String getShortClassName(Class<?> cls) {\n+    protected String getShortClassName(final Class<?> cls) {\n         return ClassUtils.getShortClassName(cls);\n     }\n \n      *\n      * @param useClassName  the new useClassName flag\n      */\n-    protected void setUseClassName(boolean useClassName) {\n+    protected void setUseClassName(final boolean useClassName) {\n         this.useClassName = useClassName;\n     }\n \n      * @param useShortClassName  the new useShortClassName flag\n      * @since 2.0\n      */\n-    protected void setUseShortClassName(boolean useShortClassName) {\n+    protected void setUseShortClassName(final boolean useShortClassName) {\n         this.useShortClassName = useShortClassName;\n     }\n \n      *\n      * @param useIdentityHashCode  the new useIdentityHashCode flag\n      */\n-    protected void setUseIdentityHashCode(boolean useIdentityHashCode) {\n+    protected void setUseIdentityHashCode(final boolean useIdentityHashCode) {\n         this.useIdentityHashCode = useIdentityHashCode;\n     }\n \n      *\n      * @param useFieldNames  the new useFieldNames flag\n      */\n-    protected void setUseFieldNames(boolean useFieldNames) {\n+    protected void setUseFieldNames(final boolean useFieldNames) {\n         this.useFieldNames = useFieldNames;\n     }\n \n      *\n      * @param defaultFullDetail  the new defaultFullDetail flag\n      */\n-    protected void setDefaultFullDetail(boolean defaultFullDetail) {\n+    protected void setDefaultFullDetail(final boolean defaultFullDetail) {\n         this.defaultFullDetail = defaultFullDetail;\n     }\n \n      *\n      * @param arrayContentDetail  the new arrayContentDetail flag\n      */\n-    protected void setArrayContentDetail(boolean arrayContentDetail) {\n+    protected void setArrayContentDetail(final boolean arrayContentDetail) {\n         this.arrayContentDetail = arrayContentDetail;\n     }\n \n      * @param fieldSeparatorAtStart  the fieldSeparatorAtStart flag\n      * @since 2.0\n      */\n-    protected void setFieldSeparatorAtStart(boolean fieldSeparatorAtStart) {\n+    protected void setFieldSeparatorAtStart(final boolean fieldSeparatorAtStart) {\n         this.fieldSeparatorAtStart = fieldSeparatorAtStart;\n     }\n \n      * @param fieldSeparatorAtEnd  the fieldSeparatorAtEnd flag\n      * @since 2.0\n      */\n-    protected void setFieldSeparatorAtEnd(boolean fieldSeparatorAtEnd) {\n+    protected void setFieldSeparatorAtEnd(final boolean fieldSeparatorAtEnd) {\n         this.fieldSeparatorAtEnd = fieldSeparatorAtEnd;\n     }\n \n--- a/src/main/java/org/apache/commons/lang3/concurrent/BackgroundInitializer.java\n+++ b/src/main/java/org/apache/commons/lang3/concurrent/BackgroundInitializer.java\n      * @param exec an external {@code ExecutorService} to be used for task\n      * execution\n      */\n-    protected BackgroundInitializer(ExecutorService exec) {\n+    protected BackgroundInitializer(final ExecutorService exec) {\n         setExternalExecutor(exec);\n     }\n \n      * started\n      */\n     public final synchronized void setExternalExecutor(\n-            ExecutorService externalExecutor) {\n+            final ExecutorService externalExecutor) {\n         if (isStarted()) {\n             throw new IllegalStateException(\n                     \"Cannot set ExecutorService after start()!\");\n      * task\n      * @return a task for the background initialization\n      */\n-    private Callable<T> createTask(ExecutorService execDestroy) {\n+    private Callable<T> createTask(final ExecutorService execDestroy) {\n         return new InitializationTask(execDestroy);\n     }\n \n          *\n          * @param exec the {@code ExecutorService}\n          */\n-        public InitializationTask(ExecutorService exec) {\n+        public InitializationTask(final ExecutorService exec) {\n             execFinally = exec;\n         }\n \n--- a/src/main/java/org/apache/commons/lang3/concurrent/BasicThreadFactory.java\n+++ b/src/main/java/org/apache/commons/lang3/concurrent/BasicThreadFactory.java\n      *\n      * @param builder the {@code Builder} object\n      */\n-    private BasicThreadFactory(Builder builder) {\n+    private BasicThreadFactory(final Builder builder) {\n         if (builder.wrappedFactory == null) {\n             wrappedFactory = Executors.defaultThreadFactory();\n         } else {\n      * @return the newly created thread\n      */\n     @Override\n-    public Thread newThread(Runnable r) {\n+    public Thread newThread(final Runnable r) {\n         Thread t = getWrappedFactory().newThread(r);\n         initializeThread(t);\n \n      *\n      * @param t the thread to be initialized\n      */\n-    private void initializeThread(Thread t) {\n+    private void initializeThread(final Thread t) {\n \n         if (getNamingPattern() != null) {\n             Long count = Long.valueOf(threadCounter.incrementAndGet());\n          * @throws NullPointerException if the passed in {@code ThreadFactory}\n          * is <b>null</b>\n          */\n-        public Builder wrappedFactory(ThreadFactory factory) {\n+        public Builder wrappedFactory(final ThreadFactory factory) {\n             if (factory == null) {\n                 throw new NullPointerException(\n                         \"Wrapped ThreadFactory must not be null!\");\n          * @return a reference to this {@code Builder}\n          * @throws NullPointerException if the naming pattern is <b>null</b>\n          */\n-        public Builder namingPattern(String pattern) {\n+        public Builder namingPattern(final String pattern) {\n             if (pattern == null) {\n                 throw new NullPointerException(\n                         \"Naming pattern must not be null!\");\n          * @param f the value of the daemon flag\n          * @return a reference to this {@code Builder}\n          */\n-        public Builder daemon(boolean f) {\n+        public Builder daemon(final boolean f) {\n             daemonFlag = Boolean.valueOf(f);\n             return this;\n         }\n          * @param prio the priority\n          * @return a reference to this {@code Builder}\n          */\n-        public Builder priority(int prio) {\n+        public Builder priority(final int prio) {\n             priority = Integer.valueOf(prio);\n             return this;\n         }\n          * @throws NullPointerException if the exception handler is <b>null</b>\n          */\n         public Builder uncaughtExceptionHandler(\n-                Thread.UncaughtExceptionHandler handler) {\n+                final Thread.UncaughtExceptionHandler handler) {\n             if (handler == null) {\n                 throw new NullPointerException(\n                         \"Uncaught exception handler must not be null!\");\n--- a/src/main/java/org/apache/commons/lang3/concurrent/CallableBackgroundInitializer.java\n+++ b/src/main/java/org/apache/commons/lang3/concurrent/CallableBackgroundInitializer.java\n      * @param call the {@code Callable} (must not be <b>null</b>)\n      * @throws IllegalArgumentException if the {@code Callable} is <b>null</b>\n      */\n-    public CallableBackgroundInitializer(Callable<T> call) {\n+    public CallableBackgroundInitializer(final Callable<T> call) {\n         checkCallable(call);\n         callable = call;\n     }\n      * execution\n      * @throws IllegalArgumentException if the {@code Callable} is <b>null</b>\n      */\n-    public CallableBackgroundInitializer(Callable<T> call, ExecutorService exec) {\n+    public CallableBackgroundInitializer(final Callable<T> call, final ExecutorService exec) {\n         super(exec);\n         checkCallable(call);\n         callable = call;\n      * @param call the object to check\n      * @throws IllegalArgumentException if the {@code Callable} is <b>null</b>\n      */\n-    private void checkCallable(Callable<T> call) {\n+    private void checkCallable(final Callable<T> call) {\n         if (call == null) {\n             throw new IllegalArgumentException(\"Callable must not be null!\");\n         }\n--- a/src/main/java/org/apache/commons/lang3/concurrent/ConcurrentException.java\n+++ b/src/main/java/org/apache/commons/lang3/concurrent/ConcurrentException.java\n      * @param cause the cause of this exception\n      * @throws IllegalArgumentException if the cause is not a checked exception\n      */\n-    public ConcurrentException(Throwable cause) {\n+    public ConcurrentException(final Throwable cause) {\n         super(ConcurrentUtils.checkedException(cause));\n     }\n \n      * @param cause the cause of this exception\n      * @throws IllegalArgumentException if the cause is not a checked exception\n      */\n-    public ConcurrentException(String msg, Throwable cause) {\n+    public ConcurrentException(final String msg, final Throwable cause) {\n         super(msg, ConcurrentUtils.checkedException(cause));\n     }\n }\n--- a/src/main/java/org/apache/commons/lang3/concurrent/ConcurrentRuntimeException.java\n+++ b/src/main/java/org/apache/commons/lang3/concurrent/ConcurrentRuntimeException.java\n      * @param cause the cause of this exception\n      * @throws IllegalArgumentException if the cause is not a checked exception\n      */\n-    public ConcurrentRuntimeException(Throwable cause) {\n+    public ConcurrentRuntimeException(final Throwable cause) {\n         super(ConcurrentUtils.checkedException(cause));\n     }\n \n      * @param cause the cause of this exception\n      * @throws IllegalArgumentException if the cause is not a checked exception\n      */\n-    public ConcurrentRuntimeException(String msg, Throwable cause) {\n+    public ConcurrentRuntimeException(final String msg, final Throwable cause) {\n         super(msg, ConcurrentUtils.checkedException(cause));\n     }\n }\n--- a/src/main/java/org/apache/commons/lang3/concurrent/ConcurrentUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/concurrent/ConcurrentUtils.java\n      * @param ex the exception to be processed\n      * @return a {@code ConcurrentException} with the checked cause\n      */\n-    public static ConcurrentException extractCause(ExecutionException ex) {\n+    public static ConcurrentException extractCause(final ExecutionException ex) {\n         if (ex == null || ex.getCause() == null) {\n             return null;\n         }\n      * @return a {@code ConcurrentRuntimeException} with the checked cause\n      */\n     public static ConcurrentRuntimeException extractCauseUnchecked(\n-            ExecutionException ex) {\n+            final ExecutionException ex) {\n         if (ex == null || ex.getCause() == null) {\n             return null;\n         }\n      * @throws ConcurrentException if the cause of the {@code\n      * ExecutionException} is a checked exception\n      */\n-    public static void handleCause(ExecutionException ex)\n+    public static void handleCause(final ExecutionException ex)\n             throws ConcurrentException {\n         ConcurrentException cex = extractCause(ex);\n \n      * ExecutionException} is a checked exception; this exception is then\n      * wrapped in the thrown runtime exception\n      */\n-    public static void handleCauseUnchecked(ExecutionException ex) {\n+    public static void handleCauseUnchecked(final ExecutionException ex) {\n         ConcurrentRuntimeException crex = extractCauseUnchecked(ex);\n \n         if (crex != null) {\n      * @throws IllegalArgumentException if the {@code Throwable} is not a\n      * checked exception\n      */\n-    static Throwable checkedException(Throwable ex) {\n+    static Throwable checkedException(final Throwable ex) {\n         if (ex != null && !(ex instanceof RuntimeException)\n                 && !(ex instanceof Error)) {\n             return ex;\n      *\n      * @param ex the exception in question\n      */\n-    private static void throwCause(ExecutionException ex) {\n+    private static void throwCause(final ExecutionException ex) {\n         if (ex.getCause() instanceof RuntimeException) {\n             throw (RuntimeException) ex.getCause();\n         }\n      * @throws ConcurrentException if the {@code ConcurrentInitializer} throws\n      * an exception\n      */\n-    public static <T> T initialize(ConcurrentInitializer<T> initializer)\n+    public static <T> T initialize(final ConcurrentInitializer<T> initializer)\n             throws ConcurrentException {\n         return initializer != null ? initializer.get() : null;\n     }\n      * @return the object managed by the {@code ConcurrentInitializer}\n      * @throws ConcurrentRuntimeException if the initializer throws an exception\n      */\n-    public static <T> T initializeUnchecked(ConcurrentInitializer<T> initializer) {\n+    public static <T> T initializeUnchecked(final ConcurrentInitializer<T> initializer) {\n         try {\n             return initialize(initializer);\n         } catch (ConcurrentException cex) {\n      * @param value the value to be added\n      * @return the value stored in the map after this operation\n      */\n-    public static <K, V> V putIfAbsent(ConcurrentMap<K, V> map, K key, V value) {\n+    public static <K, V> V putIfAbsent(final ConcurrentMap<K, V> map, final K key, final V value) {\n         if (map == null) {\n             return null;\n         }\n      * not be the object created by the {@link ConcurrentInitializer}\n      * @throws ConcurrentException if the initializer throws an exception\n      */\n-    public static <K, V> V createIfAbsent(ConcurrentMap<K, V> map, K key,\n-            ConcurrentInitializer<V> init) throws ConcurrentException {\n+    public static <K, V> V createIfAbsent(final ConcurrentMap<K, V> map, final K key,\n+            final ConcurrentInitializer<V> init) throws ConcurrentException {\n         if (map == null || init == null) {\n             return null;\n         }\n      * not be the object created by the {@link ConcurrentInitializer}\n      * @throws ConcurrentRuntimeException if the initializer throws an exception\n      */\n-    public static <K, V> V createIfAbsentUnchecked(ConcurrentMap<K, V> map,\n-            K key, ConcurrentInitializer<V> init) {\n+    public static <K, V> V createIfAbsentUnchecked(final ConcurrentMap<K, V> map,\n+            final K key, final ConcurrentInitializer<V> init) {\n         try {\n             return createIfAbsent(map, key, init);\n         } catch (ConcurrentException cex) {\n      * @param value  the constant value to return, may be null\n      * @return an instance of Future that will return the value, never null\n      */\n-    public static <T> Future<T> constantFuture(T value) {\n+    public static <T> Future<T> constantFuture(final T value) {\n         return new ConstantFuture<T>(value);\n     }\n \n          *\n          * @param value the value (may be <b>null</b>)\n          */\n-        ConstantFuture(T value) {\n+        ConstantFuture(final T value) {\n             this.value = value;\n         }\n \n          * does not block, therefore the timeout has no meaning.\n          */\n         @Override\n-        public T get(long timeout, TimeUnit unit) {\n+        public T get(final long timeout, final TimeUnit unit) {\n             return value;\n         }\n \n          * implementation always returns <b>false</b>.\n          */\n         @Override\n-        public boolean cancel(boolean mayInterruptIfRunning) {\n+        public boolean cancel(final boolean mayInterruptIfRunning) {\n             return false;\n         }\n     }\n--- a/src/main/java/org/apache/commons/lang3/concurrent/ConstantInitializer.java\n+++ b/src/main/java/org/apache/commons/lang3/concurrent/ConstantInitializer.java\n      *\n      * @param obj the object to be managed by this initializer\n      */\n-    public ConstantInitializer(T obj) {\n+    public ConstantInitializer(final T obj) {\n         object = obj;\n     }\n \n      * @return a flag whether the objects are equal\n      */\n     @Override\n-    public boolean equals(Object obj) {\n+    public boolean equals(final Object obj) {\n         if (this == obj) {\n             return true;\n         }\n--- a/src/main/java/org/apache/commons/lang3/concurrent/MultiBackgroundInitializer.java\n+++ b/src/main/java/org/apache/commons/lang3/concurrent/MultiBackgroundInitializer.java\n      * @param exec the {@code ExecutorService} for executing the background\n      * tasks\n      */\n-    public MultiBackgroundInitializer(ExecutorService exec) {\n+    public MultiBackgroundInitializer(final ExecutorService exec) {\n         super(exec);\n     }\n \n      * @throws IllegalArgumentException if a required parameter is missing\n      * @throws IllegalStateException if {@code start()} has already been called\n      */\n-    public void addInitializer(String name, BackgroundInitializer<?> init) {\n+    public void addInitializer(final String name, final BackgroundInitializer<?> init) {\n         if (name == null) {\n             throw new IllegalArgumentException(\n                     \"Name of child initializer must not be null!\");\n          * @param excepts the exceptions\n          */\n         private MultiBackgroundInitializerResults(\n-                Map<String, BackgroundInitializer<?>> inits,\n-                Map<String, Object> results,\n-                Map<String, ConcurrentException> excepts) {\n+                final Map<String, BackgroundInitializer<?>> inits,\n+                final Map<String, Object> results,\n+                final Map<String, ConcurrentException> excepts) {\n             initializers = inits;\n             resultObjects = results;\n             exceptions = excepts;\n          * @return the {@code BackgroundInitializer} with this name\n          * @throws NoSuchElementException if the name cannot be resolved\n          */\n-        public BackgroundInitializer<?> getInitializer(String name) {\n+        public BackgroundInitializer<?> getInitializer(final String name) {\n             return checkName(name);\n         }\n \n          * BackgroundInitializer}\n          * @throws NoSuchElementException if the name cannot be resolved\n          */\n-        public Object getResultObject(String name) {\n+        public Object getResultObject(final String name) {\n             checkName(name);\n             return resultObjects.get(name);\n         }\n          * @return a flag whether this initializer caused an exception\n          * @throws NoSuchElementException if the name cannot be resolved\n          */\n-        public boolean isException(String name) {\n+        public boolean isException(final String name) {\n             checkName(name);\n             return exceptions.containsKey(name);\n         }\n          * @return the exception thrown by this initializer\n          * @throws NoSuchElementException if the name cannot be resolved\n          */\n-        public ConcurrentException getException(String name) {\n+        public ConcurrentException getException(final String name) {\n             checkName(name);\n             return exceptions.get(name);\n         }\n          * @return the initializer with this name\n          * @throws NoSuchElementException if the name is unknown\n          */\n-        private BackgroundInitializer<?> checkName(String name) {\n+        private BackgroundInitializer<?> checkName(final String name) {\n             BackgroundInitializer<?> init = initializers.get(name);\n             if (init == null) {\n                 throw new NoSuchElementException(\n--- a/src/main/java/org/apache/commons/lang3/concurrent/TimedSemaphore.java\n+++ b/src/main/java/org/apache/commons/lang3/concurrent/TimedSemaphore.java\n      * @param limit the limit for the semaphore\n      * @throws IllegalArgumentException if the period is less or equals 0\n      */\n-    public TimedSemaphore(long timePeriod, TimeUnit timeUnit, int limit) {\n+    public TimedSemaphore(final long timePeriod, final TimeUnit timeUnit, final int limit) {\n         this(null, timePeriod, timeUnit, limit);\n     }\n \n      * @param limit the limit for the semaphore\n      * @throws IllegalArgumentException if the period is less or equals 0\n      */\n-    public TimedSemaphore(ScheduledExecutorService service, long timePeriod,\n-            TimeUnit timeUnit, int limit) {\n+    public TimedSemaphore(final ScheduledExecutorService service, final long timePeriod,\n+            final TimeUnit timeUnit, final int limit) {\n         if (timePeriod <= 0) {\n             throw new IllegalArgumentException(\"Time period must be greater 0!\");\n         }\n      *\n      * @param limit the limit\n      */\n-    public final synchronized void setLimit(int limit) {\n+    public final synchronized void setLimit(final int limit) {\n         this.limit = limit;\n     }\n \n--- a/src/main/java/org/apache/commons/lang3/event/EventListenerSupport.java\n+++ b/src/main/java/org/apache/commons/lang3/event/EventListenerSupport.java\n      * @throws IllegalArgumentException if <code>listenerInterface</code> is\n      *         not an interface.\n      */\n-    public static <T> EventListenerSupport<T> create(Class<T> listenerInterface) {\n+    public static <T> EventListenerSupport<T> create(final Class<T> listenerInterface) {\n         return new EventListenerSupport<T>(listenerInterface);\n     }\n \n      * @throws IllegalArgumentException if <code>listenerInterface</code> is\n      *         not an interface.\n      */\n-    public EventListenerSupport(Class<L> listenerInterface) {\n+    public EventListenerSupport(final Class<L> listenerInterface) {\n         this(listenerInterface, Thread.currentThread().getContextClassLoader());\n     }\n \n      * @throws IllegalArgumentException if <code>listenerInterface</code> is\n      *         not an interface.\n      */\n-    public EventListenerSupport(Class<L> listenerInterface, ClassLoader classLoader) {\n+    public EventListenerSupport(final Class<L> listenerInterface, final ClassLoader classLoader) {\n         this();\n         Validate.notNull(listenerInterface, \"Listener interface cannot be null.\");\n         Validate.notNull(classLoader, \"ClassLoader cannot be null.\");\n      * @throws NullPointerException if <code>listener</code> is\n      *         <code>null</code>.\n      */\n-    public void addListener(L listener) {\n+    public void addListener(final L listener) {\n         Validate.notNull(listener, \"Listener object cannot be null.\");\n         listeners.add(listener);\n     }\n      * @throws NullPointerException if <code>listener</code> is\n      *         <code>null</code>.\n      */\n-    public void removeListener(L listener) {\n+    public void removeListener(final L listener) {\n         Validate.notNull(listener, \"Listener object cannot be null.\");\n         listeners.remove(listener);\n     }\n      * @param objectOutputStream the output stream\n      * @throws IOException if an IO error occurs\n      */\n-    private void writeObject(ObjectOutputStream objectOutputStream) throws IOException {\n+    private void writeObject(final ObjectOutputStream objectOutputStream) throws IOException {\n         ArrayList<L> serializableListeners = new ArrayList<L>();\n \n         // don't just rely on instanceof Serializable:\n      * @throws IOException if an IO error occurs\n      * @throws ClassNotFoundException if the class cannot be resolved\n      */\n-    private void readObject(ObjectInputStream objectInputStream) throws IOException, ClassNotFoundException {\n+    private void readObject(final ObjectInputStream objectInputStream) throws IOException, ClassNotFoundException {\n         @SuppressWarnings(\"unchecked\") // Will throw CCE here if not correct\n         L[] listeners = (L[]) objectInputStream.readObject();\n \n      * @param listenerInterface the class of the listener interface\n      * @param classLoader the class loader to be used\n      */\n-    private void initializeTransientFields(Class<L> listenerInterface, ClassLoader classLoader) {\n+    private void initializeTransientFields(final Class<L> listenerInterface, final ClassLoader classLoader) {\n         @SuppressWarnings(\"unchecked\") // Will throw CCE here if not correct\n         L[] array = (L[]) Array.newInstance(listenerInterface, 0);\n         this.prototypeArray = array;\n      * @param listenerInterface the class of the listener interface\n      * @param classLoader the class loader to be used\n      */\n-    private void createProxy(Class<L> listenerInterface, ClassLoader classLoader) {\n+    private void createProxy(final Class<L> listenerInterface, final ClassLoader classLoader) {\n         proxy = listenerInterface.cast(Proxy.newProxyInstance(classLoader,\n                 new Class[] { listenerInterface }, createInvocationHandler()));\n     }\n          * @throws Throwable if an error occurs\n          */\n         @Override\n-        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n+        public Object invoke(final Object proxy, final Method method, final Object[] args) throws Throwable {\n             for (L listener : listeners) {\n                 method.invoke(listener, args);\n             }\n--- a/src/main/java/org/apache/commons/lang3/event/EventUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/event/EventUtils.java\n      *\n      * @throws IllegalArgumentException if the object doesn't support the listener type\n      */\n-    public static <L> void addEventListener(Object eventSource, Class<L> listenerType, L listener) {\n+    public static <L> void addEventListener(final Object eventSource, final Class<L> listenerType, final L listener) {\n         try {\n             MethodUtils.invokeMethod(eventSource, \"add\" + listenerType.getSimpleName(), listener);\n         } catch (NoSuchMethodException e) {\n      * @param eventTypes   the event types (method names) from the listener interface (if none specified, all will be\n      *                     supported)\n      */\n-    public static <L> void bindEventsToMethod(Object target, String methodName, Object eventSource,\n-            Class<L> listenerType, String... eventTypes) {\n+    public static <L> void bindEventsToMethod(final Object target, final String methodName, final Object eventSource,\n+            final Class<L> listenerType, final String... eventTypes) {\n         final L listener = listenerType.cast(Proxy.newProxyInstance(target.getClass().getClassLoader(),\n                 new Class[] { listenerType }, new EventBindingInvocationHandler(target, methodName, eventTypes)));\n         addEventListener(eventSource, listenerType, listener);\n          * @param methodName the name of the method to be invoked\n          * @param eventTypes the names of the supported event types\n          */\n-        EventBindingInvocationHandler(final Object target, final String methodName, String[] eventTypes) {\n+        EventBindingInvocationHandler(final Object target, final String methodName, final String[] eventTypes) {\n             this.target = target;\n             this.methodName = methodName;\n             this.eventTypes = new HashSet<String>(Arrays.asList(eventTypes));\n--- a/src/main/java/org/apache/commons/lang3/exception/ContextedException.java\n+++ b/src/main/java/org/apache/commons/lang3/exception/ContextedException.java\n      * \n      * @param message  the exception message, may be null\n      */\n-    public ContextedException(String message) {\n+    public ContextedException(final String message) {\n         super(message);\n         exceptionContext = new DefaultExceptionContext();\n     }\n      * \n      * @param cause  the underlying cause of the exception, may be null\n      */\n-    public ContextedException(Throwable cause) {\n+    public ContextedException(final Throwable cause) {\n         super(cause);\n         exceptionContext = new DefaultExceptionContext();\n     }\n      * @param message  the exception message, may be null\n      * @param cause  the underlying cause of the exception, may be null\n      */\n-    public ContextedException(String message, Throwable cause) {\n+    public ContextedException(final String message, final Throwable cause) {\n         super(message, cause);\n         exceptionContext = new DefaultExceptionContext();\n     }\n      * @param cause  the underlying cause of the exception, may be null\n      * @param context  the context used to store the additional information, null uses default implementation\n      */\n-    public ContextedException(String message, Throwable cause, ExceptionContext context) {\n+    public ContextedException(final String message, final Throwable cause, ExceptionContext context) {\n         super(message, cause);\n         if (context == null) {\n             context = new DefaultExceptionContext();\n      * @return {@code this}, for method chaining, not {@code null}\n      */\n     @Override\n-    public ContextedException addContextValue(String label, Object value) {        \n+    public ContextedException addContextValue(final String label, final Object value) {        \n         exceptionContext.addContextValue(label, value);\n         return this;\n     }\n      * @return {@code this}, for method chaining, not {@code null}\n      */\n     @Override\n-    public ContextedException setContextValue(String label, Object value) {        \n+    public ContextedException setContextValue(final String label, final Object value) {        \n         exceptionContext.setContextValue(label, value);\n         return this;\n     }\n      * {@inheritDoc}\n      */\n     @Override\n-    public List<Object> getContextValues(String label) {\n+    public List<Object> getContextValues(final String label) {\n         return this.exceptionContext.getContextValues(label);\n     }\n \n      * {@inheritDoc}\n      */\n     @Override\n-    public Object getFirstContextValue(String label) {\n+    public Object getFirstContextValue(final String label) {\n         return this.exceptionContext.getFirstContextValue(label);\n     }\n \n      * {@inheritDoc}\n      */\n     @Override\n-    public String getFormattedExceptionMessage(String baseMessage) {\n+    public String getFormattedExceptionMessage(final String baseMessage) {\n         return exceptionContext.getFormattedExceptionMessage(baseMessage);\n     }\n }\n--- a/src/main/java/org/apache/commons/lang3/exception/ContextedRuntimeException.java\n+++ b/src/main/java/org/apache/commons/lang3/exception/ContextedRuntimeException.java\n      * \n      * @param message  the exception message, may be null\n      */\n-    public ContextedRuntimeException(String message) {\n+    public ContextedRuntimeException(final String message) {\n         super(message);\n         exceptionContext = new DefaultExceptionContext();\n     }\n      * \n      * @param cause  the underlying cause of the exception, may be null\n      */\n-    public ContextedRuntimeException(Throwable cause) {\n+    public ContextedRuntimeException(final Throwable cause) {\n         super(cause);\n         exceptionContext = new DefaultExceptionContext();\n     }\n      * @param message  the exception message, may be null\n      * @param cause  the underlying cause of the exception, may be null\n      */\n-    public ContextedRuntimeException(String message, Throwable cause) {\n+    public ContextedRuntimeException(final String message, final Throwable cause) {\n         super(message, cause);\n         exceptionContext = new DefaultExceptionContext();\n     }\n      * @param cause  the underlying cause of the exception, may be null\n      * @param context  the context used to store the additional information, null uses default implementation\n      */\n-    public ContextedRuntimeException(String message, Throwable cause, ExceptionContext context) {\n+    public ContextedRuntimeException(final String message, final Throwable cause, ExceptionContext context) {\n         super(message, cause);\n         if (context == null) {\n             context = new DefaultExceptionContext();\n      * @return {@code this}, for method chaining, not {@code null}\n      */\n     @Override\n-    public ContextedRuntimeException addContextValue(String label, Object value) {        \n+    public ContextedRuntimeException addContextValue(final String label, final Object value) {        \n         exceptionContext.addContextValue(label, value);\n         return this;\n     }\n      * @return {@code this}, for method chaining, not {@code null}\n      */\n     @Override\n-    public ContextedRuntimeException setContextValue(String label, Object value) {        \n+    public ContextedRuntimeException setContextValue(final String label, final Object value) {        \n         exceptionContext.setContextValue(label, value);\n         return this;\n     }\n      * {@inheritDoc}\n      */\n     @Override\n-    public List<Object> getContextValues(String label) {\n+    public List<Object> getContextValues(final String label) {\n         return this.exceptionContext.getContextValues(label);\n     }\n \n      * {@inheritDoc}\n      */\n     @Override\n-    public Object getFirstContextValue(String label) {\n+    public Object getFirstContextValue(final String label) {\n         return this.exceptionContext.getFirstContextValue(label);\n     }\n \n      * {@inheritDoc}\n      */\n     @Override\n-    public String getFormattedExceptionMessage(String baseMessage) {\n+    public String getFormattedExceptionMessage(final String baseMessage) {\n         return exceptionContext.getFormattedExceptionMessage(baseMessage);\n     }\n \n--- a/src/main/java/org/apache/commons/lang3/exception/DefaultExceptionContext.java\n+++ b/src/main/java/org/apache/commons/lang3/exception/DefaultExceptionContext.java\n      * {@inheritDoc}\n      */\n     @Override\n-    public DefaultExceptionContext addContextValue(String label, Object value) {\n+    public DefaultExceptionContext addContextValue(final String label, final Object value) {\n         contextValues.add(new ImmutablePair<String, Object>(label, value));\n         return this;\n     }\n      * {@inheritDoc}\n      */\n     @Override\n-    public DefaultExceptionContext setContextValue(String label, Object value) {\n+    public DefaultExceptionContext setContextValue(final String label, final Object value) {\n         for (final Iterator<Pair<String, Object>> iter = contextValues.iterator(); iter.hasNext();) {\n             final Pair<String, Object> p = iter.next();\n             if (StringUtils.equals(label, p.getKey())) {\n      * {@inheritDoc}\n      */\n     @Override\n-    public List<Object> getContextValues(String label) {\n+    public List<Object> getContextValues(final String label) {\n         final List<Object> values = new ArrayList<Object>();\n         for (final Pair<String, Object> pair : contextValues) {\n             if (StringUtils.equals(label, pair.getKey())) {\n      * {@inheritDoc}\n      */\n     @Override\n-    public Object getFirstContextValue(String label) {\n+    public Object getFirstContextValue(final String label) {\n         for (final Pair<String, Object> pair : contextValues) {\n             if (StringUtils.equals(label, pair.getKey())) {\n                 return pair.getValue();\n      * @return the exception message <b>with</b> context information appended, never null\n      */\n     @Override\n-    public String getFormattedExceptionMessage(String baseMessage){\n+    public String getFormattedExceptionMessage(final String baseMessage){\n         StringBuilder buffer = new StringBuilder(256);\n         if (baseMessage != null) {\n             buffer.append(baseMessage);\n--- a/src/main/java/org/apache/commons/lang3/exception/ExceptionUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/exception/ExceptionUtils.java\n      * @deprecated This feature will be removed in Lang 4.0\n      */\n     @Deprecated\n-    public static Throwable getCause(Throwable throwable) {\n+    public static Throwable getCause(final Throwable throwable) {\n         return getCause(throwable, CAUSE_METHOD_NAMES);\n     }\n \n      * @deprecated This feature will be removed in Lang 4.0\n      */\n     @Deprecated\n-    public static Throwable getCause(Throwable throwable, String[] methodNames) {\n+    public static Throwable getCause(final Throwable throwable, String[] methodNames) {\n         if (throwable == null) {\n             return null;\n         }\n      * @return the root cause of the <code>Throwable</code>,\n      *  <code>null</code> if none found or null throwable input\n      */\n-    public static Throwable getRootCause(Throwable throwable) {\n+    public static Throwable getRootCause(final Throwable throwable) {\n         List<Throwable> list = getThrowableList(throwable);\n         return list.size() < 2 ? null : (Throwable)list.get(list.size() - 1);\n     }\n      * @return the wrapped exception, or <code>null</code> if not found\n      */\n     // TODO: Remove in Lang 4.0\n-    private static Throwable getCauseUsingMethodName(Throwable throwable, String methodName) {\n+    private static Throwable getCauseUsingMethodName(final Throwable throwable, final String methodName) {\n         Method method = null;\n         try {\n             method = throwable.getClass().getMethod(methodName);\n      * @param throwable  the throwable to inspect, may be null\n      * @return the count of throwables, zero if null input\n      */\n-    public static int getThrowableCount(Throwable throwable) {\n+    public static int getThrowableCount(final Throwable throwable) {\n         return getThrowableList(throwable).size();\n     }\n \n      * @param throwable  the throwable to inspect, may be null\n      * @return the array of throwables, never null\n      */\n-    public static Throwable[] getThrowables(Throwable throwable) {\n+    public static Throwable[] getThrowables(final Throwable throwable) {\n         List<Throwable> list = getThrowableList(throwable);\n         return list.toArray(new Throwable[list.size()]);\n     }\n      * @param clazz  the class to search for, subclasses do not match, null returns -1\n      * @return the index into the throwable chain, -1 if no match or null input\n      */\n-    public static int indexOfThrowable(Throwable throwable, Class<?> clazz) {\n+    public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz) {\n         return indexOf(throwable, clazz, 0, false);\n     }\n \n      *  negative treated as zero, larger than chain size returns -1\n      * @return the index into the throwable chain, -1 if no match or null input\n      */\n-    public static int indexOfThrowable(Throwable throwable, Class<?> clazz, int fromIndex) {\n+    public static int indexOfThrowable(final Throwable throwable, final Class<?> clazz, final int fromIndex) {\n         return indexOf(throwable, clazz, fromIndex, false);\n     }\n \n      * @return the index into the throwable chain, -1 if no match or null input\n      * @since 2.1\n      */\n-    public static int indexOfType(Throwable throwable, Class<?> type) {\n+    public static int indexOfType(final Throwable throwable, final Class<?> type) {\n         return indexOf(throwable, type, 0, true);\n     }\n \n      * @return the index into the throwable chain, -1 if no match or null input\n      * @since 2.1\n      */\n-    public static int indexOfType(Throwable throwable, Class<?> type, int fromIndex) {\n+    public static int indexOfType(final Throwable throwable, final Class<?> type, final int fromIndex) {\n         return indexOf(throwable, type, fromIndex, true);\n     }\n \n      * using references\n      * @return index of the <code>type</code> within throwables nested within the specified <code>throwable</code>\n      */\n-    private static int indexOf(Throwable throwable, Class<?> type, int fromIndex, boolean subclass) {\n+    private static int indexOf(final Throwable throwable, final Class<?> type, int fromIndex, final boolean subclass) {\n         if (throwable == null || type == null) {\n             return -1;\n         }\n      * @param throwable  the throwable to output\n      * @since 2.0\n      */\n-    public static void printRootCauseStackTrace(Throwable throwable) {\n+    public static void printRootCauseStackTrace(final Throwable throwable) {\n         printRootCauseStackTrace(throwable, System.err);\n     }\n \n      * @throws IllegalArgumentException if the stream is <code>null</code>\n      * @since 2.0\n      */\n-    public static void printRootCauseStackTrace(Throwable throwable, PrintStream stream) {\n+    public static void printRootCauseStackTrace(final Throwable throwable, final PrintStream stream) {\n         if (throwable == null) {\n             return;\n         }\n      * @throws IllegalArgumentException if the writer is <code>null</code>\n      * @since 2.0\n      */\n-    public static void printRootCauseStackTrace(Throwable throwable, PrintWriter writer) {\n+    public static void printRootCauseStackTrace(final Throwable throwable, final PrintWriter writer) {\n         if (throwable == null) {\n             return;\n         }\n      * @return an array of stack trace frames, never null\n      * @since 2.0\n      */\n-    public static String[] getRootCauseStackTrace(Throwable throwable) {\n+    public static String[] getRootCauseStackTrace(final Throwable throwable) {\n         if (throwable == null) {\n             return ArrayUtils.EMPTY_STRING_ARRAY;\n         }\n      * @throws IllegalArgumentException if either argument is null\n      * @since 2.0\n      */\n-    public static void removeCommonFrames(List<String> causeFrames, List<String> wrapperFrames) {\n+    public static void removeCommonFrames(final List<String> causeFrames, final List<String> wrapperFrames) {\n         if (causeFrames == null || wrapperFrames == null) {\n             throw new IllegalArgumentException(\"The List must not be null\");\n         }\n      * @return the stack trace as generated by the exception's\n      *  <code>printStackTrace(PrintWriter)</code> method\n      */\n-    public static String getStackTrace(Throwable throwable) {\n+    public static String getStackTrace(final Throwable throwable) {\n         StringWriter sw = new StringWriter();\n         PrintWriter pw = new PrintWriter(sw, true);\n         throwable.printStackTrace(pw);\n      * @param throwable  the <code>Throwable</code> to examine, may be null\n      * @return an array of strings describing each stack frame, never null\n      */\n-    public static String[] getStackFrames(Throwable throwable) {\n+    public static String[] getStackFrames(final Throwable throwable) {\n         if (throwable == null) {\n             return ArrayUtils.EMPTY_STRING_ARRAY;\n         }\n      * @param stackTrace  a stack trace String\n      * @return an array where each element is a line from the argument\n      */\n-    static String[] getStackFrames(String stackTrace) {\n+    static String[] getStackFrames(final String stackTrace) {\n         String linebreak = SystemUtils.LINE_SEPARATOR;\n         StringTokenizer frames = new StringTokenizer(stackTrace, linebreak);\n         List<String> list = new ArrayList<String>();\n      * @param t is any throwable\n      * @return List of stack frames\n      */\n-    static List<String> getStackFrameList(Throwable t) {\n+    static List<String> getStackFrameList(final Throwable t) {\n         String stackTrace = getStackTrace(t);\n         String linebreak = SystemUtils.LINE_SEPARATOR;\n         StringTokenizer frames = new StringTokenizer(stackTrace, linebreak);\n      * @return the message, non-null\n      * @since Commons Lang 2.2\n      */\n-    public static String getMessage(Throwable th) {\n+    public static String getMessage(final Throwable th) {\n         if (th == null) {\n             return \"\";\n         }\n      * @return the message, non-null\n      * @since Commons Lang 2.2\n      */\n-    public static String getRootCauseMessage(Throwable th) {\n+    public static String getRootCauseMessage(final Throwable th) {\n         Throwable root = ExceptionUtils.getRootCause(th);\n         root = root == null ? th : root;\n         return getMessage(root);\n--- a/src/main/java/org/apache/commons/lang3/math/Fraction.java\n+++ b/src/main/java/org/apache/commons/lang3/math/Fraction.java\n      * @param numerator  the numerator, for example the three in 'three sevenths'\n      * @param denominator  the denominator, for example the seven in 'three sevenths'\n      */\n-    private Fraction(int numerator, int denominator) {\n+    private Fraction(final int numerator, final int denominator) {\n         super();\n         this.numerator = numerator;\n         this.denominator = denominator;\n      * @throws ArithmeticException if the resulting numerator exceeds \n      *  <code>Integer.MAX_VALUE</code>\n      */\n-    public static Fraction getFraction(int whole, int numerator, int denominator) {\n+    public static Fraction getFraction(final int whole, final int numerator, final int denominator) {\n         if (denominator == 0) {\n             throw new ArithmeticException(\"The denominator must not be zero\");\n         }\n      * @throws ArithmeticException if the resulting numerator or denominator exceeds\n      *  <code>Integer.MAX_VALUE</code>\n      */\n-    public Fraction pow(int power) {\n+    public Fraction pow(final int power) {\n         if (power == 1) {\n             return this;\n         } else if (power == 0) {\n      * @throws ArithmeticException if the result can not be represented as\n      *                             an int\n      */\n-    private static int mulAndCheck(int x, int y) {\n+    private static int mulAndCheck(final int x, final int y) {\n         long m = (long)x*(long)y;\n         if (m < Integer.MIN_VALUE ||\n             m > Integer.MAX_VALUE) {\n      * @throws ArithmeticException if the result can not be represented as\n      * an int\n      */\n-    private static int mulPosAndCheck(int x, int y) {\n+    private static int mulPosAndCheck(final int x, final int y) {\n         /* assert x>=0 && y>=0; */\n         long m = (long)x*(long)y;\n         if (m > Integer.MAX_VALUE) {\n      * @throws ArithmeticException if the result can not be represented as\n      * an int\n      */\n-    private static int addAndCheck(int x, int y) {\n+    private static int addAndCheck(final int x, final int y) {\n         long s = (long)x+(long)y;\n         if (s < Integer.MIN_VALUE ||\n             s > Integer.MAX_VALUE) {\n      * @throws ArithmeticException if the result can not be represented as\n      * an int\n      */\n-    private static int subAndCheck(int x, int y) {\n+    private static int subAndCheck(final int x, final int y) {\n         long s = (long)x-(long)y;\n         if (s < Integer.MIN_VALUE ||\n             s > Integer.MAX_VALUE) {\n      * @throws ArithmeticException if the resulting numerator or denominator exceeds\n      *  <code>Integer.MAX_VALUE</code>\n      */\n-    public Fraction add(Fraction fraction) {\n+    public Fraction add(final Fraction fraction) {\n         return addSub(fraction, true /* add */);\n     }\n \n      * @throws ArithmeticException if the resulting numerator or denominator\n      *   cannot be represented in an <code>int</code>.\n      */\n-    public Fraction subtract(Fraction fraction) {\n+    public Fraction subtract(final Fraction fraction) {\n         return addSub(fraction, false /* subtract */);\n     }\n \n      * @throws ArithmeticException if the resulting numerator or denominator\n      *   cannot be represented in an <code>int</code>.\n      */\n-    private Fraction addSub(Fraction fraction, boolean isAdd) {\n+    private Fraction addSub(final Fraction fraction, final boolean isAdd) {\n         if (fraction == null) {\n             throw new IllegalArgumentException(\"The fraction must not be null\");\n         }\n      * @throws ArithmeticException if the resulting numerator or denominator exceeds\n      *  <code>Integer.MAX_VALUE</code>\n      */\n-    public Fraction multiplyBy(Fraction fraction) {\n+    public Fraction multiplyBy(final Fraction fraction) {\n         if (fraction == null) {\n             throw new IllegalArgumentException(\"The fraction must not be null\");\n         }\n      * @throws ArithmeticException if the resulting numerator or denominator exceeds\n      *  <code>Integer.MAX_VALUE</code>\n      */\n-    public Fraction divideBy(Fraction fraction) {\n+    public Fraction divideBy(final Fraction fraction) {\n         if (fraction == null) {\n             throw new IllegalArgumentException(\"The fraction must not be null\");\n         }\n      * @return <code>true</code> if this object is equal\n      */\n     @Override\n-    public boolean equals(Object obj) {\n+    public boolean equals(final Object obj) {\n         if (obj == this) {\n             return true;\n         }\n      * @throws NullPointerException if the object is <code>null</code>\n      */\n     @Override\n-    public int compareTo(Fraction other) {\n+    public int compareTo(final Fraction other) {\n         if (this==other) {\n             return 0;\n         }\n--- a/src/main/java/org/apache/commons/lang3/math/IEEE754rUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/math/IEEE754rUtils.java\n      * @throws IllegalArgumentException if <code>array</code> is <code>null</code>\n      * @throws IllegalArgumentException if <code>array</code> is empty\n      */\n-    public static double min(double[] array) {\n+    public static double min(final double[] array) {\n         // Validates input\n         if (array == null) {\n             throw new IllegalArgumentException(\"The Array must not be null\");\n      * @throws IllegalArgumentException if <code>array</code> is <code>null</code>\n      * @throws IllegalArgumentException if <code>array</code> is empty\n      */\n-    public static float min(float[] array) {\n+    public static float min(final float[] array) {\n         // Validates input\n         if (array == null) {\n             throw new IllegalArgumentException(\"The Array must not be null\");\n      * @param c  value 3\n      * @return  the smallest of the values\n      */\n-    public static double min(double a, double b, double c) {\n+    public static double min(final double a, final double b, final double c) {\n         return min(min(a, b), c);\n     }\n \n      * @param b  value 2\n      * @return  the smallest of the values\n      */\n-    public static double min(double a, double b) {\n+    public static double min(final double a, final double b) {\n         if(Double.isNaN(a)) {\n             return b;\n         } else\n      * @param c  value 3\n      * @return  the smallest of the values\n      */\n-    public static float min(float a, float b, float c) {\n+    public static float min(final float a, final float b, final float c) {\n         return min(min(a, b), c);\n     }\n \n      * @param b  value 2\n      * @return  the smallest of the values\n      */\n-    public static float min(float a, float b) {\n+    public static float min(final float a, final float b) {\n         if(Float.isNaN(a)) {\n             return b;\n         } else\n      * @throws IllegalArgumentException if <code>array</code> is <code>null</code>\n      * @throws IllegalArgumentException if <code>array</code> is empty\n      */\n-    public static double max(double[] array) {\n+    public static double max(final double[] array) {\n         // Validates input\n         if (array== null) {\n             throw new IllegalArgumentException(\"The Array must not be null\");\n      * @throws IllegalArgumentException if <code>array</code> is <code>null</code>\n      * @throws IllegalArgumentException if <code>array</code> is empty\n      */\n-    public static float max(float[] array) {\n+    public static float max(final float[] array) {\n         // Validates input\n         if (array == null) {\n             throw new IllegalArgumentException(\"The Array must not be null\");\n      * @param c  value 3\n      * @return  the largest of the values\n      */\n-    public static double max(double a, double b, double c) {\n+    public static double max(final double a, final double b, final double c) {\n         return max(max(a, b), c);\n     }\n \n      * @param b  value 2\n      * @return  the largest of the values\n      */\n-    public static double max(double a, double b) {\n+    public static double max(final double a, final double b) {\n         if(Double.isNaN(a)) {\n             return b;\n         } else\n      * @param c  value 3\n      * @return  the largest of the values\n      */\n-    public static float max(float a, float b, float c) {\n+    public static float max(final float a, final float b, final float c) {\n         return max(max(a, b), c);\n     }\n \n      * @param b  value 2\n      * @return  the largest of the values\n      */\n-    public static float max(float a, float b) {\n+    public static float max(final float a, final float b) {\n         if(Float.isNaN(a)) {\n             return b;\n         } else\n--- a/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\n      *  conversion fails\n      * @since 2.1\n      */\n-    public static int toInt(String str) {\n+    public static int toInt(final String str) {\n         return toInt(str, 0);\n     }\n \n      * @return the int represented by the string, or the default if conversion fails\n      * @since 2.1\n      */\n-    public static int toInt(String str, int defaultValue) {\n+    public static int toInt(final String str, final int defaultValue) {\n         if(str == null) {\n             return defaultValue;\n         }\n      *  conversion fails\n      * @since 2.1\n      */\n-    public static long toLong(String str) {\n+    public static long toLong(final String str) {\n         return toLong(str, 0L);\n     }\n \n      * @return the long represented by the string, or the default if conversion fails\n      * @since 2.1\n      */\n-    public static long toLong(String str, long defaultValue) {\n+    public static long toLong(final String str, final long defaultValue) {\n         if (str == null) {\n             return defaultValue;\n         }\n      *  if conversion fails\n      * @since 2.1\n      */\n-    public static float toFloat(String str) {\n+    public static float toFloat(final String str) {\n         return toFloat(str, 0.0f);\n     }\n \n      *  if conversion fails\n      * @since 2.1\n      */\n-    public static float toFloat(String str, float defaultValue) {\n+    public static float toFloat(final String str, final float defaultValue) {\n       if (str == null) {\n           return defaultValue;\n       }     \n      *  if conversion fails\n      * @since 2.1\n      */\n-    public static double toDouble(String str) {\n+    public static double toDouble(final String str) {\n         return toDouble(str, 0.0d);\n     }\n \n      *  if conversion fails\n      * @since 2.1\n      */\n-    public static double toDouble(String str, double defaultValue) {\n+    public static double toDouble(final String str, final double defaultValue) {\n       if (str == null) {\n           return defaultValue;\n       }\n      *  conversion fails\n      * @since 2.5\n      */\n-    public static byte toByte(String str) {\n+    public static byte toByte(final String str) {\n         return toByte(str, (byte) 0);\n     }\n \n      * @return the byte represented by the string, or the default if conversion fails\n      * @since 2.5\n      */\n-    public static byte toByte(String str, byte defaultValue) {\n+    public static byte toByte(final String str, final byte defaultValue) {\n         if(str == null) {\n             return defaultValue;\n         }\n      *  conversion fails\n      * @since 2.5\n      */\n-    public static short toShort(String str) {\n+    public static short toShort(final String str) {\n         return toShort(str, (short) 0);\n     }\n \n      * @return the short represented by the string, or the default if conversion fails\n      * @since 2.5\n      */\n-    public static short toShort(String str, short defaultValue) {\n+    public static short toShort(final String str, final short defaultValue) {\n         if(str == null) {\n             return defaultValue;\n         }\n      * @return Number created from the string (or null if the input is null)\n      * @throws NumberFormatException if the value cannot be converted\n      */\n-    public static Number createNumber(String str) throws NumberFormatException {\n+    public static Number createNumber(final String str) throws NumberFormatException {\n         if (str == null) {\n             return null;\n         }\n      * @param str  the String to check\n      * @return if it is all zeros or <code>null</code>\n      */\n-    private static boolean isAllZeros(String str) {\n+    private static boolean isAllZeros(final String str) {\n         if (str == null) {\n             return true;\n         }\n      * @return converted <code>Float</code> (or null if the input is null)\n      * @throws NumberFormatException if the value cannot be converted\n      */\n-    public static Float createFloat(String str) {\n+    public static Float createFloat(final String str) {\n         if (str == null) {\n             return null;\n         }\n      * @return converted <code>Double</code> (or null if the input is null)\n      * @throws NumberFormatException if the value cannot be converted\n      */\n-    public static Double createDouble(String str) {\n+    public static Double createDouble(final String str) {\n         if (str == null) {\n             return null;\n         }\n      * @return converted <code>Integer</code> (or null if the input is null)\n      * @throws NumberFormatException if the value cannot be converted\n      */\n-    public static Integer createInteger(String str) {\n+    public static Integer createInteger(final String str) {\n         if (str == null) {\n             return null;\n         }\n      * @return converted <code>Long</code> (or null if the input is null)\n      * @throws NumberFormatException if the value cannot be converted\n      */\n-    public static Long createLong(String str) {\n+    public static Long createLong(final String str) {\n         if (str == null) {\n             return null;\n         }\n      * @return converted <code>BigInteger</code> (or null if the input is null)\n      * @throws NumberFormatException if the value cannot be converted\n      */\n-    public static BigInteger createBigInteger(String str) {\n+    public static BigInteger createBigInteger(final String str) {\n         if (str == null) {\n             return null;\n         }\n      * @return converted <code>BigDecimal</code> (or null if the input is null)\n      * @throws NumberFormatException if the value cannot be converted\n      */\n-    public static BigDecimal createBigDecimal(String str) {\n+    public static BigDecimal createBigDecimal(final String str) {\n         if (str == null) {\n             return null;\n         }\n      * @throws IllegalArgumentException if <code>array</code> is <code>null</code>\n      * @throws IllegalArgumentException if <code>array</code> is empty\n      */\n-    public static long min(long[] array) {\n+    public static long min(final long[] array) {\n         // Validates input\n         validateArray(array);\n     \n      * @throws IllegalArgumentException if <code>array</code> is <code>null</code>\n      * @throws IllegalArgumentException if <code>array</code> is empty\n      */\n-    public static int min(int[] array) {\n+    public static int min(final int[] array) {\n         // Validates input\n         validateArray(array);\n     \n      * @throws IllegalArgumentException if <code>array</code> is <code>null</code>\n      * @throws IllegalArgumentException if <code>array</code> is empty\n      */\n-    public static short min(short[] array) {\n+    public static short min(final short[] array) {\n         // Validates input\n         validateArray(array);\n     \n      * @throws IllegalArgumentException if <code>array</code> is <code>null</code>\n      * @throws IllegalArgumentException if <code>array</code> is empty\n      */\n-    public static byte min(byte[] array) {\n+    public static byte min(final byte[] array) {\n         // Validates input\n         validateArray(array);\n     \n      * @throws IllegalArgumentException if <code>array</code> is empty\n      * @see IEEE754rUtils#min(double[]) IEEE754rUtils for a version of this method that handles NaN differently\n      */\n-    public static double min(double[] array) {\n+    public static double min(final double[] array) {\n         // Validates input\n         validateArray(array);\n     \n      * @throws IllegalArgumentException if <code>array</code> is empty\n      * @see IEEE754rUtils#min(float[]) IEEE754rUtils for a version of this method that handles NaN differently\n      */\n-    public static float min(float[] array) {\n+    public static float min(final float[] array) {\n         // Validates input\n         validateArray(array);\n     \n      * @throws IllegalArgumentException if <code>array</code> is <code>null</code>\n      * @throws IllegalArgumentException if <code>array</code> is empty\n      */\n-    public static long max(long[] array) {\n+    public static long max(final long[] array) {\n         // Validates input\n         validateArray(array);\n \n      * @throws IllegalArgumentException if <code>array</code> is <code>null</code>\n      * @throws IllegalArgumentException if <code>array</code> is empty\n      */\n-    public static int max(int[] array) {\n+    public static int max(final int[] array) {\n         // Validates input\n         validateArray(array);\n     \n      * @throws IllegalArgumentException if <code>array</code> is <code>null</code>\n      * @throws IllegalArgumentException if <code>array</code> is empty\n      */\n-    public static short max(short[] array) {\n+    public static short max(final short[] array) {\n         // Validates input\n         validateArray(array);\n     \n      * @throws IllegalArgumentException if <code>array</code> is <code>null</code>\n      * @throws IllegalArgumentException if <code>array</code> is empty\n      */\n-    public static byte max(byte[] array) {\n+    public static byte max(final byte[] array) {\n         // Validates input\n         validateArray(array);\n     \n      * @throws IllegalArgumentException if <code>array</code> is empty\n      * @see IEEE754rUtils#max(double[]) IEEE754rUtils for a version of this method that handles NaN differently\n      */\n-    public static double max(double[] array) {\n+    public static double max(final double[] array) {\n         // Validates input\n         validateArray(array);\n \n      * @throws IllegalArgumentException if <code>array</code> is empty\n      * @see IEEE754rUtils#max(float[]) IEEE754rUtils for a version of this method that handles NaN differently\n      */\n-    public static float max(float[] array) {\n+    public static float max(final float[] array) {\n         // Validates input\n         validateArray(array);\n \n         return max;\n     }\n \n-    private static void validateArray(Object array) {\n+    private static void validateArray(final Object array) {\n         if (array == null) {\n             throw new IllegalArgumentException(\"The Array must not be null\");\n         } else if (Array.getLength(array) == 0) {\n      * @param c  value 3\n      * @return  the smallest of the values\n      */\n-    public static long min(long a, long b, long c) {\n+    public static long min(long a, final long b, final long c) {\n         if (b < a) {\n             a = b;\n         }\n      * @param c  value 3\n      * @return  the smallest of the values\n      */\n-    public static int min(int a, int b, int c) {\n+    public static int min(int a, final int b, final int c) {\n         if (b < a) {\n             a = b;\n         }\n      * @param c  value 3\n      * @return  the smallest of the values\n      */\n-    public static short min(short a, short b, short c) {\n+    public static short min(short a, final short b, final short c) {\n         if (b < a) {\n             a = b;\n         }\n      * @param c  value 3\n      * @return  the smallest of the values\n      */\n-    public static byte min(byte a, byte b, byte c) {\n+    public static byte min(byte a, final byte b, final byte c) {\n         if (b < a) {\n             a = b;\n         }\n      * @return  the smallest of the values\n      * @see IEEE754rUtils#min(double, double, double) for a version of this method that handles NaN differently\n      */\n-    public static double min(double a, double b, double c) {\n+    public static double min(final double a, final double b, final double c) {\n         return Math.min(Math.min(a, b), c);\n     }\n \n      * @return  the smallest of the values\n      * @see IEEE754rUtils#min(float, float, float) for a version of this method that handles NaN differently\n      */\n-    public static float min(float a, float b, float c) {\n+    public static float min(final float a, final float b, final float c) {\n         return Math.min(Math.min(a, b), c);\n     }\n \n      * @param c  value 3\n      * @return  the largest of the values\n      */\n-    public static long max(long a, long b, long c) {\n+    public static long max(long a, final long b, final long c) {\n         if (b > a) {\n             a = b;\n         }\n      * @param c  value 3\n      * @return  the largest of the values\n      */\n-    public static int max(int a, int b, int c) {\n+    public static int max(int a, final int b, final int c) {\n         if (b > a) {\n             a = b;\n         }\n      * @param c  value 3\n      * @return  the largest of the values\n      */\n-    public static short max(short a, short b, short c) {\n+    public static short max(short a, final short b, final short c) {\n         if (b > a) {\n             a = b;\n         }\n      * @param c  value 3\n      * @return  the largest of the values\n      */\n-    public static byte max(byte a, byte b, byte c) {\n+    public static byte max(byte a, final byte b, final byte c) {\n         if (b > a) {\n             a = b;\n         }\n      * @return  the largest of the values\n      * @see IEEE754rUtils#max(double, double, double) for a version of this method that handles NaN differently\n      */\n-    public static double max(double a, double b, double c) {\n+    public static double max(final double a, final double b, final double c) {\n         return Math.max(Math.max(a, b), c);\n     }\n \n      * @return  the largest of the values\n      * @see IEEE754rUtils#max(float, float, float) for a version of this method that handles NaN differently\n      */\n-    public static float max(float a, float b, float c) {\n+    public static float max(final float a, final float b, final float c) {\n         return Math.max(Math.max(a, b), c);\n     }\n \n      * @param str  the <code>String</code> to check\n      * @return <code>true</code> if str contains only Unicode numeric\n      */\n-    public static boolean isDigits(String str) {\n+    public static boolean isDigits(final String str) {\n         if (StringUtils.isEmpty(str)) {\n             return false;\n         }\n      * @param str  the <code>String</code> to check\n      * @return <code>true</code> if the string is a correctly formatted number\n      */\n-    public static boolean isNumber(String str) {\n+    public static boolean isNumber(final String str) {\n         if (StringUtils.isEmpty(str)) {\n             return false;\n         }\n--- a/src/main/java/org/apache/commons/lang3/mutable/MutableBoolean.java\n+++ b/src/main/java/org/apache/commons/lang3/mutable/MutableBoolean.java\n      * \n      * @param value  the initial value to store\n      */\n-    public MutableBoolean(boolean value) {\n+    public MutableBoolean(final boolean value) {\n         super();\n         this.value = value;\n     }\n      * @param value  the initial value to store, not null\n      * @throws NullPointerException if the object is null\n      */\n-    public MutableBoolean(Boolean value) {\n+    public MutableBoolean(final Boolean value) {\n         super();\n         this.value = value.booleanValue();\n     }\n      * \n      * @param value  the value to set\n      */\n-    public void setValue(boolean value) {\n+    public void setValue(final boolean value) {\n         this.value = value;\n     }\n \n      * @throws NullPointerException if the object is null\n      */\n     @Override\n-    public void setValue(Boolean value) {\n+    public void setValue(final Boolean value) {\n         this.value = value.booleanValue();\n     }\n \n      * @return <code>true</code> if the objects are the same; <code>false</code> otherwise.\n      */\n     @Override\n-    public boolean equals(Object obj) {\n+    public boolean equals(final Object obj) {\n         if (obj instanceof MutableBoolean) {\n             return value == ((MutableBoolean) obj).booleanValue();\n         }\n      *  where false is less than true\n      */\n     @Override\n-    public int compareTo(MutableBoolean other) {\n+    public int compareTo(final MutableBoolean other) {\n         boolean anotherVal = other.value;\n         return value == anotherVal ? 0 : (value ? 1 : -1);\n     }\n--- a/src/main/java/org/apache/commons/lang3/mutable/MutableByte.java\n+++ b/src/main/java/org/apache/commons/lang3/mutable/MutableByte.java\n      * \n      * @param value  the initial value to store\n      */\n-    public MutableByte(byte value) {\n+    public MutableByte(final byte value) {\n         super();\n         this.value = value;\n     }\n      * @param value  the initial value to store, not null\n      * @throws NullPointerException if the object is null\n      */\n-    public MutableByte(Number value) {\n+    public MutableByte(final Number value) {\n         super();\n         this.value = value.byteValue();\n     }\n      * @throws NumberFormatException if the string cannot be parsed into a byte\n      * @since 2.5\n      */\n-    public MutableByte(String value) throws NumberFormatException {\n+    public MutableByte(final String value) throws NumberFormatException {\n         super();\n         this.value = Byte.parseByte(value);\n     }\n      * \n      * @param value  the value to set\n      */\n-    public void setValue(byte value) {\n+    public void setValue(final byte value) {\n         this.value = value;\n     }\n \n      * @throws NullPointerException if the object is null\n      */\n     @Override\n-    public void setValue(Number value) {\n+    public void setValue(final Number value) {\n         this.value = value.byteValue();\n     }\n \n      * @param operand  the value to add, not null\n      * @since Commons Lang 2.2\n      */\n-    public void add(byte operand) {\n+    public void add(final byte operand) {\n         this.value += operand;\n     }\n \n      * @throws NullPointerException if the object is null\n      * @since Commons Lang 2.2\n      */\n-    public void add(Number operand) {\n+    public void add(final Number operand) {\n         this.value += operand.byteValue();\n     }\n \n      * @param operand  the value to subtract, not null\n      * @since Commons Lang 2.2\n      */\n-    public void subtract(byte operand) {\n+    public void subtract(final byte operand) {\n         this.value -= operand;\n     }\n \n      * @throws NullPointerException if the object is null\n      * @since Commons Lang 2.2\n      */\n-    public void subtract(Number operand) {\n+    public void subtract(final Number operand) {\n         this.value -= operand.byteValue();\n     }\n \n      * @return <code>true</code> if the objects are the same; <code>false</code> otherwise.\n      */\n     @Override\n-    public boolean equals(Object obj) {\n+    public boolean equals(final Object obj) {\n         if (obj instanceof MutableByte) {\n             return value == ((MutableByte) obj).byteValue();\n         }\n      * @return negative if this is less, zero if equal, positive if greater\n      */\n     @Override\n-    public int compareTo(MutableByte other) {\n+    public int compareTo(final MutableByte other) {\n         byte anotherVal = other.value;\n         return value < anotherVal ? -1 : (value == anotherVal ? 0 : 1);\n     }\n--- a/src/main/java/org/apache/commons/lang3/mutable/MutableDouble.java\n+++ b/src/main/java/org/apache/commons/lang3/mutable/MutableDouble.java\n      * \n      * @param value  the initial value to store\n      */\n-    public MutableDouble(double value) {\n+    public MutableDouble(final double value) {\n         super();\n         this.value = value;\n     }\n      * @param value  the initial value to store, not null\n      * @throws NullPointerException if the object is null\n      */\n-    public MutableDouble(Number value) {\n+    public MutableDouble(final Number value) {\n         super();\n         this.value = value.doubleValue();\n     }\n      * @throws NumberFormatException if the string cannot be parsed into a double\n      * @since 2.5\n      */\n-    public MutableDouble(String value) throws NumberFormatException {\n+    public MutableDouble(final String value) throws NumberFormatException {\n         super();\n         this.value = Double.parseDouble(value);\n     }\n      * \n      * @param value  the value to set\n      */\n-    public void setValue(double value) {\n+    public void setValue(final double value) {\n         this.value = value;\n     }\n \n      * @throws NullPointerException if the object is null\n      */\n     @Override\n-    public void setValue(Number value) {\n+    public void setValue(final Number value) {\n         this.value = value.doubleValue();\n     }\n \n      * @param operand  the value to add\n      * @since Commons Lang 2.2\n      */\n-    public void add(double operand) {\n+    public void add(final double operand) {\n         this.value += operand;\n     }\n \n      * @throws NullPointerException if the object is null\n      * @since Commons Lang 2.2\n      */\n-    public void add(Number operand) {\n+    public void add(final Number operand) {\n         this.value += operand.doubleValue();\n     }\n \n      * @param operand  the value to subtract, not null\n      * @since Commons Lang 2.2\n      */\n-    public void subtract(double operand) {\n+    public void subtract(final double operand) {\n         this.value -= operand;\n     }\n \n      * @throws NullPointerException if the object is null\n      * @since Commons Lang 2.2\n      */\n-    public void subtract(Number operand) {\n+    public void subtract(final Number operand) {\n         this.value -= operand.doubleValue();\n     }\n \n      * @return <code>true</code> if the objects are the same; <code>false</code> otherwise.\n      */\n     @Override\n-    public boolean equals(Object obj) {\n+    public boolean equals(final Object obj) {\n         return obj instanceof MutableDouble\n             && Double.doubleToLongBits(((MutableDouble) obj).value) == Double.doubleToLongBits(value);\n     }\n      * @return negative if this is less, zero if equal, positive if greater\n      */\n     @Override\n-    public int compareTo(MutableDouble other) {\n+    public int compareTo(final MutableDouble other) {\n         double anotherVal = other.value;\n         return Double.compare(value, anotherVal);\n     }\n--- a/src/main/java/org/apache/commons/lang3/mutable/MutableFloat.java\n+++ b/src/main/java/org/apache/commons/lang3/mutable/MutableFloat.java\n      * \n      * @param value  the initial value to store\n      */\n-    public MutableFloat(float value) {\n+    public MutableFloat(final float value) {\n         super();\n         this.value = value;\n     }\n      * @param value  the initial value to store, not null\n      * @throws NullPointerException if the object is null\n      */\n-    public MutableFloat(Number value) {\n+    public MutableFloat(final Number value) {\n         super();\n         this.value = value.floatValue();\n     }\n      * @throws NumberFormatException if the string cannot be parsed into a float\n      * @since 2.5\n      */\n-    public MutableFloat(String value) throws NumberFormatException {\n+    public MutableFloat(final String value) throws NumberFormatException {\n         super();\n         this.value = Float.parseFloat(value);\n     }\n      * \n      * @param value  the value to set\n      */\n-    public void setValue(float value) {\n+    public void setValue(final float value) {\n         this.value = value;\n     }\n \n      * @throws NullPointerException if the object is null\n      */\n     @Override\n-    public void setValue(Number value) {\n+    public void setValue(final Number value) {\n         this.value = value.floatValue();\n     }\n \n      * @param operand  the value to add, not null\n      * @since Commons Lang 2.2\n      */\n-    public void add(float operand) {\n+    public void add(final float operand) {\n         this.value += operand;\n     }\n \n      * @throws NullPointerException if the object is null\n      * @since Commons Lang 2.2\n      */\n-    public void add(Number operand) {\n+    public void add(final Number operand) {\n         this.value += operand.floatValue();\n     }\n \n      * @param operand  the value to subtract\n      * @since Commons Lang 2.2\n      */\n-    public void subtract(float operand) {\n+    public void subtract(final float operand) {\n         this.value -= operand;\n     }\n \n      * @throws NullPointerException if the object is null\n      * @since Commons Lang 2.2\n      */\n-    public void subtract(Number operand) {\n+    public void subtract(final Number operand) {\n         this.value -= operand.floatValue();\n     }\n \n      * @see java.lang.Float#floatToIntBits(float)\n      */\n     @Override\n-    public boolean equals(Object obj) {\n+    public boolean equals(final Object obj) {\n         return obj instanceof MutableFloat\n             && Float.floatToIntBits(((MutableFloat) obj).value) == Float.floatToIntBits(value);\n     }\n      * @return negative if this is less, zero if equal, positive if greater\n      */\n     @Override\n-    public int compareTo(MutableFloat other) {\n+    public int compareTo(final MutableFloat other) {\n         float anotherVal = other.value;\n         return Float.compare(value, anotherVal);\n     }\n--- a/src/main/java/org/apache/commons/lang3/mutable/MutableInt.java\n+++ b/src/main/java/org/apache/commons/lang3/mutable/MutableInt.java\n      * \n      * @param value  the initial value to store\n      */\n-    public MutableInt(int value) {\n+    public MutableInt(final int value) {\n         super();\n         this.value = value;\n     }\n      * @param value  the initial value to store, not null\n      * @throws NullPointerException if the object is null\n      */\n-    public MutableInt(Number value) {\n+    public MutableInt(final Number value) {\n         super();\n         this.value = value.intValue();\n     }\n      * @throws NumberFormatException if the string cannot be parsed into an int\n      * @since 2.5\n      */\n-    public MutableInt(String value) throws NumberFormatException {\n+    public MutableInt(final String value) throws NumberFormatException {\n         super();\n         this.value = Integer.parseInt(value);\n     }\n      * \n      * @param value  the value to set\n      */\n-    public void setValue(int value) {\n+    public void setValue(final int value) {\n         this.value = value;\n     }\n \n      * @throws NullPointerException if the object is null\n      */\n     @Override\n-    public void setValue(Number value) {\n+    public void setValue(final Number value) {\n         this.value = value.intValue();\n     }\n \n      * @param operand  the value to add, not null\n      * @since Commons Lang 2.2\n      */\n-    public void add(int operand) {\n+    public void add(final int operand) {\n         this.value += operand;\n     }\n \n      * @throws NullPointerException if the object is null\n      * @since Commons Lang 2.2\n      */\n-    public void add(Number operand) {\n+    public void add(final Number operand) {\n         this.value += operand.intValue();\n     }\n \n      * @param operand  the value to subtract, not null\n      * @since Commons Lang 2.2\n      */\n-    public void subtract(int operand) {\n+    public void subtract(final int operand) {\n         this.value -= operand;\n     }\n \n      * @throws NullPointerException if the object is null\n      * @since Commons Lang 2.2\n      */\n-    public void subtract(Number operand) {\n+    public void subtract(final Number operand) {\n         this.value -= operand.intValue();\n     }\n \n      * @return <code>true</code> if the objects are the same; <code>false</code> otherwise.\n      */\n     @Override\n-    public boolean equals(Object obj) {\n+    public boolean equals(final Object obj) {\n         if (obj instanceof MutableInt) {\n             return value == ((MutableInt) obj).intValue();\n         }\n      * @return negative if this is less, zero if equal, positive if greater\n      */\n     @Override\n-    public int compareTo(MutableInt other) {\n+    public int compareTo(final MutableInt other) {\n         int anotherVal = other.value;\n         return value < anotherVal ? -1 : (value == anotherVal ? 0 : 1);\n     }\n--- a/src/main/java/org/apache/commons/lang3/mutable/MutableLong.java\n+++ b/src/main/java/org/apache/commons/lang3/mutable/MutableLong.java\n      * \n      * @param value  the initial value to store\n      */\n-    public MutableLong(long value) {\n+    public MutableLong(final long value) {\n         super();\n         this.value = value;\n     }\n      * @param value  the initial value to store, not null\n      * @throws NullPointerException if the object is null\n      */\n-    public MutableLong(Number value) {\n+    public MutableLong(final Number value) {\n         super();\n         this.value = value.longValue();\n     }\n      * @throws NumberFormatException if the string cannot be parsed into a long\n      * @since 2.5\n      */\n-    public MutableLong(String value) throws NumberFormatException {\n+    public MutableLong(final String value) throws NumberFormatException {\n         super();\n         this.value = Long.parseLong(value);\n     }\n      * \n      * @param value  the value to set\n      */\n-    public void setValue(long value) {\n+    public void setValue(final long value) {\n         this.value = value;\n     }\n \n      * @throws NullPointerException if the object is null\n      */\n     @Override\n-    public void setValue(Number value) {\n+    public void setValue(final Number value) {\n         this.value = value.longValue();\n     }\n \n      * @param operand  the value to add, not null\n      * @since Commons Lang 2.2\n      */\n-    public void add(long operand) {\n+    public void add(final long operand) {\n         this.value += operand;\n     }\n \n      * @throws NullPointerException if the object is null\n      * @since Commons Lang 2.2\n      */\n-    public void add(Number operand) {\n+    public void add(final Number operand) {\n         this.value += operand.longValue();\n     }\n \n      * @param operand  the value to subtract, not null\n      * @since Commons Lang 2.2\n      */\n-    public void subtract(long operand) {\n+    public void subtract(final long operand) {\n         this.value -= operand;\n     }\n \n      * @throws NullPointerException if the object is null\n      * @since Commons Lang 2.2\n      */\n-    public void subtract(Number operand) {\n+    public void subtract(final Number operand) {\n         this.value -= operand.longValue();\n     }\n \n      * @return <code>true</code> if the objects are the same; <code>false</code> otherwise.\n      */\n     @Override\n-    public boolean equals(Object obj) {\n+    public boolean equals(final Object obj) {\n         if (obj instanceof MutableLong) {\n             return value == ((MutableLong) obj).longValue();\n         }\n      * @return negative if this is less, zero if equal, positive if greater\n      */\n     @Override\n-    public int compareTo(MutableLong other) {\n+    public int compareTo(final MutableLong other) {\n         long anotherVal = other.value;\n         return value < anotherVal ? -1 : (value == anotherVal ? 0 : 1);\n     }\n--- a/src/main/java/org/apache/commons/lang3/mutable/MutableObject.java\n+++ b/src/main/java/org/apache/commons/lang3/mutable/MutableObject.java\n      * \n      * @param value  the initial value to store\n      */\n-    public MutableObject(T value) {\n+    public MutableObject(final T value) {\n         super();\n         this.value = value;\n     }\n      * @param value  the value to set\n      */\n     @Override\n-    public void setValue(T value) {\n+    public void setValue(final T value) {\n         this.value = value;\n     }\n \n      *          <code>false</code> otherwise.\n      */\n     @Override\n-    public boolean equals(Object obj) {\n+    public boolean equals(final Object obj) {\n         if (obj == null) {\n             return false;\n         }\n--- a/src/main/java/org/apache/commons/lang3/mutable/MutableShort.java\n+++ b/src/main/java/org/apache/commons/lang3/mutable/MutableShort.java\n      * \n      * @param value  the initial value to store\n      */\n-    public MutableShort(short value) {\n+    public MutableShort(final short value) {\n         super();\n         this.value = value;\n     }\n      * @param value  the initial value to store, not null\n      * @throws NullPointerException if the object is null\n      */\n-    public MutableShort(Number value) {\n+    public MutableShort(final Number value) {\n         super();\n         this.value = value.shortValue();\n     }\n      * @throws NumberFormatException if the string cannot be parsed into a short\n      * @since 2.5\n      */\n-    public MutableShort(String value) throws NumberFormatException {\n+    public MutableShort(final String value) throws NumberFormatException {\n         super();\n         this.value = Short.parseShort(value);\n     }\n      * \n      * @param value  the value to set\n      */\n-    public void setValue(short value) {\n+    public void setValue(final short value) {\n         this.value = value;\n     }\n \n      * @throws NullPointerException if the object is null\n      */\n     @Override\n-    public void setValue(Number value) {\n+    public void setValue(final Number value) {\n         this.value = value.shortValue();\n     }\n \n      * @param operand  the value to add, not null\n      * @since Commons Lang 2.2\n      */\n-    public void add(short operand) {\n+    public void add(final short operand) {\n         this.value += operand;\n     }\n \n      * @throws NullPointerException if the object is null\n      * @since Commons Lang 2.2\n      */\n-    public void add(Number operand) {\n+    public void add(final Number operand) {\n         this.value += operand.shortValue();\n     }\n \n      * @param operand  the value to subtract, not null\n      * @since Commons Lang 2.2\n      */\n-    public void subtract(short operand) {\n+    public void subtract(final short operand) {\n         this.value -= operand;\n     }\n \n      * @throws NullPointerException if the object is null\n      * @since Commons Lang 2.2\n      */\n-    public void subtract(Number operand) {\n+    public void subtract(final Number operand) {\n         this.value -= operand.shortValue();\n     }\n \n      * @return <code>true</code> if the objects are the same; <code>false</code> otherwise.\n      */\n     @Override\n-    public boolean equals(Object obj) {\n+    public boolean equals(final Object obj) {\n         if (obj instanceof MutableShort) {\n             return value == ((MutableShort) obj).shortValue();\n         }\n      * @return negative if this is less, zero if equal, positive if greater\n      */\n     @Override\n-    public int compareTo(MutableShort other) {\n+    public int compareTo(final MutableShort other) {\n         short anotherVal = other.value;\n         return value < anotherVal ? -1 : (value == anotherVal ? 0 : 1);\n     }\n--- a/src/main/java/org/apache/commons/lang3/reflect/ConstructorUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/reflect/ConstructorUtils.java\n      * @throws InstantiationException if an error occurs on instantiation\n      * @see #invokeConstructor(java.lang.Class, java.lang.Object[], java.lang.Class[])\n      */\n-    public static <T> T invokeConstructor(Class<T> cls, Object... args)\n+    public static <T> T invokeConstructor(final Class<T> cls, Object... args)\n             throws NoSuchMethodException, IllegalAccessException, InvocationTargetException,\n             InstantiationException {\n         if (args == null) {\n      * @throws InstantiationException if an error occurs on instantiation\n      * @see Constructor#newInstance\n      */\n-    public static <T> T invokeConstructor(Class<T> cls, Object[] args, Class<?>[] parameterTypes)\n+    public static <T> T invokeConstructor(final Class<T> cls, Object[] args, Class<?>[] parameterTypes)\n             throws NoSuchMethodException, IllegalAccessException, InvocationTargetException,\n             InstantiationException {\n         if (parameterTypes == null) {\n      * @throws InstantiationException if an error occurs on instantiation\n      * @see #invokeExactConstructor(java.lang.Class, java.lang.Object[], java.lang.Class[])\n      */\n-    public static <T> T invokeExactConstructor(Class<T> cls, Object... args)\n+    public static <T> T invokeExactConstructor(final Class<T> cls, Object... args)\n             throws NoSuchMethodException, IllegalAccessException, InvocationTargetException,\n             InstantiationException {\n         if (args == null) {\n      * @throws InstantiationException if an error occurs on instantiation\n      * @see Constructor#newInstance\n      */\n-    public static <T> T invokeExactConstructor(Class<T> cls, Object[] args,\n+    public static <T> T invokeExactConstructor(final Class<T> cls, Object[] args,\n             Class<?>[] parameterTypes) throws NoSuchMethodException, IllegalAccessException,\n             InvocationTargetException, InstantiationException {\n         if (args == null) {\n      * @see Class#getConstructor\n      * @see #getAccessibleConstructor(java.lang.reflect.Constructor)\n      */\n-    public static <T> Constructor<T> getAccessibleConstructor(Class<T> cls,\n-            Class<?>... parameterTypes) {\n+    public static <T> Constructor<T> getAccessibleConstructor(final Class<T> cls,\n+            final Class<?>... parameterTypes) {\n         try {\n             return getAccessibleConstructor(cls.getConstructor(parameterTypes));\n         } catch (NoSuchMethodException e) {\n      * @return the constructor, null if no matching accessible constructor found\n      * @see java.lang.SecurityManager\n      */\n-    public static <T> Constructor<T> getAccessibleConstructor(Constructor<T> ctor) {\n+    public static <T> Constructor<T> getAccessibleConstructor(final Constructor<T> ctor) {\n         return MemberUtils.isAccessible(ctor)\n                 && Modifier.isPublic(ctor.getDeclaringClass().getModifiers()) ? ctor : null;\n     }\n      * @param parameterTypes find method with compatible parameters\n      * @return the constructor, null if no matching accessible constructor found\n      */\n-    public static <T> Constructor<T> getMatchingAccessibleConstructor(Class<T> cls,\n-            Class<?>... parameterTypes) {\n+    public static <T> Constructor<T> getMatchingAccessibleConstructor(final Class<T> cls,\n+            final Class<?>... parameterTypes) {\n         // see if we can find the constructor directly\n         // most of the time this works and it's much faster\n         try {\n--- a/src/main/java/org/apache/commons/lang3/reflect/FieldUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/reflect/FieldUtils.java\n      * @return the Field object\n      * @throws IllegalArgumentException if the class or field name is null\n      */\n-    public static Field getField(Class<?> cls, String fieldName) {\n+    public static Field getField(final Class<?> cls, final String fieldName) {\n         Field field = getField(cls, fieldName, false);\n         MemberUtils.setAccessibleWorkaround(field);\n         return field;\n      * @return the Field object\n      * @throws IllegalArgumentException if the class or field name is null\n      */\n-    public static Field getField(final Class<?> cls, String fieldName, boolean forceAccess) {\n+    public static Field getField(final Class<?> cls, final String fieldName, final boolean forceAccess) {\n         if (cls == null) {\n             throw new IllegalArgumentException(\"The class must not be null\");\n         }\n      * @return the Field object\n      * @throws IllegalArgumentException if the class or field name is null\n      */\n-    public static Field getDeclaredField(Class<?> cls, String fieldName) {\n+    public static Field getDeclaredField(final Class<?> cls, final String fieldName) {\n         return getDeclaredField(cls, fieldName, false);\n     }\n \n      * @return the Field object\n      * @throws IllegalArgumentException if the class or field name is null\n      */\n-    public static Field getDeclaredField(Class<?> cls, String fieldName, boolean forceAccess) {\n+    public static Field getDeclaredField(final Class<?> cls, final String fieldName, final boolean forceAccess) {\n         if (cls == null) {\n             throw new IllegalArgumentException(\"The class must not be null\");\n         }\n      * @throws IllegalArgumentException if the field is null or not static\n      * @throws IllegalAccessException if the field is not accessible\n      */\n-    public static Object readStaticField(Field field) throws IllegalAccessException {\n+    public static Object readStaticField(final Field field) throws IllegalAccessException {\n         return readStaticField(field, false);\n     }\n \n      * @throws IllegalArgumentException if the field is null or not static\n      * @throws IllegalAccessException if the field is not made accessible\n      */\n-    public static Object readStaticField(Field field, boolean forceAccess) throws IllegalAccessException {\n+    public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException {\n         if (field == null) {\n             throw new IllegalArgumentException(\"The field must not be null\");\n         }\n      * @throws IllegalArgumentException if the class is null, the field name is null or if the field could not be found\n      * @throws IllegalAccessException if the field is not accessible\n      */\n-    public static Object readStaticField(Class<?> cls, String fieldName) throws IllegalAccessException {\n+    public static Object readStaticField(final Class<?> cls, final String fieldName) throws IllegalAccessException {\n         return readStaticField(cls, fieldName, false);\n     }\n \n      * @throws IllegalArgumentException if the class is null, the field name is null or if the field could not be found\n      * @throws IllegalAccessException if the field is not made accessible\n      */\n-    public static Object readStaticField(Class<?> cls, String fieldName, boolean forceAccess)\n+    public static Object readStaticField(final Class<?> cls, final String fieldName, final boolean forceAccess)\n         throws IllegalAccessException {\n         Field field = getField(cls, fieldName, forceAccess);\n         if (field == null) {\n      * @throws IllegalArgumentException if the class is null, the field name is null or if the field could not be found\n      * @throws IllegalAccessException if the field is not accessible\n      */\n-    public static Object readDeclaredStaticField(Class<?> cls, String fieldName) throws IllegalAccessException {\n+    public static Object readDeclaredStaticField(final Class<?> cls, final String fieldName) throws IllegalAccessException {\n         return readDeclaredStaticField(cls, fieldName, false);\n     }\n \n      * @throws IllegalArgumentException if the class is null, the field name is null or if the field could not be found\n      * @throws IllegalAccessException if the field is not made accessible\n      */\n-    public static Object readDeclaredStaticField(Class<?> cls, String fieldName, boolean forceAccess)\n+    public static Object readDeclaredStaticField(final Class<?> cls, final String fieldName, final boolean forceAccess)\n             throws IllegalAccessException {\n         Field field = getDeclaredField(cls, fieldName, forceAccess);\n         if (field == null) {\n      * @throws IllegalArgumentException if the field is null\n      * @throws IllegalAccessException if the field is not accessible\n      */\n-    public static Object readField(Field field, Object target) throws IllegalAccessException {\n+    public static Object readField(final Field field, final Object target) throws IllegalAccessException {\n         return readField(field, target, false);\n     }\n \n      * @throws IllegalArgumentException if the field is null\n      * @throws IllegalAccessException if the field is not made accessible\n      */\n-    public static Object readField(Field field, Object target, boolean forceAccess) throws IllegalAccessException {\n+    public static Object readField(final Field field, final Object target, final boolean forceAccess) throws IllegalAccessException {\n         if (field == null) {\n             throw new IllegalArgumentException(\"The field must not be null\");\n         }\n      * @throws IllegalArgumentException if the class or field name is null\n      * @throws IllegalAccessException if the named field is not public\n      */\n-    public static Object readField(Object target, String fieldName) throws IllegalAccessException {\n+    public static Object readField(final Object target, final String fieldName) throws IllegalAccessException {\n         return readField(target, fieldName, false);\n     }\n \n      * @throws IllegalArgumentException if the class or field name is null\n      * @throws IllegalAccessException if the named field is not made accessible\n      */\n-    public static Object readField(Object target, String fieldName, boolean forceAccess) throws IllegalAccessException {\n+    public static Object readField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException {\n         if (target == null) {\n             throw new IllegalArgumentException(\"target object must not be null\");\n         }\n      * @throws IllegalArgumentException if the class or field name is null\n      * @throws IllegalAccessException if the named field is not public\n      */\n-    public static Object readDeclaredField(Object target, String fieldName) throws IllegalAccessException {\n+    public static Object readDeclaredField(final Object target, final String fieldName) throws IllegalAccessException {\n         return readDeclaredField(target, fieldName, false);\n     }\n \n      * @throws IllegalArgumentException if <code>target</code> or <code>fieldName</code> is null\n      * @throws IllegalAccessException if the field is not made accessible\n      */\n-    public static Object readDeclaredField(Object target, String fieldName, boolean forceAccess)\n+    public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess)\n         throws IllegalAccessException {\n         if (target == null) {\n             throw new IllegalArgumentException(\"target object must not be null\");\n      * @throws IllegalArgumentException if the field is null or not static\n      * @throws IllegalAccessException if the field is not public or is final\n      */\n-    public static void writeStaticField(Field field, Object value) throws IllegalAccessException {\n+    public static void writeStaticField(final Field field, final Object value) throws IllegalAccessException {\n         writeStaticField(field, value, false);\n     }\n \n      * @throws IllegalArgumentException if the field is null or not static\n      * @throws IllegalAccessException if the field is not made accessible or is final\n      */\n-    public static void writeStaticField(Field field, Object value, boolean forceAccess) throws IllegalAccessException {\n+    public static void writeStaticField(final Field field, final Object value, final boolean forceAccess) throws IllegalAccessException {\n         if (field == null) {\n             throw new IllegalArgumentException(\"The field must not be null\");\n         }\n      * @throws IllegalArgumentException if the field cannot be located or is not static\n      * @throws IllegalAccessException if the field is not public or is final\n      */\n-    public static void writeStaticField(Class<?> cls, String fieldName, Object value) throws IllegalAccessException {\n+    public static void writeStaticField(final Class<?> cls, final String fieldName, final Object value) throws IllegalAccessException {\n         writeStaticField(cls, fieldName, value, false);\n     }\n \n      * @throws IllegalArgumentException if the field cannot be located or is not static\n      * @throws IllegalAccessException if the field is not made accessible or is final\n      */\n-    public static void writeStaticField(Class<?> cls, String fieldName, Object value, boolean forceAccess)\n+    public static void writeStaticField(final Class<?> cls, final String fieldName, final Object value, final boolean forceAccess)\n             throws IllegalAccessException {\n         Field field = getField(cls, fieldName, forceAccess);\n         if (field == null) {\n      * @throws IllegalArgumentException if the field cannot be located or is not static\n      * @throws IllegalAccessException if the field is not public or is final\n      */\n-    public static void writeDeclaredStaticField(Class<?> cls, String fieldName, Object value)\n+    public static void writeDeclaredStaticField(final Class<?> cls, final String fieldName, final Object value)\n             throws IllegalAccessException {\n         writeDeclaredStaticField(cls, fieldName, value, false);\n     }\n      * @throws IllegalArgumentException if the field cannot be located or is not static\n      * @throws IllegalAccessException if the field is not made accessible or is final\n       */\n-    public static void writeDeclaredStaticField(Class<?> cls, String fieldName, Object value, boolean forceAccess)\n+    public static void writeDeclaredStaticField(final Class<?> cls, final String fieldName, final Object value, final boolean forceAccess)\n             throws IllegalAccessException {\n         Field field = getDeclaredField(cls, fieldName, forceAccess);\n         if (field == null) {\n      * @throws IllegalArgumentException if the field is null\n      * @throws IllegalAccessException if the field is not accessible or is final\n      */\n-    public static void writeField(Field field, Object target, Object value) throws IllegalAccessException {\n+    public static void writeField(final Field field, final Object target, final Object value) throws IllegalAccessException {\n         writeField(field, target, value, false);\n     }\n \n      * @throws IllegalArgumentException if the field is null\n      * @throws IllegalAccessException if the field is not made accessible or is final\n      */\n-    public static void writeField(Field field, Object target, Object value, boolean forceAccess)\n+    public static void writeField(final Field field, final Object target, final Object value, final boolean forceAccess)\n         throws IllegalAccessException {\n         if (field == null) {\n             throw new IllegalArgumentException(\"The field must not be null\");\n      * @throws IllegalArgumentException if <code>target</code> or <code>fieldName</code> is null\n      * @throws IllegalAccessException if the field is not accessible\n      */\n-    public static void writeField(Object target, String fieldName, Object value) throws IllegalAccessException {\n+    public static void writeField(final Object target, final String fieldName, final Object value) throws IllegalAccessException {\n         writeField(target, fieldName, value, false);\n     }\n \n      * @throws IllegalArgumentException if <code>target</code> or <code>fieldName</code> is null\n      * @throws IllegalAccessException if the field is not made accessible\n      */\n-    public static void writeField(Object target, String fieldName, Object value, boolean forceAccess)\n+    public static void writeField(final Object target, final String fieldName, final Object value, final boolean forceAccess)\n             throws IllegalAccessException {\n         if (target == null) {\n             throw new IllegalArgumentException(\"target object must not be null\");\n      * @throws IllegalArgumentException if <code>target</code> or <code>fieldName</code> is null\n      * @throws IllegalAccessException if the field is not made accessible\n      */\n-    public static void writeDeclaredField(Object target, String fieldName, Object value) throws IllegalAccessException {\n+    public static void writeDeclaredField(final Object target, final String fieldName, final Object value) throws IllegalAccessException {\n         writeDeclaredField(target, fieldName, value, false);\n     }\n \n      * @throws IllegalArgumentException if <code>target</code> or <code>fieldName</code> is null\n      * @throws IllegalAccessException if the field is not made accessible\n      */\n-    public static void writeDeclaredField(Object target, String fieldName, Object value, boolean forceAccess)\n+    public static void writeDeclaredField(final Object target, final String fieldName, final Object value, final boolean forceAccess)\n             throws IllegalAccessException {\n         if (target == null) {\n             throw new IllegalArgumentException(\"target object must not be null\");\n--- a/src/main/java/org/apache/commons/lang3/reflect/MemberUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/reflect/MemberUtils.java\n      * accepted.\n      * @param o the AccessibleObject to set as accessible\n      */\n-    static void setAccessibleWorkaround(AccessibleObject o) {\n+    static void setAccessibleWorkaround(final AccessibleObject o) {\n         if (o == null || o.isAccessible()) {\n             return;\n         }\n      * @param modifiers to test\n      * @return true unless package/protected/private modifier detected\n      */\n-    static boolean isPackageAccess(int modifiers) {\n+    static boolean isPackageAccess(final int modifiers) {\n         return (modifiers & ACCESS_TEST) == 0;\n     }\n \n      * @param m Member to check\n      * @return true if <code>m</code> is accessible\n      */\n-    static boolean isAccessible(Member m) {\n+    static boolean isAccessible(final Member m) {\n         return m != null && Modifier.isPublic(m.getModifiers()) && !m.isSynthetic();\n     }\n \n      * <code>left</code>/<code>right</code>\n      * @return int consistent with <code>compare</code> semantics\n      */\n-    static int compareParameterTypes(Class<?>[] left, Class<?>[] right, Class<?>[] actual) {\n+    static int compareParameterTypes(final Class<?>[] left, final Class<?>[] right, final Class<?>[] actual) {\n         float leftCost = getTotalTransformationCost(actual, left);\n         float rightCost = getTotalTransformationCost(actual, right);\n         return leftCost < rightCost ? -1 : rightCost < leftCost ? 1 : 0;\n      * @param destArgs The destination arguments\n      * @return The total transformation cost\n      */\n-    private static float getTotalTransformationCost(Class<?>[] srcArgs, Class<?>[] destArgs) {\n+    private static float getTotalTransformationCost(final Class<?>[] srcArgs, final Class<?>[] destArgs) {\n         float totalCost = 0.0f;\n         for (int i = 0; i < srcArgs.length; i++) {\n             Class<?> srcClass, destClass;\n      * @param destClass The destination class\n      * @return The cost of transforming an object\n      */\n-    private static float getObjectTransformationCost(Class<?> srcClass, Class<?> destClass) {\n+    private static float getObjectTransformationCost(Class<?> srcClass, final Class<?> destClass) {\n         if (destClass.isPrimitive()) {\n             return getPrimitivePromotionCost(srcClass, destClass);\n         }\n--- a/src/main/java/org/apache/commons/lang3/reflect/MethodUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/reflect/MethodUtils.java\n      * @throws InvocationTargetException wraps an exception thrown by the method invoked\n      * @throws IllegalAccessException if the requested method is not accessible via reflection\n      */\n-    public static Object invokeMethod(Object object, String methodName,\n+    public static Object invokeMethod(final Object object, final String methodName,\n             Object... args) throws NoSuchMethodException,\n             IllegalAccessException, InvocationTargetException {\n         if (args == null) {\n      * @throws InvocationTargetException wraps an exception thrown by the method invoked\n      * @throws IllegalAccessException if the requested method is not accessible via reflection\n      */\n-    public static Object invokeMethod(Object object, String methodName,\n+    public static Object invokeMethod(final Object object, final String methodName,\n             Object[] args, Class<?>[] parameterTypes)\n             throws NoSuchMethodException, IllegalAccessException,\n             InvocationTargetException {\n      * @throws IllegalAccessException if the requested method is not accessible\n      *  via reflection\n      */\n-    public static Object invokeExactMethod(Object object, String methodName,\n+    public static Object invokeExactMethod(final Object object, final String methodName,\n             Object... args) throws NoSuchMethodException,\n             IllegalAccessException, InvocationTargetException {\n         if (args == null) {\n      * @throws IllegalAccessException if the requested method is not accessible\n      *  via reflection\n      */\n-    public static Object invokeExactMethod(Object object, String methodName,\n+    public static Object invokeExactMethod(final Object object, final String methodName,\n             Object[] args, Class<?>[] parameterTypes)\n             throws NoSuchMethodException, IllegalAccessException,\n             InvocationTargetException {\n      * @throws IllegalAccessException if the requested method is not accessible\n      *  via reflection\n      */\n-    public static Object invokeExactStaticMethod(Class<?> cls, String methodName,\n+    public static Object invokeExactStaticMethod(final Class<?> cls, final String methodName,\n             Object[] args, Class<?>[] parameterTypes)\n             throws NoSuchMethodException, IllegalAccessException,\n             InvocationTargetException {\n      * @throws IllegalAccessException if the requested method is not accessible\n      *  via reflection\n      */\n-    public static Object invokeStaticMethod(Class<?> cls, String methodName,\n+    public static Object invokeStaticMethod(final Class<?> cls, final String methodName,\n             Object... args) throws NoSuchMethodException,\n             IllegalAccessException, InvocationTargetException {\n         if (args == null) {\n      * @throws IllegalAccessException if the requested method is not accessible\n      *  via reflection\n      */\n-    public static Object invokeStaticMethod(Class<?> cls, String methodName,\n+    public static Object invokeStaticMethod(final Class<?> cls, final String methodName,\n             Object[] args, Class<?>[] parameterTypes)\n             throws NoSuchMethodException, IllegalAccessException,\n             InvocationTargetException {\n      * @throws IllegalAccessException if the requested method is not accessible\n      *  via reflection\n      */\n-    public static Object invokeExactStaticMethod(Class<?> cls, String methodName,\n+    public static Object invokeExactStaticMethod(final Class<?> cls, final String methodName,\n             Object... args) throws NoSuchMethodException,\n             IllegalAccessException, InvocationTargetException {\n         if (args == null) {\n      * @param parameterTypes with these parameters types\n      * @return The accessible method\n      */\n-    public static Method getAccessibleMethod(Class<?> cls, String methodName,\n-            Class<?>... parameterTypes) {\n+    public static Method getAccessibleMethod(final Class<?> cls, final String methodName,\n+            final Class<?>... parameterTypes) {\n         try {\n             return getAccessibleMethod(cls.getMethod(methodName,\n                     parameterTypes));\n      * @param parameterTypes The parameter type signatures\n      * @return the accessible method or <code>null</code> if not found\n      */\n-    private static Method getAccessibleMethodFromSuperclass(Class<?> cls,\n-            String methodName, Class<?>... parameterTypes) {\n+    private static Method getAccessibleMethodFromSuperclass(final Class<?> cls,\n+            final String methodName, final Class<?>... parameterTypes) {\n         Class<?> parentClass = cls.getSuperclass();\n         while (parentClass != null) {\n             if (Modifier.isPublic(parentClass.getModifiers())) {\n      * @return the accessible method or <code>null</code> if not found\n      */\n     private static Method getAccessibleMethodFromInterfaceNest(Class<?> cls,\n-            String methodName, Class<?>... parameterTypes) {\n+            final String methodName, final Class<?>... parameterTypes) {\n         Method method = null;\n \n         // Search up the superclass chain\n      * @param parameterTypes find method with most compatible parameters \n      * @return The accessible method\n      */\n-    public static Method getMatchingAccessibleMethod(Class<?> cls,\n-            String methodName, Class<?>... parameterTypes) {\n+    public static Method getMatchingAccessibleMethod(final Class<?> cls,\n+            final String methodName, final Class<?>... parameterTypes) {\n         try {\n             Method method = cls.getMethod(methodName, parameterTypes);\n             MemberUtils.setAccessibleWorkaround(method);\n--- a/src/main/java/org/apache/commons/lang3/reflect/TypeUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/reflect/TypeUtils.java\n      * @param toType the target type\n      * @return <code>true</code> if <code>type</code> is assignable to <code>toType</code>.\n      */\n-    public static boolean isAssignable(Type type, Type toType) {\n+    public static boolean isAssignable(final Type type, final Type toType) {\n         return isAssignable(type, toType, null);\n     }\n \n      * @param typeVarAssigns optional map of type variable assignments\n      * @return <code>true</code> if <code>type</code> is assignable to <code>toType</code>.\n      */\n-    private static boolean isAssignable(Type type, Type toType,\n-            Map<TypeVariable<?>, Type> typeVarAssigns) {\n+    private static boolean isAssignable(final Type type, final Type toType,\n+            final Map<TypeVariable<?>, Type> typeVarAssigns) {\n         if (toType == null || toType instanceof Class<?>) {\n             return isAssignable(type, (Class<?>) toType);\n         }\n      * @param toClass the target class\n      * @return true if <code>type</code> is assignable to <code>toClass</code>.\n      */\n-    private static boolean isAssignable(Type type, Class<?> toClass) {\n+    private static boolean isAssignable(final Type type, final Class<?> toClass) {\n         if (type == null) {\n             // consistency with ClassUtils.isAssignable() behavior\n             return toClass == null || !toClass.isPrimitive();\n      * @param typeVarAssigns a map with type variables\n      * @return true if <code>type</code> is assignable to <code>toType</code>.\n      */\n-    private static boolean isAssignable(Type type, ParameterizedType toParameterizedType,\n-            Map<TypeVariable<?>, Type> typeVarAssigns) {\n+    private static boolean isAssignable(final Type type, final ParameterizedType toParameterizedType,\n+            final Map<TypeVariable<?>, Type> typeVarAssigns) {\n         if (type == null) {\n             return true;\n         }\n         return true;\n     }\n \n-    private static Type unrollVariableAssignments(TypeVariable<?> var, Map<TypeVariable<?>, Type> typeVarAssigns) {\n+    private static Type unrollVariableAssignments(TypeVariable<?> var, final Map<TypeVariable<?>, Type> typeVarAssigns) {\n         Type result;\n         do {\n             result = typeVarAssigns.get(var);\n      * @return true if <code>type</code> is assignable to\n      * <code>toGenericArrayType</code>.\n      */\n-    private static boolean isAssignable(Type type, GenericArrayType toGenericArrayType,\n-            Map<TypeVariable<?>, Type> typeVarAssigns) {\n+    private static boolean isAssignable(final Type type, final GenericArrayType toGenericArrayType,\n+            final Map<TypeVariable<?>, Type> typeVarAssigns) {\n         if (type == null) {\n             return true;\n         }\n      * @return true if <code>type</code> is assignable to\n      * <code>toWildcardType</code>.\n      */\n-    private static boolean isAssignable(Type type, WildcardType toWildcardType,\n-            Map<TypeVariable<?>, Type> typeVarAssigns) {\n+    private static boolean isAssignable(final Type type, final WildcardType toWildcardType,\n+            final Map<TypeVariable<?>, Type> typeVarAssigns) {\n         if (type == null) {\n             return true;\n         }\n      * @return true if <code>type</code> is assignable to\n      * <code>toTypeVariable</code>.\n      */\n-    private static boolean isAssignable(Type type, TypeVariable<?> toTypeVariable,\n-            Map<TypeVariable<?>, Type> typeVarAssigns) {\n+    private static boolean isAssignable(final Type type, final TypeVariable<?> toTypeVariable,\n+            final Map<TypeVariable<?>, Type> typeVarAssigns) {\n         if (type == null) {\n             return true;\n         }\n      * @return the replaced type\n      * @throws IllegalArgumentException if the type cannot be substituted\n      */\n-    private static Type substituteTypeVariables(Type type, Map<TypeVariable<?>, Type> typeVarAssigns) {\n+    private static Type substituteTypeVariables(final Type type, final Map<TypeVariable<?>, Type> typeVarAssigns) {\n         if (type instanceof TypeVariable<?> && typeVarAssigns != null) {\n             Type replacementType = typeVarAssigns.get(type);\n \n      * harvest the parameters.\n      * @return a map of the type arguments to their respective type variables.\n      */\n-    public static Map<TypeVariable<?>, Type> getTypeArguments(ParameterizedType type) {\n+    public static Map<TypeVariable<?>, Type> getTypeArguments(final ParameterizedType type) {\n         return getTypeArguments(type, getRawType(type), null);\n     }\n \n      * in the inheritance hierarchy from <code>type</code> to\n      * <code>toClass</code> inclusive.\n      */\n-    public static Map<TypeVariable<?>, Type> getTypeArguments(Type type, Class<?> toClass) {\n+    public static Map<TypeVariable<?>, Type> getTypeArguments(final Type type, final Class<?> toClass) {\n         return getTypeArguments(type, toClass, null);\n     }\n \n      * @param subtypeVarAssigns a map with type variables\n      * @return the map with type arguments\n      */\n-    private static Map<TypeVariable<?>, Type> getTypeArguments(Type type, Class<?> toClass,\n-            Map<TypeVariable<?>, Type> subtypeVarAssigns) {\n+    private static Map<TypeVariable<?>, Type> getTypeArguments(final Type type, final Class<?> toClass,\n+            final Map<TypeVariable<?>, Type> subtypeVarAssigns) {\n         if (type instanceof Class<?>) {\n             return getTypeArguments((Class<?>) type, toClass, subtypeVarAssigns);\n         }\n      * @return the map with type arguments\n      */\n     private static Map<TypeVariable<?>, Type> getTypeArguments(\n-            ParameterizedType parameterizedType, Class<?> toClass,\n-            Map<TypeVariable<?>, Type> subtypeVarAssigns) {\n+            final ParameterizedType parameterizedType, final Class<?> toClass,\n+            final Map<TypeVariable<?>, Type> subtypeVarAssigns) {\n         Class<?> cls = getRawType(parameterizedType);\n \n         // make sure they're assignable\n      * @param subtypeVarAssigns a map with type variables\n      * @return the map with type arguments\n      */\n-    private static Map<TypeVariable<?>, Type> getTypeArguments(Class<?> cls, Class<?> toClass,\n-            Map<TypeVariable<?>, Type> subtypeVarAssigns) {\n+    private static Map<TypeVariable<?>, Type> getTypeArguments(Class<?> cls, final Class<?> toClass,\n+            final Map<TypeVariable<?>, Type> subtypeVarAssigns) {\n         // make sure they're assignable\n         if (!isAssignable(cls, toClass)) {\n             return null;\n      * type variables in each type in the inheritance hierarchy from\n      * <code>type</code> to <code>toClass</code> inclusive.\n      */\n-    public static Map<TypeVariable<?>, Type> determineTypeArguments(Class<?> cls,\n-            ParameterizedType superType) {\n+    public static Map<TypeVariable<?>, Type> determineTypeArguments(final Class<?> cls,\n+            final ParameterizedType superType) {\n         Class<?> superClass = getRawType(superType);\n \n         // compatibility check\n      * @param parameterizedType the parameterized type\n      * @param typeVarAssigns the map to be filled\n      */\n-    private static <T> void mapTypeVariablesToArguments(Class<T> cls,\n-            ParameterizedType parameterizedType, Map<TypeVariable<?>, Type> typeVarAssigns) {\n+    private static <T> void mapTypeVariablesToArguments(final Class<T> cls,\n+            final ParameterizedType parameterizedType, final Map<TypeVariable<?>, Type> typeVarAssigns) {\n         // capture the type variables from the owner type that have assignments\n         Type ownerType = parameterizedType.getOwnerType();\n \n      * @param superClass the super class\n      * @return the closes parent type\n      */\n-    private static Type getClosestParentType(Class<?> cls, Class<?> superClass) {\n+    private static Type getClosestParentType(final Class<?> cls, final Class<?> superClass) {\n         // only look at the interfaces if the super class is also an interface\n         if (superClass.isInterface()) {\n             // get the generic interfaces of the subject class\n      * @param type the target type\n      * @return true of <code>value</code> is an instance of <code>type</code>.\n      */\n-    public static boolean isInstance(Object value, Type type) {\n+    public static boolean isInstance(final Object value, final Type type) {\n         if (type == null) {\n             return false;\n         }\n      * @return an array containing the values from <code>bounds</code> minus the\n      * redundant types.\n      */\n-    public static Type[] normalizeUpperBounds(Type[] bounds) {\n+    public static Type[] normalizeUpperBounds(final Type[] bounds) {\n         // don't bother if there's only one (or none) type\n         if (bounds.length < 2) {\n             return bounds;\n      * @param typeVariable the subject type variable\n      * @return a non-empty array containing the bounds of the type variable.\n      */\n-    public static Type[] getImplicitBounds(TypeVariable<?> typeVariable) {\n+    public static Type[] getImplicitBounds(final TypeVariable<?> typeVariable) {\n         Type[] bounds = typeVariable.getBounds();\n \n         return bounds.length == 0 ? new Type[] { Object.class } : normalizeUpperBounds(bounds);\n      * @return a non-empty array containing the upper bounds of the wildcard\n      * type.\n      */\n-    public static Type[] getImplicitUpperBounds(WildcardType wildcardType) {\n+    public static Type[] getImplicitUpperBounds(final WildcardType wildcardType) {\n         Type[] bounds = wildcardType.getUpperBounds();\n \n         return bounds.length == 0 ? new Type[] { Object.class } : normalizeUpperBounds(bounds);\n      * @return a non-empty array containing the lower bounds of the wildcard\n      * type.\n      */\n-    public static Type[] getImplicitLowerBounds(WildcardType wildcardType) {\n+    public static Type[] getImplicitLowerBounds(final WildcardType wildcardType) {\n         Type[] bounds = wildcardType.getLowerBounds();\n \n         return bounds.length == 0 ? new Type[] { null } : bounds;\n      * @return whether or not the types can be assigned to their respective type\n      * variables.\n      */\n-    public static boolean typesSatisfyVariables(Map<TypeVariable<?>, Type> typeVarAssigns) {\n+    public static boolean typesSatisfyVariables(final Map<TypeVariable<?>, Type> typeVarAssigns) {\n         // all types must be assignable to all the bounds of the their mapped\n         // type variable.\n         for (Map.Entry<TypeVariable<?>, Type> entry : typeVarAssigns.entrySet()) {\n      * @return the corresponding {@code Class} object\n      * @throws IllegalStateException if the conversion fails\n      */\n-    private static Class<?> getRawType(ParameterizedType parameterizedType) {\n+    private static Class<?> getRawType(final ParameterizedType parameterizedType) {\n         Type rawType = parameterizedType.getRawType();\n \n         // check if raw type is a Class object\n      * @return the resolved <code>Class</code> object or <code>null</code> if\n      * the type could not be resolved\n      */\n-    public static Class<?> getRawType(Type type, Type assigningType) {\n+    public static Class<?> getRawType(final Type type, final Type assigningType) {\n         if (type instanceof Class<?>) {\n             // it is raw, no problem\n             return (Class<?>) type;\n      * @param type the type to be checked\n      * @return <code>true</code> if <code>type</code> is an array class or a {@link GenericArrayType}.\n      */\n-    public static boolean isArrayType(Type type) {\n+    public static boolean isArrayType(final Type type) {\n         return type instanceof GenericArrayType || type instanceof Class<?> && ((Class<?>) type).isArray();\n     }\n \n      * @param type the type to be checked\n      * @return component type or null if type is not an array type\n      */\n-    public static Type getArrayComponentType(Type type) {\n+    public static Type getArrayComponentType(final Type type) {\n         if (type instanceof Class<?>) {\n             Class<?> clazz = (Class<?>) type;\n             return clazz.isArray() ? clazz.getComponentType() : null;\n--- a/src/main/java/org/apache/commons/lang3/text/CompositeFormat.java\n+++ b/src/main/java/org/apache/commons/lang3/text/CompositeFormat.java\n      * @param parser implementation\n      * @param formatter implementation\n      */\n-    public CompositeFormat(Format parser, Format formatter) {\n+    public CompositeFormat(final Format parser, final Format formatter) {\n         this.parser = parser;\n         this.formatter = formatter;\n     }\n      * @see Format#format(Object, StringBuffer, FieldPosition)\n      */\n     @Override // Therefore has to use StringBuffer\n-    public StringBuffer format(Object obj, StringBuffer toAppendTo,\n-            FieldPosition pos) {\n+    public StringBuffer format(final Object obj, final StringBuffer toAppendTo,\n+            final FieldPosition pos) {\n         return formatter.format(obj, toAppendTo, pos);\n     }\n \n      * @see Format#parseObject(String, ParsePosition)\n      */\n     @Override\n-    public Object parseObject(String source, ParsePosition pos) {\n+    public Object parseObject(final String source, final ParsePosition pos) {\n         return parser.parseObject(source, pos);\n     }\n \n      * @return A reformatted String\n      * @throws ParseException thrown by parseObject(String) call\n      */\n-    public String reformat(String input) throws ParseException {\n+    public String reformat(final String input) throws ParseException {\n         return format(parseObject(input));\n     }\n \n--- a/src/main/java/org/apache/commons/lang3/text/ExtendedMessageFormat.java\n+++ b/src/main/java/org/apache/commons/lang3/text/ExtendedMessageFormat.java\n      * @param pattern  the pattern to use, not null\n      * @throws IllegalArgumentException in case of a bad pattern.\n      */\n-    public ExtendedMessageFormat(String pattern) {\n+    public ExtendedMessageFormat(final String pattern) {\n         this(pattern, Locale.getDefault());\n     }\n \n      * @param locale  the locale to use, not null\n      * @throws IllegalArgumentException in case of a bad pattern.\n      */\n-    public ExtendedMessageFormat(String pattern, Locale locale) {\n+    public ExtendedMessageFormat(final String pattern, final Locale locale) {\n         this(pattern, locale, null);\n     }\n \n      * @param registry  the registry of format factories, may be null\n      * @throws IllegalArgumentException in case of a bad pattern.\n      */\n-    public ExtendedMessageFormat(String pattern, Map<String, ? extends FormatFactory> registry) {\n+    public ExtendedMessageFormat(final String pattern, final Map<String, ? extends FormatFactory> registry) {\n         this(pattern, Locale.getDefault(), registry);\n     }\n \n      * @param registry  the registry of format factories, may be null\n      * @throws IllegalArgumentException in case of a bad pattern.\n      */\n-    public ExtendedMessageFormat(String pattern, Locale locale, Map<String, ? extends FormatFactory> registry) {\n+    public ExtendedMessageFormat(final String pattern, final Locale locale, final Map<String, ? extends FormatFactory> registry) {\n         super(DUMMY_PATTERN);\n         setLocale(locale);\n         this.registry = registry;\n      * @param pattern String\n      */\n     @Override\n-    public final void applyPattern(String pattern) {\n+    public final void applyPattern(final String pattern) {\n         if (registry == null) {\n             super.applyPattern(pattern);\n             toPattern = super.toPattern();\n      * @throws UnsupportedOperationException\n      */\n     @Override\n-    public void setFormat(int formatElementIndex, Format newFormat) {\n+    public void setFormat(final int formatElementIndex, final Format newFormat) {\n         throw new UnsupportedOperationException();\n     }\n \n      * @throws UnsupportedOperationException\n      */\n     @Override\n-    public void setFormatByArgumentIndex(int argumentIndex, Format newFormat) {\n+    public void setFormatByArgumentIndex(final int argumentIndex, final Format newFormat) {\n         throw new UnsupportedOperationException();\n     }\n \n      * @throws UnsupportedOperationException\n      */\n     @Override\n-    public void setFormats(Format[] newFormats) {\n+    public void setFormats(final Format[] newFormats) {\n         throw new UnsupportedOperationException();\n     }\n \n      * @throws UnsupportedOperationException\n      */\n     @Override\n-    public void setFormatsByArgumentIndex(Format[] newFormats) {\n+    public void setFormatsByArgumentIndex(final Format[] newFormats) {\n         throw new UnsupportedOperationException();\n     }\n \n      * @return true if this object equals the other, otherwise false\n      */\n     @Override\n-    public boolean equals(Object obj) {\n+    public boolean equals(final Object obj) {\n         if (obj == this) {\n             return true;\n         }\n      * @param desc String\n      * @return Format\n      */\n-    private Format getFormat(String desc) {\n+    private Format getFormat(final String desc) {\n         if (registry != null) {\n             String name = desc;\n             String args = null;\n      * @param pos current parse position\n      * @return argument index\n      */\n-    private int readArgumentIndex(String pattern, ParsePosition pos) {\n+    private int readArgumentIndex(final String pattern, final ParsePosition pos) {\n         int start = pos.getIndex();\n         seekNonWs(pattern, pos);\n         StringBuilder result = new StringBuilder();\n      * @param pos current parse position\n      * @return Format description String\n      */\n-    private String parseFormatDescription(String pattern, ParsePosition pos) {\n+    private String parseFormatDescription(final String pattern, final ParsePosition pos) {\n         int start = pos.getIndex();\n         seekNonWs(pattern, pos);\n         int text = pos.getIndex();\n      * @param customPatterns The custom patterns to re-insert, if any\n      * @return full pattern\n      */\n-    private String insertFormats(String pattern, ArrayList<String> customPatterns) {\n+    private String insertFormats(final String pattern, final ArrayList<String> customPatterns) {\n         if (!containsElements(customPatterns)) {\n             return pattern;\n         }\n      * @param pattern String to read\n      * @param pos current position\n      */\n-    private void seekNonWs(String pattern, ParsePosition pos) {\n+    private void seekNonWs(final String pattern, final ParsePosition pos) {\n         int len = 0;\n         char[] buffer = pattern.toCharArray();\n         do {\n      * @param pos ParsePosition\n      * @return <code>pos</code>\n      */\n-    private ParsePosition next(ParsePosition pos) {\n+    private ParsePosition next(final ParsePosition pos) {\n         pos.setIndex(pos.getIndex() + 1);\n         return pos;\n     }\n      * @param escapingOn whether to process escaped quotes\n      * @return <code>appendTo</code>\n      */\n-    private StringBuilder appendQuotedString(String pattern, ParsePosition pos,\n-            StringBuilder appendTo, boolean escapingOn) {\n+    private StringBuilder appendQuotedString(final String pattern, final ParsePosition pos,\n+            final StringBuilder appendTo, final boolean escapingOn) {\n         int start = pos.getIndex();\n         char[] c = pattern.toCharArray();\n         if (escapingOn && c[start] == QUOTE) {\n      * @param pos current parse position\n      * @param escapingOn whether to process escaped quotes\n      */\n-    private void getQuotedString(String pattern, ParsePosition pos,\n-            boolean escapingOn) {\n+    private void getQuotedString(final String pattern, final ParsePosition pos,\n+            final boolean escapingOn) {\n         appendQuotedString(pattern, pos, null, escapingOn);\n     }\n \n      * @param coll to check\n      * @return <code>true</code> if some Object was found, <code>false</code> otherwise.\n      */\n-    private boolean containsElements(Collection<?> coll) {\n+    private boolean containsElements(final Collection<?> coll) {\n         if (coll == null || coll.isEmpty()) {\n             return false;\n         }\n--- a/src/main/java/org/apache/commons/lang3/text/FormattableUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/text/FormattableUtils.java\n      * @param formattable  the instance to convert to a string, not null\n      * @return the resulting string, not null\n      */\n-    public static String toString(Formattable formattable) {\n+    public static String toString(final Formattable formattable) {\n         return String.format(SIMPLEST_FORMAT, formattable);\n     }\n \n      * @param precision  the precision of the output, see {@code Formattable}\n      * @return the {@code formatter} instance, not null\n      */\n-    public static Formatter append(CharSequence seq, Formatter formatter, int flags, int width,\n-            int precision) {\n+    public static Formatter append(final CharSequence seq, final Formatter formatter, final int flags, final int width,\n+            final int precision) {\n         return append(seq, formatter, flags, width, precision, ' ', null);\n     }\n \n      * @param padChar  the pad character to use\n      * @return the {@code formatter} instance, not null\n      */\n-    public static Formatter append(CharSequence seq, Formatter formatter, int flags, int width,\n-            int precision, char padChar) {\n+    public static Formatter append(final CharSequence seq, final Formatter formatter, final int flags, final int width,\n+            final int precision, final char padChar) {\n         return append(seq, formatter, flags, width, precision, padChar, null);\n     }\n \n      *  empty causes a hard truncation\n      * @return the {@code formatter} instance, not null\n      */\n-    public static Formatter append(CharSequence seq, Formatter formatter, int flags, int width,\n-            int precision, CharSequence ellipsis) {\n+    public static Formatter append(final CharSequence seq, final Formatter formatter, final int flags, final int width,\n+            final int precision, final CharSequence ellipsis) {\n         return append(seq, formatter, flags, width, precision, ' ', ellipsis);\n     }\n \n      *  empty causes a hard truncation\n      * @return the {@code formatter} instance, not null\n      */\n-    public static Formatter append(CharSequence seq, Formatter formatter, int flags, int width,\n-            int precision, char padChar, CharSequence ellipsis) {\n+    public static Formatter append(final CharSequence seq, final Formatter formatter, final int flags, final int width,\n+            final int precision, final char padChar, final CharSequence ellipsis) {\n         Validate.isTrue(ellipsis == null || precision < 0 || ellipsis.length() <= precision,\n                 \"Specified ellipsis '%1$s' exceeds precision of %2$s\", ellipsis, Integer.valueOf(precision));\n         StringBuilder buf = new StringBuilder(seq);\n--- a/src/main/java/org/apache/commons/lang3/text/StrBuilder.java\n+++ b/src/main/java/org/apache/commons/lang3/text/StrBuilder.java\n      *\n      * @param str  the string to copy, null treated as blank string\n      */\n-    public StrBuilder(String str) {\n+    public StrBuilder(final String str) {\n         super();\n         if (str == null) {\n             buffer = new char[CAPACITY];\n      * @param newLine  the new line text, null means use system default\n      * @return this, to enable chaining\n      */\n-    public StrBuilder setNewLineText(String newLine) {\n+    public StrBuilder setNewLineText(final String newLine) {\n         this.newLine = newLine;\n         return this;\n     }\n      * @return this, to enable chaining\n      * @throws IndexOutOfBoundsException if the length is negative\n      */\n-    public StrBuilder setLength(int length) {\n+    public StrBuilder setLength(final int length) {\n         if (length < 0) {\n             throw new StringIndexOutOfBoundsException(length);\n         }\n      * @param capacity  the capacity to ensure\n      * @return this, to enable chaining\n      */\n-    public StrBuilder ensureCapacity(int capacity) {\n+    public StrBuilder ensureCapacity(final int capacity) {\n         if (capacity > buffer.length) {\n             char[] old = buffer;\n             buffer = new char[capacity * 2];\n      * @throws IndexOutOfBoundsException if the index is invalid\n      */\n     @Override\n-    public char charAt(int index) {\n+    public char charAt(final int index) {\n         if (index < 0 || index >= length()) {\n             throw new StringIndexOutOfBoundsException(index);\n         }\n      * @return this, to enable chaining\n      * @throws IndexOutOfBoundsException if the index is invalid\n      */\n-    public StrBuilder setCharAt(int index, char ch) {\n+    public StrBuilder setCharAt(final int index, final char ch) {\n         if (index < 0 || index >= length()) {\n             throw new StringIndexOutOfBoundsException(index);\n         }\n      * @return this, to enable chaining\n      * @throws IndexOutOfBoundsException if the index is invalid\n      */\n-    public StrBuilder deleteCharAt(int index) {\n+    public StrBuilder deleteCharAt(final int index) {\n         if (index < 0 || index >= size) {\n             throw new StringIndexOutOfBoundsException(index);\n         }\n      * @throws IndexOutOfBoundsException if startIndex is invalid,\n      *  or if endIndex is invalid (but endIndex greater than size is valid)\n      */\n-    public char[] toCharArray(int startIndex, int endIndex) {\n+    public char[] toCharArray(final int startIndex, int endIndex) {\n         endIndex = validateRange(startIndex, endIndex);\n         int len = endIndex - startIndex;\n         if (len == 0) {\n      * @throws NullPointerException if the array is null\n      * @throws IndexOutOfBoundsException if any index is invalid\n      */\n-    public void getChars(int startIndex, int endIndex, char destination[], int destinationIndex) {\n+    public void getChars(final int startIndex, final int endIndex, final char destination[], final int destinationIndex) {\n         if (startIndex < 0) {\n             throw new StringIndexOutOfBoundsException(startIndex);\n         }\n      * @param obj  the object to append\n      * @return this, to enable chaining\n      */\n-    public StrBuilder append(Object obj) {\n+    public StrBuilder append(final Object obj) {\n         if (obj == null) {\n             return appendNull();\n         } \n      * @since 3.0\n      */\n     @Override\n-    public StrBuilder append(CharSequence seq) {\n+    public StrBuilder append(final CharSequence seq) {\n         if (seq == null) {\n             return appendNull();\n         } \n      * @since 3.0\n      */\n     @Override\n-    public StrBuilder append(CharSequence seq, int startIndex, int length) {\n+    public StrBuilder append(final CharSequence seq, final int startIndex, final int length) {\n         if (seq == null) {\n             return appendNull();\n         } \n      * @param str  the string to append\n      * @return this, to enable chaining\n      */\n-    public StrBuilder append(String str) {\n+    public StrBuilder append(final String str) {\n         if (str == null) {\n             return appendNull();\n         }\n      * @param length  the length to append, must be valid\n      * @return this, to enable chaining\n      */\n-    public StrBuilder append(String str, int startIndex, int length) {\n+    public StrBuilder append(final String str, final int startIndex, final int length) {\n         if (str == null) {\n             return appendNull();\n         }\n      * @see String#format(String, Object...)\n      * @since 3.2\n      */\n-    public StrBuilder append(String format, Object... objs) {\n+    public StrBuilder append(final String format, final Object... objs) {\n         return append(String.format(format, objs));\n     }\n \n      * @param str  the string buffer to append\n      * @return this, to enable chaining\n      */\n-    public StrBuilder append(StringBuffer str) {\n+    public StrBuilder append(final StringBuffer str) {\n         if (str == null) {\n             return appendNull();\n         }\n      * @param length  the length to append, must be valid\n      * @return this, to enable chaining\n      */\n-    public StrBuilder append(StringBuffer str, int startIndex, int length) {\n+    public StrBuilder append(final StringBuffer str, final int startIndex, final int length) {\n         if (str == null) {\n             return appendNull();\n         }\n      * @return this, to enable chaining\n      * @since 3.2\n      */\n-    public StrBuilder append(StringBuilder str) {\n+    public StrBuilder append(final StringBuilder str) {\n         if (str == null) {\n             return appendNull();\n         }\n      * @return this, to enable chaining\n      * @since 3.2\n      */\n-    public StrBuilder append(StringBuilder str, int startIndex, int length) {\n+    public StrBuilder append(final StringBuilder str, final int startIndex, final int length) {\n         if (str == null) {\n             return appendNull();\n         }\n      * @param str  the string builder to append\n      * @return this, to enable chaining\n      */\n-    public StrBuilder append(StrBuilder str) {\n+    public StrBuilder append(final StrBuilder str) {\n         if (str == null) {\n             return appendNull();\n         }\n      * @param length  the length to append, must be valid\n      * @return this, to enable chaining\n      */\n-    public StrBuilder append(StrBuilder str, int startIndex, int length) {\n+    public StrBuilder append(final StrBuilder str, final int startIndex, final int length) {\n         if (str == null) {\n             return appendNull();\n         }\n      * @param chars  the char array to append\n      * @return this, to enable chaining\n      */\n-    public StrBuilder append(char[] chars) {\n+    public StrBuilder append(final char[] chars) {\n         if (chars == null) {\n             return appendNull();\n         }\n      * @param length  the length to append, must be valid\n      * @return this, to enable chaining\n      */\n-    public StrBuilder append(char[] chars, int startIndex, int length) {\n+    public StrBuilder append(final char[] chars, final int startIndex, final int length) {\n         if (chars == null) {\n             return appendNull();\n         }\n      * @param value  the value to append\n      * @return this, to enable chaining\n      */\n-    public StrBuilder append(boolean value) {\n+    public StrBuilder append(final boolean value) {\n         if (value) {\n             ensureCapacity(size + 4);\n             buffer[size++] = 't';\n      * @since 3.0\n      */\n     @Override\n-    public StrBuilder append(char ch) {\n+    public StrBuilder append(final char ch) {\n         int len = length();\n         ensureCapacity(len + 1);\n         buffer[size++] = ch;\n      * @param value  the value to append\n      * @return this, to enable chaining\n      */\n-    public StrBuilder append(int value) {\n+    public StrBuilder append(final int value) {\n         return append(String.valueOf(value));\n     }\n \n      * @param value  the value to append\n      * @return this, to enable chaining\n      */\n-    public StrBuilder append(long value) {\n+    public StrBuilder append(final long value) {\n         return append(String.valueOf(value));\n     }\n \n      * @param value  the value to append\n      * @return this, to enable chaining\n      */\n-    public StrBuilder append(float value) {\n+    public StrBuilder append(final float value) {\n         return append(String.valueOf(value));\n     }\n \n      * @param value  the value to append\n      * @return this, to enable chaining\n      */\n-    public StrBuilder append(double value) {\n+    public StrBuilder append(final double value) {\n         return append(String.valueOf(value));\n     }\n \n      * @return this, to enable chaining\n      * @since 2.3\n      */\n-    public StrBuilder appendln(Object obj) {\n+    public StrBuilder appendln(final Object obj) {\n         return append(obj).appendNewLine();\n     }\n \n      * @return this, to enable chaining\n      * @since 2.3\n      */\n-    public StrBuilder appendln(String str) {\n+    public StrBuilder appendln(final String str) {\n         return append(str).appendNewLine();\n     }\n \n      * @return this, to enable chaining\n      * @since 2.3\n      */\n-    public StrBuilder appendln(String str, int startIndex, int length) {\n+    public StrBuilder appendln(final String str, final int startIndex, final int length) {\n         return append(str, startIndex, length).appendNewLine();\n     }\n \n      * @see String#format(String, Object...)\n      * @since 3.2\n      */\n-    public StrBuilder appendln(String format, Object... objs) {\n+    public StrBuilder appendln(final String format, final Object... objs) {\n         return append(format, objs).appendNewLine();\n     }\n \n      * @return this, to enable chaining\n      * @since 2.3\n      */\n-    public StrBuilder appendln(StringBuffer str) {\n+    public StrBuilder appendln(final StringBuffer str) {\n         return append(str).appendNewLine();\n     }\n \n      * @return this, to enable chaining\n      * @since 3.2\n      */\n-    public StrBuilder appendln(StringBuilder str) {\n+    public StrBuilder appendln(final StringBuilder str) {\n         return append(str).appendNewLine();\n     }\n \n      * @return this, to enable chaining\n      * @since 3.2\n      */\n-    public StrBuilder appendln(StringBuilder str, int startIndex, int length) {\n+    public StrBuilder appendln(final StringBuilder str, final int startIndex, final int length) {\n         return append(str, startIndex, length).appendNewLine();\n     }\n \n      * @return this, to enable chaining\n      * @since 2.3\n      */\n-    public StrBuilder appendln(StringBuffer str, int startIndex, int length) {\n+    public StrBuilder appendln(final StringBuffer str, final int startIndex, final int length) {\n         return append(str, startIndex, length).appendNewLine();\n     }\n \n      * @return this, to enable chaining\n      * @since 2.3\n      */\n-    public StrBuilder appendln(StrBuilder str) {\n+    public StrBuilder appendln(final StrBuilder str) {\n         return append(str).appendNewLine();\n     }\n \n      * @return this, to enable chaining\n      * @since 2.3\n      */\n-    public StrBuilder appendln(StrBuilder str, int startIndex, int length) {\n+    public StrBuilder appendln(final StrBuilder str, final int startIndex, final int length) {\n         return append(str, startIndex, length).appendNewLine();\n     }\n \n      * @return this, to enable chaining\n      * @since 2.3\n      */\n-    public StrBuilder appendln(char[] chars) {\n+    public StrBuilder appendln(final char[] chars) {\n         return append(chars).appendNewLine();\n     }\n \n      * @return this, to enable chaining\n      * @since 2.3\n      */\n-    public StrBuilder appendln(char[] chars, int startIndex, int length) {\n+    public StrBuilder appendln(final char[] chars, final int startIndex, final int length) {\n         return append(chars, startIndex, length).appendNewLine();\n     }\n \n      * @return this, to enable chaining\n      * @since 2.3\n      */\n-    public StrBuilder appendln(boolean value) {\n+    public StrBuilder appendln(final boolean value) {\n         return append(value).appendNewLine();\n     }\n \n      * @return this, to enable chaining\n      * @since 2.3\n      */\n-    public StrBuilder appendln(char ch) {\n+    public StrBuilder appendln(final char ch) {\n         return append(ch).appendNewLine();\n     }\n \n      * @return this, to enable chaining\n      * @since 2.3\n      */\n-    public StrBuilder appendln(int value) {\n+    public StrBuilder appendln(final int value) {\n         return append(value).appendNewLine();\n     }\n \n      * @return this, to enable chaining\n      * @since 2.3\n      */\n-    public StrBuilder appendln(long value) {\n+    public StrBuilder appendln(final long value) {\n         return append(value).appendNewLine();\n     }\n \n      * @return this, to enable chaining\n      * @since 2.3\n      */\n-    public StrBuilder appendln(float value) {\n+    public StrBuilder appendln(final float value) {\n         return append(value).appendNewLine();\n     }\n \n      * @return this, to enable chaining\n      * @since 2.3\n      */\n-    public StrBuilder appendln(double value) {\n+    public StrBuilder appendln(final double value) {\n         return append(value).appendNewLine();\n     }\n \n      * @return this, to enable chaining\n      * @since 2.3\n      */\n-    public <T> StrBuilder appendAll(T... array) {\n+    public <T> StrBuilder appendAll(final T... array) {\n         if (array != null && array.length > 0) {\n             for (Object element : array) {\n                 append(element);\n      * @return this, to enable chaining\n      * @since 2.3\n      */\n-    public StrBuilder appendAll(Iterable<?> iterable) {\n+    public StrBuilder appendAll(final Iterable<?> iterable) {\n         if (iterable != null) {\n             for (Object o : iterable) {\n                 append(o);\n      * @return this, to enable chaining\n      * @since 2.3\n      */\n-    public StrBuilder appendAll(Iterator<?> it) {\n+    public StrBuilder appendAll(final Iterator<?> it) {\n         if (it != null) {\n             while (it.hasNext()) {\n                 append(it.next());\n      * @param separator  the separator to use, null means no separator\n      * @return this, to enable chaining\n      */\n-    public StrBuilder appendWithSeparators(Object[] array, String separator) {\n+    public StrBuilder appendWithSeparators(final Object[] array, String separator) {\n         if (array != null && array.length > 0) {\n             separator = ObjectUtils.toString(separator);\n             append(array[0]);\n      * @param separator  the separator to use, null means no separator\n      * @return this, to enable chaining\n      */\n-    public StrBuilder appendWithSeparators(Iterable<?> iterable, String separator) {\n+    public StrBuilder appendWithSeparators(final Iterable<?> iterable, String separator) {\n         if (iterable != null) {\n             separator = ObjectUtils.toString(separator);\n             Iterator<?> it = iterable.iterator();\n      * @param separator  the separator to use, null means no separator\n      * @return this, to enable chaining\n      */\n-    public StrBuilder appendWithSeparators(Iterator<?> it, String separator) {\n+    public StrBuilder appendWithSeparators(final Iterator<?> it, String separator) {\n         if (it != null) {\n             separator = ObjectUtils.toString(separator);\n             while (it.hasNext()) {\n      * @return this, to enable chaining\n      * @since 2.3\n      */\n-    public StrBuilder appendSeparator(String separator) {\n+    public StrBuilder appendSeparator(final String separator) {\n         return appendSeparator(separator, null);\n     }\n \n      * @return this, to enable chaining\n      * @since 2.5\n      */\n-    public StrBuilder appendSeparator(String standard, String defaultIfEmpty) {\n+    public StrBuilder appendSeparator(final String standard, final String defaultIfEmpty) {\n         String str = isEmpty() ? defaultIfEmpty : standard;\n         if (str != null) {\n             append(str);\n      * @return this, to enable chaining\n      * @since 2.3\n      */\n-    public StrBuilder appendSeparator(char separator) {\n+    public StrBuilder appendSeparator(final char separator) {\n         if (size() > 0) {\n             append(separator);\n         }\n      * @return this, to enable chaining\n      * @since 2.5\n      */\n-    public StrBuilder appendSeparator(char standard, char defaultIfEmpty) {\n+    public StrBuilder appendSeparator(final char standard, final char defaultIfEmpty) {\n         if (size() > 0) {\n             append(standard);\n         } else {\n      * @return this, to enable chaining\n      * @since 2.3\n      */\n-    public StrBuilder appendSeparator(String separator, int loopIndex) {\n+    public StrBuilder appendSeparator(final String separator, final int loopIndex) {\n         if (separator != null && loopIndex > 0) {\n             append(separator);\n         }\n      * @return this, to enable chaining\n      * @since 2.3\n      */\n-    public StrBuilder appendSeparator(char separator, int loopIndex) {\n+    public StrBuilder appendSeparator(final char separator, final int loopIndex) {\n         if (loopIndex > 0) {\n             append(separator);\n         }\n      * @param padChar  the character to append\n      * @return this, to enable chaining\n      */\n-    public StrBuilder appendPadding(int length, char padChar) {\n+    public StrBuilder appendPadding(final int length, final char padChar) {\n         if (length >= 0) {\n             ensureCapacity(size + length);\n             for (int i = 0; i < length; i++) {\n      * @param padChar  the pad character to use\n      * @return this, to enable chaining\n      */\n-    public StrBuilder appendFixedWidthPadLeft(Object obj, int width, char padChar) {\n+    public StrBuilder appendFixedWidthPadLeft(final Object obj, final int width, final char padChar) {\n         if (width > 0) {\n             ensureCapacity(size + width);\n             String str = (obj == null ? getNullText() : obj.toString());\n      * @param padChar  the pad character to use\n      * @return this, to enable chaining\n      */\n-    public StrBuilder appendFixedWidthPadLeft(int value, int width, char padChar) {\n+    public StrBuilder appendFixedWidthPadLeft(final int value, final int width, final char padChar) {\n         return appendFixedWidthPadLeft(String.valueOf(value), width, padChar);\n     }\n \n      * @param padChar  the pad character to use\n      * @return this, to enable chaining\n      */\n-    public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {\n+    public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar) {\n         if (width > 0) {\n             ensureCapacity(size + width);\n             String str = (obj == null ? getNullText() : obj.toString());\n      * @param padChar  the pad character to use\n      * @return this, to enable chaining\n      */\n-    public StrBuilder appendFixedWidthPadRight(int value, int width, char padChar) {\n+    public StrBuilder appendFixedWidthPadRight(final int value, final int width, final char padChar) {\n         return appendFixedWidthPadRight(String.valueOf(value), width, padChar);\n     }\n \n      * @return this, to enable chaining\n      * @throws IndexOutOfBoundsException if the index is invalid\n      */\n-    public StrBuilder insert(int index, Object obj) {\n+    public StrBuilder insert(final int index, final Object obj) {\n         if (obj == null) {\n             return insert(index, nullText);\n         }\n      * @throws IndexOutOfBoundsException if the index is invalid\n      */\n     @SuppressWarnings(\"null\") // str cannot be null\n-    public StrBuilder insert(int index, String str) {\n+    public StrBuilder insert(final int index, String str) {\n         validateIndex(index);\n         if (str == null) {\n             str = nullText;\n      * @return this, to enable chaining\n      * @throws IndexOutOfBoundsException if the index is invalid\n      */\n-    public StrBuilder insert(int index, char chars[]) {\n+    public StrBuilder insert(final int index, final char chars[]) {\n         validateIndex(index);\n         if (chars == null) {\n             return insert(index, nullText);\n      * @return this, to enable chaining\n      * @throws IndexOutOfBoundsException if any index is invalid\n      */\n-    public StrBuilder insert(int index, char chars[], int offset, int length) {\n+    public StrBuilder insert(final int index, final char chars[], final int offset, final int length) {\n         validateIndex(index);\n         if (chars == null) {\n             return insert(index, nullText);\n      * @return this, to enable chaining\n      * @throws IndexOutOfBoundsException if the index is invalid\n      */\n-    public StrBuilder insert(int index, boolean value) {\n+    public StrBuilder insert(int index, final boolean value) {\n         validateIndex(index);\n         if (value) {\n             ensureCapacity(size + 4);\n      * @return this, to enable chaining\n      * @throws IndexOutOfBoundsException if the index is invalid\n      */\n-    public StrBuilder insert(int index, char value) {\n+    public StrBuilder insert(final int index, final char value) {\n         validateIndex(index);\n         ensureCapacity(size + 1);\n         System.arraycopy(buffer, index, buffer, index + 1, size - index);\n      * @return this, to enable chaining\n      * @throws IndexOutOfBoundsException if the index is invalid\n      */\n-    public StrBuilder insert(int index, int value) {\n+    public StrBuilder insert(final int index, final int value) {\n         return insert(index, String.valueOf(value));\n     }\n \n      * @return this, to enable chaining\n      * @throws IndexOutOfBoundsException if the index is invalid\n      */\n-    public StrBuilder insert(int index, long value) {\n+    public StrBuilder insert(final int index, final long value) {\n         return insert(index, String.valueOf(value));\n     }\n \n      * @return this, to enable chaining\n      * @throws IndexOutOfBoundsException if the index is invalid\n      */\n-    public StrBuilder insert(int index, float value) {\n+    public StrBuilder insert(final int index, final float value) {\n         return insert(index, String.valueOf(value));\n     }\n \n      * @return this, to enable chaining\n      * @throws IndexOutOfBoundsException if the index is invalid\n      */\n-    public StrBuilder insert(int index, double value) {\n+    public StrBuilder insert(final int index, final double value) {\n         return insert(index, String.valueOf(value));\n     }\n \n      * @param len  the length, must be valid\n      * @throws IndexOutOfBoundsException if any index is invalid\n      */\n-    private void deleteImpl(int startIndex, int endIndex, int len) {\n+    private void deleteImpl(final int startIndex, final int endIndex, final int len) {\n         System.arraycopy(buffer, endIndex, buffer, startIndex, size - endIndex);\n         size -= len;\n     }\n      * @return this, to enable chaining\n      * @throws IndexOutOfBoundsException if the index is invalid\n      */\n-    public StrBuilder delete(int startIndex, int endIndex) {\n+    public StrBuilder delete(final int startIndex, int endIndex) {\n         endIndex = validateRange(startIndex, endIndex);\n         int len = endIndex - startIndex;\n         if (len > 0) {\n      * @param ch  the character to delete\n      * @return this, to enable chaining\n      */\n-    public StrBuilder deleteAll(char ch) {\n+    public StrBuilder deleteAll(final char ch) {\n         for (int i = 0; i < size; i++) {\n             if (buffer[i] == ch) {\n                 int start = i;\n      * @param ch  the character to delete\n      * @return this, to enable chaining\n      */\n-    public StrBuilder deleteFirst(char ch) {\n+    public StrBuilder deleteFirst(final char ch) {\n         for (int i = 0; i < size; i++) {\n             if (buffer[i] == ch) {\n                 deleteImpl(i, i + 1, 1);\n      * @param str  the string to delete, null causes no action\n      * @return this, to enable chaining\n      */\n-    public StrBuilder deleteAll(String str) {\n+    public StrBuilder deleteAll(final String str) {\n         int len = (str == null ? 0 : str.length());\n         if (len > 0) {\n             int index = indexOf(str, 0);\n      * @param str  the string to delete, null causes no action\n      * @return this, to enable chaining\n      */\n-    public StrBuilder deleteFirst(String str) {\n+    public StrBuilder deleteFirst(final String str) {\n         int len = (str == null ? 0 : str.length());\n         if (len > 0) {\n             int index = indexOf(str, 0);\n      * @param matcher  the matcher to use to find the deletion, null causes no action\n      * @return this, to enable chaining\n      */\n-    public StrBuilder deleteAll(StrMatcher matcher) {\n+    public StrBuilder deleteAll(final StrMatcher matcher) {\n         return replace(matcher, null, 0, size, -1);\n     }\n \n      * @param matcher  the matcher to use to find the deletion, null causes no action\n      * @return this, to enable chaining\n      */\n-    public StrBuilder deleteFirst(StrMatcher matcher) {\n+    public StrBuilder deleteFirst(final StrMatcher matcher) {\n         return replace(matcher, null, 0, size, 1);\n     }\n \n      * @param insertLen  the length of the insert string, must be valid\n      * @throws IndexOutOfBoundsException if any index is invalid\n      */\n-    private void replaceImpl(int startIndex, int endIndex, int removeLen, String insertStr, int insertLen) {\n+    private void replaceImpl(final int startIndex, final int endIndex, final int removeLen, final String insertStr, final int insertLen) {\n         int newSize = size - removeLen + insertLen;\n         if (insertLen != removeLen) {\n             ensureCapacity(newSize);\n      * @return this, to enable chaining\n      * @throws IndexOutOfBoundsException if the index is invalid\n      */\n-    public StrBuilder replace(int startIndex, int endIndex, String replaceStr) {\n+    public StrBuilder replace(final int startIndex, int endIndex, final String replaceStr) {\n         endIndex = validateRange(startIndex, endIndex);\n         int insertLen = (replaceStr == null ? 0 : replaceStr.length());\n         replaceImpl(startIndex, endIndex, endIndex - startIndex, replaceStr, insertLen);\n      * @param replace  the replace character\n      * @return this, to enable chaining\n      */\n-    public StrBuilder replaceAll(char search, char replace) {\n+    public StrBuilder replaceAll(final char search, final char replace) {\n         if (search != replace) {\n             for (int i = 0; i < size; i++) {\n                 if (buffer[i] == search) {\n      * @param replace  the replace character\n      * @return this, to enable chaining\n      */\n-    public StrBuilder replaceFirst(char search, char replace) {\n+    public StrBuilder replaceFirst(final char search, final char replace) {\n         if (search != replace) {\n             for (int i = 0; i < size; i++) {\n                 if (buffer[i] == search) {\n      * @param replaceStr  the replace string, null is equivalent to an empty string\n      * @return this, to enable chaining\n      */\n-    public StrBuilder replaceAll(String searchStr, String replaceStr) {\n+    public StrBuilder replaceAll(final String searchStr, final String replaceStr) {\n         int searchLen = (searchStr == null ? 0 : searchStr.length());\n         if (searchLen > 0) {\n             int replaceLen = (replaceStr == null ? 0 : replaceStr.length());\n      * @param replaceStr  the replace string, null is equivalent to an empty string\n      * @return this, to enable chaining\n      */\n-    public StrBuilder replaceFirst(String searchStr, String replaceStr) {\n+    public StrBuilder replaceFirst(final String searchStr, final String replaceStr) {\n         int searchLen = (searchStr == null ? 0 : searchStr.length());\n         if (searchLen > 0) {\n             int index = indexOf(searchStr, 0);\n      * @param replaceStr  the replace string, null is equivalent to an empty string\n      * @return this, to enable chaining\n      */\n-    public StrBuilder replaceAll(StrMatcher matcher, String replaceStr) {\n+    public StrBuilder replaceAll(final StrMatcher matcher, final String replaceStr) {\n         return replace(matcher, replaceStr, 0, size, -1);\n     }\n \n      * @param replaceStr  the replace string, null is equivalent to an empty string\n      * @return this, to enable chaining\n      */\n-    public StrBuilder replaceFirst(StrMatcher matcher, String replaceStr) {\n+    public StrBuilder replaceFirst(final StrMatcher matcher, final String replaceStr) {\n         return replace(matcher, replaceStr, 0, size, 1);\n     }\n \n      * @throws IndexOutOfBoundsException if start index is invalid\n      */\n     public StrBuilder replace(\n-            StrMatcher matcher, String replaceStr,\n-            int startIndex, int endIndex, int replaceCount) {\n+            final StrMatcher matcher, final String replaceStr,\n+            final int startIndex, int endIndex, final int replaceCount) {\n         endIndex = validateRange(startIndex, endIndex);\n         return replaceImpl(matcher, replaceStr, startIndex, endIndex, replaceCount);\n     }\n      * @throws IndexOutOfBoundsException if any index is invalid\n      */\n     private StrBuilder replaceImpl(\n-            StrMatcher matcher, String replaceStr,\n-            int from, int to, int replaceCount) {\n+            final StrMatcher matcher, final String replaceStr,\n+            final int from, int to, int replaceCount) {\n         if (matcher == null || size == 0) {\n             return this;\n         }\n      * @param str  the string to search for, null returns false\n      * @return true if the builder starts with the string\n      */\n-    public boolean startsWith(String str) {\n+    public boolean startsWith(final String str) {\n         if (str == null) {\n             return false;\n         }\n      * @param str  the string to search for, null returns false\n      * @return true if the builder ends with the string\n      */\n-    public boolean endsWith(String str) {\n+    public boolean endsWith(final String str) {\n         if (str == null) {\n             return false;\n         }\n      * @since 3.0\n      */\n     @Override\n-    public CharSequence subSequence(int startIndex, int endIndex) {\n+    public CharSequence subSequence(final int startIndex, final int endIndex) {\n       if (startIndex < 0) {\n           throw new StringIndexOutOfBoundsException(startIndex);\n       }\n      * @return the new string\n      * @throws IndexOutOfBoundsException if the index is invalid\n      */\n-    public String substring(int start) {\n+    public String substring(final int start) {\n         return substring(start, size);\n     }\n \n      * @return the new string\n      * @throws IndexOutOfBoundsException if the index is invalid\n      */\n-    public String substring(int startIndex, int endIndex) {\n+    public String substring(final int startIndex, int endIndex) {\n         endIndex = validateRange(startIndex, endIndex);\n         return new String(buffer, startIndex, endIndex - startIndex);\n     }\n      * @param length  the number of characters to extract, negative returns empty string\n      * @return the new string\n      */\n-    public String leftString(int length) {\n+    public String leftString(final int length) {\n         if (length <= 0) {\n             return \"\";\n         } else if (length >= size) {\n      * @param length  the number of characters to extract, negative returns empty string\n      * @return the new string\n      */\n-    public String rightString(int length) {\n+    public String rightString(final int length) {\n         if (length <= 0) {\n             return \"\";\n         } else if (length >= size) {\n      * @param length  the number of characters to extract, negative returns empty string\n      * @return the new string\n      */\n-    public String midString(int index, int length) {\n+    public String midString(int index, final int length) {\n         if (index < 0) {\n             index = 0;\n         }\n      * @param ch  the character to find\n      * @return true if the builder contains the character\n      */\n-    public boolean contains(char ch) {\n+    public boolean contains(final char ch) {\n         char[] thisBuf = buffer;\n         for (int i = 0; i < this.size; i++) {\n             if (thisBuf[i] == ch) {\n      * @param str  the string to find\n      * @return true if the builder contains the string\n      */\n-    public boolean contains(String str) {\n+    public boolean contains(final String str) {\n         return indexOf(str, 0) >= 0;\n     }\n \n      * @param matcher  the matcher to use, null returns -1\n      * @return true if the matcher finds a match in the builder\n      */\n-    public boolean contains(StrMatcher matcher) {\n+    public boolean contains(final StrMatcher matcher) {\n         return indexOf(matcher, 0) >= 0;\n     }\n \n      * @param ch  the character to find\n      * @return the first index of the character, or -1 if not found\n      */\n-    public int indexOf(char ch) {\n+    public int indexOf(final char ch) {\n         return indexOf(ch, 0);\n     }\n \n      * @param startIndex  the index to start at, invalid index rounded to edge\n      * @return the first index of the character, or -1 if not found\n      */\n-    public int indexOf(char ch, int startIndex) {\n+    public int indexOf(final char ch, int startIndex) {\n         startIndex = (startIndex < 0 ? 0 : startIndex);\n         if (startIndex >= size) {\n             return -1;\n      * @param str  the string to find, null returns -1\n      * @return the first index of the string, or -1 if not found\n      */\n-    public int indexOf(String str) {\n+    public int indexOf(final String str) {\n         return indexOf(str, 0);\n     }\n \n      * @param startIndex  the index to start at, invalid index rounded to edge\n      * @return the first index of the string, or -1 if not found\n      */\n-    public int indexOf(String str, int startIndex) {\n+    public int indexOf(final String str, int startIndex) {\n         startIndex = (startIndex < 0 ? 0 : startIndex);\n         if (str == null || startIndex >= size) {\n             return -1;\n      * @param matcher  the matcher to use, null returns -1\n      * @return the first index matched, or -1 if not found\n      */\n-    public int indexOf(StrMatcher matcher) {\n+    public int indexOf(final StrMatcher matcher) {\n         return indexOf(matcher, 0);\n     }\n \n      * @param startIndex  the index to start at, invalid index rounded to edge\n      * @return the first index matched, or -1 if not found\n      */\n-    public int indexOf(StrMatcher matcher, int startIndex) {\n+    public int indexOf(final StrMatcher matcher, int startIndex) {\n         startIndex = (startIndex < 0 ? 0 : startIndex);\n         if (matcher == null || startIndex >= size) {\n             return -1;\n      * @param ch  the character to find\n      * @return the last index of the character, or -1 if not found\n      */\n-    public int lastIndexOf(char ch) {\n+    public int lastIndexOf(final char ch) {\n         return lastIndexOf(ch, size - 1);\n     }\n \n      * @param startIndex  the index to start at, invalid index rounded to edge\n      * @return the last index of the character, or -1 if not found\n      */\n-    public int lastIndexOf(char ch, int startIndex) {\n+    public int lastIndexOf(final char ch, int startIndex) {\n         startIndex = (startIndex >= size ? size - 1 : startIndex);\n         if (startIndex < 0) {\n             return -1;\n      * @param str  the string to find, null returns -1\n      * @return the last index of the string, or -1 if not found\n      */\n-    public int lastIndexOf(String str) {\n+    public int lastIndexOf(final String str) {\n         return lastIndexOf(str, size - 1);\n     }\n \n      * @param startIndex  the index to start at, invalid index rounded to edge\n      * @return the last index of the string, or -1 if not found\n      */\n-    public int lastIndexOf(String str, int startIndex) {\n+    public int lastIndexOf(final String str, int startIndex) {\n         startIndex = (startIndex >= size ? size - 1 : startIndex);\n         if (str == null || startIndex < 0) {\n             return -1;\n      * @param matcher  the matcher to use, null returns -1\n      * @return the last index matched, or -1 if not found\n      */\n-    public int lastIndexOf(StrMatcher matcher) {\n+    public int lastIndexOf(final StrMatcher matcher) {\n         return lastIndexOf(matcher, size);\n     }\n \n      * @param startIndex  the index to start at, invalid index rounded to edge\n      * @return the last index matched, or -1 if not found\n      */\n-    public int lastIndexOf(StrMatcher matcher, int startIndex) {\n+    public int lastIndexOf(final StrMatcher matcher, int startIndex) {\n         startIndex = (startIndex >= size ? size - 1 : startIndex);\n         if (matcher == null || startIndex < 0) {\n             return -1;\n      * @param other  the object to check, null returns false\n      * @return true if the builders contain the same characters in the same order\n      */\n-    public boolean equalsIgnoreCase(StrBuilder other) {\n+    public boolean equalsIgnoreCase(final StrBuilder other) {\n         if (this == other) {\n             return true;\n         }\n      * @param other  the object to check, null returns false\n      * @return true if the builders contain the same characters in the same order\n      */\n-    public boolean equals(StrBuilder other) {\n+    public boolean equals(final StrBuilder other) {\n         if (this == other) {\n             return true;\n         }\n      * @return true if the builders contain the same characters in the same order\n      */\n     @Override\n-    public boolean equals(Object obj) {\n+    public boolean equals(final Object obj) {\n         if (obj instanceof StrBuilder) {\n             return equals((StrBuilder) obj);\n         }\n      * @return the new string\n      * @throws IndexOutOfBoundsException if the index is invalid\n      */\n-    protected int validateRange(int startIndex, int endIndex) {\n+    protected int validateRange(final int startIndex, int endIndex) {\n         if (startIndex < 0) {\n             throw new StringIndexOutOfBoundsException(startIndex);\n         }\n      * @param index  the index, must be valid\n      * @throws IndexOutOfBoundsException if the index is invalid\n      */\n-    protected void validateIndex(int index) {\n+    protected void validateIndex(final int index) {\n         if (index < 0 || index > size) {\n             throw new StringIndexOutOfBoundsException(index);\n         }\n \n         /** {@inheritDoc} */\n         @Override\n-        protected List<String> tokenize(char[] chars, int offset, int count) {\n+        protected List<String> tokenize(final char[] chars, final int offset, final int count) {\n             if (chars == null) {\n                 return super.tokenize(StrBuilder.this.buffer, 0, StrBuilder.this.size());\n             } else {\n \n         /** {@inheritDoc} */\n         @Override\n-        public int read(char b[], int off, int len) {\n+        public int read(final char b[], final int off, int len) {\n             if (off < 0 || len < 0 || off > b.length ||\n                     (off + len) > b.length || (off + len) < 0) {\n                 throw new IndexOutOfBoundsException();\n \n         /** {@inheritDoc} */\n         @Override\n-        public void mark(int readAheadLimit) {\n+        public void mark(final int readAheadLimit) {\n             mark = pos;\n         }\n \n \n         /** {@inheritDoc} */\n         @Override\n-        public void write(int c) {\n+        public void write(final int c) {\n             StrBuilder.this.append((char) c);\n         }\n \n         /** {@inheritDoc} */\n         @Override\n-        public void write(char[] cbuf) {\n+        public void write(final char[] cbuf) {\n             StrBuilder.this.append(cbuf);\n         }\n \n         /** {@inheritDoc} */\n         @Override\n-        public void write(char[] cbuf, int off, int len) {\n+        public void write(final char[] cbuf, final int off, final int len) {\n             StrBuilder.this.append(cbuf, off, len);\n         }\n \n         /** {@inheritDoc} */\n         @Override\n-        public void write(String str) {\n+        public void write(final String str) {\n             StrBuilder.this.append(str);\n         }\n \n         /** {@inheritDoc} */\n         @Override\n-        public void write(String str, int off, int len) {\n+        public void write(final String str, final int off, final int len) {\n             StrBuilder.this.append(str, off, len);\n         }\n     }\n--- a/src/main/java/org/apache/commons/lang3/text/StrLookup.java\n+++ b/src/main/java/org/apache/commons/lang3/text/StrLookup.java\n      * @param map  the map of keys to values, may be null\n      * @return a lookup using the map, not null\n      */\n-    public static <V> StrLookup<V> mapLookup(Map<String, V> map) {\n+    public static <V> StrLookup<V> mapLookup(final Map<String, V> map) {\n         return new MapStrLookup<V>(map);\n     }\n \n          *\n          * @param map  the map of keys to values, may be null\n          */\n-        MapStrLookup(Map<String, V> map) {\n+        MapStrLookup(final Map<String, V> map) {\n             this.map = map;\n         }\n \n          * @return the matching value, null if no match\n          */\n         @Override\n-        public String lookup(String key) {\n+        public String lookup(final String key) {\n             if (map == null) {\n                 return null;\n             }\n--- a/src/main/java/org/apache/commons/lang3/text/StrMatcher.java\n+++ b/src/main/java/org/apache/commons/lang3/text/StrMatcher.java\n      * @param ch  the character to match, must not be null\n      * @return a new Matcher for the given char\n      */\n-    public static StrMatcher charMatcher(char ch) {\n+    public static StrMatcher charMatcher(final char ch) {\n         return new CharMatcher(ch);\n     }\n \n      * @param chars  the characters to match, null or empty matches nothing\n      * @return a new matcher for the given char[]\n      */\n-    public static StrMatcher charSetMatcher(char... chars) {\n+    public static StrMatcher charSetMatcher(final char... chars) {\n         if (chars == null || chars.length == 0) {\n             return NONE_MATCHER;\n         }\n      * @param chars  the characters to match, null or empty matches nothing\n      * @return a new Matcher for the given characters\n      */\n-    public static StrMatcher charSetMatcher(String chars) {\n+    public static StrMatcher charSetMatcher(final String chars) {\n         if (StringUtils.isEmpty(chars)) {\n             return NONE_MATCHER;\n         }\n      * @param str  the string to match, null or empty matches nothing\n      * @return a new Matcher for the given String\n      */\n-    public static StrMatcher stringMatcher(String str) {\n+    public static StrMatcher stringMatcher(final String str) {\n         if (StringUtils.isEmpty(str)) {\n             return NONE_MATCHER;\n         }\n      * @return the number of matching characters, zero for no match\n      * @since 2.4\n      */\n-    public int isMatch(char[] buffer, int pos) {\n+    public int isMatch(final char[] buffer, final int pos) {\n         return isMatch(buffer, pos, 0, buffer.length);\n     }\n \n          *\n          * @param chars  the characters to match, must not be null\n          */\n-        CharSetMatcher(char chars[]) {\n+        CharSetMatcher(final char chars[]) {\n             super();\n             this.chars = chars.clone();\n             Arrays.sort(this.chars);\n          * @return the number of matching characters, zero for no match\n          */\n         @Override\n-        public int isMatch(char[] buffer, int pos, int bufferStart, int bufferEnd) {\n+        public int isMatch(final char[] buffer, final int pos, final int bufferStart, final int bufferEnd) {\n             return Arrays.binarySearch(chars, buffer[pos]) >= 0 ? 1 : 0;\n         }\n     }\n          *\n          * @param ch  the character to match\n          */\n-        CharMatcher(char ch) {\n+        CharMatcher(final char ch) {\n             super();\n             this.ch = ch;\n         }\n          * @return the number of matching characters, zero for no match\n          */\n         @Override\n-        public int isMatch(char[] buffer, int pos, int bufferStart, int bufferEnd) {\n+        public int isMatch(final char[] buffer, final int pos, final int bufferStart, final int bufferEnd) {\n             return ch == buffer[pos] ? 1 : 0;\n         }\n     }\n          *\n          * @param str  the string to match, must not be null\n          */\n-        StringMatcher(String str) {\n+        StringMatcher(final String str) {\n             super();\n             chars = str.toCharArray();\n         }\n          * @return the number of matching characters, zero for no match\n          */\n         @Override\n-        public int isMatch(char[] buffer, int pos, int bufferStart, int bufferEnd) {\n+        public int isMatch(final char[] buffer, int pos, final int bufferStart, final int bufferEnd) {\n             int len = chars.length;\n             if (pos + len > bufferEnd) {\n                 return 0;\n          * @return the number of matching characters, zero for no match\n          */\n         @Override\n-        public int isMatch(char[] buffer, int pos, int bufferStart, int bufferEnd) {\n+        public int isMatch(final char[] buffer, final int pos, final int bufferStart, final int bufferEnd) {\n             return 0;\n         }\n     }\n          * @return the number of matching characters, zero for no match\n          */\n         @Override\n-        public int isMatch(char[] buffer, int pos, int bufferStart, int bufferEnd) {\n+        public int isMatch(final char[] buffer, final int pos, final int bufferStart, final int bufferEnd) {\n             return buffer[pos] <= 32 ? 1 : 0;\n         }\n     }\n--- a/src/main/java/org/apache/commons/lang3/text/StrSubstitutor.java\n+++ b/src/main/java/org/apache/commons/lang3/text/StrSubstitutor.java\n      * @param valueMap  the map with the values, may be null\n      * @return the result of the replace operation\n      */\n-    public static <V> String replace(Object source, Map<String, V> valueMap) {\n+    public static <V> String replace(final Object source, final Map<String, V> valueMap) {\n         return new StrSubstitutor(valueMap).replace(source);\n     }\n \n      * @return the result of the replace operation\n      * @throws IllegalArgumentException if the prefix or suffix is null\n      */\n-    public static <V> String replace(Object source, Map<String, V> valueMap, String prefix, String suffix) {\n+    public static <V> String replace(final Object source, final Map<String, V> valueMap, final String prefix, final String suffix) {\n         return new StrSubstitutor(valueMap, prefix, suffix).replace(source);\n     }\n \n      * @param valueProperties the properties with values, may be null\n      * @return the result of the replace operation\n      */\n-    public static String replace(Object source, Properties valueProperties) {\n+    public static String replace(final Object source, final Properties valueProperties) {\n         if (valueProperties == null) {\n             return source.toString();\n         }\n      * @param source  the source text containing the variables to substitute, null returns null\n      * @return the result of the replace operation\n      */\n-    public static String replaceSystemProperties(Object source) {\n+    public static String replaceSystemProperties(final Object source) {\n         return new StrSubstitutor(StrLookup.systemPropertiesLookup()).replace(source);\n     }\n \n      * @param <V> the type of the values in the map\n      * @param valueMap  the map with the variables' values, may be null\n      */\n-    public <V> StrSubstitutor(Map<String, V> valueMap) {\n+    public <V> StrSubstitutor(final Map<String, V> valueMap) {\n         this(StrLookup.mapLookup(valueMap), DEFAULT_PREFIX, DEFAULT_SUFFIX, DEFAULT_ESCAPE);\n     }\n \n      * @param suffix  the suffix for variables, not null\n      * @throws IllegalArgumentException if the prefix or suffix is null\n      */\n-    public <V> StrSubstitutor(Map<String, V> valueMap, String prefix, String suffix) {\n+    public <V> StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix) {\n         this(StrLookup.mapLookup(valueMap), prefix, suffix, DEFAULT_ESCAPE);\n     }\n \n      * @param escape  the escape character\n      * @throws IllegalArgumentException if the prefix or suffix is null\n      */\n-    public <V> StrSubstitutor(Map<String, V> valueMap, String prefix, String suffix, char escape) {\n+    public <V> StrSubstitutor(final Map<String, V> valueMap, final String prefix, final String suffix, final char escape) {\n         this(StrLookup.mapLookup(valueMap), prefix, suffix, escape);\n     }\n \n      *\n      * @param variableResolver  the variable resolver, may be null\n      */\n-    public StrSubstitutor(StrLookup<?> variableResolver) {\n+    public StrSubstitutor(final StrLookup<?> variableResolver) {\n         this(variableResolver, DEFAULT_PREFIX, DEFAULT_SUFFIX, DEFAULT_ESCAPE);\n     }\n \n      * @param escape  the escape character\n      * @throws IllegalArgumentException if the prefix or suffix is null\n      */\n-    public StrSubstitutor(StrLookup<?> variableResolver, String prefix, String suffix, char escape) {\n+    public StrSubstitutor(final StrLookup<?> variableResolver, final String prefix, final String suffix, final char escape) {\n         this.setVariableResolver(variableResolver);\n         this.setVariablePrefix(prefix);\n         this.setVariableSuffix(suffix);\n      * @throws IllegalArgumentException if the prefix or suffix is null\n      */\n     public StrSubstitutor(\n-            StrLookup<?> variableResolver, StrMatcher prefixMatcher, StrMatcher suffixMatcher, char escape) {\n+            final StrLookup<?> variableResolver, final StrMatcher prefixMatcher, final StrMatcher suffixMatcher, final char escape) {\n         this.setVariableResolver(variableResolver);\n         this.setVariablePrefixMatcher(prefixMatcher);\n         this.setVariableSuffixMatcher(suffixMatcher);\n      * @param source  the string to replace in, null returns null\n      * @return the result of the replace operation\n      */\n-    public String replace(String source) {\n+    public String replace(final String source) {\n         if (source == null) {\n             return null;\n         }\n      * @param length  the length within the array to be processed, must be valid\n      * @return the result of the replace operation\n      */\n-    public String replace(String source, int offset, int length) {\n+    public String replace(final String source, final int offset, final int length) {\n         if (source == null) {\n             return null;\n         }\n      * @param source  the character array to replace in, not altered, null returns null\n      * @return the result of the replace operation\n      */\n-    public String replace(char[] source) {\n+    public String replace(final char[] source) {\n         if (source == null) {\n             return null;\n         }\n      * @param length  the length within the array to be processed, must be valid\n      * @return the result of the replace operation\n      */\n-    public String replace(char[] source, int offset, int length) {\n+    public String replace(final char[] source, final int offset, final int length) {\n         if (source == null) {\n             return null;\n         }\n      * @param source  the buffer to use as a template, not changed, null returns null\n      * @return the result of the replace operation\n      */\n-    public String replace(StringBuffer source) {\n+    public String replace(final StringBuffer source) {\n         if (source == null) {\n             return null;\n         }\n      * @param length  the length within the array to be processed, must be valid\n      * @return the result of the replace operation\n      */\n-    public String replace(StringBuffer source, int offset, int length) {\n+    public String replace(final StringBuffer source, final int offset, final int length) {\n         if (source == null) {\n             return null;\n         }\n      * @param source  the builder to use as a template, not changed, null returns null\n      * @return the result of the replace operation\n      */\n-    public String replace(StrBuilder source) {\n+    public String replace(final StrBuilder source) {\n         if (source == null) {\n             return null;\n         }\n      * @param length  the length within the array to be processed, must be valid\n      * @return the result of the replace operation\n      */\n-    public String replace(StrBuilder source, int offset, int length) {\n+    public String replace(final StrBuilder source, final int offset, final int length) {\n         if (source == null) {\n             return null;\n         }\n      * @param source  the source to replace in, null returns null\n      * @return the result of the replace operation\n      */\n-    public String replace(Object source) {\n+    public String replace(final Object source) {\n         if (source == null) {\n             return null;\n         }\n      * @param source  the buffer to replace in, updated, null returns zero\n      * @return true if altered\n      */\n-    public boolean replaceIn(StringBuffer source) {\n+    public boolean replaceIn(final StringBuffer source) {\n         if (source == null) {\n             return false;\n         }\n      * @param length  the length within the buffer to be processed, must be valid\n      * @return true if altered\n      */\n-    public boolean replaceIn(StringBuffer source, int offset, int length) {\n+    public boolean replaceIn(final StringBuffer source, final int offset, final int length) {\n         if (source == null) {\n             return false;\n         }\n      * @param source  the builder to replace in, updated, null returns zero\n      * @return true if altered\n      */\n-    public boolean replaceIn(StrBuilder source) {\n+    public boolean replaceIn(final StrBuilder source) {\n         if (source == null) {\n             return false;\n         }\n      * @param length  the length within the builder to be processed, must be valid\n      * @return true if altered\n      */\n-    public boolean replaceIn(StrBuilder source, int offset, int length) {\n+    public boolean replaceIn(final StrBuilder source, final int offset, final int length) {\n         if (source == null) {\n             return false;\n         }\n      * @param length  the length within the builder to be processed, must be valid\n      * @return true if altered\n      */\n-    protected boolean substitute(StrBuilder buf, int offset, int length) {\n+    protected boolean substitute(final StrBuilder buf, final int offset, final int length) {\n         return substitute(buf, offset, length, null) > 0;\n     }\n \n      * @return the length change that occurs, unless priorVariables is null when the int\n      *  represents a boolean flag as to whether any change occurred.\n      */\n-    private int substitute(StrBuilder buf, int offset, int length, List<String> priorVariables) {\n+    private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables) {\n         StrMatcher prefixMatcher = getVariablePrefixMatcher();\n         StrMatcher suffixMatcher = getVariableSuffixMatcher();\n         char escape = getEscapeChar();\n      * @param varName  the variable name to check\n      * @param priorVariables  the list of prior variables\n      */\n-    private void checkCyclicSubstitution(String varName, List<String> priorVariables) {\n+    private void checkCyclicSubstitution(final String varName, final List<String> priorVariables) {\n         if (priorVariables.contains(varName) == false) {\n             return;\n         }\n      * @param endPos  the end position of the variable including the suffix, valid\n      * @return the variable's value or <b>null</b> if the variable is unknown\n      */\n-    protected String resolveVariable(String variableName, StrBuilder buf, int startPos, int endPos) {\n+    protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos) {\n         StrLookup<?> resolver = getVariableResolver();\n         if (resolver == null) {\n             return null;\n      *\n      * @param escapeCharacter  the escape character (0 for disabling escaping)\n      */\n-    public void setEscapeChar(char escapeCharacter) {\n+    public void setEscapeChar(final char escapeCharacter) {\n         this.escapeChar = escapeCharacter;\n     }\n \n      * @return this, to enable chaining\n      * @throws IllegalArgumentException if the prefix matcher is null\n      */\n-    public StrSubstitutor setVariablePrefixMatcher(StrMatcher prefixMatcher) {\n+    public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher) {\n         if (prefixMatcher == null) {\n             throw new IllegalArgumentException(\"Variable prefix matcher must not be null!\");\n         }\n      * @param prefix  the prefix character to use\n      * @return this, to enable chaining\n      */\n-    public StrSubstitutor setVariablePrefix(char prefix) {\n+    public StrSubstitutor setVariablePrefix(final char prefix) {\n         return setVariablePrefixMatcher(StrMatcher.charMatcher(prefix));\n     }\n \n      * @return this, to enable chaining\n      * @throws IllegalArgumentException if the prefix is null\n      */\n-    public StrSubstitutor setVariablePrefix(String prefix) {\n+    public StrSubstitutor setVariablePrefix(final String prefix) {\n        if (prefix == null) {\n             throw new IllegalArgumentException(\"Variable prefix must not be null!\");\n         }\n      * @return this, to enable chaining\n      * @throws IllegalArgumentException if the suffix matcher is null\n      */\n-    public StrSubstitutor setVariableSuffixMatcher(StrMatcher suffixMatcher) {\n+    public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher) {\n         if (suffixMatcher == null) {\n             throw new IllegalArgumentException(\"Variable suffix matcher must not be null!\");\n         }\n      * @param suffix  the suffix character to use\n      * @return this, to enable chaining\n      */\n-    public StrSubstitutor setVariableSuffix(char suffix) {\n+    public StrSubstitutor setVariableSuffix(final char suffix) {\n         return setVariableSuffixMatcher(StrMatcher.charMatcher(suffix));\n     }\n \n      * @return this, to enable chaining\n      * @throws IllegalArgumentException if the suffix is null\n      */\n-    public StrSubstitutor setVariableSuffix(String suffix) {\n+    public StrSubstitutor setVariableSuffix(final String suffix) {\n        if (suffix == null) {\n             throw new IllegalArgumentException(\"Variable suffix must not be null!\");\n         }\n      *\n      * @param variableResolver  the VariableResolver\n      */\n-    public void setVariableResolver(StrLookup<?> variableResolver) {\n+    public void setVariableResolver(final StrLookup<?> variableResolver) {\n         this.variableResolver = variableResolver;\n     }\n \n      * @since 3.0\n      */\n     public void setEnableSubstitutionInVariables(\n-            boolean enableSubstitutionInVariables) {\n+            final boolean enableSubstitutionInVariables) {\n         this.enableSubstitutionInVariables = enableSubstitutionInVariables;\n     }\n }\n--- a/src/main/java/org/apache/commons/lang3/text/StrTokenizer.java\n+++ b/src/main/java/org/apache/commons/lang3/text/StrTokenizer.java\n      * @param input  the text to parse\n      * @return a new tokenizer instance which parses Comma Separated Value strings\n      */\n-    public static StrTokenizer getCSVInstance(String input) {\n+    public static StrTokenizer getCSVInstance(final String input) {\n         StrTokenizer tok = getCSVClone();\n         tok.reset(input);\n         return tok;\n      * @param input  the text to parse\n      * @return a new tokenizer instance which parses Comma Separated Value strings\n      */\n-    public static StrTokenizer getCSVInstance(char[] input) {\n+    public static StrTokenizer getCSVInstance(final char[] input) {\n         StrTokenizer tok = getCSVClone();\n         tok.reset(input);\n         return tok;\n      * @param input  the string to parse\n      * @return a new tokenizer instance which parses Tab Separated Value strings.\n      */\n-    public static StrTokenizer getTSVInstance(String input) {\n+    public static StrTokenizer getTSVInstance(final String input) {\n         StrTokenizer tok = getTSVClone();\n         tok.reset(input);\n         return tok;\n      * @param input  the string to parse\n      * @return a new tokenizer instance which parses Tab Separated Value strings.\n      */\n-    public static StrTokenizer getTSVInstance(char[] input) {\n+    public static StrTokenizer getTSVInstance(final char[] input) {\n         StrTokenizer tok = getTSVClone();\n         tok.reset(input);\n         return tok;\n      *\n      * @param input  the string which is to be parsed\n      */\n-    public StrTokenizer(String input) {\n+    public StrTokenizer(final String input) {\n         super();\n         if (input != null) {\n             chars = input.toCharArray();\n      * @param input  the string which is to be parsed\n      * @param delim  the field delimiter character\n      */\n-    public StrTokenizer(String input, char delim) {\n+    public StrTokenizer(final String input, final char delim) {\n         this(input);\n         setDelimiterChar(delim);\n     }\n      * @param input  the string which is to be parsed\n      * @param delim  the field delimiter string\n      */\n-    public StrTokenizer(String input, String delim) {\n+    public StrTokenizer(final String input, final String delim) {\n         this(input);\n         setDelimiterString(delim);\n     }\n      * @param input  the string which is to be parsed\n      * @param delim  the field delimiter matcher\n      */\n-    public StrTokenizer(String input, StrMatcher delim) {\n+    public StrTokenizer(final String input, final StrMatcher delim) {\n         this(input);\n         setDelimiterMatcher(delim);\n     }\n      * @param delim  the field delimiter character\n      * @param quote  the field quoted string character\n      */\n-    public StrTokenizer(String input, char delim, char quote) {\n+    public StrTokenizer(final String input, final char delim, final char quote) {\n         this(input, delim);\n         setQuoteChar(quote);\n     }\n      * @param delim  the field delimiter matcher\n      * @param quote  the field quoted string matcher\n      */\n-    public StrTokenizer(String input, StrMatcher delim, StrMatcher quote) {\n+    public StrTokenizer(final String input, final StrMatcher delim, final StrMatcher quote) {\n         this(input, delim);\n         setQuoteMatcher(quote);\n     }\n      *\n      * @param input  the string which is to be parsed, not cloned\n      */\n-    public StrTokenizer(char[] input) {\n+    public StrTokenizer(final char[] input) {\n         super();\n         this.chars = ArrayUtils.clone(input);\n     }\n      * @param input  the string which is to be parsed, not cloned\n      * @param delim the field delimiter character\n      */\n-    public StrTokenizer(char[] input, char delim) {\n+    public StrTokenizer(final char[] input, final char delim) {\n         this(input);\n         setDelimiterChar(delim);\n     }\n      * @param input  the string which is to be parsed, not cloned\n      * @param delim the field delimiter string\n      */\n-    public StrTokenizer(char[] input, String delim) {\n+    public StrTokenizer(final char[] input, final String delim) {\n         this(input);\n         setDelimiterString(delim);\n     }\n      * @param input  the string which is to be parsed, not cloned\n      * @param delim  the field delimiter matcher\n      */\n-    public StrTokenizer(char[] input, StrMatcher delim) {\n+    public StrTokenizer(final char[] input, final StrMatcher delim) {\n         this(input);\n         setDelimiterMatcher(delim);\n     }\n      * @param delim  the field delimiter character\n      * @param quote  the field quoted string character\n      */\n-    public StrTokenizer(char[] input, char delim, char quote) {\n+    public StrTokenizer(final char[] input, final char delim, final char quote) {\n         this(input, delim);\n         setQuoteChar(quote);\n     }\n      * @param delim  the field delimiter character\n      * @param quote  the field quoted string character\n      */\n-    public StrTokenizer(char[] input, StrMatcher delim, StrMatcher quote) {\n+    public StrTokenizer(final char[] input, final StrMatcher delim, final StrMatcher quote) {\n         this(input, delim);\n         setQuoteMatcher(quote);\n     }\n      * @param input  the new string to tokenize, null sets no text to parse\n      * @return this, to enable chaining\n      */\n-    public StrTokenizer reset(String input) {\n+    public StrTokenizer reset(final String input) {\n         reset();\n         if (input != null) {\n             this.chars = input.toCharArray();\n      * @param input  the new character array to tokenize, not cloned, null sets no text to parse\n      * @return this, to enable chaining\n      */\n-    public StrTokenizer reset(char[] input) {\n+    public StrTokenizer reset(final char[] input) {\n         reset();\n         this.chars = ArrayUtils.clone(input);\n         return this;\n      * @throws UnsupportedOperationException always\n      */\n     @Override\n-    public void set(String obj) {\n+    public void set(final String obj) {\n         throw new UnsupportedOperationException(\"set() is unsupported\");\n     }\n \n      * @throws UnsupportedOperationException always\n      */\n     @Override\n-    public void add(String obj) {\n+    public void add(final String obj) {\n         throw new UnsupportedOperationException(\"add() is unsupported\");\n     }\n \n      * @param count  the number of characters to tokenize, must be valid\n      * @return the modifiable list of String tokens, unmodifiable if null array or zero count\n      */\n-    protected List<String> tokenize(char[] chars, int offset, int count) {\n+    protected List<String> tokenize(final char[] chars, final int offset, final int count) {\n         if (chars == null || count == 0) {\n             return Collections.emptyList();\n         }\n      * @param list  the list to add to\n      * @param tok  the token to add\n      */\n-    private void addToken(List<String> list, String tok) {\n+    private void addToken(final List<String> list, String tok) {\n         if (StringUtils.isEmpty(tok)) {\n             if (isIgnoreEmptyTokens()) {\n                 return;\n      * @return the starting position of the next field (the character\n      *  immediately after the delimiter), or -1 if end of string found\n      */\n-    private int readNextToken(char[] chars, int start, int len, StrBuilder workArea, List<String> tokens) {\n+    private int readNextToken(final char[] chars, int start, final int len, final StrBuilder workArea, final List<String> tokens) {\n         // skip all leading whitespace, unless it is the\n         // field delimiter or the quote character\n         while (start < len) {\n      *  immediately after the delimiter, or if end of string found,\n      *  then the length of string\n      */\n-    private int readWithQuotes(char[] chars, int start, int len, StrBuilder workArea, \n-                               List<String> tokens, int quoteStart, int quoteLen) {\n+    private int readWithQuotes(final char[] chars, final int start, final int len, final StrBuilder workArea, \n+                               final List<String> tokens, final int quoteStart, final int quoteLen) {\n         // Loop until we've found the end of the quoted\n         // string or the end of the input\n         workArea.clear();\n      * @param quoteLen  the length of the matched quote, 0 if no quoting\n      * @return true if a quote is matched\n      */\n-    private boolean isQuote(char[] chars, int pos, int len, int quoteStart, int quoteLen) {\n+    private boolean isQuote(final char[] chars, final int pos, final int len, final int quoteStart, final int quoteLen) {\n         for (int i = 0; i < quoteLen; i++) {\n             if (pos + i >= len || chars[pos + i] != chars[quoteStart + i]) {\n                 return false;\n      * @param delim  the delimiter matcher to use\n      * @return this, to enable chaining\n      */\n-    public StrTokenizer setDelimiterMatcher(StrMatcher delim) {\n+    public StrTokenizer setDelimiterMatcher(final StrMatcher delim) {\n         if (delim == null) {\n             this.delimMatcher = StrMatcher.noneMatcher();\n         } else {\n      * @param delim  the delimiter character to use\n      * @return this, to enable chaining\n      */\n-    public StrTokenizer setDelimiterChar(char delim) {\n+    public StrTokenizer setDelimiterChar(final char delim) {\n         return setDelimiterMatcher(StrMatcher.charMatcher(delim));\n     }\n \n      * @param delim  the delimiter string to use\n      * @return this, to enable chaining\n      */\n-    public StrTokenizer setDelimiterString(String delim) {\n+    public StrTokenizer setDelimiterString(final String delim) {\n         return setDelimiterMatcher(StrMatcher.stringMatcher(delim));\n     }\n \n      * @param quote  the quote matcher to use, null ignored\n      * @return this, to enable chaining\n      */\n-    public StrTokenizer setQuoteMatcher(StrMatcher quote) {\n+    public StrTokenizer setQuoteMatcher(final StrMatcher quote) {\n         if (quote != null) {\n             this.quoteMatcher = quote;\n         }\n      * @param quote  the quote character to use\n      * @return this, to enable chaining\n      */\n-    public StrTokenizer setQuoteChar(char quote) {\n+    public StrTokenizer setQuoteChar(final char quote) {\n         return setQuoteMatcher(StrMatcher.charMatcher(quote));\n     }\n \n      * @param ignored  the ignored matcher to use, null ignored\n      * @return this, to enable chaining\n      */\n-    public StrTokenizer setIgnoredMatcher(StrMatcher ignored) {\n+    public StrTokenizer setIgnoredMatcher(final StrMatcher ignored) {\n         if (ignored != null) {\n             this.ignoredMatcher = ignored;\n         }\n      * @param ignored  the ignored character to use\n      * @return this, to enable chaining\n      */\n-    public StrTokenizer setIgnoredChar(char ignored) {\n+    public StrTokenizer setIgnoredChar(final char ignored) {\n         return setIgnoredMatcher(StrMatcher.charMatcher(ignored));\n     }\n \n      * @param trimmer  the trimmer matcher to use, null ignored\n      * @return this, to enable chaining\n      */\n-    public StrTokenizer setTrimmerMatcher(StrMatcher trimmer) {\n+    public StrTokenizer setTrimmerMatcher(final StrMatcher trimmer) {\n         if (trimmer != null) {\n             this.trimmerMatcher = trimmer;\n         }\n      * @param emptyAsNull  whether empty tokens are returned as null\n      * @return this, to enable chaining\n      */\n-    public StrTokenizer setEmptyTokenAsNull(boolean emptyAsNull) {\n+    public StrTokenizer setEmptyTokenAsNull(final boolean emptyAsNull) {\n         this.emptyAsNull = emptyAsNull;\n         return this;\n     }\n      * @param ignoreEmptyTokens  whether empty tokens are not returned\n      * @return this, to enable chaining\n      */\n-    public StrTokenizer setIgnoreEmptyTokens(boolean ignoreEmptyTokens) {\n+    public StrTokenizer setIgnoreEmptyTokens(final boolean ignoreEmptyTokens) {\n         this.ignoreEmptyTokens = ignoreEmptyTokens;\n         return this;\n     }\n--- a/src/main/java/org/apache/commons/lang3/text/WordUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/text/WordUtils.java\n      * @param wrapLength  the column to wrap the words at, less than 1 is treated as 1\n      * @return a line with newlines inserted, <code>null</code> if null input\n      */\n-    public static String wrap(String str, int wrapLength) {\n+    public static String wrap(final String str, final int wrapLength) {\n         return wrap(str, wrapLength, null, false);\n     }\n     \n      * @param wrapLongWords  true if long words (such as URLs) should be wrapped\n      * @return a line with newlines inserted, <code>null</code> if null input\n      */\n-    public static String wrap(String str, int wrapLength, String newLineStr, boolean wrapLongWords) {\n+    public static String wrap(final String str, int wrapLength, String newLineStr, final boolean wrapLongWords) {\n         if (str == null) {\n             return null;\n         }\n      * @see #uncapitalize(String)\n      * @see #capitalizeFully(String)\n      */\n-    public static String capitalize(String str) {\n+    public static String capitalize(final String str) {\n         return capitalize(str, null);\n     }\n \n      * @see #capitalizeFully(String)\n      * @since 2.1\n      */\n-    public static String capitalize(String str, char... delimiters) {\n+    public static String capitalize(final String str, final char... delimiters) {\n         int delimLen = delimiters == null ? -1 : delimiters.length;\n         if (StringUtils.isEmpty(str) || delimLen == 0) {\n             return str;\n      * @param str  the String to capitalize, may be null\n      * @return capitalized String, <code>null</code> if null String input\n      */\n-    public static String capitalizeFully(String str) {\n+    public static String capitalizeFully(final String str) {\n         return capitalizeFully(str, null);\n     }\n \n      * @return capitalized String, <code>null</code> if null String input\n      * @since 2.1\n      */\n-    public static String capitalizeFully(String str, char... delimiters) {\n+    public static String capitalizeFully(String str, final char... delimiters) {\n         int delimLen = delimiters == null ? -1 : delimiters.length;\n         if (StringUtils.isEmpty(str) || delimLen == 0) {\n             return str;\n      * @return uncapitalized String, <code>null</code> if null String input\n      * @see #capitalize(String)\n      */\n-    public static String uncapitalize(String str) {\n+    public static String uncapitalize(final String str) {\n         return uncapitalize(str, null);\n     }\n \n      * @see #capitalize(String)\n      * @since 2.1\n      */\n-    public static String uncapitalize(String str, char... delimiters) {\n+    public static String uncapitalize(final String str, final char... delimiters) {\n         int delimLen = delimiters == null ? -1 : delimiters.length;\n         if (StringUtils.isEmpty(str) || delimLen == 0) {\n             return str;\n      * @param str  the String to swap case, may be null\n      * @return the changed String, <code>null</code> if null String input\n      */\n-    public static String swapCase(String str) {\n+    public static String swapCase(final String str) {\n         if (StringUtils.isEmpty(str)) {\n             return str;\n         }\n      * @see #initials(String,char[])\n      * @since 2.2\n      */\n-    public static String initials(String str) {\n+    public static String initials(final String str) {\n         return initials(str, null);\n     }\n \n      * @see #initials(String)\n      * @since 2.2\n      */\n-    public static String initials(String str, char... delimiters) {\n+    public static String initials(final String str, final char... delimiters) {\n         if (StringUtils.isEmpty(str)) {\n             return str;\n         }\n      * @param delimiters  the delimiters\n      * @return true if it is a delimiter\n      */\n-    private static boolean isDelimiter(char ch, char[] delimiters) {\n+    private static boolean isDelimiter(final char ch, final char[] delimiters) {\n         if (delimiters == null) {\n             return Character.isWhitespace(ch);\n         }\n--- a/src/main/java/org/apache/commons/lang3/text/translate/AggregateTranslator.java\n+++ b/src/main/java/org/apache/commons/lang3/text/translate/AggregateTranslator.java\n      *\n      * @param translators CharSequenceTranslator array to aggregate\n      */\n-    public AggregateTranslator(CharSequenceTranslator... translators) {\n+    public AggregateTranslator(final CharSequenceTranslator... translators) {\n         this.translators = ArrayUtils.clone(translators);\n     }\n \n      * {@inheritDoc}\n      */\n     @Override\n-    public int translate(CharSequence input, int index, Writer out) throws IOException {\n+    public int translate(final CharSequence input, final int index, final Writer out) throws IOException {\n         for (CharSequenceTranslator translator : translators) {\n             int consumed = translator.translate(input, index, out);\n             if(consumed != 0) {\n--- a/src/main/java/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java\n+++ b/src/main/java/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java\n      * @param input CharSequence to be translated\n      * @return String output of translation\n      */\n-    public final String translate(CharSequence input) {\n+    public final String translate(final CharSequence input) {\n         if (input == null) {\n             return null;\n         }\n      * @param out Writer to translate the text to\n      * @throws IOException if and only if the Writer produces an IOException\n      */\n-    public final void translate(CharSequence input, Writer out) throws IOException {\n+    public final void translate(final CharSequence input, final Writer out) throws IOException {\n         if (out == null) {\n             throw new IllegalArgumentException(\"The Writer must not be null\");\n         }\n      * @param translators CharSequenceTranslator array of translators to merge with this one\n      * @return CharSequenceTranslator merging this translator with the others\n      */\n-    public final CharSequenceTranslator with(CharSequenceTranslator... translators) {\n+    public final CharSequenceTranslator with(final CharSequenceTranslator... translators) {\n         CharSequenceTranslator[] newArray = new CharSequenceTranslator[translators.length + 1];\n         newArray[0] = this;\n         System.arraycopy(translators, 0, newArray, 1, translators.length);\n      * @param codepoint The codepoint to convert.\n      * @return An upper case hexadecimal <code>String</code>\n      */\n-    public static String hex(int codepoint) {\n+    public static String hex(final int codepoint) {\n         return Integer.toHexString(codepoint).toUpperCase(Locale.ENGLISH);\n     }\n \n--- a/src/main/java/org/apache/commons/lang3/text/translate/CodePointTranslator.java\n+++ b/src/main/java/org/apache/commons/lang3/text/translate/CodePointTranslator.java\n      * {@inheritDoc}\n      */\n     @Override\n-    public final int translate(CharSequence input, int index, Writer out) throws IOException {\n+    public final int translate(final CharSequence input, final int index, final Writer out) throws IOException {\n         int codepoint = Character.codePointAt(input, index);\n         boolean consumed = translate(codepoint, out);\n         if (consumed) {\n--- a/src/main/java/org/apache/commons/lang3/text/translate/EntityArrays.java\n+++ b/src/main/java/org/apache/commons/lang3/text/translate/EntityArrays.java\n      * @param array String[][] to be inverted\n      * @return String[][] inverted array\n      */\n-    public static String[][] invert(String[][] array) {\n+    public static String[][] invert(final String[][] array) {\n         String[][] newarray = new String[array.length][2];\n         for(int i = 0; i<array.length; i++) {\n             newarray[i][0] = array[i][1];\n--- a/src/main/java/org/apache/commons/lang3/text/translate/JavaUnicodeEscaper.java\n+++ b/src/main/java/org/apache/commons/lang3/text/translate/JavaUnicodeEscaper.java\n      *            above which to escape\n      * @return the newly created {@code UnicodeEscaper} instance\n      */\n-    public static JavaUnicodeEscaper above(int codepoint) {\n+    public static JavaUnicodeEscaper above(final int codepoint) {\n         return outsideOf(0, codepoint);\n     }\n \n      *            below which to escape\n      * @return the newly created {@code UnicodeEscaper} instance\n      */\n-    public static JavaUnicodeEscaper below(int codepoint) {\n+    public static JavaUnicodeEscaper below(final int codepoint) {\n         return outsideOf(codepoint, Integer.MAX_VALUE);\n     }\n \n      *            below which to escape\n      * @return the newly created {@code UnicodeEscaper} instance\n      */\n-    public static JavaUnicodeEscaper between(int codepointLow, int codepointHigh) {\n+    public static JavaUnicodeEscaper between(final int codepointLow, final int codepointHigh) {\n         return new JavaUnicodeEscaper(codepointLow, codepointHigh, true);\n     }\n \n      *            above which to escape\n      * @return the newly created {@code UnicodeEscaper} instance\n      */\n-    public static JavaUnicodeEscaper outsideOf(int codepointLow, int codepointHigh) {\n+    public static JavaUnicodeEscaper outsideOf(final int codepointLow, final int codepointHigh) {\n         return new JavaUnicodeEscaper(codepointLow, codepointHigh, false);\n     }\n \n      * @param between\n      *            whether to escape between the boundaries or outside them\n      */\n-    public JavaUnicodeEscaper(int below, int above, boolean between) {\n+    public JavaUnicodeEscaper(final int below, final int above, final boolean between) {\n         super(below, above, between);\n     }\n \n      *            a Unicode code point\n      */\n     @Override\n-    protected String toUtf16Escape(int codepoint) {\n+    protected String toUtf16Escape(final int codepoint) {\n         char[] surrogatePair = Character.toChars(codepoint);\n         return \"\\\\u\" + hex(surrogatePair[0]) + \"\\\\u\" + hex(surrogatePair[1]);\n     }\n--- a/src/main/java/org/apache/commons/lang3/text/translate/LookupTranslator.java\n+++ b/src/main/java/org/apache/commons/lang3/text/translate/LookupTranslator.java\n      *\n      * @param lookup CharSequence[][] table of size [*][2]\n      */\n-    public LookupTranslator(CharSequence[]... lookup) {\n+    public LookupTranslator(final CharSequence[]... lookup) {\n         lookupMap = new HashMap<CharSequence, CharSequence>();\n         int _shortest = Integer.MAX_VALUE;\n         int _longest = 0;\n      * {@inheritDoc}\n      */\n     @Override\n-    public int translate(CharSequence input, int index, Writer out) throws IOException {\n+    public int translate(final CharSequence input, final int index, final Writer out) throws IOException {\n         int max = longest;\n         if (index + longest > input.length()) {\n             max = input.length() - index;\n--- a/src/main/java/org/apache/commons/lang3/text/translate/NumericEntityEscaper.java\n+++ b/src/main/java/org/apache/commons/lang3/text/translate/NumericEntityEscaper.java\n      * @param above int value representing the highest codepoint boundary\n      * @param between whether to escape between the boundaries or outside them\n      */\n-    private NumericEntityEscaper(int below, int above, boolean between) {\n+    private NumericEntityEscaper(final int below, final int above, final boolean between) {\n         this.below = below;\n         this.above = above;\n         this.between = between;\n      * @param codepoint below which to escape\n      * @return the newly created {@code NumericEntityEscaper} instance\n      */\n-    public static NumericEntityEscaper below(int codepoint) {\n+    public static NumericEntityEscaper below(final int codepoint) {\n         return outsideOf(codepoint, Integer.MAX_VALUE);\n     }\n \n      * @param codepoint above which to escape\n      * @return the newly created {@code NumericEntityEscaper} instance\n      */\n-    public static NumericEntityEscaper above(int codepoint) {\n+    public static NumericEntityEscaper above(final int codepoint) {\n         return outsideOf(0, codepoint);\n     }\n \n      * @param codepointHigh below which to escape\n      * @return the newly created {@code NumericEntityEscaper} instance\n      */\n-    public static NumericEntityEscaper between(int codepointLow, int codepointHigh) {\n+    public static NumericEntityEscaper between(final int codepointLow, final int codepointHigh) {\n         return new NumericEntityEscaper(codepointLow, codepointHigh, true);\n     }\n \n      * @param codepointHigh above which to escape\n      * @return the newly created {@code NumericEntityEscaper} instance\n      */\n-    public static NumericEntityEscaper outsideOf(int codepointLow, int codepointHigh) {\n+    public static NumericEntityEscaper outsideOf(final int codepointLow, final int codepointHigh) {\n         return new NumericEntityEscaper(codepointLow, codepointHigh, false);\n     }\n \n      * {@inheritDoc}\n      */\n     @Override\n-    public boolean translate(int codepoint, Writer out) throws IOException {\n+    public boolean translate(final int codepoint, final Writer out) throws IOException {\n         if(between) {\n             if (codepoint < below || codepoint > above) {\n                 return false;\n--- a/src/main/java/org/apache/commons/lang3/text/translate/NumericEntityUnescaper.java\n+++ b/src/main/java/org/apache/commons/lang3/text/translate/NumericEntityUnescaper.java\n      *\n      * @param options to apply to this unescaper\n      */\n-    public NumericEntityUnescaper(OPTION... options) {\n+    public NumericEntityUnescaper(final OPTION... options) {\n         if(options.length > 0) {\n             this.options = EnumSet.copyOf(Arrays.asList(options));\n         } else {\n      * @param option to check state of\n      * @return whether the option is set\n      */\n-    public boolean isSet(OPTION option) { \n+    public boolean isSet(final OPTION option) { \n         return options == null ? false : options.contains(option);\n     }\n \n      * {@inheritDoc}\n      */\n     @Override\n-    public int translate(CharSequence input, int index, Writer out) throws IOException {\n+    public int translate(final CharSequence input, final int index, final Writer out) throws IOException {\n         int seqEnd = input.length();\n         // Uses -2 to ensure there is something after the &#\n         if(input.charAt(index) == '&' && index < seqEnd - 2 && input.charAt(index + 1) == '#') {\n--- a/src/main/java/org/apache/commons/lang3/text/translate/OctalUnescaper.java\n+++ b/src/main/java/org/apache/commons/lang3/text/translate/OctalUnescaper.java\n      * {@inheritDoc}\n      */\n     @Override\n-    public int translate(CharSequence input, int index, Writer out) throws IOException {\n+    public int translate(final CharSequence input, final int index, final Writer out) throws IOException {\n         if(input.charAt(index) == '\\\\' && index < (input.length() - 1) && Character.isDigit(input.charAt(index + 1)) ) {\n             int start = index + 1;\n \n--- a/src/main/java/org/apache/commons/lang3/text/translate/UnicodeEscaper.java\n+++ b/src/main/java/org/apache/commons/lang3/text/translate/UnicodeEscaper.java\n      * @param above int value representing the highest codepoint boundary\n      * @param between whether to escape between the boundaries or outside them\n      */\n-    protected UnicodeEscaper(int below, int above, boolean between) {\n+    protected UnicodeEscaper(final int below, final int above, final boolean between) {\n         this.below = below;\n         this.above = above;\n         this.between = between;\n      * @param codepoint below which to escape\n      * @return the newly created {@code UnicodeEscaper} instance\n      */\n-    public static UnicodeEscaper below(int codepoint) {\n+    public static UnicodeEscaper below(final int codepoint) {\n         return outsideOf(codepoint, Integer.MAX_VALUE);\n     }\n \n      * @param codepoint above which to escape\n      * @return the newly created {@code UnicodeEscaper} instance\n      */\n-    public static UnicodeEscaper above(int codepoint) {\n+    public static UnicodeEscaper above(final int codepoint) {\n         return outsideOf(0, codepoint);\n     }\n \n      * @param codepointHigh above which to escape\n      * @return the newly created {@code UnicodeEscaper} instance\n      */\n-    public static UnicodeEscaper outsideOf(int codepointLow, int codepointHigh) {\n+    public static UnicodeEscaper outsideOf(final int codepointLow, final int codepointHigh) {\n         return new UnicodeEscaper(codepointLow, codepointHigh, false);\n     }\n \n      * @param codepointHigh below which to escape\n      * @return the newly created {@code UnicodeEscaper} instance\n      */\n-    public static UnicodeEscaper between(int codepointLow, int codepointHigh) {\n+    public static UnicodeEscaper between(final int codepointLow, final int codepointHigh) {\n         return new UnicodeEscaper(codepointLow, codepointHigh, true);\n     }\n \n      * {@inheritDoc}\n      */\n     @Override\n-    public boolean translate(int codepoint, Writer out) throws IOException {\n+    public boolean translate(final int codepoint, final Writer out) throws IOException {\n         if (between) {\n             if (codepoint < below || codepoint > above) {\n                 return false;\n         return true;\n     }\n \n-    protected String toUtf16Escape(int codepoint) {\n+    protected String toUtf16Escape(final int codepoint) {\n         return \"\\\\u\" + hex(codepoint);\n     }\n }\n--- a/src/main/java/org/apache/commons/lang3/text/translate/UnicodeUnescaper.java\n+++ b/src/main/java/org/apache/commons/lang3/text/translate/UnicodeUnescaper.java\n      * {@inheritDoc}\n      */\n     @Override\n-    public int translate(CharSequence input, int index, Writer out) throws IOException {\n+    public int translate(final CharSequence input, final int index, final Writer out) throws IOException {\n         if (input.charAt(index) == '\\\\' && index + 1 < input.length() && input.charAt(index + 1) == 'u') {\n             // consume optional additional 'u' chars\n             int i = 2;\n--- a/src/main/java/org/apache/commons/lang3/time/DateFormatUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/time/DateFormatUtils.java\n      * @param pattern  the pattern to use to format the date, not null\n      * @return the formatted date\n      */\n-    public static String formatUTC(long millis, String pattern) {\n+    public static String formatUTC(final long millis, final String pattern) {\n         return format(new Date(millis), pattern, UTC_TIME_ZONE, null);\n     }\n \n      * @param pattern  the pattern to use to format the date, not null\n      * @return the formatted date\n      */\n-    public static String formatUTC(Date date, String pattern) {\n+    public static String formatUTC(final Date date, final String pattern) {\n         return format(date, pattern, UTC_TIME_ZONE, null);\n     }\n     \n      * @param locale  the locale to use, may be <code>null</code>\n      * @return the formatted date\n      */\n-    public static String formatUTC(long millis, String pattern, Locale locale) {\n+    public static String formatUTC(final long millis, final String pattern, final Locale locale) {\n         return format(new Date(millis), pattern, UTC_TIME_ZONE, locale);\n     }\n \n      * @param locale  the locale to use, may be <code>null</code>\n      * @return the formatted date\n      */\n-    public static String formatUTC(Date date, String pattern, Locale locale) {\n+    public static String formatUTC(final Date date, final String pattern, final Locale locale) {\n         return format(date, pattern, UTC_TIME_ZONE, locale);\n     }\n     \n      * @param pattern  the pattern to use to format the date, not null\n      * @return the formatted date\n      */\n-    public static String format(long millis, String pattern) {\n+    public static String format(final long millis, final String pattern) {\n         return format(new Date(millis), pattern, null, null);\n     }\n \n      * @param pattern  the pattern to use to format the date, not null\n      * @return the formatted date\n      */\n-    public static String format(Date date, String pattern) {\n+    public static String format(final Date date, final String pattern) {\n         return format(date, pattern, null, null);\n     }\n \n      * @see FastDateFormat#format(Calendar)\n      * @since 2.4\n      */\n-    public static String format(Calendar calendar, String pattern) {\n+    public static String format(final Calendar calendar, final String pattern) {\n         return format(calendar, pattern, null, null);\n     }\n     \n      * @param timeZone  the time zone  to use, may be <code>null</code>\n      * @return the formatted date\n      */\n-    public static String format(long millis, String pattern, TimeZone timeZone) {\n+    public static String format(final long millis, final String pattern, final TimeZone timeZone) {\n         return format(new Date(millis), pattern, timeZone, null);\n     }\n \n      * @param timeZone  the time zone  to use, may be <code>null</code>\n      * @return the formatted date\n      */\n-    public static String format(Date date, String pattern, TimeZone timeZone) {\n+    public static String format(final Date date, final String pattern, final TimeZone timeZone) {\n         return format(date, pattern, timeZone, null);\n     }\n \n      * @see FastDateFormat#format(Calendar)\n      * @since 2.4\n      */\n-    public static String format(Calendar calendar, String pattern, TimeZone timeZone) {\n+    public static String format(final Calendar calendar, final String pattern, final TimeZone timeZone) {\n         return format(calendar, pattern, timeZone, null);\n     }\n \n      * @param locale  the locale to use, may be <code>null</code>\n      * @return the formatted date\n      */\n-    public static String format(long millis, String pattern, Locale locale) {\n+    public static String format(final long millis, final String pattern, final Locale locale) {\n         return format(new Date(millis), pattern, null, locale);\n     }\n \n      * @param locale  the locale to use, may be <code>null</code>\n      * @return the formatted date\n      */\n-    public static String format(Date date, String pattern, Locale locale) {\n+    public static String format(final Date date, final String pattern, final Locale locale) {\n         return format(date, pattern, null, locale);\n     }\n \n      * @see FastDateFormat#format(Calendar)\n      * @since 2.4\n      */\n-    public static String format(Calendar calendar, String pattern, Locale locale) {\n+    public static String format(final Calendar calendar, final String pattern, final Locale locale) {\n         return format(calendar, pattern, null, locale);\n     }\n \n      * @param locale  the locale to use, may be <code>null</code>\n      * @return the formatted date\n      */\n-    public static String format(long millis, String pattern, TimeZone timeZone, Locale locale) {\n+    public static String format(final long millis, final String pattern, final TimeZone timeZone, final Locale locale) {\n         return format(new Date(millis), pattern, timeZone, locale);\n     }\n \n      * @param locale  the locale to use, may be <code>null</code>\n      * @return the formatted date\n      */\n-    public static String format(Date date, String pattern, TimeZone timeZone, Locale locale) {\n+    public static String format(final Date date, final String pattern, final TimeZone timeZone, final Locale locale) {\n         FastDateFormat df = FastDateFormat.getInstance(pattern, timeZone, locale);\n         return df.format(date);\n     }\n      * @see FastDateFormat#format(Calendar)\n      * @since 2.4\n      */\n-    public static String format(Calendar calendar, String pattern, TimeZone timeZone, Locale locale) {\n+    public static String format(final Calendar calendar, final String pattern, final TimeZone timeZone, final Locale locale) {\n         FastDateFormat df = FastDateFormat.getInstance(pattern, timeZone, locale);\n         return df.format(calendar);\n     }\n--- a/src/main/java/org/apache/commons/lang3/time/DateUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/time/DateUtils.java\n      * @throws IllegalArgumentException if either date is <code>null</code>\n      * @since 2.1\n      */\n-    public static boolean isSameDay(Date date1, Date date2) {\n+    public static boolean isSameDay(final Date date1, final Date date2) {\n         if (date1 == null || date2 == null) {\n             throw new IllegalArgumentException(\"The date must not be null\");\n         }\n      * @throws IllegalArgumentException if either calendar is <code>null</code>\n      * @since 2.1\n      */\n-    public static boolean isSameDay(Calendar cal1, Calendar cal2) {\n+    public static boolean isSameDay(final Calendar cal1, final Calendar cal2) {\n         if (cal1 == null || cal2 == null) {\n             throw new IllegalArgumentException(\"The date must not be null\");\n         }\n      * @throws IllegalArgumentException if either date is <code>null</code>\n      * @since 2.1\n      */\n-    public static boolean isSameInstant(Date date1, Date date2) {\n+    public static boolean isSameInstant(final Date date1, final Date date2) {\n         if (date1 == null || date2 == null) {\n             throw new IllegalArgumentException(\"The date must not be null\");\n         }\n      * @throws IllegalArgumentException if either date is <code>null</code>\n      * @since 2.1\n      */\n-    public static boolean isSameInstant(Calendar cal1, Calendar cal2) {\n+    public static boolean isSameInstant(final Calendar cal1, final Calendar cal2) {\n         if (cal1 == null || cal2 == null) {\n             throw new IllegalArgumentException(\"The date must not be null\");\n         }\n      * @throws IllegalArgumentException if either date is <code>null</code>\n      * @since 2.1\n      */\n-    public static boolean isSameLocalTime(Calendar cal1, Calendar cal2) {\n+    public static boolean isSameLocalTime(final Calendar cal1, final Calendar cal2) {\n         if (cal1 == null || cal2 == null) {\n             throw new IllegalArgumentException(\"The date must not be null\");\n         }\n      * @throws IllegalArgumentException if the date string or pattern array is null\n      * @throws ParseException if none of the date patterns were suitable (or there were none)\n      */\n-    public static Date parseDate(String str, String... parsePatterns) throws ParseException {\n+    public static Date parseDate(final String str, final String... parsePatterns) throws ParseException {\n         return parseDate(str, null, parsePatterns);\n     }\n     \n      * @throws ParseException if none of the date patterns were suitable (or there were none)\n      * @since 3.2\n      */\n-    public static Date parseDate(String str, Locale locale, String... parsePatterns) throws ParseException {\n+    public static Date parseDate(final String str, final Locale locale, final String... parsePatterns) throws ParseException {\n         return parseDateWithLeniency(str, locale, parsePatterns, true);\n     }    \n \n      * @throws ParseException if none of the date patterns were suitable\n      * @since 2.5\n      */\n-    public static Date parseDateStrictly(String str, String... parsePatterns) throws ParseException {\n+    public static Date parseDateStrictly(final String str, final String... parsePatterns) throws ParseException {\n         return parseDateStrictly(str, null, parsePatterns);\n     }\n \n      * @throws ParseException if none of the date patterns were suitable\n      * @since 3.2\n      */\n-    public static Date parseDateStrictly(String str, Locale locale, String... parsePatterns) throws ParseException {\n+    public static Date parseDateStrictly(final String str, final Locale locale, final String... parsePatterns) throws ParseException {\n         return parseDateWithLeniency(str, null, parsePatterns, false);\n     }    \n \n      * @see java.util.Calender#isLenient()\n      */\n     private static Date parseDateWithLeniency(\n-            String str, Locale locale, String[] parsePatterns, boolean lenient) throws ParseException {\n+            final String str, final Locale locale, final String[] parsePatterns, final boolean lenient) throws ParseException {\n         if (str == null || parsePatterns == null) {\n             throw new IllegalArgumentException(\"Date and Patterns must not be null\");\n         }\n      * @return the new {@code Date} with the amount added\n      * @throws IllegalArgumentException if the date is null\n      */\n-    public static Date addYears(Date date, int amount) {\n+    public static Date addYears(final Date date, final int amount) {\n         return add(date, Calendar.YEAR, amount);\n     }\n \n      * @return the new {@code Date} with the amount added\n      * @throws IllegalArgumentException if the date is null\n      */\n-    public static Date addMonths(Date date, int amount) {\n+    public static Date addMonths(final Date date, final int amount) {\n         return add(date, Calendar.MONTH, amount);\n     }\n \n      * @return the new {@code Date} with the amount added\n      * @throws IllegalArgumentException if the date is null\n      */\n-    public static Date addWeeks(Date date, int amount) {\n+    public static Date addWeeks(final Date date, final int amount) {\n         return add(date, Calendar.WEEK_OF_YEAR, amount);\n     }\n \n      * @return the new {@code Date} with the amount added\n      * @throws IllegalArgumentException if the date is null\n      */\n-    public static Date addDays(Date date, int amount) {\n+    public static Date addDays(final Date date, final int amount) {\n         return add(date, Calendar.DAY_OF_MONTH, amount);\n     }\n \n      * @return the new {@code Date} with the amount added\n      * @throws IllegalArgumentException if the date is null\n      */\n-    public static Date addHours(Date date, int amount) {\n+    public static Date addHours(final Date date, final int amount) {\n         return add(date, Calendar.HOUR_OF_DAY, amount);\n     }\n \n      * @return the new {@code Date} with the amount added\n      * @throws IllegalArgumentException if the date is null\n      */\n-    public static Date addMinutes(Date date, int amount) {\n+    public static Date addMinutes(final Date date, final int amount) {\n         return add(date, Calendar.MINUTE, amount);\n     }\n \n      * @return the new {@code Date} with the amount added\n      * @throws IllegalArgumentException if the date is null\n      */\n-    public static Date addSeconds(Date date, int amount) {\n+    public static Date addSeconds(final Date date, final int amount) {\n         return add(date, Calendar.SECOND, amount);\n     }\n \n      * @return the new {@code Date} with the amount added\n      * @throws IllegalArgumentException if the date is null\n      */\n-    public static Date addMilliseconds(Date date, int amount) {\n+    public static Date addMilliseconds(final Date date, final int amount) {\n         return add(date, Calendar.MILLISECOND, amount);\n     }\n \n      * @return the new {@code Date} with the amount added\n      * @throws IllegalArgumentException if the date is null\n      */\n-    private static Date add(Date date, int calendarField, int amount) {\n+    private static Date add(final Date date, final int calendarField, final int amount) {\n         if (date == null) {\n             throw new IllegalArgumentException(\"The date must not be null\");\n         }\n      * @throws IllegalArgumentException if the date is null\n      * @since 2.4\n      */\n-    public static Date setYears(Date date, int amount) {\n+    public static Date setYears(final Date date, final int amount) {\n         return set(date, Calendar.YEAR, amount);\n     }\n \n      * @throws IllegalArgumentException if the date is null\n      * @since 2.4\n      */\n-    public static Date setMonths(Date date, int amount) {\n+    public static Date setMonths(final Date date, final int amount) {\n         return set(date, Calendar.MONTH, amount);\n     }\n \n      * @throws IllegalArgumentException if the date is null\n      * @since 2.4\n      */\n-    public static Date setDays(Date date, int amount) {\n+    public static Date setDays(final Date date, final int amount) {\n         return set(date, Calendar.DAY_OF_MONTH, amount);\n     }\n \n      * @throws IllegalArgumentException if the date is null\n      * @since 2.4\n      */\n-    public static Date setHours(Date date, int amount) {\n+    public static Date setHours(final Date date, final int amount) {\n         return set(date, Calendar.HOUR_OF_DAY, amount);\n     }\n \n      * @throws IllegalArgumentException if the date is null\n      * @since 2.4\n      */\n-    public static Date setMinutes(Date date, int amount) {\n+    public static Date setMinutes(final Date date, final int amount) {\n         return set(date, Calendar.MINUTE, amount);\n     }\n     \n      * @throws IllegalArgumentException if the date is null\n      * @since 2.4\n      */\n-    public static Date setSeconds(Date date, int amount) {\n+    public static Date setSeconds(final Date date, final int amount) {\n         return set(date, Calendar.SECOND, amount);\n     }\n \n      * @throws IllegalArgumentException if the date is null\n      * @since 2.4\n      */\n-    public static Date setMilliseconds(Date date, int amount) {\n+    public static Date setMilliseconds(final Date date, final int amount) {\n         return set(date, Calendar.MILLISECOND, amount);\n     } \n     \n      * @throws IllegalArgumentException if the date is null\n      * @since 2.4\n      */\n-    private static Date set(Date date, int calendarField, int amount) {\n+    private static Date set(final Date date, final int calendarField, final int amount) {\n         if (date == null) {\n             throw new IllegalArgumentException(\"The date must not be null\");\n         }\n      * @throws NullPointerException if null is passed in\n      * @since 3.0\n      */\n-    public static Calendar toCalendar(Date date) {\n+    public static Calendar toCalendar(final Date date) {\n         Calendar c = Calendar.getInstance();\n         c.setTime(date);\n         return c;\n      * @return the different rounded date, not null\n      * @throws ArithmeticException if the year is over 280 million\n      */\n-    public static Date round(Date date, int field) {\n+    public static Date round(final Date date, final int field) {\n         if (date == null) {\n             throw new IllegalArgumentException(\"The date must not be null\");\n         }\n      * @throws IllegalArgumentException if the date is <code>null</code>\n      * @throws ArithmeticException if the year is over 280 million\n      */\n-    public static Calendar round(Calendar date, int field) {\n+    public static Calendar round(final Calendar date, final int field) {\n         if (date == null) {\n             throw new IllegalArgumentException(\"The date must not be null\");\n         }\n      * @throws ClassCastException if the object type is not a {@code Date} or {@code Calendar}\n      * @throws ArithmeticException if the year is over 280 million\n      */\n-    public static Date round(Object date, int field) {\n+    public static Date round(final Object date, final int field) {\n         if (date == null) {\n             throw new IllegalArgumentException(\"The date must not be null\");\n         }\n      * @throws IllegalArgumentException if the date is <code>null</code>\n      * @throws ArithmeticException if the year is over 280 million\n      */\n-    public static Date truncate(Date date, int field) {\n+    public static Date truncate(final Date date, final int field) {\n         if (date == null) {\n             throw new IllegalArgumentException(\"The date must not be null\");\n         }\n      * @throws IllegalArgumentException if the date is <code>null</code>\n      * @throws ArithmeticException if the year is over 280 million\n      */\n-    public static Calendar truncate(Calendar date, int field) {\n+    public static Calendar truncate(final Calendar date, final int field) {\n         if (date == null) {\n             throw new IllegalArgumentException(\"The date must not be null\");\n         }\n      * @throws ClassCastException if the object type is not a {@code Date} or {@code Calendar}\n      * @throws ArithmeticException if the year is over 280 million\n      */\n-    public static Date truncate(Object date, int field) {\n+    public static Date truncate(final Object date, final int field) {\n         if (date == null) {\n             throw new IllegalArgumentException(\"The date must not be null\");\n         }\n      * @throws ArithmeticException if the year is over 280 million\n      * @since 2.5\n      */\n-    public static Date ceiling(Date date, int field) {\n+    public static Date ceiling(final Date date, final int field) {\n         if (date == null) {\n             throw new IllegalArgumentException(\"The date must not be null\");\n         }\n      * @throws ArithmeticException if the year is over 280 million\n      * @since 2.5\n      */\n-    public static Calendar ceiling(Calendar date, int field) {\n+    public static Calendar ceiling(final Calendar date, final int field) {\n         if (date == null) {\n             throw new IllegalArgumentException(\"The date must not be null\");\n         }\n      * @throws ArithmeticException if the year is over 280 million\n      * @since 2.5\n      */\n-    public static Date ceiling(Object date, int field) {\n+    public static Date ceiling(final Object date, final int field) {\n         if (date == null) {\n             throw new IllegalArgumentException(\"The date must not be null\");\n         }\n      * @param modType  type to truncate, round or ceiling\n      * @throws ArithmeticException if the year is over 280 million\n      */\n-    private static void modify(Calendar val, int field, int modType) {\n+    private static void modify(final Calendar val, final int field, final int modType) {\n         if (val.get(Calendar.YEAR) > 280000000) {\n             throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n         }\n      * @throws IllegalArgumentException if the date is <code>null</code>\n      * @throws IllegalArgumentException if the rangeStyle is invalid\n      */\n-    public static Iterator<Calendar> iterator(Date focus, int rangeStyle) {\n+    public static Iterator<Calendar> iterator(final Date focus, final int rangeStyle) {\n         if (focus == null) {\n             throw new IllegalArgumentException(\"The date must not be null\");\n         }\n      * @throws IllegalArgumentException if the date is <code>null</code>\n      * @throws IllegalArgumentException if the rangeStyle is invalid\n      */\n-    public static Iterator<Calendar> iterator(Calendar focus, int rangeStyle) {\n+    public static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle) {\n         if (focus == null) {\n             throw new IllegalArgumentException(\"The date must not be null\");\n         }\n      * @throws IllegalArgumentException if the date is <code>null</code>\n      * @throws ClassCastException if the object type is not a {@code Date} or {@code Calendar}\n      */\n-    public static Iterator<?> iterator(Object focus, int rangeStyle) {\n+    public static Iterator<?> iterator(final Object focus, final int rangeStyle) {\n         if (focus == null) {\n             throw new IllegalArgumentException(\"The date must not be null\");\n         }\n      * fragment is not supported\n      * @since 2.4\n      */\n-    public static long getFragmentInMilliseconds(Date date, int fragment) {\n+    public static long getFragmentInMilliseconds(final Date date, final int fragment) {\n         return getFragment(date, fragment, Calendar.MILLISECOND);    \n     }\n     \n      * fragment is not supported\n      * @since 2.4\n      */\n-    public static long getFragmentInSeconds(Date date, int fragment) {\n+    public static long getFragmentInSeconds(final Date date, final int fragment) {\n         return getFragment(date, fragment, Calendar.SECOND);\n     }\n     \n      * fragment is not supported\n      * @since 2.4\n      */\n-    public static long getFragmentInMinutes(Date date, int fragment) {\n+    public static long getFragmentInMinutes(final Date date, final int fragment) {\n         return getFragment(date, fragment, Calendar.MINUTE);\n     }\n     \n      * fragment is not supported\n      * @since 2.4\n      */\n-    public static long getFragmentInHours(Date date, int fragment) {\n+    public static long getFragmentInHours(final Date date, final int fragment) {\n         return getFragment(date, fragment, Calendar.HOUR_OF_DAY);\n     }\n     \n      * fragment is not supported\n      * @since 2.4\n      */\n-    public static long getFragmentInDays(Date date, int fragment) {\n+    public static long getFragmentInDays(final Date date, final int fragment) {\n         return getFragment(date, fragment, Calendar.DAY_OF_YEAR);\n     }\n \n      * fragment is not supported\n      * @since 2.4\n      */\n-  public static long getFragmentInMilliseconds(Calendar calendar, int fragment) {\n+  public static long getFragmentInMilliseconds(final Calendar calendar, final int fragment) {\n     return getFragment(calendar, fragment, Calendar.MILLISECOND);\n   }\n     /**\n      * fragment is not supported\n      * @since 2.4\n      */\n-    public static long getFragmentInSeconds(Calendar calendar, int fragment) {\n+    public static long getFragmentInSeconds(final Calendar calendar, final int fragment) {\n         return getFragment(calendar, fragment, Calendar.SECOND);\n     }\n     \n      * fragment is not supported\n      * @since 2.4\n      */\n-    public static long getFragmentInMinutes(Calendar calendar, int fragment) {\n+    public static long getFragmentInMinutes(final Calendar calendar, final int fragment) {\n         return getFragment(calendar, fragment, Calendar.MINUTE);\n     }\n     \n      * fragment is not supported\n      * @since 2.4\n      */\n-    public static long getFragmentInHours(Calendar calendar, int fragment) {\n+    public static long getFragmentInHours(final Calendar calendar, final int fragment) {\n         return getFragment(calendar, fragment, Calendar.HOUR_OF_DAY);\n     }\n     \n      * fragment is not supported\n      * @since 2.4\n      */\n-    public static long getFragmentInDays(Calendar calendar, int fragment) {\n+    public static long getFragmentInDays(final Calendar calendar, final int fragment) {\n         return getFragment(calendar, fragment, Calendar.DAY_OF_YEAR);\n     }\n     \n      * fragment is not supported\n      * @since 2.4\n      */\n-    private static long getFragment(Date date, int fragment, int unit) {\n+    private static long getFragment(final Date date, final int fragment, final int unit) {\n         if(date == null) {\n             throw  new IllegalArgumentException(\"The date must not be null\");\n         }\n      * fragment is not supported\n      * @since 2.4\n      */\n-    private static long getFragment(Calendar calendar, int fragment, int unit) {\n+    private static long getFragment(final Calendar calendar, final int fragment, final int unit) {\n         if(calendar == null) {\n             throw  new IllegalArgumentException(\"The date must not be null\"); \n         }\n      * @see #truncatedEquals(Date, Date, int)\n      * @since 3.0\n      */\n-    public static boolean truncatedEquals(Calendar cal1, Calendar cal2, int field) {\n+    public static boolean truncatedEquals(final Calendar cal1, final Calendar cal2, final int field) {\n         return truncatedCompareTo(cal1, cal2, field) == 0;\n     }\n \n      * @see #truncatedEquals(Calendar, Calendar, int)\n      * @since 3.0\n      */\n-    public static boolean truncatedEquals(Date date1, Date date2, int field) {\n+    public static boolean truncatedEquals(final Date date1, final Date date2, final int field) {\n         return truncatedCompareTo(date1, date2, field) == 0;\n     }\n \n      * @see #truncatedCompareTo(Date, Date, int)\n      * @since 3.0\n      */\n-    public static int truncatedCompareTo(Calendar cal1, Calendar cal2, int field) {\n+    public static int truncatedCompareTo(final Calendar cal1, final Calendar cal2, final int field) {\n         Calendar truncatedCal1 = truncate(cal1, field);\n         Calendar truncatedCal2 = truncate(cal2, field);\n         return truncatedCal1.compareTo(truncatedCal2);\n      * @see #truncatedCompareTo(Date, Date, int)\n      * @since 3.0\n      */\n-    public static int truncatedCompareTo(Date date1, Date date2, int field) {\n+    public static int truncatedCompareTo(final Date date1, final Date date2, final int field) {\n         Date truncatedDate1 = truncate(date1, field);\n         Date truncatedDate2 = truncate(date2, field);\n         return truncatedDate1.compareTo(truncatedDate2);\n      * @throws IllegalArgumentException if date can't be represented in milliseconds\n      * @since 2.4 \n      */\n-    private static long getMillisPerUnit(int unit) {\n+    private static long getMillisPerUnit(final int unit) {\n         long result = Long.MAX_VALUE;\n         switch (unit) {\n             case Calendar.DAY_OF_YEAR:\n          * @param startFinal start date (inclusive)\n          * @param endFinal end date (inclusive)\n          */\n-        DateIterator(Calendar startFinal, Calendar endFinal) {\n+        DateIterator(final Calendar startFinal, final Calendar endFinal) {\n             super();\n             this.endFinal = endFinal;\n             spot = startFinal;\n--- a/src/main/java/org/apache/commons/lang3/time/DurationFormatUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/time/DurationFormatUtils.java\n      * @param durationMillis  the duration to format\n      * @return the formatted duration, not null\n      */\n-    public static String formatDurationHMS(long durationMillis) {\n+    public static String formatDurationHMS(final long durationMillis) {\n         return formatDuration(durationMillis, \"H:mm:ss.SSS\");\n     }\n \n      * @param durationMillis  the duration to format\n      * @return the formatted duration, not null\n      */\n-    public static String formatDurationISO(long durationMillis) {\n+    public static String formatDurationISO(final long durationMillis) {\n         return formatDuration(durationMillis, ISO_EXTENDED_FORMAT_PATTERN, false);\n     }\n \n      * @param format  the way in which to format the duration, not null\n      * @return the formatted duration, not null\n      */\n-    public static String formatDuration(long durationMillis, String format) {\n+    public static String formatDuration(final long durationMillis, final String format) {\n         return formatDuration(durationMillis, format, true);\n     }\n \n      * @param padWithZeros  whether to pad the left hand side of numbers with 0's\n      * @return the formatted duration, not null\n      */\n-    public static String formatDuration(long durationMillis, String format, boolean padWithZeros) {\n+    public static String formatDuration(long durationMillis, final String format, final boolean padWithZeros) {\n \n         Token[] tokens = lexx(format);\n \n      * @return the formatted text in days/hours/minutes/seconds, not null\n      */\n     public static String formatDurationWords(\n-        long durationMillis,\n-        boolean suppressLeadingZeroElements,\n-        boolean suppressTrailingZeroElements) {\n+        final long durationMillis,\n+        final boolean suppressLeadingZeroElements,\n+        final boolean suppressTrailingZeroElements) {\n \n         // This method is generally replacable by the format method, but \n         // there are a series of tweaks and special cases that require \n      * @param endMillis  the end of the duration to format\n      * @return the formatted duration, not null\n      */\n-    public static String formatPeriodISO(long startMillis, long endMillis) {\n+    public static String formatPeriodISO(final long startMillis, final long endMillis) {\n         return formatPeriod(startMillis, endMillis, ISO_EXTENDED_FORMAT_PATTERN, false, TimeZone.getDefault());\n     }\n \n      * @param format  the way in which to format the duration, not null\n      * @return the formatted duration, not null\n      */\n-    public static String formatPeriod(long startMillis, long endMillis, String format) {\n+    public static String formatPeriod(final long startMillis, final long endMillis, final String format) {\n         return formatPeriod(startMillis, endMillis, format, true, TimeZone.getDefault());\n     }\n \n      * @param timezone  the millis are defined in\n      * @return the formatted duration, not null\n      */\n-    public static String formatPeriod(long startMillis, long endMillis, String format, boolean padWithZeros, \n-            TimeZone timezone) {\n+    public static String formatPeriod(final long startMillis, final long endMillis, final String format, final boolean padWithZeros, \n+            final TimeZone timezone) {\n \n         // Used to optimise for differences under 28 days and \n         // called formatDuration(millis, format); however this did not work \n      * @param padWithZeros  whether to pad\n      * @return the formatted string\n      */\n-    static String format(Token[] tokens, int years, int months, int days, int hours, int minutes, int seconds,\n-            int milliseconds, boolean padWithZeros) {\n+    static String format(final Token[] tokens, final int years, final int months, final int days, final int hours, final int minutes, final int seconds,\n+            int milliseconds, final boolean padWithZeros) {\n         StringBuilder buffer = new StringBuilder();\n         boolean lastOutputSeconds = false;\n         int sz = tokens.length;\n      * @param format  the format to parse, not null\n      * @return array of Token[]\n      */\n-    static Token[] lexx(String format) {\n+    static Token[] lexx(final String format) {\n         char[] array = format.toCharArray();\n         ArrayList<Token> list = new ArrayList<Token>(array.length);\n \n          * @param value to look for\n          * @return boolean <code>true</code> if contained\n          */\n-        static boolean containsTokenWithValue(Token[] tokens, Object value) {\n+        static boolean containsTokenWithValue(final Token[] tokens, final Object value) {\n             int sz = tokens.length;\n             for (int i = 0; i < sz; i++) {\n                 if (tokens[i].getValue() == value) {\n          *\n          * @param value to wrap\n          */\n-        Token(Object value) {\n+        Token(final Object value) {\n             this.value = value;\n             this.count = 1;\n         }\n          * @param value to wrap\n          * @param count to wrap\n          */\n-        Token(Object value, int count) {\n+        Token(final Object value, final int count) {\n             this.value = value;\n             this.count = count;\n         }\n          * @return boolean <code>true</code> if equal\n          */\n         @Override\n-        public boolean equals(Object obj2) {\n+        public boolean equals(final Object obj2) {\n             if (obj2 instanceof Token) {\n                 Token tok2 = (Token) obj2;\n                 if (this.value.getClass() != tok2.value.getClass()) {\n--- a/src/main/java/org/apache/commons/lang3/time/FastDateFormat.java\n+++ b/src/main/java/org/apache/commons/lang3/time/FastDateFormat.java\n \n     private static final FormatCache<FastDateFormat> cache= new FormatCache<FastDateFormat>() {\n         @Override\n-        protected FastDateFormat createInstance(String pattern, TimeZone timeZone, Locale locale) {\n+        protected FastDateFormat createInstance(final String pattern, final TimeZone timeZone, final Locale locale) {\n             return new FastDateFormat(pattern, timeZone, locale);\n         }\n     };\n      * @return a pattern based date/time formatter\n      * @throws IllegalArgumentException if pattern is invalid\n      */\n-    public static FastDateFormat getInstance(String pattern) {\n+    public static FastDateFormat getInstance(final String pattern) {\n         return cache.getInstance(pattern, null, null);\n     }\n \n      * @return a pattern based date/time formatter\n      * @throws IllegalArgumentException if pattern is invalid\n      */\n-    public static FastDateFormat getInstance(String pattern, TimeZone timeZone) {\n+    public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone) {\n         return cache.getInstance(pattern, timeZone, null);\n     }\n \n      * @return a pattern based date/time formatter\n      * @throws IllegalArgumentException if pattern is invalid\n      */\n-    public static FastDateFormat getInstance(String pattern, Locale locale) {\n+    public static FastDateFormat getInstance(final String pattern, final Locale locale) {\n         return cache.getInstance(pattern, null, locale);\n     }\n \n      * @throws IllegalArgumentException if pattern is invalid\n      *  or {@code null}\n      */\n-    public static FastDateFormat getInstance(String pattern, TimeZone timeZone, Locale locale) {\n+    public static FastDateFormat getInstance(final String pattern, final TimeZone timeZone, final Locale locale) {\n         return cache.getInstance(pattern, timeZone, locale);\n     }\n \n      *  pattern defined\n      * @since 2.1\n      */\n-    public static FastDateFormat getDateInstance(int style) {\n+    public static FastDateFormat getDateInstance(final int style) {\n         return cache.getDateTimeInstance(style, null, null, null);\n     }\n \n      *  pattern defined\n      * @since 2.1\n      */\n-    public static FastDateFormat getDateInstance(int style, Locale locale) {\n+    public static FastDateFormat getDateInstance(final int style, final Locale locale) {\n         return cache.getDateTimeInstance(style, null, null, locale);\n     }\n \n      *  pattern defined\n      * @since 2.1\n      */\n-    public static FastDateFormat getDateInstance(int style, TimeZone timeZone) {\n+    public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone) {\n         return cache.getDateTimeInstance(style, null, timeZone, null);\n     }\n     \n      * @throws IllegalArgumentException if the Locale has no date\n      *  pattern defined\n      */\n-    public static FastDateFormat getDateInstance(int style, TimeZone timeZone, Locale locale) {\n+    public static FastDateFormat getDateInstance(final int style, final TimeZone timeZone, final Locale locale) {\n         return cache.getDateTimeInstance(style, null, timeZone, locale);\n     }\n \n      *  pattern defined\n      * @since 2.1\n      */\n-    public static FastDateFormat getTimeInstance(int style) {\n+    public static FastDateFormat getTimeInstance(final int style) {\n         return cache.getDateTimeInstance(null, style, null, null);\n     }\n \n      *  pattern defined\n      * @since 2.1\n      */\n-    public static FastDateFormat getTimeInstance(int style, Locale locale) {\n+    public static FastDateFormat getTimeInstance(final int style, final Locale locale) {\n         return cache.getDateTimeInstance(null, style, null, locale);\n     }\n \n      *  pattern defined\n      * @since 2.1\n      */\n-    public static FastDateFormat getTimeInstance(int style, TimeZone timeZone) {\n+    public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone) {\n         return cache.getDateTimeInstance(null, style, timeZone, null);\n     }\n \n      * @throws IllegalArgumentException if the Locale has no time\n      *  pattern defined\n      */\n-    public static FastDateFormat getTimeInstance(int style, TimeZone timeZone, Locale locale) {\n+    public static FastDateFormat getTimeInstance(final int style, final TimeZone timeZone, final Locale locale) {\n         return cache.getDateTimeInstance(null, style, timeZone, locale);\n     }\n \n      *  pattern defined\n      * @since 2.1\n      */\n-    public static FastDateFormat getDateTimeInstance(int dateStyle, int timeStyle) {\n+    public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle) {\n         return cache.getDateTimeInstance(dateStyle, timeStyle, null, null);\n     }\n \n      *  pattern defined\n      * @since 2.1\n      */\n-    public static FastDateFormat getDateTimeInstance(int dateStyle, int timeStyle, Locale locale) {\n+    public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final Locale locale) {\n         return cache.getDateTimeInstance(dateStyle, timeStyle, null, locale);\n     }\n \n      *  pattern defined\n      * @since 2.1\n      */\n-    public static FastDateFormat getDateTimeInstance(int dateStyle, int timeStyle, TimeZone timeZone) {\n+    public static FastDateFormat getDateTimeInstance(final int dateStyle, final int timeStyle, final TimeZone timeZone) {\n         return getDateTimeInstance(dateStyle, timeStyle, timeZone, null);\n     }\n     /**\n      *  pattern defined\n      */\n     public static FastDateFormat getDateTimeInstance(\n-            int dateStyle, int timeStyle, TimeZone timeZone, Locale locale) {\n+            final int dateStyle, final int timeStyle, final TimeZone timeZone, final Locale locale) {\n         return cache.getDateTimeInstance(dateStyle, timeStyle, timeZone, locale);\n     }\n \n      * @param locale  non-null locale to use\n      * @throws NullPointerException if pattern, timeZone, or locale is null.\n      */\n-    protected FastDateFormat(String pattern, TimeZone timeZone, Locale locale) {\n+    protected FastDateFormat(final String pattern, final TimeZone timeZone, final Locale locale) {\n         printer= new FastDatePrinter(pattern, timeZone, locale);\n         parser= new FastDateParser(pattern, timeZone, locale);\n     }\n      * @return the buffer passed in\n      */\n     @Override\n-    public StringBuffer format(Object obj, StringBuffer toAppendTo, FieldPosition pos) {\n+    public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos) {\n         return printer.format(obj, toAppendTo, pos);\n     }\n \n      * @since 2.1\n      */\n     @Override\n-    public String format(long millis) {\n+    public String format(final long millis) {\n         return printer.format(millis);\n     }\n \n      * @return the formatted string\n      */\n     @Override\n-    public String format(Date date) {\n+    public String format(final Date date) {\n         return printer.format(date);\n     }\n \n      * @return the formatted string\n      */\n     @Override\n-    public String format(Calendar calendar) {\n+    public String format(final Calendar calendar) {\n         return printer.format(calendar);\n     }\n \n      * @since 2.1\n      */\n     @Override\n-    public StringBuffer format(long millis, StringBuffer buf) {\n+    public StringBuffer format(final long millis, final StringBuffer buf) {\n         return printer.format(millis, buf);\n     }\n \n      * @return the specified string buffer\n      */\n     @Override\n-    public StringBuffer format(Date date, StringBuffer buf) {\n+    public StringBuffer format(final Date date, final StringBuffer buf) {\n         return printer.format(date, buf);\n     }\n \n      * @return the specified string buffer\n      */\n     @Override\n-    public StringBuffer format(Calendar calendar, StringBuffer buf) {\n+    public StringBuffer format(final Calendar calendar, final StringBuffer buf) {\n         return printer.format(calendar, buf);\n     }\n \n      * @see DateParser#parse(java.lang.String)\n      */\n     @Override\n-    public Date parse(String source) throws ParseException {\n+    public Date parse(final String source) throws ParseException {\n         return parser.parse(source);\n     }\n \n      * @see DateParser#parse(java.lang.String, java.text.ParsePosition)\n      */\n     @Override\n-    public Date parse(String source, ParsePosition pos) {\n+    public Date parse(final String source, final ParsePosition pos) {\n             return parser.parse(source, pos);\n     }\n \n      * @see java.text.Format#parseObject(java.lang.String, java.text.ParsePosition)\n      */\n     @Override\n-    public Object parseObject(String source, ParsePosition pos) {\n+    public Object parseObject(final String source, final ParsePosition pos) {\n         return parser.parseObject(source, pos);\n     }\n \n      * @return {@code true} if equal\n      */\n     @Override\n-    public boolean equals(Object obj) {\n+    public boolean equals(final Object obj) {\n         if (obj instanceof FastDateFormat == false) {\n             return false;\n         }\n      * @param buf  the buffer to format into\n      * @return the specified string buffer\n      */\n-    protected StringBuffer applyRules(Calendar calendar, StringBuffer buf) {\n+    protected StringBuffer applyRules(final Calendar calendar, final StringBuffer buf) {\n         return printer.applyRules(calendar, buf);\n     }\n \n--- a/src/main/java/org/apache/commons/lang3/time/FastDateParser.java\n+++ b/src/main/java/org/apache/commons/lang3/time/FastDateParser.java\n      * @param timeZone non-null time zone to use\n      * @param locale non-null locale\n      */\n-    protected FastDateParser(String pattern, TimeZone timeZone, Locale locale) {\n+    protected FastDateParser(final String pattern, final TimeZone timeZone, final Locale locale) {\n         this.pattern = pattern;\n         this.timeZone = timeZone;\n         this.locale = locale;\n      * @return <code>true</code>if equal to this instance\n      */\n     @Override\n-    public boolean equals(Object obj) {\n+    public boolean equals(final Object obj) {\n         if (! (obj instanceof FastDateParser) ) {\n             return false;\n         }\n      * @throws IOException if there is an IO issue.\n      * @throws ClassNotFoundException if a class cannot be found.\n      */\n-    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n+    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n         in.defaultReadObject();\n         init();\n     }\n      * @see org.apache.commons.lang3.time.DateParser#parseObject(java.lang.String)\n      */\n     @Override\n-    public Object parseObject(String source) throws ParseException {\n+    public Object parseObject(final String source) throws ParseException {\n         return parse(source);\n     }\n \n      * @see org.apache.commons.lang3.time.DateParser#parse(java.lang.String)\n      */\n     @Override\n-    public Date parse(String source) throws ParseException {\n+    public Date parse(final String source) throws ParseException {\n         Date date= parse(source, new ParsePosition(0));\n         if(date==null) {\n             // Add a note re supported date range\n      * @see org.apache.commons.lang3.time.DateParser#parseObject(java.lang.String, java.text.ParsePosition)\n      */\n     @Override\n-    public Object parseObject(String source, ParsePosition pos) {\n+    public Object parseObject(final String source, final ParsePosition pos) {\n         return parse(source, pos);\n     }\n \n      * @see org.apache.commons.lang3.time.DateParser#parse(java.lang.String, java.text.ParsePosition)\n      */\n     @Override\n-    public Date parse(String source, ParsePosition pos) {\n+    public Date parse(final String source, final ParsePosition pos) {\n         int offset= pos.getIndex();\n         Matcher matcher= parsePattern.matcher(source.substring(offset));\n         if(!matcher.lookingAt()) {\n      * @param unquote If true, replace two success quotes ('') with single quote (')\n      * @return The <code>StringBuilder</code>\n      */\n-    private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) {\n+    private static StringBuilder escapeRegex(final StringBuilder regex, final String value, final boolean unquote) {\n         regex.append(\"\\\\Q\");\n         for(int i= 0; i<value.length(); ++i) {\n             char c= value.charAt(i);\n      * @param locale The locale of display names\n      * @return A Map of the field key / value pairs\n      */\n-    private static Map<String, Integer> getDisplayNames(int field, Calendar definingCalendar, Locale locale) {\n+    private static Map<String, Integer> getDisplayNames(final int field, final Calendar definingCalendar, final Locale locale) {\n         return definingCalendar.getDisplayNames(field, Calendar.ALL_STYLES, locale);\n     }\n \n      * @param twoDigitYear The year to adjust\n      * @return A value within -80 and +20 years from instantiation of this instance\n      */\n-    int adjustYear(int twoDigitYear) {\n+    int adjustYear(final int twoDigitYear) {\n         int trial= twoDigitYear + thisYear - thisYear%100;\n         if(trial < thisYear+20) {\n             return trial;\n          * @param cal The <code>Calendar</code> to set\n          * @param value The parsed field to translate and set in cal\n          */\n-        void setCalendar(FastDateParser parser, Calendar cal, String value) {\n+        void setCalendar(final FastDateParser parser, final Calendar cal, final String value) {\n             \n         }\n         /**\n      * @param definingCalendar The calendar to obtain the short and long values\n      * @return The Strategy that will handle parsing for the field\n      */\n-    private Strategy getStrategy(String formatField, Calendar definingCalendar) {\n+    private Strategy getStrategy(String formatField, final Calendar definingCalendar) {\n         switch(formatField.charAt(0)) {\n         case '\\'':\n             if(formatField.length()>2) {\n      * @param field The Calendar field\n      * @return a cache of Locale to Strategy\n      */\n-    private static ConcurrentMap<Locale, Strategy> getCache(int field) {\n+    private static ConcurrentMap<Locale, Strategy> getCache(final int field) {\n         synchronized(caches) {\n             if(caches[field]==null) {\n                 caches[field]= new ConcurrentHashMap<Locale,Strategy>(3);\n      * @param definingCalendar The calendar to obtain the short and long values\n      * @return a TextStrategy for the field and Locale\n      */\n-    private Strategy getLocaleSpecificStrategy(int field, Calendar definingCalendar) {\n+    private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar) {\n         ConcurrentMap<Locale,Strategy> cache = getCache(field);\n         Strategy strategy= cache.get(Integer.valueOf(field));\n         if(strategy==null) {\n          * Construct a Strategy that ensures the formatField has literal text\n          * @param formatField The literal text to match\n          */\n-        CopyQuotedStrategy(String formatField) {\n+        CopyQuotedStrategy(final String formatField) {\n             this.formatField= formatField;\n         }\n \n          * {@inheritDoc}\n          */\n         @Override\n-        boolean addRegex(FastDateParser parser, StringBuilder regex) {\n+        boolean addRegex(final FastDateParser parser, final StringBuilder regex) {\n             escapeRegex(regex, formatField, true);\n             return false;\n         }\n          * Construct a Strategy that parses a Text field\n          * @param field The Calendar field\n          */\n-        TextStrategy(int field, Calendar definingCalendar, Locale locale) {\n+        TextStrategy(final int field, final Calendar definingCalendar, final Locale locale) {\n             this.field= field;\n             this.keyValues= getDisplayNames(field, definingCalendar, locale);\n         }\n          * {@inheritDoc}\n          */\n         @Override\n-        boolean addRegex(FastDateParser parser, StringBuilder regex) {\n+        boolean addRegex(final FastDateParser parser, final StringBuilder regex) {\n             regex.append('(');\n             for(String textKeyValue : keyValues.keySet()) {\n                 escapeRegex(regex, textKeyValue, false).append('|');\n          * {@inheritDoc}\n          */\n         @Override\n-        void setCalendar(FastDateParser parser, Calendar cal, String value) {\n+        void setCalendar(final FastDateParser parser, final Calendar cal, final String value) {\n             Integer iVal = keyValues.get(value);\n             if(iVal == null) {\n                 StringBuilder sb= new StringBuilder(value);\n          * Construct a Strategy that parses a Number field\n          * @param field The Calendar field\n          */\n-        NumberStrategy(int field) {\n+        NumberStrategy(final int field) {\n              this.field= field;\n         }\n \n          * {@inheritDoc}\n          */\n         @Override\n-        boolean addRegex(FastDateParser parser, StringBuilder regex) {\n+        boolean addRegex(final FastDateParser parser, final StringBuilder regex) {\n             if(parser.isNextNumber()) {\n                 regex.append(\"(\\\\p{IsNd}{\").append(parser.getFieldWidth()).append(\"}+)\");\n             }\n          * {@inheritDoc}\n          */\n         @Override\n-        void setCalendar(FastDateParser parser, Calendar cal, String value) {\n+        void setCalendar(final FastDateParser parser, final Calendar cal, final String value) {\n             cal.set(field, modify(Integer.parseInt(value)));\n         }\n \n          * @param iValue The parsed integer\n          * @return The modified value\n          */\n-        int modify(int iValue) {\n+        int modify(final int iValue) {\n             return iValue;\n         }\n     }\n          * {@inheritDoc}\n          */\n         @Override\n-        void setCalendar(FastDateParser parser, Calendar cal, String value) {\n+        void setCalendar(final FastDateParser parser, final Calendar cal, final String value) {\n             int iValue= Integer.parseInt(value);\n             if(iValue<100) {\n                 iValue= parser.adjustYear(iValue);\n          * Construct a Strategy that parses a TimeZone\n          * @param locale The Locale\n          */\n-        TimeZoneStrategy(Locale locale) {\n+        TimeZoneStrategy(final Locale locale) {\n             for(String id : TimeZone.getAvailableIDs()) {\n                 if(id.startsWith(\"GMT\")) {\n                     continue;\n          * {@inheritDoc}\n          */\n         @Override\n-        boolean addRegex(FastDateParser parser, StringBuilder regex) {\n+        boolean addRegex(final FastDateParser parser, final StringBuilder regex) {\n             regex.append(validTimeZoneChars);\n             return true;\n         }\n          * {@inheritDoc}\n          */\n         @Override\n-        void setCalendar(FastDateParser parser, Calendar cal, String value) {\n+        void setCalendar(final FastDateParser parser, final Calendar cal, final String value) {\n             TimeZone tz;\n             if(value.charAt(0)=='+' || value.charAt(0)=='-') {\n                 tz= TimeZone.getTimeZone(\"GMT\"+value);\n \n     private static final Strategy NUMBER_MONTH_STRATEGY = new NumberStrategy(Calendar.MONTH) {\n         @Override\n-        int modify(int iValue) {\n+        int modify(final int iValue) {\n             return iValue-1;\n         }\n     };\n     private static final Strategy HOUR_OF_DAY_STRATEGY = new NumberStrategy(Calendar.HOUR_OF_DAY);\n     private static final Strategy MODULO_HOUR_OF_DAY_STRATEGY = new NumberStrategy(Calendar.HOUR_OF_DAY) {\n         @Override\n-        int modify(int iValue) {\n+        int modify(final int iValue) {\n             return iValue%24;\n         }\n     };\n     private static final Strategy MODULO_HOUR_STRATEGY = new NumberStrategy(Calendar.HOUR) {\n         @Override\n-        int modify(int iValue) {\n+        int modify(final int iValue) {\n             return iValue%12;\n         }\n     };\n--- a/src/main/java/org/apache/commons/lang3/time/FastDatePrinter.java\n+++ b/src/main/java/org/apache/commons/lang3/time/FastDatePrinter.java\n      * @param locale  non-null locale to use\n      * @throws NullPointerException if pattern, timeZone, or locale is null.\n      */\n-    protected FastDatePrinter(String pattern, TimeZone timeZone, Locale locale) {\n+    protected FastDatePrinter(final String pattern, final TimeZone timeZone, final Locale locale) {\n         mPattern = pattern;\n         mTimeZone = timeZone;\n         mLocale = locale;\n      * @param indexRef  index references\n      * @return parsed token\n      */\n-    protected String parseToken(String pattern, int[] indexRef) {\n+    protected String parseToken(final String pattern, final int[] indexRef) {\n         StringBuilder buf = new StringBuilder();\n \n         int i = indexRef[0];\n      * @param padding  the padding required\n      * @return a new rule with the correct padding\n      */\n-    protected NumberRule selectNumberRule(int field, int padding) {\n+    protected NumberRule selectNumberRule(final int field, final int padding) {\n         switch (padding) {\n         case 1:\n             return new UnpaddedNumberField(field);\n      * @return the buffer passed in\n      */\n     @Override\n-    public StringBuffer format(Object obj, StringBuffer toAppendTo, FieldPosition pos) {\n+    public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos) {\n         if (obj instanceof Date) {\n             return format((Date) obj, toAppendTo);\n         } else if (obj instanceof Calendar) {\n      * @see org.apache.commons.lang3.time.DatePrinter#format(long)\n      */\n     @Override\n-    public String format(long millis) {\n+    public String format(final long millis) {\n         Calendar c = newCalendar();  // hard code GregorianCalendar\n         c.setTimeInMillis(millis);\n         return applyRulesToString(c);\n     }\n \n-    private String applyRulesToString(Calendar c) {\n+    private String applyRulesToString(final Calendar c) {\n         return applyRules(c, new StringBuffer(mMaxLengthEstimate)).toString();\n     }\n \n      * @see org.apache.commons.lang3.time.DatePrinter#format(java.util.Date)\n      */\n     @Override\n-    public String format(Date date) {\n+    public String format(final Date date) {\n         Calendar c = newCalendar();  // hard code GregorianCalendar\n         c.setTime(date);\n         return applyRulesToString(c);\n      * @see org.apache.commons.lang3.time.DatePrinter#format(java.util.Calendar)\n      */\n     @Override\n-    public String format(Calendar calendar) {\n+    public String format(final Calendar calendar) {\n         return format(calendar, new StringBuffer(mMaxLengthEstimate)).toString();\n     }\n \n      * @see org.apache.commons.lang3.time.DatePrinter#format(long, java.lang.StringBuffer)\n      */\n     @Override\n-    public StringBuffer format(long millis, StringBuffer buf) {\n+    public StringBuffer format(final long millis, final StringBuffer buf) {\n         return format(new Date(millis), buf);\n     }\n \n      * @see org.apache.commons.lang3.time.DatePrinter#format(java.util.Date, java.lang.StringBuffer)\n      */\n     @Override\n-    public StringBuffer format(Date date, StringBuffer buf) {\n+    public StringBuffer format(final Date date, final StringBuffer buf) {\n         Calendar c = newCalendar();  // hard code GregorianCalendar\n         c.setTime(date);\n         return applyRules(c, buf);\n      * @see org.apache.commons.lang3.time.DatePrinter#format(java.util.Calendar, java.lang.StringBuffer)\n      */\n     @Override\n-    public StringBuffer format(Calendar calendar, StringBuffer buf) {\n+    public StringBuffer format(final Calendar calendar, final StringBuffer buf) {\n         return applyRules(calendar, buf);\n     }\n \n      * @param buf  the buffer to format into\n      * @return the specified string buffer\n      */\n-    protected StringBuffer applyRules(Calendar calendar, StringBuffer buf) {\n+    protected StringBuffer applyRules(final Calendar calendar, final StringBuffer buf) {\n         for (Rule rule : mRules) {\n             rule.appendTo(buf, calendar);\n         }\n      * @return {@code true} if equal\n      */\n     @Override\n-    public boolean equals(Object obj) {\n+    public boolean equals(final Object obj) {\n         if (obj instanceof FastDatePrinter == false) {\n             return false;\n         }\n      * @throws IOException if there is an IO issue.\n      * @throws ClassNotFoundException if a class cannot be found.\n      */\n-    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n+    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n         in.defaultReadObject();\n         init();\n     }\n          *\n          * @param value the character literal\n          */\n-        CharacterLiteral(char value) {\n+        CharacterLiteral(final char value) {\n             mValue = value;\n         }\n \n          * {@inheritDoc}\n          */\n         @Override\n-        public void appendTo(StringBuffer buffer, Calendar calendar) {\n+        public void appendTo(final StringBuffer buffer, final Calendar calendar) {\n             buffer.append(mValue);\n         }\n     }\n          *\n          * @param value the string literal\n          */\n-        StringLiteral(String value) {\n+        StringLiteral(final String value) {\n             mValue = value;\n         }\n \n          * {@inheritDoc}\n          */\n         @Override\n-        public void appendTo(StringBuffer buffer, Calendar calendar) {\n+        public void appendTo(final StringBuffer buffer, final Calendar calendar) {\n             buffer.append(mValue);\n         }\n     }\n          * @param field the field\n          * @param values the field values\n          */\n-        TextField(int field, String[] values) {\n+        TextField(final int field, final String[] values) {\n             mField = field;\n             mValues = values;\n         }\n          * {@inheritDoc}\n          */\n         @Override\n-        public void appendTo(StringBuffer buffer, Calendar calendar) {\n+        public void appendTo(final StringBuffer buffer, final Calendar calendar) {\n             buffer.append(mValues[calendar.get(mField)]);\n         }\n     }\n          *\n          * @param field the field\n          */\n-        UnpaddedNumberField(int field) {\n+        UnpaddedNumberField(final int field) {\n             mField = field;\n         }\n \n          * {@inheritDoc}\n          */\n         @Override\n-        public void appendTo(StringBuffer buffer, Calendar calendar) {\n+        public void appendTo(final StringBuffer buffer, final Calendar calendar) {\n             appendTo(buffer, calendar.get(mField));\n         }\n \n          * {@inheritDoc}\n          */\n         @Override\n-        public final void appendTo(StringBuffer buffer, int value) {\n+        public final void appendTo(final StringBuffer buffer, final int value) {\n             if (value < 10) {\n                 buffer.append((char)(value + '0'));\n             } else if (value < 100) {\n          * {@inheritDoc}\n          */\n         @Override\n-        public void appendTo(StringBuffer buffer, Calendar calendar) {\n+        public void appendTo(final StringBuffer buffer, final Calendar calendar) {\n             appendTo(buffer, calendar.get(Calendar.MONTH) + 1);\n         }\n \n          * {@inheritDoc}\n          */\n         @Override\n-        public final void appendTo(StringBuffer buffer, int value) {\n+        public final void appendTo(final StringBuffer buffer, final int value) {\n             if (value < 10) {\n                 buffer.append((char)(value + '0'));\n             } else {\n          * @param field the field\n          * @param size size of the output field\n          */\n-        PaddedNumberField(int field, int size) {\n+        PaddedNumberField(final int field, final int size) {\n             if (size < 3) {\n                 // Should use UnpaddedNumberField or TwoDigitNumberField.\n                 throw new IllegalArgumentException();\n          * {@inheritDoc}\n          */\n         @Override\n-        public void appendTo(StringBuffer buffer, Calendar calendar) {\n+        public void appendTo(final StringBuffer buffer, final Calendar calendar) {\n             appendTo(buffer, calendar.get(mField));\n         }\n \n          * {@inheritDoc}\n          */\n         @Override\n-        public final void appendTo(StringBuffer buffer, int value) {\n+        public final void appendTo(final StringBuffer buffer, final int value) {\n             if (value < 100) {\n                 for (int i = mSize; --i >= 2; ) {\n                     buffer.append('0');\n          *\n          * @param field the field\n          */\n-        TwoDigitNumberField(int field) {\n+        TwoDigitNumberField(final int field) {\n             mField = field;\n         }\n \n          * {@inheritDoc}\n          */\n         @Override\n-        public void appendTo(StringBuffer buffer, Calendar calendar) {\n+        public void appendTo(final StringBuffer buffer, final Calendar calendar) {\n             appendTo(buffer, calendar.get(mField));\n         }\n \n          * {@inheritDoc}\n          */\n         @Override\n-        public final void appendTo(StringBuffer buffer, int value) {\n+        public final void appendTo(final StringBuffer buffer, final int value) {\n             if (value < 100) {\n                 buffer.append((char)(value / 10 + '0'));\n                 buffer.append((char)(value % 10 + '0'));\n          * {@inheritDoc}\n          */\n         @Override\n-        public void appendTo(StringBuffer buffer, Calendar calendar) {\n+        public void appendTo(final StringBuffer buffer, final Calendar calendar) {\n             appendTo(buffer, calendar.get(Calendar.YEAR) % 100);\n         }\n \n          * {@inheritDoc}\n          */\n         @Override\n-        public final void appendTo(StringBuffer buffer, int value) {\n+        public final void appendTo(final StringBuffer buffer, final int value) {\n             buffer.append((char)(value / 10 + '0'));\n             buffer.append((char)(value % 10 + '0'));\n         }\n          * {@inheritDoc}\n          */\n         @Override\n-        public void appendTo(StringBuffer buffer, Calendar calendar) {\n+        public void appendTo(final StringBuffer buffer, final Calendar calendar) {\n             appendTo(buffer, calendar.get(Calendar.MONTH) + 1);\n         }\n \n          * {@inheritDoc}\n          */\n         @Override\n-        public final void appendTo(StringBuffer buffer, int value) {\n+        public final void appendTo(final StringBuffer buffer, final int value) {\n             buffer.append((char)(value / 10 + '0'));\n             buffer.append((char)(value % 10 + '0'));\n         }\n          *\n          * @param rule the rule\n          */\n-        TwelveHourField(NumberRule rule) {\n+        TwelveHourField(final NumberRule rule) {\n             mRule = rule;\n         }\n \n          * {@inheritDoc}\n          */\n         @Override\n-        public void appendTo(StringBuffer buffer, Calendar calendar) {\n+        public void appendTo(final StringBuffer buffer, final Calendar calendar) {\n             int value = calendar.get(Calendar.HOUR);\n             if (value == 0) {\n                 value = calendar.getLeastMaximum(Calendar.HOUR) + 1;\n          * {@inheritDoc}\n          */\n         @Override\n-        public void appendTo(StringBuffer buffer, int value) {\n+        public void appendTo(final StringBuffer buffer, final int value) {\n             mRule.appendTo(buffer, value);\n         }\n     }\n          *\n          * @param rule the rule\n          */\n-        TwentyFourHourField(NumberRule rule) {\n+        TwentyFourHourField(final NumberRule rule) {\n             mRule = rule;\n         }\n \n          * {@inheritDoc}\n          */\n         @Override\n-        public void appendTo(StringBuffer buffer, Calendar calendar) {\n+        public void appendTo(final StringBuffer buffer, final Calendar calendar) {\n             int value = calendar.get(Calendar.HOUR_OF_DAY);\n             if (value == 0) {\n                 value = calendar.getMaximum(Calendar.HOUR_OF_DAY) + 1;\n          * {@inheritDoc}\n          */\n         @Override\n-        public void appendTo(StringBuffer buffer, int value) {\n+        public void appendTo(final StringBuffer buffer, final int value) {\n             mRule.appendTo(buffer, value);\n         }\n     }\n      * @param locale  the locale to use\n      * @return the textual name of the time zone\n      */\n-    static String getTimeZoneDisplay(TimeZone tz, boolean daylight, int style, Locale locale) {\n+    static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale) {\n         TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n         String value = cTimeZoneDisplayCache.get(key);\n         if (value == null) {\n          * @param locale the locale\n          * @param style the style\n          */\n-        TimeZoneNameRule(TimeZone timeZone, Locale locale, int style) {\n+        TimeZoneNameRule(final TimeZone timeZone, final Locale locale, final int style) {\n             mLocale = locale;\n             mStyle = style;\n             \n          * {@inheritDoc}\n          */\n         @Override\n-        public void appendTo(StringBuffer buffer, Calendar calendar) {\n+        public void appendTo(final StringBuffer buffer, final Calendar calendar) {\n             TimeZone zone = calendar.getTimeZone();\n             if (zone.useDaylightTime()\n                     && calendar.get(Calendar.DST_OFFSET) != 0) {\n          *\n          * @param colon add colon between HH and MM in the output if {@code true}\n          */\n-        TimeZoneNumberRule(boolean colon) {\n+        TimeZoneNumberRule(final boolean colon) {\n             mColon = colon;\n         }\n \n          * {@inheritDoc}\n          */\n         @Override\n-        public void appendTo(StringBuffer buffer, Calendar calendar) {\n+        public void appendTo(final StringBuffer buffer, final Calendar calendar) {\n             int offset = calendar.get(Calendar.ZONE_OFFSET) + calendar.get(Calendar.DST_OFFSET);\n \n             if (offset < 0) {\n          * @param style the timezone style\n          * @param locale the timezone locale\n          */\n-        TimeZoneDisplayKey(TimeZone timeZone,\n-                           boolean daylight, int style, Locale locale) {\n+        TimeZoneDisplayKey(final TimeZone timeZone,\n+                           final boolean daylight, int style, final Locale locale) {\n             mTimeZone = timeZone;\n             if (daylight) {\n                 style |= 0x80000000;\n          * {@inheritDoc}\n          */\n         @Override\n-        public boolean equals(Object obj) {\n+        public boolean equals(final Object obj) {\n             if (this == obj) {\n                 return true;\n             }\n--- a/src/main/java/org/apache/commons/lang3/time/FormatCache.java\n+++ b/src/main/java/org/apache/commons/lang3/time/FormatCache.java\n      * @throws IllegalArgumentException if pattern is invalid\n      *  or <code>null</code>\n      */\n-    public F getInstance(String pattern, TimeZone timeZone, Locale locale) {\n+    public F getInstance(final String pattern, TimeZone timeZone, Locale locale) {\n         if (pattern == null) {\n             throw new NullPointerException(\"pattern must not be null\");\n         }\n      * @throws IllegalArgumentException if the Locale has no date/time\n      *  pattern defined\n      */\n-    public F getDateTimeInstance(Integer dateStyle, Integer timeStyle, TimeZone timeZone, Locale locale) {\n+    public F getDateTimeInstance(final Integer dateStyle, final Integer timeStyle, final TimeZone timeZone, Locale locale) {\n         if (locale == null) {\n             locale = Locale.getDefault();\n         }\n      * @return a localized standard date/time format\n      * @throws IllegalArgumentException if the Locale has no date/time pattern defined\n      */\n-    public static String getPatternForStyle(Integer dateStyle, Integer timeStyle, Locale locale) {\n+    public static String getPatternForStyle(final Integer dateStyle, final Integer timeStyle, final Locale locale) {\n         MultipartKey key = new MultipartKey(dateStyle, timeStyle, locale);\n \n         String pattern = cDateTimeInstanceCache.get(key);\n          * Constructs an instance of <code>MultipartKey</code> to hold the specified objects.\n          * @param keys the set of objects that make up the key.  Each key may be null.\n          */\n-        public MultipartKey(Object... keys) {\n+        public MultipartKey(final Object... keys) {\n             this.keys = keys;\n         }\n \n          * {@inheritDoc}\n          */\n         @Override\n-        public boolean equals(Object obj) {\n+        public boolean equals(final Object obj) {\n             // Eliminate the usual boilerplate because\n             // this inner static class is only used in a generic ConcurrentHashMap\n             // which will not compare against other Object types\n--- a/src/main/java/org/apache/commons/lang3/tuple/ImmutablePair.java\n+++ b/src/main/java/org/apache/commons/lang3/tuple/ImmutablePair.java\n      * @param right  the right element, may be null\n      * @return a pair formed from the two parameters, not null\n      */\n-    public static <L, R> ImmutablePair<L, R> of(L left, R right) {\n+    public static <L, R> ImmutablePair<L, R> of(final L left, final R right) {\n         return new ImmutablePair<L, R>(left, right);\n     }\n \n      * @param left  the left value, may be null\n      * @param right  the right value, may be null\n      */\n-    public ImmutablePair(L left, R right) {\n+    public ImmutablePair(final L left, final R right) {\n         super();\n         this.left = left;\n         this.right = right;\n      * @throws UnsupportedOperationException as this operation is not supported\n      */\n     @Override\n-    public R setValue(R value) {\n+    public R setValue(final R value) {\n         throw new UnsupportedOperationException();\n     }\n \n--- a/src/main/java/org/apache/commons/lang3/tuple/ImmutableTriple.java\n+++ b/src/main/java/org/apache/commons/lang3/tuple/ImmutableTriple.java\n      * @param right  the right element, may be null\n      * @return a triple formed from the three parameters, not null\n      */\n-    public static <L, M, R> ImmutableTriple<L, M, R> of(L left, M middle, R right) {\n+    public static <L, M, R> ImmutableTriple<L, M, R> of(final L left, final M middle, final R right) {\n         return new ImmutableTriple<L, M, R>(left, middle, right);\n     }\n \n      * @param middle the middle value, may be null\n      * @param right  the right value, may be null\n      */\n-    public ImmutableTriple(L left, M middle, R right) {\n+    public ImmutableTriple(final L left, final M middle, final R right) {\n         super();\n         this.left = left;\n         this.middle = middle;\n--- a/src/main/java/org/apache/commons/lang3/tuple/MutablePair.java\n+++ b/src/main/java/org/apache/commons/lang3/tuple/MutablePair.java\n      * @param right  the right element, may be null\n      * @return a pair formed from the two parameters, not null\n      */\n-    public static <L, R> MutablePair<L, R> of(L left, R right) {\n+    public static <L, R> MutablePair<L, R> of(final L left, final R right) {\n         return new MutablePair<L, R>(left, right);\n     }\n \n      * @param left  the left value, may be null\n      * @param right  the right value, may be null\n      */\n-    public MutablePair(L left, R right) {\n+    public MutablePair(final L left, final R right) {\n         super();\n         this.left = left;\n         this.right = right;\n      * \n      * @param left  the new value of the left element, may be null\n      */\n-    public void setLeft(L left) {\n+    public void setLeft(final L left) {\n         this.left = left;\n     }\n \n      * \n      * @param right  the new value of the right element, may be null\n      */\n-    public void setRight(R right) {\n+    public void setRight(final R right) {\n         this.right = right;\n     }\n \n      * @return the old value for the right element\n      */\n     @Override\n-    public R setValue(R value) {\n+    public R setValue(final R value) {\n         R result = getRight();\n         setRight(value);\n         return result;\n--- a/src/main/java/org/apache/commons/lang3/tuple/MutableTriple.java\n+++ b/src/main/java/org/apache/commons/lang3/tuple/MutableTriple.java\n      * @param right  the right element, may be null\n      * @return a triple formed from the three parameters, not null\n      */\n-    public static <L, M, R> MutableTriple<L, M, R> of(L left, M middle, R right) {\n+    public static <L, M, R> MutableTriple<L, M, R> of(final L left, final M middle, final R right) {\n         return new MutableTriple<L, M, R>(left, middle, right);\n     }\n \n      * @param middle  the middle value, may be null\n      * @param right  the right value, may be null\n      */\n-    public MutableTriple(L left, M middle, R right) {\n+    public MutableTriple(final L left, final M middle, final R right) {\n         super();\n         this.left = left;\n         this.middle = middle;\n      *\n      * @param left  the new value of the left element, may be null\n      */\n-    public void setLeft(L left) {\n+    public void setLeft(final L left) {\n         this.left = left;\n     }\n \n      *\n      * @param middle  the new value of the middle element, may be null\n      */\n-    public void setMiddle(M middle) {\n+    public void setMiddle(final M middle) {\n         this.middle = middle;\n     }\n \n      *\n      * @param right  the new value of the right element, may be null\n      */\n-    public void setRight(R right) {\n+    public void setRight(final R right) {\n         this.right = right;\n     }\n }\n--- a/src/main/java/org/apache/commons/lang3/tuple/Pair.java\n+++ b/src/main/java/org/apache/commons/lang3/tuple/Pair.java\n      * @param right  the right element, may be null\n      * @return a pair formed from the two parameters, not null\n      */\n-    public static <L, R> Pair<L, R> of(L left, R right) {\n+    public static <L, R> Pair<L, R> of(final L left, final R right) {\n         return new ImmutablePair<L, R>(left, right);\n     }\n \n      * @return negative if this is less, zero if equal, positive if greater\n      */\n     @Override\n-    public int compareTo(Pair<L, R> other) {\n+    public int compareTo(final Pair<L, R> other) {\n       return new CompareToBuilder().append(getLeft(), other.getLeft())\n               .append(getRight(), other.getRight()).toComparison();\n     }\n      * @return true if the elements of the pair are equal\n      */\n     @Override\n-    public boolean equals(Object obj) {\n+    public boolean equals(final Object obj) {\n         if (obj == this) {\n             return true;\n         }\n      * @param format  the format string, optionally containing {@code %1$s} and {@code %2$s}, not null\n      * @return the formatted string, not null\n      */\n-    public String toString(String format) {\n+    public String toString(final String format) {\n         return String.format(format, getLeft(), getRight());\n     }\n \n--- a/src/main/java/org/apache/commons/lang3/tuple/Triple.java\n+++ b/src/main/java/org/apache/commons/lang3/tuple/Triple.java\n      * @param right  the right element, may be null\n      * @return a triple formed from the three parameters, not null\n      */\n-    public static <L, M, R> Triple<L, M, R> of(L left, M middle, R right) {\n+    public static <L, M, R> Triple<L, M, R> of(final L left, final M middle, final R right) {\n         return new ImmutableTriple<L, M, R>(left, middle, right);\n     }\n \n      * @return negative if this is less, zero if equal, positive if greater\n      */\n     @Override\n-    public int compareTo(Triple<L, M, R> other) {\n+    public int compareTo(final Triple<L, M, R> other) {\n       return new CompareToBuilder().append(getLeft(), other.getLeft())\n           .append(getMiddle(), other.getMiddle())\n           .append(getRight(), other.getRight()).toComparison();\n      * @return true if the elements of the triple are equal\n      */\n     @Override\n-    public boolean equals(Object obj) {\n+    public boolean equals(final Object obj) {\n         if (obj == this) {\n             return true;\n         }\n      * @param format  the format string, optionally containing {@code %1$s}, {@code %2$s} and {@code %3$s}, not null\n      * @return the formatted string, not null\n      */\n-    public String toString(String format) {\n+    public String toString(final String format) {\n         return String.format(format, getLeft(), getMiddle(), getRight());\n     }\n \n--- a/src/test/java/org/apache/commons/lang3/AnnotationUtilsTest.java\n+++ b/src/test/java/org/apache/commons/lang3/AnnotationUtilsTest.java\n         InvocationHandler generatedTestInvocationHandler = new InvocationHandler() {\n \n             @Override\n-            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n+            public Object invoke(final Object proxy, final Method method, final Object[] args) throws Throwable {\n                 if (\"equals\".equals(method.getName()) && method.getParameterTypes().length == 1) {\n                     return Boolean.valueOf(proxy == args[0]);\n                 }\n--- a/src/test/java/org/apache/commons/lang3/ArrayUtilsTest.java\n+++ b/src/test/java/org/apache/commons/lang3/ArrayUtilsTest.java\n     }\n \n     //-----------------------------------------------------------------------\n-    private void assertIsEquals(Object array1, Object array2, Object array3) {\n+    private void assertIsEquals(final Object array1, final Object array2, final Object array3) {\n         assertTrue(ArrayUtils.isEquals(array1, array1));\n         assertTrue(ArrayUtils.isEquals(array2, array2));\n         assertTrue(ArrayUtils.isEquals(array3, array3));\n                 return \"bar\";\n             }\n             @Override\n-            public Object setValue(Object value) {\n+            public Object setValue(final Object value) {\n                 throw new UnsupportedOperationException();\n             }\n             @Override\n-            public boolean equals(Object o) {\n+            public boolean equals(final Object o) {\n                 throw new UnsupportedOperationException();\n             }\n             @Override\n--- a/src/test/java/org/apache/commons/lang3/CharEncodingTest.java\n+++ b/src/test/java/org/apache/commons/lang3/CharEncodingTest.java\n  */\n public class CharEncodingTest  {\n \n-    private void assertSupportedEncoding(String name) {\n+    private void assertSupportedEncoding(final String name) {\n         assertTrue(\"Encoding should be supported: \" + name, CharEncoding.isSupported(name));\n     }\n \n         }\n     }\n \n-    void warn(String msg) {\n+    void warn(final String msg) {\n         System.err.println(msg);\n     }\n }\n--- a/src/test/java/org/apache/commons/lang3/CharUtilsPerfRun.java\n+++ b/src/test/java/org/apache/commons/lang3/CharUtilsPerfRun.java\n         }\n     }\n \n-    public static void main(String[] args) {\n+    public static void main(final String[] args) {\n         new CharUtilsPerfRun().run();\n     }\n \n         this.printlnTotal(\"run_CharSet\", start);\n     }\n \n-    private int run_CharSet(int loopCount) {\n+    private int run_CharSet(final int loopCount) {\n         int t = 0;\n         for (int i = 0; i < loopCount; i++) {\n             for (char ch : CHAR_SAMPLES) {\n         return t;\n     }\n \n-    private int run_CharUtils_isAsciiNumeric(int loopCount) {\n+    private int run_CharUtils_isAsciiNumeric(final int loopCount) {\n         int t = 0;\n         for (int i = 0; i < loopCount; i++) {\n             for (char ch : CHAR_SAMPLES) {\n         return t;\n     }\n \n-    private int run_inlined_CharUtils_isAsciiNumeric(int loopCount) {\n+    private int run_inlined_CharUtils_isAsciiNumeric(final int loopCount) {\n         int t = 0;\n         for (int i = 0; i < loopCount; i++) {\n             for (char ch : CHAR_SAMPLES) {\n         return t;\n     }\n \n-    private void printlnTotal(String prefix, long start) {\n+    private void printlnTotal(final String prefix, final long start) {\n         long total = System.currentTimeMillis() - start;\n         System.out.println(prefix + \": \" + NumberFormat.getInstance().format(total) + \" milliseconds.\");\n     }\n--- a/src/test/java/org/apache/commons/lang3/ClassUtilsTest.java\n+++ b/src/test/java/org/apache/commons/lang3/ClassUtilsTest.java\n         assertEquals( boolean.class, ClassUtils.getClass( \"boolean\" ) );\n     }\n \n-    private void assertGetClassReturnsClass( Class<?> c ) throws Exception {\n+    private void assertGetClassReturnsClass( final Class<?> c ) throws Exception {\n         assertEquals( c, ClassUtils.getClass( c.getName() ) );\n     }\n \n-    private void assertGetClassThrowsException( String className, Class<?> exceptionType ) throws Exception {\n+    private void assertGetClassThrowsException( final String className, final Class<?> exceptionType ) throws Exception {\n         try {\n             ClassUtils.getClass( className );\n             fail( \"ClassUtils.getClass() should fail with an exception of type \" + exceptionType.getName() + \" when given class name \\\"\" + className + \"\\\".\" );\n         }\n     }\n \n-    private void assertGetClassThrowsNullPointerException( String className ) throws Exception {\n+    private void assertGetClassThrowsNullPointerException( final String className ) throws Exception {\n         assertGetClassThrowsException( className, NullPointerException.class );\n     }\n \n-    private void assertGetClassThrowsClassNotFound( String className ) throws Exception {\n+    private void assertGetClassThrowsClassNotFound( final String className ) throws Exception {\n         assertGetClassThrowsException( className, ClassNotFoundException.class );\n     }\n \n--- a/src/test/java/org/apache/commons/lang3/ConversionTest.java\n+++ b/src/test/java/org/apache/commons/lang3/ConversionTest.java\n         }\n     }\n \n-    static String dbgPrint(boolean[] src) {\n+    static String dbgPrint(final boolean[] src) {\n         StringBuilder sb = new StringBuilder();\n         for (boolean e : src) {\n             if (e) {\n     }\n \n     // org.junit.Assert(boolean[], boolean[]) does not exist in JUnit 4.2\n-    static void assertBinaryEquals(boolean[] expected, boolean[] actual) {\n+    static void assertBinaryEquals(final boolean[] expected, final boolean[] actual) {\n         assertEquals(expected.length, actual.length);\n         for (int i = 0; i < expected.length; i++ ) {\n             try {\n--- a/src/test/java/org/apache/commons/lang3/EnumUtilsTest.java\n+++ b/src/test/java/org/apache/commons/lang3/EnumUtilsTest.java\n         assertArrayEquals(EnumUtils.generateBitVectors(Traffic.class, Traffic.RED, Traffic.AMBER, Traffic.GREEN, Traffic.GREEN), 7L);\n     }\n \n-    private void assertArrayEquals(long[] actual, long... expected) {\n+    private void assertArrayEquals(final long[] actual, final long... expected) {\n         Assert.assertArrayEquals(expected, actual);\n     }\n \n--- a/src/test/java/org/apache/commons/lang3/HashSetvBitSetTest.java\n+++ b/src/test/java/org/apache/commons/lang3/HashSetvBitSetTest.java\n     /**\n      * @return bitSet - HashSet\n      */\n-    private long printTimes(int count) {\n+    private long printTimes(final int count) {\n         long hashSet = timeHashSet(count);\n         long bitSet = timeBitSet(count);\n         // If percent is less than 100, then bitset is faster\n         return bitSet - hashSet;\n     }\n \n-    private static long timeHashSet(int count) {\n+    private static long timeHashSet(final int count) {\n         int [] result = new int[0];\n         long start = System.nanoTime();\n         for (int i = 0; i < LOOPS; i++) {\n         return elapsed;\n     }\n \n-    private static long timeBitSet(int count) {\n+    private static long timeBitSet(final int count) {\n         int [] result = new int[0];\n         long start = System.nanoTime();\n         for (int i = 0; i < LOOPS; i++) {\n     }\n \n     @SuppressWarnings(\"boxing\")\n-    private static int[] testHashSet(int count) {\n+    private static int[] testHashSet(final int count) {\n         HashSet<Integer> toRemove = new HashSet<Integer>();\n             int found = 0;\n             for (int i = 0; i < count; i++) {\n             return extractIndices(toRemove);\n         }\n     \n-    private static int[] testBitSet(int count) {\n+    private static int[] testBitSet(final int count) {\n         BitSet toRemove = new BitSet();\n         int found = 0;\n         for (int i = 0; i < count; i++) {\n     }\n     \n \n-    private static int[] extractIndices(HashSet<Integer> coll) {\n+    private static int[] extractIndices(final HashSet<Integer> coll) {\n         int[] result = new int[coll.size()];\n         int i = 0;\n         for (Integer index : coll) {\n         return result;\n     }\n \n-    private static int[] extractIndices(BitSet coll) {\n+    private static int[] extractIndices(final BitSet coll) {\n         int[] result = new int[coll.cardinality()];\n         int i = 0;\n         int j=0;\n         Assert.assertTrue(timeDiff <= 0);\n     }\n \n-    private long printTimes(int arraySize, int bitSetSize) {\n+    private long printTimes(final int arraySize, final int bitSetSize) {\n         int[] array = new int[arraySize];\n         BitSet remove = new BitSet();\n         for (int i = 0; i < bitSetSize; i++) {\n         return bitSet - extract;\n     }\n \n-    private long timeBitSetRemoveAll(int[] array, BitSet toRemove) {\n+    private long timeBitSetRemoveAll(final int[] array, final BitSet toRemove) {\n         int[] output = new int[0];\n         long start = System.nanoTime();\n         for(int i = 0; i < LOOPS2; i++){\n         return end - start;\n     }\n     \n-    private long timeExtractRemoveAll(int[] array, BitSet toRemove) {\n+    private long timeExtractRemoveAll(final int[] array, final BitSet toRemove) {\n         int[] output = new int[0];\n         long start = System.nanoTime();\n         for(int i = 0; i < LOOPS2; i++){\n--- a/src/test/java/org/apache/commons/lang3/LocaleUtilsTest.java\n+++ b/src/test/java/org/apache/commons/lang3/LocaleUtilsTest.java\n      *\n      * @param language  the language string\n      */\n-    private void assertValidToLocale(String language) {\n+    private void assertValidToLocale(final String language) {\n         Locale locale = LocaleUtils.toLocale(language);\n         assertNotNull(\"valid locale\", locale);\n         assertEquals(language, locale.getLanguage());\n      * @param language of the resulting Locale\n      * @param country of the resulting Locale\n      */\n-    private void assertValidToLocale(String localeString, String language, String country) {\n+    private void assertValidToLocale(final String localeString, final String language, final String country) {\n         Locale locale = LocaleUtils.toLocale(localeString);\n         assertNotNull(\"valid locale\", locale);\n         assertEquals(language, locale.getLanguage());\n      * @param variant of the resulting Locale\n      */\n     private void assertValidToLocale(\n-            String localeString, String language, \n-            String country, String variant) {\n+            final String localeString, final String language, \n+            final String country, final String variant) {\n         Locale locale = LocaleUtils.toLocale(localeString);\n         assertNotNull(\"valid locale\", locale);\n         assertEquals(language, locale.getLanguage());\n      * @param defaultLocale  the input default locale\n      * @param expected  expected results\n      */\n-    private void assertLocaleLookupList(Locale locale, Locale defaultLocale, Locale[] expected) {\n+    private void assertLocaleLookupList(final Locale locale, final Locale defaultLocale, final Locale[] expected) {\n         List<Locale> localeList = defaultLocale == null ?\n                 LocaleUtils.localeLookupList(locale) :\n                 LocaleUtils.localeLookupList(locale, defaultLocale);\n      * @param country\n      * @param languages array of languages that should be returned\n      */\n-    private void assertLanguageByCountry(String country, String[] languages) {\n+    private void assertLanguageByCountry(final String country, final String[] languages) {\n         List<Locale> list = LocaleUtils.languagesByCountry(country);\n         List<Locale> list2 = LocaleUtils.languagesByCountry(country);\n         assertNotNull(list);\n      * @param language\n      * @param countries array of countries that should be returned\n      */\n-    private void assertCountriesByLanguage(String language, String[] countries) {\n+    private void assertCountriesByLanguage(final String language, final String[] countries) {\n         List<Locale> list = LocaleUtils.countriesByLanguage(language);\n         List<Locale> list2 = LocaleUtils.countriesByLanguage(language);\n         assertNotNull(list);\n     /**\n      * @param coll  the collection to check\n      */\n-    private static void assertUnmodifiableCollection(Collection<?> coll) {\n+    private static void assertUnmodifiableCollection(final Collection<?> coll) {\n         try {\n             coll.add(null);\n             fail();\n--- a/src/test/java/org/apache/commons/lang3/ObjectUtilsTest.java\n+++ b/src/test/java/org/apache/commons/lang3/ObjectUtilsTest.java\n          *\n          * @param value\n          */\n-        public NonComparableCharSequence(String value) {\n+        public NonComparableCharSequence(final String value) {\n             super();\n             Validate.notNull(value);\n             this.value = value;\n         }\n \n         @Override\n-        public char charAt(int arg0) {\n+        public char charAt(final int arg0) {\n             return value.charAt(arg0);\n         }\n \n         }\n \n         @Override\n-        public CharSequence subSequence(int arg0, int arg1) {\n+        public CharSequence subSequence(final int arg0, final int arg1) {\n             return value.subSequence(arg0, arg1);\n         }\n \n     static final class CharSequenceComparator implements Comparator<CharSequence> {\n \n         @Override\n-        public int compare(CharSequence o1, CharSequence o2) {\n+        public int compare(final CharSequence o1, final CharSequence o2) {\n             return o1.toString().compareTo(o2.toString());\n         }\n \n--- a/src/test/java/org/apache/commons/lang3/RandomStringUtilsTest.java\n+++ b/src/test/java/org/apache/commons/lang3/RandomStringUtilsTest.java\n      * @param observed array of observed frequency counts\n      * @param expected array of expected frequency counts\n      */\n-    private double chiSquare(int[] expected, int[] observed) {\n+    private double chiSquare(final int[] expected, final int[] observed) {\n         double sumSq = 0.0d;\n         double dev = 0.0d;\n         for (int i = 0; i < observed.length; i++) {\n--- a/src/test/java/org/apache/commons/lang3/RangeTest.java\n+++ b/src/test/java/org/apache/commons/lang3/RangeTest.java\n         Comparable c = \n             new Comparable() { \n                 @Override\n-                public int compareTo(Object other) {\n+                public int compareTo(final Object other) {\n                     return 1;\n                 }\n             };\n     public void testIsWithCompare(){\n         Comparator<Integer> c = new Comparator<Integer>(){\n             @Override\n-            public int compare(Integer o1, Integer o2) {\n+            public int compare(final Integer o1, final Integer o2) {\n                 return 0; // all integers are equal\n             }\n         };\n         // TODO add tests with a better comparator\n         Comparator<Integer> c = new Comparator<Integer>(){\n             @Override\n-            public int compare(Integer o1, Integer o2) {\n+            public int compare(final Integer o1, final Integer o2) {\n                 return 0; // all integers are equal\n             }\n         };\n--- a/src/test/java/org/apache/commons/lang3/SerializationUtilsTest.java\n+++ b/src/test/java/org/apache/commons/lang3/SerializationUtilsTest.java\n         // in the finally block\n         OutputStream streamTest = new OutputStream() {\n             @Override\n-            public void write(int arg0) throws IOException {\n+            public void write(final int arg0) throws IOException {\n                 throw new IOException(SERIALIZE_IO_EXCEPTION_MESSAGE);\n             }\n         };\n class ClassNotFoundSerialization implements Serializable\n {\n \n-    private void readObject(ObjectInputStream in) throws ClassNotFoundException    {\n+    private void readObject(final ObjectInputStream in) throws ClassNotFoundException    {\n         throw new ClassNotFoundException(SerializationUtilsTest.CLASS_NOT_FOUND_MESSAGE);\n     }\n }\n--- a/src/test/java/org/apache/commons/lang3/StringEscapeUtilsTest.java\n+++ b/src/test/java/org/apache/commons/lang3/StringEscapeUtilsTest.java\n         assertEquals(expected, actual);\n     }\n     \n-    private void assertEscapeJava(String escaped, String original) throws IOException {\n+    private void assertEscapeJava(final String escaped, final String original) throws IOException {\n         assertEscapeJava(null, escaped, original);\n     }\n \n-    private void assertEscapeJava(String message, String expected, String original) throws IOException {\n+    private void assertEscapeJava(String message, final String expected, final String original) throws IOException {\n         String converted = StringEscapeUtils.escapeJava(original);\n         message = \"escapeJava(String) failed\" + (message == null ? \"\" : (\": \" + message));\n         assertEquals(message, expected, converted);\n         assertUnescapeJava(\"Unicode as final character\", \"\\uABCD\", \"\\\\uabcd\");\n     }\n \n-    private void assertUnescapeJava(String unescaped, String original) throws IOException {\n+    private void assertUnescapeJava(final String unescaped, final String original) throws IOException {\n         assertUnescapeJava(null, unescaped, original);\n     }\n \n-    private void assertUnescapeJava(String message, String unescaped, String original) throws IOException {\n+    private void assertUnescapeJava(final String message, final String unescaped, final String original) throws IOException {\n         String expected = unescaped;\n         String actual = StringEscapeUtils.unescapeJava(original);\n \n         checkCsvEscapeWriter(\"\", \"\");\n     }\n \n-    private void checkCsvEscapeWriter(String expected, String value) {\n+    private void checkCsvEscapeWriter(final String expected, final String value) {\n         try {\n             StringWriter writer = new StringWriter();\n             StringEscapeUtils.ESCAPE_CSV.translate(value, writer);\n         checkCsvUnescapeWriter(\"\\\"foo.bar\\\"\",        \"\\\"foo.bar\\\"\");\n     }\n \n-    private void checkCsvUnescapeWriter(String expected, String value) {\n+    private void checkCsvUnescapeWriter(final String expected, final String value) {\n         try {\n             StringWriter writer = new StringWriter();\n             StringEscapeUtils.UNESCAPE_CSV.translate(value, writer);\n--- a/src/test/java/org/apache/commons/lang3/StringUtilsEqualsIndexOfTest.java\n+++ b/src/test/java/org/apache/commons/lang3/StringUtilsEqualsIndexOfTest.java\n     private static class CustomCharSequence implements CharSequence {\n         private final CharSequence seq;\n \n-        public CustomCharSequence(CharSequence seq) {\n+        public CustomCharSequence(final CharSequence seq) {\n             this.seq = seq;\n         }\n \n         @Override\n-        public char charAt(int index) {\n+        public char charAt(final int index) {\n             return seq.charAt(index);\n         }\n \n         }\n \n         @Override\n-        public CharSequence subSequence(int start, int end) {\n+        public CharSequence subSequence(final int start, final int end) {\n             return new CustomCharSequence(seq.subSequence(start, end));\n         }\n \n         @Override\n-        public boolean equals(Object obj) {\n+        public boolean equals(final Object obj) {\n             if (obj == null || !(obj instanceof CustomCharSequence)) {\n                 return false;\n             }\n--- a/src/test/java/org/apache/commons/lang3/StringUtilsTest.java\n+++ b/src/test/java/org/apache/commons/lang3/StringUtilsTest.java\n         }\n     }\n     \n-    private void innerTestSplit(char separator, String sepStr, char noMatch) {\n+    private void innerTestSplit(final char separator, final String sepStr, final char noMatch) {\n         String msg = \"Failed on separator hex(\" + Integer.toHexString(separator) +\n             \"), noMatch hex(\" + Integer.toHexString(noMatch) + \"), sepStr(\" + sepStr + \")\";\n         \n         \n     }\n     \n-    private void innerTestSplitPreserveAllTokens(char separator, String sepStr, char noMatch) {\n+    private void innerTestSplitPreserveAllTokens(final char separator, final String sepStr, final char noMatch) {\n         String msg = \"Failed on separator hex(\" + Integer.toHexString(separator) +\n             \"), noMatch hex(\" + Integer.toHexString(noMatch) + \"), sepStr(\" + sepStr + \")\";\n         \n         assertAbbreviateWithOffset(\"...ijklmno\", Integer.MAX_VALUE, 10);\n     }\n \n-    private void assertAbbreviateWithOffset(String expected, int offset, int maxWidth) {\n+    private void assertAbbreviateWithOffset(final String expected, final int offset, final int maxWidth) {\n         String abcdefghijklmno = \"abcdefghijklmno\";\n         String message = \"abbreviate(String,int,int) failed\";\n         String actual = StringUtils.abbreviate(abcdefghijklmno, offset, maxWidth);\n--- a/src/test/java/org/apache/commons/lang3/builder/CompareToBuilderTest.java\n+++ b/src/test/java/org/apache/commons/lang3/builder/CompareToBuilderTest.java\n \n     static class TestObject implements Comparable<TestObject> {\n         private int a;\n-        public TestObject(int a) {\n+        public TestObject(final int a) {\n             this.a = a;\n         }\n         @Override\n-        public boolean equals(Object o) {\n+        public boolean equals(final Object o) {\n             if (o == this) {\n                 return true;\n             }\n             return a;\n         }\n \n-        public void setA(int a) {\n+        public void setA(final int a) {\n             this.a = a;\n         }\n \n             return a;\n         }\n         @Override\n-        public int compareTo(TestObject rhs) {\n+        public int compareTo(final TestObject rhs) {\n             return a < rhs.a ? -1 : a > rhs.a ? +1 : 0;\n         }\n     }\n         public TestSubObject() {\n             super(0);\n         }\n-        public TestSubObject(int a, int b) {\n+        public TestSubObject(final int a, final int b) {\n             super(a);\n             this.b = b;\n         }\n         @Override\n-        public boolean equals(Object o) {\n+        public boolean equals(final Object o) {\n             if (o == this) {\n                 return true;\n             }\n     static class TestTransientSubObject extends TestObject {\n         @SuppressWarnings(\"unused\")\n         private transient int t;\n-        public TestTransientSubObject(int a, int t) {\n+        public TestTransientSubObject(final int a, final int t) {\n             super(a);\n             this.t = t;\n         }\n         assertXYZCompareOrder(x, y, z, true, null);  \n     }\n     \n-    private void assertXYZCompareOrder(Object x, Object y, Object z, boolean testTransients, String[] excludeFields) {\n+    private void assertXYZCompareOrder(final Object x, final Object y, final Object z, final boolean testTransients, final String[] excludeFields) {\n         assertTrue(0 == CompareToBuilder.reflectionCompare(x, x, testTransients, null, excludeFields));\n         assertTrue(0 == CompareToBuilder.reflectionCompare(y, y, testTransients, null, excludeFields));\n         assertTrue(0 == CompareToBuilder.reflectionCompare(z, z, testTransients, null, excludeFields));\n         assertTrue(0 < CompareToBuilder.reflectionCompare(z, y, testTransients, null, excludeFields));\n     }\n     \n-    private void testReflectionHierarchyCompare(boolean testTransients, String[] excludeFields) {\n+    private void testReflectionHierarchyCompare(final boolean testTransients, final String[] excludeFields) {\n         TestObject to1 = new TestObject(1);\n         TestObject to2 = new TestObject(2);\n         TestObject to3 = new TestObject(3);\n      * @param testTransients Whether to include transients in the comparison\n      * @param excludeFields fields to exclude\n      */\n-    private void assertReflectionCompareContract(Object x, Object y, Object z, boolean testTransients, String[] excludeFields) {\n+    private void assertReflectionCompareContract(final Object x, final Object y, final Object z, final boolean testTransients, final String[] excludeFields) {\n \n         // signum\n         assertTrue(reflectionCompareSignum(x, y, testTransients, excludeFields) == -reflectionCompareSignum(y, x, testTransients, excludeFields));\n      * @param excludeFields fields to exclude\n      * @return int The signum\n      */\n-    private int reflectionCompareSignum(Object lhs, Object rhs, boolean testTransients, String[] excludeFields) {\n+    private int reflectionCompareSignum(final Object lhs, final Object rhs, final boolean testTransients, final String[] excludeFields) {\n         return BigInteger.valueOf(CompareToBuilder.reflectionCompare(lhs, rhs, testTransients)).signum();\n     }\n     \n--- a/src/test/java/org/apache/commons/lang3/builder/EqualsBuilderTest.java\n+++ b/src/test/java/org/apache/commons/lang3/builder/EqualsBuilderTest.java\n         private int a;\n         public TestObject() {\n         }\n-        public TestObject(int a) {\n+        public TestObject(final int a) {\n             this.a = a;\n         }\n         @Override\n-        public boolean equals(Object o) {\n+        public boolean equals(final Object o) {\n             if (o == null) { return false; }\n             if (o == this) { return true; }\n             if (o.getClass() != getClass()) {\n             return a;\n         }\n \n-        public void setA(int a) {\n+        public void setA(final int a) {\n             this.a = a;\n         }\n \n         public TestSubObject() {\n             super(0);\n         }\n-        public TestSubObject(int a, int b) {\n+        public TestSubObject(final int a, final int b) {\n             super(a);\n             this.b = b;\n         }\n         @Override\n-        public boolean equals(Object o) {\n+        public boolean equals(final Object o) {\n             if (o == null) { return false; }\n             if (o == this) { return true; }\n             if (o.getClass() != getClass()) {\n             return b *17 + super.hashCode();\n         }\n \n-        public void setB(int b) {\n+        public void setB(final int b) {\n             this.b = b;\n         }\n \n     }\n     \n     static class TestEmptySubObject extends TestObject {\n-        public TestEmptySubObject(int a) {\n+        public TestEmptySubObject(final int a) {\n             super(a);\n         }\n     }\n     static class TestTSubObject extends TestObject {\n         @SuppressWarnings(\"unused\")\n         private transient int t;\n-        public TestTSubObject(int a, int t) {\n+        public TestTSubObject(final int a, final int t) {\n             super(a);\n             this.t = t;\n         }\n     static class TestTTSubObject extends TestTSubObject {\n         @SuppressWarnings(\"unused\")\n         private transient int tt;\n-        public TestTTSubObject(int a, int t, int tt) {\n+        public TestTTSubObject(final int a, final int t, final int tt) {\n             super(a, t);\n             this.tt = tt;\n         }\n     static class TestTTLeafObject extends TestTTSubObject {\n         @SuppressWarnings(\"unused\")\n         private final int leafValue;\n-        public TestTTLeafObject(int a, int t, int tt, int leafValue) {\n+        public TestTTLeafObject(final int a, final int t, final int tt, final int leafValue) {\n             super(a, t, tt);\n             this.leafValue = leafValue;\n         }\n \n     static class TestTSubObject2 extends TestObject {\n         private transient int t;\n-        public TestTSubObject2(int a, int t) {\n+        public TestTSubObject2(final int a, final int t) {\n             super(a);\n         }\n         public int getT() {\n             return t;\n         }\n-        public void setT(int t) {\n+        public void setT(final int t) {\n             this.t = t;\n         }\n     }\n         assertTrue(!EqualsBuilder.reflectionEquals(new TestTTLeafObject(0, 2, 3, 4), new TestTTLeafObject(1, 2, 3, 4), true));\n     }\n \n-    private void testReflectionHierarchyEquals(boolean testTransients) {\n+    private void testReflectionHierarchyEquals(final boolean testTransients) {\n         TestObject to1 = new TestObject(4);\n         TestObject to1Bis = new TestObject(4);\n         TestObject to1Ter = new TestObject(4);\n      * @param testTransients whether to test transient instance variables \n      */\n     private void testReflectionEqualsEquivalenceRelationship(\n-        TestObject to,\n-        TestObject toBis,\n-        TestObject toTer,\n-        TestObject to2,\n-        TestObject oToChange,\n-        boolean testTransients) {\n+        final TestObject to,\n+        final TestObject toBis,\n+        final TestObject toTer,\n+        final TestObject to2,\n+        final TestObject oToChange,\n+        final boolean testTransients) {\n \n         // reflection test\n         assertTrue(EqualsBuilder.reflectionEquals(to, to, testTransients));\n     public static class TestACanEqualB {\n         private final int a;\n \n-        public TestACanEqualB(int a) {\n+        public TestACanEqualB(final int a) {\n             this.a = a;\n         }\n \n         @Override\n-        public boolean equals(Object o) {\n+        public boolean equals(final Object o) {\n             if (o == this) {\n                 return true;\n             }\n     public static class TestBCanEqualA {\n         private final int b;\n \n-        public TestBCanEqualA(int b) {\n+        public TestBCanEqualA(final int b) {\n             this.b = b;\n         }\n \n         @Override\n-        public boolean equals(Object o) {\n+        public boolean equals(final Object o) {\n             if (o == this) {\n                 return true;\n             }\n         @SuppressWarnings(\"unused\")\n         private final TestObject three;\n \n-        public TestObjectWithMultipleFields(int one, int two, int three) {\n+        public TestObjectWithMultipleFields(final int one, final int two, final int three) {\n             this.one = new TestObject(one);\n             this.two = new TestObject(two);\n             this.three = new TestObject(three);\n         @SuppressWarnings(\"unused\")\n         private final TestObject one;\n \n-        public TestObjectReference(int one) {\n+        public TestObjectReference(final int one) {\n             this.one = new TestObject(one);\n         }\n \n-        public void setObjectReference(TestObjectReference reference) {\n+        public void setObjectReference(final TestObjectReference reference) {\n             this.reference = reference;\n         }\n \n         @Override\n-        public boolean equals(Object obj) {\n+        public boolean equals(final Object obj) {\n             return EqualsBuilder.reflectionEquals(this, obj);\n         }\n     }\n--- a/src/test/java/org/apache/commons/lang3/builder/HashCodeBuilderAndEqualsBuilderTest.java\n+++ b/src/test/java/org/apache/commons/lang3/builder/HashCodeBuilderAndEqualsBuilderTest.java\n \n     //-----------------------------------------------------------------------\n \n-    private void testInteger(boolean testTransients) {\n+    private void testInteger(final boolean testTransients) {\n         Integer i1 = Integer.valueOf(12345);\n         Integer i2 = Integer.valueOf(12345);\n         assertEqualsAndHashCodeContract(i1, i2, testTransients);\n         testFixture(true);\n     }\n \n-    private void testFixture(boolean testTransients) {\n+    private void testFixture(final boolean testTransients) {\n         assertEqualsAndHashCodeContract(new TestFixture(2, 'c', \"Test\", (short) 2), new TestFixture(2, 'c', \"Test\", (short) 2), testTransients);\n         assertEqualsAndHashCodeContract(\n             new AllTransientFixture(2, 'c', \"Test\", (short) 2),\n      * @param rhs The Right-Hand-Side of the equals test\n      * @param testTransients wether to test transient fields\n      */\n-    private void assertEqualsAndHashCodeContract(Object lhs, Object rhs, boolean testTransients) {\n+    private void assertEqualsAndHashCodeContract(final Object lhs, final Object rhs, final boolean testTransients) {\n         if (EqualsBuilder.reflectionEquals(lhs, rhs, testTransients)) {\n             // test a couple of times for consistency.\n             assertEquals(HashCodeBuilder.reflectionHashCode(lhs, testTransients), HashCodeBuilder.reflectionHashCode(rhs, testTransients));\n         String string;\n         short s;\n \n-        TestFixture(int i, char c, String string, short s) {\n+        TestFixture(final int i, final char c, final String string, final short s) {\n             this.i = i;\n             this.c = c;\n             this.string = string;\n     static class SubTestFixture extends TestFixture {\n         transient String tString;\n \n-        SubTestFixture(int i, char c, String string, short s, String tString) {\n+        SubTestFixture(final int i, final char c, final String string, final short s, final String tString) {\n             super(i, c, string, s);\n             this.tString = tString;\n         }\n         transient String string;\n         transient short s;\n \n-        AllTransientFixture(int i, char c, String string, short s) {\n+        AllTransientFixture(final int i, final char c, final String string, final short s) {\n             this.i = i;\n             this.c = c;\n             this.string = string;\n     static class SubAllTransientFixture extends AllTransientFixture {\n         transient String tString;\n \n-        SubAllTransientFixture(int i, char c, String string, short s, String tString) {\n+        SubAllTransientFixture(final int i, final char c, final String string, final short s, final String tString) {\n             super(i, c, string, s);\n             this.tString = tString;\n         }\n--- a/src/test/java/org/apache/commons/lang3/builder/HashCodeBuilderTest.java\n+++ b/src/test/java/org/apache/commons/lang3/builder/HashCodeBuilderTest.java\n     static class TestObject {\n         private int a;\n \n-        public TestObject(int a) {\n+        public TestObject(final int a) {\n             this.a = a;\n         }\n \n         @Override\n-        public boolean equals(Object o) {\n+        public boolean equals(final Object o) {\n             if (o == this) {\n                 return true;\n             }\n             return a;\n         }\n \n-        public void setA(int a) {\n+        public void setA(final int a) {\n             this.a = a;\n         }\n \n             super(0);\n         }\n \n-        public TestSubObject(int a, int b, int t) {\n+        public TestSubObject(final int a, final int b, final int t) {\n             super(a);\n             this.b = b;\n             this.t = t;\n         }\n \n         @Override\n-        public boolean equals(Object o) {\n+        public boolean equals(final Object o) {\n             if (o == this) {\n                 return true;\n             }\n         @SuppressWarnings(\"unused\")\n         private int three = 0;\n \n-        public TestObjectWithMultipleFields(int one, int two, int three) {\n+        public TestObjectWithMultipleFields(final int one, final int two, final int three) {\n             this.one = one;\n             this.two = two;\n             this.three = three;\n--- a/src/test/java/org/apache/commons/lang3/builder/ReflectionToStringBuilderConcurrencyTest.java\n+++ b/src/test/java/org/apache/commons/lang3/builder/ReflectionToStringBuilderConcurrencyTest.java\n     static class CollectionHolder<T extends Collection<?>> {\n         T collection;\n \n-        CollectionHolder(T collection) {\n+        CollectionHolder(final T collection) {\n             this.collection = collection;\n         }\n     }\n--- a/src/test/java/org/apache/commons/lang3/builder/ReflectionToStringBuilderExcludeTest.java\n+++ b/src/test/java/org/apache/commons/lang3/builder/ReflectionToStringBuilderExcludeTest.java\n         this.validateSecretFieldPresent(toString);\n     }\n \n-    private void validateNonSecretField(String toString) {\n+    private void validateNonSecretField(final String toString) {\n         Assert.assertTrue(toString.indexOf(NOT_SECRET_FIELD) > ArrayUtils.INDEX_NOT_FOUND);\n         Assert.assertTrue(toString.indexOf(NOT_SECRET_VALUE) > ArrayUtils.INDEX_NOT_FOUND);\n     }\n \n-    private void validateSecretFieldAbsent(String toString) {\n+    private void validateSecretFieldAbsent(final String toString) {\n         Assert.assertEquals(ArrayUtils.INDEX_NOT_FOUND, toString.indexOf(SECRET_VALUE));\n         this.validateNonSecretField(toString);\n     }\n \n-    private void validateSecretFieldPresent(String toString) {\n+    private void validateSecretFieldPresent(final String toString) {\n         Assert.assertTrue(toString.indexOf(SECRET_VALUE) > 0);\n         this.validateNonSecretField(toString);\n     }\n--- a/src/test/java/org/apache/commons/lang3/builder/ReflectionToStringBuilderMutateInspectConcurrencyTest.java\n+++ b/src/test/java/org/apache/commons/lang3/builder/ReflectionToStringBuilderMutateInspectConcurrencyTest.java\n         final private TestFixture testFixture;\n         final private Random random = new Random();\n \n-        public MutatingClient(TestFixture testFixture) {\n+        public MutatingClient(final TestFixture testFixture) {\n             this.testFixture = testFixture;\n         }\n \n     class InspectingClient implements Runnable {\n         final private TestFixture testFixture;\n \n-        public InspectingClient(TestFixture testFixture) {\n+        public InspectingClient(final TestFixture testFixture) {\n             this.testFixture = testFixture;\n         }\n \n--- a/src/test/java/org/apache/commons/lang3/builder/ToStringBuilderTest.java\n+++ b/src/test/java/org/apache/commons/lang3/builder/ToStringBuilderTest.java\n      * @param o the object to create the string for.\n      * @return a String in the Object.toString format.\n      */\n-    private String toBaseString(Object o) {\n+    private String toBaseString(final Object o) {\n         return o.getClass().getName() + \"@\" + Integer.toHexString(System.identityHashCode(o));\n     }\n \n     // Gary Gregory - 2003-03-12 - ggregory@seagullsw.com\n     //\n \n-    public void assertReflectionArray(String expected, Object actual) {\n+    public void assertReflectionArray(final String expected, final Object actual) {\n         if (actual == null) {\n             // Until ToStringBuilder supports null objects.\n             return;\n         public SimpleReflectionTestFixture() {\n         }\n \n-        public SimpleReflectionTestFixture(Object o) {\n+        public SimpleReflectionTestFixture(final Object o) {\n             this.o = o;\n         }\n \n      * @return the String result\n      * @throws IllegalArgumentException if the Object is <code>null</code>\n      */\n-    public <T> String toStringWithStatics(T object, ToStringStyle style, Class<? super T> reflectUpToClass) {\n+    public <T> String toStringWithStatics(final T object, final ToStringStyle style, final Class<? super T> reflectUpToClass) {\n         return ReflectionToStringBuilder.toString(object, style, false, true, reflectUpToClass);\n     }\n \n--- a/src/test/java/org/apache/commons/lang3/builder/ToStringStyleConcurrencyTest.java\n+++ b/src/test/java/org/apache/commons/lang3/builder/ToStringStyleConcurrencyTest.java\n     static class CollectionHolder<T extends Collection<?>> {\n         T collection;\n \n-        CollectionHolder(T collection) {\n+        CollectionHolder(final T collection) {\n             this.collection = collection;\n         }\n     }\n--- a/src/test/java/org/apache/commons/lang3/concurrent/BackgroundInitializerTest.java\n+++ b/src/test/java/org/apache/commons/lang3/concurrent/BackgroundInitializerTest.java\n      *\n      * @param init the initializer to test\n      */\n-    private void checkInitialize(BackgroundInitializerTestImpl init) {\n+    private void checkInitialize(final BackgroundInitializerTestImpl init) {\n         try {\n             Integer result = init.get();\n             assertEquals(\"Wrong result\", 1, result.intValue());\n             super();\n         }\n \n-        public BackgroundInitializerTestImpl(ExecutorService exec) {\n+        public BackgroundInitializerTestImpl(final ExecutorService exec) {\n             super(exec);\n         }\n \n--- a/src/test/java/org/apache/commons/lang3/concurrent/BasicThreadFactoryTest.java\n+++ b/src/test/java/org/apache/commons/lang3/concurrent/BasicThreadFactoryTest.java\n      *\n      * @param factory the factory to be checked\n      */\n-    private void checkFactoryDefaults(BasicThreadFactory factory) {\n+    private void checkFactoryDefaults(final BasicThreadFactory factory) {\n         assertNull(\"Got a naming pattern\", factory.getNamingPattern());\n         assertNull(\"Got an exception handler\", factory\n                 .getUncaughtExceptionHandler());\n      *\n      * @param flag the value of the flag\n      */\n-    private void checkDaemonFlag(boolean flag) {\n+    private void checkDaemonFlag(final boolean flag) {\n         ThreadFactory wrapped = EasyMock.createMock(ThreadFactory.class);\n         Runnable r = EasyMock.createMock(Runnable.class);\n         Thread t = new Thread();\n--- a/src/test/java/org/apache/commons/lang3/concurrent/ConstantInitializerTest.java\n+++ b/src/test/java/org/apache/commons/lang3/concurrent/ConstantInitializerTest.java\n      * @param obj the object to compare with the test instance\n      * @param expected the expected result\n      */\n-    private void checkEquals(Object obj, boolean expected) {\n+    private void checkEquals(final Object obj, final boolean expected) {\n         assertTrue(\"Wrong result of equals\", expected == init.equals(obj));\n         if (obj != null) {\n             assertTrue(\"Not symmetric\", expected == obj.equals(init));\n--- a/src/test/java/org/apache/commons/lang3/concurrent/MultiBackgroundInitializerTest.java\n+++ b/src/test/java/org/apache/commons/lang3/concurrent/MultiBackgroundInitializerTest.java\n      * not be checked)\n      * @throws ConcurrentException if an error occurs\n      */\n-    private void checkChild(BackgroundInitializer<?> child,\n-            ExecutorService expExec) throws ConcurrentException {\n+    private void checkChild(final BackgroundInitializer<?> child,\n+            final ExecutorService expExec) throws ConcurrentException {\n         ChildBackgroundInitializer cinit = (ChildBackgroundInitializer) child;\n         Integer result = cinit.get();\n         assertEquals(\"Wrong result\", 1, result.intValue());\n--- a/src/test/java/org/apache/commons/lang3/concurrent/TimedSemaphoreTest.java\n+++ b/src/test/java/org/apache/commons/lang3/concurrent/TimedSemaphoreTest.java\n      * @param service the mock\n      * @param future the future\n      */\n-    private void prepareStartTimer(ScheduledExecutorService service,\n-            ScheduledFuture<?> future) {\n+    private void prepareStartTimer(final ScheduledExecutorService service,\n+            final ScheduledFuture<?> future) {\n         service.scheduleAtFixedRate((Runnable) EasyMock.anyObject(), EasyMock\n                 .eq(PERIOD), EasyMock.eq(PERIOD), EasyMock.eq(UNIT));\n         EasyMock.expectLastCall().andReturn(future);\n         /** Counter for the endOfPeriod() invocations. */\n         private int periodEnds;\n \n-        public TimedSemaphoreTestImpl(long timePeriod, TimeUnit timeUnit,\n-                int limit) {\n+        public TimedSemaphoreTestImpl(final long timePeriod, final TimeUnit timeUnit,\n+                final int limit) {\n             super(timePeriod, timeUnit, limit);\n         }\n \n-        public TimedSemaphoreTestImpl(ScheduledExecutorService service,\n-                long timePeriod, TimeUnit timeUnit, int limit) {\n+        public TimedSemaphoreTestImpl(final ScheduledExecutorService service,\n+                final long timePeriod, final TimeUnit timeUnit, final int limit) {\n             super(service, timePeriod, timeUnit, limit);\n         }\n \n         /** The number of invocations of the latch. */\n         private final int latchCount;\n \n-        public SemaphoreThread(TimedSemaphore b, CountDownLatch l, int c, int lc) {\n+        public SemaphoreThread(final TimedSemaphore b, final CountDownLatch l, final int c, final int lc) {\n             semaphore = b;\n             latch = l;\n             count = c;\n--- a/src/test/java/org/apache/commons/lang3/event/EventListenerSupportTest.java\n+++ b/src/test/java/org/apache/commons/lang3/event/EventListenerSupportTest.java\n         listenerSupport.addListener(new VetoableChangeListener() {\n             \n             @Override\n-            public void vetoableChange(PropertyChangeEvent e) {\n+            public void vetoableChange(final PropertyChangeEvent e) {\n             }\n         });\n         listenerSupport.addListener(EasyMock.createNiceMock(VetoableChangeListener.class));\n                      * {@inheritDoc}\n                      */\n                     @Override\n-                    public Object invoke(Object proxy, Method method, Object[] args)\n+                    public Object invoke(final Object proxy, final Method method, final Object[] args)\n                             throws Throwable {\n                         return \"vetoableChange\".equals(method.getName())\n                                 && \"Hour\".equals(((PropertyChangeEvent) args[0]).getPropertyName()) ? null\n         listenerSupport.addListener(new VetoableChangeListener()\n         {\n             @Override\n-            public void vetoableChange(PropertyChangeEvent e)\n+            public void vetoableChange(final PropertyChangeEvent e)\n             {\n                 listenerSupport.removeListener(this);\n             }\n         return new VetoableChangeListener()\n         {\n             @Override\n-            public void vetoableChange(PropertyChangeEvent e)\n+            public void vetoableChange(final PropertyChangeEvent e)\n             {\n                 calledListeners.add(this);\n             }\n--- a/src/test/java/org/apache/commons/lang3/event/EventUtilsTest.java\n+++ b/src/test/java/org/apache/commons/lang3/event/EventUtilsTest.java\n             EventUtils.addEventListener(src, PropertyChangeListener.class, new PropertyChangeListener()\n             {\n                 @Override\n-                public void propertyChange(PropertyChangeEvent e)\n+                public void propertyChange(final PropertyChangeEvent e)\n                 {\n                     // Do nothing!\n                 }\n     {\n         private int count;\n \n-        public void eventOccurred(PropertyChangeEvent e)\n+        public void eventOccurred(final PropertyChangeEvent e)\n         {\n             count++;\n         }\n     {\n         private final Map<String, Integer> eventCounts = new TreeMap<String, Integer>();\n \n-        public <L> L createListener(Class<L> listenerType)\n+        public <L> L createListener(final Class<L> listenerType)\n         {\n             return listenerType.cast(Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(),\n                     new Class[]{listenerType},\n                     this));\n         }\n \n-        public int getEventCount(String eventName)\n+        public int getEventCount(final String eventName)\n         {\n             Integer count = eventCounts.get(eventName);\n             return count == null ? 0 : count.intValue();\n         }\n \n         @Override\n-        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable\n+        public Object invoke(final Object proxy, final Method method, final Object[] args) throws Throwable\n         {\n             Integer count = eventCounts.get(method.getName());\n             if (count == null)\n     {\n         private final EventListenerSupport<MultipleEventListener> listeners = EventListenerSupport.create(MultipleEventListener.class);\n \n-        public void addMultipleEventListener(MultipleEventListener listener)\n+        public void addMultipleEventListener(final MultipleEventListener listener)\n         {\n             listeners.addListener(listener);\n         }\n \n     public static class ExceptionEventSource\n     {\n-        public void addPropertyChangeListener(PropertyChangeListener listener)\n+        public void addPropertyChangeListener(final PropertyChangeListener listener)\n         {\n             throw new RuntimeException();\n         }\n \n         private String property;\n \n-        public void setProperty(String property)\n+        public void setProperty(final String property)\n         {\n             String oldValue = this.property;\n             this.property = property;\n             listeners.fire().propertyChange(new PropertyChangeEvent(this, \"property\", oldValue, property));\n         }\n \n-        protected void addVetoableChangeListener(VetoableChangeListener listener)\n+        protected void addVetoableChangeListener(final VetoableChangeListener listener)\n         {\n             // Do nothing!\n         }\n \n-        public void addPropertyChangeListener(PropertyChangeListener listener)\n+        public void addPropertyChangeListener(final PropertyChangeListener listener)\n         {\n             listeners.addListener(listener);\n         }\n \n-        public void removePropertyChangeListener(PropertyChangeListener listener)\n+        public void removePropertyChangeListener(final PropertyChangeListener listener)\n         {\n             listeners.removeListener(listener);\n         }\n--- a/src/test/java/org/apache/commons/lang3/exception/ExceptionUtilsTest.java\n+++ b/src/test/java/org/apache/commons/lang3/exception/ExceptionUtilsTest.java\n     private static class ExceptionWithCause extends Exception {\n         private Throwable cause;\n \n-        public ExceptionWithCause(String str, Throwable cause) {\n+        public ExceptionWithCause(final String str, final Throwable cause) {\n             super(str);\n             setCause(cause);\n         }\n \n-        public ExceptionWithCause(Throwable cause) {\n+        public ExceptionWithCause(final Throwable cause) {\n             super();\n             setCause(cause);\n         }\n             return cause;\n         }\n \n-        public void setCause(Throwable cause) {\n+        public void setCause(final Throwable cause) {\n             this.cause = cause;\n         }\n     }\n     private static class NestableException extends Exception { \n         @SuppressWarnings(\"unused\")\n         public NestableException() { super(); }\n-        public NestableException(Throwable t) { super(t); }\n+        public NestableException(final Throwable t) { super(t); }\n     }\n \n }\n--- a/src/test/java/org/apache/commons/lang3/math/NumberUtilsTest.java\n+++ b/src/test/java/org/apache/commons/lang3/math/NumberUtilsTest.java\n         this.testCreateFloatFailure(\"\\u00A0\\uFEFF\\u000B\\u000C\\u001C\\u001D\\u001E\\u001F\");\n     }\n \n-    protected void testCreateFloatFailure(String str) {\n+    protected void testCreateFloatFailure(final String str) {\n         try {\n             Float value = NumberUtils.createFloat(str);\n             fail(\"createFloat(blank) failed: \" + value);\n         this.testCreateDoubleFailure(\"\\u00A0\\uFEFF\\u000B\\u000C\\u001C\\u001D\\u001E\\u001F\");\n     }\n \n-    protected void testCreateDoubleFailure(String str) {\n+    protected void testCreateDoubleFailure(final String str) {\n         try {\n             Double value = NumberUtils.createDouble(str);\n             fail(\"createDouble(blank) failed: \" + value);\n         this.testCreateIntegerFailure(\"\\u00A0\\uFEFF\\u000B\\u000C\\u001C\\u001D\\u001E\\u001F\");\n     }\n \n-    protected void testCreateIntegerFailure(String str) {\n+    protected void testCreateIntegerFailure(final String str) {\n         try {\n             Integer value = NumberUtils.createInteger(str);\n             fail(\"createInteger(blank) failed: \" + value);\n         this.testCreateLongFailure(\"\\u00A0\\uFEFF\\u000B\\u000C\\u001C\\u001D\\u001E\\u001F\");\n     }\n \n-    protected void testCreateLongFailure(String str) {\n+    protected void testCreateLongFailure(final String str) {\n         try {\n             Long value = NumberUtils.createLong(str);\n             fail(\"createLong(blank) failed: \" + value);\n         testCreateBigIntegerFailure(\"-0x\");\n     }\n \n-    protected void testCreateBigIntegerFailure(String str) {\n+    protected void testCreateBigIntegerFailure(final String str) {\n         try {\n             BigInteger value = NumberUtils.createBigInteger(str);\n             fail(\"createBigInteger(blank) failed: \" + value);\n         this.testCreateBigDecimalFailure(\"++0\");\n     }\n \n-    protected void testCreateBigDecimalFailure(String str) {\n+    protected void testCreateBigDecimalFailure(final String str) {\n         try {\n             BigDecimal value = NumberUtils.createBigDecimal(str);\n             fail(\"createBigDecimal(blank) failed: \" + value);\n         assertFalse(\"isNumber(String) LANG-664 failed\", NumberUtils.isNumber(val));\n     }\n \n-    private boolean checkCreateNumber(String val) {\n+    private boolean checkCreateNumber(final String val) {\n         try {\n             Object obj = NumberUtils.createNumber(val);\n             if (obj == null) {\n--- a/src/test/java/org/apache/commons/lang3/reflect/ConstructorUtilsTest.java\n+++ b/src/test/java/org/apache/commons/lang3/reflect/ConstructorUtilsTest.java\n             toString = \"()\";\n         }\n \n-        public TestBean(int i) {\n+        public TestBean(final int i) {\n             toString = \"(int)\";\n         }\n \n-        public TestBean(Integer i) {\n+        public TestBean(final Integer i) {\n             toString = \"(Integer)\";\n         }\n \n-        public TestBean(double d) {\n+        public TestBean(final double d) {\n             toString = \"(double)\";\n         }\n \n-        public TestBean(String s) {\n+        public TestBean(final String s) {\n             toString = \"(String)\";\n         }\n \n-        public TestBean(Object o) {\n+        public TestBean(final Object o) {\n             toString = \"(Object)\";\n         }\n \n                 singletonArray(null), singletonArray(Object.class));\n     }\n \n-    private void expectMatchingAccessibleConstructorParameterTypes(Class<?> cls,\n-            Class<?>[] requestTypes, Class<?>[] actualTypes) {\n+    private void expectMatchingAccessibleConstructorParameterTypes(final Class<?> cls,\n+            final Class<?>[] requestTypes, final Class<?>[] actualTypes) {\n         Constructor<?> c = ConstructorUtils.getMatchingAccessibleConstructor(cls,\n                 requestTypes);\n         assertTrue(toString(c.getParameterTypes()) + \" not equals \"\n                 .getParameterTypes()));\n     }\n \n-    private String toString(Class<?>[] c) {\n+    private String toString(final Class<?>[] c) {\n         return Arrays.asList(c).toString();\n     }\n \n-    private Class<?>[] singletonArray(Class<?> c) {\n+    private Class<?>[] singletonArray(final Class<?> c) {\n         Class<?>[] result = classCache.get(c);\n         if (result == null) {\n             result = new Class[] { c };\n--- a/src/test/java/org/apache/commons/lang3/reflect/MethodUtilsTest.java\n+++ b/src/test/java/org/apache/commons/lang3/reflect/MethodUtilsTest.java\n             return \"bar()\";\n         }\n \n-        public static String bar(int i) {\n+        public static String bar(final int i) {\n             return \"bar(int)\";\n         }\n \n-        public static String bar(Integer i) {\n+        public static String bar(final Integer i) {\n             return \"bar(Integer)\";\n         }\n \n-        public static String bar(double d) {\n+        public static String bar(final double d) {\n             return \"bar(double)\";\n         }\n \n-        public static String bar(String s) {\n+        public static String bar(final String s) {\n             return \"bar(String)\";\n         }\n \n-        public static String bar(Object o) {\n+        public static String bar(final Object o) {\n             return \"bar(Object)\";\n         }\n         \n-        public static void oneParameterStatic(String s) {\n+        public static void oneParameterStatic(final String s) {\n             // empty\n         }\n \n             return \"foo()\";\n         }\n \n-        public String foo(int i) {\n+        public String foo(final int i) {\n             return \"foo(int)\";\n         }\n \n-        public String foo(Integer i) {\n+        public String foo(final Integer i) {\n             return \"foo(Integer)\";\n         }\n \n-        public String foo(double d) {\n+        public String foo(final double d) {\n             return \"foo(double)\";\n         }\n \n-        public String foo(String s) {\n+        public String foo(final String s) {\n             return \"foo(String)\";\n         }\n \n-        public String foo(Object o) {\n+        public String foo(final Object o) {\n             return \"foo(Object)\";\n         }\n         \n-        public void oneParameter(String s) {\n+        public void oneParameter(final String s) {\n             // empty\n         }\n     }\n         }\n \n         @Override\n-        public void setValue(Object value) {\n+        public void setValue(final Object value) {\n         }\n     }\n \n                 singletonArray(null), singletonArray(String.class));\n     }\n \n-    private void expectMatchingAccessibleMethodParameterTypes(Class<?> cls,\n-            String methodName, Class<?>[] requestTypes, Class<?>[] actualTypes) {\n+    private void expectMatchingAccessibleMethodParameterTypes(final Class<?> cls,\n+            final String methodName, final Class<?>[] requestTypes, final Class<?>[] actualTypes) {\n         Method m = MethodUtils.getMatchingAccessibleMethod(cls, methodName,\n                 requestTypes);\n         assertTrue(toString(m.getParameterTypes()) + \" not equals \"\n                 .getParameterTypes()));\n     }\n \n-    private String toString(Class<?>[] c) {\n+    private String toString(final Class<?>[] c) {\n         return Arrays.asList(c).toString();\n     }\n \n-    private Class<?>[] singletonArray(Class<?> c) {\n+    private Class<?>[] singletonArray(final Class<?> c) {\n         Class<?>[] result = classCache.get(c);\n         if (result == null) {\n             result = new Class[] { c };\n     }\n \n     public static class InheritanceBean {\n-        public void testOne(Object obj) {}\n-        public void testOne(GrandParentObject obj) {}\n-        public void testOne(ParentObject obj) {}\n-        public void testTwo(Object obj) {}\n-        public void testTwo(GrandParentObject obj) {}\n-        public void testTwo(ChildInterface obj) {}\n+        public void testOne(final Object obj) {}\n+        public void testOne(final GrandParentObject obj) {}\n+        public void testOne(final ParentObject obj) {}\n+        public void testTwo(final Object obj) {}\n+        public void testTwo(final GrandParentObject obj) {}\n+        public void testTwo(final ChildInterface obj) {}\n     }\n     \n     interface ChildInterface {}    \n--- a/src/test/java/org/apache/commons/lang3/reflect/TypeUtilsTest.java\n+++ b/src/test/java/org/apache/commons/lang3/reflect/TypeUtilsTest.java\n \n     public static URI uri;\n \n-    public void dummyMethod(List list0, List<Object> list1, List<?> list2,\n-            List<? super Object> list3, List<String> list4, List<? extends String> list5,\n-            List<? super String> list6, List[] list7, List<Object>[] list8, List<?>[] list9,\n-            List<? super Object>[] list10, List<String>[] list11, List<? extends String>[] list12,\n-            List<? super String>[] list13) {\n+    public void dummyMethod(final List list0, final List<Object> list1, final List<?> list2,\n+            final List<? super Object> list3, final List<String> list4, final List<? extends String> list5,\n+            final List<? super String> list6, final List[] list7, final List<Object>[] list8, final List<?>[] list9,\n+            final List<? super Object>[] list10, final List<String>[] list11, final List<? extends String>[] list12,\n+            final List<? super String>[] list13) {\n     }\n \n     @SuppressWarnings(\"boxing\") // deliberately used here\n         Assert.assertTrue(TypeUtils.isAssignable(fClassType, eClassType));\n     }\n \n-    public void delegateBooleanAssertion(Type[] types, int i2, int i1, boolean expected) {\n+    public void delegateBooleanAssertion(final Type[] types, final int i2, final int i1, final boolean expected) {\n         Type type1 = types[i1];\n         Type type2 = types[i2];\n         boolean isAssignable = TypeUtils.isAssignable(type2, type1);\n //raw types, where used, are used purposely\n class AClass extends AAClass<String>.BBClass<Number> {\n \n-    public AClass(AAClass<String> enclosingInstance) {\n+    public AClass(final AAClass<String> enclosingInstance) {\n         enclosingInstance.super();\n     }\n \n--- a/src/test/java/org/apache/commons/lang3/text/CompositeFormatTest.java\n+++ b/src/test/java/org/apache/commons/lang3/text/CompositeFormatTest.java\n \n         Format parser = new Format() {\n             @Override\n-            public StringBuffer format(Object obj, StringBuffer toAppendTo, FieldPosition pos) {\n+            public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos) {\n                 throw new UnsupportedOperationException(\"Not implemented\");\n             }\n \n             @Override\n-            public Object parseObject(String source, ParsePosition pos) {\n+            public Object parseObject(final String source, final ParsePosition pos) {\n                 return null;    // do nothing\n             }\n         };\n \n         Format formatter = new Format() {\n             @Override\n-            public StringBuffer format(Object obj, StringBuffer toAppendTo, FieldPosition pos) {\n+            public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos) {\n                 return null;    // do nothing\n             }\n \n             @Override\n-            public Object parseObject(String source, ParsePosition pos) {\n+            public Object parseObject(final String source, final ParsePosition pos) {\n                 throw new UnsupportedOperationException(\"Not implemented\");\n             }\n         };\n--- a/src/test/java/org/apache/commons/lang3/text/ExtendedMessageFormatTest.java\n+++ b/src/test/java/org/apache/commons/lang3/text/ExtendedMessageFormatTest.java\n      * @param args MessageFormat arguments\n      * @param locales to test\n      */\n-    private void checkBuiltInFormat(String pattern, Object[] args, Locale[] locales) {\n+    private void checkBuiltInFormat(final String pattern, final Object[] args, final Locale[] locales) {\n         checkBuiltInFormat(pattern, null, args, locales);\n     }\n \n      * @param args MessageFormat arguments\n      * @param locales to test\n      */\n-    private void checkBuiltInFormat(String pattern, Map<String, ?> registry, Object[] args, Locale[] locales) {\n+    private void checkBuiltInFormat(final String pattern, final Map<String, ?> registry, final Object[] args, final Locale[] locales) {\n         checkBuiltInFormat(pattern, registry, args, (Locale) null);\n         for (Locale locale : locales) {\n             checkBuiltInFormat(pattern, registry, args, locale);\n      * @param args Object[]\n      * @param locale Locale\n      */\n-    private void checkBuiltInFormat(String pattern, Map<String, ?> registry, Object[] args, Locale locale) {\n+    private void checkBuiltInFormat(final String pattern, final Map<String, ?> registry, final Object[] args, final Locale locale) {\n         StringBuilder buffer = new StringBuilder();\n         buffer.append(\"Pattern=[\");\n         buffer.append(pattern);\n     }\n \n     //can't trust what MessageFormat does with toPattern() pre 1.4:\n-    private void assertPatternsEqual(String message, String expected, String actual) {\n+    private void assertPatternsEqual(final String message, final String expected, final String actual) {\n         if (SystemUtils.isJavaVersionAtLeast(JAVA_1_4)) {\n             assertEquals(message, expected, actual);\n         }\n      * @param locale Locale\n      * @return MessageFormat\n      */\n-    private MessageFormat createMessageFormat(String pattern, Locale locale) {\n+    private MessageFormat createMessageFormat(final String pattern, final Locale locale) {\n         MessageFormat result = new MessageFormat(pattern);\n         if (locale != null) {\n             result.setLocale(locale);\n      */\n     private static class LowerCaseFormat extends Format {\n         @Override\n-        public StringBuffer format(Object obj, StringBuffer toAppendTo, FieldPosition pos) {\n+        public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos) {\n             return toAppendTo.append(((String)obj).toLowerCase());\n         }\n         @Override\n-        public Object parseObject(String source, ParsePosition pos) {throw new UnsupportedOperationException();}\n+        public Object parseObject(final String source, final ParsePosition pos) {throw new UnsupportedOperationException();}\n     }\n \n     /**\n      */\n     private static class UpperCaseFormat extends Format {\n         @Override\n-        public StringBuffer format(Object obj, StringBuffer toAppendTo, FieldPosition pos) {\n+        public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos) {\n             return toAppendTo.append(((String)obj).toUpperCase());\n         }\n         @Override\n-        public Object parseObject(String source, ParsePosition pos) {throw new UnsupportedOperationException();}\n+        public Object parseObject(final String source, final ParsePosition pos) {throw new UnsupportedOperationException();}\n     }\n \n \n     private static class LowerCaseFormatFactory implements FormatFactory {\n         private static final Format LOWER_INSTANCE = new LowerCaseFormat();\n         @Override\n-        public Format getFormat(String name, String arguments, Locale locale) {\n+        public Format getFormat(final String name, final String arguments, final Locale locale) {\n             return LOWER_INSTANCE;\n         }\n     }\n     private static class UpperCaseFormatFactory implements FormatFactory {\n         private static final Format UPPER_INSTANCE = new UpperCaseFormat();\n         @Override\n-        public Format getFormat(String name, String arguments, Locale locale) {\n+        public Format getFormat(final String name, final String arguments, final Locale locale) {\n             return UPPER_INSTANCE;\n         }\n     }\n      */\n     private static class OverrideShortDateFormatFactory implements FormatFactory {\n         @Override\n-        public Format getFormat(String name, String arguments, Locale locale) {\n+        public Format getFormat(final String name, final String arguments, final Locale locale) {\n             return !\"short\".equals(arguments) ? null\n                     : locale == null ? DateFormat\n                             .getDateInstance(DateFormat.DEFAULT) : DateFormat\n      * Alternative ExtendedMessageFormat impl.\n      */\n     private static class OtherExtendedMessageFormat extends ExtendedMessageFormat {\n-        public OtherExtendedMessageFormat(String pattern, Locale locale,\n-                Map<String, ? extends FormatFactory> registry) {\n+        public OtherExtendedMessageFormat(final String pattern, final Locale locale,\n+                final Map<String, ? extends FormatFactory> registry) {\n             super(pattern, locale, registry);\n         }\n         \n--- a/src/test/java/org/apache/commons/lang3/text/StrBuilderAppendInsertTest.java\n+++ b/src/test/java/org/apache/commons/lang3/text/StrBuilderAppendInsertTest.java\n         final int[] count = new int[2];\n         StrBuilder sb = new StrBuilder() {\n             @Override\n-            public StrBuilder append(String str) {\n+            public StrBuilder append(final String str) {\n                 count[0]++;\n                 return super.append(str);\n             }\n         final int[] count = new int[2];\n         StrBuilder sb = new StrBuilder() {\n             @Override\n-            public StrBuilder append(String str) {\n+            public StrBuilder append(final String str) {\n                 count[0]++;\n                 return super.append(str);\n             }\n         final int[] count = new int[2];\n         StrBuilder sb = new StrBuilder() {\n             @Override\n-            public StrBuilder append(String str, int startIndex, int length) {\n+            public StrBuilder append(final String str, final int startIndex, final int length) {\n                 count[0]++;\n                 return super.append(str, startIndex, length);\n             }\n         final int[] count = new int[2];\n         StrBuilder sb = new StrBuilder() {\n             @Override\n-            public StrBuilder append(StringBuffer str) {\n+            public StrBuilder append(final StringBuffer str) {\n                 count[0]++;\n                 return super.append(str);\n             }\n         final int[] count = new int[2];\n         StrBuilder sb = new StrBuilder() {\n             @Override\n-            public StrBuilder append(StringBuilder str) {\n+            public StrBuilder append(final StringBuilder str) {\n                 count[0]++;\n                 return super.append(str);\n             }\n         final int[] count = new int[2];\n         StrBuilder sb = new StrBuilder() {\n             @Override\n-            public StrBuilder append(StringBuffer str, int startIndex, int length) {\n+            public StrBuilder append(final StringBuffer str, final int startIndex, final int length) {\n                 count[0]++;\n                 return super.append(str, startIndex, length);\n             }\n         final int[] count = new int[2];\n         StrBuilder sb = new StrBuilder() {\n             @Override\n-            public StrBuilder append(StringBuilder str, int startIndex, int length) {\n+            public StrBuilder append(final StringBuilder str, final int startIndex, final int length) {\n                 count[0]++;\n                 return super.append(str, startIndex, length);\n             }\n         final int[] count = new int[2];\n         StrBuilder sb = new StrBuilder() {\n             @Override\n-            public StrBuilder append(StrBuilder str) {\n+            public StrBuilder append(final StrBuilder str) {\n                 count[0]++;\n                 return super.append(str);\n             }\n         final int[] count = new int[2];\n         StrBuilder sb = new StrBuilder() {\n             @Override\n-            public StrBuilder append(StrBuilder str, int startIndex, int length) {\n+            public StrBuilder append(final StrBuilder str, final int startIndex, final int length) {\n                 count[0]++;\n                 return super.append(str, startIndex, length);\n             }\n         final int[] count = new int[2];\n         StrBuilder sb = new StrBuilder() {\n             @Override\n-            public StrBuilder append(char[] str) {\n+            public StrBuilder append(final char[] str) {\n                 count[0]++;\n                 return super.append(str);\n             }\n         final int[] count = new int[2];\n         StrBuilder sb = new StrBuilder() {\n             @Override\n-            public StrBuilder append(char[] str, int startIndex, int length) {\n+            public StrBuilder append(final char[] str, final int startIndex, final int length) {\n                 count[0]++;\n                 return super.append(str, startIndex, length);\n             }\n--- a/src/test/java/org/apache/commons/lang3/text/StrBuilderTest.java\n+++ b/src/test/java/org/apache/commons/lang3/text/StrBuilderTest.java\n \n     static final StrMatcher A_NUMBER_MATCHER = new StrMatcher() {\n         @Override\n-        public int isMatch(char[] buffer, int pos, int bufferStart, int bufferEnd) {\n+        public int isMatch(final char[] buffer, int pos, final int bufferStart, final int bufferEnd) {\n             if (buffer[pos] == 'A') {\n                 pos++;\n                 if (pos < bufferEnd && buffer[pos] >= '0' && buffer[pos] <= '9') {\n--- a/src/test/java/org/apache/commons/lang3/text/StrSubstitutorTest.java\n+++ b/src/test/java/org/apache/commons/lang3/text/StrSubstitutorTest.java\n         map.put(\"name\", \"commons\");\n         StrSubstitutor sub = new StrSubstitutor(map) {\n             @Override\n-            protected String resolveVariable(String variableName, StrBuilder buf, int startPos, int endPos) {\n+            protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos) {\n                 assertEquals(\"name\", variableName);\n                 assertSame(builder, buf);\n                 assertEquals(3, startPos);\n     }\n \n     //-----------------------------------------------------------------------\n-    private void doTestReplace(String expectedResult, String replaceTemplate, boolean substring) {\n+    private void doTestReplace(final String expectedResult, final String replaceTemplate, final boolean substring) {\n         String expectedShortResult = expectedResult.substring(1, expectedResult.length() - 1);\n         StrSubstitutor sub = new StrSubstitutor(values);\n \n         }\n     }\n \n-    private void doTestNoReplace(String replaceTemplate) {\n+    private void doTestNoReplace(final String replaceTemplate) {\n         StrSubstitutor sub = new StrSubstitutor(values);\n \n         if (replaceTemplate == null) {\n--- a/src/test/java/org/apache/commons/lang3/text/StrTokenizerTest.java\n+++ b/src/test/java/org/apache/commons/lang3/text/StrTokenizerTest.java\n \n     private static final String TSV_SIMPLE_FIXTURE = \"A\\tb\\tc\";\n \n-    private void checkClone(StrTokenizer tokenizer) {\n+    private void checkClone(final StrTokenizer tokenizer) {\n         assertFalse(StrTokenizer.getCSVInstance() == tokenizer);\n         assertFalse(StrTokenizer.getTSVInstance() == tokenizer);\n     }\n     }\n \n     //-----------------------------------------------------------------------\n-    private void testCSV(String data) {\n+    private void testCSV(final String data) {\n         this.testXSVAbc(StrTokenizer.getCSVInstance(data));\n         this.testXSVAbc(StrTokenizer.getCSVInstance(data.toCharArray()));\n     }\n         this.testCSV(\"   \\n  \" + CSV_SIMPLE_FIXTURE + \"\\n\\n\\r\");\n     }\n \n-    void testEmpty(StrTokenizer tokenizer) {\n+    void testEmpty(final StrTokenizer tokenizer) {\n         this.checkClone(tokenizer);\n         assertFalse(tokenizer.hasNext());\n         assertFalse(tokenizer.hasPrevious());\n         this.testEmpty(StrTokenizer.getCSVInstance(\"\"));\n     }\n \n-    void testXSVAbc(StrTokenizer tokenizer) {\n+    void testXSVAbc(final StrTokenizer tokenizer) {\n         this.checkClone(tokenizer);\n         assertEquals(-1, tokenizer.previousIndex());\n         assertEquals(0, tokenizer.nextIndex());\n     public void testTokenizeSubclassInputChange() {\n         StrTokenizer tkn = new StrTokenizer(\"a b c d e\") {\n             @Override\n-            protected List<String> tokenize(char[] chars, int offset, int count) {\n+            protected List<String> tokenize(final char[] chars, final int offset, final int count) {\n                 return super.tokenize(\"w x y z\".toCharArray(), 2, 5);\n             }\n         };\n     public void testTokenizeSubclassOutputChange() {\n         StrTokenizer tkn = new StrTokenizer(\"a b c\") {\n             @Override\n-            protected List<String> tokenize(char[] chars, int offset, int count) {\n+            protected List<String> tokenize(final char[] chars, final int offset, final int count) {\n                 List<String> list = super.tokenize(chars, offset, count);\n                 Collections.reverse(list);\n                 return list;\n--- a/src/test/java/org/apache/commons/lang3/time/DateUtilsRoundingTest.java\n+++ b/src/test/java/org/apache/commons/lang3/time/DateUtilsRoundingTest.java\n      * @param calendarField\n      * @since 3.0\n      */\n-    protected void roundToJanuaryFirst(Date minDate, Date maxDate, int calendarField) {\n+    protected void roundToJanuaryFirst(final Date minDate, final Date maxDate, final int calendarField) {\n         assertEquals(\"Rounding \"+ fdf.format(januaryOneDate) +\" as Date with CalendarField-value \"+ calendarField +\" must return itself\", januaryOneDate, DateUtils.round(januaryOneDate, calendarField));\n         assertEquals(januaryOneDate, DateUtils.round(minDate, calendarField));\n         assertEquals(januaryOneDate, DateUtils.round(maxDate, calendarField));\n--- a/src/test/java/org/apache/commons/lang3/time/DateUtilsTest.java\n+++ b/src/test/java/org/apache/commons/lang3/time/DateUtilsTest.java\n     }\n \n     //-----------------------------------------------------------------------\n-    private void assertDate(Date date, int year, int month, int day, int hour, int min, int sec, int mil) throws Exception {\n+    private void assertDate(final Date date, final int year, final int month, final int day, final int hour, final int min, final int sec, final int mil) throws Exception {\n         GregorianCalendar cal = new GregorianCalendar();\n         cal.setTime(date);\n         assertEquals(year, cal.get(Calendar.YEAR));\n      * This checks that this is a 7 element iterator of Calendar objects\n      * that are dates (no time), and exactly 1 day spaced after each other.\n      */\n-    private static void assertWeekIterator(Iterator<?> it, Calendar start) {\n+    private static void assertWeekIterator(final Iterator<?> it, final Calendar start) {\n         Calendar end = (Calendar) start.clone();\n         end.add(Calendar.DATE, 6);\n \n     /**\n      * Convenience method for when working with Date objects\n      */\n-    private static void assertWeekIterator(Iterator<?> it, Date start, Date end) {\n+    private static void assertWeekIterator(final Iterator<?> it, final Date start, final Date end) {\n         Calendar calStart = Calendar.getInstance();\n         calStart.setTime(start);\n         Calendar calEnd = Calendar.getInstance();\n      * that are dates (no time), and exactly 1 day spaced after each other\n      * (in addition to the proper start and stop dates)\n      */\n-    private static void assertWeekIterator(Iterator<?> it, Calendar start, Calendar end) {\n+    private static void assertWeekIterator(final Iterator<?> it, final Calendar start, final Calendar end) {\n         Calendar cal = (Calendar) it.next();\n         assertCalendarsEquals(\"\", start, cal, 0);\n         Calendar last = null;\n      * Used to check that Calendar objects are close enough\n      * delta is in milliseconds\n      */\n-    private static void assertCalendarsEquals(String message, Calendar cal1, Calendar cal2, long delta) {\n+    private static void assertCalendarsEquals(final String message, final Calendar cal1, final Calendar cal2, final long delta) {\n         if (Math.abs(cal1.getTime().getTime() - cal2.getTime().getTime()) > delta) {\n             throw new AssertionFailedError(\n                     message + \" expected \" + cal1.getTime() + \" but got \" + cal2.getTime());\n         }\n     }\n \n-    void warn(String msg) {\n+    void warn(final String msg) {\n         System.err.println(msg);\n     }\n }\n--- a/src/test/java/org/apache/commons/lang3/time/DurationFormatUtilsTest.java\n+++ b/src/test/java/org/apache/commons/lang3/time/DurationFormatUtilsTest.java\n //        }\n //    }        \n     \n-    private void bruteForce(int year, int month, int day, String format, int calendarType) {\n+    private void bruteForce(final int year, final int month, final int day, final String format, final int calendarType) {\n         String msg = year + \"-\" + month + \"-\" + day + \" to \";\n         Calendar c = Calendar.getInstance();\n         c.set(year, month, day, 0, 0, 0);\n         }\n     }\n \n-    private void assertEqualDuration(String expected, int[] start, int[] end, String format) {\n+    private void assertEqualDuration(final String expected, final int[] start, final int[] end, final String format) {\n         assertEqualDuration(null, expected, start, end, format);\n     }\n-    private void assertEqualDuration(String message, String expected, int[] start, int[] end, String format) {\n+    private void assertEqualDuration(final String message, final String expected, final int[] start, final int[] end, final String format) {\n         Calendar cal1 = Calendar.getInstance();\n         cal1.set(start[0], start[1], start[2], start[3], start[4], start[5]);\n         cal1.set(Calendar.MILLISECOND, 0);\n         }\n     }\n \n-    private void assertArrayEquals(DurationFormatUtils.Token[] obj1, DurationFormatUtils.Token[] obj2) {\n+    private void assertArrayEquals(final DurationFormatUtils.Token[] obj1, final DurationFormatUtils.Token[] obj2) {\n         assertEquals(\"Arrays are unequal length. \", obj1.length, obj2.length);\n         for (int i = 0; i < obj1.length; i++) {\n             assertTrue(\"Index \" + i + \" not equal, \" + obj1[i] + \" vs \" + obj2[i], obj1[i].equals(obj2[i]));\n--- a/src/test/java/org/apache/commons/lang3/time/FastDateFormatTest.java\n+++ b/src/test/java/org/apache/commons/lang3/time/FastDateFormatTest.java\n                         private static final long serialVersionUID = 1L;  // because SimpleDateFormat is serializable\n \n                         @Override\n-                        public Object parseObject(String formattedDate) throws ParseException {\n+                        public Object parseObject(final String formattedDate) throws ParseException {\n                             synchronized(this) {\n                                 return super.parse(formattedDate);\n                             }\n--- a/src/test/java/org/apache/commons/lang3/time/FastDateFormat_ParserTest.java\n+++ b/src/test/java/org/apache/commons/lang3/time/FastDateFormat_ParserTest.java\n public class FastDateFormat_ParserTest extends FastDateParserTest {\n \n     @Override\n-    protected DateParser getInstance(String format, TimeZone timeZone, Locale locale) {\n+    protected DateParser getInstance(final String format, final TimeZone timeZone, final Locale locale) {\n         return FastDateFormat.getInstance(format, timeZone, locale);\n     }\n }\n--- a/src/test/java/org/apache/commons/lang3/time/FastDateFormat_PrinterTest.java\n+++ b/src/test/java/org/apache/commons/lang3/time/FastDateFormat_PrinterTest.java\n public class FastDateFormat_PrinterTest extends FastDatePrinterTest {\n \n     @Override\n-    protected DatePrinter getInstance(String format, TimeZone timeZone, Locale locale) {\n+    protected DatePrinter getInstance(final String format, final TimeZone timeZone, final Locale locale) {\n         return FastDateFormat.getInstance(format, timeZone, locale);\n     }\n }\n--- a/src/test/java/org/apache/commons/lang3/time/FastDateParserTest.java\n+++ b/src/test/java/org/apache/commons/lang3/time/FastDateParserTest.java\n \n     private static final Locale SWEDEN = new Locale(\"sv\", \"SE\");\n \n-    DateParser getInstance(String format) {\n+    DateParser getInstance(final String format) {\n         return getInstance(format, TimeZone.getDefault(), Locale.getDefault());\n     }\n \n-    private DateParser getDateInstance(int dateStyle, Locale locale) {\n+    private DateParser getDateInstance(final int dateStyle, final Locale locale) {\n         return getInstance(FormatCache.getPatternForStyle(Integer.valueOf(dateStyle), null, locale), TimeZone.getDefault(), Locale.getDefault());\n     }\n \n-    private DateParser getInstance(String format, Locale locale) {\n+    private DateParser getInstance(final String format, final Locale locale) {\n         return getInstance(format, TimeZone.getDefault(), locale);\n     }\n \n-    private DateParser getInstance(String format, TimeZone timeZone) {\n+    private DateParser getInstance(final String format, final TimeZone timeZone) {\n         return getInstance(format, timeZone, Locale.getDefault());\n     }\n \n     /**\n      * Override this method in derived tests to change the construction of instances\n      */\n-    protected DateParser getInstance(String format, TimeZone timeZone, Locale locale) {\n+    protected DateParser getInstance(final String format, final TimeZone timeZone, final Locale locale) {\n         return new FastDateParser(format, timeZone, locale);\n     }\n \n         testLocales(SHORT_FORMAT_NOERA, true);\n     }\n \n-    private void testLocales(String format, boolean eraBC) throws Exception {\n+    private void testLocales(final String format, final boolean eraBC) throws Exception {\n \n         Calendar cal= Calendar.getInstance(GMT);\n         cal.clear();\n         }\n     }\n \n-    private String trimMessage(String msg) {\n+    private String trimMessage(final String msg) {\n         if (msg.length() < 100) {\n             return msg;\n         }\n         return msg.substring(0, 100)+\"...\";\n     }\n \n-    private void checkParse(Locale locale, Calendar cal, SimpleDateFormat sdf, DateParser fdf) throws ParseException {\n+    private void checkParse(final Locale locale, final Calendar cal, final SimpleDateFormat sdf, final DateParser fdf) throws ParseException {\n         String formattedDate= sdf.format(cal.getTime());\n         Date expectedTime = sdf.parse(formattedDate);\n         Date actualTime = fdf.parse(formattedDate);\n         testSdfAndFdp(\"M E\",\"3  Tue\", true);\n     }\n \n-    private void testSdfAndFdp(String format, String date, boolean shouldFail)\n+    private void testSdfAndFdp(final String format, final String date, final boolean shouldFail)\n             throws Exception {\n         final boolean debug = false;\n         Date dfdp = null;\n--- a/src/test/java/org/apache/commons/lang3/time/FastDatePrinterTest.java\n+++ b/src/test/java/org/apache/commons/lang3/time/FastDatePrinterTest.java\n     private static final TimeZone NEW_YORK = TimeZone.getTimeZone(\"America/New_York\");\n     private static final Locale SWEDEN = new Locale(\"sv\", \"SE\");\n \n-        DatePrinter getInstance(String format) {\n+        DatePrinter getInstance(final String format) {\n         return getInstance(format, TimeZone.getDefault(), Locale.getDefault());\n     }\n \n-    private DatePrinter getDateInstance(int dateStyle, Locale locale) {\n+    private DatePrinter getDateInstance(final int dateStyle, final Locale locale) {\n         return getInstance(FormatCache.getPatternForStyle(Integer.valueOf(dateStyle), null, locale), TimeZone.getDefault(), Locale.getDefault());\n     }\n \n-    private DatePrinter getInstance(String format, Locale locale) {\n+    private DatePrinter getInstance(final String format, final Locale locale) {\n         return getInstance(format, TimeZone.getDefault(), locale);\n     }\n \n-    private DatePrinter getInstance(String format, TimeZone timeZone) {\n+    private DatePrinter getInstance(final String format, final TimeZone timeZone) {\n         return getInstance(format, timeZone, Locale.getDefault());\n     }\n \n      * @param locale\n      * @return\n      */\n-    protected DatePrinter getInstance(String format, TimeZone timeZone, Locale locale) {\n+    protected DatePrinter getInstance(final String format, final TimeZone timeZone, final Locale locale) {\n         return new FastDatePrinter(format, timeZone, locale);\n     }\n ", "timestamp": 1358838462, "metainfo": ""}