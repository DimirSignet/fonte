{"sha": "17214defbc29adc30bbbcd093b2217065aa214fd", "log": "LANG-839 Add tests to compare extractIndices+removeAll with direct use of BitSet in new version of removeAll  ", "commit": "\n--- a/src/main/java/org/apache/commons/lang3/ArrayUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/ArrayUtils.java\n      * @return new array of same type minus elements specified by unique values of {@code indices}\n      * @since 3.0.1\n      */\n-    private static Object removeAll(Object array, int... indices) {\n+    // package protected for access by unit tests\n+    static Object removeAll(Object array, int... indices) {\n         int length = getLength(array);\n         int diff = 0; // number of distinct indexes, i.e. number of entries that will be removed\n \n--- a/src/test/java/org/apache/commons/lang3/HashSetvBitSetTest.java\n+++ b/src/test/java/org/apache/commons/lang3/HashSetvBitSetTest.java\n  */\n package org.apache.commons.lang3;\n \n+import java.lang.reflect.Array;\n import java.util.BitSet;\n import java.util.HashSet;\n \n public class HashSetvBitSetTest {\n \n     private static final int LOOPS = 2000; // number of times to invoke methods\n+    private static final int LOOPS2 = 10000;\n \n     @Test\n     public void testTimes() {\n         printTimes(1000);\n         printTimes(2000);\n     }\n+\n     private void printTimes(int count) {\n         long hashSet = timeHashSet(count);\n         long bitSet = timeBitSet(count);\n         }\n         return result;\n     }\n+    \n+    @Test\n+    public void testTimesExtractOrBitset() {\n+        final BitSet toRemove = new BitSet();\n+        final int[] array = new int[100];\n+        toRemove.set(10, 20);\n+        timeBitSetRemoveAll(array, toRemove); // warmup\n+        timeExtractRemoveAll(array, toRemove); // warmup\n+        printTimes(100,1);\n+        printTimes(100,10);\n+        printTimes(100,50);\n+        printTimes(100,100);\n+        printTimes(1000,10);\n+        printTimes(1000,100);\n+        printTimes(1000,500);\n+        printTimes(1000,1000);\n+    }\n+\n+    private void printTimes(int arraySize, int bitSetSize) {\n+        int[] array = new int[arraySize];\n+        BitSet remove = new BitSet();\n+        for (int i = 0; i < bitSetSize; i++) {\n+            remove.set(i);\n+        }\n+        long bitSet = timeBitSetRemoveAll(array, remove );\n+        long extract = timeExtractRemoveAll(array, remove);\n+        // If percent is less than 100, then direct use of bitset is faster\n+        System.out.println(\"Ratio=\"+(bitSet*100/extract)+\"% array=\"+array.length+\" count=\"+remove.cardinality()+\" extract=\"+extract+\" bitset=\"+bitSet);\n+    }\n+\n+    private long timeBitSetRemoveAll(int[] array, BitSet toRemove) {\n+        int[] output = new int[0];\n+        long start = System.nanoTime();\n+        for(int i = 0; i < LOOPS2; i++){\n+            output = (int[]) removeAll(array, toRemove);            \n+        }\n+        long end = System.nanoTime();\n+        Assert.assertEquals(array.length-toRemove.cardinality(), output.length);\n+        return end - start;\n+    }\n+    \n+    private long timeExtractRemoveAll(int[] array, BitSet toRemove) {\n+        int[] output = new int[0];\n+        long start = System.nanoTime();\n+        for(int i = 0; i < LOOPS2; i++){\n+            final int[] extractIndices = extractIndices(toRemove);\n+            output = (int[]) ArrayUtils.removeAll((Object)array, extractIndices);\n+        }\n+        long end = System.nanoTime();\n+        Assert.assertEquals(array.length-toRemove.cardinality(), output.length);\n+        return end - start;\n+    }\n+    \n+    /**\n+     * Removes multiple array elements specified by indices.\n+     * \n+     * @param array source\n+     * @param indices to remove\n+     * @return new array of same type minus elements specified by the set bits in {@code indices}\n+     * @since 3.2\n+     */\n+    // package protected for access by unit tests\n+    static Object removeAll(Object array, BitSet indices) {\n+        final int srcLength = ArrayUtils.getLength(array);\n+        final int maxIndex = indices.length();\n+        if (maxIndex > srcLength) { // TODO necessary? Can check this when creating the BitSit \n+            throw new IndexOutOfBoundsException(\"Index: \" + (maxIndex-1) + \", Length: \" + srcLength);\n+        }\n+        final int removals = indices.cardinality(); // true bits are items to remove\n+        Object result = Array.newInstance(array.getClass().getComponentType(), srcLength - removals);\n+        int srcIndex=0;\n+        int destIndex=0;\n+        int count;\n+        int set;\n+        while((set = indices.nextSetBit(srcIndex)) != -1){\n+            count = set - srcIndex;\n+            if (count > 0) {\n+                System.arraycopy(array, srcIndex, result, destIndex, count);\n+                destIndex += count;\n+            }\n+            srcIndex = indices.nextClearBit(set);\n+        }\n+        count = srcLength - srcIndex;\n+        if (count > 0) {\n+            System.arraycopy(array, srcIndex, result, destIndex, count);            \n+        }\n+        return result;\n+    }\n }", "timestamp": 1349778488, "metainfo": ""}