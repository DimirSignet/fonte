{"sha": "acd0f3e4a77e41cc0a1f426b403f82fd84ad5b94", "log": "[LANG-816] introduce CONST() methods to prevent Javac from inlining constants  ", "commit": "\n--- a/src/main/java/org/apache/commons/lang3/ObjectUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/ObjectUtils.java\n         }\n     }\n \n+\n+    // Constants (LANG-816):\n+    /*\n+        These methods ensure constants are not inlined by javac.\n+        For example, typically a developer might declare a constant like so:\n+\n+            public final static int MAGIC_NUMBER = 5;\n+\n+        Should a different jar file refer to this, and the MAGIC_NUMBER\n+        is changed a later date (e.g., MAGIC_NUMBER = 6), the different jar\n+        file will need to recompile itself.  This is because javac\n+        typically inlines the primitive or String constant directly into\n+        the bytecode, and removes the reference to the MAGIC_NUMBER field.\n+\n+        To help the other jar (so that it does not need to recompile\n+        when constants are changed) the original developer can declare\n+        their constant using one of the CONST() utility methods, instead:\n+\n+            public final static int MAGIC_NUMBER = CONST(5);\n+     */\n+\n+\n+    /**\n+     * This method returns the provided value unchanged.\n+     * This can prevent javac from inlining a constant\n+     * field, e.g.,\n+     *\n+     *  public final static boolean MAGIC_FLAG = CONST(true);\n+     *\n+     * This way any jars that refer to this field do not\n+     * have to recompile themselves if the field's value\n+     * changes at some future date.\n+     *\n+     * @param v the boolean value to return\n+     * @return the boolean v, unchanged\n+     */\n+    public static boolean CONST(final boolean v) { return v; }\n+\n+    /**\n+     * This method returns the provided value unchanged.\n+     * This can prevent javac from inlining a constant\n+     * field, e.g.,\n+     *\n+     *  public final static byte MAGIC_BYTE = CONST(127);\n+     *\n+     * This way any jars that refer to this field do not\n+     * have to recompile themselves if the field's value\n+     * changes at some future date.\n+     *\n+     * @param v the byte value to return\n+     * @return the byte v, unchanged\n+     */\n+    public static byte CONST(final byte v) { return v; }\n+\n+    /**\n+     * This method returns the provided value unchanged.\n+     * This can prevent javac from inlining a constant\n+     * field, e.g.,\n+     *\n+     *  public final static byte MAGIC_CHAR = CONST('a');\n+     *\n+     * This way any jars that refer to this field do not\n+     * have to recompile themselves if the field's value\n+     * changes at some future date.\n+     *\n+     * @param v the char value to return\n+     * @return the char v, unchanged\n+     */\n+    public static char CONST(final char v) { return v; }\n+\n+    /**\n+     * This method returns the provided value unchanged.\n+     * This can prevent javac from inlining a constant\n+     * field, e.g.,\n+     *\n+     *  public final static byte MAGIC_SHORT = CONST(123);\n+     *\n+     * This way any jars that refer to this field do not\n+     * have to recompile themselves if the field's value\n+     * changes at some future date.\n+     *\n+     * @param v the short value to return\n+     * @return the short v, unchanged\n+     */\n+    public static short CONST(final short v) { return v; }\n+\n+    /**\n+     * This method returns the provided value unchanged.\n+     * This can prevent javac from inlining a constant\n+     * field, e.g.,\n+     *\n+     *  public final static byte MAGIC_INT = CONST(123);\n+     *\n+     * This way any jars that refer to this field do not\n+     * have to recompile themselves if the field's value\n+     * changes at some future date.\n+     *\n+     * @param v the int value to return\n+     * @return the int v, unchanged\n+     */\n+    public static int CONST(final int v) { return v; }\n+\n+    /**\n+     * This method returns the provided value unchanged.\n+     * This can prevent javac from inlining a constant\n+     * field, e.g.,\n+     *\n+     *  public final static byte MAGIC_LONG = CONST(123L);\n+     *\n+     * This way any jars that refer to this field do not\n+     * have to recompile themselves if the field's value\n+     * changes at some future date.\n+     *\n+     * @param v the long value to return\n+     * @return the long v, unchanged\n+     */\n+    public static long CONST(final long v) { return v; }\n+\n+    /**\n+     * This method returns the provided value unchanged.\n+     * This can prevent javac from inlining a constant\n+     * field, e.g.,\n+     *\n+     *  public final static byte MAGIC_FLOAT = CONST(1.0f);\n+     *\n+     * This way any jars that refer to this field do not\n+     * have to recompile themselves if the field's value\n+     * changes at some future date.\n+     *\n+     * @param v the float value to return\n+     * @return the float v, unchanged\n+     */\n+    public static float CONST(final float v) { return v; }\n+\n+    /**\n+     * This method returns the provided value unchanged.\n+     * This can prevent javac from inlining a constant\n+     * field, e.g.,\n+     *\n+     *  public final static byte MAGIC_DOUBLE = CONST(1.0);\n+     *\n+     * This way any jars that refer to this field do not\n+     * have to recompile themselves if the field's value\n+     * changes at some future date.\n+     *\n+     * @param v the double value to return\n+     * @return the double v, unchanged\n+     */\n+    public static double CONST(final double v) { return v; }\n+\n+    /**\n+     * This method returns the provided value unchanged.\n+     * This can prevent javac from inlining a constant\n+     * field, e.g.,\n+     *\n+     *  public final static byte MAGIC_STRING = CONST(\"abc\");\n+     *\n+     * This way any jars that refer to this field do not\n+     * have to recompile themselves if the field's value\n+     * changes at some future date.\n+     *\n+     * @param v the genericized Object value to return (typically a String).\n+     * @return the genericized Object v, unchanged (typically a String).\n+     */\n+    public static <T> T CONST(final T v) { return v; }\n+\n }\n--- a/src/test/java/org/apache/commons/lang3/ObjectUtilsTest.java\n+++ b/src/test/java/org/apache/commons/lang3/ObjectUtilsTest.java\n         }\n     }\n \n+    @Test\n+    public void testConstMethods() {\n+\n+        // To truly test the CONST() method, we'd want to look in the\n+        // bytecode to see if the literals were folded into the\n+        // class, or if the bytecode kept the method call.\n+\n+        assertEquals(\"CONST(boolean)\", true, ObjectUtils.CONST(true));\n+        assertEquals(\"CONST(byte)\", (byte) 3, ObjectUtils.CONST((byte) 3));\n+        assertEquals(\"CONST(char)\", (char) 3, ObjectUtils.CONST((char) 3));\n+        assertEquals(\"CONST(short)\", (short) 3, ObjectUtils.CONST((short) 3));\n+        assertEquals(\"CONST(int)\", 3, ObjectUtils.CONST(3));\n+        assertEquals(\"CONST(long)\", 3l, ObjectUtils.CONST(3l));\n+        assertEquals(\"CONST(float)\", 3f, ObjectUtils.CONST(3f), 0);\n+        assertEquals(\"CONST(double)\", 3.0, ObjectUtils.CONST(3.0), 0);\n+        assertEquals(\"CONST(Object)\", \"abc\", ObjectUtils.CONST(\"abc\"));\n+    }\n+\n     /**\n      * String that is cloneable.\n      */", "timestamp": 1345732094, "metainfo": ""}