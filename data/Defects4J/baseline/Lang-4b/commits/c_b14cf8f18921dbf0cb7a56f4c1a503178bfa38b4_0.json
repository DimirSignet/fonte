{"sha": "b14cf8f18921dbf0cb7a56f4c1a503178bfa38b4", "log": "Fix to include superclass fields in reflection toString   ", "commit": "\n--- a/src/java/org/apache/commons/lang/builder/ToStringBuilder.java\n+++ b/src/java/org/apache/commons/lang/builder/ToStringBuilder.java\n  * <code>reflectionToString</code>, uses <code>Field.setAccessible</code> to\n  * change the visibility of the fields. This will fail under a security manager,\n  * unless the appropriate permissions are set up correctly. It is also\n- * slower than testing explicitly and does not handle superclasses.</p>\n+ * slower than testing explicitly.</p>\n  *\n  * <p>A typical invocation for this method would look like:</p>\n  * <pre>\n  *\n  * @author Stephen Colebourne\n  * @since 1.0\n- * @version $Id: ToStringBuilder.java,v 1.10 2002/12/23 00:20:31 scolebourne Exp $\n+ * @version $Id: ToStringBuilder.java,v 1.11 2002/12/31 20:17:53 scolebourne Exp $\n  */\n public class ToStringBuilder {\n     \n      *\n      * <p>Transient members will be not be included, as they are likely derived.</p>\n      *\n-     * <p>Static fields will be not be included.</p>\n+     * <p>Static fields will not be included. Superclass fields will be appended.</p>\n      *\n      * @param object  the Object to be output\n      * @return the String result\n      * @throws IllegalArgumentException if the Object is <code>null</code>\n      */\n     public static String reflectionToString(Object object) {\n-        return reflectionToString(object, null, false);\n+        return reflectionToString(object, null, false, null);\n     }\n \n     /**\n      * <p>Transient members will be not be included, as they are likely\n      * derived.</p>\n      *\n-     * <p>Static fields will be not be included.</p>\n+     * <p>Static fields will not be included. Superclass fields will be appended.</p>\n      *\n      * <p>If the style is <code>null</code>, the default\n      * <code>ToStringStyle</code> is used.</p>\n      *  <code>ToStringStyle</code> is <code>null</code>\n      */\n     public static String reflectionToString(Object object, ToStringStyle style) {\n-        return reflectionToString(object, style, false);\n+        return reflectionToString(object, style, false, null);\n     }\n \n     /**\n      * as they are likely derived fields, and not part of the value of the\n      * Object.</p>\n      *\n-     * <p>Static fields will not be tested.</p>\n+     * <p>Static fields will not be included. Superclass fields will be appended.</p>\n      *\n      * <p>\n      * If the style is <code>null</code>, the default\n      * @return the String result\n      * @throws IllegalArgumentException if the Object is <code>null</code>\n      */\n-    public static String reflectionToString(Object object, ToStringStyle style, \n-            boolean outputTransients) {\n+    public static String reflectionToString(Object object, ToStringStyle style, boolean outputTransients) {\n+        return reflectionToString(object, style, outputTransients, null);\n+    }\n+\n+    /**\n+     * <p>This method uses reflection to build a suitable\n+     * <code>toString</code>.</p>\n+     *\n+     * <p>It uses <code>Field.setAccessible</code> to gain access to private\n+     * fields. This means that it will throw a security exception if run\n+     * under a security manger, if the permissions are not set up correctly.\n+     * It is also not as efficient as testing explicitly. </p>\n+     *\n+     * <p>If the <code>outputTransients</code> is <code>true</code>,\n+     * transient members will be output, otherwise they are ignored,\n+     * as they are likely derived fields, and not part of the value of the\n+     * Object.</p>\n+     *\n+     * <p>Static fields will not be included. Superclass fields will be appended\n+     * up to and including the specified superclass. A null superclass is treated\n+     * as java.lang.Object.</p>\n+     *\n+     * <p>\n+     * If the style is <code>null</code>, the default\n+     * <code>ToStringStyle</code> is used.</p>\n+     * \n+     * @param object  the Object to be output\n+     * @param style  the style of the <code>toString</code> to create,\n+     *  may be <code>null</code>\n+     * @param outputTransients  whether to include transient fields\n+     * @param reflectUpToClass  the superclass to reflect up to (inclusive), may be null\n+     * @return the String result\n+     * @throws IllegalArgumentException if the Object is <code>null</code>\n+     */\n+    public static String reflectionToString(Object object, ToStringStyle style, boolean outputTransients, Class reflectUpToClass) {\n         if (object == null) {\n             throw new IllegalArgumentException(\"The object must not be null\");\n         }\n         if (style == null) {\n             style = getDefaultStyle();\n         }\n-        Field[] fields = object.getClass().getDeclaredFields();\n+        ToStringBuilder builder = new ToStringBuilder(object, style);\n+        Class clazz = object.getClass();\n+        reflectionAppend(object, clazz, builder, outputTransients);\n+        while (clazz.getSuperclass() != null && clazz != reflectUpToClass) {\n+            clazz = clazz.getSuperclass();\n+            reflectionAppend(object, clazz, builder, outputTransients);\n+        }\n+        return builder.toString();\n+    }\n+\n+    /**\n+     * Appends the fields and values defined by the given object of the\n+     * given Class.\n+     * \n+     * @param object  the object to append details of\n+     * @param clazz  the class to append details of\n+     * @param builder  the builder to append to\n+     * @param outputTransients  whether to output transient fields\n+     */\n+    private static void reflectionAppend(Object object, Class clazz, ToStringBuilder builder, boolean outputTransients) {\n+        Field[] fields = clazz.getDeclaredFields();\n         Field.setAccessible(fields, true);\n-        ToStringBuilder builder = new ToStringBuilder(object, style);\n         for (int i = 0; i < fields.length; ++i) {\n             Field f = fields[i];\n             if (outputTransients || !Modifier.isTransient(f.getModifiers())) {\n                 if (!Modifier.isStatic(f.getModifiers())) {\n                     try {\n                         builder.append(f.getName(), f.get(object));\n-                        \n                     } catch (IllegalAccessException ex) {\n                         //this can't happen. Would get a Security exception instead\n                         //throw a runtime exception in case the impossible happens.\n-                        throw new InternalError(\"Unexpected IllegalAccessException\");\n                     }\n                 }\n             }\n         }\n-        return builder.toString();\n-    }\n-\n-    //----------------------------------------------------------------------------\n+     }\n+     \n+     //----------------------------------------------------------------------------\n     \n     /**\n      * <p>Append the <code>toString</code> from the superclass.</p>\n--- a/src/test/org/apache/commons/lang/builder/ToStringBuilderTest.java\n+++ b/src/test/org/apache/commons/lang/builder/ToStringBuilderTest.java\n package org.apache.commons.lang.builder;\n import java.util.ArrayList;\n import java.util.HashMap;\n+import java.util.List;\n \n import junit.framework.Test;\n import junit.framework.TestCase;\n  * Unit tests {@link org.apache.commons.lang.ToStringBuilder}.\n  *\n  * @author <a href=\"mailto:scolebourne@joda.org\">Stephen Colebourne</a>\n- * @version $Id: ToStringBuilderTest.java,v 1.2 2002/12/08 20:48:46 scolebourne Exp $\n+ * @version $Id: ToStringBuilderTest.java,v 1.3 2002/12/31 20:17:53 scolebourne Exp $\n  */\n public class ToStringBuilderTest extends TestCase {\n \n         assertEquals(baseStr + \"[]\", new ToStringBuilder(base).toString());\n     }\n     \n-    public void testReflection() {\n-        assertEquals(baseStr + \"[value=5]\", ToStringBuilder.reflectionToString(base));\n-    }\n-    \n+\tpublic void testReflection() {\n+\t\tassertEquals(baseStr + \"[value=5]\", ToStringBuilder.reflectionToString(base));\n+\t}\n+\n+    private String toBaseString(Object o) {\n+        return o.getClass().getName() + \"@\" + Integer.toHexString(System.identityHashCode(o));\n+    }\n+\n+    public void testReflectionHierarchyArrayList() {\n+        List base = new ArrayList();\n+        String baseStr = this.toBaseString(base);\n+        assertEquals(baseStr + \"[elementData={<null>,<null>,<null>,<null>,<null>,<null>,<null>,<null>,<null>,<null>},size=0,modCount=0]\", ToStringBuilder.reflectionToString(base, null, true));\n+        assertEquals(baseStr + \"[size=0]\", ToStringBuilder.reflectionToString(base, null, false));\n+    }\n+\n+    public void testReflectionHierarchy() {\n+        ReflectionTestFixtureA baseA = new ReflectionTestFixtureA();\n+        String baseStr = this.toBaseString(baseA);\n+        assertEquals(baseStr + \"[a=a]\", ToStringBuilder.reflectionToString(baseA));\n+        assertEquals(baseStr + \"[a=a]\", ToStringBuilder.reflectionToString(baseA, null));\n+        assertEquals(baseStr + \"[a=a]\", ToStringBuilder.reflectionToString(baseA, null, false));\n+        assertEquals(baseStr + \"[a=a,transientA=t]\", ToStringBuilder.reflectionToString(baseA, null, true));\n+        assertEquals(baseStr + \"[a=a]\", ToStringBuilder.reflectionToString(baseA, null, false, null));\n+        assertEquals(baseStr + \"[a=a]\", ToStringBuilder.reflectionToString(baseA, null, false, Object.class));\n+        assertEquals(baseStr + \"[a=a]\", ToStringBuilder.reflectionToString(baseA, null, false, List.class));\n+        assertEquals(baseStr + \"[a=a]\", ToStringBuilder.reflectionToString(baseA, null, false, ReflectionTestFixtureA.class));\n+        \n+        ReflectionTestFixtureB baseB = new ReflectionTestFixtureB();\n+        baseStr = this.toBaseString(baseB);\n+        assertEquals(baseStr + \"[b=b,a=a]\", ToStringBuilder.reflectionToString(baseB));\n+        assertEquals(baseStr + \"[b=b,a=a]\", ToStringBuilder.reflectionToString(baseB));\n+        assertEquals(baseStr + \"[b=b,a=a]\", ToStringBuilder.reflectionToString(baseB, null));\n+        assertEquals(baseStr + \"[b=b,a=a]\", ToStringBuilder.reflectionToString(baseB, null, false));\n+        assertEquals(baseStr + \"[b=b,transientB=t,a=a,transientA=t]\", ToStringBuilder.reflectionToString(baseB, null, true));\n+        assertEquals(baseStr + \"[b=b,a=a]\", ToStringBuilder.reflectionToString(baseB, null, false, null));\n+        assertEquals(baseStr + \"[b=b,a=a]\", ToStringBuilder.reflectionToString(baseB, null, false, Object.class));\n+        assertEquals(baseStr + \"[b=b,a=a]\", ToStringBuilder.reflectionToString(baseB, null, false, List.class));\n+        assertEquals(baseStr + \"[b=b,a=a]\", ToStringBuilder.reflectionToString(baseB, null, false, ReflectionTestFixtureA.class));\n+        assertEquals(baseStr + \"[b=b]\", ToStringBuilder.reflectionToString(baseB, null, false, ReflectionTestFixtureB.class));\n+    }\n+\n+\tstatic class ReflectionTestFixtureA {\n+\t\tprivate char a='a';\n+        private transient char transientA='t';\n+\t}\n+\n+\tstatic class ReflectionTestFixtureB extends ReflectionTestFixtureA {\n+\t\tprivate char b='b';\n+        private transient char transientB='t';\n+\t}\n+\n     public void testAppendSuper() {\n         assertEquals(baseStr + \"[]\", new ToStringBuilder(base).appendSuper(\"Integer@8888[]\").toString());\n         assertEquals(baseStr + \"[<null>]\", new ToStringBuilder(base).appendSuper(\"Integer@8888[<null>]\").toString());", "timestamp": 1041365873, "metainfo": ""}