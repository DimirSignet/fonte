{"sha": "c28606bd926f8b7c3ab0dbee2ce2e7d72d937692", "log": "Refactor all 3 three Pair classes from o.a.c.l to o.a.c.l.tuple.  ", "commit": "\n--- a/src/main/java/org/apache/commons/lang3/builder/EqualsBuilder.java\n+++ b/src/main/java/org/apache/commons/lang3/builder/EqualsBuilder.java\n import java.util.Set;\n \n import org.apache.commons.lang3.ArrayUtils;\n-import org.apache.commons.lang3.Pair;\n+import org.apache.commons.lang3.tuple.Pair;\n \n /**\n  * <p>Assists in implementing {@link Object#equals(Object)} methods.</p>\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/lang3/tuple/ImmutablePair.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang3.tuple;\n+\n+/**\n+ * <p>An immutable pair consisting of two {@code Object} elements.</p>\n+ * \n+ * <p>Although the implementation is immutable, there is no restriction on the objects\n+ * that may be stored. If mutable objects are stored in the pair, then the pair\n+ * itself effectively becomes mutable. The class is also not {@code final}, so a subclass\n+ * could add undesirable behaviour.</p>\n+ * \n+ * <p>#ThreadSafe# if the objects are threadsafe</p>\n+ *\n+ * @param <L> the first element type\n+ * @param <R> the second element type\n+ *\n+ * @since Lang 3.0\n+ * @version $Id$\n+ */\n+public class ImmutablePair<L, R> extends Pair<L, R> {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = 4954918890077093841L;\n+\n+    /** Left object */\n+    public final L left;\n+    /** Right object */\n+    public final R right;\n+\n+    /**\n+     * <p>Obtains an immutable pair of from two objects inferring the generic types.</p>\n+     * \n+     * <p>This factory allows the pair to be created using inference to\n+     * obtain the generic types.</p>\n+     * \n+     * @param <L> the left element type\n+     * @param <R> the right element type\n+     * @param left  the left element, may be null\n+     * @param right  the right element, may be null\n+     * @return a pair formed from the two parameters, not null\n+     */\n+    public static <L, R> ImmutablePair<L, R> of(L left, R right) {\n+        return new ImmutablePair<L, R>(left, right);\n+    }\n+\n+    /**\n+     * Create a new pair instance.\n+     *\n+     * @param left  the left value, may be null\n+     * @param right  the right value, may be null\n+     */\n+    public ImmutablePair(L left, R right) {\n+        super();\n+        this.left = left;\n+        this.right = right;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public L getLeft() {\n+        return left;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public R getRight() {\n+        return right;\n+    }\n+\n+    /**\n+     * <p>Throws {@code UnsupportedOperationException}.</p>\n+     * \n+     * <p>This pair is immutable, so this operation is not supported.</p>\n+     *\n+     * @param value  the value to set\n+     * @return never\n+     * @throws UnsupportedOperationException as this operation is not supported\n+     */\n+    public R setValue(R value) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/lang3/tuple/MutablePair.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang3.tuple;\n+\n+/**\n+ * <p>A mutable pair consisting of two {@code Object} elements.</p>\n+ * \n+ * <p>Not #ThreadSafe#</p>\n+ *\n+ * @param <L> the first element type\n+ * @param <R> the second element type\n+ *\n+ * @since Lang 3.0\n+ * @version $Id$\n+ */\n+public class MutablePair<L, R> extends Pair<L, R> {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = 4954918890077093841L;\n+\n+    /** Left object */\n+    public L left;\n+    /** Right object */\n+    public R right;\n+\n+    /**\n+     * <p>Obtains an immutable pair of from two objects inferring the generic types.</p>\n+     * \n+     * <p>This factory allows the pair to be created using inference to\n+     * obtain the generic types.</p>\n+     * \n+     * @param <L> the left element type\n+     * @param <R> the right element type\n+     * @param left  the left element, may be null\n+     * @param right  the right element, may be null\n+     * @return a pair formed from the two parameters, not null\n+     */\n+    public static <L, R> MutablePair<L, R> of(L left, R right) {\n+        return new MutablePair<L, R>(left, right);\n+    }\n+\n+    /**\n+     * Create a new pair instance of two nulls.\n+     */\n+    public MutablePair() {\n+        super();\n+    }\n+\n+    /**\n+     * Create a new pair instance.\n+     *\n+     * @param left  the left value, may be null\n+     * @param right  the right value, may be null\n+     */\n+    public MutablePair(L left, R right) {\n+        super();\n+        this.left = left;\n+        this.right = right;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public L getLeft() {\n+        return left;\n+    }\n+\n+    /**\n+     * Set the left element of the pair.\n+     * \n+     * @param left  the new value of the left element, may be null\n+     */\n+    public void setLeftElement(L left) {\n+        this.left = left;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public R getRight() {\n+        return right;\n+    }\n+\n+    /**\n+     * Set the right element of the pair.\n+     * \n+     * @param right  the value of the right element\n+     */\n+    public void setRightElement(R right) {\n+        this.right = right;\n+    }\n+\n+    /**\n+     * Sets the {@code Map.Entry} value.\n+     * This sets the right element of the pair.\n+     * \n+     * @param value  the right value to set, not null\n+     * @return the old value for the right element\n+     */\n+    public R setValue(R value) {\n+        R result = getRight();\n+        setRightElement(value);\n+        return result;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/lang3/tuple/Pair.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang3.tuple;\n+\n+import java.io.Serializable;\n+import java.util.Formatter;\n+import java.util.Map;\n+\n+import org.apache.commons.lang3.ObjectUtils;\n+import org.apache.commons.lang3.builder.CompareToBuilder;\n+\n+/**\n+ * <p>A pair consisting of two elements.</p>\n+ * \n+ * <p>This class is an abstract implementation defining the basic API.\n+ * It refers to the elements as 'left' and 'right'. It also implements the\n+ * {@code Map.Entry} interface where the key is 'left' and the value is 'right'.</p>\n+ * \n+ * <p>Subclass implementations may be mutable or immutable.\n+ * However, there is no restriction on the type of the stored objects that may be stored.\n+ * If mutable objects are stored in the pair, then the pair itself effectively becomes mutable.</p>\n+ *\n+ * @param <L> the first element type\n+ * @param <R> the second element type\n+ *\n+ * @since Lang 3.0\n+ * @version $Id$\n+ */\n+public abstract class Pair<L, R> implements Map.Entry<L, R>, Comparable<Pair<L, R>>, Serializable {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = 4954918890077093841L;\n+    /**\n+     * The default format for the toString method.\n+     */\n+    private static final String DEFAULT_FORMAT_STRING = \"(%2$s,%3$s)\";\n+\n+    /**\n+     * <p>Obtains an immutable pair of from two objects inferring the generic types.</p>\n+     * \n+     * <p>This factory allows the pair to be created using inference to\n+     * obtain the generic types.</p>\n+     * \n+     * @param <L> the left element type\n+     * @param <R> the right element type\n+     * @param left  the left element, may be null\n+     * @param right  the right element, may be null\n+     * @return a pair formed from the two parameters, not null\n+     */\n+    public static <L, R> Pair<L, R> of(L left, R right) {\n+        return new ImmutablePair<L, R>(left, right);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Gets the left element from this pair.</p>\n+     * \n+     * <p>When treated as a key-value pair, this is the key.</p>\n+     * \n+     * @return the left element, may be null\n+     */\n+    public abstract L getLeft();\n+\n+    /**\n+     * <p>Gets the right element from this pair.</p>\n+     * \n+     * <p>When treated as a key-value pair, this is the value.</p>\n+     * \n+     * @return the right element, may be null\n+     */\n+    public abstract R getRight();\n+\n+    /**\n+     * <p>Gets the key from this pair.</p>\n+     * \n+     * <p>This method implements the {@code Map.Entry} interface returning the\n+     * left element as the key.</p>\n+     * \n+     * @return the left element as the key, may be null\n+     */\n+    public final L getKey() {\n+        return getLeft();\n+    }\n+\n+    /**\n+     * <p>Gets the value from this pair.</p>\n+     * \n+     * <p>This method implements the {@code Map.Entry} interface returning the\n+     * right element as the value.</p>\n+     * \n+     * @return the right element as the value, may be null\n+     */\n+    public R getValue() {\n+        return getRight();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Compares the pair based on the first element followed by the second element.\n+     * The types must be {@code Comparable}.</p>\n+     * \n+     * @param other  the other pair, not null\n+     * @return negative if this is less, zero if equal, positive if greater\n+     */\n+    public int compareTo(Pair<L, R> other) {\n+      return new CompareToBuilder().append(getLeft(), other.getLeft())\n+              .append(getRight(), other.getRight()).toComparison();\n+    }\n+\n+    /**\n+     * <p>Compares this pair to another based on the two elements.</p>\n+     * \n+     * @param obj  the object to compare to, null returns false\n+     * @return true if the elements of the pair are equal\n+     */\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (obj == this) {\n+            return true;\n+        }\n+        if (obj instanceof Map.Entry<?, ?>) {\n+            Map.Entry<?, ?> other = (Map.Entry<?, ?>) obj;\n+            return ObjectUtils.equals(getKey(), other.getKey())\n+                    && ObjectUtils.equals(getValue(), other.getValue());\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * <p>Returns a suitable hash code.\n+     * The hash code follows the definition in {@code Map.Entry}.</p>\n+     * \n+     * @return the hash code\n+     */\n+    @Override\n+    public int hashCode() {\n+        // see Map.Entry API specification\n+        return (getKey() == null ? 0 : getKey().hashCode()) ^\n+                (getValue() == null ? 0 : getValue().hashCode());\n+    }\n+\n+    /**\n+     * <p>Returns a String representation of the Pair in the form: (L,R).</p>\n+     * \n+     * @return a string describing this object, not null\n+     */\n+    @Override\n+    public String toString() {\n+        return toString(DEFAULT_FORMAT_STRING);\n+    }\n+\n+    /**\n+     * <p>Returns a String representation in the given format.</p>\n+     * \n+     * <p>The format specified uses the syntax from {@link Formatter}.\n+     * There are three arguments available:</p>\n+     * <ol>\n+     * <li>The simple class name</li>\n+     * <li>The left object</li>\n+     * <li>The right object</li>\n+     * </ol>\n+     * \n+     * @param format  the format suitable for use with {@code Formatter}, not null\n+     * @return a string describing for this object, not null\n+     */\n+    public String toString(String format) {\n+        return String.format(format, getClass().getSimpleName(), getLeft(), getRight());\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/lang3/tuple/ImmutablePairTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang3.tuple;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+\n+import org.junit.Test;\n+\n+/**\n+ * Test the Pair class.\n+ * @version $Id$\n+ */\n+public class ImmutablePairTest {\n+\n+    @Test\n+    public void testBasic() throws Exception {\n+        ImmutablePair<Integer, String> pair = new ImmutablePair<Integer, String>(0, \"foo\");\n+        assertEquals(0, pair.left.intValue());\n+        assertEquals(0, pair.getLeft().intValue());\n+        assertEquals(\"foo\", pair.right);\n+        assertEquals(\"foo\", pair.getRight());\n+        ImmutablePair<Object, String> pair2 = new ImmutablePair<Object, String>(null, \"bar\");\n+        assertNull(pair2.left);\n+        assertNull(pair2.getLeft());\n+        assertEquals(\"bar\", pair2.right);\n+        assertEquals(\"bar\", pair2.getRight());\n+    }\n+\n+    @Test\n+    public void testPairOf() throws Exception {\n+        ImmutablePair<Integer, String> pair = ImmutablePair.of(0, \"foo\");\n+        assertEquals(0, pair.left.intValue());\n+        assertEquals(0, pair.getLeft().intValue());\n+        assertEquals(\"foo\", pair.right);\n+        assertEquals(\"foo\", pair.getRight());\n+        ImmutablePair<Object, String> pair2 = ImmutablePair.of(null, \"bar\");\n+        assertNull(pair2.left);\n+        assertNull(pair2.getLeft());\n+        assertEquals(\"bar\", pair2.right);\n+        assertEquals(\"bar\", pair2.getRight());\n+    }\n+\n+    @Test\n+    public void testEquals() throws Exception {\n+        assertEquals(ImmutablePair.of(null, \"foo\"), ImmutablePair.of(null, \"foo\"));\n+        assertFalse(ImmutablePair.of(\"foo\", 0).equals(ImmutablePair.of(\"foo\", null)));\n+        assertFalse(ImmutablePair.of(\"foo\", \"bar\").equals(ImmutablePair.of(\"xyz\", \"bar\")));\n+\n+        ImmutablePair<String, String> p = ImmutablePair.of(\"foo\", \"bar\");\n+        assertTrue(p.equals(p));\n+        assertFalse(p.equals(new Object()));\n+    }\n+\n+    @Test\n+    public void testHashCode() throws Exception {\n+        assertEquals(ImmutablePair.of(null, \"foo\").hashCode(), ImmutablePair.of(null, \"foo\").hashCode());\n+    }\n+\n+    @Test\n+    public void testToString() throws Exception {\n+        assertEquals(\"(null,null)\", ImmutablePair.of(null, null).toString());\n+        assertEquals(\"(null,two)\", ImmutablePair.of(null, \"two\").toString());\n+        assertEquals(\"(one,null)\", ImmutablePair.of(\"one\", null).toString());\n+        assertEquals(\"(one,two)\", ImmutablePair.of(\"one\", \"two\").toString());\n+    }\n+\n+    @Test\n+    @SuppressWarnings(\"unchecked\")\n+    public void testSerialization() throws Exception {\n+        ImmutablePair<Integer, String> origPair = ImmutablePair.of(0, \"foo\");\n+        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+        ObjectOutputStream out = new ObjectOutputStream(baos);\n+        out.writeObject(origPair);\n+        ImmutablePair<Integer, String> deserializedPair = (ImmutablePair<Integer, String>) new ObjectInputStream(\n+                new ByteArrayInputStream(baos.toByteArray())).readObject();\n+        assertEquals(origPair, deserializedPair);\n+        assertEquals(origPair.hashCode(), deserializedPair.hashCode());\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/lang3/tuple/MutablePairTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang3.tuple;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+\n+import org.junit.Test;\n+\n+/**\n+ * Test the MutablePair class.\n+ * @version $Id$\n+ */\n+public class MutablePairTest {\n+\n+    @Test\n+    public void testBasic() throws Exception {\n+        MutablePair<Integer, String> pair = new MutablePair<Integer, String>(0, \"foo\");\n+        assertEquals(0, pair.getLeft().intValue());\n+        assertEquals(\"foo\", pair.getRight());\n+        MutablePair<Object, String> pair2 = new MutablePair<Object, String>(null, \"bar\");\n+        assertNull(pair2.getLeft());\n+        assertEquals(\"bar\", pair2.getRight());\n+    }\n+\n+    @Test\n+    public void testDefault() throws Exception {\n+        MutablePair<Integer, String> pair = new MutablePair<Integer, String>();\n+        assertNull(pair.getLeft());\n+        assertNull(pair.getRight());\n+    }\n+    \n+    @Test\n+    public void testMutate() throws Exception {\n+        MutablePair<Integer, String> pair = new MutablePair<Integer, String>(0, \"foo\");\n+        pair.setLeftElement(42);\n+        pair.setRightElement(\"bar\");\n+        assertEquals(42, pair.getLeft().intValue());\n+        assertEquals(\"bar\", pair.getRight());\n+    }\n+\n+    @Test\n+    public void testPairOf() throws Exception {\n+        MutablePair<Integer, String> pair = MutablePair.of(0, \"foo\");\n+        assertEquals(0, pair.getLeft().intValue());\n+        assertEquals(\"foo\", pair.getRight());\n+        MutablePair<Object, String> pair2 = MutablePair.of(null, \"bar\");\n+        assertNull(pair2.getLeft());\n+        assertEquals(\"bar\", pair2.getRight());\n+    }\n+\n+    @Test\n+    public void testEquals() throws Exception {\n+        assertEquals(MutablePair.of(null, \"foo\"), MutablePair.of(null, \"foo\"));\n+        assertFalse(MutablePair.of(\"foo\", 0).equals(MutablePair.of(\"foo\", null)));\n+        assertFalse(MutablePair.of(\"foo\", \"bar\").equals(MutablePair.of(\"xyz\", \"bar\")));\n+\n+        MutablePair<String, String> p = MutablePair.of(\"foo\", \"bar\");\n+        assertTrue(p.equals(p));\n+        assertFalse(p.equals(new Object()));\n+    }\n+\n+    @Test\n+    public void testHashCode() throws Exception {\n+        assertEquals(MutablePair.of(null, \"foo\").hashCode(), MutablePair.of(null, \"foo\").hashCode());\n+    }\n+\n+    @Test\n+    public void testToString() throws Exception {\n+        assertEquals(\"(null,null)\", MutablePair.of(null, null).toString());\n+        assertEquals(\"(null,two)\", MutablePair.of(null, \"two\").toString());\n+        assertEquals(\"(one,null)\", MutablePair.of(\"one\", null).toString());\n+        assertEquals(\"(one,two)\", MutablePair.of(\"one\", \"two\").toString());\n+    }\n+\n+    @Test\n+    @SuppressWarnings(\"unchecked\")\n+    public void testSerialization() throws Exception {\n+        MutablePair<Integer, String> origPair = MutablePair.of(0, \"foo\");\n+        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+        ObjectOutputStream out = new ObjectOutputStream(baos);\n+        out.writeObject(origPair);\n+        MutablePair<Integer, String> deserializedPair = (MutablePair<Integer, String>) new ObjectInputStream(\n+                new ByteArrayInputStream(baos.toByteArray())).readObject();\n+        assertEquals(origPair, deserializedPair);\n+        assertEquals(origPair.hashCode(), deserializedPair.hashCode());\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/lang3/tuple/PairTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang3.tuple;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map.Entry;\n+\n+import org.junit.Test;\n+\n+/**\n+ * Test the Pair class.\n+ * @version $Id$\n+ */\n+public class PairTest {\n+\n+    @Test\n+    public void testPairOf() throws Exception {\n+        Pair<Integer, String> pair = Pair.of(0, \"foo\");\n+        assertTrue(pair instanceof ImmutablePair<?, ?>);\n+        assertEquals(0, ((ImmutablePair<Integer, String>) pair).left.intValue());\n+        assertEquals(\"foo\", ((ImmutablePair<Integer, String>) pair).right);\n+        Pair<Object, String> pair2 = Pair.of(null, \"bar\");\n+        assertTrue(pair2 instanceof ImmutablePair<?, ?>);\n+        assertNull(((ImmutablePair<Object, String>) pair2).left);\n+        assertEquals(\"bar\", ((ImmutablePair<Object, String>) pair2).right);\n+    }\n+\n+    @Test\n+    public void testCompatibilityBetweenPairs() throws Exception {\n+        Pair<Integer, String> pair = ImmutablePair.of(0, \"foo\");\n+        Pair<Integer, String> pair2 = MutablePair.of(0, \"foo\");\n+        assertEquals(pair, pair2);\n+        assertEquals(pair.hashCode(), pair2.hashCode());\n+        HashSet<Pair<Integer, String>> set = new HashSet<Pair<Integer, String>>();\n+        set.add(pair);\n+        assertTrue(set.contains(pair2));\n+\n+        pair2.setValue(\"bar\");\n+        assertFalse(pair.equals(pair2));\n+        assertFalse(pair.hashCode() == pair2.hashCode());\n+    }\n+\n+    @Test\n+    public void testMapEntry() throws Exception {\n+        Pair<Integer, String> pair = ImmutablePair.of(0, \"foo\");\n+        HashMap<Integer, String> map = new HashMap<Integer, String>();\n+        map.put(0, \"foo\");\n+        Entry<Integer, String> entry = map.entrySet().iterator().next();\n+        assertEquals(pair, entry);\n+        assertEquals(pair.hashCode(), entry.hashCode());\n+    }\n+\n+    @Test\n+    public void testComparable1() throws Exception {\n+        Pair<String, String> pair1 = Pair.of(\"A\", \"D\");\n+        Pair<String, String> pair2 = Pair.of(\"B\", \"C\");\n+        assertEquals(true, pair1.compareTo(pair1) == 0);\n+        assertEquals(true, pair1.compareTo(pair2) < 0);\n+        assertEquals(true, pair2.compareTo(pair2) == 0);\n+        assertEquals(true, pair2.compareTo(pair1) > 0);\n+    }\n+\n+    @Test\n+    public void testComparable2() throws Exception {\n+        Pair<String, String> pair1 = Pair.of(\"A\", \"C\");\n+        Pair<String, String> pair2 = Pair.of(\"A\", \"D\");\n+        assertEquals(true, pair1.compareTo(pair1) == 0);\n+        assertEquals(true, pair1.compareTo(pair2) < 0);\n+        assertEquals(true, pair2.compareTo(pair2) == 0);\n+        assertEquals(true, pair2.compareTo(pair1) > 0);\n+    }\n+\n+    @Test\n+    public void testToString() throws Exception {\n+        Pair<String, String> pair = Pair.of(\"Key\", \"Value\");\n+        assertEquals(\"(Key,Value)\", pair.toString());\n+    }\n+\n+    @Test\n+    public void testToStringFormat() throws Exception {\n+        Pair<String, String> pair = Pair.of(\"Key\", \"Value\");\n+        assertEquals(\"ImmutablePair\", pair.toString(\"%1$s\"));\n+        assertEquals(\"Key\", pair.toString(\"%2$s\"));\n+        assertEquals(\"Value\", pair.toString(\"%3$s\"));\n+        assertEquals(\"Key: Value\", pair.toString(\"%2$s: %3$s\"));\n+        pair = Pair.of(null, null);\n+        assertEquals(\"null: null\", pair.toString(\"%2$s: %3$s\"));\n+    }\n+\n+}", "timestamp": 1302632989, "metainfo": ""}