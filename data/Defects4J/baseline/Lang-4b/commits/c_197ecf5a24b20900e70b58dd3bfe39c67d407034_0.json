{"sha": "197ecf5a24b20900e70b58dd3bfe39c67d407034", "log": "LANG-829 FastDateParser could use Calendar.getDisplayNames for all text fields Remove unnecessary KeyValue instances  ", "commit": "\n--- a/src/main/java/org/apache/commons/lang3/time/FastDateParser.java\n+++ b/src/main/java/org/apache/commons/lang3/time/FastDateParser.java\n import java.text.ParseException;\n import java.text.ParsePosition;\n import java.util.ArrayList;\n-import java.util.Arrays;\n import java.util.Calendar;\n-import java.util.Comparator;\n import java.util.Date;\n import java.util.List;\n import java.util.Locale;\n         return regex;\n     }\n \n-    /**\n-     * A class to store Key / Value pairs\n-     */\n-    private static class KeyValue {\n-        public String key;\n-        public int value;\n-\n-        /**\n-         * Construct a Key / Value pair\n-         * @param key The key\n-         * @param value The value\n-         */\n-        public KeyValue(String key, int value) {\n-            this.key= key;\n-            this.value= value;\n-        }\n-    }\n-\n-    /**\n-     * ignore case comparison of keys\n-     */\n-    private static final Comparator<KeyValue> IGNORE_CASE_COMPARATOR = new Comparator<KeyValue> () {\n-        @Override\n-        public int compare(KeyValue left, KeyValue right) {\n-            return left.key.compareToIgnoreCase(right.key);\n-        }\n-    };\n \n     /**\n      * Get the short and long values displayed for a field\n      * @param field The field of interest\n      * @param definingCalendar The calendar to obtain the short and long values\n-     * @param locale The locale of dislay names\n-     * @return A sorted array of the field key / value pairs\n-     */\n-    private static KeyValue[] getDisplayNames(int field, Calendar definingCalendar, Locale locale) {\n-\t\tList<KeyValue> keyValues = new ArrayList<KeyValue>(24);\n-\t\taddNamesToKeyValues(keyValues, definingCalendar.getDisplayNames(field, Calendar.ALL_STYLES, locale));\n-        return createKeyValues(keyValues);\n-    }\n-\n-\tprivate static void addNamesToKeyValues(List<KeyValue> keyValues, Map<String, Integer> displayNames) {\n-        for(Map.Entry<String, Integer> me : displayNames.entrySet()) {\n-        \tkeyValues.add(new KeyValue(me.getKey(), me.getValue()));\n-        }\n-    }\n-\n-    private static KeyValue[] createKeyValues(List<KeyValue> keyValues) {\n-        KeyValue[] fieldKeyValues= keyValues.toArray(new KeyValue[keyValues.size()]);\n-        Arrays.sort(fieldKeyValues, IGNORE_CASE_COMPARATOR);\n-        return fieldKeyValues;\n+     * @param locale The locale of display names\n+     * @return A Map of the field key / value pairs\n+     */\n+    private static Map<String, Integer> getDisplayNames(int field, Calendar definingCalendar, Locale locale) {\n+        return definingCalendar.getDisplayNames(field, Calendar.ALL_STYLES, locale);\n     }\n \n     /**\n         }\n     }\n \n-    @SuppressWarnings(\"unchecked\")\n+    @SuppressWarnings(\"unchecked\") // OK because we are creating an array with no entries\n     private static ConcurrentMap<Locale, Strategy>[] caches = new ConcurrentMap[Calendar.FIELD_COUNT];\n \n     /**\n      */\n     private Strategy getLocaleSpecificStrategy(int field, Calendar definingCalendar) {\n     \tConcurrentMap<Locale,Strategy> cache = getCache(field);\n-    \tStrategy strategy= cache.get(field);\n+    \tStrategy strategy= cache.get(Integer.valueOf(field));\n         if(strategy==null) {\n         \tstrategy= field==Calendar.ZONE_OFFSET\n         \t\t\t? new TimeZoneStrategy(locale)\n      */\n      private static class TextStrategy implements Strategy {\n         private final int field;\n-        private final KeyValue[] keyValues;\n+        private final Map<String, Integer> keyValues;\n \n         /**\n          * Construct a Strategy that parses a Text field\n         @Override\n         public boolean addRegex(FastDateParser parser, StringBuilder regex) {\n             regex.append('(');\n-            for(KeyValue textKeyValue : keyValues) {\n-                escapeRegex(regex, textKeyValue.key, false).append('|');\n+            for(String textKeyValue : keyValues.keySet()) {\n+                escapeRegex(regex, textKeyValue, false).append('|');\n             }\n             regex.setCharAt(regex.length()-1, ')');\n             return true;\n          */\n         @Override\n         public void setCalendar(FastDateParser parser, Calendar cal, String value) {\n-            int idx= Arrays.binarySearch(keyValues, new KeyValue(value, -1), IGNORE_CASE_COMPARATOR);\n-            if(idx<0) {\n+            Integer iVal = keyValues.get(value);\n+            if(iVal == null) {\n                 StringBuilder sb= new StringBuilder(value);\n                 sb.append(\" not in (\");\n-                for(KeyValue textKeyValue : keyValues) {\n-                    sb.append(textKeyValue.key).append(' ');\n+                for(String textKeyValue : keyValues.keySet()) {\n+                    sb.append(textKeyValue).append(' ');\n                 }\n                 sb.setCharAt(sb.length()-1, ')');\n                 throw new IllegalArgumentException(sb.toString());\n             }\n-            cal.set(field, keyValues[idx].value);\n+            cal.set(field, iVal.intValue());\n         }\n     }\n ", "timestamp": 1348743570, "metainfo": ""}