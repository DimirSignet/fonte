{"sha": "0039c00bf112d8004cbec6c6d8ffae3c2c7aef39", "log": "Add method to allow update to list of recognised exception method names Javadoc Formatting   ", "commit": "\n--- a/src/java/org/apache/commons/lang/exception/ExceptionUtils.java\n+++ b/src/java/org/apache/commons/lang/exception/ExceptionUtils.java\n-package org.apache.commons.lang.exception;\n-\n /* ====================================================================\n  * The Apache Software License, Version 1.1\n  *\n  * information on the Apache Software Foundation, please see\n  * <http://www.apache.org/>.\n  */\n+package org.apache.commons.lang.exception;\n \n import java.io.PrintStream;\n import java.io.PrintWriter;\n import java.lang.reflect.Method;\n import java.sql.SQLException;\n import java.util.ArrayList;\n+import java.util.Arrays;\n import java.util.LinkedList;\n import java.util.List;\n import java.util.StringTokenizer;\n \n+import org.apache.commons.lang.ArrayUtils;\n import org.apache.commons.lang.SystemUtils;\n \n /**\n- * Utility routines for manipulating <code>Throwable</code> objects.\n+ * <p><code>ExceptionUtils</code> provides utilities for manipulating \n+ * <code>Throwable</code> objects.</p>\n  *\n  * @author <a href=\"mailto:dlr@finemaltcoding.com\">Daniel Rall</a>\n+ * @author Dmitri Plotnikov\n+ * @author Stephen Colebourne\n  * @since 1.0\n+ * @version $Id: ExceptionUtils.java,v 1.19 2002/12/23 00:03:47 scolebourne Exp $\n  */\n-public class ExceptionUtils\n-{\n+public class ExceptionUtils {\n     /**\n      * The names of methods commonly used to access a wrapped\n      * exception.\n      */\n-    protected static final String[] CAUSE_METHOD_NAMES =\n-    {\n+    protected static String[] CAUSE_METHOD_NAMES = {\n         \"getCause\",\n         \"getNextException\",\n         \"getTargetException\",\n         \"getException\",\n         \"getSourceException\",\n         \"getRootCause\",\n-        \"getCausedByException\"\n+        \"getCausedByException\",\n+        \"getNested\"\n     };\n \n     /**\n-     * The empty parameter list passed to methods used to access a\n-     * wrapped exception.\n-     */\n-    protected static final Object[] CAUSE_METHOD_PARAMS = {};\n-\n-    /**\n-     * Constructs a new <code>ExceptionUtils</code>.  Protected to\n+     * Constructs a new <code>ExceptionUtils</code>. Protected to\n      * discourage instantiation.\n      */\n-    protected ExceptionUtils()\n-    {\n-    }\n-    \n-    /**\n-     * Introspects the specified <code>Throwable</code> for a\n-     * <code>getCause()</code>, <code>getNextException()</code>,\n-     * <code>getTargetException()</code>, or\n-     * <code>getException()</code> method which returns a\n-     * <code>Throwable</code> object (standard as of JDK 1.4, and part\n-     * of the {@link\n-     * org.apache.commons.lang.exception.NestableException} API),\n-     * extracting and returning the cause of the exception.  In the\n-     * absence of any such method, the object is inspected for a\n-     * <code>detail</code> field assignable to a\n-     * <code>Throwable</code>.  If none of the above is found, returns\n-     * <code>null</code>.\n-     *\n-     * @param t The exception to introspect for a cause.\n+    protected ExceptionUtils() {\n+    }\n+\n+    /**\n+     * <p>Adds to the list of method names used in the search for <code>Throwable</code>\n+     * objects.</p>\n+     * \n+     * @param methodName  the methodName to add to the list, null and empty strings are ignored\n+     */\n+    public static void addCauseMethodName(String methodName) {\n+        if (methodName != null && methodName.length() > 0) {\n+            List list = new ArrayList(Arrays.asList(CAUSE_METHOD_NAMES));\n+            list.add(methodName);\n+            CAUSE_METHOD_NAMES = (String[]) list.toArray(new String[list.size()]);\n+        }\n+    }\n+\n+    /**\n+     * <p>Introspects the specified <code>Throwable</code> to obtain the cause.</p>\n+     * \n+     * <p>The method searches for methods with specific names that return a \n+     * <code>Throwable</code> object. This will pick up most wrapping exceptions,\n+     * including those from JDK 1.4, and\n+     * {@link org.apache.commons.lang.exception.NestableException NestableException}.\n+     * The method names can be added to using {@link #addCauseMethodName(String)}.\n+     * The default list searched for are:</p>\n+     * <ul>\n+     * <li><code>getCause()</code>\n+     * <li><code>getNextException()</code>\n+     * <li><code>getTargetException()</code>\n+     * <li><code>getException()</code>\n+     * <li><code>getSourceException()</code>\n+     * <li><code>getRootCause()</code>\n+     * <li><code>getCausedByException()</code>\n+     * <li><code>getNested()</code>\n+     * </ul>\n+     * \n+     * <p>In the absence of any such method, the object is inspected for a\n+     * <code>detail</code> field assignable to a <code>Throwable</code>.</p>\n+     * \n+     * <p>If none of the above is found, returns <code>null</code>.</p>\n+     *\n+     * @param throwable The exception to introspect for a cause.\n      * @return The cause of the <code>Throwable</code>.\n-     */\n-    public static Throwable getCause(Throwable t)\n-    {\n-        return getCause(t, CAUSE_METHOD_NAMES);\n-    }\n-    \n-    /**\n-     * Extends the API of {@link #getCause(Throwable)} by\n-     * introspecting for only user-specified method names.\n-     *\n-     * @see #getCause(Throwable)\n-     */\n-    public static Throwable getCause(Throwable t, String[] methodNames)\n-    {\n-        Throwable cause = getCauseUsingWellKnownTypes(t);\n-        if (cause == null)\n-        {\n-            for (int i = 0; i < methodNames.length; i++)\n-            {\n-                cause = getCauseUsingMethodName(t, methodNames[i]);\n-                if (cause != null)\n-                {\n+     * @throws NullPointerException if the throwable is null\n+     */\n+    public static Throwable getCause(Throwable throwable) {\n+        return getCause(throwable, CAUSE_METHOD_NAMES);\n+    }\n+\n+    /**\n+     * <p>Introspects the specified <code>Throwable</code> to obtain the cause\n+     * using a supplied array of method names.</p>\n+     *\n+     * @param throwable The exception to introspect for a cause.\n+     * @return The cause of the <code>Throwable</code>.\n+     * @throws NullPointerException if the method names array is null or contains null\n+     * @throws NullPointerException if the throwable is null\n+     */\n+    public static Throwable getCause(Throwable throwable, String[] methodNames) {\n+        Throwable cause = getCauseUsingWellKnownTypes(throwable);\n+        if (cause == null) {\n+            for (int i = 0; i < methodNames.length; i++) {\n+                cause = getCauseUsingMethodName(throwable, methodNames[i]);\n+                if (cause != null) {\n                     break;\n                 }\n             }\n \n-            if (cause == null)\n-            {\n-                cause = getCauseUsingFieldName(t, \"detail\");\n+            if (cause == null) {\n+                cause = getCauseUsingFieldName(throwable, \"detail\");\n             }\n         }\n         return cause;\n     }\n-    \n-    /**\n-     * Walks through the exception chain to the last element -- the\n+\n+    /**\n+     * <p>Walks through the exception chain to the last element -- the\n      * \"root\" of the tree -- using {@link #getCause(Throwable)}, and\n-     * returns that exception.\n-     *\n+     * returns that exception.</p>\n+     *\n+     * @param throwable  the throwable to get the root cause for\n      * @return The root cause of the <code>Throwable</code>.\n-     * @see #getCause(Throwable)\n-     */\n-    public static Throwable getRootCause(Throwable t)\n-    {\n-        Throwable cause = getCause(t);\n-        if (cause != null)\n-        {\n-            t = cause;\n-            while ((t = getCause(t)) != null)\n-            {\n-                cause = t;\n+     */\n+    public static Throwable getRootCause(Throwable throwable) {\n+        Throwable cause = getCause(throwable);\n+        if (cause != null) {\n+            throwable = cause;\n+            while ((throwable = getCause(throwable)) != null) {\n+                cause = throwable;\n             }\n         }\n         return cause;\n     }\n \n     /**\n-     * Uses <code>instanceof</code> checks to examine the exception,\n+     * <p>Uses <code>instanceof</code> checks to examine the exception,\n      * looking for well known types which could contain chained or\n-     * wrapped exceptions.\n-     *\n-     * @param t The exception to examine.\n+     * wrapped exceptions.</p>\n+     *\n+     * @param throwable  the exception to examine\n      * @return The wrapped exception, or <code>null</code> if not\n      * found.\n      */\n-    private static Throwable getCauseUsingWellKnownTypes(Throwable t)\n-    {\n-        if (t instanceof Nestable)\n-        {\n-            return ((Nestable) t).getCause();\n-        }\n-        else if (t instanceof SQLException)\n-        {\n-            return ((SQLException) t).getNextException();\n-        }\n-        else if (t instanceof InvocationTargetException)\n-        {\n-            return ((InvocationTargetException) t).getTargetException();\n-        }\n-        else\n-        {\n+    private static Throwable getCauseUsingWellKnownTypes(Throwable throwable) {\n+        if (throwable instanceof Nestable) {\n+            return ((Nestable) throwable).getCause();\n+        } else if (throwable instanceof SQLException) {\n+            return ((SQLException) throwable).getNextException();\n+        } else if (throwable instanceof InvocationTargetException) {\n+            return ((InvocationTargetException) throwable).getTargetException();\n+        } else {\n             return null;\n         }\n     }\n \n     /**\n-     * @param t The exception to examine.\n-     * @param methodName The name of the method to find and invoke.\n+     * <p>Find a throwable by method name.</p>\n+     * \n+     * @param throwable  the exception to examine\n+     * @param methodName  the name of the method to find and invoke\n      * @return The wrapped exception, or <code>null</code> if not\n      * found.\n      */\n-    private static Throwable getCauseUsingMethodName(Throwable t,\n-                                                     String methodName)\n-    {\n+    private static Throwable getCauseUsingMethodName(Throwable throwable, String methodName) {\n         Method method = null;\n-        try\n-        {\n-            method = t.getClass().getMethod(methodName, null);\n-        }\n-        catch (NoSuchMethodException ignored)\n-        {\n-        }\n-        catch (SecurityException ignored)\n-        {\n-        }\n-\n-        if (method != null &&\n-            Throwable.class.isAssignableFrom(method.getReturnType()))\n-        {\n-            try\n-            {\n-                return (Throwable) method.invoke(t, CAUSE_METHOD_PARAMS);\n-            }\n-            catch (IllegalAccessException ignored)\n-            {\n-            }\n-            catch (IllegalArgumentException ignored)\n-            {\n-            }\n-            catch (InvocationTargetException ignored)\n-            {\n+        try {\n+            method = throwable.getClass().getMethod(methodName, null);\n+        } catch (NoSuchMethodException ignored) {\n+        } catch (SecurityException ignored) {\n+        }\n+\n+        if (method != null && Throwable.class.isAssignableFrom(method.getReturnType())) {\n+            try {\n+                return (Throwable) method.invoke(throwable, ArrayUtils.EMPTY_OBJECT_ARRAY);\n+            } catch (IllegalAccessException ignored) {\n+            } catch (IllegalArgumentException ignored) {\n+            } catch (InvocationTargetException ignored) {\n             }\n         }\n         return null;\n     }\n \n     /**\n-     * @param t The exception to examine.\n-     * @param fieldName The name of the attribute to examine.\n+     * <p>Find a throwable by field name.</p>\n+     * \n+     * @param throwable  the exception to examine\n+     * @param fieldName  the name of the attribute to examine\n      * @return The wrapped exception, or <code>null</code> if not\n      * found.\n      */\n-    private static Throwable getCauseUsingFieldName(Throwable t,\n-                                                    String fieldName)\n-    {\n+    private static Throwable getCauseUsingFieldName(Throwable throwable, String fieldName) {\n         Field field = null;\n-        try\n-        {\n-            field = t.getClass().getField(fieldName);\n-        }\n-        catch (NoSuchFieldException ignored)\n-        {\n-        }\n-        catch (SecurityException ignored)\n-        {\n-        }\n-\n-        if (field != null &&\n-            Throwable.class.isAssignableFrom(field.getType()))\n-        {\n-            try\n-            {\n-                return (Throwable) field.get(t);\n-            }\n-            catch (IllegalAccessException ignored)\n-            {\n-            }\n-            catch (IllegalArgumentException ignored)\n-            {\n+        try {\n+            field = throwable.getClass().getField(fieldName);\n+        } catch (NoSuchFieldException ignored) {\n+        } catch (SecurityException ignored) {\n+        }\n+\n+        if (field != null && Throwable.class.isAssignableFrom(field.getType())) {\n+            try {\n+                return (Throwable) field.get(throwable);\n+            } catch (IllegalAccessException ignored) {\n+            } catch (IllegalArgumentException ignored) {\n             }\n         }\n         return null;\n     }\n \n     /**\n-     * Returns the number of <code>Throwable</code> objects in the\n-     * exception chain.\n-     *\n-     * @param t The exception to inspect.\n+     * <p>Returns the number of <code>Throwable</code> objects in the\n+     * exception chain.</p>\n+     *\n+     * @param throwable  the exception to inspect\n      * @return The throwable count.\n      */\n-    public static int getThrowableCount(Throwable t)\n-    {\n+    public static int getThrowableCount(Throwable throwable) {\n         // Count the number of throwables\n         int count = 0;\n-        while (t != null)\n-        {\n+        while (throwable != null) {\n             count++;\n-            t = ExceptionUtils.getCause(t);\n+            throwable = ExceptionUtils.getCause(throwable);\n         }\n         return count;\n     }\n \n     /**\n-     * Returns the list of <code>Throwable</code> objects in the\n-     * exception chain.\n-     *\n-     * @param t The exception to inspect.\n+     * <p>Returns the list of <code>Throwable</code> objects in the\n+     * exception chain.</p>\n+     *\n+     * @param throwable  the exception to inspect\n      * @return The list of <code>Throwable</code> objects.\n      */\n-    public static Throwable[] getThrowables(Throwable t)\n-    {\n+    public static Throwable[] getThrowables(Throwable throwable) {\n         List list = new ArrayList();\n-        while (t != null)\n-        {\n-            list.add(t);\n-            t = ExceptionUtils.getCause(t);\n-        }\n-        return (Throwable []) list.toArray(new Throwable[list.size()]);\n-    }\n-\n-    /**\n-     * Delegates to {@link #indexOfThrowable(Throwable, Class, int)},\n-     * starting the search at the beginning of the exception chain.\n+        while (throwable != null) {\n+            list.add(throwable);\n+            throwable = ExceptionUtils.getCause(throwable);\n+        }\n+        return (Throwable[]) list.toArray(new Throwable[list.size()]);\n+    }\n+\n+    /**\n+     * <p>Delegates to {@link #indexOfThrowable(Throwable, Class, int)},\n+     * starting the search at the beginning of the exception chain.</p>\n      *\n      * @see #indexOfThrowable(Throwable, Class, int)\n      */\n-    public static int indexOfThrowable(Throwable t, Class type)\n-    {\n-        return indexOfThrowable(t, type, 0);\n-    }\n-\n-    /**\n-     * Returns the (zero based) index, of the first\n+    public static int indexOfThrowable(Throwable throwable, Class type) {\n+        return indexOfThrowable(throwable, type, 0);\n+    }\n+\n+    /**\n+     * <p>Returns the (zero based) index, of the first\n      * <code>Throwable</code> that matches the specified type in the\n      * exception chain of <code>Throwable</code> objects with an index\n      * greater than or equal to the specified index, or\n-     * <code>-1</code> if the type is not found.\n-     *\n-     * @param t The exception to inspect.\n-     * @param type <code>Class</code> to look for.\n-     * @param fromIndex The (zero based) index of the starting\n-     * position in the chain to be searched.\n-     * @return index The first occurrence of the type in the chain, or\n-     * <code>-1</code> if the type is not found.\n+     * <code>-1</code> if the type is not found.</p>\n+     *\n+     * @param throwable  the exception to inspect\n+     * @param type  <code>Class</code> to look for\n+     * @param fromIndex  the (zero based) index of the starting\n+     *  position in the chain to be searched\n+     * @return the first occurrence of the type in the chain, or\n+     *  <code>-1</code> if the type is not found\n      * @throws IndexOutOfBoundsException If the <code>fromIndex</code>\n-     * argument is negative or not less than the count of\n-     * <code>Throwable</code>s in the chain.\n-     */\n-    public static int indexOfThrowable(Throwable t, Class type, int fromIndex)\n-    {\n-        if (fromIndex < 0)\n-        {\n-            throw new IndexOutOfBoundsException\n-                (\"Throwable index out of range: \" + fromIndex);\n-        }\n-        Throwable[] throwables = ExceptionUtils.getThrowables(t);\n-        if (fromIndex >= throwables.length)\n-        {\n-            throw new IndexOutOfBoundsException\n-                (\"Throwable index out of range: \" + fromIndex);\n-        }\n-        for (int i = fromIndex; i < throwables.length; i++)\n-        {\n-            if (throwables[i].getClass().equals(type))\n-            {\n+     *  argument is negative or not less than the count of\n+     *  <code>Throwable</code>s in the chain.\n+     */\n+    public static int indexOfThrowable(Throwable throwable, Class type, int fromIndex) {\n+        if (fromIndex < 0) {\n+            throw new IndexOutOfBoundsException(\"Throwable index out of range: \" + fromIndex);\n+        }\n+        Throwable[] throwables = ExceptionUtils.getThrowables(throwable);\n+        if (fromIndex >= throwables.length) {\n+            throw new IndexOutOfBoundsException(\"Throwable index out of range: \" + fromIndex);\n+        }\n+        for (int i = fromIndex; i < throwables.length; i++) {\n+            if (throwables[i].getClass().equals(type)) {\n                 return i;\n             }\n         }\n         return -1;\n     }\n-    \n+\n     /**\n      * Prints a compact stack trace for the root cause of a throwable.\n      * The compact stack trace starts with the root cause and prints\n      * The method is equivalent to t.printStackTrace() for throwables\n      * that don't have nested causes.\n      */\n-    public static void printRootCauseStackTrace(Throwable t, PrintStream stream)\n-    {\n+    public static void printRootCauseStackTrace(Throwable t, PrintStream stream) {\n         String trace[] = getRootCauseStackTrace(t);\n-        for (int i = 0; i < trace.length; i++){\n+        for (int i = 0; i < trace.length; i++) {\n             stream.println(trace[i]);\n         }\n         stream.flush();\n     }\n-    \n+\n     /**\n      * Equivalent to printRootCauseStackTrace(t, System.err)\n      */\n-    public static void printRootCauseStackTrace(Throwable t)\n-    {\n+    public static void printRootCauseStackTrace(Throwable t) {\n         printRootCauseStackTrace(t, System.err);\n     }\n \n      * Same as printRootCauseStackTrace(t, stream), except it takes\n      * a PrintWriter as an argument.\n      */\n-    public static void printRootCauseStackTrace(Throwable t, PrintWriter writer)\n-    {\n+    public static void printRootCauseStackTrace(Throwable t, PrintWriter writer) {\n         String trace[] = getRootCauseStackTrace(t);\n-        for (int i = 0; i < trace.length; i++){\n+        for (int i = 0; i < trace.length; i++) {\n             writer.println(trace[i]);\n         }\n         writer.flush();\n     }\n-\n \n     /**\n      * Creates a compact stack trace for the root cause of the supplied \n      * throwable.\n      *   \n-     * See <code>printRootCauseStackTrace(Throwable t, PrintStream s)</code> \n-     */\n-    public static String[] getRootCauseStackTrace(Throwable t)\n-    {\n+     * See <code>printRootCauseStackTrace(Throwable t, PrintStream s)</code> \n+     */\n+    public static String[] getRootCauseStackTrace(Throwable t) {\n         Throwable throwables[] = getThrowables(t);\n-        int count = throwables.length;        \n+        int count = throwables.length;\n         ArrayList frames = new ArrayList();\n-        List nextTrace = getStackFrameList(throwables[count-1]);        \n-        for (int i = count; --i >= 0;){\n+        List nextTrace = getStackFrameList(throwables[count - 1]);\n+        for (int i = count; --i >= 0;) {\n             List trace = nextTrace;\n-            if (i != 0){\n-                nextTrace = getStackFrameList(throwables[i-1]);\n+            if (i != 0) {\n+                nextTrace = getStackFrameList(throwables[i - 1]);\n                 removeCommonFrames(trace, nextTrace);\n             }\n-            if (i == count - 1){\n+            if (i == count - 1) {\n                 frames.add(throwables[i].toString());\n-            }\n-            else {\n+            } else {\n                 frames.add(\" [wrapped] \" + throwables[i].toString());\n             }\n-            for (int j = 0; j < trace.size(); j++){\n+            for (int j = 0; j < trace.size(); j++) {\n                 frames.add(trace.get(j));\n             }\n         }\n \n     /**\n      * Given two stack traces, removes common frames from the cause trace.\n-     * \n-     * @param causeFrames   stack trace of a cause throwable\n-     * @param wrapperFrames stack trace of a wrapper throwable \n-     */\n-    private static void removeCommonFrames(List causeFrames, List wrapperFrames)\n-    {\n-        int causeFrameIndex = causeFrames.size() - 1; \n+     * \n+     * @param causeFrames   stack trace of a cause throwable\n+     * @param wrapperFrames stack trace of a wrapper throwable \n+     */\n+    private static void removeCommonFrames(List causeFrames, List wrapperFrames) {\n+        int causeFrameIndex = causeFrames.size() - 1;\n         int wrapperFrameIndex = wrapperFrames.size() - 1;\n-        while (causeFrameIndex >= 0 && wrapperFrameIndex >= 0)\n-        {\n+        while (causeFrameIndex >= 0 && wrapperFrameIndex >= 0) {\n             // Remove the frame from the cause trace if it is the same\n             // as in the wrapper trace\n-            String causeFrame = (String)causeFrames.get(causeFrameIndex);\n-            String wrapperFrame = (String)wrapperFrames.get(wrapperFrameIndex);\n-            if (causeFrame.equals(wrapperFrame)){\n+            String causeFrame = (String) causeFrames.get(causeFrameIndex);\n+            String wrapperFrame = (String) wrapperFrames.get(wrapperFrameIndex);\n+            if (causeFrame.equals(wrapperFrame)) {\n                 causeFrames.remove(causeFrameIndex);\n             }\n             causeFrameIndex--;\n             wrapperFrameIndex--;\n         }\n     }\n-    \n+\n     /**\n      * A convenient way of extracting the stack trace from an\n      * exception.\n      * @return The stack trace as generated by the exception's\n      * <code>printStackTrace(PrintWriter)</code> method.\n      */\n-    public static String getStackTrace(Throwable t)\n-    {\n+    public static String getStackTrace(Throwable t) {\n         StringWriter sw = new StringWriter();\n         PrintWriter pw = new PrintWriter(sw, true);\n         t.printStackTrace(pw);\n      * @param t The <code>Throwable</code>.\n      * @return  An array of strings describing each stack frame.\n      */\n-    public static String[] getStackFrames(Throwable t)\n-    {\n+    public static String[] getStackFrames(Throwable t) {\n         return getStackFrames(getStackTrace(t));\n     }\n \n      * {@link org.apache.commons.lang.exception.NestableDelegate}\n      * classes.\n      */\n-    static String[] getStackFrames(String stackTrace)\n-    {\n+    static String[] getStackFrames(String stackTrace) {\n         String linebreak = SystemUtils.LINE_SEPARATOR;\n         StringTokenizer frames = new StringTokenizer(stackTrace, linebreak);\n         List list = new LinkedList();\n-        while (frames.hasMoreTokens())\n-        {\n+        while (frames.hasMoreTokens()) {\n             list.add(frames.nextToken());\n         }\n-        return (String []) list.toArray(new String[] {});\n-    }\n-    \n+        return (String[]) list.toArray(new String[] {\n+        });\n+    }\n+\n     /**\n      * Produces a List of stack frames - the message is not included.\n      * This works in most cases - it will only fail if the exception message\n      * contains a line that starts with:  \"   at\".\n-     * \n-     * @param t is any throwable\n-     * @return List of stack frames\n-     */\n-    static List getStackFrameList(Throwable t){\n+     * \n+     * @param t is any throwable\n+     * @return List of stack frames\n+     */\n+    static List getStackFrameList(Throwable t) {\n         String stackTrace = getStackTrace(t);\n         String linebreak = SystemUtils.LINE_SEPARATOR;\n         StringTokenizer frames = new StringTokenizer(stackTrace, linebreak);\n         List list = new LinkedList();\n         boolean traceStarted = false;\n-        while (frames.hasMoreTokens())\n-        {\n-            String token = frames.nextToken(); \n+        while (frames.hasMoreTokens()) {\n+            String token = frames.nextToken();\n             // Determine if the line starts with <whitespace>at\n             int at = token.indexOf(\"at\");\n-            if (at != -1 && token.substring(0, at).trim().length() == 0){\n+            if (at != -1 && token.substring(0, at).trim().length() == 0) {\n                 traceStarted = true;\n                 list.add(token);\n-            }\n-            else if (traceStarted){\n+            } else if (traceStarted) {\n                 break;\n             }\n         }", "timestamp": 1040601827, "metainfo": ""}