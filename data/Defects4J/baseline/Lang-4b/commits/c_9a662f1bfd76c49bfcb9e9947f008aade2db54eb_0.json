{"sha": "9a662f1bfd76c49bfcb9e9947f008aade2db54eb", "log": "Fixed numeric problems reported in PR #29294 Submitted by: C. Scott Ananian Reviewed by: Phil Steitz   ", "commit": "\n--- a/src/java/org/apache/commons/lang/math/Fraction.java\n+++ b/src/java/org/apache/commons/lang/math/Fraction.java\n package org.apache.commons.lang.math;\n \n import java.io.Serializable;\n+import java.math.BigInteger;\n \n /**\n  * <p><code>Fraction</code> is a <code>Number</code> implementation that\n  * @author Stephen Colebourne\n  * @author Tim O'Brien\n  * @author Pete Gieser\n+ * @author C. Scott Ananian\n  * @since 2.0\n- * @version $Id: Fraction.java,v 1.13 2004/02/18 22:56:13 ggregory Exp $\n+ * @version $Id: Fraction.java,v 1.14 2004/07/11 23:20:17 psteitz Exp $\n  */\n public final class Fraction extends Number implements Serializable, Comparable {\n \n             throw new ArithmeticException(\"The denominator must not be zero\");\n         }\n         if (denominator < 0) {\n+            if (numerator==Integer.MIN_VALUE ||\n+                    denominator==Integer.MIN_VALUE) {\n+                throw new ArithmeticException(\"overflow: can't negate\");\n+            }\n             numerator = -numerator;\n             denominator = -denominator;\n         }\n      * @param denominator  the denominator, for example the seven in 'one and three sevenths'\n      * @return a new fraction instance\n      * @throws ArithmeticException if the denomiator is <code>zero</code>\n-     * @throws ArithmeticException if the denomiator is negative\n+     * @throws ArithmeticException if the denominator is negative\n      * @throws ArithmeticException if the numerator is negative\n      * @throws ArithmeticException if the resulting numerator exceeds \n      *  <code>Integer.MAX_VALUE</code>\n         if (numerator < 0) {\n             throw new ArithmeticException(\"The numerator must not be negative\");\n         }\n-        double numeratorValue = 0;\n+        long numeratorValue;\n         if (whole < 0) {\n-            numeratorValue = (double) whole * denominator - numerator;\n+            numeratorValue = whole * (long)denominator - numerator;\n         } else {\n-            numeratorValue = (double) whole * denominator + numerator;\n-        }\n-        if (Math.abs(numeratorValue) > Integer.MAX_VALUE) {\n+            numeratorValue = whole * (long)denominator + numerator;\n+        }\n+        if (numeratorValue < Integer.MIN_VALUE ||\n+                numeratorValue > Integer.MAX_VALUE)  {\n             throw new ArithmeticException(\"Numerator too large to represent as an Integer.\");\n         }\n         return new Fraction((int) numeratorValue, denominator);\n      * @param numerator  the numerator, for example the three in 'three sevenths'\n      * @param denominator  the denominator, for example the seven in 'three sevenths'\n      * @return a new fraction instance, with the numerator and denominator reduced\n-     * @throws ArithmeticException if the denomiator is <code>zero</code>\n+     * @throws ArithmeticException if the denominator is <code>zero</code>\n      */\n     public static Fraction getReducedFraction(int numerator, int denominator) {\n         if (denominator == 0) {\n             throw new ArithmeticException(\"The denominator must not be zero\");\n         }\n+        if (numerator==0) {\n+            return ZERO; // normalize zero.\n+        }\n+        // allow 2^k/-2^31 as a valid fraction (where k>0)\n+        if (denominator==Integer.MIN_VALUE && (numerator&1)==0) {\n+            numerator/=2; denominator/=2;\n+        }\n         if (denominator < 0) {\n+            if (numerator==Integer.MIN_VALUE ||\n+                    denominator==Integer.MIN_VALUE) {\n+                throw new ArithmeticException(\"overflow: can't negate\");\n+            }\n             numerator = -numerator;\n             denominator = -denominator;\n         }\n-        int gcd = greatestCommonDivisor(Math.abs(numerator), denominator);\n-        return new Fraction(numerator / gcd, denominator / gcd);\n+        // simplify fraction.\n+        int gcd = greatestCommonDivisor(numerator, denominator);\n+        numerator /= gcd;\n+        denominator /= gcd;\n+        return new Fraction(numerator, denominator);\n     }\n \n     /**\n      * @return a new fraction instance that is close to the value\n      * @throws ArithmeticException if <code>|value| > Integer.MAX_VALUE</code> \n      *  or <code>value = NaN</code>\n-     * @throws ArithmeticException if the calculated denomiator is <code>zero</code>\n+     * @throws ArithmeticException if the calculated denominator is <code>zero</code>\n      * @throws ArithmeticException if the the algorithm does not converge\n      */\n     public static Fraction getFraction(double value) {\n      *\n      * <p>The formats accepted are:</p>\n      *\n-     * <p>\n      * <ol>\n      *  <li><code>double</code> String containing a dot</li>\n      *  <li>'X Y/Z'</li>\n      *  <li>'Y/Z'</li>\n+     *  <li>'X' (a simple whole number)</li>\n      * </ol>\n      * and a .</p>\n      *\n             if (pos < 0) {\n                 throw new NumberFormatException(\"The fraction could not be parsed as the format X Y/Z\");\n             } else {\n+                int numer = Integer.parseInt(str.substring(0, pos));\n                 int denom = Integer.parseInt(str.substring(pos + 1));\n-                return getFraction(\n-                    Integer.parseInt(str.substring(0, pos)) + whole * denom,\n-                    denom\n-                );\n+                return getFraction(whole, numer, denom);\n             }\n         }\n \n             // simple whole number\n             return getFraction(Integer.parseInt(str), 1);\n         } else {\n-            return getFraction(\n-                Integer.parseInt(str.substring(0, pos)),\n-                Integer.parseInt(str.substring(pos + 1))\n-            );\n+            int numer = Integer.parseInt(str.substring(0, pos));\n+            int denom = Integer.parseInt(str.substring(pos + 1));\n+            return getFraction(numer, denom);\n         }\n     }\n \n     }\n \n     /**\n-     * <p>Gets a fraction that is the invert (1/fraction) of this one.</p>\n-     *\n+     * <p>Gets a fraction that is the inverse (1/fraction) of this one.</p>\n+     * \n      * <p>The returned fraction is not reduced.</p>\n      *\n-     * @return a new fraction instance with the numerator and denominator inverted\n-     * @throws ArithmeticException if the numerator is <code>zero</code>\n+     * @return a new fraction instance with the numerator and denominator\n+     *         inverted.\n+     * @throws ArithmeticException if the fraction represents zero.\n      */\n     public Fraction invert() {\n         if (numerator == 0) {\n-            throw new ArithmeticException(\"Unable to invert a fraction with a zero numerator\");\n-        }\n-        return getFraction(denominator, numerator);\n+            throw new ArithmeticException(\"Unable to invert zero.\");\n+        }\n+        if (numerator==Integer.MIN_VALUE) {\n+            throw new ArithmeticException(\"overflow: can't negate numerator\");\n+        }\n+        if (numerator<0) {\n+            return new Fraction(-denominator, -numerator);\n+        } else {\n+            return new Fraction(denominator, numerator);\n+        }\n     }\n \n     /**\n      * @return a new fraction instance with the opposite signed numerator\n      */\n     public Fraction negate() {\n-        return getFraction(-numerator, denominator);\n+        // the positive range is one smaller than the negative range of an int.\n+        if (numerator==Integer.MIN_VALUE) {\n+            throw new ArithmeticException(\"overflow: too large to negate\");\n+        }\n+        return new Fraction(-numerator, denominator);\n     }\n \n     /**\n      * <p>Gets a fraction that is the positive equivalent of this one.</p>\n-     * <p>More precisely: <pre>(fraction >= 0 ? this : -fraction)</pre></p>\n+     * <p>More precisely: <code>(fraction >= 0 ? this : -fraction)</code></p>\n      *\n      * <p>The returned fraction is not reduced.</p>\n      *\n         if (numerator >= 0) {\n             return this;\n         }\n-        return getFraction(-numerator, denominator);\n+        return negate();\n     }\n \n     /**\n      * <p>Gets a fraction that is raised to the passed in power.</p>\n      *\n-     * <p>The returned fraction is not reduced.</p>\n+     * <p>The returned fraction is in reduced form.</p>\n      *\n      * @param power  the power to raise the fraction to\n      * @return <code>this</code> if the power is one, <code>ONE</code> if the power\n             return this;\n         } else if (power == 0) {\n             return ONE;\n+        } else if (power < 0) {\n+            if (power==Integer.MIN_VALUE) { // MIN_VALUE can't be negated.\n+                return this.invert().pow(2).pow(-(power/2));\n+            }\n+            return this.invert().pow(-power);\n         } else {\n-            double denominatorValue = Math.pow(denominator, power);\n-            double numeratorValue = Math.pow(numerator, power);\n-            if (numeratorValue > Integer.MAX_VALUE || denominatorValue > Integer.MAX_VALUE) {\n-                throw new ArithmeticException(\"Integer overflow\");\n+            Fraction f = this.multiplyBy(this);\n+            if ((power % 2) == 0) { // if even...\n+                return f.pow(power/2);\n+            } else { // if odd...\n+                return f.pow(power/2).multiplyBy(this);\n             }\n-            if (power < 0) {\n-                return getFraction((int) Math.pow(denominator, -power), \n-                    (int) Math.pow(numerator, -power));\n+        }\n+    }\n+\n+    /**\n+     * <p>Gets the greatest common divisor of the absolute value of\n+     * two numbers, using the \"binary gcd\" method which avoids\n+     * division and modulo operations.  See Knuth 4.5.2 algorithm B.\n+     * This algorithm is due to Josef Stein (1961).</p>\n+     *\n+     * @param u  a non-zero number\n+     * @param v  a non-zero number\n+     * @return the greatest common divisor, never zero\n+     */\n+    private static int greatestCommonDivisor(int u, int v) {\n+        // keep u and v negative, as negative integers range down to\n+        // -2^31, while positive numbers can only be as large as 2^31-1\n+        // (i.e. we can't necessarily negate a negative number without\n+        // overflow)\n+        /* assert u!=0 && v!=0; */\n+        if (u>0) { u=-u; } // make u negative\n+        if (v>0) { v=-v; } // make v negative\n+        // B1. [Find power of 2]\n+        int k=0;\n+        while ((u&1)==0 && (v&1)==0 && k<31) { // while u and v are both even...\n+            u/=2; v/=2; k++; // cast out twos.\n+        }\n+        if (k==31) {\n+            throw new ArithmeticException(\"overflow: gcd is 2^31\");\n+        }\n+        // B2. Initialize: u and v have been divided by 2^k and at least\n+        //     one is odd.\n+        int t = ((u&1)==1) ? v : -(u/2)/*B3*/;\n+        // t negative: u was odd, v may be even (t replaces v)\n+        // t positive: u was even, v is odd (t replaces u)\n+        do {\n+            /* assert u<0 && v<0; */\n+            // B4/B3: cast out twos from t.\n+            while ((t&1)==0) { // while t is even..\n+                t/=2; // cast out twos\n             }\n-            return getFraction((int) Math.pow(numerator, power), \n-                (int) Math.pow(denominator, power));\n-        }\n-    }\n-\n-    /**\n-     * <p>Gets the greatest common divisor of two numbers.</p>\n-     *\n-     * @param number1  a positive number\n-     * @param number2  a positive number\n-     * @return the greatest common divisor, never zero\n-     */\n-    private static int greatestCommonDivisor(int number1, int number2) {\n-        int remainder = number1 % number2;\n-        while (remainder != 0) {\n-            number1 = number2;\n-            number2 = remainder;\n-            remainder = number1 % number2;\n-        }\n-        return number2;\n+            // B5 [reset max(u,v)]\n+            if (t>0) {\n+                u = -t;\n+            } else {\n+                v = t;\n+            }\n+            // B6/B3. at this point both u and v should be odd.\n+            t = (v - u)/2;\n+            // |u| larger: t positive (replace u)\n+            // |v| larger: t negative (replace v)\n+        } while (t!=0);\n+        return -u*(1<<k); // gcd is u*2^k\n     }\n \n     // Arithmetic\n     //-------------------------------------------------------------------\n \n-    /**\n-     * <p>Adds the value of this fraction to another, returning the result in \n-     * reduced form.</p>\n+    /** \n+     * Multiply two integers, checking for overflow.\n+     * \n+     * @param x a factor\n+     * @param y a factor\n+     * @return the product <code>x*y</code>\n+     * @throws ArithmeticException if the result can not be represented as\n+     *                             an int\n+     */\n+    private static int mulAndCheck(int x, int y) {\n+        long m = ((long)x)*((long)y);\n+        if (m < Integer.MIN_VALUE ||\n+            m > Integer.MAX_VALUE) {\n+            throw new ArithmeticException(\"overflow: mul\");\n+        }\n+        return (int)m;\n+    }\n+    \n+    /**\n+     *  Multiply two non-negative integers, checking for overflow.\n+     * \n+     * @param x a non-negative factor\n+     * @param y a non-negative factor\n+     * @return the product <code>x*y</code>\n+     * @throws ArithmeticException if the result can not be represented as\n+     * an int\n+     */\n+    private static int mulPosAndCheck(int x, int y) {\n+        /* assert x>=0 && y>=0; */\n+        long m = ((long)x)*((long)y);\n+        if (m > Integer.MAX_VALUE) {\n+            throw new ArithmeticException(\"overflow: mulPos\");\n+        }\n+        return (int)m;\n+    }\n+    \n+    /** \n+     * Add two integers, checking for overflow.\n+     * \n+     * @param x an addend\n+     * @param y an addend\n+     * @return the sum <code>x+y</code>\n+     * @throws ArithmeticException if the result can not be represented as\n+     * an int\n+     */\n+    private static int addAndCheck(int x, int y) {\n+        long s = (long)x+(long)y;\n+        if (s < Integer.MIN_VALUE ||\n+            s > Integer.MAX_VALUE) {\n+            throw new ArithmeticException(\"overflow: add\");\n+        }\n+        return (int)s;\n+    }\n+    \n+    /** \n+     * Subtract two integers, checking for overflow.\n+     * \n+     * @param x the minuend\n+     * @param y the subtrahend\n+     * @return the difference <code>x-y</code>\n+     * @throws ArithmeticException if the result can not be represented as\n+     * an int\n+     */\n+    private static int subAndCheck(int x, int y) {\n+        long s = (long)x-(long)y;\n+        if (s < Integer.MIN_VALUE ||\n+            s > Integer.MAX_VALUE) {\n+            throw new ArithmeticException(\"overflow: add\");\n+        }\n+        return (int)s;\n+    }\n+    \n+    /**\n+     * <p>Adds the value of this fraction to another, returning the result in reduced form.\n+     * The algorithm follows Knuth, 4.5.1.</p>\n      *\n      * @param fraction  the fraction to add, must not be <code>null</code>\n      * @return a <code>Fraction</code> instance with the resulting values\n      *  <code>Integer.MAX_VALUE</code>\n      */\n     public Fraction add(Fraction fraction) {\n+        return addSub(fraction, true /* add */);\n+    }\n+\n+    /**\n+     * <p>Subtracts the value of another fraction from the value of this one, \n+     * returning the result in reduced form.</p>\n+     *\n+     * @param fraction  the fraction to subtract, must not be <code>null</code>\n+     * @return a <code>Fraction</code> instance with the resulting values\n+     * @throws IllegalArgumentException if the fraction is <code>null</code>\n+     * @throws ArithmeticException if the resulting numerator or denominator\n+     *   cannot be represented in an <code>int</code>.\n+     */\n+    public Fraction subtract(Fraction fraction) {\n+        return addSub(fraction, false /* subtract */);\n+    }\n+\n+    /** \n+     * Implement add and subtract using algorithm described in Knuth 4.5.1.\n+     * \n+     * @param fraction the fraction to subtract, must not be <code>null</code>\n+     * @param isAdd true to add, false to subtract\n+     * @return a <code>Fraction</code> instance with the resulting values\n+     * @throws IllegalArgumentException if the fraction is <code>null</code>\n+     * @throws ArithmeticException if the resulting numerator or denominator\n+     *   cannot be represented in an <code>int</code>.\n+     */\n+    private Fraction addSub(Fraction fraction, boolean isAdd) {\n         if (fraction == null) {\n             throw new IllegalArgumentException(\"The fraction must not be null\");\n         }\n+        // zero is identity for addition.\n         if (numerator == 0) {\n-            return fraction;\n+            return isAdd ? fraction : fraction.negate();\n         }\n         if (fraction.numerator == 0) {\n             return this;\n         }     \n-        // Compute lcd explicitly to limit overflow\n-        int gcd = greatestCommonDivisor(Math.abs(fraction.denominator), Math.abs(denominator));\n-        int thisResidue = denominator/gcd;\n-        int thatResidue = fraction.denominator/gcd;\n-        double denominatorValue = Math.abs((double) gcd * thisResidue * thatResidue);\n-        double numeratorValue = (double) numerator * thatResidue + fraction.numerator * thisResidue;\n-        if (Math.abs(numeratorValue) > Integer.MAX_VALUE || \n-            Math.abs(denominatorValue) > Integer.MAX_VALUE) {\n-                throw new ArithmeticException(\"Integer overflow\");\n-        }\n-        return Fraction.getReducedFraction((int) numeratorValue, (int) denominatorValue);\n-    }\n-\n-    /**\n-     * <p>Subtracts the value of another fraction from the value of this one,\n-     * returning the result in reduced form.</p>\n-     *\n-     * @param fraction  the fraction to subtract, must not be <code>null</code>\n-     * @return a <code>Fraction</code> instance with the resulting values\n-     * @throws IllegalArgumentException if the fraction is <code>null</code>\n-     * @throws ArithmeticException if the resulting numerator or denominator exceeds\n-     *  <code>Integer.MAX_VALUE</code>\n-     */\n-    public Fraction subtract(Fraction fraction) {\n-        if (fraction == null) {\n-            throw new IllegalArgumentException(\"The fraction must not be null\");\n-        }\n-        return add(fraction.negate());\n-    }\n-\n-    /**\n-     * <p>Multiplies the value of this fraction by another, returning the result \n-     * in reduced form.</p>\n+        // if denominators are randomly distributed, d1 will be 1 about 61%\n+        // of the time.\n+        int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n+        if (d1==1) {\n+            // result is ( (u*v' +/- u'v) / u'v')\n+            int uvp = mulAndCheck(numerator, fraction.denominator);\n+            int upv = mulAndCheck(fraction.numerator, denominator);\n+            return new Fraction\n+                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n+                 mulPosAndCheck(denominator, fraction.denominator));\n+        }\n+        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n+        // exercise 7.  we're going to use a BigInteger.\n+        // t = u(v'/d1) +/- v(u'/d1)\n+        BigInteger uvp = BigInteger.valueOf(numerator)\n+            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n+        BigInteger upv = BigInteger.valueOf(fraction.numerator)\n+            .multiply(BigInteger.valueOf(denominator/d1));\n+        BigInteger t = isAdd ? uvp.add(upv) : uvp.subtract(upv);\n+        // but d2 doesn't need extra precision because\n+        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n+        int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n+        int d2 = (tmodd1==0)?d1:greatestCommonDivisor(tmodd1, d1);\n+\n+        // result is (t/d2) / (u'/d1)(v'/d2)\n+        BigInteger w = t.divide(BigInteger.valueOf(d2));\n+        if (w.bitLength() > 31) {\n+            throw new ArithmeticException\n+                (\"overflow: numerator too large after multiply\");\n+        }\n+        return new Fraction\n+            (w.intValue(),\n+             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n+    }\n+\n+    /**\n+     * <p>Multiplies the value of this fraction by another, returning the \n+     * result in reduced form.</p>\n      *\n      * @param fraction  the fraction to multiply by, must not be <code>null</code>\n      * @return a <code>Fraction</code> instance with the resulting values\n         if (numerator == 0 || fraction.numerator == 0) {\n             return ZERO;\n         }\n-        double numeratorValue = (double) numerator * fraction.numerator;\n-        double denominatorValue = (double) denominator * fraction.denominator;\n-        if (Math.abs(numeratorValue) > Integer.MAX_VALUE || \n-            Math.abs(denominatorValue) > Integer.MAX_VALUE) {\n-                throw new ArithmeticException(\"Integer overflow\");\n-        }\n-        return getReducedFraction((int) numeratorValue, (int) denominatorValue);\n-    }\n-\n-    /**\n-     * <p>Divide the value of this fraction by another, returning the result \n-     * in reduced form.</p>\n+        // knuth 4.5.1\n+        // make sure we don't overflow unless the result *must* overflow.\n+        int d1 = greatestCommonDivisor(numerator, fraction.denominator);\n+        int d2 = greatestCommonDivisor(fraction.numerator, denominator);\n+        return getReducedFraction\n+            (mulAndCheck(numerator/d1, fraction.numerator/d2),\n+             mulPosAndCheck(denominator/d2, fraction.denominator/d1));\n+    }\n+\n+    /**\n+     * <p>Divide the value of this fraction by another.</p>\n      *\n      * @param fraction  the fraction to divide by, must not be <code>null</code>\n      * @return a <code>Fraction</code> instance with the resulting values\n         if (fraction.numerator == 0) {\n             throw new ArithmeticException(\"The fraction to divide by must not be zero\");\n         }\n-        if (numerator == 0) {\n-            return ZERO;\n-        }  \n-        double numeratorValue = (double) numerator * fraction.denominator;\n-        double denominatorValue = (double) denominator * fraction.numerator;\n-        if (Math.abs(numeratorValue) > Integer.MAX_VALUE || \n-            Math.abs(denominatorValue) > Integer.MAX_VALUE) {\n-                throw new ArithmeticException(\"Integer overflow\");\n-        }\n-        return getReducedFraction((int) numeratorValue, (int) denominatorValue);\n+        return multiplyBy(fraction.invert());\n     }\n \n     // Basics\n             return false;\n         }\n         Fraction other = (Fraction) obj;\n-        return (numerator == other.numerator &&\n-                denominator == other.denominator);\n+        return (getNumerator() == other.getNumerator() &&\n+                getDenominator() == other.getDenominator());\n     }\n \n     /**\n      */\n     public int hashCode() {\n         if (hashCode == 0) {\n-            hashCode = 17;\n-            hashCode = 37 * hashCode + numerator;\n-            hashCode = 37 * hashCode + denominator;\n+            // hashcode update should be atomic.\n+            hashCode = 37 * (37 * 17 + getNumerator()) + getDenominator();\n         }\n         return hashCode;\n     }\n      */\n     public int compareTo(Object object) {\n         Fraction other = (Fraction) object;\n+        if (this==other) {\n+            return 0;\n+        }\n         if (numerator == other.numerator && denominator == other.denominator) {\n             return 0;\n         }\n     public String toString() {\n         if (toString == null) {\n             toString = new StringBuffer(32)\n-                .append(numerator)\n+                .append(getNumerator())\n                 .append('/')\n-                .append(denominator).toString();\n+                .append(getDenominator()).toString();\n         }\n         return toString;\n     }\n                 toProperString = \"0\";\n             } else if (numerator == denominator) {\n                 toProperString = \"1\";\n-            } else if (Math.abs(numerator) > denominator) {\n+            } else if ((numerator>0?-numerator:numerator) < -denominator) {\n+                // note that we do the magnitude comparison test above with\n+                // NEGATIVE (not positive) numbers, since negative numbers\n+                // have a larger range.  otherwise numerator==Integer.MIN_VALUE\n+                // is handled incorrectly.\n                 int properNumerator = getProperNumerator();\n                 if (properNumerator == 0) {\n                     toProperString = Integer.toString(getProperWhole());\n                     toProperString = new StringBuffer(32)\n                         .append(getProperWhole()).append(' ')\n                         .append(properNumerator).append('/')\n-                        .append(denominator).toString();\n+                        .append(getDenominator()).toString();\n                 }\n             } else {\n                 toProperString = new StringBuffer(32)\n-                    .append(numerator).append('/')\n-                    .append(denominator).toString();\n+                    .append(getNumerator()).append('/')\n+                    .append(getDenominator()).toString();\n             }\n         }\n         return toProperString;\n     }\n-\n }\n--- a/src/test/org/apache/commons/lang/math/FractionTest.java\n+++ b/src/test/org/apache/commons/lang/math/FractionTest.java\n import junit.framework.Test;\n import junit.framework.TestCase;\n import junit.framework.TestSuite;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n /**\n- * Test cases for the {@link Fraction} classes.\n+ * Test cases for the {@link Fraction} class\n  *\n  * @author Stephen Colebourne\n- * @version $Id: FractionTest.java,v 1.6 2004/02/18 23:02:38 ggregory Exp $\n+ * @author C. Scott Ananian\n+ * @version $Id: FractionTest.java,v 1.7 2004/07/11 23:20:17 psteitz Exp $\n  */\n public class FractionTest extends TestCase {\n     \n-    private static final int SKIP = 53;\n+    private static final int SKIP = 500;  //53\n \n     public FractionTest(String name) {\n         super(name);\n         assertEquals(4, Fraction.FOUR_FIFTHS.getNumerator());\n         assertEquals(5, Fraction.FOUR_FIFTHS.getDenominator());\n     }\n-    \n+\n     public void testFactory_int_int() {\n         Fraction f = null;\n         \n             f = Fraction.getFraction(-3, 0);\n             fail(\"expecting ArithmeticException\");\n         } catch (ArithmeticException ex) {}\n+\n+        // very large: can't represent as unsimplified fraction, although\n+        try {\n+            f = Fraction.getFraction(4, Integer.MIN_VALUE);\n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {}\n+        try {\n+            f = Fraction.getFraction(1, Integer.MIN_VALUE);\n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {}\n     }\n \n     public void testFactory_int_int_int() {\n             f = Fraction.getFraction(-Integer.MAX_VALUE, 1, 2);\n             fail(\"expecting ArithmeticException\");\n         } catch (ArithmeticException ex) {}\n-    }\n-\n+\n+        // very large\n+        f = Fraction.getFraction(-1, 0, Integer.MAX_VALUE);\n+        assertEquals(-Integer.MAX_VALUE, f.getNumerator());\n+        assertEquals(Integer.MAX_VALUE, f.getDenominator());\n+\n+        try {\n+            // negative denominators not allowed in this constructor.\n+            f = Fraction.getFraction(0, 4, Integer.MIN_VALUE);\n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {}\n+        try {\n+            f = Fraction.getFraction(1, 1, Integer.MAX_VALUE);\n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {}\n+        try {\n+            f = Fraction.getFraction(-1, 2, Integer.MAX_VALUE);\n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {}\n+    }\n     public void testReducedFactory_int_int() {\n         Fraction f = null;\n         \n         f = Fraction.getReducedFraction(121, 22);\n         assertEquals(11, f.getNumerator());\n         assertEquals(2, f.getDenominator());\n+        \n+        // Extreme values \n+        // OK, can reduce before negating\n+        f = Fraction.getReducedFraction(-2, Integer.MIN_VALUE);\n+        assertEquals(1, f.getNumerator());\n+        assertEquals(-(Integer.MIN_VALUE / 2), f.getDenominator());\n+        \n+        // Can't reduce, negation will throw\n+        try { \n+            f = Fraction.getReducedFraction(-7, Integer.MIN_VALUE);  \n+            fail(\"Expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {}      \n     }\n \n     public void testFactory_double() {\n     public void testFactory_String() {\n         try {\n             Fraction.getFraction(null);\n-            fail(\"expecting ArithmeticException\");\n+            fail(\"expecting IllegalArgumentException\");\n         } catch (IllegalArgumentException ex) {}\n     }\n     \n         \n         try {\n             f = Fraction.getFraction(\"2.3R\");\n+            fail(\"Expecting NumberFormatException\");\n         } catch (NumberFormatException ex) {}\n         \n         try {\n         \n         try {\n             f = Fraction.getFraction(\".\");\n+            fail(\"Expecting NumberFormatException\");\n         } catch (NumberFormatException ex) {}\n     }\n \n         assertEquals(6, f.getNumerator());\n         assertEquals(4, f.getDenominator());\n         \n+        f = Fraction.getFraction(\"-7 1/2\");\n+        assertEquals(-15, f.getNumerator());\n+        assertEquals(2, f.getDenominator());\n+        \n+        f = Fraction.getFraction(\"-1 2/4\");\n+        assertEquals(-6, f.getNumerator());\n+        assertEquals(4, f.getDenominator());\n+        \n         try {\n             f = Fraction.getFraction(\"2 3\");\n-            fail(\"expecting NumberFomatException\");\n+            fail(\"expecting NumberFormatException\");\n         } catch (NumberFormatException ex) {}\n         \n         try {\n             f = Fraction.getFraction(\"a 3\");\n-            fail(\"expecting NumberFomatException\");\n+            fail(\"expecting NumberFormatException\");\n         } catch (NumberFormatException ex) {}\n         \n         try {\n             f = Fraction.getFraction(\"2 b/4\");\n-            fail(\"expecting NumberFomatException\");\n+            fail(\"expecting NumberFormatException\");\n         } catch (NumberFormatException ex) {}\n         \n         try {\n             f = Fraction.getFraction(\"2 \");\n-            fail(\"expecting NumberFomatException\");\n+            fail(\"expecting NumberFormatException\");\n         } catch (NumberFormatException ex) {}\n \n         try {\n             f = Fraction.getFraction(\" 3\");\n-            fail(\"expecting NumberFomatException\");\n+            fail(\"expecting NumberFormatException\");\n         } catch (NumberFormatException ex) {}\n         \n         try {\n             f = Fraction.getFraction(\" \");\n-            fail(\"expecting NumberFomatException\");\n+            fail(\"expecting NumberFormatException\");\n         } catch (NumberFormatException ex) {}\n     }\n \n         \n         try {\n             f = Fraction.getFraction(\"2/d\");\n-            fail(\"expecting NumberFomatException\");\n+            fail(\"expecting NumberFormatException\");\n         } catch (NumberFormatException ex) {}\n         \n         try {\n             f = Fraction.getFraction(\"2e/3\");\n-            fail(\"expecting NumberFomatException\");\n+            fail(\"expecting NumberFormatException\");\n         } catch (NumberFormatException ex) {}\n         \n         try {\n             f = Fraction.getFraction(\"2/\");\n-            fail(\"expecting NumberFomatException\");\n+            fail(\"expecting NumberFormatException\");\n         } catch (NumberFormatException ex) {}\n         \n         try {\n             f = Fraction.getFraction(\"/\");\n-            fail(\"expecting NumberFomatException\");\n+            fail(\"expecting NumberFormatException\");\n         } catch (NumberFormatException ex) {}\n     }\n \n         assertEquals(-3, f.getProperWhole());\n         assertEquals(5, f.getProperNumerator());\n         assertEquals(6, f.getDenominator());\n+\n+        f = Fraction.getFraction(Integer.MIN_VALUE, 0, 1);\n+        assertEquals(Integer.MIN_VALUE, f.getNumerator());\n+        assertEquals(Integer.MIN_VALUE, f.getProperWhole());\n+        assertEquals(0, f.getProperNumerator());\n+        assertEquals(1, f.getDenominator());\n     }\n             \n     public void testConversions() {\n         f = f.reduce();\n         assertEquals(2, f.getNumerator());\n         assertEquals(3, f.getDenominator());\n+\n+        f = Fraction.getFraction(2, 3);\n+        f = f.reduce();\n+        assertEquals(2, f.getNumerator());\n+        assertEquals(3, f.getDenominator());\n     }\n     \n     public void testInvert() {\n         assertEquals(3, f.getNumerator());\n         assertEquals(4, f.getDenominator());\n         \n+        f = Fraction.getFraction(-15, 47);\n+        f = f.invert();\n+        assertEquals(-47, f.getNumerator());\n+        assertEquals(15, f.getDenominator());\n+        \n         f = Fraction.getFraction(0, 3);\n         try {\n             f = f.invert();\n-        } catch (ArithmeticException ex) {}\n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {}\n+\n+        // large values\n+        f = Fraction.getFraction(Integer.MIN_VALUE, 1);\n+        try {\n+            f = f.invert();\n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {}\n+\n+        f = Fraction.getFraction(Integer.MAX_VALUE, 1);\n+        f = f.invert();\n+        assertEquals(1, f.getNumerator());\n+        assertEquals(Integer.MAX_VALUE, f.getDenominator());\n     }\n     \n     public void testNegate() {\n         f = f.negate();\n         assertEquals(50, f.getNumerator());\n         assertEquals(75, f.getDenominator());\n+\n+        // large values\n+        f = Fraction.getFraction(Integer.MAX_VALUE-1, Integer.MAX_VALUE);\n+        f = f.negate();\n+        assertEquals(Integer.MIN_VALUE+2, f.getNumerator());\n+        assertEquals(Integer.MAX_VALUE, f.getDenominator());\n+\n+        f = Fraction.getFraction(Integer.MIN_VALUE, 1);\n+        try {\n+            f = f.negate();\n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {}\n     }\n     \n     public void testAbs() {\n         f = f.abs();\n         assertEquals(50, f.getNumerator());\n         assertEquals(75, f.getDenominator());\n+\n+        f = Fraction.getFraction(Integer.MAX_VALUE, 1);\n+        f = f.abs();\n+        assertEquals(Integer.MAX_VALUE, f.getNumerator());\n+        assertEquals(1, f.getDenominator());\n+\n+        f = Fraction.getFraction(Integer.MAX_VALUE, -1);\n+        f = f.abs();\n+        assertEquals(Integer.MAX_VALUE, f.getNumerator());\n+        assertEquals(1, f.getDenominator());\n+\n+        f = Fraction.getFraction(Integer.MIN_VALUE, 1);\n+        try {\n+            f = f.abs();\n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {}\n     }\n     \n     public void testPow() {\n         \n         f = Fraction.getFraction(3, 5);\n         assertSame(f, f.pow(1));\n+        assertEquals(f, f.pow(1));\n \n         f = Fraction.getFraction(3, 5);\n         f = f.pow(2);\n         assertEquals(25, f.getNumerator());\n         assertEquals(9, f.getDenominator());\n         \n-        f = Fraction.getFraction(Integer.MAX_VALUE);\n+        // check unreduced fractions stay that way.\n+        f = Fraction.getFraction(6, 10);\n+        assertEquals(Fraction.ONE, f.pow(0));\n+        \n+        f = Fraction.getFraction(6, 10);\n+        assertEquals(f, f.pow(1));\n+        assertFalse(f.pow(1).equals(Fraction.getFraction(3,5)));\n+\n+        f = Fraction.getFraction(6, 10);\n+        f = f.pow(2);\n+        assertEquals(9, f.getNumerator());\n+        assertEquals(25, f.getDenominator());\n+        \n+        f = Fraction.getFraction(6, 10);\n+        f = f.pow(3);\n+        assertEquals(27, f.getNumerator());\n+        assertEquals(125, f.getDenominator());\n+        \n+        f = Fraction.getFraction(6, 10);\n+        f = f.pow(-1);\n+        assertEquals(10, f.getNumerator());\n+        assertEquals(6, f.getDenominator());\n+        \n+        f = Fraction.getFraction(6, 10);\n+        f = f.pow(-2);\n+        assertEquals(25, f.getNumerator());\n+        assertEquals(9, f.getDenominator());\n+        \n+        // zero to any positive power is still zero.\n+        f = Fraction.getFraction(0, 1231);\n+        f = f.pow(1);\n+        assertTrue(0==f.compareTo(Fraction.ZERO));\n+        assertEquals(0, f.getNumerator());\n+        assertEquals(1231, f.getDenominator());\n+        f = f.pow(2);\n+        assertTrue(0==f.compareTo(Fraction.ZERO));\n+        assertEquals(0, f.getNumerator());\n+        assertEquals(1, f.getDenominator());\n+\n+        // zero to negative powers should throw an exception\n+        try {\n+            f = f.pow(-1);\n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {}\n+        try {\n+            f = f.pow(Integer.MIN_VALUE);\n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {}\n+\n+        // one to any power is still one.\n+        f = Fraction.getFraction(1, 1);\n+        f = f.pow(0);\n+        assertEquals(f, Fraction.ONE);\n+        f = f.pow(1);\n+        assertEquals(f, Fraction.ONE);\n+        f = f.pow(-1);\n+        assertEquals(f, Fraction.ONE);\n+        f = f.pow(Integer.MAX_VALUE);\n+        assertEquals(f, Fraction.ONE);\n+        f = f.pow(Integer.MIN_VALUE);\n+        assertEquals(f, Fraction.ONE);\n+\n+        f = Fraction.getFraction(Integer.MAX_VALUE, 1);\n+        try {\n+            f = f.pow(2);\n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {}\n+\n+        // Numerator growing too negative during the pow operation.\n+        f = Fraction.getFraction(Integer.MIN_VALUE, 1);\n+        try {\n+            f = f.pow(3);\n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {}\n+\n+        f = Fraction.getFraction(65536, 1);\n         try {\n             f = f.pow(2);\n             fail(\"expecting ArithmeticException\");\n         f = f2.add(f1);\n         assertSame(f2, f);\n         \n+        f1 = Fraction.getFraction(-1, 13*13*2*2);\n+        f2 = Fraction.getFraction(-2, 13*17*2);\n+        f = f1.add(f2);\n+        assertEquals(13*13*17*2*2, f.getDenominator());\n+        assertEquals(-17 - 2*13*2, f.getNumerator());\n+        \n         try {\n             f.add(null);\n             fail(\"expecting IllegalArgumentException\");\n         } catch (IllegalArgumentException ex) {}\n+        \n+        // if this fraction is added naively, it will overflow.\n+        // check that it doesn't.\n+        f1 = Fraction.getFraction(1,32768*3);\n+        f2 = Fraction.getFraction(1,59049);\n+        f = f1.add(f2);\n+        assertEquals(52451, f.getNumerator());\n+        assertEquals(1934917632, f.getDenominator());\n+\n+        f1 = Fraction.getFraction(Integer.MIN_VALUE, 3);\n+        f2 = Fraction.ONE_THIRD;\n+        f = f1.add(f2);\n+        assertEquals(Integer.MIN_VALUE+1, f.getNumerator());\n+        assertEquals(3, f.getDenominator());\n         \n         f1 = Fraction.getFraction(Integer.MAX_VALUE - 1, 1);\n         f2 = Fraction.ONE;\n             fail(\"expecting ArithmeticException but got: \" + f.toString());\n         } catch (ArithmeticException ex) {}\n         \n+        // denominator should not be a multiple of 2 or 3 to trigger overflow\n+        f1 = Fraction.getFraction(Integer.MIN_VALUE, 5);\n+        f2 = Fraction.getFraction(-1,5);\n+        try {\n+            f = f1.add(f2); // should overflow\n+            fail(\"expecting ArithmeticException but got: \" + f.toString());\n+        } catch (ArithmeticException ex) {}\n+        \n         try {\n             f= Fraction.getFraction(-Integer.MAX_VALUE, 1);\n             f = f.add(f);\n             fail(\"expecting ArithmeticException\");\n         } catch (ArithmeticException ex) {}\n             \n+        try {\n+            f= Fraction.getFraction(-Integer.MAX_VALUE, 1);\n+            f = f.add(f);\n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {}\n+            \n+        f1 = Fraction.getFraction(3,327680);\n+        f2 = Fraction.getFraction(2,59049);\n+        try {\n+            f = f1.add(f2); // should overflow\n+            fail(\"expecting ArithmeticException but got: \" + f.toString());\n+        } catch (ArithmeticException ex) {}\n     }\n             \n     public void testSubtract() {\n             fail(\"expecting IllegalArgumentException\");\n         } catch (IllegalArgumentException ex) {}\n         \n+        // if this fraction is subtracted naively, it will overflow.\n+        // check that it doesn't.\n+        f1 = Fraction.getFraction(1,32768*3);\n+        f2 = Fraction.getFraction(1,59049);\n+        f = f1.subtract(f2);\n+        assertEquals(-13085, f.getNumerator());\n+        assertEquals(1934917632, f.getDenominator());\n+\n+        f1 = Fraction.getFraction(Integer.MIN_VALUE, 3);\n+        f2 = Fraction.ONE_THIRD.negate();\n+        f = f1.subtract(f2);\n+        assertEquals(Integer.MIN_VALUE+1, f.getNumerator());\n+        assertEquals(3, f.getDenominator());\n+        \n+        f1 = Fraction.getFraction(Integer.MAX_VALUE, 1);\n+        f2 = Fraction.ONE;\n+        f = f1.subtract(f2);\n+        assertEquals(Integer.MAX_VALUE-1, f.getNumerator());\n+        assertEquals(1, f.getDenominator());\n+\n         try {\n             f1 = Fraction.getFraction(1, Integer.MAX_VALUE);\n             f2 = Fraction.getFraction(1, Integer.MAX_VALUE - 1);\n             fail(\"expecting ArithmeticException\");  //should overflow\n         } catch (ArithmeticException ex) {}\n             \n+        // denominator should not be a multiple of 2 or 3 to trigger overflow\n+        f1 = Fraction.getFraction(Integer.MIN_VALUE, 5);\n+        f2 = Fraction.getFraction(1,5);\n+        try {\n+            f = f1.subtract(f2); // should overflow\n+            fail(\"expecting ArithmeticException but got: \" + f.toString());\n+        } catch (ArithmeticException ex) {}\n+        \n+        try {\n+            f= Fraction.getFraction(Integer.MIN_VALUE, 1);\n+            f = f.subtract(Fraction.ONE);\n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {}\n+            \n+        try {\n+            f= Fraction.getFraction(Integer.MAX_VALUE, 1);\n+            f = f.subtract(Fraction.ONE.negate());\n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {}\n+            \n+        f1 = Fraction.getFraction(3,327680);\n+        f2 = Fraction.getFraction(2,59049);\n+        try {\n+            f = f1.subtract(f2); // should overflow\n+            fail(\"expecting ArithmeticException but got: \" + f.toString());\n+        } catch (ArithmeticException ex) {}\n     }\n             \n     public void testMultiply() {\n         f = f1.multiplyBy(f2);\n         assertEquals(6, f.getNumerator());\n         assertEquals(25, f.getDenominator());\n+        \n+        f1 = Fraction.getFraction(6, 10);\n+        f2 = Fraction.getFraction(6, 10);\n+        f = f1.multiplyBy(f2);\n+        assertEquals(9, f.getNumerator());\n+        assertEquals(25, f.getDenominator());\n+        f = f.multiplyBy(f2);\n+        assertEquals(27, f.getNumerator());\n+        assertEquals(125, f.getDenominator());\n         \n         f1 = Fraction.getFraction(3, 5);\n         f2 = Fraction.getFraction(-2, 5);\n         assertEquals(6, f.getNumerator());\n         assertEquals(25, f.getDenominator());\n         \n+        \n         f1 = Fraction.getFraction(0, 5);\n         f2 = Fraction.getFraction(2, 7);\n         f = f1.multiplyBy(f2);\n         assertEquals(2, f.getNumerator());\n         assertEquals(7, f.getDenominator());\n         \n+        f1 = Fraction.getFraction(Integer.MAX_VALUE, 1);\n+        f2 = Fraction.getFraction(Integer.MIN_VALUE, Integer.MAX_VALUE);\n+        f = f1.multiplyBy(f2);\n+        assertEquals(Integer.MIN_VALUE, f.getNumerator());\n+        assertEquals(1, f.getDenominator());\n+\n         try {\n             f.multiplyBy(null);\n             fail(\"expecting IllegalArgumentException\");\n         assertEquals(1, f.getNumerator());\n         assertEquals(1, f.getDenominator());\n         \n+        f1 = Fraction.getFraction(Integer.MIN_VALUE, Integer.MAX_VALUE);\n+        f2 = Fraction.getFraction(1, Integer.MAX_VALUE);\n+        f = f1.divideBy(f2);\n+        assertEquals(Integer.MIN_VALUE, f.getNumerator());\n+        assertEquals(1, f.getDenominator());\n+\n         try {\n             f.divideBy(null);\n             fail(\"IllegalArgumentException\");\n         Fraction f2 = null;\n         \n         f1 = Fraction.getFraction(3, 5);\n+        assertTrue(f1.compareTo(f1) == 0);\n         \n         try {\n             f1.compareTo(null);\n         \n         f2 = Fraction.getFraction(2, 5);\n         assertTrue(f1.compareTo(f2) > 0);\n+        assertTrue(f2.compareTo(f2) == 0);\n         \n         f2 = Fraction.getFraction(4, 5);\n         assertTrue(f1.compareTo(f2) < 0);\n+        assertTrue(f2.compareTo(f2) == 0);\n         \n         f2 = Fraction.getFraction(3, 5);\n         assertTrue(f1.compareTo(f2) == 0);\n+        assertTrue(f2.compareTo(f2) == 0);\n         \n         f2 = Fraction.getFraction(6, 10);\n         assertTrue(f1.compareTo(f2) == 0);\n+        assertTrue(f2.compareTo(f2) == 0);\n+\n+        f2 = Fraction.getFraction(-1, 1, Integer.MAX_VALUE);\n+        assertTrue(f1.compareTo(f2) > 0);\n+        assertTrue(f2.compareTo(f2) == 0);\n+\n     }\n     \n     public void testToString() {\n         \n         f = Fraction.getFraction(2, 2);\n         assertEquals(\"2/2\", f.toString());        \n+\n+        f = Fraction.getFraction(Integer.MIN_VALUE, 0, 1);\n+        assertEquals(\"-2147483648/1\", f.toString());        \n+\n+        f = Fraction.getFraction(-1, 1, Integer.MAX_VALUE);\n+        assertEquals(\"-2147483648/2147483647\", f.toString());\n     }\n     \n     public void testToProperString() {\n         \n         f = Fraction.getFraction(-7, 5);\n         assertEquals(\"-1 2/5\", f.toProperString());        \n-    }\n-    \n+\n+        f = Fraction.getFraction(Integer.MIN_VALUE, 0, 1);\n+        assertEquals(\"-2147483648\", f.toProperString());        \n+\n+        f = Fraction.getFraction(-1, 1, Integer.MAX_VALUE);\n+        assertEquals(\"-1 1/2147483647\", f.toProperString());\n+    }\n }", "timestamp": 1089588017, "metainfo": ""}