{"sha": "1004aa6826a19fcb9e6a33b029b492a100fa081b", "log": "Make all named warning groups suppressable. The real radical change here is that in order to do this, we need to tell the compiler which diagnostic groups it's running with, which requires a bit of clean-up in the compiler's bootstrapping sequence.  R=johnlenz DELTA=94  (74 added, 14 deleted, 6 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=114010   ", "commit": "\n--- a/src/com/google/javascript/jscomp/AbstractCommandLineRunner.java\n+++ b/src/com/google/javascript/jscomp/AbstractCommandLineRunner.java\n    */\n   protected abstract B createOptions();\n \n+  /**\n+   * The warning classes that are available from the command-line.\n+   */\n   protected DiagnosticGroups getDiagnosticGroups() {\n-    return new DiagnosticGroups();\n+    if (compiler == null) {\n+      return new DiagnosticGroups();\n+    }\n+    return compiler.getDiagnosticGroups();\n   }\n \n   /** No longer does anything. */\n--- a/src/com/google/javascript/jscomp/Compiler.java\n+++ b/src/com/google/javascript/jscomp/Compiler.java\n   // error manager to which error management is delegated\n   private ErrorManager errorManager;\n \n+  // Warnings guard for filtering warnings.\n+  private WarningsGuard warningsGuard;\n+\n   // Parse tree root nodes\n   Node externsRoot;\n   Node jsRoot;\n         setErrorManager(printer);\n       }\n     }\n+\n+    // Initialize the warnings guard.\n+    List<WarningsGuard> guards = Lists.newArrayList();\n+    guards.add(\n+        new SuppressDocWarningsGuard(\n+            getDiagnosticGroups().getRegisteredGroups()));\n+    WarningsGuard warningsGuard = options.getWarningsGuard();\n+    if (warningsGuard != null) {\n+      guards.add(options.getWarningsGuard());\n+    }\n+\n+    // All passes must run the variable check. This synthesizes\n+    // variables later so that the compiler doesn't crash. It also\n+    // checks the externs file for validity. If you don't want to warn\n+    // about missing variable declarations, we shut that specific\n+    // error off.\n+    if (!options.checkSymbols &&\n+        (warningsGuard == null || !warningsGuard.disables(\n+            DiagnosticGroups.CHECK_VARIABLES))) {\n+      guards.add(new DiagnosticGroupWarningsGuard(\n+          DiagnosticGroups.CHECK_VARIABLES, CheckLevel.OFF));\n+    }\n+    this.warningsGuard = new ComposeWarningsGuard(guards);\n   }\n \n   /**\n   // Error reporting\n   //------------------------------------------------------------------------\n \n+  /**\n+   * The warning classes that are available from the command-line, and\n+   * are suppressable by the {@code @suppress} annotation.\n+   */\n+  protected DiagnosticGroups getDiagnosticGroups() {\n+    return new DiagnosticGroups();\n+  }\n+\n   @Override\n   public void report(JSError error) {\n     CheckLevel level = error.level;\n-    WarningsGuard guard = options.getWarningsGuard();\n-    if (guard != null) {\n-      CheckLevel newLevel = guard.level(error);\n+    if (warningsGuard != null) {\n+      CheckLevel newLevel = warningsGuard.level(error);\n       if (newLevel != null) {\n         level = newLevel;\n       }\n--- a/src/com/google/javascript/jscomp/DefaultPassConfig.java\n+++ b/src/com/google/javascript/jscomp/DefaultPassConfig.java\n     if (options.syntheticBlockStartMarker != null) {\n       // This pass must run before the first fold constants pass.\n       checks.add(createSyntheticBlocks);\n-    }\n-\n-    // All passes must run the variable check. This synthesizes\n-    // variables later so that the compiler doesn't crash. It also\n-    // checks the externs file for validity. If you don't want to warn\n-    // about missing variable declarations, we shut that specific\n-    // error off.\n-    WarningsGuard warningsGuard = options.getWarningsGuard();\n-    if (!options.checkSymbols &&\n-        (warningsGuard == null || !warningsGuard.disables(\n-            DiagnosticGroups.CHECK_VARIABLES))) {\n-      options.setWarningLevel(DiagnosticGroups.CHECK_VARIABLES,\n-          CheckLevel.OFF);\n     }\n \n     checks.add(checkVars);\n--- a/src/com/google/javascript/jscomp/DiagnosticGroups.java\n+++ b/src/com/google/javascript/jscomp/DiagnosticGroups.java\n package com.google.javascript.jscomp;\n \n import com.google.common.base.Preconditions;\n+import com.google.common.collect.ImmutableMap;\n import com.google.common.collect.Maps;\n \n import java.util.List;\n       DiagnosticGroup group) {\n     groupsByName.put(name, group);\n     return group;\n+  }\n+\n+  /** Get the registered diagnostic groups, indexed by name. */\n+  protected Map<String, DiagnosticGroup> getRegisteredGroups() {\n+    return ImmutableMap.copyOf(groupsByName);\n   }\n \n   /** Find the diagnostic group registered under the given name. */\n--- a/test/com/google/javascript/jscomp/CompilerTestCase.java\n+++ b/test/com/google/javascript/jscomp/CompilerTestCase.java\n    */\n   protected CompilerOptions getOptions() {\n     CompilerOptions options = new CompilerOptions();\n+\n+    // This doesn't affect whether checkSymbols is run--it just affects\n+    // whether variable warnings are filtered.\n+    options.checkSymbols = true;\n+\n     options.setWarningLevel(\n         DiagnosticGroups.MISSING_PROPERTIES, CheckLevel.WARNING);\n     options.setCodingConvention(getCodingConvention());\n--- a/test/com/google/javascript/jscomp/SyntacticScopeCreatorTest.java\n+++ b/test/com/google/javascript/jscomp/SyntacticScopeCreatorTest.java\n    */\n   private int createGlobalScopeHelper(String js) {\n     Compiler compiler = new Compiler();\n+    CompilerOptions options = new CompilerOptions();\n+    options.checkSymbols = true;\n+    compiler.initOptions(options);\n+\n     Node root = compiler.parseTestCode(js);\n     assertEquals(0, compiler.getErrorCount());\n     Scope globalScope =\n--- a/test/com/google/javascript/jscomp/TypeCheckTest.java\n+++ b/test/com/google/javascript/jscomp/TypeCheckTest.java\n       \"function f(x) { !x.foo || x.foo(); }\");\n   }\n \n+  public void testMissingProperty34() throws Exception {\n+    testTypes(\n+        \"/** @fileoverview \\n * @suppress {missingProperties} */\" +\n+        \"/** @constructor */ function Foo() {}\" +\n+        \"Foo.prototype.bar = function() { return this.a; };\" +\n+        \"Foo.prototype.baz = function() { this.b = 3; };\");\n+  }\n+\n   public void testDeclaredNativeTypeEquality() throws Exception {\n     Node n = parseAndTypeCheck(\"/** @constructor */ function Object() {};\");\n     assertEquals(registry.getNativeType(JSTypeNative.OBJECT_FUNCTION_TYPE),\n--- a/test/com/google/javascript/jscomp/VariableReferenceCheckTest.java\n+++ b/test/com/google/javascript/jscomp/VariableReferenceCheckTest.java\n   private boolean enableAmbiguousFunctionCheck = false;\n \n   @Override\n-  public CompilerPass getProcessor(Compiler compiler) {\n+  public CompilerOptions getOptions() {\n+    CompilerOptions options = super.getOptions();\n     if (enableAmbiguousFunctionCheck) {\n-      compiler.getOptions().setWarningLevel(\n+      options.setWarningLevel(\n           DiagnosticGroups.AMBIGUOUS_FUNCTION_DECL, CheckLevel.WARNING);\n     }\n-\n+    return options;\n+  }\n+\n+  @Override\n+  public CompilerPass getProcessor(Compiler compiler) {\n     // Treats bad reads as errors, and reports bad write warnings.\n     return new VariableReferenceCheck(compiler, CheckLevel.WARNING);\n   }", "timestamp": 1281662845, "metainfo": ""}