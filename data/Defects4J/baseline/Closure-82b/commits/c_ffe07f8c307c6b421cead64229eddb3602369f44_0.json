{"sha": "ffe07f8c307c6b421cead64229eddb3602369f44", "log": "Add --define flag to the API. Remove the warning for ambiguous function definitions: it's not yet fully baked. Fix a bug in data-flow based variable inlining.    ", "commit": "\n--- a/src/com/google/javascript/jscomp/AbstractCompilerRunner.java\n+++ b/src/com/google/javascript/jscomp/AbstractCompilerRunner.java\n \n package com.google.javascript.jscomp;\n \n+import com.google.common.annotations.VisibleForTesting;\n import com.google.common.base.Preconditions;\n import com.google.common.collect.ImmutableList;\n import com.google.common.collect.Maps;\n import java.util.List;\n import java.util.Map;\n import java.util.logging.Level;\n-\n \n /**\n  * AbstractCompilerRunner encapsulates the logic required to run the Compiler.\n   public static final Flag<List<String>> FLAG_jscomp_off =\n       Flag.stringCollector();\n \n+  @FlagSpec(altName = \"D\",\n+      help = \"Override the value of a variable annotated @define. \" +\n+      \"The format is <name>[=<val>], where <name> is the name of a @define \" +\n+      \"variable and <val> is a boolean, number, or a single-quoted string \" +\n+      \"that contains no single quotes. If [=<val>] is omitted, \" +\n+      \"the variable is marked true.\")\n+  public static final Flag<List<String>> FLAG_define = Flag.stringCollector();\n+\n   private PrintStream out;\n   private final PrintStream err;\n   private A compiler;\n    * will not return null when createOptions() is called.\n    */\n   protected abstract B createOptions();\n+\n+  final protected void initOptionsFromFlags(CompilerOptions options) {\n+\n+    DiagnosticGroups.setWarningLevels(\n+        options, AbstractCompilerRunner.FLAG_jscomp_error.get(),\n+        CheckLevel.ERROR);\n+    DiagnosticGroups.setWarningLevels(\n+        options, AbstractCompilerRunner.FLAG_jscomp_warning.get(),\n+        CheckLevel.WARNING);\n+    DiagnosticGroups.setWarningLevels(\n+        options, AbstractCompilerRunner.FLAG_jscomp_off.get(),\n+        CheckLevel.OFF);\n+\n+    createDefineReplacements(FLAG_define.get(), options);\n+  }\n \n   final protected A getCompiler() {\n     return compiler;\n       }\n     }\n   }\n+\n+  /**\n+   * Create a map of constant names to constant values from a textual\n+   * description of the map.\n+   *\n+   * @param definitions A list of overriding definitions for defines in\n+   *     the form <name>[=<val>], where <val> is a number, boolean, or\n+   *     single-quoted string without single quotes.\n+   */\n+  @VisibleForTesting\n+  static void createDefineReplacements(List<String> definitions,\n+      CompilerOptions options) {\n+    // Parse the definitions\n+    for (String override : definitions) {\n+      String[] assignment = override.split(\"=\", 2);\n+      String defName = assignment[0];\n+\n+      if (defName.length() > 0) {\n+        if (assignment.length == 1) {\n+          options.setDefineToBooleanLiteral(defName, true);\n+          continue;\n+        } else {\n+          String defValue = assignment[1];\n+\n+          if (defValue.equals(\"true\")) {\n+            options.setDefineToBooleanLiteral(defName, true);\n+            continue;\n+          } else if (defValue.equals(\"false\")) {\n+            options.setDefineToBooleanLiteral(defName, false);\n+            continue;\n+          } else if (defValue.length() > 1 &&\n+              defValue.charAt(0) == '\\'' &&\n+              defValue.charAt(defValue.length() - 1) == '\\'') {\n+            // If the value starts and ends with a single quote,\n+            // we assume that it's a string.\n+            String maybeStringVal =\n+                defValue.substring(1, defValue.length() - 1);\n+            if (maybeStringVal.indexOf('\\'') == -1) {\n+              options.setDefineToStringLiteral(defName, maybeStringVal);\n+              continue;\n+            }\n+          } else {\n+            try {\n+              options.setDefineToDoubleLiteral(defName,\n+                  Double.parseDouble(defValue));\n+              continue;\n+            } catch (NumberFormatException e) {\n+              // do nothing, it will be caught at the end\n+            }\n+          }\n+        }\n+      }\n+\n+      throw new RuntimeException(\n+          \"--define flag syntax invalid: \" + override);\n+    }\n+  }\n }\n--- a/src/com/google/javascript/jscomp/CompilerRunner.java\n+++ b/src/com/google/javascript/jscomp/CompilerRunner.java\n       options.closurePass = true;\n     }\n \n-    DiagnosticGroups.setWarningLevels(\n-        options, AbstractCompilerRunner.FLAG_jscomp_error.get(),\n-        CheckLevel.ERROR);\n-    DiagnosticGroups.setWarningLevels(\n-        options, AbstractCompilerRunner.FLAG_jscomp_warning.get(),\n-        CheckLevel.WARNING);\n-    DiagnosticGroups.setWarningLevels(\n-        options, AbstractCompilerRunner.FLAG_jscomp_off.get(),\n-        CheckLevel.OFF);\n-\n+    initOptionsFromFlags(options);\n     return options;\n   }\n \n--- a/src/com/google/javascript/jscomp/JSModuleGraph.java\n+++ b/src/com/google/javascript/jscomp/JSModuleGraph.java\n package com.google.javascript.jscomp;\n \n import com.google.common.collect.Iterables;\n+import com.google.common.collect.LinkedHashMultimap;\n import com.google.common.collect.Maps;\n import com.google.common.collect.Multimap;\n-import com.google.common.collect.Multimaps;\n \n import java.util.ArrayList;\n import java.util.Collection;\n import java.util.Map;\n import java.util.Set;\n import java.util.TreeSet;\n-\n \n /**\n  * A {@link JSModule} dependency graph that assigns a depth to each module and\n    * to avoid such an error.\n    */\n   public void coalesceDuplicateFiles() {\n-    Multimap<String, JSModule> fileRefs = Multimaps.newLinkedHashMultimap();\n+    Multimap<String, JSModule> fileRefs = LinkedHashMultimap.create();\n     for (JSModule module : moduleDepths.keySet()) {\n       for (CompilerInput jsFile : module.getInputs()) {\n         fileRefs.put(jsFile.getName(), module);\n--- a/src/com/google/javascript/jscomp/MustBeReachingVariableDef.java\n+++ b/src/com/google/javascript/jscomp/MustBeReachingVariableDef.java\n       this();\n       while(vars.hasNext()) {\n         Var var = vars.next();\n-        if (NodeUtil.isVar(var.getParentNode())) {\n-          reachingDef.put(var, new Definition(var.scope.getRootNode()));\n-        }\n+        // Every variable in the scope is defined once in the beginning of the\n+        // function: all the declared variables are undefined, all functions\n+        // have been assigned and all arguments has its value from the caller.\n+        reachingDef.put(var, new Definition(var.scope.getRootNode()));\n       }\n     }\n \n--- a/src/com/google/javascript/jscomp/VarCheck.java\n+++ b/src/com/google/javascript/jscomp/VarCheck.java\n     DiagnosticType.error(\"JSC_INVALID_FUNCTION_DECL\",\n         \"Syntax error: function declaration must have a name\");\n \n-  static final DiagnosticType AMBIGUOUS_FUNCTION_DECL =\n-    DiagnosticType.warning(\"AMBIGUIOUS_FUNCTION_DECL\",\n-        \"Conditional named functions have inconsistent behavior. Instead of\" +\n-        \" 'function f(){}' use 'var f = function(){}'.\");\n-\n   private CompilerInput synthesizedExternsInput = null;\n   private Node synthesizedExternsRoot = null;\n \n         t.report(n, INVALID_FUNCTION_DECL);\n       }\n       return;\n-    }\n-\n-    if (NodeUtil.isFunctionDeclaration(parent)) {\n-      // Warn about having conditional named function declarations as IE and\n-      // FireFox handle them differently.\n-      if (!isHoistedFunction(parent)) {\n-        t.report(n, AMBIGUOUS_FUNCTION_DECL);\n-      }\n     }\n \n     // Check that the var has been declared.\n     }\n     return synthesizedExternsRoot;\n   }\n-\n-  /**\n-   * @return Whether the name function will be hoisted in its scope.\n-   */\n-  boolean isHoistedFunction(Node fn) {\n-    Preconditions.checkArgument(NodeUtil.isFunctionDeclaration(fn));\n-    return fn.getParent().getType() == Token.SCRIPT\n-        || fn.getParent().getParent().getType() == Token.FUNCTION;\n-  }\n }\n--- a/test/com/google/javascript/jscomp/CompilerRunnerTest.java\n+++ b/test/com/google/javascript/jscomp/CompilerRunnerTest.java\n \n   public void testCheckSymbolsOffForDefault() {\n     CompilerRunner.FLAG_warning_level.setForTest(WarningLevel.DEFAULT);\n-    testSame(\"x = 3; var y; var y;\");\n+    test(\"x = 3; var y; var y;\", \"x=3; var y;\");\n   }\n \n   public void testCheckSymbolsOnForVerbose() {\n   public void testDuplicateParams() {\n     test(\"function (a, a) {}\", RhinoErrorReporter.DUPLICATE_PARAM);\n     assertTrue(lastCompiler.hasHaltingErrors());\n+  }\n+\n+  public void testDefineFlag() {\n+    AbstractCompilerRunner.FLAG_define.setForTest(\n+        Lists.newArrayList(\"FOO\", \"BAR=5\"));\n+    test(\"/** @define {boolean} */ var FOO = false;\" +\n+         \"/** @define {number} */ var BAR = 3;\",\n+         \"var FOO = true, BAR = 5;\");\n   }\n \n   /* Helper functions */\n     compiler.init(externs, inputs, new CompilerOptions());\n     Node all = compiler.parseInputs();\n     Node n = all.getLastChild();\n-    Node externs = all.getFirstChild();\n-    (new Normalize(compiler, false)).process(externs, n);\n-    (new MakeDeclaredNamesUnique.UndoConstantRenaming(compiler)).process(\n-        externs, n);\n-    (MakeDeclaredNamesUnique.getContextualRenameInverter(compiler)).process(\n-        externs, n);\n     return n;\n   }\n }\n--- a/test/com/google/javascript/jscomp/FlowSensitiveInlineVariablesTest.java\n+++ b/test/com/google/javascript/jscomp/FlowSensitiveInlineVariablesTest.java\n     inline(\"var x = 1; L: M: N: x = 2; print(x)\", \"var x = 1; print(2)\");\n   }\n   \n+  public void testInlineArguments() {\n+    testSame(\"function _func(x) { print(x) }\");\n+    testSame(\"function _func(x,y) { if(y) { x = 1 }; print(x) }\");\n+    \n+    test(\"function(x, y) { x = 1; print(x) }\",\n+         \"function(x, y) { print(1) }\");\n+\n+    test(\"function(x, y) { if (y) { x = 1; print(x) }}\",\n+         \"function(x, y) { if (y) { print(1) }}\");\n+  }\n+  \n   private void noInline(String input) {\n     inline(input, input);\n   }\n--- a/test/com/google/javascript/jscomp/MustBeReachingVariableDefTest.java\n+++ b/test/com/google/javascript/jscomp/MustBeReachingVariableDefTest.java\n     assertMatch(\"var x; D: x--; U: x\");\n   }\n \n+  public void testFunctionParams1() {\n+    computeDefUse(\"if (param2) { D: param1 = 1; U: param1 }\");\n+    assertSame(def, defUse.getDef(\"param1\", use));  \n+  }\n+  \n+  public void testFunctionParams2() {\n+    computeDefUse(\"if (param2) { D: param1 = 1} U: param1\");\n+    assertNotSame(def, defUse.getDef(\"param1\", use));\n+  }\n+  \n   /**\n    * The use of x at U: is the definition of x at D:.\n    */\n--- a/test/com/google/javascript/jscomp/VarCheckTest.java\n+++ b/test/com/google/javascript/jscomp/VarCheckTest.java\n     testSame(\"var a = 3; (function a() { return a(); })();\");\n   }\n \n-  public void testAmbiguousFunctionDeclarations() {\n-    testSame(\"if (1) { function f(){}; }\", VarCheck.AMBIGUOUS_FUNCTION_DECL);\n-    testSame(\"{ function f(){}; }\", VarCheck.AMBIGUOUS_FUNCTION_DECL);\n-    testSame(\"a:function f(){};\", VarCheck.AMBIGUOUS_FUNCTION_DECL);\n-\n-    testSame(\"function f(){}\");\n-    testSame(\"(function(){ function f(){} })\");\n-  }\n-\n   public void testLegalVarReferenceBetweenModules() {\n     testDependentModules(\"var x = 10;\", \"var y = x++;\", null);\n   }", "timestamp": 1259602237, "metainfo": ""}