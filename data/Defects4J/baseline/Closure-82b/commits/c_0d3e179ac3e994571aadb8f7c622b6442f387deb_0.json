{"sha": "0d3e179ac3e994571aadb8f7c622b6442f387deb", "log": "-Don't recognize goog.mixin(A, B) as an inhertitance pattern. Recognize only goog.mixin(A.prototype, B.prototype).  R=nicksantos DELTA=49  (28 added, 10 deleted, 11 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=427   ", "commit": "\n--- a/src/com/google/javascript/jscomp/ClosureCodingConvention.java\n+++ b/src/com/google/javascript/jscomp/ClosureCodingConvention.java\n       // SubClass.mixin(SuperClass.prototype)\n       // goog.mixin(SubClass.prototype, SuperClass.prototype)\n       // goog$mixin(SubClass.prototype, SuperClass.prototype)\n-      if (callNode.getChildCount() == 2 &&\n-          callName.getType() == Token.GETPROP) {\n+      boolean isDeprecatedCall = callNode.getChildCount() == 2 &&\n+          callName.getType() == Token.GETPROP;\n+      if (isDeprecatedCall) {\n         // SubClass.inherits(SuperClass)\n         subclass = callName.getFirstChild();\n       } else if (callNode.getChildCount() == 3) {\n         // goog.inherits(SubClass, SuperClass)\n         subclass = callName.getNext();\n+      }\n+\n+      if (type == SubclassType.MIXIN) {\n+        // Only consider mixins that mix two prototypes as related to inheritance.\n+        if (!endsWithPrototype(superclass)) {\n+          return null;\n+        }\n+        if (!isDeprecatedCall) {\n+          if (!endsWithPrototype(subclass)) {\n+            return null;\n+          }\n+          // Strip off the prototype from the name.\n+          subclass = subclass.getFirstChild();\n+        }\n+        superclass = superclass.getFirstChild();\n       }\n \n       // bail out if either of the side of the \"inherits\"\n       if (subclass != null &&\n           subclass.isUnscopedQualifiedName() &&\n           superclass.isUnscopedQualifiedName()) {\n-        // make sure to strip the prototype off of the nodes\n-        // to normalize for goog.mixin\n-        return new SubclassRelationship(\n-            type,\n-            stripPrototype(subclass),\n-            stripPrototype(superclass));\n+        return new SubclassRelationship(type, subclass, superclass);\n       }\n     }\n \n   }\n \n   /**\n-   * Given a qualified name node, strip \"prototype\" off the end.\n-   *\n-   * Examples of this transformation:\n-   * a.b.c => a.b.c\n-   * a.b.c.prototype => a.b.c\n-   */\n-  private Node stripPrototype(Node qualifiedName) {\n-    if (qualifiedName.getType() == Token.GETPROP &&\n-        qualifiedName.getLastChild().getString().equals(\"prototype\")) {\n-      return qualifiedName.getFirstChild();\n-    }\n-\n-    return qualifiedName;\n+   * Given a qualified name node, returns whether \"prototype\" is at the end.\n+   * For example:\n+   * a.b.c => false\n+   * a.b.c.prototype => true\n+   */\n+  private boolean endsWithPrototype(Node qualifiedName) {\n+    return qualifiedName.getType() == Token.GETPROP &&\n+        qualifiedName.getLastChild().getString().equals(\"prototype\");\n   }\n \n   /**\n--- a/test/com/google/javascript/jscomp/ClosureCodingConventionTest.java\n+++ b/test/com/google/javascript/jscomp/ClosureCodingConventionTest.java\n         \"A\", \"B\");\n   }\n \n+  public void testInheritanceDetection11() {\n+    assertNotClassDefining(\"A.mixin(B)\");\n+  }\n+  \n+  public void testInheritanceDetection12() {\n+    assertNotClassDefining(\"goog.mixin(A.prototype, B)\");\n+  }\n+  \n+  public void testInheritanceDetection13() {\n+    assertNotClassDefining(\"goog.mixin(A, B)\");\n+  }\n+  \n   public void testInheritanceDetectionPostCollapseProperties() {\n     assertDefinesClasses(\"goog$inherits(A, B);\", \"A\", \"B\");\n     assertNotClassDefining(\"goog$inherits(A);\");", "timestamp": 1296756087, "metainfo": ""}