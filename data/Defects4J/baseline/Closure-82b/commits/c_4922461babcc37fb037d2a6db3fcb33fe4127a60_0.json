{"sha": "4922461babcc37fb037d2a6db3fcb33fe4127a60", "log": "Fix a bug in expression decomposition (Alan)    ", "commit": "\n--- a/src/com/google/javascript/jscomp/DefaultPassConfig.java\n+++ b/src/com/google/javascript/jscomp/DefaultPassConfig.java\n \n     if (options.flowSensitiveInlineVariables) {\n       passes.add(flowSensitiveInlineVariables);\n+\n+      // After inlining some of the variable uses, some variables are unused.\n+      // Re-run remove unused vars to clean it up.\n+      if (options.removeUnusedVars) {\n+        passes.add(removeUnusedVars);\n+      }\n     }\n \n     if (options.collapseAnonymousFunctions) {\n--- a/src/com/google/javascript/jscomp/ExpressionDecomposer.java\n+++ b/src/com/google/javascript/jscomp/ExpressionDecomposer.java\n     Node replacementValueNode = Node.newString(Token.NAME, tempName);\n     parent.replaceChild(expr, replacementValueNode);\n \n-    // Readd the expression in the declaration of the temporary name.\n+    // Re-add the expression in the declaration of the temporary name.\n     Node tempNameNode = Node.newString(Token.NAME, tempName);\n     tempNameNode.addChildrenToBack(expr);\n     Node tempVarNode = new Node(Token.VAR, tempNameNode);\n     Node injectionPointParent = injectionPoint.getParent();\n     injectionPointParent.addChildBefore(tempVarNode, injectionPoint);\n \n+    // If it is ASSIGN_XXX we need to assign it back to the original value.\n+    // Note that calling the temp constant is a lie in this case, but we do know\n+    // that it is not modified until after the exposed expression.\n+    if (NodeUtil.isAssignmentOp(parent) && !NodeUtil.isAssign(parent)) {\n+      Node gParent = parent.getParent();\n+      Node assignBack = new Node(Token.ASSIGN,\n+          expr.cloneTree(),\n+          tempNameNode.cloneNode());\n+      if (NodeUtil.isExpressionNode(gParent)) {\n+        gParent.getParent().addChildAfter(\n+            NodeUtil.newExpr(assignBack), gParent);\n+      } else {\n+        // TODO(user): Use comma here sucks. We might close some accuracy\n+        // in flow sensitive passes but as far as I know it is unavoidable.\n+        Node comma = new Node(Token.COMMA);\n+        gParent.replaceChild(parent, comma);\n+        comma.addChildrenToFront(assignBack);\n+        comma.addChildrenToFront(parent);\n+      }\n+    }\n     return tempVarNode;\n   }\n \n--- a/test/com/google/javascript/jscomp/ExpresssionDecomposerTest.java\n+++ b/test/com/google/javascript/jscomp/ExpresssionDecomposerTest.java\n     helperCanExposeExpression(\n         DecompositionType.UNDECOMPOSABLE, \"while(foo());\", \"foo\");\n     helperCanExposeExpression(\n+        DecompositionType.UNDECOMPOSABLE, \"while(x = goo()&&foo()){}\", \"foo\");\n+    helperCanExposeExpression(\n+        DecompositionType.UNDECOMPOSABLE, \"while(x += goo()&&foo()){}\", \"foo\");\n+    \n+    helperCanExposeExpression(\n         DecompositionType.UNDECOMPOSABLE, \"do{}while(foo());\", \"foo\");\n     helperCanExposeExpression(\n         DecompositionType.UNDECOMPOSABLE, \"for(;foo(););\", \"foo\");\n     helperCanExposeExpression(\n         DecompositionType.DECOMPOSABLE, \"x = goo() && foo()\", \"foo\");\n     helperCanExposeExpression(\n+        DecompositionType.DECOMPOSABLE, \"x += goo() && foo()\", \"foo\");\n+    helperCanExposeExpression(\n         DecompositionType.DECOMPOSABLE, \"var x = goo() && foo()\", \"foo\");\n     helperCanExposeExpression(\n         DecompositionType.DECOMPOSABLE, \"if(goo() && foo()){}\", \"foo\");\n         DecompositionType.DECOMPOSABLE, \"switch(goo() && foo()){}\", \"foo\");\n     helperCanExposeExpression(\n         DecompositionType.DECOMPOSABLE, \"switch(goo() && foo()){}\", \"foo\");\n+    helperCanExposeExpression(\n+        DecompositionType.DECOMPOSABLE, \"switch(x = goo() && foo()){}\", \"foo\");\n     helperCanExposeExpression(\n         DecompositionType.DECOMPOSABLE,\n         \"function (){ return goo() && foo();}\", \"foo\");\n         \"var temp_2;\" +\n         \"if (1) temp_2 = foo(); else temp_2 = 0;\" +\n         \"if (temp_const_1(1, temp_const_0, temp_2));\");\n+  }\n+  \n+  public void testExposePlusEquals() {\n+    helperExposeExpression(\n+        \"var x = 0; x += foo() + 1\",\n+        \"foo\",\n+        \"var x = 0; var temp_const_0 = x;\" +\n+        \"temp_const_0 += foo() + 1;\" +\n+        \"x = temp_const_0;\");\n+\n+    helperExposeExpression(\n+        \"var x = 0; y = (x += foo()) + x\",\n+        \"foo\",\n+        \"var x = 0; var temp_const_0 = x;\" +\n+        \"y = (temp_const_0 += foo(), x=temp_const_0) + x\");\n   }\n \n   /** Test case helpers. */\n--- a/test/com/google/javascript/jscomp/InlineFunctionsTest.java\n+++ b/test/com/google/javascript/jscomp/InlineFunctionsTest.java\n     testSame(\"function f(){call(function(){return})}f()\");\n   }\n \n+  public void testDecomposePlusEquals() {\n+    test(\"function f(){a=1;return 1} var x = 1; x += f()\",\n+        \"var x = 1;\" +\n+        \"var JSCompiler_temp_const_0 = x;\" +\n+        \"{var JSCompiler_inline_result_1; a=1; JSCompiler_inline_result_1=1}\" +\n+        \"JSCompiler_temp_const_0 += JSCompiler_inline_result_1;\" +\n+        \"x = JSCompiler_temp_const_0\");\n+  }\n+  \n   public void testInlineConstructor1() {\n     test(\"function f() {} function _g() {f.call(this)}\",\n          \"function _g() {void 0}\");", "timestamp": 1267056883, "metainfo": ""}