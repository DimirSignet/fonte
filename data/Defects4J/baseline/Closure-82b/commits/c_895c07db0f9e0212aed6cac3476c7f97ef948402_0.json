{"sha": "895c07db0f9e0212aed6cac3476c7f97ef948402", "log": "In a world where the compiler figures out dependency info and auto-excludes files that aren't required, it's not scalable to parse every file. So switch to a source-based dependency analyzer. (Nick) R=andrew,andrew,robert DELTA=226  (146 added, 8 deleted, 72 changed)  Revision created by MOE tool push_codebase. MOE_MIGRATION=azbmqm   ", "commit": "\n--- a/src/com/google/javascript/jscomp/CompilerInput.java\n+++ b/src/com/google/javascript/jscomp/CompilerInput.java\n package com.google.javascript.jscomp;\n \n import com.google.common.base.Preconditions;\n+import com.google.common.collect.ImmutableList;\n import com.google.common.collect.ImmutableSet;\n import com.google.common.collect.Lists;\n import com.google.common.collect.Sets;\n import com.google.javascript.jscomp.NodeTraversal.AbstractShallowCallback;\n import com.google.javascript.jscomp.deps.DependencyInfo;\n+import com.google.javascript.jscomp.deps.JsFileParser;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n \n import java.io.IOException;\n import java.util.Collection;\n+import java.util.Collections;\n import java.util.List;\n import java.util.Set;\n \n   // Provided and required symbols.\n   private final Set<String> provides = Sets.newHashSet();\n   private final Set<String> requires = Sets.newHashSet();\n+  private boolean generatedDependencyInfoFromSource = false;\n+\n+  // An error manager for handling problems when dealing with\n+  // provides/requires.\n+  private ErrorManager errorManager;\n+\n+  // An AbstractCompiler for doing parsing.\n+  private AbstractCompiler compiler;\n \n   public CompilerInput(SourceAst ast) {\n     this(ast, ast.getSourceFile().getName(), false);\n     return ast;\n   }\n \n+  /** Sets an error manager for routing error messages. */\n+  public void setErrorManager(ErrorManager errorManager) {\n+    this.errorManager = errorManager;\n+  }\n+\n+  /** Sets an abstract compiler for doing parsing. */\n+  public void setCompiler(AbstractCompiler compiler) {\n+    this.compiler = compiler;\n+    setErrorManager(compiler.getErrorManager());\n+  }\n+\n   /** Gets a list of types depended on by this input. */\n-  public Collection<String> getRequires(AbstractCompiler compiler) {\n-    if (getAstRoot(compiler) != null) {\n-      DepsFinder deps = new DepsFinder(compiler, true);\n-      NodeTraversal.traverse(compiler, getAstRoot(compiler), deps);\n-      requires.addAll(deps.types);\n-      return requires;\n+  @Override\n+  public Collection<String> getRequires() {\n+    Preconditions.checkNotNull(errorManager,\n+        \"Expected setErrorManager to be called first\");\n+    try {\n+      regenerateDependencyInfoIfNecessary();\n+      return Collections.<String>unmodifiableSet(requires);\n+    } catch (IOException e) {\n+      errorManager.report(CheckLevel.ERROR,\n+          JSError.make(AbstractCompiler.READ_ERROR, getName()));\n+      return ImmutableList.<String>of();\n+    }\n+  }\n+\n+  /** Gets a list of types provided by this input. */\n+  @Override\n+  public Collection<String> getProvides() {\n+    Preconditions.checkNotNull(errorManager,\n+        \"Expected setErrorManager to be called first\");\n+    try {\n+      regenerateDependencyInfoIfNecessary();\n+      return Collections.<String>unmodifiableSet(provides);\n+    } catch (IOException e) {\n+      errorManager.report(CheckLevel.ERROR,\n+          JSError.make(AbstractCompiler.READ_ERROR, getName()));\n+      return ImmutableList.<String>of();\n+    }\n+  }\n+\n+  /**\n+   * Regenerates the provides/requires if we need to do so.\n+   */\n+  private void regenerateDependencyInfoIfNecessary() throws IOException {\n+    // If the code is NOT a JsAst, then it was not originally JS code.\n+    // Look at the Ast for dependency info.\n+    if (!(ast instanceof JsAst)) {\n+      Preconditions.checkNotNull(compiler,\n+          \"Expected setCompiler to be called first\");\n+      DepsFinder finder = new DepsFinder();\n+      Node root = getAstRoot(compiler);\n+      if (root == null) {\n+        return;\n+      }\n+\n+      finder.visitTree(getAstRoot(compiler));\n+\n+      // TODO(nicksantos|user): This caching behavior is a bit\n+      // odd, and only works if you assume the exact call flow that\n+      // clients are currently using.  In that flow, they call\n+      // getProvides(), then remove the goog.provide calls from the\n+      // AST, and then call getProvides() again.\n+      //\n+      // This won't work for any other call flow, or any sort of incremental\n+      // compilation scheme. The API needs to be fixed so callers aren't\n+      // doing weird things like this, and then we should get rid of the\n+      // multiple-scan strategy.\n+\n+      provides.addAll(finder.provides);\n+      requires.addAll(finder.requires);\n     } else {\n-      return ImmutableSet.<String>of();\n-    }\n-  }\n-\n-  /** Gets a list of types depended on by this input. */\n-  @Override\n-  public Collection<String> getRequires() {\n-    // TODO(nicksantos): Implement me.\n-    throw new UnsupportedOperationException();\n-  }\n-\n-  /** Gets a list of types provided by this input. */\n-  public Collection<String> getProvides(AbstractCompiler compiler) {\n-    if (getAstRoot(compiler) != null) {\n-      DepsFinder deps = new DepsFinder(compiler, false);\n-      NodeTraversal.traverse(compiler, getAstRoot(compiler), deps);\n-      provides.addAll(deps.types);\n-      return provides;\n-    } else {\n-      return ImmutableSet.<String>of();\n-    }\n-  }\n-\n-  /** Gets a list of types provided by this input. */\n-  @Override\n-  public Collection<String> getProvides() {\n-    // TODO(nicksantos): Implement me.\n-    throw new UnsupportedOperationException();\n-  }\n-\n-  private class DepsFinder extends AbstractShallowCallback {\n-    private boolean findRequire;\n-    private List<String> types;\n-    private CodingConvention codingConvention;\n-\n-    DepsFinder(AbstractCompiler compiler, boolean findRequire) {\n-      this.findRequire = findRequire;\n-      this.codingConvention = compiler.getCodingConvention();\n-      this.types = Lists.newArrayList();\n-    }\n-\n-    public void visit(NodeTraversal t, Node n, Node parent) {\n-      switch (n.getType()) {\n-        case Token.CALL:\n-          String className = findRequire\n-              ? codingConvention.extractClassNameIfRequire(n, parent)\n-              : codingConvention.extractClassNameIfProvide(n, parent);\n-          if (className != null) {\n-            types.add(className);\n-          }\n-          break;\n+      // Otherwise, look at the source code.\n+      if (!generatedDependencyInfoFromSource) {\n+        // Note: it's ok to use getName() instead of\n+        // getPathRelativeToClosureBase() here because we're not using\n+        // this to generate deps files. (We're only using it for\n+        // symbol dependencies.)\n+        DependencyInfo info = (new JsFileParser(errorManager)).parseFile(\n+            getName(), getName(), getCode());\n+\n+        provides.addAll(info.getProvides());\n+        requires.addAll(info.getRequires());\n+\n+        generatedDependencyInfoFromSource = true;\n+      }\n+    }\n+  }\n+\n+  private static class DepsFinder {\n+    private final List<String> provides = Lists.newArrayList();\n+    private final List<String> requires = Lists.newArrayList();\n+    private final CodingConvention codingConvention =\n+        new ClosureCodingConvention();\n+\n+    void visitTree(Node n) {\n+      visitSubtree(n, null);\n+    }\n+\n+    void visitSubtree(Node n, Node parent) {\n+      if (n.getType() == Token.CALL) {\n+        String require =\n+            codingConvention.extractClassNameIfRequire(n, parent);\n+        if (require != null) {\n+          requires.add(require);\n+        }\n+\n+        String provide =\n+            codingConvention.extractClassNameIfProvide(n, parent);\n+        if (provide != null) {\n+          provides.add(provide);\n+        }\n+        return;\n+      } else if (parent != null &&\n+          parent.getType() != Token.EXPR_RESULT &&\n+          parent.getType() != Token.SCRIPT) {\n+        return;\n+      }\n+\n+      for (Node child = n.getFirstChild();\n+           child != null; child = child.getNext()) {\n+        visitSubtree(child, n);\n       }\n     }\n   }\n--- a/src/com/google/javascript/jscomp/JSModule.java\n+++ b/src/com/google/javascript/jscomp/JSModule.java\n     final Map<String, CompilerInput> provides = Maps.newHashMap();\n     // Collect all symbols provided in these files.\n     for (CompilerInput input : inputs) {\n-      for (String provide : input.getProvides(compiler)) {\n+      input.setCompiler(compiler);\n+      for (String provide : input.getProvides()) {\n         provides.put(provide, input);\n       }\n     }\n     final Multimap<CompilerInput, CompilerInput> deps =\n         HashMultimap.create();\n     for (CompilerInput input : inputs) {\n-      for (String req : input.getRequires(compiler)) {\n+      for (String req : input.getRequires()) {\n         CompilerInput dep = provides.get(req);\n         if (dep != null) {\n           deps.put(input, dep);\n--- /dev/null\n+++ b/src/com/google/javascript/jscomp/deps/DepsFileParser.java\n+/*\n+ * Copyright 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp.deps;\n+\n+import com.google.common.base.Charsets;\n+import com.google.common.collect.Lists;\n+import com.google.common.io.Files;\n+import com.google.javascript.jscomp.ErrorManager;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * A parser that can extract dependency information from existing deps.js files.\n+ *\n+ * <p>See //javascript/closure/deps.js for an example file.</p>\n+ *\n+ * @author agrieve@google.com (Andrew Grieve)\n+ */\n+public class DepsFileParser extends JsFileLineParser {\n+\n+  private static Logger logger = Logger.getLogger(DepsFileParser.class.getName());\n+\n+  /**\n+   * Pattern for matching JavaScript string literals. The group is:\n+   * goog.addDependency({1});\n+   */\n+  private final Matcher depMatcher =\n+      Pattern.compile(\"\\\\s*goog.addDependency\\\\((.*)\\\\);?\\\\s*\").matcher(\"\");\n+\n+  /**\n+   * Pattern for matching the args of a goog.addDependency(). The group is:\n+   * goog.addDependency({1}, {2}, {3});\n+   */\n+  private final Matcher depArgsMatch =\n+      Pattern.compile(\"\\\\s*([^,]*), (\\\\[[^\\\\]]*\\\\]), (\\\\[[^\\\\]]*\\\\])\\\\s*\").matcher(\"\");\n+\n+  /**\n+   * The dependency information extracted from the current file.\n+   */\n+  private List<DependencyInfo> depInfos;\n+\n+  /**\n+   * Constructor\n+   *\n+   * @param errorManager Handles parse errors.\n+   */\n+  public DepsFileParser(ErrorManager errorManager) {\n+    super(errorManager);\n+  }\n+\n+  /**\n+   * Parses the given file and returns a list of dependency information that it\n+   * contained.\n+   *\n+   * @param filePath Path to the file to parse.\n+   * @return A list of DependencyInfo objects.\n+   * @throws IOException Thrown if the file could not be read.\n+   */\n+  public List<DependencyInfo> parseFile(String filePath) throws IOException {\n+    return parseFile(filePath, Files.toString(new File(filePath), Charsets.UTF_8));\n+  }\n+\n+  /**\n+   * Parses the given file and returns a list of dependency information that it\n+   * contained.\n+   * It uses the passed in fileContents instead of reading the file.\n+   *\n+   * @param filePath Path to the file to parse.\n+   * @param fileContents The contents to parse.\n+   * @return A list of DependencyInfo objects.\n+   */\n+  public List<DependencyInfo> parseFile(String filePath, String fileContents) {\n+    depInfos = Lists.newArrayList();\n+    logger.info(\"Parsing Dep: \" + filePath);\n+    doParse(filePath, fileContents);\n+\n+    return depInfos;\n+  }\n+\n+  /**\n+   * Extracts dependency information from lines that look like\n+   *   goog.addDependency('pathRelativeToClosure', ['provides'], ['requires']);\n+   * Adds the dependencies to depInfos.\n+   *\n+   * @throws ParseException Thrown if the given line has a malformed\n+   *     goog.addDependency().\n+   */\n+  @Override\n+  protected void parseLine(String line) throws ParseException {\n+    depMatcher.reset(line);\n+    // See if the line looks like: goog.addDependency(...)\n+    if (depMatcher.matches()) {\n+      String addDependencyParams = depMatcher.group(1);\n+      depArgsMatch.reset(addDependencyParams);\n+      // Extract the three parameters.\n+      if (!depArgsMatch.matches()) {\n+        // Although we could recover, we mark this as fatal since there should\n+        // not be problems with generated deps.js files.\n+        throw new ParseException(\"Invalid arguments to goog.addDependency(). Found: \"\n+            + addDependencyParams, true);\n+      }\n+      // Parse the file path.\n+      String path = parseJsString(depArgsMatch.group(1));\n+      DependencyInfo depInfo = new SimpleDependencyInfo(path, filePath,\n+          // Parse the provides.\n+          parseJsStringArray(depArgsMatch.group(2)),\n+          // Parse the requires.\n+          parseJsStringArray(depArgsMatch.group(3)));\n+\n+      if (logger.isLoggable(Level.FINE)) {\n+        logger.fine(\"Found dep: \" + depInfo);\n+      }\n+      depInfos.add(depInfo);\n+    }\n+  }\n+}\n--- /dev/null\n+++ b/src/com/google/javascript/jscomp/deps/JsFileLineParser.java\n+/*\n+ * Copyright 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp.deps;\n+\n+import com.google.common.collect.Lists;\n+import com.google.javascript.jscomp.CheckLevel;\n+import com.google.javascript.jscomp.DiagnosticType;\n+import com.google.javascript.jscomp.ErrorManager;\n+import com.google.javascript.jscomp.JSError;\n+\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * Base class for classes that parse Javascript sources on a line-by-line basis. Strips comments\n+ * from files and records all parsing errors.\n+ *\n+ * @author agrieve@google.com (Andrew Grieve)\n+ */\n+public abstract class JsFileLineParser {\n+\n+  static final DiagnosticType PARSE_WARNING = DiagnosticType.warning(\n+      \"DEPS_PARSE_WARNING\", \"{0}\\n{1}\");\n+  static final DiagnosticType PARSE_ERROR = DiagnosticType.error(\n+      \"DEPS_PARSE_ERROR\", \"{0}\\n{1}\");\n+\n+  /**\n+   * Thrown by base classes to signify a problem parsing a line.\n+   */\n+  protected static class ParseException extends Exception {\n+    public static final long serialVersionUID = 1L;\n+    private boolean fatal;\n+\n+    /**\n+     * Constructor.\n+     *\n+     * @param message A description of what caused the exception.\n+     * @param fatal Whether the exception is recoverable.\n+     */\n+    public ParseException(String message, boolean fatal) {\n+      super(message);\n+      this.fatal = fatal;\n+    }\n+\n+    public boolean isFatal() {\n+      return fatal;\n+    }\n+  }\n+\n+  /** Pattern for stripping JavaScript comments from source files. */\n+  private static final Pattern STRIP_COMMENTS_PATTERN =\n+      Pattern.compile(\"/\\\\*.*?\\\\*/\" + // Multi-line comments\n+          \"|//.*?$\" // Single-line comments.\n+          , Pattern.DOTALL | Pattern.MULTILINE);\n+\n+  /** Pattern for matching JavaScript string literals. */\n+  private static final Pattern STRING_LITERAL_PATTERN = Pattern.compile(\n+      \"\\\\s*(?:'((?:\\\\\\\\'|[^'])*?)'|\\\"((?:\\\\\\\\\\\"|[^\\\"])*?)\\\")\\\\s*\");\n+\n+  /** Matcher used in the parsing comments. */\n+  private Matcher stripCommentsMatcher = STRIP_COMMENTS_PATTERN.matcher(\"\");\n+  /** Matcher used in the parsing string literals. */\n+  private Matcher valueMatcher = STRING_LITERAL_PATTERN.matcher(\"\");\n+\n+  /** Path of the file currently being parsed. */\n+  protected String filePath;\n+  /** The line number of the line currently being parsed. */\n+  protected int lineNum;\n+  /** Handles error messages. */\n+  protected ErrorManager errorManager;\n+  /** Did our parse succeed. */\n+  protected boolean parseSucceeded;\n+\n+  /**\n+   * Constructor.\n+   *\n+   * @param errorManager Parse error handler.\n+   */\n+  public JsFileLineParser(ErrorManager errorManager) {\n+    this.errorManager = errorManager;\n+  }\n+\n+  public boolean didParseSucceed() {\n+    return parseSucceeded;\n+  }\n+\n+  /**\n+   * Performs the line-by-line parsing of the given fileContents. This method\n+   * strips out Javascript comments and then uses the abstract parseLine()\n+   * method to do the line parsing.\n+   *\n+   * @param filePath The path to the file being parsed. Used for reporting parse\n+   *     exceptions.\n+   * @param fileContents The contents of the file.\n+   */\n+  protected void doParse(String filePath, String fileContents) {\n+    this.filePath = filePath;\n+    parseSucceeded = true;\n+\n+    // Strip all comments.\n+    stripCommentsMatcher.reset(fileContents);\n+    // TODO(agrieve): Multi-line comments will be removed, causing line-number reporting\n+    // to be wrong.\n+    fileContents = stripCommentsMatcher.replaceAll(\"\");\n+    lineNum = 0;\n+    // Parse all lines.\n+    for (String line : fileContents.split(\"\\n\")) {\n+      ++lineNum;\n+      try {\n+        parseLine(line);\n+      } catch (ParseException e) {\n+        // Inform the error handler of the exception.\n+        errorManager.report(\n+            e.isFatal() ? CheckLevel.ERROR : CheckLevel.WARNING,\n+            JSError.make(filePath, lineNum, 0 /* char offset */,\n+                e.isFatal() ? PARSE_ERROR : PARSE_WARNING,\n+                e.getMessage(), line));\n+        parseSucceeded = parseSucceeded && !e.isFatal();\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Called for each line of the file being parsed.\n+   *\n+   * @param line The line to parse.\n+   * @throws ParseException Should be thrown to signify a problem with the line.\n+   */\n+  protected abstract void parseLine(String line) throws ParseException;\n+\n+  /**\n+   * Parses a JS string literal.\n+   *\n+   * @param jsStringLiteral The literal. Must look like \"asdf\" or 'asdf'\n+   * @throws ParseException Thrown if there is a string literal that cannot be\n+   *     parsed.\n+   */\n+  protected String parseJsString(String jsStringLiteral) throws ParseException {\n+    valueMatcher.reset(jsStringLiteral);\n+    if (!valueMatcher.matches()) {\n+      throw new ParseException(\"Syntax error in JS String literal\", true /* fatal */);\n+    }\n+    return valueMatcher.group(1) != null ? valueMatcher.group(1) : valueMatcher.group(2);\n+  }\n+\n+  /**\n+   * Parses a Javascript array of string literals. (eg: ['a', 'b', \"c\"]).\n+   * @param input A string containing an Javascript array of string literals.\n+   * @return A list of parsed string literals.\n+   * @throws ParseException Thrown if there is a syntax error with the input.\n+   */\n+  List<String> parseJsStringArray(String input)\n+      throws ParseException {\n+    List<String> results = Lists.newArrayList();\n+    int indexStart = input.indexOf('[');\n+    int indexEnd = input.lastIndexOf(']');\n+    if ((indexStart == -1) || (indexEnd == -1)) {\n+      throw new ParseException(\"Syntax error when parsing JS array\", true /* fatal */);\n+    }\n+    String innerValues = input.substring(indexStart + 1, indexEnd);\n+\n+    if (!innerValues.trim().isEmpty()) {\n+      valueMatcher.reset(innerValues);\n+      for (;;) {\n+        // Parse the current string literal.\n+        if (!valueMatcher.lookingAt()) {\n+          throw new ParseException(\"Syntax error in JS String literal\", true /* fatal */);\n+        }\n+        // Add it to the results.\n+        results.add(valueMatcher.group(1) != null ?\n+            valueMatcher.group(1) : valueMatcher.group(2));\n+        if (valueMatcher.hitEnd()) {\n+          break;\n+        }\n+        // Ensure there is a comma after the value.\n+        if (innerValues.charAt(valueMatcher.end()) != ',') {\n+          throw new ParseException(\"Missing comma in string array\", true /* fatal */);\n+        }\n+        // Move to the next value.\n+        valueMatcher.region(valueMatcher.end() + 1, valueMatcher.regionEnd());\n+      }\n+    }\n+    return results;\n+  }\n+}\n--- /dev/null\n+++ b/src/com/google/javascript/jscomp/deps/JsFileParser.java\n+/*\n+ * Copyright 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp.deps;\n+\n+import com.google.common.base.Charsets;\n+import com.google.common.collect.Lists;\n+import com.google.common.io.Files;\n+import com.google.javascript.jscomp.ErrorManager;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.logging.Logger;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * A parser that can extract goog.require() and goog.provide() dependency\n+ * information from a .js file.\n+ *\n+ * @author agrieve@google.com (Andrew Grieve)\n+ */\n+public class JsFileParser extends JsFileLineParser {\n+\n+  private static Logger logger = Logger.getLogger(JsFileParser.class.getName());\n+\n+  /** Pattern for matching goog.provide(*) and goog.require(*). */\n+  private static final Pattern GOOG_PROVIDE_REQUIRE_PATTERN = Pattern.compile(\n+      \"(?:^|;)\\\\s*goog\\\\.(provide|require)\\\\s*\\\\((.*?)\\\\)\");\n+\n+  /** Matchers used in the parsing. */\n+  private Matcher googMatcher = GOOG_PROVIDE_REQUIRE_PATTERN.matcher(\"\");\n+\n+  /** The info for the file we are currently parsing. */\n+  private List<String> provides;\n+  private List<String> requires;\n+\n+  /**\n+   * Constructor\n+   *\n+   * @param errorManager Handles parse errors.\n+   */\n+  public JsFileParser(ErrorManager errorManager) {\n+    super(errorManager);\n+  }\n+\n+  /**\n+   * Parses the given file and returns the dependency information that it\n+   * contained.\n+   *\n+   * @param filePath Path to the file to parse.\n+   * @param closureRelativePath Path of the file relative to closure.\n+   * @return A DependencyInfo containing all provides/requires found in the\n+   *     file.\n+   * @throws IOException Thrown if there was an problem reading the given file.\n+   */\n+  public DependencyInfo parseFile(String filePath, String closureRelativePath)\n+      throws IOException {\n+    return parseFile(filePath, closureRelativePath,\n+        Files.toString(new File(filePath), Charsets.UTF_8));\n+  }\n+\n+  /**\n+   * Parses the given file and returns the dependency information that it\n+   * contained.\n+   *\n+   * @param filePath Path to the file to parse.\n+   * @param closureRelativePath Path of the file relative to closure.\n+   * @param fileContents The contents to parse.\n+   * @return A DependencyInfo containing all provides/requires found in the\n+   *     file.\n+   */\n+  public DependencyInfo parseFile(String filePath, String closureRelativePath,\n+      String fileContents) {\n+    provides = Lists.newArrayList();\n+    requires = Lists.newArrayList();\n+\n+    logger.fine(\"Parsing Source: \" + filePath);\n+    doParse(filePath, fileContents);\n+\n+    DependencyInfo dependencyInfo = new SimpleDependencyInfo(\n+        closureRelativePath, filePath, provides, requires);\n+    logger.fine(\"DepInfo: \" + dependencyInfo);\n+    return dependencyInfo;\n+  }\n+\n+  /**\n+   * Parses a line of javascript, extracting goog.provide and goog.require\n+   * information.\n+   */\n+  @Override\n+  protected void parseLine(String line) throws ParseException {\n+    // Iterate over the provides/requires.\n+    googMatcher.reset(line);\n+    while (googMatcher.find()) {\n+      // See if it's a require or provide.\n+      boolean isRequire = googMatcher.group(1).charAt(0) == 'r';\n+      // Parse the param.\n+      String arg = parseJsString(googMatcher.group(2));\n+\n+      // Add the dependency.\n+      if (isRequire) {\n+        // goog is always implicit.\n+        // TODO(nicksantos): I'm pretty sure we don't need this anymore.\n+        // Remove this later.\n+        if (!\"goog\".equals(arg)) {\n+          requires.add(arg);\n+        }\n+      } else {\n+        provides.add(arg);\n+      }\n+    }\n+  }\n+}", "timestamp": 1270075171, "metainfo": ""}