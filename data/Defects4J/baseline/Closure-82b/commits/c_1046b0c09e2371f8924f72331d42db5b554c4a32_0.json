{"sha": "1046b0c09e2371f8924f72331d42db5b554c4a32", "log": "Rewrite ProcessClosurePrimitives to have a distinct indexing and mutation step.    ", "commit": "\n--- a/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\n+++ b/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\n package com.google.javascript.jscomp;\n \n import com.google.common.base.Preconditions;\n+import com.google.common.collect.Lists;\n import com.google.common.collect.Maps;\n import com.google.common.collect.Sets;\n-import com.google.javascript.jscomp.CheckLevel;\n import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n \n-import java.util.ArrayList;\n-import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n   static final String GOOG = \"goog\";\n \n   private final AbstractCompiler compiler;\n-  private final List<UnrecognizedRequire> unrecognizedRequires;\n-  private final Map<String, ProvidedNode> providedNodes;\n+\n+  // The goog.provides must be processed in a deterministic order.\n+  private final Map<String, ProvidedName> providedNames =\n+      Maps.newLinkedHashMap();\n+\n+  private final List<UnrecognizedRequire> unrecognizedRequires =\n+      Lists.newArrayList();\n   private final Set<String> exportedVariables = Sets.newHashSet();\n   private final CheckLevel requiresLevel;\n   private final boolean rewriteNewDateGoogNow;\n                            CheckLevel requiresLevel,\n                            boolean rewriteNewDateGoogNow) {\n     this.compiler = compiler;\n-    this.unrecognizedRequires = new ArrayList<UnrecognizedRequire>();\n-    this.providedNodes = new HashMap<String, ProvidedNode>();\n     this.requiresLevel = requiresLevel;\n     this.rewriteNewDateGoogNow = rewriteNewDateGoogNow;\n \n     // goog is special-cased because it is provided in Closure's base library.\n-    providedNodes.put(GOOG, new ProvidedNode(null, null, null));\n+    providedNames.put(GOOG,\n+        new ProvidedName(GOOG, null, null, false /* implicit */));\n   }\n \n   Set<String> getExportedVariableNames() {\n   public void process(Node externs, Node root) {\n     new NodeTraversal(compiler, this).traverse(root);\n \n-    for (ProvidedNode pn : providedNodes.values()) {\n-      if (pn != null) {\n-        pn.maybeRemove();\n-      }\n+    for (ProvidedName pn : providedNames.values()) {\n+      pn.replace();\n     }\n \n     if (requiresLevel.isOn()) {\n       for (UnrecognizedRequire r : unrecognizedRequires) {\n         DiagnosticType error;\n-        if (providedNodes.get(r.namespace) != null) {\n+        if (providedNames.get(r.namespace) != null) {\n           // The namespace ended up getting provided after it was required.\n           error = LATE_PROVIDE_ERROR;\n         } else {\n    * {@inheritDoc}\n    */\n   public void visit(NodeTraversal t, Node n, Node parent) {\n+    // TODO(nicksantos): Clean this method up.\n     switch (n.getType()) {\n       case Token.CALL:\n         boolean isExpr = parent.getType() == Token.EXPR_RESULT;\n               Node arg = left.getNext();\n               if (verifyArgument(t, left, arg)) {\n                 String ns = arg.getString();\n-                ProvidedNode provided = providedNodes.get(ns);\n-                if (provided == null) {\n+                ProvidedName provided = providedNames.get(ns);\n+                if (provided == null || !provided.isExplicitlyProvided()) {\n                   unrecognizedRequires.add(\n                       new UnrecognizedRequire(n, ns, t.getSourceName()));\n                 } else {\n                   JSModule module = t.getModule();\n-                  if (module != provided.module /* covers null case */ &&\n+                  if (module != provided.firstModule /* covers null case */ &&\n                       !compiler.getModuleGraph().dependsOn(module,\n-                          provided.module)) {\n+                          provided.firstModule)) {\n                     compiler.report(\n                         JSError.make(t, n, XMODULE_REQUIRE_ERROR, ns,\n-                            provided.module.getName(),\n+                            provided.firstModule.getName(),\n                             module.getName()));\n                   }\n                 }\n               Node arg = left.getNext();\n               if (verifyProvide(t, left, arg)) {\n                 String ns = arg.getString();\n-                if (providedNodes.get(ns) != null) {\n-                  compiler.report(\n-                      JSError.make(t, n, DUPLICATE_NAMESPACE_ERROR, ns));\n-                } else if (!providedNodes.containsKey(ns)) {\n-                  replaceProvide(t, parent, parent.getParent(), ns);\n+                if (providedNames.containsKey(ns)) {\n+                  ProvidedName previouslyProvided = providedNames.get(ns);\n+                  if (!previouslyProvided.isExplicitlyProvided()) {\n+                    previouslyProvided.addProvide(parent, t.getModule(), true);\n+                  } else {\n+                    compiler.report(\n+                        JSError.make(t, n, DUPLICATE_NAMESPACE_ERROR, ns));\n+                  }\n                 } else {\n-                  // Namespace was already inserted for a sub-namespace.\n-                  parent.getParent().removeChild(parent);\n-                  providedNodes.put(ns,\n-                      new ProvidedNode(null, null, t.getModule()));\n+                  registerAnyProvidedPrefixes(ns, parent, t.getModule());\n+                  providedNames.put(\n+                      ns, new ProvidedName(ns, parent, t.getModule(), true));\n                 }\n-                compiler.reportCodeChange();\n               }\n             } else if (\"exportSymbol\".equals(methodName)) {\n               Node arg = left.getNext();\n             if (parent.getBooleanProp(Node.IS_NAMESPACE)) {\n               processProvideFromPreviousPass(t, name, parent);\n             } else {\n-              ProvidedNode pn = providedNodes.get(name);\n+              ProvidedName pn = providedNames.get(name);\n               if (pn != null) {\n-                pn.addCandidate(parent, parent.getParent());\n+                pn.addDefinition(parent);\n               }\n             }\n           }\n           if (parent.getBooleanProp(Node.IS_NAMESPACE)) {\n             processProvideFromPreviousPass(t, name, parent);\n           } else {\n-            ProvidedNode pn = providedNodes.get(name);\n+            ProvidedName pn = providedNames.get(name);\n             if (pn != null) {\n-              pn.addCandidate(parent, parent.getParent());\n+              pn.addDefinition(parent);\n             }\n           }\n         }\n         if (t.inGlobalScope() &&\n             !NodeUtil.isFunctionAnonymous(n)) {\n           String name = n.getFirstChild().getString();\n-          ProvidedNode pn = providedNodes.get(name);\n+          ProvidedName pn = providedNames.get(name);\n           if (pn != null) {\n             compiler.report(JSError.make(t, n, FUNCTION_NAMESPACE_ERROR, name));\n           }\n    */\n   private void processProvideFromPreviousPass(\n       NodeTraversal t, String name, Node parent) {\n-    if (!providedNodes.containsKey(name)) {\n-      // Record this provide created on a previous pass.\n-      providedNodes.put(name, new ProvidedNode(\n-          parent, parent.getParent(), t.getModule()));\n-      // Make sure it has the proper prefixes.\n-      maybeProvidePrefixes(parent, parent.getParent(), name);\n+    if (!providedNames.containsKey(name)) {\n+      // Record this provide created on a previous pass, and create a dummy\n+      // EXPR node as a placeholder to simulate an explicit provide.\n+      Node expr = new Node(Token.EXPR_RESULT);\n+      expr.copyInformationFromForTree(parent);\n+      parent.getParent().addChildBefore(expr, parent);\n+      compiler.reportCodeChange();\n+\n+      registerAnyProvidedPrefixes(name, expr, t.getModule());\n+\n+      ProvidedName provided = new ProvidedName(name, expr, t.getModule(), true);\n+      providedNames.put(name, provided);\n+      provided.addDefinition(parent);\n     } else {\n       // Remove this provide if it came from a previous pass since we have an\n       // replacement already.\n       if (isNamespacePlaceholder(parent)) {\n         parent.getParent().removeChild(parent);\n+        compiler.reportCodeChange();\n       }\n     }\n   }\n     if (verifyArgument(t, left, arg, Token.OBJECTLIT)) {\n       // Translate OBJECTLIT into SubstitutionMap. All keys and\n       // values must be strings, or an error will be thrown.\n-      final Map<String,String> cssNames = Maps.newHashMap();\n+      final Map<String, String> cssNames = Maps.newHashMap();\n       JSError error = null;\n       for (Node key = arg.getFirstChild(); key != null;\n           key = key.getNext().getNext()) {\n   }\n \n   /**\n-   * Replaces a goog.provide call with one or more variable assignments.\n+   * Registers ProvidedNames for prefix namespaces if they haven't\n+   * already been defined. The prefix namespaces must be registered in\n+   * order from shortest to longest.\n    *\n-   * @param t The current traversal.\n-   * @param node The EXPR_RESULT node to be replaced.\n-   * @param parent The parent of {@code node}.\n-   * @param ns The namespace to provide.\n-   */\n-  private void replaceProvide(\n-      NodeTraversal t, Node node, Node parent, String ns) {\n-    Node newNode;\n-    if (ns.indexOf('.') == -1) {\n-      newNode = makeVarDeclNode(ns, node);\n-      parent.replaceChild(node, newNode);\n-    } else {\n-      newNode = makeAssignmentExprNode(ns, node);\n-      parent.replaceChild(node, newNode);\n-      maybeProvidePrefixes(newNode, parent, ns);\n-    }\n-    providedNodes.put(ns, new ProvidedNode(newNode, parent, t.getModule()));\n-  }\n-\n-  /**\n-   * Provides prefix namespaces if they haven't already been defined.\n-   *\n-   * @param node Node to insert definitions before\n-   * @param parent Parent of {@code node}\n-   * @param ns The namespace whose prefixes may need to be provided\n-   */\n-  private void maybeProvidePrefixes(Node node, Node parent, String ns) {\n-    int pos = ns.lastIndexOf('.');\n-    Node nodeToAddBefore = node;\n+   * @param ns The namespace whose prefixes may need to be provided.\n+   * @param node The EXPR of the provide call.\n+   * @param module The current module.\n+   */\n+  private void registerAnyProvidedPrefixes(\n+      String ns, Node node, JSModule module) {\n+    int pos = ns.indexOf('.');\n     while (pos != -1) {\n       String prefixNs = ns.substring(0, pos);\n-      pos = prefixNs.lastIndexOf('.');\n-      if (providedNodes.containsKey(prefixNs)) {\n-        break;\n+      pos = ns.indexOf('.', pos + 1);\n+      if (providedNames.containsKey(prefixNs)) {\n+        providedNames.get(prefixNs).addProvide(\n+            node, module, false /* implicit */);\n       } else {\n-        // Use a null value in this map to indicate that the namespace has\n-        // been declared implicitly and is not removable.\n-        providedNodes.put(prefixNs, null);\n-        Node newNode = (pos == -1\n-                        ? makeVarDeclNode(prefixNs, node)\n-                        : makeAssignmentExprNode(prefixNs, node));\n-        parent.addChildBefore(newNode, nodeToAddBefore);\n-        nodeToAddBefore = newNode;\n-      }\n-    }\n-  }\n-\n-  /**\n-   * Creates a simple namespace variable declaration\n-   * (e.g. <code>var foo = {};</code>).\n-   *\n-   * @param namespace A simple namespace (must be a valid js identifier)\n-   * @param sourceNode The node to get source information from.\n-   */\n-  private Node makeVarDeclNode(String namespace, Node sourceNode) {\n-    Node name = Node.newString(Token.NAME, namespace);\n-    name.addChildToFront(new Node(Token.OBJECTLIT));\n-\n-    Node decl = new Node(Token.VAR, name);\n-    decl.putBooleanProp(Node.IS_NAMESPACE, true);\n-\n-    // TODO(nicksantos): ew ew ew. Create a mutator package.\n-    if (compiler.getCodingConvention().isConstant(namespace)) {\n-      name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n-    }\n-\n-    Preconditions.checkState(isNamespacePlaceholder(decl));\n-    decl.copyInformationFromForTree(sourceNode);\n-    return decl;\n-  }\n-\n-  /**\n-   * Creates a dotted namespace assignment expression\n-   * (e.g. <code>foo.bar = {};</code>).\n-   *\n-   * @param namespace A dotted namespace\n-   * @param node A node from which to copy source info.\n-   */\n-  private Node makeAssignmentExprNode(String namespace, Node node) {\n-    Node decl = new Node(Token.EXPR_RESULT,\n-        new Node(Token.ASSIGN,\n-            NodeUtil.newQualifiedNameNode(namespace, node, namespace),\n-            new Node(Token.OBJECTLIT)));\n-    decl.putBooleanProp(Node.IS_NAMESPACE, true);\n-    Preconditions.checkState(isNamespacePlaceholder(decl));\n-    decl.copyInformationFromForTree(node);\n-    return decl;\n+        providedNames.put(\n+            prefixNs,\n+            new ProvidedName(prefixNs, node, module, false /* implicit */));\n+      }\n+    }\n   }\n \n   // -------------------------------------------------------------------------\n \n   /**\n-   * Information required to replace a provided node later in the traversal.\n-   */\n-  private class ProvidedNode {\n-    private final Node providedNode;\n-    private final Node providedParent;\n-    private final JSModule module;\n-    private Node replacementCandidate;\n-    private Node replacementCandidateParent;\n-\n-    ProvidedNode(Node node, Node parent, JSModule module) {\n-      Preconditions.checkArgument((node == null) ||\n-                                  NodeUtil.isVar(node) ||\n-                                  NodeUtil.isExpressionNode(node));\n-      Preconditions.checkArgument((node == null) == (parent == null));\n-      this.providedNode = node;\n-      this.providedParent = parent;\n-      this.replacementCandidate = null;\n-      this.replacementCandidateParent = null;\n-      this.module = module;\n+   * Information required to replace a goog.provide call later in the traversal.\n+   */\n+  private class ProvidedName {\n+    private final String namespace;\n+\n+    // The node and module where the call was explicitly or implicitly\n+    // goog.provided.\n+    private final Node firstNode;\n+    private final JSModule firstModule;\n+\n+    // The node where the call was explicitly goog.provided. May be null\n+    // if the namespace is always provided implicitly.\n+    private Node explicitNode = null;\n+\n+    // The candidate definition.\n+    private Node candidateDefinition = null;\n+\n+    ProvidedName(String namespace, Node node, JSModule module,\n+        boolean explicit) {\n+      Preconditions.checkArgument(\n+          node == null /* The base case */ ||\n+          NodeUtil.isExpressionNode(node));\n+      this.namespace = namespace;\n+      this.firstNode = node;\n+      this.firstModule = module;\n+\n+      addProvide(node, module, explicit);\n+    }\n+\n+    /**\n+     * Add an implicit or explicit provide.\n+     */\n+    void addProvide(Node node, JSModule module, boolean explicit) {\n+      // TODO(nicksantos): Fixing this pass in the presence of modules\n+      // will require the module parameter.\n+      if (explicit) {\n+        Preconditions.checkState(explicitNode == null);\n+        Preconditions.checkArgument(NodeUtil.isExpressionNode(node));\n+        explicitNode = node;\n+      }\n+    }\n+\n+    boolean isExplicitlyProvided() {\n+      return explicitNode != null;\n     }\n \n     /**\n      * declarations; if no declation exists record a reference to an\n      * assignment so it repurposed later.\n      */\n-    void addCandidate(Node node, Node parent) {\n+    void addDefinition(Node node) {\n       Preconditions.checkArgument(NodeUtil.isExpressionNode(node) || // assign\n                                   NodeUtil.isFunction(node) ||\n                                   NodeUtil.isVar(node));\n-      Preconditions.checkArgument(providedNode != node);\n-\n-      if ((replacementCandidate == null) || !NodeUtil.isExpressionNode(node)) {\n-        replacementCandidate = node;\n-        replacementCandidateParent = parent;\n+      Preconditions.checkArgument(explicitNode != node);\n+      if ((candidateDefinition == null) || !NodeUtil.isExpressionNode(node)) {\n+        candidateDefinition = node;\n       }\n     }\n \n     /**\n-     * Remove the definition added to replace the provide statement if a\n-     * duplicate definition exists.  If no suitable definition exists, but\n-     * an assignment is found, convert the assignment into a variable\n-     * definition.\n+     * Replace the provide statement.\n+     *\n+     * If we're providing a name with no definition, then create one.\n+     * If we're providing a name with a duplicate definition, then make sure\n+     * that definition becomes a declaration.\n      */\n-    void maybeRemove() {\n-      if ((providedNode != null)\n-          && (replacementCandidate != null)\n-          && isNamespacePlaceholder(providedNode)) {\n-        providedParent.removeChild(providedNode);\n+    void replace() {\n+      if (firstNode == null) {\n+        // Don't touch the base case ('goog').\n+        return;\n+      }\n+\n+      // Handle the case where there is a duplicate definition for an explicitly\n+      // provided symbol.\n+      if (candidateDefinition != null && explicitNode != null) {\n+        explicitNode.detachFromParent();\n         compiler.reportCodeChange();\n \n-        if (NodeUtil.isExpressionNode(replacementCandidate)) {\n-          replacementCandidate.putBooleanProp(Node.IS_NAMESPACE, true);\n-          Node assignNode = replacementCandidate.getFirstChild();\n+        // Does this need a VAR keyword?\n+        if (NodeUtil.isExpressionNode(candidateDefinition)) {\n+          candidateDefinition.putBooleanProp(Node.IS_NAMESPACE, true);\n+          Node assignNode = candidateDefinition.getFirstChild();\n           Node nameNode = assignNode.getFirstChild();\n           if (nameNode.getType() == Token.NAME) {\n             // Need to convert this assign to a var declaration.\n             assignNode.removeChild(valueNode);\n             nameNode.addChildToFront(valueNode);\n             Node varNode = new Node(Token.VAR, nameNode);\n-            varNode.copyInformationFrom(replacementCandidate);\n-            replacementCandidateParent.replaceChild(replacementCandidate,\n-                                                    varNode);\n+            varNode.copyInformationFrom(candidateDefinition);\n+            candidateDefinition.getParent().replaceChild(\n+                candidateDefinition, varNode);\n             nameNode.setJSDocInfo(assignNode.getJSDocInfo());\n             compiler.reportCodeChange();\n           }\n         }\n-      }\n+      } else {\n+        // Handle the case where there's not a duplicate definition.\n+        Node declaration = createDeclarationNode();\n+\n+        // The node was implicitly provided, so insert it before\n+        // the explicit provide.\n+        if (explicitNode != firstNode) {\n+          firstNode.getParent().addChildBefore(declaration, firstNode);\n+          if (explicitNode != null) {\n+            explicitNode.detachFromParent();\n+          }\n+        } else {\n+          Preconditions.checkNotNull(explicitNode);\n+          explicitNode.getParent().replaceChild(explicitNode, declaration);\n+        }\n+        compiler.reportCodeChange();\n+      }\n+    }\n+\n+    /**\n+     * Create the declaration node for this name, without inserting it\n+     * into the AST.\n+     */\n+    private Node createDeclarationNode() {\n+      if (namespace.indexOf('.') == -1) {\n+        return makeVarDeclNode(namespace, firstNode);\n+      } else {\n+        return makeAssignmentExprNode(namespace, firstNode);\n+      }\n+    }\n+\n+    /**\n+     * Creates a simple namespace variable declaration\n+     * (e.g. <code>var foo = {};</code>).\n+     *\n+     * @param namespace A simple namespace (must be a valid js identifier)\n+     * @param sourceNode The node to get source information from.\n+     */\n+    private Node makeVarDeclNode(String namespace, Node sourceNode) {\n+      Node name = Node.newString(Token.NAME, namespace);\n+      name.addChildToFront(new Node(Token.OBJECTLIT));\n+\n+      Node decl = new Node(Token.VAR, name);\n+      decl.putBooleanProp(Node.IS_NAMESPACE, true);\n+\n+      // TODO(nicksantos): ew ew ew. Create a mutator package.\n+      if (compiler.getCodingConvention().isConstant(namespace)) {\n+        name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n+      }\n+\n+      Preconditions.checkState(isNamespacePlaceholder(decl));\n+      decl.copyInformationFromForTree(sourceNode);\n+      return decl;\n+    }\n+\n+    /**\n+     * Creates a dotted namespace assignment expression\n+     * (e.g. <code>foo.bar = {};</code>).\n+     *\n+     * @param namespace A dotted namespace\n+     * @param node A node from which to copy source info.\n+     */\n+    private Node makeAssignmentExprNode(String namespace, Node node) {\n+      Node decl = new Node(Token.EXPR_RESULT,\n+          new Node(Token.ASSIGN,\n+            NodeUtil.newQualifiedNameNode(namespace, node, namespace),\n+              new Node(Token.OBJECTLIT)));\n+      decl.putBooleanProp(Node.IS_NAMESPACE, true);\n+      Preconditions.checkState(isNamespacePlaceholder(decl));\n+      decl.copyInformationFromForTree(node);\n+      return decl;\n     }\n   }\n \n--- a/test/com/google/javascript/jscomp/ProcessClosurePrimitivesTest.java\n+++ b/test/com/google/javascript/jscomp/ProcessClosurePrimitivesTest.java\n \n   // Provide a name after the definition of the class providing the\n   // parent namespace.\n-  public void testProvideOrder3() {\n+  public void testProvideOrder3a() {\n+    test(\"goog.provide('a.b');\" +\n+         \"a.b = function(x,y) {};\" +\n+         \"goog.provide('a.b.c');\" +\n+         \"a.b.c;\",\n+         \"var a = {};\" +\n+         \"a.b = function(x,y) {};\" +\n+         \"a.b.c = {};\" +\n+         \"a.b.c;\");\n+  }\n+\n+  public void testProvideOrder3b() {\n     additionalEndCode = \"\";\n     addAdditionalNamespace = false;\n     // This tests a cleanly provided name, below a function namespace.\n          \"a.b.c;\");\n   }\n \n-  public void testProvideOrder4() {\n-    additionalEndCode = \"\";\n-    addAdditionalNamespace = false;\n-    // This tests a cleanly provided name, below a function namespace.\n+  public void testProvideOrder4a() {\n     test(\"goog.provide('goog.a');\" +\n          \"goog.provide('goog.a.b');\" +\n          \"if (x) {\" +\n          \"  goog.a.b=1;\" +\n          \"else\" +\n          \"  goog.a.b=2;\");\n-  }  \n+  }\n+\n+  public void testProvideOrder4b() {\n+    additionalEndCode = \"\";\n+    addAdditionalNamespace = false;\n+    // This tests a cleanly provided name, below a namespace.\n+    test(\"goog.provide('goog.a');\" +\n+         \"goog.provide('goog.a.b');\" +\n+         \"if (x) {\" +\n+         \"  goog.a.b = 1;\" +\n+         \"} else {\" +\n+         \"  goog.a.b = 2;\" +\n+         \"}\",\n+\n+         \"goog.a={};\" +\n+         \"if(x)\" +\n+         \"  goog.a.b=1;\" +\n+         \"else\" +\n+         \"  goog.a.b=2;\");\n+  }\n \n   public void testInvalidProvide() {\n     test(\"goog.provide('a.class');\", null, INVALID_PROVIDE_ERROR);\n          \"var goog = {}; goog.Foo = function() { goog.BaseFoo.call(this); }; \" +\n          \"goog.inherits(goog.Foo, goog.BaseFoo);\");\n   }\n+\n+  public void testImplicitAndExplicitProvide() {\n+    test(\"var goog = {}; \" +\n+         \"goog.provide('goog.foo.bar'); goog.provide('goog.foo');\",\n+         \"var goog = {}; goog.foo = {}; goog.foo.bar = {};\");\n+  }\n }", "timestamp": 1265398074, "metainfo": ""}