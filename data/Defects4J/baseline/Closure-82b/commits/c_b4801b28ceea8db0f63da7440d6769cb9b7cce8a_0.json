{"sha": "b4801b28ceea8db0f63da7440d6769cb9b7cce8a", "log": "Change on 2010/05/28 by johnlenz          Inline functions with inner functions into global scope if they don't         declare any names.          R=acleung         DELTA=329  (244 added, 27 deleted, 58 changed)  Change on 2010/05/28 by dcc          First pass on refactoring FoldConstants into separate peephole optimizations. This changelist adds the notion of an AbstractPeepholeOptimization and adds a PeepholeOptimizationsPass that runs them. In this go around the minimization aspects of FoldConstants have been factored out into PeepholeMinimize. A future change will factor out the other components of FoldConstants into their own PeepholeOptimizations. DefaultPassConfig has also been updated to run the new PeepholeOptimizationPass.          This change does not move the minimization-related unit tests from FoldConstantsTest to PeepholeMinimizeTest -- a future, separate, change will do so. Hopefully this will make it easier to review.          R=acleung         DELTA=1966  (1271 added, 675 deleted, 20 changed)    Revision created by MOE tool push_codebase. MOE_MIGRATION=13010   ", "commit": "\n--- /dev/null\n+++ b/src/com/google/javascript/jscomp/AbstractPeepholeOptimization.java\n+/*\n+ * Copyright 2010 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.javascript.rhino.Node;\n+\n+/**\n+ * An abstract class whose implementations run peephole optimizations:\n+ * optimizations that look at a small section of code and either remove\n+ * that code (if it is not needed) or replaces it with smaller code.\n+ * \n+*\n+ */\n+abstract class AbstractPeepholeOptimization {\n+   \n+  private NodeTraversal currentTraversal;\n+  \n+  /** \n+   * Given a node to optimize and a traversal, optimize the node. Subclasses \n+   * should override to provide their own peephole optimization.\n+   * \n+   * @param subtree The subtree that will be optimized. \n+   * @return The new version of the subtree (or null if the subtree or one of\n+   * its parents was removed from the AST). If the subtree has not changed,\n+   * this method must return {@code subtree}.\n+   */  \n+  abstract Node optimizeSubtree(Node subtree);\n+\n+  /** \n+   * Helper method for reporting an error to the compiler when applying a \n+   * peephole optimization.\n+   * \n+   * @param diagnostic The error type\n+   * @param n The node for which the error should be reported\n+   */ \n+  protected void error(DiagnosticType diagnostic, Node n) {\n+    JSError error = currentTraversal.makeError(n, diagnostic, n.toString());\n+    currentTraversal.getCompiler().report(error);\n+  }\n+  \n+  /** \n+   * Helper method for telling the compiler that something has changed. \n+   * Subclasses must call these if they have changed the AST. \n+   */\n+  protected void reportCodeChange() {\n+    Preconditions.checkNotNull(currentTraversal);\n+    currentTraversal.getCompiler().reportCodeChange();\n+  }\n+  \n+  /**\n+   * Are the nodes equal for the purpose of inlining?\n+   * If type aware optimizations are on, type equality is checked.\n+   */\n+  protected boolean areNodesEqualForInlining(Node n1, Node n2) {\n+    /* Our implementation delegates to the compiler. We provide this\n+     * method because we don't want to expose Compiler to PeepholeOptimizations.\n+     */\n+    Preconditions.checkNotNull(currentTraversal);\n+    return currentTraversal.getCompiler().areNodesEqualForInlining(n1, n2);\n+  }\n+  \n+  /**\n+   * Informs the optimization that a traversal will begin.  \n+   */\n+  void beginTraversal(NodeTraversal traversal) {\n+    currentTraversal = traversal;\n+  }\n+  \n+  /**\n+   * Informs the optimization that a traversal has completed.\n+   */\n+  void endTraversal(NodeTraversal traversal) {\n+    currentTraversal = null;\n+  }\n+}\n--- a/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java\n+++ b/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java\n     // We are not going to do any dead assignment elimination in when there is\n     // at least one inner function because in most browsers, when there is a\n     // closure, ALL the variables are saved (escaped).\n-    if (!NodeUtil.containsFunctionDeclaration(\n+    if (!NodeUtil.containsFunction(\n         t.getScopeRoot().getLastChild())) {\n       // Computes liveness information first.\n       ControlFlowGraph<Node> cfg = t.getControlFlowGraph();\n--- a/src/com/google/javascript/jscomp/DefaultPassConfig.java\n+++ b/src/com/google/javascript/jscomp/DefaultPassConfig.java\n import com.google.common.annotations.VisibleForTesting;\n import com.google.common.base.Charsets;\n import com.google.common.base.Preconditions;\n+import com.google.common.collect.ImmutableSet;\n import com.google.common.collect.Lists;\n import com.google.common.collect.Maps;\n import com.google.common.collect.Sets;\n       // These used to be one pass.\n       passes.add(minimizeExitPoints);\n       passes.add(foldConstants);\n+      passes.add(peepholeOptimizations);\n     }\n \n     if (options.removeDeadCode) {\n     @Override\n     protected CompilerPass createInternal(AbstractCompiler compiler) {\n       return new FoldConstants(compiler);\n+    }\n+  };\n+\n+  /** Various peephole optimizations. */\n+  private static final PassFactory peepholeOptimizations =\n+      new PassFactory(\"peepholeOptimizations\", false) {\n+    @Override\n+    protected CompilerPass createInternal(AbstractCompiler compiler) {\n+\n+      ImmutableSet<AbstractPeepholeOptimization> optimizations =\n+        ImmutableSet.<AbstractPeepholeOptimization>of(\n+            new PeepholeSubstituteAlternateSyntax());\n+\n+      final PeepholeOptimizationsPass peepholePass =\n+          new PeepholeOptimizationsPass(compiler, optimizations);\n+\n+      return peepholePass;\n     }\n   };\n \n--- a/src/com/google/javascript/jscomp/FoldConstants.java\n+++ b/src/com/google/javascript/jscomp/FoldConstants.java\n import com.google.common.collect.ImmutableSet;\n import com.google.common.collect.Lists;\n import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n-import com.google.javascript.jscomp.NodeTraversal.AbstractShallowCallback;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n \n import java.util.List;\n-import java.util.regex.Pattern;\n \n /**\n  * FoldConstants simplifies expressions which consist only of constants,\n           \"JSC_NEGATING_A_NON_NUMBER_ERROR\",\n           \"Can't negate non-numeric value: {0}\");\n \n-  static final DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS =\n-      DiagnosticType.error(\n-          \"JSC_INVALID_REGULAR_EXPRESSION_FLAGS\",\n-          \"Invalid flags to RegExp constructor: {0}\");\n-\n   static final DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE =\n       DiagnosticType.error(\n           \"JSC_BITWISE_OPERAND_OUT_OF_RANGE\",\n   static final DiagnosticType FRACTIONAL_BITWISE_OPERAND = DiagnosticType.error(\n       \"JSC_FRACTIONAL_BITWISE_OPERAND\",\n       \"Fractional bitwise operand: {0}\");\n-\n-  private static final int AND_PRECEDENCE = NodeUtil.precedence(Token.AND);\n-  private static final int OR_PRECEDENCE = NodeUtil.precedence(Token.OR);\n \n   private final AbstractCompiler compiler;\n \n           // away the operator\n           parent.replaceChild(n, n.removeFirstChild());\n           t.getCompiler().reportCodeChange();\n-          return;\n-        }\n-\n-        // Try to mimize NOT nodes such as !(x==y) into x!=y.\n-        if (type == Token.NOT && tryMinimizeNot(t, n, parent)) {\n           return;\n         }\n \n     }\n \n     if (type == Token.NEW || type == Token.CALL) {\n-      if (Token.NAME == left.getType()) {\n+      if (Token.NAME == left.getType() && left.getNext() == null) {\n         String className = left.getString();\n-        if (\"RegExp\".equals(className)) {\n-          if (tryFoldRegularExpressionConstructor(t, n, parent)) {\n+        if (\"Array\".equals(className)) {\n+          if (tryFoldLiteralConstructor(\n+              t, n, parent, className, Token.ARRAYLIT)) {\n             return;\n           }\n-        } else if (left.getNext() == null) {\n-          if (\"Array\".equals(className)) {\n-            if (tryFoldLiteralConstructor(\n-                t, n, parent, className, Token.ARRAYLIT)) {\n-              return;\n-            }\n-          } else if (\"Object\".equals(className)) {\n-            if (tryFoldLiteralConstructor(\n-                t, n, parent, className, Token.OBJECTLIT)) {\n-              return;\n-            }\n+        } else if (\"Object\".equals(className)) {\n+          if (tryFoldLiteralConstructor(\n+              t, n, parent, className, Token.OBJECTLIT)) {\n+            return;\n           }\n         }\n       }\n     }\n \n     if (type == Token.EXPR_RESULT) {\n-      tryMinimizeCondition(t, left, n);\n-      return;\n-    }\n-\n+        return;\n+    }\n+  \n     if (type == Token.RETURN) {\n-      tryReduceReturn(t, n);\n       return;\n     }\n \n     }\n \n     if (type == Token.IF || type == Token.HOOK) {\n-      tryMinimizeCondition(t, n.getFirstChild(), n);\n-      boolean changes = tryFoldHookIf(t, n, parent);\n-\n-      // bad cascades can occur if we run the second round\n-      // of IF optimizations immediately\n-      if (type == Token.IF && !changes) {\n-        tryMinimizeIf(t, n, parent);\n-      }\n+      tryFoldHookIf(t, n, parent);\n       return;\n     }\n \n     if (type == Token.DO) {\n-      tryMinimizeCondition(t, NodeUtil.getConditionExpression(n), n);\n       tryFoldDo(t, n, parent);\n       return;\n     }\n \n     if (type == Token.WHILE) {\n-      tryMinimizeCondition(t, NodeUtil.getConditionExpression(n), n);\n       tryFoldWhile(t, n, parent);\n       return;\n     }\n     if (type == Token.FOR) {\n       Node condition = NodeUtil.getConditionExpression(n);\n       if (condition != null) {\n-        tryMinimizeCondition(t, condition, n);\n-        // The root condition node might have changed, get it again.\n-        condition = NodeUtil.getConditionExpression(n);\n         this.tryFoldForCondition(condition, n);\n       }\n \n     t.getCompiler().report(t.makeError(n, diagnostic, n.toString()));\n   }\n \n-  /**\n-   * Does a statement consume a 'dangling else'? A statement consumes\n-   * a 'dangling else' if an 'else' token following the statement\n-   * would be considered by the parser to be part of the statement.\n-   */\n-  private boolean consumesDanglingElse(Node n) {\n-    while (true) {\n-      switch (n.getType()) {\n-        case Token.IF:\n-          if (n.getChildCount() < 3) return true;\n-          // This IF node has no else clause.\n-          n = n.getLastChild();\n-          continue;\n-        case Token.WITH:\n-        case Token.WHILE:\n-        case Token.FOR:\n-          n = n.getLastChild();\n-          continue;\n-        default:\n-          return false;\n-      }\n-    }\n-  }\n-\n   private void tryFoldAssign(NodeTraversal t, Node n, Node left, Node right) {\n     Preconditions.checkArgument(n.getType() == Token.ASSIGN);\n \n     }\n     return true;\n   }\n-\n-  /**\n-   * Try to minimize NOT nodes such as !(x==y).\n-   */\n-  private boolean tryMinimizeNot(NodeTraversal t, Node n, Node parent) {\n-    Node notChild = n.getFirstChild();\n-    // negative operator of the current one : == -> != for instance.\n-    int complementOperator;\n-    switch (notChild.getType()) {\n-      case Token.EQ:\n-        complementOperator = Token.NE;\n-        break;\n-      case Token.NE:\n-        complementOperator = Token.EQ;\n-        break;\n-      case Token.SHEQ:\n-        complementOperator = Token.SHNE;\n-        break;\n-      case Token.SHNE:\n-        complementOperator = Token.SHEQ;\n-        break;\n-      // GT, GE, LT, LE are not handled in this because !(x<NaN) != x>=NaN.\n-      default:\n-        return false;\n-    }\n-    Node newOperator = n.removeFirstChild();\n-    newOperator.setType(complementOperator);\n-    parent.replaceChild(n, newOperator);\n-    t.getCompiler().reportCodeChange();\n-    return true;\n-  }\n-\n-  /**\n-   * Try turning IF nodes into smaller HOOKs\n-   */\n-  void tryMinimizeIf(NodeTraversal t, Node n, Node parent) {\n-    Node cond = n.getFirstChild();\n-    Node thenBranch = cond.getNext();\n-    Node elseBranch = thenBranch.getNext();\n-\n-    if (elseBranch == null) {\n-      if (isExpressBlock(thenBranch)) {\n-        Node expr = getBlockExpression(thenBranch);\n-        if (isPropertyAssignmentInExpression(t, expr)) {\n-          // Keep opportunities for CollapseProperties such as\n-          // a.longIdentifier || a.longIdentifier = ... -> var a = ...;\n-          return;\n-        }\n-\n-        if (cond.getType() == Token.NOT) {\n-          // if(!x)bar(); -> x||bar();\n-          if (isLowerPrecedenceInExpression(t, cond, OR_PRECEDENCE) &&\n-              isLowerPrecedenceInExpression(t, expr.getFirstChild(),\n-                  OR_PRECEDENCE)) {\n-            // It's not okay to add two sets of parentheses.\n-            return;\n-          }\n-\n-          Node or = new Node(Token.OR, cond.removeFirstChild(),\n-          expr.removeFirstChild()).copyInformationFrom(n);\n-          Node newExpr = NodeUtil.newExpr(or);\n-          parent.replaceChild(n, newExpr);\n-          t.getCompiler().reportCodeChange();\n-\n-          return;\n-        }\n-\n-        // if(x)foo(); -> x&&foo();\n-        if (isLowerPrecedenceInExpression(t, cond, AND_PRECEDENCE) ||\n-            isLowerPrecedenceInExpression(t, expr.getFirstChild(),\n-                AND_PRECEDENCE)) {\n-          // One additional set of parentheses isn't worth it.\n-          return;\n-        }\n-\n-        n.removeChild(cond);\n-        Node and = new Node(Token.AND, cond, expr.removeFirstChild())\n-                       .copyInformationFrom(n);\n-        Node newExpr = NodeUtil.newExpr(and);\n-        parent.replaceChild(n, newExpr);\n-        t.getCompiler().reportCodeChange();\n-      }\n-\n-      return;\n-    }\n-\n-    tryRemoveRepeatedStatements(t, n);\n-\n-    // if(!x)foo();else bar(); -> if(x)bar();else foo();\n-    // An additional set of curly braces isn't worth it.\n-    if (cond.getType() == Token.NOT && !consumesDanglingElse(elseBranch)) {\n-      n.replaceChild(cond, cond.removeFirstChild());\n-      n.removeChild(thenBranch);\n-      n.addChildToBack(thenBranch);\n-      t.getCompiler().reportCodeChange();\n-      return;\n-    }\n-\n-    // if(x)return 1;else return 2; -> return x?1:2;\n-    if (isReturnExpressBlock(thenBranch) && isReturnExpressBlock(elseBranch)) {\n-      Node thenExpr = getBlockReturnExpression(thenBranch);\n-      Node elseExpr = getBlockReturnExpression(elseBranch);\n-      n.removeChild(cond);\n-      thenExpr.detachFromParent();\n-      elseExpr.detachFromParent();\n-\n-      // note - we ignore any cases with \"return;\", technically this\n-      // can be converted to \"return undefined;\" or some variant, but\n-      // that does not help code size.\n-      Node hookNode = new Node(Token.HOOK, cond, thenExpr, elseExpr)\n-                          .copyInformationFrom(n);\n-      Node returnNode = new Node(Token.RETURN, hookNode);\n-      parent.replaceChild(n, returnNode);\n-      t.getCompiler().reportCodeChange();\n-      return;\n-    }\n-\n-    boolean thenBranchIsExpressionBlock = isExpressBlock(thenBranch);\n-    boolean elseBranchIsExpressionBlock = isExpressBlock(elseBranch);\n-\n-    if (thenBranchIsExpressionBlock && elseBranchIsExpressionBlock) {\n-      Node thenOp = getBlockExpression(thenBranch).getFirstChild();\n-      Node elseOp = getBlockExpression(elseBranch).getFirstChild();\n-      if (thenOp.getType() == elseOp.getType()) {\n-        // if(x)a=1;else a=2; -> a=x?1:2;\n-        if (NodeUtil.isAssignmentOp(thenOp)) {\n-          Node lhs = thenOp.getFirstChild();\n-          if (compiler.areNodesEqualForInlining(lhs, elseOp.getFirstChild()) &&\n-              // if LHS has side effects, don't proceed [since the optimization\n-              // evaluates LHS before cond]\n-              // NOTE - there are some circumstances where we can\n-              // proceed even if there are side effects...\n-              !NodeUtil.mayEffectMutableState(lhs)) {\n-\n-            n.removeChild(cond);\n-            Node assignName = thenOp.removeFirstChild();\n-            Node thenExpr = thenOp.removeFirstChild();\n-            Node elseExpr = elseOp.getLastChild();\n-            elseOp.removeChild(elseExpr);\n-\n-            Node hookNode = new Node(Token.HOOK, cond, thenExpr, elseExpr)\n-                                .copyInformationFrom(n);\n-            Node assign = new Node(thenOp.getType(), assignName, hookNode)\n-                              .copyInformationFrom(thenOp);\n-            Node expr = NodeUtil.newExpr(assign);\n-            parent.replaceChild(n, expr);\n-            t.getCompiler().reportCodeChange();\n-          }\n-        } else if (NodeUtil.isCall(thenOp)) {\n-          // if(x)foo();else bar(); -> x?foo():bar()\n-          n.removeChild(cond);\n-          thenOp.detachFromParent();\n-          elseOp.detachFromParent();\n-          Node hookNode = new Node(Token.HOOK, cond, thenOp, elseOp)\n-                              .copyInformationFrom(n);\n-          Node expr = NodeUtil.newExpr(hookNode);\n-          parent.replaceChild(n, expr);\n-          t.getCompiler().reportCodeChange();\n-        }\n-      }\n-      return;\n-    }\n-\n-    boolean thenBranchIsVar = isVarBlock(thenBranch);\n-    boolean elseBranchIsVar = isVarBlock(elseBranch);\n-\n-    // if(x)var y=1;else y=2  ->  var y=x?1:2\n-    if (thenBranchIsVar && elseBranchIsExpressionBlock &&\n-        NodeUtil.isAssign(getBlockExpression(elseBranch).getFirstChild())) {\n-\n-      Node var = getBlockVar(thenBranch);\n-      Node elseAssign = getBlockExpression(elseBranch).getFirstChild();\n-\n-      Node name1 = var.getFirstChild();\n-      Node maybeName2 = elseAssign.getFirstChild();\n-\n-      if (name1.hasChildren()\n-          && maybeName2.getType() == Token.NAME\n-          && name1.getString().equals(maybeName2.getString())) {\n-        Node thenExpr = name1.removeChildren();\n-        Node elseExpr = elseAssign.getLastChild().detachFromParent();\n-        cond.detachFromParent();\n-        Node hookNode = new Node(Token.HOOK, cond, thenExpr, elseExpr)\n-                            .copyInformationFrom(n);\n-        var.detachFromParent();\n-        name1.addChildrenToBack(hookNode);\n-        parent.replaceChild(n, var);\n-        t.getCompiler().reportCodeChange();\n-      }\n-\n-    // if(x)y=1;else var y=2  ->  var y=x?1:2\n-    } else if (elseBranchIsVar && thenBranchIsExpressionBlock &&\n-        NodeUtil.isAssign(getBlockExpression(thenBranch).getFirstChild())) {\n-\n-      Node var = getBlockVar(elseBranch);\n-      Node thenAssign = getBlockExpression(thenBranch).getFirstChild();\n-\n-      Node maybeName1 = thenAssign.getFirstChild();\n-      Node name2 = var.getFirstChild();\n-\n-      if (name2.hasChildren()\n-          && maybeName1.getType() == Token.NAME\n-          && maybeName1.getString().equals(name2.getString())) {\n-        Node thenExpr = thenAssign.getLastChild().detachFromParent();\n-        Node elseExpr = name2.removeChildren();\n-        cond.detachFromParent();\n-        Node hookNode = new Node(Token.HOOK, cond, thenExpr, elseExpr)\n-                            .copyInformationFrom(n);\n-        var.detachFromParent();\n-        name2.addChildrenToBack(hookNode);\n-        parent.replaceChild(n, var);\n-        t.getCompiler().reportCodeChange();\n-      }\n-    }\n-  }\n-\n-  /**\n-   * Try to remove duplicate statements from IF blocks. For example:\n-   *\n-   * if (a) {\n-   *   x = 1;\n-   *   return true;\n-   * } else {\n-   *   x = 2;\n-   *   return true;\n-   * }\n-   *\n-   * becomes:\n-   *\n-   * if (a) {\n-   *   x = 1;\n-   * } else {\n-   *   x = 2;\n-   * }\n-   * return true;\n-   *\n-   * @param n The IF node to examine.\n-   */\n-  private void tryRemoveRepeatedStatements(NodeTraversal t, Node n) {\n-    Preconditions.checkState(n.getType() == Token.IF);\n-\n-    Node parent = n.getParent();\n-    if (!NodeUtil.isStatementBlock(parent)) {\n-      // If the immediate parent is something like a label, we\n-      // can't move the statement, so bail.\n-      return;\n-    }\n-\n-    Node cond = n.getFirstChild();\n-    Node trueBranch = cond.getNext();\n-    Node falseBranch = trueBranch.getNext();\n-    Preconditions.checkNotNull(trueBranch);\n-    Preconditions.checkNotNull(falseBranch);\n-\n-    while (true) {\n-      Node lastTrue = trueBranch.getLastChild();\n-      Node lastFalse = falseBranch.getLastChild();\n-      if (lastTrue == null || lastFalse == null\n-          || !compiler.areNodesEqualForInlining(lastTrue, lastFalse)) {\n-        break;\n-      }\n-      lastTrue.detachFromParent();\n-      lastFalse.detachFromParent();\n-      parent.addChildAfter(lastTrue, n);\n-      t.getCompiler().reportCodeChange();\n-    }\n-  }\n-\n-  /**\n-   * Reduce \"return undefined\" or \"return void 0\" to simply \"return\".\n-   */\n-  private void tryReduceReturn(NodeTraversal t, Node n) {\n-    Node result = n.getFirstChild();\n-    if (result != null) {\n-      switch (result.getType()) {\n-        case Token.VOID:\n-          Node operand = result.getFirstChild();\n-          if (!NodeUtil.mayHaveSideEffects(operand)) {\n-            n.removeFirstChild();\n-            t.getCompiler().reportCodeChange();\n-          }\n-          return;\n-        case Token.NAME:\n-          String name = result.getString();\n-          if (name.equals(\"undefined\")) {\n-            n.removeFirstChild();\n-            t.getCompiler().reportCodeChange();\n-          }\n-          return;\n-      }\n-    }\n-  }\n-\n-  /**\n-   * Does the expression contain a property assignment?\n-   */\n-  private boolean isPropertyAssignmentInExpression(NodeTraversal t, Node n) {\n-    final boolean[] found = { false };\n-    new NodeTraversal(t.getCompiler(), new AbstractShallowCallback() {\n-      public void visit(NodeTraversal t, Node n, Node parent) {\n-        found[0] |= (n.getType() == Token.GETPROP &&\n-                     parent.getType() == Token.ASSIGN);\n-      }\n-    }).traverse(n);\n-    return found[0];\n-  }\n-\n-  /**\n-   * Does the expression contain an operator with lower precedence than\n-   * the argument?\n-   */\n-  private boolean isLowerPrecedenceInExpression(NodeTraversal t, Node n,\n-      final int precedence) {\n-    final boolean[] lower = { false };\n-    new NodeTraversal(t.getCompiler(), new AbstractShallowCallback() {\n-      public void visit(NodeTraversal t, Node n, Node parent) {\n-        lower[0] |= NodeUtil.precedence(n.getType()) < precedence;\n-      }\n-    }).traverse(n);\n-    return lower[0];\n-  }\n-\n+   \n   /**\n    * Try to fold a AND/OR node.\n    */\n     t.getCompiler().reportCodeChange();\n   }\n \n-\n   /**\n    * Try to fold an array join: ['a', 'b', 'c'].join('') -> 'abc';\n    */\n   }\n \n   /**\n-   * Try to fold a RegExp constructor to a regular expression literal.\n-   */\n-  private boolean tryFoldRegularExpressionConstructor(\n-      NodeTraversal t, Node n, Node parent) {\n-    Node constructor = n.getFirstChild();\n-    Node pattern = constructor.getNext();  // e.g.  ^foobar$\n-    Node flags = null != pattern ? pattern.getNext() : null;  // e.g. gi\n-\n-    if (null == pattern || (null != flags && null != flags.getNext())) {\n-      // too few or too many arguments\n-      return false;\n-    }\n-\n-    if (// is pattern folded\n-        pattern.getType() == Token.STRING\n-        // make sure empty pattern doesn't fold to //\n-        && !\"\".equals(pattern.getString())\n-\n-        // NOTE(nicksantos): Make sure that the regexp isn't longer than\n-        // 100 chars, or it blows up the regexp parser in Opera 9.2.\n-        && pattern.getString().length() < 100\n-\n-        && (null == flags || flags.getType() == Token.STRING)\n-        // don't escape patterns with unicode escapes since Safari behaves badly\n-        // (read can't parse or crashes) on regex literals with unicode escapes\n-        && !containsUnicodeEscape(pattern.getString())) {\n-\n-      // Make sure that / is escaped, so that it will fit safely in /brackets/.\n-      // pattern is a string value with \\\\ and similar already escaped\n-      pattern = makeForwardSlashBracketSafe(pattern);\n-\n-      Node regexLiteral;\n-      if (null == flags || \"\".equals(flags.getString())) {\n-        // fold to /foobar/\n-        regexLiteral = new Node(Token.REGEXP, pattern);\n-      } else {\n-        // fold to /foobar/gi\n-        if (!areValidRegexpFlags(flags.getString())) {\n-          error(t, INVALID_REGULAR_EXPRESSION_FLAGS, flags);\n-          return false;\n-        }\n-        if (!areSafeFlagsToFold(flags.getString())) {\n-          return false;\n-        }\n-        n.removeChild(flags);\n-        regexLiteral = new Node(Token.REGEXP, pattern, flags);\n-      }\n-\n-      parent.replaceChild(n, regexLiteral);\n-      t.getCompiler().reportCodeChange();\n-      return true;\n-    }\n-\n-    return false;\n-  }\n-\n-  private static final Pattern REGEXP_FLAGS_RE = Pattern.compile(\"^[gmi]*$\");\n-\n-  /**\n-   * are the given flags valid regular expression flags?\n-   * Javascript recognizes several suffix flags for regular expressions,\n-   * 'g' - global replace, 'i' - case insensitive, 'm' - multi-line.\n-   * They are case insensitive, and javascript does not recognize the extended\n-   * syntax mode, single-line mode, or expression replacement mode from perl5.\n-   */\n-  private static boolean areValidRegexpFlags(String flags) {\n-    return REGEXP_FLAGS_RE.matcher(flags).matches();\n-  }\n-\n-  /**\n-   * are the given flags safe to fold?\n-   * We don't fold the regular expression if global ('g') flag is on,\n-   * because in this case it isn't really a constant: its 'lastIndex'\n-   * property contains the state of last execution, so replacing\n-   * 'new RegExp('foobar','g')' with '/foobar/g' may change the behavior of\n-   * the program if the RegExp is used inside a loop, for example.\n-   */\n-  private static boolean areSafeFlagsToFold(String flags) {\n-    return flags.indexOf('g') < 0;\n-  }\n-\n-  /**\n-   * returns a string node that can safely be rendered inside /brackets/.\n-   */\n-  private static Node makeForwardSlashBracketSafe(Node n) {\n-    String s = n.getString();\n-    // sb contains everything in s[0:pos]\n-    StringBuilder sb = null;\n-    int pos = 0;\n-    for (int i = 0; i < s.length(); ++i) {\n-      switch (s.charAt(i)) {\n-        case '\\\\':  // skip over the next char after a '\\\\'.\n-          ++i;\n-          break;\n-        case '/':  // escape it\n-          if (null == sb) { sb = new StringBuilder(s.length() + 16); }\n-          sb.append(s, pos, i).append('\\\\');\n-          pos = i;\n-          break;\n-      }\n-    }\n-\n-    // don't discard useful line-number info if there were no changes\n-    if (null == sb) { return n.cloneTree(); }\n-\n-    sb.append(s, pos, s.length());\n-    return Node.newString(sb.toString()).copyInformationFrom(n);\n-  }\n-\n-  /**\n    * Replaces a new Array or Object node with an object literal, unless the\n    * call to Array or Object is to a local function with the same name.\n    *\n     parent.replaceChild(n, literalNode);\n     t.getCompiler().reportCodeChange();\n     return true;\n-  }\n-\n-  /**\n-   * true if the javascript string would contain a unicode escape when written\n-   * out as the body of a regular expression literal.\n-   */\n-  static boolean containsUnicodeEscape(String s) {\n-    String esc = CodeGenerator.regexpEscape(s);\n-    for (int i = -1; (i = esc.indexOf(\"\\\\u\", i + 1)) >= 0;) {\n-      int nSlashes = 0;\n-      while (i - nSlashes > 0 && '\\\\' == esc.charAt(i - nSlashes - 1)) {\n-        ++nSlashes;\n-      }\n-      // if there are an even number of slashes before the \\ u then it is a\n-      // unicode literal.\n-      if (0 == (nSlashes & 1)) { return true; }\n-    }\n-    return false;\n   }\n \n   /**\n         Predicates.<Node>or(\n             new NodeUtil.MatchNodeType(Token.BREAK),\n             new NodeUtil.MatchNodeType(Token.CONTINUE)),\n-        Predicates.<Node>not(new NodeUtil.MatchNodeType(Token.FUNCTION)));\n-  }\n-\n-  /**\n-   * Try to minimize conditions expressions, as there are additional\n-   * assumptions that can be made when it is known that the final result\n-   * is a boolean.\n-   *\n-   * The following transformations are done recursively:\n-   *   !(x||y) --> !x&&!y\n-   *   !(x&&y) --> !x||!y\n-   *   !!x     --> x\n-   * Thus:\n-   *   !(x&&!y) --> !x||!!y --> !x||y\n-   */\n-  void tryMinimizeCondition(NodeTraversal t, Node n, Node parent) {\n-\n-    switch (n.getType()) {\n-      case Token.NOT:\n-        Node first = n.getFirstChild();\n-        switch (first.getType()) {\n-          case Token.NOT: {\n-              Node newRoot = first.removeFirstChild();\n-              parent.replaceChild(n, newRoot);\n-              n = newRoot; // continue from here.\n-              t.getCompiler().reportCodeChange();\n-\n-              // The child has moved up, to minimize it recurse.\n-              tryMinimizeCondition(t, n, parent);\n-              return;\n-            }\n-          case Token.AND:\n-          case Token.OR: {\n-              Node leftParent = first.getFirstChild();\n-              Node rightParent = first.getLastChild();\n-              if (leftParent.getType() != Token.NOT\n-                  || rightParent.getType() != Token.NOT) {\n-                // No NOTs to elminate.\n-                break;\n-              }\n-              Node left = leftParent.removeFirstChild();\n-              Node right = rightParent.removeFirstChild();\n-\n-              int newOp = (first.getType() == Token.AND) ? Token.OR : Token.AND;\n-              Node newRoot = new Node(newOp, left, right);\n-              parent.replaceChild(n, newRoot);\n-              n = newRoot; // continue from here.\n-              t.getCompiler().reportCodeChange();\n-\n-              // Unlike the NOT case above, we know that AND and OR are\n-              // valid root to check minimize so just break out and check\n-              // the children.\n-            }\n-            break;\n-        }\n-        break;\n-\n-      case Token.OR:\n-      case Token.AND:\n-        // check the children.\n-        break;\n-\n-      default:\n-        // if(true) --> if(1)\n-        if (NodeUtil.isLiteralValue(n)) {\n-          boolean result = NodeUtil.getBooleanValue(n);\n-          int equivalentResult = result ? 1 : 0;\n-          maybeReplaceChildWithNumber(t, n, parent, equivalentResult);\n-        }\n-        // We can't do anything else currently.\n-        return;\n-    }\n-\n-    for (Node c = n.getFirstChild(); c != null; ) {\n-      Node next = c.getNext();  // c may be removed.\n-      tryMinimizeCondition(t, c, n);\n-      c = next;\n-    }\n+        new NodeUtil.MatchNotFunction());\n   }\n \n   /**\n         compiler.reportCodeChange();\n       }\n     }\n-  }\n-\n-  /**\n-   * Replaces a node with a number node if the new number node is not equivalent\n-   * to the current node.\n-   */\n-  private void maybeReplaceChildWithNumber(NodeTraversal t, Node n, Node parent,\n-      int num) {\n-    Node newNode = Node.newNumber(num);\n-    if(!newNode.isEquivalentTo(n)) {\n-      parent.replaceChild(n, newNode);\n-      t.getCompiler().reportCodeChange();\n-    }\n-  }\n-\n-  /**\n-   * @return Whether the node is a block with a single statement that is\n-   *     an expression.\n-   */\n-  private boolean isExpressBlock(Node n) {\n-    if (n.getType() == Token.BLOCK) {\n-      if (n.hasOneChild()) {\n-        return NodeUtil.isExpressionNode(n.getFirstChild());\n-      }\n-    }\n-\n-    return false;\n-  }\n-\n-  /**\n-   * @return The expression node.\n-   */\n-  private Node getBlockExpression(Node n) {\n-    Preconditions.checkState(isExpressBlock(n));\n-    return n.getFirstChild();\n-  }\n-\n-  /**\n-   * @return Whether the node is a block with a single statement that is\n-   *     an return.\n-   */\n-  private boolean isReturnExpressBlock(Node n) {\n-    if (n.getType() == Token.BLOCK) {\n-      if (n.hasOneChild()) {\n-        Node first = n.getFirstChild();\n-        if (first.getType() == Token.RETURN) {\n-          return first.hasOneChild();\n-        }\n-      }\n-    }\n-\n-    return false;\n-  }\n-\n-  /**\n-   * @return The expression that is part of the return.\n-   */\n-  private Node getBlockReturnExpression(Node n) {\n-    Preconditions.checkState(isReturnExpressBlock(n));\n-    return n.getFirstChild().getFirstChild();\n-  }\n-\n-  /**\n-   * @return Whether the node is a block with a single statement that is\n-   *     a VAR declaration of a single variable.\n-   */\n-  private boolean isVarBlock(Node n) {\n-    if (n.getType() == Token.BLOCK) {\n-      if (n.hasOneChild()) {\n-        Node first = n.getFirstChild();\n-        if (first.getType() == Token.VAR) {\n-          return first.hasOneChild();\n-        }\n-      }\n-    }\n-\n-    return false;\n-  }\n-\n-  /**\n-   * @return The var node.\n-   */\n-  private Node getBlockVar(Node n) {\n-    Preconditions.checkState(isVarBlock(n));\n-    return n.getFirstChild();\n-  }\n+  } \n }\n--- a/src/com/google/javascript/jscomp/FunctionArgumentInjector.java\n+++ b/src/com/google/javascript/jscomp/FunctionArgumentInjector.java\n    * Gather any names declared in the local scope.\n    */\n   private static void gatherLocalNames(Node n, Set<String> names) {\n-    Preconditions.checkState(n.getType() != Token.FUNCTION);\n-    if (n.getType() == Token.NAME) {\n+    if (n.getType() == Token.FUNCTION) {\n+      if (NodeUtil.isFunctionDeclaration(n)) {\n+        names.add(n.getFirstChild().getString());\n+      }\n+      // Don't traverse into inner function scopes;\n+      return;\n+    } else if (n.getType() == Token.NAME) {\n       switch (n.getParent().getType()) {\n         case Token.VAR:\n         case Token.CATCH:\n--- a/src/com/google/javascript/jscomp/FunctionInjector.java\n+++ b/src/com/google/javascript/jscomp/FunctionInjector.java\n       return false;\n     }\n \n-    // Don't inline functions that introduce function boundaries to prevent\n-    // memory leaks.\n-    if (NodeUtil.containsFunctionDeclaration(block)) {\n-      return false;\n-    }\n-\n     return true;\n   }\n \n   /**\n    * @param t  The traversal use to reach the call site.\n    * @param callNode The CALL node.\n-   * @param fnNode The function to evaluate.\n+   * @param fnNode The function to evaluate for inlining.\n    * @param needAliases A set of function parameter names that can not be\n    *     used without aliasing. Returned by getUnsafeParameterNames().\n-   * @param mode  Inlining mode to be used.\n+   * @param mode Inlining mode to be used.\n+   * @param referencesThis Whether fnNode contains references to its this\n+   *     object.\n+   * @param containsFunctions Whether fnNode contains inner functions.\n    * @return Whether the inlining can occur.\n    */\n   CanInlineResult canInlineReferenceToFunction(NodeTraversal t,\n       Node callNode, Node fnNode, Set<String> needAliases,\n-      InliningMode mode, boolean referencesThis) {\n-\n+      InliningMode mode, boolean referencesThis, boolean containsFunctions) {\n+    // TODO(johnlenz): This function takes too many parameter, without\n+    // context.  Modify the API to take a structure describing the function.\n+    \n     // Allow direct function calls or \"fn.call\" style calls.\n     if (!isSupportedCallType(callNode)) {\n+      return CanInlineResult.NO;\n+    }\n+\n+    // Limit where functions that contain functions can be inline.  Introducing\n+    // an inner function into another function can capture a variable and cause\n+    // a memory leak.  This isn't a problem in the global scope as those values\n+    // last until explicitly cleared.\n+    if (containsFunctions && !t.inGlobalScope()) {\n+      // TODO(johnlenz): Allow inlining into any scope without local names or\n+      // inner functions.\n       return CanInlineResult.NO;\n     }\n \n     // Don't inline functions with var declarations into a scope with inner\n     // functions as the new vars would leak into the inner function and\n     // cause memory leaks.\n-    boolean fnContainsVars = NodeUtil.isNodeTypeReferenced(\n-        NodeUtil.getFunctionBody(fnNode), Token.VAR);\n+    boolean fnContainsVars = NodeUtil.has(\n+        NodeUtil.getFunctionBody(fnNode),\n+        new NodeUtil.MatchDeclaration(),\n+        new NodeUtil.MatchShallowStatement());\n     boolean callerContainsFunction = false;\n     if (!t.inGlobalScope()) {\n       Node fnCaller = t.getScopeRoot();\n       Node fnCallerBody = fnCaller.getLastChild();\n \n-      callerContainsFunction = NodeUtil.containsFunctionDeclaration(\n-          fnCallerBody);\n+      callerContainsFunction = NodeUtil.containsFunction(fnCallerBody);\n     }\n \n     if (fnContainsVars && callerContainsFunction) {\n       // TODO(johnlenz): Counting the number of returns is relatively expensive\n       //   this information should be determined during the traversal and\n       //   cached.\n-      int returnCount = NodeUtil.getNodeTypeReferenceCount(block, Token.RETURN);\n+      int returnCount = NodeUtil.getNodeTypeReferenceCount(\n+          block, Token.RETURN, new NodeUtil.MatchShallowStatement());\n       int resultCount = (returnCount > 0) ? returnCount - 1 : 0;\n       int baseOverhead = (returnCount > 0) ? INLINE_BLOCK_OVERHEAD : 0;\n \n--- a/src/com/google/javascript/jscomp/FunctionToBlockMutator.java\n+++ b/src/com/google/javascript/jscomp/FunctionToBlockMutator.java\n     Node root = block;\n \n     boolean hasReturnAtExit = false;\n-    int returnCount = NodeUtil.getNodeTypeReferenceCount(block, Token.RETURN);\n+    int returnCount = NodeUtil.getNodeTypeReferenceCount(\n+        block, Token.RETURN, new NodeUtil.MatchShallowStatement());\n     if (returnCount > 0) {\n       hasReturnAtExit = hasReturnAtExit(block);\n       // TODO(johnlenz): Simpler not to special case this,\n--- a/src/com/google/javascript/jscomp/InlineFunctions.java\n+++ b/src/com/google/javascript/jscomp/InlineFunctions.java\n         // Functions expressions in the form of:\n         //   var fooFn = function(x) { return ... }\n         case Token.VAR:\n-          // TODO(johnlenz): Make this a Preconditions check.\n-          //     Currently this fails for some targets.\n-          if (n.hasOneChild()) {\n-            // Only look at declarations in the global scope.\n-            Node nameNode = n.getFirstChild();\n-            if (nameNode.getType() == Token.NAME && nameNode.hasChildren()\n-                && nameNode.getFirstChild().getType() == Token.FUNCTION) {\n-              maybeAddFunction(new FunctionVar(n), t.getModule());\n-            }\n+          Preconditions.checkState(n.hasOneChild());\n+          Node nameNode = n.getFirstChild();\n+          if (nameNode.getType() == Token.NAME && nameNode.hasChildren()\n+              && nameNode.getFirstChild().getType() == Token.FUNCTION) {\n+            maybeAddFunction(new FunctionVar(n), t.getModule());\n           }\n           break;\n \n           if (NodeUtil.referencesThis(block)) {\n             fs.setReferencesThis(true);\n           }\n+\n+          if (NodeUtil.containsFunction(block)) {\n+            fs.setHasInnerFunctions(true);\n+            // If there are inner functions, we can inline into global scope\n+            // if there are no local vars or named functions.\n+            // TODO(johnlenz): this can be improved by looking at the possible\n+            // values for locals.  If there are simple values, or constants\n+            // we could still inline.\n+            if (hasLocalNames(fnNode)) {\n+              fs.setInline(false);\n+            }\n+          }\n         }\n \n         // Check if block inlining is allowed.\n         }\n       }\n     }\n+  }\n+\n+  /**\n+   * @param fnNode The function to inspect.\n+   * @return Whether the function has parameters, var, or function declarations.\n+   */\n+  private boolean hasLocalNames(Node fnNode) {\n+    Node block = NodeUtil.getFunctionBody(fnNode);\n+    return NodeUtil.getFnParameters(fnNode).hasChildren()\n+        || NodeUtil.has(\n+             block, \n+             new NodeUtil.MatchDeclaration(), \n+             new NodeUtil.MatchShallowStatement());\n   }\n \n   /**\n         JSModule module, InliningMode mode) {\n       CanInlineResult result = injector.canInlineReferenceToFunction(\n           t, callNode, fs.getFn().getFunctionNode(),\n-          fs.getNamesToAlias(), mode, fs.getReferencesThis());\n+          fs.getNamesToAlias(), mode, fs.getReferencesThis(),\n+          fs.hasInnerFunctions());\n       if (result != CanInlineResult.NO) {\n         // Yeah!\n         boolean decompose =\n     private boolean remove = true;\n     private boolean inlineDirectly = false;\n     private boolean referencesThis = false;\n+    private boolean hasInnerFunctions = false;\n     private Map<Node, Reference> references = null;\n     private JSModule module = null;\n     private Set<String> namesToAlias = null;\n \n     public boolean getReferencesThis() {\n       return this.referencesThis;\n+    }\n+\n+    public void setHasInnerFunctions(boolean hasInnerFunctions) {\n+      this.hasInnerFunctions = hasInnerFunctions;\n+    }\n+\n+\n+    public boolean hasInnerFunctions() {\n+      return hasInnerFunctions;\n     }\n \n     void removeBlockInliningReferences() {\n     }\n   }\n \n-  /** \n-   * Interface for dealing with function declarations and function \n-   * expressions equally \n+  /**\n+   * Interface for dealing with function declarations and function\n+   * expressions equally\n    */\n   private static interface Function {\n     /** Gets the name of the function */\n--- a/src/com/google/javascript/jscomp/NodeUtil.java\n+++ b/src/com/google/javascript/jscomp/NodeUtil.java\n   }\n \n   /**\n-   * Determines if the given node contains a function declaration.\n-   */\n-  static boolean containsFunctionDeclaration(Node n) {\n+   * Determines if the given node contains a function statement or function\n+   * expression.\n+   */\n+  static boolean containsFunction(Node n) {\n     return containsType(n, Token.FUNCTION);\n   }\n \n   /**\n-   * Returns true if the subtree contains references to 'this' keyword\n+   * Returns true if the shallow scope contains references to 'this' keyword\n    */\n   static boolean referencesThis(Node n) {\n-    return containsType(n, Token.THIS);\n+    return containsType(n, Token.THIS, new MatchNotFunction());\n   }\n \n   /**\n     return isNameReferenced(\n         function.getLastChild(),\n         \"arguments\",\n-        Predicates.<Node>not(new MatchNodeType(Token.FUNCTION)));\n+        new MatchNotFunction());\n   }\n \n   /**\n   }\n \n   /**\n-   * @return true if n or any of its children are of the specified type.\n-   *     Does not traverse into functions.\n-   */\n-  static boolean containsTypeInOuterScope(Node node, int type) {\n-    return containsType(node, type,\n-        Predicates.<Node>not(new MatchNodeType(Token.FUNCTION)));\n-  }\n-\n-  /**\n    * @return true if n or any of its children are of the specified type\n    */\n   static boolean containsType(Node node,\n     visitPreOrder(\n         root,\n         collector,\n-        Predicates.<Node>not(new MatchNodeType(Token.FUNCTION)));\n+        new MatchNotFunction());\n     return collector.vars.values();\n   }\n \n     }\n   }\n \n-  /**\n-   * Whether a Node type is within the node tree.\n-   */\n-  static boolean isNodeTypeReferenced(Node node, int type) {\n-    return isNodeTypeReferenced(node, type, Predicates.<Node>alwaysTrue());\n-  }\n-\n-  /**\n-   * Whether a Node type is within the node tree.\n-   */\n-  static boolean isNodeTypeReferenced(\n+\n+  /**\n+   * A predicate for matching var or function declarations.\n+   */\n+  static class MatchDeclaration implements Predicate<Node> {\n+    public boolean apply(Node n) {\n+      return isFunctionDeclaration(n) || n.getType() == Token.VAR;\n+    }\n+  }\n+\n+  /**\n+   * A predicate for matching anything except function nodes.\n+   */\n+  static class MatchNotFunction implements Predicate<Node>{\n+    public boolean apply(Node n) {\n+      return !isFunction(n);\n+    }\n+  }\n+\n+  /**\n+   * A predicate for matching statements without exiting the current scope.\n+   */\n+  static class MatchShallowStatement implements Predicate<Node>{\n+    public boolean apply(Node n) {\n+      Node parent = n.getParent();\n+      return n.getType() == Token.BLOCK\n+          || (!isFunction(n) && (parent == null\n+              || isControlStructure(parent)\n+              || isStatementBlock(parent)));\n+    }\n+  }\n+\n+  /**\n+   * Finds the number of times a type is referenced within the node tree.\n+   */\n+  static int getNodeTypeReferenceCount(\n       Node node, int type, Predicate<Node> traverseChildrenPred) {\n-    return has(node, new MatchNodeType(type), traverseChildrenPred);\n-  }\n-\n-  /**\n-   * Finds the number of times a type is referenced within the node tree.\n-   */\n-  static int getNodeTypeReferenceCount(Node node, int type) {\n-    return getCount(node, new MatchNodeType(type));\n+    return getCount(node, new MatchNodeType(type), traverseChildrenPred);\n   }\n \n   /**\n    * Finds the number of times a simple name is referenced within the node tree.\n    */\n   static int getNameReferenceCount(Node node, String name) {\n-    return getCount(node, new MatchNameNode(name) );\n+    return getCount(\n+        node, new MatchNameNode(name), Predicates.<Node>alwaysTrue());\n   }\n \n   /**\n    * @return The number of times the the predicate is true for the node\n    * or any of its children.\n    */\n-  static int getCount(Node n, Predicate<Node> pred) {\n+  static int getCount(\n+      Node n, Predicate<Node> pred, Predicate<Node> traverseChildrenPred) {\n     int total = 0;\n \n     if (pred.apply(n)) {\n       total++;\n     }\n \n-    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n-      total += getCount(c, pred);\n+    if (traverseChildrenPred.apply(n)) {\n+      for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n+        total += getCount(c, pred, traverseChildrenPred);\n+      }\n     }\n \n     return total;\n--- /dev/null\n+++ b/src/com/google/javascript/jscomp/PeepholeOptimizationsPass.java\n+/*\n+ * Copyright 2010 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+import com.google.common.collect.ImmutableSet;\n+import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n+import com.google.javascript.rhino.Node;\n+\n+/**\n+ * A compiler pass to run various peephole optimizations (e.g. constant folding,\n+ * some useless code removal, some minimizations).\n+ * \n+ * @author dcc@google.com (Devin Coughlin)\n+ */\n+class PeepholeOptimizationsPass extends AbstractPostOrderCallback \n+    implements CompilerPass {\n+  private AbstractCompiler compiler;\n+  \n+  private ImmutableSet<AbstractPeepholeOptimization> peepholeOptimizations;\n+                \n+  PeepholeOptimizationsPass(AbstractCompiler compiler, \n+      ImmutableSet<AbstractPeepholeOptimization> optimizations) {\n+    this.compiler = compiler;\n+    this.peepholeOptimizations = optimizations;\n+  }\n+  \n+  public AbstractCompiler getCompiler() {\n+    return compiler;\n+  }\n+\n+  @Override\n+  public void process(Node externs, Node root) {\n+    NodeTraversal t = new NodeTraversal(compiler, this);\n+    \n+    beginTraversal(t);\n+    t.traverse(root);\n+    endTraversal(t);\n+  }\n+\n+  @Override\n+  public void visit(NodeTraversal t, Node n, Node parent) {\n+    Node currentVersionOfNode = n;\n+    \n+    boolean somethingChanged = false;\n+    \n+    do {\n+      somethingChanged = false;\n+      for (AbstractPeepholeOptimization optimization : peepholeOptimizations) {\n+        Node newVersionOfNode = \n+            optimization.optimizeSubtree(currentVersionOfNode);\n+        \n+        if (newVersionOfNode != currentVersionOfNode) {\n+          somethingChanged = true;\n+          \n+          currentVersionOfNode = newVersionOfNode;\n+        }\n+        \n+        if (currentVersionOfNode == null) {\n+          return;\n+        }\n+      }\n+    } while(somethingChanged);\n+  }\n+  \n+  /**\n+   * Make sure that all the optimizations have the current traversal so they\n+   * can report errors.\n+   */ \n+  private void beginTraversal(NodeTraversal t) {\n+    for (AbstractPeepholeOptimization optimization : peepholeOptimizations) {\n+      optimization.beginTraversal(t);\n+    } \n+  }\n+    \n+  private void endTraversal(NodeTraversal t) {\n+    for (AbstractPeepholeOptimization optimization : peepholeOptimizations) {\n+      optimization.endTraversal(t);\n+    } \n+  }\n+}\n--- /dev/null\n+++ b/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n+/*\n+ * Copyright 2010 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.base.Predicate;\n+import com.google.javascript.rhino.Node;\n+import com.google.javascript.rhino.Token;\n+\n+import java.util.regex.Pattern;\n+\n+/**\n+ * A peephole optimization that minimizes code by simplifying conditional \n+ * expressions, replacing IFs with HOOKs, replacing object constructors\n+ * with literals, and simplifying returns.\n+ * \n+*\n+*\n+ */\n+public class PeepholeSubstituteAlternateSyntax \n+  extends AbstractPeepholeOptimization {\n+\n+  private static final int AND_PRECEDENCE = NodeUtil.precedence(Token.AND);\n+  private static final int OR_PRECEDENCE = NodeUtil.precedence(Token.OR);\n+\n+  static final DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS =\n+    DiagnosticType.error(\n+        \"JSC_INVALID_REGULAR_EXPRESSION_FLAGS\",\n+        \"Invalid flags to RegExp constructor: {0}\");\n+  \n+  static final Predicate<Node> DONT_TRAVERSE_FUNCTIONS_PREDICATE\n+      = new Predicate<Node>() {\n+    @Override\n+    public boolean apply(Node input) {\n+      return input.getType() != Token.FUNCTION;\n+    }\n+  };\n+  \n+  /**\n+   * Tries apply our various peephole minimizations on the passed in node.\n+   */\n+  @Override\n+  public Node optimizeSubtree(Node node) {\n+    switch(node.getType()) {\n+      case Token.RETURN:\n+        return tryReduceReturn(node);        \n+      case Token.NOT:\n+        return tryMinimizeNot(node);\n+      case Token.IF:\n+        tryMinimizeCondition(node.getFirstChild());\n+        return tryMinimizeIf(node);     \n+      case Token.EXPR_RESULT:\n+        tryMinimizeCondition(node.getFirstChild());\n+        return node;\n+      case Token.HOOK:\n+          tryMinimizeCondition(node.getFirstChild());\n+        return node;\n+      case Token.WHILE:\n+      case Token.DO:\n+      case Token.FOR:\n+        if (NodeUtil.getConditionExpression(node) != null) {\n+          tryMinimizeCondition(NodeUtil.getConditionExpression(node));\n+        }\n+        return node;\n+        \n+      case Token.NEW:\n+      case Token.CALL:{\n+        Node left = node.getFirstChild();\n+        if (left != null) {\n+          if (Token.NAME == left.getType()) {\n+            String className = left.getString();\n+            if (\"RegExp\".equals(className)) {\n+              return tryFoldRegularExpressionConstructor(node);\n+            }\n+          }\n+        }    \n+      }\n+        return node;\n+        default:\n+          return node; //Nothing changed\n+    }\n+  }\n+  \n+  /**\n+   * Reduce \"return undefined\" or \"return void 0\" to simply \"return\".\n+   * \n+   * Returns the replacement for n, or the original if no change was made.\n+   */\n+  private Node tryReduceReturn(Node n) {\n+    Node result = n.getFirstChild();\n+    if (result != null) {\n+      switch (result.getType()) {\n+        case Token.VOID:\n+          Node operand = result.getFirstChild();\n+          if (!NodeUtil.mayHaveSideEffects(operand)) {\n+            n.removeFirstChild();\n+            reportCodeChange();\n+          }\n+          break;\n+        case Token.NAME:\n+          String name = result.getString();\n+          if (name.equals(\"undefined\")) {\n+            n.removeFirstChild();\n+            reportCodeChange();\n+          }\n+          break;\n+        default:\n+          //Do nothing\n+            break;\n+      }\n+    }\n+    \n+    return n;\n+  }\n+  \n+  /**\n+   * Try to minimize NOT nodes such as !(x==y).\n+   * \n+   * Returns the replacement for n or the original if no change was made\n+   */\n+  private Node tryMinimizeNot(Node n) {\n+    Node parent = n.getParent();\n+    \n+    Node notChild = n.getFirstChild();\n+    // negative operator of the current one : == -> != for instance.\n+    int complementOperator;\n+    switch (notChild.getType()) {\n+      case Token.EQ:\n+        complementOperator = Token.NE;\n+        break;\n+      case Token.NE:\n+        complementOperator = Token.EQ;\n+        break;\n+      case Token.SHEQ:\n+        complementOperator = Token.SHNE;\n+        break;\n+      case Token.SHNE:\n+        complementOperator = Token.SHEQ;\n+        break;\n+      // GT, GE, LT, LE are not handled in this because !(x<NaN) != x>=NaN.\n+      default:\n+        return n;\n+    }\n+    Node newOperator = n.removeFirstChild();\n+    newOperator.setType(complementOperator);\n+    parent.replaceChild(n, newOperator);\n+    reportCodeChange();\n+    return newOperator;\n+  }\n+  \n+  /**\n+   * Try turning IF nodes into smaller HOOKs\n+   * \n+   * Returns the replacement for n or the original if no replacement was\n+   * necessary.\n+   */\n+  Node tryMinimizeIf(Node n) {\n+    \n+    Node parent = n.getParent();\n+    \n+    Node cond = n.getFirstChild();\n+    Node thenBranch = cond.getNext();\n+    Node elseBranch = thenBranch.getNext();\n+\n+    if (elseBranch == null) {\n+      if (isExpressBlock(thenBranch)) {\n+        Node expr = getBlockExpression(thenBranch);\n+        if (isPropertyAssignmentInExpression(expr)) {\n+          // Keep opportunities for CollapseProperties such as\n+          // a.longIdentifier || a.longIdentifier = ... -> var a = ...;\n+          return n;\n+        }\n+\n+        if (cond.getType() == Token.NOT) {\n+          // if(!x)bar(); -> x||bar();\n+          if (isLowerPrecedenceInExpression(cond, OR_PRECEDENCE) &&\n+              isLowerPrecedenceInExpression(expr.getFirstChild(),\n+                  OR_PRECEDENCE)) {\n+            // It's not okay to add two sets of parentheses.\n+            return n;\n+          }\n+\n+          Node or = new Node(Token.OR, cond.removeFirstChild(),\n+          expr.removeFirstChild()).copyInformationFrom(n);\n+          Node newExpr = NodeUtil.newExpr(or);\n+          parent.replaceChild(n, newExpr);\n+          reportCodeChange();\n+\n+          return newExpr;\n+        }\n+\n+        // if(x)foo(); -> x&&foo();\n+        if (isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) ||\n+            isLowerPrecedenceInExpression(expr.getFirstChild(),\n+                AND_PRECEDENCE)) {\n+          // One additional set of parentheses isn't worth it.\n+          return n;\n+        }\n+\n+        n.removeChild(cond);\n+        Node and = new Node(Token.AND, cond, expr.removeFirstChild())\n+                       .copyInformationFrom(n);\n+        Node newExpr = NodeUtil.newExpr(and);\n+        parent.replaceChild(n, newExpr);\n+        reportCodeChange();\n+        \n+        return newExpr;\n+      }\n+\n+      return n;\n+    }\n+   \n+    /* TODO(dcc) This modifies the siblings of n, which is undesirable for a\n+     * peephole optimization. This should probably get moved to another pass.\n+     */\n+    tryRemoveRepeatedStatements(n);\n+\n+    // if(!x)foo();else bar(); -> if(x)bar();else foo();\n+    // An additional set of curly braces isn't worth it.\n+    if (cond.getType() == Token.NOT && !consumesDanglingElse(elseBranch)) {\n+      n.replaceChild(cond, cond.removeFirstChild());\n+      n.removeChild(thenBranch);\n+      n.addChildToBack(thenBranch);\n+      reportCodeChange();\n+      return n;\n+    }\n+\n+    // if(x)return 1;else return 2; -> return x?1:2;\n+    if (isReturnExpressBlock(thenBranch) && isReturnExpressBlock(elseBranch)) {\n+      Node thenExpr = getBlockReturnExpression(thenBranch);\n+      Node elseExpr = getBlockReturnExpression(elseBranch);\n+      n.removeChild(cond);\n+      thenExpr.detachFromParent();\n+      elseExpr.detachFromParent();\n+\n+      // note - we ignore any cases with \"return;\", technically this\n+      // can be converted to \"return undefined;\" or some variant, but\n+      // that does not help code size.\n+      Node hookNode = new Node(Token.HOOK, cond, thenExpr, elseExpr)\n+                          .copyInformationFrom(n);\n+      Node returnNode = new Node(Token.RETURN, hookNode);\n+      parent.replaceChild(n, returnNode);\n+      reportCodeChange();\n+      return returnNode;\n+    }\n+\n+    boolean thenBranchIsExpressionBlock = isExpressBlock(thenBranch);\n+    boolean elseBranchIsExpressionBlock = isExpressBlock(elseBranch);\n+\n+    if (thenBranchIsExpressionBlock && elseBranchIsExpressionBlock) {\n+      Node thenOp = getBlockExpression(thenBranch).getFirstChild();\n+      Node elseOp = getBlockExpression(elseBranch).getFirstChild();\n+      if (thenOp.getType() == elseOp.getType()) {\n+        // if(x)a=1;else a=2; -> a=x?1:2;\n+        if (NodeUtil.isAssignmentOp(thenOp)) {\n+          Node lhs = thenOp.getFirstChild();\n+          if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) &&\n+              // if LHS has side effects, don't proceed [since the optimization\n+              // evaluates LHS before cond]\n+              // NOTE - there are some circumstances where we can\n+              // proceed even if there are side effects...\n+              !NodeUtil.mayEffectMutableState(lhs)) {\n+\n+            n.removeChild(cond);\n+            Node assignName = thenOp.removeFirstChild();\n+            Node thenExpr = thenOp.removeFirstChild();\n+            Node elseExpr = elseOp.getLastChild();\n+            elseOp.removeChild(elseExpr);\n+\n+            Node hookNode = new Node(Token.HOOK, cond, thenExpr, elseExpr)\n+                                .copyInformationFrom(n);\n+            Node assign = new Node(thenOp.getType(), assignName, hookNode)\n+                              .copyInformationFrom(thenOp);\n+            Node expr = NodeUtil.newExpr(assign);\n+            parent.replaceChild(n, expr);\n+            reportCodeChange();\n+            \n+            return expr;\n+          }\n+        } else if (NodeUtil.isCall(thenOp)) {\n+          // if(x)foo();else bar(); -> x?foo():bar()\n+          n.removeChild(cond);\n+          thenOp.detachFromParent();\n+          elseOp.detachFromParent();\n+          Node hookNode = new Node(Token.HOOK, cond, thenOp, elseOp)\n+                              .copyInformationFrom(n);\n+          Node expr = NodeUtil.newExpr(hookNode);\n+          parent.replaceChild(n, expr);\n+          reportCodeChange();\n+          \n+          return expr;\n+        }\n+      }\n+      return n;\n+    }\n+\n+    boolean thenBranchIsVar = isVarBlock(thenBranch);\n+    boolean elseBranchIsVar = isVarBlock(elseBranch);\n+\n+    // if(x)var y=1;else y=2  ->  var y=x?1:2\n+    if (thenBranchIsVar && elseBranchIsExpressionBlock &&\n+        NodeUtil.isAssign(getBlockExpression(elseBranch).getFirstChild())) {\n+\n+      Node var = getBlockVar(thenBranch);\n+      Node elseAssign = getBlockExpression(elseBranch).getFirstChild();\n+\n+      Node name1 = var.getFirstChild();\n+      Node maybeName2 = elseAssign.getFirstChild();\n+\n+      if (name1.hasChildren()\n+          && maybeName2.getType() == Token.NAME\n+          && name1.getString().equals(maybeName2.getString())) {\n+        Node thenExpr = name1.removeChildren();\n+        Node elseExpr = elseAssign.getLastChild().detachFromParent();\n+        cond.detachFromParent();\n+        Node hookNode = new Node(Token.HOOK, cond, thenExpr, elseExpr)\n+                            .copyInformationFrom(n);\n+        var.detachFromParent();\n+        name1.addChildrenToBack(hookNode);\n+        parent.replaceChild(n, var);\n+        reportCodeChange();\n+        return var;\n+      }\n+\n+    // if(x)y=1;else var y=2  ->  var y=x?1:2\n+    } else if (elseBranchIsVar && thenBranchIsExpressionBlock &&\n+        NodeUtil.isAssign(getBlockExpression(thenBranch).getFirstChild())) {\n+\n+      Node var = getBlockVar(elseBranch);\n+      Node thenAssign = getBlockExpression(thenBranch).getFirstChild();\n+\n+      Node maybeName1 = thenAssign.getFirstChild();\n+      Node name2 = var.getFirstChild();\n+\n+      if (name2.hasChildren()\n+          && maybeName1.getType() == Token.NAME\n+          && maybeName1.getString().equals(name2.getString())) {\n+        Node thenExpr = thenAssign.getLastChild().detachFromParent();\n+        Node elseExpr = name2.removeChildren();\n+        cond.detachFromParent();\n+        Node hookNode = new Node(Token.HOOK, cond, thenExpr, elseExpr)\n+                            .copyInformationFrom(n);\n+        var.detachFromParent();\n+        name2.addChildrenToBack(hookNode);\n+        parent.replaceChild(n, var);\n+        reportCodeChange();\n+        \n+        return var;\n+      }\n+    }\n+    \n+    return n;\n+  }\n+  \n+  /**\n+   * Try to remove duplicate statements from IF blocks. For example:\n+   *\n+   * if (a) {\n+   *   x = 1;\n+   *   return true;\n+   * } else {\n+   *   x = 2;\n+   *   return true;\n+   * }\n+   *\n+   * becomes:\n+   *\n+   * if (a) {\n+   *   x = 1;\n+   * } else {\n+   *   x = 2;\n+   * }\n+   * return true;\n+   *\n+   * @param n The IF node to examine.\n+   */\n+  private void tryRemoveRepeatedStatements(Node n) {\n+    Preconditions.checkState(n.getType() == Token.IF);\n+\n+    Node parent = n.getParent();\n+    if (!NodeUtil.isStatementBlock(parent)) {\n+      // If the immediate parent is something like a label, we\n+      // can't move the statement, so bail.\n+      return;\n+    }\n+\n+    Node cond = n.getFirstChild();\n+    Node trueBranch = cond.getNext();\n+    Node falseBranch = trueBranch.getNext();\n+    Preconditions.checkNotNull(trueBranch);\n+    Preconditions.checkNotNull(falseBranch);\n+\n+    while (true) {\n+      Node lastTrue = trueBranch.getLastChild();\n+      Node lastFalse = falseBranch.getLastChild();\n+      if (lastTrue == null || lastFalse == null\n+          || !areNodesEqualForInlining(lastTrue, lastFalse)) {\n+        break;\n+      }\n+      lastTrue.detachFromParent();\n+      lastFalse.detachFromParent();\n+      parent.addChildAfter(lastTrue, n);\n+      reportCodeChange();\n+    }\n+  }\n+  /**\n+   * @return Whether the node is a block with a single statement that is\n+   *     an expression.\n+   */\n+  private boolean isExpressBlock(Node n) {\n+    if (n.getType() == Token.BLOCK) {\n+      if (n.hasOneChild()) {\n+        return NodeUtil.isExpressionNode(n.getFirstChild());\n+      }\n+    }\n+\n+    return false;\n+  }\n+ \n+  /**\n+   * @return The expression node.\n+   */\n+  private Node getBlockExpression(Node n) {\n+    Preconditions.checkState(isExpressBlock(n));\n+    return n.getFirstChild();\n+  }\n+\n+  /**\n+   * @return Whether the node is a block with a single statement that is\n+   *     an return.\n+   */\n+  private boolean isReturnExpressBlock(Node n) {\n+    if (n.getType() == Token.BLOCK) {\n+      if (n.hasOneChild()) {\n+        Node first = n.getFirstChild();\n+        if (first.getType() == Token.RETURN) {\n+          return first.hasOneChild();\n+        }\n+      }\n+    }\n+\n+    return false;\n+  }\n+\n+  /**\n+   * @return The expression that is part of the return.\n+   */\n+  private Node getBlockReturnExpression(Node n) {\n+    Preconditions.checkState(isReturnExpressBlock(n));\n+    return n.getFirstChild().getFirstChild();\n+  }\n+\n+  /**\n+   * @return Whether the node is a block with a single statement that is\n+   *     a VAR declaration of a single variable.\n+   */\n+  private boolean isVarBlock(Node n) {\n+    if (n.getType() == Token.BLOCK) {\n+      if (n.hasOneChild()) {\n+        Node first = n.getFirstChild();\n+        if (first.getType() == Token.VAR) {\n+          return first.hasOneChild();\n+        }\n+      }\n+    }\n+\n+    return false;\n+  }\n+\n+  /**\n+   * @return The var node.\n+   */\n+  private Node getBlockVar(Node n) {\n+    Preconditions.checkState(isVarBlock(n));\n+    return n.getFirstChild();\n+  }\n+  \n+  /**\n+   * Does a statement consume a 'dangling else'? A statement consumes\n+   * a 'dangling else' if an 'else' token following the statement\n+   * would be considered by the parser to be part of the statement.\n+   */\n+  private boolean consumesDanglingElse(Node n) {\n+    while (true) {\n+      switch (n.getType()) {\n+        case Token.IF:\n+          if (n.getChildCount() < 3) {\n+            return true;\n+          }\n+          // This IF node has no else clause.\n+          n = n.getLastChild();\n+          continue;\n+        case Token.WITH:\n+        case Token.WHILE:\n+        case Token.FOR:\n+          n = n.getLastChild();\n+          continue;\n+        default:\n+          return false;\n+      }\n+    }\n+  }\n+  \n+  /**\n+   * Does the expression contain an operator with lower precedence than\n+   * the argument?\n+   */\n+  private boolean isLowerPrecedenceInExpression(Node n,\n+      final int precedence) {  \n+    Predicate<Node> isLowerPrecedencePredicate = new Predicate<Node>() {\n+      @Override\n+      public boolean apply(Node input) {\n+        return NodeUtil.precedence(input.getType()) < precedence;\n+      }\n+    };\n+    \n+    return NodeUtil.has(n, isLowerPrecedencePredicate,\n+        DONT_TRAVERSE_FUNCTIONS_PREDICATE);\n+  }\n+\n+  /**\n+   * Does the expression contain a property assignment?\n+   */\n+  private boolean isPropertyAssignmentInExpression(Node n) {\n+    Predicate<Node> isPropertyAssignmentInExpressionPredicate = \n+        new Predicate<Node>() {\n+      @Override\n+      public boolean apply(Node input) {\n+        return (input.getType() == Token.GETPROP && \n+            input.getParent().getType() == Token.ASSIGN);\n+      }\n+    };\n+    \n+    return NodeUtil.has(n, isPropertyAssignmentInExpressionPredicate,\n+        DONT_TRAVERSE_FUNCTIONS_PREDICATE);\n+  }\n+\n+  /**\n+   * Try to minimize conditions expressions, as there are additional\n+   * assumptions that can be made when it is known that the final result\n+   * is a boolean.\n+   *\n+   * The following transformations are done recursively:\n+   *   !(x||y) --> !x&&!y\n+   *   !(x&&y) --> !x||!y\n+   *   !!x     --> x\n+   * Thus:\n+   *   !(x&&!y) --> !x||!!y --> !x||y\n+   *   \n+   *   Returns the replacement for n, or the original if no change was made\n+   */\n+  Node tryMinimizeCondition(Node n) {\n+    Node parent = n.getParent();\n+    \n+    switch (n.getType()) {\n+      case Token.NOT:\n+        Node first = n.getFirstChild();\n+        switch (first.getType()) {\n+          case Token.NOT: {\n+              Node newRoot = first.removeFirstChild();\n+              parent.replaceChild(n, newRoot);\n+              n = newRoot; // continue from here.\n+              reportCodeChange();\n+\n+              // The child has moved up, to minimize it recurse.\n+              \n+              return tryMinimizeCondition(n);\n+            }\n+          case Token.AND:\n+          case Token.OR: {\n+              Node leftParent = first.getFirstChild();\n+              Node rightParent = first.getLastChild();\n+              if (leftParent.getType() != Token.NOT\n+                  || rightParent.getType() != Token.NOT) {\n+                // No NOTs to elminate.\n+                break;\n+              }\n+              Node left = leftParent.removeFirstChild();\n+              Node right = rightParent.removeFirstChild();\n+\n+              int newOp = (first.getType() == Token.AND) ? Token.OR : Token.AND;\n+              Node newRoot = new Node(newOp, left, right);\n+              parent.replaceChild(n, newRoot);\n+              n = newRoot; // continue from here.\n+              reportCodeChange();\n+\n+              // Unlike the NOT case above, we know that AND and OR are\n+              // valid root to check minimize so just break out and check\n+              // the children.\n+            }\n+            break;\n+        }\n+        break;\n+\n+      case Token.OR:\n+      case Token.AND:\n+        // check the children.\n+        break;\n+\n+      default:\n+        // if(true) --> if(1)\n+        if (NodeUtil.isLiteralValue(n)) {\n+          boolean result = NodeUtil.getBooleanValue(n);\n+          int equivalentResult = result ? 1 : 0;\n+          return maybeReplaceChildWithNumber(n, parent, equivalentResult);\n+        }\n+        // We can't do anything else currently.\n+        return n;\n+    }\n+\n+    for (Node c = n.getFirstChild(); c != null; ) {\n+      Node next = c.getNext();  // c may be removed.\n+      tryMinimizeCondition(c);\n+      c = next;\n+    }\n+    \n+    return n;\n+  }\n+  \n+  /**\n+   * Replaces a node with a number node if the new number node is not equivalent\n+   * to the current node.\n+   * \n+   * Returns the replacement for n if it was replaced, otherwise returns n.\n+   */\n+  private Node maybeReplaceChildWithNumber(Node n, Node parent, int num) {\n+    Node newNode = Node.newNumber(num);\n+    if (!newNode.isEquivalentTo(n)) {\n+      parent.replaceChild(n, newNode);\n+      reportCodeChange();\n+      \n+      return newNode;\n+    }\n+    \n+    return n;\n+  }\n+\n+  private Node tryFoldRegularExpressionConstructor(Node n) { \n+    Node parent = n.getParent();\n+    Node constructor = n.getFirstChild();\n+    Node pattern = constructor.getNext();  // e.g.  ^foobar$\n+    Node flags = null != pattern ? pattern.getNext() : null;  // e.g. gi\n+\n+    if (null == pattern || (null != flags && null != flags.getNext())) {\n+      // too few or too many arguments\n+      return n;\n+    }\n+\n+    if (// is pattern folded\n+        pattern.getType() == Token.STRING\n+        // make sure empty pattern doesn't fold to //\n+        && !\"\".equals(pattern.getString())\n+\n+        // NOTE(nicksantos): Make sure that the regexp isn't longer than\n+        // 100 chars, or it blows up the regexp parser in Opera 9.2.\n+        && pattern.getString().length() < 100\n+\n+        && (null == flags || flags.getType() == Token.STRING)\n+        // don't escape patterns with unicode escapes since Safari behaves badly\n+        // (read can't parse or crashes) on regex literals with unicode escapes\n+        && !containsUnicodeEscape(pattern.getString())) {\n+\n+      // Make sure that / is escaped, so that it will fit safely in /brackets/.\n+      // pattern is a string value with \\\\ and similar already escaped\n+      pattern = makeForwardSlashBracketSafe(pattern);\n+\n+      Node regexLiteral;\n+      if (null == flags || \"\".equals(flags.getString())) {\n+        // fold to /foobar/\n+        regexLiteral = new Node(Token.REGEXP, pattern);\n+      } else {\n+        // fold to /foobar/gi\n+        if (!areValidRegexpFlags(flags.getString())) {\n+          error(INVALID_REGULAR_EXPRESSION_FLAGS, flags);\n+          return n;\n+        }\n+        if (!areSafeFlagsToFold(flags.getString())) {\n+          return n;\n+        }\n+        n.removeChild(flags);\n+        regexLiteral = new Node(Token.REGEXP, pattern, flags);\n+      }\n+\n+      parent.replaceChild(n, regexLiteral);\n+      reportCodeChange();\n+      return regexLiteral;\n+    }\n+\n+    return n;\n+  }\n+\n+  private static final Pattern REGEXP_FLAGS_RE = Pattern.compile(\"^[gmi]*$\");\n+\n+  /**\n+   * are the given flags valid regular expression flags?\n+   * Javascript recognizes several suffix flags for regular expressions,\n+   * 'g' - global replace, 'i' - case insensitive, 'm' - multi-line.\n+   * They are case insensitive, and javascript does not recognize the extended\n+   * syntax mode, single-line mode, or expression replacement mode from perl5.\n+   */\n+  private static boolean areValidRegexpFlags(String flags) {\n+    return REGEXP_FLAGS_RE.matcher(flags).matches();\n+  }\n+\n+  /**\n+   * are the given flags safe to fold?\n+   * We don't fold the regular expression if global ('g') flag is on,\n+   * because in this case it isn't really a constant: its 'lastIndex'\n+   * property contains the state of last execution, so replacing\n+   * 'new RegExp('foobar','g')' with '/foobar/g' may change the behavior of\n+   * the program if the RegExp is used inside a loop, for example.\n+   */\n+  private static boolean areSafeFlagsToFold(String flags) {\n+    return flags.indexOf('g') < 0;\n+  }\n+\n+  /**\n+   * returns a string node that can safely be rendered inside /brackets/.\n+   */\n+  private static Node makeForwardSlashBracketSafe(Node n) {\n+    String s = n.getString();\n+    // sb contains everything in s[0:pos]\n+    StringBuilder sb = null;\n+    int pos = 0;\n+    for (int i = 0; i < s.length(); ++i) {\n+      switch (s.charAt(i)) {\n+        case '\\\\':  // skip over the next char after a '\\\\'.\n+          ++i;\n+          break;\n+        case '/':  // escape it\n+          if (null == sb) { sb = new StringBuilder(s.length() + 16); }\n+          sb.append(s, pos, i).append('\\\\');\n+          pos = i;\n+          break;\n+      }\n+    }\n+\n+    // don't discard useful line-number info if there were no changes\n+    if (null == sb) { return n.cloneTree(); }\n+\n+    sb.append(s, pos, s.length());\n+    return Node.newString(sb.toString()).copyInformationFrom(n);\n+  }\n+  \n+  /**\n+   * true if the javascript string would contain a unicode escape when written\n+   * out as the body of a regular expression literal.\n+   */\n+  static boolean containsUnicodeEscape(String s) {\n+    String esc = CodeGenerator.regexpEscape(s);\n+    for (int i = -1; (i = esc.indexOf(\"\\\\u\", i + 1)) >= 0;) {\n+      int nSlashes = 0;\n+      while (i - nSlashes > 0 && '\\\\' == esc.charAt(i - nSlashes - 1)) {\n+        ++nSlashes;\n+      }\n+      // if there are an even number of slashes before the \\ u then it is a\n+      // unicode literal.\n+      if (0 == (nSlashes & 1)) { return true; }\n+    }\n+    return false;\n+  }\n+}\n--- a/test/com/google/javascript/jscomp/FoldConstantsTest.java\n+++ b/test/com/google/javascript/jscomp/FoldConstantsTest.java\n \n package com.google.javascript.jscomp;\n \n+import com.google.common.collect.ImmutableSet;\n import com.google.javascript.rhino.Node;\n \n public class FoldConstantsTest extends CompilerTestCase {\n     return new CompilerPass() {\n       public void process(Node externs, Node js) {\n         NodeTraversal.traverse(compiler, js, new FoldConstants(compiler));\n+\n+        /* TODO(dcc): For now we run all remaining FoldConstants tests under\n+         * both the FoldConstants pass and the new PeepholeOptimizationPass,\n+         * since many remaining FoldConstants tests rely on functionality\n+         * that used to be in FoldConstants but is now in some\n+         * PeepholeOptimization (e.g. PeepholeSubstituteAlternateSyntax).\n+         *\n+         * As we continue with refactoring FoldConstants, more and more of\n+         * these tests will be moved to their own PeepholeFooTest files.\n+         *\n+         * Those that genuinely need to test combinations of different\n+         * Peephole passes will be moved to AbstractPeepholeOptimizationTest.\n+         */\n+\n+        ImmutableSet<AbstractPeepholeOptimization> peepholeOptimizations =\n+          ImmutableSet.<AbstractPeepholeOptimization>of(\n+              new PeepholeSubstituteAlternateSyntax());\n+\n+        PeepholeOptimizationsPass peepholePass =\n+            new PeepholeOptimizationsPass(compiler, peepholeOptimizations);\n+\n+        peepholePass.process(externs, js);\n       }\n     };\n   }\n     // Test an obscure case with do and while\n     fold(\"if(x){do{foo()}while(y)}else bar()\",\n          \"if(x){do foo();while(y)}else bar()\");\n-\n \n     // Play with nested IFs\n     fold(\"function(){if(x){if(y)foo()}}\",\n     fold(\"function z() {if (a()) { return true }\" +\n          \"else if (b()) { return true }\" +\n          \"else { return true }}\",\n-         \"function z() {if (!a()) { b() } return true;}\");\n+         \"function z() {a()||b();return true;}\");\n     fold(\"function z() {\" +\n          \"  if (a) { bar(); foo(); return true }\" +\n          \"    else { bar(); goo(); return true }\" +\n     fold(\"x = 'abcnulldef'.indexOf(null)\", \"x = 3\");\n     fold(\"x = 'abctruedef'.indexOf(true)\", \"x = 3\");\n \n-\n     // The following testcase fails with JSC_PARSE_ERROR. Hence omitted.\n     // foldSame(\"x = 1.indexOf('bcd');\");\n     foldSame(\"x = NaN.indexOf('bcd')\");\n     // Bogus flags should not fold\n     fold(\"x = new RegExp(\\\"foobar\\\", \\\"bogus\\\")\",\n          \"x = RegExp(\\\"foobar\\\",\\\"bogus\\\")\",\n-         FoldConstants.INVALID_REGULAR_EXPRESSION_FLAGS);\n+         PeepholeSubstituteAlternateSyntax.INVALID_REGULAR_EXPRESSION_FLAGS);\n     // Don't fold if the flags contain 'g'\n     fold(\"x = new RegExp(\\\"foobar\\\", \\\"g\\\")\",\n          \"x = RegExp(\\\"foobar\\\",\\\"g\\\")\");\n   }\n \n   public void testContainsUnicodeEscape() throws Exception {\n-    assertTrue(!FoldConstants.containsUnicodeEscape(\"\"));\n-    assertTrue(!FoldConstants.containsUnicodeEscape(\"foo\"));\n-    assertTrue( FoldConstants.containsUnicodeEscape(\"\\u2028\"));\n-    assertTrue( FoldConstants.containsUnicodeEscape(\"\\\\u2028\"));\n-    assertTrue( FoldConstants.containsUnicodeEscape(\"foo\\\\u2028\"));\n-    assertTrue(!FoldConstants.containsUnicodeEscape(\"foo\\\\\\\\u2028\"));\n-    assertTrue( FoldConstants.containsUnicodeEscape(\"foo\\\\\\\\u2028bar\\\\u2028\"));\n+    assertTrue(!PeepholeSubstituteAlternateSyntax.containsUnicodeEscape(\"\"));\n+    assertTrue(!PeepholeSubstituteAlternateSyntax.containsUnicodeEscape(\"foo\"));\n+    assertTrue(PeepholeSubstituteAlternateSyntax.containsUnicodeEscape(\n+        \"\\u2028\"));\n+    assertTrue(PeepholeSubstituteAlternateSyntax.containsUnicodeEscape(\n+        \"\\\\u2028\"));\n+    assertTrue(\n+        PeepholeSubstituteAlternateSyntax.containsUnicodeEscape(\"foo\\\\u2028\"));\n+    assertTrue(!PeepholeSubstituteAlternateSyntax.containsUnicodeEscape(\n+        \"foo\\\\\\\\u2028\"));\n+    assertTrue(PeepholeSubstituteAlternateSyntax.containsUnicodeEscape(\n+            \"foo\\\\\\\\u2028bar\\\\u2028\"));\n   }\n \n   public void testBug1438784() throws Exception {\n     fold(\"for(var i=0;i<10;i++)if(x)x.y;\", \"for(var i=0;i<10;i++);\");\n   }\n-\n \n   public void testFoldUselessWhile() {\n     fold(\"while(false) { foo() }\", \"\");\n   }\n \n   public void testBug1509085() {\n-    new FoldConstantsTest() {\n+    FoldConstantsTest oneRepetitiontest = new FoldConstantsTest() {\n       @Override\n       protected int getNumRepetitions() {\n         return 1;\n       }\n-    }.fold(\"x ? x() : void 0\", \"if(x) x();\");\n+    };\n+\n+    oneRepetitiontest.fold(\"x ? x() : void 0\", \"x&&x();\");\n+    oneRepetitiontest.foldSame(\"y = x ? x() : void 0\");\n   }\n \n   public void testFoldInstanceOf() {\n--- a/test/com/google/javascript/jscomp/FunctionArgumentInjectorTest.java\n+++ b/test/com/google/javascript/jscomp/FunctionArgumentInjectorTest.java\n         Sets.newHashSet(\"a\", \"b\"));\n   }\n \n+  public void testMaybeAddTempsForCallArguments14() {\n+    // Parameters referenced in a loop must\n+    // be assigned to temps.\n+    testNeededTemps(\n+        \"function foo(a,b){goo();for(;;){a;b;}}; foo(x,y);\",\n+        \"foo\",\n+        Sets.newHashSet(\"a\", \"b\"));\n+  }  \n+\n   public void testMaybeAddTempsForCallArguments20() {\n     // A long string referenced more than once should have a temp.\n     testNeededTemps(\n--- a/test/com/google/javascript/jscomp/FunctionInjectorTest.java\n+++ b/test/com/google/javascript/jscomp/FunctionInjectorTest.java\n         \"foo\", INLINE_BLOCK);\n   }\n \n+  public void testCanInlineReferenceToFunction45() {\n+    // Call with inner function expression.\n+    helperCanInlineReferenceToFunction(CanInlineResult.YES,\n+        \"function foo(){return function() {return true;}}; foo();\",\n+        \"foo\", INLINE_DIRECT);\n+  }\n+\n+  public void testCanInlineReferenceToFunction46() {\n+    // Call with inner function expression.\n+    helperCanInlineReferenceToFunction(CanInlineResult.YES,\n+        \"function foo(){return function() {return true;}}; foo();\",\n+        \"foo\", INLINE_BLOCK);\n+  }\n+\n+  public void testCanInlineReferenceToFunction47() {\n+    // Call with inner function expression and variable decl.\n+    helperCanInlineReferenceToFunction(CanInlineResult.NO,\n+        \"function foo(){var a; return function() {return true;}}; foo();\",\n+        \"foo\", INLINE_DIRECT);\n+  }\n+\n+  public void testCanInlineReferenceToFunction48() {\n+    // Call with inner function expression and variable decl.\n+    // TODO(johnlenz): should we validate no values in scope?\n+    helperCanInlineReferenceToFunction(CanInlineResult.YES,\n+        \"function foo(){var a; return function() {return true;}}; foo();\",\n+        \"foo\", INLINE_BLOCK);\n+  }\n+\n+  public void testCanInlineReferenceToFunction49() {\n+    // Call with inner function expression.\n+    helperCanInlineReferenceToFunction(CanInlineResult.YES,\n+        \"function foo(){return function() {var a; return true;}}; foo();\",\n+        \"foo\", INLINE_DIRECT);\n+  }\n+\n+  public void testCanInlineReferenceToFunction50() {\n+    // Call with inner function expression.\n+    helperCanInlineReferenceToFunction(CanInlineResult.YES,\n+        \"function foo(){return function() {var a; return true;}}; foo();\",\n+        \"foo\", INLINE_BLOCK);\n+  }\n+\n+  public void testCanInlineReferenceToFunction51() {\n+    // Call with inner function statement.\n+    helperCanInlineReferenceToFunction(CanInlineResult.YES,\n+        \"function foo(){function x() {var a; return true;} return x}; foo();\",\n+        \"foo\", INLINE_BLOCK);\n+  }\n+\n   public void testCanInlineReferenceToFunctionInExpression1() {\n     // Call in if condition\n     helperCanInlineReferenceToFunction(CanInlineResult.YES,\n             \"for(var b$$inline_3 in c){\" +\n               \"1;break JSCompiler_inline_label_foo_4\" +\n             \"}}}}\",\n+        \"foo\", INLINE_BLOCK);\n+  }\n+\n+  public void testInlineFunctionWithInnerFunction1() {\n+    // Call with inner function expression.\n+    helperInlineReferenceToFunction(\n+        \"function foo(){return function() {return true;}}; foo();\",\n+        \"function foo(){return function() {return true;}};\" +\n+            \"(function() {return true;})\",\n+        \"foo\", INLINE_DIRECT);\n+  }\n+\n+  public void testInlineFunctionWithInnerFunction2() {\n+    // Call with inner function expression.\n+    helperInlineReferenceToFunction(\n+        \"function foo(){return function() {return true;}}; foo();\",\n+        \"function foo(){return function() {return true;}};\" +\n+            \"{(function() {return true;})}\",\n+        \"foo\", INLINE_BLOCK);\n+  }\n+\n+  public void testInlineFunctionWithInnerFunction3() {\n+    // Call with inner function expression.\n+    helperInlineReferenceToFunction(\n+        \"function foo(){return function() {var a; return true;}}; foo();\",\n+        \"function foo(){return function() {var a; return true;}};\" +\n+            \"(function() {var a; return true;});\",\n+        \"foo\", INLINE_DIRECT);\n+  }\n+\n+  public void testInlineFunctionWithInnerFunction4() {\n+    // Call with inner function expression.\n+    helperInlineReferenceToFunction(\n+        \"function foo(){return function() {var a; return true;}}; foo();\",\n+        \"function foo(){return function() {var a; return true;}};\" +\n+            \"{(function() {var a$$inline_0; return true;});}\",\n+        \"foo\", INLINE_BLOCK);\n+  }\n+\n+  public void testInlineFunctionWithInnerFunction5() {\n+    // Call with inner function statement.\n+    helperInlineReferenceToFunction(\n+        \"function foo(){function x() {var a; return true;} return x}; foo();\",\n+        \"function foo(){function x(){var a;return true}return x};\" +\n+            \"{function x$$inline_1(){var a$$inline_2;return true}x$$inline_1}\",\n         \"foo\", INLINE_BLOCK);\n   }\n \n     Method tester = new Method() {\n       public boolean call(NodeTraversal t, Node n, Node parent) {\n         CanInlineResult result = injector.canInlineReferenceToFunction(\n-            t, n, fnNode, unsafe, mode, NodeUtil.referencesThis(fnNode));\n+            t, n, fnNode, unsafe, mode,\n+            NodeUtil.referencesThis(fnNode),\n+            NodeUtil.containsFunction(NodeUtil.getFunctionBody(fnNode)));\n         assertEquals(expectedResult, result);\n         return true;\n       }\n       public boolean call(NodeTraversal t, Node n, Node parent) {\n \n         CanInlineResult canInline = injector.canInlineReferenceToFunction(\n-            t, n, fnNode, unsafe, mode, NodeUtil.referencesThis(fnNode));\n+            t, n, fnNode, unsafe, mode,\n+            NodeUtil.referencesThis(fnNode),\n+            NodeUtil.containsFunction(NodeUtil.getFunctionBody(fnNode)));\n         assertTrue(\"canInlineReferenceToFunction should not be CAN_NOT_INLINE\",\n             CanInlineResult.NO != canInline);\n         if (decompose) {\n--- a/test/com/google/javascript/jscomp/InlineFunctionsTest.java\n+++ b/test/com/google/javascript/jscomp/InlineFunctionsTest.java\n              \";b=FOO;a(BAR);x=1;y=2\");\n   }\n \n-  public void testInlineFunctions15() {\n-    // don't inline closure factories\n+  public void testInlineFunctions15a() {\n+    // closure factories: do inline into global scope.\n     test(\"function foo(){return function(a){return a+1}}\" +\n          \"var b=function(){return c};\" +\n          \"var d=b()+foo()\",\n \n+         \"var d=c+function(a){return a+1}\");\n+  }\n+\n+  public void testInlineFunctions15b() {\n+    // closure factories: don't inline closure with locals.\n+    test(\"function foo(){var x;return function(a){return a+1}}\" +\n+         \"var b=function(){return c};\" +\n+         \"var d=b()+foo()\",\n+\n+         \"function foo(){var x;return function(a){return a+1}}\" +\n+         \"var d=c+foo()\");\n+  }\n+\n+  public void testInlineFunctions15c() {\n+    // closure factories: don't inline into non-global scope.\n+    test(\"function foo(){return function(a){return a+1}}\" +\n+         \"var b=function(){return c};\" +\n+         \"function _x(){ var d=b()+foo() }\",\n+\n          \"function foo(){return function(a){return a+1}}\" +\n-         \"var d=c+foo()\");\n+         \"function _x(){ var d=c+foo() }\");\n   }\n \n   public void testInlineFunctions16() {\n         );\n    }\n \n-  public void testComplexFunctionWithFunctionDefinition() {\n-    testSame(\"function f(){call(function(){return})}f()\");\n+  public void testComplexFunctionWithFunctionDefinition1() {\n+    test(\"function f(){call(function(){return})}f()\",\n+         \"{call(function(){return})}\");\n+  }\n+\n+  public void testComplexFunctionWithFunctionDefinition2() {\n+    // Don't inline if local names might need to be captured.\n+    testSame(\"function f(a){call(function(){return})}f()\");\n+  }\n+\n+  public void testComplexFunctionWithFunctionDefinition3() {\n+    // Don't inline if local names might need to be captured.\n+    testSame(\"function f(){var a; call(function(){return})}f()\");\n   }\n \n   public void testDecomposePlusEquals() {\n          \"void 0\");\n   }\n \n-  public void testFunctionExpressionCallInlining11() {\n-    // Can't inline functions that return inner functions.\n-    testSame(\"((function(){return function(){foo()}})())();\");\n+  public void testFunctionExpressionCallInlining11a() {\n+    // Inline functions that return inner functions.\n+    test(\"((function(){return function(){foo()}})())();\", \"{foo()}\");\n+  }\n+\n+  public void testFunctionExpressionCallInlining11b() {\n+    // Can't inline functions that return inner functions and have local names.\n+    testSame(\"((function(){var a; return function(){foo()}})())();\");\n+  }\n+\n+  public void testFunctionExpressionCallInlining11c() {\n+    // Can't inline functions that return inner functions into non-global scope.\n+    testSame(\"function _x() {\" +\n+    \t\t\"((function(){return function(){foo()}})())();\" +\n+    \t\t\"}\");\n   }\n \n   public void testFunctionExpressionCallInlining12() {\n--- a/test/com/google/javascript/jscomp/NodeUtilTest.java\n+++ b/test/com/google/javascript/jscomp/NodeUtilTest.java\n \n package com.google.javascript.jscomp;\n \n+import com.google.common.base.Predicates;\n import com.google.common.collect.Lists;\n import com.google.common.collect.Sets;\n import com.google.javascript.rhino.Node;\n   }\n \n   public void testContainsFunctionDeclaration() {\n-    assertTrue(NodeUtil.containsFunctionDeclaration(\n+    assertTrue(NodeUtil.containsFunction(\n                    getNode(\"function foo(){}\")));\n-    assertTrue(NodeUtil.containsFunctionDeclaration(\n+    assertTrue(NodeUtil.containsFunction(\n                    getNode(\"(b?function(){}:null)\")));\n \n-    assertFalse(NodeUtil.containsFunctionDeclaration(\n+    assertFalse(NodeUtil.containsFunction(\n                    getNode(\"(b?foo():null)\")));\n-    assertFalse(NodeUtil.containsFunctionDeclaration(\n+    assertFalse(NodeUtil.containsFunction(\n                     getNode(\"foo()\")));\n   }\n \n \n   public void testGetNodeTypeReferenceCount() {\n     assertEquals(0, NodeUtil.getNodeTypeReferenceCount(\n-        parse(\"function foo(){}\"), Token.THIS));\n+        parse(\"function foo(){}\"), Token.THIS, \n+            Predicates.<Node>alwaysTrue()));\n     assertEquals(1, NodeUtil.getNodeTypeReferenceCount(\n-        parse(\"this\"), Token.THIS));\n+        parse(\"this\"), Token.THIS, \n+            Predicates.<Node>alwaysTrue()));\n     assertEquals(2, NodeUtil.getNodeTypeReferenceCount(\n-        parse(\"this;function foo(){}(this)\"), Token.THIS));\n+        parse(\"this;function foo(){}(this)\"), Token.THIS,\n+            Predicates.<Node>alwaysTrue()));\n   }\n \n   public void testIsNameReferenceCount() {\n--- /dev/null\n+++ b/test/com/google/javascript/jscomp/PeepholeOptimizationsPassTest.java\n+/*\n+ * Copyright 2010 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.Sets;\n+import com.google.javascript.rhino.Node;\n+import com.google.javascript.rhino.Token;\n+\n+import java.util.List;\n+import java.util.Set;\n+\n+/**\n+ * Unit tests for PeepholeOptimizationsPass.\n+ * \n+*\n+ */\n+public class PeepholeOptimizationsPassTest extends CompilerTestCase {\n+\n+  private ImmutableSet<AbstractPeepholeOptimization> currentPeepholePasses;\n+\n+  @Override\n+  public void setUp() throws Exception {\n+    super.setUp();\n+    super.enableLineNumberCheck(true);\n+  }\n+\n+  @Override\n+  public CompilerPass getProcessor(final Compiler compiler) {\n+    return new PeepholeOptimizationsPass(compiler, currentPeepholePasses);\n+  }\n+\n+  @Override\n+  protected int getNumRepetitions() {\n+    // Our tests do not require multiple passes to reach a fixed-point.\n+    return 1;\n+  }\n+\n+  /**\n+   * PeepholeOptimizationsPass should handle the case when no peephole\n+   * optimizations are turned on.\n+   */\n+  public void testEmptyPass() {\n+    currentPeepholePasses = ImmutableSet.<AbstractPeepholeOptimization>of();\n+\n+    testSame(\"var x; var y;\");\n+  }\n+\n+  public void testOptimizationOrder() {\n+    /*\n+     * We need to make sure that: 1) We are only traversing the AST once 2) For\n+     * each node, we visit the optimizations in the client-supplied order\n+     * \n+     * To test this, we create two fake optimizations that each make an entry in\n+     * the visitationLog when they are passed a name node to optimize.\n+     * \n+     * Each entry is of the form nameX where 'name' is the name of the name node\n+     * visited and X is the identity of the optimization (1 or 2 in this case).\n+     * After the pass is run, we verify the correct ordering by querying the\n+     * log.\n+     * \n+     * Using a log, rather than, say, transforming nodes, allows us to ensure\n+     * not only that we are visiting each node but that our visits occur in the\n+     * right order (i.e. we need to make sure we're not traversing the entire\n+     * AST for the first optimization and then a second time for the second).\n+     */\n+\n+    final List<String> visitationLog = Lists.newArrayList();\n+\n+    AbstractPeepholeOptimization note1Applied = \n+        new AbstractPeepholeOptimization() {\n+      @Override\n+      public Node optimizeSubtree(Node node) {\n+        if (node.getType() == Token.NAME) {\n+          visitationLog.add(node.getString() + \"1\");\n+        }\n+\n+        return node;\n+      }\n+    };\n+\n+    AbstractPeepholeOptimization note2Applied = \n+        new AbstractPeepholeOptimization() {\n+      @Override\n+      public Node optimizeSubtree(Node node) {\n+        if (node.getType() == Token.NAME) {\n+          visitationLog.add(node.getString() + \"2\");\n+        }\n+\n+        return node;\n+      }\n+    };\n+\n+    currentPeepholePasses =\n+      ImmutableSet.<AbstractPeepholeOptimization>of(note1Applied, note2Applied);\n+    \n+    test(\"var x; var y\", \"var x; var y\");\n+\n+    /*\n+     * We expect the optimization order to be: \"x\" visited by optimization1 \"x\"\n+     * visited by optimization2 \"y\" visited by optimization1 \"y\" visited by\n+     * optimization2\n+     */\n+\n+    assertEquals(4, visitationLog.size());\n+    assertEquals(\"x1\", visitationLog.get(0));\n+    assertEquals(\"x2\", visitationLog.get(1));\n+    assertEquals(\"y1\", visitationLog.get(2));\n+    assertEquals(\"y2\", visitationLog.get(3));\n+  }\n+\n+  /**\n+   * A peephole optimization that, given a subtree consisting of a VAR node,\n+   * removes children of that node named \"x\".\n+   */\n+  private static class RemoveNodesNamedXUnderVarOptimization \n+      extends AbstractPeepholeOptimization {\n+    @Override\n+    public Node optimizeSubtree(Node node) {\n+      if (node.getType() == Token.VAR) {\n+        Set<Node> nodesToRemove = Sets.newHashSet();\n+\n+        for (Node child : node.children()) {\n+          if (\"x\".equals(child.getString())) {\n+            nodesToRemove.add(child);\n+          }\n+        }\n+\n+        for (Node childToRemove : nodesToRemove) {\n+          node.removeChild(childToRemove);\n+          reportCodeChange();\n+        }\n+      }\n+\n+      return node;\n+    }\n+  }\n+\n+  /**\n+   * A peephole optimization that, given a subtree consisting of a name node\n+   * named \"x\" removes that node.\n+   */\n+  private static class RemoveNodesNamedXOptimization \n+      extends AbstractPeepholeOptimization {\n+    @Override\n+    public Node optimizeSubtree(Node node) {\n+      if (node.getType() == Token.NAME && \"x\".equals(node.getString())) {\n+        node.getParent().removeChild(node);\n+        reportCodeChange();\n+\n+        return null;\n+      }\n+\n+      return node;\n+    }\n+  }\n+\n+  /**\n+   * A peephole optimization that, given a subtree consisting of a name node\n+   * named \"x\" whose parent is a VAR node, removes the parent VAR node.\n+   */\n+  private static class RemoveParentVarsForNodesNamedX \n+      extends AbstractPeepholeOptimization {\n+    @Override\n+    public Node optimizeSubtree(Node node) {\n+      if (node.getType() == Token.NAME && \"x\".equals(node.getString())) {\n+        Node parent = node.getParent();\n+        if (parent.getType() == Token.VAR) {\n+          parent.getParent().removeChild(parent);\n+          reportCodeChange();\n+          return null;\n+        }\n+      }\n+      return node;\n+    }\n+  }\n+\n+  /**\n+   * A peephole optimization that, given a subtree consisting of a name node\n+   * named \"y\", replaces it with a name node named \"x\";\n+   */\n+  private static class RenameYToX extends AbstractPeepholeOptimization {\n+    @Override\n+    public Node optimizeSubtree(Node node) {\n+      if (node.getType() == Token.NAME && \"y\".equals(node.getString())) {\n+        Node replacement = Node.newString(Token.NAME, \"x\");\n+\n+        node.getParent().replaceChild(node, replacement);\n+        reportCodeChange();\n+\n+        return replacement;\n+      }\n+      return node;\n+    }\n+  }\n+\n+  public void testOptimizationRemovingSubtreeChild() {\n+    currentPeepholePasses = ImmutableSet.<AbstractPeepholeOptimization>of(new \n+          RemoveNodesNamedXUnderVarOptimization());\n+    \n+    test(\"var x,y;\", \"var y;\");\n+    test(\"var y,x;\", \"var y;\");\n+    test(\"var x,y,x;\", \"var y;\");\n+  }\n+\n+  public void testOptimizationRemovingSubtree() {\n+    currentPeepholePasses = ImmutableSet.<AbstractPeepholeOptimization>of(new \n+          RemoveNodesNamedXOptimization());\n+    \n+    test(\"var x,y;\", \"var y;\");\n+    test(\"var y,x;\", \"var y;\");\n+    test(\"var x,y,x;\", \"var y;\");\n+  }\n+\n+  public void testOptimizationRemovingSubtreeParent() {\n+    currentPeepholePasses = ImmutableSet.<AbstractPeepholeOptimization>of(new \n+          RemoveParentVarsForNodesNamedX());\n+  \n+    test(\"var x; var y\", \"var y\");\n+  }\n+\n+  /**\n+   * Test the case where the first peephole optimization removes a node and the\n+   * second wants to remove (the now nonexistent) parent of that node.\n+   */\n+  public void testOptimizationsRemoveParentAfterRemoveChild() {\n+    currentPeepholePasses = ImmutableSet.<AbstractPeepholeOptimization>of(\n+          new RemoveNodesNamedXOptimization(),\n+          new RemoveParentVarsForNodesNamedX());\n+    \n+    test(\"var x,y; var z;\", \"var y; var z;\");\n+  }\n+\n+  public void testOptimizationReplacingNode() {\n+    currentPeepholePasses = ImmutableSet.<AbstractPeepholeOptimization>of(\n+          new RenameYToX(),\n+          new RemoveParentVarsForNodesNamedX());\n+    \n+    test(\"var y; var z;\", \"var z;\");\n+  }\n+}", "timestamp": 1275163622, "metainfo": ""}