{"sha": "61b5204064333144810c184d38b4dc78f947bd62", "log": "Create a much better integration test for CommandLineRunner.  R=acleung DELTA=188  (118 added, 33 deleted, 37 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=181025   ", "commit": "\n--- a/src/com/google/javascript/jscomp/AbstractCommandLineRunner.java\n+++ b/src/com/google/javascript/jscomp/AbstractCommandLineRunner.java\n import com.google.common.base.Charsets;\n import com.google.common.base.Joiner;\n import com.google.common.base.Preconditions;\n+import com.google.common.base.Receiver;\n+import com.google.common.base.Supplier;\n import com.google.common.collect.ImmutableList;\n import com.google.common.collect.Lists;\n import com.google.common.collect.Maps;\n import java.io.IOException;\n import java.io.OutputStreamWriter;\n import java.io.PrintStream;\n+import java.io.StringWriter;\n import java.io.Writer;\n import java.nio.charset.Charset;\n import java.util.ArrayList;\n \n   private static Charset inputCharset;\n \n+  private boolean testMode = false;\n+  private Supplier<List<JSSourceFile>> externsSupplierForTesting = null;\n+  private Supplier<List<JSSourceFile>> inputsSupplierForTesting = null;\n+  private Supplier<List<JSModule>> modulesSupplierForTesting = null;\n+  private Receiver<Integer> exitCodeReceiverForTesting = null;\n+\n   // Bookkeeping to measure optimal phase orderings.\n   private static final int NUM_RUNS_TO_DETERMINE_OPTIMAL_ORDER = 100;\n \n     this.config = new CommandLineConfig();\n     this.out = out;\n     this.err = err;\n+  }\n+\n+  /**\n+   * Put the command line runner into test mode. In test mode,\n+   * all outputs will be blackholed.\n+   * @param externsSupplier A provider for externs.\n+   * @param inputsSupplier A provider for source inputs.\n+   * @param modulesSupplier A provider for modules. Only one of inputsSupplier\n+   *     and modulesSupplier may be non-null.\n+   * @param exitCodeReceiver A receiver for the status code that would\n+   *     have been passed to System.exit in non-test mode.\n+   */\n+  @VisibleForTesting\n+  void enableTestMode(\n+      Supplier<List<JSSourceFile>> externsSupplier,\n+      Supplier<List<JSSourceFile>> inputsSupplier,\n+      Supplier<List<JSModule>> modulesSupplier,\n+      Receiver<Integer> exitCodeReceiver) {\n+    Preconditions.checkArgument(\n+        inputsSupplier == null ^ modulesSupplier == null);\n+    testMode = true;\n+    this.externsSupplierForTesting = externsSupplier;\n+    this.inputsSupplierForTesting = inputsSupplier;\n+    this.modulesSupplierForTesting = modulesSupplier;\n+    this.exitCodeReceiverForTesting = exitCodeReceiver;\n+  }\n+\n+  /**\n+   * Returns whether we're in test mode.\n+   */\n+  protected boolean isInTestMode() {\n+    return testMode;\n   }\n \n   /**\n       t.printStackTrace();\n       result = -2;\n     }\n+\n     if (config.computePhaseOrdering) {\n       runTimeStats.outputBestPhaseOrdering();\n     }\n-    System.exit(result);\n+\n+    if (testMode) {\n+      exitCodeReceiverForTesting.accept(result);\n+    } else {\n+      System.exit(result);\n+    }\n   }\n \n   /**\n   /**\n    * Creates js source code inputs from a list of files.\n    */\n-  private static List<JSSourceFile> createSourceInputs(List<String> files)\n+  private List<JSSourceFile> createSourceInputs(List<String> files)\n       throws FlagUsageException, IOException {\n+    if (isInTestMode()) {\n+      return inputsSupplierForTesting.get();\n+    }\n     if (files.isEmpty()) {\n       files = Collections.singletonList(\"-\");\n     }\n    * @param jsFiles A list of js file paths, not null\n    * @return An array of module objects\n    */\n-  static JSModule[] createJsModules(List<String> specs, List<String> jsFiles)\n+  List<JSModule> createJsModules(\n+      List<String> specs, List<String> jsFiles)\n       throws FlagUsageException, IOException {\n+    if (isInTestMode()) {\n+      return modulesSupplierForTesting.get();\n+    }\n+\n     Preconditions.checkState(specs != null);\n     Preconditions.checkState(!specs.isEmpty());\n     Preconditions.checkState(jsFiles != null);\n           + nextJsFileIndex + \" but found \" + totalNumJsFiles);\n     }\n \n-    return modulesByName.values().toArray(new JSModule[modulesByName.size()]);\n+    return Lists.newArrayList(modulesByName.values());\n   }\n \n   /**\n    *         will have the empty string as their value in this map.\n    */\n   static Map<String, String> parseModuleWrappers(List<String> specs,\n-      JSModule[] modules) throws FlagUsageException {\n+      List<JSModule> modules) throws FlagUsageException {\n     Preconditions.checkState(specs != null);\n \n     Map<String, String> wrappers =\n-        Maps.newHashMapWithExpectedSize(modules.length);\n+        Maps.newHashMapWithExpectedSize(modules.size());\n \n     // Prepopulate the map with module names.\n     for (JSModule m : modules) {\n   protected int doRun() throws FlagUsageException, IOException {\n     Compiler.setLoggingLevel(Level.parse(config.loggingLevel));\n \n-    List<JSSourceFile> externsList = createExterns();\n-    JSSourceFile[] externs = new JSSourceFile[externsList.size()];\n-    externsList.toArray(externs);\n+    List<JSSourceFile> externs = createExterns();\n \n     compiler = createCompiler();\n     B options = createOptions();\n \n-    JSModule[] modules = null;\n+    List<JSModule> modules = null;\n     Result result;\n \n     setRunOptions(options);\n     List<String> moduleSpecs = config.module;\n     if (!moduleSpecs.isEmpty()) {\n       modules = createJsModules(moduleSpecs, jsFiles);\n-      result = compiler.compile(externs, modules, options);\n+      result = compiler.compileModules(externs, modules, options);\n     } else {\n-      List<JSSourceFile> inputList = createSourceInputs(jsFiles);\n-      JSSourceFile[] inputs = new JSSourceFile[inputList.size()];\n-      inputList.toArray(inputs);\n+      List<JSSourceFile> inputs = createSourceInputs(jsFiles);\n       result = compiler.compile(externs, inputs, options);\n     }\n \n   /**\n    * Processes the results of the compile job, and returns an error code.\n    */\n-  int processResults(Result result, JSModule[] modules, B options)\n+  int processResults(Result result, List<JSModule> modules, B options)\n        throws FlagUsageException, IOException {\n     if (config.computePhaseOrdering) {\n       return 0;\n \n   protected List<JSSourceFile> createExterns() throws FlagUsageException,\n       IOException {\n-    return createExternInputs(config.externs);\n+    return isInTestMode() ? externsSupplierForTesting.get() :\n+        createExternInputs(config.externs);\n   }\n \n   /**\n     if (fileName == null) {\n       return null;\n     }\n+    if (testMode) {\n+      return new StringWriter();\n+    }\n     // Use a FileWriter if the charset translation isn't required.\n     return new BufferedWriter(new FileWriter(fileName));\n   }\n       throws IOException {\n     if (fileName == null) {\n       return null;\n+    }\n+    if (testMode) {\n+      return new StringWriter();\n     }\n     // Use a FileOutputStream for a non-default charset.\n     return new BufferedWriter(\n--- a/src/com/google/javascript/jscomp/CommandLineRunner.java\n+++ b/src/com/google/javascript/jscomp/CommandLineRunner.java\n   protected List<JSSourceFile> createExterns() throws FlagUsageException,\n       IOException {\n     List<JSSourceFile> externs = super.createExterns();\n-    if (!flags.use_only_custom_externs) {\n+    if (flags.use_only_custom_externs || isInTestMode()) {\n+      return externs;\n+    } else {\n       List<JSSourceFile> defaultExterns = getDefaultExterns();\n       defaultExterns.addAll(externs);\n       return defaultExterns;\n-    } else {\n-      return externs;\n     }\n   }\n \n--- a/test/com/google/javascript/jscomp/CommandLineRunnerTest.java\n+++ b/test/com/google/javascript/jscomp/CommandLineRunnerTest.java\n package com.google.javascript.jscomp;\n \n import com.google.common.base.Joiner;\n+import com.google.common.base.Receivers;\n+import com.google.common.base.Supplier;\n+import com.google.common.base.Suppliers;\n import com.google.common.collect.Lists;\n import com.google.javascript.rhino.Node;\n \n import junit.framework.TestCase;\n \n-import java.io.IOException;\n import java.util.List;\n \n /**\n \n   private Compiler lastCompiler = null;\n   private CommandLineRunner lastCommandLineRunner = null;\n+  private List<Integer> exitCodes = null;\n \n   // If set to true, uses comparison by string instead of by AST.\n   private boolean useStringComparison = false;\n   private List<String> args = Lists.newArrayList();\n \n   /** Externs for the test */\n-  private final JSSourceFile[] externs = new JSSourceFile[] {\n+  private final List<JSSourceFile> externs = Lists.newArrayList(\n     JSSourceFile.fromCode(\"externs\",\n-        \"var arguments;\" +\n-        \"/** @constructor \\n * @param {...*} var_args \\n \" +\n-        \"* @return {!Array} */ \" +\n-        \"function Array(var_args) {}\\n\"\n+        \"var arguments;\"\n+        + \"/** @constructor \\n * @param {...*} var_args \\n \"\n+        + \"* @return {!Array} */ \"\n+        + \"function Array(var_args) {}\\n\"\n         + \"/** @constructor */ function Window() {}\\n\"\n         + \"/** @type {string} */ Window.prototype.name;\\n\"\n         + \"/** @type {Window} */ var window;\"\n         + \"/** @nosideeffects */ function noSideEffects() {}\")\n-  };\n+  );\n \n   @Override\n   public void setUp() throws Exception {\n     useStringComparison = false;\n     useModules = ModulePattern.NONE;\n     args.clear();\n+    exitCodes = Lists.newArrayList();\n   }\n \n   @Override\n \n   public void testHelpFlag() {\n     args.add(\"--help\");\n-    testSame(\"function f() {}\");\n+    assertFalse(\n+        createCommandLineRunner(\n+            new String[] {\"function f() {}\"}).shouldRunCompiler());\n   }\n \n   public void testExternsLifting1() throws Exception{\n         \"Errors: \\n\" + Joiner.on(\"\\n\").join(compiler.getErrors()) +\n         \"Warnings: \\n\" + Joiner.on(\"\\n\").join(compiler.getWarnings()),\n         1, compiler.getErrors().length + compiler.getWarnings().length);\n+\n+    assertTrue(exitCodes.size() > 0);\n+    int lastExitCode = exitCodes.get(exitCodes.size() - 1);\n+\n     if (compiler.getErrors().length > 0) {\n       assertEquals(1, compiler.getErrors().length);\n       assertEquals(warning, compiler.getErrors()[0].getType());\n+      assertEquals(1, lastExitCode);\n     } else {\n       assertEquals(1, compiler.getWarnings().length);\n       assertEquals(warning, compiler.getWarnings()[0].getType());\n+      assertEquals(0, lastExitCode);\n     }\n   }\n \n-  private Compiler compile(String[] original) {\n+  private CommandLineRunner createCommandLineRunner(String[] original) {\n     args.add(\"--js_output_file\");\n     args.add(\"/path/to/out.js\");\n \n     }\n \n     String[] argStrings = args.toArray(new String[] {});\n-    CommandLineRunner runner = new CommandLineRunner(argStrings);\n-    Compiler compiler = runner.createCompiler();\n+    return new CommandLineRunner(argStrings);\n+  }\n+\n+  private Compiler compile(String[] original) {\n+    CommandLineRunner runner = createCommandLineRunner(original);\n+    assertTrue(runner.shouldRunCompiler());\n+    Supplier<List<JSSourceFile>> inputsSupplier = null;\n+    Supplier<List<JSModule>> modulesSupplier = null;\n+\n+    if (useModules == ModulePattern.NONE) {\n+      List<JSSourceFile> inputs = Lists.newArrayList();\n+      for (int i = 0; i < original.length; i++) {\n+        inputs.add(JSSourceFile.fromCode(\"input\" + i, original[i]));\n+      }\n+      inputsSupplier = Suppliers.ofInstance(inputs);\n+    } else if (useModules == ModulePattern.STAR) {\n+      modulesSupplier = Suppliers.<List<JSModule>>ofInstance(\n+          Lists.<JSModule>newArrayList(\n+              CompilerTestCase.createModuleStar(original)));\n+    } else if (useModules == ModulePattern.CHAIN) {\n+      modulesSupplier = Suppliers.<List<JSModule>>ofInstance(\n+          Lists.<JSModule>newArrayList(\n+              CompilerTestCase.createModuleChain(original)));\n+    } else {\n+      throw new IllegalArgumentException(\"Unknown module type: \" + useModules);\n+    }\n+\n+    runner.enableTestMode(\n+        Suppliers.<List<JSSourceFile>>ofInstance(externs),\n+        inputsSupplier,\n+        modulesSupplier,\n+        Receivers.<Integer>collect(exitCodes));\n+    runner.run();\n+    lastCompiler = runner.getCompiler();\n     lastCommandLineRunner = runner;\n-    lastCompiler = compiler;\n-    CompilerOptions options = runner.createOptions();\n-    try {\n-      runner.setRunOptions(options);\n-    } catch (AbstractCommandLineRunner.FlagUsageException e) {\n-      fail(\"Unexpected exception \" + e);\n-    } catch (IOException e) {\n-      assert(false);\n-    }\n-    if (useModules != ModulePattern.NONE) {\n-      compiler.compile(\n-          externs,\n-          useModules == ModulePattern.STAR ?\n-              CompilerTestCase.createModuleStar(original) :\n-              CompilerTestCase.createModuleChain(original),\n-          options);\n-    } else {\n-      JSSourceFile[] inputs = new JSSourceFile[original.length];\n-      for (int i = 0; i < original.length; i++) {\n-        inputs[i] = JSSourceFile.fromCode(\"input\" + i, original[i]);\n-      }\n-      compiler.compile(\n-          externs,\n-          inputs,\n-          options);\n-    }\n-    return compiler;\n+    return lastCompiler;\n   }\n \n   private Node parse(String[] original) {\n     String[] argStrings = args.toArray(new String[] {});\n     CommandLineRunner runner = new CommandLineRunner(argStrings);\n     Compiler compiler = runner.createCompiler();\n-    JSSourceFile[] inputs = new JSSourceFile[original.length];\n-    for (int i = 0; i < inputs.length; i++) {\n-      inputs[i] = JSSourceFile.fromCode(\"input\" + i, original[i]);\n+    List<JSSourceFile> inputs = Lists.newArrayList();\n+    for (int i = 0; i < original.length; i++) {\n+      inputs.add(JSSourceFile.fromCode(\"input\" + i, original[i]));\n     }\n     compiler.init(externs, inputs, new CompilerOptions());\n     Node all = compiler.parseInputs();", "timestamp": 1282348002, "metainfo": ""}