{"sha": "dff6e0114f19c20aeb63393d67aa0880ff5745b5", "log": "Change on 2010/06/25 by johnlenz  \tPreserve blocks around problematic labelled statements. \tFixes issue 190  \tR=nicksantos \tDELTA=95  (86 added, 2 deleted, 7 changed)  Change on 2010/06/25 by nicksantos  \tmore descriptive error messaging for CheckReturns.   \tR=acleung \tDELTA=59  (21 added, 2 deleted, 36 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=42001   ", "commit": "\n--- a/src/com/google/javascript/jscomp/CheckMissingReturn.java\n+++ b/src/com/google/javascript/jscomp/CheckMissingReturn.java\n   static final DiagnosticType MISSING_RETURN_STATEMENT =\n       DiagnosticType.warning(\n           \"JSC_MISSING_RETURN_STATEMENT\",\n-          \"missing return statement\");\n+          \"Missing return statement. Function expected to return {0}.\");\n \n   private final AbstractCompiler compiler;\n   private final CheckLevel level;\n \n   @Override\n   public void enterScope(NodeTraversal t) {\n-    if (!explicitReturnExpected(t.getScopeRoot())) {\n+    JSType returnType = explicitReturnExpected(t.getScopeRoot());\n+    if (returnType == null) {\n       return;\n     }\n \n \n     if (!test.allPathsSatisfyPredicate()) {\n       compiler.report(\n-          t.makeError(t.getScopeRoot(), level, MISSING_RETURN_STATEMENT));\n+          t.makeError(t.getScopeRoot(), level,\n+              MISSING_RETURN_STATEMENT, returnType.toString()));\n     }\n   }\n \n   /**\n    * Determines if the given scope should explicitly return. All functions\n    * with non-void or non-unknown return types must have explicit returns.\n+   * @return If a return type is expected, returns it. Otherwise returns null.\n    */\n-  private boolean explicitReturnExpected(Node scope) {\n+  private JSType explicitReturnExpected(Node scope) {\n     JSType scopeType = scope.getJSType();\n \n     if (!(scopeType instanceof FunctionType)) {\n-      return false;\n+      return null;\n     }\n \n     if (isEmptyFunction(scope)) {\n-      return false;\n+      return null;\n     }\n \n     JSType returnType = ((FunctionType) scopeType).getReturnType();\n \n     if (returnType == null) {\n-      return false;\n+      return null;\n     }\n \n-    return !isVoidOrUnknown(returnType);\n+    if (!isVoidOrUnknown(returnType)) {\n+      return returnType;\n+    }\n+\n+    return null;\n   }\n \n \n--- a/src/com/google/javascript/jscomp/CodeGenerator.java\n+++ b/src/com/google/javascript/jscomp/CodeGenerator.java\n \n       case Token.FUNCTION:\n         if (n.getClass() != Node.class) {\n-          throw new Error(\"Unexpected Node subclass.\"); \n-        }        \n+          throw new Error(\"Unexpected Node subclass.\");\n+        }\n         Preconditions.checkState(childCount == 3);\n         boolean funcNeedsParens = (context == Context.START_OF_EXPR);\n         if (funcNeedsParens) {\n       case Token.SCRIPT:\n       case Token.BLOCK: {\n         if (n.getClass() != Node.class) {\n-          throw new Error(\"Unexpected Node subclass.\"); \n+          throw new Error(\"Unexpected Node subclass.\");\n         }\n         boolean stripBlock = n.isSyntheticBlock() ||\n             ((context != Context.PRESERVE_BLOCK) && (n.getChildCount() < 2));\n     // Strip unneeded blocks, that is blocks with <2 children unless\n     // the CodePrinter specifically wants to keep them.\n     if (n.getType() == Token.BLOCK ) {\n-      int count = getNonEmptyChildCount(n);\n+      int count = getNonEmptyChildCount(n, 2);\n       if (count == 0) {\n         if (cc.shouldPreserveExtraBlocks()) {\n           cc.beginBlock();\n         //   IE6/7 needs a block around DOs.\n         Node firstAndOnlyChild = getFirstNonEmptyChild(n);\n         boolean alwaysWrapInBlock = cc.shouldPreserveExtraBlocks();\n-        if (alwaysWrapInBlock ||\n-            firstAndOnlyChild.getType() == Token.FUNCTION ||\n-            firstAndOnlyChild.getType() == Token.DO) {\n+        if (alwaysWrapInBlock || isOneExactlyFunctionOrDo(firstAndOnlyChild)) {\n           cc.beginBlock();\n           add(firstAndOnlyChild, Context.STATEMENT);\n           cc.maybeLineBreak();\n       if (nodeToProcess.getType() == Token.VAR) {\n         cc.endStatement();\n       }\n+    }\n+  }\n+\n+  /**\n+   * @return Whether the Node is a DO or FUNCTION (with or without\n+   * labels).\n+   */\n+  private boolean isOneExactlyFunctionOrDo(Node n) {\n+    if (n.getType() == Token.LABEL) {\n+      Node labeledStatement = n.getLastChild();\n+      if (labeledStatement.getType() != Token.BLOCK) {\n+        return isOneExactlyFunctionOrDo(labeledStatement);\n+      } else {\n+        // For labels with block children, we need to ensure that a\n+        // labeled FUNCTION or DO isn't generated when extraneous BLOCKs \n+        // are skipped. \n+        if (getNonEmptyChildCount(n, 2) == 1) { \n+          return isOneExactlyFunctionOrDo(getFirstNonEmptyChild(n));\n+        } else {\n+          // Either a empty statement or an block with more than one child,\n+          // way it isn't a FUNCTION or DO.\n+          return false;\n+        }\n+      }\n+    } else {\n+      return (n.getType() == Token.FUNCTION || n.getType() == Token.DO);\n     }\n   }\n \n     }\n     return sb.toString();\n   }\n-\n-  /** Gets the number of children of this node that are non empty. */\n-  private static int getNonEmptyChildCount(Node n) {\n+  /**\n+   * @param maxCount The maximum number of children to look for.\n+   * @return The number of children of this node that are non empty up to\n+   * maxCount.\n+   */\n+  private static int getNonEmptyChildCount(Node n, int maxCount) {\n     int i = 0;\n-    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n+    Node c = n.getFirstChild();\n+    for (; c != null && i < maxCount; c = c.getNext()) {\n       if (c.getType() != Token.EMPTY) {\n         i++;\n       }\n--- a/test/com/google/javascript/jscomp/CodePrinterTest.java\n+++ b/test/com/google/javascript/jscomp/CodePrinterTest.java\n \n     // Name functions expression.\n     assertPrint(\"(function f(){})\", \"(function f(){})\");\n-    \n+\n     // Function declaration.\n     assertPrint(\"function f(){}\", \"function f(){}\");\n \n         \"})();\\n\" +\n         \"if(1) {\\n\" +\n         \"  alert()\\n\" +\n-        \"}\\n\");    \n+        \"}\\n\");\n   }\n \n   public void testTypeAnnotations() {\n         \"/**\\n\" +\n         \" * @param {*} x\\n\" +\n         \" * @return {undefined}\\n\" +\n-        \" */\\n\" + \n+        \" */\\n\" +\n         \"var a = function(x) {\\n}\");\n   }\n-  \n+\n   public void testOptionalTypesAnnotation() {\n     assertTypeAnnotations(\n         \"/**\\n\" +\n         \" */\\n\" +\n         \"var a = function(x) {\\n}\");\n   }\n-  \n+\n   public void testVariableArgumentsTypesAnnotation() {\n     assertTypeAnnotations(\n         \"/**\\n\" +\n         \" */\\n\" +\n         \"var a = function(x) {\\n}\");\n   }\n-  \n+\n   public void testTempConstructor() {\n     assertTypeAnnotations(\n         \"var x = function() {\\n/**\\n * @constructor\\n */\\nfunction t1() {}\\n\" +\n     testReparse(\"'foo\\\"bar' + \\\"foo'c\\\" + 'stuff\\\\n and \\\\\\\\more'\");\n     testReparse(\"x.__proto__;\");\n   }\n-  \n+\n   private void testReparse(String code) {\n     Node parse1 = parse(code);\n     Node parse2 = parse(new CodePrinter.Builder(parse1).build());\n \n     assertPrint(\"if(x)do{foo()}while(y);else bar()\",\n         \"if(x){do foo();while(y)}else bar()\");\n+\n+    assertPrint(\"if(x){do{foo()}while(y)}\",\n+        \"if(x){do foo();while(y)}\");\n+\n+    assertPrint(\"if(x)do{foo()}while(y);\",\n+        \"if(x){do foo();while(y)}\");\n+\n+    assertPrint(\"if(x)A:do{foo()}while(y);\",\n+        \"if(x){A:do foo();while(y)}\");\n+    \n+    assertPrint(\"var i = 0;a: do{b: do{i++;break b;} while(0);} while(0);\",\n+        \"var i=0;a:do{b:do{i++;break b}while(0)}while(0)\");\n   }\n \n   public void testFunctionSafariCompatiblity() {\n-    // Do loops within IFs cause syntax errors in IE6 and IE7.\n+    // Functions within IFs cause syntax errors on Safari.\n     assertPrint(\"function(){if(e1){function goo(){return true}}else foo()}\",\n         \"function(){if(e1){function goo(){return true}}else foo()}\");\n \n \n     assertPrint(\"if(e1)function goo(){return true}\",\n         \"if(e1){function goo(){return true}}\");\n+\n+    assertPrint(\"if(e1)A:function goo(){return true}\",\n+        \"if(e1){A:function goo(){return true}}\");\n   }\n \n   public void testExponents() {", "timestamp": 1277510212, "metainfo": ""}