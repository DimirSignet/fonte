{"sha": "7044f1ca2265b1a4855cc683726151ef8a65be9d", "log": "Remove invokeExactMethod. Going to consolidate on one inokeMethod that considers superclasses and doesn't break scope rules.   ", "commit": "\n--- a/src/java/org/apache/commons/lang/reflect/MethodUtils.java\n+++ b/src/java/org/apache/commons/lang/reflect/MethodUtils.java\n  * @author Gregor Raman\n  * @author Jan Sorensen\n  * @author Robert Burrell Donkin\n- * @version $Id: MethodUtils.java,v 1.2 2002/11/14 18:51:57 rdonkin Exp $\n+ * @version $Id: MethodUtils.java,v 1.3 2002/11/18 22:18:44 rdonkin Exp $\n  */\n public class MethodUtils {\n     \n     /**\n      * <p>Invoke a named method whose parameter type matches the object type.</p>\n      *\n-     * <p>The behaviour of this method is less deterministic \n-     * than {@link #invokeExactMethod}. \n-     * It loops through all methods with names that match\n-     * and then executes the first it finds with compatable parameters.</p>\n-     *\n      * <p>This method supports calls to methods taking primitive parameters \n      * via passing in wrapping classes. So, for example, a <code>Boolean</code> class\n      * would match a <code>boolean</code> primitive.</p>\n \n     /**\n      * <p>Invoke a named method whose parameter type matches the object type.</p>\n-     *\n-     * <p>The behaviour of this method is less deterministic \n-     * than {@link #invokeExactMethod(Object object,String methodName,Object [] args)}. \n-     * It loops through all methods with names that match\n-     * and then executes the first it finds with compatable parameters.</p>\n      *\n      * <p>This method supports calls to methods taking primitive parameters \n      * via passing in wrapping classes. So, for example, a <code>Boolean</code> class\n \n     /**\n      * <p>Invoke a named method whose parameter type matches the object type.</p>\n-     *\n-     * <p>The behaviour of this method is less deterministic \n-     * than {@link \n-     * #invokeExactMethod(Object object,String methodName,Object [] args,Class[] parameterTypes)}. \n-     * It loops through all methods with names that match\n-     * and then executes the first it finds with compatable parameters.</p>\n      *\n      * <p>This method supports calls to methods taking primitive parameters \n      * via passing in wrapping classes. So, for example, a <code>Boolean</code> class\n             args = ArrayUtils.EMPTY_OBJECT_ARRAY;\n         }  \n \n-//return null;\n         Method method = getMatchingAccessibleMethod(\n                 object.getClass(),\n                 methodName,\n                     methodName + \"() on object: \" + object.getClass().getName());\n         return method.invoke(object, args);\n     }\n-\n-\n-    /**\n-     * <p>Invoke a method whose parameter type matches exactly the object\n-     * type.</p>\n-     *\n-     * <p> This is a convenient wrapper for\n-     * {@link #invokeExactMethod(Object object,String methodName,Object [] args)}.\n-     * </p>\n-     *\n-     * @param object invoke method on this object\n-     * @param methodName get method with this name\n-     * @param arg use this argument\n-     *\n-     * @throws NoSuchMethodException if there is no such accessible method\n-     * @throws InvocationTargetException wraps an exception thrown by the\n-     *  method invoked\n-     * @throws IllegalAccessException if the requested method is not accessible\n-     *  via reflection\n-     */\n-    public static Object invokeExactMethod(\n-            Object object,\n-            String methodName,\n-            Object arg)\n-            throws\n-            NoSuchMethodException,\n-            IllegalAccessException,\n-            InvocationTargetException {\n-\n-        Object[] args = {arg};\n-        return invokeExactMethod(object, methodName, args);\n-\n-    }\n-\n-\n-    /**\n-     * <p>Invoke a method whose parameter types match exactly the object\n-     * types.</p>\n-     *\n-     * <p> This uses reflection to invoke the method obtained from a call to\n-     * {@link #getAccessibleMethod}.</p>\n-     *\n-     * @param object invoke method on this object\n-     * @param methodName get method with this name\n-     * @param args use these arguments - treat null as empty array\n-     *\n-     * @throws NoSuchMethodException if there is no such accessible method\n-     * @throws InvocationTargetException wraps an exception thrown by the\n-     *  method invoked\n-     * @throws IllegalAccessException if the requested method is not accessible\n-     *  via reflection\n-     */\n-    public static Object invokeExactMethod(\n-            Object object,\n-            String methodName,\n-            Object[] args)\n-            throws\n-            NoSuchMethodException,\n-            IllegalAccessException,\n-            InvocationTargetException {\n-        if (args == null) {\n-            args = ArrayUtils.EMPTY_OBJECT_ARRAY;\n-        }  \n-        int arguments = args.length;\n-        Class parameterTypes [] = new Class[arguments];\n-        for (int i = 0; i < arguments; i++) {\n-            parameterTypes[i] = args[i].getClass();\n-        }\n-        return invokeExactMethod(object, methodName, args, parameterTypes);\n-\n-    }\n-\n-\n-    /**\n-     * <p>Invoke a method whose parameter types match exactly the parameter\n-     * types given.</p>\n-     *\n-     * <p>This uses reflection to invoke the method obtained from a call to\n-     * {@link #getAccessibleMethod}.</p>\n-     *\n-     * @param object invoke method on this object\n-     * @param methodName get method with this name\n-     * @param args use these arguments - treat null as empty array\n-     * @param parameterTypes match these parameters - treat null as empty array\n-     *\n-     * @throws NoSuchMethodException if there is no such accessible method\n-     * @throws InvocationTargetException wraps an exception thrown by the\n-     *  method invoked\n-     * @throws IllegalAccessException if the requested method is not accessible\n-     *  via reflection\n-     */\n-    public static Object invokeExactMethod(\n-            Object object,\n-            String methodName,\n-            Object[] args,\n-            Class[] parameterTypes)\n-            throws\n-            NoSuchMethodException,\n-            IllegalAccessException,\n-            InvocationTargetException {\n-        \n-        if (args == null) {\n-            args = ArrayUtils.EMPTY_OBJECT_ARRAY;\n-        }  \n-                \n-        if (parameterTypes == null) {\n-            parameterTypes = ArrayUtils.EMPTY_CLASS_ARRAY;\n-        }\n-\n-        Method method = getAccessibleMethod(\n-                object.getClass(),\n-                methodName,\n-                parameterTypes);\n-        if (method == null)\n-            throw new NoSuchMethodException(\"No such accessible method: \" +\n-                    methodName + \"() on object: \" + object.getClass().getName());\n-        return method.invoke(object, args);\n-\n-    }\n-\n \n     /**\n      * <p>Return an accessible method (that is, one that can be invoked via\n--- a/src/test/org/apache/commons/lang/reflect/MethodUtilsTestCase.java\n+++ b/src/test/org/apache/commons/lang/reflect/MethodUtilsTestCase.java\n \n \n     /**\n-     * <p> Test <code>invokeExactMethod</code>.\n-     */\n-    public void testInvokeExactMethod() {\n-        // test MethodUtils.invokeExactMethod\n+     * <p> Test <code>invokeMethod</code>.\n+     */\n+    public void testinvokeMethod2() {\n+        // test MethodUtils.invokeMethod\n         // easy bit first - invoke a public method\n         // METHOD ONE\n         try {\n \n             TestBean bean = new TestBean();\n-            Object ret = MethodUtils.invokeExactMethod(bean, \"setStringProperty\", \"TEST\");\n+            Object ret = MethodUtils.invokeMethod(bean, \"setStringProperty\", \"TEST\");\n             // check that the return's right and that the properties been set\n             assertNull(ret);\n             assertEquals(\"Method ONE was invoked\", \"TEST\", bean.getStringProperty());\n         // METHOD TWO FAILURE\n         try {\n \n-            Object ret = MethodUtils.invokeExactMethod(\n+            Object ret = MethodUtils.invokeMethod(\n                     privateBeanFactory.create(),\n                     \"methodBar\",\n                     \"ANOTHER TEST\");\n         // METHOD THREE\n         try {\n \n-            Object ret = MethodUtils.invokeExactMethod(\n+            Object ret = MethodUtils.invokeMethod(\n                     privateBeanFactory.createSubclass(),\n                     \"methodBaz\",\n                     \"YET ANOTHER TEST\");\n         \n         MethodUtils.invokeMethod(parent, \"getName\", null);\n         MethodUtils.invokeMethod(parent, \"getName\", null, null);\n-        MethodUtils.invokeExactMethod(parent, \"getName\", null);\n-        MethodUtils.invokeExactMethod(parent, \"getName\", null, null);        \n+        MethodUtils.invokeMethod(parent, \"getName\", null);\n+        MethodUtils.invokeMethod(parent, \"getName\", null, null);        \n     }\n \n     \n \n \n     /**\n-     * Simple tests for accessing static methods via invokeExactMethod().\n+     * Simple tests for accessing static methods via invokeMethod().\n      */\n     public void testSimpleStatic2() {\n \n         try {\n \n             // Return initial value of the counter\n-            value = MethodUtils.invokeExactMethod\n+            value = MethodUtils.invokeMethod\n                 (bean, \"currentCounter\", new Object[0], new Class[0]);\n             assertNotNull(\"currentCounter exists\", value);\n             assertTrue(\"currentCounter type\",\n                          ((Integer) value).intValue());\n \n             // Increment via no-arguments version\n-            MethodUtils.invokeExactMethod\n+            MethodUtils.invokeMethod\n                 (bean, \"incrementCounter\", new Object[0], new Class[0]);\n \n             // Validate updated value\n             current++;\n-            value = MethodUtils.invokeExactMethod\n+            value = MethodUtils.invokeMethod\n                 (bean, \"currentCounter\", new Object[0], new Class[0]);\n             assertNotNull(\"currentCounter exists\", value);\n             assertTrue(\"currentCounter type\",\n                          ((Integer) value).intValue());\n \n             // Increment via specified-argument version\n-            MethodUtils.invokeExactMethod\n+            MethodUtils.invokeMethod\n                 (bean, \"incrementCounter\",\n                  new Object[] { new Integer(5) },\n                  new Class[] { Integer.TYPE });\n \n             // Validate updated value\n             current += 5;\n-            value = MethodUtils.invokeExactMethod\n+            value = MethodUtils.invokeMethod\n                 (bean, \"currentCounter\", new Object[0], new Class[0]);\n             assertNotNull(\"currentCounter exists\", value);\n             assertTrue(\"currentCounter type\",", "timestamp": 1037657924, "metainfo": ""}