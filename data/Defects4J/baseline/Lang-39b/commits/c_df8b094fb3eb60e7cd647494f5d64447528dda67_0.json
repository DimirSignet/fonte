{"sha": "df8b094fb3eb60e7cd647494f5d64447528dda67", "log": "Finally applying Chas Emerick's improved getLevenshtein implementation  ", "commit": "\n--- a/src/java/org/apache/commons/lang/StringUtils.java\n+++ b/src/java/org/apache/commons/lang/StringUtils.java\n      * another, where each change is a single character modification (deletion,\n      * insertion or substitution).</p>\n      *\n-     * <p>This implementation of the Levenshtein distance algorithm\n-     * is from <a href=\"http://www.merriampark.com/ld.htm\">http://www.merriampark.com/ld.htm</a></p>\n+     * <p>The previous implementation of the Levenshtein distance algorithm\n+     * was from <a href=\"http://www.merriampark.com/ld.htm\">http://www.merriampark.com/ld.htm</a></p>\n+     *\n+     * <p>Chas Emerick has written an implementation in Java, which avoids an OutOfMemoryError\n+     * which can occur when my Java implementation is used with very large strings.<br>\n+     * This implementation of the Levenshtein distance algorithm\n+     * is from <a href=\"http://www.merriampark.com/ldjava.htm\">http://www.merriampark.com/ldjava.htm</a></p>\n      *\n      * <pre>\n      * StringUtils.getLevenshteinDistance(null, *)             = IllegalArgumentException\n         if (s == null || t == null) {\n             throw new IllegalArgumentException(\"Strings must not be null\");\n         }\n-        int d[][]; // matrix\n-        int n; // length of s\n-        int m; // length of t\n+\n+        /*\n+           The difference between this impl. and the previous is that, rather \n+           than creating and retaining a matrix of size s.length()+1 by t.length()+1, \n+           we maintain two single-dimensional arrays of length s.length()+1.  The first, d,\n+           is the 'current working' distance array that maintains the newest distance cost\n+           counts as we iterate through the characters of String s.  Each time we increment\n+           the index of String t we are comparing, d is copied to p, the second int[].  Doing so\n+           allows us to retain the previous cost counts as required by the algorithm (taking \n+           the minimum of the cost count to the left, up one, and diagonally up and to the left\n+           of the current cost count being calculated).  (Note that the arrays aren't really \n+           copied anymore, just switched...this is clearly much better than cloning an array \n+           or doing a System.arraycopy() each time  through the outer loop.)\n+\n+           Effectively, the difference between the two implementations is this one does not \n+           cause an out of memory condition when calculating the LD over two very large strings.\n+         */\n+\n+        int n = s.length(); // length of s\n+        int m = t.length(); // length of t\n+\n+        if (n == 0) {\n+            return m;\n+        } else if (m == 0) {\n+            return n;\n+        }\n+\n+        int p[] = new int[n+1]; //'previous' cost array, horizontally\n+        int d[] = new int[n+1]; // cost array, horizontally\n+        int _d[]; //placeholder to assist in swapping p and d\n+\n+        // indexes into strings s and t\n         int i; // iterates through s\n         int j; // iterates through t\n-        char s_i; // ith character of s\n+\n         char t_j; // jth character of t\n+\n         int cost; // cost\n \n-        // Step 1\n-        n = s.length();\n-        m = t.length();\n-        if (n == 0) {\n-            return m;\n-        }\n-        if (m == 0) {\n-            return n;\n-        }\n-        d = new int[n + 1][m + 1];\n-\n-        // Step 2\n-        for (i = 0; i <= n; i++) {\n-            d[i][0] = i;\n-        }\n-\n-        for (j = 0; j <= m; j++) {\n-            d[0][j] = j;\n-        }\n-\n-        // Step 3\n-        for (i = 1; i <= n; i++) {\n-            s_i = s.charAt(i - 1);\n-\n-            // Step 4\n-            for (j = 1; j <= m; j++) {\n-                t_j = t.charAt(j - 1);\n-\n-                // Step 5\n-                if (s_i == t_j) {\n-                    cost = 0;\n-                } else {\n-                    cost = 1;\n-                }\n-\n-                // Step 6\n-                d[i][j] = min(d[i - 1][j] + 1, d[i][j - 1] + 1, d[i - 1][j - 1] + cost);\n-            }\n-        }\n-\n-        // Step 7\n-        return d[n][m];\n+        for (i = 0; i<=n; i++) {\n+            p[i] = i;\n+        }\n+\n+        for (j = 1; j<=m; j++) {\n+            t_j = t.charAt(j-1);\n+            d[0] = j;\n+\n+            for (i=1; i<=n; i++) {\n+                cost = s.charAt(i-1)==t_j ? 0 : 1;\n+                // minimum of cell to the left+1, to the top+1, diagonally left and up +cost\n+                d[i] = Math.min(Math.min(d[i-1]+1, p[i]+1),  p[i-1]+cost);  \n+            }\n+\n+            // copy current distance counts to 'previous row' distance counts\n+            _d = p;\n+            p = d;\n+            d = _d;\n+        }\n+\n+        // our last action in the above loop was to switch d and p, so p now \n+        // actually has the most recent cost counts\n+        return p[n];\n     }\n \n     /**\n      * @param c  value 3\n      * @return  the smallest of the values\n      */\n+/*\n     private static int min(int a, int b, int c) {\n         // Method copied from NumberUtils to avoid dependency on subpackage\n         if (b < a) {\n         }\n         return a;\n     }\n+*/\n \n }", "timestamp": 1142316567, "metainfo": ""}