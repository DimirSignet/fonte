{"sha": "bf7d900840f36dbd06253489d7670349e94a8def", "log": "Integrate and tweak http://issues.apache.org/bugzilla/show_bug.cgi?id=35588. Next: Try and replace VariableFormatter.Token with java.text.FieldPosition.  ", "commit": "\n--- a/src/java/org/apache/commons/lang/text/VariableFormatter.java\n+++ b/src/java/org/apache/commons/lang/text/VariableFormatter.java\n \n import java.util.ArrayList;\n import java.util.Iterator;\n+import java.util.LinkedList;\n import java.util.List;\n import java.util.Map;\n \n-import org.apache.commons.lang.StringUtils;\n-\n /**\n- * Candidate class to replace Interpolation and MappedMessageFormat?\n- * \n- * <p>\n- * A class for variable interpolation (substitution).\n- * </p>\n- * <p>\n- * This class can be given a text which can contain an arbitrary number of variables. It will then try to replace all\n- * variables by their current values, which are obtained from a map. A variable per default is specified using the\n- * typical notation &quot; <code>${&lt;varname&gt;}</code> &quot;. However by calling the\n- * <code>setVariablePrefix()</code> and <code>setVariableSuffix()</code> methods it is possible to use a different\n- * prefix or suffix.\n+ * <p>\n+ * Replaces variables in text with other text.\n+ * </p>\n+ * <p>\n+ * This class can be given a text which can contain an arbitrary number of variables. The default notation for a\n+ * variable in text is <code>${variableName}</code>. However by calling the <code>setVariablePrefix()</code> and\n+ * <code>setVariableSuffix()</code> methods it is possible to use a different prefix or suffix. Variable values are\n+ * resolved from a map.\n+ * </p>\n+ * <p>\n+ * The simplest example is to use this class to replace Java System properties. For example:\n+ * \n+ * <pre>\n+ * VariableFormatter.replaceSystemProperties(\n+ *      \"You are running with java.version = ${java.version} and os.name = ${os.name}.\");\n+ * </pre>\n+ * \n  * </p>\n  * <p>\n  * Typical usage of this class follows the following pattern: First an instance is created and initialized with the map\n  * their values are known) will be resolved. The following example demonstrates this:\n  * </p>\n  * <p>\n- * <code><pre>\n+ * \n+ * <pre>\n  * Map valuesMap = HashMap();\n  * valuesMap.put(&quot;animal&quot;, &quot;quick brown fox&quot;);\n  * valuesMap.put(&quot;target&quot;, &quot;lazy dog&quot;);\n  * String templateString = &quot;The ${animal} jumped over the ${target}.&quot;;\n  * VariableFormat vf = new VariableVormat(valuesMap);\n  * String resolvedString = cf.replace(templateString);\n- * </pre></code> yielding: <code><pre>\n- *    The quick brown fox jumped over the lazy dog.\n- * </pre></code>\n+ * </pre>\n+ * \n+ * yielding:\n+ * \n+ * <pre>\n+ *      The quick brown fox jumped over the lazy dog.\n+ * </pre>\n+ * \n  * </p>\n  * <p>\n  * In addition to this usage pattern there are some static convenience methods that cover the most common use cases.\n  * To achieve this effect there are two possibilities: Either set a different prefix and suffix for variables which do\n  * not conflict with the result text you want to produce. The other possibility is to use the escape character that can\n  * be set through the <code>setEscapeCharacter()</code> method. If this character is placed before a variable\n- * reference, this reference is ignored and won't be replaced. It can also be placed before a variable suffix, then this\n- * suffix will be ignored, too. Per default the escape character is set to the <code>$</code> character, so that in\n- * the example above the text could have run:\n- * </p>\n- * <p>\n- * <code>The variable $${${name$}} must be used.</code>\n+ * reference, this reference is ignored and won't be replaced. Per default the escape character is set to the\n+ * <code>$</code> character, so that in the example above the text could have run:\n+ * </p>\n+ * <p>\n+ * <code>The variable $${${name}} must be used.</code>\n  * </p>\n  * \n  * \n          */\n         public void setMap(Map map) {\n             this.map = map;\n+        }\n+    }\n+\n+    /**\n+     * A simple class representing a token detected by the <code>VariableParser</code> class.\n+     */\n+    protected static class Token {\n+        /** Constant for the token type ESCAPED_VAR. */\n+        static final short ESCAPED_VAR_TOKEN = 3;\n+\n+        /** Constant for the token type TEXT. */\n+        static final short TEXT_TOKEN = 1;\n+\n+        /** Constant for the token type VARIABLE. */\n+        static final short VARIABLE_TOKEN = 2;\n+\n+        /**\n+         * Creates a new variable token.\n+         * \n+         * @param aStartIndex\n+         *            The token starting index\n+         * @param aLength\n+         *            The token length\n+         * @return a new token\n+         */\n+        public static Token newEscapedVariableToken(int aStartIndex, int aLength) {\n+            return new Token(ESCAPED_VAR_TOKEN, aStartIndex, aLength);\n+        }\n+\n+        /**\n+         * Creates a new variable token.\n+         * \n+         * @param aStartIndex\n+         *            The token starting index\n+         * @param aLength\n+         *            The token length\n+         * @return a new token\n+         */\n+        public static Token newTextToken(int aStartIndex, int aLength) {\n+            return new Token(TEXT_TOKEN, aStartIndex, aLength);\n+        }\n+\n+        /**\n+         * Creates a new variable token.\n+         * \n+         * @param aStartIndex\n+         *            The token starting index\n+         * @param aLength\n+         *            The token length\n+         * @return a new token\n+         */\n+        public static Token newVariableToken(int aStartIndex, int aLength) {\n+            return new Token(VARIABLE_TOKEN, aStartIndex, aLength);\n+        }\n+\n+        /** Stores the length of this token in characters. */\n+        private int length;\n+\n+        /** Stores the token's start position in the source text. */\n+        private int startIndex;\n+\n+        /** Stores the token type. */\n+        private short type;\n+\n+        /**\n+         * Creates a new token.\n+         * \n+         * @param aType\n+         *            The token type\n+         * @param aStartIndex\n+         *            The token starting index\n+         * @param aLength\n+         *            The token length\n+         */\n+        public Token(short aType, int aStartIndex, int aLength) {\n+            this.setType(aType);\n+            this.setStartIndex(aStartIndex);\n+            this.setLength(aLength);\n+        }\n+\n+        /**\n+         * Returns the token's length.\n+         * \n+         * @return the length of this token in characters\n+         */\n+        public int getLength() {\n+            return this.length;\n+        }\n+\n+        /**\n+         * Returns the token's start index.\n+         * \n+         * @return this token's start index in the source data\n+         */\n+        public int getStartIndex() {\n+            return this.startIndex;\n+        }\n+\n+        /**\n+         * Returns the text for this token from the passed in source array.\n+         * \n+         * @param data\n+         *            the array with the source data\n+         * @return the text for this token\n+         */\n+        public String getText(char[] data) {\n+            return new String(data, getStartIndex(), getLength());\n+        }\n+\n+        /**\n+         * Returns this token's type.\n+         * \n+         * @return the type of this token\n+         */\n+        public short getType() {\n+            return this.type;\n+        }\n+\n+        /**\n+         * @param length\n+         *            The length to set.\n+         */\n+        private void setLength(int length) {\n+            this.length = length;\n+        }\n+\n+        /**\n+         * @param startIndex\n+         *            The startIndex to set.\n+         */\n+        private void setStartIndex(int startIndex) {\n+            this.startIndex = startIndex;\n+        }\n+\n+        /**\n+         * @param type\n+         *            The type to set.\n+         */\n+        private void setType(short type) {\n+            this.type = type;\n+        }\n+    }\n+\n+    /**\n+     * A helper class for detecting variables in the source text. This class provides simple tokenizer functionality. It\n+     * splits input text into tokens for text, variables, and escaped variable start tokens.\n+     */\n+    protected static class VariableParser {\n+        /** Stores the end index. */\n+        private int endIndex;\n+\n+        /** Stores the matcher for escaped variable start tokens. */\n+        private StrTokenizer.Matcher escVarMatcher;\n+\n+        /** Stores the length of the data. */\n+        private int length;\n+\n+        /** Stores the current position. */\n+        private int pos;\n+\n+        /** Stores a list with the pending tokens. */\n+        private LinkedList tokenList;\n+\n+        /** Stores the matcher for variable end tokens. */\n+        private StrTokenizer.Matcher varEndMatcher;\n+\n+        /** Stores the matcher for variable start tokens. */\n+        private StrTokenizer.Matcher varStartMatcher;\n+\n+        /**\n+         * Creates a new instance of <code>VariableParser</code> and initializes it.\n+         * \n+         * @param startMatcher\n+         *            the variable start matcher\n+         * @param endMatcher\n+         *            the variable end matcher\n+         * @param escMatcher\n+         *            the escaped variable start matcher\n+         * @param startPos\n+         *            the start index in the source data\n+         * @param length\n+         *            the length of the source data\n+         */\n+        public VariableParser(StrTokenizer.Matcher startMatcher, StrTokenizer.Matcher endMatcher,\n+                StrTokenizer.Matcher escMatcher, int startPos, int length) {\n+            this.setVarStartMatcher(startMatcher);\n+            this.setVarEndMatcher(endMatcher);\n+            this.setEscVarMatcher(escMatcher);\n+            this.setPos(startPos);\n+            this.setLength(length);\n+            this.setEndIndex(startPos + length);\n+            this.setTokenList(new LinkedList());\n+        }\n+\n+        /**\n+         * Checks if there is a text token before the current position.\n+         * \n+         * @param startPos\n+         *            the start pos for the current <code>nextToken()</code> invocation\n+         */\n+        private void checkTextToken(int startPos) {\n+            if (startPos < getPos()) {\n+                getTokenList().addLast(Token.newTextToken(startPos, getPos() - startPos));\n+            }\n+        }\n+\n+        /**\n+         * @return Returns the endIndex.\n+         */\n+        private int getEndIndex() {\n+            return this.endIndex;\n+        }\n+\n+        /**\n+         * @return Returns the escVarMatcher.\n+         */\n+        private StrTokenizer.Matcher getEscVarMatcher() {\n+            return this.escVarMatcher;\n+        }\n+\n+        /**\n+         * @return Returns the length.\n+         */\n+        private int getLength() {\n+            return this.length;\n+        }\n+\n+        /**\n+         * @return Returns the pos.\n+         */\n+        private int getPos() {\n+            return this.pos;\n+        }\n+\n+        /**\n+         * @return Returns the tokenList.\n+         */\n+        private LinkedList getTokenList() {\n+            return this.tokenList;\n+        }\n+\n+        /**\n+         * @return Returns the varEndMatcher.\n+         */\n+        private StrTokenizer.Matcher getVarEndMatcher() {\n+            return this.varEndMatcher;\n+        }\n+\n+        /**\n+         * @return Returns the varStartMatcher.\n+         */\n+        private StrTokenizer.Matcher getVarStartMatcher() {\n+            return this.varStartMatcher;\n+        }\n+\n+        /**\n+         * Checks if the end of the source data has been reached.\n+         * \n+         * @return a flag whether the end was reached\n+         */\n+        private boolean isEnd() {\n+            return getPos() >= getEndIndex();\n+        }\n+\n+        /**\n+         * Returns the next token in the given data.\n+         * \n+         * @param data\n+         *            the array with the source data\n+         * @return the next token or <b>null</b> if the end is reached\n+         */\n+        public Token nextToken(char[] data) {\n+            if (getTokenList().isEmpty()) {\n+                if (isEnd()) {\n+                    // end of data is reached\n+                    return null;\n+                }\n+                int startPos = getPos();\n+                int tokenLen;\n+                while (!isEnd() && getTokenList().isEmpty()) {\n+                    if ((tokenLen = getEscVarMatcher().isMatch(data, getLength(), getPos())) > 0) {\n+                        checkTextToken(startPos);\n+                        getTokenList().addLast(Token.newEscapedVariableToken(getPos(), tokenLen));\n+                        setPos(getPos() + tokenLen);\n+                    } else if ((tokenLen = getVarStartMatcher().isMatch(data, getLength(), getPos())) > 0) {\n+                        checkTextToken(startPos);\n+                        setPos(getPos() + tokenLen);\n+                        int varStart = getPos(), endLen = 0;\n+                        while (!isEnd() && (endLen = getVarEndMatcher().isMatch(data, getLength(), getPos())) <= 0) {\n+                            setPos(getPos() + 1);\n+                        }\n+                        if (endLen <= 0) {\n+                            checkTextToken(varStart - tokenLen);\n+                        } else {\n+                            getTokenList().addLast(Token.newVariableToken(varStart, getPos() - varStart));\n+                            setPos(getPos() + endLen);\n+                        }\n+                    } else {\n+                        setPos(getPos() + 1);\n+                    }\n+                }\n+                if (getTokenList().isEmpty()) {\n+                    checkTextToken(startPos);\n+                }\n+            }\n+            return (Token) getTokenList().removeFirst();\n+        }\n+\n+        /**\n+         * @param endIndex\n+         *            The endIndex to set.\n+         */\n+        private void setEndIndex(int endIndex) {\n+            this.endIndex = endIndex;\n+        }\n+\n+        /**\n+         * @param escVarMatcher\n+         *            The escVarMatcher to set.\n+         */\n+        private void setEscVarMatcher(StrTokenizer.Matcher escVarMatcher) {\n+            this.escVarMatcher = escVarMatcher;\n+        }\n+\n+        /**\n+         * @param length\n+         *            The length to set.\n+         */\n+        private void setLength(int length) {\n+            this.length = length;\n+        }\n+\n+        /**\n+         * @param pos\n+         *            The pos to set.\n+         */\n+        private void setPos(int pos) {\n+            this.pos = pos;\n+        }\n+\n+        /**\n+         * @param tokenList\n+         *            The tokenList to set.\n+         */\n+        private void setTokenList(LinkedList tokenList) {\n+            this.tokenList = tokenList;\n+        }\n+\n+        /**\n+         * @param varEndMatcher\n+         *            The varEndMatcher to set.\n+         */\n+        private void setVarEndMatcher(StrTokenizer.Matcher varEndMatcher) {\n+            this.varEndMatcher = varEndMatcher;\n+        }\n+\n+        /**\n+         * @param varStartMatcher\n+         *            The varStartMatcher to set.\n+         */\n+        private void setVarStartMatcher(StrTokenizer.Matcher varStartMatcher) {\n+            this.varStartMatcher = varStartMatcher;\n         }\n     }\n \n     private String variableSuffix;\n \n     /**\n+     * Creates a new instance with defaults for variable prefix and suffix and the escaping character.\n+     */\n+    public VariableFormatter() {\n+        this((VariableResolver) null, DEFAULT_PREFIX, DEFAULT_SUFFIX, DEFAULT_ESCAPE);\n+    }\n+\n+    /**\n      * Creates a new instance and initializes it. Uses defaults for variable prefix and suffix and the escaping\n      * character.\n      * \n      */\n     public VariableFormatter(Map valueMap) {\n         this(valueMap, DEFAULT_PREFIX, DEFAULT_SUFFIX, DEFAULT_ESCAPE);\n-    }\n-\n-    /**\n-     * Creates a new instance with defaults for variable prefix and suffix and the escaping character.\n-     */\n-    public VariableFormatter() {\n-        this((VariableResolver) null, DEFAULT_PREFIX, DEFAULT_SUFFIX, DEFAULT_ESCAPE);\n     }\n \n     /**\n     }\n \n     /**\n-     * Recursive handler for multple levels of interpolation. This is the main interpolation method, which resolves the\n+     * Creates a parser object for tokenizing the input data.\n+     * \n+     * @param data\n+     *            the input data\n+     * @param offset\n+     *            the offset in the source array\n+     * @param length\n+     *            the length of the data to be processed\n+     * @return the parser\n+     */\n+    protected VariableParser createParser(char[] data, int offset, int length) {\n+        return new VariableParser(new StrTokenizer.StringMatcher(getVariablePrefix()), new StrTokenizer.StringMatcher(\n+                getVariableSuffix()), new StrTokenizer.StringMatcher(String.valueOf(getEscapeCharacter())\n+            + getVariablePrefix()), offset, length);\n+    }\n+\n+    /**\n+     * Recursive handler for multiple levels of interpolation. This is the main interpolation method, which resolves the\n      * values of all variable references contained in the passed in text.\n      * \n-     * @param obj\n-     *            the text to be interpolated (as object)\n+     * @param data\n+     *            the text to be interpolated (as character array)\n+     * @param offset\n+     *            the start offset in the text array\n+     * @param length\n+     *            the length of the data to be processed\n+     * @param ref\n+     *            a reference object which will be returned if no interpolation was performed\n      * @param priorVariables\n      *            keeps track of the replaced variables\n      * @return the result of the interpolation process\n      */\n+    private Object doReplace(char[] data, int offset, int length, Object ref, List priorVariables) {\n+        if (data == null) {\n+            return null;\n+        }\n+\n+        Object resultObj = ref;\n+        int tokenCnt = 0;\n+        StrBuilder buf = new StrBuilder(length);\n+\n+        // on the first call initialize priorVariables\n+        if (priorVariables == null) {\n+            priorVariables = new ArrayList();\n+            priorVariables.add(new String(data, offset, length));\n+        }\n+\n+        VariableParser parser = createParser(data, offset, length);\n+        Token tok;\n+        while ((tok = parser.nextToken(data)) != null) {\n+            switch (tok.getType()) {\n+                case Token.TEXT_TOKEN :\n+                    buf.append(data, tok.getStartIndex(), tok.getLength());\n+                    break;\n+\n+                case Token.ESCAPED_VAR_TOKEN :\n+                    buf.append(getVariablePrefix());\n+                    tokenCnt++;\n+                    break;\n+\n+                case Token.VARIABLE_TOKEN :\n+                    String variable = tok.getText(data);\n+\n+                    // if we've got a loop, create a useful exception message and\n+                    // throw\n+                    if (priorVariables.contains(variable)) {\n+                        String initialBase = priorVariables.remove(0).toString();\n+                        priorVariables.add(variable);\n+                        StrBuilder priorVariableSb = new StrBuilder();\n+\n+                        // create a nice trace of interpolated variables like so:\n+                        // var1->var2->var3\n+                        for (Iterator it = priorVariables.iterator(); it.hasNext();) {\n+                            priorVariableSb.append(it.next());\n+                            if (it.hasNext()) {\n+                                priorVariableSb.append(\"->\");\n+                            }\n+                        }\n+                        throw new IllegalStateException(\"Infinite loop in property interpolation of \"\n+                            + initialBase\n+                            + \": \"\n+                            + priorVariableSb.toString());\n+                    }\n+                    // otherwise, add this variable to the interpolation list.\n+                    priorVariables.add(variable);\n+\n+                    resultObj = resolveVariable(variable);\n+                    if (resultObj != null) {\n+                        resultObj = doReplace(resultObj, priorVariables);\n+                        buf.append(resultObj);\n+                    } else {\n+                        // variable not defined - so put it back in the value\n+                        buf.append(getVariablePrefix()).append(variable).append(getVariableSuffix());\n+                    }\n+\n+                    // pop the interpolated variable off the stack\n+                    // this maintains priorVariables correctness for\n+                    // properties with multiple interpolations, e.g.\n+                    // prop.name=${some.other.prop1}/blahblah/${some.other.prop2}\n+                    priorVariables.remove(priorVariables.size() - 1);\n+                    break;\n+            }\n+            tokenCnt++;\n+        }\n+\n+        if (resultObj != null && tokenCnt == 1) {\n+            // if there was only one token, return the reference object\n+            return resultObj;\n+        }\n+        return buf.toString();\n+    }\n+\n+    /**\n+     * Recursive handler for multiple levels of interpolation. This is the main interpolation method for interpolating\n+     * objects. It is called for recursively processing the values of resolved variables.\n+     * \n+     * @param obj\n+     *            the data to be interpolated (as object)\n+     * @param priorVariables\n+     *            keeps track of the replaced variables\n+     * @return the result of the interpolation process\n+     */\n     private Object doReplace(Object obj, List priorVariables) {\n         if (obj == null) {\n             return null;\n         }\n-\n-        String base = obj.toString();\n-        if (base.indexOf(getVariablePrefix()) < 0) {\n-            return obj;\n-        }\n-\n-        // on the first call initialize priorVariables\n-        // and add base as the first element\n-        if (priorVariables == null) {\n-            priorVariables = new ArrayList();\n-            priorVariables.add(base);\n-        }\n-\n-        int begin = -1;\n-        int end = -1;\n-        int prec = 0 - getVariableSuffix().length();\n-        String variable = null;\n-        StringBuffer result = new StringBuffer();\n-        Object objResult = null;\n-        int objLen = 0;\n-\n-        while (((begin = base.indexOf(\n-                getVariablePrefix(), \n-                prec + getVariableSuffix().length())) > -1)\n-            && ((end = findEndToken(base, begin)) > -1)) {\n-            int escBegin = escaped(base, begin);\n-            if (escBegin >= 0) {\n-                result.append(base.substring(prec + getVariableSuffix().length(), escBegin));\n-                unescape(result, base, escBegin, end + getVariableSuffix().length(), priorVariables);\n-            }\n-\n-            else {\n-                result.append(base.substring(prec + getVariableSuffix().length(), begin));\n-                variable = base.substring(begin + getVariablePrefix().length(), end);\n-\n-                // if we've got a loop, create a useful exception message and\n-                // throw\n-                if (priorVariables.contains(variable)) {\n-                    String initialBase = priorVariables.remove(0).toString();\n-                    priorVariables.add(variable);\n-                    StringBuffer priorVariableSb = new StringBuffer();\n-\n-                    // create a nice trace of interpolated variables like so:\n-                    // var1->var2->var3\n-                    for (Iterator it = priorVariables.iterator(); it.hasNext();) {\n-                        priorVariableSb.append(it.next());\n-                        if (it.hasNext()) {\n-                            priorVariableSb.append(\"->\");\n-                        }\n-                    }\n-                    throw new IllegalStateException(\"Infinite loop in property interpolation of \"\n-                        + initialBase\n-                        + \": \"\n-                        + priorVariableSb.toString());\n-                }\n-                // otherwise, add this variable to the interpolation list.\n-                priorVariables.add(variable);\n-\n-                objResult = resolveVariable(variable);\n-                if (objResult != null) {\n-                    objResult = doReplace(objResult, priorVariables);\n-                    result.append(objResult);\n-                    objLen = objResult.toString().length();\n-                } else {\n-                    // variable not defined - so put it back in the value\n-                    result.append(getVariablePrefix()).append(variable).append(getVariableSuffix());\n-                }\n-\n-                // pop the interpolated variable off the stack\n-                // this maintains priorVariables correctness for\n-                // properties with multiple interpolations, e.g.\n-                // prop.name=${some.other.prop1}/blahblah/${some.other.prop2}\n-                priorVariables.remove(priorVariables.size() - 1);\n-            }\n-\n-            prec = end;\n-        }\n-\n-        result.append(base.substring(prec + getVariableSuffix().length(), base.length()));\n-        return (objResult != null && objLen > 0 && objLen == result.length()) ? objResult : result.toString();\n-    }\n-\n-    /**\n-     * Checks if the variable reference found at the specified position is escaped and if this is the case, where the\n-     * escaped text starts.\n-     * \n-     * @param text\n-     *            the text to be processed\n-     * @param beginIndex\n-     *            the start index of the variable reference to check\n-     * @return the starting index of the escaped text or -1 if this reference is not escaped\n-     */\n-    protected int escaped(String text, int beginIndex) {\n-        if (beginIndex < 1 || text.charAt(beginIndex - 1) != getEscapeCharacter()) {\n-            return -1;\n-        }\n-        int idx = beginIndex - 2;\n-        while (idx >= 0 && text.charAt(idx) == getEscapeCharacter()) {\n-            idx--;\n-        }\n-        return idx + 1;\n-    }\n-\n-    /**\n-     * Searches for a variable end token in the given string from the specified start position.\n-     * \n-     * @param text\n-     *            the text to search\n-     * @param beginIndex\n-     *            the start index\n-     * @return the index of the end token or -1 if none was found\n-     */\n-    protected int findEndToken(String text, int beginIndex) {\n-        int pos = beginIndex - getVariableSuffix().length();\n-\n-        do {\n-            pos = text.indexOf(getVariableSuffix(), pos + getVariableSuffix().length());\n-        } while (pos > 0 && getEscapeCharacter() == text.charAt(pos - 1));\n-\n-        return pos;\n+        char[] data = obj.toString().toCharArray();\n+        return doReplace(data, 0, data.length, obj, priorVariables);\n     }\n \n     /**\n      */\n     public String getVariableSuffix() {\n         return this.variableSuffix;\n+    }\n+\n+    /**\n+     * Replaces the occurrences of all variables in the given source array by their current values.\n+     * \n+     * @param data\n+     *            a character array with the source data\n+     * @return the result of the replace operation\n+     */\n+    public String replace(char[] data) {\n+        return replace(data, 0, data == null ? 0 : data.length);\n+    }\n+\n+    /**\n+     * Replaces the occurrences of all variables in the given source array by their current values. Only the specified\n+     * portion of the array will be processed.\n+     * \n+     * @param data\n+     *            a character array with the source data\n+     * @param offset\n+     *            the start offset; processing will start at this position\n+     * @param length\n+     *            the length of the portion to be processed\n+     * @return the result of the replace operation\n+     */\n+    public String replace(char[] data, int offset, int length) {\n+        Object result = doReplace(data, offset, length, null, null);\n+        return result == null ? null : result.toString();\n     }\n \n     /**\n         }\n         this.variableSuffix = variableSuffix;\n     }\n-\n-    /**\n-     * Unescapes an escaped variable reference. This method is called if <code>escaped()</code> has determined an\n-     * escaped variable reference. Its purpose is to remove any escaping characters and to add the resulting text into\n-     * the target buffer. This implementation will remove the first escape character. So if the default values are used,\n-     * a text portion of <code>$${myvar}</code> will become <code>${myvar}</code>,\n-     * <code>$$$${var with dollars}</code> will result in <code>$$${var with\n-     * dollars}</code>. Text between the\n-     * first variable start token and the last unescaped variable end token can contain variable references and will be\n-     * recursively replaced. So constructs of the following form can be built:\n-     * <code>Variable $${${varName$}} is incorrect!</code> (note how the first &quot;}&quot; character is escaped, so\n-     * that the second &quot;}&quot; marks the end of this construct.\n-     * \n-     * @param buf\n-     *            the target buffer\n-     * @param text\n-     *            the text to be processed\n-     * @param beginIndex\n-     *            the begin index of the escaped variable reference\n-     * @param endIndex\n-     *            the end index of the escaped variable reference\n-     * @param priorVariables\n-     *            keeps track of the replaced variables\n-     */\n-    protected void unescape(StringBuffer buf, String text, int beginIndex, int endIndex, List priorVariables) {\n-        int startToken = text.indexOf(getVariablePrefix(), beginIndex);\n-        buf.append(text.substring(beginIndex + 1, startToken));\n-        buf.append(getVariablePrefix());\n-        String escapedContent = text.substring(startToken + getVariablePrefix().length(), endIndex);\n-        buf.append(doReplace(StringUtils.replace(escapedContent, String.valueOf(getEscapeCharacter())\n-            + getVariableSuffix(), getVariableSuffix()), priorVariables));\n-    }\n-\n }\n--- a/src/test/org/apache/commons/lang/text/VariableFormatterTest.java\n+++ b/src/test/org/apache/commons/lang/text/VariableFormatterTest.java\n      * Tests escaping variable references.\n      */\n     public void testEscape() {\n+        assertEquals(\"${\", this.getFormat().replace(\"$${\"));\n         assertEquals(\"${animal}\", this.getFormat().replace(\"$${animal}\"));\n         this.getValueMap().put(\"var_name\", \"x\");\n         assertEquals(\"Many $$$$${target} $s\", this.getFormat().replace(\"Many $$$$$${target} $s\"));\n-        assertEquals(\"Variable ${x} must be used!\", this.getFormat().replace(\"Variable $${${var_name$}} must be used!\"));\n+        assertEquals(\"Variable ${x} must be used!\", this.getFormat().replace(\"Variable $${${var_name}} must be used!\"));\n     }\n \n     /**\n      */\n     public void testReplaceNothing() {\n         assertNull(this.getFormat().replace(null));\n+        assertNull(this.getFormat().replace((Object)null));\n         assertEquals(\"Nothing to replace.\", this.getFormat().replace(\"Nothing to replace.\"));\n         assertEquals(\"42\", this.getFormat().replace(new Integer(42)));\n     }\n         testReplaceNoElement(\"${${}}\");\n         testReplaceNoElement(\"${${ }}\");\n     }\n+    \n+    /**\n+     * Tests replace operations on char arrays.\n+     */\n+    public void testReplaceCharArray() {\n+        assertEquals(null, this.getFormat().replace((char[]) null));\n+        assertEquals(\"\", this.getFormat().replace(new char[0]));\n+        assertEquals(new String(new char[1]), this.getFormat().replace(new char[1]));\n+        char[] data = REPLACE_TEMPLATE.toCharArray();\n+        assertEquals(\"The quick brown fox jumps over the lazy dog.\", this.getFormat().replace(data));\n+        assertEquals(\"The quick brown fox\", this.getFormat().replace(data, 0, 13));\n+        assertEquals(\"\", this.getFormat().replace(data, 0, 0));\n+        char[] empty = new char[0];\n+        assertEquals(\"\", this.getFormat().replace(empty));\n+    }\n \n     void validateNoReplace(VariableFormatter formatter) {\n         String srcString = \"Hello ${user.name}\";", "timestamp": 1123706186, "metainfo": ""}