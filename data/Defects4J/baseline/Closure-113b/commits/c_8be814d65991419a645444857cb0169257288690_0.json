{"sha": "8be814d65991419a645444857cb0169257288690", "log": "Create RenameVars2. ------------- Created by MOE: http://code.google.com/p/moe-java MOE_MIGRATED_REVID=45835331", "commit": "\n--- a/src/com/google/javascript/jscomp/CompilerOptions.java\n+++ b/src/com/google/javascript/jscomp/CompilerOptions.java\n   //--------------------------------\n \n   boolean aggressiveRenaming;\n+  boolean alternateRenaming; // triggers RenameVars2.\n \n   /** Folds constants (e.g. (2 + 3) to 5) */\n   public boolean foldConstants;\n \n     // Optimizations\n     aggressiveRenaming = false;\n+    alternateRenaming = false;\n     foldConstants = false;\n     coalesceVariableNames = false;\n     deadAssignmentElimination = false;\n   }\n \n   public void setAggressiveRenaming(boolean aggressive) {\n-    this.aggressiveRenaming = true;\n+    this.aggressiveRenaming = aggressive;\n+  }\n+\n+  public void setAlternateRenaming(boolean altnerate) {\n+    this.alternateRenaming = altnerate;\n   }\n \n   public void setFoldConstants(boolean foldConstants) {\n--- a/src/com/google/javascript/jscomp/DefaultPassConfig.java\n+++ b/src/com/google/javascript/jscomp/DefaultPassConfig.java\n       reservedNames.addAll(exportedNames);\n     }\n     reservedNames.addAll(ParserRunner.getReservedVars());\n+    if (options.alternateRenaming) {\n+      RenameVars2 rn = new RenameVars2(\n+          compiler,\n+          options.renamePrefix,\n+          options.variableRenaming == VariableRenamingPolicy.LOCAL,\n+          preserveAnonymousFunctionNames,\n+          options.generatePseudoNames,\n+          options.shadowVariables,\n+          prevVariableMap,\n+          reservedChars,\n+          reservedNames);\n+      rn.process(externs, root);\n+      return rn.getVariableMap();\n+    }\n     RenameVars rn = new RenameVars(\n         compiler,\n         options.renamePrefix,\n--- /dev/null\n+++ b/src/com/google/javascript/jscomp/RenameVars2.java\n+/*\n+ * Copyright 2004 The Closure Compiler Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.ArrayListMultimap;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Sets;\n+import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n+import com.google.javascript.jscomp.NodeTraversal.ScopedCallback;\n+import com.google.javascript.jscomp.Scope.Var;\n+import com.google.javascript.rhino.Node;\n+\n+import java.util.ArrayList;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.SortedSet;\n+import java.util.TreeSet;\n+\n+import javax.annotation.Nullable;\n+\n+/**\n+ * RenameVars renames all the variables names into short names, to reduce code\n+ * size and also to obfuscate the code.\n+ *\n+ */\n+final class RenameVars2 implements CompilerPass {\n+  private final AbstractCompiler compiler;\n+\n+  /** List of global NAME nodes */\n+  private final ArrayList<Node> globalNameNodes = new ArrayList<Node>();\n+\n+  /** List of local NAME nodes */\n+  private final ArrayList<Node> localNameNodes = new ArrayList<Node>();\n+\n+  /**\n+   * Maps a name node to its pseudo name, null if we are not generating so\n+   * there will be no overhead unless we are debugging.\n+   */\n+  private final Map<Node, String> pseudoNameMap;\n+\n+  /** Set of extern variable names */\n+  private final Set<String> externNames = new HashSet<String>();\n+\n+  /** Set of reserved variable names */\n+  private final Set<String> reservedNames;\n+\n+  /** The renaming map */\n+  private final Map<String, String> renameMap = new HashMap<String, String>();\n+\n+  /** The previously used rename map. */\n+  private final VariableMap prevUsedRenameMap;\n+\n+  /** The global name prefix */\n+  private final String prefix;\n+\n+  /** Counter for each assignment */\n+  private int assignmentCount = 0;\n+\n+  /** Logs all name assignments */\n+  private StringBuilder assignmentLog;\n+\n+  // Logic for bleeding functions, where the name leaks into the outer\n+  // scope on IE but not on other browsers.\n+  private final Set<Var> localBleedingFunctions = Sets.newHashSet();\n+  private final ArrayListMultimap<Scope, Var> localBleedingFunctionsPerScope =\n+      ArrayListMultimap.create();\n+\n+  class Assignment {\n+    final String oldName;\n+    final int orderOfOccurrence;\n+    String newName;\n+    int count; // Number of times this is referenced\n+\n+    Assignment(String name) {\n+      this.oldName = name;\n+      this.newName = null;\n+      this.count = 0;\n+\n+      // Represents the order at which a symbol appears in the source.\n+      this.orderOfOccurrence = assignmentCount++;\n+    }\n+\n+    /**\n+     * Assigns the new name.\n+     */\n+    void setNewName(String newName) {\n+      Preconditions.checkState(this.newName == null);\n+      this.newName = newName;\n+    }\n+  }\n+\n+  /** Maps an old name to a new name assignment */\n+  private final Map<String, Assignment> assignments =\n+      new HashMap<String, Assignment>();\n+\n+  /** Whether renaming should apply to local variables only. */\n+  private final boolean localRenamingOnly;\n+\n+  /**\n+   * Whether function expression names should be preserved. Typically, for\n+   * debugging purposes.\n+   *\n+   * @see NameAnonymousFunctions\n+   */\n+  private final boolean preserveFunctionExpressionNames;\n+\n+  private final boolean shouldShadow;\n+\n+  /** Characters that shouldn't be used in variable names. */\n+  private final char[] reservedCharacters;\n+\n+  /** A prefix to distinguish temporary local names from global names */\n+  // TODO(user): No longer needs to be public when shadowing doesn't use it.\n+  public static final String LOCAL_VAR_PREFIX = \"L \";\n+\n+  // TODO(user): Temporary. To make checking in / merging DefaultPassConfig\n+  // easier.\n+  private final NameGenerator nameGeneratorGiven;\n+  RenameVars2(AbstractCompiler compiler, String prefix,\n+      boolean localRenamingOnly, boolean preserveFunctionExpressionNames,\n+      boolean generatePseudoNames, boolean shouldShadow,\n+      VariableMap prevUsedRenameMap,\n+      @Nullable char[] reservedCharacters,\n+      @Nullable Set<String> reservedNames) {\n+    this(compiler, prefix, localRenamingOnly, preserveFunctionExpressionNames,\n+        generatePseudoNames, shouldShadow, prevUsedRenameMap,\n+        reservedCharacters, reservedNames, null);\n+\n+  }\n+  RenameVars2(AbstractCompiler compiler, String prefix,\n+      boolean localRenamingOnly, boolean preserveFunctionExpressionNames,\n+      boolean generatePseudoNames, boolean shouldShadow,\n+      VariableMap prevUsedRenameMap,\n+      @Nullable char[] reservedCharacters,\n+      @Nullable Set<String> reservedNames,\n+      @Nullable NameGenerator nameGenerator) {\n+    this.compiler = compiler;\n+    this.prefix = prefix == null ? \"\" : prefix;\n+    this.localRenamingOnly = localRenamingOnly;\n+    this.preserveFunctionExpressionNames = preserveFunctionExpressionNames;\n+    if (generatePseudoNames) {\n+      this.pseudoNameMap = Maps.newHashMap();\n+    } else {\n+      this.pseudoNameMap = null;\n+    }\n+    this.prevUsedRenameMap = prevUsedRenameMap;\n+    this.reservedCharacters = reservedCharacters;\n+    this.shouldShadow = shouldShadow;\n+    if (reservedNames == null) {\n+      this.reservedNames = Sets.newHashSet();\n+    } else {\n+      this.reservedNames = Sets.newHashSet(reservedNames);\n+    }\n+    this.nameGeneratorGiven = nameGenerator;\n+  }\n+\n+  /**\n+   * Iterate through the nodes, collect all the NAME nodes that need to be\n+   * renamed, and count how many times each variable name is referenced.\n+   *\n+   * There are 2 passes:\n+   * - externs: keep track of the global vars in the externNames_ map.\n+   * - source: keep track of all name references in globalNameNodes_, and\n+   *   localNameNodes_.\n+   *\n+   * To get shorter local variable renaming, we rename local variables to a\n+   * temporary name \"LOCAL_VAR_PREFIX + index\" where index is the index of the\n+   * variable declared in the local scope stack.\n+   * e.g.\n+   * Foo(fa, fb) {\n+   *   var c = function(d, e) { return fa; }\n+   * }\n+   * The indexes are: fa:0, fb:1, c:2, d:3, e:4\n+   *\n+   * In that way, local variable names are reused in each global function.\n+   * e.g. the final code might look like\n+   * function x(a,b) { ... }\n+   * function y(a,b,c) { ... }\n+   */\n+  class ProcessVars extends AbstractPostOrderCallback\n+      implements ScopedCallback {\n+    private final boolean isExternsPass_;\n+\n+    ProcessVars(boolean isExterns) {\n+      isExternsPass_ = isExterns;\n+    }\n+\n+    @Override\n+    public void enterScope(NodeTraversal t) {\n+      if (t.inGlobalScope()) {\n+        return;\n+      }\n+      Iterator<Var> it = t.getScope().getVars();\n+      while (it.hasNext()) {\n+        Var current = it.next();\n+        if (current.isBleedingFunction()) {\n+          localBleedingFunctions.add(current);\n+          localBleedingFunctionsPerScope.put(\n+              t.getScope().getParent(), current);\n+        }\n+      }\n+    }\n+\n+    @Override\n+    public void exitScope(NodeTraversal t) {}\n+\n+    @Override\n+    public void visit(NodeTraversal t, Node n, Node parent) {\n+      if (!n.isName()) {\n+        return;\n+      }\n+\n+      String name = n.getString();\n+\n+      // Ignore anonymous functions\n+      if (name.length() == 0) {\n+        return;\n+      }\n+\n+      // Is this local or Global?\n+      // Bleeding functions should be treated as part of their outer\n+      // scope, because IE has bugs in how it handles bleeding\n+      // functions.\n+      Scope.Var var = t.getScope().getVar(name);\n+      boolean local = (var != null) && var.isLocal() &&\n+          (!var.scope.getParent().isGlobal() ||\n+           !var.isBleedingFunction());\n+\n+      // Are we renaming global variables?\n+      if (!local && localRenamingOnly) {\n+        reservedNames.add(name);\n+        return;\n+      }\n+\n+      // Are we renaming function expression names?\n+      if (preserveFunctionExpressionNames && var != null\n+          && NodeUtil.isFunctionExpression(var.getParentNode())) {\n+        reservedNames.add(name);\n+        return;\n+      }\n+\n+      // Check if we can rename this.\n+      if (!okToRenameVar(name, local)) {\n+        if (local) {\n+          // Blindly de-uniquify for the Prototype library for issue 103.\n+          String newName = MakeDeclaredNamesUnique.ContextualRenameInverter\n+              .getOrginalName(name);\n+          if (!newName.equals(name)) {\n+            n.setString(newName);\n+          }\n+        }\n+        return;\n+      }\n+\n+      if (isExternsPass_) {\n+        // Keep track of extern globals.\n+        if (!local) {\n+          externNames.add(name);\n+        }\n+        return;\n+      }\n+\n+      if (pseudoNameMap != null) {\n+        recordPseudoName(n);\n+      }\n+\n+      if (local) {\n+        // Local var: assign a new name\n+        String tempName = LOCAL_VAR_PREFIX + getLocalVarIndex(var);\n+        incCount(tempName);\n+        localNameNodes.add(n);\n+        n.setString(tempName);\n+      } else if (var != null) { // Not an extern\n+        // If it's global, increment global count\n+        incCount(name);\n+        globalNameNodes.add(n);\n+      }\n+    }\n+\n+    // Increment count of an assignment\n+    void incCount(String name) {\n+      Assignment s = assignments.get(name);\n+      if (s == null) {\n+        s = new Assignment(name);\n+        assignments.put(name, s);\n+      }\n+      s.count++;\n+    }\n+  }\n+\n+  /**\n+   * Sorts Assignment objects by their count, breaking ties by their order of\n+   * occurrence in the source to ensure a deterministic total ordering.\n+   */\n+  private static final Comparator<Assignment> FREQUENCY_COMPARATOR =\n+      new Comparator<Assignment>() {\n+    @Override\n+    public int compare(Assignment a1, Assignment a2) {\n+      if (a1.count != a2.count) {\n+        return a2.count - a1.count;\n+      }\n+      // Break a tie using the order in which the variable first appears in\n+      // the source.\n+      return ORDER_OF_OCCURRENCE_COMPARATOR.compare(a1, a2);\n+    }\n+  };\n+\n+  /**\n+   * Sorts Assignment objects by the order the variable name first appears in\n+   * the source.\n+   */\n+  private static final Comparator<Assignment> ORDER_OF_OCCURRENCE_COMPARATOR =\n+      new Comparator<Assignment>() {\n+        @Override\n+        public int compare(Assignment a1, Assignment a2) {\n+          return a1.orderOfOccurrence - a2.orderOfOccurrence;\n+        }\n+      };\n+\n+  @Override\n+  public void process(Node externs, Node root) {\n+    assignmentLog = new StringBuilder();\n+\n+    // Do variable reference counting.\n+    NodeTraversal.traverse(compiler, externs, new ProcessVars(true));\n+    NodeTraversal.traverse(compiler, root, new ProcessVars(false));\n+\n+    // Make sure that new names don't overlap with extern names.\n+    reservedNames.addAll(externNames);\n+\n+    // Rename vars, sorted by frequency of occurrence to minimize code size.\n+    SortedSet<Assignment> varsByFrequency =\n+        new TreeSet<Assignment>(FREQUENCY_COMPARATOR);\n+    varsByFrequency.addAll(assignments.values());\n+\n+    if (shouldShadow) {\n+      new ShadowVariables2(\n+          compiler, assignments, varsByFrequency, pseudoNameMap).process(\n+              externs, root);\n+    }\n+\n+    // First try to reuse names from an earlier compilation.\n+    if (prevUsedRenameMap != null) {\n+      reusePreviouslyUsedVariableMap();\n+    }\n+\n+    // Assign names, sorted by descending frequency to minimize code size.\n+    assignNames(varsByFrequency);\n+\n+    boolean changed = false;\n+\n+    // Rename the globals!\n+    for (Node n : globalNameNodes) {\n+      String newName = getNewGlobalName(n);\n+      // Note: if newName is null, then oldName is an extern.\n+      if (newName != null) {\n+        n.setString(newName);\n+        changed = true;\n+      }\n+    }\n+\n+    // Rename the locals!\n+    for (Node n : localNameNodes) {\n+      String newName = getNewLocalName(n);\n+      if (newName != null) {\n+        n.setString(newName);\n+        changed = true;\n+      }\n+    }\n+\n+    if (changed) {\n+      compiler.reportCodeChange();\n+    }\n+\n+    // Lastly, write the name assignments to the debug log.\n+    compiler.addToDebugLog(\"JS var assignments:\\n\" + assignmentLog);\n+    assignmentLog = null;\n+  }\n+\n+  private String getNewGlobalName(Node n) {\n+    String oldName = n.getString();\n+    Assignment a = assignments.get(oldName);\n+    if (a.newName != null && !a.newName.equals(oldName)) {\n+      if (pseudoNameMap != null) {\n+        return pseudoNameMap.get(n);\n+      }\n+      return a.newName;\n+    } else {\n+      return null;\n+    }\n+  }\n+\n+  private String getNewLocalName(Node n) {\n+    String oldTempName = n.getString();\n+    Assignment a = assignments.get(oldTempName);\n+    if (!a.newName.equals(oldTempName)) {\n+      if (pseudoNameMap != null) {\n+        return pseudoNameMap.get(n);\n+      }\n+      return a.newName;\n+    }\n+    return null;\n+  }\n+\n+  private void recordPseudoName(Node n) {\n+    // Variable names should be in a different name space than\n+    // property pseudo names.\n+    pseudoNameMap.put(n, '$' + n.getString() + \"$$\");\n+  }\n+\n+  /**\n+   * Runs through the assignments and reuses as many names as possible from the\n+   * previously used variable map. Updates reservedNames with the set of names\n+   * that were reused.\n+   */\n+  private void reusePreviouslyUsedVariableMap() {\n+    // If prevUsedRenameMap had duplicate values then this pass would be\n+    // non-deterministic.\n+    // In such a case, the following will throw an IllegalArgumentException.\n+    Preconditions.checkState(\n+        prevUsedRenameMap.getNewNameToOriginalNameMap() instanceof Map);\n+    for (Assignment a : assignments.values()) {\n+      String prevNewName = prevUsedRenameMap.lookupNewName(a.oldName);\n+      if (prevNewName == null || reservedNames.contains(prevNewName)) {\n+        continue;\n+      }\n+\n+      if (a.oldName.startsWith(LOCAL_VAR_PREFIX)\n+          || (!externNames.contains(a.oldName)\n+              && prevNewName.startsWith(prefix))) {\n+        reservedNames.add(prevNewName);\n+        finalizeNameAssignment(a, prevNewName);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Determines which new names to substitute for the original names.\n+   */\n+  private void assignNames(SortedSet<Assignment> varsToRename) {\n+    NameGenerator globalNameGenerator = null;\n+    NameGenerator localNameGenerator = null;\n+\n+    if (nameGeneratorGiven != null) {\n+      globalNameGenerator = localNameGenerator = nameGeneratorGiven;\n+      nameGeneratorGiven.restartNaming();\n+    } else {\n+      globalNameGenerator =\n+          new NameGenerator(reservedNames, prefix, reservedCharacters);\n+\n+      // Local variables never need a prefix.\n+      localNameGenerator =\n+          prefix.isEmpty() ? globalNameGenerator : new NameGenerator(\n+              reservedNames, \"\", reservedCharacters);\n+    }\n+\n+    // Generated names and the assignments for non-local vars.\n+    List<Assignment> pendingAssignments = new ArrayList<Assignment>();\n+    List<String> generatedNamesForAssignments = new ArrayList<String>();\n+\n+    for (Assignment a : varsToRename) {\n+      if (a.newName != null) {\n+        continue;\n+      }\n+\n+      if (externNames.contains(a.oldName)) {\n+        continue;\n+      }\n+\n+      String newName;\n+      if (a.oldName.startsWith(LOCAL_VAR_PREFIX)) {\n+        // For local variable, we make the assignment right away.\n+        newName = localNameGenerator.generateNextName();\n+        finalizeNameAssignment(a, newName);\n+      } else {\n+        // For non-local variable, delay finalizing the name assignment\n+        // until we know how many new names we'll have of length 2, 3, etc.\n+        newName = globalNameGenerator.generateNextName();\n+        pendingAssignments.add(a);\n+        generatedNamesForAssignments.add(newName);\n+      }\n+      reservedNames.add(newName);\n+    }\n+\n+    // Now that we have a list of generated names, and a list of variable\n+    // Assignment objects, we assign the generated names to the vars as\n+    // follows:\n+    // 1) The most frequent vars get the shorter names.\n+    // 2) If N number of vars are going to be assigned names of the same\n+    //    length, we assign the N names based on the order at which the vars\n+    //    first appear in the source. This makes the output somewhat less\n+    //    random, because symbols declared close together are assigned names\n+    //    that are quite similar. With this heuristic, the output is more\n+    //    compressible.\n+    //    For instance, the output may look like:\n+    //    var da = \"..\", ea = \"..\";\n+    //    function fa() { .. } function ga() { .. }\n+\n+    int numPendingAssignments = generatedNamesForAssignments.size();\n+    for (int i = 0; i < numPendingAssignments;) {\n+      SortedSet<Assignment> varsByOrderOfOccurrence =\n+          new TreeSet<Assignment>(ORDER_OF_OCCURRENCE_COMPARATOR);\n+\n+      // Add k number of Assignment to the set, where k is the number of\n+      // generated names of the same length.\n+      int len = generatedNamesForAssignments.get(i).length();\n+      for (int j = i; j < numPendingAssignments\n+          && generatedNamesForAssignments.get(j).length() == len; j++) {\n+        varsByOrderOfOccurrence.add(pendingAssignments.get(j));\n+      }\n+\n+      // Now, make the assignments\n+      for (Assignment a : varsByOrderOfOccurrence) {\n+        finalizeNameAssignment(a, generatedNamesForAssignments.get(i));\n+        ++i;\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Makes a final name assignment.\n+   */\n+  private void finalizeNameAssignment(Assignment a, String newName) {\n+    a.setNewName(newName);\n+\n+    // Keep track of the mapping\n+    renameMap.put(a.oldName, newName);\n+\n+    // Log the mapping\n+    assignmentLog.append(a.oldName).append(\" => \").append(newName).append('\\n');\n+  }\n+\n+  /**\n+   * Gets the variable map.\n+   */\n+  VariableMap getVariableMap() {\n+    return new VariableMap(ImmutableMap.copyOf(renameMap));\n+  }\n+\n+  /**\n+   * Determines whether a variable name is okay to rename.\n+   */\n+  private boolean okToRenameVar(String name, boolean isLocal) {\n+    return !compiler.getCodingConvention().isExported(name, isLocal);\n+  }\n+\n+  /**\n+   * Returns the index within the scope stack.\n+   * e.g. function Foo(a) { var b; function c(d) { } }\n+   * a = 0, b = 1, c = 2, d = 3\n+   */\n+  private int getLocalVarIndex(Var v) {\n+    int num = v.index;\n+    Scope s = v.scope.getParent();\n+    if (s == null) {\n+      throw new IllegalArgumentException(\"Var is not local\");\n+    }\n+\n+    boolean isBleedingIntoScope = s.getParent() != null &&\n+        localBleedingFunctions.contains(v);\n+\n+    while (s.getParent() != null) {\n+      if (isBleedingIntoScope) {\n+        num += localBleedingFunctionsPerScope.get(s).indexOf(v) + 1;\n+        isBleedingIntoScope = false;\n+      } else {\n+        num += localBleedingFunctionsPerScope.get(s).size();\n+      }\n+\n+      num += s.getVarCount();\n+      s = s.getParent();\n+    }\n+    return num;\n+  }\n+}\n--- /dev/null\n+++ b/src/com/google/javascript/jscomp/ShadowVariables2.java\n+/*\n+ * Copyright 2011 The Closure Compiler Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+import com.google.common.collect.HashMultimap;\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Multimap;\n+import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n+import com.google.javascript.jscomp.NodeTraversal.ScopedCallback;\n+import com.google.javascript.jscomp.RenameVars2.Assignment;\n+import com.google.javascript.jscomp.Scope.Var;\n+import com.google.javascript.rhino.Node;\n+\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.SortedSet;\n+\n+/**\n+ * Tries to compute a list of variables that can shadow a variable in the\n+ * outer scope.\n+ *\n+ * For example:\n+ *\n+ * <code>\n+ * var a = function() {\n+ *   var b = getB();\n+ *   b();\n+ *   return function(y) {};\n+ * };\n+ * </code>\n+ *\n+ * Normally, b would be mapped to variable L0, y would be L1.\n+ *\n+ * Instead we are going to make y shadows L0 in hope of using less variables\n+ * and reusing frequently used local names.\n+ *\n+ */\n+class ShadowVariables2 implements CompilerPass {\n+\n+  // Keep a map of Upward Referencing name nodes of each scope.\n+  // A name is upward referencing name of a scope if:\n+  //\n+  // 1) It refers to (or defines) a name that is defined in the current\n+  // scope or any scope above the current scope that isn't the\n+  // global scope.\n+  //\n+  // 2) It is a upward referencing name of a child scope of this scope.\n+  //\n+  // Example:\n+  // var x; var y; function foo(a) { function bar(b) { x, a } }\n+  // The upward referencing names in scope 'foo' is bar, b, x and a;\n+  // The key to this map is the root node of the scope.\n+  //\n+  // We can see that for any variable x in the current scope, we can shadow\n+  // a variable y in an outer scope given that y is not a upward referencing\n+  // name of the current scope.\n+\n+  // TODO(user): Maps scope to string instead of Node to string.\n+  // Make sure of scope memorization to minimize scope creation cost.\n+  private final Multimap<Node, String> scopeUpRefMap = HashMultimap.create();\n+\n+  // Maps all local Scope.Var to all of its referencing NAME node\n+  // in any scope.\n+  private final Multimap<Var, Node> varToNameUsage = HashMultimap.create();\n+\n+  private final AbstractCompiler compiler;\n+\n+  // All the information used for renaming.\n+  private final SortedSet<Assignment> varsByFrequency;\n+  private final Map<String, Assignment> assignments;\n+  private final Map<Node, String> oldPseudoNameMap;\n+  private final Map<Node, String> deltaPseudoNameMap;\n+\n+\n+  /**\n+   * @param assignments Map of old variable names to its assignment Objects.\n+   * @param varsByFrequency Sorted variable assignments by Frequency.\n+   * @param pseudoNameMap The current pseudo name map so this pass can update\n+   *     it accordingly.\n+   */\n+  ShadowVariables2(\n+      AbstractCompiler compiler,\n+      Map<String, Assignment> assignments,\n+      SortedSet<Assignment> varsByFrequency,\n+      Map<Node, String> pseudoNameMap) {\n+    this.compiler = compiler;\n+    this.assignments = assignments;\n+    this.varsByFrequency = varsByFrequency;\n+    this.oldPseudoNameMap = pseudoNameMap;\n+    this.deltaPseudoNameMap = Maps.newLinkedHashMap();\n+  }\n+\n+  @Override\n+  public void process(Node externs, Node root) {\n+\n+    // The algorithm is divided into two stages:\n+    //\n+    // 1. Information gathering (variable usage, upward referencing)\n+    //\n+    // 2. Tries to find shadows for each variables, updates the\n+    //    variable usage frequency map.\n+    //\n+    // 3. Updates the pseudo naming map if needed.\n+    NodeTraversal.traverse(compiler, root, new GatherReferenceInfo());\n+    NodeTraversal.traverse(compiler, root, new DoShadowVariables());\n+\n+    if (oldPseudoNameMap != null) {\n+      oldPseudoNameMap.putAll(deltaPseudoNameMap);\n+    }\n+  }\n+\n+  private class GatherReferenceInfo extends AbstractPostOrderCallback {\n+    @Override\n+    public void visit(NodeTraversal t, Node n, Node parent) {\n+      // Skipping over non-name nodes and empty function names.\n+      if (!NodeUtil.isReferenceName(n)) {\n+        return;\n+      }\n+\n+      // We focus on shadowing local variables as their name occurs much more\n+      // than global names.\n+      // TODO(user): Alternatively, we could experiment with using a local\n+      // name to shadow a global variable.\n+      if (t.inGlobalScope()) {\n+        return;\n+      }\n+\n+      Var var = t.getScope().getVar(n.getString());\n+      if (var == null) {\n+        // extern name or undefined name.\n+        return;\n+      }\n+\n+      if (var.getScope().isGlobal()) {\n+        // We will not shadow a global variable name.\n+        return;\n+      }\n+\n+      // Using the definition of upward referencing, fill in the map.\n+      if (var.getScope() != t.getScope()) {\n+        for (Scope s = t.getScope();\n+            s != var.getScope() && s.isLocal(); s = s.getParent()) {\n+          scopeUpRefMap.put(s.getRootNode(), var.name);\n+        }\n+      }\n+\n+      if (var.getScope() == t.getScope()) {\n+        scopeUpRefMap.put(t.getScopeRoot(), var.name);\n+      }\n+\n+      // Find in the usage map that tracks a var and all of its usage.\n+      varToNameUsage.put(var, n);\n+    }\n+  }\n+\n+  private class DoShadowVariables extends AbstractPostOrderCallback\n+      implements ScopedCallback {\n+\n+    @Override\n+    public void enterScope(NodeTraversal t) {\n+      Scope s = t.getScope();\n+      if (!s.isLocal()) {\n+        return;\n+      }\n+\n+      // Since we don't shadow global, there is nothing to be done in the\n+      // first immediate local scope as well.\n+      if (s.getParent().isGlobal()) {\n+        return;\n+      }\n+\n+      for (Iterator<Var> vars = s.getVars(); vars.hasNext();) {\n+        Var var = vars.next();\n+\n+        // Don't shadow variables that is bleed-out to fix an IE bug.\n+        if (var.isBleedingFunction()) {\n+          continue;\n+        }\n+\n+        // Don't shadow an exported local.\n+        if (compiler.getCodingConvention().isExported(var.name, s.isLocal())) {\n+          continue;\n+        }\n+\n+        // Try to look for the best shadow for the current candidate.\n+        Assignment bestShadow = findBestShadow(s);\n+        if (bestShadow == null) {\n+          continue;\n+        }\n+\n+        // The name assignment being shadowed.\n+        Assignment localAssignment = assignments.get(var.getName());\n+\n+        // Only shadow if this increases the number of occurrences of the\n+        // shadowed variable.\n+        if (bestShadow.count < localAssignment.count) {\n+          continue; // Hope the next local variable would have a smaller count.\n+        }\n+\n+        doShadow(localAssignment, bestShadow, var);\n+\n+        if (oldPseudoNameMap != null) {\n+          String targetPseudoName =\n+            oldPseudoNameMap.get(s.getVar(bestShadow.oldName).nameNode);\n+          for (Node use : varToNameUsage.get(var)) {\n+            deltaPseudoNameMap.put(use, targetPseudoName);\n+          }\n+        }\n+      }\n+    }\n+\n+    @Override\n+    public void exitScope(NodeTraversal t) {}\n+\n+    @Override\n+    public void visit(NodeTraversal t, Node n, Node parent) {}\n+\n+    /**\n+     * @returns An assignment that can be used as a shadow for a local variable\n+     *     in the scope defined by curScopeRoot.\n+     */\n+    private Assignment findBestShadow(Scope curScope) {\n+      // Search for the candidate starting from the most used local.\n+      for (Assignment assignment : varsByFrequency) {\n+        if (assignment.oldName.startsWith(RenameVars.LOCAL_VAR_PREFIX)) {\n+          if (!scopeUpRefMap.get(curScope.getRootNode()).contains(\n+              assignment.oldName)) {\n+            if (curScope.isDeclared(assignment.oldName, true)) {\n+              return assignment;\n+            }\n+          }\n+        }\n+      }\n+      return null;\n+    }\n+\n+    private void doShadow(Assignment original, Assignment toShadow, Var var) {\n+      Scope s = var.getScope();\n+      // We are now shadowing 'bestShadow' with localAssignment.\n+      // All of the reference NAME node of this variable.\n+      Collection<Node> references = varToNameUsage.get(var);\n+\n+      // First remove both assignments from the sorted list since they need\n+      // to be re-sorted.\n+      varsByFrequency.remove(original);\n+      varsByFrequency.remove(toShadow);\n+\n+      // Adjust the count offset by the inner scope variable.\n+      original.count -= references.size();\n+      toShadow.count += references.size();\n+\n+      // Add it back to the sorted list after re-adjustment.\n+      varsByFrequency.add(original);\n+      varsByFrequency.add(toShadow);\n+\n+      // This is an important step. If variable L7 is going to be renamed to\n+      // L1, by definition of upward referencing, The name L1 is now in the\n+      // set of upward referencing names of the current scope up to the\n+      // declaring scope of the best shadow variable.\n+      Var shadowed = s.getVar(toShadow.oldName);\n+      if (shadowed != null) {\n+        for (Scope curScope = s; curScope != shadowed.scope;\n+            curScope = curScope.getParent()) {\n+          scopeUpRefMap.put(curScope.getRootNode(), toShadow.oldName);\n+        }\n+      }\n+\n+      // Mark all the references as shadowed.\n+      for (Node n : references) {\n+        n.setString(toShadow.oldName);\n+        Node cur = n;\n+        while (cur != s.getRootNode()) {\n+          cur = cur.getParent();\n+          if (cur.isFunction()) {\n+            scopeUpRefMap.put(cur, toShadow.oldName);\n+          }\n+        }\n+      }\n+    }\n+  }\n+}\n--- /dev/null\n+++ b/test/com/google/javascript/jscomp/RenameVars2Test.java\n+/*\n+ * Copyright 2005 The Closure Compiler Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.javascript.rhino.Node;\n+\n+import java.util.HashSet;\n+import java.util.Map;\n+\n+\n+/**\n+ * Tests for {@link Rename2Vars}.\n+ */\n+public class RenameVars2Test extends CompilerTestCase {\n+  private static final String DEFAULT_PREFIX = \"\";\n+  private String prefix = DEFAULT_PREFIX;\n+\n+  private VariableMap previouslyUsedMap =\n+      new VariableMap(ImmutableMap.<String, String>of());\n+  private RenameVars renameVars;\n+  private boolean withClosurePass = false;\n+  private boolean localRenamingOnly = false;\n+  private boolean preserveFunctionExpressionNames = false;\n+  private boolean useGoogleCodingConvention = true;\n+  private boolean generatePseudoNames = false;\n+  private boolean shouldShadow = false;\n+  private boolean withNormalize = false;\n+  private NameGenerator nameGenerator = null;\n+\n+  @Override\n+  protected CodingConvention getCodingConvention() {\n+    if (useGoogleCodingConvention) {\n+      return new GoogleCodingConvention();\n+    } else {\n+      return CodingConventions.getDefault();\n+    }\n+  }\n+\n+  @Override\n+  protected CompilerPass getProcessor(Compiler compiler) {\n+    CompilerPass pass;\n+    if (withClosurePass) {\n+      pass = new ClosurePassAndRenameVars(compiler);\n+    } else {\n+      pass =  renameVars = new RenameVars(compiler, prefix,\n+          localRenamingOnly, preserveFunctionExpressionNames,\n+          generatePseudoNames, shouldShadow,\n+          previouslyUsedMap, null, null, nameGenerator);\n+    }\n+\n+    if (withNormalize) {\n+      // Don't use the standard CompilerTestCase normalization options\n+      // as renaming is a post denormalization operation, but we do still\n+      // want to run the normal normalizations on the input in some cases.\n+      pass = new NormalizePassWrapper(compiler, pass);\n+    }\n+\n+    return pass;\n+  }\n+\n+  @Override\n+  protected int getNumRepetitions() {\n+    return 1;\n+  }\n+\n+  @Override\n+  protected void setUp() throws Exception {\n+    super.setUp();\n+    previouslyUsedMap = new VariableMap(ImmutableMap.<String, String>of());\n+    prefix = DEFAULT_PREFIX;\n+    withClosurePass = false;\n+    withNormalize = false;\n+    localRenamingOnly = false;\n+    preserveFunctionExpressionNames = false;\n+    generatePseudoNames = false;\n+    shouldShadow = false;\n+    nameGenerator = null;\n+\n+    // TODO(johnlenz): Enable Normalize during these tests.\n+  }\n+\n+  public void testRenameSimple() {\n+    test(\"function Foo(v1, v2) {return v1;} Foo();\",\n+         \"function a(b, c) {return b;} a();\");\n+  }\n+\n+  public void testRenameGlobals() {\n+    test(\"var Foo; var Bar, y; function x() { Bar++; }\",\n+         \"var a; var b, c; function d() { b++; }\");\n+  }\n+\n+  public void testRenameLocals() {\n+    test(\"(function (v1, v2) {}); (function (v3, v4) {});\",\n+        \"(function (a, b) {}); (function (a, b) {});\");\n+    test(\"function f1(v1, v2) {}; function f2(v3, v4) {};\",\n+        \"function c(a, b) {}; function d(a, b) {};\");\n+  }\n+\n+  public void testRenameRedeclaredGlobals() {\n+    test(\"function f1(v1, v2) {f1()};\" +\n+         \"/** @suppress {duplicate} */\" +\n+         \"function f1(v3, v4) {f1()};\",\n+         \"function a(b, c) {a()};\" +\n+         \"function a(b, c) {a()};\");\n+\n+    localRenamingOnly = true;\n+\n+    test(\"function f1(v1, v2) {f1()};\" +\n+        \"/** @suppress {duplicate} */\" +\n+        \"function f1(v3, v4) {f1()};\",\n+        \"function f1(a, b) {f1()};\" +\n+        \"function f1(a, b) {f1()};\");\n+  }\n+\n+  public void testRecursiveFunctions1() {\n+    test(\"var walk = function walk(node, aFunction) {\" +\n+         \"  walk(node, aFunction);\" +\n+         \"};\",\n+         \"var a = function a(b, c) {\" +\n+         \"  a(b, c);\" +\n+         \"};\");\n+\n+    localRenamingOnly = true;\n+\n+    test(\"var walk = function walk(node, aFunction) {\" +\n+         \"  walk(node, aFunction);\" +\n+         \"};\",\n+         \"var walk = function walk(a, b) {\" +\n+         \"  walk(a, b);\" +\n+         \"};\");\n+  }\n+\n+  public void testRecursiveFunctions2() {\n+    preserveFunctionExpressionNames = true;\n+\n+    test(\"var walk = function walk(node, aFunction) {\" +\n+         \"  walk(node, aFunction);\" +\n+         \"};\",\n+         \"var c = function walk(a, b) {\" +\n+         \"  walk(a, b);\" +\n+         \"};\");\n+\n+    localRenamingOnly = true;\n+\n+    test(\"var walk = function walk(node, aFunction) {\" +\n+        \"  walk(node, aFunction);\" +\n+        \"};\",\n+        \"var walk = function walk(a, b) {\" +\n+        \"  walk(a, b);\" +\n+        \"};\");\n+  }\n+\n+  public void testRenameLocalsClashingWithGlobals() {\n+    test(\"function a(v1, v2) {return v1;} a();\",\n+        \"function a(b, c) {return b;} a();\");\n+  }\n+\n+  public void testRenameNested() {\n+    test(\"function f1(v1, v2) { (function(v3, v4) {}) }\",\n+         \"function a(b, c) { (function(d, e) {}) }\");\n+    test(\"function f1(v1, v2) { function f2(v3, v4) {} }\",\n+         \"function a(b, c) { function d(e, f) {} }\");\n+  }\n+\n+  public void testBleedingRecursiveFunctions1() {\n+    // On IE, bleeding functions will interfere with each other if\n+    // they are in the same scope. In the below example, we want to be\n+    // sure that a and b get separate names.\n+    test(\"var x = function a(x) { return x ? 1 : a(1); };\" +\n+         \"var y = function b(x) { return x ? 2 : b(2); };\",\n+         \"var c = function b(a) { return a ? 1 : b(1); };\" +\n+         \"var e = function d(a) { return a ? 2 : d(2); };\");\n+  }\n+\n+  public void testBleedingRecursiveFunctions2() {\n+    test(\"function f() {\" +\n+         \"  var x = function a(x) { return x ? 1 : a(1); };\" +\n+         \"  var y = function b(x) { return x ? 2 : b(2); };\" +\n+         \"}\",\n+         \"function d() {\" +\n+         \"  var e = function b(a) { return a ? 1 : b(1); };\" +\n+         \"  var f = function a(c) { return c ? 2 : a(2); };\" +\n+         \"}\");\n+  }\n+\n+  public void testBleedingRecursiveFunctions3() {\n+    test(\"function f() {\" +\n+         \"  var x = function a(x) { return x ? 1 : a(1); };\" +\n+         \"  var y = function b(x) { return x ? 2 : b(2); };\" +\n+         \"  var z = function c(x) { return x ? y : c(2); };\" +\n+         \"}\",\n+         \"function f() {\" +\n+         \"  var g = function c(a) { return a ? 1 : c(1); };\" +\n+         \"  var d = function a(b) { return b ? 2 : a(2); };\" +\n+         \"  var h = function b(e) { return e ? d : b(2); };\" +\n+         \"}\");\n+  }\n+\n+  public void testRenameWithExterns1() {\n+    String externs = \"var foo;\";\n+    test(externs, \"var bar; foo(bar);\", \"var a; foo(a);\", null, null);\n+  }\n+\n+  public void testRenameWithExterns2() {\n+    String externs = \"var a;\";\n+    test(externs, \"var b = 5\", \"var b = 5\", null, null);\n+  }\n+\n+  public void testDoNotRenameExportedName() {\n+    test(\"_foo()\", \"_foo()\");\n+  }\n+\n+  public void testRenameWithNameOverlap() {\n+    test(\"var a = 1; var b = 2; b + b;\",\n+         \"var a = 1; var b = 2; b + b;\");\n+  }\n+\n+  public void testRenameWithPrefix1() {\n+    prefix = \"PRE_\";\n+    test(\"function Foo(v1, v2) {return v1} Foo();\",\n+        \"function PRE_(a, b) {return a} PRE_();\");\n+    prefix = DEFAULT_PREFIX;\n+\n+  }\n+\n+  public void testRenameWithPrefix2() {\n+    prefix = \"PRE_\";\n+    test(\"function Foo(v1, v2) {var v3 = v1 + v2; return v3;} Foo();\",\n+        \"function PRE_(a, b) {var c = a + b; return c;} PRE_();\");\n+    prefix = DEFAULT_PREFIX;\n+  }\n+\n+  public void testRenameWithPrefix3() {\n+    prefix = \"a\";\n+    test(\"function Foo() {return 1;}\" +\n+         \"function Bar() {\" +\n+         \"  var a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,\" +\n+         \"      A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z,aa,ab;\" +\n+         \"  Foo();\" +\n+         \"} Bar();\",\n+\n+        \"function a() {return 1;}\" +\n+         \"function aa() {\" +\n+         \"  var b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,A,\" +\n+         \"      B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z,$,ba,ca;\" +\n+         \"  a();\" +\n+         \"} aa();\");\n+    prefix = DEFAULT_PREFIX;\n+  }\n+\n+  public void testNamingBasedOnOrderOfOccurrence() {\n+    test(\"var q,p,m,n,l,k; \" +\n+             \"(function (r) {}); try { } catch(s) {}; var t = q + q;\",\n+         \"var a,b,c,d,e,f; \" +\n+             \"(function(g) {}); try { } catch(h) {}; var i = a + a;\"\n+         );\n+    test(\"(function(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z,\" +\n+         \"a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,$){});\" +\n+         \"var a4,a3,a2,a1,b4,b3,b2,b1,ab,ac,ad,fg;function foo(){};\",\n+         \"(function(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,\" +\n+         \"A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z,$){});\" +\n+         \"var aa,ba,ca,da,ea,fa,ga,ha,ia,ja,ka,la;function ma(){};\");\n+  }\n+\n+  public void testStableRenameSimple() {\n+    VariableMap expectedVariableMap = makeVariableMap(\n+        \"Foo\", \"a\", \"L 0\", \"b\", \"L 1\", \"c\");\n+    testRenameMap(\"function Foo(v1, v2) {return v1;} Foo();\",\n+                  \"function a(b, c) {return b;} a();\", expectedVariableMap);\n+\n+    expectedVariableMap = makeVariableMap(\n+        \"Foo\", \"a\", \"L 0\", \"b\", \"L 1\", \"c\", \"L 2\", \"d\");\n+    testRenameMapUsingOldMap(\"function Foo(v1, v2, v3) {return v1;} Foo();\",\n+         \"function a(b, c, d) {return b;} a();\", expectedVariableMap);\n+  }\n+\n+  public void testStableRenameGlobals() {\n+    VariableMap expectedVariableMap = makeVariableMap(\n+        \"Foo\", \"a\", \"Bar\", \"b\", \"y\", \"c\", \"x\", \"d\");\n+    testRenameMap(\"var Foo; var Bar, y; function x() { Bar++; }\",\n+                  \"var a; var b, c; function d() { b++; }\",\n+                  expectedVariableMap);\n+\n+    expectedVariableMap = makeVariableMap(\n+        \"Foo\", \"a\", \"Bar\", \"b\", \"y\", \"c\", \"x\", \"d\", \"Baz\", \"f\", \"L 0\" , \"e\");\n+    testRenameMapUsingOldMap(\n+        \"var Foo, Baz; var Bar, y; function x(R) { return R + Bar++; }\",\n+        \"var a, f; var b, c; function d(e) { return e + b++; }\",\n+        expectedVariableMap);\n+  }\n+\n+  public void testStableRenameWithPointlesslyAnonymousFunctions() {\n+    VariableMap expectedVariableMap = makeVariableMap(\"L 0\", \"a\", \"L 1\", \"b\");\n+    testRenameMap(\"(function (v1, v2) {}); (function (v3, v4) {});\",\n+                  \"(function (a, b) {}); (function (a, b) {});\",\n+                  expectedVariableMap);\n+\n+    expectedVariableMap = makeVariableMap(\"L 0\", \"a\", \"L 1\", \"b\", \"L 2\", \"c\");\n+    testRenameMapUsingOldMap(\"(function (v0, v1, v2) {});\" +\n+                             \"(function (v3, v4) {});\",\n+                             \"(function (a, b, c) {});\" +\n+                             \"(function (a, b) {});\",\n+                             expectedVariableMap);\n+  }\n+\n+  public void testStableRenameLocalsClashingWithGlobals() {\n+    test(\"function a(v1, v2) {return v1;} a();\",\n+         \"function a(b, c) {return b;} a();\");\n+    previouslyUsedMap = renameVars.getVariableMap();\n+    test(\"function bar(){return;}function a(v1, v2) {return v1;} a();\",\n+         \"function d(){return;}function a(b, c) {return b;} a();\");\n+  }\n+\n+  public void testStableRenameNested() {\n+    VariableMap expectedVariableMap = makeVariableMap(\n+        \"f1\", \"a\", \"L 0\", \"b\", \"L 1\", \"c\", \"L 2\", \"d\", \"L 3\", \"e\");\n+    testRenameMap(\"function f1(v1, v2) { (function(v3, v4) {}) }\",\n+                  \"function a(b, c) { (function(d, e) {}) }\",\n+                  expectedVariableMap);\n+\n+    expectedVariableMap = makeVariableMap(\n+        \"f1\", \"a\", \"L 0\", \"b\", \"L 1\", \"c\", \"L 2\", \"d\", \"L 3\", \"e\", \"L 4\", \"f\");\n+    testRenameMapUsingOldMap(\n+        \"function f1(v1, v2) { (function(v3, v4, v5) {}) }\",\n+        \"function a(b, c) { (function(d, e, f) {}) }\",\n+        expectedVariableMap);\n+  }\n+\n+  public void testStableRenameWithExterns1() {\n+    String externs = \"var foo;\";\n+    test(externs, \"var bar; foo(bar);\", \"var a; foo(a);\", null, null);\n+    previouslyUsedMap = renameVars.getVariableMap();\n+    test(externs, \"var bar, baz; foo(bar, baz);\",\n+         \"var a, b; foo(a, b);\", null, null);\n+  }\n+\n+  public void testStableRenameWithExterns2() {\n+    String externs = \"var a;\";\n+    test(externs, \"var b = 5\", \"var b = 5\", null, null);\n+    previouslyUsedMap = renameVars.getVariableMap();\n+    test(externs, \"var b = 5, catty = 9;\", \"var b = 5, c=9;\", null, null);\n+  }\n+\n+  public void testStableRenameWithNameOverlap() {\n+    test(\"var a = 1; var b = 2; b + b;\",\n+         \"var a = 1; var b = 2; b + b;\");\n+    previouslyUsedMap = renameVars.getVariableMap();\n+    test(\"var a = 1; var c, b = 2; b + b;\",\n+         \"var a = 1; var c, b = 2; b + b;\");\n+  }\n+\n+  public void testStableRenameWithAnonymousFunctions() {\n+    VariableMap expectedVariableMap = makeVariableMap(\"L 0\", \"a\", \"foo\", \"b\");\n+    testRenameMap(\"function foo(bar){return bar;}foo(function(h){return h;});\",\n+                  \"function b(a){return a}b(function(a){return a;})\",\n+                  expectedVariableMap);\n+\n+    expectedVariableMap = makeVariableMap(\"foo\", \"b\", \"L 0\", \"a\", \"L 1\", \"c\");\n+    testRenameMapUsingOldMap(\n+        \"function foo(bar) {return bar;}foo(function(g,h) {return g+h;});\",\n+        \"function b(a){return a}b(function(a,c){return a+c;})\",\n+        expectedVariableMap);\n+  }\n+\n+  public void testStableRenameSimpleExternsChanges() {\n+    VariableMap expectedVariableMap = makeVariableMap(\n+        \"Foo\", \"a\", \"L 0\", \"b\", \"L 1\", \"c\");\n+    testRenameMap(\"function Foo(v1, v2) {return v1;} Foo();\",\n+                  \"function a(b, c) {return b;} a();\", expectedVariableMap);\n+\n+    expectedVariableMap = makeVariableMap(\"L 0\", \"b\", \"L 1\", \"c\", \"L 2\", \"a\");\n+    String externs = \"var Foo;\";\n+    testRenameMapUsingOldMap(externs,\n+                             \"function Foo(v1, v2, v0) {return v1;} Foo();\",\n+                             \"function Foo(b, c, a) {return b;} Foo();\",\n+                             expectedVariableMap);\n+  }\n+\n+  public void testStableRenameSimpleLocalNameExterned() {\n+    test(\"function Foo(v1, v2) {return v1;} Foo();\",\n+         \"function a(b, c) {return b;} a();\");\n+\n+    previouslyUsedMap = renameVars.getVariableMap();\n+\n+    String externs = \"var b;\";\n+    test(externs, \"function Foo(v1, v2) {return v1;} Foo(b);\",\n+         \"function a(d, c) {return d;} a(b);\", null, null);\n+  }\n+\n+  public void testStableRenameSimpleGlobalNameExterned() {\n+    test(\"function Foo(v1, v2) {return v1;} Foo();\",\n+         \"function a(b, c) {return b;} a();\");\n+\n+    previouslyUsedMap = renameVars.getVariableMap();\n+\n+    String externs = \"var Foo;\";\n+    test(externs, \"function Foo(v1, v2, v0) {return v1;} Foo();\",\n+         \"function Foo(b, c, a) {return b;} Foo();\", null, null);\n+  }\n+\n+  public void testStableRenameWithPrefix1AndUnstableLocalNames() {\n+    prefix = \"PRE_\";\n+    test(\"function Foo(v1, v2) {return v1} Foo();\",\n+         \"function PRE_(a, b) {return a} PRE_();\");\n+\n+    previouslyUsedMap = renameVars.getVariableMap();\n+\n+    prefix = \"PRE_\";\n+    test(\"function Foo(v0, v1, v2) {return v1} Foo();\",\n+         \"function PRE_(a, b, c) {return b} PRE_();\");\n+  }\n+\n+  public void testStableRenameWithPrefix2() {\n+    prefix = \"a\";\n+    test(\"function Foo() {return 1;}\" +\n+         \"function Bar() {\" +\n+         \"  var a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,\" +\n+         \"      A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z,aa,ab;\" +\n+         \"  Foo();\" +\n+         \"} Bar();\",\n+\n+         \"function a() {return 1;}\" +\n+         \"function aa() {\" +\n+         \"  var b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,A,\" +\n+         \"      B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z,$,ba,ca;\" +\n+         \"  a();\" +\n+         \"} aa();\");\n+\n+    previouslyUsedMap = renameVars.getVariableMap();\n+\n+    prefix = \"a\";\n+    test(\"function Foo() {return 1;}\" +\n+         \"function Baz() {return 1;}\" +\n+         \"function Bar() {\" +\n+         \"  var a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,\" +\n+         \"      A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z,aa,ab;\" +\n+         \"  Foo();\" +\n+         \"} Bar();\",\n+\n+         \"function a() {return 1;}\" +\n+         \"function ab() {return 1;}\" +\n+         \"function aa() {\" +\n+         \"  var b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,A,\" +\n+         \"      B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z,$,ba,ca;\" +\n+         \"  a();\" +\n+         \"} aa();\");\n+  }\n+\n+  public void testContrivedExampleWhereConsistentRenamingIsWorse() {\n+    previouslyUsedMap = makeVariableMap(\n+        \"Foo\", \"LongString\", \"L 0\", \"b\", \"L 1\", \"c\");\n+\n+    test(\"function Foo(v1, v2) {return v1;} Foo();\",\n+         \"function LongString(b, c) {return b;} LongString();\");\n+\n+    previouslyUsedMap = renameVars.getVariableMap();\n+    VariableMap expectedVariableMap = makeVariableMap(\n+        \"Foo\", \"LongString\", \"L 0\", \"b\", \"L 1\", \"c\");\n+    assertVariableMapsEqual(expectedVariableMap, previouslyUsedMap);\n+  }\n+\n+  public void testPrevUsedMapWithDuplicates() {\n+    previouslyUsedMap = makeVariableMap(\"Foo\", \"z\", \"Bar\", \"z\");\n+    try {\n+      testSame(\"\");\n+      fail();\n+    } catch (java.lang.IllegalArgumentException expected) {\n+    }\n+  }\n+\n+  public void testExportSimpleSymbolReservesName() {\n+    test(\"var goog, x; goog.exportSymbol('a', x);\",\n+         \"var a, b; a.exportSymbol('a', b);\");\n+    withClosurePass = true;\n+    test(\"var goog, x; goog.exportSymbol('a', x);\",\n+         \"var b, c; b.exportSymbol('a', c);\");\n+  }\n+\n+  public void testExportComplexSymbolReservesName() {\n+    test(\"var goog, x; goog.exportSymbol('a.b', x);\",\n+         \"var a, b; a.exportSymbol('a.b', b);\");\n+    withClosurePass = true;\n+    test(\"var goog, x; goog.exportSymbol('a.b', x);\",\n+         \"var b, c; b.exportSymbol('a.b', c);\");\n+  }\n+\n+  public void testExportToNonStringDoesntExplode() {\n+    withClosurePass = true;\n+    test(\"var goog, a, b; goog.exportSymbol(a, b);\",\n+         \"var a, b, c; a.exportSymbol(b, c);\");\n+  }\n+\n+  public void testDollarSignSuperExport1() {\n+    useGoogleCodingConvention = false;\n+    // See http://code.google.com/p/closure-compiler/issues/detail?id=32\n+    test(\"var x = function($super,duper,$fantastic){}\",\n+         \"var c = function($super,    a,        b){}\");\n+\n+    localRenamingOnly = false;\n+    test(\"var $super = 1\", \"var a = 1\");\n+\n+    useGoogleCodingConvention = true;\n+    test(\"var x = function($super,duper,$fantastic){}\",\n+         \"var c = function($super,a,b){}\");\n+  }\n+\n+  public void testDollarSignSuperExport2() {\n+    withNormalize = true;\n+\n+    useGoogleCodingConvention = false;\n+    // See http://code.google.com/p/closure-compiler/issues/detail?id=32\n+    test(\"var x = function($super,duper,$fantastic){};\" +\n+            \"var y = function($super,duper){};\",\n+         \"var c = function($super,    a,         b){};\" +\n+            \"var d = function($super,    a){};\");\n+\n+    localRenamingOnly = false;\n+    test(\"var $super = 1\", \"var a = 1\");\n+\n+    useGoogleCodingConvention = true;\n+    test(\"var x = function($super,duper,$fantastic){};\" +\n+            \"var y = function($super,duper){};\",\n+         \"var c = function($super,   a,    b         ){};\" +\n+            \"var d = function($super,a){};\");\n+  }\n+\n+  public void testBias() {\n+    nameGenerator = new NameGenerator(new HashSet<String>(0), \"\", null);\n+    nameGenerator.favors(\"AAAAAAAAHH\");\n+    test(\"var x, y\", \"var A, H\");\n+  }\n+\n+  public void testPseudoNames() {\n+    generatePseudoNames = false;\n+    // See http://code.google.com/p/closure-compiler/issues/detail?id=32\n+    test(\"var foo = function(a, b, c){}\",\n+         \"var d = function(a, b, c){}\");\n+\n+    generatePseudoNames = true;\n+    test(\"var foo = function(a, b, c){}\",\n+         \"var $foo$$ = function($a$$, $b$$, $c$$){}\");\n+\n+    test(\"var a = function(a, b, c){}\",\n+         \"var $a$$ = function($a$$, $b$$, $c$$){}\");\n+  }\n+\n+  private void testRenameMapUsingOldMap(String input, String expected,\n+                                        VariableMap expectedMap) {\n+    previouslyUsedMap = renameVars.getVariableMap();\n+    testRenameMap(\"\", input, expected,  expectedMap);\n+  }\n+\n+  private void testRenameMapUsingOldMap(String externs, String input,\n+                                        String expected,\n+                                        VariableMap expectedMap) {\n+    previouslyUsedMap = renameVars.getVariableMap();\n+    testRenameMap(externs, input, expected,  expectedMap);\n+  }\n+\n+  private void testRenameMap(String input, String expected,\n+                             VariableMap expectedRenameMap) {\n+    testRenameMap(\"\", input, expected, expectedRenameMap);\n+  }\n+\n+  private void testRenameMap(String externs, String input, String expected,\n+                             VariableMap expectedRenameMap) {\n+    test(externs, input, expected, null, null);\n+    VariableMap renameMap = renameVars.getVariableMap();\n+    assertVariableMapsEqual(expectedRenameMap, renameMap);\n+  }\n+\n+  private VariableMap makeVariableMap(String... keyValPairs) {\n+    Preconditions.checkArgument(keyValPairs.length % 2 == 0);\n+\n+    ImmutableMap.Builder<String, String> renameMap = ImmutableMap.builder();\n+    for (int i = 0; i < keyValPairs.length; i += 2) {\n+      renameMap.put(keyValPairs[i], keyValPairs[i + 1]);\n+    }\n+\n+    return new VariableMap(renameMap.build());\n+  }\n+\n+  private static void assertVariableMapsEqual(VariableMap a, VariableMap b) {\n+    Map<String, String> ma = a.getOriginalNameToNewNameMap();\n+    Map<String, String> mb = b.getOriginalNameToNewNameMap();\n+    assertEquals(\"VariableMaps not equal\", ma, mb);\n+  }\n+\n+  private class ClosurePassAndRenameVars implements CompilerPass {\n+    private final Compiler compiler;\n+\n+    private ClosurePassAndRenameVars(Compiler compiler) {\n+      this.compiler = compiler;\n+    }\n+\n+    @Override\n+    public void process(Node externs, Node root) {\n+      ProcessClosurePrimitives closurePass =\n+          new ProcessClosurePrimitives(\n+              compiler, null, CheckLevel.WARNING);\n+      closurePass.process(externs, root);\n+      renameVars = new RenameVars(compiler, prefix,\n+          false, false, false, false, previouslyUsedMap, null,\n+          closurePass.getExportedVariableNames(), null);\n+      renameVars.process(externs, root);\n+    }\n+  }\n+\n+  private class NormalizePassWrapper implements CompilerPass {\n+    private final Compiler compiler;\n+    private final CompilerPass wrappedPass;\n+\n+    private NormalizePassWrapper(Compiler compiler,\n+        CompilerPass wrappedPass) {\n+      this.compiler = compiler;\n+      this.wrappedPass = wrappedPass;\n+    }\n+\n+    @Override\n+    public void process(Node externs, Node root) {\n+      Normalize normalize = new Normalize(compiler, false);\n+      normalize.process(externs, root);\n+\n+      wrappedPass.process(externs, root);\n+    }\n+  }\n+}\n--- /dev/null\n+++ b/test/com/google/javascript/jscomp/ShadowVariables2Test.java\n+/*\n+ * Copyright 2011 The Closure Compiler Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+/**\n+ * Unit tests for {@link ShadowVariables2}.\n+ *\n+ *\n+ */\n+public class ShadowVariables2Test extends CompilerTestCase{\n+  // Use pseudo names to make test easier to read.\n+  private boolean generatePseudoNames = false;\n+  private RenameVars pass = null;\n+\n+  @Override\n+  protected CompilerPass getProcessor(Compiler compiler) {\n+      pass = new RenameVars(\n+          compiler, \"\", false, false,\n+          generatePseudoNames, true, null, null, null, null);\n+      return  pass;\n+  }\n+\n+  @Override\n+  protected int getNumRepetitions() {\n+    return 1;\n+  }\n+\n+  @Override\n+  protected void setUp() throws Exception {\n+    super.setUp();\n+    generatePseudoNames = false;\n+  }\n+\n+  @Override\n+  protected void tearDown() throws Exception {\n+    super.tearDown();\n+    pass = null;\n+  }\n+\n+  public void testShadowSimple1() {\n+    test(\"function foo(x) { return function (y) {} }\",\n+         \"function   b(a) { return function (a) {} }\");\n+\n+    generatePseudoNames = true;\n+\n+    test(\"function  foo  ( x  ) { return function ( y  ) {} }\",\n+         \"function $foo$$($x$$) { return function ($x$$) {} }\");\n+\n+  }\n+\n+  public void testShadowSimple2() {\n+    test(\"function foo(x,y) { return function (y,z) {} }\",\n+         \"function   c(a,b) { return function (a,b) {} }\");\n+\n+    generatePseudoNames = true;\n+\n+    test(\"function  foo  ( x  , y  ) { return function ( y  , z  ) {} }\",\n+         \"function $foo$$($x$$,$y$$) { return function ($x$$,$y$$) {} }\");\n+  }\n+\n+  /**\n+   * If we have a choice, pick out the most used variable to shadow.\n+   */\n+  public void testShadowMostUsedVar() {\n+    generatePseudoNames = true;\n+    test(\"function  foo  () {var  x  ; var  y  ;  y  ; y  ; y  ; x  ;\" +\n+         \"  return function ( k  ) {} }\",\n+\n+         \"function $foo$$() {var $x$$; var $y$$; $y$$;$y$$;$y$$;$x$$;\" +\n+         \"  return function ($y$$) {} }\");\n+  }\n+\n+  public void testNoShadowReferencedVariables() {\n+    generatePseudoNames = true;\n+    test(\"function  f1  () { var  x  ; x  ; x  ; x  ;\" +\n+         \"  return function  f2  ( y  ) {\" +\n+         \"    return function  f3  () { x  } }}\",\n+         \"function $f1$$() { var $x$$;$x$$;$x$$;$x$$;\" +\n+         \"  return function $f2$$($y$$) {\" +\n+         \"    return function $f3$$() {$x$$} }}\");\n+  }\n+\n+  public void testNoShadowGlobalVariables() {\n+    generatePseudoNames = true;\n+    test(\"var  x  ;  x  ; function  foo  () { return function ( y  ) {}}\",\n+         \"var $x$$; $x$$; function $foo$$() { return function ($y$$) {}}\");\n+  }\n+\n+  public void testShadowBleedInFunctionName() {\n+    generatePseudoNames = true;\n+    test(\"function  foo  () { function  b  ( y  ) { y  }  b  ;  b  ;}\",\n+         \"function $foo$$() { function $b$$($b$$) {$b$$} $b$$; $b$$;}\");\n+   }\n+\n+  public void testNoShadowLessPopularName() {\n+    generatePseudoNames = true;\n+    // We make sure that y doesn't pick x as a shadow and remains to be renamed\n+    // to 'a'.\n+    // If we do shadow y with whatever x renames to (say b) we will\n+    // get 4 b's and 7 a's while currently we get 3 b's and 8 a's.\n+    // I believe this arrangement will always be better for gzipping.\n+    test(\"function  f1  ( x  ) {\" +\n+         \"  function  f2  ( y  ) {}  x  ; x  ;}\" +\n+         \"function  f3  ( i  ) {\" +\n+         \"  var  k  ; var  j  ; j  ; j  ; j  ; j  ; j  ; j  ;}\",\n+\n+         \"function $f1$$($x$$) {\" +\n+         \"  function $f2$$($y$$) {} $x$$;$x$$;}\" +\n+         \"function $f3$$($i$$) {\" +\n+         \"  var $k$$; var $j$$;$j$$;$j$$;$j$$;$j$$;$j$$;$j$$;}\");\n+  }\n+\n+  public void testShadowFunctionName() {\n+    generatePseudoNames = true;\n+    test(\"var  g   = function() {\" +\n+         \"  var  x  ; return function(){function  y  (){}}}\",\n+         \"var $g$$ = function() {\" +\n+         \"  var $x$$; return function(){function $x$$(){}}}\");\n+  }\n+\n+  public void testShadowLotsOfScopes1() {\n+    generatePseudoNames = true;\n+    test(\"var  g   = function( x  ) { return function() { return function() {\" +\n+         \" return function() { var  y   }}}}\",\n+         \"var $g$$ = function($x$$) { return function() { return function() {\" +\n+         \" return function() { var $x$$ }}}}\");\n+  }\n+\n+  public void testShadowLotsOfScopes2() {\n+    generatePseudoNames = true;\n+    // 'y' doesn't have a candidate to shadow due to upward referencing.\n+    test(\"var  g   = function( x  ) { return function( y  ) \" +\n+         \" {return function() {return function() {  x   }}}}\",\n+         \"var $g$$ = function($x$$) { return function($y$$) \" +\n+         \" {return function() {return function() { $x$$ }}}}\");\n+\n+    test(\"var  g   = function( x  ) { return function() \" +\n+        \" {return function( y  ) {return function() {  x   }}}}\",\n+        \"var $g$$ = function($x$$) { return function() \" +\n+        \" {return function($y$$) {return function() { $x$$ }}}}\");\n+\n+    test(\"var  g   = function( x  ) { return function() \" +\n+        \" {return function() {return function( y  ) {  x   }}}}\",\n+        \"var $g$$ = function($x$$) { return function() \" +\n+        \" {return function() {return function($y$$) { $x$$ }}}}\");\n+  }\n+\n+  public void testShadowLotsOfScopes3() {\n+    generatePseudoNames = true;\n+    // 'y' doesn't have a candidate to shadow due to upward referencing.\n+    test(\"var  g   = function( x  ) { return function() \" +\n+        \" {return function() {return function() {  x   }; var  y   }}}\",\n+        \"var $g$$ = function($x$$) { return function() \" +\n+        \" {return function() {return function() { $x$$ }; var $y$$}}}\");\n+    test(\"var  g   = function( x  ) { return function() \" +\n+        \" {return function() {return function() {  x   }}; var  y   }}\",\n+        \"var $g$$ = function($x$$) { return function() \" +\n+        \" {return function() {return function() { $x$$ }}; var $y$$}}\");\n+    test(\"var  g   = function( x  ) { return function() \" +\n+        \" {return function() {return function() {  x   }}}; var  y   }\",\n+        \"var $g$$ = function($x$$) { return function() \" +\n+        \" {return function() {return function() { $x$$ }}}; var $y$$}\");\n+  }\n+\n+  public void testShadowLotsOfScopes4() {\n+    // Make sure we do get the optimal shadowing scheme where\n+    test(\"var g = function(x) { return function() { return function() {\" +\n+         \" return function(){return function(){};var m};var n};var o}}\",\n+         \"var b = function(a) { return function() { return function() {\" +\n+         \" return function(){return function(){};var a};var a};var a}}\");\n+  }\n+\n+  public void testShadowLotsOfScopes5() {\n+    generatePseudoNames = true;\n+    test(\"var  g   = function( x  ) {\" +\n+         \" return function() { return function() {\" +\n+         \" return function() { return function() {\" +\n+         \"      x  }; o  };var  n  };var  o  };var  p  }\",\n+         \"var $g$$ = function($x$$) {\" +\n+         \" return function() { return function() {\" +\n+         \" return function() { return function() {\" +\n+         \"     $x$$};$o$$};var $p$$};var $o$$};var $p$$}\");\n+\n+    test(\"var  g   = function( x  ) {\" +\n+        \" return function() { return function() {\" +\n+        \" return function() { return function() {\" +\n+        \"      x  }; p  };var  n  };var  o  };var  p  }\",\n+        \"var $g$$ = function($x$$) {\" +\n+        \" return function() { return function() {\" +\n+        \" return function() { return function() {\" +\n+        \"     $x$$};$p$$};var $o$$};var $o$$};var $p$$}\");\n+  }\n+\n+  public void testShadowWithShadowAlready() {\n+    test(\"var g = function(x) { return function() { return function() {\" +\n+         \" return function(){return function(){x}};var p};var o};var p}\",\n+         \"var c = function(b) { return function() { return function() {\" +\n+         \" return function(){return function(){b}};var a};var a};var a}\");\n+\n+    test(\"var g = function(x) { return function() { return function() {\" +\n+         \" return function(){return function(){x};p};var p};var o};var p}\",\n+         \"var c = function(b) { return function() { return function() {\" +\n+         \" return function(){return function(){b};a};var a};var a};var a}\");\n+  }\n+\n+  public void testShadowBug1() {\n+    generatePseudoNames = true;\n+    test(\"function  f  ( x  ) { return function( y  ) {\" +\n+         \"    return function( x  ) {  x   +  y  ; }}}\",\n+         \"function $f$$($x$$) { return function($y$$) {\" +\n+         \"    return function($x$$) { $x$$ + $y$$; }}}\");\n+  }\n+\n+  public void testOptimal() {\n+    // A test for a case that wasn't optimal in a single pass algorithm.\n+    test(\"function f(x) { function g(y) { function h(x) {}}}\",\n+         \"function c(a) { function b(a) { function b(a) {}}}\");\n+  }\n+\n+  public void testSharingAcrossInnerScopes() {\n+    test(\"function f() {var f=function g(){g()}; var x=function y(){y()}}\",\n+         \"function c() {var d=function a(){a()}; var e=function b(){b()}}\");\n+    test(\"function f(x) { return x ? function(y){} : function(z) {} }\",\n+         \"function b(a) { return a ? function(a){} : function(a) {} }\");\n+  }\n+\n+  public void testExportedLocal1() {\n+    test(\"function f(a) { a();a();a(); return function($super){} }\",\n+         \"function b(a) { a();a();a(); return function($super){} }\");\n+  }\n+\n+  public void testExportedLocal2() {\n+    test(\"function f($super) { $super();$super(); return function(a){} }\",\n+         \"function a($super) { $super();$super(); return function(b){} }\");\n+  }\n+\n+  public void testRenameMapHasNoDuplicates() {\n+    test(\"function foo(x) { return function (y) {} }\",\n+         \"function   b(a) { return function (a) {} }\");\n+\n+    VariableMap vm = pass.getVariableMap();\n+    try {\n+      vm.getNewNameToOriginalNameMap();\n+    } catch (java.lang.IllegalArgumentException unexpected) {\n+      fail(\"Invalid VariableMap generated: \" +\n+           vm.getOriginalNameToNewNameMap().toString());\n+    }\n+  }\n+\n+  public void testBug4172539() {\n+    // All the planets must line up. When we look at the 2nd inner function,\n+    // y can shadow x, also m can shadow x as well. Now all that is left for\n+    // n to shadow is 'y'. Now because y has already shadowed x, the pseudo\n+    // name maps has already updated y gets $x$$. This mean n will be updated\n+    // with \"$x$$\" in the name map which is incorrect. That is the reason\n+    // why we can't update the pseudo name map on-the-fly.\n+\n+    generatePseudoNames = true;\n+    test(\"function f(x) {\" +\n+         \"  x;x;x;\" +\n+         \"  return function (y) { y; x };\" +\n+         \"  return function (y) {\" +\n+         \"    y;\" +\n+         \"    return function (m, n) {\" +\n+         \"       m;m;m;\" +\n+         \"    };\" +\n+         \"  };\" +\n+         \"}\",\n+\n+         \"function $f$$($x$$) {\" +\n+         \"  $x$$;$x$$;$x$$;\" +\n+         \"  return function ($y$$) { $y$$; $x$$ };\" +\n+         \"  return function ($x$$) {\" +\n+         \"    $x$$;\" +\n+         \"    return function ($x$$, $y$$) {\" +\n+         \"       $x$$;$x$$;$x$$;\" +\n+         \"    };\" +\n+         \"  };\" +\n+         \"}\");\n+  }\n+}", "timestamp": 1367254218, "metainfo": ""}