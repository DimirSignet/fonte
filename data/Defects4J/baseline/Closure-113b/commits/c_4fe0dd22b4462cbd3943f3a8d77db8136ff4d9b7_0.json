{"sha": "4fe0dd22b4462cbd3943f3a8d77db8136ff4d9b7", "log": "Don't eat the first token of the @return description. This is kind of a hack because it mixes the character stream up with the token stream, but it's probably more maintainable and has less overhead than trying to manage the description in the token stream (which is the \"pure-but-lots-of-work\" solution).  R=jschorr DELTA=58  (48 added, 7 deleted, 3 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=1178   ", "commit": "\n--- a/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\n+++ b/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\n                 case THIS:\n                 case TYPE:\n                 case TYPEDEF:\n-                  skipEOLs();\n                   lineno = stream.getLineno();\n                   charno = stream.getCharno();\n \n-                  token = next();\n-\n                   Node typeNode = null;\n-                  if (annotation == Annotation.RETURN &&\n-                      token != JsDocToken.LC) {\n+                  if (!lookAheadForTypeAnnotation() &&\n+                      annotation == Annotation.RETURN) {\n                     // If RETURN doesn't have a type annotation, record\n                     // it as the unknown type.\n                     typeNode = newNode(Token.QMARK);\n                   } else {\n+                    skipEOLs();\n+                    token = next();\n                     typeNode = parseAndRecordTypeNode(token, lineno, charno);\n                   }\n \n                           break;\n                         }\n \n-                        // *Update* the token to that after the type annotation.\n-                        token = current();\n-\n                         // Find the return's description (if applicable).\n                         if (jsdocBuilder.shouldParseDocumentation()) {\n                           ExtractionInfo returnDescriptionInfo =\n \n     // Read the content from the first line.\n     String line = stream.getRemainingJSDocLine();\n-\n     if (option != WhitespaceOption.PRESERVE) {\n       line = line.trim();\n     }\n   JSDocInfo getFileOverviewJSDocInfo() {\n     return fileOverviewJSDocInfo;\n   }\n+\n+  /**\n+   * Look ahead for a type annotation by advancing the character stream.\n+   * Does not modify the token stream.\n+   * This is kind of a hack, and is only necessary because we use the token\n+   * stream to parse types, but need the underlying character stream to get\n+   * JsDoc descriptions.\n+   * @return Whether we found a type annotation.\n+   */\n+  private boolean lookAheadForTypeAnnotation() {\n+    boolean matchedLc = false;\n+    int c;\n+    while (true) {\n+      c = stream.getChar();\n+      if (c == ' ') {\n+        continue;\n+      } else if (c == '{') {\n+        matchedLc = true;\n+        break;\n+      } else {\n+        break;\n+      }\n+    }\n+    stream.ungetChar(c);\n+    return matchedLc;\n+  }\n }\n--- a/src/com/google/javascript/jscomp/parsing/JsDocTokenStream.java\n+++ b/src/com/google/javascript/jscomp/parsing/JsDocTokenStream.java\n     stringBufferTop = N + 1;\n   }\n \n-  private void ungetChar(int c) {\n+  void ungetChar(int c) {\n     // can not unread past across line boundary\n     assert(!(ungetCursor != 0 && ungetBuffer[ungetCursor - 1] == '\\n'));\n     ungetBuffer[ungetCursor++] = c;\n--- a/test/com/google/javascript/jscomp/parsing/JsDocInfoParserTest.java\n+++ b/test/com/google/javascript/jscomp/parsing/JsDocInfoParserTest.java\n \n     assertAnnotationMarker(jsdoc, \"author\", 0, 0);\n     assertAnnotationMarker(jsdoc, \"param\", 1, 3);\n+  }\n+\n+  public void testParseWithMarkers5() throws Exception {\n+    JSDocInfo jsdoc =\n+        parse(\"@return some long \\n * multiline\" +\n+              \" \\n * description */\", true);\n+\n+    assertDocumentationInMarker(\n+        assertAnnotationMarker(jsdoc, \"return\", 0, 0),\n+        \"some long multiline description\", 8, 2, 15);\n+  }\n+\n+  public void testParseWithMarkers6() throws Exception {\n+    JSDocInfo jsdoc =\n+        parse(\"@param x some long \\n * multiline\" +\n+              \" \\n * description */\", true);\n+\n+    assertDocumentationInMarker(\n+        assertAnnotationMarker(jsdoc, \"param\", 0, 0),\n+        \"some long multiline description\", 8, 2, 15);\n   }\n \n   public void testParseWithMarkerNames1() throws Exception {", "timestamp": 1301507091, "metainfo": ""}