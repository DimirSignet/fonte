{"sha": "529825d574c49e4cdc183350ea90fdf4d1877582", "log": "Fix bit shift ranges to support logical shifts in the (INT32_MAX, UINT32_MAX) range. The compiler currently gives spurious warnings for obviously good logical shifts, e.g. (0xFF000000 >>> 24). ------------- Created by MOE: http://code.google.com/p/moe-java MOE_MIGRATED_REVID=50120206", "commit": "\n--- a/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\n+++ b/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\n \n       // check ranges.  We do not do anything that would clip the double to\n       // a 32-bit range, since the user likely does not intend that.\n-      if (!(lval >= Integer.MIN_VALUE && lval <= Integer.MAX_VALUE)) {\n+      if (lval < Integer.MIN_VALUE) {\n         report(BITWISE_OPERAND_OUT_OF_RANGE, left);\n         return n;\n       }\n-\n       // only the lower 5 bits are used when shifting, so don't do anything\n       // if the shift amount is outside [0,32)\n       if (!(rval >= 0 && rval < 32)) {\n         return n;\n       }\n \n-      // Convert the numbers to ints\n-      int lvalInt = (int) lval;\n-      if (lvalInt != lval) {\n-        report(FRACTIONAL_BITWISE_OPERAND, left);\n-        return n;\n-      }\n-\n       int rvalInt = (int) rval;\n       if (rvalInt != rval) {\n         report(FRACTIONAL_BITWISE_OPERAND, right);\n \n       switch (n.getType()) {\n         case Token.LSH:\n-          result = lvalInt << rvalInt;\n-          break;\n         case Token.RSH:\n-          result = lvalInt >> rvalInt;\n+          // Convert the numbers to ints\n+          if (lval > Integer.MAX_VALUE) {\n+            report(BITWISE_OPERAND_OUT_OF_RANGE, left);\n+            return n;\n+          }\n+          int lvalInt = (int) lval;\n+          if (lvalInt != lval) {\n+            report(FRACTIONAL_BITWISE_OPERAND, left);\n+            return n;\n+          }\n+          if (n.getType() == Token.LSH) {\n+            result = lvalInt << rvalInt;\n+          } else {\n+            result = lvalInt >> rvalInt;\n+          }\n           break;\n         case Token.URSH:\n           // JavaScript handles zero shifts on signed numbers differently than\n           // Java as an Java int can not represent the unsigned 32-bit number\n           // where JavaScript can so use a long here.\n-          long lvalLong = lvalInt & 0xffffffffL;\n-          result = lvalLong >>> rvalInt;\n+          long maxUint32 = 0xffffffffL;\n+          if (lval > maxUint32) {\n+            report(BITWISE_OPERAND_OUT_OF_RANGE, left);\n+            return n;\n+          }\n+          long lvalLong = (long) lval;\n+          if (lvalLong != lval) {\n+            report(FRACTIONAL_BITWISE_OPERAND, left);\n+            return n;\n+          }\n+          result = (lvalLong & maxUint32) >>> rvalInt;\n           break;\n         default:\n           throw new AssertionError(\"Unknown shift operator: \" +\n--- a/test/com/google/javascript/jscomp/PeepholeFoldConstantsTest.java\n+++ b/test/com/google/javascript/jscomp/PeepholeFoldConstantsTest.java\n     fold(\"x = -1 >>> 1\", \"x = 2147483647\"); // 0x7fffffff\n     fold(\"x = -1 >>> 0\", \"x = 4294967295\"); // 0xffffffff\n     fold(\"x = -2 >>> 0\", \"x = 4294967294\"); // 0xfffffffe\n+    fold(\"x = 0x90000000 >>> 28\", \"x = 9\");\n \n     testSame(\"3000000000 << 1\",\n          PeepholeFoldConstants.BITWISE_OPERAND_OUT_OF_RANGE);\n     testSame(\"1 << -1\",\n         PeepholeFoldConstants.SHIFT_AMOUNT_OUT_OF_BOUNDS);\n     testSame(\"3000000000 >> 1\",\n+        PeepholeFoldConstants.BITWISE_OPERAND_OUT_OF_RANGE);\n+    testSame(\"0x90000000 >> 28\",\n         PeepholeFoldConstants.BITWISE_OPERAND_OUT_OF_RANGE);\n     testSame(\"1 >> 32\",\n         PeepholeFoldConstants.SHIFT_AMOUNT_OUT_OF_BOUNDS);", "timestamp": 1375753463, "metainfo": ""}