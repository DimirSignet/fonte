{"sha": "8f4b174685e702b19e32a46eb6623d8a74ac79e1", "log": "An optimization pass for regular expression bodies.  I don't know about the overall utility of this, or how/whether it should be rolled out, but it saves between 3-6.5% pre-gzip and between 1.5-3% post-gzip on parsing code that I've been trying to aggressively minify.  R=acleung,johnlenz DELTA=3492  (3486 added, 1 deleted, 5 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=1861   ", "commit": "\n--- a/src/com/google/javascript/jscomp/CheckRegExp.java\n+++ b/src/com/google/javascript/jscomp/CheckRegExp.java\n package com.google.javascript.jscomp;\n \n import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n+import com.google.javascript.jscomp.regex.RegExpTree;\n import com.google.javascript.rhino.Token;\n import com.google.javascript.rhino.Node;\n \n /**\n  * Look for references to the global RegExp object that would cause\n- * regular expressions to be unoptimizable.\n+ * regular expressions to be unoptimizable, and checks that regular expressions\n+ * are syntactically valid.\n  *\n  * @author johnlenz@google.com (John Lenz)\n  */\n     DiagnosticType.warning(\"JSC_REGEXP_REFERENCE\",\n         \"References to the global RegExp object prevents \" +\n         \"optimization of regular expressions.\");\n+  static final DiagnosticType MALFORMED_REGEXP = DiagnosticType.warning(\n+        \"JSC_MALFORMED_REGEXP\",\n+        \"Malformed Regular Expression: {0}\");\n \n   private final AbstractCompiler compiler;\n   private boolean globalRegExpPropertiesUsed = false;\n           globalRegExpPropertiesUsed = true;\n         }\n       }\n+\n+    // Check the syntax of regular expression patterns.\n+    } else if (n.getType() == Token.REGEXP) {\n+      String pattern = n.getFirstChild().getString();\n+      String flags = n.getChildCount() == 2\n+          ? n.getLastChild().getString() : \"\";\n+      try {\n+        RegExpTree.parseRegExp(pattern, flags);\n+      } catch (IllegalArgumentException ex) {\n+        t.report(n, MALFORMED_REGEXP, ex.getMessage());\n+      }\n     }\n   }\n }\n--- a/src/com/google/javascript/jscomp/DiagnosticGroups.java\n+++ b/src/com/google/javascript/jscomp/DiagnosticGroups.java\n \n   public static DiagnosticGroup CHECK_REGEXP =\n       DiagnosticGroups.registerGroup(\"checkRegExp\",\n-          CheckRegExp.REGEXP_REFERENCE);\n+          CheckRegExp.REGEXP_REFERENCE,\n+          CheckRegExp.MALFORMED_REGEXP);\n \n   public static DiagnosticGroup CHECK_TYPES =\n       DiagnosticGroups.registerGroup(\"checkTypes\",\n--- a/src/com/google/javascript/jscomp/PeepholeRemoveDeadCode.java\n+++ b/src/com/google/javascript/jscomp/PeepholeRemoveDeadCode.java\n       Preconditions.checkState(block.getType() == Token.BLOCK);\n       if (block.hasChildren()) {\n         for (Node blockChild : block.children()) {\n-          int type = blockChild.getType();\n           // If this is a block with a labelless break, it is useless.\n           switch (blockChild.getType()) {\n             case Token.BREAK:\n--- /dev/null\n+++ b/src/com/google/javascript/jscomp/PeepholeSimplifyRegExp.java\n+/*\n+ * Copyright 2011 The Closure Compiler Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+import com.google.javascript.jscomp.regex.RegExpTree;\n+import com.google.javascript.rhino.Node;\n+import com.google.javascript.rhino.Token;\n+\n+/**\n+ * Simplifies regular expression patterns and flags.\n+ *\n+ */\n+class PeepholeSimplifyRegExp extends AbstractPeepholeOptimization {\n+\n+  @Override\n+  Node optimizeSubtree(Node subtree) {\n+    if (subtree.getType() == Token.REGEXP) {\n+      // Split regexp into pattern and flags.\n+      String pattern = subtree.getFirstChild().getString();\n+      String flags = subtree.getChildCount() == 2\n+          ? subtree.getLastChild().getString() : \"\";\n+      // Parse to an AST and optimize.\n+      RegExpTree regexTree;\n+      try {\n+        regexTree = RegExpTree.parseRegExp(pattern, flags);\n+      } catch (IllegalArgumentException ex) {\n+        // Warnings are propagated in the CheckRegExp pass.\n+        return subtree;\n+      }\n+      regexTree = regexTree.simplify(flags);\n+      // Decompose the AST.\n+      String literal = regexTree.toString();\n+      String newPattern = literal.substring(1, literal.length() - 1);\n+      // Remove unnecessary flags and order them consistently for gzip.\n+      String newFlags = (\n+          // The g flags cannot match or replace more than one instance if it is\n+          // anchored at the front and back as in /^foo$/ and if the anchors are\n+          // relative to the whole string.\n+          // But if the regex has capturing groups, then the match operator\n+          // would return capturing groups without the g flag.\n+          (flags.contains(\"g\")\n+           && (!RegExpTree.matchesWholeInput(regexTree, flags)\n+               || regexTree.hasCapturingGroup())\n+           ? \"g\" : \"\")\n+          // Remove the i flag if it doesn't have any effect.\n+          // E.g. /[a-z0-9_]/i -> /\\w/\n+          + (flags.contains(\"i\") && regexTree.isCaseSensitive() ? \"i\" : \"\")\n+          // If the regular expression contains no anchors, then the m flag has\n+          // no effect.\n+          + (flags.contains(\"m\") && regexTree.containsAnchor() ? \"m\" : \"\"));\n+      // Update the original if something was done.\n+      if (!(newPattern.equals(pattern) && newFlags.equals(flags))) {\n+        subtree.getFirstChild().setString(newPattern);\n+        if (!\"\".equals(newFlags)) {\n+          subtree.getLastChild().setString(newFlags);\n+        } else if (subtree.getChildCount() == 2) {\n+          subtree.getLastChild().detachFromParent();\n+        }\n+        reportCodeChange();\n+      }\n+    }\n+    return subtree;\n+  }\n+}\n--- /dev/null\n+++ b/test/com/google/javascript/jscomp/PeepholeSimplifyRegExpTest.java\n+/*\n+ * Copyright 2011 The Closure Compiler Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+import com.google.javascript.rhino.Node;\n+\n+public class PeepholeSimplifyRegExpTest extends CompilerTestCase {\n+\n+  public final void testWaysOfMatchingEmptyString() {\n+    testSame(\"/(?:)/\");\n+    test(\"/(?:)/i\", \"/(?:)/\");  // We can get rid of i flag when no letters.\n+    test(\"/.{0}/i\", \"/(?:)/\");\n+    test(\"/[^\\\\0-\\\\uffff]{0}/\", \"/(?:)/\");\n+    // Cannot get rid of capturing groups.\n+    testSame(\"/(){0}/\");\n+  }\n+\n+  public final void testCharsetOptimizations() {\n+    testSame(\"/./\");\n+    test(\"/[\\\\0-\\\\uffff]/\", \"/[\\\\S\\\\s]/\");\n+    test(\"/[^\\\\0-\\\\uffff]/\", \"/(?!)/\");\n+    test(\"/[^\\\\0-\\\\x40\\\\x42-\\\\uffff]/\", \"/A/\");\n+    test(\"/[0-9a-fA-F]/i\", \"/[\\\\da-f]/i\");\n+    test(\"/[0-9a-zA-Z_$]/i\", \"/[\\\\w$]/\");\n+    test(\"/[()*+\\\\-,]/g\", \"/[(--]/g\");\n+    test(\"/[()*+\\\\-,z]/g\", \"/[(--z]/g\");\n+    test(\"/[\\\\-\\\\.\\\\/0]/g\", \"/[--0]/g\");\n+    test(\"/[\\\\-\\\\.\\\\/0\\\\n]/g\", \"/[\\\\n\\\\--0]/g\");\n+    test(\"/[\\\\[\\\\\\\\\\\\]]/g\", \"/[[-\\\\]]/g\");\n+    test(\"/[\\\\[\\\\\\\\\\\\]\\\\^]/g\", \"/[[-^]/g\");\n+    test(\"/[\\\\^`_]/g\", \"/[\\\\^-`]/g\");\n+    test(\"/[^\\\\^`_]/g\", \"/[^^-`]/g\");\n+    test(\"/^(?=[^a-z])/i\", \"/^(?=[\\\\W\\\\d_])/\");\n+    test(\"/^[^a-z0-9]/i\", \"/^[\\\\W_]/\");\n+    test(\"/[0-FA-Z]/\", \"/[0-Z]/\");\n+    test(\"/[0-9]/\", \"/\\\\d/\");\n+    test(\"/[^0-9]/\", \"/\\\\D/\");\n+    testSame(\"/\\\\D/\");\n+    test(\"/[_a-z0-9]/i\", \"/\\\\w/\");\n+    test(\"/[0-9_a-z]/i\", \"/\\\\w/\");\n+    test(\"/[_a-z0-9]/\", \"/[\\\\d_a-z]/\");\n+    test(\"/[_E-Za-f0-9]/i\", \"/\\\\w/\");\n+    test(\"/[E-Za-f]/i\", \"/[a-z]/i\");\n+    test(\"/[_E-Za-f0-9]/\", \"/[\\\\dE-Z_a-f]/\");\n+    // Test case normalization.\n+    // U+00CA and U+00EA are E and e with ^ above\n+    test(\"/[\\\\u00ca\\\\u00ea]/\", \"/[\\\\xca\\\\xea]/\");\n+    test(\"/[\\\\u00ca\\\\u00ea]/i\", \"/\\\\xca/i\");\n+    // IE (at least 6, 7, and 8) do not include \\xA0 in \\s so when an author\n+    // explicitly includes it make sure it appears in the output.\n+    testSame(\"/^[\\\\s\\\\xa0]*$/\");\n+    test(\"/^(?:\\\\s|\\\\xA0)*$/\", \"/^[\\\\s\\\\xa0]*$/\");\n+  }\n+\n+  public final void testCharsetFixup() {\n+    testSame(\"/[a-z]/i\");\n+    // This is the case.  The below produces no output in squarefree.\n+    // (function () {\n+    //   // Runs to just before the letter 'a' and starts right after 'z'.\n+    //   var re = /[^\\0-`{-\\uffff]/i\n+    //   for (var i = 0; i < 0x10000; ++i) {\n+    //     var s = String.fromCharCode(i);\n+    //     if (re.test(s)) { print(s + ' : ' + s.charCodeAt(0).toString(16)); }\n+    //   }\n+    // })()\n+    test(\"/[^\\\\0-`{-\\\\uffff]/i\", \"/(?!)/\");\n+    // This looks a bit odd, but\n+    // /[^a-z]/i is the same as all non-word characters, all digits, and _ and\n+    // /[\\W\\d_]/ is the same length.\n+    test(\"/[^a-z]/i\", \"/[\\\\W\\\\d_]/\");\n+  }\n+\n+  public final void testGroups() {\n+    testSame(\"/foo(bar)baz/\");\n+  }\n+\n+  public final void testBackReferences() {\n+    testSame(\"/foo(bar)baz(?:\\\\1|\\\\x01)boo/\");\n+    // But when there is no group to refer to, then the back-reference *is*\n+    // the same as an octal escape.\n+    test(\"/foo(?:bar)baz(?:\\\\1|\\\\x01)boo/\", \"/foobarbaz\\\\x01boo/\");\n+    // \\\\8 is never an octal escape.  If there is no 8th group, then it\n+    // is the literal character '8'\n+    test(\"/foo(?:bar)baz(?:\\\\8|8)boo/\", \"/foobarbaz8boo/\");\n+    // \\10 can be a capturing group.\n+    test(\"/(1?)(2?)(3?)(4?)(5?)(6?)(7?)(8?)(9?)(A?)(B?)\"\n+         + \"\\\\12\\\\11\\\\10\\\\9\\\\8\\\\7\\\\6\\\\5\\\\4\\\\3\\\\2\\\\1\\\\0/\",\n+         \"/(1?)(2?)(3?)(4?)(5?)(6?)(7?)(8?)(9?)(A?)(B?)\"\n+         // \\\\12 does not match any group, so is treated as group 1 followed\n+         // by literal 2.\n+         + \"\\\\1(?:2)\\\\11\\\\10\\\\9\\\\8\\\\7\\\\6\\\\5\\\\4\\\\3\\\\2\\\\1\\\\0/\");\n+    // But \\1 should not be emitted followed by a digit un-parenthesized.\n+    test(\"/(1?)(2?)(3?)(4?)(5?)(6?)(7?)(8?)(9?)(A?)(B?)(?:\\\\1)0/\",\n+         \"/(1?)(2?)(3?)(4?)(5?)(6?)(7?)(8?)(9?)(A?)(B?)\\\\1(?:0)/\");\n+    // \\012 is never treated as a group even when there are 12 groups.\n+    test(\"/(1?)(2?)(3?)(4?)(5?)(6?)(7?)(8?)(9?)(A?)(B?)(C?)\"\n+         + \"\\\\012\\\\11\\\\10\\\\9\\\\8\\\\7\\\\6\\\\5\\\\4\\\\3\\\\2\\\\1\\\\0/\",\n+         \"/(1?)(2?)(3?)(4?)(5?)(6?)(7?)(8?)(9?)(A?)(B?)(C?)\"\n+         + \"\\\\n\\\\11\\\\10\\\\9\\\\8\\\\7\\\\6\\\\5\\\\4\\\\3\\\\2\\\\1\\\\0/\");\n+  }\n+\n+  public final void testSingleCharAlterations() {\n+    test(\"/a|B|c|D/i\", \"/[a-d]/i\");\n+    test(\"/a|B|c|D/\", \"/[BDac]/\");\n+    test(\"/a|[Bc]|D/\", \"/[BDac]/\");\n+    test(\"/[aB]|[cD]/\", \"/[BDac]/\");\n+    test(\"/a|B|c|D|a|B/i\", \"/[a-d]/i\");  // Duplicates.\n+    test(\"/a|A|/i\", \"/a?/i\");\n+  }\n+\n+  public final void testAlterations() {\n+    testSame(\"/foo|bar/\");\n+    test(\"/Foo|BAR/i\", \"/foo|bar/i\");\n+    test(\"/Foo||BAR/\", \"/Foo||BAR/\");\n+    test(\"/Foo|BAR|/\", \"/Foo|BAR|/\");\n+  }\n+\n+  public final void testNestedAlterations() {\n+    test(\"/foo|bar|(?:baz|boo)|far/\", \"/foo|bar|baz|boo|far/\");\n+  }\n+\n+  public final void testEscapeSequencesAndNonLatinChars() {\n+    test(\"/\\u1234/i\", \"/\\\\u1234/\");\n+    testSame(\"/\\\\u1234/\");\n+    test(\"/\\u00A0/\", \"/\\\\xa0/\");\n+    test(\"/\\\\u00A0/\", \"/\\\\xa0/\");\n+    test(\"/\\\\u00a0/\", \"/\\\\xa0/\");\n+  }\n+\n+  public final void testAnchors() {\n+    // m changes the meaning of anchors which is useless if there are none.\n+    testSame(\"/foo(?!$)/gm\");\n+    test(\"/./m\", \"/./\");\n+    test(\"/\\\\^/m\", \"/\\\\^/\");\n+    test(\"/[\\\\^]/m\", \"/\\\\^/\");\n+    testSame(\"/(^|foo)bar/\");\n+    testSame(\"/^.|.$/gm\");\n+    test(\"/foo(?=)$/m\", \"/foo$/m\");\n+    // We can get rid of the g when there are no capturing groups and the\n+    // pattern is fully anchored.\n+    test(\"/^foo$/g\", \"/^foo$/\");\n+  }\n+\n+  public final void testRepetitions() {\n+    testSame(\"/a*/\");\n+    testSame(\"/a+/\");\n+    testSame(\"/a+?/\");\n+    testSame(\"/a?/\");\n+    testSame(\"/a{6}/\");\n+    testSame(\"/a{4,}/\");\n+    testSame(\"/a{4,6}/\");\n+    testSame(\"/a{4,6}?/\");\n+    test(\"/(?:a?)?/\", \"/a?/\");\n+    test(\"/(?:a?)*/\", \"/a*/\");\n+    test(\"/(?:a*)?/\", \"/a*/\");\n+    test(\"/a(?:a*)?/\", \"/a+/\");\n+    test(\"/(?:a{2,3}){3,4}/\", \"/a{6,12}/\");\n+    test(\"/a{2,3}a{3,4}/\", \"/a{5,7}/\");\n+    testSame(\"/a{2,3}b{3,4}/\");\n+    test(\"/a*a*/\", \"/a*/\");\n+    test(\"/a+a+/\", \"/a{2,}/\");\n+    test(\"/a+a*/\", \"/a+/\");\n+    // In partial repetitions the open curly is treated literally.\n+    test(\"/a{/\", \"/a\\\\{/\");\n+    test(\"/a{}/\", \"/a\\\\{}/\");\n+    test(\"/a{,3}/\", \"/a\\\\{,3}/\");\n+    test(\"/a{x}/\", \"/a\\\\{x}/\");\n+    test(\"/a{-1}/\", \"/a\\\\{-1}/\");\n+    test(\"/a{3,1}/\", \"/a\\\\{3,1}/\");\n+  }\n+\n+  public final void testMoreCharsets() {\n+    test(\"var a = /[\\\\x00\\\\x22\\\\x26\\\\x27\\\\x3c\\\\x3e]/g\",\n+         \"var a = /[\\\\0\\\"&'<>]/g\");\n+    test(\"var b = /[\\\\x00\\\\x22\\\\x27\\\\x3c\\\\x3e]/g\",\n+         \"var b = /[\\\\0\\\"'<>]/g\");\n+    test(\"var c = /[\\\\x00\\\\x09-\\\\x0d \\\\x22\\\\x26\\\\x27\\\\x2d\\\\/\\\\x3c-\\\\x3e`\"\n+         + \"\\\\x85\\\\xa0\\\\u2028\\\\u2029]/g\",\n+         \"var c = /[\\\\0\\\\t-\\\\r \\\"&'/<->`\\\\x85\\\\xa0\\\\u2028\\\\u2029-]/g\");\n+    test(\"var d = /[\\\\x00\\\\x09-\\\\x0d \\\\x22\\\\x27\\\\x2d\\\\/\\\\x3c-\\\\x3e`\"\n+         + \"\\\\x85\\\\xa0\\\\u2028\\\\u2029]/g\",\n+         \"var d = /[\\\\0\\\\t-\\\\r \\\"'/<->`\\\\x85\\\\xa0\\\\u2028\\\\u2029-]/g\");\n+    test(\"var e = /[\\\\x00\\\\x08-\\\\x0d\\\\x22\\\\x26\\\\x27\\\\/\\\\x3c-\\\\x3e\\\\\\\\\"\n+         + \"\\\\x85\\\\u2028\\\\u2029]/g\",\n+         \"var e = /[\\\\0\\\\b-\\\\r\\\"&'/<->\\\\\\\\\\\\x85\\\\u2028\\\\u2029]/g\");\n+    test(\"var f = /[\\\\x00\\\\x08-\\\\x0d\\\\x22\\\\x24\\\\x26-\\\\/\\\\x3a\\\\x3c-\\\\x3f\"\n+         + \"\\\\x5b-\\\\x5e\\\\x7b-\\\\x7d\\\\x85\\\\u2028\\\\u2029]/g\",\n+         \"var f = /[\\\\0\\\\b-\\\\r\\\"$&-/:<-?[-^{-}\\\\x85\\\\u2028\\\\u2029]/g\");\n+    test(\"var g = /[\\\\x00\\\\x08-\\\\x0d\\\\x22\\\\x26-\\\\x2a\\\\/\\\\x3a-\\\\x3e@\\\\\\\\\"\n+         + \"\\\\x7b\\\\x7d\\\\x85\\\\xa0\\\\u2028\\\\u2029]/g\",\n+         \"var g = /[\\\\0\\\\b-\\\\r\\\"&-*/:->@\\\\\\\\{}\\\\x85\\\\xa0\\\\u2028\\\\u2029]/g\");\n+    test(\"var h = /^(?!-*(?:expression|(?:moz-)?binding))(?:[.#]?-?\"\n+         + \"(?:[_a-z0-9][_a-z0-9-]*)(?:-[_a-z][_a-z0-9-]*)*-?|-?\"\n+         + \"(?:[0-9]+(?:\\\\.[0-9]*)?|\\\\.[0-9])(?:[a-z]{1,2}|%)?|!important|)$/i\",\n+         \"var h = /^(?!-*(?:expression|(?:moz-)?binding))(?:[#.]?-?\"\n+         + \"\\\\w[\\\\w-]*(?:-[_a-z][\\\\w-]*)*-?|-?\"\n+         + \"(?:\\\\d+(?:\\\\.\\\\d*)?|\\\\.\\\\d)(?:[a-z]{1,2}|%)?|!important|)$/i\");\n+    test(\"var i = /^(?:(?:https?|mailto):|[^&:\\\\/?#]*(?:[\\\\/?#]|$))/i\",\n+         \"var i = /^(?:(?:https?|mailto):|[^#&/:?]*(?:[#/?]|$))/i\");\n+    test(\"var j = /^(?!style|on|action|archive|background|cite|classid\"\n+         + \"|codebase|data|dsync|href|longdesc|src|usemap)(?:[a-z0-9_$:-]*\"\n+         + \"|dir=(?:ltr|rtl))$/i\",\n+         \"var j = /^(?!style|on|action|archive|background|cite|classid\"\n+         + \"|codebase|data|dsync|href|longdesc|src|usemap)(?:[\\\\w$:-]*\"\n+         + \"|dir=(?:ltr|rtl))$/i\");\n+    test(\"var k = /^(?!script|style|title|textarea|xmp|no)[a-z0-9_$:-]*$/i\",\n+         \"var k = /^(?!script|style|title|textarea|xmp|no)[\\\\w$:-]*$/i\");\n+    test(\"var l = /<(?:!|\\\\/?[a-z])(?:[^>'\\\"]|\\\"[^\\\"]*\\\"|'[^']*')*>/gi\",\n+         \"var l = /<(?:!|\\\\/?[a-z])(?:[^\\\"'>]|\\\"[^\\\"]*\\\"|'[^']*')*>/gi\");\n+  }\n+\n+  public final void testMoreRegularExpression() {\n+    testSame(\"/\\\"/\");\n+    testSame(\"/'/\");\n+    test(\"/(?:[^<\\\\/\\\"'\\\\s\\\\\\\\]|<(?!\\\\/script))+/i\",\n+         \"/(?:[^\\\\s\\\"'/<\\\\\\\\]|<(?!\\\\/script))+/i\");\n+    testSame(\"/-->/\");\n+    testSame(\"/<!--/\");\n+    testSame(\"/<\\\\/(\\\\w+)\\\\b/\");\n+    testSame(\"/<\\\\/?/\");\n+    test(\"/<script(?=[\\\\s>\\\\/]|$)/i\", \"/<script(?=[\\\\s/>]|$)/i\");\n+    test(\"/<style(?=[\\\\s>\\\\/]|$)/i\", \"/<style(?=[\\\\s/>]|$)/i\");\n+    test(\"/<textarea(?=[\\\\s>\\\\/]|$)/i\", \"/<textarea(?=[\\\\s/>]|$)/i\");\n+    test(\"/<title(?=[\\\\s>\\\\/]|$)/i\", \"/<title(?=[\\\\s/>]|$)/i\");\n+    test(\"/<xmp(?=[\\\\s>\\\\/]|$)/i\", \"/<xmp(?=[\\\\s/>]|$)/i\");\n+    testSame(\"/[\\\"']/\");\n+    test(\"/[\\\\\\\\)\\\\s]/\", \"/[\\\\s)\\\\\\\\]/\");\n+    test(\"/[\\\\f\\\\r\\\\n\\\\u2028\\\\u2029]/\", \"/[\\\\n\\\\f\\\\r\\\\u2028\\\\u2029]/\");\n+    test(\"/[\\\\n\\\\r\\\\f]/\", \"/[\\\\n\\\\f\\\\r]/\");\n+    testSame(\"/\\\\*\\\\//\");\n+    testSame(\"/\\\\//\");\n+    testSame(\"/\\\\/\\\\*/\");\n+    testSame(\"/\\\\/\\\\//\");\n+    testSame(\"/\\\\\\\\(?:\\\\r\\\\n?|[\\\\n\\\\f\\\"])/\");\n+    testSame(\"/\\\\\\\\(?:\\\\r\\\\n?|[\\\\n\\\\f'])/\");\n+    testSame(\"/\\\\burl\\\\s*\\\\(\\\\s*([\\\"']?)/i\");\n+    testSame(\"/\\\\s+/\");\n+    test(\"/^(?:[^'\\\\\\\\\\\\n\\\\r\\\\u2028\\\\u2029<]|\\\\\\\\(?:\\\\r\\\\n?|[^\\\\r<]\"\n+         + \"|<(?!\\\\/script))|<(?!\\\\/script))/i\",\n+         \"/^(?:[^\\\\n\\\\r'<\\\\\\\\\\\\u2028\\\\u2029]|\\\\\\\\(?:\\\\r\\\\n?|[^\\\\r<]\"\n+         + \"|<(?!\\\\/script))|<(?!\\\\/script))/i\");\n+    test(\"/^(?:[^\\\\\\\"\\\\\\\\\\\\n\\\\r\\\\u2028\\\\u2029<]|\\\\\\\\(?:\\\\r\\\\n?\"\n+         + \"|[^\\\\r<]|<(?!\\\\/script))|<(?!\\\\/script))/i\",\n+         \"/^(?:[^\\\\n\\\\r\\\"<\\\\\\\\\\\\u2028\\\\u2029]|\\\\\\\\(?:\\\\r\\\\n?\"\n+         + \"|[^\\\\r<]|<(?!\\\\/script))|<(?!\\\\/script))/i\");\n+    test(\"/^(?:[^\\\\[\\\\\\\\\\\\/<\\\\n\\\\r\\\\u2028\\\\u2029]|\\\\\\\\[^\\\\n\\\\r\\\\u2028\\\\u2029]\"\n+         + \"|\\\\\\\\?<(?!\\\\/script)|\\\\[(?:[^\\\\]\\\\\\\\<\\\\n\\\\r\\\\u2028\\\\u2029]|\"\n+         + \"\\\\\\\\(?:[^\\\\n\\\\r\\\\u2028\\\\u2029]))*|\\\\\\\\?<(?!\\\\/script)\\\\])/i\",\n+         \"/^(?:[^\\\\n\\\\r/<[\\\\\\\\\\\\u2028\\\\u2029]|\\\\\\\\.\"\n+         + \"|\\\\\\\\?<(?!\\\\/script)|\\\\[(?:[^\\\\n\\\\r<\\\\\\\\\\\\]\\\\u2028\\\\u2029]|\"\n+         + \"\\\\\\\\.)*|\\\\\\\\?<(?!\\\\/script)])/i\");\n+    testSame(\"/^(?=>|\\\\s+[\\\\w-]+\\\\s*=)/\");\n+    test(\"/^(?=[\\\\/\\\\s>])/\", \"/^(?=[\\\\s/>])/\");\n+    test(\"/^(?=[^\\\"'\\\\s>])/\", \"/^(?=[^\\\\s\\\"'>])/\");\n+    testSame(\"/^/\");\n+    testSame(\"/^[^<]+/\");\n+    test(\"/^[a-z0-9:-]*(?:[a-z0-9]|$)/i\", \"/^[\\\\d:a-z-]*(?:[^\\\\W_]|$)/i\");\n+    testSame(\"/^[a-z]+/i\");\n+    testSame(\"/^\\\\s*\\\"/\");\n+    testSame(\"/^\\\\s*'/\");\n+    testSame(\"/^\\\\s*([a-z][\\\\w-]*)/i\");\n+    testSame(\"/^\\\\s*=/\");\n+    testSame(\"/^\\\\s*\\\\/?>/\");\n+    testSame(\"/^\\\\s+$/\");\n+    testSame(\"/^\\\\s+/\");\n+  }\n+\n+  public final void testPrecedence() {\n+    // Repetition binds more tightly than concatenation.\n+    testSame(\"/ab?/\");\n+    testSame(\"/(?:ab)?/\");\n+    // Concatenation bind more tightly than alterations.\n+    testSame(\"/foo|bar/\");\n+    testSame(\"/f(?:oo|ba)r/\");\n+  }\n+\n+  public final void testMalformedRegularExpressions() {\n+    test(\n+        \"/(?<!foo)/\", \"/(?<!foo)/\",  // Lookbehind not valid in ES.\n+        null,  // No error.\n+        CheckRegExp.MALFORMED_REGEXP);  // Warning.\n+    test(\n+        \"/(/\", \"/(/\",\n+        null,  // No error.\n+        CheckRegExp.MALFORMED_REGEXP);  // Warning.\n+    test(\n+        \"/)/\", \"/)/\",\n+        null,  // No error.\n+        CheckRegExp.MALFORMED_REGEXP);  // Warning.\n+    test(\n+        \"/\\\\uabc/\", \"/\\\\uabc/\",\n+        null,  // No error.\n+        CheckRegExp.MALFORMED_REGEXP);  // Warning.\n+    test(\n+        \"/\\\\uabcg/\", \"/\\\\uabcg/\",\n+        null,  // No error.\n+        CheckRegExp.MALFORMED_REGEXP);  // Warning.\n+  }\n+\n+  @Override\n+  protected CompilerPass getProcessor(Compiler compiler) {\n+    final CompilerPass simplifier = new PeepholeOptimizationsPass(\n+        compiler, new PeepholeSimplifyRegExp());\n+    final CompilerPass checker = new CheckRegExp(compiler);\n+\n+    return new CompilerPass() {\n+      @Override\n+      public void process(Node externs, Node root) {\n+        checker.process(externs, root);\n+        simplifier.process(externs, root);\n+      }\n+    };\n+  }\n+}\n--- /dev/null\n+++ b/test/com/google/javascript/jscomp/regex/CharRangesTest.java\n+/*\n+ * Copyright 2011 The Closure Compiler Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp.regex;\n+\n+import java.util.BitSet;\n+import java.util.Random;\n+\n+import com.google.javascript.jscomp.regex.CharRanges;\n+\n+import junit.framework.TestCase;\n+\n+public class CharRangesTest extends TestCase {\n+\n+  static final long SEED = Long.parseLong(System.getProperty(\n+      \"junit.random.seed\", \"\" + System.currentTimeMillis()));\n+\n+  public final void testAgainstRegularImplementation() {\n+    Random rnd = new Random(SEED);\n+\n+    for (int run = 10; --run >= 0;) {\n+      // Fill with bits in the range [0x1000, 0x3000).\n+      BitSet bs = new BitSet();\n+      for (int i = 0x1000; --i >= 0;) {\n+        bs.set(0x1000 + rnd.nextInt(0x3000));\n+      }\n+\n+      // Create an equivalent sparse bit set\n+      int[] members = new int[bs.cardinality()];\n+      for (int i = -1, k = 0; k < members.length; ++k) {\n+        members[k] = i = bs.nextSetBit(i + 1);\n+      }\n+      CharRanges sbs = CharRanges.withMembers(members);\n+\n+      // Check all bits including past the min/max bit\n+      for (int i = 0; i < 0x5000; ++i) {\n+        if (bs.get(i) != sbs.contains(i)) {\n+          fail(\"sbs=\" + sbs + \", bs=\" + bs + \", difference at bit \" + i);\n+        }\n+      }\n+    }\n+  }\n+\n+  public final void testEmptyCharRanges() {\n+    CharRanges sbs = CharRanges.EMPTY;\n+    for (int i = -1000; i < 1000; ++i) {\n+      assertFalse(sbs.contains(i));\n+    }\n+    assertEquals(\"[]\", sbs.toString());\n+  }\n+\n+  public final void testCharRangesFactories() {\n+    CharRanges isbs = CharRanges.withMembers(new int[] { 0, 1, 4, 9 });\n+    CharRanges isbs2 = CharRanges.withMembers(new int[] { 0, 1, 4, 9 });\n+    assertEquals(\"[0x0-0x1 0x4 0x9]\", isbs.toString());\n+\n+    CharRanges esbs = CharRanges.withMembers(new int[0]);\n+\n+    assertEquals(isbs, isbs);\n+    assertEquals(isbs, isbs2);\n+    assertFalse(isbs.equals(esbs));\n+    assertFalse(isbs.equals(null));\n+    assertFalse(isbs.equals(new Object()));\n+\n+    assertEquals(isbs.hashCode(), isbs2.hashCode());\n+    assertFalse(isbs.hashCode() == esbs.hashCode());\n+  }\n+\n+  public final void testRangeConstructor() {\n+    try {\n+      CharRanges.withRanges(new int[] { 1 });\n+      fail(\"Mismatched ranges\");\n+    } catch (IllegalArgumentException ex) {\n+      // pass\n+    }\n+\n+    try {\n+      CharRanges.withRanges(new int[] { 1, 4, 4, 5 });\n+      fail(\"Discontiguous ranges\");\n+    } catch (IllegalArgumentException ex) {\n+      // pass\n+    }\n+\n+    try {\n+      CharRanges.withRanges(new int[] { 4, 5, 1, 3 });\n+      fail(\"Misordered ranges\");\n+    } catch (IllegalArgumentException ex) {\n+      // pass\n+    }\n+\n+    try {\n+      CharRanges.withRanges(new int[] { 0, 0 });\n+      fail(\"Empty range\");\n+    } catch (IllegalArgumentException ex) {\n+      // pass\n+    }\n+  }\n+\n+  public final void testDupeMembers() {\n+    CharRanges sbs1 = CharRanges.withMembers(new int[] { 0, 1, 4, 9 });\n+    assertEquals(sbs1.toString(), \"[0x0-0x1 0x4 0x9]\", sbs1.toString());\n+\n+    CharRanges sbs2 = CharRanges.withMembers(new int[] { 9, 1, 4, 1, 0 });\n+    assertEquals(sbs2.toString(), \"[0x0-0x1 0x4 0x9]\", sbs2.toString());\n+\n+    assertEquals(sbs1, sbs2);\n+    assertEquals(sbs1.hashCode(), sbs2.hashCode());\n+\n+    for (int i = -10; i < 20; ++i) {\n+      assertEquals(\"\" + i, sbs1.contains(i), sbs2.contains(i));\n+    }\n+  }\n+\n+  public final void testDifference() {\n+    //                     1               2               3\n+    //     0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0\n+    // b-a  DD         DD DDD        D      DDD\n+    // a      AAAAAAAAA      A A A A   A AAA   AAA A A\n+    // b    BBB  BBB  BBB BBB        B B    BBB\n+    // a-b     DD   DD       D D D D     DDD   DDD D D\n+    CharRanges a = CharRanges.withRanges(new int[] {\n+        0x03, 0x0C, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19,\n+        0x1C, 0x1D, 0x1E, 0x21, 0x24, 0x27, 0x28, 0x29, 0x2A, 0x2B });\n+    CharRanges b = CharRanges.withRanges(new int[] {\n+        0x01, 0x04, 0x06, 0x09, 0x0B, 0x0E, 0x0F, 0x12, 0x1A, 0x1B,\n+        0x1C, 0x1D, 0x21, 0x24 });\n+    CharRanges empty = CharRanges.withMembers(new int[0]);\n+\n+    assertEquals(empty, empty.union(empty));\n+    assertEquals(a, a.union(empty));\n+    assertEquals(b, empty.union(b));\n+\n+    CharRanges aSb = a.difference(b);\n+    assertEquals(\n+        \"[0x4-0x5 0x9-0xa 0x12 0x14 0x16 0x18 0x1e-0x20 0x24-0x26 0x28 0x2a]\",\n+        aSb.toString());\n+    assertTrue(a.containsAll(aSb));\n+    assertFalse(aSb.containsAll(a));\n+    assertFalse(aSb.containsAll(b));\n+\n+    CharRanges bSa = b.difference(a);\n+    assertEquals(\n+        \"[0x1-0x2 0xc-0xd 0xf-0x11 0x1a 0x21-0x23]\",\n+        bSa.toString());\n+    assertTrue(b.containsAll(bSa));\n+    assertFalse(bSa.containsAll(a));\n+    assertFalse(bSa.containsAll(b));\n+\n+    // Check that a and b not changed by operation\n+    assertEquals(\n+        \"[0x3-0xb 0x12 0x14 0x16 0x18 0x1c 0x1e-0x20 0x24-0x26 0x28 0x2a]\",\n+        a.toString());\n+    assertEquals(\n+        \"[0x1-0x3 0x6-0x8 0xb-0xd 0xf-0x11 0x1a 0x1c 0x21-0x23]\",\n+        b.toString());\n+\n+    //    0 1 2 3 4 5 6 7 8 9 a b c d e f\n+    // m: * * * *     *     * *       * *\n+    // s:     *     * * *     * *   * *\n+    // d: * *   *           *           *\n+    CharRanges m = CharRanges.withMembers(0, 1, 2, 3, 6, 9, 0xa, 0xe, 0xf);\n+    CharRanges s = CharRanges.withMembers(2, 5, 6, 7, 0xa, 0xb, 0xd, 0xe);\n+    CharRanges d = m.difference(s);\n+    assertEquals(\"[0x0-0x1 0x3 0x9 0xf]\", d.toString());\n+    assertTrue(m.containsAll(d));\n+    assertFalse(d.containsAll(m));\n+    assertFalse(d.containsAll(s));\n+    assertFalse(s.containsAll(d));\n+    assertTrue(d.containsAll(d));\n+  }\n+\n+  public final void testUnion() {\n+    //                 1               2               3\n+    // 0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0\n+    //    AAAAAAAAA      A A A A   A AAA   AAA A A\n+    //  BBB  BBB  BBB BBB        B B    BBB\n+    //  UUUUUUUUUUUUU UUUU U U U U U UUUUUUUUU U U\n+    CharRanges a = CharRanges.withRanges(new int[] {\n+        0x03, 0x0C, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19,\n+        0x1C, 0x1D, 0x1E, 0x21, 0x24, 0x27, 0x28, 0x29, 0x2A, 0x2B });\n+    CharRanges b = CharRanges.withRanges(new int[] {\n+        0x01, 0x04, 0x06, 0x09, 0x0B, 0x0E, 0x0F, 0x12, 0x1A, 0x1B,\n+        0x1C, 0x1D, 0x21, 0x24 });\n+    CharRanges empty = CharRanges.withMembers(new int[0]);\n+\n+    assertEquals(empty, empty.union(empty));\n+    assertEquals(a, a.union(empty));\n+    assertEquals(b, empty.union(b));\n+\n+    CharRanges aUb = a.union(b);\n+    assertEquals(\n+        \"[0x1-0xd 0xf-0x12 0x14 0x16 0x18 0x1a 0x1c 0x1e-0x26 0x28 0x2a]\",\n+        aUb.toString());\n+    assertEquals(aUb, b.union(a));\n+    assertTrue(aUb.containsAll(a));\n+    assertTrue(aUb.containsAll(b));\n+    assertFalse(a.containsAll(b));\n+    assertFalse(b.containsAll(a));\n+    assertTrue(a.containsAll(a));\n+    assertTrue(b.containsAll(b));\n+    assertTrue(aUb.containsAll(aUb));\n+\n+    // Check that a and b not changed by operation\n+    assertEquals(\n+        \"[0x3-0xb 0x12 0x14 0x16 0x18 0x1c 0x1e-0x20 0x24-0x26 0x28 0x2a]\",\n+        a.toString());\n+    assertEquals(\n+        \"[0x1-0x3 0x6-0x8 0xb-0xd 0xf-0x11 0x1a 0x1c 0x21-0x23]\",\n+        b.toString());\n+  }\n+}", "timestamp": 1305241600, "metainfo": ""}