{"sha": "d04e35ac538138591feca94e109f27b8e09434b4", "log": "Add owner-based type signature for bind.  Notice that this type signature isn't complete. The problem is that the return type of bind() depends on the number of arguments passed to it. e.g., if 'f' is a 3-argument function, and you call it with 2 arguments, then it returns a 1-argument function.  But this gets us most of the way there.  R=johnlenz DELTA=65  (44 added, 0 deleted, 21 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=3992   ", "commit": "\n--- a/src/com/google/javascript/rhino/jstype/FunctionType.java\n+++ b/src/com/google/javascript/rhino/jstype/FunctionType.java\n   @Override\n   public JSType getPropertyType(String name) {\n     if (!hasOwnProperty(name)) {\n-      if (\"call\".equals(name)) {\n-        // Define the \"call\" function lazily.\n-        Node params = getParametersNode();\n-        if (params == null) {\n-          // If there's no params array, don't do any type-checking\n-          // in this CALL function.\n-          defineDeclaredProperty(name,\n-              new FunctionBuilder(registry)\n-              .withReturnType(getReturnType())\n-              .build(),\n-              source);\n-        } else {\n-          params = params.cloneTree();\n+      // Define the \"call\", \"apply\", and \"bind\" functions lazily.\n+      boolean isCall = \"call\".equals(name);\n+      boolean isBind = \"bind\".equals(name);\n+      if (isCall || isBind) {\n+        // Notice that \"call\" and \"bind\" have the same argument signature,\n+        // except that all the arguments of \"bind\" (except the first)\n+        // are optional.\n+        FunctionBuilder builder = new FunctionBuilder(registry)\n+            .withReturnType(\n+                isCall ?\n+                getReturnType() :\n+                (new FunctionBuilder(registry)\n+                    .withReturnType(getReturnType()).build()));\n+\n+        Node origParams = getParametersNode();\n+        if (origParams != null) {\n+          Node params = origParams.cloneTree();\n+\n           Node thisTypeNode = Node.newString(Token.NAME, \"thisType\");\n           thisTypeNode.setJSType(\n               registry.createOptionalNullableType(getTypeOfThis()));\n           params.addChildToFront(thisTypeNode);\n-          thisTypeNode.setOptionalArg(true);\n-\n-          defineDeclaredProperty(name,\n-              new FunctionBuilder(registry)\n-              .withParamsNode(params)\n-              .withReturnType(getReturnType())\n-              .build(),\n-              source);\n+          thisTypeNode.setOptionalArg(isCall);\n+\n+          if (isBind) {\n+            // The arguments of bind() are unique in that they are all\n+            // optional but not undefinable.\n+            for (Node current = thisTypeNode.getNext();\n+                 current != null; current = current.getNext()) {\n+              current.setOptionalArg(true);\n+            }\n+          }\n+\n+          builder.withParamsNode(params);\n         }\n+\n+        defineDeclaredProperty(name, builder.build(), source);\n       } else if (\"apply\".equals(name)) {\n         // Define the \"apply\" function lazily.\n         FunctionParamBuilder builder = new FunctionParamBuilder(registry);\n--- a/test/com/google/javascript/jscomp/CompilerTypeTestCase.java\n+++ b/test/com/google/javascript/jscomp/CompilerTypeTestCase.java\n       \"/** @constructor \\n * @param {*} var_args */ \" +\n       \"function Function(var_args) {}\" +\n       \"/** @type {!Function} */ Function.prototype.apply;\" +\n+      \"/** @type {!Function} */ Function.prototype.bind;\" +\n       \"/** @type {!Function} */ Function.prototype.call;\" +\n       \"/** @constructor \\n * @param {*} arg \\n @return {string} */\" +\n       \"function String(arg) {}\" +\n--- a/test/com/google/javascript/jscomp/TypeCheckTest.java\n+++ b/test/com/google/javascript/jscomp/TypeCheckTest.java\n         \"var Foo = function(handler, opt_context) { \" +\n         \"  handler.apply(opt_context, x);\" +\n         \"};\");\n+  }\n+\n+  public void testFunctionBind1() throws Exception {\n+    testTypes(\n+        \"/** @type {function(string, number): boolean} */\" +\n+        \"function f(x, y) { return true; }\" +\n+        \"f.bind(null, 3);\",\n+        \"actual parameter 2 of f.bind does not match formal parameter\\n\" +\n+        \"found   : number\\n\" +\n+        \"required: string\");\n+  }\n+\n+  public void testFunctionBind2() throws Exception {\n+    testTypes(\n+        \"/** @type {function(number): boolean} */\" +\n+        \"function f(x) { return true; }\" +\n+        \"f(f.bind(null, 3)());\",\n+        \"actual parameter 1 of f does not match formal parameter\\n\" +\n+        \"found   : boolean\\n\" +\n+        \"required: number\");\n   }\n \n   public void testCast2() throws Exception {\n--- a/test/com/google/javascript/rhino/jstype/FunctionTypeTest.java\n+++ b/test/com/google/javascript/rhino/jstype/FunctionTypeTest.java\n \n     Asserts.assertEquivalenceOperations(fn, loop);\n   }\n+\n+  public void testBindSignature() {\n+    FunctionType fn = new FunctionBuilder(registry)\n+        .withTypeOfThis(DATE_TYPE)\n+        .withParamsNode(registry.createParameters(STRING_TYPE, NUMBER_TYPE))\n+        .withReturnType(BOOLEAN_TYPE).build();\n+\n+    assertEquals(\n+        \"function ((Date|null|undefined), string, number):\" +\n+        \" function (...[?]): boolean\",\n+        fn.getPropertyType(\"bind\").toString());\n+  }\n }", "timestamp": 1324069535, "metainfo": ""}