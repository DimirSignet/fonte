{"sha": "67316ef8d729bd17c510c5498a55a497de6f728e", "log": "Create references for parameter names in jsdoc  R=jschorr DELTA=128  (118 added, 0 deleted, 10 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=3304   ", "commit": "\n--- a/src/com/google/javascript/jscomp/SymbolTable.java\n+++ b/src/com/google/javascript/jscomp/SymbolTable.java\n import com.google.common.collect.Sets;\n import com.google.common.collect.Table;\n import com.google.javascript.rhino.JSDocInfo;\n+import com.google.javascript.rhino.JSDocInfo.Marker;\n import com.google.javascript.rhino.Node;\n+import com.google.javascript.rhino.SourcePosition;\n import com.google.javascript.rhino.Token;\n import com.google.javascript.rhino.jstype.FunctionType;\n import com.google.javascript.rhino.jstype.JSType;\n   }\n \n   /**\n+   * If {@code sym} is a function, try to find a Symbol for\n+   * a parameter with the given name.\n+   *\n+   * Returns null if we couldn't find one.\n+   *\n+   * Notice that this just makes a best effort, and may not be able\n+   * to find parameters for non-conventional function definitions.\n+   * For example, we would not be able to find \"y\" in this code:\n+   * <code>\n+   * var x = x() ? function(y) {} : function(y) {};\n+   * </code>\n+   */\n+  public Symbol getParameterInFunction(Symbol sym, String paramName) {\n+    SymbolScope scope = getScopeInFunction(sym);\n+    if (scope != null) {\n+      Symbol param = scope.getSlot(paramName);\n+      if (param != null && param.scope == scope) {\n+        return param;\n+      }\n+    }\n+    return null;\n+  }\n+\n+  private SymbolScope getScopeInFunction(Symbol sym) {\n+    FunctionType type = sym.getFunctionType();\n+    if (type == null) {\n+      return null;\n+    }\n+\n+    Node functionNode = type.getSource();\n+    if (functionNode == null) {\n+      return null;\n+    }\n+\n+    return scopes.get(functionNode);\n+  }\n+\n+  /**\n    * All local scopes are associated with a function, and some functions\n    * are associated with a symbol. Returns the symbol associated with the given\n    * scope.\n     NodeTraversal.traverseRoots(\n         compiler, Lists.newArrayList(externs, root),\n         new JSDocInfoCollector(compiler.getTypeRegistry()));\n+\n+    // Create references to parameters in the JSDoc.\n+    for (Symbol sym : getAllSymbols()) {\n+      JSDocInfo info = sym.getJSDocInfo();\n+      if (info == null) {\n+        continue;\n+      }\n+\n+      for (Marker marker : info.getMarkers()) {\n+        SourcePosition<Node> pos = marker.getNameNode();\n+        if (pos == null) {\n+          continue;\n+        }\n+\n+        Node paramNode = pos.getItem();\n+        Symbol param = getParameterInFunction(sym, paramNode.getString());\n+        if (param != null) {\n+          param.defineReferenceAt(paramNode);\n+        }\n+      }\n+    }\n   }\n \n   private void createPropertyScopeFor(Symbol s) {\n         // Find references in the JSDocInfo.\n         JSDocInfo info = n.getJSDocInfo();\n         docInfos.add(info);\n+\n         for (Node typeAst : info.getTypeNodes()) {\n           SymbolScope scope = scopes.get(t.getScopeRoot());\n           visitTypeNode(scope == null ? globalScope : scope, typeAst);\n--- a/src/com/google/javascript/rhino/JSDocInfo.java\n+++ b/src/com/google/javascript/rhino/JSDocInfo.java\n   }\n \n   /**\n-   * A piece of information in a marker containing a position with a string.\n+   * A piece of information (found in a marker) which contains a position\n+   * with a string.\n    */\n   public static class StringPosition extends SourcePosition<String> {\n   }\n \n   /**\n-   * A piece of information in a marker containing a position with a string\n-   * that has no leading or trailing whitespace.\n+   * A piece of information (found in a marker) which contains a position\n+   * with a string that has no leading or trailing whitespace.\n    */\n   static class TrimmedStringPosition extends StringPosition {\n     @Override public void setItem(String item) {\n   }\n \n   /**\n-   * A piece of information in a marker containing a position with a type.\n+   * A piece of information (found in a marker) which contains a position\n+   * with a name node.\n+   */\n+  public static class NamePosition extends SourcePosition<Node> {}\n+\n+  /**\n+   * A piece of information (found in a marker) which contains a position\n+   * with a type expression syntax tree.\n    */\n   public static class TypePosition extends SourcePosition<Node> {\n     private boolean brackets = false;\n   public static final class Marker {\n     private TrimmedStringPosition annotation = null;\n     private TrimmedStringPosition name = null;\n+    private SourcePosition<Node> nameNode = null;\n     private StringPosition description = null;\n     private TypePosition type = null;\n \n     /**\n-     * Gets the position info for the annotation name (e.g., \"@see\").\n+     * Gets the position information for the annotation name. (e.g., \"param\")\n      */\n     public StringPosition getAnnotation() {\n       return annotation;\n     }\n \n     /**\n-     * Gets the position info for parameter name of a @param tag.\n+     * Gets the position information for the name found\n+     * in a @param tag.\n+     * @deprecated Use #getNameNode\n      */\n+    @Deprecated\n     public StringPosition getName() {\n       return name;\n     }\n     }\n \n     /**\n-     * Gets the position info for the description part of a block tag.\n+     * Gets the position information for the name found\n+     * in an @param tag.\n+     */\n+    public SourcePosition<Node> getNameNode() {\n+      return nameNode;\n+    }\n+\n+    void setNameNode(SourcePosition<Node> p) {\n+      nameNode = p;\n+    }\n+\n+    /**\n+     * Gets the position information for the description found\n+     * in a block tag.\n      */\n     public StringPosition getDescription() {\n       return description;\n     }\n \n     /**\n-     * Gets the position info for the type expression of a block tag.\n+     * Gets the position information for the type expression found\n+     * in some block tags, like \"@param\" and \"@return\".\n      */\n     public TypePosition getType() {\n       return type;\n--- a/src/com/google/javascript/rhino/JSDocInfoBuilder.java\n+++ b/src/com/google/javascript/rhino/JSDocInfoBuilder.java\n package com.google.javascript.rhino;\n \n import com.google.javascript.rhino.JSDocInfo.Visibility;\n+import com.google.javascript.rhino.Token;\n \n import java.util.Set;\n \n    */\n   public void markName(String name, int lineno, int charno) {\n     if (currentMarker != null) {\n+      // Record the name as both a SourcePosition<String> and a\n+      // SourcePosition<Node>. The <String> form is deprecated,\n+      // because <Node> is more consistent with how other name\n+      // references are handled (see #markTypeNode)\n+      //\n+      // TODO(nicksantos): Remove all uses of the Name position\n+      // and replace them with the NameNode position.\n       JSDocInfo.TrimmedStringPosition position =\n           new JSDocInfo.TrimmedStringPosition();\n       position.setItem(name);\n       position.setPositionInformation(lineno, charno,\n           lineno, charno + name.length());\n       currentMarker.setName(position);\n+\n+      SourcePosition<Node> nodePos =\n+          new JSDocInfo.NamePosition();\n+      Node node = Node.newString(Token.NAME, name, lineno, charno);\n+      node.setLength(name.length());\n+      nodePos.setItem(node);\n+      nodePos.setPositionInformation(lineno, charno,\n+          lineno, charno + name.length());\n+      currentMarker.setNameNode(nodePos);\n     }\n   }\n \n--- a/test/com/google/javascript/jscomp/SymbolTableTest.java\n+++ b/test/com/google/javascript/jscomp/SymbolTableTest.java\n     assertEquals(\"Foo.prototype\", refs.get(0).getNode().getQualifiedName());\n   }\n \n-  public void testReferencesInJSDoc() {\n+  public void testReferencesInJSDocType() {\n     SymbolTable table = createSymbolTable(\n         \"/** @constructor */ function Foo() {}\\n\" +\n         \"/** @type {Foo} */ var x;\\n\" +\n     assertEquals(13, refs.get(4).getNode().getCharno());\n   }\n \n-  public void testReferencesInJSDoc2() {\n+  public void testReferencesInJSDocType2() {\n     SymbolTable table = createSymbolTable(\n         \"/** @param {string} x */ function f(x) {}\\n\");\n     Symbol str = getGlobalVar(table, \"String\");\n       Reference ref = refs.get(i);\n       assertEquals(i != last, ref.getNode().isFromExterns());\n     }\n+  }\n+\n+  public void testReferencesInJSDocName() {\n+    String code = \"/** @param {Object} x */ function f(x) {}\\n\";\n+    SymbolTable table = createSymbolTable(code);\n+    Symbol x = getLocalVar(table, \"x\");\n+    assertNotNull(x);\n+\n+    List<Reference> refs = Lists.newArrayList(table.getReferences(x));\n+    assertEquals(2, refs.size());\n+\n+    assertEquals(code.indexOf(\"x) {\"), refs.get(0).getNode().getCharno());\n+    assertEquals(code.indexOf(\"x */\"), refs.get(1).getNode().getCharno());\n   }\n \n   private Symbol getGlobalVar(SymbolTable table, String name) {", "timestamp": 1316547247, "metainfo": ""}