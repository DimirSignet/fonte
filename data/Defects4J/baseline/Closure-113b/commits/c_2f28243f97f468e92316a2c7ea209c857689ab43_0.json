{"sha": "2f28243f97f468e92316a2c7ea209c857689ab43", "log": "RFC: An AST builder helper class.  This class has two goals: 1) have a simpler method of building the AST for those new to the compiler. 2) create a more readable AST construction. Rather than something like: Node fn = new Node(Token.FUNCTION, Node.newString(Token.NAME, \"fn\"), new Node(Token.PARAM_LIST, new Node(Token.NAME, \"a\"), new Node(Token.NAME, \"b\")),new Node(Token.BLOCK)); you would have: Node fn = function(name(\"fn\"), paramList(name(\"a\"),name(\"b\")), block());  The intent is that the the referencing class will have a \"import static Ast.*\".  R=nicksantos DELTA=560  (560 added, 0 deleted, 0 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=3726   ", "commit": "\n--- /dev/null\n+++ b/src/com/google/javascript/rhino/IR.java\n+/*\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   John Lenz\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package com.google.javascript.rhino;\n+\n+import com.google.common.base.Preconditions;\n+\n+/**\n+ * An AST construction helper class\n+ * @author johnlenz@google.com (John Lenz)\n+ */\n+public class IR {\n+\n+  private IR() {}\n+\n+  public static Node empty() {\n+    return new Node(Token.EMPTY);\n+  }\n+\n+  public static Node function(Node name, Node params, Node body) {\n+    Preconditions.checkState(name.isName());\n+    Preconditions.checkState(params.isParamList());\n+    Preconditions.checkState(body.isBlock());\n+    return new Node(Token.FUNCTION, name, params, body);\n+  }\n+\n+  public static Node paramList() {\n+    return new Node(Token.PARAM_LIST);\n+  }\n+\n+  public static Node paramList(Node param) {\n+    Preconditions.checkState(param.isName());\n+    return new Node(Token.PARAM_LIST, param);\n+  }\n+\n+  public static Node paramList(Node ... params) {\n+    Node paramList = new Node(Token.PARAM_LIST);\n+    for (Node param : params) {\n+      Preconditions.checkState(param.isName());\n+      paramList.addChildToBack(param);\n+    }\n+    return paramList;\n+  }\n+\n+  public static Node block() {\n+    Node block = new Node(Token.BLOCK);\n+    return block;\n+  }\n+\n+  public static Node block(Node stmt) {\n+    Preconditions.checkState(mayBeStatement(stmt));\n+    Node block = new Node(Token.BLOCK, stmt);\n+    return block;\n+  }\n+\n+  public static Node block(Node ... stmts) {\n+    Node block = new Node(Token.BLOCK);\n+    for (Node stmt : stmts) {\n+      Preconditions.checkState(mayBeStatement(stmt));\n+      block.addChildToBack(stmt);\n+    }\n+    return block;\n+  }\n+\n+  public static Node script(Node ... stmts) {\n+    // TODO(johnlenz): finish setting up the SCRIPT node\n+    Node block = new Node(Token.SCRIPT);\n+    for (Node stmt : stmts) {\n+      Preconditions.checkState(mayBeStatement(stmt));\n+      block.addChildToBack(stmt);\n+    }\n+    return block;\n+  }\n+\n+  public static Node var(Node name, Node value) {\n+    Preconditions.checkState(name.isName() && !name.hasChildren());\n+    Preconditions.checkState(mayBeExpression(value));\n+    name.addChildToFront(value);\n+    return var(name);\n+  }\n+\n+  public static Node var(Node name) {\n+    Preconditions.checkState(name.isName());\n+    return new Node(Token.VAR, name);\n+  }\n+\n+  public static Node returnNode() {\n+    return new Node(Token.RETURN);\n+  }\n+\n+  public static Node returnNode(Node expr) {\n+    Preconditions.checkState(mayBeExpression(expr));\n+    return new Node(Token.RETURN, expr);\n+  }\n+\n+  public static Node throwNode(Node expr) {\n+    Preconditions.checkState(mayBeExpression(expr));\n+    return new Node(Token.THROW, expr);\n+  }\n+\n+  public static Node exprResult(Node expr) {\n+    Preconditions.checkState(mayBeExpression(expr));\n+    return new Node(Token.EXPR_RESULT, expr);\n+  }\n+\n+  public static Node ifNode(Node cond, Node then) {\n+    Preconditions.checkState(mayBeExpression(cond));\n+    Preconditions.checkState(then.isBlock());\n+    return new Node(Token.IF, cond, then);\n+  }\n+\n+  public static Node ifNode(Node cond, Node then, Node elseNode) {\n+    Preconditions.checkState(mayBeExpression(cond));\n+    Preconditions.checkState(then.isBlock());\n+    Preconditions.checkState(elseNode.isBlock());\n+    return new Node(Token.IF, cond, then, elseNode);\n+  }\n+\n+  public static Node doNode(Node body, Node cond) {\n+    Preconditions.checkState(body.isBlock());\n+    Preconditions.checkState(mayBeExpression(cond));\n+    return new Node(Token.DO, body, cond);\n+  }\n+\n+  public static Node forIn(Node target, Node cond, Node body) {\n+    Preconditions.checkState(target.isVar() || mayBeExpression(target));\n+    Preconditions.checkState(mayBeExpression(cond));\n+    Preconditions.checkState(body.isBlock());\n+    return new Node(Token.FOR, target, cond, body);\n+  }\n+\n+  public static Node forNode(Node init, Node cond, Node incr, Node body) {\n+    Preconditions.checkState(init.isVar() || mayBeExpressionOrEmpty(init));\n+    Preconditions.checkState(mayBeExpressionOrEmpty(cond));\n+    Preconditions.checkState(mayBeExpressionOrEmpty(incr));\n+    Preconditions.checkState(body.isBlock());\n+    return new Node(Token.FOR, init, cond, incr, body);\n+  }\n+\n+  public static Node switchNode(Node cond, Node ... cases) {\n+    Preconditions.checkState(mayBeExpression(cond));\n+    Node switchNode = new Node(Token.SWITCH, cond);\n+    for (Node caseNode : cases) {\n+      Preconditions.checkState(caseNode.isCase() || caseNode.isDefaultCase());\n+      switchNode.addChildToBack(caseNode);\n+    }\n+    return switchNode;\n+  }\n+\n+  public static Node caseNode(Node expr, Node body) {\n+    Preconditions.checkState(mayBeExpression(expr));\n+    Preconditions.checkState(body.isBlock());\n+    body.putBooleanProp(Node.SYNTHETIC_BLOCK_PROP, true);\n+    return new Node(Token.CASE, expr, body);\n+  }\n+\n+  public static Node defaultCase(Node body) {\n+    Preconditions.checkState(body.isBlock());\n+    body.putBooleanProp(Node.SYNTHETIC_BLOCK_PROP, true);\n+    return new Node(Token.DEFAULT_CASE, body);\n+  }\n+\n+  public static Node label(Node name, Node stmt) {\n+    // TODO(johnlenz): additional validation here.\n+    Preconditions.checkState(name.isLabelName());\n+    Preconditions.checkState(mayBeStatement(stmt));\n+    Node block = new Node(Token.LABEL, name, stmt);\n+    return block;\n+  }\n+\n+  public static Node labelName(String name) {\n+    Preconditions.checkState(!name.isEmpty());\n+    return Node.newString(Token.LABEL_NAME, name);\n+  }\n+\n+  public static Node tryFinally(Node tryBody, Node finallyBody) {\n+    Preconditions.checkState(tryBody.isLabelName());\n+    Preconditions.checkState(finallyBody.isLabelName());\n+    Node catchBody = block().copyInformationFrom(tryBody);\n+    return new Node(Token.TRY, tryBody, catchBody, finallyBody);\n+  }\n+\n+  public static Node tryCatch(Node tryBody, Node catchNode) {\n+    Preconditions.checkState(tryBody.isBlock());\n+    Preconditions.checkState(catchNode.isCatch());\n+    Node catchBody = block(catchNode).copyInformationFrom(catchNode);\n+    return new Node(Token.TRY, tryBody, catchBody);\n+  }\n+\n+  public static Node tryCatchFinally(Node tryBody, Node catchNode, Node finallyBody) {\n+    Preconditions.checkState(finallyBody.isBlock());\n+    Node tryNode = tryCatch(tryBody, catchNode);\n+    tryNode.addChildToBack(finallyBody);\n+    return tryNode;\n+  }\n+\n+  public static Node catchNode(Node expr, Node body) {\n+    Preconditions.checkState(expr.isName());\n+    Preconditions.checkState(body.isBlock());\n+    return new Node(Token.CATCH, expr, body);\n+  }\n+\n+  public static Node breakNode() {\n+    return new Node(Token.BREAK);\n+  }\n+\n+  public static Node breakNode(Node name) {\n+    // TODO(johnlenz): additional validation here.\n+    Preconditions.checkState(name.isLabelName());\n+    return new Node(Token.BREAK, name);\n+  }\n+\n+  public static Node continueNode() {\n+    return new Node(Token.CONTINUE);\n+  }\n+\n+  public static Node continueNode(Node name) {\n+    // TODO(johnlenz): additional validation here.\n+    Preconditions.checkState(name.isLabelName());\n+    return new Node(Token.CONTINUE, name);\n+  }\n+\n+\n+  //\n+\n+  public static Node call(Node target, Node ... args) {\n+    Node call = new Node(Token.CALL, target);\n+    for (Node arg : args) {\n+      Preconditions.checkState(mayBeExpression(arg));\n+      call.addChildToBack(arg);\n+    }\n+    return call;\n+  }\n+\n+  public static Node newNode(Node target, Node ... args) {\n+    Node newcall = new Node(Token.NEW, target);\n+    for (Node arg : args) {\n+      Preconditions.checkState(mayBeExpression(arg));\n+      newcall.addChildToBack(arg);\n+    }\n+    return newcall;\n+  }\n+\n+  public static Node name(String name) {\n+    return Node.newString(Token.NAME, name);\n+  }\n+\n+  public static Node getprop(Node target, Node prop) {\n+    Preconditions.checkState(mayBeExpression(target));\n+    Preconditions.checkState(prop.isString());\n+    return new Node(Token.GETPROP, target, prop);\n+  }\n+\n+  public static Node getelem(Node target, Node elem) {\n+    Preconditions.checkState(mayBeExpression(target));\n+    Preconditions.checkState(mayBeExpression(elem));\n+    return new Node(Token.GETELEM, target, elem);\n+  }\n+\n+  public static Node assign(Node target, Node expr) {\n+    Preconditions.checkState(isAssignmentTarget(target));\n+    Preconditions.checkState(mayBeExpression(expr));\n+    return new Node(Token.ASSIGN, target, expr);\n+  }\n+\n+  public static Node hook(Node cond, Node trueval, Node falseval) {\n+    Preconditions.checkState(mayBeExpression(cond));\n+    Preconditions.checkState(mayBeExpression(trueval));\n+    Preconditions.checkState(mayBeExpression(falseval));\n+    return new Node(Token.HOOK, cond, trueval, falseval);\n+  }\n+\n+  public static Node comma(Node expr1, Node expr2) {\n+    return binaryOp(Token.COMMA, expr1, expr2);\n+  }\n+\n+  public static Node and(Node expr1, Node expr2) {\n+    return binaryOp(Token.AND, expr1, expr2);\n+  }\n+\n+  public static Node or(Node expr1, Node expr2) {\n+    return binaryOp(Token.OR, expr1, expr2);\n+  }\n+\n+  public static Node not(Node expr1) {\n+    return unaryOp(Token.NOT, expr1);\n+  }\n+\n+  /**\n+   * \"==\"\n+   */\n+  public static Node eq(Node expr1, Node expr2) {\n+    return binaryOp(Token.EQ, expr1, expr2);\n+  }\n+\n+  /**\n+   * \"===\"\n+   */\n+  public static Node sheq(Node expr1, Node expr2) {\n+    return binaryOp(Token.SHEQ, expr1, expr2);\n+  }\n+\n+  public static Node voidNode(Node expr1) {\n+    return unaryOp(Token.VOID, expr1);\n+  }\n+\n+  public static Node neg(Node expr1) {\n+    return unaryOp(Token.NEG, expr1);\n+  }\n+\n+  public static Node pos(Node expr1) {\n+    return unaryOp(Token.POS, expr1);\n+  }\n+\n+  public static Node add(Node expr1, Node expr2) {\n+    return binaryOp(Token.ADD, expr1, expr2);\n+  }\n+\n+  public static Node sub(Node expr1, Node expr2) {\n+    return binaryOp(Token.SUB, expr1, expr2);\n+  }\n+\n+  // TODO(johnlenz): the rest of the ops\n+\n+  // literals\n+  public static Node objectlit(Node ... propdefs) {\n+    Node objectlit = new Node(Token.OBJECTLIT);\n+    for (Node propdef : propdefs) {\n+      Preconditions.checkState(\n+          propdef.isString() || propdef.isGetterDef() || propdef.isSetterDef());\n+      Preconditions.checkState(propdef.hasOneChild());\n+      objectlit.addChildToBack(propdef);\n+    }\n+    return objectlit;\n+  }\n+\n+  // TODO(johnlenz): quoted props\n+\n+  public static Node propdef(Node string, Node value) {\n+    Preconditions.checkState(!string.isString());\n+    Preconditions.checkState(!string.hasChildren());\n+    Preconditions.checkState(mayBeExpression(value));\n+    string.addChildToFront(value);\n+    return string;\n+  }\n+\n+  public static Node arraylit(Node ... exprs) {\n+    Node arraylit = new Node(Token.ARRAYLIT);\n+    for (Node expr : exprs) {\n+      Preconditions.checkState(mayBeExpressionOrEmpty(expr));\n+      arraylit.addChildToBack(expr);\n+    }\n+    return arraylit;\n+  }\n+\n+  public static Node regexp(Node expr) {\n+    Preconditions.checkState(expr.isString());\n+    return new Node(Token.REGEXP, expr);\n+  }\n+\n+  public static Node regexp(Node expr, Node flags) {\n+    Preconditions.checkState(expr.isString());\n+    Preconditions.checkState(flags.isString());\n+    return new Node(Token.REGEXP, expr, flags);\n+  }\n+\n+  public static Node string(String s) {\n+    return Node.newString(s);\n+  }\n+\n+  public static Node number(double d) {\n+    return Node.newNumber(d);\n+  }\n+\n+  public static Node trueNode() {\n+    return new Node(Token.TRUE);\n+  }\n+\n+  public static Node falseNode() {\n+    return new Node(Token.FALSE);\n+  }\n+\n+  public static Node nullNode() {\n+    return new Node(Token.NULL);\n+  }\n+\n+  // helper methods\n+\n+  private static Node binaryOp(int token, Node expr1, Node expr2) {\n+    Preconditions.checkState(mayBeExpression(expr1));\n+    Preconditions.checkState(mayBeExpression(expr2));\n+    return new Node(token, expr1, expr2);\n+  }\n+\n+  private static Node unaryOp(int token, Node expr) {\n+    Preconditions.checkState(mayBeExpression(expr));\n+    return new Node(token, expr);\n+  }\n+\n+  private static boolean mayBeExpressionOrEmpty(Node n) {\n+    return n.isEmpty() || mayBeExpression(n);\n+  }\n+\n+  private static boolean isAssignmentTarget(Node n) {\n+    return n.isName() || n.isGetProp() || n.isGetElem();\n+  }\n+\n+  // NOTE: some nodes are neither statements nor expression nodes:\n+  //   SCRIPT, LABEL_NAME, PARAM_LIST, CASE, DEFAULT_CASE, CATCH\n+  //   GETTER_DEF, SETTER_DEF\n+\n+  /**\n+   * It isn't possible to always determine if a detached node is a expression,\n+   * so make a best guess.\n+   */\n+  private static boolean mayBeStatement(Node n) {\n+    switch (n.getType()) {\n+      case Token.EMPTY:\n+      case Token.FUNCTION:\n+        // EMPTY and FUNCTION are used both in expression and statement\n+        // contexts\n+        return true;\n+\n+      case Token.BLOCK:\n+      case Token.BREAK:\n+      case Token.CONST:\n+      case Token.CONTINUE:\n+      case Token.DEBUGGER:\n+      case Token.DO:\n+      case Token.EXPR_RESULT:\n+      case Token.FOR:\n+      case Token.IF:\n+      case Token.LABEL:\n+      case Token.RETURN:\n+      case Token.SWITCH:\n+      case Token.THROW:\n+      case Token.TRY:\n+      case Token.VAR:\n+      case Token.WHILE:\n+      case Token.WITH:\n+        return true;\n+\n+      default:\n+        return false;\n+    }\n+  }\n+\n+  /**\n+   * It isn't possible to always determine if a detached node is a expression,\n+   * so make a best guess.\n+   */\n+  private static boolean mayBeExpression(Node n) {\n+    switch (n.getType()) {\n+      case Token.FUNCTION:\n+        // FUNCTION is used both in expression and statement\n+        // contexts.\n+        return true;\n+\n+      case Token.ADD:\n+      case Token.AND:\n+      case Token.ARRAYLIT:\n+      case Token.ASSIGN:\n+      case Token.ASSIGN_BITOR:\n+      case Token.ASSIGN_BITXOR:\n+      case Token.ASSIGN_BITAND:\n+      case Token.ASSIGN_LSH:\n+      case Token.ASSIGN_RSH:\n+      case Token.ASSIGN_URSH:\n+      case Token.ASSIGN_ADD:\n+      case Token.ASSIGN_SUB:\n+      case Token.ASSIGN_MUL:\n+      case Token.ASSIGN_DIV:\n+      case Token.ASSIGN_MOD:\n+      case Token.BITAND:\n+      case Token.BITOR:\n+      case Token.BITNOT:\n+      case Token.BITXOR:\n+      case Token.CALL:\n+      case Token.COMMA:\n+      case Token.DEC:\n+      case Token.DELPROP:\n+      case Token.DIV:\n+      case Token.EQ:\n+      case Token.FALSE:\n+      case Token.GE:\n+      case Token.GETPROP:\n+      case Token.GETELEM:\n+      case Token.GT:\n+      case Token.HOOK:\n+      case Token.IN:\n+      case Token.INC:\n+      case Token.INSTANCEOF:\n+      case Token.LE:\n+      case Token.LSH:\n+      case Token.LT:\n+      case Token.MOD:\n+      case Token.MUL:\n+      case Token.NAME:\n+      case Token.NE:\n+      case Token.NEG:\n+      case Token.NEW:\n+      case Token.NOT:\n+      case Token.NUMBER:\n+      case Token.NULL:\n+      case Token.OBJECTLIT:\n+      case Token.OR:\n+      case Token.POS:\n+      case Token.REGEXP:\n+      case Token.RSH:\n+      case Token.SHEQ:\n+      case Token.SHNE:\n+      case Token.STRING:\n+      case Token.SUB:\n+      case Token.THIS:\n+      case Token.TYPEOF:\n+      case Token.TRUE:\n+      case Token.URSH:\n+      case Token.VOID:\n+        return true;\n+\n+      default:\n+        return false;\n+    }\n+  }\n+}", "timestamp": 1321409911, "metainfo": ""}