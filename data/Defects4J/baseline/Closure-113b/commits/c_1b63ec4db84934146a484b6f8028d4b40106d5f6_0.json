{"sha": "1b63ec4db84934146a484b6f8028d4b40106d5f6", "log": "Rotate commutative operators to eliminate parens.  Also, remove rotation in ReorderConstantExpression when it would add parens. ------------- Created by MOE: http://code.google.com/p/moe-java MOE_MIGRATED_REVID=51667839", "commit": "\n--- a/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n+++ b/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n     if (!late) {\n       return n;\n     }\n+    // All commutative operators are also associative\n     Preconditions.checkArgument(NodeUtil.isAssociative(n.getType()));\n     Node rhs = n.getLastChild();\n     if (n.getType() == rhs.getType()) {\n-      Node parent = n.getParent();\n+      // Transform a * (b * c) to a * b * c\n       Node first = n.getFirstChild().detachFromParent();\n       Node second = rhs.getFirstChild().detachFromParent();\n       Node third = rhs.getLastChild().detachFromParent();\n           .copyInformationFrom(n);\n       Node newRoot = new Node(rhs.getType(), newLhs, third)\n           .copyInformationFrom(rhs);\n-      parent.replaceChild(n, newRoot);\n+      n.getParent().replaceChild(n, newRoot);\n       reportCodeChange();\n       return newRoot;\n+    } else if (NodeUtil.isCommutative(n.getType()) &&\n+               !NodeUtil.mayHaveSideEffects(n)) {\n+      // Transform a * (b / c) to b / c * a\n+      Node lhs = n.getFirstChild();\n+      int precedence = NodeUtil.precedence(n.getType());\n+      int lhsPrecedence = NodeUtil.precedence(lhs.getType());\n+      int rhsPrecedence = NodeUtil.precedence(rhs.getType());\n+      if (rhsPrecedence == precedence &&\n+          (lhs.getType() == n.getType() || lhsPrecedence != precedence)) {\n+        n.removeChild(rhs);\n+        n.addChildToFront(rhs);\n+        reportCodeChange();\n+        return n;\n+      }\n     }\n     return n;\n   }\n--- a/src/com/google/javascript/jscomp/ReorderConstantExpression.java\n+++ b/src/com/google/javascript/jscomp/ReorderConstantExpression.java\n     // if the operator is symmetric\n     if (NodeUtil.isSymmetricOperation(subtree)\n         || NodeUtil.isRelationalOperation(subtree)) {\n+      if (NodeUtil.precedence(subtree.getType()) ==\n+          NodeUtil.precedence(subtree.getFirstChild().getType())) {\n+        // then flipping would add parens\n+        return subtree;\n+      }\n       // right value is immutable and left is not\n       if (NodeUtil.isImmutableValue(subtree.getLastChild())\n           && !NodeUtil.isImmutableValue(subtree.getFirstChild())) {\n--- a/test/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntaxTest.java\n+++ b/test/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntaxTest.java\n     testSame(\"var a = String({valueOf: function() { return 1; }});\");\n   }\n \n-  public void testAssocitivity() {\n-    test(\"var a,b,c; a || (b || c); a * (b * c); a | (b | c)\",\n-        \"var a,b,c; (a || b) || c; (a * b) * c; (a | b) | c\");\n-    testSame(\"var a,b,c; a % (b % c); a / (b / c); a - (b - c);\");\n+  public void testRotateAssociativeOperators() {\n+    test(\"a || (b || c); a * (b * c); a | (b | c)\",\n+        \"(a || b) || c; (a * b) * c; (a | b) | c\");\n+    testSame(\"a % (b % c); a / (b / c); a - (b - c);\");\n+    test(\"a * (b % c);\", \"b % c * a\");\n+    test(\"(a * b) * (c / d)\", \"c / d * (a * b)\");\n+    test(\"c / d * (a * b)\", \"c / d * a * b\");\n+    test(\"(a + b) * (c % d)\", \"c % d * (a + b)\");\n+    testSame(\"(a / b) * (c % d)\");\n+    testSame(\"(c = 5) * (c % d)\");\n   }\n \n   private static class StringCompareTestCase extends CompilerTestCase {\n--- a/test/com/google/javascript/jscomp/ReorderConstantExpressionTest.java\n+++ b/test/com/google/javascript/jscomp/ReorderConstantExpressionTest.java\n \n     testSame(\"a \" + op + \" b\");\n   }\n+\n+  public void testReorderConstantDoesntAddParens() {\n+    testSame(\"a % b * 4\");\n+    testSame(\"a * b * 4\");\n+  }\n }", "timestamp": 1377904815, "metainfo": ""}