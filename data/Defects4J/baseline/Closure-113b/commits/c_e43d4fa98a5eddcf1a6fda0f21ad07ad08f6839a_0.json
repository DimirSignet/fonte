{"sha": "e43d4fa98a5eddcf1a6fda0f21ad07ad08f6839a", "log": "Bugfix for struct/dict: mutating the prototype property of functions  R=nicksantos DELTA=74  (50 added, 6 deleted, 18 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=5709   ", "commit": "\n--- a/src/com/google/javascript/rhino/jstype/JSType.java\n+++ b/src/com/google/javascript/rhino/jstype/JSType.java\n    * @return {@code this &lt;: (String, string)}\n    */\n   public final boolean isString() {\n-    return this.isSubtype(\n+    return isSubtype(\n         getNativeType(JSTypeNative.STRING_VALUE_OR_OBJECT_TYPE));\n   }\n \n    * @return {@code this &lt;: (Number, number)}\n    */\n   public final boolean isNumber() {\n-    return this.isSubtype(\n+    return isSubtype(\n         getNativeType(JSTypeNative.NUMBER_VALUE_OR_OBJECT_TYPE));\n   }\n \n   public boolean isStruct() {\n     if (isObject()) {\n       ObjectType objType = toObjectType();\n+      ObjectType iproto = objType.getImplicitPrototype();\n+      // For the case when a @struct constructor is assigned to a function's\n+      // prototype property\n+      if (iproto != null && iproto.isStruct()) {\n+        return true;\n+      }\n       FunctionType ctor = objType.getConstructor();\n       // This test is true for object literals\n       if (ctor == null) {\n    */\n   public boolean isDict() {\n     if (isObject()) {\n-      FunctionType ctor = toObjectType().getConstructor();\n+      ObjectType objType = toObjectType();\n+      ObjectType iproto = objType.getImplicitPrototype();\n+      // For the case when a @dict constructor is assigned to a function's\n+      // prototype property\n+      if (iproto != null && iproto.isDict()) {\n+        return true;\n+      }\n+      FunctionType ctor = objType.getConstructor();\n       return ctor != null && ctor.makesDicts();\n     }\n     return false;\n     }\n \n     if (isUnionType() && that.isUnionType()) {\n-      return this.toMaybeUnionType().checkUnionEquivalenceHelper(\n+      return toMaybeUnionType().checkUnionEquivalenceHelper(\n           that.toMaybeUnionType(), eqMethod);\n     }\n \n     if (isFunctionType() && that.isFunctionType()) {\n-      return this.toMaybeFunctionType().checkFunctionEquivalenceHelper(\n+      return toMaybeFunctionType().checkFunctionEquivalenceHelper(\n           that.toMaybeFunctionType(), eqMethod);\n     }\n \n     if (isRecordType() && that.isRecordType()) {\n-      return this.toMaybeRecordType().checkRecordEquivalenceHelper(\n+      return toMaybeRecordType().checkRecordEquivalenceHelper(\n           that.toMaybeRecordType(), eqMethod);\n     }\n \n    * of {@code that}.<p>\n    */\n   public boolean canAssignTo(JSType that) {\n-    if (this.isSubtype(that)) {\n-      return true;\n-    }\n-    return false;\n+    return isSubtype(that);\n   }\n \n   /**\n    * Algorithm (11.9.3, page 55&ndash;56) of the ECMA-262 specification.<p>\n    */\n   public final boolean canTestForEqualityWith(JSType that) {\n-    return this.testForEquality(that).equals(UNKNOWN);\n+    return testForEquality(that).equals(UNKNOWN);\n   }\n \n   /**\n    * Tests whether this type is nullable.\n    */\n   public boolean isNullable() {\n-    return this.isSubtype(getNativeType(JSTypeNative.NULL_TYPE));\n+    return isSubtype(getNativeType(JSTypeNative.NULL_TYPE));\n   }\n \n   /**\n     }\n \n     // other types\n-    switch (this.testForEquality(that)) {\n+    switch (testForEquality(that)) {\n       case FALSE:\n         return new TypePair(null, null);\n \n     }\n \n     // other types\n-    switch (this.testForEquality(that)) {\n+    switch (testForEquality(that)) {\n       case TRUE:\n         JSType noType = getNativeType(JSTypeNative.NO_TYPE);\n         return new TypePair(noType, noType);\n     // Other types.\n     // There are only two types whose shallow inequality is deterministically\n     // true -- null and undefined. We can just enumerate them.\n-    if (this.isNullType() && that.isNullType() ||\n-        this.isVoidType() && that.isVoidType()) {\n+    if (isNullType() && that.isNullType() ||\n+        isVoidType() && that.isVoidType()) {\n       return new TypePair(null, null);\n     } else {\n       return new TypePair(this, that);\n    * around type-identity.\n    */\n   public String toDebugHashCodeString() {\n-    return \"{\" + this.hashCode() + \"}\";\n+    return \"{\" + hashCode() + \"}\";\n   }\n \n   /**\n--- a/src/com/google/javascript/rhino/jstype/ObjectType.java\n+++ b/src/com/google/javascript/rhino/jstype/ObjectType.java\n    */\n   public final boolean defineDeclaredProperty(String propertyName,\n       JSType type, Node propertyNode) {\n-    boolean result = defineProperty(propertyName, type, false,\n-        propertyNode);\n-\n+    boolean result = defineProperty(propertyName, type, false, propertyNode);\n     // All property definitions go through this method\n-    // or defineDeclaredProperty. Because the properties defined an an\n+    // or defineInferredProperty. Because the properties defined an an\n     // object can affect subtyping, it's slightly more efficient\n     // to register this after defining the property.\n     registry.registerPropertyOnType(propertyName, this);\n-\n     return result;\n   }\n \n--- a/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java\n+++ b/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java\n \n     JSType propertyType = getPropertyType(propertyName);\n     ObjectType nativeType =\n-        this.isFunctionType() ?\n+        isFunctionType() ?\n         registry.getNativeObjectType(JSTypeNative.FUNCTION_PROTOTYPE) :\n         registry.getNativeObjectType(JSTypeNative.OBJECT_PROTOTYPE);\n     JSType nativePropertyType = nativeType.getPropertyType(propertyName);\n       // to avoid guessing.\n       return true;\n     }\n-    return thatObj != null && this.isImplicitPrototype(thatObj);\n+    return thatObj != null && isImplicitPrototype(thatObj);\n   }\n \n   private boolean implicitPrototypeChainIsUnknown() {\n--- a/test/com/google/javascript/jscomp/TypeCheckTest.java\n+++ b/test/com/google/javascript/jscomp/TypeCheckTest.java\n               \"after it is constructed.\");\n   }\n \n+  public void testSetprop11() throws Exception {\n+    testTypes(\"/**\\n\" +\n+              \" * @constructor\\n\" +\n+              \" * @struct\\n\" +\n+              \" */\\n\" +\n+              \"function Foo() {}\\n\" +\n+              \"function Bar() {}\\n\" +\n+              \"Bar.prototype = new Foo();\\n\" +\n+              \"Bar.prototype.someprop = 123;\\n\",\n+              \"Cannot add a property to a struct instance \" +\n+              \"after it is constructed.\");\n+  }\n+\n   public void testGetpropDict1() throws Exception {\n     testTypes(\"/**\\n\" +\n               \" * @constructor\\n\" +\n               \"Cannot do '.' access on a dict\");\n   }\n \n+  public void testGetpropDict6() throws Exception {\n+    testTypes(\"/**\\n\" +\n+              \" * @constructor\\n\" +\n+              \" * @dict\\n\" +\n+              \" */\\n\" +\n+              \"function Foo() {}\\n\" +\n+              \"function Bar() {}\\n\" +\n+              \"Bar.prototype = new Foo();\\n\" +\n+              \"Bar.prototype.someprop = 123;\\n\",\n+              \"Cannot do '.' access on a dict\");\n+  }\n+\n   public void testGetelemStruct1() throws Exception {\n     testTypes(\"/**\\n\" +\n               \" * @constructor\\n\" +\n               \" */\" +\n               \"function Bar(){ this.x = 123; }\\n\" +\n               \"var z = /** @type {Foo} */(new Bar)['x'];\");\n+  }\n+\n+  public void testGetelemStruct7() throws Exception {\n+    testTypes(\"/**\\n\" +\n+              \" * @constructor\\n\" +\n+              \" * @struct\\n\" +\n+              \" */\\n\" +\n+              \"function Foo() {}\\n\" +\n+              \"function Bar() {}\\n\" +\n+              \"Bar.prototype = new Foo();\\n\" +\n+              \"Bar.prototype['someprop'] = 123;\\n\",\n+              \"Cannot do '[]' access on a struct\");\n   }\n \n   public void testInOnStruct() throws Exception {", "timestamp": 1351204604, "metainfo": ""}