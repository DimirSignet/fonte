{"sha": "7e93d521cb67ce33018315234fafe8a5aa30ee1e", "log": "Prevent unsupport JavaScript variants that Rhino can parse from crashing the compiler in \"ide mode\". Fixes issue 663  R=nicksantos DELTA=42  (41 added, 0 deleted, 1 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=4239   ", "commit": "\n--- a/src/com/google/javascript/jscomp/NodeTraversal.java\n+++ b/src/com/google/javascript/jscomp/NodeTraversal.java\n \n     // Body\n     Preconditions.checkState(body.getNext() == null &&\n-            body.isBlock());\n+            body.isBlock(), body);\n     traverseBranch(body, n);\n \n     popScope();\n--- a/src/com/google/javascript/jscomp/parsing/IRFactory.java\n+++ b/src/com/google/javascript/jscomp/parsing/IRFactory.java\n       node.addChildToBack(lp);\n \n       Node bodyNode = transform(functionNode.getBody());\n+      if (!bodyNode.isBlock()) {\n+        // When in ideMode Rhino tries to parse some constructs the compiler\n+        // doesn't support, repair it here. see Rhino's\n+        // Parser#parseFunctionBodyExpr.\n+        Preconditions.checkState(config.isIdeMode);\n+        bodyNode = IR.block();\n+      }\n       parseDirectives(bodyNode);\n       node.addChildToBack(bodyNode);\n      return node;\n--- a/test/com/google/javascript/jscomp/IntegrationTest.java\n+++ b/test/com/google/javascript/jscomp/IntegrationTest.java\n         \"print(3/0);print(3/-0);\");\n   }\n \n+  public void testIncompleteFunction() {\n+    CompilerOptions options = createCompilerOptions();\n+    options.ideMode = true;\n+    DiagnosticType[] warnings = new DiagnosticType[]{\n+        RhinoErrorReporter.PARSE_ERROR,\n+        RhinoErrorReporter.PARSE_ERROR,\n+        RhinoErrorReporter.PARSE_ERROR,\n+        RhinoErrorReporter.PARSE_ERROR};\n+    test(options,\n+        new String[] { \"var foo = {bar: function(e) }\" },\n+        new String[] { \"var foo = {bar: function(e){}};\" },\n+        warnings\n+    );\n+  }\n+\n   private void testSame(CompilerOptions options, String original) {\n     testSame(options, new String[] { original });\n   }\n     }\n   }\n \n+  /**\n+   * Asserts that when compiling with the given compiler options,\n+   * there is an error or warning.\n+   */\n+  private void test(CompilerOptions options,\n+      String[] original, String[] compiled, DiagnosticType[] warnings) {\n+    Compiler compiler = compile(options, original);\n+    checkUnexpectedErrorsOrWarnings(compiler, warnings.length);\n+\n+    if (compiled != null) {\n+      Node root = compiler.getRoot().getLastChild();\n+      Node expectedRoot = parse(compiled, options);\n+      String explanation = expectedRoot.checkTreeEquals(root);\n+      assertNull(\"\\nExpected: \" + compiler.toSource(expectedRoot) +\n+          \"\\nResult: \" + compiler.toSource(root) +\n+          \"\\n\" + explanation, explanation);\n+    }\n+  }\n+\n   private void checkUnexpectedErrorsOrWarnings(\n       Compiler compiler, int expected) {\n     int actual = compiler.getErrors().length + compiler.getWarnings().length;", "timestamp": 1329845223, "metainfo": ""}