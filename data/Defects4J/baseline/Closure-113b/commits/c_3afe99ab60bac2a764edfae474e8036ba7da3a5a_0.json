{"sha": "3afe99ab60bac2a764edfae474e8036ba7da3a5a", "log": "Minimize if statements differently depending on whether they can be simplified. ------------- Created by MOE: http://code.google.com/p/moe-java MOE_MIGRATED_REVID=46369518", "commit": "\n--- a/src/com/google/javascript/jscomp/PeepholeMinimizeConditions.java\n+++ b/src/com/google/javascript/jscomp/PeepholeMinimizeConditions.java\n   extends AbstractPeepholeOptimization {\n \n   private static final int AND_PRECEDENCE = NodeUtil.precedence(Token.AND);\n-  private static final int OR_PRECEDENCE = NodeUtil.precedence(Token.OR);\n \n   private final boolean late;\n \n         return tryMinimizeNot(node);\n \n       case Token.IF:\n-        tryMinimizeCondition(node.getFirstChild(), false);\n+        performConditionSubstitutions(node.getFirstChild());\n         return tryMinimizeIf(node);\n \n       case Token.EXPR_RESULT:\n \n     Node parent = n.getParent();\n \n-    Node cond = n.getFirstChild();\n+    Node originalCond = n.getFirstChild();\n \n     /* If the condition is a literal, we'll let other\n      * optimizations try to remove useless code.\n      */\n-    if (NodeUtil.isLiteralValue(cond, true)) {\n+    if (NodeUtil.isLiteralValue(originalCond, true)) {\n       return n;\n     }\n \n-    Node thenBranch = cond.getNext();\n+    Node thenBranch = originalCond.getNext();\n     Node elseBranch = thenBranch.getNext();\n+\n+    MinimizedCondition minCond = MinimizedCondition\n+        .fromConditionNode(originalCond);\n+    // Compute two minimized representations. The first representation counts\n+    // a leading NOT node, and the second ignores a leading NOT node.\n+    // If we can fold the if statement into a HOOK or boolean operation,\n+    // then the NOT node does not matter, and we prefer the second condition.\n+    // If we cannot fold the if statement, then we prefer the first condition.\n+    Node unnegatedCond = minCond.getShorterRepresentation(true);\n+    Node shortCond = minCond.getShorterRepresentation(false);\n \n     if (elseBranch == null) {\n       if (isFoldableExpressBlock(thenBranch)) {\n           return n;\n         }\n \n-        if (cond.isNot()) {\n+        if (shortCond.isNot()) {\n           // if(!x)bar(); -> x||bar();\n-          if (isLowerPrecedence(cond.getFirstChild(), OR_PRECEDENCE) &&\n-              isLowerPrecedence(expr.getFirstChild(),\n-                  OR_PRECEDENCE)) {\n-            // It's not okay to add two sets of parentheses.\n-            return n;\n-          }\n-\n           Node or = IR.or(\n-              cond.removeFirstChild(),\n+              shortCond.removeFirstChild(),\n               expr.removeFirstChild()).srcref(n);\n           Node newExpr = NodeUtil.newExpr(or);\n           parent.replaceChild(n, newExpr);\n \n           return newExpr;\n         }\n+        Preconditions.checkState(shortCond.isEquivalentTo(unnegatedCond));\n \n         // if(x)foo(); -> x&&foo();\n-        if (isLowerPrecedence(cond, AND_PRECEDENCE) &&\n+        if (isLowerPrecedence(shortCond, AND_PRECEDENCE) &&\n             isLowerPrecedence(expr.getFirstChild(),\n                 AND_PRECEDENCE)) {\n           // One additional set of parentheses is worth the change even if\n           // there is no immediate code size win. However, two extra pair of\n           // {}, we would have to think twice. (unless we know for sure the\n           // we can further optimize its parent.\n+          maybeReplaceNode(originalCond, shortCond);\n           return n;\n         }\n \n-        n.removeChild(cond);\n-        Node and = IR.and(cond, expr.removeFirstChild()).srcref(n);\n+        Node and = IR.and(shortCond, expr.removeFirstChild()).srcref(n);\n         Node newExpr = NodeUtil.newExpr(and);\n         parent.replaceChild(n, newExpr);\n         reportCodeChange();\n             Node innerElseBranch = innerThenBranch.getNext();\n \n             if (innerElseBranch == null &&\n-                 !(isLowerPrecedence(cond, AND_PRECEDENCE) &&\n+                 !(isLowerPrecedence(unnegatedCond, AND_PRECEDENCE) &&\n                    isLowerPrecedence(innerCond, AND_PRECEDENCE))) {\n               n.detachChildren();\n               n.addChildToBack(\n                   IR.and(\n-                      cond,\n+                      unnegatedCond,\n                       innerCond.detachFromParent())\n-                      .srcref(cond));\n+                      .srcref(originalCond));\n               n.addChildrenToBack(innerThenBranch.detachFromParent());\n               reportCodeChange();\n               // Not worth trying to fold the current IF-ELSE into && because\n           }\n         }\n       }\n-\n+      maybeReplaceNode(originalCond, unnegatedCond);\n       return n;\n     }\n \n \n     // if(!x)foo();else bar(); -> if(x)bar();else foo();\n     // An additional set of curly braces isn't worth it.\n-    if (cond.isNot() && !consumesDanglingElse(elseBranch)) {\n-      n.replaceChild(cond, cond.removeFirstChild());\n+    if (shortCond.isNot() && !consumesDanglingElse(elseBranch)) {\n+      n.replaceChild(originalCond, shortCond.removeFirstChild());\n       n.removeChild(thenBranch);\n       n.addChildToBack(thenBranch);\n       reportCodeChange();\n     if (isReturnExpressBlock(thenBranch) && isReturnExpressBlock(elseBranch)) {\n       Node thenExpr = getBlockReturnExpression(thenBranch);\n       Node elseExpr = getBlockReturnExpression(elseBranch);\n-      n.removeChild(cond);\n       thenExpr.detachFromParent();\n       elseExpr.detachFromParent();\n \n       // can be converted to \"return undefined;\" or some variant, but\n       // that does not help code size.\n       Node returnNode = IR.returnNode(\n-                            IR.hook(cond, thenExpr, elseExpr)\n+                            IR.hook(shortCond, thenExpr, elseExpr)\n                                 .srcref(n));\n       parent.replaceChild(n, returnNode);\n       reportCodeChange();\n               // NOTE - there are some circumstances where we can\n               // proceed even if there are side effects...\n               !mayEffectMutableState(lhs) &&\n-              (!mayHaveSideEffects(cond) ||\n+              (!mayHaveSideEffects(originalCond) ||\n                   (thenOp.isAssign() && thenOp.getFirstChild().isName()))) {\n \n-            n.removeChild(cond);\n             Node assignName = thenOp.removeFirstChild();\n             Node thenExpr = thenOp.removeFirstChild();\n             Node elseExpr = elseOp.getLastChild();\n             elseOp.removeChild(elseExpr);\n \n-            Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n+            Node hookNode = IR.hook(shortCond, thenExpr, elseExpr).srcref(n);\n             Node assign = new Node(thenOp.getType(), assignName, hookNode)\n                               .srcref(thenOp);\n             Node expr = NodeUtil.newExpr(assign);\n         }\n       }\n       // if(x)foo();else bar(); -> x?foo():bar()\n-      n.removeChild(cond);\n       thenOp.detachFromParent();\n       elseOp.detachFromParent();\n       Node expr = IR.exprResult(\n-          IR.hook(cond, thenOp, elseOp).srcref(n));\n+          IR.hook(shortCond, thenOp, elseOp).srcref(n));\n       parent.replaceChild(n, expr);\n       reportCodeChange();\n       return expr;\n           && name1.getString().equals(maybeName2.getString())) {\n         Node thenExpr = name1.removeChildren();\n         Node elseExpr = elseAssign.getLastChild().detachFromParent();\n-        cond.detachFromParent();\n-        Node hookNode = IR.hook(cond, thenExpr, elseExpr)\n+        Node hookNode = IR.hook(shortCond, thenExpr, elseExpr)\n                             .srcref(n);\n         var.detachFromParent();\n         name1.addChildrenToBack(hookNode);\n           && maybeName1.getString().equals(name2.getString())) {\n         Node thenExpr = thenAssign.getLastChild().detachFromParent();\n         Node elseExpr = name2.removeChildren();\n-        cond.detachFromParent();\n-        Node hookNode = IR.hook(cond, thenExpr, elseExpr)\n+        Node hookNode = IR.hook(shortCond, thenExpr, elseExpr)\n                             .srcref(n);\n         var.detachFromParent();\n         name2.addChildrenToBack(hookNode);\n       }\n     }\n \n+    maybeReplaceNode(originalCond, unnegatedCond);\n     return n;\n   }\n \n         DONT_TRAVERSE_FUNCTIONS_PREDICATE);\n   }\n \n+  /**\n+   * Try to minimize condition expression, as there are additional\n+   * assumptions that can be made when it is known that the final result\n+   * is a boolean.\n+   *\n+   * @return The replacement for n, or the original if no change was made.\n+   */\n   private Node tryMinimizeCondition(Node n, boolean countLeadingNot) {\n-    n = tryMinimizeConditionOld(n);\n+    n = performConditionSubstitutions(n);\n     return demorganMinimizeCondition(n, countLeadingNot);\n   }\n \n    */\n   private Node demorganMinimizeCondition(Node n, boolean countLeadingNot) {\n     MinimizedCondition minCond = MinimizedCondition.fromConditionNode(n);\n-    if (countLeadingNot ||\n-         minCond.getLength() <= minCond.getNegativeLength()) {\n-      return maybeReplaceNode(n, minCond.getNode());\n-    } else {\n-      return maybeReplaceNode(n,\n-          new Node(Token.NOT, minCond.getNegatedNode()));\n-    }\n+    Node newNode = minCond.getShorterRepresentation(countLeadingNot);\n+    return maybeReplaceNode(n, newNode);\n   }\n \n   private Node maybeReplaceNode(Node lhs, Node rhs) {\n       return length(negative);\n     }\n \n+    /** Return the shorter representation of the original condition node.\n+     *\n+     * @param countLeadingNot When this is false, do not count a leading\n+     *  NOT in doing the minimization.\n+     *  i.e. Prefer the right side in cases such as:\n+     *    !x || !y || z  ==>  !(x && y && !z)\n+     *  This is useful in contexts such as IFs or HOOKs where subsequent\n+     *  optimizations can efficiently deal with leading NOTs.\n+     *\n+     *  @return The minimized condition Node, equivalent to that\n+     *    passed to #fromConditionNode().\n+     */\n+    Node getShorterRepresentation(boolean countLeadingNot) {\n+      if (countLeadingNot || getLength() <= getNegativeLength()) {\n+       return getNode();\n+     } else {\n+       return new Node(Token.NOT, getNegatedNode());\n+     }\n+    }\n+\n     private static Node negate(Node node) {\n       Preconditions.checkArgument(node.getParent() == null);\n       int complementOperator;\n   }\n \n   /**\n-   * Try to minimize conditions expressions, as there are additional\n-   * assumptions that can be made when it is known that the final result\n-   * is a boolean.\n-   *\n-   * The following transformations are done recursively:\n-   *   !(x||y) --> !x&&!y\n-   *   !(x&&y) --> !x||!y\n-   *   !!x     --> x\n-   * Thus:\n-   *   !(x&&!y) --> !x||!!y --> !x||y\n+   * Try to minimize the given condition by applying local substitutions.\n+   *\n+   * The following types of transformations are performed:\n+   *   x || true        --> true\n+   *   x && true        --> x\n+   *   x ? false : true --> !x\n+   *   x ? true : y     --> x || y\n    *\n    *   Returns the replacement for n, or the original if no change was made\n    */\n-  private Node tryMinimizeConditionOld(Node n) {\n+  private Node performConditionSubstitutions(Node n) {\n     Node parent = n.getParent();\n \n     switch (n.getType()) {\n \n         // Because the expression is in a boolean context minimize\n         // the children, this can't be done in the general case.\n-        left = tryMinimizeConditionOld(left);\n-        right = tryMinimizeConditionOld(right);\n+        left = performConditionSubstitutions(left);\n+        right = performConditionSubstitutions(right);\n \n         // Remove useless conditionals\n         // Handle four cases:\n         // Because the expression is in a boolean context minimize\n         // the result children, this can't be done in the general case.\n         // The condition is handled in the general case in #optimizeSubtree\n-        trueNode = tryMinimizeConditionOld(trueNode);\n-        falseNode = tryMinimizeConditionOld(falseNode);\n+        trueNode = performConditionSubstitutions(trueNode);\n+        falseNode = performConditionSubstitutions(falseNode);\n \n         // Handle four cases:\n         //   x ? true : false --> x\n--- a/test/com/google/javascript/jscomp/PeepholeMinimizeConditionsTest.java\n+++ b/test/com/google/javascript/jscomp/PeepholeMinimizeConditionsTest.java\n     fold(\"function f(){if(!x)b=1}\", \"function f(){x||(b=1)}\");\n     fold(\"if(!x)z=1;else if(y)z=2\", \"if(x){y&&(z=2);}else{z=1;}\");\n     fold(\"if(x)y&&(z=2);else z=1;\", \"x ? y&&(z=2) : z=1\");\n-    foldSame(\"function f(){if(!(x=1))a.b=1}\");\n+    fold(\"function f(){if(!(x=1))a.b=1}\",\n+         \"function f(){(x=1)||(a.b=1)}\");\n   }\n \n   public void testAndParenthesesCount() {\n          \"(0!==c || 2!==a && 1!==a) ? g() : f()\");\n   }\n \n+  public void testPreserveIf() {\n+    foldSame(\"if(!a&&!b)for(;f(););\");\n+  }\n+\n   public void testSwapHook() {\n     fold(\"!x ? foo() : bar()\",\n          \"x ? bar() : foo()\");", "timestamp": 1368488193, "metainfo": ""}