{"sha": "177d001a30c568037141e555d84f9bd28d3d2d86", "log": "Adds basic support for template keys and templatized types to the base JSType. Array and Object will be converted to this templatized type system.  R=dimvar,nicksantos DELTA=324  (225 added, 17 deleted, 82 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=5698   ", "commit": "\n--- a/src/com/google/javascript/jscomp/FunctionTypeBuilder.java\n+++ b/src/com/google/javascript/jscomp/FunctionTypeBuilder.java\n           .withParamsNode(parametersNode)\n           .withReturnType(returnType, returnTypeInferred)\n           .withTypeOfThis(thisType)\n-          .withTemplateNames(templateTypeNames)\n+          .withTemplateKeys(templateTypeNames)\n           .build();\n       maybeSetBaseType(fnType);\n     }\n    */\n   private FunctionType getOrCreateConstructor() {\n     FunctionType fnType = typeRegistry.createConstructorType(\n-        fnName, contents.getSourceNode(), parametersNode, returnType);\n+        fnName, contents.getSourceNode(), parametersNode, returnType, null);\n     JSType existingType = typeRegistry.getType(fnName);\n \n     if (makesStructs) {\n--- a/src/com/google/javascript/jscomp/TypeInference.java\n+++ b/src/com/google/javascript/jscomp/TypeInference.java\n \n   private Map<TemplateType, JSType> inferTemplateTypesFromParameters(\n       FunctionType fnType, Node call) {\n-    if (fnType.getTemplateTypeNames().isEmpty()) {\n+    if (fnType.getTemplateKeys().isEmpty()) {\n       return Collections.emptyMap();\n     }\n \n    */\n   private boolean inferTemplatedTypesForCall(\n       Node n, FunctionType fnType) {\n-    if (fnType.getTemplateTypeNames().isEmpty()) {\n+    if (fnType.getTemplateKeys().isEmpty()) {\n       return false;\n     }\n \n--- a/src/com/google/javascript/jscomp/TypedScopeCreator.java\n+++ b/src/com/google/javascript/jscomp/TypedScopeCreator.java\n \n           FunctionType delegateProxy = typeRegistry.createConstructorType(\n               delegateBaseObject.getReferenceName() + DELEGATE_PROXY_SUFFIX,\n-              null, null, null);\n+              null, null, null, null);\n           delegateProxy.setPrototypeBasedOn(delegateBaseObject);\n \n           codingConvention.applyDelegateRelationship(\n--- a/src/com/google/javascript/rhino/jstype/ArrowType.java\n+++ b/src/com/google/javascript/rhino/jstype/ArrowType.java\n   }\n \n   @Override\n-  public boolean hasAnyTemplateInternal() {\n-    return returnType.hasAnyTemplate()\n+  public boolean hasAnyTemplateTypesInternal() {\n+    return returnType.hasAnyTemplateTypes()\n         || hasTemplatedParameterType();\n   }\n \n       for (Node paramNode = parameters.getFirstChild();\n            paramNode != null; paramNode = paramNode.getNext()) {\n         JSType type = paramNode.getJSType();\n-        if (type != null && type.hasAnyTemplate()) {\n+        if (type != null && type.hasAnyTemplateTypes()) {\n           return true;\n         }\n       }\n--- a/src/com/google/javascript/rhino/jstype/FunctionBuilder.java\n+++ b/src/com/google/javascript/rhino/jstype/FunctionBuilder.java\n   private Node parametersNode = null;\n   private JSType returnType = null;\n   private ObjectType typeOfThis = null;\n-  private ImmutableList<String> templateTypeNames = ImmutableList.of();\n+  private ImmutableList<String> templateKeys = ImmutableList.of();\n   private boolean inferredReturnType = false;\n   private boolean isConstructor = false;\n   private boolean isNativeType = false;\n   }\n \n   /** Set the template name. */\n-  public FunctionBuilder withTemplateNames(\n-      ImmutableList<String> templateTypeNames) {\n-    this.templateTypeNames = templateTypeNames;\n+  public FunctionBuilder withTemplateKeys(\n+      ImmutableList<String> templateKeys) {\n+    this.templateKeys = templateKeys;\n     return this;\n   }\n \n     this.parametersNode = otherType.getParametersNode();\n     this.returnType = otherType.getReturnType();\n     this.typeOfThis = otherType.getTypeOfThis();\n-    this.templateTypeNames = otherType.getTemplateTypeNames();\n+    this.templateKeys = otherType.getTemplateKeys();\n     this.isConstructor = otherType.isConstructor();\n     this.isNativeType = otherType.isNativeObjectType();\n     return this;\n   public FunctionType build() {\n     return new FunctionType(registry, name, sourceNode,\n         new ArrowType(registry, parametersNode, returnType, inferredReturnType),\n-        typeOfThis, templateTypeNames, isConstructor, isNativeType);\n+        typeOfThis, templateKeys, isConstructor, isNativeType);\n   }\n }\n--- a/src/com/google/javascript/rhino/jstype/FunctionType.java\n+++ b/src/com/google/javascript/rhino/jstype/FunctionType.java\n    */\n   private List<FunctionType> subTypes;\n \n-  /**\n-   * The template type name. May be {@code null}.\n-   */\n-  private final ImmutableList<String> templateTypeNames;\n-\n   /** Creates an instance for a function that might be a constructor. */\n   FunctionType(JSTypeRegistry registry, String name, Node source,\n                ArrowType arrowType, ObjectType typeOfThis,\n-               ImmutableList<String> templateTypeNames,\n+               ImmutableList<String> templateKeys,\n                boolean isConstructor, boolean nativeType) {\n     super(registry, name,\n         registry.getNativeObjectType(JSTypeNative.FUNCTION_INSTANCE_TYPE),\n-        nativeType);\n+        nativeType, templateKeys, null);\n     setPrettyPrint(true);\n \n     Preconditions.checkArgument(source == null ||\n       this.kind = Kind.CONSTRUCTOR;\n       this.propAccess = PropAccess.ANY;\n       this.typeOfThis = typeOfThis != null ?\n-          typeOfThis : new InstanceObjectType(registry, this, nativeType);\n+          typeOfThis : new InstanceObjectType(registry, this, nativeType, null);\n     } else {\n       this.kind = Kind.ORDINARY;\n       this.typeOfThis = typeOfThis != null ?\n           registry.getNativeObjectType(JSTypeNative.UNKNOWN_TYPE);\n     }\n     this.call = arrowType;\n-    this.templateTypeNames = templateTypeNames != null\n-        ? templateTypeNames : ImmutableList.<String>of();\n   }\n \n   /** Creates an instance for a function that is an interface. */\n     this.call = new ArrowType(registry, new Node(Token.PARAM_LIST), null);\n     this.kind = Kind.INTERFACE;\n     this.typeOfThis = new InstanceObjectType(registry, this);\n-    this.templateTypeNames = ImmutableList.of();\n   }\n \n   /** Creates an instance for a function that is an interface. */\n                 registry,\n                 this.getReferenceName() + \".prototype\",\n                 registry.getNativeObjectType(OBJECT_TYPE),\n-                isNativeObjectType()),\n+                isNativeObjectType(), null, null),\n             null);\n       }\n     }\n       return false;\n     }\n \n-    return typeOfThis.checkEquivalenceHelper(\n-        that.typeOfThis, eqMethod) &&\n+    return typeOfThis.checkEquivalenceHelper(that.typeOfThis, eqMethod) &&\n         call.checkArrowEquivalenceHelper(that.call, eqMethod);\n   }\n \n   @Override\n   public boolean hasCachedValues() {\n     return prototypeSlot != null || super.hasCachedValues();\n-  }\n-\n-  /**\n-   * Gets the template type name.\n-   */\n-  public ImmutableList<String> getTemplateTypeNames() {\n-    return templateTypeNames;\n   }\n \n   @Override\n   }\n \n   @Override\n-  public boolean hasAnyTemplateInternal() {\n-    return !getTemplateTypeNames().isEmpty()\n-        || typeOfThis.hasAnyTemplate()\n-        || call.hasAnyTemplate();\n+  public boolean hasAnyTemplateTypesInternal() {\n+    return !getTemplateKeys().isEmpty()\n+        || typeOfThis.hasAnyTemplateTypes()\n+        || call.hasAnyTemplateTypes();\n   }\n }\n--- a/src/com/google/javascript/rhino/jstype/InstanceObjectType.java\n+++ b/src/com/google/javascript/rhino/jstype/InstanceObjectType.java\n package com.google.javascript.rhino.jstype;\n \n \n+import com.google.common.base.Joiner;\n import com.google.common.base.Preconditions;\n+import com.google.common.collect.ImmutableList;\n import com.google.javascript.rhino.Node;\n \n /**\n   private final FunctionType constructor;\n \n   InstanceObjectType(JSTypeRegistry registry, FunctionType constructor) {\n-    this(registry, constructor, false);\n+    this(registry, constructor, false, null);\n   }\n \n   InstanceObjectType(JSTypeRegistry registry, FunctionType constructor,\n-                     boolean isNativeType) {\n-    super(registry, null, null, isNativeType);\n+                     boolean isNativeType,\n+                     ImmutableList<JSType> templatizedTypes) {\n+    super(registry, null, null, isNativeType, constructor.getTemplateKeys(),\n+        templatizedTypes);\n     Preconditions.checkNotNull(constructor);\n     this.constructor = constructor;\n   }\n   @Override\n   String toStringHelper(boolean forAnnotations) {\n     if (constructor.hasReferenceName()) {\n-      return constructor.getReferenceName();\n+      String typeString = constructor.getReferenceName();\n+\n+      ImmutableList<JSType> templatizedTypes = getTemplatizedTypes();\n+      if (!templatizedTypes.isEmpty()) {\n+        typeString += \".<\" + Joiner.on(\",\").join(templatizedTypes) + \">\";\n+      }\n+\n+      return typeString;\n     } else {\n       return super.toStringHelper(forAnnotations);\n     }\n--- a/src/com/google/javascript/rhino/jstype/JSType.java\n+++ b/src/com/google/javascript/rhino/jstype/JSType.java\n import static com.google.javascript.rhino.jstype.TernaryValue.UNKNOWN;\n \n import com.google.common.base.Predicate;\n+import com.google.common.collect.ImmutableList;\n import com.google.javascript.rhino.ErrorReporter;\n import com.google.javascript.rhino.JSDocInfo;\n import com.google.javascript.rhino.jstype.JSTypeRegistry.ResolveMode;\n \n   private boolean resolved = false;\n   private JSType resolveResult = null;\n+  private final ImmutableList<String> templateKeys;\n+  private final ImmutableList<JSType> templatizedTypes;\n \n   private boolean inTemplatedCheckVisit = false;\n \n   final JSTypeRegistry registry;\n \n   JSType(JSTypeRegistry registry) {\n+    this(registry, null, null);\n+  }\n+\n+  JSType(JSTypeRegistry registry, ImmutableList<String> templateKeys,\n+      ImmutableList<JSType> templatizedTypes) {\n     this.registry = registry;\n+\n+    // Do sanity checking on the specified keys and templatized types.\n+    int keysLength = templateKeys == null ? 0 : templateKeys.size();\n+    int typesLength = templatizedTypes == null ? 0 : templatizedTypes.size();\n+    if (typesLength > keysLength) {\n+      throw new IllegalArgumentException(\n+          \"Cannot have more templatized types than template keys\");\n+    } else if (typesLength < keysLength) {\n+      // If there are fewer templatized types than keys, extend the templatized\n+      // types list to match the number of keys, using UNKNOWN_TYPE for the\n+      // unspecified types.\n+      ImmutableList.Builder<JSType> builder = ImmutableList.builder();\n+      if (typesLength > 0) {\n+        builder.addAll(templatizedTypes);\n+      }\n+      for (int i = 0; i < keysLength - typesLength; i++) {\n+        builder.add(registry.getNativeType(JSTypeNative.UNKNOWN_TYPE));\n+      }\n+      templatizedTypes = builder.build();\n+    } else if (keysLength == 0 && typesLength == 0) {\n+      // Ensure that both lists are non-null.\n+      templateKeys = ImmutableList.of();\n+      templatizedTypes = ImmutableList.of();\n+    }\n+\n+    this.templateKeys = templateKeys;\n+    this.templatizedTypes = templatizedTypes;\n   }\n \n   /**\n     return type == null ? null : type.toMaybeTemplateType();\n   }\n \n-  public boolean hasAnyTemplate() {\n+  public boolean hasAnyTemplateTypes() {\n     if (!this.inTemplatedCheckVisit) {\n       this.inTemplatedCheckVisit = true;\n-      boolean result = hasAnyTemplateInternal();\n+      boolean result = hasAnyTemplateTypesInternal();\n       this.inTemplatedCheckVisit = false;\n       return result;\n     } else {\n     }\n   }\n \n-  boolean hasAnyTemplateInternal() {\n-    return false;\n-  }\n+  boolean hasAnyTemplateTypesInternal() {\n+    if (isTemplatized()) {\n+      for (JSType templatizedType : templatizedTypes) {\n+        if (templatizedType.hasAnyTemplateTypes()) {\n+          return true;\n+        }\n+      }\n+    }\n+    return false;\n+  }\n+\n+  /**\n+   * Returns true if this type is templatized; false otherwise.\n+   */\n+  public boolean isTemplatized() {\n+    return !templateKeys.isEmpty();\n+  }\n+\n+  /**\n+   * Returns the template keys associated with this type.\n+   */\n+  public ImmutableList<String> getTemplateKeys() {\n+    return templateKeys;\n+  }\n+\n+  public ImmutableList<JSType> getTemplatizedTypes() {\n+    return templatizedTypes;\n+  }\n+\n+  /**\n+   * Returns true if this type is templatized for the specified key; false\n+   * otherwise.\n+   */\n+  public boolean hasTemplatizedType(String key) {\n+    return templateKeys.contains(key);\n+  }\n+\n+  /**\n+   * Returns the type associated with a given template key. Will return\n+   * the UNKNOWN_TYPE if there is no template type associated with that\n+   * template key.\n+   */\n+  public JSType getTemplatizedType(String key) {\n+     int index = templateKeys.indexOf(key);\n+     if (index < 0) {\n+       return registry.getNativeType(JSTypeNative.UNKNOWN_TYPE);\n+     }\n+     return templatizedTypes.get(index);\n+  }\n+\n+  /**\n+   * Determines if the two specified JSTypes have equivalent, invariant\n+   * templatized types.\n+   */\n+  static boolean hasEquivalentTemplateTypes(\n+      JSType type1, JSType type2, EquivalenceMethod eqMethod) {\n+    ImmutableList<JSType> templatizedTypes1 = type1.getTemplatizedTypes();\n+    ImmutableList<JSType> templatizedTypes2 = type2.getTemplatizedTypes();\n+    int nTemplatizedTypes1 = templatizedTypes1.size();\n+    int nTemplatizedTypes2 = templatizedTypes2.size();\n+\n+    if (nTemplatizedTypes1 != nTemplatizedTypes2) {\n+      return false;\n+    }\n+\n+    for (int i = 0; i < nTemplatizedTypes1; i++) {\n+      JSType templatizedType1 = templatizedTypes1.get(i);\n+      JSType templatizedType2 = templatizedTypes2.get(i);\n+      if (templatizedType1.checkEquivalenceHelper(templatizedType2, eqMethod)) {\n+        return false;\n+      }\n+    }\n+\n+    return true;\n+  }\n+\n \n   /**\n    * Tests whether this type is an {@code Object}, or any subtype thereof.\n--- a/src/com/google/javascript/rhino/jstype/JSTypeRegistry.java\n+++ b/src/com/google/javascript/rhino/jstype/JSTypeRegistry.java\n     // use each other's results, so at least one of them will get null\n     // instead of an actual type; however, this seems to be benign.\n     PrototypeObjectType TOP_LEVEL_PROTOTYPE =\n-        new PrototypeObjectType(this, null, null, true);\n+        new PrototypeObjectType(this, null, null, true, null, null);\n     registerNativeType(JSTypeNative.TOP_LEVEL_PROTOTYPE, TOP_LEVEL_PROTOTYPE);\n \n     // Object\n   }\n \n   private void register(JSType type, String name) {\n+    Preconditions.checkArgument(\n+        !name.contains(\"<\"), \"Type names cannot contain template annotations.\");\n+\n     namesToTypes.put(name, type);\n \n     // Add all the namespaces in which this name lives.\n   public FunctionType createConstructorType(\n       JSType returnType, JSType... parameterTypes) {\n     return createConstructorType(\n-        null, null, createParameters(parameterTypes), returnType);\n+        null, null, createParameters(parameterTypes), returnType, null);\n   }\n \n   /**\n   private FunctionType createConstructorTypeWithVarArgs(\n       JSType returnType, JSType... parameterTypes) {\n     return createConstructorType(\n-        null, null, createParametersWithVarArgs(parameterTypes), returnType);\n+        null, null, createParametersWithVarArgs(parameterTypes), returnType,\n+        null);\n   }\n \n   /**\n    */\n   ObjectType createNativeAnonymousObjectType() {\n     PrototypeObjectType type =\n-        new PrototypeObjectType(this, null, null, true);\n+        new PrototypeObjectType(this, null, null, true, null, null);\n     type.setPrettyPrint(true);\n     return type;\n   }\n    *     to indicate that the parameter types are unknown.\n    * @param returnType the function's return type or {@code null} to indicate\n    *     that the return type is unknown.\n+   * @param templateKeys the templatized type keys for the class.\n    */\n   public FunctionType createConstructorType(String name, Node source,\n-      Node parameters, JSType returnType) {\n+      Node parameters, JSType returnType, ImmutableList<String> templateKeys) {\n     return new FunctionType(this, name, source,\n         createArrowType(parameters, returnType), null,\n-        null, true, false);\n+        templateKeys, true, false);\n   }\n \n   /**\n   public ParameterizedType createParameterizedType(\n       ObjectType objectType, JSType parameterType) {\n     return new ParameterizedType(this, objectType, parameterType);\n+  }\n+\n+  /**\n+   * Creates a templatized instance of the specified type.\n+   * @param baseType the type to be templatized.\n+   * @param templatizedTypes a list of the template JSTypes. Will be matched by\n+   *     list order to the template keys specified in the constructor function.\n+   */\n+  public JSType createTemplatizedType(\n+      JSType baseType, ImmutableList<JSType> templatizedTypes) {\n+    // Only instance object types can currently be templatized; extend this\n+    // logic when more types can be templatized.\n+    if (baseType instanceof InstanceObjectType) {\n+      ObjectType baseObjType = baseType.toObjectType();\n+      return new InstanceObjectType(\n+          this, baseObjType.getConstructor(), baseObjType.isNativeObjectType(),\n+          templatizedTypes);\n+    } else {\n+      throw new IllegalArgumentException(\n+          \"Only instance object types can be templatized\");\n+    }\n   }\n \n   /**\n--- a/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\n+++ b/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\n \n package com.google.javascript.rhino.jstype;\n \n+import com.google.common.collect.ImmutableList;\n import com.google.common.collect.Lists;\n import com.google.javascript.rhino.Node;\n \n \n   @Override\n   public JSType caseObjectType(ObjectType objType) {\n-    return objType;\n+    if (objType.isTemplatized()) {\n+      ImmutableList.Builder<JSType> builder = ImmutableList.builder();\n+      for (JSType templatizedType : objType.getTemplatizedTypes()) {\n+        builder.add(templatizedType.visit(this));\n+      }\n+      return registry.createTemplatizedType(objType, builder.build());\n+    } else {\n+      return objType;\n+    }\n   }\n \n   @Override\n--- a/src/com/google/javascript/rhino/jstype/ObjectType.java\n+++ b/src/com/google/javascript/rhino/jstype/ObjectType.java\n import static com.google.javascript.rhino.jstype.TernaryValue.FALSE;\n import static com.google.javascript.rhino.jstype.TernaryValue.UNKNOWN;\n \n+import com.google.common.collect.ImmutableList;\n import com.google.common.collect.ImmutableSet;\n import com.google.common.collect.Sets;\n import com.google.javascript.rhino.JSDocInfo;\n \n   ObjectType(JSTypeRegistry registry) {\n     super(registry);\n+  }\n+\n+  ObjectType(JSTypeRegistry registry, ImmutableList<String> templateKeys,\n+      ImmutableList<JSType> templatizedTypes) {\n+    super(registry, templateKeys, templatizedTypes);\n   }\n \n   @Override\n--- a/src/com/google/javascript/rhino/jstype/ParameterizedType.java\n+++ b/src/com/google/javascript/rhino/jstype/ParameterizedType.java\n   }\n \n   @Override\n-  public boolean hasAnyTemplateInternal() {\n-    return super.hasAnyTemplate() || parameterType.hasAnyTemplate();\n+  public boolean hasAnyTemplateTypesInternal() {\n+    return super.hasAnyTemplateTypes() || parameterType.hasAnyTemplateTypes();\n   }\n }\n--- a/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java\n+++ b/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java\n    */\n   PrototypeObjectType(JSTypeRegistry registry, String className,\n       ObjectType implicitPrototype) {\n-    this(registry, className, implicitPrototype, false);\n+    this(registry, className, implicitPrototype, false, null, null);\n   }\n \n   /**\n-   * Creates an object type, allowing specification of the implicit prototype\n-   * when creating native objects.\n+   * Creates an object type, allowing specification of the implicit prototype,\n+   * whether the object is native, and any templatized types.\n    */\n   PrototypeObjectType(JSTypeRegistry registry, String className,\n-      ObjectType implicitPrototype, boolean nativeType) {\n-    super(registry);\n+      ObjectType implicitPrototype, boolean nativeType,\n+      ImmutableList<String> templateKeys,\n+      ImmutableList<JSType> templatizedTypes) {\n+    super(registry, templateKeys, templatizedTypes);\n     this.properties = Maps.newTreeMap();\n     this.className = className;\n     this.nativeType = nativeType;\n--- a/src/com/google/javascript/rhino/jstype/ProxyObjectType.java\n+++ b/src/com/google/javascript/rhino/jstype/ProxyObjectType.java\n   }\n \n   @Override\n-  public boolean hasAnyTemplateInternal() {\n-    return referencedType.hasAnyTemplate();\n+  public boolean hasAnyTemplateTypesInternal() {\n+    return referencedType.hasAnyTemplateTypes();\n   }\n }\n--- a/src/com/google/javascript/rhino/jstype/TemplateType.java\n+++ b/src/com/google/javascript/rhino/jstype/TemplateType.java\n   }\n \n   @Override\n-  public boolean hasAnyTemplateInternal() {\n+  public boolean hasAnyTemplateTypesInternal() {\n     return true;\n   }\n \n--- a/src/com/google/javascript/rhino/jstype/UnionType.java\n+++ b/src/com/google/javascript/rhino/jstype/UnionType.java\n   }\n \n   @Override\n-  public boolean hasAnyTemplateInternal() {\n+  public boolean hasAnyTemplateTypesInternal() {\n     for (JSType alternate : alternates) {\n-      if (alternate.hasAnyTemplate()) {\n+      if (alternate.hasAnyTemplateTypes()) {\n         return true;\n       }\n     }\n--- a/src/com/google/javascript/rhino/jstype/UnionTypeBuilder.java\n+++ b/src/com/google/javascript/rhino/jstype/UnionTypeBuilder.java\n               current.isUnknownType() ||\n               alternate.isNoResolvedType() ||\n               current.isNoResolvedType() ||\n-              alternate.hasAnyTemplate() ||\n-              current.hasAnyTemplate()) {\n+              alternate.hasAnyTemplateTypes() ||\n+              current.hasAnyTemplateTypes()) {\n             if (alternate.isEquivalentTo(current)) {\n               // Alternate is unnecessary.\n               return this;\n--- a/src/com/google/javascript/rhino/testing/BaseJSTypeTestCase.java\n+++ b/src/com/google/javascript/rhino/testing/BaseJSTypeTestCase.java\n \n package com.google.javascript.rhino.testing;\n \n+import com.google.common.collect.ImmutableList;\n import com.google.javascript.rhino.JSTypeExpression;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.jstype.FunctionBuilder;\n   protected ObjectType NO_OBJECT_TYPE;\n   protected ObjectType NO_TYPE;\n   protected ObjectType NO_RESOLVED_TYPE;\n-  protected JSType ARRAY_FUNCTION_TYPE;\n+  protected FunctionType ARRAY_FUNCTION_TYPE;\n   protected ObjectType ARRAY_TYPE;\n   protected JSType BOOLEAN_OBJECT_FUNCTION_TYPE;\n   protected ObjectType BOOLEAN_OBJECT_TYPE;\n     NO_RESOLVED_TYPE =\n         registry.getNativeObjectType(JSTypeNative.NO_RESOLVED_TYPE);\n     ARRAY_FUNCTION_TYPE =\n-        registry.getNativeType(JSTypeNative.ARRAY_FUNCTION_TYPE);\n+        registry.getNativeFunctionType(JSTypeNative.ARRAY_FUNCTION_TYPE);\n     ARRAY_TYPE =\n         registry.getNativeObjectType(JSTypeNative.ARRAY_TYPE);\n     BOOLEAN_OBJECT_FUNCTION_TYPE =\n     return registry.createOptionalType(type);\n   }\n \n+  protected JSType createTemplatizedType(\n+      JSType baseType, ImmutableList<JSType> templatizedTypes) {\n+    return registry.createTemplatizedType(baseType, templatizedTypes);\n+  }\n+\n   /**\n    * Asserts that a Node representing a type expression resolves to the\n    * correct {@code JSType}.\n--- a/test/com/google/javascript/jscomp/ClosureCodingConventionTest.java\n+++ b/test/com/google/javascript/jscomp/ClosureCodingConventionTest.java\n \n     Node nodeA = new Node(Token.FUNCTION);\n     FunctionType ctorA = registry.createConstructorType(\"A\", nodeA,\n-        new Node(Token.PARAM_LIST), null);\n+        new Node(Token.PARAM_LIST), null, null);\n \n     Node nodeB = new Node(Token.FUNCTION);\n     FunctionType ctorB = registry.createConstructorType(\"B\", nodeB,\n-        new Node(Token.PARAM_LIST), null);\n+        new Node(Token.PARAM_LIST), null, null);\n \n     conv.applySubclassRelationship(ctorA, ctorB, SubclassType.INHERITS);\n \n--- a/test/com/google/javascript/jscomp/ConcreteTypeTest.java\n+++ b/test/com/google/javascript/jscomp/ConcreteTypeTest.java\n \n     JSType[] paramTypes = new JSType[paramNames.length];\n     Arrays.fill(paramTypes, unknownType);\n-    decl.setJSType(\n-        typeRegistry.createConstructorType(name, decl, args, unknownType));\n+    decl.setJSType(typeRegistry.createConstructorType(\n+        name, decl, args, unknownType, null));\n \n     return new ConcreteFunctionType(factory, decl, null);\n   }\n--- a/test/com/google/javascript/rhino/jstype/FunctionTypeTest.java\n+++ b/test/com/google/javascript/rhino/jstype/FunctionTypeTest.java\n \n   public void testCtorWithPrototypeSet() {\n     FunctionType ctor = registry.createConstructorType(\n-        \"Foo\", null, null, null);\n+        \"Foo\", null, null, null, null);\n     assertFalse(ctor.getInstanceType().isUnknownType());\n \n     Node node = new Node(Token.OBJECTLIT);\n--- a/test/com/google/javascript/rhino/jstype/JSTypeTest.java\n+++ b/test/com/google/javascript/rhino/jstype/JSTypeTest.java\n import com.google.javascript.rhino.jstype.JSType.TypePair;\n import com.google.javascript.rhino.jstype.RecordTypeBuilder.RecordProperty;\n import com.google.javascript.rhino.testing.Asserts;\n+import com.google.javascript.rhino.testing.AbstractStaticScope;\n import com.google.javascript.rhino.testing.BaseJSTypeTestCase;\n-import com.google.javascript.rhino.testing.AbstractStaticScope;\n import com.google.javascript.rhino.testing.MapBasedScope;\n \n import java.util.HashMap;\n         Lists.<ObjectType>newArrayList(interfaceInstType));\n     subInterfaceInstType = subInterfaceType.getInstanceType();\n \n-    googBar = registry.createConstructorType(\"goog.Bar\", null, null, null);\n+    googBar = registry.createConstructorType(\n+        \"goog.Bar\", null, null, null, null);\n     googBar.getPrototype().defineDeclaredProperty(\"date\", DATE_TYPE,\n         null);\n     googBar.setImplementedInterfaces(\n     googBarInst = googBar.getInstanceType();\n \n     googSubBar = registry.createConstructorType(\n-        \"googSubBar\", null, null, null);\n+        \"googSubBar\", null, null, null, null);\n     googSubBar.setPrototypeBasedOn(googBar.getInstanceType());\n     googSubBarInst = googSubBar.getInstanceType();\n \n     googSubSubBar = registry.createConstructorType(\n-        \"googSubSubBar\", null, null, null);\n+        \"googSubSubBar\", null, null, null, null);\n     googSubSubBar.setPrototypeBasedOn(googSubBar.getInstanceType());\n     googSubSubBarInst = googSubSubBar.getInstanceType();\n \n         canTestForShallowEqualityWith(SYNTAX_ERROR_TYPE));\n     assertFalse(U2U_CONSTRUCTOR_TYPE.\n         canTestForShallowEqualityWith(TYPE_ERROR_TYPE));\n-    assertTrue( U2U_CONSTRUCTOR_TYPE.\n+    assertTrue(U2U_CONSTRUCTOR_TYPE.\n         canTestForShallowEqualityWith(ALL_TYPE));\n     assertFalse(U2U_CONSTRUCTOR_TYPE.\n         canTestForShallowEqualityWith(VOID_TYPE));\n    */\n   public void testFunctionPrototypeAndImplicitPrototype1() {\n     FunctionType constructor =\n-        registry.createConstructorType(\"Foo\", null, null, null);\n+        registry.createConstructorType(\"Foo\", null, null, null, null);\n     ObjectType instance = constructor.getInstanceType();\n \n     // adding one property on the prototype\n     NamedType b = new NamedType(registry, \"typeB\", \"source\", 1, 0);\n \n     ObjectType realA = registry.createConstructorType(\n-        \"typeA\", null, null, null).getInstanceType();\n+        \"typeA\", null, null, null, null).getInstanceType();\n     ObjectType realB = registry.createEnumType(\n         \"typeB\", null, NUMBER_TYPE).getElementsType();\n     registry.declareType(\"typeA\", realA);\n \n   public void testConstructorWithArgSubtypeChain() throws Exception {\n     FunctionType googBarArgConstructor = registry.createConstructorType(\n-        \"barArg\", null, registry.createParameters(googBar), null);\n+        \"barArg\", null, registry.createParameters(googBar), null, null);\n     FunctionType googSubBarArgConstructor = registry.createConstructorType(\n-        \"subBarArg\", null, registry.createParameters(googSubBar), null);\n+        \"subBarArg\", null, registry.createParameters(googSubBar), null, null);\n \n     List<JSType> typeChain = Lists.newArrayList(\n         registry.getNativeType(JSTypeNative.FUNCTION_INSTANCE_TYPE),\n \n   public void testInterfaceInheritanceSubtypeChain() throws Exception {\n     FunctionType tempType =\n-      registry.createConstructorType(\"goog.TempType\", null, null, null);\n+      registry.createConstructorType(\"goog.TempType\", null, null, null, null);\n     tempType.setImplementedInterfaces(\n         Lists.<ObjectType>newArrayList(subInterfaceInstType));\n     List<JSType> typeChain = Lists.newArrayList(\n   }\n \n   public void testGoodSetPrototypeBasedOn() {\n-    FunctionType fun = registry.createConstructorType(\"fun\", null, null, null);\n+    FunctionType fun = registry.createConstructorType(\n+        \"fun\", null, null, null, null);\n     fun.setPrototypeBasedOn(unresolvedNamedType);\n     assertTrue(fun.getInstanceType().isUnknownType());\n   }\n \n   public void testLateSetPrototypeBasedOn() {\n-    FunctionType fun = registry.createConstructorType(\"fun\", null, null, null);\n+    FunctionType fun = registry.createConstructorType(\n+        \"fun\", null, null, null, null);\n     assertFalse(fun.getInstanceType().isUnknownType());\n \n     fun.setPrototypeBasedOn(unresolvedNamedType);\n   public void testIsTemplatedType() throws Exception {\n     assertTrue(\n         new TemplateType(registry, \"T\")\n-            .hasAnyTemplate());\n+            .hasAnyTemplateTypes());\n     assertFalse(\n         ARRAY_TYPE\n-            .hasAnyTemplate());\n+            .hasAnyTemplateTypes());\n \n     assertTrue(\n         registry.createParameterizedType(\n             ARRAY_TYPE, new TemplateType(registry, \"T\"))\n-            .hasAnyTemplate());\n+            .hasAnyTemplateTypes());\n     assertFalse(\n         registry.createParameterizedType(\n             ARRAY_TYPE, STRING_TYPE)\n-            .hasAnyTemplate());\n+            .hasAnyTemplateTypes());\n \n     assertTrue(\n         new FunctionBuilder(registry)\n             .withReturnType(new TemplateType(registry, \"T\"))\n             .build()\n-            .hasAnyTemplate());\n+            .hasAnyTemplateTypes());\n     assertTrue(\n         new FunctionBuilder(registry)\n             .withTypeOfThis(new TemplateType(registry, \"T\"))\n             .build()\n-            .hasAnyTemplate());\n+            .hasAnyTemplateTypes());\n     assertFalse(\n         new FunctionBuilder(registry)\n             .withReturnType(STRING_TYPE)\n             .build()\n-            .hasAnyTemplate());\n+            .hasAnyTemplateTypes());\n \n     assertTrue(\n         registry.createUnionType(\n             NULL_TYPE, new TemplateType(registry, \"T\"), STRING_TYPE)\n-            .hasAnyTemplate());\n+            .hasAnyTemplateTypes());\n     assertFalse(\n         registry.createUnionType(\n             NULL_TYPE, ARRAY_TYPE, STRING_TYPE)\n-            .hasAnyTemplate());\n+            .hasAnyTemplateTypes());\n+  }\n+\n+  public void testTemplatizedType() throws Exception {\n+    FunctionType templatizedCtor = registry.createConstructorType(\n+        \"TestingType\", null, null, UNKNOWN_TYPE, ImmutableList.of(\"A\", \"B\"));\n+    JSType templatizedInstance = registry.createTemplatizedType(\n+        templatizedCtor.getInstanceType(),\n+        ImmutableList.of(NUMBER_TYPE, STRING_TYPE));\n+\n+    assertTrue(templatizedInstance.isTemplatized());\n+    assertTrue(templatizedInstance.hasTemplatizedType(\"A\"));\n+    assertTrue(templatizedInstance.hasTemplatizedType(\"B\"));\n+    assertFalse(templatizedInstance.hasTemplatizedType(\"C\"));\n+\n+    assertEquals(NUMBER_TYPE, templatizedInstance.getTemplatizedType(\"A\"));\n+    assertEquals(STRING_TYPE, templatizedInstance.getTemplatizedType(\"B\"));\n+    assertEquals(UNKNOWN_TYPE, templatizedInstance.getTemplatizedType(\"C\"));\n+\n+    assertEquals(\"TestingType.<number,string>\", templatizedInstance.toString());\n+  }\n+\n+  public void testPartiallyTemplatizedType() throws Exception {\n+    FunctionType templatizedCtor = registry.createConstructorType(\n+        \"TestingType\", null, null, UNKNOWN_TYPE, ImmutableList.of(\"A\", \"B\"));\n+    JSType templatizedInstance = registry.createTemplatizedType(\n+        templatizedCtor.getInstanceType(),\n+        ImmutableList.of(NUMBER_TYPE));\n+\n+    assertTrue(templatizedInstance.isTemplatized());\n+    assertTrue(templatizedInstance.hasTemplatizedType(\"A\"));\n+    assertTrue(templatizedInstance.hasTemplatizedType(\"B\"));\n+    assertFalse(templatizedInstance.hasTemplatizedType(\"C\"));\n+\n+    assertEquals(NUMBER_TYPE, templatizedInstance.getTemplatizedType(\"A\"));\n+    assertEquals(UNKNOWN_TYPE, templatizedInstance.getTemplatizedType(\"B\"));\n+    assertEquals(UNKNOWN_TYPE, templatizedInstance.getTemplatizedType(\"C\"));\n+\n+    assertEquals(\"TestingType.<number,?>\", templatizedInstance.toString());\n+  }\n+\n+  public void testInvalidTemplatizedType() throws Exception {\n+    FunctionType templatizedCtor = registry.createConstructorType(\n+        \"TestingType\", null, null, UNKNOWN_TYPE, ImmutableList.of(\"A\", \"B\"));\n+\n+    boolean exceptionThrown = false;\n+    try {\n+      JSType templatizedInstance = registry.createTemplatizedType(\n+          templatizedCtor.getInstanceType(),\n+          ImmutableList.of(NUMBER_TYPE, STRING_TYPE, BOOLEAN_TYPE));\n+    } catch (IllegalArgumentException e) {\n+      exceptionThrown = true;\n+    }\n+    assertTrue(exceptionThrown);\n   }\n \n   private static boolean containsType(\n--- a/test/com/google/javascript/rhino/jstype/NamedTypeTest.java\n+++ b/test/com/google/javascript/rhino/jstype/NamedTypeTest.java\n   public void testNamedTypeProperties() {\n     NamedType namedA = new NamedType(registry, \"TypeA\", \"source\", 1, 0);\n     FunctionType ctorA = registry.createConstructorType(\n-        \"TypeA\", null, null, null);\n+        \"TypeA\", null, null, null, null);\n     ObjectType typeA = ctorA.getInstanceType();\n \n     namedA.defineDeclaredProperty(\"foo\", NUMBER_TYPE, null);", "timestamp": 1351112840, "metainfo": ""}