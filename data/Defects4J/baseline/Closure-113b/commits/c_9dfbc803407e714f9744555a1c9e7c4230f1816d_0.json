{"sha": "9dfbc803407e714f9744555a1c9e7c4230f1816d", "log": "Use the new IR interface where possible.  R=nicksantos   Revision created by MOE tool push_codebase. MOE_MIGRATION=3799   ", "commit": "\n--- a/src/com/google/javascript/jscomp/AliasExternals.java\n+++ b/src/com/google/javascript/jscomp/AliasExternals.java\n       getPropNode.removeChild(propSrc);\n \n       Node newNameNode =\n-        Node.newString(Token.NAME, getArrayNotationNameFor(propName));\n-\n-      Node elemNode = new Node(Token.GETELEM, propSrc, newNameNode);\n+          IR.name(getArrayNotationNameFor(propName));\n+\n+      Node elemNode = IR.getelem(propSrc, newNameNode);\n       replaceNode(getPropNode.getParent(), getPropNode, elemNode);\n \n       compiler.reportCodeChange();\n \n       // Create the call GETPROP_prop() node, using the old propSrc as the\n       // one paremeter to GETPROP_prop() call.\n-      Node callName = Node.newString(Token.NAME,\n-        getMutatorFor(propNameNode.getString()));\n-      Node call = new Node(Token.CALL, callName, propSrc, propDest);\n+      Node callName = IR.name(\n+          getMutatorFor(propNameNode.getString()));\n+      Node call = IR.call( callName, propSrc, propDest);\n       call.putBooleanProp(Node.FREE_CALL, true);\n \n       // And replace the assign statement with the new call\n         name PROP_length\n             string length\n      */\n-    Node propValue = Node.newString(Token.STRING, propName);\n+    Node propValue = IR.string(propName);\n     Node propNameNode =\n-      Node.newString(Token.NAME, getArrayNotationNameFor(propName));\n+        IR.name(getArrayNotationNameFor(propName));\n     propNameNode.addChildToFront(propValue);\n-    Node var = new Node(Token.VAR, propNameNode);\n+    Node var = IR.var(propNameNode);\n     root.addChildToFront(var);\n \n     compiler.reportCodeChange();\n      */\n \n     String globalName = global.name;\n-    Node globalValue = Node.newString(Token.NAME, global.name);\n+    Node globalValue = IR.name(global.name);\n     globalValue.putBooleanProp(Node.IS_CONSTANT_NAME, global.isConstant);\n \n-    Node globalNameNode =\n-      Node.newString(Token.NAME, \"GLOBAL_\" + globalName);\n+    Node globalNameNode = IR.name(\"GLOBAL_\" + globalName);\n     globalNameNode.addChildToFront(globalValue);\n-    Node var = new Node(Token.VAR, globalNameNode);\n+    Node var = IR.var(globalNameNode);\n     root.addChildToFront(var);\n \n     compiler.reportCodeChange();\n--- a/src/com/google/javascript/jscomp/AliasKeywords.java\n+++ b/src/com/google/javascript/jscomp/AliasKeywords.java\n       Node name = NodeUtil.newName(\n           compiler.getCodingConvention(),\n           getAliasName(), throwNode, getAliasName());\n-      Node aliasCall = new Node(Token.CALL, name, throwNode.removeFirstChild());\n+      Node aliasCall = IR.call( name, throwNode.removeFirstChild());\n       aliasCall.putBooleanProp(Node.FREE_CALL, true);\n-      Node exprResult = new Node(Token.EXPR_RESULT, aliasCall);\n+      Node exprResult = IR.exprResult(aliasCall);\n       parent.replaceChild(throwNode, exprResult);\n     }\n \n      */\n     protected void insertAliasDeclaration(Node codeRoot) {\n       Node varNode = new Node(Token.VAR);\n-      Node value = new Node(Token.VOID, Node.newNumber(0));\n+      Node value = IR.voidNode(IR.number(0));\n       Node name = NodeUtil.newName(\n           compiler.getCodingConvention(), getAliasName(),\n           varNode, getAliasName());\n--- a/src/com/google/javascript/jscomp/AliasStrings.java\n+++ b/src/com/google/javascript/jscomp/AliasStrings.java\n                                           String name,\n                                           StringInfo info) {\n     occurrence.parent.replaceChild(occurrence.node,\n-                                   Node.newString(Token.NAME, name));\n+                                   IR.name(name));\n     info.isAliased = true;\n     compiler.reportCodeChange();\n   }\n--- a/src/com/google/javascript/jscomp/AstChangeProxy.java\n+++ b/src/com/google/javascript/jscomp/AstChangeProxy.java\n \n import com.google.common.base.Preconditions;\n import com.google.common.collect.Lists;\n+import com.google.javascript.rhino.IR;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n \n         parentType == Token.LABEL);\n \n     if (parentType == Token.LABEL && size != 1) {\n-      Node block = new Node(Token.BLOCK);\n+      Node block = IR.block();\n       for (Node newChild : replacements) {\n         newChild.copyInformationFrom(node);\n         Node oldParent = newChild.getParent();\n--- a/src/com/google/javascript/jscomp/AstParallelizer.java\n+++ b/src/com/google/javascript/jscomp/AstParallelizer.java\n import com.google.common.base.Predicate;\n import com.google.common.base.Supplier;\n import com.google.common.collect.Lists;\n+import com.google.javascript.rhino.IR;\n import com.google.javascript.rhino.Node;\n-import com.google.javascript.rhino.Token;\n-\n import java.util.List;\n \n /**\n     Supplier<Node> placeHolders = new Supplier<Node>() {\n       @Override\n       public Node get() {\n-        return new Node(Token.FUNCTION,\n-            Node.newString(Token.NAME, TEMP_NAME),\n-            new Node(Token.PARAM_LIST), new Node(Token.BLOCK));\n+        return IR.function(IR.name(TEMP_NAME), IR.paramList(), IR.block());\n       }\n     };\n     return new AstParallelizer(\n     Supplier<Node> placeHolders = new Supplier<Node>() {\n       @Override\n       public Node get() {\n-        return NodeUtil.newExpr(Node.newString(TEMP_NAME));\n+        return NodeUtil.newExpr(IR.string(TEMP_NAME));\n       }\n     };\n \n--- a/src/com/google/javascript/jscomp/ClosureOptimizePrimitives.java\n+++ b/src/com/google/javascript/jscomp/ClosureOptimizePrimitives.java\n \n import com.google.common.collect.Lists;\n import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n+import com.google.javascript.rhino.IR;\n import com.google.javascript.rhino.Node;\n-import com.google.javascript.rhino.Token;\n-\n import java.util.List;\n \n /**\n     for (Node callNode : callNodes) {\n       Node curParam = callNode.getFirstChild().getNext();\n       if (canOptimizeObjectCreate(curParam)) {\n-        Node objNode = new Node(Token.OBJECTLIT)\n-            .copyInformationFrom(callNode);\n+        Node objNode = IR.objectlit().srcref(callNode);\n         while (curParam != null) {\n           Node keyNode = curParam;\n           Node valueNode = curParam.getNext();\n           callNode.removeChild(valueNode);\n \n           if (!keyNode.isString()) {\n-            keyNode = Node.newString(NodeUtil.getStringValue(keyNode))\n-                .copyInformationFrom(keyNode);\n+            keyNode = IR.string(NodeUtil.getStringValue(keyNode))\n+                .srcref(keyNode);\n           }\n           keyNode.setQuotedString();\n-          keyNode.addChildToBack(valueNode);\n-          objNode.addChildToBack(keyNode);\n+          objNode.addChildToBack(IR.propdef(keyNode, valueNode));\n         }\n         callNode.getParent().replaceChild(callNode, objNode);\n         compiler.reportCodeChange();\n--- a/src/com/google/javascript/jscomp/CoalesceVariableNames.java\n+++ b/src/com/google/javascript/jscomp/CoalesceVariableNames.java\n import com.google.javascript.jscomp.graph.GraphNode;\n import com.google.javascript.jscomp.graph.LinkedUndirectedGraph;\n import com.google.javascript.jscomp.graph.UndiGraph;\n+import com.google.javascript.rhino.IR;\n import com.google.javascript.rhino.Node;\n-import com.google.javascript.rhino.Token;\n-\n import java.util.Comparator;\n import java.util.Deque;\n import java.util.Iterator;\n       if (name.hasChildren()) {\n         Node value = name.removeFirstChild();\n         var.removeChild(name);\n-        Node assign = new Node(Token.ASSIGN, name, value)\n-            .copyInformationFrom(name);\n+        Node assign = IR.assign(name, value).srcref(name);\n \n         // We don't need to wrapped it with EXPR node if it is within a FOR.\n         if (!parent.isFor()) {\n--- a/src/com/google/javascript/jscomp/CollapseProperties.java\n+++ b/src/com/google/javascript/jscomp/CollapseProperties.java\n import com.google.javascript.jscomp.ReferenceCollectingCallback.ReferenceCollection;\n import com.google.javascript.jscomp.Scope;\n import com.google.javascript.jscomp.Scope.Var;\n+import com.google.javascript.rhino.IR;\n import com.google.javascript.rhino.JSDocInfo;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n         }\n \n         // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, new Node(Token.NULL));\n+        aliasParent.replaceChild(alias.node, IR.nullNode());\n         compiler.reportCodeChange();\n \n         // Inlining the variable may have introduced new references\n     Node nameNode = NodeUtil.newName(\n         compiler.getCodingConvention(), alias, ref.node,\n         name.getFullName());\n-    Node varNode = new Node(Token.VAR, nameNode).copyInformationFrom(nameNode);\n+    Node varNode = IR.var(nameNode).copyInformationFrom(nameNode);\n \n     Preconditions.checkState(\n         ref.node.getParent().isExprResult());\n       parent.removeChild(rvalue);\n       nameNode.addChildToFront(rvalue);\n \n-      Node varNode = new Node(Token.VAR, nameNode);\n+      Node varNode = IR.var(nameNode);\n       greatGramps.replaceChild(gramps, varNode);\n     } else {\n       // This must be a complex assignment.\n \n       // Create a stub variable declaration right\n       // before the current statement.\n-      Node stubVar = new Node(Token.VAR, nameNode.cloneTree())\n+      Node stubVar = IR.var(nameNode.cloneTree())\n           .copyInformationFrom(nameNode);\n       currentParent.addChildBefore(stubVar, current);\n \n         value.detachFromParent();\n       } else {\n         // Substitute a reference for the value.\n-        refNode = Node.newString(Token.NAME, propAlias);\n+        refNode = IR.name(propAlias);\n         if (key.getBooleanProp(Node.IS_CONSTANT_NAME)) {\n           refNode.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n         }\n       }\n \n       // Declare the collapsed name as a variable with the original value.\n-      Node nameNode = Node.newString(Token.NAME, propAlias);\n+      Node nameNode = IR.name(propAlias);\n       nameNode.addChildToFront(value);\n       if (key.getBooleanProp(Node.IS_CONSTANT_NAME)) {\n         nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n       }\n-      Node newVar = new Node(Token.VAR, nameNode)\n+      Node newVar = IR.var(nameNode)\n           .copyInformationFromForTree(key);\n       if (nameToAddAfter != null) {\n         varParent.addChildAfter(newVar, nameToAddAfter);\n       for (Name p : n.props) {\n         if (p.needsToBeStubbed()) {\n           String propAlias = appendPropForAlias(alias, p.getBaseName());\n-          Node nameNode = Node.newString(Token.NAME, propAlias);\n-          Node newVar = new Node(Token.VAR, nameNode)\n+          Node nameNode = IR.name(propAlias);\n+          Node newVar = IR.var(nameNode)\n               .copyInformationFromForTree(addAfter);\n           parent.addChildAfter(newVar, addAfter);\n           addAfter = newVar;\n--- a/src/com/google/javascript/jscomp/Compiler.java\n+++ b/src/com/google/javascript/jscomp/Compiler.java\n import com.google.javascript.jscomp.mozilla.rhino.ErrorReporter;\n import com.google.javascript.jscomp.parsing.Config;\n import com.google.javascript.jscomp.parsing.ParserRunner;\n+import com.google.javascript.rhino.IR;\n import com.google.javascript.rhino.InputId;\n import com.google.javascript.rhino.JSDocInfo;\n import com.google.javascript.rhino.Node;\n-import com.google.javascript.rhino.Token;\n import com.google.javascript.rhino.jstype.JSTypeRegistry;\n \n import java.io.IOException;\n     }\n \n     // Parse main js sources.\n-    jsRoot = new Node(Token.BLOCK);\n+    jsRoot = IR.block();\n     jsRoot.setIsSyntheticBlock(true);\n \n-    externsRoot = new Node(Token.BLOCK);\n+    externsRoot = IR.block();\n     externsRoot.setIsSyntheticBlock(true);\n \n-    externAndJsRoot = new Node(Token.BLOCK, externsRoot, jsRoot);\n+    externAndJsRoot = IR.block(externsRoot, jsRoot);\n     externAndJsRoot.setIsSyntheticBlock(true);\n \n     if (options.tracer.isOn()) {\n--- a/src/com/google/javascript/jscomp/CompilerOptions.java\n+++ b/src/com/google/javascript/jscomp/CompilerOptions.java\n import com.google.common.collect.Maps;\n import com.google.common.collect.Multimap;\n import com.google.common.collect.Sets;\n+import com.google.javascript.rhino.IR;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.SourcePosition;\n-import com.google.javascript.rhino.Token;\n-\n import java.io.Serializable;\n import java.util.Collections;\n import java.util.List;\n       String name = entry.getKey();\n       Object value = entry.getValue();\n       if (value instanceof Boolean) {\n-        map.put(name, ((Boolean) value).booleanValue() ?\n-            new Node(Token.TRUE) : new Node(Token.FALSE));\n+        map.put(name, NodeUtil.booleanNode(((Boolean) value).booleanValue()));\n       } else if (value instanceof Integer) {\n-        map.put(name, Node.newNumber(((Integer) value).intValue()));\n+        map.put(name, IR.number(((Integer) value).intValue()));\n       } else if (value instanceof Double) {\n-        map.put(name, Node.newNumber(((Double) value).doubleValue()));\n+        map.put(name, IR.number(((Double) value).doubleValue()));\n       } else {\n         Preconditions.checkState(value instanceof String);\n-        map.put(name, Node.newString((String) value));\n+        map.put(name, IR.string((String) value));\n       }\n     }\n     return map;\n--- a/src/com/google/javascript/jscomp/ConvertToDottedProperties.java\n+++ b/src/com/google/javascript/jscomp/ConvertToDottedProperties.java\n package com.google.javascript.jscomp;\n \n import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n+import com.google.javascript.rhino.IR;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n \n             NodeUtil.isValidPropertyName(right.getString())) {\n           n.removeChild(left);\n           n.removeChild(right);\n-          parent.replaceChild(n, new Node(Token.GETPROP, left, right));\n+          parent.replaceChild(n, IR.getprop(left, right));\n           compiler.reportCodeChange();\n         }\n         break;\n--- a/src/com/google/javascript/jscomp/CreateSyntheticBlocks.java\n+++ b/src/com/google/javascript/jscomp/CreateSyntheticBlocks.java\n \n import com.google.common.collect.Lists;\n import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n+import com.google.javascript.rhino.IR;\n import com.google.javascript.rhino.Node;\n-import com.google.javascript.rhino.Token;\n-\n import java.util.ArrayDeque;\n import java.util.Deque;\n import java.util.List;\n \n \n     Node originalParent = marker.endMarker.getParent();\n-    Node outerBlock = new Node(Token.BLOCK);\n+    Node outerBlock = IR.block();\n     outerBlock.setIsSyntheticBlock(true);\n     originalParent.addChildBefore(outerBlock, marker.startMarker);\n \n-    Node innerBlock = new Node(Token.BLOCK);\n+    Node innerBlock = IR.block();\n     innerBlock.setIsSyntheticBlock(true);\n     // Move everything after the start Node up to the end Node into the inner\n     // block.\n--- a/src/com/google/javascript/jscomp/CrossModuleMethodMotion.java\n+++ b/src/com/google/javascript/jscomp/CrossModuleMethodMotion.java\n import com.google.javascript.jscomp.AnalyzePrototypeProperties.NameInfo;\n import com.google.javascript.jscomp.AnalyzePrototypeProperties.Property;\n import com.google.javascript.jscomp.AnalyzePrototypeProperties.Symbol;\n+import com.google.javascript.rhino.IR;\n import com.google.javascript.rhino.Node;\n-import com.google.javascript.rhino.Token;\n-\n import java.io.Serializable;\n import java.util.Collection;\n import java.util.Iterator;\n           int stubId = idGenerator.newId();\n \n           // example: JSCompiler_stubMethod(id);\n-          Node stubCall = new Node(Token.CALL,\n-              Node.newString(Token.NAME, STUB_METHOD_NAME),\n-              Node.newNumber(stubId))\n+          Node stubCall = IR.call(\n+              IR.name(STUB_METHOD_NAME),\n+              IR.number(stubId))\n               .copyInformationFromForTree(value);\n           stubCall.putBooleanProp(Node.FREE_CALL, true);\n \n           // unstub the function body in the deeper module\n           Node unstubParent = compiler.getNodeForCodeInsertion(\n               deepestCommonModuleRef);\n-          Node unstubCall = new Node(Token.CALL,\n-              Node.newString(Token.NAME, UNSTUB_METHOD_NAME),\n-              Node.newNumber(stubId),\n+          Node unstubCall = IR.call(\n+              IR.name(UNSTUB_METHOD_NAME),\n+              IR.number(stubId),\n               value);\n           unstubCall.putBooleanProp(Node.FREE_CALL, true);\n           unstubParent.addChildToFront(\n               // A.prototype.b = JSCompiler_unstubMethod(id, body);\n-              new Node(Token.EXPR_RESULT,\n-                  new Node(Token.ASSIGN,\n-                      new Node(Token.GETPROP,\n+              IR.exprResult(\n+                  IR.assign(\n+                      IR.getprop(\n                           proto.cloneTree(),\n-                          Node.newString(Token.STRING, nameInfo.name)),\n+                          IR.string(nameInfo.name)),\n                       unstubCall))\n                   .copyInformationFromForTree(value));\n \n--- a/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java\n+++ b/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java\n import com.google.javascript.jscomp.NodeTraversal.ScopedCallback;\n import com.google.javascript.jscomp.Scope.Var;\n import com.google.javascript.jscomp.graph.DiGraph.DiGraphNode;\n+import com.google.javascript.rhino.IR;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n \n       } else if (n.isInc() || n.isDec()) {\n         if (NodeUtil.isExpressionNode(parent)) {\n           parent.replaceChild(n,\n-              new Node(Token.VOID, Node.newNumber(0).copyInformationFrom(n)));\n+              IR.voidNode(IR.number(0).srcref(n)));\n         } else if(n.isComma() && n != parent.getLastChild()) {\n           parent.removeChild(n);\n         } else if (parent.isFor() && !NodeUtil.isForIn(parent) &&\n             NodeUtil.getConditionExpression(parent) != n) {\n-          parent.replaceChild(n, new Node(Token.EMPTY));\n+          parent.replaceChild(n, IR.empty());\n         } else {\n           // Cannot replace x = a++ with x = a because that's not valid\n           // when a is not a number.\n--- a/src/com/google/javascript/jscomp/DefaultPassConfig.java\n+++ b/src/com/google/javascript/jscomp/DefaultPassConfig.java\n import com.google.javascript.jscomp.CompilerOptions.LanguageMode;\n import com.google.javascript.jscomp.ExtractPrototypeMemberDeclarations.Pattern;\n import com.google.javascript.jscomp.NodeTraversal.Callback;\n+import com.google.javascript.rhino.IR;\n import com.google.javascript.rhino.Node;\n-import com.google.javascript.rhino.Token;\n-\n import java.io.File;\n import java.io.FileReader;\n import java.io.IOException;\n     Map<String, Node> additionalReplacements = Maps.newHashMap();\n \n     if (options.markAsCompiled || options.closurePass) {\n-      additionalReplacements.put(COMPILED_CONSTANT_NAME, new Node(Token.TRUE));\n+      additionalReplacements.put(COMPILED_CONSTANT_NAME, IR.trueNode());\n     }\n \n     if (options.closurePass && options.locale != null) {\n       additionalReplacements.put(CLOSURE_LOCALE_CONSTANT_NAME,\n-          Node.newString(options.locale));\n+          IR.string(options.locale));\n     }\n \n     return additionalReplacements;\n--- a/src/com/google/javascript/jscomp/DefinitionsRemover.java\n+++ b/src/com/google/javascript/jscomp/DefinitionsRemover.java\n \n import com.google.common.base.Preconditions;\n import com.google.common.collect.ImmutableSet;\n+import com.google.javascript.rhino.IR;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n \n     @Override\n     public void performRemove() {\n       // replace internal name with \"\"\n-      function.replaceChild(function.getFirstChild(),\n-                            Node.newString(Token.NAME, \"\"));\n+      function.replaceChild(function.getFirstChild(), IR.name(\"\"));\n     }\n   }\n \n         case Token.GETTER_DEF:\n         case Token.STRING:\n           // TODO(johnlenz): return a GETELEM for quoted strings.\n-          return new Node(Token.GETPROP,\n-            new Node(Token.OBJECTLIT),\n-            name.cloneNode());\n+          return IR.getprop(\n+              IR.objectlit(),\n+              IR.string(name.getString()));\n         default:\n           throw new IllegalStateException(\"unexpected\");\n       }\n--- a/src/com/google/javascript/jscomp/DevirtualizePrototypeMethods.java\n+++ b/src/com/google/javascript/jscomp/DevirtualizePrototypeMethods.java\n import com.google.common.base.Preconditions;\n import com.google.common.collect.Lists;\n import com.google.javascript.jscomp.DefinitionsRemover.Definition;\n+import com.google.javascript.rhino.IR;\n import com.google.javascript.rhino.Node;\n-import com.google.javascript.rhino.Token;\n import com.google.javascript.rhino.jstype.FunctionType;\n import com.google.javascript.rhino.jstype.JSType;\n import com.google.javascript.rhino.jstype.JSTypeNative;\n       Node objectNode = node.getFirstChild();\n       node.removeChild(objectNode);\n       parent.replaceChild(node, objectNode);\n-      parent.addChildToFront(\n-          Node.newString(Token.NAME, newMethodName)\n-              .copyInformationFrom(node));\n+      parent.addChildToFront(IR.name(newMethodName).srcref(node));\n       Preconditions.checkState(parent.isCall());\n       parent.putBooleanProp(Node.FREE_CALL, true);\n       compiler.reportCodeChange();\n     Node expr = parent.getParent();\n     Node block = expr.getParent();\n \n-    Node newNameNode = Node.newString(Token.NAME, newMethodName)\n+    Node newNameNode = IR.name(newMethodName)\n         .copyInformationFrom(parent.getFirstChild());\n \n     if (specializationState != null) {\n \n     parent.removeChild(functionNode);\n     newNameNode.addChildToFront(functionNode);\n-    block.replaceChild(expr, new Node(Token.VAR, newNameNode));\n+    block.replaceChild(expr, IR.var(newNameNode));\n \n     // add extra argument\n     String self = newMethodName + \"$self\";\n     Node argList = functionNode.getFirstChild().getNext();\n-    argList.addChildToFront(Node.newString(Token.NAME, self)\n+    argList.addChildToFront(IR.name(self)\n         .copyInformationFrom(functionNode));\n \n     // rewrite body\n \n     for (Node child : node.children()) {\n       if (child.isThis()) {\n-        Node newName = Node.newString(Token.NAME, name);\n+        Node newName = IR.name(name);\n         newName.setJSType(child.getJSType());\n         node.replaceChild(child, newName);\n       } else {\n--- a/src/com/google/javascript/jscomp/ExportTestFunctions.java\n+++ b/src/com/google/javascript/jscomp/ExportTestFunctions.java\n package com.google.javascript.jscomp;\n \n import com.google.common.base.Preconditions;\n+import com.google.javascript.rhino.IR;\n import com.google.javascript.rhino.Node;\n-import com.google.javascript.rhino.Token;\n-\n import java.util.regex.Pattern;\n \n /**\n     Node exportCallTarget = NodeUtil.newQualifiedNameNode(\n         compiler.getCodingConvention(),\n         exportSymbolFunction, node, testFunctionName);\n-    Node call = new Node(Token.CALL, exportCallTarget);\n+    Node call = IR.call( exportCallTarget);\n     if (exportCallTarget.isName()) {\n       call.putBooleanProp(Node.FREE_CALL, true);\n     }\n-    call.addChildToBack(Node.newString(testFunctionName));\n+    call.addChildToBack(IR.string(testFunctionName));\n     call.addChildToBack(NodeUtil.newQualifiedNameNode(\n         compiler.getCodingConvention(),\n         testFunctionName, node, testFunctionName));\n \n-    Node expression = new Node(Token.EXPR_RESULT, call);\n+    Node expression = IR.exprResult(call);\n \n     scriptNode.addChildAfter(expression, node);\n     compiler.reportCodeChange();\n--- a/src/com/google/javascript/jscomp/ExpressionDecomposer.java\n+++ b/src/com/google/javascript/jscomp/ExpressionDecomposer.java\n import com.google.common.base.Preconditions;\n import com.google.common.base.Supplier;\n import com.google.javascript.jscomp.MakeDeclaredNamesUnique.ContextualRenamer;\n+import com.google.javascript.rhino.IR;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n \n     // Replace the expression with a reference to the new name.\n     Node expressionParent = expression.getParent();\n     expressionParent.replaceChild(\n-        expression, Node.newString(Token.NAME, resultName));\n+        expression, IR.name(resultName));\n \n     // Re-add the expression at the appropriate place.\n     Node newExpressionRoot = NodeUtil.newVarNode(resultName, expression);\n \n     // Transform the conditional to an IF statement.\n     Node cond = null;\n-    Node trueExpr = new Node(Token.BLOCK).copyInformationFrom(expr);\n-    Node falseExpr = new Node(Token.BLOCK).copyInformationFrom(expr);\n+    Node trueExpr = IR.block().srcref(expr);\n+    Node falseExpr = IR.block().srcref(expr);\n     switch (expr.getType()) {\n       case Token.HOOK:\n         // a = x?y:z --> if (x) {a=y} else {a=z}\n \n     Node ifNode;\n     if (falseExpr.hasChildren()) {\n-      ifNode = new Node(Token.IF, cond, trueExpr, falseExpr);\n+      ifNode = IR.ifNode(cond, trueExpr, falseExpr);\n     } else {\n-      ifNode = new Node(Token.IF, cond, trueExpr);\n+      ifNode = IR.ifNode(cond, trueExpr);\n     }\n     ifNode.copyInformationFrom(expr);\n \n       injectionPointParent.addChildAfter(ifNode, tempVarNode);\n \n       // Replace the expression with the temporary name.\n-      Node replacementValueNode = Node.newString(Token.NAME, tempName);\n+      Node replacementValueNode = IR.name(tempName);\n       parent.replaceChild(expr, replacementValueNode);\n     } else {\n       // Only conditionals that are the direct child of an expression statement\n   private static Node buildResultExpression(\n       Node expr, boolean needResult, String tempName) {\n     if (needResult) {\n-      return new Node(Token.ASSIGN,\n-          Node.newString(Token.NAME, tempName),\n-          expr).copyInformationFromForTree(expr);\n+      return IR.assign(\n+          IR.name(tempName),\n+          expr).srcrefTree(expr);\n     } else {\n       return expr;\n     }\n \n     // The temp is known to be constant.\n     String tempName = getTempConstantValueName();\n-    Node replacementValueNode = Node.newString(Token.NAME, tempName)\n-        .copyInformationFrom(expr);\n+    Node replacementValueNode = IR.name(tempName).srcref(expr);\n \n     Node tempNameValue;\n \n     //   original-parameter1\n     //   original-parameter2\n     //   ...\n-    Node newCall = new Node(Token.CALL,\n-        new Node(Token.GETPROP,\n+    Node newCall = IR.call(\n+        IR.getprop(\n             functionNameNode.cloneNode(),\n-            Node.newString(\"call\")),\n-        thisNameNode.cloneNode(), call.getLineno(), call.getCharno());\n+            IR.string(\"call\")),\n+        thisNameNode.cloneNode()).srcref(call);\n \n     // Throw away the call name\n     call.removeFirstChild();\n--- a/src/com/google/javascript/jscomp/ExternExportsPass.java\n+++ b/src/com/google/javascript/jscomp/ExternExportsPass.java\n           if (isCompletePathPrefix && functionToExport != null) {\n             initializer = createExternFunction(functionToExport);\n           } else {\n-            initializer = new Node(Token.OBJECTLIT);\n+            initializer = IR.objectlit();\n           }\n \n           appendPathDefinition(pathPrefix, initializer);\n       } else {\n         Node qualifiedPath = NodeUtil.newQualifiedNameNode(\n             compiler.getCodingConvention(), path, -1, -1);\n-        pathDefinition = NodeUtil.newExpr(new Node(Token.ASSIGN, qualifiedPath,\n-            initializer));\n+        pathDefinition = NodeUtil.newExpr(\n+            IR.assign(qualifiedPath, initializer));\n       }\n \n       externsRoot.addChildToBack(pathDefinition);\n     this.exports = Lists.newArrayList();\n     this.compiler = compiler;\n     this.definitionMap = Maps.newHashMap();\n-    this.externsRoot = new Node(Token.BLOCK);\n+    this.externsRoot = IR.block();\n     this.externsRoot.setIsSyntheticBlock(true);\n     this.alreadyExportedPaths = Sets.newHashSet();\n     this.mappedPaths = Maps.newHashMap();\n--- a/src/com/google/javascript/jscomp/ExtractPrototypeMemberDeclarations.java\n+++ b/src/com/google/javascript/jscomp/ExtractPrototypeMemberDeclarations.java\n \n import com.google.common.collect.Lists;\n import com.google.javascript.jscomp.NodeTraversal.AbstractShallowCallback;\n+import com.google.javascript.rhino.IR;\n import com.google.javascript.rhino.Node;\n-import com.google.javascript.rhino.Token;\n-\n import java.util.LinkedList;\n import java.util.List;\n \n     if (pattern == Pattern.USE_GLOBAL_TEMP) {\n       // Use the temp variable to hold the prototype.\n       Node stmt = new Node(first.node.getType(),\n-          new Node(Token.ASSIGN,\n-              Node.newString(Token.NAME, prototypeAlias),\n+         IR.assign(\n+              IR.name(prototypeAlias),\n               NodeUtil.newQualifiedNameNode(\n                   compiler.getCodingConvention(), className + \".prototype\",\n                   instance.parent, className + \".prototype\")))\n \n       instance.parent.addChildBefore(stmt, first.node);\n     } else if (pattern == Pattern.USE_ANON_FUNCTION){\n-      Node block = new Node(Token.BLOCK);\n-      Node func = new Node(Token.FUNCTION,\n-           Node.newString(Token.NAME, \"\"),\n-           new Node(Token.PARAM_LIST, Node.newString(Token.NAME, prototypeAlias)),\n+      Node block = IR.block();\n+      Node func = IR.function(\n+           IR.name(\"\"),\n+           IR.paramList(IR.name(prototypeAlias)),\n            block);\n \n-      Node call = new Node(Token.CALL,func,\n+      Node call = IR.call(func,\n            NodeUtil.newQualifiedNameNode(\n                compiler.getCodingConvention(), className + \".prototype\",\n                instance.parent, className + \".prototype\"));\n--- a/src/com/google/javascript/jscomp/FunctionInjector.java\n+++ b/src/com/google/javascript/jscomp/FunctionInjector.java\n import com.google.common.collect.Sets;\n import com.google.javascript.jscomp.ExpressionDecomposer.DecompositionType;\n import com.google.javascript.jscomp.MakeDeclaredNamesUnique.ContextualRenamer;\n+import com.google.javascript.rhino.IR;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n \n         injectionPointParent.addChildBefore(newBlock, injectionPoint);\n         // Replace the call site with a reference to the intermediate\n         // result name.\n-        parent.replaceChild(callNode, Node.newString(Token.NAME, resultName));\n+        parent.replaceChild(callNode, IR.name(resultName));\n         break;\n \n       default:\n--- a/src/com/google/javascript/jscomp/FunctionRewriter.java\n+++ b/src/com/google/javascript/jscomp/FunctionRewriter.java\n import com.google.common.collect.ImmutableList;\n import com.google.common.collect.Multimap;\n import com.google.javascript.jscomp.NodeTraversal.Callback;\n+import com.google.javascript.rhino.IR;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n \n      * @param charno character offset in original line.\n      */\n     protected final Node buildCallNode(String methodName, Node argumentNode,\n-                                       int lineno, int charno) {\n-      Node call = new Node(Token.CALL, lineno, charno);\n+                                       Node srcref) {\n+      Node call = IR.call(IR.name(methodName)).srcref(srcref);\n       call.putBooleanProp(Node.FREE_CALL, true);\n-      call.addChildToBack(Node.newString(Token.NAME, methodName));\n       if (argumentNode != null) {\n         call.addChildToBack(argumentNode.cloneTree());\n       }\n     @Override\n     public Node reduce(Node node) {\n       if (NodeUtil.isEmptyFunctionExpression(node)) {\n-        return buildCallNode(FACTORY_METHOD_NAME, null,\n-                             node.getLineno(), node.getCharno());\n+        return buildCallNode(FACTORY_METHOD_NAME, null, node);\n       } else {\n         return node;\n       }\n       }\n \n       if (isIdentityFunction(node)) {\n-        return buildCallNode(FACTORY_METHOD_NAME, null,\n-                             node.getLineno(), node.getCharno());\n+        return buildCallNode(FACTORY_METHOD_NAME, null, node);\n       } else {\n         return node;\n       }\n \n       Node valueNode = getValueNode(node);\n       if (valueNode != null) {\n-        return buildCallNode(FACTORY_METHOD_NAME, valueNode,\n-                             node.getLineno(), node.getCharno());\n+        return buildCallNode(FACTORY_METHOD_NAME, valueNode, node);\n       } else {\n         return node;\n       }\n               \"Expected STRING, got \" + Token.name(propName.getType()));\n         }\n \n-        return buildCallNode(FACTORY_METHOD_NAME, propName,\n-                             node.getLineno(), node.getCharno());\n+        return buildCallNode(FACTORY_METHOD_NAME, propName, node);\n       } else {\n         return node;\n       }\n               \"Expected STRING, got \" + Token.name(propName.getType()));\n         }\n \n-        return buildCallNode(FACTORY_METHOD_NAME, propName,\n-                             node.getLineno(), node.getCharno());\n+        return buildCallNode(FACTORY_METHOD_NAME, propName, node);\n       } else {\n         return node;\n       }\n--- a/src/com/google/javascript/jscomp/FunctionToBlockMutator.java\n+++ b/src/com/google/javascript/jscomp/FunctionToBlockMutator.java\n import com.google.common.collect.Lists;\n import com.google.common.collect.Maps;\n import com.google.javascript.jscomp.MakeDeclaredNamesUnique.InlineRenamer;\n+import com.google.javascript.rhino.IR;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n \n         // Rewrite: function f() {} ==> var f = function() {}\n         Node fnNameNode = n.getFirstChild();\n \n-        Node var = new Node(Token.VAR).copyInformationFrom(n);\n-        Node name = Node.newString(Token.NAME, fnNameNode.getString())\n-            .copyInformationFrom(fnNameNode);\n+        Node name = IR.name(fnNameNode.getString()).srcref(fnNameNode);\n+        Node var = IR.var(name).srcref(n);\n \n         fnNameNode.setString(\"\");\n         // Add the VAR, remove the FUNCTION\n         n.getParent().replaceChild(n, var);\n-        var.addChildToFront(name);\n         // readd the function as a function expression\n         name.addChildToFront(n);\n       }\n               newVars.add(0, newNode);\n               // Remove the parameter from the list to replace.\n               newArgMap.put(THIS_MARKER,\n-                  Node.newString(Token.NAME, newName)\n-                      .copyInformationFromForTree(newValue));\n+                  IR.name(newName)\n+                      .srcrefTree(newValue));\n             }\n           } else {\n             Node newValue = entry.getValue().cloneTree();\n         replaceReturnWithBreak(block, null, resultName, labelName);\n \n         // Add label\n-        Node label = new Node(Token.LABEL).copyInformationFrom(block);\n-        Node name = Node.newString(Token.LABEL_NAME, labelName)\n-            .copyInformationFrom(block);\n-        label.addChildToFront(name);\n-        label.addChildToBack(block);\n-\n-        Node newRoot = new Node(Token.BLOCK).copyInformationFrom(block);\n+        Node name = IR.labelName(labelName).srcref(block);\n+        Node label = IR.label(name, block).srcref(block);\n+\n+        Node newRoot = IR.block().srcref(block);\n         newRoot.addChildrenToBack(label);\n \n \n   private static Node createAssignStatementNode(String name, Node expression) {\n     // Create 'name = result-expression;' statement.\n     // EXPR (ASSIGN (NAME, EXPRESSION))\n-    Node nameNode = Node.newString(Token.NAME, name);\n-    Node assign = new Node(Token.ASSIGN, nameNode, expression);\n+    Node nameNode = IR.name(name);\n+    Node assign = IR.assign(nameNode, expression);\n     return NodeUtil.newExpr(assign);\n   }\n \n       Preconditions.checkState(NodeUtil.isStatementBlock(parent));\n \n       Node resultNode = getReplacementReturnStatement(current, resultName);\n-      Node name = Node.newString(Token.LABEL_NAME, labelName);\n-      Node breakNode = new Node(Token.BREAK, name);\n+      Node breakNode = IR.breakNode(IR.labelName(labelName));\n \n       // Replace the node in parent, and reset current to the first new child.\n       breakNode.copyInformationFromForTree(current);\n--- a/src/com/google/javascript/jscomp/FunctionTypeBuilder.java\n+++ b/src/com/google/javascript/jscomp/FunctionTypeBuilder.java\n import com.google.common.collect.Lists;\n import com.google.common.collect.Sets;\n import com.google.javascript.jscomp.Scope.Var;\n+import com.google.javascript.rhino.IR;\n import com.google.javascript.rhino.JSDocInfo;\n import com.google.javascript.rhino.JSTypeExpression;\n import com.google.javascript.rhino.Node;\n-import com.google.javascript.rhino.Token;\n import com.google.javascript.rhino.jstype.FunctionBuilder;\n import com.google.javascript.rhino.jstype.FunctionParamBuilder;\n import com.google.javascript.rhino.jstype.FunctionType;\n    */\n   FunctionTypeBuilder inferParameterTypes(JSDocInfo info) {\n     // Create a fake args parent.\n-    Node lp = new Node(Token.PARAM_LIST);\n+    Node lp = IR.paramList();\n     for (String name : info.getParameterNames()) {\n-      lp.addChildToBack(Node.newString(Token.NAME, name));\n+      lp.addChildToBack(IR.name(name));\n     }\n \n     return inferParameterTypes(lp, info);\n--- a/src/com/google/javascript/jscomp/GatherSideEffectSubexpressionsCallback.java\n+++ b/src/com/google/javascript/jscomp/GatherSideEffectSubexpressionsCallback.java\n import com.google.common.collect.Lists;\n import com.google.javascript.jscomp.CodingConvention.SubclassRelationship;\n import com.google.javascript.jscomp.NodeTraversal.Callback;\n+import com.google.javascript.rhino.IR;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n \n       Node ret = null;\n       for (Node part : parts) {\n         if (ret != null) {\n-          ret = new Node(Token.COMMA, ret, part).copyInformationFrom(node);\n+          ret = IR.comma(ret, part).srcref(node);\n         } else {\n           ret = part;\n         }\n--- a/src/com/google/javascript/jscomp/GenerateExports.java\n+++ b/src/com/google/javascript/jscomp/GenerateExports.java\n \n import com.google.common.base.Preconditions;\n import com.google.javascript.jscomp.FindExportableNodes.GenerateNodeContext;\n+import com.google.javascript.rhino.IR;\n import com.google.javascript.rhino.Node;\n-import com.google.javascript.rhino.Token;\n-\n import java.util.Map;\n \n /**\n       Node call;\n       if (useExportSymbol) {\n         // exportSymbol(publicPath, object);\n-        call = new Node(Token.CALL,\n+        call = IR.call(\n             NodeUtil.newQualifiedNameNode(\n                 compiler.getCodingConvention(), exportSymbolFunction,\n+                context.getNode(), export),\n+            IR.string(export),\n+            NodeUtil.newQualifiedNameNode(\n+                compiler.getCodingConvention(), export,\n                 context.getNode(), export));\n-        call.addChildToBack(Node.newString(export));\n-        call.addChildToBack(NodeUtil.newQualifiedNameNode(\n-            compiler.getCodingConvention(), export,\n-            context.getNode(), export));\n       } else {\n         // exportProperty(object, publicName, symbol);\n         String property = getPropertyName(node);\n-        call = new Node(Token.CALL,\n-            new Node[] {\n-                NodeUtil.newQualifiedNameNode(\n-                    compiler.getCodingConvention(), exportPropertyFunction,\n-                    context.getNode(), exportPropertyFunction),\n-                NodeUtil.newQualifiedNameNode(\n-                    compiler.getCodingConvention(), parent,\n-                    context.getNode(), exportPropertyFunction),\n-                Node.newString(property),\n-                NodeUtil.newQualifiedNameNode(\n-                    compiler.getCodingConvention(), export,\n-                    context.getNode(), exportPropertyFunction)\n-            });\n+        call = IR.call(\n+            NodeUtil.newQualifiedNameNode(\n+                compiler.getCodingConvention(), exportPropertyFunction,\n+                context.getNode(), exportPropertyFunction),\n+            NodeUtil.newQualifiedNameNode(\n+                compiler.getCodingConvention(), parent,\n+                context.getNode(), exportPropertyFunction),\n+            IR.string(property),\n+            NodeUtil.newQualifiedNameNode(\n+                compiler.getCodingConvention(), export,\n+                context.getNode(), exportPropertyFunction));\n       }\n \n-      Node expression = new Node(Token.EXPR_RESULT, call);\n+      Node expression = IR.exprResult(call);\n       annotate(expression);\n \n       // It's important that any class-building calls (goog.inherits)\n--- a/src/com/google/javascript/jscomp/GroupVariableDeclarations.java\n+++ b/src/com/google/javascript/jscomp/GroupVariableDeclarations.java\n import com.google.common.collect.Sets;\n import com.google.javascript.jscomp.NodeTraversal.ScopedCallback;\n import com.google.javascript.jscomp.Scope.Var;\n+import com.google.javascript.rhino.IR;\n import com.google.javascript.rhino.Node;\n-import com.google.javascript.rhino.Token;\n-\n import java.util.Iterator;\n import java.util.Set;\n \n       // replace\n       groupVar.replaceChild(initializedName, clone);\n       // add the assignment now.\n-      Node initializedVal = initializedName.getFirstChild();\n-      initializedName.removeChild(initializedVal);\n-      Node assignmentNode = new Node(Token.ASSIGN, initializedName);\n-      assignmentNode.addChildAfter(initializedVal, initializedName);\n+      Node initializedVal = initializedName.removeFirstChild();\n+      Node assignmentNode = IR.assign(initializedName, initializedVal);\n       if (groupVarParent.isFor()) {\n         // Handle For and For-In Loops specially. For these, we do not need\n         // to construct an EXPR_RESULT node.\n           groupVarParent.replaceChild(groupVar, nameNodeClone);\n         } else {\n           // In For loop, we replace the VAR node with an EMPTY node\n-          Node emptyNode = new Node(Token.EMPTY);\n+          Node emptyNode = IR.empty();\n           groupVarParent.replaceChild(groupVar, emptyNode);\n         }\n       } else {\n--- a/src/com/google/javascript/jscomp/IgnoreCajaProperties.java\n+++ b/src/com/google/javascript/jscomp/IgnoreCajaProperties.java\n package com.google.javascript.jscomp;\n \n import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n+import com.google.javascript.rhino.IR;\n import com.google.javascript.rhino.Node;\n-import com.google.javascript.rhino.Token;\n \n /**\n  * Caja is a system that rewrites web content (JavaScript, CSS, HTML)\n         n.removeChild(body);\n         Node key = n.getFirstChild();\n         n.removeChild(key);\n-        Node tmp = Node.newString(Token.NAME,\n+        Node tmp = IR.name(\n             \"JSCompiler_IgnoreCajaProperties_\" + counter++);\n-        n.addChildToFront(new Node(Token.VAR, tmp));\n+        n.addChildToFront(IR.var(tmp));\n         Node assignment;\n         Node ifBody;\n \n           //     body;\n           //   }\n           // }\n-          ifBody = new Node(\n-              Token.BLOCK,\n+          ifBody = IR.block(\n               key,\n-              new Node(\n-                  Token.EXPR_RESULT,\n-                  new Node(\n-                    Token.ASSIGN,\n-                    key.getFirstChild().cloneNode(),\n-                    tmp.cloneTree())),\n+              IR.exprResult(\n+                  IR.assign(\n+                      key.getFirstChild().cloneNode(),\n+                      tmp.cloneTree())),\n               body);\n         } else {\n           // for (key in x) { body; }\n           //     body;\n           //   }\n           // }\n-          ifBody = new Node(\n-              Token.BLOCK,\n-              new Node(\n-                  Token.EXPR_RESULT,\n-                  new Node(\n-                    Token.ASSIGN,\n-                    key,\n-                    tmp.cloneTree())),\n+          ifBody = IR.block(\n+              IR.exprResult(\n+                  IR.assign(\n+                      key,\n+                      tmp.cloneTree())),\n               body);\n         }\n \n         // Construct the new body of the for loop.\n-        Node newBody = new Node(\n-            Token.BLOCK,\n-            new Node(\n-                Token.IF,\n-                new Node(\n-                    Token.NOT,\n-                    new Node(\n-                        Token.CALL,\n-                        new Node(\n-                            Token.GETPROP,\n+        Node newBody = IR.block(\n+            IR.ifNode(\n+                IR.not(\n+                    IR.call(\n+                        IR.getprop(\n                             tmp.cloneTree(),\n-                            Node.newString(\"match\")),\n-                        new Node(\n-                            Token.REGEXP,\n-                            Node.newString(\"___$\")))),\n+                            IR.string(\"match\")),\n+                        IR.regexp(\n+                            IR.string(\"___$\")))),\n                 ifBody));\n         n.addChildToBack(newBody);\n         compiler.reportCodeChange();\n--- a/src/com/google/javascript/jscomp/InlineObjectLiterals.java\n+++ b/src/com/google/javascript/jscomp/InlineObjectLiterals.java\n import com.google.javascript.jscomp.ReferenceCollectingCallback.ReferenceCollection;\n import com.google.javascript.jscomp.ReferenceCollectingCallback.ReferenceMap;\n import com.google.javascript.jscomp.Scope.Var;\n+import com.google.javascript.rhino.IR;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n \n         Node value = key.removeFirstChild();\n         // TODO(user): Copy type information.\n         nodes.add(\n-          new Node(Token.ASSIGN,\n-                   Node.newString(Token.NAME, varmap.get(var)), value));\n+            IR.assign(\n+                IR.name(varmap.get(var)),\n+                value));\n         all.remove(var);\n       }\n \n       // TODO(user): Better source information.\n       for (String var : all) {\n         nodes.add(\n-          new Node(Token.ASSIGN,\n-                   Node.newString(Token.NAME, varmap.get(var)),\n-                   NodeUtil.newUndefinedNode(null)));\n+            IR.assign(\n+                IR.name(varmap.get(var)),\n+                NodeUtil.newUndefinedNode(null)));\n       }\n \n       Node replacement;\n       if (nodes.isEmpty()) {\n-        replacement = new Node(Token.TRUE);\n+        replacement = IR.trueNode();\n       } else {\n         // All assignments evaluate to true, so make sure that the\n         // expr statement evaluates to true in case it matters.\n-        nodes.add(new Node(Token.TRUE));\n+        nodes.add(IR.trueNode());\n \n         // Join these using COMMA.  A COMMA node must have 2 children, so we\n         // create a tree. In the tree the first child be the COMMA to match\n           Preconditions.checkState(varmap.containsKey(var));\n \n           // Replace the GETPROP node with a NAME.\n-          Node replacement = Node.newString(Token.NAME, varmap.get(var));\n+          Node replacement = IR.name(varmap.get(var));\n           replacement.copyInformationFrom(getprop);\n           ref.getGrandparent().replaceChild(ref.getParent(), replacement);\n         }\n--- a/src/com/google/javascript/jscomp/InlineSimpleMethods.java\n+++ b/src/com/google/javascript/jscomp/InlineSimpleMethods.java\n \n import com.google.common.collect.Lists;\n import com.google.javascript.jscomp.NodeTraversal.Callback;\n+import com.google.javascript.rhino.IR;\n import com.google.javascript.rhino.Node;\n-import com.google.javascript.rhino.Token;\n-\n import java.util.Collection;\n import java.util.List;\n import java.util.logging.Logger;\n     // If the return value of the method call is read,\n     // replace it with \"void 0\". Otherwise, remove the call entirely.\n     if (NodeUtil.isExprCall(parent)) {\n-      parent.getParent().replaceChild(parent, new Node(Token.EMPTY));\n+      parent.getParent().replaceChild(parent, IR.empty());\n     } else {\n       Node srcLocation = call;\n       parent.replaceChild(call, NodeUtil.newUndefinedNode(srcLocation));\n--- a/src/com/google/javascript/jscomp/InstrumentFunctions.java\n+++ b/src/com/google/javascript/jscomp/InstrumentFunctions.java\n import com.google.javascript.jscomp.graph.DiGraph.DiGraphNode;\n import com.google.javascript.jscomp.ControlFlowGraph.Branch;\n import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n+import com.google.javascript.rhino.IR;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n import com.google.protobuf.TextFormat;\n     NodeTraversal.traverse(compiler, root, new InstrumentCallback());\n \n     if (!appNameSetter.isEmpty()) {\n-      Node call = new Node(Token.CALL,\n-          Node.newString(Token.NAME, appNameSetter),\n-          Node.newString(appNameStr));\n+      Node call = IR.call(\n+          IR.name(appNameSetter),\n+          IR.string(appNameStr));\n       call.putBooleanProp(Node.FREE_CALL, true);\n-      Node expr = new Node(Token.EXPR_RESULT, call);\n+      Node expr = IR.exprResult(call);\n \n       Node addingRoot = compiler.getNodeForCodeInsertion(null);\n       addingRoot.addChildrenToFront(expr);\n \n       if (!allPathsReturn(body)) {\n         Node call = newReportFunctionExitNode();\n-        Node expr = new Node(Token.EXPR_RESULT, call);\n+        Node expr = IR.exprResult(call);\n         body.addChildToBack(expr);\n         compiler.reportCodeChange();\n       }\n     }\n \n     private Node newReportFunctionExitNode() {\n-      Node call = new Node(Token.CALL,\n-          Node.newString(Token.NAME, reportFunctionExitName),\n-          Node.newNumber(functionId));\n+      Node call = IR.call(\n+          IR.name(reportFunctionExitName),\n+          IR.number(functionId));\n       call.putBooleanProp(Node.FREE_CALL, true);\n       return call;\n     }\n \n       if (!reportFunctionName.isEmpty()) {\n         Node body = n.getFirstChild().getNext().getNext();\n-        Node call = new Node(Token.CALL,\n-            Node.newString(Token.NAME, reportFunctionName),\n-            Node.newNumber(id));\n+        Node call = IR.call(\n+            IR.name(reportFunctionName),\n+            IR.number(id));\n         call.putBooleanProp(Node.FREE_CALL, true);\n-        Node expr = new Node(Token.EXPR_RESULT, call);\n+        Node expr = IR.exprResult(call);\n         body.addChildToFront(expr);\n         compiler.reportCodeChange();\n       }\n       }\n \n       if (!definedFunctionName.isEmpty()) {\n-        Node call = new Node(Token.CALL,\n-            Node.newString(Token.NAME, definedFunctionName),\n-            Node.newNumber(id));\n+        Node call = IR.call(\n+            IR.name(definedFunctionName),\n+            IR.number(id));\n         call.putBooleanProp(Node.FREE_CALL, true);\n         Node expr = NodeUtil.newExpr(call);\n \n--- a/src/com/google/javascript/jscomp/JsAst.java\n+++ b/src/com/google/javascript/jscomp/JsAst.java\n \n import com.google.javascript.jscomp.parsing.ParserRunner;\n \n+import com.google.javascript.rhino.IR;\n import com.google.javascript.rhino.InputId;\n import com.google.javascript.rhino.Node;\n-import com.google.javascript.rhino.Token;\n-\n import java.io.IOException;\n \n import java.util.logging.Logger;\n \n     if (root == null || compiler.hasHaltingErrors()) {\n       // There was a parse error or IOException, so use a dummy block.\n-      root = new Node(Token.SCRIPT);\n+      root = IR.script();\n     } else {\n       compiler.prepareAst(root);\n     }\n--- a/src/com/google/javascript/jscomp/MinimizeExitPoints.java\n+++ b/src/com/google/javascript/jscomp/MinimizeExitPoints.java\n import com.google.javascript.jscomp.NodeTraversal;\n import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n import com.google.javascript.jscomp.NodeUtil;\n+import com.google.javascript.rhino.IR;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n import com.google.javascript.rhino.jstype.TernaryValue;\n     if (ifNode.getNext() != null) {\n       // Move siblings of the if block into the opposite\n       // logic block of the exit.\n-      Node newDestBlock = new Node(Token.BLOCK).copyInformationFrom(ifNode);\n+      Node newDestBlock = IR.block().srcref(ifNode);\n       if (destBlock == null) {\n         // Only possible if this is the false block.\n         ifNode.addChildToBack(newDestBlock);\n--- a/src/com/google/javascript/jscomp/NameAnalyzer.java\n+++ b/src/com/google/javascript/jscomp/NameAnalyzer.java\n import com.google.javascript.jscomp.graph.LinkedDirectedGraph;\n import com.google.javascript.jscomp.graph.DiGraph.DiGraphEdge;\n import com.google.javascript.jscomp.graph.FixedPointGraphTraversal.EdgeCallback;\n+import com.google.javascript.rhino.IR;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n \n       if (NodeUtil.isExpressionNode(parent)) {\n         changeProxy.removeChild(gramps, parent);\n       } else {\n-        changeProxy.replaceWith(\n-            parent, node, new Node(Token.VOID, Node.newNumber(0)));\n+        changeProxy.replaceWith(parent, node, IR.voidNode(IR.number(0)));\n       }\n     }\n   }\n \n     @Override\n     public void remove() {\n-      changeProxy.replaceWith(gramps, parent, new Node(Token.FALSE));\n+      changeProxy.replaceWith(gramps, parent, IR.falseNode());\n     }\n   }\n \n     if (parent.isFor()) {\n       // tweak replacements array s.t. it is a single expression node.\n       if (replacements.isEmpty()) {\n-        replacements.add(new Node(Token.EMPTY));\n+        replacements.add(IR.empty());\n       } else {\n         Node expr = collapseReplacements(replacements);\n         replacements.clear();\n       if (expr == null) {\n         expr = rep;\n       } else {\n-        expr = new Node(Token.COMMA, expr, rep);\n+        expr = IR.comma(expr, rep);\n       }\n     }\n \n--- a/src/com/google/javascript/jscomp/NodeUtil.java\n+++ b/src/com/google/javascript/jscomp/NodeUtil.java\n    * @return Newly created EXPR node with the child as subexpression.\n    */\n   public static Node newExpr(Node child) {\n-    Node expr = new Node(Token.EXPR_RESULT, child)\n-        .copyInformationFrom(child);\n-    return expr;\n+    return IR.exprResult(child).srcref(child);\n   }\n \n   /**\n       // Only Token.FOR can have an Token.EMPTY other control structure\n       // need something for the condition. Others need to be replaced\n       // or the structure removed.\n-      parent.replaceChild(node, new Node(Token.EMPTY));\n+      parent.replaceChild(node, IR.empty());\n     } else {\n       throw new IllegalStateException(\"Invalid attempt to remove node: \" +\n           node.toString() + \" of \"+ parent.toString());\n   static void maybeAddFinally(Node tryNode) {\n     Preconditions.checkState(tryNode.isTry());\n     if (!NodeUtil.hasFinally(tryNode)) {\n-      tryNode.addChildrenToBack(new Node(Token.BLOCK)\n-          .copyInformationFrom(tryNode));\n+      tryNode.addChildrenToBack(IR.block().srcref(tryNode));\n     }\n   }\n \n \n     Node parent = getAddingRoot(branch);\n     for (Node nameNode : vars) {\n-      Node var = new Node(\n-          Token.VAR,\n-          Node.newString(Token.NAME, nameNode.getString())\n-              .copyInformationFrom(nameNode))\n-          .copyInformationFrom(nameNode);\n+      Node var = IR.var(\n+          IR.name(nameNode.getString())\n+              .srcref(nameNode))\n+          .srcref(nameNode);\n       copyNameAnnotations(nameNode, var.getFirstChild());\n       parent.addChildToFront(var);\n     }\n       String part = (endPos == -1\n                      ? name.substring(startPos)\n                      : name.substring(startPos, endPos));\n-      Node propNode = Node.newString(Token.STRING, part, lineno, charno);\n+      Node propNode = Node.newString(part, lineno, charno);\n       if (convention.isConstantKey(part)) {\n         propNode.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n       }\n    */\n   static Node newName(\n       CodingConvention convention, String name, Node basisNode) {\n-    Node nameNode = Node.newString(Token.NAME, name);\n+    Node nameNode = IR.name(name);\n     if (convention.isConstantKey(name)) {\n       nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n     }\n    *   \"void 0\"\n    */\n   static Node newUndefinedNode(Node srcReferenceNode) {\n-    Node node = new Node(Token.VOID, Node.newNumber(0));\n+    Node node = IR.voidNode(IR.number(0));\n     if (srcReferenceNode != null) {\n         node.copyInformationFromForTree(srcReferenceNode);\n     }\n    * Create a VAR node containing the given name and initial value expression.\n    */\n   static Node newVarNode(String name, Node value) {\n-    Node nodeName = Node.newString(Token.NAME, name);\n+    Node nodeName = IR.name(name);\n     if (value != null) {\n       Preconditions.checkState(value.getNext() == null);\n       nodeName.addChildToBack(value);\n-      nodeName.copyInformationFrom(value);\n-    }\n-    Node var = new Node(Token.VAR, nodeName)\n-        .copyInformationFrom(nodeName);\n+      nodeName.srcref(value);\n+    }\n+    Node var = IR.var(nodeName).srcref(nodeName);\n \n     return var;\n   }\n    */\n   static Node newCallNode(Node callTarget, Node... parameters) {\n     boolean isFreeCall = !isGet(callTarget);\n-    Node call = new Node(Token.CALL, callTarget);\n+    Node call = IR.call(callTarget);\n     call.putBooleanProp(Node.FREE_CALL, isFreeCall);\n     for (Node parameter : parameters) {\n       call.addChildToBack(parameter);\n--- a/src/com/google/javascript/jscomp/Normalize.java\n+++ b/src/com/google/javascript/jscomp/Normalize.java\n import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n import com.google.javascript.jscomp.NodeTraversal.Callback;\n import com.google.javascript.jscomp.Scope.Var;\n+import com.google.javascript.rhino.IR;\n import com.google.javascript.rhino.JSDocInfo;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n           if (CONVERT_WHILE_TO_FOR) {\n             Node expr = n.getFirstChild();\n             n.setType(Token.FOR);\n-            Node empty = new Node(Token.EMPTY);\n+            Node empty = IR.empty();\n             empty.copyInformationFrom(n);\n             n.addChildBefore(empty, expr);\n             n.addChildAfter(empty.cloneNode(), expr);\n       // Prepare a spot for the function.\n       Node oldNameNode = n.getFirstChild();\n       Node fnNameNode = oldNameNode.cloneNode();\n-      Node var = new Node(Token.VAR, fnNameNode, n.getLineno(), n.getCharno());\n-      var.copyInformationFrom(n);\n+      Node var = IR.var(fnNameNode).srcref(n);\n \n       // Prepare the function\n       oldNameNode.setString(\"\");\n         case Token.DO:\n           return;\n         default:\n-          Node block = new Node(Token.BLOCK);\n+          Node block = IR.block();\n           block.copyInformationFrom(last);\n           n.replaceChild(last, block);\n           block.addChildToFront(last);\n               }\n             } else if (!c.getFirstChild().isEmpty()) {\n               Node init = c.getFirstChild();\n-              Node empty = new Node(Token.EMPTY);\n+              Node empty = IR.empty();\n               empty.copyInformationFrom(c);\n               c.replaceChild(init, empty);\n \n           while (c.getFirstChild() != c.getLastChild()) {\n             Node name = c.getFirstChild();\n             c.removeChild(name);\n-            Node newVar = new Node(\n-                Token.VAR, name, n.getLineno(), n.getCharno());\n+            Node newVar = IR.var(name).srcref(n);\n             n.addChildBefore(newVar, c);\n             reportCodeChange(\"VAR with multiple children\");\n           }\n         // Convert \"var name = value\" to \"name = value\"\n         Node value = n.getFirstChild();\n         n.removeChild(value);\n-        Node replacement = new Node(Token.ASSIGN, n, value);\n+        Node replacement = IR.assign(n, value);\n         replacement.copyInformationFrom(parent);\n         gramps.replaceChild(parent, NodeUtil.newExpr(replacement));\n       } else {\n--- a/src/com/google/javascript/jscomp/ObjectPropertyStringPostprocess.java\n+++ b/src/com/google/javascript/jscomp/ObjectPropertyStringPostprocess.java\n package com.google.javascript.jscomp;\n \n import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n+import com.google.javascript.rhino.IR;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n \n         secondArgument.removeChild(newChild);\n         n.replaceChild(firstArgument, newChild);\n         n.replaceChild(secondArgument,\n-            Node.newString(secondArgument.getFirstChild().getString()));\n+            IR.string(secondArgument.getFirstChild().getString()));\n       } else if (secondArgumentType == Token.GETELEM) {\n         // Rewrite \"new goog.testing.ObjectPropertyString(window, foo[bar])\"\n         // as \"new goog.testing.ObjectPropertyString(foo, bar)\".\n         // Rewrite \"new goog.testing.ObjectPropertyString(window, foo)\" as\n         // \"new goog.testing.ObjectPropertyString(window, 'foo')\"\n         n.replaceChild(secondArgument,\n-            Node.newString(secondArgument.getString()));\n+            IR.string(secondArgument.getString()));\n       }\n       compiler.reportCodeChange();\n     }\n--- a/src/com/google/javascript/jscomp/ObjectPropertyStringPreprocess.java\n+++ b/src/com/google/javascript/jscomp/ObjectPropertyStringPreprocess.java\n package com.google.javascript.jscomp;\n \n import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n+import com.google.javascript.rhino.IR;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n \n   @Override\n   public void process(Node externs, Node root) {\n     addExternDeclaration(externs,\n-        new Node(Token.VAR,\n-            Node.newString(Token.NAME, EXTERN_OBJECT_PROPERTY_STRING)));\n+        IR.var(\n+            IR.name(EXTERN_OBJECT_PROPERTY_STRING)));\n     NodeTraversal.traverse(compiler, root, new Callback());\n   }\n \n   private void addExternDeclaration(Node externs, Node declarationStmt) {\n     Node script = externs.getLastChild();\n     if (script == null || !script.isScript()) {\n-      script = new Node(Token.SCRIPT);\n+      script = IR.script();\n       script.setIsSyntheticBlock(true);\n       externs.addChildToBack(script);\n     }\n     @Override\n     public void visit(NodeTraversal t, Node n, Node parent) {\n       if (OBJECT_PROPERTY_STRING.equals(n.getQualifiedName())) {\n-        Node newName =\n-            Node.newString(Token.NAME, EXTERN_OBJECT_PROPERTY_STRING);\n+        Node newName = IR.name(EXTERN_OBJECT_PROPERTY_STRING);\n         newName.copyInformationFrom(n);\n         parent.replaceChild(n, newName);\n         compiler.reportCodeChange();\n--- a/src/com/google/javascript/jscomp/OperaCompoundAssignFix.java\n+++ b/src/com/google/javascript/jscomp/OperaCompoundAssignFix.java\n import com.google.common.collect.Lists;\n import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n import com.google.javascript.jscomp.NodeTraversal.ScopedCallback;\n+import com.google.javascript.rhino.IR;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n \n     parent.replaceChild(assign, comma);\n \n     String newName = names.peek().getNextNewName();\n-    Node newAssign = new Node(Token.ASSIGN,\n-        Node.newString(Token.NAME, newName));\n+    Node newAssign = IR.assign(\n+        IR.name(newName), assign.getLastChild().detachFromParent());\n     newAssign.copyInformationFromForTree(assign);\n-    newAssign.addChildToBack(assign.getLastChild().detachFromParent());\n     comma.addChildrenToBack(newAssign);\n-    assign.addChildrenToBack(\n-        Node.newString(Token.NAME, newName).copyInformationFrom(assign));\n+    assign.addChildrenToBack(IR.name(newName).srcref(assign));\n     comma.addChildrenToBack(assign);\n \n     Node root = t.getScopeRoot();\n-    Node var = new Node(Token.VAR, Node.newString(Token.NAME, newName));\n+    Node var = IR.var(IR.name(newName));\n     var.copyInformationFromForTree(assign);\n \n     if (NodeUtil.isStatementBlock(root)) {\n--- a/src/com/google/javascript/jscomp/OptimizeArgumentsArray.java\n+++ b/src/com/google/javascript/jscomp/OptimizeArgumentsArray.java\n import com.google.common.base.Preconditions;\n import com.google.common.collect.Lists;\n import com.google.javascript.jscomp.NodeTraversal.ScopedCallback;\n+import com.google.javascript.rhino.IR;\n import com.google.javascript.rhino.Node;\n-import com.google.javascript.rhino.Token;\n-\n import java.util.Deque;\n import java.util.List;\n \n     for (int i = 0; i < numExtraArgs; i++) {\n       String name = getNewName();\n       argNames[i] = name;\n-      parametersList.addChildrenToBack(Node.newString(Token.NAME, name));\n+      parametersList.addChildrenToBack(IR.name(name));\n       changed = true;\n     }\n \n       // Unnamed parameter.\n       if (value >= numNamedParameter) {\n         ref.getParent().getParent().replaceChild(ref.getParent(),\n-            Node.newString(Token.NAME, argNames[value - numNamedParameter]));\n+            IR.name(argNames[value - numNamedParameter]));\n       } else {\n \n         // Here, for no apparent reason, the user is accessing a named parameter\n           name = name.getNext();\n         }\n         ref.getParent().getParent().replaceChild(ref.getParent(),\n-            Node.newString(Token.NAME, name.getString()));\n+            IR.name(name.getString()));\n       }\n       changed = true;\n     }\n--- a/src/com/google/javascript/jscomp/OptimizeParameters.java\n+++ b/src/com/google/javascript/jscomp/OptimizeParameters.java\n import com.google.javascript.jscomp.AbstractCompiler.LifeCycleStage;\n import com.google.javascript.jscomp.DefinitionsRemover.Definition;\n import com.google.javascript.jscomp.Scope.Var;\n+import com.google.javascript.rhino.IR;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n \n     if (varName != null) {\n       stmt = NodeUtil.newVarNode(varName.getString(), value);\n     } else {\n-      stmt = new Node(Token.EXPR_RESULT, value);\n+      stmt = IR.exprResult(value);\n     }\n     block.addChildToFront(stmt);\n     compiler.reportCodeChange();\n       // Keep the args in the same order, do the last first.\n       eliminateParamsAfter(fnNode, argNode.getNext());\n       argNode.detachFromParent();\n-      Node var = new Node(Token.VAR, argNode).copyInformationFrom(argNode);\n+      Node var = IR.var(argNode).copyInformationFrom(argNode);\n       fnNode.getLastChild().addChildrenToFront(var);\n       compiler.reportCodeChange();\n       return true;\n--- a/src/com/google/javascript/jscomp/OptimizeReturns.java\n+++ b/src/com/google/javascript/jscomp/OptimizeReturns.java\n import com.google.common.base.Preconditions;\n import com.google.common.collect.Lists;\n import com.google.javascript.jscomp.DefinitionsRemover.Definition;\n+import com.google.javascript.rhino.IR;\n import com.google.javascript.rhino.Node;\n-import com.google.javascript.rhino.Token;\n-\n-\n import java.util.Collection;\n import java.util.List;\n \n             Node result = node.removeFirstChild();\n             if (keepValue) {\n               node.getParent().addChildBefore(\n-                new Node(\n-                  Token.EXPR_RESULT, result).copyInformationFrom(result), node);\n+                IR.exprResult(result).srcref(result), node);\n             }\n             compiler.reportCodeChange();\n           }\n--- a/src/com/google/javascript/jscomp/PeepholeCollectPropertyAssignments.java\n+++ b/src/com/google/javascript/jscomp/PeepholeCollectPropertyAssignments.java\n       propertyName = property.getString();\n     }\n \n-    Node newProperty = Node.newString(propertyName)\n+    Node newProperty = IR.string(propertyName)\n         .copyInformationFrom(property);\n     // Preserve the quotedness of a property reference\n     if (lhs.isGetElem()) {\n--- a/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\n+++ b/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\n     Node child = n.getFirstChild();\n     if (!child.isNumber() || child.getDouble() != 0.0) {\n       if (!mayHaveSideEffects(n)) {\n-        n.replaceChild(child, Node.newNumber(0));\n+        n.replaceChild(child, IR.number(0));\n         reportCodeChange();\n       }\n     }\n     }\n \n     if (typeNameString != null) {\n-      Node newNode = Node.newString(typeNameString);\n+      Node newNode = IR.string(typeNameString);\n       originalTypeofNode.getParent().replaceChild(originalTypeofNode, newNode);\n       reportCodeChange();\n \n \n           double negNum = -left.getDouble();\n \n-          Node negNumNode = Node.newNumber(negNum);\n+          Node negNumNode = IR.number(negNum);\n           parent.replaceChild(n, negNumNode);\n           reportCodeChange();\n           return negNumNode;\n           if (val >= Integer.MIN_VALUE && val <= Integer.MAX_VALUE) {\n             int intVal = (int) val;\n             if (intVal == val) {\n-              Node notIntValNode = Node.newNumber(~intVal);\n+              Node notIntValNode = IR.number(~intVal);\n               parent.replaceChild(n, notIntValNode);\n               reportCodeChange();\n               return notIntValNode;\n           left.removeChild(ll);\n           String result = leftString + rightString;\n           n.replaceChild(left, ll);\n-          n.replaceChild(right, Node.newString(result));\n+          n.replaceChild(right, IR.string(result));\n           reportCodeChange();\n           return n;\n         }\n           right.removeChild(rr);\n           String result = leftString + rightString;\n           n.replaceChild(right, rr);\n-          n.replaceChild(left, Node.newString(result));\n+          n.replaceChild(left, IR.string(result));\n           reportCodeChange();\n           return n;\n         }\n       String leftString = NodeUtil.getStringValue(left);\n       String rightString = NodeUtil.getStringValue(right);\n       if (leftString != null && rightString != null) {\n-        Node newStringNode = Node.newString(leftString + rightString);\n+        Node newStringNode = IR.string(leftString + rightString);\n         n.getParent().replaceChild(n, newStringNode);\n         reportCodeChange();\n         return newStringNode;\n               Token.name(n.getType()));\n       }\n \n-      Node newNumber = Node.newNumber(result);\n+      Node newNumber = IR.number(result);\n       n.getParent().replaceChild(n, newNumber);\n       reportCodeChange();\n \n       }\n \n       Node parent = n.getParent();\n-      Node newString = Node.newString(stringValue);\n+      Node newString = IR.string(stringValue);\n \n       parent.replaceChild(n, newString);\n       newString.copyInformationFrom(parent);\n       }\n \n       Preconditions.checkState(knownLength != -1);\n-      Node lengthNode = Node.newNumber(knownLength);\n+      Node lengthNode = IR.number(knownLength);\n       n.getParent().replaceChild(n, lengthNode);\n       reportCodeChange();\n \n--- a/src/com/google/javascript/jscomp/PeepholeFoldWithTypes.java\n+++ b/src/com/google/javascript/jscomp/PeepholeFoldWithTypes.java\n package com.google.javascript.jscomp;\n \n import com.google.common.base.Preconditions;\n+import com.google.javascript.rhino.IR;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n import com.google.javascript.rhino.jstype.JSType;\n         }\n \n         if (typeName != null) {\n-          Node newNode = Node.newString(typeName);\n+          Node newNode = IR.string(typeName);\n           typeofNode.getParent().replaceChild(typeofNode, newNode);\n           reportCodeChange();\n \n--- a/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java\n+++ b/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java\n   private Node tryFoldStringToLowerCase(Node subtree, Node stringNode) {\n     // From Rhino, NativeString.java. See ECMA 15.5.4.11\n     String lowered = stringNode.getString().toLowerCase(ROOT_LOCALE);\n-    Node replacement = Node.newString(lowered);\n+    Node replacement = IR.string(lowered);\n     subtree.getParent().replaceChild(subtree, replacement);\n     reportCodeChange();\n     return replacement;\n   private Node tryFoldStringToUpperCase(Node subtree, Node stringNode) {\n     // From Rhino, NativeString.java. See ECMA 15.5.4.12\n     String uppered = stringNode.getString().toUpperCase(ROOT_LOCALE);\n-    Node replacement = Node.newString(uppered);\n+    Node replacement = IR.string(uppered);\n     subtree.getParent().replaceChild(subtree, replacement);\n     reportCodeChange();\n     return replacement;\n         // is 10 or omitted, just replace it with the number\n         Node numericNode;\n         if (isParseInt) {\n-          numericNode = Node.newNumber(checkVal.intValue());\n+          numericNode = IR.number(checkVal.intValue());\n         } else {\n-          numericNode = Node.newNumber(checkVal);\n+          numericNode = IR.number(checkVal);\n         }\n         n.getParent().replaceChild(n, numericNode);\n         reportCodeChange();\n         return n;\n       }\n \n-      newNode = Node.newNumber(newVal);\n+      newNode = IR.number(newVal);\n     } else {\n       String normalizedNewVal = \"0\";\n       try {\n         double newVal = Double.parseDouble(stringVal);\n-        newNode = Node.newNumber(newVal);\n+        newNode = IR.number(newVal);\n         normalizedNewVal = normalizeNumericString(String.valueOf(newVal));\n       }\n       catch(NumberFormatException e) {\n     }\n     int indexVal = isIndexOf ? lstring.indexOf(searchValue, fromIndex)\n                              : lstring.lastIndexOf(searchValue, fromIndex);\n-    Node newNode = Node.newNumber(indexVal);\n+    Node newNode = IR.number(indexVal);\n     n.getParent().replaceChild(n, newNode);\n \n     reportCodeChange();\n           // + 2 for the quotes.\n           foldedSize += sb.length() + 2;\n           arrayFoldedChildren.add(\n-              Node.newString(sb.toString()).copyInformationFrom(prev));\n+              IR.string(sb.toString()).copyInformationFrom(prev));\n           sb = null;\n         }\n         foldedSize += InlineCostEstimator.getCost(elem);\n       // + 2 for the quotes.\n       foldedSize += sb.length() + 2;\n       arrayFoldedChildren.add(\n-          Node.newString(sb.toString()).copyInformationFrom(prev));\n+          IR.string(sb.toString()).copyInformationFrom(prev));\n     }\n     // one for each comma.\n     foldedSize += arrayFoldedChildren.size() - 1;\n     int originalSize = InlineCostEstimator.getCost(n);\n     switch (arrayFoldedChildren.size()) {\n       case 0:\n-        Node emptyStringNode = Node.newString(\"\");\n+        Node emptyStringNode = IR.string(\"\");\n         n.getParent().replaceChild(n, emptyStringNode);\n         reportCodeChange();\n         return emptyStringNode;\n     }\n \n     String result = stringAsString.substring(start, start + length);\n-    Node resultNode = Node.newString(result);\n+    Node resultNode = IR.string(result);\n \n     Node parent = n.getParent();\n     parent.replaceChild(n, resultNode);\n     }\n \n     String result = stringAsString.substring(start, end);\n-    Node resultNode = Node.newString(result);\n+    Node resultNode = IR.string(result);\n \n     Node parent = n.getParent();\n     parent.replaceChild(n, resultNode);\n       return n;\n     }\n \n-    Node resultNode = Node.newString(\n+    Node resultNode = IR.string(\n         stringAsString.substring(index, index + 1));\n     Node parent = n.getParent();\n     parent.replaceChild(n, resultNode);\n       return n;\n     }\n \n-    Node resultNode = Node.newNumber(stringAsString.charAt(index));\n+    Node resultNode = IR.number(stringAsString.charAt(index));\n     Node parent = n.getParent();\n     parent.replaceChild(n, resultNode);\n     reportCodeChange();\n--- a/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n+++ b/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n    * Returns the replacement for n if it was replaced, otherwise returns n.\n    */\n   private Node maybeReplaceChildWithNumber(Node n, Node parent, int num) {\n-    Node newNode = Node.newNumber(num);\n+    Node newNode = IR.number(num);\n     if (!newNode.isEquivalentTo(n)) {\n       parent.replaceChild(n, newNode);\n       reportCodeChange();\n     if (null == sb) { return n.cloneTree(); }\n \n     sb.append(s, pos, s.length());\n-    return Node.newString(sb.toString()).copyInformationFrom(n);\n+    return IR.string(sb.toString()).srcref(n);\n   }\n \n   /**\n--- a/src/com/google/javascript/jscomp/PrepareAst.java\n+++ b/src/com/google/javascript/jscomp/PrepareAst.java\n package com.google.javascript.jscomp;\n \n import com.google.common.base.Preconditions;\n+import com.google.javascript.rhino.IR;\n import com.google.javascript.rhino.JSDocInfo;\n import com.google.javascript.rhino.JSTypeExpression;\n import com.google.javascript.rhino.Node;\n       for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n         if (NodeUtil.isControlStructureCodeBlock(n,c) &&\n             !c.isBlock()) {\n-          Node newBlock = new Node(Token.BLOCK, n.getLineno(), n.getCharno());\n-          newBlock.copyInformationFrom(n);\n+          Node newBlock = IR.block().srcref(n);\n           n.replaceChild(c, newBlock);\n           if (!c.isEmpty()) {\n             newBlock.addChildrenToFront(c);\n--- a/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\n+++ b/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\n import com.google.common.collect.Maps;\n import com.google.common.collect.Sets;\n import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n+import com.google.javascript.rhino.IR;\n import com.google.javascript.rhino.JSDocInfo;\n import com.google.javascript.rhino.JSDocInfoBuilder;\n import com.google.javascript.rhino.Node;\n \n               // We can't modify parent, so just create a node that will\n               // get compiled out.\n-              parent.replaceChild(n, Node.newNumber(0));\n+              parent.replaceChild(n, IR.number(0));\n               compiler.reportCodeChange();\n             } else if (\"setCssNameMapping\".equals(methodName)) {\n               processSetCssNameMapping(t, n, parent);\n             assignNode.removeChild(nameNode);\n             assignNode.removeChild(valueNode);\n             nameNode.addChildToFront(valueNode);\n-            Node varNode = new Node(Token.VAR, nameNode);\n+            Node varNode = IR.var(nameNode);\n             varNode.copyInformationFrom(candidateDefinition);\n             candidateDefinition.getParent().replaceChild(\n                 candidateDefinition, varNode);\n      * (e.g. <code>var foo = {};</code>).\n      */\n     private Node makeVarDeclNode() {\n-      Node name = Node.newString(Token.NAME, namespace);\n+      Node name = IR.name(namespace);\n       name.addChildToFront(createNamespaceLiteral());\n \n-      Node decl = new Node(Token.VAR, name);\n+      Node decl = IR.var(name);\n       decl.putBooleanProp(Node.IS_NAMESPACE, true);\n \n       // TODO(nicksantos): ew ew ew. Create a mutator package.\n      * So always give the namespace literal a type.\n      */\n     private Node createNamespaceLiteral() {\n-      Node objlit = new Node(Token.OBJECTLIT);\n+      Node objlit = IR.objectlit();\n       objlit.setJSType(\n           compiler.getTypeRegistry().createAnonymousObjectType());\n       return objlit;\n      * (e.g. <code>foo.bar = {};</code>).\n      */\n     private Node makeAssignmentExprNode() {\n-      Node decl = new Node(Token.EXPR_RESULT,\n-          new Node(Token.ASSIGN,\n+      Node decl = IR.exprResult(\n+          IR.assign(\n               NodeUtil.newQualifiedNameNode(\n                   compiler.getCodingConvention(), namespace,\n                   firstNode /* real source info will be filled in below */,\n--- a/src/com/google/javascript/jscomp/ProcessTweaks.java\n+++ b/src/com/google/javascript/jscomp/ProcessTweaks.java\n import com.google.common.collect.Lists;\n import com.google.common.collect.Maps;\n import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n+import com.google.javascript.rhino.IR;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n \n     Node createDefaultValueNode() {\n       switch (this) {\n         case REGISTER_BOOLEAN:\n-          return new Node(Token.FALSE);\n+          return IR.falseNode();\n         case REGISTER_NUMBER:\n-          return Node.newNumber(0);\n+          return IR.number(0);\n         case REGISTER_STRING:\n-          return Node.newString(\"\");\n+          return IR.string(\"\");\n       }\n       throw new IllegalStateException();\n     }\n           }\n           parent.replaceChild(callNode, newValue);\n         } else {\n-          Node voidZeroNode = new Node(Token.VOID)\n-              .copyInformationFrom(callNode);\n-          voidZeroNode.addChildToBack(Node.newNumber(0)\n-              .copyInformationFrom(callNode));\n+          Node voidZeroNode = IR.voidNode(IR.number(0).srcref(callNode))\n+              .srcref(callNode);\n           parent.replaceChild(callNode, voidZeroNode);\n         }\n       }\n    */\n   private Node createCompilerDefaultValueOverridesVarNode(\n       Node sourceInformationNode) {\n-    Node objNode = new Node(Token.OBJECTLIT)\n-        .copyInformationFrom(sourceInformationNode);\n+    Node objNode = IR.objectlit().srcref(sourceInformationNode);\n     for (Entry<String, Node> entry : compilerDefaultValueOverrides.entrySet()) {\n-      Node objKeyNode = Node.newString(entry.getKey())\n+      Node objKeyNode = IR.string(entry.getKey())\n           .copyInformationFrom(sourceInformationNode);\n       Node objValueNode = entry.getValue().cloneNode()\n           .copyInformationFrom(sourceInformationNode);\n--- a/src/com/google/javascript/jscomp/RemoveTryCatch.java\n+++ b/src/com/google/javascript/jscomp/RemoveTryCatch.java\n package com.google.javascript.jscomp;\n \n import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n+import com.google.javascript.rhino.IR;\n import com.google.javascript.rhino.JSDocInfo;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n           // try node\n           Node block;\n           if (!NodeUtil.isStatementBlock(parent)) {\n-            block = new Node(Token.BLOCK);\n+            block = IR.block();\n             parent.replaceChild(n, block);\n             block.addChildToFront(tryBlock);\n           } else {\n--- a/src/com/google/javascript/jscomp/RemoveUnusedClassProperties.java\n+++ b/src/com/google/javascript/jscomp/RemoveUnusedClassProperties.java\n import com.google.common.base.Preconditions;\n import com.google.common.collect.Lists;\n import com.google.common.collect.Sets;\n+import com.google.javascript.rhino.IR;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n \n           assign.getParent().replaceChild(assign,\n               assign.getLastChild().detachFromParent());\n         } else if (parent.isInc() || parent.isDec()) {\n-          parent.getParent().replaceChild(parent, Node.newNumber(0));\n+          parent.getParent().replaceChild(parent, IR.number(0));\n         } else {\n           throw new IllegalStateException(\"unexpected: \"+ parent);\n         }\n--- a/src/com/google/javascript/jscomp/RemoveUnusedVars.java\n+++ b/src/com/google/javascript/jscomp/RemoveUnusedVars.java\n import com.google.javascript.jscomp.CodingConvention.SubclassRelationship;\n import com.google.javascript.jscomp.DefinitionsRemover.Definition;\n import com.google.javascript.jscomp.Scope.Var;\n+import com.google.javascript.rhino.IR;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n \n         compiler.reportCodeChange();\n       }\n       for (Node n : toReplaceWithZero) {\n-        n.getParent().replaceChild(n, Node.newNumber(0).copyInformationFrom(n));\n+        n.getParent().replaceChild(n, IR.number(0).srcref(n));\n         compiler.reportCodeChange();\n       }\n     }\n         // var a = foo(); => foo();\n         if (toRemove.getChildCount() == 1) {\n           parent.replaceChild(toRemove,\n-              new Node(Token.EXPR_RESULT, nameNode.removeFirstChild()));\n+              IR.exprResult(nameNode.removeFirstChild()));\n           compiler.reportCodeChange();\n         }\n       } else if (toRemove.isVar() &&\n              !current.isName();\n              current = current.getFirstChild()) {\n           if (current.isGetElem()) {\n-            replacement = new Node(Token.COMMA,\n+            replacement = IR.comma(\n                 current.getLastChild().detachFromParent(), replacement);\n             replacement.copyInformationFrom(current);\n           }\n--- a/src/com/google/javascript/jscomp/RenameProperties.java\n+++ b/src/com/google/javascript/jscomp/RenameProperties.java\n import com.google.javascript.jscomp.graph.UndiGraph;\n import com.google.javascript.jscomp.graph.UndiGraph.UndiGraphEdge;\n import com.google.javascript.jscomp.graph.UndiGraph.UndiGraphNode;\n+import com.google.javascript.rhino.IR;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n import com.google.javascript.rhino.TokenStream;\n         }\n         sb.append(replacement);\n       }\n-      parent.replaceChild(nodeEntry.getKey(), Node.newString(sb.toString()));\n+      parent.replaceChild(nodeEntry.getKey(), IR.string(sb.toString()));\n       changed = true;\n     }\n \n--- a/src/com/google/javascript/jscomp/ReplaceCssNames.java\n+++ b/src/com/google/javascript/jscomp/ReplaceCssNames.java\n import com.google.common.annotations.VisibleForTesting;\n import com.google.common.base.Joiner;\n import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n+import com.google.javascript.rhino.IR;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n import com.google.javascript.rhino.jstype.JSType;\n             } else {\n               processStringNode(t, second);\n               n.removeChild(first);\n-              Node replacement = new Node(Token.ADD, first,\n-                  Node.newString(\"-\" + second.getString())\n+              Node replacement = IR.add(first,\n+                  IR.string(\"-\" + second.getString())\n                       .copyInformationFrom(second))\n                   .copyInformationFrom(n);\n               replacement.setJSType(nativeStringType);\n--- a/src/com/google/javascript/jscomp/ReplaceIdGenerators.java\n+++ b/src/com/google/javascript/jscomp/ReplaceIdGenerators.java\n import com.google.common.collect.Lists;\n import com.google.common.collect.Maps;\n import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n+import com.google.javascript.rhino.IR;\n import com.google.javascript.rhino.JSDocInfo;\n import com.google.javascript.rhino.Node;\n import java.util.Collections;\n         rename = nameGenerator.generateNextName();\n       }\n \n-      parent.replaceChild(n, Node.newString(rename));\n+      parent.replaceChild(n, IR.string(rename));\n       idGeneratorMap.add(\n           new Replacement(rename, t.getSourceName(), t.getLineNumber()));\n \n--- a/src/com/google/javascript/jscomp/ReplaceMessages.java\n+++ b/src/com/google/javascript/jscomp/ReplaceMessages.java\n package com.google.javascript.jscomp;\n \n import javax.annotation.Nullable;\n+\n+import com.google.javascript.rhino.IR;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n \n         return origValueNode;\n       case Token.ADD:\n         // The message is a simple string. Create a string node.\n-        return Node.newString(message.toString());\n+        return IR.string(message.toString());\n       case Token.CALL:\n         // The message is a function call. Replace it with a string expression.\n         return replaceCallNode(message, origValueNode);\n     Iterator<CharSequence> iterator = message.parts().iterator();\n     Node valueNode = iterator.hasNext()\n         ? constructAddOrStringNode(iterator, argListNode)\n-        : Node.newString(\"\");\n-    Node newBlockNode = new Node(Token.BLOCK,\n-        new Node(Token.RETURN, valueNode));\n+        : IR.string(\"\");\n+    Node newBlockNode = IR.block(IR.returnNode(valueNode));\n \n     functionNode.replaceChild(oldBlockNode, newBlockNode);\n   }\n           // uppercase placeholder names, but function arguments in javascript\n           // code can have mixed case.\n           if (arg.equalsIgnoreCase(phRef.getName())) {\n-            partNode = Node.newString(Token.NAME, arg);\n+            partNode = IR.name(arg);\n           }\n         }\n       }\n       }\n     } else {\n       // The part is just a string literal.\n-      partNode = Node.newString(part.toString());\n+      partNode = IR.string(part.toString());\n     }\n \n     if (partsIterator.hasNext()) {\n-      return new Node(Token.ADD, partNode,\n+      return IR.add(partNode,\n                       constructAddOrStringNode(partsIterator, argListNode));\n     } else {\n       return partNode;\n       }\n     } else {\n       // The part is just a string literal.\n-      partNode = Node.newString(part.toString());\n+      partNode = IR.string(part.toString());\n     }\n \n     if (parts.hasNext()) {\n-      return new Node(Token.ADD, partNode,\n+      return IR.add(partNode,\n           constructStringExprNode(parts, objLitNode));\n     } else {\n       return partNode;\n--- a/src/com/google/javascript/jscomp/ReplaceStrings.java\n+++ b/src/com/google/javascript/jscomp/ReplaceStrings.java\n import com.google.common.collect.Maps;\n import com.google.common.collect.Multimap;\n import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n+import com.google.javascript.rhino.IR;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n import com.google.javascript.rhino.jstype.JSType;\n       case Token.STRING:\n         key = expr.getString();\n         replacementString = getReplacement(key);\n-        replacement = Node.newString(replacementString);\n+        replacement = IR.string(replacementString);\n         break;\n       case Token.ADD:\n         StringBuilder keyBuilder = new StringBuilder();\n-        Node keyNode = Node.newString(\"\");\n+        Node keyNode = IR.string(\"\");\n         replacement = buildReplacement(expr, keyNode, keyBuilder);\n         key = keyBuilder.toString();\n         replacementString = getReplacement(key);\n           if (value != null && value.isString()) {\n             key = value.getString();\n             replacementString = getReplacement(key);\n-            replacement = Node.newString(replacementString);\n+            replacement = IR.string(replacementString);\n             break;\n           }\n         }\n         return prefix;\n       default:\n         keyBuilder.append(placeholderToken);\n-        prefix = new Node(\n-            Token.ADD, prefix, Node.newString(placeholderToken));\n-        return new Node(Token.ADD, prefix, expr.cloneTree());\n+        prefix = IR.add(prefix, IR.string(placeholderToken));\n+        return IR.add(prefix, expr.cloneTree());\n     }\n   }\n \n--- a/src/com/google/javascript/jscomp/RescopeGlobalSymbols.java\n+++ b/src/com/google/javascript/jscomp/RescopeGlobalSymbols.java\n \n import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n import com.google.javascript.jscomp.NodeTraversal.AbstractShallowStatementCallback;\n+import com.google.javascript.rhino.IR;\n import com.google.javascript.rhino.Node;\n-import com.google.javascript.rhino.Token;\n-\n import java.util.ArrayList;\n import java.util.List;\n \n   }\n \n   private void addExternForGlobalSymbolNamespace() {\n-    Node nameNode = Node.newString(Token.NAME, globalSymbolNamespace);\n-    Node varNode = new Node(Token.VAR);\n-    varNode.addChildToBack(nameNode);\n+    Node varNode = IR.var(IR.name(globalSymbolNamespace));\n     CompilerInput input = compiler.newExternInput(\n         \"{RescopeGlobalSymbolsNamespaceVar}\");\n     input.getAstRoot(compiler).addChildrenToBack(varNode);\n \n     private void replaceSymbol(Node node, String name) {\n       Node parent = node.getParent();\n-      Node replacement = new Node(Token.GETPROP,\n-          Node.newString(Token.NAME, globalSymbolNamespace)\n-              .copyInformationFrom(node),\n-          Node.newString(name).copyInformationFrom(node));\n-      replacement.copyInformationFrom(node);\n+      Node replacement = IR.getprop(\n+          IR.name(globalSymbolNamespace).srcref(node),\n+          IR.string(name).srcref(node));\n+      replacement.srcref(node);\n       if (node.hasChildren()) {\n         // var declaration list: var a = 1, b = 2;\n-        Node assign = new Node(Token.ASSIGN, replacement,\n+        Node assign = IR.assign(replacement,\n             node.removeFirstChild());\n         parent.replaceChild(node, assign);\n       } else {\n           commas.add(c.cloneTree());\n         } else {\n           // Var statement outside of for-loop.\n-          Node expr = new Node(Token.EXPR_RESULT);\n-          expr.copyInformationFrom(c);\n-          expr.addChildToBack(c.cloneTree());\n+          Node expr = IR.exprResult(c.cloneTree()).srcref(c);\n           parent.addChildBefore(expr, n);\n         }\n       }\n     private Node joinOnComma(List<Node> commas, Node source) {\n       Node comma = commas.get(0);\n       for (int i = 1; i < commas.size(); i++) {\n-        Node nextComma = new Node(Token.COMMA, comma, commas.get(i));\n+        Node nextComma = IR.comma(comma, commas.get(i));\n         nextComma.copyInformationFrom(source);\n         comma = nextComma;\n       }\n--- a/src/com/google/javascript/jscomp/RuntimeTypeCheck.java\n+++ b/src/com/google/javascript/jscomp/RuntimeTypeCheck.java\n import com.google.common.collect.Iterables;\n import com.google.common.collect.Sets;\n import com.google.common.io.CharStreams;\n+import com.google.javascript.rhino.IR;\n import com.google.javascript.rhino.Node;\n-import com.google.javascript.rhino.Token;\n import com.google.javascript.rhino.jstype.FunctionType;\n import com.google.javascript.rhino.jstype.JSType;\n import com.google.javascript.rhino.jstype.ObjectType;\n       Node classNode = NodeUtil.newQualifiedNameNode(\n           compiler.getCodingConvention(), className, -1, -1);\n \n-      Node marker = Node.newString(\n+      Node marker = IR.string(\n               interfaceType == null ?\n               \"instance_of__\" + className :\n               \"implements__\" + interfaceType.getReferenceName());\n \n-      Node assign = new Node(Token.EXPR_RESULT, new Node(Token.ASSIGN,\n-          new Node(Token.GETELEM,\n-              new Node(Token.GETPROP,\n+      Node assign = IR.exprResult(IR.assign(\n+          IR.getelem(\n+              IR.getprop(\n                   classNode,\n-                  Node.newString(\"prototype\")), marker),\n-          new Node(Token.TRUE)));\n+                  IR.string(\"prototype\")), marker),\n+          IR.trueNode()));\n \n       nodeToInsertAfter.getParent().addChildAfter(assign, nodeToInsertAfter);\n       compiler.reportCodeChange();\n           continue;\n         }\n \n-        checkNode = new Node(Token.EXPR_RESULT, checkNode);\n+        checkNode = IR.exprResult(checkNode);\n         if (insertionPoint == null) {\n           block.addChildToFront(checkNode);\n         } else {\n      * @return the function call node or {@code null} if the type is not checked\n      */\n     private Node createCheckTypeCallNode(JSType type, Node expr) {\n-      Node arrayNode = new Node(Token.ARRAYLIT);\n+      Node arrayNode = IR.arraylit();\n       Collection<JSType> alternates;\n       if (type.isUnionType()) {\n         alternates = Sets.newTreeSet(ALPHA);\n         }\n         arrayNode.addChildToBack(checkerNode);\n       }\n-      return new Node(Token.CALL, jsCode(\"checkType\"), expr, arrayNode);\n+      return IR.call(jsCode(\"checkType\"), expr, arrayNode);\n     }\n \n     /**\n           || type.isNumberValueType()\n           || type.isStringValueType()\n           || type.isVoidType()) {\n-        return new Node(Token.CALL,\n+        return IR.call(\n             jsCode(\"valueChecker\"),\n-            Node.newString(type.toString()));\n+            IR.string(type.toString()));\n \n       } else if (type.isInstanceType()) {\n         ObjectType objType = (ObjectType) type;\n         StaticSourceFile sourceFile =\n             NodeUtil.getSourceFile(objType.getConstructor().getSource());\n         if (sourceFile == null || sourceFile.isExtern()) {\n-          return new Node(Token.CALL,\n+          return IR.call(\n                   jsCode(\"externClassChecker\"),\n-                  Node.newString(refName));\n-        }\n-\n-        return new Node(Token.CALL,\n+                  IR.string(refName));\n+        }\n+\n+        return IR.call(\n                 jsCode(objType.getConstructor().isInterface() ?\n                         \"interfaceChecker\" : \"classChecker\"),\n-                Node.newString(refName));\n+                IR.string(refName));\n \n       } else {\n         // We don't check this type (e.g. unknown & all types).\n--- a/src/com/google/javascript/jscomp/SpecializeModule.java\n+++ b/src/com/google/javascript/jscomp/SpecializeModule.java\n import com.google.common.collect.Lists;\n import com.google.common.collect.Maps;\n import com.google.common.collect.Sets;\n+import com.google.javascript.rhino.IR;\n import com.google.javascript.rhino.Node;\n-import com.google.javascript.rhino.Token;\n-\n import java.util.Collection;\n import java.util.Collections;\n import java.util.List;\n \n     functionInfoBySpecializedFunctionNode = Maps.newLinkedHashMap();\n \n-    Node syntheticModuleJsRoot = new Node(Token.BLOCK);\n+    Node syntheticModuleJsRoot = IR.block();\n     syntheticModuleJsRoot.setIsSyntheticBlock(true);\n \n     for (CompilerInput input : module.getInputs()) {\n \n     // The jsRoot needs a parent (in a normal compilation this would be the\n     // node that contains jsRoot and the externs).\n-    Node syntheticExternsAndJsRoot = new Node(Token.BLOCK);\n+    Node syntheticExternsAndJsRoot = IR.block();\n     syntheticExternsAndJsRoot.addChildToBack(syntheticModuleJsRoot);\n \n     return syntheticModuleJsRoot;\n             NodeUtil.newName(compiler.getCodingConvention(), \"\", nameNode));\n       }\n \n-      Node assignment = new Node(Token.ASSIGN, nameNode, functionCopy);\n+      Node assignment = IR.assign(nameNode, functionCopy);\n       assignment.copyInformationFrom(functionCopy);\n \n       return NodeUtil.newExpr(assignment);\n--- a/src/com/google/javascript/jscomp/StripCode.java\n+++ b/src/com/google/javascript/jscomp/StripCode.java\n import com.google.common.collect.Sets;\n import com.google.javascript.jscomp.CodingConvention.SubclassRelationship;\n import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n+import com.google.javascript.rhino.IR;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n \n      * @param parent {@code n}'s parent\n      */\n     void replaceWithNull(Node n, Node parent) {\n-      parent.replaceChild(n, new Node(Token.NULL));\n+      parent.replaceChild(n, IR.nullNode());\n     }\n \n     /**\n--- a/src/com/google/javascript/jscomp/SyntheticAst.java\n+++ b/src/com/google/javascript/jscomp/SyntheticAst.java\n \n package com.google.javascript.jscomp;\n \n+import com.google.javascript.rhino.IR;\n import com.google.javascript.rhino.InputId;\n import com.google.javascript.rhino.Node;\n-import com.google.javascript.rhino.Token;\n \n \n /**\n \n   @Override\n   public void clearAst() {\n-    root = new Node(Token.SCRIPT);\n+    root = IR.script();\n     root.setInputId(inputId);\n     root.setIsSyntheticBlock(true);\n     root.setStaticSourceFile(sourceFile);\n--- a/src/com/google/javascript/jscomp/UnfoldCompoundAssignments.java\n+++ b/src/com/google/javascript/jscomp/UnfoldCompoundAssignments.java\n \n import com.google.common.base.Preconditions;\n import com.google.javascript.jscomp.NodeTraversal.Callback;\n+import com.google.javascript.rhino.IR;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n \n     // TODO(elnatan): We might want to use type information to only add this '+'\n     // when lhs isn't already a number.\n     if (isIncrement) {\n-      lhs = new Node(Token.POS, lhs);\n+      lhs = IR.pos(lhs);\n     }\n     node.setType(Token.ASSIGN);\n     Node rhs = new Node(isIncrement ? Token.ADD : Token.SUB,\n-        lhs, Node.newNumber(1));\n+        lhs, IR.number(1));\n     rhs.copyInformationFromForTree(node);\n     node.addChildToBack(rhs);\n     compiler.reportCodeChange();\n--- a/src/com/google/javascript/jscomp/VarCheck.java\n+++ b/src/com/google/javascript/jscomp/VarCheck.java\n import com.google.common.collect.Lists;\n import com.google.common.collect.Sets;\n import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n+import com.google.javascript.rhino.IR;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n \n    * subsequent compiler passes from crashing.\n    */\n   private void createSynthesizedExternVar(String varName) {\n-    Node nameNode = Node.newString(Token.NAME, varName);\n+    Node nameNode = IR.name(varName);\n \n     // Mark the variable as constant if it matches the coding convention\n     // for constant vars.\n     }\n \n     getSynthesizedExternsRoot().addChildToBack(\n-        new Node(Token.VAR, nameNode));\n+        IR.var(nameNode));\n     varsToDeclareInExterns.remove(varName);\n     compiler.reportCodeChange();\n   }\n--- a/src/com/google/javascript/jscomp/jsonml/Reader.java\n+++ b/src/com/google/javascript/jscomp/jsonml/Reader.java\n import com.google.javascript.jscomp.AbstractCompiler;\n import com.google.javascript.jscomp.DiagnosticType;\n import com.google.javascript.jscomp.JSError;\n+import com.google.javascript.rhino.IR;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n \n     }\n \n     errorReporter = this.new ErrorReporter(compiler);\n-    Node root = new Node(Token.BLOCK);\n+    Node root = IR.block();\n     nodeIndex = -1;\n \n     Preconditions.checkState(rootElement.getType() == TagType.Program);\n       if (child.getType() == TagType.EmptyStmt ||\n           child.getType() == TagType.Empty) {\n         nodeIndex++;\n-        node.addChildToBack(new Node(Token.EMPTY));\n+        node.addChildToBack(IR.empty());\n       } else {\n         transformElement(child, node);\n       }\n \n     String label = getOptionalAttribute(element, TagAttr.LABEL, String.class);\n     if (label != null) {\n-      node.addChildToBack(Node.newString(Token.LABEL_NAME, label));\n+      node.addChildToBack(IR.labelName(label));\n     }\n   }\n \n         element.getType() == TagType.Empty) {\n       nodeIndex++;\n       // Empty elements are only replaced by BLOCK node\n-      Node block = new Node(Token.BLOCK);\n+      Node block = IR.block();\n       parent.addChildToBack(block);\n       block.putBooleanProp(Node.EMPTY_BLOCK, true);\n     } else if (element.getType() != TagType.BlockStmt) {\n-      Node block = new Node(Token.BLOCK);\n+      Node block = IR.block();\n       parent.addChildToBack(block);\n       boolean state = insertExprResultState;\n       insertExprResultState = true;\n     transformElement(child, node);\n \n     // always insert an extra BLOCK node\n-    Node block = new Node(Token.BLOCK);\n+    Node block = IR.block();\n     block.setIsSyntheticBlock(true);\n     node.addChildToBack(block);\n \n \n     Node node = null;\n     if (name instanceof Number) {\n-      node = Node.newNumber(((Number) name).doubleValue());\n+      node = IR.number(((Number) name).doubleValue());\n     } else if (name instanceof String) {\n-      node = Node.newString(Token.STRING, (String) name);\n+      node = IR.string((String) name);\n     } else {\n       throw new IllegalStateException(\n           \"The name of the property has invalid type.\");\n     parent.addChildToBack(node);\n \n     // the first child represent body\n-    Node block = new Node(Token.BLOCK);\n+    Node block = IR.block();\n     block.setIsSyntheticBlock(true);\n     node.addChildToBack(block);\n \n   private void transformEmpty(JsonML element, Node parent) {\n     switch (parent.getType()) {\n       case Token.ARRAYLIT:\n-        parent.addChildToBack(new Node(Token.EMPTY));\n+        parent.addChildToBack(IR.empty());\n         break;\n       case Token.FUNCTION:\n-        parent.addChildToBack(Node.newString(Token.NAME, \"\"));\n+        parent.addChildToBack(IR.name(\"\"));\n         break;\n       default:\n         throw new IllegalArgumentException(\"Unexpected Empty element.\");\n   private void transformEmptyStmt(JsonML element, Node parent) {\n     Preconditions.checkState(\n         parent.getType() == Token.BLOCK || parent.getType() == Token.SCRIPT);\n-    parent.addChildToBack(new Node(Token.EMPTY));\n+    parent.addChildToBack(IR.empty());\n   }\n \n   private void transformEvalExpr(JsonML element, Node parent)\n     node.putBooleanProp(Node.FREE_CALL, true);\n     parent.addChildToBack(node);\n \n-    Node child = Node.newString(Token.NAME, \"eval\");\n+    Node child = IR.name(\"eval\");\n     child.putBooleanProp(Node.DIRECT_EVAL, true);\n     node.addChildToBack(child);\n \n   private void transformIdExpr(JsonML element, Node parent)\n       throws JsonMLException {\n     String name = getStringAttribute(element, TagAttr.NAME);\n-    Node node = Node.newString(Token.NAME, name);\n+    Node node = IR.name(name);\n     setPosition(node);\n     parent.addChildToBack(node);\n   }\n       throws JsonMLException {\n     JsonML child = element.getChild(0);\n     nodeIndex++;\n-    Node node = Node.newString(Token.NAME,\n+    Node node = IR.name(\n         getAttribute(child, TagAttr.NAME, String.class));\n     setPosition(node);\n     parent.addChildToBack(node);\n \n   private void transformIdPatt(JsonML element, Node parent)\n       throws JsonMLException {\n-    Node node = Node.newString(Token.NAME,\n+    Node node = IR.name(\n         getStringAttribute(element, TagAttr.NAME));\n     setPosition(node);\n     parent.addChildToBack(node);\n       throws JsonMLException {\n     String label = getStringAttribute(element, TagAttr.LABEL);\n     Node node = createNode(Token.LABEL, element);\n-    node.addChildToBack(Node.newString(Token.LABEL_NAME, label));\n+    node.addChildToBack(IR.labelName(label));\n     parent.addChildToBack(node);\n \n     JsonML child = element.getChild(0);\n     if (child.getType() == TagType.EmptyStmt) {\n       nodeIndex++;\n-      node.addChildToBack(new Node(Token.EMPTY));\n+      node.addChildToBack(IR.empty());\n     } else {\n       transformElement(element.getChild(0), node);\n     }\n       case BOOLEAN: {\n         Boolean value = getAttribute(element, TagAttr.VALUE, Boolean.class);\n         if (value) {\n-          node = new Node(Token.TRUE);\n+          node = IR.trueNode();\n         } else {\n-          node = new Node(Token.FALSE);\n+          node = IR.falseNode();\n         }\n         break;\n       }\n       case NULL: {\n         // needed to throw an exception if value is not null\n         getAttribute(element, TagAttr.VALUE, null);\n-        node = new Node(Token.NULL);\n+        node = IR.nullNode();\n         break;\n       }\n \n       case NUMBER: {\n         Double value = getAttribute(element, TagAttr.VALUE, Double.class);\n-        node = Node.newNumber(value);\n+        node = IR.number(value);\n         break;\n       }\n \n       case STRING: {\n         String value = getStringAttribute(element, TagAttr.VALUE);\n-        node = Node.newString(value);\n+        node = IR.string(value);\n         break;\n       }\n \n     Preconditions.checkNotNull(parent);\n     insertExprResultState = true;\n \n-    Node script = new Node(Token.SCRIPT);\n+    Node script = IR.script();\n     script.setIsSyntheticBlock(true);\n     parent.addChildToBack(script);\n \n       parent.setDirectives(directives);\n     } else {\n       // for a directive which is not supported, we create a regular node\n-      Node node = new Node(Token.EXPR_RESULT);\n+      Node node = IR.exprResult(IR.string(directive));\n       parent.addChildToBack(node);\n-      node.addChildToBack(Node.newString(Token.STRING, directive));\n     }\n   }\n \n     parent.addChildToBack(node);\n \n     String body = getStringAttribute(element, TagAttr.BODY);\n-    node.addChildToBack(Node.newString(Token.STRING, body));\n+    node.addChildToBack(IR.string(body));\n \n     String flags = getStringAttribute(element, TagAttr.FLAGS);\n     if (!(flags.equals(\"\"))) {\n-      node.addChildToBack(Node.newString(Token.STRING, flags));\n+      node.addChildToBack(IR.string(flags));\n     }\n   }\n \n     transformElement(child, node);\n \n     // the second child represents catch\n-    Node block = new Node(Token.BLOCK);\n+    Node block = IR.block();\n     node.addChildToBack(block);\n     child = element.getChild(1);\n \n--- a/src/com/google/javascript/jscomp/parsing/IRFactory.java\n+++ b/src/com/google/javascript/jscomp/parsing/IRFactory.java\n import com.google.javascript.jscomp.mozilla.rhino.ast.WhileLoop;\n import com.google.javascript.jscomp.mozilla.rhino.ast.WithStatement;\n import com.google.javascript.jscomp.parsing.Config.LanguageMode;\n+import com.google.javascript.rhino.IR;\n import com.google.javascript.rhino.JSDocInfo;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n   }\n \n   private Node newStringNode(String value) {\n-    return Node.newString(value).clonePropsFrom(templateNode);\n+    return IR.string(value).clonePropsFrom(templateNode);\n   }\n \n   private Node newStringNode(int type, String value) {\n   }\n \n   private Node newNumberNode(Double value) {\n-    return Node.newNumber(value).clonePropsFrom(templateNode);\n+    return IR.number(value).clonePropsFrom(templateNode);\n   }\n }\n--- a/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\n+++ b/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\n import com.google.javascript.jscomp.mozilla.rhino.ErrorReporter;\n import com.google.javascript.jscomp.mozilla.rhino.ast.Comment;\n import com.google.javascript.jscomp.parsing.Config.LanguageMode;\n+import com.google.javascript.rhino.IR;\n import com.google.javascript.rhino.JSDocInfo;\n import com.google.javascript.rhino.JSDocInfo.Visibility;\n import com.google.javascript.rhino.JSDocInfoBuilder;\n       token = next();\n       if (token == JsDocToken.RC) {\n         // EMPTY represents the UNKNOWN type in the Type AST.\n-        return wrapNode(Token.ELLIPSIS, new Node(Token.EMPTY));\n+        return wrapNode(Token.ELLIPSIS, IR.empty());\n       }\n       restArg = true;\n     }\n     if (typeExpr == null) {\n       return null;\n     }\n-    Node typeList = new Node(Token.BLOCK);\n+    Node typeList = IR.block();\n     typeList.addChildToBack(typeExpr);\n     while (match(JsDocToken.COMMA)) {\n       next();\n   // e.g., source-name, between all nodes.\n   private Node createTemplateNode() {\n     // The Node type choice is arbitrary.\n-    Node templateNode = new Node(Token.SCRIPT);\n+    Node templateNode = IR.script();\n     templateNode.setStaticSourceFile(\n       this.associatedNode != null ?\n       this.associatedNode.getStaticSourceFile() :\n--- a/src/com/google/javascript/rhino/IR.java\n+++ b/src/com/google/javascript/rhino/IR.java\n   // TODO(johnlenz): quoted props\n \n   public static Node propdef(Node string, Node value) {\n-    Preconditions.checkState(!string.isString());\n+    Preconditions.checkState(string.isString());\n     Preconditions.checkState(!string.hasChildren());\n     Preconditions.checkState(mayBeExpression(value));\n     string.addChildToFront(value);", "timestamp": 1322000932, "metainfo": ""}