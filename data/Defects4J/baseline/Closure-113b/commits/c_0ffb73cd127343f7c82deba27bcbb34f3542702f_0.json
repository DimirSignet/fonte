{"sha": "0ffb73cd127343f7c82deba27bcbb34f3542702f", "log": "Add switch for controlling new aggressive minimization ------------- Created by MOE: http://code.google.com/p/moe-java MOE_MIGRATED_REVID=46479423", "commit": "\n--- a/src/com/google/javascript/jscomp/PeepholeMinimizeConditions.java\n+++ b/src/com/google/javascript/jscomp/PeepholeMinimizeConditions.java\n   extends AbstractPeepholeOptimization {\n \n   private static final int AND_PRECEDENCE = NodeUtil.precedence(Token.AND);\n+  private static final int NOT_PRECEDENCE = NodeUtil.precedence(Token.NOT);\n+  private static final boolean DEFAULT_AGGRESSIVE_MINIMIZE_CONDITIONS = false;\n \n   private final boolean late;\n+  private final boolean aggressiveMinimization;\n \n   static final Predicate<Node> DONT_TRAVERSE_FUNCTIONS_PREDICATE\n       = new Predicate<Node>() {\n    * do anything to minimize for size.\n    */\n   PeepholeMinimizeConditions(boolean late) {\n+    this(late, DEFAULT_AGGRESSIVE_MINIMIZE_CONDITIONS);\n+  }\n+\n+  PeepholeMinimizeConditions(boolean late, boolean aggressive) {\n     this.late = late;\n+    this.aggressiveMinimization = aggressive;\n   }\n \n   /**\n     Node thenBranch = originalCond.getNext();\n     Node elseBranch = thenBranch.getNext();\n \n-    MinimizedCondition minCond = MinimizedCondition\n-        .fromConditionNode(originalCond);\n-    // Compute two minimized representations. The first representation counts\n-    // a leading NOT node, and the second ignores a leading NOT node.\n-    // If we can fold the if statement into a HOOK or boolean operation,\n-    // then the NOT node does not matter, and we prefer the second condition.\n-    // If we cannot fold the if statement, then we prefer the first condition.\n-    Node unnegatedCond = minCond.getShorterRepresentation(true);\n-    Node shortCond = minCond.getShorterRepresentation(false);\n+\n+    Node unnegatedCond;\n+    Node shortCond;\n+    if (aggressiveMinimization) {\n+      MinimizedCondition minCond = MinimizedCondition\n+          .fromConditionNode(originalCond);\n+      // Compute two minimized representations. The first representation counts\n+      // a leading NOT node, and the second ignores a leading NOT node.\n+      // If we can fold the if statement into a HOOK or boolean operation,\n+      // then the NOT node does not matter, and we prefer the second condition.\n+      // If we cannot fold the if statement, then we prefer the first condition.\n+      unnegatedCond = minCond.getShorterRepresentation(true);\n+      shortCond = minCond.getShorterRepresentation(false);\n+    } else {\n+      unnegatedCond = originalCond;\n+      shortCond = originalCond;\n+    }\n \n     if (elseBranch == null) {\n       if (isFoldableExpressBlock(thenBranch)) {\n           return n;\n         }\n \n+        n.removeChild(originalCond);\n         Node and = IR.and(shortCond, expr.removeFirstChild()).srcref(n);\n         Node newExpr = NodeUtil.newExpr(and);\n         parent.replaceChild(n, newExpr);\n     if (isReturnExpressBlock(thenBranch) && isReturnExpressBlock(elseBranch)) {\n       Node thenExpr = getBlockReturnExpression(thenBranch);\n       Node elseExpr = getBlockReturnExpression(elseBranch);\n+      n.removeChild(originalCond);\n       thenExpr.detachFromParent();\n       elseExpr.detachFromParent();\n \n               (!mayHaveSideEffects(originalCond) ||\n                   (thenOp.isAssign() && thenOp.getFirstChild().isName()))) {\n \n+            n.removeChild(originalCond);\n             Node assignName = thenOp.removeFirstChild();\n             Node thenExpr = thenOp.removeFirstChild();\n             Node elseExpr = elseOp.getLastChild();\n         }\n       }\n       // if(x)foo();else bar(); -> x?foo():bar()\n+      n.removeChild(originalCond);\n       thenOp.detachFromParent();\n       elseOp.detachFromParent();\n       Node expr = IR.exprResult(\n           && name1.getString().equals(maybeName2.getString())) {\n         Node thenExpr = name1.removeChildren();\n         Node elseExpr = elseAssign.getLastChild().detachFromParent();\n+        originalCond.detachFromParent();\n         Node hookNode = IR.hook(shortCond, thenExpr, elseExpr)\n                             .srcref(n);\n         var.detachFromParent();\n           && maybeName1.getString().equals(name2.getString())) {\n         Node thenExpr = thenAssign.getLastChild().detachFromParent();\n         Node elseExpr = name2.removeChildren();\n+        originalCond.detachFromParent();\n         Node hookNode = IR.hook(shortCond, thenExpr, elseExpr)\n                             .srcref(n);\n         var.detachFromParent();\n   }\n \n   /**\n+   * Whether the node type has higher precedence than \"precedence\"\n+   */\n+  private static boolean isHigherPrecedence(Node n, final int precedence) {\n+    return NodeUtil.precedence(n.getType()) > precedence;\n+  }\n+\n+  /**\n    * Does the expression contain a property assignment?\n    */\n   private static boolean isPropertyAssignmentInExpression(Node n) {\n    */\n   private Node tryMinimizeCondition(Node n, boolean countLeadingNot) {\n     n = performConditionSubstitutions(n);\n-    return demorganMinimizeCondition(n, countLeadingNot);\n+    if (aggressiveMinimization) {\n+      return demorganMinimizeCondition(n, countLeadingNot);\n+    } else {\n+      return n;\n+    }\n   }\n \n   /**\n     Node parent = n.getParent();\n \n     switch (n.getType()) {\n+      case Token.NOT:\n+        Node first = n.getFirstChild();\n+        switch (first.getType()) {\n+          case Token.NOT: {\n+              Node newRoot = first.removeFirstChild();\n+              parent.replaceChild(n, newRoot);\n+              reportCodeChange();\n+              // No need to traverse, tryMinimizeCondition is called on the\n+              // NOT children are handled below.\n+              return newRoot;\n+            }\n+          case Token.AND:\n+          case Token.OR: {\n+              // !(!x && !y) --> x || y\n+              // !(!x || !y) --> x && y\n+              // !(!x && y) --> x || !y\n+              // !(!x || y) --> x && !y\n+              // !(x && !y) --> !x || y\n+              // !(x || !y) --> !x && y\n+              // !(x && y) --> !x || !y\n+              // !(x || y) --> !x && !y\n+              Node leftParent = first.getFirstChild();\n+              Node rightParent = first.getLastChild();\n+              Node left, right;\n+\n+              // Check special case when such transformation cannot reduce\n+              // due to the added ()\n+              // It only occurs when both of expressions are not NOT expressions\n+              if (!leftParent.isNot()\n+                  && !rightParent.isNot()) {\n+                // If an expression has higher precedence than && or ||,\n+                // but lower precedence than NOT, an additional () is needed\n+                // Thus we do not preceed\n+                int opPrecedence = NodeUtil.precedence(first.getType());\n+                if ((isLowerPrecedence(leftParent, NOT_PRECEDENCE)\n+                    && isHigherPrecedence(leftParent, opPrecedence))\n+                    || (isLowerPrecedence(rightParent, NOT_PRECEDENCE)\n+                    && isHigherPrecedence(rightParent, opPrecedence))) {\n+                  return n;\n+                }\n+              }\n+\n+              if (leftParent.isNot()) {\n+                left = leftParent.removeFirstChild();\n+              } else {\n+                leftParent.detachFromParent();\n+                left = IR.not(leftParent).srcref(leftParent);\n+              }\n+              if (rightParent.isNot()) {\n+                right = rightParent.removeFirstChild();\n+              } else {\n+                rightParent.detachFromParent();\n+                right = IR.not(rightParent).srcref(rightParent);\n+              }\n+\n+              int newOp = (first.isAnd()) ? Token.OR : Token.AND;\n+              Node newRoot = new Node(newOp, left, right);\n+              parent.replaceChild(n, newRoot);\n+              reportCodeChange();\n+              // No need to traverse, tryMinimizeCondition is called on the\n+              // AND and OR children below.\n+              return newRoot;\n+            }\n+\n+           default:\n+             TernaryValue nVal = NodeUtil.getPureBooleanValue(first);\n+             if (nVal != TernaryValue.UNKNOWN) {\n+               boolean result = nVal.not().toBoolean(true);\n+               int equivalentResult = result ? 1 : 0;\n+               return maybeReplaceChildWithNumber(n, parent, equivalentResult);\n+             }\n+        }\n+        // No need to traverse, tryMinimizeCondition is called on the NOT\n+        // children in the general case in the main post-order traversal.\n+        return n;\n       case Token.OR:\n       case Token.AND: {\n         Node left = n.getFirstChild();\n--- a/test/com/google/javascript/jscomp/PeepholeMinimizeConditionsTest.java\n+++ b/test/com/google/javascript/jscomp/PeepholeMinimizeConditionsTest.java\n public class PeepholeMinimizeConditionsTest extends CompilerTestCase {\n \n   private boolean late = true;\n+  private boolean aggressive = true;\n \n   // TODO(user): Remove this when we no longer need to do string comparison.\n   private PeepholeMinimizeConditionsTest(boolean compareAsTree) {\n   @Override\n   public void setUp() throws Exception {\n     late = true;\n+    aggressive = true;\n     super.setUp();\n     enableLineNumberCheck(true);\n     disableNormalize();\n   @Override\n   public CompilerPass getProcessor(final Compiler compiler) {\n     PeepholeOptimizationsPass peepholePass = new PeepholeOptimizationsPass(\n-        compiler, new PeepholeMinimizeConditions(late));\n+        compiler, new PeepholeMinimizeConditions(late, aggressive));\n     peepholePass.setRetraverseOnChange(false);\n     return peepholePass;\n   }", "timestamp": 1368488199, "metainfo": ""}