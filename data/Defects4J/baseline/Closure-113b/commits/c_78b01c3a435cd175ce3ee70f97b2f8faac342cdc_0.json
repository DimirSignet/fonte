{"sha": "78b01c3a435cd175ce3ee70f97b2f8faac342cdc", "log": "Correct handling of conditional branches within expressions when doing dead assignment elminination. Fixes issue 384.  R=acleung DELTA=166  (143 added, 0 deleted, 23 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=951   ", "commit": "\n--- a/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java\n+++ b/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java\n   private boolean isVariableStillLiveWithinExpression(\n       Node n, Node exprRoot, String variable) {\n     while (n != exprRoot) {\n-      for(Node sibling = n.getNext(); sibling != null;\n-          sibling = sibling.getNext()) {\n-        if (!ControlFlowGraph.isEnteringNewCfgNode(sibling)) {\n-          VariableLiveness state = isVariableReadBeforeKill(sibling, variable);\n-\n-          // If we see a READ or KILL there is no need to continue.\n-          if (state == VariableLiveness.READ) {\n-            return true;\n-          } else if (state == VariableLiveness.KILL) {\n-            return false;\n-          }\n-        }\n+      VariableLiveness state = VariableLiveness.MAYBE_LIVE;\n+      switch (n.getParent().getType()) {\n+        case Token.OR:\n+        case Token.AND:\n+          // If the currently node is the first child of\n+          // AND/OR, be conservative only consider the READs\n+          // of the second operand.\n+          if (n.getNext() != null) {\n+            state = isVariableReadBeforeKill(\n+                n.getNext(), variable);\n+            if (state == VariableLiveness.KILL) {\n+              state = VariableLiveness.MAYBE_LIVE;\n+            }\n+          }\n+          break;\n+\n+        case Token.HOOK:\n+          // If current node is the condition, check each following\n+          // branch, otherwise it is a conditional branch and the\n+          // other branch can be ignored.\n+          if (n.getNext() != null && n.getNext().getNext() != null) {\n+            state = checkHookBranchReadBeforeKill(\n+                n.getNext(), n.getNext().getNext(), variable);\n+          }\n+          break;\n+\n+        default:\n+          for(Node sibling = n.getNext(); sibling != null;\n+              sibling = sibling.getNext()) {\n+            state = isVariableReadBeforeKill(sibling, variable);\n+            if (state != VariableLiveness.MAYBE_LIVE) {\n+              break;\n+            }\n+          }\n+      }\n+\n+      // If we see a READ or KILL there is no need to continue.\n+      if (state == VariableLiveness.READ) {\n+        return true;\n+      } else if (state == VariableLiveness.KILL) {\n+        return false;\n       }\n       n = n.getParent();\n     }\n    */\n   private VariableLiveness isVariableReadBeforeKill(\n       Node n, String variable) {\n+    if (ControlFlowGraph.isEnteringNewCfgNode(n)) { // Not a FUNCTION\n+      return VariableLiveness.MAYBE_LIVE;\n+    }\n+\n     if (NodeUtil.isName(n) && variable.equals(n.getString())) {\n       if (NodeUtil.isLhs(n, n.getParent())) {\n         Preconditions.checkState(n.getParent().getType() == Token.ASSIGN);\n       }\n     }\n \n-    // Expressions are evaluated left-right, depth first.\n-    for (Node child = n.getFirstChild();\n-        child != null; child = child.getNext()) {\n-      if (!ControlFlowGraph.isEnteringNewCfgNode(child)) { // Not a FUNCTION\n-        VariableLiveness state = isVariableReadBeforeKill(child, variable);\n-        if (state != VariableLiveness.MAYBE_LIVE) {\n-          return state;\n-        }\n-      }\n-    }\n+    switch (n.getType()) {\n+      // Conditionals\n+      case Token.OR:\n+      case Token.AND:\n+        VariableLiveness v1 = isVariableReadBeforeKill(\n+          n.getFirstChild(), variable);\n+        VariableLiveness v2 = isVariableReadBeforeKill(\n+          n.getLastChild(), variable);\n+        // With a AND/OR the first branch always runs, but the second is\n+        // may not.\n+        if (v1 != VariableLiveness.MAYBE_LIVE) {\n+          return v1;\n+        } else if (v2 == VariableLiveness.READ) {\n+          return VariableLiveness.READ;\n+        } else {\n+          return VariableLiveness.MAYBE_LIVE;\n+        }\n+      case Token.HOOK:\n+        VariableLiveness first = isVariableReadBeforeKill(\n+            n.getFirstChild(), variable);\n+        if (first != VariableLiveness.MAYBE_LIVE) {\n+          return first;\n+        }\n+        return checkHookBranchReadBeforeKill(\n+            n.getFirstChild().getNext(), n.getLastChild(), variable);\n+\n+      default:\n+        // Expressions are evaluated left-right, depth first.\n+        for (Node child = n.getFirstChild();\n+            child != null; child = child.getNext()) {\n+          VariableLiveness state = isVariableReadBeforeKill(child, variable);\n+          if (state != VariableLiveness.MAYBE_LIVE) {\n+            return state;\n+          }\n+        }\n+    }\n+\n     return VariableLiveness.MAYBE_LIVE;\n   }\n+\n+  private VariableLiveness checkHookBranchReadBeforeKill(\n+      Node trueCase, Node falseCase, String variable) {\n+    VariableLiveness v1 = isVariableReadBeforeKill(\n+      trueCase, variable);\n+    VariableLiveness v2 = isVariableReadBeforeKill(\n+      falseCase, variable);\n+    // With a hook it is unknown which branch will run, so\n+    // we must be conservative.  A read by either is a READ, and\n+    // a KILL is only considered if both KILL.\n+    if (v1 == VariableLiveness.READ || v2 == VariableLiveness.READ) {\n+      return VariableLiveness.READ;\n+    } else if (v1 == VariableLiveness.KILL && v2 == VariableLiveness.KILL) {\n+      return VariableLiveness.KILL;\n+    } else {\n+      return VariableLiveness.MAYBE_LIVE;\n+    }\n+  }\n }\n--- a/test/com/google/javascript/jscomp/DeadAssignmentsEliminationTest.java\n+++ b/test/com/google/javascript/jscomp/DeadAssignmentsEliminationTest.java\n   }\n \n \n-  public void testInExpression() {\n+  public void testInExpression1() {\n     inFunction(\"var a; return a=(a=(a=3));\", \"var a; return 3;\");\n     inFunction(\"var a; return a=(a=(a=a));\", \"var a; return a;\");\n     inFunction(\"var a; return a=(a=(a=a+1)+1);\", \"var a; return a+1+1;\");\n     inFunction(\"var a; return a=(a=(a=f(a)+1)+1);\", \"var a; return f(a)+1+1;\");\n     inFunction(\"var a; return a=f(a=f(a=f(a)));\", \"var a; return f(f(f(a)));\");\n   }\n+\n+  public void testInExpression2() {\n+    // This can be improved.  \"a = 1\" is dead but \"a\" is read in the following\n+    // expression.\n+    inFunction(\n+        \"var a; a = 1; if ((a = 2) || (a = 3) || (a)) {}\",\n+        \"var a; a = 1; if ((    2) || (a = 3) || (a)) {}\");\n+\n+    inFunction(\n+        \"var a; (a = 1) || (a = 2)\",\n+        \"var a; 1 || 2\");\n+\n+    inFunction(\"var a; (a = 1) || (a = 2); return a\");\n+\n+    inFunction(\n+        \"var a; a = 1; a ? a = 2 : a;\",\n+        \"var a; a = 1; a ?     2 : a;\");\n+\n+    inFunction(\"var a; a = 1; a ? a = 2 : a; return a\");\n+\n+    inFunction(\n+        \"var a; a = 1; a ? a : a = 2;\",\n+        \"var a; a = 1; a ? a : 2;\");\n+\n+    inFunction(\"var a; a = 1; a ? a : a =2; return a\");\n+\n+    inFunction(\n+        \"var a; (a = 1) ? a = 2 : a = 3;\",\n+        \"var a;      1  ?     2 :     3;\");\n+\n+    // This can be improved.  \"a = 1\" is dead but \"a\" is read in the following\n+    // expression.\n+    inFunction(\"var a; (a = 1) ? a = 2 : a = 3; return a\");\n+  }\n+\n+  public void testIssue384a() {\n+    inFunction(\n+            \" var a, b;\\n\" +\n+            \" if (f(b = true) || f(b = false))\\n\" +\n+            \"   a = b;\\n\" +\n+            \" else\\n\" +\n+            \"   a = null;\\n\" +\n+            \" return a;\");\n+  }\n+\n+  public void testIssue384b() {\n+    inFunction(\n+            \" var a, b;\\n\" +\n+            \" (f(b = true) || f(b = false)) ? (a = b) : (a = null);\\n\" +\n+            \" return a;\");\n+  }\n+\n+  public void testIssue384c() {\n+    inFunction(\n+            \" var a, b;\\n\" +\n+            \" (a ? f(b = true) : f(b = false)) && (a = b);\\n\" +\n+            \" return a;\");\n+  }\n+\n+  public void testIssue384d() {\n+    inFunction(\n+            \" var a, b;\\n\" +\n+            \" (f(b = true) || f(b = false)) && (a = b);\\n\" +\n+            \" return a;\");\n+  }\n }", "timestamp": 1300485568, "metainfo": ""}