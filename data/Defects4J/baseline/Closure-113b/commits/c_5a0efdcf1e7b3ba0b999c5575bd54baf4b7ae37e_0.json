{"sha": "5a0efdcf1e7b3ba0b999c5575bd54baf4b7ae37e", "log": "Handle chained assignment and the resulting aliases more gracefully. Fixes issue 874 Fixes issue 838  R=nicksantos DELTA=442 (358 added, 33 deleted, 51 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=6053   ", "commit": "\n--- a/src/com/google/javascript/jscomp/NameAnalyzer.java\n+++ b/src/com/google/javascript/jscomp/NameAnalyzer.java\n import com.google.common.base.Preconditions;\n import com.google.common.base.Predicate;\n import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.LinkedListMultimap;\n+import com.google.common.collect.ListMultimap;\n import com.google.common.collect.Lists;\n import com.google.common.collect.Maps;\n import com.google.common.collect.Sets;\n import com.google.javascript.jscomp.NodeTraversal.Callback;\n import com.google.javascript.jscomp.Scope.Var;\n import com.google.javascript.jscomp.graph.DiGraph;\n+import com.google.javascript.jscomp.graph.DiGraph.DiGraphEdge;\n import com.google.javascript.jscomp.graph.FixedPointGraphTraversal;\n+import com.google.javascript.jscomp.graph.FixedPointGraphTraversal.EdgeCallback;\n import com.google.javascript.jscomp.graph.LinkedDirectedGraph;\n-import com.google.javascript.jscomp.graph.DiGraph.DiGraphEdge;\n-import com.google.javascript.jscomp.graph.FixedPointGraphTraversal.EdgeCallback;\n import com.google.javascript.rhino.IR;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n    * If scopes.get(node).equals(name) && node2 is a child of node, then node2\n    * will not get executed unless name is referenced via a get operation\n    */\n-  private final Map<Node, NameInformation> scopes = Maps.newHashMap();\n+  private final ListMultimap<Node, NameInformation> scopes =\n+      LinkedListMultimap.create();\n \n   /** Used to parse prototype names */\n   private static final String PROTOTYPE_SUBSTRING = \".prototype.\";\n     public void visit(NodeTraversal t, Node n, Node parent) {\n       NameInformation ns = null;\n       if (NodeUtil.isVarDeclaration(n)) {\n-        ns = createNameInformation(t, n, parent);\n+        ns = createNameInformation(t, n);\n       } else if (NodeUtil.isFunctionDeclaration(n)) {\n-        ns = createNameInformation(t, n.getFirstChild(), n);\n+        ns = createNameInformation(t, n.getFirstChild());\n       }\n       if (ns != null) {\n         JsName jsName = getName(ns.name, true);\n       }\n \n       if (n.isAssign()) {\n-        Node nameNode = n.getFirstChild();\n-        NameInformation ns = createNameInformation(t, nameNode, n);\n-        if (ns != null) {\n-          if (parent.isFor() && !NodeUtil.isForIn(parent)) {\n-            // Patch for assignments that appear in the init,\n-            // condition or iteration part of a FOR loop.  Without\n-            // this change, all 3 of those parts try to claim the for\n-            // loop as their dependency scope.  The last assignment in\n-            // those three fields wins, which can result in incorrect\n-            // reference edges between referenced and assigned variables.\n-            //\n-            // TODO(user) revisit the dependency scope calculation\n-            // logic.\n-            if (parent.getFirstChild().getNext() != n) {\n-              recordDepScope(n, ns);\n-            } else {\n-              recordDepScope(nameNode, ns);\n-            }\n-          } else {\n-            recordDepScope(n, ns);\n-          }\n+        recordAssignment(t, n, n);\n+        if (!NodeUtil.isImmutableResult(n.getLastChild())) {\n+          recordConsumers(t, n, n);\n         }\n       } else if (NodeUtil.isVarDeclaration(n)) {\n-        NameInformation ns = createNameInformation(t, n, parent);\n+        NameInformation ns = createNameInformation(t, n);\n         recordDepScope(n, ns);\n       } else if (NodeUtil.isFunctionDeclaration(n)) {\n-        NameInformation ns = createNameInformation(t, n.getFirstChild(), n);\n+        NameInformation ns = createNameInformation(t, n.getFirstChild());\n         recordDepScope(n, ns);\n       } else if (NodeUtil.isExprCall(n)) {\n         Node callNode = n.getFirstChild();\n         Node nameNode = callNode.getFirstChild();\n-        NameInformation ns = createNameInformation(t, nameNode, callNode);\n+        NameInformation ns = createNameInformation(t, nameNode);\n         if (ns != null && ns.onlyAffectsClassDef) {\n           recordDepScope(n, ns);\n+        }\n+      }\n+    }\n+\n+    private void recordConsumers(NodeTraversal t, Node n, Node recordNode) {\n+      Node parent = n.getParent();\n+      switch (parent.getType()) {\n+        case Token.ASSIGN:\n+          if (n == parent.getLastChild()) {\n+            recordAssignment(t, parent, recordNode);\n+          }\n+          recordConsumers(t, parent, recordNode);\n+          break;\n+        case Token.NAME:\n+          NameInformation ns = createNameInformation(t, parent);\n+          recordDepScope(recordNode, ns);\n+          break;\n+        case Token.OR:\n+          recordConsumers(t, parent, recordNode);\n+          break;\n+        case Token.AND:\n+          // In \"a && b\" only \"b\" can be meaningfully aliased.\n+          // \"a\" must be falsy, which it must be an immutable, non-Object\n+        case Token.COMMA:\n+        case Token.HOOK:\n+          if (n != parent.getFirstChild()) {\n+            recordConsumers(t, parent, recordNode);\n+          }\n+          break;\n+      }\n+    }\n+\n+    private void recordAssignment(NodeTraversal t, Node n, Node recordNode) {\n+      Node nameNode = n.getFirstChild();\n+      Node parent = n.getParent();\n+      NameInformation ns = createNameInformation(t, nameNode);\n+      if (ns != null) {\n+        if (parent.isFor() && !NodeUtil.isForIn(parent)) {\n+          // Patch for assignments that appear in the init,\n+          // condition or iteration part of a FOR loop.  Without\n+          // this change, all 3 of those parts try to claim the for\n+          // loop as their dependency scope.  The last assignment in\n+          // those three fields wins, which can result in incorrect\n+          // reference edges between referenced and assigned variables.\n+          //\n+          // TODO(user) revisit the dependency scope calculation\n+          // logic.\n+          if (parent.getFirstChild().getNext() != n) {\n+            recordDepScope(recordNode, ns);\n+          } else {\n+            recordDepScope(nameNode, ns);\n+          }\n+        } else {\n+          recordDepScope(recordNode, ns);\n         }\n       }\n     }\n      * Defines a dependency scope.\n      */\n     private void recordDepScope(Node node, NameInformation name) {\n+      Preconditions.checkNotNull(name);\n       scopes.put(node, name);\n     }\n   }\n     @Override\n     public void visit(NodeTraversal t, Node n, Node parent) {\n       if (NodeUtil.isVarDeclaration(n)) {\n-        NameInformation ns = createNameInformation(t, n, parent);\n+        NameInformation ns = createNameInformation(t, n);\n         Preconditions.checkNotNull(ns, \"NameInformation is null\");\n         createName(ns.name);\n       } else if (NodeUtil.isFunctionDeclaration(n)) {\n         Node nameNode = n.getFirstChild();\n-        NameInformation ns = createNameInformation(t, nameNode, n);\n+        NameInformation ns = createNameInformation(t, nameNode);\n         Preconditions.checkNotNull(ns, \"NameInformation is null\");\n         createName(nameNode.getString());\n       }\n       // Record global variable and function declarations\n       if (t.inGlobalScope()) {\n         if (NodeUtil.isVarDeclaration(n)) {\n-          NameInformation ns = createNameInformation(t, n, parent);\n+          NameInformation ns = createNameInformation(t, n);\n           Preconditions.checkNotNull(ns);\n           recordSet(ns.name, n);\n         } else if (NodeUtil.isFunctionDeclaration(n)) {\n           Node nameNode = n.getFirstChild();\n-          NameInformation ns = createNameInformation(t, nameNode, n);\n+          NameInformation ns = createNameInformation(t, nameNode);\n           if (ns != null) {\n             JsName nameInfo = getName(nameNode.getString(), true);\n             recordSet(nameInfo.name, nameNode);\n           }\n         } else if (NodeUtil.isObjectLitKey(n, parent)) {\n-          NameInformation ns = createNameInformation(t, n, parent);\n+          NameInformation ns = createNameInformation(t, n);\n           if (ns != null) {\n             recordSet(ns.name, n);\n           }\n       if (n.isAssign()) {\n         Node nameNode = n.getFirstChild();\n \n-        NameInformation ns = createNameInformation(t, nameNode, n);\n+        NameInformation ns = createNameInformation(t, nameNode);\n         if (ns != null) {\n           if (ns.isPrototype) {\n             recordPrototypeSet(ns.prototypeClass, ns.prototypeProperty, n);\n         }\n       } else if (n.isCall()) {\n         Node nameNode = n.getFirstChild();\n-        NameInformation ns = createNameInformation(t, nameNode, n);\n+        NameInformation ns = createNameInformation(t, nameNode);\n         if (ns != null && ns.onlyAffectsClassDef) {\n           JsName name = getName(ns.name, true);\n           refNodes.add(new ClassDefiningFunctionNode(name, n));\n         return;\n       }\n \n-      NameInformation nameInfo = createNameInformation(t, n, parent);\n+      NameInformation nameInfo = createNameInformation(t, n);\n       if (nameInfo == null) {\n         // The name is not a global name\n         return;\n       // looking up the nearest enclosing dependency scope. It's unnecessary to\n       // determine all enclosing dependency scopes because this callback should\n       // create a chain of references between them.\n-      NameInformation referring = getDependencyScope(n);\n+      List<NameInformation> referers = getDependencyScope(n);\n+      if (referers.isEmpty()) {\n+        maybeRecordReferenceOrAlias(t, n, parent, nameInfo, null);\n+      } else {\n+        for (NameInformation referring : referers) {\n+          maybeRecordReferenceOrAlias(t, n, parent, nameInfo, referring);\n+        }\n+        recordAliases(referers);\n+      }\n+    }\n+\n+    private void maybeRecordReferenceOrAlias(\n+        NodeTraversal t, Node n, Node parent,\n+        NameInformation nameInfo, NameInformation referring) {\n       String referringName = \"\";\n       if (referring != null) {\n         referringName = referring.isPrototype\n       }\n \n       if (nodesToKeep.contains(n)) {\n-        NameInformation functionScope = getEnclosingFunctionDependencyScope(t);\n-        if (functionScope != null) {\n-          recordReference(functionScope.name, name, RefType.REGULAR);\n+        List<NameInformation> functionScopes =\n+            getEnclosingFunctionDependencyScope(t);\n+        if (!functionScopes.isEmpty()) {\n+          for (NameInformation functionScope : functionScopes) {\n+            recordReference(functionScope.name, name, RefType.REGULAR);\n+          }\n         } else {\n           recordReference(WINDOW, name, RefType.REGULAR);\n+          if (referring != null) {\n+            maybeRecordAlias(name, parent, referring, referringName);\n+          }\n         }\n       } else if (referring != null) {\n         if (!maybeRecordAlias(name, parent, referring, referringName)) {\n             recordReference(WINDOW, name, RefType.REGULAR);\n             break;\n           }\n+        }\n+      }\n+    }\n+\n+    private void recordAliases(List<NameInformation> referers) {\n+      int size = referers.size();\n+      for (int i = 0; i < size; i++) {\n+        for (int j = i + 1; j < size; j++) {\n+          recordAlias(referers.get(i).name, referers.get(j).name);\n+          recordAlias(referers.get(j).name, referers.get(i).name);\n         }\n       }\n     }\n           parent.isAssign()) &&\n           !isPrototypePropAssignment &&\n           referring != null &&\n-          scopes.get(parent) == referring) {\n+          scopes.get(parent).contains(referring)) {\n         recordAlias(referringName, name);\n         return true;\n       }\n    *\n    * @param t The node traversal\n    * @param n The current node\n-   * @param parent The parent of n\n    * @return The name information, or null if the name is irrelevant to this\n    *     pass\n    */\n-  private NameInformation createNameInformation(NodeTraversal t, Node n,\n-      Node parent) {\n+  private NameInformation createNameInformation(NodeTraversal t, Node n) {\n+    Node parent = n.getParent();\n     // Build the full name and find its root node by iterating down through all\n     // GETPROP/GETELEM nodes.\n     String name = \"\";\n             n.isGetProp() &&\n             parent.isAssign() &&\n             \"prototype\".equals(n.getLastChild().getString())) {\n-          if (createNameInformation(t, n.getFirstChild(), n) != null) {\n+          if (createNameInformation(t, n.getFirstChild()) != null) {\n             name = rootNameNode.getString() + name;\n             name = name.substring(0, name.length() - PROTOTYPE_SUFFIX_LEN);\n             NameInformation nameInfo = new NameInformation();\n   /**\n    * Gets the nearest enclosing dependency scope, or null if there isn't one.\n    */\n-  private NameInformation getDependencyScope(Node n) {\n+  private List<NameInformation> getDependencyScope(Node n) {\n     for (Node node : n.getAncestors()) {\n-      NameInformation ref = scopes.get(node);\n-      if (ref != null) {\n-        return ref;\n-      }\n-    }\n-\n-    return null;\n+      List<NameInformation> refs = scopes.get(node);\n+      if (!refs.isEmpty()) {\n+        return refs;\n+      }\n+    }\n+\n+    return Collections.emptyList();\n   }\n \n   /**\n    * its parent if the parent node is a variable declaration or\n    * assignment.\n    */\n-  private NameInformation getEnclosingFunctionDependencyScope(NodeTraversal t) {\n+  private List<NameInformation> getEnclosingFunctionDependencyScope(\n+      NodeTraversal t) {\n     Node function = t.getEnclosingFunction();\n     if (function == null) {\n-      return null;\n-    }\n-\n-    NameInformation ref = scopes.get(function);\n-    if (ref != null) {\n-      return ref;\n+      return Collections.emptyList();\n+    }\n+\n+    List<NameInformation> refs = scopes.get(function);\n+    if (!refs.isEmpty()) {\n+      return refs;\n     }\n \n     // Function expression.  try to get a name from the parent var\n       }\n     }\n \n-    return null;\n+    return Collections.emptyList();\n   }\n \n   /**\n         break;\n       case Token.ASSIGN:\n         Preconditions.checkArgument(parent.isFor(),\n-            \"Unsupported assignment in replaceWithRhs. parent: %s\", Token.name(parent.getType()));\n+            \"Unsupported assignment in replaceWithRhs. parent: %s\",\n+            Token.name(parent.getType()));\n         break;\n       default:\n         throw new IllegalArgumentException(\n--- a/src/com/google/javascript/jscomp/NodeUtil.java\n+++ b/src/com/google/javascript/jscomp/NodeUtil.java\n     return n.isNull() || isUndefined(n);\n   }\n \n+  static final Predicate<Node> IMMUTABLE_PREDICATE = new Predicate<Node>() {\n+    @Override\n+    public boolean apply(Node n) {\n+      return isImmutableValue(n);\n+    }\n+  };\n+\n+  static boolean isImmutableResult(Node n) {\n+    return allResultsMatch(n, IMMUTABLE_PREDICATE);\n+  }\n+\n   /**\n    * Apply the supplied predicate against\n    * all possible result Nodes of the expression.\n--- a/test/com/google/javascript/jscomp/NameAnalyzerTest.java\n+++ b/test/com/google/javascript/jscomp/NameAnalyzerTest.java\n     return 1;\n   }\n \n-  public void testRemoveVarDeclartion1() {\n+  public void testRemoveVarDeclaration1() {\n     test(\"var foo = 3;\", \"\");\n   }\n \n-  public void testRemoveVarDeclartion2() {\n+  public void testRemoveVarDeclaration2() {\n     test(\"var foo = 3, bar = 4; externfoo = foo;\",\n          \"var foo = 3; externfoo = foo;\");\n   }\n \n-  public void testRemoveVarDeclartion3() {\n+  public void testRemoveVarDeclaration3() {\n     test(\"var a = f(), b = 1, c = 2; b; c\", \"f();var b = 1, c = 2; b; c\");\n   }\n \n-  public void testRemoveVarDeclartion4() {\n+  public void testRemoveVarDeclaration4() {\n     test(\"var a = 0, b = f(), c = 2; a; c\", \"var a = 0;f();var c = 2; a; c\");\n   }\n \n-  public void testRemoveVarDeclartion5() {\n+  public void testRemoveVarDeclaration5() {\n     test(\"var a = 0, b = 1, c = f(); a; b\", \"var a = 0, b = 1; f(); a; b\");\n   }\n \n-  public void testRemoveVarDeclartion6() {\n+  public void testRemoveVarDeclaration6() {\n     test(\"var a = 0, b = a = 1; a\", \"var a = 0; a = 1; a\");\n   }\n \n-  public void testRemoveVarDeclartion7() {\n+  public void testRemoveVarDeclaration7() {\n     test(\"var a = 0, b = a = 1\", \"\");\n   }\n \n-  public void testRemoveVarDeclartion8() {\n+  public void testRemoveVarDeclaration8() {\n     test(\"var a;var b = 0, c = a = b = 1\", \"\");\n   }\n \n-  public void testRemoveFunction() {\n+\n+  public void testRemoveDeclaration1() {\n+    test(\"var a;var b = 0, c = a = b = 1\", \"\");\n+  }\n+\n+  public void testRemoveDeclaration2() {\n+    test(\"var a,b,c; c = a = b = 1\", \"\");\n+  }\n+\n+  public void testRemoveDeclaration3() {\n+    test(\"var a,b,c; c = a = b = {}; a.x = 1;\", \"\");\n+  }\n+\n+  public void testRemoveDeclaration4() {\n+    testSame(\"var a,b,c; c = a = b = {}; a.x = 1;alert(c.x);\");\n+  }\n+\n+  public void testRemoveDeclaration5() {\n+    test(\"var a,b,c; c = a = b = null; use(b)\", \"var b;b=null;use(b)\");\n+  }\n+\n+  public void testRemoveDeclaration6() {\n+    test(\"var a,b,c; c = a = b = 'str';use(b)\", \"var b;b='str';use(b)\");\n+  }\n+\n+  public void testRemoveDeclaration7() {\n+    test(\"var a,b,c; c = a = b = true;use(b)\", \"var b;b=true;use(b)\");\n+  }\n+\n+  public void testRemoveFunction1() {\n+    test(\"var foo = function(){};\", \"\");\n+  }\n+\n+  public void testRemoveFunction2() {\n+    test(\"var foo; foo = function(){};\", \"\");\n+  }\n+\n+  public void testRemoveFunction3() {\n     test(\"var foo = {}; foo.bar = function() {};\", \"\");\n+  }\n+\n+  public void testRemoveFunction4() {\n+    test(\"var a = {}; a.b = {}; a.b.c = function() {};\", \"\");\n   }\n \n   public void testReferredToByWindow() {\n     test(\"var f = function (){f()}\", \"\");\n   }\n \n+  public void testRemoveRecursiveFunction2a() {\n+    test(\"var f = function g(){g()}\", \"\");\n+  }\n+\n   public void testRemoveRecursiveFunction3() {\n     test(\"var f;f = function (){f()}\", \"\");\n   }\n \n   public void testRemoveRecursiveFunction4() {\n-    // TODO(user) bug?  not removed if name definition doesn't exist.\n+    // don't removed if name definition doesn't exist.\n     testSame(\"f = function (){f()}\");\n   }\n \n          \"var e = false;if(e);\");\n   }\n \n+  public void testIf4a() {\n+    // TODO(johnlenz): fix this.\n+    testSame(\"var e = [], f;if(f=e);f[0] = 1;\");\n+  }\n+\n+  public void testIf4b() {\n+    // TODO(johnlenz): fix this.\n+    test(\"var e = [], f;if(e=f);f[0] = 1;\",\n+         \"var f;if(f);f[0] = 1;\");\n+  }\n+\n+  public void testIf4c() {\n+    test(\"var e = [], f;if(f=e);e[0] = 1;\",\n+         \"var e = [];if(e);e[0] = 1;\");\n+  }\n+\n   public void testIf5() {\n     test(\"var e = false, f;var foo = {};if(f = e + 1)foo.bar=function(){};\",\n          \"var e = false;if(e + 1);\");\n   }\n \n   public void testSetterInForIn3() {\n-    // TODO(user) Fix issue similar to b/2316773: bar should be preserved\n-    // but isn't due to missing references between e and foo.a\n-    test(\"var foo = {}; var bar; for(e in bar = foo.a); bar.b = 3\",\n-         \"var foo = {}; for(e in foo.a);\");\n+    testSame(\"var foo = {}; var bar; for(e in bar = foo.a); bar.b = 3\");\n   }\n \n   public void testSetterInForIn4() {\n-    // TODO(user) Fix issue similar to b/2316773: bar should be preserved\n-    // but isn't due to missing references between e and foo.a\n-    test(\"var foo = {}; var bar; for (e in bar = foo.a); bar.b = 3; foo.a\",\n-         \"var foo = {}; for (e in foo.a); foo.a\");\n+    testSame(\"var foo = {}; var bar; for (e in bar = foo.a); bar.b = 3; foo.a\");\n   }\n \n   public void testSetterInForIn5() {\n     testSame(\"var x = 0; x += 3; x *= 5;\");\n   }\n \n-  public void testNestedAssigns() {\n+  public void testNestedAssigns1() {\n     test(\"var x = 0; var y = x = 3; window.alert(y);\",\n          \"var y = 3; window.alert(y);\");\n+  }\n+\n+  public void testNestedAssigns2() {\n+    testSame(\"var x = 0; var y = x = {}; x.b = 3; window.alert(y);\");\n   }\n \n   public void testComplexNestedAssigns1() {\n \n   public void testConditionallyDefinedFunction2() {\n     testSame(\"var g; 1 || (externfoo.x = function() { g; })\");\n+  }\n+\n+  public void testConditionallyDefinedFunction3() {\n+      testSame(\"var a = {};\" +\n+           \"rand() % 2 || (a.f = function() { externfoo = 1; } || alert());\");\n   }\n \n   public void testGetElemOnThis() {\n         \"\");\n   }\n \n+  public void testAssignWithHook2a() {\n+    test(\"function Foo(){} var foo = null;\" +\n+        \"var f; f = window.a ? \" +\n+        \"    function () {return new Foo()} : function () {return foo};\",\n+        \"\");\n+  }\n+\n   public void testAssignWithHook3() {\n     testSame(\"function Foo(){} var foo = null; var f = {};\" +\n         \"f.b = window.a ? \" +\n         \"f.b = window.a ? function () {return new Foo()} :\" +\n         \"    window.b ? function () {return foo} :\" +\n         \"    function() { return Foo };\",\n+        \"\");\n+  }\n+\n+  public void testAssignWithHook7() {\n+    testSame(\"function Foo(){} var foo = null;\" +\n+        \"var f = window.a ? new Foo() : foo;\" +\n+        \"f()\");\n+  }\n+\n+  public void testAssignWithHook8() {\n+    test(\"function Foo(){} var foo = null;\" +\n+        \"var f = window.a ? new Foo() : foo;\",\n+        \"function Foo(){}\" +\n+        \"window.a && new Foo()\");\n+  }\n+\n+  public void testAssignWithHook9() {\n+    test(\"function Foo(){} var foo = null; var f = {};\" +\n+        \"f.b = window.a ? new Foo() : foo;\",\n+        \"function Foo(){} window.a && new Foo()\");\n+  }\n+\n+  public void testAssign1() {\n+    test(\"function Foo(){} var foo = null; var f = {};\" +\n+        \"f.b = window.a;\",\n+        \"\");\n+  }\n+\n+  public void testAssign2() {\n+    test(\"function Foo(){} var foo = null; var f = {};\" +\n+        \"f.b = window;\",\n+        \"\");\n+  }\n+\n+  public void testAssign3() {\n+    test(\"var f = {};\" +\n+        \"f.b = window;\",\n+        \"\");\n+  }\n+\n+  public void testAssign4() {\n+    test(\"function Foo(){} var foo = null; var f = {};\" +\n+        \"f.b = new Foo();\",\n+        \"function Foo(){} new Foo()\");\n+  }\n+\n+  public void testAssign5() {\n+    test(\"function Foo(){} var foo = null; var f = {};\" +\n+        \"f.b = foo;\",\n         \"\");\n   }\n \n         \"this.x = Foo.getInstance();\");\n   }\n \n-  // TODO(user): Make NameAnalyzer handle this. The OR subexpressions may\n-  // modify global state.\n-  // public void testConditionallyDefinedFunction3() {\n-  //    test(\"var a = {};\" +\n-  //         \"rand() % 2 || (a.f = function() { externfoo = 1; } || alert());\",\n-  //         \"rand() % 2 || function() { externfoo = 1; } || alert();\");\n-  // }\n+\n \n   public void testNoRemoveWindowPropertyAlias1() {\n      testSame(\n   public void testNoRemoveWindowPropertyAlias3() {\n     testSame(\n         \"var self_ = window;\\n\" +\n+        \"self_['qs'] = function() {};\");\n+  }\n+\n+  public void testNoRemoveWindowPropertyAlias4() {\n+    // TODO(johnlenz): fix this. \"self_\" should remain.\n+    test(\n+        \"var self_ = window['gbar'] || {};\\n\" +\n+        \"self_.qs = function() {};\",\n+        \"\");\n+ }\n+\n+  public void testNoRemoveWindowPropertyAlias4a() {\n+    // TODO(johnlenz): fix this. \"self_\" should remain.\n+    test(\n+        \"var self_; self_ = window.gbar || {};\\n\" +\n+        \"self_.qs = function() {};\",\n+        \"\");\n+ }\n+\n+  public void testNoRemoveWindowPropertyAlias5() {\n+    // TODO(johnlenz): fix this. \"self_\" should remain.\n+    test(\n+        \"var self_ = window || {};\\n\" +\n+        \"self_['qs'] = function() {};\",\n+        \"\");\n+  }\n+\n+  public void testNoRemoveWindowPropertyAlias5a() {\n+    // TODO(johnlenz): fix this.\n+    test(\n+        \"var self_; self_ = window || {};\\n\" +\n+        \"self_['qs'] = function() {};\",\n+        \"\");\n+  }\n+\n+  public void testNoRemoveWindowPropertyAlias6() {\n+    testSame(\n+        \"var self_ = (window.gbar = window.gbar || {});\\n\" +\n+        \"self_.qs = function() {};\");\n+  }\n+\n+  public void testNoRemoveWindowPropertyAlias6a() {\n+    testSame(\n+        \"var self_; self_ = (window.gbar = window.gbar || {});\\n\" +\n+        \"self_.qs = function() {};\");\n+  }\n+\n+  public void testNoRemoveWindowPropertyAlias7() {\n+    testSame(\n+        \"var self_ = (window = window || {});\\n\" +\n+        \"self_['qs'] = function() {};\");\n+  }\n+\n+  public void testNoRemoveWindowPropertyAlias7a() {\n+    testSame(\n+        \"var self_; self_ = (window = window || {});\\n\" +\n         \"self_['qs'] = function() {};\");\n   }\n \n         \"\");\n   }\n \n+  public void testIssue838a() {\n+    testSame(\"var z = window['z'] || (window['z'] = {});\\n\" +\n+         \"z['hello'] = 'Hello';\\n\" +\n+         \"z['world'] = 'World';\");\n+  }\n+\n+  public void testIssue838b() {\n+    testSame(\n+         \"var z;\" +\n+         \"window['z'] = z || (z = {});\\n\" +\n+         \"z['hello'] = 'Hello';\\n\" +\n+         \"z['world'] = 'World';\");\n+  }\n+\n+\n+  public void testIssue874a() {\n+    testSame(\n+        \"var a = a || {};\\n\" +\n+        \"var b = a;\\n\" +\n+        \"b.View = b.View || {}\\n\" +\n+        \"var c = b.View;\\n\" +\n+        \"c.Editor = function f(d, e) {\\n\" +\n+        \"  return d + e\\n\" +\n+        \"};\\n\" +\n+        \"window.ImageEditor.View.Editor = a.View.Editor;\");\n+  }\n+\n+  public void testIssue874b() {\n+    testSame(\n+        \"var b;\\n\" +\n+        \"var c = b = {};\\n\" +\n+        \"c.Editor = function f(d, e) {\\n\" +\n+        \"  return d + e\\n\" +\n+        \"};\\n\" +\n+        \"window['Editor'] = b.Editor;\");\n+  }\n+\n+  public void testIssue874c() {\n+    testSame(\n+        \"var b, c;\\n\" +\n+        \"c = b = {};\\n\" +\n+        \"c.Editor = function f(d, e) {\\n\" +\n+        \"  return d + e\\n\" +\n+        \"};\\n\" +\n+        \"window['Editor'] = b.Editor;\");\n+  }\n+\n+  public void testIssue874d() {\n+    testSame(\n+        \"var b = {}, c;\\n\" +\n+        \"c = b;\\n\" +\n+        \"c.Editor = function f(d, e) {\\n\" +\n+        \"  return d + e\\n\" +\n+        \"};\\n\" +\n+        \"window['Editor'] = b.Editor;\");\n+  }\n+\n+  public void testIssue874e() {\n+    testSame(\n+        \"var a;\\n\" +\n+        \"var b = a || (a = {});\\n\" +\n+        \"var c = b.View || (b.View = {});\\n\" +\n+        \"c.Editor = function f(d, e) {\\n\" +\n+        \"  return d + e\\n\" +\n+        \"};\\n\" +\n+        \"window.ImageEditor.View.Editor = a.View.Editor;\");\n+  }\n+\n+  public void testBug6575051() {\n+    testSame(\n+        \"var hackhack = window['__o_o_o__'] = window['__o_o_o__'] || {};\\n\" +\n+        \"window['__o_o_o__']['va'] = 1;\\n\" +\n+        \"hackhack['Vb'] = 1;\");\n+  }\n \n   @Override\n   protected CompilerPass getProcessor(Compiler compiler) {", "timestamp": 1357163491, "metainfo": ""}