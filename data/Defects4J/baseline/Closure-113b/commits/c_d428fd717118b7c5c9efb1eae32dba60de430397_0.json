{"sha": "d428fd717118b7c5c9efb1eae32dba60de430397", "log": "Add a pass that records variable visibility for later query. This will be used for the visibility-based side effects analysis.  R=acleung DELTA=409  (409 added, 0 deleted, 0 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=89002   ", "commit": "\n--- a/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\n+++ b/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\n     NodeTraversal.traverse(compiler, root, this);\n   }\n \n+  /**\n+   * Gets the variables that were referenced in this callback.\n+   */\n+  public Set<Var> getReferencedVariables() {\n+    return referenceMap.keySet();\n+  }\n+  \n   /**\n    * Gets the reference collection for the given variable.\n    */\n--- /dev/null\n+++ b/src/com/google/javascript/jscomp/VariableVisibilityAnalysis.java\n+/*\n+ * Copyright 2010 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.Maps;\n+import com.google.javascript.jscomp.ReferenceCollectingCallback.ReferenceCollection;\n+import com.google.javascript.jscomp.Scope.Var;\n+import com.google.javascript.rhino.Node;\n+import com.google.javascript.rhino.Token;\n+\n+import java.util.Map;\n+\n+/**\n+ * An analysis pass that determines the visibility of variables -- that is,\n+ * whether a variable is truly local, a local captured by an inner scope, a\n+ * parameter, or a global variable.\n+ * \n+ * SideEffectsAnalysis uses this class to partition a potentially infinite\n+ * number of concrete storage locations into a (small) finite number of\n+ * abstract storage locations based on a variable's storage visibility.\n+ * \n+ * @author dcc@google.com (Devin Coughlin)\n+ */\n+public class VariableVisibilityAnalysis implements CompilerPass {\n+\n+  enum VariableVisibility {\n+    \n+    /** Local variable, not captured by closure */\n+    LOCAL,\n+    \n+    /** Local variable captured by a closure */\n+    CAPTURED_LOCAL,\n+    \n+    /** \n+     * Formal parameter declaration variable\n+     * \n+     * Parameters are different than local variables because they can be\n+     * aliased by elements of the arguments object.\n+     */\n+    PARAMETER,\n+    \n+    /** A global variable */\n+    GLOBAL\n+  }\n+  \n+  private AbstractCompiler compiler;\n+  \n+  /**\n+   * Maps the declaring name node for a variable to that variable's\n+   * visibility.\n+   */\n+  private Map<Node, VariableVisibility> visibilityByDeclaringNameNode;\n+  \n+  public VariableVisibilityAnalysis(AbstractCompiler compiler) {\n+    this.compiler = compiler;\n+   \n+    visibilityByDeclaringNameNode = Maps.newHashMap();\n+  }\n+  \n+  /**\n+   * Returns the visibility of of a variable, given that variable's declaring\n+   * name node.\n+   * \n+   * The name node's parent must be one of:\n+   * <pre>\n+   *    Token.VAR (for a variable declaration)\n+   *    Token.FUNCTION (for a function declaration)\n+   *    Token.LP (for a function formal parameter)\n+   * </pre> \n+   * \n+   * The returned visibility will be one of:\n+   * <pre>\n+   *    LOCAL_VARIABLE : the variable is a local variable used only in its\n+   *        declared scope\n+   *    CAPTURED_LOCAL_VARIABLE : A local variable that is used in a capturing\n+   *        closure\n+   *     PARAMETER_VARIABLE : the variable is a formal parameter\n+   *     GLOBAL_VARIABLE : the variable is declared in the global scope\n+   *  </pre>  \n+   *    \n+   * @param declaringNameNode The name node for a declaration.\n+   */\n+  public VariableVisibility getVariableVisibility(Node declaringNameNode) {\n+    Node parent = declaringNameNode.getParent();\n+    \n+    Preconditions.checkArgument(NodeUtil.isVar(parent)\n+        || NodeUtil.isFunction(parent)\n+        || parent.getType() == Token.LP);\n+    \n+    return visibilityByDeclaringNameNode.get(declaringNameNode);\n+  }\n+ \n+  /**\n+   * Determines the visibility class for each variable in root.\n+   */\n+  @Override\n+  public void process(Node externs, Node root) {\n+    ReferenceCollectingCallback callback = \n+      new ReferenceCollectingCallback(compiler, \n+          ReferenceCollectingCallback.DO_NOTHING_BEHAVIOR);\n+    \n+    NodeTraversal.traverse(compiler, root, callback);\n+    \n+    for (Var variable : callback.getReferencedVariables()) {\n+      ReferenceCollection referenceCollection =\n+          callback.getReferenceCollection(variable);\n+      \n+      VariableVisibility visibility;\n+      \n+      if (variableIsParameter(variable)) {\n+        visibility = VariableVisibility.PARAMETER;     \n+      } else if (variable.isLocal()) {\n+        if (referenceCollection.isEscaped()) {\n+          visibility = VariableVisibility.CAPTURED_LOCAL;        \n+        } else {\n+          visibility = VariableVisibility.LOCAL;          \n+        }\n+      } else if (variable.isGlobal()) {\n+        visibility = VariableVisibility.GLOBAL;\n+      } else {\n+        throw new IllegalStateException(\"Un-handled variable visibility for \" +\n+            variable);\n+      }\n+      \n+      visibilityByDeclaringNameNode.put(variable.getNameNode(), visibility);\n+    }   \n+  }\n+  \n+  /**\n+   * Returns true if the variable is a formal parameter.\n+   */\n+  private static boolean variableIsParameter(Var variable) {\n+    Node variableParent = variable.getParentNode();\n+    \n+    return variableParent != null && variableParent.getType() == Token.LP;\n+  }\n+}\n--- /dev/null\n+++ b/test/com/google/javascript/jscomp/VariableVisibilityAnalysisTest.java\n+/*\n+ * Copyright 2010 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n+import com.google.javascript.jscomp.VariableVisibilityAnalysis.VariableVisibility;\n+import com.google.javascript.rhino.Node;\n+import com.google.javascript.rhino.Token;\n+\n+/**\n+ * Tests of {@link VariableVisibilityAnalysis}.\n+ * \n+ * @author dcc@google.com (Devin Coughlin)\n+ */\n+public class VariableVisibilityAnalysisTest extends CompilerTestCase {\n+\n+  private Compiler lastCompiler;\n+  private VariableVisibilityAnalysis lastAnalysis;\n+  \n+  @Override\n+  protected CompilerPass getProcessor(Compiler compiler) {\n+    lastAnalysis = new VariableVisibilityAnalysis(compiler);\n+    lastCompiler = compiler;\n+    \n+    return lastAnalysis;\n+  }\n+  \n+  public void testCapturedVariables() {\n+    String source = \n+        \"global:var global;\\n\" +\n+        \"function Outer() {\\n\" +\n+        \"  captured:var captured;\\n\" +\n+        \"  notcaptured:var notCaptured;\\n\" +\n+        \"  function Inner() {\\n\" +\n+        \"    alert(captured);\" +\n+        \"   }\\n\" +\n+        \"}\\n\";\n+    \n+    analyze(source);\n+    \n+    assertIsCapturedLocal(\"captured\");\n+    assertIsUncapturedLocal(\"notcaptured\");\n+  }\n+  \n+  public void testGlobals() {\n+    String source = \n+      \"global:var global;\";\n+    \n+    analyze(source);\n+    \n+    assertIsGlobal(\"global\"); \n+  }\n+  \n+  public void testParameters() {\n+    String source = \n+      \"function A(a,b,c) {\\n\" +\n+      \"}\\n\";\n+\n+    analyze(source);\n+    \n+    assertIsParameter(\"a\");\n+    assertIsParameter(\"b\");\n+    assertIsParameter(\"c\");\n+  }\n+  \n+  public void testFunctions() {\n+    String source =\n+        \"function global() {\\n\" +\n+        \"  function inner() {\\n\" +\n+        \"  }\\n\" +\n+        \"  function innerCaptured() {\\n\" +\n+        \"    (function(){innerCaptured()})()\\n\" +\n+        \"  }\\n\" +\n+        \"}\\n\";\n+    \n+    analyze(source);\n+    \n+    assertFunctionHasVisibility(\"global\",\n+        VariableVisibility.GLOBAL);\n+    \n+    assertFunctionHasVisibility(\"inner\",\n+        VariableVisibility.LOCAL);\n+    \n+    assertFunctionHasVisibility(\"innerCaptured\",\n+        VariableVisibility.CAPTURED_LOCAL);\n+  }\n+  \n+  private void assertFunctionHasVisibility(String functionName,\n+      VariableVisibility visibility) {\n+    \n+    Node functionNode = searchForFunction(functionName);\n+    assertNotNull(functionNode);\n+    \n+    Node nameNode = functionNode.getFirstChild();\n+    assertEquals(visibility, lastAnalysis.getVariableVisibility(nameNode));  \n+  }\n+  \n+  private void assertLabeledVariableHasVisibility(String label,\n+      VariableVisibility visibility) {\n+    Node labeledVariable = searchLabel(label);\n+    \n+    Preconditions.checkState(NodeUtil.isVar(labeledVariable));\n+    \n+    // VAR\n+    //   NAME \n+    Node nameNode = labeledVariable.getFirstChild();\n+    \n+    assertEquals(visibility, lastAnalysis.getVariableVisibility(nameNode));  \n+  }\n+  \n+  private void assertIsCapturedLocal(String label) {\n+    assertLabeledVariableHasVisibility(label, \n+        VariableVisibility.CAPTURED_LOCAL); \n+  }\n+  \n+  private void assertIsUncapturedLocal(String label) {\n+    assertLabeledVariableHasVisibility(label, \n+        VariableVisibility.LOCAL); \n+  }\n+  \n+  private void assertIsGlobal(String label) {\n+    assertLabeledVariableHasVisibility(label, \n+        VariableVisibility.GLOBAL); \n+  }\n+  \n+  private void assertIsParameter(String parameterName) {\n+    Node parameterNode = searchForParameter(parameterName);\n+    \n+    assertNotNull(parameterNode);\n+    \n+    assertEquals(VariableVisibility.PARAMETER,\n+        lastAnalysis.getVariableVisibility(parameterNode));\n+  }\n+  \n+  private VariableVisibilityAnalysis analyze(String src) {\n+    testSame(src);\n+    \n+    return lastAnalysis;\n+  }\n+  \n+  /*\n+   * Finds a parameter NAME node with the given name in the source AST.\n+   * \n+   * Behavior is undefined if there are multiple parameters with\n+   * parameterName.\n+   */\n+  private Node searchForParameter(final String parameterName) {\n+    Preconditions.checkArgument(parameterName != null);\n+    \n+    final Node[] foundNode = new Node[1];\n+    \n+    AbstractPostOrderCallback findParameter = new AbstractPostOrderCallback() {\n+      \n+      @Override\n+      public void visit(NodeTraversal t, Node n, Node parent) {\n+        if (n.getParent().getType() == Token.LP\n+            && parameterName.equals(n.getString())) {\n+          \n+          foundNode[0] = n;\n+        }\n+      }\n+    }; \n+      \n+    new NodeTraversal(lastCompiler, findParameter)\n+        .traverse(lastCompiler.jsRoot);\n+    \n+    return foundNode[0];\n+  }\n+\n+  /*\n+   * Finds a function node with the given name in the source AST.\n+   * \n+   * Behavior is undefined if there are multiple functions with\n+   * parameterName.\n+   */\n+  private Node searchForFunction(final String functionName) {\n+    Preconditions.checkArgument(functionName != null);\n+    \n+    final Node[] foundNode = new Node[1];\n+    \n+    AbstractPostOrderCallback findFunction = new AbstractPostOrderCallback() {\n+      \n+      @Override\n+      public void visit(NodeTraversal t, Node n, Node parent) {\n+        if (NodeUtil.isFunction(n)\n+            && functionName.equals(NodeUtil.getFunctionName(n))) { \n+          foundNode[0] = n;\n+        }\n+      }\n+    }; \n+      \n+    new NodeTraversal(lastCompiler, findFunction)\n+        .traverse(lastCompiler.jsRoot);\n+    \n+    return foundNode[0];\n+  }\n+  \n+  // Shamelessly stolen from NameReferenceGraphConstructionTest\n+  private Node searchLabel(String label) {\n+    LabeledVariableSearcher s = new LabeledVariableSearcher(label);\n+      \n+    new NodeTraversal(lastCompiler, s).traverse(lastCompiler.jsRoot);\n+    assertNotNull(\"Label \" + label + \" should be in the source code\", s.found);\n+    \n+    return s.found;\n+  }\n+  \n+  /**\n+   * Quick traversal to find a given labeled variable in the AST.\n+   * \n+   * Finds the variable for foo in:\n+   * foo: var a = ...\n+   */\n+  private class LabeledVariableSearcher extends AbstractPostOrderCallback {\n+    Node found = null;\n+    final String target;\n+\n+    LabeledVariableSearcher(String target) {\n+      this.target = target;\n+    }\n+    @Override\n+    public void visit(NodeTraversal t, Node n, Node parent) {\n+      if (n.getType() == Token.LABEL &&\n+          target.equals(n.getFirstChild().getString())) {\n+        \n+        // LABEL\n+        //     VAR\n+        //       NAME\n+        \n+        found = n.getLastChild();\n+      }\n+    }\n+  }\n+}", "timestamp": 1280951284, "metainfo": ""}