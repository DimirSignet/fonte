{"sha": "0d98b3ca84c0b6179b71a9de75b0a2fe42d7343f", "log": "Make sure that NameAnalyzer does not remove property assignments done via aliases. (Nick) R=antonio DELTA=417  (399 added, 9 deleted, 9 changed)  put the graph tests in the graph package. (Nick) R=alan DELTA=1422  (753 added, 660 deleted, 9 changed)  Revision created by MOE tool push_codebase. MOE_MIGRATION=qlondb   ", "commit": "\n--- a/src/com/google/javascript/jscomp/NameAnalyzer.java\n+++ b/src/com/google/javascript/jscomp/NameAnalyzer.java\n package com.google.javascript.jscomp;\n \n import com.google.common.base.Preconditions;\n+import com.google.common.collect.HashMultimap;\n import com.google.common.collect.ImmutableSet;\n import com.google.common.collect.Lists;\n import com.google.common.collect.Maps;\n+import com.google.common.collect.Multimap;\n import com.google.common.collect.Sets;\n import com.google.javascript.jscomp.CodingConvention.SubclassRelationship;\n import com.google.javascript.jscomp.GatherSideEffectSubexpressionsCallback.CopySideEffectSubexpressions;\n import com.google.javascript.jscomp.graph.DiGraph.DiGraphEdge;\n import com.google.javascript.jscomp.graph.FixedPointGraphTraversal;\n import com.google.javascript.jscomp.graph.FixedPointGraphTraversal.EdgeCallback;\n-\n import com.google.javascript.jscomp.graph.LinkedDirectedGraph;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n import java.util.Iterator;\n import java.util.List;\n import java.util.Map;\n+import java.util.PriorityQueue;\n import java.util.Set;\n \n /**\n   private final List<RefNode> refNodes = Lists.newArrayList();\n \n   /**\n+   * When multiple names in the global scope point to the same object, we\n+   * call them aliases. Store a map from each alias name to the alias set.\n+   */\n+  private final Map<String, AliasSet> aliases = Maps.newHashMap();\n+\n+  /**\n+   * All the aliases in a program form a graph, where each global name is\n+   * a node in the graph, and two names are connected if one directly aliases\n+   * the other.\n+   *\n+   * An {@code AliasSet} represents a connected component in that graph. We do\n+   * not explicitly track the graph--we just track the connected components.\n+   */\n+  private static class AliasSet {\n+    Set<String> names = Sets.newHashSet();\n+\n+    // Every alias set starts with exactly 2 names.\n+    AliasSet(String name1, String name2) {\n+      names.add(name1);\n+      names.add(name2);\n+    }\n+  }\n+\n+  /**\n    * Relationship between the two names.\n    * Currently only two different reference types exists:\n    * goog.inherits class relations and all other references.\n     /** Whether this node is referenced */\n     boolean referenced = false;\n \n+    /** Whether the name has descendants that are written to. */\n+    boolean hasWrittenDescendants = false;\n+\n     /**\n      * Output the node as a string\n      *\n      * Parent node of the name access (ASSIGN, VAR, FUNCTION, or CALL)\n      */\n     Node parent;\n+\n \n     /**\n      * Create a node that refers to a name\n         Node nameNode = n.getFirstChild();\n         NameInformation ns = createNameInformation(t, nameNode, n);\n         if (ns != null) {\n-          recordDepScope(parent, ns);\n+          if (parent.getType() == Token.FOR && !NodeUtil.isForIn(parent)) {\n+            // Patch for assignments that appear in the init,\n+            // condition or iteration part of a FOR loop.  Without\n+            // this change, all 3 of those parts try to claim the for\n+            // loop as their dependency scope.  The last assignment in\n+            // those three fields wins, which can result in incorrect\n+            // reference edges between referenced and assigned variables.\n+            //\n+            // TODO(user) revisit the dependency scope calculation\n+            // logic.\n+            if (parent.getFirstChild().getNext() != n) {\n+              recordDepScope(n, ns);\n+            } else {\n+              recordDepScope(nameNode, ns);\n+            }\n+          } else {\n+            recordDepScope(parent, ns);\n+          }\n         }\n       } else if (NodeUtil.isVarDeclaration(n)) {\n         NameInformation ns = createNameInformation(t, n, parent);\n         NameInformation ns = createNameInformation(t, nameNode, n);\n         if (ns != null) {\n           if (ns.isPrototype) {\n-            JsName name = getName(ns.prototypeClass, false);\n-            if (name != null) {\n-              name.prototypeNames.add(ns.prototypeProperty);\n-              refNodes.add(new PrototypeSetNode(name, n));\n-            }\n+            recordPrototypeSet(ns.prototypeClass, ns.prototypeProperty, n);\n           } else {\n             recordSet(ns.name, nameNode);\n           }\n       JsName jsn = getName(name, true);\n       JsNameRefNode nameRefNode = new JsNameRefNode(jsn, node);\n       refNodes.add(nameRefNode);\n+\n+      // Now, look at all parent names and record that their properties have\n+      // been written to.\n+      if (node.getType() == Token.GETELEM) {\n+        recordWriteOnProperties(name);\n+      } else if (name.indexOf('.') != -1) {\n+        recordWriteOnProperties(name.substring(0, name.lastIndexOf('.')));\n+      }\n+    }\n+\n+    /**\n+     * Records the assignment to a prototype property of a global name,\n+     * if possible.\n+     *\n+     * @param className The name of the class.\n+     * @param prototypeProperty The name of the prototype property.\n+     * @param node The top node representing the name (GETPROP)\n+     */\n+    private void recordPrototypeSet(String className, String prototypeProperty,\n+        Node node) {\n+      JsName name = getName(className, false);\n+      if (name != null) {\n+        name.prototypeNames.add(prototypeProperty);\n+        refNodes.add(new PrototypeSetNode(name, node));\n+        recordWriteOnProperties(className);\n+      }\n+    }\n+\n+    /**\n+     * Record that the properties of this name have been written to.\n+     */\n+    private void recordWriteOnProperties(String parentName) {\n+      do {\n+        JsName parent = getName(parentName, true);\n+        if (parent.hasWrittenDescendants) {\n+          // If we already recorded this name, then all its parents must\n+          // also be recorded. short-circuit this loop.\n+          return;\n+        } else {\n+          parent.hasWrittenDescendants = true;\n+        }\n+\n+        if (parentName.indexOf('.') == -1) {\n+          return;\n+        }\n+        parentName = parentName.substring(0, parentName.lastIndexOf('.'));\n+      } while(true);\n     }\n   }\n \n       }\n \n       if (nameInfo.onlyAffectsClassDef) {\n-        recordReference(nameInfo.name,\n-                        nameInfo.superclass,\n-                        RefType.INHERITANCE);\n+        recordReference(\n+            nameInfo.name, nameInfo.superclass, RefType.INHERITANCE);\n \n         // Make sure that we record a reference to the function that does\n         // the inheritance, so that the inherits() function itself does\n         // not get stripped.\n         String nodeName = n.getQualifiedName();\n         if (nodeName != null) {\n-          recordReference(nameInfo.name,\n-                          nodeName,\n-                          RefType.REGULAR);\n+          recordReference(\n+              nameInfo.name, nodeName, RefType.REGULAR);\n         }\n \n         return;\n           recordReference(WINDOW, name, RefType.REGULAR);\n         }\n       } else if (referring != null) {\n-        recordReference(referringName, name, RefType.REGULAR);\n+        if ((parent.getType() == Token.NAME ||\n+             parent.getType() == Token.ASSIGN) &&\n+            scopes.get(parent) == referring) {\n+          recordAlias(referringName, name);\n+        } else {\n+          RefType depType = referring.onlyAffectsClassDef ?\n+              RefType.INHERITANCE : RefType.REGULAR;\n+          recordReference(referringName, name, depType);\n+        }\n       } else {\n         // No named dependency scope found.  Unfortunately that might\n         // mean that the expression is a child of an anonymous\n         compiler, root, new HoistVariableAndFunctionDeclarations());\n     NodeTraversal.traverse(compiler, root, new FindDeclarationsAndSetters());\n     NodeTraversal.traverse(compiler, root, new FindReferences());\n+\n+    // Create bi-directional references between parent names and their\n+    // descendents. This may create new names.\n     referenceParentNames();\n+\n+    // If we modify the property of an alias, make sure that modification\n+    // gets reflected in the original object.\n+    referenceAliases();\n+\n     calculateReferences();\n \n     if (removeUnreferenced) {\n   }\n \n   /**\n+   * Records an alias of one name to another name.\n+   */\n+  private void recordAlias(String fromName, String toName) {\n+    recordReference(fromName, toName, RefType.REGULAR);\n+\n+    // We need to add an edge to the alias graph. The alias graph is expressed\n+    // implicitly as a set of connected components, called AliasSets.\n+    //\n+    // There are three possibilities:\n+    // 1) Neither name is part of a connected component. Create a new one.\n+    // 2) Exactly one name is part of a connected component. Merge the new\n+    //    name into the component.\n+    // 3) The two names are already part of connected components. Merge\n+    //    those components together.\n+    AliasSet toNameAliasSet = aliases.get(toName);\n+    AliasSet fromNameAliasSet = aliases.get(fromName);\n+    AliasSet resultSet = null;\n+    if (toNameAliasSet == null && fromNameAliasSet == null) {\n+      resultSet = new AliasSet(toName, fromName);\n+    } else if (toNameAliasSet != null && fromNameAliasSet != null) {\n+      resultSet = toNameAliasSet;\n+      resultSet.names.addAll(fromNameAliasSet.names);\n+      for (String name : fromNameAliasSet.names) {\n+        aliases.put(name, resultSet);\n+      }\n+    } else if (toNameAliasSet != null) {\n+      resultSet = toNameAliasSet;\n+      resultSet.names.add(fromName);\n+    } else {\n+      resultSet = fromNameAliasSet;\n+      resultSet.names.add(toName);\n+    }\n+    aliases.put(fromName, resultSet);\n+    aliases.put(toName, resultSet);\n+  }\n+\n+  /**\n    * Records a reference from one name to another name.\n    */\n   private void recordReference(String fromName, String toName,\n                                RefType depType) {\n+    if (fromName.equals(toName)) {\n+      // Don't bother recording self-references.\n+      return;\n+    }\n+\n     JsName from = getName(fromName, true);\n     JsName to = getName(toName, true);\n     referenceGraph.createNode(from);\n     referenceGraph.createNode(to);\n-    if (!referenceGraph.isConnectedInDirection(from, to)) {\n+    if (!referenceGraph.isConnectedInDirection(from, depType, to)) {\n       referenceGraph.connect(from, depType, to);\n     }\n   }\n   }\n \n   /**\n+   * The NameAnalyzer algorithm works best when all objects have a canonical\n+   * name in the global scope. When multiple names in the global scope\n+   * point to the same object, things start to break down.\n+   *\n+   * For example, if we have\n+   * <code>\n+   * var a = {};\n+   * var b = a;\n+   * a.foo = 3;\n+   * alert(b.foo);\n+   * </code>\n+   * then a.foo and b.foo are the same name, even though NameAnalyzer doesn't\n+   * represent them as such.\n+   *\n+   * To handle this case, we look at all the aliases in the program.\n+   * If descendant properties of that alias are assigned, then we create a\n+   * directional reference from the original name to the alias. For example,\n+   * in this case, the assign to {@code a.foo} triggers a reference from\n+   * {@code b} to {@code a}, but NOT from a to b.\n+   */\n+  private void referenceAliases() {\n+    for (Map.Entry<String, AliasSet> entry : aliases.entrySet()) {\n+      JsName name = getName(entry.getKey(), false);\n+      if (name.hasWrittenDescendants) {\n+        for (String alias : entry.getValue().names) {\n+          recordReference(alias, entry.getKey(), RefType.REGULAR);\n+        }\n+      }\n+    }\n+  }\n+\n+  /**\n    * Adds mutual references between all known global names and their parent\n    * names. (e.g. between <code>a.b.c</code> and <code>a.b</code>).\n    */\n--- a/src/com/google/javascript/jscomp/graph/DiGraph.java\n+++ b/src/com/google/javascript/jscomp/graph/DiGraph.java\n \n /**\n  * A generic directed graph.\n- * \n+ *\n *\n  *\n  * @param <N> Value type that the graph node stores.\n    * @param n2 Destination node.\n    */\n   public abstract void disconnectInDirection(N n1, N n2);\n-  \n+\n+  /**\n+   * Checks whether two nodes in the graph are connected via a directed edge.\n+   *\n+   * @param n1 Node 1.\n+   * @param n2 Node 2.\n+   * @return <code>true</code> if the graph contains edge from n1 to n2.\n+   */\n   public abstract boolean isConnectedInDirection(N n1, N n2);\n-  \n+\n+  /**\n+   * Checks whether two nodes in the graph are connected via a directed edge\n+   * with the given value.\n+   *\n+   * @param n1 Node 1.\n+   * @param edgeValue edge value tag\n+   * @param n2 Node 2.\n+   * @return <code>true</code> if the edge exists.\n+   */\n+  public abstract boolean isConnectedInDirection(N n1, E edgeValue, N n2);\n+\n \n   /**\n    * A generic directed graph node.\n     public void setDestination(DiGraphNode<N, E> node);\n   }\n }\n-\n-\n--- a/src/com/google/javascript/jscomp/graph/LinkedDirectedGraph.java\n+++ b/src/com/google/javascript/jscomp/graph/LinkedDirectedGraph.java\n package com.google.javascript.jscomp.graph;\n \n import com.google.common.base.Preconditions;\n+import com.google.common.base.Predicate;\n+import com.google.common.base.Predicates;\n import com.google.common.collect.Lists;\n import com.google.common.collect.Maps;\n \n \n   @Override\n   public boolean isConnectedInDirection(N n1, N n2) {\n+    return isConnectedInDirection(n1, Predicates.<E>alwaysTrue(), n2);\n+  }\n+\n+  @Override\n+  public boolean isConnectedInDirection(N n1, E edgeValue, N n2) {\n+    return isConnectedInDirection(n1, Predicates.equalTo(edgeValue), n2);\n+  }\n+\n+  private boolean isConnectedInDirection(N n1, Predicate<E> edgeMatcher, N n2) {\n     // Verify the nodes.\n     DiGraphNode<N, E> dNode1 = nodes.get(n1);\n     if (dNode1 == null) {\n     }\n \n     for (DiGraphEdge<N, E> outEdge : dNode1.getOutEdges()) {\n-      if (outEdge.getDestination() == dNode2) {\n+      if (outEdge.getDestination() == dNode2 &&\n+          edgeMatcher.apply(outEdge.getValue())) {\n         return true;\n       }\n     }\n--- a/test/com/google/javascript/jscomp/NameAnalyzerTest.java\n+++ b/test/com/google/javascript/jscomp/NameAnalyzerTest.java\n          \"var i = 0; for(i = 1, i , 2; i = 0;);\");\n   }\n \n+  public void testSetterInForStruct9() {\n+    test(\"var Class = function() {}; \" +\n+         \"for (var i = 1; Class.property_ = 0; i++);\",\n+         \"for (var i = 1; 0; i++);\");\n+  }\n+\n+  public void testSetterInForStruct10() {\n+    test(\"var Class = function() {}; \" +\n+         \"for (var i = 1; Class.property_ = 0; i = 2);\",\n+         \"for (; 0;);\");\n+  }\n+\n+  public void testSetterInForStruct11() {\n+    test(\"var Class = function() {}; \" +\n+         \"for (;Class.property_ = 0;);\",\n+         \"for (;0;);\");\n+  }\n+\n+  public void testSetterInForStruct12() {\n+    test(\"var a = 1; var Class = function() {}; \" +\n+         \"for (;Class.property_ = a;);\",\n+         \"var a = 1; for (; a;);\");\n+  }\n+\n+  public void testSetterInForStruct13() {\n+    test(\"var a = 1; var Class = function() {}; \" +\n+         \"for (Class.property_ = a; 0 ;);\",\n+         \"for (; 0;);\");\n+  }\n+\n+  public void testSetterInForStruct14() {\n+    test(\"var a = 1; var Class = function() {}; \" +\n+         \"for (; 0; Class.property_ = a);\",\n+         \"for (; 0;);\");\n+  }\n+\n+  public void testSetterInForStruct15() {\n+    test(\"var Class = function() {}; \" +\n+         \"for (var i = 1; 0; Class.prototype.property_ = 0);\",\n+         \"for (; 0; 0);\");\n+  }\n+\n+  public void testSetterInForStruct16() {\n+    test(\"var Class = function() {}; \" +\n+         \"for (var i = 1; i = 0; Class.prototype.property_ = 0);\",\n+         \"for (; 0; 0);\");\n+  }\n+\n+  public void testSetterInForIn1() {\n+    test(\"var foo = {}; var bar; for(e in bar = foo.a);\",\n+         \"var foo = {}; for(e in foo.a);\");\n+  }\n+\n+  public void testSetterInForIn2() {\n+    testSame(\"var foo = {}; var bar; for(e in bar = foo.a); bar\");\n+  }\n+\n+  public void testSetterInForIn3() {\n+    // TODO(user) Fix issue similar to b/2316773: bar should be preserved\n+    // but isn't due to missing references between e and foo.a\n+    test(\"var foo = {}; var bar; for(e in bar = foo.a); bar.b = 3\",\n+         \"var foo = {}; for(e in foo.a);\");\n+  }\n+\n+  public void testSetterInForIn4() {\n+    // TODO(user) Fix issue similar to b/2316773: bar should be preserved\n+    // but isn't due to missing references between e and foo.a\n+    test(\"var foo = {}; var bar; for (e in bar = foo.a); bar.b = 3; foo.a\",\n+         \"var foo = {}; for (e in foo.a); foo.a\");\n+  }\n+\n+  public void testSetterInForIn5() {\n+    // TODO(user) Fix issue similar to b/2316773: bar should be preserved\n+    // but isn't due to missing references between e and foo.a\n+    test(\"var foo = {}; var bar; for (e in foo.a) { bar = e } bar.b = 3; foo.a\",\n+         \"var foo={};for(e in foo.a);foo.a\");\n+  }\n+\n+  public void testSetterInForIn6() {\n+    testSame(\"var foo = {};for(e in foo);\");\n+  }\n+\n+  public void testSetterInIfPredicate() {\n+    // TODO(user) Make NameAnalyzer smarter so it can remove \"Class\".\n+    testSame(\"var a = 1;\" +\n+             \"var Class = function() {}; \" +\n+             \"if (Class.property_ = a);\");\n+  }\n+\n+  public void testSetterInWhilePredicate() {\n+    // TODO(user) Make NameAnalyzer smarter so it can remove \"Class\".\n+    testSame(\"var a = 1;\" +\n+             \"var Class = function() {}; \" +\n+             \"while (Class.property_ = a);\");\n+  }\n+\n+  public void testSetterInDoWhilePredicate() {\n+    // TODO(user) Make NameAnalyzer smarter so it can remove \"Class\".\n+    testSame(\"var a = 1;\" +\n+             \"var Class = function() {}; \" +\n+             \"do {} while(Class.property_ = a);\");\n+  }\n+\n+  public void testSetterInSwitchInput() {\n+    // TODO(user) Make NameAnalyzer smarter so it can remove \"Class\".\n+    testSame(\"var a = 1;\" +\n+             \"var Class = function() {}; \" +\n+             \"switch (Class.property_ = a) {\" +\n+             \"  default:\" +\n+             \"}\");\n+  }\n+\n   public void testComplexAssigns() {\n     // Complex assigns are not removed by the current pass.\n     testSame(\"var x = 0; x += 3; x *= 5;\");\n     test(\"var a; LBL: a = f()\", \"LBL: f()\");\n   }\n \n+  public void testPreservePropertyMutationsToAlias1() {\n+    // Test for issue b/2316773 - property get case\n+    // Since a is referenced, property mutations via a's alias b must\n+    // be preserved.\n+    testSame(\"var a = {}; var b = a; b.x = 1; a\");\n+  }\n+\n+  public void testPreservePropertyMutationsToAlias2() {\n+    // Test for issue b/2316773 - property get case, don't keep 'c'\n+    test(\"var a = {}; var b = a; var c = a; b.x = 1; a\",\n+         \"var a = {}; var b = a; b.x = 1; a\");\n+  }\n+\n+  public void testPreservePropertyMutationsToAlias3() {\n+    // Test for issue b/2316773 - property get case, chain\n+    testSame(\"var a = {}; var b = a; var c = b; c.x = 1; a\");\n+  }\n+\n+ public void testPreservePropertyMutationsToAlias4() {\n+    // Test for issue b/2316773 - element get case\n+    testSame(\"var a = {}; var b = a; b['x'] = 1; a\");\n+  }\n+\n+  public void testPreservePropertyMutationsToAlias5() {\n+    // From issue b/2316773 description\n+    testSame(\"function testCall(o){}\" +\n+             \"var DATA = {'prop': 'foo','attr': {}};\" +\n+             \"var SUBDATA = DATA['attr'];\" +\n+             \"SUBDATA['subprop'] = 'bar';\" +\n+             \"testCall(DATA);\");\n+  }\n+\n+  public void testPreservePropertyMutationsToAlias6() {\n+    // Longer GETELEM chain\n+    testSame(\"function testCall(o){}\" +\n+             \"var DATA = {'prop': 'foo','attr': {}};\" +\n+             \"var SUBDATA = DATA['attr'];\" +\n+             \"var SUBSUBDATA = SUBDATA['subprop'];\" +\n+             \"SUBSUBDATA['subsubprop'] = 'bar';\" +\n+             \"testCall(DATA);\");\n+  }\n+\n+  public void testPreservePropertyMutationsToAlias7() {\n+    // Make sure that the base class does not depend on the derived class.\n+    test(\"var a = {}; var b = {}; b.x = 0;\" +\n+         \"var goog = {}; goog.inherits(b, a); a\",\n+         \"var a = {}; a\");\n+  }\n+\n+  public void testPreservePropertyMutationsToAlias8() {\n+    // Make sure that the derived classes don't end up depending on each other.\n+    test(\"var a = {};\" +\n+         \"var b = {}; b.x = 0;\" +\n+         \"var c = {}; c.y = 0;\" +\n+         \"var goog = {}; goog.inherits(b, a); goog.inherits(c, a); c\",\n+         \"var a = {}; var c = {}; c.y = 0;\" +\n+         \"var goog = {}; goog.inherits(c, a); c\");\n+  }\n+\n+  public void testPreservePropertyMutationsToAlias9() {\n+    testSame(\"var a = {b: {}};\" +\n+         \"var c = a.b; c.d = 3;\" +\n+         \"a.d = 3; a.d;\");\n+  }\n+\n+  public void testRemoveAlias() {\n+    test(\"var a = {b: {}};\" +\n+         \"var c = a.b;\" +\n+         \"a.d = 3; a.d;\",\n+         \"var a = {b: {}}; a.d = 3; a.d;\");\n+  }\n+\n   // TODO(user): Make NameAnalyzer handle this. The OR subexpressions may\n   // modify global state.\n   // public void testConditionallyDefinedFunction2() {\n--- /dev/null\n+++ b/test/com/google/javascript/jscomp/graph/GraphColoringTest.java\n+/*\n+ * Copyright 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp.graph;\n+\n+import com.google.javascript.jscomp.graph.Graph;\n+import com.google.javascript.jscomp.graph.GraphColoring;\n+import com.google.javascript.jscomp.graph.LinkedUndirectedGraph;\n+import com.google.javascript.jscomp.graph.GraphNode;\n+import com.google.javascript.jscomp.graph.Graph.GraphEdge;\n+import com.google.javascript.jscomp.graph.GraphColoring.Color;\n+import com.google.javascript.jscomp.graph.GraphColoring.GreedyGraphColoring;\n+\n+import junit.framework.TestCase;\n+\n+import java.util.Comparator;\n+\n+/**\n+ * Tests for {@link GraphColoring}.\n+ *\n+*\n+ */\n+public class GraphColoringTest extends TestCase {\n+\n+  public void testNoEdge() {\n+    Graph<String, String> graph = new LinkedUndirectedGraph<String, String>();\n+    for (int i = 0; i < 5; i++) {\n+      graph.createNode(\"Node \" + i);\n+      // All node with same color.\n+      GraphColoring<String, String> coloring =\n+          new GreedyGraphColoring<String, String>(graph);\n+      assertEquals(1, coloring.color());\n+      validateColoring(graph);\n+      for (int j = 0; j < i; j++) {\n+        assertEquals(\"Node 0\", coloring.getPartitionSuperNode(\"Node 0\"));\n+      }\n+    }\n+  }\n+\n+  public void testTwoNodesConnected() {\n+    Graph<String, String> graph = new LinkedUndirectedGraph<String, String>();\n+    graph.createNode(\"A\");\n+    graph.createNode(\"B\");\n+    graph.connect(\"A\", \"--\", \"B\");\n+    GraphColoring<String, String> coloring =\n+        new GreedyGraphColoring<String, String>(graph);\n+    assertEquals(2, coloring.color());\n+    validateColoring(graph);\n+    assertEquals(\"A\", coloring.getPartitionSuperNode(\"A\"));\n+    assertEquals(\"B\", coloring.getPartitionSuperNode(\"B\"));\n+  }\n+\n+  public void testGreedy() {\n+    Graph<String, String> graph = new LinkedUndirectedGraph<String, String>();\n+    graph.createNode(\"A\");\n+    graph.createNode(\"B\");\n+    graph.createNode(\"C\");\n+    graph.createNode(\"D\");\n+    graph.connect(\"A\", \"--\", \"C\");\n+    graph.connect(\"B\", \"--\", \"C\");\n+    graph.connect(\"B\", \"--\", \"D\");\n+    GraphColoring<String, String> coloring =\n+        new GreedyGraphColoring<String, String>(graph);\n+    assertEquals(2, coloring.color());\n+    validateColoring(graph);\n+    assertEquals(\"A\", coloring.getPartitionSuperNode(\"A\"));\n+    assertEquals(\"A\", coloring.getPartitionSuperNode(\"B\"));\n+    assertEquals(\"C\", coloring.getPartitionSuperNode(\"C\"));\n+  }\n+\n+  public void testFullyConnected() {\n+    final int count = 100;\n+    Graph<String, String> graph = new LinkedUndirectedGraph<String, String>();\n+    for (int i = 0; i < count; i++) {\n+      graph.createNode(\"Node \" + i);\n+      for (int j = 0; j < count; j++) {\n+        graph.createNode(\"Node \" + j);\n+        if (i != j) {\n+          graph.connect(\"Node \" + i, null, \"Node \" + j);\n+        }\n+      }\n+    }\n+    GraphColoring<String, String> coloring =\n+        new GreedyGraphColoring<String, String>(graph);\n+    assertEquals(count, coloring.color());\n+    validateColoring(graph);\n+    for (int i = 0; i < count; i++) {\n+      assertEquals(\"Node \" + i, coloring.getPartitionSuperNode(\"Node \" + i));\n+    }\n+  }\n+\n+  public void testAllConnectedToOneNode() {\n+    final int count = 10;\n+    Graph<String, String> graph = new LinkedUndirectedGraph<String, String>();\n+    graph.createNode(\"Center\");\n+    for (int i = 0; i < count; i++) {\n+      graph.createNode(\"Node \" + i);\n+      graph.connect(\"Center\", null, \"Node \" + i);\n+    }\n+    GraphColoring<String, String> coloring =\n+        new GreedyGraphColoring<String, String>(graph);\n+    assertEquals(2, coloring.color());\n+    validateColoring(graph);\n+    assertEquals(\"Center\", coloring.getPartitionSuperNode(\"Center\"));\n+    for (int i = 0; i < count; i++) {\n+      assertEquals(\"Node 0\", coloring.getPartitionSuperNode(\"Node \" + i));\n+    }\n+  }\n+\n+  public void testTwoFullyConnected() {\n+    final int count = 100;\n+    // A graph with two disconnected disjunct cliques.\n+    Graph<String, String> graph = new LinkedUndirectedGraph<String, String>();\n+    for (int i = 0; i < count; i++) {\n+      graph.createNode(\"Node Left \" + i);\n+      graph.createNode(\"Node Right \" + i);\n+      for (int j = 0; j < count; j++) {\n+        graph.createNode(\"Node Left \" + j);\n+        graph.createNode(\"Node Right \" + j);\n+        if (i != j) {\n+          graph.connect(\"Node Left \" + i, null, \"Node Left \" + j);\n+          graph.connect(\"Node Right \" + i, null, \"Node Right \" + j);\n+        }\n+      }\n+    }\n+    assertEquals(count, new GreedyGraphColoring<String, String>(graph).color());\n+    validateColoring(graph);\n+\n+    // Connect the two cliques.\n+    for (int i = 0; i < count; i++) {\n+      graph.connect(\"Node Left \" + i, null, \"Node Right \" + i);\n+    }\n+    // Think of two exactly same graph with the same coloring side by side.\n+    // If we circularly shift the colors of one of the graph by 1, we can\n+    // connect the isomorphic nodes and still have a valid coloring in the\n+    // resulting graph.\n+    assertEquals(count, new GreedyGraphColoring<String, String>(graph).color());\n+    validateColoring(graph);\n+  }\n+\n+  public void testDeterministic() {\n+    // A pentagon.\n+    Graph<String, String> graph = new LinkedUndirectedGraph<String, String>();\n+    graph.createNode(\"A\");\n+    graph.createNode(\"B\");\n+    graph.createNode(\"C\");\n+    graph.createNode(\"D\");\n+    graph.createNode(\"E\");\n+    graph.connect(\"A\", \"-->\", \"B\");\n+    graph.connect(\"B\", \"-->\", \"C\");\n+    graph.connect(\"C\", \"-->\", \"D\");\n+    graph.connect(\"D\", \"-->\", \"E\");\n+    graph.connect(\"E\", \"-->\", \"A\");\n+\n+    Comparator<String> lexicographic = new Comparator<String>() {\n+      public int compare(String o1, String o2) {\n+        return o1.toString().compareTo(o2.toString());\n+      }\n+    };\n+    GraphColoring<String, String> coloring =\n+        new GreedyGraphColoring<String, String>(graph, lexicographic);\n+    assertEquals(3, coloring.color());\n+    validateColoring(graph);\n+    assertEquals(\"A\", coloring.getPartitionSuperNode(\"A\"));\n+    assertEquals(\"A\", coloring.getPartitionSuperNode(\"C\"));\n+\n+    Comparator<String> biasD = new Comparator<String>() {\n+      public int compare(String o1, String o2) {\n+        if (o1.equals(\"D\")) {\n+          return -1;\n+        } else {\n+          return o1.toString().compareTo(o2.toString());\n+        }\n+      }\n+    };\n+\n+    coloring = new GreedyGraphColoring<String, String>(graph, biasD);\n+    assertEquals(3, coloring.color());\n+    validateColoring(graph);\n+    assertEquals(\"A\", coloring.getPartitionSuperNode(\"A\"));\n+    assertFalse(\"A\".equals(coloring.getPartitionSuperNode(\"C\")));\n+  }\n+\n+  /**\n+   * Validate that each node has been colored and connected nodes have different\n+   * coloring.\n+   */\n+  private static <N, E> void validateColoring(Graph<N, E> graph) {\n+    for (GraphNode<N, E> node : graph.getNodes()) {\n+      assertTrue(node.getAnnotation() != null);\n+    }\n+    for (GraphEdge<N, E> edge : graph.getEdges()) {\n+      Color c1 = edge.getNodeA().getAnnotation();\n+      Color c2 = edge.getNodeB().getAnnotation();\n+      assertTrue(c1 != null);\n+      assertTrue(c2 != null);\n+      assertTrue(!c1.equals(c2));\n+    }\n+  }\n+}\n--- /dev/null\n+++ b/test/com/google/javascript/jscomp/graph/GraphReachabilityTest.java\n+/*\n+ * Copyright 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp.graph;\n+\n+import com.google.javascript.jscomp.graph.GraphReachability;\n+import com.google.javascript.jscomp.graph.LinkedDirectedGraph;\n+import com.google.javascript.jscomp.graph.DiGraph;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * Tests for {@link GraphReachability}.\n+ * \n+*\n+ */\n+public class GraphReachabilityTest extends TestCase {\n+  GraphReachability<String, String> reachability = null;\n+  DiGraph<String, String> graph = null;\n+  \n+  public void testSimple() {\n+    graph = new LinkedDirectedGraph<String, String>();\n+    graph.createNode(\"A\");\n+    reachability = new GraphReachability<String, String>(graph);\n+    reachability.compute(\"A\");\n+    assertReachable(\"A\");\n+    \n+    graph.createNode(\"B\");\n+    reachability = new GraphReachability<String, String>(graph);\n+    reachability.compute(\"A\");\n+    assertReachable(\"A\");\n+    assertNotReachable(\"B\");\n+    \n+    graph.connect(\"A\", \"--->\", \"B\");\n+    reachability = new GraphReachability<String, String>(graph);\n+    reachability.compute(\"B\");\n+    assertNotReachable(\"A\");\n+    assertReachable(\"B\");\n+    \n+    graph.connect(\"B\", \"--->\", \"A\");\n+    reachability = new GraphReachability<String, String>(graph);\n+    reachability.compute(\"B\");\n+    assertReachable(\"A\");\n+    assertReachable(\"B\");\n+    \n+    graph.createNode(\"C\");\n+    reachability = new GraphReachability<String, String>(graph);\n+    reachability.compute(\"A\");\n+    assertReachable(\"A\");\n+    assertReachable(\"B\");\n+    assertNotReachable(\"C\");\n+\n+    graph.createNode(\"D\");\n+    graph.connect(\"C\", \"--->\", \"D\");\n+    reachability = new GraphReachability<String, String>(graph);\n+    reachability.compute(\"A\");\n+    assertReachable(\"A\");\n+    assertReachable(\"B\");\n+    assertNotReachable(\"C\");\n+    assertNotReachable(\"D\");\n+    reachability.recompute(\"C\");\n+    assertReachable(\"C\");\n+    assertReachable(\"D\");\n+  }\n+  \n+  public void assertReachable(String s) {\n+    assertSame(s + \" should be reachable\", graph.getNode(s).getAnnotation(),\n+        GraphReachability.REACHABLE);\n+  }\n+  \n+  public void assertNotReachable(String s) {\n+    assertNotSame(s + \" should not be reachable\",\n+        graph.getNode(s).getAnnotation(), GraphReachability.REACHABLE);\n+  }\n+}\n--- /dev/null\n+++ b/test/com/google/javascript/jscomp/graph/GraphTest.java\n+/*\n+ * Copyright 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp.graph;\n+\n+import com.google.javascript.jscomp.graph.Graph;\n+import com.google.javascript.jscomp.graph.LinkedDirectedGraph;\n+import com.google.javascript.jscomp.graph.LinkedUndirectedGraph;\n+import com.google.javascript.jscomp.graph.Annotatable;\n+import com.google.javascript.jscomp.graph.Annotation;\n+import com.google.javascript.jscomp.graph.GraphNode;\n+import com.google.javascript.jscomp.graph.SubGraph;\n+import com.google.javascript.jscomp.graph.DiGraph;\n+import com.google.javascript.jscomp.graph.Graph.GraphEdge;\n+import com.google.javascript.jscomp.graph.UndiGraph;\n+\n+import junit.framework.TestCase;\n+\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+/**\n+ * Tests for the graph data structure.\n+ *\n+*\n+ */\n+public class GraphTest extends TestCase {\n+\n+  public void testDirectedSimple() {\n+    DiGraph<String, String> graph =\n+        new LinkedDirectedGraph<String, String>();\n+    graph.createNode(\"a\");\n+    graph.createNode(\"b\");\n+    graph.createNode(\"c\");\n+    graph.connect(\"a\", \"->\", \"b\");\n+    assertTrue(graph.hasNode(\"a\"));\n+    assertTrue(graph.hasNode(\"b\"));\n+    assertTrue(graph.hasNode(\"c\"));\n+    assertFalse(graph.hasNode(\"d\"));\n+    assertTrue(graph.isConnected(\"a\", \"b\"));\n+    assertTrue(graph.isConnected(\"b\", \"a\"));\n+    assertFalse(graph.isConnected(\"a\", \"c\"));\n+    assertFalse(graph.isConnected(\"b\", \"c\"));\n+    assertFalse(graph.isConnected(\"c\", \"a\"));\n+    assertFalse(graph.isConnected(\"c\", \"b\"));\n+    assertFalse(graph.isConnected(\"a\", \"a\"));\n+    assertFalse(graph.isConnected(\"b\", \"b\"));\n+    assertFalse(graph.isConnected(\"b\", \"c\"));\n+    assertTrue(graph.isConnectedInDirection(\"a\", \"b\"));\n+    assertFalse(graph.isConnectedInDirection(\"b\", \"a\"));\n+    assertFalse(graph.isConnectedInDirection(\"a\", \"c\"));\n+    assertFalse(graph.isConnectedInDirection(\"b\", \"c\"));\n+    assertFalse(graph.isConnectedInDirection(\"c\", \"a\"));\n+    assertFalse(graph.isConnectedInDirection(\"c\", \"b\"));\n+\n+    // Removal.\n+    graph.disconnect(\"a\", \"b\");\n+    assertFalse(graph.isConnected(\"a\", \"b\"));\n+    assertFalse(graph.isConnected(\"b\", \"a\"));\n+\n+    // Disconnect both ways.\n+    graph.connect(\"a\", \"->\", \"b\");\n+    graph.connect(\"b\", \"->\", \"a\");\n+    graph.disconnect(\"a\", \"b\");\n+    assertFalse(graph.isConnected(\"a\", \"b\"));\n+    assertFalse(graph.isConnected(\"b\", \"a\"));\n+\n+    // Disconnect one way.\n+    graph.connect(\"a\", \"->\", \"b\");\n+    graph.connect(\"b\", \"->\", \"a\");\n+    graph.disconnectInDirection(\"a\", \"b\");\n+    assertTrue(graph.isConnected(\"b\", \"a\"));\n+    assertTrue(graph.isConnected(\"a\", \"b\"));\n+    assertFalse(graph.isConnectedInDirection(\"a\", \"b\"));\n+    assertTrue(graph.isConnectedInDirection(\"b\", \"a\"));\n+  }\n+\n+  public void testUndirectedSimple() {\n+    UndiGraph<String, String> graph =\n+        new LinkedUndirectedGraph<String, String>();\n+    graph.createNode(\"a\");\n+    graph.createNode(\"b\");\n+    graph.createNode(\"c\");\n+    graph.connect(\"a\", \"--\", \"b\");\n+    assertTrue(graph.hasNode(\"a\"));\n+    assertTrue(graph.hasNode(\"b\"));\n+    assertTrue(graph.hasNode(\"c\"));\n+    assertFalse(graph.hasNode(\"d\"));\n+    assertTrue(graph.isConnected(\"a\", \"b\"));\n+    assertTrue(graph.isConnected(\"b\", \"a\"));\n+    assertFalse(graph.isConnected(\"a\", \"c\"));\n+    assertFalse(graph.isConnected(\"b\", \"c\"));\n+    assertFalse(graph.isConnected(\"c\", \"a\"));\n+    assertFalse(graph.isConnected(\"c\", \"b\"));\n+    assertFalse(graph.isConnected(\"a\", \"a\"));\n+    assertFalse(graph.isConnected(\"b\", \"b\"));\n+    assertFalse(graph.isConnected(\"b\", \"c\"));\n+\n+    // Removal.\n+    graph.disconnect(\"a\", \"b\");\n+    assertFalse(graph.isConnected(\"a\", \"b\"));\n+    assertFalse(graph.isConnected(\"b\", \"a\"));\n+  }\n+\n+  public void testDirectedSelfLoop() {\n+    DiGraph<String, String> graph =\n+        new LinkedDirectedGraph<String, String>();\n+    graph.createNode(\"a\");\n+    graph.createNode(\"b\");\n+    graph.connect(\"a\", \"->\", \"a\");\n+    assertTrue(graph.isConnected(\"a\", \"a\"));\n+    assertFalse(graph.isConnected(\"a\", \"b\"));\n+    assertFalse(graph.isConnected(\"b\", \"a\"));\n+    assertTrue(graph.isConnectedInDirection(\"a\", \"a\"));\n+    assertFalse(graph.isConnectedInDirection(\"a\", \"b\"));\n+    assertFalse(graph.isConnectedInDirection(\"b\", \"a\"));\n+\n+    // Removal.\n+    graph.disconnect(\"a\", \"a\");\n+    assertFalse(graph.isConnected(\"a\", \"a\"));\n+\n+    // Disconnect both ways.\n+    graph.connect(\"a\", \"->\", \"a\");\n+    graph.disconnect(\"a\", \"a\");\n+    assertFalse(graph.isConnected(\"a\", \"a\"));\n+    assertFalse(graph.isConnected(\"a\", \"a\"));\n+\n+    // Disconnect one way.\n+    graph.connect(\"a\", \"->\", \"a\");\n+    graph.disconnectInDirection(\"a\", \"a\");\n+    assertFalse(graph.isConnected(\"a\", \"a\"));\n+  }\n+\n+  public void testUndirectedSelfLoop() {\n+    UndiGraph<String, String> graph =\n+        new LinkedUndirectedGraph<String, String>();\n+    graph.createNode(\"a\");\n+    graph.createNode(\"b\");\n+    graph.connect(\"a\", \"--\", \"a\");\n+    assertTrue(graph.isConnected(\"a\", \"a\"));\n+    assertFalse(graph.isConnected(\"a\", \"b\"));\n+    assertFalse(graph.isConnected(\"b\", \"a\"));\n+\n+    // Removal.\n+    graph.disconnect(\"a\", \"a\");\n+    assertFalse(graph.isConnected(\"a\", \"a\"));\n+  }\n+\n+  public void testDirectedInAndOutEdges() {\n+    DiGraph<String, String> graph =\n+        new LinkedDirectedGraph<String, String>();\n+    graph.createNode(\"a\");\n+    graph.createNode(\"b\");\n+    graph.createNode(\"c\");\n+    graph.createNode(\"d\");\n+    graph.connect(\"a\", \"->\", \"b\");\n+    graph.connect(\"a\", \"-->\", \"b\");\n+    graph.connect(\"a\", \"--->\", \"b\");\n+    graph.connect(\"a\", \"->\", \"c\");\n+    graph.connect(\"c\", \"->\", \"d\");\n+    assertSetEquals(graph.getDirectedSuccNodes(\"a\"), \"b\", \"c\");\n+    assertSetEquals(graph.getDirectedPredNodes(\"b\"), \"a\");\n+    assertSetEquals(graph.getDirectedPredNodes(\"c\"), \"a\");\n+    assertListCount(graph.getDirectedSuccNodes(\"a\"), \"b\", 3);\n+\n+    // Removal.\n+    graph.disconnect(\"a\", \"b\");\n+    assertFalse(graph.isConnected(\"a\", \"b\"));\n+  }\n+\n+  public void testUndirectedNeighbors() {\n+    UndiGraph<String, String> graph =\n+        new LinkedUndirectedGraph<String, String>();\n+    graph.createNode(\"a\");\n+    graph.createNode(\"b\");\n+    graph.createNode(\"c\");\n+    graph.createNode(\"d\");\n+    graph.connect(\"a\", \"-\", \"b\");\n+    graph.connect(\"a\", \"--\", \"b\");\n+    graph.connect(\"a\", \"---\", \"b\");\n+    graph.connect(\"a\", \"-\", \"c\");\n+    graph.connect(\"c\", \"-\", \"d\");\n+    assertSetEquals(graph.getNeighborNodes(\"a\"), \"b\", \"c\");\n+    assertSetEquals(graph.getNeighborNodes(\"b\"), \"a\");\n+    assertSetEquals(graph.getNeighborNodes(\"c\"), \"a\", \"d\");\n+    assertListCount(graph.getNeighborNodes(\"a\"), \"b\", 3);\n+\n+    // Removal.\n+    graph.disconnect(\"a\", \"b\");\n+    assertFalse(graph.isConnected(\"a\", \"b\"));\n+  }\n+\n+  public void testNodeAnnotations() {\n+    Graph<String, String> graph = new LinkedUndirectedGraph<String, String>();\n+    GraphNode<String, String> a = graph.createNode(\"a\");\n+    GraphNode<String, String> b = graph.createNode(\"b\");\n+    checkAnnotations(graph, a, b);\n+  }\n+\n+  public void testEdgeAnnotations() {\n+    Graph<String, String> graph = new LinkedUndirectedGraph<String, String>();\n+    graph.createNode(\"1\");\n+    graph.createNode(\"2\");\n+    graph.createNode(\"3\");\n+    graph.connect(\"1\", \"a\", \"2\");\n+    graph.connect(\"2\", \"b\", \"3\");\n+    GraphEdge<String, String> a = graph.getEdges(\"1\", \"2\").get(0);\n+    GraphEdge<String, String> b = graph.getEdges(\"2\", \"3\").get(0);\n+    checkAnnotations(graph, a, b);\n+  }\n+\n+  private static void checkAnnotations(\n+      Graph<String, String> graph, Annotatable a, Annotatable b) {\n+    final Annotation A = new Annotation() {};\n+    final Annotation B = new Annotation() {};\n+\n+    // Initially null.\n+    assertNull(a.getAnnotation());\n+    assertNull(b.getAnnotation());\n+\n+    // Test basic setting.\n+    a.setAnnotation(A);\n+    b.setAnnotation(B);\n+    assertSame(A, a.getAnnotation());\n+    assertSame(B, b.getAnnotation());\n+\n+    // Test clearing.\n+    graph.clearEdgeAnnotations();\n+    graph.clearNodeAnnotations();\n+    assertNull(a.getAnnotation());\n+    assertNull(b.getAnnotation());\n+\n+    a.setAnnotation(A);\n+    b.setAnnotation(B);\n+    // Pushing clears.\n+    graph.pushEdgeAnnotations();\n+    graph.pushNodeAnnotations();\n+    assertNull(a.getAnnotation());\n+    assertNull(b.getAnnotation());\n+    a.setAnnotation(B);\n+    b.setAnnotation(B);\n+    graph.pushEdgeAnnotations();\n+    graph.pushNodeAnnotations();\n+    a.setAnnotation(B);\n+    b.setAnnotation(A);\n+\n+    // Test restoring then restoring old values with pop.\n+    assertSame(B, a.getAnnotation());\n+    assertSame(A, b.getAnnotation());\n+    graph.popEdgeAnnotations();\n+    graph.popNodeAnnotations();\n+    assertSame(B, a.getAnnotation());\n+    assertSame(B, b.getAnnotation());\n+    graph.popEdgeAnnotations();\n+    graph.popNodeAnnotations();\n+    assertSame(A, a.getAnnotation());\n+    assertSame(B, b.getAnnotation());\n+  }\n+\n+  public void testDegree() {\n+    testDirectedDegree(new LinkedDirectedGraph<String, String>());\n+    testDirectedDegree(new LinkedUndirectedGraph<String, String>());\n+  }\n+\n+  public void testDirectedDegree(Graph<String, String> graph) {\n+    graph.createNode(\"a\");\n+    graph.createNode(\"b\");\n+    graph.createNode(\"c\");\n+    graph.createNode(\"d\");\n+    assertEquals(0, graph.getNodeDegree(\"a\"));\n+    graph.connect(\"a\", \"-\", \"b\");\n+    assertEquals(1, graph.getNodeDegree(\"a\"));\n+    graph.connect(\"b\", \"-\", \"c\");\n+    assertEquals(1, graph.getNodeDegree(\"a\"));\n+    graph.connect(\"a\", \"-\", \"c\");\n+    assertEquals(2, graph.getNodeDegree(\"a\"));\n+    graph.connect(\"d\", \"-\", \"a\");\n+    assertEquals(3, graph.getNodeDegree(\"a\"));\n+  }\n+\n+  public void testDirectedConnectIfNotFound() {\n+    testDirectedConnectIfNotFound(new LinkedDirectedGraph<String, String>());\n+    testDirectedConnectIfNotFound(new LinkedUndirectedGraph<String, String>());\n+  }\n+\n+  public void testDirectedConnectIfNotFound(Graph<String, String> graph) {\n+    graph.createNode(\"a\");\n+    graph.createNode(\"b\");\n+    graph.connectIfNotFound(\"a\", \"-\", \"b\");\n+    assertEquals(1, graph.getNodeDegree(\"a\"));\n+    graph.connectIfNotFound(\"a\", \"-\", \"b\");\n+    assertEquals(1, graph.getNodeDegree(\"a\"));\n+    graph.connectIfNotFound(\"a\", null, \"b\");\n+    assertEquals(2, graph.getNodeDegree(\"a\"));\n+    graph.connectIfNotFound(\"a\", null, \"b\");\n+    assertEquals(2, graph.getNodeDegree(\"a\"));\n+  }\n+\n+  public void testSimpleSubGraph() {\n+    UndiGraph<String, String> graph =\n+        new LinkedUndirectedGraph<String, String>();\n+    graph.createNode(\"a\");\n+    graph.createNode(\"b\");\n+    graph.createNode(\"c\");\n+    graph.connect(\"a\", \"--\", \"b\");\n+\n+    SubGraph<String, String> subGraph = graph.newSubGraph();\n+    subGraph.addNode(\"a\");\n+    subGraph.addNode(\"b\");\n+\n+    try {\n+      subGraph.addNode(\"d\");\n+      fail(\"SubGraph should not allow add for node that is not in graph.\");\n+    } catch (IllegalArgumentException e) {\n+      // exception expected\n+    }\n+\n+    assertFalse(subGraph.isIndependentOf(\"a\"));\n+    assertFalse(subGraph.isIndependentOf(\"b\"));\n+    assertTrue(subGraph.isIndependentOf(\"c\"));\n+  }\n+\n+  private <T extends GraphNode<String, String>> void assertListCount(\n+      List<T> list, String target, int count) {\n+    for (GraphNode<String, String> node : list) {\n+      if (node.getValue().equals(target)) {\n+        count--;\n+      }\n+    }\n+    assertTrue(count == 0);\n+  }\n+\n+  private <T extends GraphNode<String, String>> void assertSetEquals(\n+      List<T> list, String ... targets) {\n+    Set<String> set = new HashSet<String>();\n+    for (GraphNode<String, String> node : list) {\n+      set.add(node.getValue());\n+    }\n+    Set<String> otherSet = new HashSet<String>();\n+    for (String target : targets) {\n+      otherSet.add(target);\n+    }\n+    assertTrue(otherSet.equals(set));\n+  }\n+}\n--- /dev/null\n+++ b/test/com/google/javascript/jscomp/graph/StandardUnionFindTest.java\n+/*\n+ * Copyright 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp.graph;\n+\n+import com.google.common.collect.HashMultiset;\n+import com.google.common.collect.ImmutableSet;\n+\n+import junit.framework.Assert;\n+import junit.framework.TestCase;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.Set;\n+\n+/**\n+ * Unit test for the {@link StandardUnionFind} data structure.\n+ *\n+*\n+ */\n+public class StandardUnionFindTest extends TestCase {\n+  private StandardUnionFind<String> union;\n+\n+  @Override protected void setUp() {\n+    union = new StandardUnionFind<String>();\n+  }\n+\n+  public void testEmpty() {\n+    assertEquals(0, union.allEquivalenceClasses().size());\n+  }\n+\n+  public void testAdd() {\n+    union.add(\"foo\");\n+    union.add(\"bar\");\n+    assertTrue(null != union.find(\"foo\"));\n+    assertEquals(2, union.allEquivalenceClasses().size());\n+  }\n+\n+  public void testUnion() {\n+    union.union(\"A\", \"B\");\n+    union.union(\"C\", \"D\");\n+    assertEquals(union.find(\"A\"), union.find(\"B\"));\n+    assertEquals(union.find(\"C\"), union.find(\"D\"));\n+    assertFalse(union.find(\"A\").equals(union.find(\"D\")));\n+  }\n+\n+  public void testSetSize() {\n+    union.union(\"A\", \"B\");\n+    union.union(\"B\", \"C\");\n+    union.union(\"D\", \"E\");\n+    union.union(\"F\", \"F\");\n+\n+    assertEquals(3, union.findAll(\"A\").size());\n+    assertEquals(3, union.findAll(\"B\").size());\n+    assertEquals(3, union.findAll(\"C\").size());\n+    assertEquals(2, union.findAll(\"D\").size());\n+    assertEquals(1, union.findAll(\"F\").size());\n+\n+  }\n+\n+  public void testFind() {\n+    union.add(\"A\");\n+    union.add(\"B\");\n+    assertEquals(\"A\", union.find(\"A\"));\n+    assertEquals(\"B\", union.find(\"B\"));\n+\n+    union.union(\"A\", \"B\");\n+    assertEquals(union.find(\"A\"), union.find(\"B\"));\n+\n+    try {\n+      union.find(\"Z\");\n+      fail(\"find() on unknown element should not be allowed.\");\n+    } catch (IllegalArgumentException e) {\n+    }\n+  }\n+\n+  public void testAllEquivalenceClasses() {\n+    union.union(\"A\", \"B\");\n+    union.union(\"A\", \"B\");\n+    union.union(\"B\", \"A\");\n+    union.union(\"B\", \"C\");\n+    union.union(\"D\", \"E\");\n+    union.union(\"F\", \"F\");\n+\n+    Collection<Set<String>> classes = union.allEquivalenceClasses();\n+    assertEquals(3, classes.size());\n+    assertContentsAnyOrder(classes, \n+        ImmutableSet.of(\"A\", \"B\", \"C\"),\n+        ImmutableSet.of(\"D\", \"E\"),\n+        ImmutableSet.of(\"F\"));\n+  }\n+\n+  public void testFindAll() {\n+    union.union(\"A\", \"B\");\n+    union.union(\"A\", \"B\");\n+    union.union(\"B\", \"A\");\n+    union.union(\"D\", \"E\");\n+    union.union(\"F\", \"F\");\n+\n+    Set<String> aSet = union.findAll(\"A\");\n+    assertEquals(2, aSet.size());\n+    assertTrue(aSet.contains(\"A\"));\n+    assertTrue(aSet.contains(\"B\"));\n+    assertFalse(aSet.contains(\"C\"));\n+    assertFalse(aSet.contains(\"D\"));\n+    assertFalse(aSet.contains(\"E\"));\n+    assertFalse(aSet.contains(\"F\"));\n+\n+    union.union(\"B\", \"C\");\n+    assertTrue(aSet.contains(\"C\"));\n+    assertEquals(3, aSet.size());\n+\n+    try {\n+      union.findAll(\"Z\");\n+      fail(\"findAll() on unknown element should not be allowed.\");\n+    } catch (IllegalArgumentException e) {\n+    }\n+  }\n+\n+  public void testFindAllIterator() {\n+    union.union(\"A\", \"B\");\n+    union.union(\"B\", \"C\");\n+    union.union(\"A\", \"B\");\n+    union.union(\"D\", \"E\");\n+\n+    Set<String> aSet = union.findAll(\"A\");\n+    Iterator<String> aIter = aSet.iterator();\n+    assertTrue(aIter.hasNext());\n+    assertEquals(\"A\", aIter.next());\n+    assertEquals(\"B\", aIter.next());\n+    assertEquals(\"C\", aIter.next());\n+    assertFalse(aIter.hasNext());\n+\n+    Set<String> dSet = union.findAll(\"D\");\n+    Iterator<String> dIter = dSet.iterator();\n+    assertTrue(dIter.hasNext());\n+    assertEquals(\"D\", dIter.next());\n+    assertEquals(\"E\", dIter.next());\n+    assertFalse(dIter.hasNext());\n+  }\n+\n+  public void testFindAllSize() {\n+    union.union(\"A\", \"B\");\n+    union.union(\"B\", \"C\");\n+    assertEquals(3, union.findAll(\"A\").size());\n+    assertEquals(3, union.findAll(\"B\").size());\n+    assertEquals(3, union.findAll(\"C\").size());\n+    union.union(\"D\", \"E\");\n+    assertEquals(3, union.findAll(\"C\").size());\n+    assertEquals(2, union.findAll(\"D\").size());\n+    union.union(\"B\", \"E\");\n+    assertEquals(5, union.findAll(\"C\").size());\n+    assertEquals(5, union.findAll(\"D\").size());\n+  }\n+\n+  public void testElements(){\n+    union.union(\"A\", \"B\");\n+    union.union(\"B\", \"C\");\n+    union.union(\"A\", \"B\");\n+    union.union(\"D\", \"E\");\n+\n+    Set<String> elements = union.elements();\n+    assertEquals(ImmutableSet.of(\"A\", \"B\", \"C\", \"D\", \"E\"), elements);\n+    assertFalse(elements.contains(\"F\"));\n+  }\n+  \n+  public void testCopy() {\n+    union.union(\"A\", \"B\");\n+    union.union(\"B\", \"Z\");\n+    union.union(\"X\", \"Y\");\n+    UnionFind<String> copy = new StandardUnionFind<String>(union);\n+    assertContentsAnyOrder(copy.findAll(\"Z\"), \"A\", \"B\", \"Z\");\n+    assertContentsAnyOrder(copy.findAll(\"X\"), \"X\", \"Y\");\n+  }\n+\n+  public void testChangesToCopyDontAffectOriginal() {\n+    union.union(\"A\", \"B\");\n+    union.union(\"X\", \"Y\");\n+    union.union(\"A\", \"C\");\n+    UnionFind<String> copy = new StandardUnionFind<String>(union);\n+    copy.union(\"A\", \"D\");\n+    assertContentsAnyOrder(copy.findAll(\"D\"), \"A\", \"B\", \"C\", \"D\");\n+    assertContentsAnyOrder(union.findAll(\"A\"), \"A\", \"B\", \"C\");\n+    assertContentsAnyOrder(copy.findAll(\"X\"), \"X\", \"Y\");\n+    try {\n+      union.findAll(\"D\");\n+      fail(\"D has been inserted to the original collection\");\n+    } catch (IllegalArgumentException e) {\n+      // Expected.\n+    }\n+  }\n+  \n+  public void testCheckEquivalent() {\n+    union.union(\"A\", \"B\");\n+    union.add(\"C\");\n+    assertTrue(union.areEquivalent(\"A\", \"B\"));\n+    assertFalse(union.areEquivalent(\"C\", \"A\"));\n+    assertFalse(union.areEquivalent(\"C\", \"B\"));\n+    try {\n+      union.areEquivalent(\"A\", \"F\");\n+    } catch (IllegalArgumentException e) {\n+      // Expected.\n+    }\n+  }\n+  \n+  /**\n+   * Asserts that {@code actual} contains precisely the elements\n+   * {@code expected}, in any order.  Both collections may contain\n+   * duplicates, and this method will only pass if the quantities are\n+   * exactly the same.\n+   */\n+  private static void assertContentsAnyOrder(\n+      String message, Iterable<?> actual, Object... expected) {\n+    Assert.assertEquals(message,\n+        HashMultiset.create(Arrays.asList(expected)),\n+        HashMultiset.create(actual));\n+  }\n+\n+  /**\n+   * Variant of {@link #assertContentsAnyOrder(String,Iterable,Object...)}\n+   * using a generic message.\n+   */\n+  private static void assertContentsAnyOrder(\n+      Iterable<?> actual, Object... expected) {\n+    assertContentsAnyOrder((String) null, actual, expected);\n+  }\n+}", "timestamp": 1270246117, "metainfo": ""}