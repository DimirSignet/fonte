{"sha": "583972a2c34266f7a35867b13749c3c368e02acf", "log": "Add a method for collapsing unions.  R=tylerg DELTA=136  (136 added, 0 deleted, 0 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=3454   ", "commit": "\n--- a/src/com/google/javascript/rhino/jstype/JSType.java\n+++ b/src/com/google/javascript/rhino/jstype/JSType.java\n   }\n \n   /**\n+   * Gets the least supertype of this that's not a union.\n+   */\n+  public JSType collapseUnion() {\n+    return this;\n+  }\n+\n+  /**\n    * Gets the least supertype of {@code this} and {@code that}.\n    * The least supertype is the join (&#8744;) or supremum of both types in the\n    * type lattice.<p>\n--- a/src/com/google/javascript/rhino/jstype/JSTypeRegistry.java\n+++ b/src/com/google/javascript/rhino/jstype/JSTypeRegistry.java\n import com.google.common.collect.ArrayListMultimap;\n import com.google.common.collect.ImmutableList;\n import com.google.common.collect.LinkedHashMultimap;\n+import com.google.common.collect.Lists;\n import com.google.common.collect.Maps;\n import com.google.common.collect.Multimap;\n import com.google.javascript.rhino.ErrorReporter;\n     } else {\n       return ImmutableList.of();\n     }\n+  }\n+\n+  /**\n+   * Finds the common supertype of the two given object types.\n+   */\n+  ObjectType findCommonSuperObject(ObjectType a, ObjectType b) {\n+    List<ObjectType> stackA = getSuperStack(a);\n+    List<ObjectType> stackB = getSuperStack(b);\n+\n+    ObjectType result = getNativeObjectType(JSTypeNative.OBJECT_TYPE);\n+    while (!stackA.isEmpty() && !stackB.isEmpty()) {\n+      ObjectType currentA = stackA.remove(stackA.size() - 1);\n+      ObjectType currentB = stackB.remove(stackB.size() - 1);\n+      if (currentA.isEquivalentTo(currentB)) {\n+        result = currentA;\n+      } else {\n+        return result;\n+      }\n+    }\n+    return result;\n+  }\n+\n+  private static List<ObjectType> getSuperStack(ObjectType a) {\n+    List<ObjectType> stack = Lists.newArrayListWithExpectedSize(5);\n+    for (ObjectType current = a;\n+         current != null;\n+         current = current.getImplicitPrototype()) {\n+      stack.add(current);\n+    }\n+    return stack;\n   }\n \n   /**\n--- a/src/com/google/javascript/rhino/jstype/ProxyObjectType.java\n+++ b/src/com/google/javascript/rhino/jstype/ProxyObjectType.java\n     }\n     return super.getTypeOfThis();\n   }\n+\n+  @Override\n+  public JSType collapseUnion() {\n+    if (referencedType.isUnionType()) {\n+      return referencedType.collapseUnion();\n+    }\n+    return this;\n+  }\n }\n--- a/src/com/google/javascript/rhino/jstype/UnionType.java\n+++ b/src/com/google/javascript/rhino/jstype/UnionType.java\n     }\n     return true;\n   }\n+\n+  @Override\n+  public JSType collapseUnion() {\n+    JSType currentValue = null;\n+    ObjectType currentCommonSuper = null;\n+    for (JSType a : alternates) {\n+      if (a.isUnknownType()) {\n+        return getNativeType(JSTypeNative.UNKNOWN_TYPE);\n+      }\n+\n+      ObjectType obj = a.toObjectType();\n+      if (obj == null) {\n+        if (currentValue == null && currentCommonSuper == null) {\n+          // If obj is not an object, then it must be a value.\n+          currentValue = a;\n+        } else {\n+          // Multiple values and objects will always collapse to the ALL_TYPE.\n+          return getNativeType(JSTypeNative.ALL_TYPE);\n+        }\n+      } else if (currentValue != null) {\n+        // Values and objects will always collapse to the ALL_TYPE.\n+        return getNativeType(JSTypeNative.ALL_TYPE);\n+      } else if (currentCommonSuper == null) {\n+        currentCommonSuper = obj;\n+      } else {\n+        currentCommonSuper =\n+            registry.findCommonSuperObject(currentCommonSuper, obj);\n+      }\n+    }\n+    return currentCommonSuper;\n+  }\n }\n--- a/test/com/google/javascript/rhino/jstype/UnionTypeTest.java\n+++ b/test/com/google/javascript/rhino/jstype/UnionTypeTest.java\n         stringOrNumberProxy.getTypesUnderShallowInequality(\n             stringOrBooleanProxy).typeA.toString());\n   }\n+\n+  public void testCollapseUnion1() {\n+    assertEquals(\n+        \"*\",\n+        registry.createUnionType(NUMBER_TYPE, STRING_TYPE)\n+        .collapseUnion().toString());\n+  }\n+\n+  public void testCollapseUnion2() {\n+    assertEquals(\n+        \"?\",\n+        registry.createUnionType(UNKNOWN_TYPE, NUMBER_TYPE)\n+        .collapseUnion().toString());\n+    assertEquals(\n+        \"?\",\n+        registry.createUnionType(NUMBER_TYPE, UNKNOWN_TYPE)\n+        .collapseUnion().toString());\n+  }\n+\n+  public void testCollapseUnion3() {\n+    assertEquals(\n+        \"Object\",\n+        registry.createUnionType(ARRAY_TYPE, DATE_TYPE)\n+        .collapseUnion().toString());\n+    assertEquals(\n+        \"Object\",\n+        registry.createUnionType(ARRAY_TYPE, OBJECT_TYPE)\n+        .collapseUnion().toString());\n+    assertEquals(\n+        \"Error\",\n+        registry.createUnionType(ERROR_TYPE, RANGE_ERROR_TYPE)\n+        .collapseUnion().toString());\n+    assertEquals(\n+        \"Error\",\n+        registry.createUnionType(EVAL_ERROR_TYPE, RANGE_ERROR_TYPE)\n+        .collapseUnion().toString());\n+    assertEquals(\n+        \"Error\",\n+        registry.createUnionType(\n+            EVAL_ERROR_TYPE, RANGE_ERROR_TYPE, TYPE_ERROR_TYPE)\n+        .collapseUnion().toString());\n+  }\n+\n+  public void testCollapseUnion4() {\n+    assertEquals(\n+        \"*\",\n+        registry.createUnionType(OBJECT_TYPE, STRING_TYPE)\n+        .collapseUnion().toString());\n+    assertEquals(\n+        \"*\",\n+        registry.createUnionType(STRING_TYPE, OBJECT_TYPE)\n+        .collapseUnion().toString());\n+  }\n+\n+  public void testCollapseProxyUnion() {\n+    // Make sure we don't unbox the proxy.\n+    ProxyObjectType type = new ProxyObjectType(registry, OBJECT_TYPE);\n+    assertTrue(type == type.collapseUnion());\n+  }\n }", "timestamp": 1318457992, "metainfo": ""}