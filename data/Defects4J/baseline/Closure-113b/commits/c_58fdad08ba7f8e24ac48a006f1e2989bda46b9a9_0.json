{"sha": "58fdad08ba7f8e24ac48a006f1e2989bda46b9a9", "log": "Some NodeUtil cleanup, narrow the public interface, remove some unused functions, and some other cleanup.  R=nicksantos DELTA=130  (40 added, 50 deleted, 40 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=5519   ", "commit": "\n--- a/src/com/google/javascript/jscomp/AbstractPeepholeOptimization.java\n+++ b/src/com/google/javascript/jscomp/AbstractPeepholeOptimization.java\n   }\n \n   /**\n+   * Returns true if the current node's type implies side effects.\n+   *\n+   * This is a non-recursive version of the may have side effects\n+   * check; used to check wherever the current node's type is one of\n+   * the reason's why a subtree has side effects.\n+   */\n+  boolean nodeTypeMayHaveSideEffects(Node n) {\n+    return NodeUtil.nodeTypeMayHaveSideEffects(n, compiler);\n+  }\n+\n+  /**\n    * @return Whether the source code version is ECMAScript 5 or later.\n    *     Workarounds for quirks in browsers that do not support ES5 can be\n    *     ignored when this is true.\n--- a/src/com/google/javascript/jscomp/CheckSideEffects.java\n+++ b/src/com/google/javascript/jscomp/CheckSideEffects.java\n     }\n \n     boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n-    boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n+    boolean isSimpleOp = NodeUtil.isSimpleOperator(n);\n     if (!isResultUsed &&\n         (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {\n       String msg = \"This code lacks side-effects. Is there a bug?\";\n--- a/src/com/google/javascript/jscomp/ExpressionDecomposer.java\n+++ b/src/com/google/javascript/jscomp/ExpressionDecomposer.java\n         subExpression, expressionRoot);\n     // Before extraction, record whether there are side-effect\n     boolean hasFollowingSideEffects = NodeUtil.mayHaveSideEffects(\n-        nonconditionalExpr);\n+        nonconditionalExpr, compiler);\n \n     Node exprInjectionPoint = findInjectionPoint(nonconditionalExpr);\n     DecompositionState state = new DecompositionState();\n   private DecompositionType isSubexpressionMovable(\n       Node expressionRoot, Node subExpression) {\n     boolean requiresDecomposition = false;\n-    boolean seenSideEffects = NodeUtil.mayHaveSideEffects(subExpression);\n+    boolean seenSideEffects = NodeUtil.mayHaveSideEffects(\n+        subExpression, compiler);\n \n     Node child = subExpression;\n     for (Node parent : child.getAncestors()) {\n     } else {\n       // The function called doesn't have side-effects but check to see if there\n       // are side-effects that that may affect it.\n-      return NodeUtil.mayHaveSideEffects(n);\n+      return NodeUtil.mayHaveSideEffects(n, compiler);\n     }\n   }\n }\n--- a/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java\n+++ b/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java\n       // TODO(user): Side-effect is OK sometimes. As long as there are no\n       // side-effect function down all paths to the use. Once we have all the\n       // side-effect analysis tool.\n-      if (NodeUtil.mayHaveSideEffects(def.getLastChild())) {\n+      if (NodeUtil.mayHaveSideEffects(def.getLastChild(), compiler)) {\n         return false;\n       }\n \n--- a/src/com/google/javascript/jscomp/FunctionInjector.java\n+++ b/src/com/google/javascript/jscomp/FunctionInjector.java\n           // Check for arguments that are evaluated more than once.\n           // Note: Unlike block inlining, there it is not possible that a\n           // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg)\n+          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n               && NodeUtil.getNameReferenceCount(\n                   block, fnParam.getString()) > 1) {\n             return CanInlineResult.NO;\n       // For every call argument check for side-effects, even if there\n       // isn't a named parameter to match.\n       if (cArg != null) {\n-        if (NodeUtil.mayHaveSideEffects(cArg)) {\n+        if (NodeUtil.mayHaveSideEffects(cArg, compiler)) {\n           return CanInlineResult.NO;\n         }\n         cArg = cArg.getNext();\n--- a/src/com/google/javascript/jscomp/GatherSideEffectSubexpressionsCallback.java\n+++ b/src/com/google/javascript/jscomp/GatherSideEffectSubexpressionsCallback.java\n       return processShortCircuitExpression(node);\n     }\n \n-    if (!NodeUtil.nodeTypeMayHaveSideEffects(node)) {\n+    if (!NodeUtil.nodeTypeMayHaveSideEffects(node, compiler)) {\n       return true;\n     } else {\n \n     // contains a call.\n     Node left = node.getFirstChild();\n     Node right = left.getNext();\n-    if (NodeUtil.mayHaveSideEffects(right)) {\n+    if (NodeUtil.mayHaveSideEffects(right, compiler)) {\n       accumulator.keepSimplifiedShortCircuitExpression(node);\n       return false;\n     } else {\n     Node condition = node.getFirstChild();\n     Node ifBranch = condition.getNext();\n     Node elseBranch = ifBranch.getNext();\n-    boolean thenHasSideEffects = NodeUtil.mayHaveSideEffects(ifBranch);\n-    boolean elseHasSideEffects = NodeUtil.mayHaveSideEffects(elseBranch);\n+    boolean thenHasSideEffects = NodeUtil.mayHaveSideEffects(\n+        ifBranch, compiler);\n+    boolean elseHasSideEffects = NodeUtil.mayHaveSideEffects(\n+        elseBranch, compiler);\n     if (thenHasSideEffects || elseHasSideEffects) {\n       accumulator.keepSimplifiedHookExpression(\n           node, thenHasSideEffects, elseHasSideEffects);\n--- a/src/com/google/javascript/jscomp/InlineSimpleMethods.java\n+++ b/src/com/google/javascript/jscomp/InlineSimpleMethods.java\n               logger.fine(\"Inlining property accessor: \" + callName);\n               inlinePropertyReturn(parent, callNode, returned);\n             } else if (NodeUtil.isLiteralValue(returned, false) &&\n-              !NodeUtil.mayHaveSideEffects(callNode.getFirstChild())) {\n+              !NodeUtil.mayHaveSideEffects(\n+                  callNode.getFirstChild(), compiler)) {\n               logger.fine(\"Inlining constant accessor: \" + callName);\n               inlineConstReturn(parent, callNode, returned);\n             }\n           } else if (isEmptyMethod(firstDefinition) &&\n-              !NodeUtil.mayHaveSideEffects(callNode.getFirstChild())) {\n+              !NodeUtil.mayHaveSideEffects(\n+                  callNode.getFirstChild(), compiler)) {\n             logger.fine(\"Inlining empty method: \" + callName);\n             inlineEmptyMethod(t, parent, callNode);\n           }\n     for (Node currentChild = call.getFirstChild().getNext();\n          currentChild != null;\n          currentChild = currentChild.getNext()) {\n-      if (NodeUtil.mayHaveSideEffects(currentChild)) {\n+      if (NodeUtil.mayHaveSideEffects(currentChild, compiler)) {\n         return true;\n       }\n     }\n--- a/src/com/google/javascript/jscomp/NodeUtil.java\n+++ b/src/com/google/javascript/jscomp/NodeUtil.java\n import javax.annotation.Nullable;\n \n /**\n- * NodeUtil contains utilities that get properties from the Node object.\n+ * NodeUtil contains generally useful AST utilities.\n  *\n  */\n public final class NodeUtil {\n \n-  static final long MAX_POSITIVE_INTEGER_NUMBER = (long)Math.pow(2, 53);\n-\n-  final static String JSC_PROPERTY_NAME_FN = \"JSCompiler_renameProperty\";\n-\n-  // TODO(user): Eliminate this class and make all of the static methods\n-  // instance methods of com.google.javascript.rhino.Node.\n+  static final long MAX_POSITIVE_INTEGER_NUMBER = (long) Math.pow(2, 53);\n+\n+  static final String JSC_PROPERTY_NAME_FN = \"JSCompiler_renameProperty\";\n+\n+  static final char LARGEST_BASIC_LATIN = 0x7f;\n \n   /** the set of builtin constructors that don't have side effects. */\n   private static final Set<String> CONSTRUCTORS_WITHOUT_SIDE_EFFECTS =\n   /**\n    * Returns true if the operator on this node is symmetric\n    */\n-  public static boolean isSymmetricOperation(Node n) {\n+  static boolean isSymmetricOperation(Node n) {\n     switch (n.getType()) {\n       case Token.EQ: // equal\n       case Token.NE: // not equal\n    * Returns true if the operator on this node is relational.\n    * the returned set does not include the equalities.\n    */\n-  public static boolean isRelationalOperation(Node n) {\n+  static boolean isRelationalOperation(Node n) {\n     switch (n.getType()) {\n       case Token.GT: // equal\n       case Token.GE: // not equal\n    * Returns the inverse of an operator if it is invertible.\n    * ex. '>' ==> '<'\n    */\n-  public static int getInverseOperator(int type) {\n+  static int getInverseOperator(int type) {\n     switch (type) {\n       case Token.GT:\n         return Token.LT;\n    * @param child The expression itself.\n    * @return Newly created EXPR node with the child as subexpression.\n    */\n-  public static Node newExpr(Node child) {\n+  static Node newExpr(Node child) {\n     return IR.exprResult(child).srcref(child);\n   }\n \n         return true;\n \n       default:\n-        if (isSimpleOperatorType(n.getType())) {\n+        if (isSimpleOperator(n)) {\n           break;\n         }\n \n                 nameNode.getLastChild().getString())) {\n           Node param = nameNode.getNext();\n           if (param != null &&\n-              (param.isString() || param.isRegExp()))\n-          return false;\n+              (param.isString() || param.isRegExp())) {\n+            return false;\n+          }\n         }\n       }\n     }\n     }\n   }\n \n+  static boolean isUndefined(Node n) {\n+    switch (n.getType()) {\n+      case Token.VOID:\n+        return true;\n+      case Token.NAME:\n+        return n.getString().equals(\"undefined\");\n+    }\n+    return false;\n+  }\n+\n+  static boolean isNullOrUndefined(Node n) {\n+    return n.isNull() || isUndefined(n);\n+  }\n+\n   /**\n    * Apply the supplied predicate against\n    * all possible result Nodes of the expression.\n     }\n   }\n \n-  static boolean isUndefined(Node n) {\n-    switch (n.getType()) {\n-      case Token.VOID:\n-        return true;\n-      case Token.NAME:\n-        return n.getString().equals(\"undefined\");\n-    }\n-    return false;\n-  }\n-\n-  static boolean isNullOrUndefined(Node n) {\n-    return n.isNull() || isUndefined(n);\n-  }\n+\n \n   static class MayBeStringResultPredicate implements Predicate<Node> {\n     @Override\n       parent.replaceChild(node, IR.empty());\n     } else {\n       throw new IllegalStateException(\"Invalid attempt to remove node: \" +\n-          node.toString() + \" of \"+ parent.toString());\n+          node.toString() + \" of \" + parent.toString());\n     }\n   }\n \n   }\n \n   /**\n-   * Is this node or any of its children a CALL?\n-   */\n-  static boolean containsCall(Node n) {\n-    return containsType(n, Token.CALL);\n-  }\n-\n-  /**\n    * Is this node a function declaration? A function declaration is a function\n    * that has a name that is added to the current scope (i.e. a function that\n    * is not part of a expression; see {@link #isFunctionExpression}).\n    */\n   static boolean isFunctionObjectApply(Node callNode) {\n     return isObjectCallMethod(callNode, \"apply\");\n-  }\n-\n-  /**\n-   * @return Whether the callNode represents an expression in the form of:\n-   *    x.apply(...)\n-   *    x['apply'](...)\n-   *  or\n-   *    x.call(...)\n-   *    x['call'](...)\n-   */\n-  static boolean isFunctionObjectCallOrApply(Node callNode) {\n-    return isFunctionObjectCall(callNode) || isFunctionObjectApply(callNode);\n-  }\n-\n-  /**\n-   * @return Whether the callNode represents an expression in the form of:\n-   *    x.call(...)\n-   *    x['call'](...)\n-   * where x is a NAME node.\n-   */\n-  static boolean isSimpleFunctionObjectCall(Node callNode) {\n-    if (isFunctionObjectCall(callNode)) {\n-      if (callNode.getFirstChild().getFirstChild().isName()) {\n-        return true;\n-      }\n-    }\n-\n-    return false;\n   }\n \n   /**\n   /**\n    * Gets the root node of a qualified name. Must be either NAME or THIS.\n    */\n-  public static Node getRootOfQualifiedName(Node qName) {\n+  static Node getRootOfQualifiedName(Node qName) {\n     for (Node current = qName; true;\n          current = current.getFirstChild()) {\n       if (current.isName() || current.isThis()) {\n    *\n    * @return True if all characters in the string are in Basic Latin set.\n    */\n-\n   static boolean isLatin(String s) {\n-    char LARGEST_BASIC_LATIN = 0x7f;\n     int len = s.length();\n     for (int index = 0; index < len; index++) {\n       char c = s.charAt(index);\n   /**\n    * Determines whether the given name is a valid variable name.\n    */\n-  public static boolean isValidSimpleName(String name) {\n+  static boolean isValidSimpleName(String name) {\n     return TokenStream.isJSIdentifier(name) &&\n         !TokenStream.isKeyword(name) &&\n         // no Unicode escaped characters - some browsers are less tolerant\n   /**\n    * Retrieves vars declared in the current node tree, excluding descent scopes.\n    */\n-  public static Collection<Node> getVarsDeclaredInBranch(Node root) {\n+  static Collection<Node> getVarsDeclaredInBranch(Node root) {\n     VarCollector collector = new VarCollector();\n     visitPreOrder(\n         root,\n     return isPrototypeProperty(n.getFirstChild().getFirstChild());\n   }\n \n+  /**\n+   * @return Whether the node represents a qualified prototype property.\n+   */\n   static boolean isPrototypeProperty(Node n) {\n     String lhsString = n.getQualifiedName();\n     if (lhsString == null) {\n     return true;\n   }\n \n+  /**\n+   * @return An appropriate AST node for the boolean value.\n+   */\n   static Node booleanNode(boolean value) {\n     return value ? IR.trueNode() : IR.falseNode();\n   }\n \n+  /**\n+   * @return An appropriate AST node for the double value.\n+   */\n   static Node numberNode(double value, Node srcref) {\n     Node result;\n     if (Double.isNaN(value)) {\n--- a/src/com/google/javascript/jscomp/PeepholeCollectPropertyAssignments.java\n+++ b/src/com/google/javascript/jscomp/PeepholeCollectPropertyAssignments.java\n \n     Node rhs = lhs.getNext();\n     // with a value that cannot change the values of the variables,\n-    if (NodeUtil.mayHaveSideEffects(rhs)\n+    if (mayHaveSideEffects(rhs)\n         || NodeUtil.canBeSideEffected(rhs)) {\n       return false;\n     }\n--- a/src/com/google/javascript/jscomp/PeepholeRemoveDeadCode.java\n+++ b/src/com/google/javascript/jscomp/PeepholeRemoveDeadCode.java\n         }\n         break;\n       default:\n-        if (!NodeUtil.nodeTypeMayHaveSideEffects(n)) {\n+        if (!nodeTypeMayHaveSideEffects(n)) {\n           // This is the meat of this function. The node itself doesn't generate\n           // any side-effects but preserve any side-effects in the children.\n           Node resultList = null;\n--- a/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n+++ b/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n   boolean isPure(Node n) {\n     return n == null\n         || (!NodeUtil.canBeSideEffected(n)\n-            && !NodeUtil.mayHaveSideEffects(n));\n+            && !mayHaveSideEffects(n));\n   }\n \n   /**\n--- a/src/com/google/javascript/jscomp/RemoveUnusedVars.java\n+++ b/src/com/google/javascript/jscomp/RemoveUnusedVars.java\n         if (parent.isVar()) {\n           Node value = n.getFirstChild();\n           if (value != null && var != null && isRemovableVar(var) &&\n-              !NodeUtil.mayHaveSideEffects(value)) {\n+              !NodeUtil.mayHaveSideEffects(value, compiler)) {\n             // If the var is unreferenced and creating its value has no side\n             // effects, then we can create a continuation for it instead\n             // of traversing immediately.\n         // foreach iterations have 3 children. Leave them alone.\n       } else if (toRemove.isVar() &&\n           nameNode.hasChildren() &&\n-          NodeUtil.mayHaveSideEffects(nameNode.getFirstChild())) {\n+          NodeUtil.mayHaveSideEffects(nameNode.getFirstChild(), compiler)) {\n         // If this is a single var declaration, we can at least remove the\n         // declaration itself and just leave the value, e.g.,\n         // var a = foo(); => foo();\n--- a/src/com/google/javascript/jscomp/StatementFusion.java\n+++ b/src/com/google/javascript/jscomp/StatementFusion.java\n     return n;\n   }\n \n-  private static boolean canFuseIntoOneStatement(Node block) {\n+  private boolean canFuseIntoOneStatement(Node block) {\n     // Fold only statement block. NOT scripts block.\n     if (!block.isBlock()) {\n       return false;\n       case Token.FOR:\n         return NodeUtil.isForIn(last) &&\n             // Avoid cases where we have for(var x = foo() in a) { ....\n-            !NodeUtil.mayHaveSideEffects(last.getFirstChild());\n+            !mayHaveSideEffects(last.getFirstChild());\n     }\n \n     return false;\n--- a/src/com/google/javascript/jscomp/UnreachableCodeElimination.java\n+++ b/src/com/google/javascript/jscomp/UnreachableCodeElimination.java\n       return;\n     }\n     if (gNode.getAnnotation() != GraphReachability.REACHABLE ||\n-        (removeNoOpStatements && !NodeUtil.mayHaveSideEffects(n))) {\n+        (removeNoOpStatements && !NodeUtil.mayHaveSideEffects(n, compiler))) {\n       removeDeadExprStatementSafely(n);\n       return;\n     }", "timestamp": 1348167340, "metainfo": ""}