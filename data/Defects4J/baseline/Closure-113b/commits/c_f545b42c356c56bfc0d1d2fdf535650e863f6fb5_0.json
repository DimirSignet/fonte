{"sha": "f545b42c356c56bfc0d1d2fdf535650e863f6fb5", "log": "output the module config even in the degenerate case  R=laszlocsomor DELTA=56  (42 added, 1 deleted, 13 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=4209   ", "commit": "\n--- a/src/com/google/javascript/jscomp/AbstractCommandLineRunner.java\n+++ b/src/com/google/javascript/jscomp/AbstractCommandLineRunner.java\n     if (parsedModuleWrappers == null) {\n       parsedModuleWrappers = parseModuleWrappers(\n           config.moduleWrapper,\n-          Lists.newArrayList(compiler.getModuleGraph().getAllModules()));\n+          Lists.newArrayList(\n+              compiler.getDegenerateModuleGraph().getAllModules()));\n     }\n \n     String fileName = getModuleOutputFileName(m);\n         continue;\n       }\n \n-      JSModuleGraph graph = compiler.getModuleGraph();\n       if (shouldGenerateOutputPerModule(output)) {\n         // Generate per-module manifests or bundles\n+        JSModuleGraph graph = compiler.getDegenerateModuleGraph();\n         Iterable<JSModule> modules = graph.getAllModules();\n         for (JSModule module : modules) {\n           Writer out = fileNameToOutputWriter2(\n         // Generate a single file manifest or bundle.\n         Writer out = fileNameToOutputWriter2(\n             expandCommandLinePath(output, null));\n-        if (graph == null) {\n+        if (config.module.isEmpty()) {\n           if (isManifest) {\n             printManifestTo(compiler.getInputsInOrder(), out);\n           } else {\n             printBundleTo(compiler.getInputsInOrder(), out);\n           }\n         } else {\n-          printModuleGraphManifestOrBundleTo(graph, out, isManifest);\n+          printModuleGraphManifestOrBundleTo(\n+              compiler.getDegenerateModuleGraph(), out, isManifest);\n         }\n         out.close();\n       }\n--- a/src/com/google/javascript/jscomp/Compiler.java\n+++ b/src/com/google/javascript/jscomp/Compiler.java\n     return moduleGraph;\n   }\n \n+  /**\n+   * Gets a module graph. This will always return a module graph, even\n+   * in the degenerate case when there's only one module.\n+   */\n+  JSModuleGraph getDegenerateModuleGraph() {\n+    return moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph;\n+  }\n+\n   @Override\n   public JSTypeRegistry getTypeRegistry() {\n     if (typeRegistry == null) {", "timestamp": 1328888153, "metainfo": ""}