{"sha": "75aeb38f6a718778023d3d7f10dc491003161eff", "log": "Enable generic type extension via @extends and @implements. Subtyping relationships with generic interfaces will be handled in a follow-up CL. ------------- Created by MOE: http://code.google.com/p/moe-java MOE_MIGRATED_REVID=44214013", "commit": "\n--- a/src/com/google/javascript/jscomp/FunctionTypeBuilder.java\n+++ b/src/com/google/javascript/jscomp/FunctionTypeBuilder.java\n   private boolean isInterface = false;\n   private Node parametersNode = null;\n   private ImmutableList<TemplateType> templateTypeNames = ImmutableList.of();\n-  private ImmutableList<String> classTypeParameterNames = ImmutableList.of();;\n+  private ImmutableList<TemplateType> classTemplateTypeNames = ImmutableList.of();\n \n   static final DiagnosticType EXTENDS_WITHOUT_TYPEDEF = DiagnosticType.warning(\n       \"JSC_EXTENDS_WITHOUT_TYPEDEF\",\n         reportWarning(CONSTRUCTOR_REQUIRED, \"@struct\", formatFnName());\n       } else if (makesDicts && !isConstructor) {\n         reportWarning(CONSTRUCTOR_REQUIRED, \"@dict\", formatFnName());\n+      }\n+\n+      // Class template types, which can be used in the scope of a constructor\n+      // definition.\n+      ImmutableList<String> typeParameters = info.getClassTemplateTypeNames();\n+      if (!typeParameters.isEmpty()) {\n+        if (isConstructor || isInterface) {\n+          ImmutableList.Builder<TemplateType> builder = ImmutableList.builder();\n+          for (String typeParameter : typeParameters) {\n+            builder.add(typeRegistry.createTemplateType(typeParameter));\n+          }\n+          classTemplateTypeNames = builder.build();\n+          typeRegistry.setTemplateTypeNames(classTemplateTypeNames);\n+        } else {\n+          reportWarning(CLASS_TEMPLATE_WITHOUT_CONSTRUCTOR,\n+              formatFnName());\n+        }\n       }\n \n       // base type\n               maybeInterfaceType.setValidator(new ExtendedTypeValidator())) {\n             extendedInterfaces.add((ObjectType) maybeInterfaceType);\n           }\n-        }\n-      }\n-\n-      ImmutableList<String> typeParameters = info.getClassTemplateTypeNames();\n-      if (!typeParameters.isEmpty()) {\n-        if (isConstructor || isInterface) {\n-          this.classTypeParameterNames = typeParameters;\n-        } else {\n-          reportWarning(CLASS_TEMPLATE_WITHOUT_CONSTRUCTOR,\n-              formatFnName());\n         }\n       }\n     }\n       fnType = getOrCreateConstructor();\n     } else if (isInterface) {\n       fnType = typeRegistry.createInterfaceType(\n-          fnName, contents.getSourceNode(), classTypeParameterNames);\n+          fnName, contents.getSourceNode(), classTemplateTypeNames);\n       if (getScopeDeclaredIn().isGlobal() && !fnName.isEmpty()) {\n         typeRegistry.declareType(fnName, fnType.getInstanceType());\n       }\n   private FunctionType getOrCreateConstructor() {\n     FunctionType fnType = typeRegistry.createConstructorType(\n         fnName, contents.getSourceNode(), parametersNode, returnType,\n-        classTypeParameterNames);\n+        classTemplateTypeNames);\n     JSType existingType = typeRegistry.getType(fnName);\n \n     if (makesStructs) {\n--- /dev/null\n+++ b/src/com/google/javascript/jscomp/TemplateTypeMapReplacer.java\n+/*\n+ * Copyright 2013 The Closure Compiler Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+import com.google.javascript.rhino.jstype.JSType;\n+import com.google.javascript.rhino.jstype.JSTypeRegistry;\n+import com.google.javascript.rhino.jstype.ModificationVisitor;\n+import com.google.javascript.rhino.jstype.TemplateType;\n+import com.google.javascript.rhino.jstype.TemplateTypeMap;\n+\n+import java.util.ArrayDeque;\n+\n+/**\n+ * Uses a TemplateTypeMap to replace TemplateTypes with their associated JSType\n+ * values.\n+ *\n+ * @author izaakr@google.com (Izaak Rubin)\n+ */\n+public class TemplateTypeMapReplacer extends ModificationVisitor {\n+  private final TemplateTypeMap replacements;\n+  private ArrayDeque<TemplateType> visitedTypes;\n+\n+  TemplateTypeMapReplacer(\n+      JSTypeRegistry registry, TemplateTypeMap replacements) {\n+    super(registry);\n+    this.replacements = replacements;\n+    this.visitedTypes = new ArrayDeque<TemplateType>();\n+  }\n+\n+  @Override\n+  public JSType caseTemplateType(TemplateType type) {\n+    if (replacements.hasTemplateKey(type)) {\n+      if (hasVisitedType(type)) {\n+        // If we have already encountered this TemplateType during replacement\n+        // (i.e. there is a reference loop), return the type itself.\n+        return type;\n+      } else {\n+        JSType replacement = replacements.getTemplateType(type);\n+\n+        visitedTypes.push(type);\n+        JSType visitedReplacement = replacement.visit(this);\n+        visitedTypes.pop();\n+\n+        return visitedReplacement;\n+      }\n+    } else {\n+      return type;\n+    }\n+  }\n+\n+  /**\n+   * Checks if the specified type has already been visited during the Visitor's\n+   * traversal of a JSType.\n+   */\n+  private boolean hasVisitedType(TemplateType type) {\n+    for (TemplateType visitedType : visitedTypes) {\n+      if (visitedType == type) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+}\n--- a/src/com/google/javascript/jscomp/TypeInference.java\n+++ b/src/com/google/javascript/jscomp/TypeInference.java\n     }\n   }\n \n-  private static class TemplateTypeMapReplacer extends ModificationVisitor {\n-    private final TemplateTypeMap replacements;\n-    boolean madeChanges = false;\n-\n-    TemplateTypeMapReplacer(\n-        JSTypeRegistry registry, TemplateTypeMap replacements) {\n-      super(registry);\n-      this.replacements = replacements;\n-    }\n-\n-    @Override\n-    public JSType caseTemplateType(TemplateType type) {\n-      if (replacements.hasTemplateKey(type)) {\n-        madeChanges = true;\n-        JSType replacement = replacements.getTemplateType(type);\n-        return replacements.getTemplateType(type);\n-      } else {\n-        return type;\n-      }\n-    }\n-  }\n-\n   /**\n    * For functions with function(this: T, ...) and T as parameters, type\n    * inference will set the type of this on a function literal argument to the\n--- a/src/com/google/javascript/jscomp/TypeValidator.java\n+++ b/src/com/google/javascript/jscomp/TypeValidator.java\n import com.google.javascript.rhino.jstype.JSTypeRegistry;\n import com.google.javascript.rhino.jstype.ObjectType;\n import com.google.javascript.rhino.jstype.StaticSlot;\n+import com.google.javascript.rhino.jstype.TemplateTypeMap;\n import com.google.javascript.rhino.jstype.UnknownType;\n \n import java.text.MessageFormat;\n       propNode = propNode == null ? n : propNode;\n \n       JSType found = propSlot.getType();\n+      found = found.restrictByNotNullOrUndefined();\n+\n       JSType required\n           = implementedInterface.getImplicitPrototype().getPropertyType(prop);\n-      found = found.restrictByNotNullOrUndefined();\n+      TemplateTypeMap typeMap = implementedInterface.getTemplateTypeMap();\n+      if (!typeMap.isEmpty()) {\n+        TemplateTypeMapReplacer replacer = new TemplateTypeMapReplacer(\n+            typeRegistry, typeMap);\n+        required = required.visit(replacer);\n+      }\n       required = required.restrictByNotNullOrUndefined();\n+\n       if (!found.isSubtype(required)) {\n         // Implemented, but not correctly typed\n         FunctionType constructor =\n--- a/src/com/google/javascript/rhino/jstype/FunctionType.java\n+++ b/src/com/google/javascript/rhino/jstype/FunctionType.java\n     if (baseType.hasReferenceName() ||\n         isNativeObjectType() ||\n         baseType.isFunctionPrototypeType()) {\n+      typeOfThis.extendTemplateTypeMap(baseType.getTemplateTypeMap());\n       baseType = new PrototypeObjectType(\n           registry, getReferenceName() + \".prototype\", baseType);\n     }\n     throws UnsupportedOperationException {\n     if (isInterface()) {\n       this.extendedInterfaces = ImmutableList.copyOf(extendedInterfaces);\n+      for (ObjectType extendedInterface : this.extendedInterfaces) {\n+        typeOfThis.extendTemplateTypeMap(\n+            extendedInterface.getTemplateTypeMap());\n+      }\n     } else {\n       throw new UnsupportedOperationException();\n     }\n--- a/src/com/google/javascript/rhino/jstype/JSType.java\n+++ b/src/com/google/javascript/rhino/jstype/JSType.java\n \n   private boolean resolved = false;\n   private JSType resolveResult = null;\n-  protected final TemplateTypeMap templateTypeMap;\n+  protected TemplateTypeMap templateTypeMap;\n \n   private boolean inTemplatedCheckVisit = false;\n   private static final CanCastToVisitor CAN_CAST_TO_VISITOR =\n    */\n   public TemplateTypeMap getTemplateTypeMap() {\n     return templateTypeMap;\n+  }\n+\n+  /**\n+   * Extends the template type map associated with this type, merging in the\n+   * keys and values of the specified map.\n+   */\n+  public void extendTemplateTypeMap(TemplateTypeMap otherMap) {\n+    templateTypeMap = templateTypeMap.extend(otherMap);\n   }\n \n   /**\n--- a/src/com/google/javascript/rhino/jstype/JSTypeRegistry.java\n+++ b/src/com/google/javascript/rhino/jstype/JSTypeRegistry.java\n    *     to indicate that the parameter types are unknown.\n    * @param returnType the function's return type or {@code null} to indicate\n    *     that the return type is unknown.\n-   * @param templateKeyNames the templatized type keys for the class.\n+   * @param templateKeys the templatized types for the class.\n    */\n   public FunctionType createConstructorType(String name, Node source,\n-      Node parameters, JSType returnType, ImmutableList<String> templateKeyNames) {\n-    return createConstructorTypeInternal(name, source, parameters, returnType,\n-        createTemplateMapKeys(templateKeyNames));\n-  }\n-\n-  private FunctionType createConstructorTypeInternal(String name, Node source,\n       Node parameters, JSType returnType, ImmutableList<TemplateType> templateKeys) {\n     return new FunctionType(this, name, source,\n         createArrowType(parameters, returnType), null,\n    * @param name the function's name\n    * @param source the node defining this function. Its type\n    *     ({@link Node#getType()}) must be {@link Token#FUNCTION}.\n+   * @param templateKeys the templatized types for the interface.\n    */\n   public FunctionType createInterfaceType(String name, Node source,\n-      ImmutableList<String> typeParameters) {\n-    return createInterfaceTypeInternal(name, source,\n-        createTemplateMapKeys(typeParameters));\n-  }\n-\n-  private FunctionType createInterfaceTypeInternal(String name, Node source,\n-      ImmutableList<TemplateType> typeParameters) {\n+      ImmutableList<TemplateType> templateKeys) {\n     return FunctionType.forInterface(this, name, source,\n-        createTemplateTypeMap(typeParameters, null));\n+        createTemplateTypeMap(templateKeys, null));\n   }\n \n   public TemplateType createTemplateType(String name) {\n--- a/src/com/google/javascript/rhino/jstype/TemplateTypeMap.java\n+++ b/src/com/google/javascript/rhino/jstype/TemplateTypeMap.java\n   }\n \n   /**\n+   * Returns true if the map is empty; false otherwise.\n+   */\n+  public boolean isEmpty() {\n+    return templateKeys.isEmpty();\n+  }\n+\n+  /**\n    * Returns a list of all template keys.\n    */\n   public ImmutableList<TemplateType> getTemplateKeys() {\n   }\n \n   /**\n-   * Returns a new TemplateTypeMap whose keys have been extended with the\n-   * specified list.\n-   */\n-  TemplateTypeMap extendKeys(ImmutableList<TemplateType> newKeys) {\n+   * Extends this TemplateTypeMap with the contents of the specified map.\n+   * UNKNOWN_TYPE will be used as the value for any missing values in the\n+   * specified map.\n+   */\n+  TemplateTypeMap extend(TemplateTypeMap thatMap) {\n+    thatMap = thatMap.addUnknownValues();\n     return registry.createTemplateTypeMap(\n-        concatImmutableLists(templateKeys, newKeys), templateValues);\n+        concatImmutableLists(thatMap.templateKeys, templateKeys),\n+        concatImmutableLists(thatMap.templateValues, templateValues));\n   }\n \n   /**\n    * Returns a new TemplateTypeMap whose values have been extended with the\n    * specified list.\n    */\n-  TemplateTypeMap extendValues(ImmutableList<JSType> newValues) {\n+  TemplateTypeMap addValues(ImmutableList<JSType> newValues) {\n     // Ignore any new template values that will not align with an existing\n     // template key.\n     int numUnfilledKeys = numUnfilledTemplateKeys();\n   }\n \n   /**\n+   * Returns a new TemplateTypeMap, where all unfilled values have been filled\n+   * with UNKNOWN_TYPE.\n+   */\n+  private TemplateTypeMap addUnknownValues() {\n+    int numUnfilledTemplateKeys = numUnfilledTemplateKeys();\n+    if (numUnfilledTemplateKeys == 0) {\n+      return this;\n+    }\n+\n+    ImmutableList.Builder<JSType> builder = ImmutableList.builder();\n+    for (int i = 0; i < numUnfilledTemplateKeys; i++) {\n+      builder.add(registry.getNativeType(JSTypeNative.UNKNOWN_TYPE));\n+    }\n+    return addValues(builder.build());\n+  }\n+\n+  /**\n    * Concatenates two ImmutableList instances. If either input is empty, the\n    * other is returned; otherwise, a new ImmutableList instance is created that\n    * contains the contents of both arguments.\n--- a/src/com/google/javascript/rhino/jstype/TemplatizedType.java\n+++ b/src/com/google/javascript/rhino/jstype/TemplatizedType.java\n   TemplatizedType(\n       JSTypeRegistry registry, ObjectType objectType,\n       ImmutableList<JSType> templateTypes) {\n-    super(registry, objectType, objectType.getTemplateTypeMap().extendValues(\n+    super(registry, objectType, objectType.getTemplateTypeMap().addValues(\n         templateTypes));\n \n     // Cache which template keys were filled, and what JSTypes they were filled\n--- a/test/com/google/javascript/jscomp/TypeCheckTest.java\n+++ b/test/com/google/javascript/jscomp/TypeCheckTest.java\n         \"foo.bar();\");\n   }\n \n+  /**\n+   * Verify that templatized interfaces can extend one another and share\n+   * template values.\n+   */\n+  public void testInterfaceInheritanceCheck14() throws Exception {\n+    testTypes(\n+        \"/** @interface\\n @classTemplate T */function A() {};\" +\n+        \"/** @desc description\\n @return {T} */A.prototype.foo = function() {};\" +\n+        \"/** @interface\\n @classTemplate U\\n @extends {A.<U>} */function B() {};\" +\n+        \"/** @desc description\\n @return {U} */B.prototype.bar = function() {};\" +\n+        \"/** @constructor\\n @implements {B.<string>} */function C() {};\" +\n+        \"/** @return {string}\\n @override */C.prototype.foo = function() {};\" +\n+        \"/** @return {string}\\n @override */C.prototype.bar = function() {};\");\n+  }\n+\n+  /**\n+   * Verify that templatized instances can correctly implement templatized\n+   * interfaces.\n+   */\n+  public void testInterfaceInheritanceCheck15() throws Exception {\n+    testTypes(\n+        \"/** @interface\\n @classTemplate T */function A() {};\" +\n+        \"/** @desc description\\n @return {T} */A.prototype.foo = function() {};\" +\n+        \"/** @interface\\n @classTemplate U\\n @extends {A.<U>} */function B() {};\" +\n+        \"/** @desc description\\n @return {U} */B.prototype.bar = function() {};\" +\n+        \"/** @constructor\\n @classTemplate V\\n @implements {B.<V>}\\n */function C() {};\" +\n+        \"/** @return {V}\\n @override */C.prototype.foo = function() {};\" +\n+        \"/** @return {V}\\n @override */C.prototype.bar = function() {};\");\n+  }\n+\n   public void testInterfacePropertyNotImplemented() throws Exception {\n     testTypes(\n         \"/** @interface */function Int() {};\" +\n         \"/** @interface \\n @extends {Int} */function Int2() {};\" +\n         \"/** @constructor\\n @implements {Int2} */function Foo() {};\",\n         \"property foo on interface Int is not implemented by type Foo\");\n+  }\n+\n+  /**\n+   * Verify that templatized interfaces enforce their template type values.\n+   */\n+  public void testInterfacePropertyNotImplemented3() throws Exception {\n+    testTypes(\n+        \"/** @interface\\n @classTemplate T */function Int() {};\" +\n+        \"/** @desc description\\n @return {T} */Int.prototype.foo = function() {};\" +\n+        \"/** @constructor\\n @implements {Int.<string>} */function Foo() {};\" +\n+        \"/** @return {number}\\n @override */Foo.prototype.foo = function() {};\",\n+        \"mismatch of the foo property type and the type of the property it \" +\n+        \"overrides from interface Int\\n\" +\n+        \"original: function (this:Int): string\\n\" +\n+        \"override: function (this:Foo): number\");\n   }\n \n   public void testStubConstructorImplementingInterface() throws Exception {\n--- a/test/com/google/javascript/jscomp/TypedScopeCreatorTest.java\n+++ b/test/com/google/javascript/jscomp/TypedScopeCreatorTest.java\n     assertEquals(\"T\", findNameType(\"local\", lastLocalScope).toString());\n   }\n \n+  public void testClassTemplateInheritance1() {\n+    // Verify that template type inheritance works for prototype properties.\n+    testSame(\n+        \"/**\\n\" +\n+        \" * @constructor\\n\" +\n+        \" * @classTemplate T\\n\" +\n+        \" */\\n\" +\n+        \"function C() {};\\n\" +\n+        \"\" +\n+        \"/** @type {T} */\" +\n+        \"C.prototype.foo = 1;\\n\" +\n+        \"\" +\n+        \"/**\\n\" +\n+        \" * @constructor\\n\" +\n+        \" * @classTemplate T, U\\n\" +\n+        \" * @extends {C.<U>}\" +\n+        \" */\\n\" +\n+        \"function D() {};\\n\" +\n+        \"\" +\n+        \"/** @type {T} */\" +\n+        \"D.prototype.bar;\\n\" +\n+        \"\" +\n+        \"/** @type {D.<string, number>} */ var x = new D();\\n\" +\n+        \"var result1 = x.foo;\\n\" +\n+        \"var result2 = x.bar;\\n\");\n+    assertEquals(\"number\", findNameType(\"result1\", globalScope).toString());\n+    assertEquals(\"string\", findNameType(\"result2\", globalScope).toString());\n+  }\n+\n+  public void testClassTemplateInheritance2() {\n+    // Verify that template type inheritance works for properties and methods.\n+    testSame(\n+        \"/**\\n\" +\n+        \" * @constructor\\n\" +\n+        \" * @classTemplate T\\n\" +\n+        \" */\\n\" +\n+        \"function C() {};\\n\" +\n+        \"\" +\n+        \"/** @return {T} */\\n\" +\n+        \"C.prototype.method1 = function() {}\\n\" +\n+        \"\" +\n+        \"/**\\n\" +\n+        \" * @constructor\\n\" +\n+        \" * @classTemplate T, U\\n\" +\n+        \" * @extends {C.<U>}\" +\n+        \" */\\n\" +\n+        \"function D() {};\\n\" +\n+        \"\" +\n+        \"/** @return {T} */\\n\" +\n+        \"D.prototype.method2 = function() {}\\n\" +\n+        \"\" +\n+        \"/** @type {D.<boolean, string>} */ var x = new D();\\n\" +\n+        \"var result1 = x.method1();\\n\" +\n+        \"var result2 = x.method2();\\n\");\n+    assertEquals(\"string\", findNameType(\"result1\", globalScope).toString());\n+    assertEquals(\"boolean\", findNameType(\"result2\", globalScope).toString());\n+  }\n+\n+  public void testClassTemplateInheritance3() {\n+    // Verify that template type inheritance works when the superclass template\n+    // types are not specified.\n+    testSame(\n+        \"/**\\n\" +\n+        \" * @constructor\\n\" +\n+        \" * @classTemplate T\\n\" +\n+        \" */\\n\" +\n+        \"function C() {\\n\" +\n+        \"  /** @type {T} */\\n\" +\n+        \"  this.foo;\" +\n+        \"};\\n\" +\n+        \"\" +\n+        \"/**\\n\" +\n+        \" * @constructor\\n\" +\n+        \" * @classTemplate T\\n\" +\n+        \" * @extends {C}\" +\n+        \" */\\n\" +\n+        \"function D() {\\n\" +\n+        \"  /** @type {T} */\\n\" +\n+        \"  this.bar;\" +\n+        \"};\\n\" +\n+        \"\" +\n+        \"/** @type {D.<boolean>} */ var x = new D();\\n\" +\n+        \"var result1 = x.foo;\\n\" +\n+        \"var result2 = x.bar;\\n\");\n+    assertEquals(\"?\", findNameType(\"result1\", globalScope).toString());\n+    assertEquals(\"boolean\", findNameType(\"result2\", globalScope).toString());\n+  }\n+\n+  public void testClassTemplateInheritance4() {\n+    // Verify that overriding methods works with template type inheritance.\n+    testSame(\n+        \"/**\\n\" +\n+        \" * @constructor\\n\" +\n+        \" * @classTemplate T\\n\" +\n+        \" */\\n\" +\n+        \"function C() {};\\n\" +\n+        \"\" +\n+        \"/** @return {T} */\\n\" +\n+        \"C.prototype.method = function() {}\\n\" +\n+        \"\" +\n+        \"/**\\n\" +\n+        \" * @constructor\\n\" +\n+        \" * @classTemplate T, U\\n\" +\n+        \" * @extends {C.<U>}\" +\n+        \" */\\n\" +\n+        \"function D() {};\\n\" +\n+        \"\" +\n+        \"/** @override */\\n\" +\n+        \"D.prototype.method = function() {}\\n\" +\n+        \"\" +\n+        \"/** @type {D.<boolean, string>} */ var x = new D();\\n\" +\n+        \"var result = x.method();\\n\");\n+    assertEquals(\"string\", findNameType(\"result\", globalScope).toString());\n+  }\n+\n+  public void testClassTemplateInheritance5() {\n+    // Verify that overriding methods works with template type inheritance.\n+    testSame(\n+        \"/**\\n\" +\n+        \" * @constructor\\n\" +\n+        \" * @classTemplate T\\n\" +\n+        \" */\\n\" +\n+        \"function C() {};\\n\" +\n+        \"\" +\n+        \"/** @return {T} */\\n\" +\n+        \"C.prototype.method1 = function() {}\\n\" +\n+        \"\" +\n+        \"/**\\n\" +\n+        \" * @constructor\\n\" +\n+        \" * @classTemplate T, U\\n\" +\n+        \" * @extends {C.<U>}\" +\n+        \" */\\n\" +\n+        \"function D() {};\\n\" +\n+        \"\" +\n+        \"/** @return {T} */\\n\" +\n+        \"D.prototype.method2 = function() {}\\n\" +\n+        \"\" +\n+        \"/** @type {D.<string, boolean>} */ var x = new D();\\n\" +\n+        \"/** @type {C.<boolean>} */ var y = x;\\n\" +\n+        \"/** @type {C} */ var z = y;\\n\" +\n+        \"var result1 = x.method2();\\n\" +\n+        \"var result2 = y.method1();\\n\" +\n+        \"var result3 = z.method1();\\n\");\n+    assertEquals(\"string\", findNameType(\"result1\", globalScope).toString());\n+    assertEquals(\"boolean\", findNameType(\"result2\", globalScope).toString());\n+    assertEquals(\"T\", findNameType(\"result3\", globalScope).toString());\n+  }\n+\n   public void testClosureParameterTypesWithoutJSDoc() {\n     testSame(\n         \"/**\\n\" +\n--- a/test/com/google/javascript/rhino/jstype/FunctionTypeTest.java\n+++ b/test/com/google/javascript/rhino/jstype/FunctionTypeTest.java\n \n   public void testSubtypeWithInterfaceThisType() {\n     FunctionType iface = registry.createInterfaceType(\"I\", null,\n-        ImmutableList.<String>of());\n+        ImmutableList.<TemplateType>of());\n     FunctionType ifaceReturnBoolean = new FunctionBuilder(registry)\n         .withParamsNode(registry.createParameters())\n         .withTypeOfThis(iface.getInstanceType())\n \n   public void testInterfacePrototypeChain1() {\n     FunctionType iface = registry.createInterfaceType(\"I\", null,\n-        ImmutableList.<String>of());\n+        ImmutableList.<TemplateType>of());\n     assertTypeEquals(\n         iface.getPrototype(),\n         iface.getInstanceType().getImplicitPrototype());\n \n   public void testInterfacePrototypeChain2() {\n     FunctionType iface = registry.createInterfaceType(\"I\", null,\n-        ImmutableList.<String>of());\n+        ImmutableList.<TemplateType>of());\n     iface.getPrototype().defineDeclaredProperty(\n         \"numberProp\", NUMBER_TYPE, null);\n \n     FunctionType subIface = registry.createInterfaceType(\"SubI\", null,\n-        ImmutableList.<String>of());\n+        ImmutableList.<TemplateType>of());\n     subIface.setExtendedInterfaces(\n         Lists.<ObjectType>newArrayList(iface.getInstanceType()));\n     assertTypeEquals(\n     assertTrue(subIfaceInst.hasProperty(\"numberProp\"));\n     assertTrue(subIfaceInst.isPropertyTypeDeclared(\"numberProp\"));\n     assertFalse(subIfaceInst.isPropertyTypeInferred(\"numberProp\"));\n+  }\n+\n+  public void testInterfacePrototypeChain3() {\n+    TemplateType templateT = registry.createTemplateType(\"T\");\n+    FunctionType iface = registry.createInterfaceType(\"I\", null,\n+        ImmutableList.of(templateT));\n+    iface.getPrototype().defineDeclaredProperty(\n+        \"genericProp\", templateT, null);\n+\n+    FunctionType subIface = registry.createInterfaceType(\"SubI\", null,\n+        ImmutableList.<TemplateType>of());\n+    subIface.setExtendedInterfaces(\n+        Lists.<ObjectType>newArrayList(iface.getInstanceType()));\n+    assertTypeEquals(\n+        subIface.getPrototype(),\n+        subIface.getInstanceType().getImplicitPrototype());\n+    assertTypeEquals(\n+        OBJECT_TYPE,\n+        subIface.getPrototype().getImplicitPrototype());\n+\n+    ObjectType subIfaceInst = subIface.getInstanceType();\n+    assertTrue(subIfaceInst.hasProperty(\"genericProp\"));\n+    assertTrue(subIfaceInst.isPropertyTypeDeclared(\"genericProp\"));\n+    assertFalse(subIfaceInst.isPropertyTypeInferred(\"genericProp\"));\n+    assertEquals(templateT, subIfaceInst.getPropertyType(\"genericProp\"));\n   }\n \n   private void assertLeastSupertype(String s, JSType t1, JSType t2) {\n \n   public void testSetImplementsOnInterface() {\n     FunctionType iface = registry.createInterfaceType(\"I\", null,\n-        ImmutableList.<String>of());\n+        ImmutableList.<TemplateType>of());\n     FunctionType subIface = registry.createInterfaceType(\"SubI\", null,\n-        ImmutableList.<String>of());\n+        ImmutableList.<TemplateType>of());\n     try {\n       subIface.setImplementedInterfaces(\n           ImmutableList.of(iface.getInstanceType()));\n--- a/test/com/google/javascript/rhino/jstype/JSTypeTest.java\n+++ b/test/com/google/javascript/rhino/jstype/JSTypeTest.java\n \n   public void testTemplatizedType() throws Exception {\n     FunctionType templatizedCtor = registry.createConstructorType(\n-        \"TestingType\", null, null, UNKNOWN_TYPE, ImmutableList.of(\"A\", \"B\"));\n+        \"TestingType\", null, null, UNKNOWN_TYPE, ImmutableList.of(\n+            registry.createTemplateType(\"A\"),\n+            registry.createTemplateType(\"B\")));\n     JSType templatizedInstance = registry.createTemplatizedType(\n         templatizedCtor.getInstanceType(),\n         ImmutableList.of(NUMBER_TYPE, STRING_TYPE));\n \n   public void testPartiallyTemplatizedType() throws Exception {\n     FunctionType templatizedCtor = registry.createConstructorType(\n-        \"TestingType\", null, null, UNKNOWN_TYPE, ImmutableList.of(\"A\", \"B\"));\n+        \"TestingType\", null, null, UNKNOWN_TYPE, ImmutableList.of(\n+            registry.createTemplateType(\"A\"),\n+            registry.createTemplateType(\"B\")));\n     JSType templatizedInstance = registry.createTemplatizedType(\n         templatizedCtor.getInstanceType(),\n         ImmutableList.of(NUMBER_TYPE));\n--- a/test/com/google/javascript/rhino/jstype/TemplatizedTypeTest.java\n+++ b/test/com/google/javascript/rhino/jstype/TemplatizedTypeTest.java\n \n   public void testCustomTemplatizedType() throws Exception {\n     FunctionType ctor = registry.createConstructorType(\n-        \"Foo\", null, null, null, ImmutableList.of(\"T\", \"U\"));\n+        \"Foo\", null, null, null, ImmutableList.of(\n+            registry.createTemplateType(\"T\"),\n+            registry.createTemplateType(\"U\")));\n     ObjectType baseType = ctor.getInstanceType();\n \n     JSType templatizedType1 = registry.createTemplatizedType(", "timestamp": 1363820895, "metainfo": ""}