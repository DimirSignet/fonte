{"sha": "6ba7fd9137b8b15f32fcb332f946a0951eb3fe6e", "log": "Put change handler in Loop. Currently, the same handler is used by all passes. This is a bug, named passes don't reset the handler so once it changes it stays there until the next PhaseOptimizer is created. The message in the tracer is used by no-one. The handler is never removed when the PhaseOptimizer is no longer needed (tiny mem leak). ------------- Created by MOE: http://code.google.com/p/moe-java MOE_MIGRATED_REVID=42965629", "commit": "\n--- a/src/com/google/javascript/jscomp/PhaseOptimizer.java\n+++ b/src/com/google/javascript/jscomp/PhaseOptimizer.java\n \n   private final AbstractCompiler compiler;\n   private final PerformanceTracker tracker;\n-  private final CodeChangeHandler recentChange = new CodeChangeHandler();\n   private boolean loopMutex = false;\n   private PassFactory sanityCheck = null;\n   private boolean printAstHashcodes = false;\n     this.compiler = compiler;\n     this.tracker = tracker;\n     this.progressRange = progressRange;\n-    compiler.addChangeHandler(recentChange);\n   }\n \n   /**\n     @Override\n     public void process(Node externs, Node root) {\n       logger.fine(name);\n-      tracer = newTracer();\n+      if (tracker != null) {\n+        tracker.recordPassStart(name, factory.isOneTimePass());\n+      }\n+      tracer = new Tracer(\"JSCompiler\");\n       // Delay the creation of the actual pass until *after* all previous passes\n       // have been processed.\n       // Some precondition checks rely on this, eg, in CoalesceVariableNames.\n       factory.create(compiler).process(externs, root);\n-      endPass(externs, root);\n-    }\n-\n-    /**\n-     * Marks the end of a pass.\n-     */\n-    private void endPass(Node externs, Node root) {\n       try {\n         if (progressRange == null) {\n           compiler.setProgress(-1, name);\n         throw new RuntimeException(\"Sanity check failed for \" + name, e);\n       }\n     }\n-\n-    /**\n-     * Returns a new tracer for the given pass name.\n-     */\n-    private Tracer newTracer() {\n-      String comment = name +\n-          (recentChange.hasCodeChanged() ? \" on recently changed AST\" : \"\");\n-      if (tracker != null) {\n-        tracker.recordPassStart(name, factory.isOneTimePass());\n-      }\n-      return new Tracer(\"JSCompiler\", comment);\n-    }\n   }\n \n   /**\n   class Loop implements CompilerPass {\n     private final List<NamedPass> myPasses = Lists.newArrayList();\n     private final Set<String> myNames = Sets.newHashSet();\n+    private CodeChangeHandler recentChange = new CodeChangeHandler();\n \n     void addLoopedPass(PassFactory factory) {\n       String name = factory.getName();\n         optimizePasses();\n       }\n \n+      compiler.addChangeHandler(recentChange);\n       // Contains a pass iff it made changes the last time it was run.\n       Set<NamedPass> madeChanges = new HashSet<NamedPass>();\n       // Contains a pass iff it was run during the last inner loop.\n         }\n       } finally {\n         loopMutex = false;\n+        compiler.removeChangeHandler(recentChange);\n       }\n     }\n ", "timestamp": 1361570296, "metainfo": ""}