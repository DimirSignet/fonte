{"sha": "8936be78f9ecad965b20fbf9ea78eda49514454e", "log": "Create an explicit \"LifeCycleStage\", so that we can have more stages besides normalized and unnormalized.  R=johnlenz DELTA=82  (18 added, 35 deleted, 29 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=158   ", "commit": "\n--- a/src/com/google/javascript/jscomp/AbstractCompiler.java\n+++ b/src/com/google/javascript/jscomp/AbstractCompiler.java\n public abstract class AbstractCompiler implements SourceExcerptProvider {\n   static final DiagnosticType READ_ERROR = DiagnosticType.error(\n       \"JSC_READ_ERROR\", \"Cannot read: {0}\");\n+\n+  private LifeCycleStage stage = LifeCycleStage.RAW;\n \n   // TODO(nicksantos): Decide if all of these are really necessary.\n   // Many of them are just accessors that should be passed to the\n   public abstract ReverseAbstractInterpreter getReverseAbstractInterpreter();\n \n   /**\n-   * @return Whether the normalization pass has been run.\n-   */\n-  abstract boolean isNormalized();\n+   * @return The current life-cycle stage of the AST we're working on.\n+   */\n+  LifeCycleStage getLifeCycleStage() {\n+    return stage;\n+  }\n \n   /**\n    * Generates unique ids.\n   abstract public ErrorManager getErrorManager();\n \n   /**\n-   * Set if the normalization pass has been done.\n-   * Note: non-private to enable test cases that require the Normalize pass.\n-   */\n-  abstract void setNormalized();\n-\n-  /**\n-   * Set once unnormalizing passes have been start.\n-   * Note: non-private to enable test cases that require the Normalize pass.\n-   */\n-  abstract void setUnnormalized();\n+   * Set the current life-cycle state.\n+   */\n+  void setLifeCycleStage(LifeCycleStage stage) {\n+    this.stage = stage;\n+  }\n \n   /**\n    * Are the nodes equal for the purpose of inlining?\n    * @return The error level the given error object will be reported at.\n    */\n   abstract CheckLevel getErrorLevel(JSError error);\n+\n+  static enum LifeCycleStage {\n+    RAW,\n+    NORMALIZED;\n+\n+    boolean isNormalized() {\n+      return this == NORMALIZED;\n+    }\n+  }\n }\n--- a/src/com/google/javascript/jscomp/AbstractPeepholeOptimization.java\n+++ b/src/com/google/javascript/jscomp/AbstractPeepholeOptimization.java\n     Preconditions.checkNotNull(currentTraversal);\n     Preconditions.checkNotNull(currentTraversal.getCompiler());\n \n-    return currentTraversal.getCompiler().isNormalized();\n+    return currentTraversal.getCompiler().getLifeCycleStage().isNormalized();\n   }\n \n   /**\n--- a/src/com/google/javascript/jscomp/AmbiguateProperties.java\n+++ b/src/com/google/javascript/jscomp/AmbiguateProperties.java\n \n   AmbiguateProperties(AbstractCompiler compiler,\n       char[] reservedCharacters) {\n-    Preconditions.checkState(compiler.isNormalized());\n+    Preconditions.checkState(compiler.getLifeCycleStage().isNormalized());\n     this.compiler = compiler;\n     this.reservedCharacters = reservedCharacters;\n \n--- a/src/com/google/javascript/jscomp/CoalesceVariableNames.java\n+++ b/src/com/google/javascript/jscomp/CoalesceVariableNames.java\n    * to foo, rename both variable to foo_bar.\n    */\n   CoalesceVariableNames(AbstractCompiler compiler, boolean usePseudoNames) {\n-    Preconditions.checkState(!compiler.isNormalized());\n+    Preconditions.checkState(!compiler.getLifeCycleStage().isNormalized());\n \n     this.compiler = compiler;\n     colorings = Lists.newLinkedList();\n--- a/src/com/google/javascript/jscomp/CollapseAnonymousFunctions.java\n+++ b/src/com/google/javascript/jscomp/CollapseAnonymousFunctions.java\n   private final AbstractCompiler compiler;\n \n   public CollapseAnonymousFunctions(AbstractCompiler compiler) {\n-    Preconditions.checkArgument(compiler.isNormalized());\n+    Preconditions.checkArgument(compiler.getLifeCycleStage().isNormalized());\n     this.compiler = compiler;\n   }\n \n--- a/src/com/google/javascript/jscomp/CollapseVariableDeclarations.java\n+++ b/src/com/google/javascript/jscomp/CollapseVariableDeclarations.java\n   private final Set<Node> nodesToCollapse = Sets.newHashSet();\n \n   CollapseVariableDeclarations(AbstractCompiler compiler) {\n-    Preconditions.checkState(!compiler.isNormalized());\n+    Preconditions.checkState(!compiler.getLifeCycleStage().isNormalized());\n     this.compiler = compiler;\n   }\n \n--- a/src/com/google/javascript/jscomp/Compiler.java\n+++ b/src/com/google/javascript/jscomp/Compiler.java\n    */\n   private int uniqueNameId = 0;\n \n-  /**\n-   * Whether the optional \"normalization\" pass has been run.  Passes that\n-   * depend on the assumptions made there should check this value.\n-   */\n-  private boolean normalized = false;\n-\n   /** Whether to use threads. */\n   private boolean useThreads = true;\n \n         return String.valueOf(self.nextUniqueNameId());\n       }\n     };\n-  }\n-\n-  /**\n-   * Set if the normalization pass has been done.\n-   * Note: non-private to enable test cases that require the Normalize pass.\n-   */\n-  @Override\n-  void setNormalized() {\n-    normalized = true;\n-  }\n-\n-  /**\n-   * Set once unnormalizing passes have been start.\n-   * Note: non-private to enable test cases that require the Normalize pass.\n-   */\n-  @Override\n-  void setUnnormalized() {\n-    normalized = false;\n-  }\n-\n-  @Override\n-  boolean isNormalized() {\n-    return normalized;\n   }\n \n   @Override\n     private List<JSModule> modules;\n     private PassConfig.State passConfigState;\n     private JSTypeRegistry typeRegistry;\n-    private boolean normalized;\n+    private AbstractCompiler.LifeCycleStage lifeCycleStage;\n \n     private IntermediateState() {}\n   }\n     state.modules = modules;\n     state.passConfigState = getPassConfig().getIntermediateState();\n     state.typeRegistry = typeRegistry;\n-    state.normalized = normalized;\n+    state.lifeCycleStage = getLifeCycleStage();\n \n     return state;\n   }\n     passes = createPassConfigInternal();\n     getPassConfig().setIntermediateState(state.passConfigState);\n     typeRegistry = state.typeRegistry;\n-    normalized = state.normalized;\n+    setLifeCycleStage(state.lifeCycleStage);\n   }\n \n   @VisibleForTesting\n--- a/src/com/google/javascript/jscomp/ConstCheck.java\n+++ b/src/com/google/javascript/jscomp/ConstCheck.java\n \n   @Override\n   public void process(Node externs, Node root) {\n-    Preconditions.checkState(compiler.isNormalized());\n+    Preconditions.checkState(compiler.getLifeCycleStage().isNormalized());\n     NodeTraversal.traverse(compiler, root, this);\n   }\n \n--- a/src/com/google/javascript/jscomp/DefaultPassConfig.java\n+++ b/src/com/google/javascript/jscomp/DefaultPassConfig.java\n import com.google.common.collect.Maps;\n import com.google.common.collect.Sets;\n import com.google.common.io.Files;\n+import com.google.javascript.jscomp.AbstractCompiler.LifeCycleStage;\n import com.google.javascript.jscomp.NodeTraversal.Callback;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n     protected CompilerPass createInternal(final AbstractCompiler compiler) {\n       return new CompilerPass() {\n         @Override public void process(Node externs, Node root) {\n-          compiler.setUnnormalized();\n+          compiler.setLifeCycleStage(LifeCycleStage.RAW);\n         }\n       };\n     }\n--- a/src/com/google/javascript/jscomp/FunctionInjector.java\n+++ b/src/com/google/javascript/jscomp/FunctionInjector.java\n   Node inline(\n       NodeTraversal t, Node callNode, String fnName, Node fnNode,\n       InliningMode mode) {\n-    Preconditions.checkState(compiler.isNormalized());\n+    Preconditions.checkState(compiler.getLifeCycleStage().isNormalized());\n \n     if (mode == InliningMode.DIRECT) {\n       return inlineReturnValue(callNode, fnNode);\n--- a/src/com/google/javascript/jscomp/GatherRawExports.java\n+++ b/src/com/google/javascript/jscomp/GatherRawExports.java\n \n   @Override\n   public void process(Node externs, Node root) {\n-    Preconditions.checkState(compiler.isNormalized());\n+    Preconditions.checkState(compiler.getLifeCycleStage().isNormalized());\n     NodeTraversal.traverse(compiler, root, this);\n   }\n \n--- a/src/com/google/javascript/jscomp/InlineFunctions.java\n+++ b/src/com/google/javascript/jscomp/InlineFunctions.java\n \n   @Override\n   public void process(Node externs, Node root) {\n-    Preconditions.checkState(compiler.isNormalized());\n+    Preconditions.checkState(compiler.getLifeCycleStage().isNormalized());\n \n     NodeTraversal.traverse(compiler, root, new FindCandidateFunctions());\n     if (fns.isEmpty()) {\n--- a/src/com/google/javascript/jscomp/Normalize.java\n+++ b/src/com/google/javascript/jscomp/Normalize.java\n import com.google.common.collect.Lists;\n import com.google.common.collect.Maps;\n import com.google.common.collect.Sets;\n+import com.google.javascript.jscomp.AbstractCompiler.LifeCycleStage;\n import com.google.javascript.jscomp.MakeDeclaredNamesUnique.BoilerplateRenamer;\n import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n import com.google.javascript.jscomp.NodeTraversal.Callback;\n     new PropagateConstantAnnotationsOverVars(compiler, assertOnChange)\n         .process(externs, root);\n \n-    compiler.setNormalized();\n+    compiler.setLifeCycleStage(LifeCycleStage.NORMALIZED);\n   }\n \n   /**\n--- a/src/com/google/javascript/jscomp/SanityCheck.java\n+++ b/src/com/google/javascript/jscomp/SanityCheck.java\n   }\n \n   private void sanityCheckVars(Node externs, Node root) {\n-    if (compiler.isNormalized()) {\n+    if (compiler.getLifeCycleStage().isNormalized()) {\n       (new VarCheck(compiler, true)).process(externs, root);\n     }\n   }\n     // Exceptions into Errors so that it is easier to find the root cause\n     // when there are cascading issues.\n     new PrepareAst(compiler, true).process(null, root);\n-    if (compiler.isNormalized()) {\n+    if (compiler.getLifeCycleStage().isNormalized()) {\n       (new Normalize(compiler, true)).process(externs, root);\n \n       boolean checkUserDeclarations = true;\n--- a/src/com/google/javascript/jscomp/UnfoldCompoundAssignments.java\n+++ b/src/com/google/javascript/jscomp/UnfoldCompoundAssignments.java\n    */\n   @Override\n   public void process(Node externs, Node root) {\n-    Preconditions.checkState(compiler.isNormalized(),\n+    Preconditions.checkState(compiler.getLifeCycleStage().isNormalized(),\n         \"UnfoldCompoundAssignments requires a normalized AST\");\n     NodeTraversal.traverse(compiler, root, this);\n   }\n--- a/test/com/google/javascript/jscomp/FunctionInjectorTest.java\n+++ b/test/com/google/javascript/jscomp/FunctionInjectorTest.java\n package com.google.javascript.jscomp;\n \n import com.google.common.collect.Sets;\n+import com.google.javascript.jscomp.AbstractCompiler.LifeCycleStage;\n import com.google.javascript.jscomp.FunctionInjector.CanInlineResult;\n import com.google.javascript.jscomp.FunctionInjector.InliningMode;\n import com.google.javascript.jscomp.NodeTraversal.Callback;\n \n     Normalize normalize = new Normalize(compiler, false);\n     normalize.process(externsRoot, mainRoot);\n-    compiler.setNormalized();\n+    compiler.setLifeCycleStage(LifeCycleStage.NORMALIZED);\n \n     final Node fnNode = findFunction(tree, fnName);\n     assertNotNull(fnNode);\n--- a/test/com/google/javascript/jscomp/FunctionToBlockMutatorTest.java\n+++ b/test/com/google/javascript/jscomp/FunctionToBlockMutatorTest.java\n package com.google.javascript.jscomp;\n \n import com.google.common.base.Preconditions;\n+import com.google.javascript.jscomp.AbstractCompiler.LifeCycleStage;\n import com.google.javascript.jscomp.NodeTraversal.Callback;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n         FunctionArgumentInjector.findModifiedParameters(fnNode);\n \n     // Fake precondition.\n-    compiler.setNormalized();\n+    compiler.setLifeCycleStage(LifeCycleStage.NORMALIZED);\n \n     // inline tester\n     Method tester = new Method() {\n--- a/test/com/google/javascript/jscomp/SanityCheckTest.java\n+++ b/test/com/google/javascript/jscomp/SanityCheckTest.java\n \n package com.google.javascript.jscomp;\n \n+import com.google.javascript.jscomp.AbstractCompiler.LifeCycleStage;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n-\n \n /**\n  * @author nicksantos@google.com (Nick Santos)\n   public void testUnnormalized() throws Exception {\n     otherPass = new CompilerPass() {\n       @Override public void process(Node externs, Node root) {\n-        getLastCompiler().setNormalized();\n+        getLastCompiler().setLifeCycleStage(LifeCycleStage.NORMALIZED);\n       }\n     };\n \n         Node name = Node.newString(Token.NAME, \"x\");\n         name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n         root.addChildToBack(new Node(Token.EXPR_RESULT, name));\n-        getLastCompiler().setNormalized();\n+        getLastCompiler().setLifeCycleStage(LifeCycleStage.NORMALIZED);\n       }\n     };\n ", "timestamp": 1292534434, "metainfo": ""}