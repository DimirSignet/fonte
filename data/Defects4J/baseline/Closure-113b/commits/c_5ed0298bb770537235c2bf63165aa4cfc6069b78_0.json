{"sha": "5ed0298bb770537235c2bf63165aa4cfc6069b78", "log": "Fix various eclipse warnings. ------------- Created by MOE: http://code.google.com/p/moe-java MOE_MIGRATED_REVID=46797763", "commit": "\n--- a/src/com/google/javascript/jscomp/AnalyzeNameReferences.java\n+++ b/src/com/google/javascript/jscomp/AnalyzeNameReferences.java\n /**\n  * Analyzes names and references usage by determining:\n  * <p><ol>\n- * <li>If the name is reachable from the {@link NameReferenceGraph#MAIN}.</li>\n+ * <li>If the name is reachable from the {@link NameReferenceGraph#main}.</li>\n  * <li>as well as the deepest common module that references it.</li>\n  * </ol>\n  *\n--- a/src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java\n+++ b/src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java\n     //    name are given a special [anonymous] context.\n     // 2) Every assignment of a prototype property of a non-function is\n     //    given a name context. These contexts do not have scopes.\n-    private Stack<NameContext> symbolStack = new Stack<NameContext>();\n+    private final Stack<NameContext> symbolStack = new Stack<NameContext>();\n \n     @Override\n     public void enterScope(NodeTraversal t) {\n--- a/src/com/google/javascript/jscomp/AngularPass.java\n+++ b/src/com/google/javascript/jscomp/AngularPass.java\n   final AbstractCompiler compiler;\n \n   /** Nodes annotated with @ngInject */\n-  private List<NodeContext> injectables = new ArrayList<NodeContext>();\n+  private final List<NodeContext> injectables = new ArrayList<NodeContext>();\n \n   public AngularPass(AbstractCompiler compiler) {\n     this.compiler = compiler;\n \n   class NodeContext {\n     /** Name of the function/object. */\n-    private String name;\n+    private final String name;\n     /** Node jsDoc is attached to. */\n-    private Node node;\n+    private final Node node;\n     /** Function node */\n-    private Node functionNode;\n+    private final Node functionNode;\n     /** Node after which to inject the new code */\n-    private Node target;\n+    private final Node target;\n \n     public NodeContext(String name, Node node, Node functionNode, Node target) {\n       this.name = name;\n--- a/src/com/google/javascript/jscomp/CallGraph.java\n+++ b/src/com/google/javascript/jscomp/CallGraph.java\n import com.google.common.collect.ImmutableList;\n import com.google.common.collect.Maps;\n import com.google.javascript.jscomp.DefinitionsRemover.Definition;\n-import com.google.javascript.jscomp.NameReferenceGraph.Name;\n import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n import com.google.javascript.jscomp.graph.DiGraph;\n import com.google.javascript.jscomp.graph.LinkedDirectedGraph;\n  * @author dcc@google.com (Devin Coughlin)\n  */\n public class CallGraph implements CompilerPass {\n-  private AbstractCompiler compiler;\n+  private final AbstractCompiler compiler;\n \n   /**\n    * Maps an AST node (with type Token.CALL or Token.NEW) to a Callsite object.\n    */\n-  private Map<Node, Callsite> callsitesByNode;\n+  private final Map<Node, Callsite> callsitesByNode;\n \n   /** Maps an AST node (with type Token.FUNCTION) to a Function object. */\n-  private Map<Node, Function> functionsByNode;\n+  private final Map<Node, Function> functionsByNode;\n \n   /**\n    * Will the call graph support looking up the callsites that could call a\n    * given function?\n    */\n-  private boolean computeBackwardGraph;\n+  private final boolean computeBackwardGraph;\n \n   /**\n    * Will the call graph support looking up the functions that a given callsite\n    * can call?\n    */\n-  private boolean computeForwardGraph;\n-\n-  /**\n-   * If true, then the callgraph will use NameReferenceGraph as a\n-   * definition provider; otherwise, use the faster SimpleDefinitionProvider.\n-   */\n-  private boolean useNameReferenceGraph = false;\n+  private final boolean computeForwardGraph;\n \n   /** Has the CallGraph already been constructed? */\n   private boolean alreadyRun = false;\n    * functions that are actually called.\n    */\n   private void fillInFunctionInformation(DefinitionProvider provider) {\n-    if (useNameReferenceGraph) {\n-      NameReferenceGraph referenceGraph = (NameReferenceGraph) provider;\n-\n-      for (Function function : getAllFunctions()) {\n-        if (!function.isMain()) {\n-          String functionName = function.getName();\n-\n-          if (functionName != null) {\n-            Name symbol = referenceGraph.getSymbol(functionName);\n-            updateFunctionForName(function, symbol);\n-          }\n-        }\n-      }\n-    } else {\n-      SimpleDefinitionFinder finder = (SimpleDefinitionFinder) provider;\n-\n-      for (DefinitionSite definitionSite : finder.getDefinitionSites()) {\n-        Definition definition = definitionSite.definition;\n-\n-        Function function = lookupFunctionForDefinition(definition);\n-\n-        if (function != null) {\n-          for (UseSite useSite : finder.getUseSites(definition)) {\n-            updateFunctionForUse(function, useSite.node);\n-          }\n-        }\n-      }\n-    }\n-  }\n-\n-  /**\n-   * Updates {@link Function} information (such as whether is is aliased\n-   * or exposed to .apply or .call from a {@link NameReferenceGraph.Name}.\n-   *\n-   * Note: this method may be called multiple times per Function, each time\n-   * with a different name.\n-   */\n-  private void updateFunctionForName(Function function, Name name) {\n-    if (name.isAliased()) {\n-      function.isAliased = true;\n-    }\n-\n-    if (name.exposedToCallOrApply()) {\n-      function.isExposedToCallOrApply = true;\n+    SimpleDefinitionFinder finder = (SimpleDefinitionFinder) provider;\n+\n+    for (DefinitionSite definitionSite : finder.getDefinitionSites()) {\n+      Definition definition = definitionSite.definition;\n+\n+      Function function = lookupFunctionForDefinition(definition);\n+\n+      if (function != null) {\n+        for (UseSite useSite : finder.getUseSites(definition)) {\n+          updateFunctionForUse(function, useSite.node);\n+        }\n+      }\n     }\n   }\n \n    * Constructs a DefinitionProvider that can be used to determine the\n    * targets of callsites.\n    *\n-   * This construction is the main cost of building the callgraph, so we offer\n-   * the client a choice of NameReferenceGraph, which is slow and hopefully more\n-   * precise, and SimpleDefinitionFinder, which is fast and perhaps not as\n-   * precise.\n-   *\n-   * We use SimpleNameFinder as the default because in practice it does\n+   * We use SimpleNameFinder because in practice it does\n    * not appear to be less precise than NameReferenceGraph and is at least an\n    * order of magnitude faster on large compiles.\n    */\n   private DefinitionProvider constructDefinitionProvider(Node externsRoot,\n         Node jsRoot) {\n-    if (useNameReferenceGraph) {\n-      // Name reference graph is very, very slow\n-      NameReferenceGraphConstruction graphConstruction\n-          = new NameReferenceGraphConstruction(compiler);\n-\n-      graphConstruction.process(externsRoot, jsRoot);\n-\n-      return graphConstruction.getNameReferenceGraph();\n-    } else {\n-      SimpleDefinitionFinder defFinder = new SimpleDefinitionFinder(compiler);\n-      defFinder.process(externsRoot, jsRoot);\n-      return defFinder;\n-    }\n+    SimpleDefinitionFinder defFinder = new SimpleDefinitionFinder(compiler);\n+    defFinder.process(externsRoot, jsRoot);\n+    return defFinder;\n   }\n \n   /**\n \n     Node targetExpression = callsite.getFirstChild();\n \n-    // NameReferenceGraph throws an exception unless the node is\n-    // a GETPROP or a NAME\n-    if (!useNameReferenceGraph\n-        || (targetExpression.isGetProp()\n-        ||  targetExpression.isName())) {\n-\n-      Collection<Definition> definitions =\n+    Collection<Definition> definitions =\n         definitionProvider.getDefinitionsReferencedAt(targetExpression);\n \n-      if (definitions != null && !definitions.isEmpty()) {\n-        return definitions;\n-      }\n+    if (definitions != null && !definitions.isEmpty()) {\n+      return definitions;\n     }\n \n     return null;\n    */\n   public class Function {\n \n-    private Node astNode;\n+    private final Node astNode;\n \n     private boolean isAliased = false;\n \n    * Function is, and what its target Functions are.\n    */\n   public class Callsite {\n-    private Node astNode;\n+    private final Node astNode;\n \n     private boolean hasUnknownTarget = false;\n     private boolean hasExternTarget = false;\n--- a/src/com/google/javascript/jscomp/CommandLineRunner.java\n+++ b/src/com/google/javascript/jscomp/CommandLineRunner.java\n \n     options.closurePass = flags.processClosurePrimitives;\n \n-    options.jqueryPass = flags.processJqueryPrimitives &&\n-        CompilationLevel.ADVANCED_OPTIMIZATIONS == level;\n+    options.jqueryPass = CompilationLevel.ADVANCED_OPTIMIZATIONS == level &&\n+        flags.processJqueryPrimitives;\n \n     options.angularPass = flags.angularPass;\n \n--- a/src/com/google/javascript/jscomp/DotFormatter.java\n+++ b/src/com/google/javascript/jscomp/DotFormatter.java\n   private static final String LINE = \" -- \";\n \n   // stores the current assignment of node to keys\n-  private HashMap<Node, Integer> assignments = new HashMap<Node, Integer>();\n+  private final HashMap<Node, Integer> assignments = new HashMap<Node, Integer>();\n \n   // key count in order to assign a unique key to each node\n   private int keyCount = 0;\n \n   // the builder used to generate the dot diagram\n-  private Appendable builder;\n+  private final Appendable builder;\n \n   private final ControlFlowGraph<Node> cfg;\n \n--- a/src/com/google/javascript/jscomp/LinkedFlowScope.java\n+++ b/src/com/google/javascript/jscomp/LinkedFlowScope.java\n     }\n \n     return slots;\n+  }\n+\n+  @Override\n+  public int hashCode() {\n+    throw new UnsupportedOperationException();\n   }\n \n   /**\n--- a/src/com/google/javascript/jscomp/MustBeReachingVariableDef.java\n+++ b/src/com/google/javascript/jscomp/MustBeReachingVariableDef.java\n     public String toString() {\n       return \"Definition@\" + node.toString();\n     }\n+\n+    @Override\n+    public int hashCode() {\n+      return node.hashCode();\n+    }\n   }\n \n   /**\n     public boolean equals(Object other) {\n       return (other instanceof MustDef) &&\n           ((MustDef) other).reachingDef.equals(this.reachingDef);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+      return reachingDef.hashCode();\n     }\n   }\n \n--- a/src/com/google/javascript/jscomp/OptimizeParameters.java\n+++ b/src/com/google/javascript/jscomp/OptimizeParameters.java\n     implements CompilerPass, OptimizeCalls.CallGraphCompilerPass {\n \n   private final AbstractCompiler compiler;\n-  private List<Node> removedNodes = Lists.newArrayList();\n+  private final List<Node> removedNodes = Lists.newArrayList();\n \n   OptimizeParameters(AbstractCompiler compiler) {\n     this.compiler = compiler;\n--- a/src/com/google/javascript/jscomp/RenameVars.java\n+++ b/src/com/google/javascript/jscomp/RenameVars.java\n     // If prevUsedRenameMap had duplicate values then this pass would be\n     // non-deterministic.\n     // In such a case, the following will throw an IllegalArgumentException.\n-    Preconditions.checkState(\n-        prevUsedRenameMap.getNewNameToOriginalNameMap() instanceof Map);\n+    Preconditions.checkNotNull(prevUsedRenameMap.getNewNameToOriginalNameMap());\n     for (Assignment a : assignments.values()) {\n       String prevNewName = prevUsedRenameMap.lookupNewName(a.oldName);\n       if (prevNewName == null || reservedNames.contains(prevNewName)) {\n--- a/src/com/google/javascript/jscomp/RenameVars2.java\n+++ b/src/com/google/javascript/jscomp/RenameVars2.java\n     // If prevUsedRenameMap had duplicate values then this pass would be\n     // non-deterministic.\n     // In such a case, the following will throw an IllegalArgumentException.\n-    Preconditions.checkState(\n-        prevUsedRenameMap.getNewNameToOriginalNameMap() instanceof Map);\n+    Preconditions.checkNotNull(prevUsedRenameMap.getNewNameToOriginalNameMap());\n     for (Assignment a : assignments.values()) {\n       String prevNewName = prevUsedRenameMap.lookupNewName(a.oldName);\n       if (prevNewName == null || reservedNames.contains(prevNewName)) {\n--- a/src/com/google/javascript/jscomp/Tracer.java\n+++ b/src/com/google/javascript/jscomp/Tracer.java\n    * Converts 'v' to a string and pads it with up to 16 spaces for\n    * improved alignment.\n    * @param v The value to convert.\n-   * @param digits_column_width The desired with of the string.\n+   * @param digitsColumnWidth The desired with of the string.\n    */\n   private static String longToPaddedString(long v, int digitsColumnWidth) {\n     int digitWidth = numDigits(v);\n    * Stop the trace.\n    * This may only be done once and must be done from the same thread\n    * that started it.\n-   * @param silence_threshold Traces for time less than silence_threshold\n+   * @param silenceThreshold Traces for time less than silence_threshold\n    * ms will be left out of the trace report. A value of -1 indicates\n    * that the current ThreadTrace silence_threshold should be used.\n    * @return The time that this trace actually ran\n    *\n    */\n   static final class AtomicTracerStatMap {\n-    private ConcurrentMap<String, Long> map =\n+    private final ConcurrentMap<String, Long> map =\n         new ConcurrentHashMap<String, Long>();\n \n     /**\n--- a/src/com/google/javascript/jscomp/TypeInferencePass.java\n+++ b/src/com/google/javascript/jscomp/TypeInferencePass.java\n \n   private final AbstractCompiler compiler;\n   private final ReverseAbstractInterpreter reverseInterpreter;\n-  private Scope topScope;\n-  private MemoizedScopeCreator scopeCreator;\n+  private final Scope topScope;\n+  private final MemoizedScopeCreator scopeCreator;\n   private final Map<String, AssertionFunctionSpec> assertionFunctionsMap;\n \n   TypeInferencePass(AbstractCompiler compiler,\n         compiler, new FirstScopeBuildingCallback(), scopeCreator))\n         .traverseWithScope(node, topScope);\n \n-    Preconditions.checkState(scopeCreator instanceof MemoizedScopeCreator);\n-    for (Scope s :\n-           ((MemoizedScopeCreator) scopeCreator).getAllMemoizedScopes()) {\n+    for (Scope s : scopeCreator.getAllMemoizedScopes()) {\n       s.resolveTypes();\n     }\n \n--- a/src/com/google/javascript/jscomp/deps/SimpleDependencyInfo.java\n+++ b/src/com/google/javascript/jscomp/deps/SimpleDependencyInfo.java\n         + \"provides=%3$s, requires=%4$s)\", srcPathRelativeToClosure,\n         pathOfDefiningFile, provides, requires);\n   }\n+\n+  @Override\n+  public int hashCode() {\n+    int hash = 1;\n+    hash = hash * 3 + (srcPathRelativeToClosure == null ?\n+        0 : srcPathRelativeToClosure.hashCode());\n+    hash = hash * 5 + (pathOfDefiningFile == null ?\n+        0 : pathOfDefiningFile.hashCode());\n+    hash = hash * 7 + (requires == null ? 0 : requires.hashCode());\n+    hash = hash * 11 + (provides == null ? 0 : provides.hashCode());\n+    return hash;\n+  }\n }\n--- a/src/com/google/javascript/jscomp/parsing/IRFactory.java\n+++ b/src/com/google/javascript/jscomp/parsing/IRFactory.java\n \n   // Use a template node for properties set on all nodes to minimize the\n   // memory footprint associated with these.\n-  private Node templateNode;\n+  private final Node templateNode;\n \n   // TODO(johnlenz): Consider creating a template pool for ORIGINALNAME_PROP.\n \n    * function f(/** string &#42;/ x) {}\n    * annotates 'x' as a string.\n    *\n-   * @see http://code.google.com/p/jsdoc-toolkit/wiki/InlineDocs\n+   * @see <a href=\"http://code.google.com/p/jsdoc-toolkit/wiki/InlineDocs\">\n+   *   Using Inline Doc Comments</a>\n    */\n   private Node transformParameter(AstNode node) {\n     Node irNode = justTransform(node);\n--- a/test/com/google/javascript/jscomp/DataFlowAnalysisTest.java\n+++ b/test/com/google/javascript/jscomp/DataFlowAnalysisTest.java\n    * A variable.\n    */\n   static class Variable extends Value {\n-    private String name;\n+    private final String name;\n \n     /**\n      * Constructor.\n    * A number constant.\n    */\n   static class Number extends Value {\n-    private int value;\n+    private final int value;\n \n     /**\n      * Constructor\n             this.constMap.equals(otherLattice.constMap);\n       }\n       return false;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+      return constMap.hashCode();\n     }\n   }\n \n--- a/test/com/google/javascript/jscomp/RenameVars2Test.java\n+++ b/test/com/google/javascript/jscomp/RenameVars2Test.java\n \n \n /**\n- * Tests for {@link Rename2Vars}.\n+ * Tests for {@link RenameVars2}.\n  */\n public class RenameVars2Test extends CompilerTestCase {\n   private static final String DEFAULT_PREFIX = \"\";\n--- a/test/com/google/javascript/jscomp/VariableMapTest.java\n+++ b/test/com/google/javascript/jscomp/VariableMapTest.java\n     }\n   }\n \n-  public void testReverseThrowsErrorOnDuplicate() throws ParseException {\n+  public void testReverseThrowsErrorOnDuplicate() {\n     VariableMap vm = new VariableMap(ImmutableMap.of(\"AA\", \"b\", \"BB\", \"b\"));\n     try {\n       vm.getNewNameToOriginalNameMap();\n     }\n   }\n \n-  public void testReverseLookupOfNullFindsNoName() throws ParseException {\n+  public void testReverseLookupOfNullFindsNoName() {\n     VariableMap vm = new VariableMap(ImmutableMap.of(\"AA\", \"a\", \"BB\", \"b\"));\n     assertNull(vm.lookupSourceName(null));\n   }\n--- a/test/com/google/javascript/rhino/JSDocInfoTest.java\n+++ b/test/com/google/javascript/rhino/JSDocInfoTest.java\n import junit.framework.TestCase;\n \n public class JSDocInfoTest extends TestCase {\n-  private TestErrorReporter errorReporter = new TestErrorReporter(null, null);\n-  private JSTypeRegistry registry = new JSTypeRegistry(errorReporter);\n+  private final TestErrorReporter errorReporter = new TestErrorReporter(null, null);\n+  private final JSTypeRegistry registry = new JSTypeRegistry(errorReporter);\n \n   private JSType getNativeType(JSTypeNative typeId) {\n     return registry.getNativeType(typeId);", "timestamp": 1368838241, "metainfo": ""}