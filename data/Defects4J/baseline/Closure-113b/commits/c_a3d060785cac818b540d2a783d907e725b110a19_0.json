{"sha": "a3d060785cac818b540d2a783d907e725b110a19", "log": "Implement goog.getMsgWithFallback  R=johnlenz DELTA=213  (190 added, 5 deleted, 18 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=5573   ", "commit": "\n--- a/src/com/google/javascript/jscomp/JSError.java\n+++ b/src/com/google/javascript/jscomp/JSError.java\n  */\n package com.google.javascript.jscomp;\n \n-import com.google.javascript.jscomp.CheckLevel;\n import com.google.javascript.rhino.Node;\n \n import javax.annotation.Nullable;\n   public static JSError make(String sourceName, Node n,\n                              DiagnosticType type, String... arguments) {\n     return new JSError(sourceName, n, type, arguments);\n+  }\n+\n+  /**\n+   * Creates a JSError from a file and Node position.\n+   *\n+   * @param n Determines the line and char position and source file name\n+   * @param type The DiagnosticType\n+   * @param arguments Arguments to be incorporated into the message\n+   */\n+  public static JSError make(Node n, DiagnosticType type, String... arguments) {\n+    return new JSError(n.getSourceFileName(), n, type, arguments);\n   }\n \n   /**\n--- a/src/com/google/javascript/jscomp/JsMessageExtractor.java\n+++ b/src/com/google/javascript/jscomp/JsMessageExtractor.java\n     }\n \n     @Override\n-    protected void processJsMessage(JsMessage message,\n+    void processJsMessage(JsMessage message,\n         JsMessageDefinition definition) {\n       if (!message.isExternal()) {\n         messages.add(message);\n--- a/src/com/google/javascript/jscomp/JsMessageVisitor.java\n+++ b/src/com/google/javascript/jscomp/JsMessageVisitor.java\n \n package com.google.javascript.jscomp;\n \n+import static com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n+\n import com.google.common.base.CaseFormat;\n import com.google.common.collect.Maps;\n import com.google.common.collect.Sets;\n import com.google.javascript.jscomp.JsMessage.Builder;\n-import static com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n+import com.google.javascript.jscomp.Scope.Var;\n import com.google.javascript.rhino.JSDocInfo;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n     implements CompilerPass {\n \n   private static final String MSG_FUNCTION_NAME = \"goog.getMsg\";\n+  private static final String MSG_FALLBACK_FUNCTION_NAME =\n+      \"goog.getMsgWithFallback\";\n \n   static final DiagnosticType MESSAGE_HAS_NO_DESCRIPTION =\n       DiagnosticType.warning(\"JSC_MSG_HAS_NO_DESCRIPTION\",\n   static final DiagnosticType MESSAGE_NOT_INITIALIZED_USING_NEW_SYNTAX =\n       DiagnosticType.error(\"JSC_MSG_NOT_INITIALIZED_USING_NEW_SYNTAX\",\n           \"message not initialized using \" + MSG_FUNCTION_NAME);\n+\n+  static final DiagnosticType BAD_FALLBACK_SYNTAX =\n+      DiagnosticType.error(\"JSC_MSG_BAD_FALLBACK_SYNTAX\",\n+          String.format(\n+              \"Bad syntax. \" +\n+              \"Expected syntax: goog.getMsgWithFallback(MSG_1, MSG_2)\",\n+              MSG_FALLBACK_FUNCTION_NAME));\n+\n+  static final DiagnosticType FALLBACK_ARG_ERROR =\n+      DiagnosticType.error(\"JSC_MSG_FALLBACK_ARG_ERROR\",\n+          \"Could not find message entry for fallback argument {0}\");\n \n   private static final String PH_JS_PREFIX = \"{$\";\n   private static final String PH_JS_SUFFIX = \"}\";\n   private final Map<String, MessageLocation> messageNames =\n       Maps.newHashMap();\n \n+  private final Map<Var, JsMessage> unnamedMessages =\n+      Maps.newHashMap();\n+\n   /**\n    * List of found goog.getMsg call nodes.\n    *\n         break;\n       case Token.CALL:\n         // goog.getMsg()\n-        if (MSG_FUNCTION_NAME.equals(node.getFirstChild().getQualifiedName())) {\n+        String fnName = node.getFirstChild().getQualifiedName();\n+        if (MSG_FUNCTION_NAME.equals(fnName)) {\n           googMsgNodes.put(node, traversal.getSourceName());\n+        } else if (MSG_FALLBACK_FUNCTION_NAME.equals(fnName)) {\n+          visitFallbackFunctionCall(traversal, node);\n         }\n         return;\n       default:\n     if (needToCheckDuplications\n         && !isUnnamedMsg\n         && !extractedMessage.isExternal()) {\n-      checkIfMessageDuplicated(traversal.getSourceName(), messageKey, msgNode);\n-    }\n+      checkIfMessageDuplicated(extractedMessage, messageKey, msgNode);\n+    }\n+    trackMessage(traversal, extractedMessage,\n+        messageKey, msgNode, isUnnamedMsg);\n \n     if (extractedMessage.isEmpty()) {\n       // value of the message is an empty string. Translators do not like it.\n   }\n \n   /**\n+   * Track a message for later retrieval.\n+   *\n+   * This is used for tracking duplicates, and for figuring out message\n+   * fallback. Not all message types are trackable, because that would\n+   * require a more sophisticated analysis. e.g.,\n+   * function f(s) { s.MSG_UNNAMED_X = 'Some untrackable message'; }\n+   */\n+  private void trackMessage(\n+      NodeTraversal t, JsMessage message, String msgName,\n+      Node msgNode, boolean isUnnamedMessage) {\n+    if (!isUnnamedMessage) {\n+      MessageLocation location = new MessageLocation(message, msgNode);\n+      messageNames.put(msgName, location);\n+    } else if (msgNode.isName()) {\n+      Var var = t.getScope().getVar(msgName);\n+      if (var != null) {\n+        unnamedMessages.put(var, message);\n+      }\n+    }\n+  }\n+\n+  /** Get a previously tracked message. */\n+  private JsMessage getTrackedMessage(NodeTraversal t, String msgName) {\n+    boolean isUnnamedMessage = isUnnamedMessageName(msgName);\n+    if (!isUnnamedMessage) {\n+      MessageLocation location = messageNames.get(msgName);\n+      return location == null ? null : location.message;\n+    } else {\n+      Var var = t.getScope().getVar(msgName);\n+      if (var != null) {\n+        return unnamedMessages.get(var);\n+      }\n+    }\n+    return null;\n+  }\n+\n+  /**\n    * Checks if message already processed. If so - it generates 'message\n    * duplicated' compiler error.\n    *\n    * @param msgName the name of the message\n    * @param msgNode the node that represents JS message\n    */\n-  private void checkIfMessageDuplicated(String sourceName, String msgName,\n+  private void checkIfMessageDuplicated(JsMessage message, String msgName,\n       Node msgNode) {\n     if (messageNames.containsKey(msgName)) {\n       MessageLocation location = messageNames.get(msgName);\n-      compiler.report(JSError.make(sourceName, msgNode, MESSAGE_DUPLICATE_KEY,\n-          msgName, location.sourceName, Integer.toString(location.lineNo)));\n-    } else {\n-      MessageLocation location =\n-          new MessageLocation(sourceName, msgNode.getLineno());\n-      messageNames.put(msgName, location);\n+      compiler.report(JSError.make(msgNode, MESSAGE_DUPLICATE_KEY,\n+          msgName, location.messageNode.getSourceFileName(),\n+          Integer.toString(location.messageNode.getLineno())));\n     }\n   }\n \n     }\n   }\n \n+  /** Visit a call to goog.getMsgWithFallback. */\n+  private void visitFallbackFunctionCall(NodeTraversal t, Node call) {\n+    // Check to make sure the function call looks like:\n+    // goog.getMsgWithFallback(MSG_1, MSG_2);\n+    if (call.getChildCount() != 3 ||\n+        !call.getChildAtIndex(1).isName() ||\n+        !call.getChildAtIndex(2).isName()) {\n+      compiler.report(t.makeError(call, BAD_FALLBACK_SYNTAX));\n+      return;\n+    }\n+\n+    Node firstArg = call.getChildAtIndex(1);\n+    JsMessage firstMessage = getTrackedMessage(t, firstArg.getString());\n+    if (firstMessage == null) {\n+      compiler.report(\n+          t.makeError(firstArg, FALLBACK_ARG_ERROR, firstArg.getString()));\n+      return;\n+    }\n+\n+    Node secondArg = firstArg.getNext();\n+    JsMessage secondMessage = getTrackedMessage(\n+        t, call.getChildAtIndex(2).getString());\n+    if (secondMessage == null) {\n+      compiler.report(\n+          t.makeError(secondArg, FALLBACK_ARG_ERROR, secondArg.getString()));\n+      return;\n+    }\n+\n+    processMessageFallback(call, firstMessage, secondMessage);\n+  }\n+\n \n   /**\n    * Processes found JS message. Several examples of \"standard\" processing\n    */\n   abstract void processJsMessage(JsMessage message,\n       JsMessageDefinition definition);\n+\n+  /**\n+   * Processes the goog.getMsgWithFallback primitive.\n+   * goog.getMsgWithFallback(MSG_1, MSG_2);\n+   *\n+   * By default, does nothing.\n+   */\n+  void processMessageFallback(Node callNode, JsMessage message1,\n+      JsMessage message2) {}\n \n   /**\n    * Returns whether the given JS identifier is a valid JS message name.\n   }\n \n   private static class MessageLocation {\n-    private final String sourceName;\n-    private final int lineNo;\n-\n-    private MessageLocation(String sourceName, int lineNo) {\n-      this.sourceName = sourceName;\n-      this.lineNo = lineNo;\n+    private final JsMessage message;\n+    private final Node messageNode;\n+\n+    private MessageLocation(JsMessage message, Node messageNode) {\n+      this.message = message;\n+      this.messageNode = messageNode;\n     }\n   }\n }\n--- a/src/com/google/javascript/jscomp/ReplaceMessages.java\n+++ b/src/com/google/javascript/jscomp/ReplaceMessages.java\n \n package com.google.javascript.jscomp;\n \n-import javax.annotation.Nullable;\n-\n+import com.google.common.collect.Iterables;\n import com.google.javascript.rhino.IR;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n \n import java.util.Iterator;\n+\n+import javax.annotation.Nullable;\n \n /**\n  * ReplaceMessages replaces user-visible messages with alternatives.\n   }\n \n   @Override\n-  protected void processJsMessage(JsMessage message,\n+  void processMessageFallback(\n+      Node callNode, JsMessage message1, JsMessage message2) {\n+    boolean isEmptyBundle = Iterables.isEmpty(bundle.getAllMessages());\n+    boolean isFirstMessageTranslated =\n+        (bundle.getMessage(message1.getId()) != null);\n+    Node replacementNode = isFirstMessageTranslated || isEmptyBundle ?\n+        callNode.getChildAtIndex(1) : callNode.getChildAtIndex(2);\n+    callNode.getParent().replaceChild(callNode,\n+        replacementNode.detachFromParent());\n+  }\n+\n+  @Override\n+  void processJsMessage(JsMessage message,\n       JsMessageDefinition definition) {\n \n     // Get the replacement.\n--- a/test/com/google/javascript/jscomp/ReplaceMessagesTest.java\n+++ b/test/com/google/javascript/jscomp/ReplaceMessagesTest.java\n          MESSAGE_TREE_MALFORMED);\n   }\n \n+  public void testBadFallbackSyntax1() {\n+    test(\"/** @desc d */\\n\" +\n+         \"var MSG_A = goog.getMsg('asdf');\" +\n+         \"var x = goog.getMsgWithFallback(MSG_A);\", null,\n+         JsMessageVisitor.BAD_FALLBACK_SYNTAX);\n+  }\n+\n+  public void testBadFallbackSyntax2() {\n+    test(\"var x = goog.getMsgWithFallback('abc', 'bcd');\", null,\n+         JsMessageVisitor.BAD_FALLBACK_SYNTAX);\n+  }\n+\n+  public void testBadFallbackSyntax3() {\n+    test(\"/** @desc d */\\n\" +\n+         \"var MSG_A = goog.getMsg('asdf');\" +\n+         \"var x = goog.getMsgWithFallback(MSG_A, y);\", null,\n+         JsMessageVisitor.FALLBACK_ARG_ERROR);\n+  }\n+\n+  public void testBadFallbackSyntax4() {\n+    test(\"/** @desc d */\\n\" +\n+         \"var MSG_A = goog.getMsg('asdf');\" +\n+         \"var x = goog.getMsgWithFallback(y, MSG_A);\", null,\n+         JsMessageVisitor.FALLBACK_ARG_ERROR);\n+  }\n+\n+  public void testUseFallback() {\n+    registerMessage(new JsMessage.Builder(\"MSG_B\")\n+        .appendStringPart(\"translated\")\n+        .build());\n+    test(\"/** @desc d */\\n\" +\n+         \"var MSG_A = goog.getMsg('msg A');\" +\n+         \"/** @desc d */\\n\" +\n+         \"var MSG_B = goog.getMsg('msg B');\" +\n+         \"var x = goog.getMsgWithFallback(MSG_A, MSG_B);\",\n+         \"var MSG_A = 'msg A';\" +\n+         \"var MSG_B = 'translated';\" +\n+         \"var x = MSG_B;\");\n+  }\n+\n+  public void testFallbackEmptyBundle() {\n+    test(\"/** @desc d */\\n\" +\n+         \"var MSG_A = goog.getMsg('msg A');\" +\n+         \"/** @desc d */\\n\" +\n+         \"var MSG_B = goog.getMsg('msg B');\" +\n+         \"var x = goog.getMsgWithFallback(MSG_A, MSG_B);\",\n+         \"var MSG_A = 'msg A';\" +\n+         \"var MSG_B = 'msg B';\" +\n+         \"var x = MSG_A;\");\n+  }\n+\n+  public void testNoUseFallback() {\n+    registerMessage(new JsMessage.Builder(\"MSG_A\")\n+        .appendStringPart(\"translated\")\n+        .build());\n+    test(\"/** @desc d */\\n\" +\n+         \"var MSG_A = goog.getMsg('msg A');\" +\n+         \"/** @desc d */\\n\" +\n+         \"var MSG_B = goog.getMsg('msg B');\" +\n+         \"var x = goog.getMsgWithFallback(MSG_A, MSG_B);\",\n+         \"var MSG_A = 'translated';\" +\n+         \"var MSG_B = 'msg B';\" +\n+         \"var x = MSG_A;\");\n+  }\n+\n   private void registerMessage(JsMessage message) {\n     messages.put(message.getKey(), message);\n   }\n \n     @Override\n     public Iterable<JsMessage> getAllMessages() {\n-      throw new UnsupportedOperationException();\n+      return messages.values();\n     }\n \n     @Override", "timestamp": 1349102099, "metainfo": ""}