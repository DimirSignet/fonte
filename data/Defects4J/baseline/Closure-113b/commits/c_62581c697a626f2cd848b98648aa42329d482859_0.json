{"sha": "62581c697a626f2cd848b98648aa42329d482859", "log": "All outputs (except the main output file) should be encoded in utf-8 by default. This includes: source maps bundles manifests  R=johnlenz,zhuyi DELTA=102  (78 added, 0 deleted, 24 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=3614   ", "commit": "\n--- a/src/com/google/javascript/jscomp/AbstractCommandLineRunner.java\n+++ b/src/com/google/javascript/jscomp/AbstractCommandLineRunner.java\n   private A compiler;\n \n   private Charset inputCharset;\n-  private String outputCharset;\n+\n+  // NOTE(nicksantos): JSCompiler has always used ASCII as the default\n+  // output charset. This was done to solve legacy problems with\n+  // bad proxies, etc. We are not sure if these issues are still problems,\n+  // and changing the encoding would require a big obnoxious migration plan.\n+  //\n+  // New outputs should use outputCharset2, which is how I would have\n+  // designed this if I had a time machine.\n+  private Charset outputCharset2;\n+  private String legacyOutputCharset;\n \n   private boolean testMode = false;\n   private Supplier<List<JSSourceFile>> externsSupplierForTesting = null;\n     options.setCodingConvention(config.codingConvention);\n     options.setSummaryDetailLevel(config.summaryDetailLevel);\n \n-    outputCharset = options.outputCharset = getOutputCharset();\n+    legacyOutputCharset = options.outputCharset = getLegacyOutputCharset();\n+    outputCharset2 = getOutputCharset2();\n     inputCharset = getInputCharset();\n \n     if (config.jsOutputFile.length() > 0) {\n \n     boolean writeOutputToFile = !options.jsOutputFile.isEmpty();\n     if (writeOutputToFile) {\n-      jsOutput = fileNameToOutputWriter(options.jsOutputFile);\n+      jsOutput = fileNameToLegacyOutputWriter(options.jsOutputFile);\n     } else if (jsOutput instanceof OutputStream) {\n-      jsOutput = streamToOutputWriter((OutputStream) jsOutput);\n+      jsOutput = streamToLegacyOutputWriter((OutputStream) jsOutput);\n     }\n \n     List<String> jsFiles = config.js;\n         Writer mapOut = null;\n \n         if (!shouldGenerateMapPerModule(options)) {\n-          mapOut = fileNameToOutputWriter(expandSourceMapPath(options, null));\n+          mapOut = fileNameToOutputWriter2(expandSourceMapPath(options, null));\n         }\n \n         for (JSModule m : modules) {\n           if (shouldGenerateMapPerModule(options)) {\n-            mapOut = fileNameToOutputWriter(expandSourceMapPath(options, m));\n+            mapOut = fileNameToOutputWriter2(expandSourceMapPath(options, m));\n           }\n \n-          Writer writer = fileNameToOutputWriter(getModuleOutputFileName(m));\n+          Writer writer =\n+              fileNameToLegacyOutputWriter(getModuleOutputFileName(m));\n \n           if (options.sourceMapOutputPath != null) {\n             compiler.getSourceMap().reset();\n    *    be a supported charset.\n    * @throws FlagUsageException if flag is not a valid Charset name.\n    */\n-  private String getOutputCharset() throws FlagUsageException {\n+  private String getLegacyOutputCharset() throws FlagUsageException {\n     if (!config.charset.isEmpty()) {\n       if (!Charset.isSupported(config.charset)) {\n         throw new FlagUsageException(config.charset +\n       return config.charset;\n     }\n     return \"US-ASCII\";\n+  }\n+\n+  /**\n+   * Query the flag for the output charset. Defaults to UTF-8.\n+   * @throws FlagUsageException if flag is not a valid Charset name.\n+   */\n+  private Charset getOutputCharset2() throws FlagUsageException {\n+    if (!config.charset.isEmpty()) {\n+      if (!Charset.isSupported(config.charset)) {\n+        throw new FlagUsageException(config.charset +\n+            \" is not a valid charset name.\");\n+      }\n+      return Charset.forName(config.charset);\n+    }\n+    return Charsets.UTF_8;\n   }\n \n   protected List<JSSourceFile> createExterns() throws FlagUsageException,\n       exPath = outputFile.getParent() + File.separatorChar + exPath;\n     }\n \n-    return fileNameToOutputWriter(exPath);\n+    return fileNameToOutputWriter2(exPath);\n   }\n \n   /**\n    * Converts a file name into a Writer taking in account the output charset.\n    * Returns null if the file name is null.\n    */\n-  private Writer fileNameToOutputWriter(String fileName) throws IOException {\n+  private Writer fileNameToLegacyOutputWriter(String fileName) throws IOException {\n     if (fileName == null) {\n       return null;\n     }\n       return new StringWriter();\n     }\n \n-    return streamToOutputWriter(filenameToOutputStream(fileName));\n+    return streamToLegacyOutputWriter(filenameToOutputStream(fileName));\n+  }\n+\n+  /**\n+   * Converts a file name into a Writer taking in account the output charset.\n+   * Returns null if the file name is null.\n+   */\n+  private Writer fileNameToOutputWriter2(String fileName) throws IOException {\n+    if (fileName == null) {\n+      return null;\n+    }\n+    if (testMode) {\n+      return new StringWriter();\n+    }\n+\n+    return streamToOutputWriter2(filenameToOutputStream(fileName));\n   }\n \n   /**\n   }\n \n   /**\n-   * Create a writer.\n-   */\n-  private Writer streamToOutputWriter(OutputStream stream)\n+   * Create a writer with the legacy output charset.\n+   */\n+  private Writer streamToLegacyOutputWriter(OutputStream stream)\n       throws IOException {\n-    if (outputCharset == null) {\n+    if (legacyOutputCharset == null) {\n       return new BufferedWriter(\n           new OutputStreamWriter(stream));\n     } else {\n       return new BufferedWriter(\n-          new OutputStreamWriter(stream, outputCharset));\n+          new OutputStreamWriter(stream, legacyOutputCharset));\n+    }\n+  }\n+\n+  /**\n+   * Create a writer with the newer output charset.\n+   */\n+  private Writer streamToOutputWriter2(OutputStream stream)\n+      throws IOException {\n+    if (outputCharset2 == null) {\n+      return new BufferedWriter(\n+          new OutputStreamWriter(stream));\n+    } else {\n+      return new BufferedWriter(\n+          new OutputStreamWriter(stream, outputCharset2));\n     }\n   }\n \n     }\n \n     String outName = expandSourceMapPath(options, null);\n-    Writer out = fileNameToOutputWriter(outName);\n+    Writer out = fileNameToOutputWriter2(outName);\n     compiler.getSourceMap().appendTo(out, associatedName);\n     out.close();\n   }\n         // Generate per-module manifests or bundles\n         Iterable<JSModule> modules = graph.getAllModules();\n         for (JSModule module : modules) {\n-          Writer out = fileNameToOutputWriter(\n+          Writer out = fileNameToOutputWriter2(\n               expandCommandLinePath(output, module));\n           if (isManifest) {\n             printManifestTo(module.getInputs(), out);\n         }\n       } else {\n         // Generate a single file manifest or bundle.\n-        Writer out = fileNameToOutputWriter(\n+        Writer out = fileNameToOutputWriter2(\n             expandCommandLinePath(output, null));\n         if (graph == null) {\n           if (isManifest) {", "timestamp": 1320352760, "metainfo": ""}