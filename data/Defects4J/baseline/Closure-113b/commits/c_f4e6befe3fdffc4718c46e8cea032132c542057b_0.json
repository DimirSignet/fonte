{"sha": "f4e6befe3fdffc4718c46e8cea032132c542057b", "log": "Tighten CheckRegExp so fewer false positives are generated. ------------- Created by MOE: http://code.google.com/p/moe-java MOE_MIGRATED_REVID=49111760", "commit": "\n--- a/src/com/google/javascript/jscomp/CheckRegExp.java\n+++ b/src/com/google/javascript/jscomp/CheckRegExp.java\n  */\n package com.google.javascript.jscomp;\n \n+import com.google.common.collect.ImmutableSet;\n import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n import com.google.javascript.jscomp.regex.RegExpTree;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n+\n+import java.util.Set;\n \n /**\n  * Look for references to the global RegExp object that would cause\n   static final DiagnosticType MALFORMED_REGEXP = DiagnosticType.warning(\n         \"JSC_MALFORMED_REGEXP\",\n         \"Malformed Regular Expression: {0}\");\n+\n+  private static final Set<String> REGEXP_PROPERTY_BLACKLIST = ImmutableSet.of(\n+      \"$1\", \"$2\", \"$3\", \"$4\", \"$5\", \"$6\", \"$7\", \"$8\", \"$9\",\n+      \"$_\", \"$input\",\n+      // The following would also be blacklisted, but they aren't valid\n+      // identifiers, so can't be accessed with the '.' operator anyway.\n+      // \"$*\", \"$&\", \"$+\", \"$`\", \"$'\",\n+      \"input\", \"lastMatch\", \"lastParen\", \"leftContext\", \"rightContext\",\n+      \"global\", \"ignoreCase\", \"lastIndex\", \"multiline\", \"source\");\n \n   private final AbstractCompiler compiler;\n   private boolean globalRegExpPropertiesUsed = false;\n         int parentType = parent.getType();\n         boolean first = (n == parent.getFirstChild());\n         if (!((parentType == Token.NEW && first)\n-               || (parentType == Token.CALL && first)\n-               || (parentType == Token.INSTANCEOF && !first))) {\n+            || (parentType == Token.CALL && first)\n+            || (parentType == Token.INSTANCEOF && !first)\n+            || parentType == Token.EQ || parentType == Token.NE\n+            || parentType == Token.SHEQ || parentType == Token.SHNE\n+            || parentType == Token.CASE\n+            || (parentType == Token.GETPROP && first\n+            && !REGEXP_PROPERTY_BLACKLIST.contains(\n+            parent.getLastChild().getString())))) {\n           t.report(n, REGEXP_REFERENCE);\n           globalRegExpPropertiesUsed = true;\n         }\n--- a/test/com/google/javascript/jscomp/CheckRegExpTest.java\n+++ b/test/com/google/javascript/jscomp/CheckRegExpTest.java\n   }\n \n   public void testRegExp() {\n-    // Creating regexp's is ok\n+    // Creating RegExp's is OK.\n     testReference(\"RegExp();\", false);\n     testReference(\"var x = RegExp();\", false);\n     testReference(\"new RegExp();\", false);\n     // Checking for RegExp instances is OK, as well.\n     testReference(\"x instanceof RegExp;\", false);\n \n-    // Any other reference isn't\n-    testReference(\"RegExp.test();\", true);\n-    testReference(\"var x = RegExp.test();\", true);\n-    testReference(\"RegExp.exec();\", true);\n+    // Comparing for equality with RegExp is OK.\n+    testReference(\"x === RegExp;\", false);\n+    testReference(\"x !== RegExp;\", false);\n+    testReference(\"switch (x) { case RegExp: }\", false);\n+    testReference(\"x == RegExp;\", false);\n+    testReference(\"x != RegExp;\", false);\n+\n+    // Access to non-magical properties is OK.\n+    testReference(\"RegExp.test();\", false);\n+    testReference(\"var x = RegExp.test();\", false);\n+    testReference(\"RegExp.exec();\", false);\n+    testReference(\"RegExp.foobar;\", false);\n+\n+    // Magical properties aren't allowed.\n     testReference(\"RegExp.$1;\", true);\n-    testReference(\"RegExp.foobar;\", true);\n+    testReference(\"RegExp.$_;\", true);\n+    testReference(\"RegExp.$input;\", true);\n+    testReference(\"RegExp.rightContext;\", true);\n+    testReference(\"RegExp.multiline;\", true);\n+\n+    // Any other reference isn't allowed.\n     testReference(\"delete RegExp;\", true);\n+    testReference(\"RegExp;\", true);\n+    testReference(\"if (RegExp);\", true);\n+    testReference(\"if (!RegExp);\", true);\n \n-    // Aliases aren't allowed\n+    // Aliases aren't allowed.\n     testReference(\"var x = RegExp;\", true);\n     testReference(\"f(RegExp);\", true);\n     testReference(\"new f(RegExp);\", true);\n     testReference(\"var x = RegExp; x.test()\", true);\n \n-    // No RegExp reference is ok\n+    // No RegExp reference is OK.\n     testReference(\"var x;\", false);\n \n-    // Local RegExp is ok\n+    // Local RegExp is OK.\n     testReference(\"function f() {var RegExp; RegExp.test();}\", false);\n+\n+    // Property named 'RegExp' is OK.\n+    testReference(\"var x = {RegExp: {}}; x.RegExp.$1;\", false);\n   }\n \n   public void testInvalidRange() {", "timestamp": 1373401941, "metainfo": ""}