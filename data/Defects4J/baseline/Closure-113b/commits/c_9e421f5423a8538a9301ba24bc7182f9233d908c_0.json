{"sha": "9e421f5423a8538a9301ba24bc7182f9233d908c", "log": "Allow local variables in goog.scope Fixes issue 1020 R=blickly", "commit": "\n--- a/src/com/google/javascript/jscomp/ScopedAliases.java\n+++ b/src/com/google/javascript/jscomp/ScopedAliases.java\n package com.google.javascript.jscomp;\n \n import com.google.common.base.Preconditions;\n+import com.google.common.collect.HashMultiset;\n import com.google.common.collect.Lists;\n import com.google.common.collect.Maps;\n+import com.google.common.collect.Multiset;\n import com.google.common.collect.Sets;\n import com.google.javascript.jscomp.CompilerOptions.AliasTransformation;\n import com.google.javascript.jscomp.CompilerOptions.AliasTransformationHandler;\n   static final DiagnosticType GOOG_SCOPE_NON_ALIAS_LOCAL = DiagnosticType.error(\n       \"JSC_GOOG_SCOPE_NON_ALIAS_LOCAL\",\n       \"The local variable {0} is in a goog.scope and is not an alias.\");\n+\n+  private Multiset<String> scopedAliasNames = HashMultiset.create();\n \n   ScopedAliases(AbstractCompiler compiler,\n       @Nullable PreprocessorSymbolTable preprocessorSymbolTable,\n     // normalization (before optimizations). We run it here on a limited\n     // set of variables, but only as a last resort (because this will screw\n     // up warning messages downstream).\n-    private final Set<String> forbiddenLocals = Sets.newHashSet();\n+    private final Set<String> forbiddenLocals = Sets.newHashSet(\"$jscomp\");\n     private boolean hasNamespaceShadows = false;\n \n     private boolean hasErrors = false;\n       for (Var v : scope.getVarIterable()) {\n         Node n = v.getNode();\n         Node parent = n.getParent();\n-        if (parent.isVar() &&\n-            n.hasChildren() && n.getFirstChild().isQualifiedName()) {\n-          String name = n.getString();\n-          Var aliasVar = scope.getVar(name);\n-          aliases.put(name, aliasVar);\n-\n-          String qualifiedName =\n-              aliasVar.getInitialValue().getQualifiedName();\n-          transformation.addAlias(name, qualifiedName);\n-\n-          int rootIndex = qualifiedName.indexOf(\".\");\n-          if (rootIndex != -1) {\n-            String qNameRoot = qualifiedName.substring(0, rootIndex);\n-            if (!aliases.containsKey(qNameRoot)) {\n-              forbiddenLocals.add(qNameRoot);\n-            }\n-          }\n+        boolean isVarAssign = parent.isVar() && n.hasChildren();\n+        if (isVarAssign && n.getFirstChild().isQualifiedName()) {\n+          recordAlias(v);\n         } else if (v.isBleedingFunction()) {\n           // Bleeding functions already get a BAD_PARAMETERS error, so just\n           // do nothing.\n         } else if (parent.getType() == Token.LP) {\n           // Parameters of the scope function also get a BAD_PARAMETERS\n           // error.\n+        } else if (isVarAssign) {\n+          Node value = v.getInitialValue().detachFromParent();\n+          String name = n.getString();\n+          int nameCount = scopedAliasNames.count(name);\n+          scopedAliasNames.add(name);\n+          String globalName =\n+              \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n+\n+          compiler.ensureLibraryInjected(\"base\");\n+\n+          // Add $jscomp.scope.name = EXPR;\n+          // Make sure we copy over all the jsdoc and debug info.\n+          Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(\n+              compiler.getCodingConvention(),\n+              globalName,\n+              value,\n+              v.getJSDocInfo())\n+              .useSourceInfoIfMissingFromForTree(n);\n+          NodeUtil.setDebugInformation(\n+              newDecl.getFirstChild().getFirstChild(), n, name);\n+          parent.getParent().addChildBefore(newDecl, parent);\n+\n+          // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n+          v.getNameNode().addChildToFront(\n+              NodeUtil.newQualifiedNameNode(\n+                  compiler.getCodingConvention(), globalName, n, name));\n+\n+          recordAlias(v);\n         } else {\n-          // TODO(robbyw): Support using locals for private variables.\n+          // Do not allow hoisted functions or other kinds of local symbols.\n           report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n+        }\n+      }\n+    }\n+\n+    private void recordAlias(Var aliasVar) {\n+      String name = aliasVar.getName();\n+      aliases.put(name, aliasVar);\n+\n+      String qualifiedName =\n+        aliasVar.getInitialValue().getQualifiedName();\n+      transformation.addAlias(name, qualifiedName);\n+\n+      int rootIndex = qualifiedName.indexOf(\".\");\n+      if (rootIndex != -1) {\n+        String qNameRoot = qualifiedName.substring(0, rootIndex);\n+        if (!aliases.containsKey(qNameRoot)) {\n+          forbiddenLocals.add(qNameRoot);\n         }\n       }\n     }\n--- a/test/com/google/javascript/jscomp/ScopedAliasesTest.java\n+++ b/test/com/google/javascript/jscomp/ScopedAliasesTest.java\n   private static final String GOOG_SCOPE_START_BLOCK =\n       \"goog.scope(function() {\";\n   private static final String GOOG_SCOPE_END_BLOCK = \"});\";\n+\n+  private static final String SCOPE_NAMESPACE =\n+      \"var $jscomp = {}; $jscomp.scope = {};\";\n \n   private static String EXTERNS = \"var window;\";\n \n   }\n \n   public void testNonAliasLocal() {\n-    testScopedFailure(\"var x = 10\", ScopedAliases.GOOG_SCOPE_NON_ALIAS_LOCAL);\n-    testScopedFailure(\"var x = goog.dom + 10\",\n-        ScopedAliases.GOOG_SCOPE_NON_ALIAS_LOCAL);\n-    testScopedFailure(\"var x = goog['dom']\",\n-        ScopedAliases.GOOG_SCOPE_NON_ALIAS_LOCAL);\n-    testScopedFailure(\"var x = goog.dom, y = 10\",\n-        ScopedAliases.GOOG_SCOPE_NON_ALIAS_LOCAL);\n     testScopedFailure(\"function f() {}\",\n         ScopedAliases.GOOG_SCOPE_NON_ALIAS_LOCAL);\n+  }\n+\n+  public void testOkAliasLocal() {\n+    testScoped(\"var x = 10;\",\n+               SCOPE_NAMESPACE + \"$jscomp.scope.x = 10\");\n+    testScoped(\"var x = goog['dom'];\",\n+               SCOPE_NAMESPACE + \"$jscomp.scope.x = goog['dom']\");\n+    testScoped(\"var x = 10, y = 9;\",\n+               SCOPE_NAMESPACE + \"$jscomp.scope.x = 10; $jscomp.scope.y = 9;\");\n+    testScoped(\"var x = 10, y = 9; goog.getX = function () { return x + y; }\",\n+               SCOPE_NAMESPACE + \"$jscomp.scope.x = 10; $jscomp.scope.y = 9;\" +\n+               \"goog.getX = function () { \" +\n+               \"    return $jscomp.scope.x + $jscomp.scope.y; }\");\n+  }\n+\n+  public void testAliasReassign() {\n+    testScopedFailure(\"var x = 3; x = 5;\",\n+        ScopedAliases.GOOG_SCOPE_ALIAS_REDEFINED);\n+  }\n+\n+  public void testMultipleLocals() {\n+    test(\"goog.scope(function () { var x = 3; });\" +\n+         \"goog.scope(function () { var x = 4; });\",\n+         SCOPE_NAMESPACE + \"$jscomp.scope.x = 3; $jscomp.scope.x$1 = 4\");\n   }\n \n   // Alias Recording Tests", "timestamp": 1370838189, "metainfo": ""}