{"sha": "6259562c99de5f162f99539d05d8caf7030bdf0a", "log": "Move cross-module passes all together at the end, after the main optimization loop.  R=blickly DELTA=21 (3 added, 17 deleted, 1 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=6047   ", "commit": "\n--- a/src/com/google/javascript/jscomp/DefaultPassConfig.java\n+++ b/src/com/google/javascript/jscomp/DefaultPassConfig.java\n       passes.add(closureOptimizePrimitives);\n     }\n \n-    // TODO(user): This forces a first crack at crossModuleCodeMotion\n-    // before devirtualization. Once certain functions are devirtualized,\n-    // it confuses crossModuleCodeMotion ability to recognized that\n-    // it is recursive.\n-\n-    // TODO(user): This is meant for a temporary quick win.\n-    // In the future, we might want to improve our analysis in\n-    // CrossModuleCodeMotion so we don't need to do this.\n-    if (options.crossModuleCodeMotion) {\n-      passes.add(crossModuleCodeMotion);\n-    }\n-\n     // Method devirtualization benefits from property disambiguation so\n     // it should run after that pass but before passes that do\n     // optimizations based on global names (like cross module code motion\n \n     passes.add(createEmptyPass(\"beforeMainOptimizations\"));\n \n+    passes.addAll(getMainOptimizationLoop());\n+\n     if (options.specializeInitialModule) {\n       // When specializing the initial module, we want our fixups to be\n       // as lean as possible, so we run the entire optimization loop to a\n       // fixed point before specializing, then specialize, and then run the\n       // main optimization loop again.\n \n-      passes.addAll(getMainOptimizationLoop());\n-\n       if (options.crossModuleCodeMotion) {\n         passes.add(crossModuleCodeMotion);\n       }\n       }\n \n       passes.add(specializeInitialModule);\n-    }\n-\n-    passes.addAll(getMainOptimizationLoop());\n+      passes.addAll(getMainOptimizationLoop());\n+    }\n \n     passes.add(createEmptyPass(\"beforeModuleMotion\"));\n \n    * Process smart name processing - removes unused classes and does referencing\n    * starting with minimum set of names.\n    */\n-  final PassFactory smartNamePass =\n-      new PassFactory(\"smartNamePass\", true) {\n+  final PassFactory smartNamePass = new PassFactory(\"smartNamePass\", true) {\n     @Override\n     protected CompilerPass create(final AbstractCompiler compiler) {\n       return new CompilerPass() {", "timestamp": 1356570531, "metainfo": ""}