{"sha": "09ed556367fbe81b3003881dfacad643939664c0", "log": "Fixes issue 204 Add support for data members on interfaces  R=johnlenz,nicksantos,acleung DELTA=211  (77 added, 125 deleted, 9 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=692   ", "commit": "\n--- a/src/com/google/javascript/jscomp/TypeCheck.java\n+++ b/src/com/google/javascript/jscomp/TypeCheck.java\n       DiagnosticType.warning(\"JSC_HIDDEN_SUPERCLASS_PROPERTY_MISMATCH\",\n           \"mismatch of the {0} property type and the type \" +\n           \"of the property it overrides from superclass {1}\\n\" +\n-          \"original: {2}\\n\" +\n-          \"override: {3}\");\n-\n-  static final DiagnosticType HIDDEN_INTERFACE_PROPERTY_MISMATCH =\n-      DiagnosticType.warning(\n-          \"JSC_HIDDEN_INTERFACE_PROPERTY_MISMATCH\",\n-          \"mismatch of the {0} property type and the type \" +\n-          \"of the property it overrides from interface {1}\\n\" +\n           \"original: {2}\\n\" +\n           \"override: {3}\");\n \n       HIDDEN_SUPERCLASS_PROPERTY,\n       HIDDEN_INTERFACE_PROPERTY,\n       HIDDEN_SUPERCLASS_PROPERTY_MISMATCH,\n-      HIDDEN_INTERFACE_PROPERTY_MISMATCH,\n       UNKNOWN_OVERRIDE,\n       INTERFACE_METHOD_OVERRIDE,\n       UNKNOWN_EXPR_TYPE,\n               HIDDEN_INTERFACE_PROPERTY, propertyName,\n               interfaceType.getTopMostDefiningType(propertyName).toString()));\n         }\n-        // Check that it is ok\n-        if (interfaceHasProperty) {\n-          JSType interfacePropType =\n-              interfaceType.getPrototype().getPropertyType(propertyName);\n-          if (!propertyType.canAssignTo(interfacePropType)) {\n-            compiler.report(t.makeError(n,\n-                HIDDEN_INTERFACE_PROPERTY_MISMATCH, propertyName,\n-                interfaceType.getTopMostDefiningType(propertyName).toString(),\n-                interfacePropType.toString(), propertyType.toString()));\n-          }\n-        }\n       }\n     }\n \n         }\n       }\n       if (functionType.isConstructor()) {\n-        validator.expectAllInterfacePropertiesImplemented(functionType);\n+        validator.expectAllInterfaceProperties(t, n, functionType);\n       }\n     }\n   }\n--- a/src/com/google/javascript/jscomp/TypeValidator.java\n+++ b/src/com/google/javascript/jscomp/TypeValidator.java\n           \"JSC_INTERFACE_METHOD_NOT_IMPLEMENTED\",\n           \"property {0} on interface {1} is not implemented by type {2}\");\n \n+  static final DiagnosticType HIDDEN_INTERFACE_PROPERTY_MISMATCH =\n+      DiagnosticType.warning(\n+        \"JSC_HIDDEN_INTERFACE_PROPERTY_MISMATCH\",\n+        \"mismatch of the {0} property type and the type \" +\n+        \"of the property it overrides from interface {1}\\n\" +\n+        \"original: {2}\\n\" +\n+        \"override: {3}\");\n+\n   static final DiagnosticGroup ALL_DIAGNOSTICS = new DiagnosticGroup(\n       INVALID_CAST,\n       TYPE_MISMATCH_WARNING,\n       MISSING_EXTENDS_TAG_WARNING,\n       DUP_VAR_DECLARATION,\n       HIDDEN_PROPERTY_MISMATCH,\n-      INTERFACE_METHOD_NOT_IMPLEMENTED);\n+      INTERFACE_METHOD_NOT_IMPLEMENTED,\n+      HIDDEN_INTERFACE_PROPERTY_MISMATCH);\n \n   TypeValidator(AbstractCompiler compiler) {\n     this.compiler = compiler;\n \n   /**\n    * Expect that all properties on interfaces that this type implements are\n-   * implemented.\n-   */\n-  void expectAllInterfacePropertiesImplemented(FunctionType type) {\n+   * implemented and correctly typed.\n+   */\n+  void expectAllInterfaceProperties(NodeTraversal t, Node n,\n+      FunctionType type) {\n     ObjectType instance = type.getInstanceType();\n     for (ObjectType implemented : type.getAllImplementedInterfaces()) {\n       if (implemented.getImplicitPrototype() != null) {\n         for (String prop :\n             implemented.getImplicitPrototype().getOwnPropertyNames()) {\n-          if (!instance.hasProperty(prop)) {\n-            Node source = type.getSource();\n-            Preconditions.checkNotNull(source);\n-            String sourceName = (String) source.getProp(Node.SOURCENAME_PROP);\n-            sourceName = sourceName == null ? \"\" : sourceName;\n-            if (shouldReport) {\n-              compiler.report(JSError.make(sourceName, source,\n-                  INTERFACE_METHOD_NOT_IMPLEMENTED,\n-                  prop, implemented.toString(), instance.toString()));\n-            }\n-            registerMismatch(instance, implemented);\n-          }\n+          expectInterfaceProperty(t, n, instance, implemented, prop);\n         }\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Expect that the peroperty in an interface that this type implements is\n+   * implemented and correctly typed.\n+   */\n+  private void expectInterfaceProperty(NodeTraversal t, Node n,\n+      ObjectType instance, ObjectType implementedInterface, String prop) {\n+    if (!instance.hasProperty(prop)) {\n+      // Not implemented\n+      String sourceName = (String) n.getProp(Node.SOURCENAME_PROP);\n+      sourceName = sourceName == null ? \"\" : sourceName;\n+      if (shouldReport) {\n+        compiler.report(JSError.make(sourceName, n,\n+            INTERFACE_METHOD_NOT_IMPLEMENTED,\n+            prop, implementedInterface.toString(), instance.toString()));\n+      }\n+      registerMismatch(instance, implementedInterface);\n+    } else {\n+      JSType found = instance.getPropertyType(prop);\n+      JSType required\n+        = implementedInterface.getImplicitPrototype().getPropertyType(prop);\n+      found = found.restrictByNotNullOrUndefined();\n+      required = required.restrictByNotNullOrUndefined();\n+      if (!found.canAssignTo(required)) {\n+        // Implemented, but not correctly typed\n+        if (shouldReport) {\n+          FunctionType constructor\n+            = implementedInterface.toObjectType().getConstructor();\n+          compiler.report(t.makeError(n,\n+              HIDDEN_INTERFACE_PROPERTY_MISMATCH, prop,\n+              constructor.getTopMostDefiningType(prop).toString(),\n+              required.toString(), found.toString()));\n+        }\n+        registerMismatch(found, required);\n       }\n     }\n   }\n--- a/test/com/google/javascript/jscomp/TypeCheckTest.java\n+++ b/test/com/google/javascript/jscomp/TypeCheckTest.java\n              \"Element.prototype.innerHTML;\" +\n              \"/** @constructor \\n @extends Element */\" +\n              \"function DIVElement() {};\",\n-             \"(new DIVElement).innerHTML = new Array();\", null, false);\n+             \"(new DIVElement).innerHTML = new Array();\",\n+             null, false);\n   }\n \n   public void testImplicitCastNotInExterns() throws Exception {\n         \"inconsistent return type\\n\" +\n         \"found   : number\\n\" +\n         \"required: string\");\n+  }\n+\n+  public void testInterfaceInheritanceCheck12() throws Exception {\n+    testTypes(\n+        \"/** @interface */ function I() {};\\n\" +\n+        \"/** @type {string} */ I.prototype.foobar;\\n\" +\n+        \"/** \\n * @constructor \\n * @implements {I} */\\n\" +\n+        \"function C() {\\n\" +\n+        \"/** \\n * @type {number} */ this.foobar = 2;};\\n\" +\n+        \"/** @type {I} */ \\n var test = new C(); alert(test.foobar);\",\n+        \"mismatch of the foobar property type and the type of the property\" +\n+        \" it overrides from interface I\\n\" +\n+        \"original: string\\n\" +\n+        \"override: number\");\n   }\n \n   public void testInterfacePropertyNotImplemented() throws Exception {", "timestamp": 1298909319, "metainfo": ""}