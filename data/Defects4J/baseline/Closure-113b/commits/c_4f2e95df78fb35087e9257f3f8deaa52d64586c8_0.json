{"sha": "4f2e95df78fb35087e9257f3f8deaa52d64586c8", "log": "Fix bugs in scope-change reporting found by the scope-change sanity check. ------------- Created by MOE: http://code.google.com/p/moe-java MOE_MIGRATED_REVID=45177496", "commit": "\n--- a/src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java\n+++ b/src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java\n     /**\n      * Remove the declaration from the AST.\n      */\n-    void remove();\n+    void remove(AbstractCompiler compiler);\n \n     /**\n      * The variable for the root of this symbol.\n     }\n \n     @Override\n-    public void remove() {\n+    public void remove(AbstractCompiler compiler) {\n       Node parent = nameNode.getParent();\n+      compiler.reportChangeToEnclosingScope(parent);\n       if (parent.isFunction() || parent.hasOneChild()) {\n         NodeUtil.removeChild(parent.getParent(), parent);\n       } else {\n     }\n \n     @Override\n-    public void remove() {\n+    public void remove(AbstractCompiler compiler) {\n+      compiler.reportChangeToEnclosingScope(exprNode);\n       NodeUtil.removeChild(exprNode.getParent(), exprNode);\n     }\n \n     }\n \n     @Override\n-    public void remove() {\n+    public void remove(AbstractCompiler compiler) {\n+      compiler.reportChangeToEnclosingScope(key);\n       map.removeChild(key);\n     }\n \n--- a/src/com/google/javascript/jscomp/InlineFunctions.java\n+++ b/src/com/google/javascript/jscomp/InlineFunctions.java\n       String fnName = fn.getName();\n       Node fnNode = fs.getSafeFnNode();\n \n+      t.getCompiler().reportChangeToEnclosingScope(callNode);\n       injector.inline(callNode, fnName, fnNode, mode);\n-      t.getCompiler().reportCodeChange();\n       t.getCompiler().addToDebugLog(\"Inlined function: \" + fn.getName());\n     }\n   }\n--- a/src/com/google/javascript/jscomp/InlineObjectLiterals.java\n+++ b/src/com/google/javascript/jscomp/InlineObjectLiterals.java\n           blacklistVarReferencesInTree(val, v.scope);\n         }\n         vnode.getParent().addChildBefore(varnode, vnode);\n+        compiler.reportChangeToEnclosingScope(vnode);\n       }\n \n       if (defined) {\n       }\n \n       for (Reference ref : referenceInfo.references) {\n+        compiler.reportChangeToEnclosingScope(ref.getNode());\n         // The init/decl have already been converted.\n         if (defined && ref == init) {\n           continue;\n           ref.getGrandparent().replaceChild(ref.getParent(), replacement);\n         }\n       }\n-\n-      compiler.reportCodeChange();\n     }\n   }\n }\n--- a/src/com/google/javascript/jscomp/InlineVariables.java\n+++ b/src/com/google/javascript/jscomp/InlineVariables.java\n       Preconditions.checkState(value != null);\n       // Check for function declarations before the value is moved in the AST.\n       boolean isFunctionDeclaration = NodeUtil.isFunctionDeclaration(value);\n-\n-      // decl and ref may be in different scopes, report change for both\n-      compiler.reportChangeToEnclosingScope(decl.getNode());\n       compiler.reportChangeToEnclosingScope(ref.getNode());\n-\n       inlineValue(v, ref, value.detachFromParent());\n       if (decl != init) {\n         Node expressRoot = init.getGrandparent();\n       }\n       // Function declarations have already been removed.\n       if (!isFunctionDeclaration) {\n+        compiler.reportChangeToEnclosingScope(decl.getNode());\n         removeDeclaration(decl);\n       }\n     }\n--- a/src/com/google/javascript/jscomp/MinimizeExitPoints.java\n+++ b/src/com/google/javascript/jscomp/MinimizeExitPoints.java\n         break;\n \n       case Token.FUNCTION:\n+        // FYI: the function will be analyzed w/out a call to\n+        // NodeTraversal/pushScope. Bypassing pushScope could cause a bug if\n+        // there is code that relies on NodeTraversal knowing the correct scope.\n         tryMinimizeExits(n.getLastChild(), Token.RETURN, null);\n         break;\n     }\n \n     // Just an 'exit'.\n     if (matchingExitNode(n, exitType, labelName)) {\n+      compiler.reportChangeToEnclosingScope(n);\n       NodeUtil.removeChild(n.getParent(), n);\n-      compiler.reportCodeChange();\n       return;\n     }\n \n \n       // Move all the if node's following siblings.\n       moveAllFollowing(ifNode, ifNode.getParent(), newDestBlock);\n-      compiler.reportCodeChange();\n+      compiler.reportChangeToEnclosingScope(ifNode);\n     }\n   }\n \n--- a/src/com/google/javascript/jscomp/NodeTraversal.java\n+++ b/src/com/google/javascript/jscomp/NodeTraversal.java\n    * Then, if a function doesn't change between two runs of P1, it won't look at\n    * the function the second time.\n    * (We're assuming that P1 runs to a fixpoint, o/w we may miss optimizations.)\n+   *\n+   * Most changes are reported with calls to Compiler.reportCodeChange(), which\n+   * doesn't know which scope changed. We keep track of the current scope by\n+   * calling Compiler.setScope inside pushScope and popScope.\n+   * The automatic tracking can be wrong in rare cases when a pass changes scope\n+   * w/out causing a call to pushScope or popScope. It's very hard to find the\n+   * places where this happens unless a bug is triggered.\n+   * Passes that do cross-scope modifications call\n+   * Compiler.reportChangeToEnclosingScope(Node n).\n    */\n   public static void traverseChangedFunctions(\n       AbstractCompiler compiler, FunctionCallback callback) {\n     final AbstractCompiler comp = compiler;\n     final FunctionCallback cb = callback;\n     final Node jsRoot = comp.getJsRoot();\n-    if (comp.hasScopeChanged(jsRoot)) {\n-      cb.visit(comp, jsRoot);\n-    }\n-    traverse(comp, jsRoot,\n-        new AbstractPreOrderCallback() {\n-          @Override\n-          public final boolean shouldTraverse(NodeTraversal t, Node n, Node p) {\n-            if (n.isFunction() && comp.hasScopeChanged(n)) {\n-              cb.visit(comp, n);\n-            }\n-            return true;\n+    NodeTraversal t = new NodeTraversal(comp, new AbstractPreOrderCallback() {\n+        @Override\n+        public final boolean shouldTraverse(NodeTraversal t, Node n, Node p) {\n+          if ((n == jsRoot || n.isFunction()) && comp.hasScopeChanged(n)) {\n+            cb.visit(comp, n);\n           }\n-        });\n+          return true;\n+        }\n+      });\n+    t.traverse(jsRoot);\n   }\n \n   /**\n     Preconditions.checkState(n.isFunction());\n \n     final Node fnName = n.getFirstChild();\n-\n     boolean isFunctionExpression = (parent != null)\n         && NodeUtil.isFunctionExpression(n);\n \n       scopeRoots.pop();\n     }\n     cfgs.pop();\n-    if (!scopes.isEmpty()) {\n-      compiler.setScope(scopes.peek().getRootNode());\n+    if (hasScope()) {\n+      compiler.setScope(getScopeRoot());\n     }\n   }\n \n       scopes.push(scope);\n     }\n     scopeRoots.clear();\n-\n+    // No need to call compiler.setScope; the top scopeRoot is now the top scope\n     return scope;\n   }\n \n--- a/src/com/google/javascript/jscomp/NodeUtil.java\n+++ b/src/com/google/javascript/jscomp/NodeUtil.java\n \n   /** Checks that the scope roots marked as changed have indeed changed */\n   public static void verifyScopeChanges(Map<Node, Node> map,\n-      Node main, boolean verifyUnchangedNodes) {\n+      Node main, boolean verifyUnchangedNodes,\n+      AbstractCompiler compiler) {\n+    // compiler is passed only to call compiler.toSource during debugging to see\n+    // mismatches in scopes\n+\n     // If verifyUnchangedNodes is false, we are comparing the initial AST to the\n     // final AST. Don't check unmarked nodes b/c they may have been changed by\n     // non-loopable passes.\n--- a/src/com/google/javascript/jscomp/PhaseOptimizer.java\n+++ b/src/com/google/javascript/jscomp/PhaseOptimizer.java\n     if (sanityCheck != null) {\n       sanityCheck.create(compiler).process(externs, root);\n       if (inLoop) {\n-        NodeUtil.verifyScopeChanges(mtoc, jsRoot, true);\n+        NodeUtil.verifyScopeChanges(mtoc, jsRoot, true, compiler);\n         setSanityCheckState();\n       }\n     }\n     @Override\n     public void reportChange() {\n       if (crossScopeReporting) {\n-        // This call was caused by Compiler/reportChangeToScope, do nothing\n+        // This call was caused by Compiler/reportChangeToEnclosingScope,\n+        // do nothing.\n         return;\n       }\n       lastChange = timestamp;\n--- a/src/com/google/javascript/jscomp/RemoveUnusedClassProperties.java\n+++ b/src/com/google/javascript/jscomp/RemoveUnusedClassProperties.java\n           Preconditions.checkState(assign != null\n               && NodeUtil.isAssignmentOp(assign)\n               && assign.getFirstChild() == n);\n+          compiler.reportChangeToEnclosingScope(assign);\n           // 'this.x = y' to 'y'\n           assign.getParent().replaceChild(assign,\n               assign.getLastChild().detachFromParent());\n         } else if (parent.isInc() || parent.isDec()) {\n+          compiler.reportChangeToEnclosingScope(parent);\n           parent.getParent().replaceChild(parent, IR.number(0));\n         } else {\n           throw new IllegalStateException(\"unexpected: \" + parent);\n         }\n-        compiler.reportCodeChange();\n       }\n     }\n   }\n--- a/src/com/google/javascript/jscomp/RemoveUnusedPrototypeProperties.java\n+++ b/src/com/google/javascript/jscomp/RemoveUnusedPrototypeProperties.java\n    * never referenced.\n    */\n   private void removeUnusedSymbols(Collection<NameInfo> allNameInfo) {\n-    boolean changed = false;\n     for (NameInfo nameInfo : allNameInfo) {\n       if (!nameInfo.isReferenced()) {\n         for (Symbol declaration : nameInfo.getDeclarations()) {\n           boolean canRemove = false;\n-\n           if (specializationState == null) {\n             canRemove = true;\n           } else {\n               canRemove = true;\n             }\n           }\n-\n           if (canRemove) {\n-            declaration.remove();\n-            changed = true;\n+            // Code-change reporting happens at the remove methods\n+            declaration.remove(compiler);\n           }\n         }\n-\n         logger.fine(\"Removed unused prototype property: \" + nameInfo.name);\n       }\n-    }\n-\n-    if (changed) {\n-      compiler.reportCodeChange();\n     }\n   }\n \n--- a/src/com/google/javascript/jscomp/RemoveUnusedVars.java\n+++ b/src/com/google/javascript/jscomp/RemoveUnusedVars.java\n       while ((lastArg = argList.getLastChild()) != null) {\n         Var var = fnScope.getVar(lastArg.getString());\n         if (!referenced.contains(var)) {\n+          compiler.reportChangeToEnclosingScope(lastArg);\n           argList.removeChild(lastArg);\n-          compiler.reportCodeChange();\n         } else {\n           break;\n         }\n      */\n     public void applyChanges() {\n       for (Node n : toRemove) {\n+        compiler.reportChangeToEnclosingScope(n);\n         n.getParent().removeChild(n);\n-        compiler.reportCodeChange();\n       }\n       for (Node n : toReplaceWithZero) {\n+        compiler.reportChangeToEnclosingScope(n);\n         n.getParent().replaceChild(n, IR.number(0).srcref(n));\n-        compiler.reportCodeChange();\n       }\n     }\n \n    */\n   private void removeAllAssigns(Var var) {\n     for (Assign assign : assignsByVar.get(var)) {\n+      compiler.reportChangeToEnclosingScope(assign.assignNode);\n       assign.remove();\n-      compiler.reportCodeChange();\n     }\n   }\n \n       // Remove calls to inheritance-defining functions where the unreferenced\n       // class is the subclass.\n       for (Node exprCallNode : classDefiningCalls.get(var)) {\n+        compiler.reportChangeToEnclosingScope(exprCallNode);\n         NodeUtil.removeChild(exprCallNode.getParent(), exprCallNode);\n-        compiler.reportCodeChange();\n       }\n \n       // Regardless of what happens to the original declaration,\n         // that's taken care of in removeUnreferencedFunctionArgs.\n       } else if (NodeUtil.isFunctionExpression(toRemove)) {\n         if (!preserveFunctionExpressionNames) {\n+          compiler.reportChangeToEnclosingScope(toRemove);\n           toRemove.getFirstChild().setString(\"\");\n-          compiler.reportCodeChange();\n         }\n         // Don't remove bleeding functions.\n       } else if (parent != null &&\n         // declaration itself and just leave the value, e.g.,\n         // var a = foo(); => foo();\n         if (toRemove.getChildCount() == 1) {\n+          compiler.reportChangeToEnclosingScope(toRemove);\n           parent.replaceChild(toRemove,\n               IR.exprResult(nameNode.removeFirstChild()));\n-          compiler.reportCodeChange();\n         }\n       } else if (toRemove.isVar() &&\n           toRemove.getChildCount() > 1) {\n         // For var declarations with multiple names (i.e. var a, b, c),\n         // only remove the unreferenced name\n+        compiler.reportChangeToEnclosingScope(toRemove);\n         toRemove.removeChild(nameNode);\n-        compiler.reportCodeChange();\n       } else if (parent != null) {\n+        compiler.reportChangeToEnclosingScope(toRemove);\n         NodeUtil.removeChild(parent, toRemove);\n-        compiler.reportCodeChange();\n       }\n     }\n   }\n--- a/src/com/google/javascript/jscomp/UnreachableCodeElimination.java\n+++ b/src/com/google/javascript/jscomp/UnreachableCodeElimination.java\n     private void removeNode(Node n) {\n       codeChanged = true;\n       NodeUtil.redeclareVarsInsideBranch(n);\n-      compiler.reportCodeChange();\n+      compiler.reportChangeToEnclosingScope(n);\n       if (logger.isLoggable(Level.FINE)) {\n         logger.fine(\"Removing \" + n.toString());\n       }\n--- a/test/com/google/javascript/jscomp/CompilerTestCase.java\n+++ b/test/com/google/javascript/jscomp/CompilerTestCase.java\n       }\n \n       // Check correctness of the changed-scopes-only traversal\n-      NodeUtil.verifyScopeChanges(mtoc, mainRoot, false);\n+      NodeUtil.verifyScopeChanges(mtoc, mainRoot, false, compiler);\n \n       if (expected != null) {\n         if (compareAsTree) {\n--- a/test/com/google/javascript/jscomp/MultiPassTest.java\n+++ b/test/com/google/javascript/jscomp/MultiPassTest.java\n \n /**\n  * This file contains the only tests that use the infrastructure in\n- * CompilerTestCase to run multiple passes. The other files that use\n- * CompilerTestCase test a single pass.\n+ * CompilerTestCase to run multiple passes and do sanity checks. The other files\n+ * that use CompilerTestCase unit test a single pass.\n  */\n public class MultiPassTest extends CompilerTestCase {\n   private List<PassFactory> passes;\n         \"function f() { return 1; }\");\n   }\n \n+  public void testCollapseObjectLiteralsScopeChange() {\n+    passes = Lists.newLinkedList();\n+    addCollapseObjectLiterals();\n+    test(\"function f() {\" +\n+        \"  var obj = { x: 1 };\" +\n+        \"  var z = function() { return obj.x; }\" +\n+        \"}\",\n+        \"function f(){\" +\n+        \"  var JSCompiler_object_inline_x_0 = 1;\" +\n+        \"  var z = function(){\" +\n+        \"    return JSCompiler_object_inline_x_0;\" +\n+        \"  }\" +\n+        \"}\");\n+  }\n+\n+  public void testRemoveUnusedClassPropertiesScopeChange() {\n+    passes = Lists.newLinkedList();\n+    addRemoveUnusedClassProperties();\n+    test(\"/** @constructor */\" +\n+        \"function Foo() { this.a = 1; }\" +\n+        \"Foo.baz = function() {};\",\n+        \"/** @constructor */\" +\n+        \"function Foo() { 1; }\" +\n+        \"Foo.baz = function() {};\");\n+  }\n+\n+  public void testRemoveUnusedVariablesScopeChange() {\n+    passes = Lists.newLinkedList();\n+    addRemoveUnusedVars();\n+    test(\"function f() { var x; }\",\n+        \"function f() {}\");\n+    test(\"function g() { function f(x, y) { return 1; } }\",\n+        \"function g() {}\");\n+    test(\"function f() { var x = 123; }\",\n+        \"function f() {}\");\n+  }\n+\n   public void testTopScopeChange() {\n     passes = Lists.newLinkedList();\n     addInlineVariables();\n     addPeephole();\n     test(\"var x = 1, y = x, z = x + y;\", \"var z = 2;\");\n+  }\n+\n+  private void addCollapseObjectLiterals() {\n+    passes.add(new PassFactory(\"collapseObjectLiterals\", false) {\n+        @Override\n+        protected CompilerPass create(AbstractCompiler compiler) {\n+          return new InlineObjectLiterals(\n+              compiler, compiler.getUniqueNameIdSupplier());\n+        }\n+      });\n   }\n \n   private void addDeadCodeElimination() {\n       });\n   }\n \n-  private void addInlineVariables() {\n-    passes.add(new PassFactory(\"inlineVariables\", false) {\n-        @Override\n-        protected CompilerPass create(AbstractCompiler compiler) {\n-          return new InlineVariables(compiler, InlineVariables.Mode.ALL, true);\n-        }\n-      });\n-  }\n-\n   private void addInlineFunctions() {\n     passes.add(new PassFactory(\"inlineFunctions\", false) {\n         @Override\n         protected CompilerPass create(AbstractCompiler compiler) {\n           return new InlineFunctions(compiler,\n               compiler.getUniqueNameIdSupplier(), true, true, true, true, true);\n+        }\n+      });\n+  }\n+\n+  private void addInlineVariables() {\n+    passes.add(new PassFactory(\"inlineVariables\", false) {\n+        @Override\n+        protected CompilerPass create(AbstractCompiler compiler) {\n+          return new InlineVariables(compiler, InlineVariables.Mode.ALL, true);\n         }\n       });\n   }\n         }\n       });\n   }\n+\n+  private void addRemoveUnusedClassProperties() {\n+    passes.add(new PassFactory(\"removeUnusedClassProperties\", false) {\n+        @Override\n+        protected CompilerPass create(AbstractCompiler compiler) {\n+          return new RemoveUnusedClassProperties(compiler);\n+        }\n+      });\n+  }\n+\n+  private void addRemoveUnusedVars() {\n+    passes.add(new PassFactory(\"removeUnusedVars\", false) {\n+        @Override\n+        protected CompilerPass create(AbstractCompiler compiler) {\n+          return new RemoveUnusedVars(compiler, false, false, false);\n+        }\n+      });\n+  }\n }", "timestamp": 1366234975, "metainfo": ""}