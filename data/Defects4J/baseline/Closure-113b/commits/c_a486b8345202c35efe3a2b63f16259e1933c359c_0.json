{"sha": "a486b8345202c35efe3a2b63f16259e1933c359c", "log": "Cut variable coalescing runtime by about 40%. If we know that variables x and y intersect, then we don't have to look at them again.  R=johnlenz DELTA=140  (41 added, 61 deleted, 38 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=223254   ", "commit": "\n--- a/src/com/google/javascript/jscomp/CoalesceVariableNames.java\n+++ b/src/com/google/javascript/jscomp/CoalesceVariableNames.java\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n \n-import java.util.ArrayList;\n import java.util.Comparator;\n import java.util.Deque;\n import java.util.Iterator;\n       }\n     }\n \n-    // Go through every single point of the program and look at each variable\n-    // pairs. If they are both live at the same time, at an edge between them.\n-    for (DiGraphNode<Node, Branch> cfgNode : cfg.getDirectedGraphNodes()) {\n-      FlowState<LiveVariableLattice> state = cfgNode.getAnnotation();\n-      if (cfg.isImplicitReturn(cfgNode)) {\n-        continue;\n-      }\n-\n-      int varsInScope = scope.getVarCount();\n-      ArrayList<CombinedLiveRangeChecker> rangesToCheck =\n-          new ArrayList<CombinedLiveRangeChecker>(\n-              varsInScope * varsInScope);\n-\n-      for (Iterator<Var> i1 = scope.getVars(); i1.hasNext();) {\n-        Var v1 = i1.next();\n-        for (Iterator<Var> i2 = scope.getVars(); i2.hasNext();) {\n-          Var v2 = i2.next();\n-\n-          if (v1 == v2 || !interferenceGraph.hasNode(v1) ||\n-              !interferenceGraph.hasNode(v2)) {\n-            // Skip nodes that were not added. They are globals and escaped\n-            // locals. Also avoid merging a variable with itself.\n-            continue;\n+    // Go through each variable and try to connect them.\n+    for (Iterator<Var> i1 = scope.getVars(); i1.hasNext();) {\n+      Var v1 = i1.next();\n+\n+      NEXT_VAR_PAIR:\n+      for (Iterator<Var> i2 = scope.getVars(); i2.hasNext();) {\n+        Var v2 = i2.next();\n+\n+        // Skip duplicate pairs.\n+        if (v1.index >= v2.index) {\n+          continue;\n+        }\n+\n+        if (!interferenceGraph.hasNode(v1) ||\n+            !interferenceGraph.hasNode(v2)) {\n+          // Skip nodes that were not added. They are globals and escaped\n+          // locals. Also avoid merging a variable with itself.\n+          continue NEXT_VAR_PAIR;\n+        }\n+\n+        if (v1.getParentNode().getType() == Token.LP &&\n+            v2.getParentNode().getType() == Token.LP) {\n+          interferenceGraph.connectIfNotFound(v1, null, v2);\n+          continue NEXT_VAR_PAIR;\n+        }\n+\n+        // Go through every CFG node in the program and look at\n+        // this variable pair. If they are both live at the same\n+        // time, add an edge between them and continue to the next pair.\n+        NEXT_CROSS_CFG_NODE:\n+        for (DiGraphNode<Node, Branch> cfgNode : cfg.getDirectedGraphNodes()) {\n+          if (cfg.isImplicitReturn(cfgNode)) {\n+            continue NEXT_CROSS_CFG_NODE;\n           }\n \n+          FlowState<LiveVariableLattice> state = cfgNode.getAnnotation();\n+          // Check the live states and add edge when possible.\n+          if ((state.getIn().isLive(v1) && state.getIn().isLive(v2)) ||\n+              (state.getOut().isLive(v1) && state.getOut().isLive(v2))) {\n+            interferenceGraph.connectIfNotFound(v1, null, v2);\n+            continue NEXT_VAR_PAIR;\n+          }\n+        }\n+\n+        // v1 and v2 might not have an edge between them! woohoo. there's\n+        // one last sanity check that we have to do: we have to check\n+        // if there's a collision *within* the cfg node.\n+        NEXT_INTRA_CFG_NODE:\n+        for (DiGraphNode<Node, Branch> cfgNode : cfg.getDirectedGraphNodes()) {\n+          if (cfg.isImplicitReturn(cfgNode)) {\n+            continue NEXT_INTRA_CFG_NODE;\n+          }\n+\n+          FlowState<LiveVariableLattice> state = cfgNode.getAnnotation();\n           boolean v1OutLive = state.getOut().isLive(v1);\n           boolean v2OutLive = state.getOut().isLive(v2);\n-          // Finally, check the live states and add edge when possible.\n-          if (v1.getParentNode().getType() == Token.LP &&\n-              v2.getParentNode().getType() == Token.LP) {\n-            interferenceGraph.connectIfNotFound(v1, null, v2);\n-          } else if ((state.getIn().isLive(v1) && state.getIn().isLive(v2)) ||\n-              (v1OutLive && v2OutLive)) {\n-            interferenceGraph.connectIfNotFound(v1, null, v2);\n-          } else {\n-            LiveRangeChecker checker1 =\n-                new LiveRangeChecker(v1, v2OutLive ? null : v2);\n-            LiveRangeChecker checker2 =\n-                new LiveRangeChecker(v2, v1OutLive ? null : v1);\n-            rangesToCheck.add(new CombinedLiveRangeChecker(checker1, checker2));\n+          CombinedLiveRangeChecker checker = new CombinedLiveRangeChecker(\n+              new LiveRangeChecker(v1, v2OutLive ? null : v2),\n+              new LiveRangeChecker(v2, v1OutLive ? null : v1));\n+          NodeTraversal.traverse(\n+              compiler,\n+              cfgNode.getValue(),\n+              checker);\n+          if (checker.connectIfCrossed(interferenceGraph)) {\n+            continue NEXT_VAR_PAIR;\n           }\n         }\n       }\n-\n-      // Do the collected live range checks.\n-      checkRanges(rangesToCheck, cfgNode.getValue());\n-      for (CombinedLiveRangeChecker range : rangesToCheck) {\n-        range.connectIfCrossed(interferenceGraph);\n-      }\n     }\n     return interferenceGraph;\n-  }\n-\n-  /**\n-   * Check if the live ranges of the given pairs of variables overlap within a\n-   * node represented by a CFG node. This only occurs when a variable {@code\n-   * def} is assigned within a node and a second variable {@code use} is live\n-   * after it. This function will traversing the subtree in a\n-   * left-to-right-post-order fashion in correspondent to how expressions are\n-   * evaluated.\n-   *\n-   * @param root The current subtree represent by a control flow graph node.\n-   */\n-  private void checkRanges(\n-      ArrayList<CombinedLiveRangeChecker> rangesToCheck, Node root) {\n-    CombinedCfgNodeLiveRangeChecker callbacks =\n-      new CombinedCfgNodeLiveRangeChecker(rangesToCheck);\n-    NodeTraversal.traverse(compiler, root, callbacks);\n-  }\n-\n-  /**\n-   * A simple wrapper calls to call two AbstractCfgNodeTraversalCallback\n-   * callback during the same traversal.  All traversals callbacks have the same\n-   * \"shouldTraverse\" conditions.\n-   */\n-  private static class CombinedCfgNodeLiveRangeChecker\n-      extends AbstractCfgNodeTraversalCallback {\n-\n-    private final ArrayList<CombinedLiveRangeChecker> callbacks;\n-\n-    CombinedCfgNodeLiveRangeChecker(\n-        ArrayList<CombinedLiveRangeChecker> callbacks) {\n-      this.callbacks = callbacks;\n-    }\n-\n-    @Override\n-    public void visit(NodeTraversal t, Node n, Node parent) {\n-      if (CombinedLiveRangeChecker.shouldVisit(n)) {\n-        for (CombinedLiveRangeChecker callback : callbacks) {\n-          callback.visit(t, n, parent);\n-        }\n-      }\n-    }\n   }\n \n   /**\n       this.callback2 = callback2;\n     }\n \n-    /**\n-     * @return Whether any CombinedLiveRangeChecker would be interested in the\n-     * node.\n-     */\n-    public static boolean shouldVisit(Node n) {\n-      return LiveRangeChecker.shouldVisit(n);\n-    }\n-\n     @Override\n     public void visit(NodeTraversal t, Node n, Node parent) {\n-      callback1.visit(t, n, parent);\n-      callback2.visit(t, n, parent);\n-    }\n-\n-    void connectIfCrossed(UndiGraph<Var, Void> interferenceGraph) {\n+      if (LiveRangeChecker.shouldVisit(n)) {\n+        callback1.visit(t, n, parent);\n+        callback2.visit(t, n, parent);\n+      }\n+    }\n+\n+    boolean connectIfCrossed(UndiGraph<Var, Void> interferenceGraph) {\n       if (callback1.crossed || callback2.crossed) {\n         Var v1 = callback1.getDef();\n         Var v2 = callback2.getDef();\n         interferenceGraph.connectIfNotFound(v1, null, v2);\n-      }\n+        return true;\n+      }\n+      return false;\n     }\n   }\n ", "timestamp": 1284571810, "metainfo": ""}