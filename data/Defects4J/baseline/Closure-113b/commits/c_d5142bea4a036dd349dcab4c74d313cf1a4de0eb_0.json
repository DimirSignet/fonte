{"sha": "d5142bea4a036dd349dcab4c74d313cf1a4de0eb", "log": "Make CodeChangeHandler a class, so that the subclasses can share default method implementations. (Also, it'll be easier for me to extend it from PhaseOptimizer to keep track of changed functions.) ------------- Created by MOE: http://code.google.com/p/moe-java MOE_MIGRATED_REVID=42635623", "commit": "\n--- a/src/com/google/javascript/jscomp/CodeChangeHandler.java\n+++ b/src/com/google/javascript/jscomp/CodeChangeHandler.java\n \n package com.google.javascript.jscomp;\n \n+import com.google.javascript.rhino.Node;\n+\n /**\n  * A simple listener for code change events.\n+ * Records whether the code has changed since the last reset.\n  * @author nicksantos@google.com (Nick Santos)\n+ * @author dimvar@google.com (Dimitris Vardoulakis)\n  */\n-interface CodeChangeHandler {\n+class CodeChangeHandler {\n+  private boolean hasChanged = false;\n \n-  // TODO(nicksantos): Add more to this interface, for more fine-grained\n-  // change reporting.\n-\n-  /** Report a change to the AST. */\n-  void reportChange();\n-\n-  /**\n-   * A trivial change handler that just records whether the code\n-   * has changed since the last reset.\n-   */\n-  static final class RecentChange implements CodeChangeHandler {\n-    private boolean hasChanged = false;\n-\n-    @Override\n-    public void reportChange() {\n-      hasChanged = true;\n-    }\n-\n-    boolean hasCodeChanged() {\n-      return hasChanged;\n-    }\n-\n-    void reset() {\n-      hasChanged = false;\n-    }\n+  /** Report a change to some unspecified node of the AST. */\n+  public void reportChange() {\n+    hasChanged = true;\n   }\n \n-  /**\n-   * A change handler that throws an exception if any changes are made.\n-   */\n-  static final class ForbiddenChange implements CodeChangeHandler {\n-    @Override\n-    public void reportChange() {\n-      throw new IllegalStateException(\"Code changes forbidden\");\n-    }\n+  /** Report a change to a specific function in the AST. */\n+  public void reportChangedFun(Node n) {\n+    hasChanged = true;\n+  }\n+\n+  /** Report that a function node has been removed from the AST */\n+  public void reportDeletedFun(Node n) {\n+    hasChanged = true;\n+  }\n+\n+  void reset() {\n+    hasChanged = false;\n+  }\n+\n+  boolean hasCodeChanged() {\n+    return hasChanged;\n   }\n }\n--- a/src/com/google/javascript/jscomp/Compiler.java\n+++ b/src/com/google/javascript/jscomp/Compiler.java\n   }\n \n   /**\n-   * Creates n Compiler that reports errors and warnings to an output\n-   * stream.\n+   * Creates a Compiler that reports errors and warnings to an output stream.\n    */\n   public Compiler(PrintStream stream) {\n     addChangeHandler(recentChange);\n     endPass();\n   }\n \n-  protected final CodeChangeHandler.RecentChange recentChange =\n-      new CodeChangeHandler.RecentChange();\n+  protected final CodeChangeHandler recentChange = new CodeChangeHandler();\n   private final List<CodeChangeHandler> codeChangeHandlers =\n       Lists.<CodeChangeHandler>newArrayList();\n \n--- /dev/null\n+++ b/src/com/google/javascript/jscomp/ForbiddenChange.java\n+/*\n+ * Copyright 2013 The Closure Compiler Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+import com.google.javascript.rhino.Node;\n+\n+/**\n+ * A change handler that throws an exception if any changes are made.\n+ * @author nicksantos@google.com (Nick Santos)\n+ * @author dimvar@google.com (Dimitris Vardoulakis)\n+ */\n+final class ForbiddenChange extends CodeChangeHandler {\n+\n+  @Override\n+  public void reportChange() {\n+    throw new IllegalStateException(\"Code changes forbidden\");\n+  }\n+\n+  @Override\n+  public void reportChangedFun(Node n) {\n+    throw new IllegalStateException(\"Code changes forbidden\");\n+  }\n+\n+  @Override\n+  public void reportDeletedFun(Node n) {\n+    throw new IllegalStateException(\"Code changes forbidden\");\n+  }\n+}\n--- a/src/com/google/javascript/jscomp/PeepholeOptimizationsPass.java\n+++ b/src/com/google/javascript/jscomp/PeepholeOptimizationsPass.java\n class PeepholeOptimizationsPass\n     implements CompilerPass {\n   private AbstractCompiler compiler;\n-  \n+\n   // Use an array here for faster iteration compared to ImmutableSet\n   private final AbstractPeepholeOptimization[] peepholeOptimizations;\n \n \n   private boolean retraverseOnChange = true;\n \n-  static private class ScopeState {\n+  private static class ScopeState {\n     boolean changed;\n     boolean traverseChildScopes;\n     ScopeState() {\n     }\n   }\n \n-  static private class StateStack {\n+  private static class StateStack {\n     private ArrayList<ScopeState> states = Lists.newArrayList();\n     private int currentDepth = 0;\n \n     }\n   }\n \n-  private class PeepholeChangeHandler implements CodeChangeHandler {\n+  private class PeepholeChangeHandler extends CodeChangeHandler {\n     @Override\n     public void reportChange() {\n       traversalState.peek().changed = true;\n     this.compiler = compiler;\n     this.peepholeOptimizations = optimizations;\n   }\n-  \n+\n   PeepholeOptimizationsPass setRetraverseOnChange(boolean retraverse) {\n     this.retraverseOnChange = retraverse;\n     return this;\n     int visits = 0;\n     do {\n       Node c = node.getFirstChild();\n-      while(c != null) {\n+      while (c != null) {\n         Node next = c.getNext();\n         traverse(c);\n         c = next;\n \n   private boolean shouldRetraverse(Node node) {\n     if (retraverseOnChange\n-        && node.getParent() != null \n+        && node.getParent() != null\n         && (node.isFunction() || node.isScript())) {\n       ScopeState state = traversalState.peek();\n       if (state.changed) {\n--- a/src/com/google/javascript/jscomp/PerformanceTracker.java\n+++ b/src/com/google/javascript/jscomp/PerformanceTracker.java\n import com.google.common.collect.ImmutableMap;\n import com.google.common.collect.Lists;\n import com.google.common.collect.Maps;\n-import com.google.javascript.jscomp.CodeChangeHandler.RecentChange;\n import com.google.javascript.jscomp.CompilerOptions.TracerMode;\n import com.google.javascript.rhino.Node;\n \n \n   // Keeps track of AST changes and computes code size estimation\n   // if there is any.\n-  private final RecentChange codeChange = new RecentChange();\n+  private final CodeChangeHandler codeChange = new CodeChangeHandler();\n \n   private int codeSize = 0;\n   private int gzCodeSize = 0;\n   /** Stats for each run of a compiler pass. */\n   private final List<Stats> log = Lists.newArrayList();\n \n+  /** For each pass, keep track of the runtime, the size changes, etc */\n   public static class Stats {\n     Stats(String pass, boolean iot) {\n       this.pass = pass;\n--- a/src/com/google/javascript/jscomp/PhaseOptimizer.java\n+++ b/src/com/google/javascript/jscomp/PhaseOptimizer.java\n \n   private final AbstractCompiler compiler;\n   private final PerformanceTracker tracker;\n-  private final CodeChangeHandler.RecentChange recentChange =\n-      new CodeChangeHandler.RecentChange();\n+  private final CodeChangeHandler recentChange = new CodeChangeHandler();\n   private boolean loopMutex = false;\n   private Tracer currentTracer = null;\n   private String currentPassName = null;\n--- a/src/com/google/javascript/jscomp/SanityCheck.java\n+++ b/src/com/google/javascript/jscomp/SanityCheck.java\n    */\n   private void sanityCheckNormalization(Node externs, Node root) {\n     // Verify nothing has inappropriately denormalize the AST.\n-    CodeChangeHandler handler =\n-        new CodeChangeHandler.ForbiddenChange();\n+    CodeChangeHandler handler = new ForbiddenChange();\n     compiler.addChangeHandler(handler);\n \n     // TODO(johnlenz): Change these normalization checks Preconditions and\n--- a/test/com/google/javascript/jscomp/CompilerTestCase.java\n+++ b/test/com/google/javascript/jscomp/CompilerTestCase.java\n import com.google.common.base.Predicates;\n import com.google.common.collect.ImmutableList;\n import com.google.common.collect.Lists;\n-import com.google.javascript.jscomp.CodeChangeHandler.RecentChange;\n import com.google.javascript.jscomp.CompilerOptions.LanguageMode;\n import com.google.javascript.jscomp.type.ReverseAbstractInterpreter;\n import com.google.javascript.jscomp.type.SemanticReverseAbstractInterpreter;\n   private void test(Compiler compiler, String[] expected,\n                     DiagnosticType error, DiagnosticType warning,\n                     String description) {\n-    RecentChange recentChange = new RecentChange();\n+    CodeChangeHandler recentChange = new  CodeChangeHandler();\n     compiler.addChangeHandler(recentChange);\n \n     Node root = compiler.parseInputs();", "timestamp": 1361319503, "metainfo": ""}