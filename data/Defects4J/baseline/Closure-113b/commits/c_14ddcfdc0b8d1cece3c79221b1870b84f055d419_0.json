{"sha": "14ddcfdc0b8d1cece3c79221b1870b84f055d419", "log": "Change the internal representation of constant variables.  Run inline-variables before smart-name-removal.    ", "commit": "\n--- a/src/com/google/javascript/jscomp/CollapseProperties.java\n+++ b/src/com/google/javascript/jscomp/CollapseProperties.java\n     for (Name n : globalNames) {\n       collapseDeclarationOfNameAndDescendants(n, n.name);\n     }\n+\n+    // TODO(johnlenz): The pass should maintain the constant annotations during\n+    // the main pass.\n+    new Normalize.PropogateConstantAnnotations(compiler, false);\n   }\n \n   /**\n     // AFTER:\n     //   name a$b$c\n     Node ref = NodeUtil.newName(alias, n, originalName);\n-    if (n.getLastChild().getBooleanProp(Node.IS_CONSTANT_NAME)) {\n-      ref.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n-    }\n+    NodeUtil.copyNameAnnotations(n.getLastChild(), ref);\n     parent.replaceChild(n, ref);\n     compiler.reportCodeChange();\n   }\n     // Create the new alias node.\n     Node nameNode = NodeUtil.newName(alias, gramps.getFirstChild(),\n         refName.fullName());\n-    if (ref.node.getLastChild().getBooleanProp(Node.IS_CONSTANT_NAME)) {\n-      nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n-    }\n+    NodeUtil.copyNameAnnotations(ref.node.getLastChild(), nameNode);\n \n     if (gramps.getType() == Token.EXPR_RESULT) {\n       // BEFORE: a.b.c = ...;\n--- a/src/com/google/javascript/jscomp/Compiler.java\n+++ b/src/com/google/javascript/jscomp/Compiler.java\n   }\n \n   private void runSanityCheck() {\n-    sanityCheck.create(this).process(null, jsRoot);\n+    sanityCheck.create(this).process(externsRoot, jsRoot);\n   }\n \n   /**\n--- a/src/com/google/javascript/jscomp/DefaultPassConfig.java\n+++ b/src/com/google/javascript/jscomp/DefaultPassConfig.java\n     // Collapsing properties can undo constant inlining, so we do this before\n     // the main optimization loop.\n     if (options.collapseProperties) {\n-      passes.add(undoConstantRenaming);\n       passes.add(collapseProperties);\n-      passes.add(renameConstants.makeOneTimePass());\n     }\n \n     // Tighten types based on actual usage.\n     assertAllOneTimePasses(passes);\n \n     if (options.smartNameRemoval || options.reportPath != null) {\n-      passes.addAll(getCodeRemovingPasses(true));\n+      passes.addAll(getCodeRemovingPasses());\n       passes.add(smartNamePass);\n     }\n \n       passes.add(inlineGetters);\n     }\n \n-    passes.addAll(getCodeRemovingPasses(false));\n+    passes.addAll(getCodeRemovingPasses());\n \n     if (options.inlineFunctions || options.inlineLocalFunctions) {\n       passes.add(inlineFunctions);\n   }\n \n   /** Creates several passes aimed at removing code. */\n-  private List<PassFactory> getCodeRemovingPasses(\n-      boolean beforeSmartNameRemoval) {\n+  private List<PassFactory> getCodeRemovingPasses() {\n     List<PassFactory> passes = Lists.newArrayList();\n-    if ((options.inlineVariables || options.inlineLocalVariables)\n-        && !beforeSmartNameRemoval) {\n+    if (options.inlineVariables || options.inlineLocalVariables) {\n       passes.add(inlineVariables);\n     } else if (options.inlineConstantVars) {\n       passes.add(inlineConstants);\n       return new CollapseProperties(\n           compiler, options.collapsePropertiesOnExternTypes,\n           !isInliningForbidden());\n-    }\n-  };\n-\n-  /**\n-   * Undo the renaming to $$CONSTANT that we're doing to preserve\n-   * annotations.\n-   */\n-  private final PassFactory undoConstantRenaming =\n-      new PassFactory(\"undoConstantNames\", true) {\n-    @Override\n-    protected CompilerPass createInternal(AbstractCompiler compiler) {\n-      return new MakeDeclaredNamesUnique.UndoConstantRenaming(compiler);\n-    }\n-  };\n-\n-  /**\n-   * Add $$CONSTANT to names of constant variables, to preserve the\n-   * {@code @const} annotation.\n-   */\n-  private final PassFactory renameConstants =\n-      new PassFactory(\"renameConstants\", false) {\n-    @Override\n-    protected CompilerPass createInternal(AbstractCompiler compiler) {\n-      return new Normalize(compiler, false).new RenameConstants();\n     }\n   };\n \n--- a/src/com/google/javascript/jscomp/Denormalize.java\n+++ b/src/com/google/javascript/jscomp/Denormalize.java\n package com.google.javascript.jscomp;\n \n import com.google.common.base.Preconditions;\n+import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n import com.google.javascript.jscomp.NodeTraversal.Callback;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n       compiler.reportCodeChange();\n     }\n   }\n+\n+  static class StripConstantAnnotations\n+      extends AbstractPostOrderCallback\n+      implements CompilerPass {\n+    private AbstractCompiler compiler;\n+\n+    StripConstantAnnotations(AbstractCompiler compiler) {\n+      this.compiler = compiler;\n+    }\n+\n+    @Override\n+    public void process(Node externs, Node js) {\n+      NodeTraversal.traverse(compiler, externs, this);\n+      NodeTraversal.traverse(compiler, js, this);\n+    }\n+\n+    @Override\n+    public void visit(NodeTraversal t, Node node, Node parent) {\n+      if (node.getType() == Token.NAME || node.getType() == Token.STRING) {\n+        node.removeProp(Node.IS_CONSTANT_NAME);\n+      }\n+    }\n+  }\n }\n--- a/src/com/google/javascript/jscomp/FunctionArgumentInjector.java\n+++ b/src/com/google/javascript/jscomp/FunctionArgumentInjector.java\n         argMap.put(fnArg.getString(), cArg);\n         cArg = cArg.getNext();\n       } else {\n-        argMap.put(fnArg.getString(), Node.newString(Token.NAME, \"undefined\"));\n+        argMap.put(fnArg.getString(), NodeUtil.newUndefinedNode());\n       }\n     }\n \n--- a/src/com/google/javascript/jscomp/FunctionInjector.java\n+++ b/src/com/google/javascript/jscomp/FunctionInjector.java\n     FunctionToBlockMutator mutator = new FunctionToBlockMutator(\n         compiler, this.safeNameIdSupplier);\n \n-    // Remove const marker from the label name\n-    String fnNameClean = Normalize.removeConstantMarkerFromName(fnName);\n-\n     Node newBlock = mutator.mutate(\n-        fnNameClean, fnNode, callNode, resultName,\n+        fnName, fnNode, callNode, resultName,\n         needsDefaultReturnResult, isCallInLoop);\n \n     // TODO(nicksantos): Create a common mutation function that\n--- a/src/com/google/javascript/jscomp/FunctionToBlockMutator.java\n+++ b/src/com/google/javascript/jscomp/FunctionToBlockMutator.java\n       Node name = n.getFirstChild();\n       // It isn't initialized.\n       if (!name.hasChildren()) {\n-        name.addChildToBack(Node.newString(Token.NAME, \"undefined\"));\n+        name.addChildToBack(NodeUtil.newUndefinedNode());\n       }\n       return;\n     }\n     NodeTraversal.traverse(\n         compiler, fnNode, new MakeDeclaredNamesUnique(\n             new InlineRenamer(\n-                compiler.getUniqueNameIdSupplier(), \n+                compiler.getUniqueNameIdSupplier(),\n                 \"JSCompiler_inline_\",\n                 isCallInLoop)));\n   }\n--- a/src/com/google/javascript/jscomp/MakeDeclaredNamesUnique.java\n+++ b/src/com/google/javascript/jscomp/MakeDeclaredNamesUnique.java\n       case Token.NAME:\n         String newName = getReplacementName(n.getString());\n         if (newName != null) {\n+          Renamer renamer = nameStack.peek();\n+          if (renamer.stripConstIfReplaced()) {\n+            // TODO(johnlenz): Do we need to do anything about the javadoc?\n+            n.removeProp(Node.IS_CONSTANT_NAME);\n+          }\n           n.setString(newName);\n           t.getCompiler().reportCodeChange();\n         }\n     String getReplacementName(String oldName);\n \n     /**\n+     * @return Whether the constant-ness of a name should be removed.\n+     */\n+    boolean stripConstIfReplaced();\n+\n+    /**\n      * @return A Renamer for a scope within the scope of the current Renamer.\n      */\n     Renamer forChildScope();\n     }\n \n     public void process(Node externs, Node js) {\n-      new UndoConstantRenaming(compiler).process(externs, js);\n       NodeTraversal.traverse(compiler, js, this);\n     }\n \n \n             nameMap.put(var, newName);\n           }\n-        }\n-      }\n-    }\n-  }\n-\n-  static class UndoConstantRenaming extends AbstractPostOrderCallback\n-      implements CompilerPass {\n-    private AbstractCompiler compiler;\n-\n-    /**\n-     * Keep a hash table mapping variable names with $$constant to the\n-     * equivalent name with $$constant removed.  This avoids running\n-     * String.replace on the same strings over and over.\n-     */\n-    private Map<String, String> constantRenamingCache =\n-        Maps.newHashMap();\n-\n-    UndoConstantRenaming(AbstractCompiler compiler) {\n-      this.compiler = compiler;\n-    }\n-\n-    @Override\n-    public void process(Node externs, Node js) {\n-      NodeTraversal.traverse(compiler, js, this);\n-    }\n-\n-    @Override\n-    public void visit(NodeTraversal t, Node node, Node parent) {\n-      if (node.getType() == Token.NAME) {\n-        String name = node.getString();\n-        if (name.contains(NodeUtil.CONSTANT_MARKER)) {\n-          // Make sure there is not more than one constant marker, or something\n-          // has gone terribly wrong.\n-          Preconditions.checkState(name.indexOf(NodeUtil.CONSTANT_MARKER) ==\n-              name.lastIndexOf(NodeUtil.CONSTANT_MARKER));\n-\n-          String constantFreeName = constantRenamingCache.get(name);\n-          if (constantFreeName == null) {\n-            constantFreeName = name.replace(NodeUtil.CONSTANT_MARKER, \"\");\n-            constantRenamingCache.put(name, constantFreeName);\n-          }\n-          node.setString(constantFreeName);\n-          node.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n-          compiler.reportCodeChange();\n         }\n       }\n     }\n     private int incrementNameCount(String name) {\n       return nameUsage.add(name, 1);\n     }\n+\n+    @Override\n+    public boolean stripConstIfReplaced() {\n+      return false;\n+    }\n   }\n \n \n       if (name.isEmpty()) {\n         return name;\n       }\n-      if (removeConstness) {\n-        // When inlining call within loops, constants lose there\n-        // const-ness, this supports that necessary change.\n-        name = name.replace(NodeUtil.CONSTANT_MARKER, \"\");\n-      }\n       return namePrefix + name + \"_\" + uniqueIdSupplier.get();\n     }\n \n     public Renamer forChildScope() {\n       return new InlineRenamer(uniqueIdSupplier, namePrefix, removeConstness);\n     }\n+\n+    @Override\n+    public boolean stripConstIfReplaced() {\n+      return removeConstness;\n+    }\n   }\n \n }\n--- a/src/com/google/javascript/jscomp/NodeTypeNormalizer.java\n+++ b/src/com/google/javascript/jscomp/NodeTypeNormalizer.java\n  */\n class NodeTypeNormalizer implements CompilerPass {\n \n-  private CodeChangeHandler changeHandler;\n+  private final boolean assertOnChange;\n \n   NodeTypeNormalizer() {\n-    this(null);\n+    this(false);\n   }\n \n-  NodeTypeNormalizer(CodeChangeHandler changeHandler) {\n-    this.changeHandler = changeHandler;\n+  NodeTypeNormalizer(boolean forbidChanges) {\n+    this.assertOnChange = forbidChanges;\n   }\n \n   private void reportChange() {\n-    if (changeHandler != null) {\n-      changeHandler.reportChange();\n+    if (assertOnChange) {\n+      Preconditions.checkState(false, \"normalizeNodeType constraints violated\");\n     }\n   }\n \n     // Remove unused properties to minimize differences between ASTs\n     // produced by the two parsers.\n     if (n.getType() == Token.FUNCTION) {\n-      n.removeProp(Node.FUNCTION_PROP);\n-      reportChange();\n+      Preconditions.checkState(n.getProp(Node.FUNCTION_PROP) == null);\n     }\n \n     normalizeBlocks(n);\n--- a/src/com/google/javascript/jscomp/NodeUtil.java\n+++ b/src/com/google/javascript/jscomp/NodeUtil.java\n    * @return True if the variable is constant\n    */\n   static boolean isConstantName(Node node) {\n-    return node.getString().contains(CONSTANT_MARKER);\n+    return node.getBooleanProp(Node.IS_CONSTANT_NAME);\n   }\n \n   /**\n--- a/src/com/google/javascript/jscomp/Normalize.java\n+++ b/src/com/google/javascript/jscomp/Normalize.java\n \n   @Override\n   public void process(Node externs, Node root) {\n-    new RenameConstants().process(externs, root);\n-\n     NodeTraversal.traverse(compiler, root, this);\n     if (MAKE_LOCAL_NAMES_UNIQUE) {\n       MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n       t.traverseRoots(externs, root);\n     }\n     removeDuplicateDeclarations(root);\n+    new PropogateConstantAnnotations(compiler, assertOnChange)\n+        .process(externs, root);\n   }\n \n   @Override\n     return true;\n   }\n \n-  class RenameConstants extends AbstractPostOrderCallback\n+  public static class PropogateConstantAnnotations\n+      extends AbstractPostOrderCallback\n       implements CompilerPass {\n+    private final AbstractCompiler compiler;\n+    private final boolean assertOnChange;\n+\n+    public PropogateConstantAnnotations(\n+        AbstractCompiler compiler, boolean forbidChanges) {\n+      this.compiler = compiler;\n+      this.assertOnChange = forbidChanges;\n+    }\n+\n     @Override\n     public void process(Node externs, Node root) {\n-      NodeTraversal.traverse(compiler, root, this);\n+      new NodeTraversal(compiler, this).traverseRoots(externs, root);\n     }\n \n     @Override\n     public void visit(NodeTraversal t, Node n, Node parent) {\n+      // Note: Constant properties annotations are not propagated.\n       if (n.getType() == Token.NAME) {\n-        // If the normalize pass has already been run, this will already have\n-        // been renamed.\n         if (n.getString().isEmpty()) {\n           return;\n         }\n         JSDocInfo info = null;\n         // Find the JSDocInfo for a top level variable.\n         Var var = t.getScope().getVar(n.getString());\n-        if (var == null) {\n-          // We do not want to rename names defined in externs,\n-          // and this pass is not traversing the externs.\n-          n.putBooleanProp(Node.IS_CONSTANT_NAME, false);\n-          return;\n-        } else {\n+        if (var != null) {\n           info = var.getJSDocInfo();\n         }\n \n-        if (NodeUtil.isConstantName(n)) {\n-          // TODO(johnlenz): Enable this check generally when all the passes\n-          // are fixed.\n-          // Preconditions.checkState(n.getBooleanProp(Node.IS_CONSTANT_NAME),\n-          //    \"Constant missing constant annotation\");\n-          return;\n-        }\n-\n-        if ((info != null && info.isConstant()) ||\n-            n.getBooleanProp(Node.IS_CONSTANT_NAME)) {\n+        if ((info != null && info.isConstant()) &&\n+            !n.getBooleanProp(Node.IS_CONSTANT_NAME)) {\n           n.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n-          n.setString(addConstantMarkerToName(n.getString()));\n-          reportCodeChange(\"rename constant var\");\n+          if (assertOnChange) {\n+            String name = n.getString();\n+            throw new IllegalStateException(\n+                \"Unexpected const change.\\n\" +\n+                \"  name: \"+ name + \"\\n\" +\n+                \"  gramps:\" + n.getParent().getParent().toStringTree());\n+          }\n+          // Even though the AST has changed (an annotation was added),\n+          // the annotations are not compared so don't report the change.\n+          // reportCodeChange(\"constant annotation\");\n         }\n       }\n     }\n-  }\n-\n-  static String addConstantMarkerToName(String name) {\n-    return name + NodeUtil.CONSTANT_MARKER;\n-  }\n-\n-  static String removeConstantMarkerFromName(String name) {\n-    return name.replace(NodeUtil.CONSTANT_MARKER, \"\");\n   }\n \n   /**\n \n     @Override\n     public void visit(NodeTraversal t, Node n, Node parent) {\n-      if (n.getType() == Token.NAME || n.getType() == Token.STRING) {\n+      if (n.getType() == Token.NAME) {\n         String name = n.getString();\n         if (n.getString().isEmpty()) {\n           return;\n         boolean isConst = n.getBooleanProp(Node.IS_CONSTANT_NAME);\n         if (checkUserDeclarations) {\n           boolean expectedConst = false;\n-          if (NodeUtil.isConstantName(n)) {\n+          if (NodeUtil.isConstantName(n)\n+              || compiler.getCodingConvention().isConstant(n.getString())) {\n             expectedConst = true;\n           } else {\n             expectedConst = false;\n           constantMap.put(name, isConst);\n         } else {\n           Preconditions.checkState(value.booleanValue() == isConst,\n-              \"The name \" + name + \"is not consistently annotated as \" +\n+              \"The name \" + name + \" is not consistently annotated as \" +\n               \"constant.\");\n         }\n       }\n--- a/src/com/google/javascript/jscomp/PhaseOptimizer.java\n+++ b/src/com/google/javascript/jscomp/PhaseOptimizer.java\n   /**\n    * Marks the end of a pass.\n    */\n-  private void endPass(Node root) {\n+  private void endPass(Node externs, Node root) {\n     Preconditions.checkState(currentTracer != null && currentPassName != null);\n     stopTracer(currentTracer, currentPassName);\n     String passToCheck = currentPassName;\n     currentPassName = null;\n     currentTracer = null;\n \n-    maybeSanityCheck(root);\n+    try {\n+      maybeSanityCheck(externs, root);\n+    } catch (Exception e) {\n+      // TODO(johnlenz): Remove this once the normalization checks report\n+      // errors instead of exceptions.\n+      throw new RuntimeException(\"Sanity check failed for \" + passToCheck, e);\n+    }\n   }\n \n   /**\n    * Runs the sanity check if it is available.\n    */\n-  void maybeSanityCheck(Node root) {\n+  void maybeSanityCheck(Node externs, Node root) {\n     if (sanityCheck != null) {\n-      sanityCheck.create(compiler).process(null, root);\n+      sanityCheck.create(compiler).process(externs, root);\n     }\n   }\n \n       logger.info(name);\n       startPass(name);\n       processInternal(externs, root);\n-      endPass(root);\n+      endPass(externs, root);\n     }\n \n     abstract void processInternal(Node externs, Node root);\n--- a/src/com/google/javascript/jscomp/RemoveUnusedVars.java\n+++ b/src/com/google/javascript/jscomp/RemoveUnusedVars.java\n \n import com.google.common.base.Preconditions;\n import com.google.common.collect.Sets;\n+import com.google.javascript.jscomp.Scope.Var;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n \n    * Keeps track of what variables we've warned about, so that we don't do it\n    * on subsequent traversals.\n    */\n-  private final Set<Scope.Var> warnedVars_ = Sets.newHashSet();\n+  private final Set<Var> warnedVars_ = Sets.newHashSet();\n+\n+  /**\n+   * Keep track of variables that we've referenced.\n+   */\n+  private final Set<Var> referenced = Sets.newHashSet();\n \n   RemoveUnusedVars(\n       AbstractCompiler compiler,\n     int i = 0;\n     do {\n       numRemoved_ = 0;\n+      referenced.clear();\n       traverseAndRemoveUnusedReferences(root);\n \n       if (numRemoved_ > 0) {\n       case Token.NAME:\n         if (parent.getType() != Token.VAR) {\n           // All non-var declarations are references to other vars\n-          Scope.Var var = scope.getVar(n.getString());\n+          Var var = scope.getVar(n.getString());\n           if (var != null) {\n             markReferencedVar(var);\n           }\n     Node argList = function.getFirstChild().getNext();\n     Node lastArg;\n     while ((lastArg = argList.getLastChild()) != null) {\n-      Scope.Var var = fnScope.getVar(lastArg.getString());\n-      if (!var.referenced) {\n+      Var var = fnScope.getVar(lastArg.getString());\n+      if (!referenced.contains(var)) {\n         argList.removeChild(lastArg);\n         fnScope.undeclare(var);\n         numRemoved_++;\n   /**\n    * Marks a var as referenced, recursing into any functions.\n    */\n-  private void markReferencedVar(Scope.Var var) {\n-    if (var.referenced) {\n+  private void markReferencedVar(Var var) {\n+    if (referenced.contains(var)) {\n       // Already marked\n       return;\n     }\n-    var.referenced = true;\n+    referenced.add(var);\n \n     Node parent = var.getParentNode();\n     if (parent.getType() == Token.FUNCTION &&\n   private void removeUnreferencedVars(Scope scope) {\n     CodingConvention convention = compiler_.getCodingConvention();\n \n-    for (Iterator<Scope.Var> it = scope.getVars(); it.hasNext(); ) {\n-      Scope.Var var = it.next();\n-\n-      if (!var.referenced &&\n+    for (Iterator<Var> it = scope.getVars(); it.hasNext(); ) {\n+      Var var = it.next();\n+\n+      if (!referenced.contains(var) &&\n           (var.isLocal() || !convention.isExported(var.name))) {\n \n         compiler_.addToDebugLog(\"Unreferenced var: \" + var.name);\n--- a/src/com/google/javascript/jscomp/SanityCheck.java\n+++ b/src/com/google/javascript/jscomp/SanityCheck.java\n         new CodeChangeHandler.RecentChange();\n     compiler.addChangeHandler(handler);\n \n-    new NodeTypeNormalizer(handler).process(null, root);\n+    // TODO(johnlenz): Change these normalization checks Preconditions and\n+    // Exceptions into Errors so that it is easier to find the root cause\n+    // when there are cascading issues.\n+    new NodeTypeNormalizer(true).process(null, root);\n     Preconditions.checkState(!handler.hasCodeChanged(),\n-        \"normalizeNodeType constraints violated by last pass\");\n+        \"This should never fire, NodeTypeNormalizer should assert first.\");\n \n     if (compiler.isNormalized()) {\n       (new Normalize(compiler, true)).process(externs, root);\n       Preconditions.checkState(!handler.hasCodeChanged(),\n-          \"normalize constraints violated by last pass\");\n+          \"This should never fire, Normalize should assert first.\");\n+\n+      boolean checkUserDeclarations = true;\n+      CompilerPass pass = new Normalize.VerifyConstants(\n+          compiler, checkUserDeclarations);\n+      pass.process(externs, root);\n     }\n \n     compiler.removeChangeHandler(handler);\n--- a/src/com/google/javascript/jscomp/Scope.java\n+++ b/src/com/google/javascript/jscomp/Scope.java\n     /** Input source */\n     CompilerInput input;\n \n-    /** Whether it's been referenced */\n-    boolean referenced;\n-\n     /** Whether the variable is a define */\n     boolean isDefine;\n \n     var.name = name;\n     var.nameNode = nameNode;\n     var.type = type;\n-    var.referenced = false;\n     var.scope = this;\n     var.index = vars.size();\n     var.input = input;\n--- a/test/com/google/javascript/jscomp/FunctionInjectorTest.java\n+++ b/test/com/google/javascript/jscomp/FunctionInjectorTest.java\n         \"for(;1;){ foo(1); }\",\n         \"function foo(a){var b;return a;}; \" +\n         \"for(;1;){ {\" +\n-            \"var JSCompiler_inline_b_3=undefined;1}}\",\n+            \"var JSCompiler_inline_b_3=void 0;1}}\",\n         \"foo\", INLINE_BLOCK);\n \n     helperInlineReferenceToFunction(\n         \"do{ foo(1); } while(1)\",\n         \"function foo(a){var b;return a;}; \" +\n         \"do{ {\" +\n-            \"var JSCompiler_inline_b_3=undefined;1}}while(1)\",\n+            \"var JSCompiler_inline_b_3=void 0;1}}while(1)\",\n         \"foo\", INLINE_BLOCK);\n \n     helperInlineReferenceToFunction(\n         \"function foo(){return _g;}; \" +\n         \"function x() {\" +\n         \"  {var JSCompiler_inline_result_0; JSCompiler_inline_result_0=_g;}\" +\n-        \"  var CONSTANT_RESULT$$constant = JSCompiler_inline_result_0;\" +\n+        \"  var CONSTANT_RESULT = JSCompiler_inline_result_0;\" +\n         \"}\",\n         \"foo\", INLINE_BLOCK);\n   }\n--- a/test/com/google/javascript/jscomp/FunctionToBlockMutatorTest.java\n+++ b/test/com/google/javascript/jscomp/FunctionToBlockMutatorTest.java\n   public void testMutateInitializeUninitializedVars1() {\n     helperMutate(\n         \"function foo(a){var b;return a;}; foo(1);\",\n-        \"{var JSCompiler_inline_b_3=undefined;1}\",\n+        \"{var JSCompiler_inline_b_3=void 0;1}\",\n         \"foo\", null, false, true);\n   }\n \n     // baseline: outside a loop, the constant remains constant.\n     boolean callInLoop = false;\n     helperMutate(\n-        \"function foo(a){var b$$constant = bar(); a;}; foo(1);\",\n-        \"{var JSCompiler_inline_b$$constant_3=bar(); 1;}\",\n+        \"function foo(a){var B = bar(); a;}; foo(1);\",\n+        \"{var JSCompiler_inline_B_3=bar(); 1;}\",\n         \"foo\", null, false, callInLoop);\n     // ... in a loop, the constant-ness is removed.\n+    // TODO(johnlenz): update this test to look for the const annotation.\n     callInLoop = true;\n     helperMutate(\n-        \"function foo(a){var b$$constant = bar(); a;}; foo(1);\",\n-        \"{var JSCompiler_inline_b_3 = bar(); 1;}\",\n+        \"function foo(a){var B = bar(); a;}; foo(1);\",\n+        \"{var JSCompiler_inline_B_3 = bar(); 1;}\",\n         \"foo\", null, false, callInLoop);\n   }  \n \n--- a/test/com/google/javascript/jscomp/InlineFunctionsTest.java\n+++ b/test/com/google/javascript/jscomp/InlineFunctionsTest.java\n \n   public void testNoInlineIfParametersModified6() {\n     test(\"function f(x,y){return x?(y=2):0}f(2)\",\n-         \"{var JSCompiler_inline_y_3=undefined;2?(\" +\n+         \"{var JSCompiler_inline_y_3=void 0;2?(\" +\n          \"JSCompiler_inline_y_3=2):0}\");\n   }\n \n \n   public void testInlineFunctionWithArgsMismatch1() {\n     test(\"function f(g) { return g; } f();\",\n-         \"undefined\");\n+         \"void 0\");\n   }\n \n   public void testInlineFunctionWithArgsMismatch2() {\n \n   public void testInlineFunctionWithArgsMismatch3() {\n     test(\"function f(one, two, three) { return one + two + three; } f(1);\",\n-         \"1+undefined+undefined\");\n+         \"1+void 0+void 0\");\n   }\n \n   public void testInlineFunctionWithArgsMismatch4() {\n--- a/test/com/google/javascript/jscomp/InlineVariablesTest.java\n+++ b/test/com/google/javascript/jscomp/InlineVariablesTest.java\n         \"  /** @const */\\n\" +\n         \"  var X = 1; X;\\n\" +\n         \"}\",\n-        \"var X$$constant=1; X$$constant; function f() {1;}\");\n+        \"var X=1; X; function f() {1;}\");\n   }\n }\n--- a/test/com/google/javascript/jscomp/MakeDeclaredNamesUniqueTest.java\n+++ b/test/com/google/javascript/jscomp/MakeDeclaredNamesUniqueTest.java\n     testSame(\"try { } catch(e) {e; try { } catch(e$$1) {e$$1;} }; \");\n     testSame(\"var a$$1;\");\n     testSame(\"function f() { var $$; }\");\n-    test(\"var CONST$$constant = 3; var b = CONST$$constant;\",\n+    test(\"var CONST = 3; var b = CONST;\",\n          \"var CONST = 3; var b = CONST;\");\n-    test(\"function() {var CONST$$constant = 3; var ACONST$$constant$$1 = 2;}\",\n+    test(\"function() {var CONST = 3; var ACONST$$1 = 2;}\",\n          \"function() {var CONST = 3; var ACONST = 2;}\");\n   }\n \n   public void testConstRemovingRename1() {\n     removeConst = true;\n-    test(\"function() {var CONST$$constant = 3; var ACONST$$constant$$1 = 2;}\",\n+    test(\"function() {var CONST = 3; var ACONST$$1 = 2;}\",\n          \"function() {var unique_CONST_0 = 3; var unique_ACONST$$1_1 = 2;}\");\n   }\n \n   public void testConstRemovingRename2() {\n     removeConst = true;\n-    test(\"var CONST$$constant = 3; var b = CONST$$constant;\",\n+    test(\"var CONST = 3; var b = CONST;\",\n          \"var unique_CONST_0 = 3; var unique_b_1 = unique_CONST_0;\");\n   }\n }\n--- a/test/com/google/javascript/jscomp/NormalizeTest.java\n+++ b/test/com/google/javascript/jscomp/NormalizeTest.java\n          \"try { } catch(e) {e; try { } catch(e$$1) {e$$1;} }; \");\n \n     // Verify global redefinition of extern definition is left alone.\n-    testSame(\"var window\");\n+    testSame(\"/** @suppress {duplicate} */\\nvar window;\");\n \n     // Verify local masking extern made unique.\n     test(\"function f() {var window}\",\n \n   public void testRenamingConstants() {\n     test(\"var ACONST = 4;var b = ACONST;\",\n-         \"var ACONST$$constant = 4; var b = ACONST$$constant;\");\n+         \"var ACONST = 4; var b = ACONST;\");\n \n     test(\"var a, ACONST = 4;var b = ACONST;\",\n-         \"var a; var ACONST$$constant = 4; var b = ACONST$$constant;\");\n+         \"var a; var ACONST = 4; var b = ACONST;\");\n \n     test(\"var ACONST; ACONST = 4; var b = ACONST;\",\n-         \"var ACONST$$constant; ACONST$$constant = 4;\" +\n-         \"var b = ACONST$$constant;\");\n+         \"var ACONST; ACONST = 4;\" +\n+         \"var b = ACONST;\");\n \n     test(\"var ACONST = new Foo(); var b = ACONST;\",\n-         \"var ACONST$$constant = new Foo(); var b = ACONST$$constant;\");\n-\n-    test(\"/** @const */var aa; aa=1;\", \"var aa$$constant;aa$$constant=1\");\n+         \"var ACONST = new Foo(); var b = ACONST;\");\n+\n+    test(\"/** @const */var aa; aa=1;\", \"var aa;aa=1\");\n   }\n \n   public void testSkipRenamingExterns() {\n   }\n \n   private class WithCollapse extends CompilerTestCase {\n-     private void testConstantProperties() {\n+    WithCollapse() {\n+      enableNormalize();\n+    }\n+\n+    private void testConstantProperties() {\n       test(\"var a={}; a.ACONST = 4;var b = a.ACONST;\",\n-            \"var a$ACONST$$constant = 4; var b = a$ACONST$$constant;\");\n+            \"var a$ACONST = 4; var b = a$ACONST;\");\n \n       test(\"var a={b:{}}; a.b.ACONST = 4;var b = a.b.ACONST;\",\n-           \"var a$b$ACONST$$constant = 4;var b = a$b$ACONST$$constant;\");\n+           \"var a$b$ACONST = 4;var b = a$b$ACONST;\");\n \n       test(\"var a = {FOO: 1};var b = a.FOO;\",\n-           \"var a$FOO$$constant = 1; var b = a$FOO$$constant;\");\n+           \"var a$FOO = 1; var b = a$FOO;\");\n \n       test(\"var EXTERN; var ext; ext.FOO;\", \"var b = EXTERN; var c = ext.FOO\",\n            \"var b = EXTERN; var c = ext.FOO\", null, null);\n \n       test(\"var a={}; a.ACONST = 4; var b = a.ACONST;\",\n-           \"var a$ACONST$$constant = 4; var b = a$ACONST$$constant;\");\n+           \"var a$ACONST = 4; var b = a$ACONST;\");\n \n       test(\"var a = {}; function foo() { var d = a.CONST; };\" +\n            \"(function(){a.CONST=4})();\",\n-           \"var a$CONST$$constant;function foo(){var d = a$CONST$$constant;};\" +\n-           \"(function(){a$CONST$$constant = 4})();\");\n+           \"var a$CONST;function foo(){var d = a$CONST;};\" +\n+           \"(function(){a$CONST = 4})();\");\n \n       test(\"var a = {}; a.ACONST = new Foo(); var b = a.ACONST;\",\n-           \"var a$ACONST$$constant = new Foo(); var b = a$ACONST$$constant;\");\n-     }\n-\n-     @Override\n-     protected int getNumRepetitions() {\n-       // The normalize pass is only run once.\n-        return 1;\n-     }\n-\n-     @Override\n-     public CompilerPass getProcessor(final Compiler compiler) {\n-       return new CompilerPass() {\n-         public void process(Node externs, Node root) {\n-           new CollapseProperties(compiler, false, true).process(externs, root);\n-           new Normalize(compiler, false).new RenameConstants().process(\n-               externs, root);\n-         }\n-       };\n-     }\n-   }\n-\n+           \"var a$ACONST = new Foo(); var b = a$ACONST;\");\n+    }\n+\n+    @Override\n+    protected int getNumRepetitions() {\n+      // The normalize pass is only run once.\n+      return 1;\n+    }\n+\n+    @Override\n+    public CompilerPass getProcessor(final Compiler compiler) {\n+      return new CompilerPass() {\n+        public void process(Node externs, Node root) {\n+          new CollapseProperties(compiler, false, true).process(externs, root);\n+        }\n+      };\n+    }\n+  }\n }\n--- a/test/com/google/javascript/jscomp/SanityCheckTest.java\n+++ b/test/com/google/javascript/jscomp/SanityCheckTest.java\n     try {\n       test(\"var x = 3;\", \"var x=3;0;0\");\n     } catch (IllegalStateException e) {\n-      assertEquals(\"normalizeNodeType constraints violated by last pass\",\n+      assertEquals(\"normalizeNodeType constraints violated\",\n           e.getMessage());\n       exceptionCaught = true;\n     }\n-    assert(exceptionCaught);\n+    assertTrue(exceptionCaught);\n   }\n \n   public void testUnnormalized() throws Exception {\n           \"Normalize constraints violated:\\nWHILE node\"));\n       exceptionCaught = true;\n     }\n-    assert(exceptionCaught);\n+    assertTrue(exceptionCaught);\n+  }\n+\n+  public void testConstantAnnotationMismatch() throws Exception {\n+    otherPass = new CompilerPass() {\n+      @Override public void process(Node externs, Node root) {\n+        getLastCompiler().reportCodeChange();\n+        Node name = Node.newString(Token.NAME, \"x\");\n+        name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n+        root.addChildToBack(new Node(Token.EXPR_RESULT, name));\n+        getLastCompiler().setNormalized();\n+      }\n+    };\n+\n+    boolean exceptionCaught = false;\n+    try {\n+      test(\"var x;\", \"var x; x;\");\n+    } catch (RuntimeException e) {\n+      assertTrue(e.getMessage().contains(\n+          \"The name x is not consistently annotated as constant.\"));\n+      exceptionCaught = true;\n+    }\n+    assertTrue(exceptionCaught);\n   }\n \n   public void testSymbolTable() throws Exception {", "timestamp": 1261095609, "metainfo": ""}