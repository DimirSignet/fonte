{"sha": "41c1bcc059d230dce1d2afc78a18ef08b50e30fe", "log": "In \"for(x in exp)\" exp is only executed once.  R=nicksantos DELTA=89  (61 added, 9 deleted, 19 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=4662   ", "commit": "\n--- a/src/com/google/javascript/jscomp/ControlFlowAnalysis.java\n+++ b/src/com/google/javascript/jscomp/ControlFlowAnalysis.java\n       Node item = forNode.getFirstChild();\n       Node collection = item.getNext();\n       Node body = collection.getNext();\n+      // The collection behaves like init.\n+      createEdge(collection, Branch.UNCOND, forNode);\n       // The edge that transfer control to the beginning of the loop body.\n       createEdge(forNode, Branch.ON_TRUE, computeFallThrough(body));\n       // The edge to end of the loop.\n         return computeFallThrough(n.getFirstChild());\n       case Token.FOR:\n         if (NodeUtil.isForIn(n)) {\n-          return n;\n+          return n.getFirstChild().getNext();\n         }\n         return computeFallThrough(n.getFirstChild());\n       case Token.LABEL:\n--- a/src/com/google/javascript/jscomp/ControlFlowGraph.java\n+++ b/src/com/google/javascript/jscomp/ControlFlowGraph.java\n         // for(var x = 0; x < 10; x++) { } has a graph that is isomorphic to\n         // var x = 0; while(x<10) {  x++; }\n         if (NodeUtil.isForIn(parent)) {\n-          return n == parent.getLastChild();\n+          // TODO(user): Investigate how we should handle the case where\n+          // we have a very complex expression inside the FOR-IN header.\n+          return n != parent.getFirstChild();\n         } else {\n           return NodeUtil.getConditionExpression(parent) != n;\n         }\n--- a/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java\n+++ b/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java\n         public void visit(NodeTraversal t, Node n, Node parent) {\n           if (n.isName()) {\n \n+            // n.getParent() isn't null. This just the case where n is the root\n+            // node that gatherCb started at.\n+            if (parent == null) {\n+              return;\n+            }\n+\n             // Make sure that the name node is purely a read.\n             if ((NodeUtil.isAssignmentOp(parent) && parent.getFirstChild() == n)\n-                || parent.isVar() || parent.isInc() ||\n-                parent.isDec() || parent.isParamList() ||\n-                parent.isCatch()) {\n+                || parent.isVar() || parent.isInc() || parent.isDec() ||\n+                parent.isParamList() || parent.isCatch()) {\n               return;\n             }\n \n--- a/src/com/google/javascript/jscomp/LiveVariablesAnalysis.java\n+++ b/src/com/google/javascript/jscomp/LiveVariablesAnalysis.java\n             // for(var x in y) {...}\n             lhs = lhs.getLastChild();\n           }\n+\n           if (lhs.isName()) {\n             addToSetIfLocal(lhs, kill);\n             addToSetIfLocal(lhs, gen);\n           } else {\n             computeGenKill(lhs, gen, kill, conditional);\n           }\n-          computeGenKill(rhs, gen, kill, conditional);\n+\n+          // rhs is executed only once so we don't go into it every loop.\n         }\n         return;\n \n--- a/src/com/google/javascript/jscomp/UnreachableCodeElimination.java\n+++ b/src/com/google/javascript/jscomp/UnreachableCodeElimination.java\n       return;\n     }\n \n+    // TODO(user): This is a problem with removeNoOpStatements. Everything\n+    // every expression in a FOR-IN header looks like side effect free on it's\n+    // own.\n+    if (NodeUtil.isForIn(parent)) {\n+      return;\n+    }\n+\n     switch (n.getType()) {\n       // Removing an unreachable DO node is messy because it means we still have\n       // to execute one iteration. If the DO's body has breaks in the middle, it\n     if (logger.isLoggable(Level.FINE)) {\n       logger.fine(\"Removing \" + n.toString());\n     }\n+\n     NodeUtil.removeChild(n.getParent(), n);\n   }\n }\n--- a/test/com/google/javascript/jscomp/CoalesceVariableNamesTest.java\n+++ b/test/com/google/javascript/jscomp/CoalesceVariableNamesTest.java\n         \"};\");\n   }\n \n+  public void testForInWithAssignment() {\n+    inFunction(\n+      \"var _f = function (commands) {\" +\n+          \"  var k, v, ref;\" +\n+          \"  for (k in ref = commands) {\" +\n+          \"    v = ref[k];\" +\n+          \"    alert(k + ':' + v);\" +\n+          \"  }\" +\n+          \"}\",\n+\n+      \"var _f = function (commands) {\" +\n+          \"  var k,ref;\" +\n+          \"  for (k in ref = commands) {\" +\n+          \"    commands = ref[k];\" +\n+          \"    alert(k + ':' + commands);\" +\n+          \"  }\" +\n+          \"}\"\n+        );\n+  }\n \n   public void testUsePseduoNames() {\n     usePseudoName = true;\n--- a/test/com/google/javascript/jscomp/ControlFlowAnalysisTest.java\n+++ b/test/com/google/javascript/jscomp/ControlFlowAnalysisTest.java\n       \"  node1 -> node2 [weight=1];\\n\" +\n       \"  node3 [label=\\\"NAME\\\"];\\n\" +\n       \"  node1 -> node3 [weight=1];\\n\" +\n-      \"  node4 [label=\\\"FOR\\\"];\\n\" +\n-      \"  node1 -> node4 \" +\n-      \"[label=\\\"UNCOND\\\", fontcolor=\\\"red\\\", weight=0.01, color=\\\"red\\\"];\\n\" +\n-      \"  node0 -> node4 [weight=1];\\n\" +\n-      \"  node5 [label=\\\"NAME\\\"];\\n\" +\n-      \"  node4 -> node5 [weight=1];\\n\" +\n+      \"  node4 [label=\\\"NAME\\\"];\\n\" +\n+      \"  node1 -> node4 [label=\\\"UNCOND\\\", fontcolor=\\\"red\\\", weight=0.01, color=\\\"red\\\"];\\n\" +\n+      \"  node5 [label=\\\"FOR\\\"];\\n\" +\n+      \"  node0 -> node5 [weight=1];\\n\" +\n       \"  node6 [label=\\\"NAME\\\"];\\n\" +\n-      \"  node4 -> node6 [weight=1];\\n\" +\n+      \"  node5 -> node6 [weight=1];\\n\" +\n+      \"  node5 -> node4 [weight=1];\\n\" +\n+      \"  node4 -> node5 [label=\\\"UNCOND\\\", fontcolor=\\\"red\\\", weight=0.01, color=\\\"red\\\"];\\n\" +\n       \"  node7 [label=\\\"BLOCK\\\"];\\n\" +\n-      \"  node4 -> node7 [weight=1];\\n\" +\n+      \"  node5 -> node7 [weight=1];\\n\" +\n       \"  node8 [label=\\\"EXPR_RESULT\\\"];\\n\" +\n       \"  node7 -> node8 [weight=1];\\n\" +\n       \"  node9 [label=\\\"CALL\\\"];\\n\" +\n       \"  node8 -> node9 [weight=1];\\n\" +\n       \"  node10 [label=\\\"NAME\\\"];\\n\" +\n       \"  node9 -> node10 [weight=1];\\n\" +\n-      \"  node8 -> node4 \" +\n-      \"[label=\\\"UNCOND\\\", fontcolor=\\\"red\\\", weight=0.01, color=\\\"red\\\"];\\n\" +\n-      \"  node7 -> node8 \" +\n-      \"[label=\\\"UNCOND\\\", fontcolor=\\\"red\\\", weight=0.01, color=\\\"red\\\"];\\n\" +\n+      \"  node8 -> node5 [label=\\\"UNCOND\\\", fontcolor=\\\"red\\\", weight=0.01, color=\\\"red\\\"];\\n\" +\n+      \"  node7 -> node8 [label=\\\"UNCOND\\\", fontcolor=\\\"red\\\", weight=0.01, color=\\\"red\\\"];\\n\" +\n       \"  node11 [label=\\\"EMPTY\\\"];\\n\" +\n-      \"  node4 -> node11 \" +\n-      \"[label=\\\"ON_FALSE\\\", fontcolor=\\\"red\\\", weight=0.01, color=\\\"red\\\"];\\n\" +\n-      \"  node4 -> node7 \" +\n-      \"[label=\\\"ON_TRUE\\\", fontcolor=\\\"red\\\", weight=0.01, color=\\\"red\\\"];\\n\" +\n+      \"  node5 -> node11 [label=\\\"ON_FALSE\\\", fontcolor=\\\"red\\\", weight=0.01, color=\\\"red\\\"];\\n\" +\n+      \"  node5 -> node7 [label=\\\"ON_TRUE\\\", fontcolor=\\\"red\\\", weight=0.01, color=\\\"red\\\"];\\n\" +\n       \"  node0 -> node11 [weight=1];\\n\" +\n-      \"  node11 -> RETURN \" +\n-      \"[label=\\\"UNCOND\\\", fontcolor=\\\"red\\\", weight=0.01, color=\\\"red\\\"];\\n\" +\n-      \"  node0 -> node1 \" +\n-      \"[label=\\\"UNCOND\\\", fontcolor=\\\"red\\\", weight=0.01, color=\\\"red\\\"];\\n\" +\n+      \"  node11 -> RETURN [label=\\\"UNCOND\\\", fontcolor=\\\"red\\\", weight=0.01, color=\\\"red\\\"];\\n\" +\n+      \"  node0 -> node1 [label=\\\"UNCOND\\\", fontcolor=\\\"red\\\", weight=0.01, color=\\\"red\\\"];\\n\" +\n       \"}\\n\";\n     testCfg(src, expected);\n   }\n             \"label: for (var x in y) { \" +\n             \"    if (x) { break label; } else { i++ } x(); }\"),\n         Lists.newArrayList(\n-            Token.SCRIPT, Token.VAR, Token.VAR,\n+            Token.SCRIPT, Token.VAR, Token.VAR, Token.NAME,\n             Token.FOR, Token.BLOCK,\n             Token.IF, Token.BLOCK, Token.BREAK,\n             Token.BLOCK, Token.EXPR_RESULT, Token.EXPR_RESULT));\n--- a/test/com/google/javascript/jscomp/FlowSensitiveInlineVariablesTest.java\n+++ b/test/com/google/javascript/jscomp/FlowSensitiveInlineVariablesTest.java\n   public void testInvalidInlineArguments2() {\n     testSame(\"function f(c) {var f = c; arguments[0] = this;\" +\n              \"f.apply(this, arguments); return this;}\");\n+  }\n+\n+  public void testForIn() {\n+    noInline(\"var x; var y = {}; for(x in y){}\");\n+    noInline(\"var x; var y = {}; var z; for(x in z = y){print(z)}\");\n+    noInline(\"var x; var y = {}; var z; for(x in y){print(z)}\");\n+\n   }\n \n   public void testNotOkToSkipCheckPathBetweenNodes() {\n--- a/test/com/google/javascript/jscomp/LiveVariableAnalysisTest.java\n+++ b/test/com/google/javascript/jscomp/LiveVariableAnalysisTest.java\n     assertLiveAfterX(\"var a; while(1) { try {X:a=1;break} finally {a}}\", \"a\");\n   }\n \n+  public void testForInAssignment() {\n+    assertLiveBeforeX(\"var a,b; for (var y in a = b) { X:a[y] }\", \"a\");\n+    // No one refers to b after the first iteration.\n+    assertNotLiveBeforeX(\"var a,b; for (var y in a = b) { X:a[y] }\", \"b\");\n+    assertLiveBeforeX(\"var a,b; for (var y in a = b) { X:a[y] }\", \"y\");\n+    assertLiveAfterX(\"var a,b; for (var y in a = b) { a[y]; X: y();}\", \"a\");\n+  }\n+\n   public void testExceptionThrowingAssignments() {\n     assertLiveBeforeX(\"try{var a; X:a=foo();a} catch(e) {e()}\", \"a\");\n     assertLiveBeforeX(\"try{X:var a=foo();a} catch(e) {e()}\", \"a\");\n--- a/test/com/google/javascript/jscomp/MaybeReachingVariableUseTest.java\n+++ b/test/com/google/javascript/jscomp/MaybeReachingVariableUseTest.java\n   }\n \n   public void testForIn() {\n-    assertMatch(\"D: var x = []; U: for (var y in x) { }\");\n+    // Uses within FOR-IN header are hard to test. They are covered\n+    // by the tests in the flow sensitive inliner.\n     assertNotMatch(\"D: var x = [], foo; U: for (x in foo) { }\");\n     assertNotMatch(\"D: var x = [], foo; for (x in foo) { U:x }\");\n     assertMatch(\"var x = [], foo; D: for (x in foo) { U:x }\");\n--- a/test/com/google/javascript/jscomp/UnreachableCodeEliminationTest.java\n+++ b/test/com/google/javascript/jscomp/UnreachableCodeEliminationTest.java\n     testSame(\"throw 1; var x; var y;\");\n     test(\"throw 1; var x = foo\", \"var x; throw 1\");\n   }\n+\n+  public void testForInLoop() {\n+    testSame(\"for(var x in y) {}\");\n+  }\n }", "timestamp": 1335909116, "metainfo": ""}