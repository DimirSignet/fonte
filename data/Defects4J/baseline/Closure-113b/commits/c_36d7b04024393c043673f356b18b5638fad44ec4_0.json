{"sha": "36d7b04024393c043673f356b18b5638fad44ec4", "log": "I have a scenario where I'm hitting a NullPointerException using the --create_externs_from_exports option.  The simplified scenario is:  var id = function() {return 'id'}; var foo = function() { var id; return; } goog.exportSymbol('id', id);  In the compiler's ExternExportsPass class, there's a definitionMap that maps symbols names to Nodes. In the node traversal, the id function is found but then later overwritten by the the local variable id in function foo.  So, clearly this is bad behavior. Addressing by moving the ExternExportsPass to occur after normalization. ------------- Created by MOE: http://code.google.com/p/moe-java MOE_MIGRATED_REVID=46355600", "commit": "\n--- a/src/com/google/javascript/jscomp/Compiler.java\n+++ b/src/com/google/javascript/jscomp/Compiler.java\n         return;\n       }\n \n-      if (options.isExternExportsEnabled()\n-          || options.externExportsPath != null) {\n-        externExports();\n-      }\n-\n       // IDE-mode is defined to stop here, before the heavy rewriting begins.\n       if (!options.ideMode) {\n         optimize();\n     // unmodified local names.\n     normalize();\n \n+    // Create extern exports after the normalize because externExports depends on unique names.\n+    if (options.isExternExportsEnabled()\n+        || options.externExportsPath != null) {\n+      externExports();\n+    }\n+\n     phaseOptimizer = new PhaseOptimizer(this, tracker, null);\n     if (options.devMode == DevMode.EVERY_PASS) {\n       phaseOptimizer.setSanityCheck(sanityCheck);\n--- a/src/com/google/javascript/jscomp/ExternExportsPass.java\n+++ b/src/com/google/javascript/jscomp/ExternExportsPass.java\n     private Node createExternFunction(Node exportedFunction) {\n       Node paramList = NodeUtil.getFunctionParameters(exportedFunction)\n           .cloneTree();\n+      // Use the original parameter names so that the externs look pretty.\n+      Node param = paramList.getFirstChild();\n+      while (param != null && param.isName()) {\n+        System.err.println(param);\n+        String originalName = (String) param.getProp(Node.ORIGINALNAME_PROP);\n+        if (originalName != null) {\n+          param.setString(originalName);\n+        }\n+        param = param.getNext();\n+      }\n       Node externFunction = IR.function(IR.name(\"\"), paramList, IR.block());\n \n       checkForFunctionsWithUnknownTypes(exportedFunction);\n--- a/test/com/google/javascript/jscomp/ExternExportsPassTest.java\n+++ b/test/com/google/javascript/jscomp/ExternExportsPassTest.java\n \n import com.google.common.base.Joiner;\n import com.google.common.collect.Lists;\n-\n import junit.framework.TestCase;\n \n import java.util.List;\n                     \"var foobar = function() {\\n};\\n\");\n   }\n \n+  public void testExportParamWithSymbolDefinedInFunction() throws Exception {\n+    compileAndCheck(\n+        \"var id = function() {return 'id'};\\n\" +\n+        \"var ft = function() {\\n\" +\n+        \"  var id;\\n\" +\n+        \"  return 1;\\n\" +\n+        \"};\\n\" +\n+        \"goog.exportSymbol('id', id);\\n\",\n+        \"/**\\n\" +\n+        \" * @return {?}\\n\" +\n+        \" */\\n\" +\n+        \"var id = function() {\\n\" +\n+        \"};\\n\");\n+  }\n+\n   private void compileAndCheck(String js, String expected) {\n     Result result = compileAndExportExterns(js);\n \n     CompilerOptions options = new CompilerOptions();\n     options.externExportsPath = \"externs.js\";\n \n-    // Turn on IDE mode to get rid of optimizations.\n-    options.ideMode = true;\n+    // Turn off IDE mode.\n+    options.ideMode = false;\n \n     /* Check types so we can make sure our exported externs have\n      * type information.", "timestamp": 1368060469, "metainfo": ""}