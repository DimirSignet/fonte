{"sha": "6d38965a1e0a3a61435b9bebc91ff1ba0a64013a", "log": "Handle prototype assignments much better. Fixes issue #1023.  R=blickly", "commit": "\n--- a/src/com/google/javascript/jscomp/TypeInference.java\n+++ b/src/com/google/javascript/jscomp/TypeInference.java\n       scope = traverse(name.getFirstChild(), scope);\n     }\n \n-    // Object literals can be reflected on other types, or changed with\n-    // type casts.\n+    // Object literals can be reflected on other types.\n     // See CodingConvention#getObjectLiteralCase and goog.object.reflect.\n     // Ignore these types of literals.\n-    // TODO(nicksantos): There should be an \"anonymous object\" type that\n-    // we can check for here.\n     ObjectType objectType = ObjectType.cast(type);\n-    if (objectType == null) {\n-      return scope;\n-    }\n-\n-    boolean hasLendsName = n.getJSDocInfo() != null &&\n-        n.getJSDocInfo().getLendsName() != null;\n-    if (objectType.hasReferenceName() && !hasLendsName) {\n+    if (objectType == null || n.getBooleanProp(Node.REFLECTED_OBJECT)) {\n       return scope;\n     }\n \n--- a/src/com/google/javascript/jscomp/TypedScopeCreator.java\n+++ b/src/com/google/javascript/jscomp/TypedScopeCreator.java\n               typeRegistry.getType(objectLiteralCast.typeName));\n           if (type != null && type.getConstructor() != null) {\n             setDeferredType(objectLiteralCast.objectNode, type);\n+            objectLiteralCast.objectNode.putBooleanProp(\n+                Node.REFLECTED_OBJECT, true);\n           } else {\n             compiler.report(JSError.make(t.getSourceName(), n,\n                     CONSTRUCTOR_EXPECTED));\n             // what props are going to be on that prototype.\n             return;\n           }\n-          if (qVar.getScope() == scope) {\n-            scope.undeclare(qVar);\n-          }\n+\n+          qVar.getScope().undeclare(qVar);\n         }\n       }\n \n         defineSlot(n, parent, valueType, inferred);\n       } else if (rhsValue != null && rhsValue.isTrue()) {\n         // We declare these for delegate proxy method properties.\n-        FunctionType ownerType =\n-            JSType.toMaybeFunctionType(getObjectSlot(ownerName));\n-        if (ownerType != null) {\n-          JSType ownerTypeOfThis = ownerType.getTypeOfThis();\n+        ObjectType ownerType = getObjectSlot(ownerName);\n+        FunctionType ownerFnType = JSType.toMaybeFunctionType(ownerType);\n+        if (ownerFnType != null) {\n+          JSType ownerTypeOfThis = ownerFnType.getTypeOfThis();\n           String delegateName = codingConvention.getDelegateSuperclassName();\n           JSType delegateType = delegateName == null ?\n               null : typeRegistry.getType(delegateName);\n         return true;\n       }\n \n+      // Prototype sets are always declared.\n+      if (qName != null && qName.endsWith(\".prototype\")) {\n+        return false;\n+      }\n+\n       boolean inferred = true;\n       if (info != null) {\n         inferred = !(info.hasType()\n--- a/src/com/google/javascript/rhino/Node.java\n+++ b/src/com/google/javascript/rhino/Node.java\n       INFERRED_FUNCTION  = 55,    // Marks a function whose parameter types\n                                   // have been inferred.\n       CHANGE_TIME        = 56,    // For passes that work only on changed funs.\n-      LAST_PROP          = 56;    // Unused in the compiler, but keep for Rhino.\n+      REFLECTED_OBJECT   = 57,    // An object that's used for goog.object.reflect-style reflection.\n+      LAST_PROP          = 57;    // Unused in the compiler, but keep for Rhino.\n \n   public static final int   // flags for INCRDECR_PROP\n       DECR_FLAG = 0x1,\n         case SLASH_V:   return \"slash_v\";\n         case INFERRED_FUNCTION:   return \"inferred\";\n         case CHANGE_TIME: return \"change_time\";\n+        case REFLECTED_OBJECT: return \"reflected_object\";\n         default:\n           throw new IllegalStateException(\"unexpected prop id \" + propType);\n       }\n--- a/test/com/google/javascript/jscomp/TypeCheckTest.java\n+++ b/test/com/google/javascript/jscomp/TypeCheckTest.java\n         \"};\");\n   }\n \n+  public void testIssue1023() throws Exception {\n+    testTypes(\n+        \"/** @constructor */\" +\n+        \"function F() {}\" +\n+        \"(function () {\" +\n+        \"  F.prototype = {\" +\n+        \"    /** @param {string} x */\" +\n+        \"    bar: function (x) {  }\" +\n+        \"  };\" +\n+        \"})();\" +\n+        \"(new F()).bar(true)\",\n+        \"actual parameter 1 of F.prototype.bar does not match formal parameter\\n\" +\n+        \"found   : boolean\\n\" +\n+        \"required: string\");\n+  }\n+\n   /**\n    * Tests that the || operator is type checked correctly, that is of\n    * the type of the first argument or of the second argument. See\n--- a/test/com/google/javascript/jscomp/TypedScopeCreatorTest.java\n+++ b/test/com/google/javascript/jscomp/TypedScopeCreatorTest.java\n     assertFalse(x.isPropertyTypeDeclared(\"alert\"));\n \n     ObjectType y = (ObjectType) findNameType(\"y\", globalScope);\n-    assertEquals(\"?\",\n+    assertEquals(\"function (this:Window, ?): undefined\",\n         y.getPropertyType(\"alert\").toString());\n   }\n \n     assertEquals(\"function (this:I): undefined\",\n         iPrototype.getPropertyType(\"baz\").toString());\n \n-    // should not be null\n-    assertNull(globalScope.getVar(\"I.prototype\"));\n-    // assertEquals(iPrototype, globalScope.getVar(\"I.prototype\").getType());\n+    assertEquals(iPrototype, globalScope.getVar(\"I.prototype\").getType());\n   }\n \n   // TODO(johnlenz): A syntax for stubs using object literals?", "timestamp": 1371755403, "metainfo": ""}