{"sha": "b80dfd3b0e5e4b490b7afb469320d18bac4520b4", "log": "Nerf direct function inlining when the function be inlined has side-effects and the call arguments can be effected. Fixes issue 1101 ------------- Created by MOE: http://code.google.com/p/moe-java MOE_MIGRATED_REVID=53511956", "commit": "\n--- a/src/com/google/javascript/jscomp/FunctionInjector.java\n+++ b/src/com/google/javascript/jscomp/FunctionInjector.java\n \n     Node block = fnNode.getLastChild();\n \n+    boolean hasSideEffects = false;  // empty function case\n+    if (block.hasChildren()) {\n+      Preconditions.checkState(block.hasOneChild());\n+      Node stmt = block.getFirstChild();\n+      if (stmt.isReturn()) {\n+        hasSideEffects = NodeUtil.mayHaveSideEffects(\n+            stmt.getFirstChild(), compiler);\n+      }\n+    }\n+\n     // CALL NODE: [ NAME, ARG1, ARG2, ... ]\n     Node cArg = callNode.getFirstChild().getNext();\n \n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n         if (cArg != null) {\n+          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n+            return CanInlineResult.NO;\n+          }\n+\n           // Check for arguments that are evaluated more than once.\n           // Note: Unlike block inlining, there it is not possible that a\n           // parameter reference will be in a loop.\n--- a/test/com/google/javascript/jscomp/FunctionInjectorTest.java\n+++ b/test/com/google/javascript/jscomp/FunctionInjectorTest.java\n import com.google.javascript.jscomp.FunctionInjector.InliningMode;\n import com.google.javascript.jscomp.NodeTraversal.Callback;\n import com.google.javascript.rhino.Node;\n+\n import junit.framework.TestCase;\n \n import java.util.List;\n         \"foo\", INLINE_BLOCK);\n   }\n \n+  public void testIssue1101a() {\n+    helperCanInlineReferenceToFunction(CanInlineResult.NO,\n+        \"function foo(a){return modifiyX() + a;} foo(x);\", \"foo\",\n+        INLINE_DIRECT);\n+  }\n+\n+  public void testIssue1101b() {\n+    helperCanInlineReferenceToFunction(CanInlineResult.NO,\n+        \"function foo(a){return (x.prop = 2),a;} foo(x.prop);\", \"foo\",\n+        INLINE_DIRECT);\n+  }\n+\n+\n   /**\n    * Test case\n    *\n--- a/test/com/google/javascript/jscomp/InlineFunctionsTest.java\n+++ b/test/com/google/javascript/jscomp/InlineFunctionsTest.java\n   boolean assumeStrictThis = false;\n   boolean assumeMinimumCapture = false;\n \n+  final static String EXTERNS =\n+      \"/** @nosideeffects */ function nochg(){}\\n\" +\n+      \"function chg(){}\\n\";\n+\n   public InlineFunctionsTest() {\n+    super(EXTERNS);\n     this.enableNormalize();\n-    this.enableMarkNoSideEffects();\n+    this.enableComputeSideEffects();\n   }\n \n   @Override\n \n   public void testInlineFunctions6() {\n     // more complex inlines\n-    test(\"function BAR_FN(x, y, z) { return z(foo(x + y)) }\" +\n+    test(\"function BAR_FN(x, y, z) { return z(nochg(x + y)) }\" +\n          \"alert(BAR_FN(1, 2, baz))\",\n \n-         \"alert(baz(foo(1+2)))\");\n+         \"var JSCompiler_temp_const$$0=alert;\" +\n+         \"var JSCompiler_inline_result$$1;\" +\n+         \"{JSCompiler_inline_result$$1=baz(nochg(1+2));}\" +\n+         \"JSCompiler_temp_const$$0(JSCompiler_inline_result$$1)\");\n   }\n \n   public void testInlineFunctions7() {\n          \"var b=function(){return c};\" +\n          \"var d=b()+foo()\",\n \n-         \"var JSCompiler_temp_const$$0 = c;\\n\" +\n-         \"var JSCompiler_inline_result$$1;\\n\" +\n-         \"{\\n\" +\n-         \"var x$$inline_2;\\n\" +\n-         \"JSCompiler_inline_result$$1 = \" +\n-         \"    function(a$$inline_3){ return a$$inline_3+1 };\\n\" +\n-         \"}\" +\n-         \"var d=JSCompiler_temp_const$$0 + JSCompiler_inline_result$$1\");\n+         \"var JSCompiler_inline_result$$0;\" +\n+         \"{var x$$inline_1;\" +\n+         \"JSCompiler_inline_result$$0=function(a$$inline_2){return a$$inline_2+1};}\" +\n+         \"var d=c+JSCompiler_inline_result$$0\");\n   }\n \n   public void testInlineFunctions15c() {\n \n     assumeMinimumCapture = true;\n \n-    // closure factories: don't inline functions with vars.\n+    // closure factories: inline functions with vars.\n     test(\"function foo(){var x; return function(a){return a+1}}\" +\n          \"var b=function(){return c};\" +\n          \"function _x(){ var d=b()+foo() }\",\n \n-         \"function _x() { \\n\" +\n-         \"  var JSCompiler_temp_const$$0 = c;\\n\" +\n-         \"  var JSCompiler_inline_result$$1;\\n\" +\n-         \"  {\\n\" +\n-         \"  var x$$inline_2;\\n\" +\n-         \"  JSCompiler_inline_result$$1 = \" +\n-         \"      function(a$$inline_3) {return a$$inline_3+1};\\n\" +\n-         \"  }\\n\" +\n-         \"  var d = JSCompiler_temp_const$$0+JSCompiler_inline_result$$1\\n\" +\n+         \"function _x(){\" +\n+         \"  var JSCompiler_inline_result$$0;\" +\n+         \"  {\" +\n+         \"    var x$$inline_1;\" +\n+         \"    JSCompiler_inline_result$$0=function(a$$inline_2){\" +\n+         \"        return a$$inline_2+1};\" +\n+         \"  }\" +\n+         \"  var d=c+JSCompiler_inline_result$$0\" +\n          \"}\");\n   }\n \n     test(\"function foo(a, b){return a+b}\" +\n         \"function bar(d){return c}\" +\n         \"var d=foo(bar(1),e)\",\n-        \"var d;{d=c+e}\");\n+        \"var d=c+e;\");\n   }\n \n   public void testInlineFunctions20() {\n     test(\"function foo(a, b){return a+b}\" +\n         \"function bar(d){return c}\" +\n         \"var d=bar(foo(1,e))\",\n-        \"var d;{d=c}\");\n+        \"var d=c\");\n   }\n \n   public void testInlineFunctions22() {\n          \"++a$$inline_0}\");\n   }\n \n-  public void testNoInlineIfParametersModified8() {\n+  public void testInlineIfParametersModified8() {\n     // OK, object parameter modified.\n-    test(\"function f(a){return a.x=2}f(o)\", \"o.x=2\");\n-  }\n-\n-  public void testNoInlineIfParametersModified9() {\n+    test(\"function f(a){return a.x=2}f(o)\", \"{o.x=2}\");\n+  }\n+\n+  public void testInlineIfParametersModified9() {\n     // OK, array parameter modified.\n-    test(\"function f(a){return a[2]=2}f(o)\", \"o[2]=2\");\n+    test(\"function f(a){return a[2]=2}f(o)\", \"{o[2]=2}\");\n   }\n \n   public void testInlineNeverPartialSubtitution1() {\n     // is small enough to be inlined without removing the function declaration.\n     // but it is not in this first test.\n     allowBlockInlining = false;\n-    testSame(\"function f(a){return 1 + a + a;}\" +\n+    testSame(\"function f(a){return chg() + a + a;}\" +\n         \"var a = f(f(1));\");\n   }\n \n     // Here both direct and block inlining is used.  The call to f as a\n     // parameter is inlined directly, which the call to f with f as a parameter\n     // is inlined using block inlining.\n-    test(\"function f(a){return 1 + a + a;}\" +\n+    test(\"function f(a){return chg() + a + a;}\" +\n          \"var a = f(f(1));\",\n          \"var a;\" +\n-         \"{var a$$inline_0=1+1+1;\" +\n-         \"a=1+a$$inline_0+a$$inline_0}\");\n+         \"{var a$$inline_0=chg()+1+1;\" +\n+         \"a=chg()+a$$inline_0+a$$inline_0}\");\n   }\n \n   public void testCostBasedInlining10() {\n     // call to f() is inlined, as there is no longer a possible side-effect-ing\n     // parameter.\n     allowBlockInlining = false;\n-    test(\"function f(a){return a + a;}\" +\n+    test(\"function f(a){return nochg() + a + a;}\" +\n         \"var a = f(f(1));\",\n-        \"var a= 1+1+(1+1);\");\n+        \"var a= nochg()+(nochg()+1+1)+(nochg()+1+1);\");\n   }\n \n   public void testCostBasedInlining11() {\n     // With block inlining\n-    test(\"function f(a){return a + a;}\" +\n+    test(\"function f(a){return chg() + a + a;}\" +\n          \"var a = f(f(1))\",\n          \"var a;\" +\n-         \"{var a$$inline_0=1+1;\" +\n-         \"a=a$$inline_0+a$$inline_0}\");\n+         \"{var a$$inline_0=chg()+1+1;\" +\n+         \"a=chg()+a$$inline_0+a$$inline_0}\");\n   }\n \n   public void testCostBasedInlining12() {\n \n   public void testDoubleInlining1() {\n     allowBlockInlining = false;\n-    test(\"var foo = function(a) { return getWindow(a); };\" +\n+    test(\"var foo = function(a) { return nochg(a); };\" +\n          \"var bar = function(b) { return b; };\" +\n          \"foo(bar(x));\",\n-         \"getWindow(x)\");\n+         \"nochg(x)\");\n   }\n \n   public void testDoubleInlining2() {\n         \"  var self = a.b;\\n\" +\n         \"  var myUrl = new goog.Uri(getOwnerWin_(self).location.href);\\n\" +\n         \"};\",\n-        \"HangoutStarter.prototype.launchHangout = function() { \" +\n-        \"  var self$$2 = a.b;\" +\n-        \"  var JSCompiler_temp_const$$0 = goog.Uri;\" +\n+        \"HangoutStarter.prototype.launchHangout=function(){\" +\n+        \"  var self$$2=a.b;\" +\n+        \"  var JSCompiler_temp_const$$0=goog.Uri;\" +\n         \"  var JSCompiler_inline_result$$1;\" +\n         \"  {\" +\n-        \"  var self$$inline_2 = self$$2;\" +\n-        \"  if (!self$$inline_2.domServices_) {\" +\n-        \"    self$$inline_2.domServices_ = goog$component$DomServices.get(\" +\n-        \"        self$$inline_2.appContext_);\" +\n+        \"    var JSCompiler_inline_result$$0;\" +\n+        \"    {\" +\n+        \"      var self$$inline_1=self$$2;\" +\n+        \"      if(!self$$inline_1.domServices_) {\" +\n+        \"        self$$inline_1.domServices_=goog$component$DomServices.get(self$$inline_1.appContext_);\" +\n+        \"      }\" +\n+        \"      JSCompiler_inline_result$$0=self$$inline_1.domServices_;\" +\n+        \"    }\" +\n+        \"    JSCompiler_inline_result$$1=JSCompiler_inline_result$$0.getDomHelper().getWindow();\" +\n         \"  }\" +\n-        \"  JSCompiler_inline_result$$1=self$$inline_2.domServices_;\" +\n-        \"  }\" +\n-        \"  var myUrl = new JSCompiler_temp_const$$0(\" +\n-        \"      JSCompiler_inline_result$$1.getDomHelper().\" +\n-        \"          getWindow().location.href)\" +\n+        \"  var myUrl=new JSCompiler_temp_const$$0(JSCompiler_inline_result$$1.location.href)\" +\n         \"}\");\n   }\n \n         \"function f(x){ for(var x in y){} } f()\",\n         \"{var x$$inline_0=void 0;for(x$$inline_0 in y);}\");\n    }\n+\n+  public void testIssue1101() {\n+    test(\n+        \"var x = (function (saved) {\" +\n+        \"    return foo(obj) + saved;\" +\n+        \"  })(obj[\\\"prop\\\"]);\",\n+        \"var x;\" +\n+        \"{\" +\n+        \"  var saved$$inline_0=obj[\\\"prop\\\"];x=foo(obj)+saved$$inline_0\" +\n+        \"}\");\n+  }\n }", "timestamp": 1380671965, "metainfo": ""}