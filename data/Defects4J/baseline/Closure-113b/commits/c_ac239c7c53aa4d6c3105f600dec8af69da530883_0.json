{"sha": "ac239c7c53aa4d6c3105f600dec8af69da530883", "log": "Add a new isInvariant relation. Fixes issue 791.  R=dimvar DELTA=231  (175 added, 7 deleted, 49 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=5678   ", "commit": "\n--- a/src/com/google/javascript/rhino/jstype/ArrowType.java\n+++ b/src/com/google/javascript/rhino/jstype/ArrowType.java\n    * @return True if our parameter spec is equal to {@code that}'s parameter\n    *     spec.\n    */\n-  boolean hasEqualParameters(ArrowType that, boolean tolerateUnknowns) {\n+  boolean hasEqualParameters(ArrowType that, EquivalenceMethod eqMethod) {\n     Node thisParam = parameters.getFirstChild();\n     Node otherParam = that.parameters.getFirstChild();\n     while (thisParam != null && otherParam != null) {\n         // Both parameter lists give a type for this param, it should be equal\n         if (otherParamType != null &&\n             !thisParamType.checkEquivalenceHelper(\n-                otherParamType, tolerateUnknowns)) {\n+                otherParamType, eqMethod)) {\n           return false;\n         }\n       } else {\n   }\n \n   boolean checkArrowEquivalenceHelper(\n-      ArrowType that, boolean tolerateUnknowns) {\n+      ArrowType that, EquivalenceMethod eqMethod) {\n     // Please keep this method in sync with the hashCode() method below.\n-    if (!returnType.checkEquivalenceHelper(that.returnType, tolerateUnknowns)) {\n+    if (!returnType.checkEquivalenceHelper(that.returnType, eqMethod)) {\n       return false;\n     }\n-    return hasEqualParameters(that, tolerateUnknowns);\n+    return hasEqualParameters(that, eqMethod);\n   }\n \n   @Override\n--- /dev/null\n+++ b/src/com/google/javascript/rhino/jstype/EquivalenceMethod.java\n+/*\n+ *\n+ * ***** BEGIN LICENSE BLOCK *****\n+ * Version: MPL 1.1/GPL 2.0\n+ *\n+ * The contents of this file are subject to the Mozilla Public License Version\n+ * 1.1 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * http://www.mozilla.org/MPL/\n+ *\n+ * Software distributed under the License is distributed on an \"AS IS\" basis,\n+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing rights and limitations under the\n+ * License.\n+ *\n+ * The Original Code is Rhino code, released\n+ * May 6, 1999.\n+ *\n+ * The Initial Developer of the Original Code is\n+ * Netscape Communications Corporation.\n+ * Portions created by the Initial Developer are Copyright (C) 1997-1999\n+ * the Initial Developer. All Rights Reserved.\n+ *\n+ * Contributor(s):\n+ *   Nick Santos\n+ *   Google Inc.\n+ *\n+ * Alternatively, the contents of this file may be used under the terms of\n+ * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n+ * case the provisions of the GPL are applicable instead of those above. If\n+ * you wish to allow use of your version of this file only under the terms of\n+ * the GPL and not to allow others to use your version of this file under the\n+ * MPL, indicate your decision by deleting the provisions above and replacing\n+ * them with the notice and other provisions required by the GPL. If you do\n+ * not delete the provisions above, a recipient may use your version of this\n+ * file under either the MPL or the GPL.\n+ *\n+ * ***** END LICENSE BLOCK ***** */\n+\n+package com.google.javascript.rhino.jstype;\n+\n+/**\n+ * Represents different ways for comparing equality among types.\n+ * @author nicksantos@google.com (Nick Santos)\n+ */\n+enum EquivalenceMethod {\n+  /**\n+   * Indicates that the two types should behave exactly the same under\n+   * all type operations.\n+   *\n+   * Thus, {string} != {?} and {Unresolved} != {?}\n+   */\n+  IDENTITY,\n+\n+  /**\n+   * Indicates that the two types are almost exactly the same, and that a\n+   * data flow analysis algorithm comparing them should consider them equal.\n+   *\n+   * In traditional type inference, the types form a finite lattice, and this\n+   * ensures that type inference will terminate.\n+   *\n+   * In our type system, the unknown types do not obey the lattice rules. So\n+   * if we continue to perform inference over the unknown types, we may\n+   * never terminate.\n+   *\n+   * By treating all unknown types as equivalent for the purposes of data\n+   * flow analysis, we ensure that the algorithm will terminate.\n+   *\n+   * Thus, {string} != {?} and {Unresolved} ~= {?}\n+   */\n+  DATA_FLOW,\n+\n+  /**\n+   * Indicates that two types are invariant.\n+   *\n+   * In a type system without unknown types, this would be the same\n+   * as IDENTITY. But we always want to consider type A invariant with type B\n+   * if B is unknown.\n+   *\n+   * Thus, {string} ~= {?} and {Unresolved} ~= {?}\n+   */\n+  INVARIANT\n+}\n--- a/src/com/google/javascript/rhino/jstype/FunctionType.java\n+++ b/src/com/google/javascript/rhino/jstype/FunctionType.java\n   private FunctionType tryMergeFunctionPiecewise(\n       FunctionType other, boolean leastSuper) {\n     Node newParamsNode = null;\n-    if (call.hasEqualParameters(other.call, false)) {\n+    if (call.hasEqualParameters(other.call, EquivalenceMethod.IDENTITY)) {\n       newParamsNode = call.parameters;\n     } else {\n       // If the parameters are not equal, don't try to merge them.\n    * have signatures, two interfaces are equal if their names match.\n    */\n   boolean checkFunctionEquivalenceHelper(\n-      FunctionType that, boolean tolerateUnknowns) {\n+      FunctionType that, EquivalenceMethod eqMethod) {\n     if (isConstructor()) {\n       if (that.isConstructor()) {\n         return this == that;\n     }\n \n     return typeOfThis.checkEquivalenceHelper(\n-        that.typeOfThis, tolerateUnknowns) &&\n-        call.checkArrowEquivalenceHelper(that.call, tolerateUnknowns);\n+        that.typeOfThis, eqMethod) &&\n+        call.checkArrowEquivalenceHelper(that.call, eqMethod);\n   }\n \n   @Override\n   }\n \n   public boolean hasEqualCallType(FunctionType otherType) {\n-    return this.call.checkArrowEquivalenceHelper(otherType.call, false);\n+    return this.call.checkArrowEquivalenceHelper(\n+        otherType.call, EquivalenceMethod.IDENTITY);\n   }\n \n   /**\n--- a/src/com/google/javascript/rhino/jstype/JSType.java\n+++ b/src/com/google/javascript/rhino/jstype/JSType.java\n   /**\n    * Checks if two types are equivalent.\n    */\n-  public final boolean isEquivalentTo(JSType jsType) {\n-    return checkEquivalenceHelper(jsType, false);\n-  }\n-\n-  /**\n-   * Whether this type is meaningfully different from {@code that} type.\n+  public final boolean isEquivalentTo(JSType that) {\n+    return checkEquivalenceHelper(that, EquivalenceMethod.IDENTITY);\n+  }\n+\n+  /**\n+   * Checks if two types are invariant.\n+   * @see EquivalenceMethod\n+   */\n+  public final boolean isInvariant(JSType that) {\n+    return checkEquivalenceHelper(that, EquivalenceMethod.INVARIANT);\n+  }\n+\n+  /**\n+   * Whether this type is meaningfully different from {@code that} type for\n+   * the purposes of data flow analysis.\n+   *\n    * This is a trickier check than pure equality, because it has to properly\n-   * handle unknown types.\n+   * handle unknown types. See {@code EquivalenceMethod} for more info.\n    *\n    * @see <a href=\"http://www.youtube.com/watch?v=_RpSv3HjpEw\">Unknown\n    *     unknowns</a>\n    */\n   public final boolean differsFrom(JSType that) {\n-    return !checkEquivalenceHelper(that, true);\n+    return !checkEquivalenceHelper(that, EquivalenceMethod.DATA_FLOW);\n   }\n \n   /**\n    * An equivalence visitor.\n    */\n-  boolean checkEquivalenceHelper(JSType that, boolean tolerateUnknowns) {\n+  boolean checkEquivalenceHelper(JSType that, EquivalenceMethod eqMethod) {\n     if (this == that) {\n       return true;\n     }\n \n     boolean thisUnknown = isUnknownType();\n     boolean thatUnknown = that.isUnknownType();\n-    if (isUnknownType() || that.isUnknownType()) {\n-      if (tolerateUnknowns) {\n-        // If we tolerate unknowns, then two types are the same if they're\n+    if (thisUnknown || thatUnknown) {\n+      if (eqMethod == EquivalenceMethod.INVARIANT) {\n+        // If we're checking for invariance, the unknown type is invariant\n+        // with everyone.\n+        return true;\n+      } else if (eqMethod == EquivalenceMethod.DATA_FLOW) {\n+        // If we're checking data flow, then two types are the same if they're\n         // both unknown.\n         return thisUnknown && thatUnknown;\n       } else if (thisUnknown && thatUnknown &&\n \n     if (isUnionType() && that.isUnionType()) {\n       return this.toMaybeUnionType().checkUnionEquivalenceHelper(\n-          that.toMaybeUnionType(), tolerateUnknowns);\n+          that.toMaybeUnionType(), eqMethod);\n     }\n \n     if (isFunctionType() && that.isFunctionType()) {\n       return this.toMaybeFunctionType().checkFunctionEquivalenceHelper(\n-          that.toMaybeFunctionType(), tolerateUnknowns);\n+          that.toMaybeFunctionType(), eqMethod);\n     }\n \n     if (isRecordType() && that.isRecordType()) {\n       return this.toMaybeRecordType().checkRecordEquivalenceHelper(\n-          that.toMaybeRecordType(), tolerateUnknowns);\n+          that.toMaybeRecordType(), eqMethod);\n     }\n \n     ParameterizedType thisParamType = toMaybeParameterizedType();\n       boolean paramsMatch = false;\n       if (thisParamType != null && thatParamType != null) {\n         paramsMatch = thisParamType.getParameterType().checkEquivalenceHelper(\n-            thatParamType.getParameterType(), tolerateUnknowns);\n-      } else if (tolerateUnknowns) {\n+            thatParamType.getParameterType(), eqMethod);\n+      } else if (eqMethod == EquivalenceMethod.IDENTITY) {\n+        paramsMatch = false;\n+      } else {\n+        // If one of the type parameters is unknown, but the other is not,\n+        // then we consider these the same for the purposes of data flow\n+        // and invariance.\n         paramsMatch = true;\n-      } else {\n-        paramsMatch = false;\n       }\n \n       JSType thisRootType = thisParamType == null ?\n       JSType thatRootType = thatParamType == null ?\n           that : thatParamType.getReferencedTypeInternal();\n       return paramsMatch &&\n-          thisRootType.checkEquivalenceHelper(thatRootType, tolerateUnknowns);\n+          thisRootType.checkEquivalenceHelper(thatRootType, eqMethod);\n     }\n \n     if (isNominalType() && that.isNominalType()) {\n     if (this instanceof ProxyObjectType) {\n       return ((ProxyObjectType) this)\n           .getReferencedTypeInternal().checkEquivalenceHelper(\n-              that, tolerateUnknowns);\n+              that, eqMethod);\n     }\n \n     if (that instanceof ProxyObjectType) {\n       return checkEquivalenceHelper(\n           ((ProxyObjectType) that).getReferencedTypeInternal(),\n-          tolerateUnknowns);\n+          eqMethod);\n     }\n \n     // Relies on the fact that for the base {@link JSType}, only one\n--- a/src/com/google/javascript/rhino/jstype/RecordType.java\n+++ b/src/com/google/javascript/rhino/jstype/RecordType.java\n   }\n \n   boolean checkRecordEquivalenceHelper(\n-      RecordType otherRecord, boolean tolerateUnknowns) {\n+      RecordType otherRecord, EquivalenceMethod eqMethod) {\n     Set<String> keySet = properties.keySet();\n     Map<String, JSType> otherProps = otherRecord.properties;\n     if (!otherProps.keySet().equals(keySet)) {\n     }\n     for (String key : keySet) {\n       if (!otherProps.get(key).checkEquivalenceHelper(\n-              properties.get(key), tolerateUnknowns)) {\n+              properties.get(key), eqMethod)) {\n         return false;\n       }\n     }\n       // is returned.\n       for (String property : properties.keySet()) {\n         if (thatRecord.hasProperty(property) &&\n-            !thatRecord.getPropertyType(property).isEquivalentTo(\n+            !thatRecord.getPropertyType(property).isInvariant(\n                 getPropertyType(property))) {\n           return registry.getNativeObjectType(JSTypeNative.NO_TYPE);\n         }\n           JSType altPropType = alt.getPropertyType(propName);\n           if (altPropType != null && !alt.isEquivalentTo(this) &&\n               alt.isSubtype(that) &&\n-              (propType.isUnknownType() || altPropType.isUnknownType() ||\n-                  altPropType.isEquivalentTo(propType))) {\n+              propType.isInvariant(altPropType)) {\n             builder.addAlternate(alt);\n           }\n         }\n \n       JSType propA = typeA.getPropertyType(property);\n       JSType propB = typeB.getPropertyType(property);\n-      if (!propA.isUnknownType() && !propB.isUnknownType()) {\n-        if (typeA.isPropertyTypeDeclared(property)) {\n-          if (!propA.isEquivalentTo(propB)) {\n-            return false;\n-          }\n-        } else {\n-          if (!propA.isSubtype(propB)) {\n-            return false;\n-          }\n+      if (typeA.isPropertyTypeDeclared(property)) {\n+        // If one declared property isn't invariant,\n+        // then the whole record isn't covariant.\n+        if (!propA.isInvariant(propB)) {\n+          return false;\n+        }\n+      } else {\n+        // If one inferred property isn't a subtype,\n+        // then the whole record isn't covariant.\n+        if (!propA.isSubtype(propB)) {\n+          return false;\n         }\n       }\n     }\n--- a/src/com/google/javascript/rhino/jstype/UnionType.java\n+++ b/src/com/google/javascript/rhino/jstype/UnionType.java\n    * and all alternates are equal.\n    */\n   boolean checkUnionEquivalenceHelper(\n-      UnionType that, boolean tolerateUnknowns) {\n-    if (!tolerateUnknowns && alternates.size() != that.alternates.size()) {\n+      UnionType that, EquivalenceMethod eqMethod) {\n+    if (eqMethod == EquivalenceMethod.IDENTITY\n+        && alternates.size() != that.alternates.size()) {\n       return false;\n     }\n     for (JSType alternate : that.alternates) {\n-      if (!hasAlternate(alternate, tolerateUnknowns)) {\n+      if (!hasAlternate(alternate, eqMethod)) {\n         return false;\n       }\n     }\n     return true;\n   }\n \n-  private boolean hasAlternate(JSType type, boolean tolerateUnknowns) {\n+  private boolean hasAlternate(JSType type, EquivalenceMethod eqMethod) {\n     for (JSType alternate : alternates) {\n-      if (alternate.checkEquivalenceHelper(type, tolerateUnknowns)) {\n+      if (alternate.checkEquivalenceHelper(type, eqMethod)) {\n         return true;\n       }\n     }\n--- a/test/com/google/javascript/jscomp/TypeCheckTest.java\n+++ b/test/com/google/javascript/jscomp/TypeCheckTest.java\n   }\n \n   public void testIssue791() throws Exception {\n-    // TODO(nicksantos): This warning is wrong, and should be fixed.\n     testTypes(\n         \"/** @param {{func: function()}} obj */\" +\n         \"function test1(obj) {}\" +\n         \"var fnStruc1 = {};\" +\n         \"fnStruc1.func = function() {};\" +\n-        \"test1(fnStruc1);\",\n-        \"actual parameter 1 of test1 does not match formal parameter\\n\" +\n-        \"found   : {func: function (): undefined}\\n\" +\n-        \"required: {func: function (): ?}\");\n+        \"test1(fnStruc1);\");\n   }\n \n   public void testIssue810() throws Exception {\n--- a/test/com/google/javascript/rhino/jstype/RecordTypeTest.java\n+++ b/test/com/google/javascript/rhino/jstype/RecordTypeTest.java\n     Asserts.assertTypeEquals(\n         aSupC, proxyRecordA.getLeastSupertype(proxyRecordC));\n   }\n+\n+  public void testSubtypeWithUnknowns() throws Exception {\n+    JSType recordA = new RecordTypeBuilder(registry)\n+        .addProperty(\"a\", NUMBER_TYPE, null)\n+        .build();\n+    JSType recordB = new RecordTypeBuilder(registry)\n+        .addProperty(\"a\", UNKNOWN_TYPE, null)\n+        .build();\n+    assertTrue(recordA.isSubtype(recordB));\n+    assertTrue(recordB.isSubtype(recordA));\n+  }\n+\n+  public void testSubtypeWithUnknowns2() throws Exception {\n+    JSType recordA = new RecordTypeBuilder(registry)\n+        .addProperty(\"a\",\n+            new FunctionBuilder(registry)\n+            .withReturnType(NUMBER_TYPE)\n+            .build(),\n+            null)\n+        .build();\n+    JSType recordB = new RecordTypeBuilder(registry)\n+        .addProperty(\"a\",\n+            new FunctionBuilder(registry)\n+            .withReturnType(UNKNOWN_TYPE)\n+            .build(),\n+            null)\n+        .build();\n+    assertTrue(recordA.isSubtype(recordB));\n+    assertTrue(recordB.isSubtype(recordA));\n+  }\n+\n+  public void testSubtypeWithFunctionProps() throws Exception {\n+    JSType recordA = new RecordTypeBuilder(registry)\n+        .addProperty(\"a\",\n+            new FunctionBuilder(registry)\n+            .withReturnType(NUMBER_TYPE)\n+            .build(),\n+            null)\n+        .build();\n+    JSType recordB = new RecordTypeBuilder(registry)\n+        .addProperty(\"a\",\n+            new FunctionBuilder(registry)\n+            .withReturnType(STRING_TYPE)\n+            .build(),\n+            null)\n+        .build();\n+    assertFalse(recordA.isSubtype(recordB));\n+    assertFalse(recordB.isSubtype(recordA));\n+  }\n+\n+  public void testSubtypeWithManyProps() throws Exception {\n+    JSType recordA = new RecordTypeBuilder(registry)\n+        .addProperty(\"a\", NUMBER_TYPE, null)\n+        .addProperty(\"b\", NUMBER_TYPE, null)\n+        .build();\n+    JSType recordB = new RecordTypeBuilder(registry)\n+        .addProperty(\"a\", NUMBER_TYPE, null)\n+        .addProperty(\"b\", STRING_TYPE, null)\n+        .build();\n+    JSType recordC = new RecordTypeBuilder(registry)\n+        .addProperty(\"a\", NUMBER_TYPE, null)\n+        .addProperty(\"b\",\n+            registry.createUnionType(NUMBER_TYPE, STRING_TYPE), null)\n+        .build();\n+    assertFalse(recordA.isSubtype(recordB));\n+    assertFalse(recordB.isSubtype(recordA));\n+    assertFalse(recordC.isSubtype(recordB));\n+    assertFalse(recordB.isSubtype(recordC));\n+  }\n }", "timestamp": 1350664876, "metainfo": ""}