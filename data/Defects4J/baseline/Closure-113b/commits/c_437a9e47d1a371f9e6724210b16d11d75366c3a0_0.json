{"sha": "437a9e47d1a371f9e6724210b16d11d75366c3a0", "log": "Sanity-check the timestamps on scope roots. (Uncovered a bug in the changed-functions traversal. See new setting of currentScope in PhaseOptimizer.) ------------- Created by MOE: http://code.google.com/p/moe-java MOE_MIGRATED_REVID=44316335", "commit": "\n--- a/src/com/google/javascript/jscomp/Compiler.java\n+++ b/src/com/google/javascript/jscomp/Compiler.java\n \n   @Override\n   Node getEnclosingScope(Node n) {\n-    while (n != jsRoot) {\n+    while (n != jsRoot && n.getParent() != null) {\n       n = n.getParent();\n-      if (n.isFunction()) { return n; }\n+      if (n.isFunction()) {\n+        return n;\n+      }\n     }\n     return n;\n   }\n--- a/src/com/google/javascript/jscomp/NodeUtil.java\n+++ b/src/com/google/javascript/jscomp/NodeUtil.java\n import java.util.Arrays;\n import java.util.Collection;\n import java.util.Collections;\n+import java.util.HashMap;\n import java.util.HashSet;\n import java.util.Map;\n import java.util.Set;\n     }\n     return false;\n   }\n+\n+  /**\n+   * Given an AST and its copy, map the root node of each scope of main to the\n+   * corresponding root node of clone\n+   */\n+  public static Map<Node, Node> mapMainToClone(Node main, Node clone) {\n+    Preconditions.checkState(main.isEquivalentTo(clone));\n+    Map<Node, Node> mtoc = new HashMap<Node, Node>();\n+    mtoc.put(main, clone);\n+    mtocHelper(mtoc, main, clone);\n+    return mtoc;\n+  }\n+\n+  private static void mtocHelper(Map<Node, Node> map, Node main, Node clone) {\n+    if (main.isFunction()) {\n+      map.put(main, clone);\n+    }\n+    Node mchild = main.getFirstChild(), cchild = clone.getFirstChild();\n+    while (mchild != null) {\n+      mtocHelper(map, mchild, cchild);\n+      mchild = mchild.getNext();\n+      cchild = cchild.getNext();\n+    }\n+  }\n+\n+  /** Checks that the scope roots marked as changed have indeed changed */\n+  public static void verifyScopeChanges(Map<Node, Node> map,\n+      Node main, boolean verifyUnchangedNodes) {\n+    // If verifyUnchangedNodes is false, we are comparing the initial AST to the\n+    // final AST. Don't check unmarked nodes b/c they may have been changed by\n+    // non-loopable passes.\n+    // If verifyUnchangedNodes is true, we are comparing the ASTs before & after\n+    // a pass. Check all scope roots.\n+    final Map<Node, Node> mtoc = map;\n+    final boolean checkUnchanged = verifyUnchangedNodes;\n+    Node clone = mtoc.get(main);\n+    if (main.getChangeTime() > clone.getChangeTime()) {\n+      Preconditions.checkState(!main.isEquivalentToShallow(clone));\n+    } else if (checkUnchanged) {\n+      Preconditions.checkState(main.isEquivalentToShallow(clone));\n+    }\n+    visitPreOrder(main,\n+        new Visitor() {\n+          @Override\n+          public void visit(Node n) {\n+            if (n.isFunction() && mtoc.containsKey(n)) {\n+              Node clone = mtoc.get(n);\n+              if (n.getChangeTime() > clone.getChangeTime()) {\n+                Preconditions.checkState(!n.isEquivalentToShallow(clone));\n+              } else if (checkUnchanged) {\n+                Preconditions.checkState(n.isEquivalentToShallow(clone));\n+              }\n+            }\n+          }\n+        },\n+        Predicates.<Node>alwaysTrue());\n+  }\n }\n--- a/src/com/google/javascript/jscomp/PhaseOptimizer.java\n+++ b/src/com/google/javascript/jscomp/PhaseOptimizer.java\n   // change handlers. This flag prevents double update in ScopedChangeHandler.\n   private boolean crossScopeReporting;\n \n+  // Used for sanity checks between loopable passes\n+  private Node lastAst;\n+  private Map<Node, Node> mtoc; // Stands for \"main to clone\"\n+\n   /**\n    * @param compiler the compiler that owns/creates this.\n    * @param tracker an optional performance tracker\n   PhaseOptimizer(AbstractCompiler compiler, PerformanceTracker tracker,\n       ProgressRange progressRange) {\n     this.compiler = compiler;\n+    this.jsRoot = compiler.getJsRoot();\n     this.tracker = tracker;\n     this.progressRange = progressRange;\n     this.inLoop = false;\n    */\n   void setSanityCheck(PassFactory sanityCheck) {\n     this.sanityCheck = sanityCheck;\n+    setSanityCheckState();\n+  }\n+\n+  private void setSanityCheckState() {\n+    lastAst = jsRoot.cloneTree();\n+    mtoc = NodeUtil.mapMainToClone(jsRoot, lastAst);\n   }\n \n   /**\n           / passes.size();\n       progress = progressRange.initialValue;\n     }\n-\n-    jsRoot = root;\n     for (CompilerPass pass : passes) {\n       pass.process(externs, root);\n       if (hasHaltingErrors()) {\n   /**\n    * Runs the sanity check if it is available.\n    */\n-  void maybeSanityCheck(Node externs, Node root) {\n+  private void maybeSanityCheck(Node externs, Node root) {\n     if (sanityCheck != null) {\n       sanityCheck.create(compiler).process(externs, root);\n+      NodeUtil.verifyScopeChanges(mtoc, jsRoot, true);\n+      setSanityCheckState();\n     }\n   }\n \n \n   /** {@code n} is either a function or the top-level node of the AST */\n   void setScope(Node n) {\n-    currentScope = n;\n+    // NodeTraversal causes setScope calls outside loops; ignore them.\n+    if (inLoop) {\n+      currentScope = n.isFunction() ? n : compiler.getEnclosingScope(n);\n+    }\n   }\n \n   boolean hasScopeChanged(Node n) {\n       // Set up function-change tracking\n       scopeHandler = new ScopedChangeHandler();\n       compiler.addChangeHandler(scopeHandler);\n-      currentScope = root;\n+      setScope(root);\n       // lastRuns is initialized before each loop. This way, when a pass is run\n       // in the 2nd loop for the 1st time, it looks at all scopes.\n       lastRuns = new HashMap<NamedPass, Integer>();\n--- a/test/com/google/javascript/jscomp/CompilerTestCase.java\n+++ b/test/com/google/javascript/jscomp/CompilerTestCase.java\n import com.google.common.collect.ImmutableList;\n import com.google.common.collect.Lists;\n import com.google.javascript.jscomp.CompilerOptions.LanguageMode;\n-import com.google.javascript.jscomp.NodeTraversal.AbstractPreOrderCallback;\n import com.google.javascript.jscomp.type.ReverseAbstractInterpreter;\n import com.google.javascript.jscomp.type.SemanticReverseAbstractInterpreter;\n import com.google.javascript.rhino.Node;\n import junit.framework.TestCase;\n \n import java.io.IOException;\n-import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n \n     test(compiler, expected, error, warning, null);\n   }\n \n-  private Map<Node, Node> findCorrespondingNodes(Node n1, Node n2) {\n-    Preconditions.checkState(n1.isEquivalentTo(n2));\n-    Map<Node, Node> correspondingNodes = new HashMap<Node, Node>();\n-    correspondingNodes.put(n1, n2);\n-    correspondingNodesHelper(correspondingNodes, n1, n2);\n-    return correspondingNodes;\n-  }\n-\n-  private void correspondingNodesHelper(Map<Node, Node> map, Node n1, Node n2) {\n-    if (n1.isFunction()) {\n-      map.put(n1, n2);\n-    }\n-    for (Node child1 = n1.getFirstChild(), child2 = n2.getFirstChild();\n-         child1 != null;\n-         child1 = child1.getNext(), child2 = child2.getNext()) {\n-      correspondingNodesHelper(map, child1, child2);\n-    }\n-  }\n-\n   /**\n    * Verifies that the compiler pass's JS output matches the expected output\n    * and (optionally) that an expected warning is issued. Or, if an error is\n     Node rootClone = root.cloneTree();\n     Node externsRootClone = rootClone.getFirstChild();\n     Node mainRootClone = rootClone.getLastChild();\n-    final Map<Node, Node> nodeMap =\n-        findCorrespondingNodes(mainRoot, mainRootClone);\n+    Map<Node, Node> mtoc = NodeUtil.mapMainToClone(mainRoot, mainRootClone);\n \n     int numRepetitions = getNumRepetitions();\n     ErrorManager[] errorManagers = new ErrorManager[numRepetitions];\n             hasCodeChanged);\n       }\n \n-      // If a scope is marked as changed, it should not be shallow-equivalent\n-      // to its corresponding cloned scope. The converse is false b/c we don't\n-      // track changes to scopes by non-loopable passes.\n-      if (mainRoot.getChangeTime() != 0) {\n-        assertFalse(mainRoot.isEquivalentToShallow(nodeMap.get(mainRoot)));\n-      }\n-      NodeTraversal.traverse(compiler, mainRoot,\n-          new AbstractPreOrderCallback() {\n-            @Override\n-            public final boolean shouldTraverse(\n-                NodeTraversal t, Node n, Node p) {\n-              if (n.isFunction() &&\n-                  n.getChangeTime() != 0 && nodeMap.containsKey(n)) {\n-                assertFalse(n.isEquivalentToShallow(nodeMap.get(n)));\n-              }\n-              return true;\n-            }\n-          });\n+      // Check correctness of the changed-scopes-only traversal\n+      NodeUtil.verifyScopeChanges(mtoc, mainRoot, false);\n \n       if (expected != null) {\n         if (compareAsTree) {\n--- a/test/com/google/javascript/jscomp/MultiPassTest.java\n+++ b/test/com/google/javascript/jscomp/MultiPassTest.java\n   protected CompilerPass getProcessor(Compiler compiler) {\n     PhaseOptimizer po = new PhaseOptimizer(compiler, null, null);\n     po.consume(passes);\n+    po.setSanityCheck(new PassFactory(\"sanityCheck\", false) {\n+        @Override\n+        protected CompilerPass create(AbstractCompiler compiler) {\n+          return new SanityCheck(compiler);\n+        }\n+      });\n     compiler.setPhaseOptimizer(po);\n     return po;\n   }\n--- a/test/com/google/javascript/jscomp/PhaseOptimizerTest.java\n+++ b/test/com/google/javascript/jscomp/PhaseOptimizerTest.java\n     assertPasses(\"a\", \"x\", \"y\", \"x\", \"y\", \"x\", \"x\", \"y\", \"z\");\n   }\n \n-  public void testSanityCheck() {\n-    Loop loop = optimizer.addFixedPointLoop();\n-    addLoopedPass(loop, \"x\", 1);\n-    addOneTimePass(\"z\");\n-    optimizer.setSanityCheck(\n-        createPassFactory(\"sanity\", createPass(\"sanity\", 0), false));\n-    assertPasses(\"x\", \"sanity\", \"x\", \"sanity\", \"z\", \"sanity\");\n-  }\n-\n   public void testConsumption1() {\n     optimizer.consume(\n         Lists.newArrayList(", "timestamp": 1363996891, "metainfo": ""}