{"sha": "94cd95e3bdbea760d996f121bc1f1a0eed3a7e83", "log": "Two more changes to RemoveUnusedClassProperties 1) Legacy Closure style code often defines value on the prototype, we want to remove those if it is the only other property set. Previously we would leave them and the RemoveUnusedPrototypeProperties pass would remove them, but now that we would otherwise back off in the face of them we want to remove them. 2) If someone is reflecting on the class using goog.reflect.object we want to preserve the property, so we back off if any object literal definition is present, this is consistent with backing off with other property sets. ------------- Created by MOE: http://code.google.com/p/moe-java MOE_MIGRATED_REVID=49502148", "commit": "\n--- a/src/com/google/javascript/jscomp/RemoveUnusedClassProperties.java\n+++ b/src/com/google/javascript/jscomp/RemoveUnusedClassProperties.java\n        case Token.GETPROP: {\n          String propName = n.getLastChild().getString();\n          if (inExterns || isPinningPropertyUse(n)\n-             || !n.getFirstChild().isThis()) {\n+             || !isKnownClassProperty(n)) {\n            used.add(propName);\n          } else {\n            // This is a definition of a property but it is only removable\n            // if it is defined on \"this\".\n            candidates.add(n);\n+         }\n+         break;\n+       }\n+\n+       case Token.OBJECTLIT: {\n+         // Assume any object literal definition might be a reflection on the\n+         // class property.\n+         for (Node c : n.children()) {\n+           used.add(c.getString());\n          }\n          break;\n        }\n          }\n          break;\n      }\n+  }\n+\n+  private boolean isKnownClassProperty(Node n) {\n+    Preconditions.checkState(n.isGetProp());\n+    Node target = n.getFirstChild();\n+    return target.isThis()\n+        || (target.isGetProp()\n+            && target.getLastChild().getString().equals(\"prototype\"));\n   }\n \n   /**\n--- a/test/com/google/javascript/jscomp/RemoveUnusedClassPropertiesTest.java\n+++ b/test/com/google/javascript/jscomp/RemoveUnusedClassPropertiesTest.java\n   public void testObjLit() {\n     // A property defined on an object other than \"this\" can not be removed.\n     testSame(\"({a:2})\");\n-    // but doesn't prevent the removal of the definition on 'this'.\n-    test(\"({a:0}); this.a = 1;\", \"({a:0});1\");\n+    // and prevent the removal of the definition on 'this'.\n+    testSame(\"({a:0}); this.a = 1;\");\n     // Some use of the property \"a\" prevents the removal.\n     testSame(\"x = ({a:0}); this.a = 1; alert(x.a)\");\n   }\n          \"1;alert(Object.keys(this))\");\n   }\n \n+  public void testObjectReflection1() {\n+    // Verify reflection prevents removal.\n+    testSame(\n+        \"/** @constructor */ function A() {this.foo = 1;}\\n\" +\n+        \"use(goog.reflect.object(A, {foo: 'foo'}));\\n\");\n+  }\n+\n+  public void testObjectReflection2() {\n+    // Any object literal definition prevents removal.\n+    // Type based removal would allow this to be removed.\n+    testSame(\n+        \"/** @constructor */ function A() {this.foo = 1;}\\n\" +\n+        \"use({foo: 'foo'});\\n\");\n+  }\n+\n   public void testIssue730() {\n     // Partial removal of properties can causes problems if the object is\n     // sealed.\n         \"B.prototype.dostuff = function() {this.a.foo++;alert('hi');}\\n\" +\n         \"new B().dostuff();\\n\");\n   }\n+\n+  public void testPrototypeProps1() {\n+    test(\n+        \"function A() {this.foo = 1;}\\n\" +\n+        \"A.prototype.foo = 0;\\n\" +\n+        \"A.prototype.method = function() {this.foo++};\\n\" +\n+        \"new A().method()\\n\",\n+        \"function A() {1;}\\n\" +\n+        \"0;\\n\" +\n+        \"A.prototype.method = function() {0;};\\n\" +\n+        \"new A().method()\\n\");\n+  }\n }", "timestamp": 1374100013, "metainfo": ""}