{"sha": "ecde688b4adf68c977a5bc27bd67b555ac352e62", "log": "Deleting a property should prevent collapsing of that property.  R=acleung DELTA=165  (135 added, 10 deleted, 20 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=2232   ", "commit": "\n--- a/src/com/google/javascript/jscomp/CollapseProperties.java\n+++ b/src/com/google/javascript/jscomp/CollapseProperties.java\n   private void checkNamespaces() {\n     for (Name name : nameMap.values()) {\n       if (name.isNamespace() &&\n-          (name.aliasingGets > 0 || name.localSets + name.globalSets > 1)) {\n+          (name.aliasingGets > 0 || name.localSets + name.globalSets > 1 ||\n+           name.deleteProps > 0)) {\n         boolean initialized = name.declaration != null;\n         for (Ref ref : name.getRefs()) {\n           if (ref == name.declaration) {\n             continue;\n           }\n \n-          if (ref.type == Ref.Type.SET_FROM_GLOBAL ||\n+          if (ref.type == Ref.Type.DELETE_PROP) {\n+            if (initialized) {\n+              warnAboutNamespaceRedefinition(name, ref);\n+            }\n+          } else if (\n+              ref.type == Ref.Type.SET_FROM_GLOBAL ||\n               ref.type == Ref.Type.SET_FROM_LOCAL) {\n             if (initialized) {\n               warnAboutNamespaceRedefinition(name, ref);\n         collapseDeclarationOfNameAndDescendants(\n             p, appendPropForAlias(alias, p.name));\n \n-        if (!p.inExterns && canCollapseChildNames && p.declaration != null &&\n+        if (!p.inExterns && canCollapseChildNames &&\n+            p.declaration != null &&\n+            p.canCollapse() &&\n             p.declaration.node != null &&\n             p.declaration.node.getParent() != null &&\n             p.declaration.node.getParent().getType() == Token.ASSIGN) {\n                                TokenStream.isJSIdentifier(key.getString());\n       String propName = isJsIdentifier ?\n           key.getString() : String.valueOf(++arbitraryNameCounter);\n+\n+      // If the name cannot be collapsed, skip it.\n+      String qName = objlitName.fullName() + '.' + propName;\n+      Name p = nameMap.get(qName);\n+      if (p != null && !p.canCollapse()) {\n+        continue;\n+      }\n+\n       String propAlias = appendPropForAlias(alias, propName);\n-      String qName = objlitName.fullName() + '.' + propName;\n-\n       Node refNode = null;\n       if (discardKeys) {\n         objlit.removeChild(key);\n       compiler.reportCodeChange();\n       nameToAddAfter = newVar;\n \n-      if (isJsIdentifier) {\n-        // Update the global name's node ancestry if it hasn't already been\n-        // done. (Duplicate keys in an object literal can bring us here twice\n-        // for the same global name.)\n-        Name p = nameMap.get(qName);\n-        if (p != null) {\n-          if (!discardKeys) {\n-            Ref newAlias =\n-                p.declaration.cloneAndReclassify(Ref.Type.ALIASING_GET);\n-            newAlias.node = refNode;\n-            p.addRef(newAlias);\n-          }\n-\n-          p.declaration.node = nameNode;\n-\n-          if (value.getType() == Token.FUNCTION) {\n-            checkForHosedThisReferences(value, value.getJSDocInfo(), p);\n-          }\n+      // Update the global name's node ancestry if it hasn't already been\n+      // done. (Duplicate keys in an object literal can bring us here twice\n+      // for the same global name.)\n+      if (isJsIdentifier && p != null) {\n+        if (!discardKeys) {\n+          Ref newAlias =\n+              p.declaration.cloneAndReclassify(Ref.Type.ALIASING_GET);\n+          newAlias.node = refNode;\n+          p.addRef(newAlias);\n+        }\n+\n+        p.declaration.node = nameNode;\n+\n+        if (value.getType() == Token.FUNCTION) {\n+          checkForHosedThisReferences(value, value.getJSDocInfo(), p);\n         }\n       }\n \n--- a/src/com/google/javascript/jscomp/GlobalNamespace.java\n+++ b/src/com/google/javascript/jscomp/GlobalNamespace.java\n               type = determineGetTypeForHookOrBooleanExpr(t, parent, name);\n             }\n             break;\n+          case Token.DELPROP:\n+            type = Ref.Type.DELETE_PROP;\n+            break;\n           default:\n             type = Ref.Type.ALIASING_GET;\n             break;\n               return Ref.Type.ALIASING_GET;\n             }\n             break;\n+          case Token.DELPROP:\n+            return Ref.Type.DELETE_PROP;\n         }\n         prev = anc;\n       }\n     int aliasingGets = 0;\n     int totalGets = 0;\n     int callGets = 0;\n+    int deleteProps = 0;\n     boolean inExterns;\n \n     JSDocInfo docInfo = null;\n     }\n \n     void addRef(Ref ref) {\n+      addRefInternal(ref);\n       switch (ref.type) {\n         case SET_FROM_GLOBAL:\n           if (declaration == null) {\n             declaration = ref;\n             docInfo = getDocInfoForDeclaration(ref);\n           }\n-          addRefInternal(ref);\n           globalSets++;\n           break;\n         case SET_FROM_LOCAL:\n-          addRefInternal(ref);\n           localSets++;\n           break;\n         case PROTOTYPE_GET:\n         case DIRECT_GET:\n-          addRefInternal(ref);\n           totalGets++;\n           break;\n         case ALIASING_GET:\n-          addRefInternal(ref);\n           aliasingGets++;\n           totalGets++;\n           break;\n         case CALL_GET:\n-          addRefInternal(ref);\n           callGets++;\n           totalGets++;\n+          break;\n+        case DELETE_PROP:\n+          deleteProps++;\n           break;\n         default:\n           throw new IllegalStateException();\n             callGets--;\n             totalGets--;\n             break;\n+          case DELETE_PROP:\n+            deleteProps--;\n+            break;\n           default:\n             throw new IllegalStateException();\n         }\n     boolean canCollapse() {\n       return !inExterns && !isGetOrSetDefinition() && (isClassOrEnum ||\n           (parent == null || parent.canCollapseUnannotatedChildNames()) &&\n-          (globalSets > 0 || localSets > 0));\n+          (globalSets > 0 || localSets > 0) &&\n+          deleteProps == 0);\n     }\n \n     boolean isGetOrSetDefinition() {\n \n     boolean canCollapseUnannotatedChildNames() {\n       if (type == Type.OTHER || isGetOrSetDefinition()\n-          || globalSets != 1 || localSets != 0) {\n+          || globalSets != 1 || localSets != 0 || deleteProps != 0) {\n         return false;\n       }\n \n       ALIASING_GET,     // Prevents a name's properties from being collapsed\n       DIRECT_GET,       // Prevents a name from being completely eliminated\n       CALL_GET,         // Prevents a name from being collapsed if never set\n+      DELETE_PROP,      // Prevents a name from being collapsed at all.\n     }\n \n     Node node;\n--- a/test/com/google/javascript/jscomp/CollapsePropertiesTest.java\n+++ b/test/com/google/javascript/jscomp/CollapsePropertiesTest.java\n          \"foo.Bar = function() {};\",\n          \"var foo$Bar$Baz; var foo$Bar = function(){};\");\n   }\n+\n+  public void testDelete1() {\n+    testSame(\n+        \"var foo = {};\" +\n+        \"foo.bar = 3;\" +\n+        \"delete foo.bar;\");\n+  }\n+\n+  public void testDelete2() {\n+    test(\n+        \"var foo = {};\" +\n+        \"foo.bar = 3;\" +\n+        \"foo.baz = 3;\" +\n+        \"delete foo.bar;\",\n+        \"var foo = {};\" +\n+        \"foo.bar = 3;\" +\n+        \"var foo$baz = 3;\" +\n+        \"delete foo.bar;\");\n+  }\n+\n+  public void testDelete3() {\n+    testSame(\n+        \"var foo = {bar: 3};\" +\n+        \"delete foo.bar;\");\n+  }\n+\n+  public void testDelete4() {\n+    test(\n+        \"var foo = {bar: 3, baz: 3};\" +\n+        \"delete foo.bar;\",\n+        \"var foo$baz=3;var foo={bar:3};delete foo.bar\");\n+  }\n+\n+  public void testDelete5() {\n+    test(\n+        \"var x = {};\" +\n+        \"x.foo = {};\" +\n+        \"x.foo.bar = 3;\" +\n+        \"delete x.foo.bar;\",\n+        \"var x$foo = {};\" +\n+        \"x$foo.bar = 3;\" +\n+        \"delete x$foo.bar;\");\n+  }\n+\n+  public void testDelete6() {\n+    test(\n+        \"var x = {};\" +\n+        \"x.foo = {};\" +\n+        \"x.foo.bar = 3;\" +\n+        \"x.foo.baz = 3;\" +\n+        \"delete x.foo.bar;\",\n+        \"var x$foo = {};\" +\n+        \"x$foo.bar = 3;\" +\n+        \"var x$foo$baz = 3;\" +\n+        \"delete x$foo.bar;\");\n+  }\n+\n+  public void testDelete7() {\n+    test(\n+        \"var x = {};\" +\n+        \"x.foo = {bar: 3};\" +\n+        \"delete x.foo.bar;\",\n+        \"var x$foo = {bar: 3};\" +\n+        \"delete x$foo.bar;\");\n+  }\n+\n+  public void testDelete8() {\n+    test(\n+        \"var x = {};\" +\n+        \"x.foo = {bar: 3, baz: 3};\" +\n+        \"delete x.foo.bar;\",\n+        \"var x$foo$baz = 3; var x$foo = {bar: 3};\" +\n+        \"delete x$foo.bar;\");\n+  }\n+\n+  public void testDelete9() {\n+    testSame(\n+        \"var x = {};\" +\n+        \"x.foo = {};\" +\n+        \"x.foo.bar = 3;\" +\n+        \"delete x.foo;\");\n+  }\n+\n+  public void testDelete10() {\n+    testSame(\n+        \"var x = {};\" +\n+        \"x.foo = {bar: 3};\" +\n+        \"delete x.foo;\");\n+  }\n+\n+  public void testDelete11() {\n+    // Constructors are always collapsed.\n+    test(\n+        \"var x = {};\" +\n+        \"x.foo = {};\" +\n+        \"/** @constructor */ x.foo.Bar = function() {};\" +\n+        \"delete x.foo;\",\n+        \"var x = {};\" +\n+        \"x.foo = {};\" +\n+        \"var x$foo$Bar = function() {};\" +\n+        \"delete x.foo;\",\n+        null,\n+        CollapseProperties.NAMESPACE_REDEFINED_WARNING);\n+  }\n }", "timestamp": 1307718383, "metainfo": ""}