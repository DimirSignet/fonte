{"sha": "3e66c9c827308d2f549a16440e3f0ef7fd844e04", "log": "Add fine grained dependency options  R=johnlenz DELTA=230  (206 added, 4 deleted, 20 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=3955   ", "commit": "\n--- a/src/com/google/javascript/jscomp/AbstractCommandLineRunner.java\n+++ b/src/com/google/javascript/jscomp/AbstractCommandLineRunner.java\n     options.setTweakProcessing(config.tweakProcessing);\n     createDefineOrTweakReplacements(config.tweak, options, true);\n \n-    options.manageClosureDependencies = config.manageClosureDependencies;\n+    options.setManageClosureDependencies(config.manageClosureDependencies);\n     if (config.closureEntryPoints.size() > 0) {\n       options.setManageClosureDependencies(config.closureEntryPoints);\n     }\n--- a/src/com/google/javascript/jscomp/Compiler.java\n+++ b/src/com/google/javascript/jscomp/Compiler.java\n       }\n \n       // Check if the sources need to be re-ordered.\n-      if (options.manageClosureDependencies) {\n+      if (options.dependencyOptions.needsManagement()) {\n         for (CompilerInput input : inputs) {\n           input.setCompiler(this);\n \n         try {\n           inputs =\n               (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n-              .manageDependencies(\n-                  options.manageClosureDependenciesEntryPoints, inputs);\n+              .manageDependencies(options.dependencyOptions, inputs);\n         } catch (CircularDependencyException e) {\n           report(JSError.make(\n               JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n--- a/src/com/google/javascript/jscomp/CompilerOptions.java\n+++ b/src/com/google/javascript/jscomp/CompilerOptions.java\n package com.google.javascript.jscomp;\n \n import com.google.common.base.Preconditions;\n-import com.google.common.collect.ImmutableList;\n import com.google.common.collect.Lists;\n import com.google.common.collect.Maps;\n import com.google.common.collect.Multimap;\n   // Input Options\n   //--------------------------------\n \n-  boolean manageClosureDependencies = false;\n-  List<String> manageClosureDependenciesEntryPoints = ImmutableList.of();\n+  DependencyOptions dependencyOptions = new DependencyOptions();\n \n   /** Returns localized replacement for MSG_* variables */\n   // Transient so that clients don't have to implement Serializable.\n   }\n \n   /**\n+   * Sets dependency options. See the DependencyOptions class for more info.\n+   * This supercedes manageClosureDependencies.\n+   */\n+  public void setDependencyOptions(DependencyOptions options) {\n+    this.dependencyOptions = options;\n+  }\n+\n+  /**\n    * Sort inputs by their goog.provide/goog.require calls, and prune inputs\n    * whose symbols are not required.\n    */\n   public void setManageClosureDependencies(boolean newVal) {\n-    manageClosureDependencies = newVal;\n+    dependencyOptions.setDependencySorting(newVal);\n+    dependencyOptions.setDependencyPruning(newVal);\n+    dependencyOptions.setMoocherDropping(false);\n   }\n \n   /**\n    */\n   public void setManageClosureDependencies(List<String> entryPoints) {\n     Preconditions.checkNotNull(entryPoints);\n-    manageClosureDependencies = true;\n-    manageClosureDependenciesEntryPoints = entryPoints;\n+    setManageClosureDependencies(true);\n+    dependencyOptions.setEntryPoints(entryPoints);\n   }\n \n   /**\n--- /dev/null\n+++ b/src/com/google/javascript/jscomp/DependencyOptions.java\n+/*\n+ * Copyright 2011 The Closure Compiler Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+import com.google.common.collect.Sets;\n+\n+import java.io.Serializable;\n+import java.util.Collection;\n+import java.util.Set;\n+\n+/**\n+ * Options for how to manage dependencies between input files.\n+ *\n+ * Dependency information is usually pulled out from the JS code by\n+ * looking for primitive dependency functions (like Closure Library's\n+ * goog.provide/goog.require). Analysis of this dependency information is\n+ * controlled by {@code CodingConvention}, which lets you define those\n+ * dependency primitives.\n+ *\n+ * This options class determines how we use that dependency information\n+ * to change how code is built.\n+ *\n+ * @author nicksantos@google.com (Nick Santos)\n+ */\n+public class DependencyOptions implements Serializable {\n+  private static final long serialVersionUID = 1L;\n+\n+  private boolean sortDependencies = false;\n+  private boolean pruneDependencies = false;\n+  private boolean dropMoochers = false;\n+  private final Set<String> entryPoints = Sets.newHashSet();\n+\n+  /**\n+   * Enables or disables dependency sorting mode.\n+   *\n+   * If true, we will sort the input files based on dependency information\n+   * in them. Otherwise, we will use the order of files specified\n+   * on the command-line.\n+   */\n+  public void setDependencySorting(boolean enabled) {\n+    this.sortDependencies = enabled;\n+  }\n+\n+  /**\n+   * Enables or disables dependency pruning mode.\n+   *\n+   * In dependency pruning mode, we will look for all files that provide a\n+   * symbol. Unless that file is a transitive dependency of a file that\n+   * we're using, we will remove it from the compilation job.\n+   *\n+   * This does not affect how we handle files that do not provide symbols.\n+   * See setMoocherDropping for information on how these are handled.\n+   */\n+  public void setDependencyPruning(boolean enabled) {\n+    this.pruneDependencies = enabled;\n+  }\n+\n+  /**\n+   * Enables or disables moocher dropping mode.\n+   *\n+   * A 'moocher' is a file that does not provide any symbols (though they\n+   * may require symbols). This is usually because they don't want to\n+   * tie themselves to a particular dependency system (e.g., Closure's\n+   * goog.provide, CommonJS modules). So they rely on other people to\n+   * manage dependencies on them.\n+   *\n+   * If true, we drop these files when we prune dependencies.\n+   * If false, we always keep these files an anything they depend on.\n+   * The default is false.\n+   *\n+   * Notice that this option only makes sense if dependency pruning is on,\n+   * and a set of entry points is specified.\n+   */\n+  public void setMoocherDropping(boolean enabled) {\n+    this.dropMoochers = enabled;\n+  }\n+\n+  /**\n+   * Adds a collection of symbols to always keep.\n+   *\n+   * In dependency pruning mode, we will automatically keep all the\n+   * transitive dependencies of these symbols.\n+   *\n+   * The syntactic form of a symbol depends on the type of dependency\n+   * primitives we're using. For example, goog.provide('foo.bar')\n+   * provides the symbol 'foo.bar'.\n+   */\n+  public void setEntryPoints(Collection<String> symbols) {\n+    entryPoints.clear();\n+    entryPoints.addAll(symbols);\n+  }\n+\n+  /** Returns whether re-ordering of files is needed. */\n+  boolean needsManagement() {\n+    return sortDependencies || pruneDependencies;\n+  }\n+\n+  boolean shouldSortDependencies() {\n+    return sortDependencies;\n+  }\n+\n+  boolean shouldPruneDependencies() {\n+    return pruneDependencies;\n+  }\n+\n+  boolean shouldDropMoochers() {\n+    return pruneDependencies && dropMoochers;\n+  }\n+\n+  Collection<String> getEntryPoints() {\n+    return entryPoints;\n+  }\n+}\n--- a/src/com/google/javascript/jscomp/JSModuleGraph.java\n+++ b/src/com/google/javascript/jscomp/JSModuleGraph.java\n package com.google.javascript.jscomp;\n \n import com.google.common.base.Preconditions;\n+import com.google.common.collect.ImmutableList;\n import com.google.common.collect.Iterables;\n import com.google.common.collect.LinkedHashMultimap;\n import com.google.common.collect.LinkedListMultimap;\n   }\n \n   /**\n-   * Sort the sources of modules in dependency-order.\n-   *\n-   * If a source file provides a symbol that is not required, then that\n-   * file will be removed from the compilation. If a source file provides\n-   * a symbol that is not required until a later module, then that\n-   * file will be moved to the later module.\n+   * Applies a DependencyOptions in \"dependency sorting\" and \"dependency pruning\"\n+   * mode to the given list of inputs. Returns a new list with the files sorted\n+   * and removed. This module graph will be updated to reflect the new list.\n+   *\n+   * If you need more fine-grained dependency management, you should create your\n+   * own DependencyOptions and call\n+   * {@code manageDependencies(DependencyOptions, List<CompilerInput>)}.\n    *\n    * @param entryPoints The entry points into the program.\n    *     Expressed as JS symbols.\n    * @param inputs The original list of sources. Used to ensure that the sort\n    *     is stable.\n-   * @return The sorted list of sources.\n    * @throws CircularDependencyException if there is a circular dependency\n    *     between the provides and requires.\n    * @throws MissingProvideException if an entry point was not provided\n    *     by any of the inputs.\n+   * @see DependencyOptions for more info on how this works.\n    */\n   public List<CompilerInput> manageDependencies(\n       List<String> entryPoints,\n       List<CompilerInput> inputs)\n       throws CircularDependencyException, MissingProvideException {\n+    DependencyOptions depOptions = new DependencyOptions();\n+    depOptions.setDependencySorting(true);\n+    depOptions.setDependencyPruning(true);\n+    depOptions.setEntryPoints(entryPoints);\n+    return manageDependencies(depOptions, inputs);\n+  }\n+\n+  /**\n+   * Apply the dependency options to the list of sources, returning a new\n+   * source list re-ordering and dropping files as necessary.\n+   * This module graph will be updated to reflect the new list.\n+   *\n+   * @param inputs The original list of sources. Used to ensure that the sort\n+   *     is stable.\n+   * @throws CircularDependencyException if there is a circular dependency\n+   *     between the provides and requires.\n+   * @throws MissingProvideException if an entry point was not provided\n+   *     by any of the inputs.\n+   * @see DependencyOptions for more info on how this works.\n+   */\n+  public List<CompilerInput> manageDependencies(\n+      DependencyOptions depOptions,\n+      List<CompilerInput> inputs)\n+      throws CircularDependencyException, MissingProvideException {\n+\n     SortedDependencies<CompilerInput> sorter =\n         new SortedDependencies<CompilerInput>(inputs);\n     Set<CompilerInput> entryPointInputs =\n-        Sets.newLinkedHashSet(sorter.getInputsWithoutProvides());\n-    for (String entryPoint : entryPoints) {\n+        Sets.newLinkedHashSet(\n+            depOptions.shouldDropMoochers() ?\n+            ImmutableList.<CompilerInput>of() :\n+            sorter.getInputsWithoutProvides());\n+    for (String entryPoint : depOptions.getEntryPoints()) {\n       entryPointInputs.add(sorter.getInputProviding(entryPoint));\n     }\n \n     // The order of inputs, sorted independently of modules.\n-    List<CompilerInput> absoluteOrder = sorter.getSortedDependenciesOf(inputs);\n+    List<CompilerInput> absoluteOrder =\n+        sorter.getDependenciesOf(inputs, depOptions.shouldSortDependencies());\n \n     // Figure out which sources *must* be in each module.\n     ListMultimap<JSModule, CompilerInput> entryPointInputsPerModule =\n     // of that module's dependencies.\n     for (JSModule module : entryPointInputsPerModule.keySet()) {\n       List<CompilerInput> transitiveClosure =\n-          sorter.getSortedDependenciesOf(\n-              entryPointInputsPerModule.get(module));\n+          sorter.getDependenciesOf(\n+              entryPointInputsPerModule.get(module),\n+              depOptions.shouldSortDependencies());\n       for (CompilerInput input : transitiveClosure) {\n         JSModule oldModule = input.getModule();\n         if (oldModule == null) {\n--- a/src/com/google/javascript/jscomp/deps/SortedDependencies.java\n+++ b/src/com/google/javascript/jscomp/deps/SortedDependencies.java\n    * list.\n    */\n   public List<INPUT> getSortedDependenciesOf(List<INPUT> roots) {\n+    return getDependenciesOf(roots, true);\n+  }\n+\n+  /**\n+   * Gets all the dependencies of the given roots. The inputs must be returned\n+   * in a stable order. In other words, if A comes before B, and A does not\n+   * transitively depend on B, then A must also come before B in the returned\n+   * list.\n+   *\n+   * @param sorted If true, get them in topologically sorted order. If false,\n+   *     get them in the original order they were passed to the compiler.\n+   */\n+  public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted) {\n     Preconditions.checkArgument(inputs.containsAll(roots));\n     Set<INPUT> included = Sets.newHashSet();\n     Deque<INPUT> worklist = new ArrayDeque<INPUT>(roots);\n     }\n \n     ImmutableList.Builder<INPUT> builder = ImmutableList.builder();\n-    for (INPUT current : sortedList) {\n+    for (INPUT current : (sorted ? sortedList : inputs)) {\n       if (included.contains(current)) {\n         builder.add(current);\n       }\n--- a/test/com/google/javascript/jscomp/CompilerTest.java\n+++ b/test/com/google/javascript/jscomp/CompilerTest.java\n             \"mix\", \"goog.require('gin'); goog.require('tonic');\")};\n     CompilerOptions options = new CompilerOptions();\n     options.ideMode = true;\n-    options.manageClosureDependencies = true;\n+    options.setManageClosureDependencies(true);\n     Compiler compiler = new Compiler();\n     compiler.init(new JSSourceFile[0], inputs, options);\n     compiler.parseInputs();\n--- a/test/com/google/javascript/jscomp/JSModuleGraphTest.java\n+++ b/test/com/google/javascript/jscomp/JSModuleGraphTest.java\n         sourceNames(results));\n   }\n \n+  public void testManageDependencies3() throws Exception {\n+    List<CompilerInput> inputs = setUpManageDependenciesTest();\n+    DependencyOptions depOptions = new DependencyOptions();\n+    depOptions.setDependencySorting(true);\n+    depOptions.setDependencyPruning(true);\n+    depOptions.setMoocherDropping(true);\n+    depOptions.setEntryPoints(ImmutableList.<String>of(\"c2\"));\n+    List<CompilerInput> results = graph.manageDependencies(\n+        depOptions, inputs);\n+\n+    // Everything gets pushed up into module c, because that's\n+    // the only one that has entry points.\n+    assertInputs(A);\n+    assertInputs(B);\n+    assertInputs(C, \"a1\", \"c1\", \"c2\");\n+    assertInputs(E);\n+\n+    assertEquals(\n+        Lists.newArrayList(\"a1\", \"c1\", \"c2\"),\n+        sourceNames(results));\n+  }\n+\n   private List<CompilerInput> setUpManageDependenciesTest() {\n     List<CompilerInput> inputs = Lists.newArrayList();\n ", "timestamp": 1323725125, "metainfo": ""}