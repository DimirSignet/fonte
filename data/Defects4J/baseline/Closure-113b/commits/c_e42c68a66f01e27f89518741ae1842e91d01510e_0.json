{"sha": "e42c68a66f01e27f89518741ae1842e91d01510e", "log": "Slim down ast node annotation objects. This is much less ambitious than the original CL proposed by John. In this CL, the props are mutable and there are only two concrete base classes.  R=johnlenz DELTA=127  (80 added, 15 deleted, 32 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=2368   ", "commit": "\n--- a/src/com/google/javascript/rhino/Node.java\n+++ b/src/com/google/javascript/rhino/Node.java\n     private String str;\n   }\n \n-  // PropListItems are immutable so that they can be shared.\n-  private static class PropListItem implements Serializable {\n+  // PropListItems must be immutable so that they can be shared.\n+  private interface PropListItem {\n+    int getType();\n+    PropListItem getNext();\n+    void setNext(PropListItem next);\n+    Object getObjectValue();\n+    int getIntValue();\n+  }\n+\n+  private static abstract class AbstractPropListItem\n+      implements PropListItem, Serializable {\n     private static final long serialVersionUID = 1L;\n \n-    final PropListItem next;\n-    final int type;\n+    private PropListItem next;\n+    private final int propType;\n+\n+    AbstractPropListItem(int propType, PropListItem next) {\n+      this.propType = propType;\n+      this.next = next;\n+    }\n+\n+    public int getType() {\n+      return propType;\n+    }\n+\n+    public PropListItem getNext() {\n+      return next;\n+    }\n+\n+    public void setNext(PropListItem next) {\n+      this.next = next;\n+    }\n+  }\n+\n+  // A base class for Object storing props\n+  private static class ObjectPropListItem\n+      extends AbstractPropListItem {\n+    private static final long serialVersionUID = 1L;\n+\n+    private final Object objectValue;\n+\n+    ObjectPropListItem(int propType, Object objectValue, PropListItem next) {\n+      super(propType, next);\n+      this.objectValue = objectValue;\n+    }\n+\n+    @Override\n+    public int getIntValue() {\n+      throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public Object getObjectValue() {\n+      return objectValue;\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return objectValue == null ? \"null\" : objectValue.toString();\n+    }\n+  }\n+\n+  // A base class for int storing props\n+  private static class IntPropListItem extends AbstractPropListItem {\n+    private static final long serialVersionUID = 1L;\n+\n     final int intValue;\n-    final Object objectValue;\n-\n-    PropListItem(int type, int intValue, PropListItem next) {\n-      this(type, intValue, null, next);\n-    }\n-\n-    PropListItem(int type, Object objectValue, PropListItem next) {\n-      this(type, 0, objectValue, next);\n-    }\n-\n-    PropListItem(\n-        int type, int intValue, Object objectValue, PropListItem next) {\n-      this.type = type;\n+\n+    IntPropListItem(int propType, int intValue, PropListItem next) {\n+      super(propType, next);\n       this.intValue = intValue;\n-      this.objectValue = objectValue;\n-      this.next = next;\n-    }\n-  }\n-\n+    }\n+\n+    @Override\n+    public int getIntValue() {\n+      return intValue;\n+    }\n+\n+    @Override\n+    public Object getObjectValue() {\n+      throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return String.valueOf(intValue);\n+    }\n+  }\n \n   public Node(int nodeType) {\n     type = nodeType;\n   @VisibleForTesting\n   PropListItem lookupProperty(int propType) {\n     PropListItem x = propListHead;\n-    while (x != null && propType != x.type) {\n-      x = x.next;\n+    while (x != null && propType != x.getType()) {\n+      x = x.getNext();\n     }\n     return x;\n   }\n   private PropListItem removeProp(PropListItem item, int propType) {\n     if (item == null) {\n       return null;\n-    } else if (item.type == propType) {\n-      return item.next;\n+    } else if (item.getType() == propType) {\n+      return item.getNext();\n     } else {\n-      PropListItem result = removeProp(item.next, propType);\n-      if (result != item.next) {\n-        return new PropListItem(\n-            item.type, item.intValue, item.objectValue, result);\n+      PropListItem result = removeProp(item.getNext(), propType);\n+      if (result != item.getNext()) {\n+        item.setNext(result);\n+        return item;\n       } else {\n         return item;\n       }\n     if (item == null) {\n       return null;\n     }\n-    return item.objectValue;\n+    return item.getObjectValue();\n   }\n \n   public boolean getBooleanProp(int propType) {\n     if (item == null) {\n       return 0;\n     }\n-    return item.intValue;\n+    return item.getIntValue();\n   }\n \n   public int getExistingIntProp(int propType) {\n     if (item == null) {\n       Kit.codeBug();\n     }\n-    return item.intValue;\n+    return item.getIntValue();\n   }\n \n   public void putProp(int propType, Object value) {\n     removeProp(propType);\n     if (value != null) {\n-      propListHead = new PropListItem(propType, value, propListHead);\n+      propListHead = createProp(propType, value, propListHead);\n     }\n   }\n \n   public void putIntProp(int propType, int value) {\n     removeProp(propType);\n     if (value != 0) {\n-      propListHead = new PropListItem(propType, value, propListHead);\n-    }\n+      propListHead = createProp(propType, value, propListHead);\n+    }\n+  }\n+\n+  PropListItem createProp(int propType, Object value, PropListItem next) {\n+    return new ObjectPropListItem(propType, value, next);\n+  }\n+\n+  PropListItem createProp(int propType, int value, PropListItem next) {\n+    return new IntPropListItem(propType, value, next);\n   }\n \n   // Gets all the property types, in sorted order.\n   private int[] getSortedPropTypes() {\n     int count = 0;\n-    for (PropListItem x = propListHead; x != null; x = x.next) {\n+    for (PropListItem x = propListHead; x != null; x = x.getNext()) {\n       count++;\n     }\n \n     int[] keys = new int[count];\n-    for (PropListItem x = propListHead; x != null; x = x.next) {\n+    for (PropListItem x = propListHead; x != null; x = x.getNext()) {\n       count--;\n-      keys[count] = x.type;\n+      keys[count] = x.getType();\n     }\n \n     Arrays.sort(keys);\n               value = \"last local block\";\n               break;\n             case ISNUMBER_PROP:\n-              switch (x.intValue) {\n+              switch (x.getIntValue()) {\n                 case BOTH:\n                   value = \"both\";\n                   break;\n               }\n               break;\n             case SPECIALCALL_PROP:\n-              switch (x.intValue) {\n+              switch (x.getIntValue()) {\n                 case SPECIALCALL_EVAL:\n                   value = \"eval\";\n                   break;\n               }\n               break;\n             default:\n-              Object obj = x.objectValue;\n-              if (obj != null) {\n-                value = obj.toString();\n-              } else {\n-                value = String.valueOf(x.intValue);\n-              }\n+              value = x.toString();\n               break;\n           }\n           sb.append(value);", "timestamp": 1308684092, "metainfo": ""}