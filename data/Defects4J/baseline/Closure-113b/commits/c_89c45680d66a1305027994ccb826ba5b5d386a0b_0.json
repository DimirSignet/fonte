{"sha": "89c45680d66a1305027994ccb826ba5b5d386a0b", "log": "Peephole optimizations should not be emitting errors. Downgrade them to warnings.  They should be moved to a \"suspicous code\" pass.  R=nicksantos DELTA=63 (7 added, 3 deleted, 53 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=5983   ", "commit": "\n--- a/src/com/google/javascript/jscomp/AbstractPeepholeOptimization.java\n+++ b/src/com/google/javascript/jscomp/AbstractPeepholeOptimization.java\n    * @param diagnostic The error type\n    * @param n The node for which the error should be reported\n    */\n-  protected void error(DiagnosticType diagnostic, Node n) {\n+  protected void report(DiagnosticType diagnostic, Node n) {\n     JSError error =\n         JSError.make(NodeUtil.getSourceName(n), n, diagnostic, n.toString());\n     compiler.report(error);\n--- a/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\n+++ b/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\n  */\n class PeepholeFoldConstants extends AbstractPeepholeOptimization {\n \n+  // TODO(johnlenz): optimizations should not be emiting errors. Move these to\n+  // a check pass.\n   static final DiagnosticType INVALID_GETELEM_INDEX_ERROR =\n-      DiagnosticType.error(\n+      DiagnosticType.warning(\n           \"JSC_INVALID_GETELEM_INDEX_ERROR\",\n           \"Array index not integer: {0}\");\n \n   static final DiagnosticType INDEX_OUT_OF_BOUNDS_ERROR =\n-      DiagnosticType.error(\n+      DiagnosticType.warning(\n           \"JSC_INDEX_OUT_OF_BOUNDS_ERROR\",\n           \"Array index out of bounds: {0}\");\n \n   static final DiagnosticType NEGATING_A_NON_NUMBER_ERROR =\n-      DiagnosticType.error(\n+      DiagnosticType.warning(\n           \"JSC_NEGATING_A_NON_NUMBER_ERROR\",\n           \"Can't negate non-numeric value: {0}\");\n \n   static final DiagnosticType BITWISE_OPERAND_OUT_OF_RANGE =\n-      DiagnosticType.error(\n+      DiagnosticType.warning(\n           \"JSC_BITWISE_OPERAND_OUT_OF_RANGE\",\n           \"Operand out of range, bitwise operation will lose information: {0}\");\n \n-  static final DiagnosticType SHIFT_AMOUNT_OUT_OF_BOUNDS = DiagnosticType.error(\n-      \"JSC_SHIFT_AMOUNT_OUT_OF_BOUNDS\",\n-      \"Shift amount out of bounds: {0}\");\n-\n-  static final DiagnosticType FRACTIONAL_BITWISE_OPERAND = DiagnosticType.error(\n-      \"JSC_FRACTIONAL_BITWISE_OPERAND\",\n-      \"Fractional bitwise operand: {0}\");\n+  static final DiagnosticType SHIFT_AMOUNT_OUT_OF_BOUNDS =\n+      DiagnosticType.warning(\n+          \"JSC_SHIFT_AMOUNT_OUT_OF_BOUNDS\",\n+          \"Shift amount out of bounds: {0}\");\n+\n+  static final DiagnosticType FRACTIONAL_BITWISE_OPERAND =\n+      DiagnosticType.warning(\n+          \"JSC_FRACTIONAL_BITWISE_OPERAND\",\n+          \"Fractional bitwise operand: {0}\");\n \n   private static final double MAX_FOLD_NUMBER = Math.pow(2, 53);\n \n         }\n         return n;\n       case Token.NEG:\n-        try {\n-          if (left.isName()) {\n-            if (left.getString().equals(\"Infinity\")) {\n-              // \"-Infinity\" is valid and a literal, don't modify it.\n-              return n;\n-            } else if (left.getString().equals(\"NaN\")) {\n-              // \"-NaN\" is \"NaN\".\n-              n.removeChild(left);\n-              parent.replaceChild(n, left);\n-              reportCodeChange();\n-              return left;\n-            }\n+        if (left.isName()) {\n+          if (left.getString().equals(\"Infinity\")) {\n+            // \"-Infinity\" is valid and a literal, don't modify it.\n+            return n;\n+          } else if (left.getString().equals(\"NaN\")) {\n+            // \"-NaN\" is \"NaN\".\n+            n.removeChild(left);\n+            parent.replaceChild(n, left);\n+            reportCodeChange();\n+            return left;\n           }\n-\n+        }\n+\n+        if (left.isNumber()) {\n           double negNum = -left.getDouble();\n \n           Node negNumNode = IR.number(negNum);\n           parent.replaceChild(n, negNumNode);\n           reportCodeChange();\n           return negNumNode;\n-        } catch (UnsupportedOperationException ex) {\n+        } else {\n           // left is not a number node, so do not replace, but warn the\n           // user because they can't be doing anything good\n-          error(NEGATING_A_NON_NUMBER_ERROR, left);\n+          report(NEGATING_A_NON_NUMBER_ERROR, left);\n           return n;\n         }\n       case Token.BITNOT:\n               reportCodeChange();\n               return notIntValNode;\n             } else {\n-              error(FRACTIONAL_BITWISE_OPERAND, left);\n+              report(FRACTIONAL_BITWISE_OPERAND, left);\n               return n;\n             }\n           } else {\n-            error(BITWISE_OPERAND_OUT_OF_RANGE, left);\n+            report(BITWISE_OPERAND_OUT_OF_RANGE, left);\n             return n;\n           }\n         } catch (UnsupportedOperationException ex) {\n           // left is not a number node, so do not replace, but warn the\n           // user because they can't be doing anything good\n-          error(NEGATING_A_NON_NUMBER_ERROR, left);\n+          report(NEGATING_A_NON_NUMBER_ERROR, left);\n           return n;\n         }\n         default:\n       // check ranges.  We do not do anything that would clip the double to\n       // a 32-bit range, since the user likely does not intend that.\n       if (!(lval >= Integer.MIN_VALUE && lval <= Integer.MAX_VALUE)) {\n-        error(BITWISE_OPERAND_OUT_OF_RANGE, left);\n+        report(BITWISE_OPERAND_OUT_OF_RANGE, left);\n         return n;\n       }\n \n       // only the lower 5 bits are used when shifting, so don't do anything\n       // if the shift amount is outside [0,32)\n       if (!(rval >= 0 && rval < 32)) {\n-        error(SHIFT_AMOUNT_OUT_OF_BOUNDS, right);\n+        report(SHIFT_AMOUNT_OUT_OF_BOUNDS, right);\n         return n;\n       }\n \n       // Convert the numbers to ints\n       int lvalInt = (int) lval;\n       if (lvalInt != lval) {\n-        error(FRACTIONAL_BITWISE_OPERAND, left);\n+        report(FRACTIONAL_BITWISE_OPERAND, left);\n         return n;\n       }\n \n       int rvalInt = (int) rval;\n       if (rvalInt != rval) {\n-        error(FRACTIONAL_BITWISE_OPERAND, right);\n+        report(FRACTIONAL_BITWISE_OPERAND, right);\n         return n;\n       }\n \n     double index = right.getDouble();\n     int intIndex = (int) index;\n     if (intIndex != index) {\n-      error(INVALID_GETELEM_INDEX_ERROR, right);\n+      report(INVALID_GETELEM_INDEX_ERROR, right);\n       return n;\n     }\n \n     if (intIndex < 0) {\n-      error(INDEX_OUT_OF_BOUNDS_ERROR, right);\n+      report(INDEX_OUT_OF_BOUNDS_ERROR, right);\n       return n;\n     }\n \n     }\n \n     if (elem == null) {\n-      error(INDEX_OUT_OF_BOUNDS_ERROR, right);\n+      report(INDEX_OUT_OF_BOUNDS_ERROR, right);\n       return n;\n     }\n \n--- a/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n+++ b/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n   private final int STRING_SPLIT_OVERHEAD = \".split('.')\".length();\n \n   static final DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS =\n-    DiagnosticType.error(\n+    DiagnosticType.warning(\n         \"JSC_INVALID_REGULAR_EXPRESSION_FLAGS\",\n         \"Invalid flags to RegExp constructor: {0}\");\n \n       } else {\n         // fold to /foobar/gi\n         if (!areValidRegexpFlags(flags.getString())) {\n-          error(INVALID_REGULAR_EXPRESSION_FLAGS, flags);\n+          report(INVALID_REGULAR_EXPRESSION_FLAGS, flags);\n           return n;\n         }\n         if (!areSafeFlagsToFold(flags.getString())) {\n--- a/test/com/google/javascript/jscomp/PeepholeFoldConstantsTest.java\n+++ b/test/com/google/javascript/jscomp/PeepholeFoldConstantsTest.java\n \n   @Override\n   protected int getNumRepetitions() {\n-    // Reduce this to 2 if we get better expression evaluators.\n+    // Reduce this to 1 if we get better expression evaluators.\n     return 2;\n   }\n \n   }\n \n   private void fold(String js, String expected, DiagnosticType warning) {\n-    test(js, expected, warning);\n+    test(js, expected, null, warning);\n   }\n \n   // TODO(user): This is same as fold() except it uses string comparison. Any\n          PeepholeFoldConstants.BITWISE_OPERAND_OUT_OF_RANGE);\n     fold(\"a=~-0x100000000\", \"a=~-0x100000000\",\n          PeepholeFoldConstants.BITWISE_OPERAND_OUT_OF_RANGE);\n-    fold(\"a=~.5\", \"~.5\", PeepholeFoldConstants.FRACTIONAL_BITWISE_OPERAND);\n+    testSame(\"a=~.5\", PeepholeFoldConstants.FRACTIONAL_BITWISE_OPERAND);\n   }\n \n   public void testUnaryOpsStringCompare() {\n     fold(\"x = -1 >>> 0\", \"x = 4294967295\"); // 0xffffffff\n     fold(\"x = -2 >>> 0\", \"x = 4294967294\"); // 0xfffffffe\n \n-    fold(\"3000000000 << 1\", \"3000000000<<1\",\n+    testSame(\"3000000000 << 1\",\n          PeepholeFoldConstants.BITWISE_OPERAND_OUT_OF_RANGE);\n-    fold(\"1 << 32\", \"1<<32\",\n+    testSame(\"1 << 32\",\n         PeepholeFoldConstants.SHIFT_AMOUNT_OUT_OF_BOUNDS);\n-    fold(\"1 << -1\", \"1<<32\",\n+    testSame(\"1 << -1\",\n         PeepholeFoldConstants.SHIFT_AMOUNT_OUT_OF_BOUNDS);\n-    fold(\"3000000000 >> 1\", \"3000000000>>1\",\n+    testSame(\"3000000000 >> 1\",\n         PeepholeFoldConstants.BITWISE_OPERAND_OUT_OF_RANGE);\n-    fold(\"1 >> 32\", \"1>>32\",\n+    testSame(\"1 >> 32\",\n         PeepholeFoldConstants.SHIFT_AMOUNT_OUT_OF_BOUNDS);\n-    fold(\"1.5 << 0\",  \"1.5<<0\",\n+    testSame(\"1.5 << 0\",\n         PeepholeFoldConstants.FRACTIONAL_BITWISE_OPERAND);\n-    fold(\"1 << .5\",   \"1.5<<0\",\n+    testSame(\"1 << .5\",\n         PeepholeFoldConstants.FRACTIONAL_BITWISE_OPERAND);\n-    fold(\"1.5 >>> 0\", \"1.5>>>0\",\n+    testSame(\"1.5 >>> 0\",\n         PeepholeFoldConstants.FRACTIONAL_BITWISE_OPERAND);\n-    fold(\"1 >>> .5\",  \"1.5>>>0\",\n+    testSame(\"1 >>> .5\",\n         PeepholeFoldConstants.FRACTIONAL_BITWISE_OPERAND);\n-    fold(\"1.5 >> 0\",  \"1.5>>0\",\n+    testSame(\"1.5 >> 0\",\n         PeepholeFoldConstants.FRACTIONAL_BITWISE_OPERAND);\n-    fold(\"1 >> .5\",   \"1.5>>0\",\n+    testSame(\"1 >> .5\",\n         PeepholeFoldConstants.FRACTIONAL_BITWISE_OPERAND);\n   }\n \n     fold(\"x = [,10][0]\", \"x = void 0\");\n     fold(\"x = [10, 20][0]\", \"x = 10\");\n     fold(\"x = [10, 20][1]\", \"x = 20\");\n-    fold(\"x = [10, 20][0.5]\", \"\",\n+\n+    testSame(\"x = [10, 20][0.5]\",\n         PeepholeFoldConstants.INVALID_GETELEM_INDEX_ERROR);\n-    fold(\"x = [10, 20][-1]\",    \"\",\n+    testSame(\"x = [10, 20][-1]\",\n         PeepholeFoldConstants.INDEX_OUT_OF_BOUNDS_ERROR);\n-    fold(\"x = [10, 20][2]\",     \"\",\n+    testSame(\"x = [10, 20][2]\",\n         PeepholeFoldConstants.INDEX_OUT_OF_BOUNDS_ERROR);\n \n     foldSame(\"x = [foo(), 0][1]\");\n--- a/test/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntaxTest.java\n+++ b/test/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntaxTest.java\n     fold(\"x = new RegExp(\\\"\\\")\",              \"x = RegExp(\\\"\\\")\");\n     fold(\"x = new RegExp(\\\"\\\", \\\"i\\\")\",       \"x = RegExp(\\\"\\\",\\\"i\\\")\");\n     // Bogus flags should not fold\n-    fold(\"x = new RegExp(\\\"foobar\\\", \\\"bogus\\\")\",\n-         \"x = RegExp(\\\"foobar\\\",\\\"bogus\\\")\",\n+    testSame(\"x = RegExp(\\\"foobar\\\", \\\"bogus\\\")\",\n          PeepholeSubstituteAlternateSyntax.INVALID_REGULAR_EXPRESSION_FLAGS);\n     // Can Fold\n     fold(\"x = new RegExp(\\\"foobar\\\")\",        \"x = /foobar/\");", "timestamp": 1355518398, "metainfo": ""}