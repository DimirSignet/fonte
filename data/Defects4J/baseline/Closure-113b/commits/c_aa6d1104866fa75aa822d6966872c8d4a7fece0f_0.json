{"sha": "aa6d1104866fa75aa822d6966872c8d4a7fece0f", "log": "Add cases for minimizing Token.HOOKs and Token.COMMAs. ------------- Created by MOE: http://code.google.com/p/moe-java MOE_MIGRATED_REVID=46948912", "commit": "\n--- a/src/com/google/javascript/jscomp/PeepholeMinimizeConditions.java\n+++ b/src/com/google/javascript/jscomp/PeepholeMinimizeConditions.java\n             node = new Node(Token.NOT, node).srcref(node);\n             length += estimateCostOneLevel(node);\n             return this;\n-          case Token.NOT:\n-            length -= estimateCostOneLevel(node);\n-            node = node.removeFirstChild();\n-            this.changed = true;\n-            return this;\n           // Otherwise a binary operator with a complement.\n           case Token.EQ:\n             complementOperator = Token.NE;\n         return new MeasuredNode(node.cloneTree(), length, changed);\n       }\n \n-      static MeasuredNode addNode(int opType, Node infoSource,\n-          MeasuredNode l, MeasuredNode r) {\n-        Node newNode = new Node(opType, l.node, r.node).srcref(infoSource);\n-        int newCost = estimateCostOneLevel(newNode) + l.length + r.length;\n-        return new MeasuredNode(newNode, newCost, l.changed || r.changed);\n-      }\n+      static MeasuredNode addNode(Node parent, MeasuredNode... children) {\n+        int cost = 0;\n+        boolean changed = false;\n+        for (MeasuredNode child : children) {\n+          parent.addChildrenToBack(child.node);\n+          cost += child.length;\n+          changed = changed || child.changed;\n+        }\n+        cost += estimateCostOneLevel(parent);\n+        return new MeasuredNode(parent, cost, changed);\n+      }\n+\n     }\n     private final MeasuredNode positive;\n     private final MeasuredNode negative;\n     private MinimizedCondition(MeasuredNode p, MeasuredNode n) {\n       Preconditions.checkArgument(p.node.getParent() == null);\n       Preconditions.checkArgument(n.node.getParent() == null);\n-      Preconditions.checkState(n.changed);\n       positive = p;\n-      negative = n;\n+      negative = n.change();\n     }\n \n     /** Minimize the condition at the given node.\n           ImmutableSet<MeasuredNode> positiveAsts = ImmutableSet.of(\n               subtree.positive.cloneTree().addNot(),\n               subtree.negative.cloneTree());\n-          subtree.positive.changed = true;\n           ImmutableSet<MeasuredNode> negativeAsts = ImmutableSet.of(\n               subtree.negative.negate(),\n-              subtree.positive.change());\n+              subtree.positive);\n           return new MinimizedCondition(\n               Collections.min(positiveAsts, AST_LENGTH_COMPARATOR),\n               Collections.min(negativeAsts, AST_LENGTH_COMPARATOR));\n           MinimizedCondition leftSubtree = fromConditionNode(n.getFirstChild());\n           MinimizedCondition rightSubtree = fromConditionNode(n.getLastChild());\n           ImmutableSet<MeasuredNode> positiveAsts = ImmutableSet.of(\n-              MeasuredNode.addNode(opType, n,\n+              MeasuredNode.addNode(new Node(opType).srcref(n),\n                   leftSubtree.positive.cloneTree(),\n                   rightSubtree.positive.cloneTree()),\n-              MeasuredNode.addNode(complementType, n,\n+              MeasuredNode.addNode(new Node(complementType).srcref(n),\n                   leftSubtree.negative.cloneTree(),\n                   rightSubtree.negative.cloneTree()).negate());\n           ImmutableSet<MeasuredNode> negativeAsts = ImmutableSet.of(\n-              MeasuredNode.addNode(opType, n,\n+              MeasuredNode.addNode(new Node(opType).srcref(n),\n                   leftSubtree.positive,\n                   rightSubtree.positive).negate(),\n-              MeasuredNode.addNode(complementType, n,\n+              MeasuredNode.addNode(new Node(complementType).srcref(n),\n                   leftSubtree.negative,\n                   rightSubtree.negative));\n           return new MinimizedCondition(\n               Collections.min(positiveAsts, AST_LENGTH_COMPARATOR),\n               Collections.min(negativeAsts, AST_LENGTH_COMPARATOR));\n+        }\n+        case Token.HOOK: {\n+          Node cond = n.getFirstChild();\n+          Node thenNode = cond.getNext();\n+          Node elseNode = thenNode.getNext();\n+          MinimizedCondition thenSubtree = fromConditionNode(thenNode);\n+          MinimizedCondition elseSubtree = fromConditionNode(elseNode);\n+          MeasuredNode posTree = MeasuredNode.addNode(\n+              new Node(Token.HOOK, cond.cloneTree()).srcref(n),\n+              thenSubtree.positive,\n+              elseSubtree.positive);\n+          MeasuredNode negTree = MeasuredNode.addNode(\n+              new Node(Token.HOOK, cond.cloneTree()).srcref(n),\n+              thenSubtree.negative,\n+              elseSubtree.negative);\n+          return new MinimizedCondition(posTree, negTree);\n+        }\n+        case Token.COMMA: {\n+          Node lhs = n.getFirstChild();\n+          MinimizedCondition rhsSubtree = fromConditionNode(lhs.getNext());\n+          MeasuredNode posTree = MeasuredNode.addNode(\n+              new Node(Token.COMMA, lhs.cloneTree()).srcref(n),\n+              rhsSubtree.positive);\n+          MeasuredNode negTree = MeasuredNode.addNode(\n+              new Node(Token.COMMA, lhs.cloneTree()).srcref(n),\n+              rhsSubtree.negative);\n+          return new MinimizedCondition(posTree, negTree);\n         }\n         default:\n           return unoptimized(n);\n--- a/test/com/google/javascript/jscomp/PeepholeMinimizeConditionsTest.java\n+++ b/test/com/google/javascript/jscomp/PeepholeMinimizeConditionsTest.java\n     fold(\"while(!(!!x&&y)) foo()\", \"while(!x||!y) foo()\");\n     fold(\"while(x&&!0) foo()\", \"while(x) foo()\");\n     fold(\"while(x||!1) foo()\", \"while(x) foo()\");\n-    fold(\"while(!((x,y)&&z)) foo()\", \"while(!(x,y)||!z) foo()\");\n+    fold(\"while(!((x,y)&&z)) foo()\", \"while((x,!y)||!z) foo()\");\n   }\n \n   public void testMinimizeDemorganRemoveLeadingNot() {\n     foldSame(\"if(!a&&!b)for(;f(););\");\n   }\n \n-  public void testSwapHook() {\n+  public void testMinimizeHook() {\n     fold(\"!x ? foo() : bar()\",\n          \"x ? bar() : foo()\");\n+    fold(\"while(!(x ? y : z)) foo();\",\n+         \"while(x ? !y : !z) foo();\");\n+    fold(\"(x ? !y : !z) ? foo() : bar()\",\n+         \"(x ? y : z) ? bar() : foo()\");\n+  }\n+\n+  public void testMinimizeComma() {\n+    fold(\"while(!(inc(), test())) foo();\",\n+         \"while(inc(), !test()) foo();\");\n+    fold(\"(inc(), !test()) ? foo() : bar()\",\n+         \"(inc(), test()) ? bar() : foo()\");\n   }\n \n   public void testMinimizeExprResult() {", "timestamp": 1369178037, "metainfo": ""}