{"sha": "fabe711b0c888bab57dc2dfc79044f1111d56416", "log": "Move variable redeclaration check from SyntacticScopeCreator to VarCheck. ------------- Created by MOE: http://code.google.com/p/moe-java MOE_MIGRATED_REVID=51577979", "commit": "\n--- a/src/com/google/javascript/jscomp/DiagnosticGroups.java\n+++ b/src/com/google/javascript/jscomp/DiagnosticGroups.java\n   public static final DiagnosticGroup CHECK_VARIABLES =\n       DiagnosticGroups.registerGroup(\"checkVars\",\n           VarCheck.UNDEFINED_VAR_ERROR,\n-          SyntacticScopeCreator.VAR_MULTIPLY_DECLARED_ERROR,\n+          VarCheck.VAR_MULTIPLY_DECLARED_ERROR,\n           VariableReferenceCheck.UNDECLARED_REFERENCE,\n           VariableReferenceCheck.REDECLARED_VARIABLE);\n \n \n   public static final DiagnosticGroup DUPLICATE_VARS =\n       DiagnosticGroups.registerGroup(\"duplicate\",\n-          SyntacticScopeCreator.VAR_MULTIPLY_DECLARED_ERROR,\n+          VarCheck.VAR_MULTIPLY_DECLARED_ERROR,\n           TypeValidator.DUP_VAR_DECLARATION,\n           VariableReferenceCheck.REDECLARED_VARIABLE);\n \n--- a/src/com/google/javascript/jscomp/SyntacticScopeCreator.java\n+++ b/src/com/google/javascript/jscomp/SyntacticScopeCreator.java\n \n import com.google.common.base.Preconditions;\n import com.google.javascript.rhino.InputId;\n-import com.google.javascript.rhino.JSDocInfo;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n \n   // The arguments variable is special, in that it's declared in every local\n   // scope, but not explicitly declared.\n   private static final String ARGUMENTS = \"arguments\";\n-\n-  public static final DiagnosticType VAR_MULTIPLY_DECLARED_ERROR =\n-      DiagnosticType.error(\n-          \"JSC_VAR_MULTIPLY_DECLARED_ERROR\",\n-          \"Variable {0} first declared in {1}\");\n-\n-  public static final DiagnosticType VAR_ARGUMENTS_SHADOWED_ERROR =\n-    DiagnosticType.error(\n-        \"JSC_VAR_ARGUMENTS_SHADOWED_ERROR\",\n-        \"Shadowing \\\"arguments\\\" is not allowed\");\n \n   /**\n    * Creates a ScopeCreator.\n   private class DefaultRedeclarationHandler implements RedeclarationHandler {\n     @Override\n     public void onRedeclaration(\n-        Scope s, String name, Node n, CompilerInput input) {\n-      Node parent = n.getParent();\n-\n-      // Don't allow multiple variables to be declared at the top-level scope\n-      if (scope.isGlobal()) {\n-        Scope.Var origVar = scope.getVar(name);\n-        Node origParent = origVar.getParentNode();\n-        if (origParent.isCatch() &&\n-            parent.isCatch()) {\n-          // Okay, both are 'catch(x)' variables.\n-          return;\n-        }\n-\n-        boolean allowDupe = hasDuplicateDeclarationSuppression(n, origVar);\n-\n-        if (!allowDupe) {\n-          compiler.report(\n-              JSError.make(NodeUtil.getSourceName(n), n,\n-                           VAR_MULTIPLY_DECLARED_ERROR,\n-                           name,\n-                           (origVar.input != null\n-                            ? origVar.input.getName()\n-                            : \"??\")));\n-        }\n-      } else if (name.equals(ARGUMENTS) && !NodeUtil.isVarDeclaration(n)) {\n-        // Disallow shadowing \"arguments\" as we can't handle with our current\n-        // scope modeling.\n-        compiler.report(\n-            JSError.make(NodeUtil.getSourceName(n), n,\n-                VAR_ARGUMENTS_SHADOWED_ERROR));\n-      }\n-    }\n+        Scope s, String name, Node n, CompilerInput input) {}\n   }\n \n   /**\n \n \n   /**\n-   * @param n The name node to check.\n-   * @param origVar The associated Var.\n-   * @return Whether duplicated declarations warnings should be suppressed\n-   *     for the given node.\n-   */\n-  static boolean hasDuplicateDeclarationSuppression(Node n, Scope.Var origVar) {\n-    Preconditions.checkState(n.isName());\n-    Node parent = n.getParent();\n-    Node origParent = origVar.getParentNode();\n-\n-    JSDocInfo info = n.getJSDocInfo();\n-    if (info == null) {\n-      info = parent.getJSDocInfo();\n-    }\n-    if (info != null && info.getSuppressions().contains(\"duplicate\")) {\n-      return true;\n-    }\n-\n-    info = origVar.nameNode.getJSDocInfo();\n-    if (info == null) {\n-      info = origParent.getJSDocInfo();\n-    }\n-    return (info != null && info.getSuppressions().contains(\"duplicate\"));\n-  }\n-\n-  /**\n    * Generates an untyped global scope from the root of AST of compiler (which\n    * includes externs).\n    *\n--- a/src/com/google/javascript/jscomp/VarCheck.java\n+++ b/src/com/google/javascript/jscomp/VarCheck.java\n import com.google.common.collect.Lists;\n import com.google.common.collect.Sets;\n import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n+import com.google.javascript.jscomp.SyntacticScopeCreator.RedeclarationHandler;\n import com.google.javascript.rhino.IR;\n+import com.google.javascript.rhino.JSDocInfo;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n \n       \"JSC_UNDEFINED_EXTERN_VAR_ERROR\",\n       \"name {0} is not undefined in the externs.\");\n \n+  static final DiagnosticType VAR_MULTIPLY_DECLARED_ERROR =\n+      DiagnosticType.error(\n+          \"JSC_VAR_MULTIPLY_DECLARED_ERROR\",\n+          \"Variable {0} first declared in {1}\");\n+\n+  static final DiagnosticType VAR_ARGUMENTS_SHADOWED_ERROR =\n+    DiagnosticType.error(\n+        \"JSC_VAR_ARGUMENTS_SHADOWED_ERROR\",\n+        \"Shadowing \\\"arguments\\\" is not allowed\");\n+\n+  // The arguments variable is special, in that it's declared in every local\n+  // scope, but not explicitly declared.\n+  private static final String ARGUMENTS = \"arguments\";\n+\n   // Vars that still need to be declared in externs. These will be declared\n   // at the end of the pass, or when we see the equivalent var declared\n   // in the normal code.\n     this.sanityCheck = sanityCheck;\n   }\n \n+  /**\n+   * Create a SyntacticScopeCreator. If not in sanity check mode, use a\n+   * {@link RedeclarationCheckHandler} to check var redeclarations.\n+   * @return the SyntacticScopeCreator\n+   */\n+  private ScopeCreator createScopeCreator() {\n+    if (sanityCheck) {\n+      return new SyntacticScopeCreator(compiler);\n+    } else {\n+      return new SyntacticScopeCreator(\n+          compiler, new RedeclarationCheckHandler());\n+    }\n+  }\n+\n   @Override\n   public void process(Node externs, Node root) {\n+    ScopeCreator scopeCreator = createScopeCreator();\n     // Don't run externs-checking in sanity check mode. Normalization will\n     // remove duplicate VAR declarations, which will make\n     // externs look like they have assigns.\n     if (!sanityCheck) {\n-      NodeTraversal.traverse(compiler, externs, new NameRefInExternsCheck());\n-    }\n-\n-    NodeTraversal.traverseRoots(\n-        compiler, Lists.newArrayList(externs, root), this);\n+      NodeTraversal traversal = new NodeTraversal(\n+          compiler, new NameRefInExternsCheck(), scopeCreator);\n+      traversal.traverse(externs);\n+    }\n+\n+    NodeTraversal t = new NodeTraversal(compiler, this, scopeCreator);\n+    t.traverseRoots(Lists.newArrayList(externs, root));\n     for (String varName : varsToDeclareInExterns) {\n       createSynthesizedExternVar(varName);\n     }\n   @Override\n   public void hotSwapScript(Node scriptRoot, Node originalRoot) {\n     Preconditions.checkState(scriptRoot.isScript());\n-    NodeTraversal t = new NodeTraversal(compiler, this);\n+    ScopeCreator scopeCreator = createScopeCreator();\n+    NodeTraversal t = new NodeTraversal(compiler, this, scopeCreator);\n     // Note we use the global scope to prevent wrong \"undefined-var errors\" on\n     // variables that are defined in other JS files.\n-    t.traverseWithScope(scriptRoot,\n-        SyntacticScopeCreator.generateUntypedTopScope(compiler));\n+    Scope topScope = scopeCreator.createScope(compiler.getRoot(), null);\n+    t.traverseWithScope(scriptRoot, topScope);\n     // TODO(bashir) Check if we need to createSynthesizedExternVar like process.\n   }\n \n       if (NodeUtil.isFunctionExpression(parent)) {\n         // e.g. [ function foo() {} ], it's okay if \"foo\" isn't defined in the\n         // current scope.\n-      } else {\n+      } else if (!(scope.isLocal() && ARGUMENTS.equals(varName))) {\n         // The extern checks are stricter, don't report a second error.\n         if (!strictExternCheck || !t.getInput().isExtern()) {\n           t.report(n, UNDEFINED_VAR_ERROR, varName);\n     }\n   }\n \n+\n+  /**\n+   * @param n The name node to check.\n+   * @param origVar The associated Var.\n+   * @return Whether duplicated declarations warnings should be suppressed\n+   *     for the given node.\n+   */\n+  static boolean hasDuplicateDeclarationSuppression(Node n, Scope.Var origVar) {\n+    Preconditions.checkState(n.isName());\n+    Node parent = n.getParent();\n+    Node origParent = origVar.getParentNode();\n+\n+    JSDocInfo info = n.getJSDocInfo();\n+    if (info == null) {\n+      info = parent.getJSDocInfo();\n+    }\n+    if (info != null && info.getSuppressions().contains(\"duplicate\")) {\n+      return true;\n+    }\n+\n+    info = origVar.nameNode.getJSDocInfo();\n+    if (info == null) {\n+      info = origParent.getJSDocInfo();\n+    }\n+    return (info != null && info.getSuppressions().contains(\"duplicate\"));\n+  }\n+\n+  /**\n+   * The handler for duplicate declarations.\n+   */\n+  private class RedeclarationCheckHandler implements RedeclarationHandler {\n+    @Override\n+    public void onRedeclaration(\n+        Scope s, String name, Node n, CompilerInput input) {\n+      Node parent = n.getParent();\n+\n+      // Don't allow multiple variables to be declared at the top-level scope\n+      if (s.isGlobal()) {\n+        Scope.Var origVar = s.getVar(name);\n+        Node origParent = origVar.getParentNode();\n+        if (origParent.isCatch() &&\n+            parent.isCatch()) {\n+          // Okay, both are 'catch(x)' variables.\n+          return;\n+        }\n+\n+        boolean allowDupe = hasDuplicateDeclarationSuppression(n, origVar);\n+\n+        if (!allowDupe) {\n+          compiler.report(\n+              JSError.make(NodeUtil.getSourceName(n), n,\n+                           VAR_MULTIPLY_DECLARED_ERROR,\n+                           name,\n+                           (origVar.input != null\n+                            ? origVar.input.getName()\n+                            : \"??\")));\n+        }\n+      } else if (name.equals(ARGUMENTS) && !NodeUtil.isVarDeclaration(n)) {\n+        // Disallow shadowing \"arguments\" as we can't handle with our current\n+        // scope modeling.\n+        compiler.report(\n+            JSError.make(NodeUtil.getSourceName(n), n,\n+                VAR_ARGUMENTS_SHADOWED_ERROR));\n+      }\n+    }\n+  }\n+\n   /** Lazily create a \"new\" externs root for undeclared variables. */\n   private Node getSynthesizedExternsRoot() {\n     return  compiler.getSynthesizedExternsInput().getAstRoot(compiler);\n--- a/src/com/google/javascript/jscomp/VariableReferenceCheck.java\n+++ b/src/com/google/javascript/jscomp/VariableReferenceCheck.java\n         boolean isDeclaration = reference.isDeclaration();\n \n         boolean allowDupe =\n-            SyntacticScopeCreator.hasDuplicateDeclarationSuppression(\n+            VarCheck.hasDuplicateDeclarationSuppression(\n                 reference.getNode(), v);\n         if (isDeclaration && !allowDupe) {\n           // Look through all the declarations we've found so far, and\n             // Special case to deal with var goog = goog || {}\n             Node grandparent = reference.getGrandparent();\n             if (grandparent.isName()\n-                && grandparent.getString() == v.name) {\n+                && grandparent.getString().equals(v.name)) {\n               continue;\n             }\n \n--- a/test/com/google/javascript/jscomp/CollapsePropertiesTest.java\n+++ b/test/com/google/javascript/jscomp/CollapsePropertiesTest.java\n   }\n \n   public void testObjLitDeclarationWithDuplicateKeys() {\n+    disableNormalize();\n     test(\"var a = {b: 0, b: 1}; var c = a.b;\",\n-         \"var a$b = 0; var a$b = 1; var c = a$b;\",\n-         SyntacticScopeCreator.VAR_MULTIPLY_DECLARED_ERROR);\n+         \"var a$b = 0; var a$b = 1; var c = a$b;\");\n   }\n \n   public void testObjLitAssignmentDepth1() {\n--- a/test/com/google/javascript/jscomp/CommandLineRunnerTest.java\n+++ b/test/com/google/javascript/jscomp/CommandLineRunnerTest.java\n   public void testCheckSymbolsOnForVerbose() {\n     args.add(\"--warning_level=VERBOSE\");\n     test(\"x = 3;\", VarCheck.UNDEFINED_VAR_ERROR);\n-    test(\"var y; var y;\", SyntacticScopeCreator.VAR_MULTIPLY_DECLARED_ERROR);\n+    test(\"var y; var y;\", VarCheck.VAR_MULTIPLY_DECLARED_ERROR);\n   }\n \n   public void testCheckSymbolsOverrideForVerbose() {\n     args.add(\"--jscomp_off=externsValidation\");\n     args.add(\"--warning_level=VERBOSE\");\n     test(\"var theirVar = {}; var myVar = {}; var myVar = {};\",\n-         SyntacticScopeCreator.VAR_MULTIPLY_DECLARED_ERROR);\n+         VarCheck.VAR_MULTIPLY_DECLARED_ERROR);\n   }\n \n   public void testGoogAssertStripping() {\n--- a/test/com/google/javascript/jscomp/NormalizeTest.java\n+++ b/test/com/google/javascript/jscomp/NormalizeTest.java\n     // TODO(johnlenz): Do we need to handle this differently for \"third_party\"\n     // mode? Remove the previous function definitions?\n     test(\"function f(){} function f(){}\",\n-         \"function f(){} function f(){}\",\n-         SyntacticScopeCreator.VAR_MULTIPLY_DECLARED_ERROR);\n+         \"function f(){} function f(){}\");\n     test(\"if (a) { function f(){} } else { function f(){} }\",\n          \"if (a) { var f = function (){} } else { f = function (){} }\");\n   }\n--- a/test/com/google/javascript/jscomp/ProcessDefinesTest.java\n+++ b/test/com/google/javascript/jscomp/ProcessDefinesTest.java\n \n package com.google.javascript.jscomp;\n \n-import static com.google.javascript.jscomp.SyntacticScopeCreator.VAR_MULTIPLY_DECLARED_ERROR;\n-\n import com.google.common.collect.Maps;\n import com.google.javascript.jscomp.GlobalNamespace.Name;\n import com.google.javascript.rhino.Node;\n         \"var DEF=true;var x;x=true\");\n   }\n \n-  public void testDuplicateVar() {\n-    test(\"/** @define {boolean} */ var DEF = false; var DEF = true;\",\n-         null, VAR_MULTIPLY_DECLARED_ERROR);\n-  }\n-\n   public void testAssignBeforeDeclaration1() {\n     test(\"DEF=false;var b=false,/** @define {boolean} */DEF=true,c=false\",\n          null, ProcessDefines.INVALID_DEFINE_INIT_ERROR);\n--- a/test/com/google/javascript/jscomp/SyntacticScopeCreatorTest.java\n+++ b/test/com/google/javascript/jscomp/SyntacticScopeCreatorTest.java\n     return scope;\n   }\n \n-  /**\n-   * Helper to traverse the tree creating the Scope object everywhere.\n-   */\n-  private static void testScopes(String js, int errorCount) {\n-    Compiler compiler = new Compiler();\n-    Node root = compiler.parseTestCode(js);\n-    NodeTraversal.traverse(\n-        compiler, root, new NodeTraversal.AbstractPostOrderCallback() {\n-          @Override\n-          public\n-          void visit(NodeTraversal t, Node n, Node parent) {\n-            t.getScope();\n-          }\n-        });\n-    assertEquals(errorCount, compiler.getErrorCount());\n-  }\n-\n   public void testFunctionScope() {\n     Scope scope = getScope(\"function foo() {}\\n\" +\n                            \"var x = function bar(a1) {};\" +\n     assertEquals(fooNode, fooScope.getRootNode());\n     assertTrue(fooScope.isDeclared(\"x\", false));\n   }\n-\n-  public void testRedeclaration1() {\n-     String js = \"var a; var a;\";\n-     int errors = createGlobalScopeHelper(js);\n-     assertEquals(1, errors);\n-  }\n-\n-  public void testRedeclaration2() {\n-    String js = \"var a; /** @suppress {duplicate} */ var a;\";\n-    int errors = createGlobalScopeHelper(js);\n-    assertEquals(0, errors);\n-  }\n-\n-  public void testRedeclaration3() {\n-    String js = \" /** @suppress {duplicate} */ var a; var a; \";\n-    int errors = createGlobalScopeHelper(js);\n-    assertEquals(0, errors);\n-  }\n-\n-\n-  public void testFunctionScopeArguments() {\n-    // A var declaration doesn't mask arguments\n-    testScopes(\"function f() {var arguments}\", 0);\n-\n-    testScopes(\"var f = function arguments() {}\", 1);\n-    testScopes(\"var f = function (arguments) {}\", 1);\n-    testScopes(\"function f() {try {} catch(arguments) {}}\", 1);\n-  }\n-\n-  /**\n-   * Parse the supplied JS and create the global SyntaticScope object.\n-   * @return The error count.\n-   */\n-  private int createGlobalScopeHelper(String js) {\n-    Compiler compiler = new Compiler();\n-    CompilerOptions options = new CompilerOptions();\n-    options.checkSymbols = true;\n-    compiler.initOptions(options);\n-\n-    Node root = compiler.parseTestCode(js);\n-    assertEquals(0, compiler.getErrorCount());\n-    Scope globalScope =\n-      new SyntacticScopeCreator(compiler).createScope(root, null);\n-    assertEquals(root, globalScope.getRootNode());\n-    return compiler.getErrorCount();\n-  }\n }\n--- a/test/com/google/javascript/jscomp/VarCheckTest.java\n+++ b/test/com/google/javascript/jscomp/VarCheckTest.java\n \n package com.google.javascript.jscomp;\n \n+import static com.google.javascript.jscomp.VarCheck.VAR_MULTIPLY_DECLARED_ERROR;\n+\n import com.google.common.collect.Lists;\n import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n import com.google.javascript.rhino.Node;\n \n   public void testMultiplyDeclaredVars1() {\n     test(\"var x = 1; var x = 2;\", null,\n-         SyntacticScopeCreator.VAR_MULTIPLY_DECLARED_ERROR);\n+        VarCheck.VAR_MULTIPLY_DECLARED_ERROR);\n   }\n \n   public void testMultiplyDeclaredVars2() {\n \n   public void testMultiplyDeclaredVars3() {\n     test(\"try { var x = 1; x *=2; } catch (x) {}\", null,\n-         SyntacticScopeCreator.VAR_MULTIPLY_DECLARED_ERROR);\n+         VarCheck.VAR_MULTIPLY_DECLARED_ERROR);\n   }\n \n   public void testMultiplyDeclaredVars4() {\n     testSame(\"x;\", \"var x = 1; var x = 2;\",\n-         SyntacticScopeCreator.VAR_MULTIPLY_DECLARED_ERROR, true);\n+        VarCheck.VAR_MULTIPLY_DECLARED_ERROR, true);\n   }\n \n   public void testVarReferenceInExterns() {\n   public void testVariableInNormalCodeUsedInExterns4() {\n     checkSynthesizedExtern(\n         \"x;\", \"function x() {}\", \"var x; x; \");\n+  }\n+\n+  public void testRedeclaration1() {\n+     String js = \"var a; var a;\";\n+     test(js, null, VarCheck.VAR_MULTIPLY_DECLARED_ERROR);\n+  }\n+\n+  public void testRedeclaration2() {\n+    String js = \"var a; /** @suppress {duplicate} */ var a;\";\n+    testSame(js);\n+  }\n+\n+  public void testRedeclaration3() {\n+    String js = \" /** @suppress {duplicate} */ var a; var a; \";\n+    testSame(js);\n+  }\n+\n+  public void testDuplicateVar() {\n+    test(\"/** @define {boolean} */ var DEF = false; var DEF = true;\",\n+         null, VAR_MULTIPLY_DECLARED_ERROR);\n+  }\n+\n+  public void testFunctionScopeArguments() {\n+    // A var declaration doesn't mask arguments\n+    testSame(\"function f() {var arguments}\");\n+\n+    test(\"var f = function arguments() {}\",\n+        null, VarCheck.VAR_ARGUMENTS_SHADOWED_ERROR);\n+    test(\"var f = function (arguments) {}\",\n+        null, VarCheck.VAR_ARGUMENTS_SHADOWED_ERROR);\n+    test(\"function f() {try {} catch(arguments) {}}\",\n+        null, VarCheck.VAR_ARGUMENTS_SHADOWED_ERROR);\n   }\n \n   private final static class VariableTestCheck implements CompilerPass {", "timestamp": 1377822233, "metainfo": ""}