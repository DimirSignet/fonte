{"sha": "1f5edbcd2b5b09ec59151137e643d9ce75ef1055", "log": "Fix assorted type system bugs and crashes. Fixes issue 124 for reals. (nick) R=andrew DELTA=161  (122 added, 9 deleted, 30 changed)  Revision created by MOE tool push_codebase. MOE_MIGRATION=   ", "commit": "\n--- a/src/com/google/javascript/jscomp/ChainableReverseAbstractInterpreter.java\n+++ b/src/com/google/javascript/jscomp/ChainableReverseAbstractInterpreter.java\n         break;\n \n       default:\n-        throw new IllegalArgumentException(\"Node cannot be refined.\");\n+        throw new IllegalArgumentException(\"Node cannot be refined. \\n\" +\n+            node.toStringTree());\n     }\n   }\n \n \n     @Override\n     protected JSType caseTopType(JSType topType) {\n+      JSType result = topType;\n       if (resultEqualsValue) {\n-        if (value.equals(\"number\")) {\n-          return getNativeType(NUMBER_TYPE);\n-        } else if (value.equals(\"boolean\")) {\n-          return getNativeType(BOOLEAN_TYPE);\n-        } else if (value.equals(\"string\")) {\n-          return getNativeType(STRING_TYPE);\n-        } else if (value.equals(\"undefined\")) {\n-          return getNativeType(VOID_TYPE);\n-        } else if (value.equals(\"function\")) {\n-          return getNativeType(U2U_CONSTRUCTOR_TYPE);\n-        }\n-      }\n-      return topType;\n+        JSType typeByName = getNativeTypeForTypeOf(value);\n+        if (typeByName != null) {\n+          result = typeByName;\n+        }\n+      }\n+      return result;\n     }\n \n     public JSType caseNoObjectType() {\n \n   /**\n    * Returns a version of {@code type} that is restricted by some knowledge\n-   * about the result of the {@code typeof} operation..\n+   * about the result of the {@code typeof} operation.\n    * <p>\n    * The behavior of the {@code typeof} operator can be summarized by the\n    * following table:\n    */\n   JSType getRestrictedByTypeOfResult(JSType type, String value,\n                                      boolean resultEqualsValue) {\n-    return type == null ? null :\n-        type.visit(new RestrictByOneTypeOfResultVisitor(\n-            value, resultEqualsValue));\n+    if (type == null) {\n+      if (resultEqualsValue) {\n+        JSType result = getNativeTypeForTypeOf(value);\n+        return result == null ? getNativeType(UNKNOWN_TYPE) : result;\n+      } else {\n+        return null;\n+      }\n+    }\n+    return type.visit(\n+        new RestrictByOneTypeOfResultVisitor(value, resultEqualsValue));\n   }\n \n   JSType getNativeType(JSTypeNative typeId) {\n     return typeRegistry.getNativeType(typeId);\n   }\n+\n+  /**\n+   * If we definitely know what a type is based on the typeof result,\n+   * return it.  Otherwise, return null.\n+   *\n+   * The typeof operation in JS is poorly defined, and this function works\n+   * for both the native typeof and goog.typeOf. It should not be made public,\n+   * because its semantics are informally defined, and would be wrong in\n+   * the general case.\n+   */\n+  private JSType getNativeTypeForTypeOf(String value) {\n+    if (value.equals(\"number\")) {\n+      return getNativeType(NUMBER_TYPE);\n+    } else if (value.equals(\"boolean\")) {\n+      return getNativeType(BOOLEAN_TYPE);\n+    } else if (value.equals(\"string\")) {\n+      return getNativeType(STRING_TYPE);\n+    } else if (value.equals(\"undefined\")) {\n+      return getNativeType(VOID_TYPE);\n+    } else if (value.equals(\"function\")) {\n+      return getNativeType(U2U_CONSTRUCTOR_TYPE);\n+    } else {\n+      return null;\n+    }\n+  }\n }\n--- a/src/com/google/javascript/jscomp/ClosureReverseAbstractInterpreter.java\n+++ b/src/com/google/javascript/jscomp/ClosureReverseAbstractInterpreter.java\n import static com.google.javascript.rhino.jstype.JSTypeNative.ARRAY_TYPE;\n import static com.google.javascript.rhino.jstype.JSTypeNative.NO_OBJECT_TYPE;\n import static com.google.javascript.rhino.jstype.JSTypeNative.NULL_TYPE;\n+import static com.google.javascript.rhino.jstype.JSTypeNative.OBJECT_TYPE;\n \n import com.google.common.base.Function;\n import com.google.common.collect.ImmutableMap;\n       })\n       .put(\"isArray\", new Function<TypeRestriction, JSType>() {\n         public JSType apply(TypeRestriction p) {\n+          if (p.type == null) {\n+            return p.outcome ? getNativeType(ARRAY_TYPE) : null;\n+          }\n+\n           Visitor<JSType> visitor = p.outcome ? restrictToArrayVisitor :\n               restrictToNotArrayVisitor;\n-          return p.type == null ? null : p.type.visit(visitor);\n+          return p.type.visit(visitor);\n         }\n       })\n       .put(\"isObject\", new Function<TypeRestriction, JSType>() {\n         public JSType apply(TypeRestriction p) {\n+          if (p.type == null) {\n+            return p.outcome ? getNativeType(OBJECT_TYPE) : null;\n+          }\n+\n           Visitor<JSType> visitor = p.outcome ? restrictToObjectVisitor :\n               restrictToNotObjectVisitor;\n-          return p.type == null ? null : p.type.visit(visitor);\n+          return p.type.visit(visitor);\n         }\n       })\n       .build();\n   }\n \n+  @Override\n   public FlowScope getPreciserScopeKnowingConditionOutcome(Node condition,\n       FlowScope blindScope, boolean outcome) {\n     if (condition.getType() == CALL && condition.getChildCount() == 2) {\n       Node callee = condition.getFirstChild();\n       Node param = condition.getLastChild();\n-      if (callee.getType() == GETPROP) {\n+      if (callee.getType() == GETPROP && param.isQualifiedName()) {\n         JSType paramType =  getTypeIfRefinable(param, blindScope);\n-        if (paramType != null) {\n-          Node left = callee.getFirstChild();\n-          Node right = callee.getLastChild();\n-          if (left.getType() == NAME && \"goog\".equals(left.getString()) &&\n-              right.getType() == STRING) {\n-            Function<TypeRestriction, JSType> restricter =\n-                restricters.get(right.getString());\n-            if (restricter != null) {\n-              return restrictParameter(param, paramType, blindScope, restricter,\n-                  outcome);\n-            }\n+        Node left = callee.getFirstChild();\n+        Node right = callee.getLastChild();\n+        if (left.getType() == NAME && \"goog\".equals(left.getString()) &&\n+            right.getType() == STRING) {\n+          Function<TypeRestriction, JSType> restricter =\n+              restricters.get(right.getString());\n+          if (restricter != null) {\n+            return restrictParameter(param, paramType, blindScope, restricter,\n+                outcome);\n           }\n         }\n       }\n--- a/src/com/google/javascript/jscomp/TypeInference.java\n+++ b/src/com/google/javascript/jscomp/TypeInference.java\n     if (value != null) {\n       scope = traverse(value, scope);\n       updateScopeForTypeChange(scope, n, n.getJSType() /* could be null */,\n-         getJSType(value));\n+          getJSType(value));\n       return scope;\n     } else {\n       StaticSlot<JSType> var = scope.getSlot(varName);\n-      if (var != null &&\n-          !(var.isTypeInferred() && unflowableVarNames.contains(varName))) {\n-        type = var.getType();\n-        if (type == null) {\n-          type = getNativeType(UNKNOWN_TYPE);\n+      if (var != null) {\n+        // There are two situations where we don't want to use type information\n+        // from the scope, even if we have it.\n+\n+        // 1) The var is escaped in a weird way, e.g.,\n+        // function f() { var x = 3; function g() { x = null } (x); }\n+        boolean isInferred = var.isTypeInferred();\n+        boolean unflowable =\n+            isInferred && unflowableVarNames.contains(varName);\n+\n+        // 2) We're reading type information from another scope for an\n+        // inferred variable.\n+        // var t = null; function f() { (t); }\n+        boolean nonLocalInferredSlot =\n+            isInferred &&\n+            syntacticScope.getParent() != null &&\n+            var == syntacticScope.getParent().getSlot(varName);\n+\n+        if (!unflowable && !nonLocalInferredSlot) {\n+          type = var.getType();\n+          if (type == null) {\n+            type = getNativeType(UNKNOWN_TYPE);\n+          }\n         }\n       }\n     }\n--- a/test/com/google/javascript/jscomp/ClosureReverseAbstractInterpreterTest.java\n+++ b/test/com/google/javascript/jscomp/ClosureReverseAbstractInterpreterTest.java\n         OBJECT_TYPE);\n   }\n \n+  public void testGoogIsArrayOnNull() throws Exception {\n+    testClosureFunction(\"goog.isArray\",\n+        null,\n+        ARRAY_TYPE,\n+        null);\n+  }\n+\n+  public void testGoogIsFunctionOnNull() throws Exception {\n+    testClosureFunction(\"goog.isFunction\",\n+        null,\n+        U2U_CONSTRUCTOR_TYPE,\n+        null);\n+  }\n+\n+  public void testGoogIsObjectOnNull() throws Exception {\n+    testClosureFunction(\"goog.isObject\",\n+        null,\n+        OBJECT_TYPE,\n+        null);\n+  }\n+\n   private void testClosureFunction(String function, JSType type,\n       JSType trueType, JSType falseType) {\n     // function(a) where a : type\n--- a/test/com/google/javascript/jscomp/TypeCheckTest.java\n+++ b/test/com/google/javascript/jscomp/TypeCheckTest.java\n         \"function f(x) { return goog.isObject(x) ? x : []; }\", null);\n   }\n \n+  public void testTypeOfReduction14() throws Exception {\n+    // Don't do type inference on GETELEMs.\n+    testClosureTypes(\n+        CLOSURE_DEFS +\n+        \"function f(arguments) { \" +\n+        \"  return goog.isString(arguments[0]) ? arguments[0] : 0;\" +\n+        \"}\", null);\n+  }\n+\n+  public void testTypeOfReduction15() throws Exception {\n+    // Don't do type inference on GETELEMs.\n+    testClosureTypes(\n+        CLOSURE_DEFS +\n+        \"function f(arguments) { \" +\n+        \"  return typeof arguments[0] == 'string' ? arguments[0] : 0;\" +\n+        \"}\", null);\n+  }\n+\n   public void testQualifiedNameReduction1() throws Exception {\n     testTypes(\"var x = {}; /** @type {string?} */ x.a = 'a';\\n\" +\n         \"/** @return {string} */ var f = function() {\\n\" +\n     testTypes(\n         \"/** @constructor */ var Foo = function() {};\" +\n         \"/** @type {number} */ Foo.prototype.bar = 3;\" +\n-        \"var FooAlias = Foo;\" +\n+        \"/** @constructor */ var FooAlias = Foo;\" +\n         \"/** @return {string} */ function foo() { \" +\n         \"  return (new FooAlias()).bar; }\",\n         \"inconsistent return type\\n\" +\n         \"inconsistent return type\\n\" +\n         \"found   : boolean\\n\" +\n         \"required: number\");\n+  }\n+\n+  public void testIssue124() throws Exception {\n+    testTypes(\n+        \"var t = null;\" +\n+        \"function test() {\" +\n+        \"  if (t != null) { t = null; }\" +\n+        \"  t = 1;\" +\n+        \"}\");\n+  }\n+\n+  public void testIssue124b() throws Exception {\n+    testTypes(\n+        \"var t = null;\" +\n+        \"function test() {\" +\n+        \"  if (t != null) { t = null; }\" +\n+        \"  t = undefined;\" +\n+        \"}\",\n+        \"condition always evaluates to false\\n\" +\n+        \"left : (null|undefined)\\n\" +\n+        \"right: null\");\n   }\n \n   /**", "timestamp": 1268953643, "metainfo": ""}