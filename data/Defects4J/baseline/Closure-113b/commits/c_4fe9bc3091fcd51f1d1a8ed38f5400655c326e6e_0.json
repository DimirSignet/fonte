{"sha": "4fe9bc3091fcd51f1d1a8ed38f5400655c326e6e", "log": "Merge remote-tracking branch 'GoogleCode/master'", "commit": "\n--- a/src/com/google/javascript/jscomp/AngularPass.java\n+++ b/src/com/google/javascript/jscomp/AngularPass.java\n               dependenciesArray\n           )\n       );\n-      // adds `something.$inject = [...]` node after the annotated node.\n-      Node target = entry.getTarget();\n-      target.getParent().addChildAfter(statement, target);\n+      // adds `something.$inject = [...]` node after the annotated node or the following\n+      // goog.inherits call.\n+      Node insertionPoint = entry.getTarget();\n+      Node next = insertionPoint.getNext();\n+      while (next != null &&\n+             NodeUtil.isExprCall(next) &&\n+             convention.getClassesDefinedByCall(\n+                 next.getFirstChild()) != null) {\n+        insertionPoint = next;\n+        next = insertionPoint.getNext();\n+      }\n+\n+      insertionPoint.getParent().addChildAfter(statement, insertionPoint);\n       codeChanged = true;\n     }\n     if (codeChanged) {\n--- a/src/com/google/javascript/jscomp/CheckRequiresForConstructors.java\n+++ b/src/com/google/javascript/jscomp/CheckRequiresForConstructors.java\n \n package com.google.javascript.jscomp;\n \n-import com.google.common.base.Preconditions;\n import com.google.common.collect.Lists;\n import com.google.common.collect.Sets;\n-import com.google.javascript.jscomp.CheckLevel;\n import com.google.javascript.jscomp.NodeTraversal.Callback;\n import com.google.javascript.rhino.JSDocInfo;\n+import com.google.javascript.rhino.JSTypeExpression;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n+import com.google.javascript.rhino.jstype.JSType;\n \n import java.util.List;\n import java.util.Set;\n \n     @Override\n     public void visit(NodeTraversal t, Node n, Node parent) {\n-      JSDocInfo info;\n       switch (n.getType()) {\n         case Token.ASSIGN:\n-          info = (JSDocInfo) n.getProp(Node.JSDOC_INFO_PROP);\n-          if (info != null && info.isConstructor()) {\n-            String qualifiedName = n.getFirstChild().getQualifiedName();\n-            constructors.add(qualifiedName);\n-          }\n+        case Token.VAR:\n+          maybeAddConstructor(t, n);\n           break;\n         case Token.FUNCTION:\n-          if (NodeUtil.isFunctionExpression(n)) {\n-            if (parent.isName()) {\n-              String functionName = parent.getString();\n-              info = (JSDocInfo) parent.getProp(Node.JSDOC_INFO_PROP);\n-              if (info != null && info.isConstructor()) {\n-                constructors.add(functionName);\n-              } else {\n-                Node gramps = parent.getParent();\n-                Preconditions.checkState(\n-                    gramps != null && gramps.isVar());\n-                info = (JSDocInfo) gramps.getProp(Node.JSDOC_INFO_PROP);\n-                if (info != null && info.isConstructor()) {\n-                  constructors.add(functionName);\n-                }\n-              }\n-            }\n-          } else {\n-            info = (JSDocInfo) n.getProp(Node.JSDOC_INFO_PROP);\n-            if (info != null && info.isConstructor()) {\n-              String functionName = n.getFirstChild().getString();\n-              constructors.add(functionName);\n-            }\n+          // Exclude function expressions.\n+          if (NodeUtil.isStatement(n)) {\n+            maybeAddConstructor(t, n);\n           }\n           break;\n         case Token.CALL:\n       }\n       newNodes.add(n);\n     }\n+\n+    private void maybeAddConstructor(NodeTraversal t, Node n) {\n+      JSDocInfo info = (JSDocInfo) n.getProp(Node.JSDOC_INFO_PROP);\n+      if (info != null) {\n+        String ctorName = n.getFirstChild().getQualifiedName();\n+        if (info.isConstructor()) {\n+          constructors.add(ctorName);\n+        } else {\n+          JSTypeExpression typeExpr = info.getType();\n+          if (typeExpr != null) {\n+            JSType type = typeExpr.evaluate(t.getScope(), compiler.getTypeRegistry());\n+            if (type.isConstructor()) {\n+              constructors.add(ctorName);\n+            }\n+          }\n+        }\n+      }\n+    }\n   }\n }\n--- a/src/com/google/javascript/jscomp/DataFlowAnalysis.java\n+++ b/src/com/google/javascript/jscomp/DataFlowAnalysis.java\n \n   /*\n    * Feel free to increase this to a reasonable number if you are finding that\n-   * more and more passes need more than 200000 steps before finding a\n+   * more and more passes need more than 400000 steps before finding a\n    * fixed-point. If you just have a special case, consider calling\n    * {@link #analyse(int)} instead.\n    */\n-  public static final int MAX_STEPS = 200000;\n+  public static final int MAX_STEPS = 400000;\n \n   /**\n    * Constructs a data flow analysis.\n--- a/src/com/google/javascript/jscomp/NodeUtil.java\n+++ b/src/com/google/javascript/jscomp/NodeUtil.java\n   }\n \n   /**\n+   * Creates a node representing a qualified name.\n+   *\n+   * @param name A qualified name (e.g. \"foo\" or \"foo.bar.baz\")\n+   * @return A NAME or GETPROP node\n+   */\n+  public static Node newQualifiedNameNodeDeclaration(\n+      CodingConvention convention, String name, Node value, JSDocInfo info) {\n+    Node result;\n+    Node nameNode = newQualifiedNameNode(convention, name);\n+    if (nameNode.isName()) {\n+      result = IR.var(nameNode, value);\n+      result.setJSDocInfo(info);\n+    } else {\n+      result = IR.exprResult(IR.assign(nameNode, value));\n+      result.getFirstChild().setJSDocInfo(info);\n+    }\n+    return result;\n+  }\n+\n+  /**\n    * Creates a node representing a qualified name, copying over the source\n    * location information from the basis node and assigning the given original\n    * name to the node.\n--- a/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\n+++ b/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\n \n   static final DiagnosticType INVALID_PROVIDE_ERROR = DiagnosticType.error(\n       \"JSC_INVALID_PROVIDE_ERROR\",\n-      \"\\\"{0}\\\" is not a valid JS property name\");\n+      \"\\\"{0}\\\" is not a valid JS identifier name\");\n+\n+  static final DiagnosticType INVALID_DEFINE_NAME_ERROR = DiagnosticType.error(\n+      \"JSC_INVALID_DEFINE_NAME_ERROR\",\n+      \"\\\"{0}\\\" is not a valid JS identifier name\");\n+\n+  static final DiagnosticType MISSING_DEFINE_ANNOTATION = DiagnosticType.error(\n+      \"JSC_INVALID_MISSING_DEFINE_ANNOTATION\",\n+      \"Missing @define annotation\");\n \n   static final DiagnosticType XMODULE_REQUIRE_ERROR = DiagnosticType.warning(\n       \"JSC_XMODULE_REQUIRE_ERROR\",\n   private final Set<String> exportedVariables = Sets.newHashSet();\n   private final CheckLevel requiresLevel;\n   private final PreprocessorSymbolTable preprocessorSymbolTable;\n+  private final List<Node> defineCalls = Lists.newArrayList();\n \n   ProcessClosurePrimitives(AbstractCompiler compiler,\n       @Nullable PreprocessorSymbolTable preprocessorSymbolTable,\n   @Override\n   public void process(Node externs, Node root) {\n     new NodeTraversal(compiler, this).traverse(root);\n+\n+    for (Node n : defineCalls) {\n+      replaceGoogDefines(n);\n+    }\n \n     for (ProvidedName pn : providedNames.values()) {\n       pn.replace();\n             r.inputName, r.requireNode, requiresLevel, error, r.namespace));\n       }\n     }\n+  }\n+\n+  /**\n+   * @param n\n+   */\n+  private void replaceGoogDefines(Node n) {\n+    Node parent = n.getParent();\n+    Preconditions.checkState(parent.isExprResult());\n+    String name = n.getChildAtIndex(1).getString();\n+    Node value = n.getChildAtIndex(2).detachFromParent();\n+\n+    Node replacement = NodeUtil.newQualifiedNameNodeDeclaration(\n+        compiler.getCodingConvention(), name, value, n.getJSDocInfo());\n+    replacement.useSourceInfoIfMissingFromForTree(n);\n+    parent.getParent().replaceChild(parent, replacement);\n+    compiler.reportCodeChange();\n   }\n \n   @Override\n             } else if (!isExpr) {\n               // All other methods must be called in an EXPR.\n               break;\n+            } else if (\"define\".equals(methodName)) {\n+              processDefineCall(t, n, parent);\n             } else if (\"require\".equals(methodName)) {\n               processRequireCall(t, n, parent);\n             } else if (\"provide\".equals(methodName)) {\n   private void processRequireCall(NodeTraversal t, Node n, Node parent) {\n     Node left = n.getFirstChild();\n     Node arg = left.getNext();\n-    if (verifyArgument(t, left, arg)) {\n+    if (verifyLastArgumentIsString(t, left, arg)) {\n       String ns = arg.getString();\n       ProvidedName provided = providedNames.get(ns);\n       if (provided == null || !provided.isExplicitlyProvided()) {\n         providedNames.put(\n             ns, new ProvidedName(ns, parent, t.getModule(), true));\n       }\n+    }\n+  }\n+\n+    /**\n+   * Handles a goog.define call.\n+   */\n+  private void processDefineCall(NodeTraversal t, Node n, Node parent) {\n+    Node left = n.getFirstChild();\n+    Node args = left.getNext();\n+    if (verifyDefine(t, parent, left, args)) {\n+      Node nameNode = args;\n+      String name = args.getString();\n+      Node value = args.getNext();\n+\n+      maybeAddToSymbolTable(left);\n+      maybeAddStringNodeToSymbolTable(nameNode);\n+\n+      this.defineCalls.add(n);\n     }\n   }\n \n    * @return Whether the argument checked out okay\n    */\n   private boolean verifyProvide(NodeTraversal t, Node methodName, Node arg) {\n-    if (!verifyArgument(t, methodName, arg)) {\n+    if (!verifyLastArgumentIsString(t, methodName, arg)) {\n       return false;\n     }\n \n   }\n \n   /**\n+   * Verifies that a provide method call has exactly one argument,\n+   * and that it's a string literal and that the contents of the string are\n+   * valid JS tokens. Reports a compile error if it doesn't.\n+   *\n+   * @return Whether the argument checked out okay\n+   */\n+  private boolean verifyDefine(NodeTraversal t,\n+      Node expr,\n+      Node methodName, Node args) {\n+\n+    // Verify first arg\n+    Node arg = args;\n+    if (!verifyNotNull(t, methodName, arg) ||\n+        !verifyOfType(t, methodName, arg, Token.STRING)) {\n+      return false;\n+    }\n+\n+    // Verify second arg\n+    arg = arg.getNext();\n+    if (!verifyNotNull(t, methodName, arg) ||\n+        !verifyIsLast(t, methodName, arg)) {\n+      return false;\n+    }\n+\n+    String name = args.getString();\n+    for (String part : name.split(\"\\\\.\")) {\n+      if (!NodeUtil.isValidQualifiedName(part)) {\n+        compiler.report(t.makeError(args, INVALID_DEFINE_NAME_ERROR, name));\n+        return false;\n+      }\n+    }\n+\n+    JSDocInfo info = expr.getFirstChild().getJSDocInfo();\n+    if (info == null || !info.isDefine()) {\n+      compiler.report(t.makeError(expr, MISSING_DEFINE_ANNOTATION));\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  /**\n    * Verifies that a method call has exactly one argument, and that it's a\n    * string literal. Reports a compile error if it doesn't.\n    *\n    * @return Whether the argument checked out okay\n    */\n-  private boolean verifyArgument(NodeTraversal t, Node methodName, Node arg) {\n-    return verifyArgument(t, methodName, arg, Token.STRING);\n-  }\n-\n-  /**\n-   * Verifies that a method call has exactly one argument, and that it is of the\n-   * desired type. Reports a compile error if it doesn't.\n-   *\n+  private boolean verifyLastArgumentIsString(\n+      NodeTraversal t, Node methodName, Node arg) {\n+    return verifyNotNull(t, methodName, arg) &&\n+        verifyOfType(t, methodName, arg, Token.STRING) &&\n+        verifyIsLast(t, methodName, arg);\n+  }\n+\n+  /**\n    * @return Whether the argument checked out okay\n    */\n-  private boolean verifyArgument(NodeTraversal t, Node methodName, Node arg,\n-      int desiredType) {\n-    DiagnosticType diagnostic = null;\n+  private boolean verifyNotNull(NodeTraversal t, Node methodName, Node arg) {\n     if (arg == null) {\n-      diagnostic = NULL_ARGUMENT_ERROR;\n-    } else if (arg.getType() != desiredType) {\n-      diagnostic = INVALID_ARGUMENT_ERROR;\n-    } else if (arg.getNext() != null) {\n-      diagnostic = TOO_MANY_ARGUMENTS_ERROR;\n-    }\n-    if (diagnostic != null) {\n       compiler.report(\n           t.makeError(methodName,\n-              diagnostic, methodName.getQualifiedName()));\n+              NULL_ARGUMENT_ERROR, methodName.getQualifiedName()));\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  /**\n+   * @return Whether the argument checked out okay\n+   */\n+  private boolean verifyOfType(NodeTraversal t, Node methodName,\n+      Node arg, int desiredType) {\n+    if (arg.getType() != desiredType) {\n+      compiler.report(\n+          t.makeError(methodName,\n+              INVALID_ARGUMENT_ERROR, methodName.getQualifiedName()));\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  /**\n+   * @return Whether the argument checked out okay\n+   */\n+  private boolean verifyIsLast(NodeTraversal t, Node methodName, Node arg) {\n+    if (arg.getNext() != null) {\n+      compiler.report(\n+          t.makeError(methodName,\n+              TOO_MANY_ARGUMENTS_ERROR, methodName.getQualifiedName()));\n       return false;\n     }\n     return true;\n--- a/src/com/google/javascript/jscomp/SymbolTable.java\n+++ b/src/com/google/javascript/jscomp/SymbolTable.java\n \n     public void visitTypeNode(SymbolScope scope, Node n) {\n       if (n.isString()) {\n-        Symbol symbol = scope.getSlot(n.getString());\n-        if (symbol == null) {\n-          // If we can't find this type, it might be a reference to a\n-          // primitive type (like {string}). Autobox it to check.\n-          JSType type = typeRegistry.getType(n.getString());\n-          JSType autobox = type == null ? null : type.autoboxesTo();\n-          symbol = autobox == null\n-              ? null : getSymbolForTypeHelper(autobox, true);\n-        }\n+        Symbol symbol = lookupPossiblyDottedName(scope, n.getString());\n         if (symbol != null) {\n           symbol.defineReferenceAt(n);\n+        } else {\n+          logger.warning(\"Could not find symbol for type: \" + n.getString());\n         }\n       }\n \n            child != null; child = child.getNext()) {\n         visitTypeNode(scope, child);\n       }\n+    }\n+\n+    // TODO(peterhal): @template types.\n+    private Symbol lookupPossiblyDottedName(SymbolScope scope, String dottedName) {\n+      // Try the dotted name to start.\n+      String[] names = dottedName.split(\"\\\\.\");\n+      Symbol result = null;\n+      SymbolScope currentScope = scope;\n+      for (int i = 0; i < names.length; i++) {\n+        String name = names[i];\n+        result = currentScope.getSlot(name);\n+        if (result == null) {\n+          break;\n+        }\n+        if (i < (names.length - 1)) {\n+          currentScope = result.getPropertyScope();\n+          if (currentScope == null) {\n+            result = null;\n+            break;\n+          }\n+        }\n+      }\n+\n+      if (result == null) {\n+        // If we can't find this type, it might be a reference to a\n+        // primitive type (like {string}). Autobox it to check.\n+        JSType type = typeRegistry.getType(dottedName);\n+        JSType autobox = type == null ? null : type.autoboxesTo();\n+        result = autobox == null\n+            ? null : getSymbolForTypeHelper(autobox, true);\n+      }\n+      return result;\n     }\n   }\n \n--- a/src/com/google/javascript/jscomp/parsing/IRFactory.java\n+++ b/src/com/google/javascript/jscomp/parsing/IRFactory.java\n         case com.google.javascript.rhino.head.Token.GETPROP:\n         case com.google.javascript.rhino.head.Token.GETELEM:\n           valid = isExprStmt(node.getParent());\n+          break;\n+\n+        case com.google.javascript.rhino.head.Token.CALL:\n+          valid = info.isDefine();\n           break;\n       }\n       if (!valid) {\n--- a/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\n+++ b/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\n                   parser.addParserWarning(\"msg.jsdoc.define\",\n                       lineno, charno);\n                 }\n-                break;\n+                return recordDescription(token);\n \n               case PRIVATE:\n                 if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {\n                       \"msg.jsdoc.visibility.private\",\n                       lineno, charno);\n                 }\n-                break;\n+                return recordDescription(token);\n \n               case PROTECTED:\n                 if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {\n                       \"msg.jsdoc.visibility.protected\",\n                       lineno, charno);\n                 }\n-                break;\n+                return recordDescription(token);\n \n               case PUBLIC:\n                 if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {\n                       \"msg.jsdoc.visibility.public\",\n                       lineno, charno);\n                 }\n-                break;\n+                return recordDescription(token);\n \n               case RETURN:\n                 if (type == null) {\n     }\n \n     return next();\n+  }\n+\n+  /**\n+   * Records a marker's description if there is one available and record it in\n+   * the current marker.\n+   */\n+  private JsDocToken recordDescription(JsDocToken token) {\n+    // Find marker's description (if applicable).\n+    if (jsdocBuilder.shouldParseDocumentation()) {\n+      ExtractionInfo descriptionInfo = extractMultilineTextualBlock(token);\n+      token = descriptionInfo.token;\n+    } else {\n+      token = eatTokensUntilEOL(token);\n+    }\n+    return token;\n   }\n \n   private void checkExtendedTypes(List<ExtendedTypeInfo> extendedTypes) {\n--- a/test/com/google/javascript/jscomp/AngularPassTest.java\n+++ b/test/com/google/javascript/jscomp/AngularPassTest.java\n     );\n   }\n \n+  public void testNgInjectAddsInjectAfterGoogInherits() throws Exception {\n+    test(\n+         \"/** @ngInject \\n @constructor */\" +\n+         \"function fn(a, b) {}\" +\n+         \"goog.inherits(fn, parent);\",\n+\n+         \"function fn(a, b) {}\\n\" +\n+         \"goog.inherits(fn, parent);\" +\n+         \"fn['$inject']=['a', 'b']\"\n+         );\n+\n+    test(\n+         \"/** @ngInject \\n @constructor */\" +\n+         \"function fn(a, b) {}\" +\n+         \"goog.inherits(fn, parent);\" +\n+         \"var foo = 42;\",\n+\n+         \"function fn(a, b) {}\\n\" +\n+         \"goog.inherits(fn, parent);\" +\n+         \"fn['$inject']=['a', 'b'];\" +\n+         \"var foo = 42;\"\n+         );\n+  }\n+\n   public void testNgInjectAddsInjectToProps() throws Exception {\n     test(\n         \"var ns = {};\\n\" +\n--- a/test/com/google/javascript/jscomp/CheckRequiresForConstructorsTest.java\n+++ b/test/com/google/javascript/jscomp/CheckRequiresForConstructorsTest.java\n import static com.google.javascript.jscomp.CheckRequiresForConstructors.MISSING_REQUIRE_WARNING;\n \n import com.google.common.collect.ImmutableList;\n-import com.google.javascript.jscomp.CheckLevel;\n-import com.google.javascript.jscomp.Result;\n \n /**\n  * Tests for {@link CheckRequiresForConstructors}.\n     String warning = \"'goog.Forgot' used but not goog.require'd\";\n     test(js, js, null, MISSING_REQUIRE_WARNING, warning);\n   }\n+\n+  public void testVarConstructorName() {\n+    String js = \"/** @type {function(new:Date)} */var bar = Date;\" +\n+        \"new bar();\";\n+    testSame(js);\n+  }\n+\n+  public void testVarConstructorFunction() {\n+    String js = \"/** @type {function(new:Date)} */var bar = function() {};\" +\n+        \"new bar();\";\n+    testSame(js);\n+  }\n+\n+  public void testAssignConstructorName() {\n+    String js = \"var foo = {};\" +\n+        \"/** @type {function(new:Date)} */foo.bar = Date;\" +\n+        \"new foo.bar();\";\n+    testSame(js);\n+  }\n+\n+  public void testAssignConstructorFunction() {\n+    String js = \"var foo = {};\" +\n+        \"/** @type {function(new:Date)} */foo.bar = function() {};\" +\n+        \"new foo.bar();\";\n+    testSame(js);\n+  }\n+\n+  public void testConstructorFunctionReference() {\n+    String js = \"/** @type {function(new:Date)} */function bar() {}\" +\n+        \"new bar();\";\n+    testSame(js);\n+  }\n }\n--- a/test/com/google/javascript/jscomp/IntegrationTest.java\n+++ b/test/com/google/javascript/jscomp/IntegrationTest.java\n     options.closurePass = true;\n     options.collapseProperties = true;\n     test(options, code, CLOSURE_COMPILED + \" var x$bar = 3;\");\n+  }\n+\n+  public void testGoogDefine1() {\n+    String code = CLOSURE_BOILERPLATE +\n+        \"/** @define {boolean} */ goog.define('FLAG', true);\";\n+\n+    CompilerOptions options = createCompilerOptions();\n+\n+    options.closurePass = true;\n+    options.collapseProperties = true;\n+    options.setDefineToBooleanLiteral(\"FLAG\", false);\n+\n+    test(options, code, CLOSURE_COMPILED + \" var FLAG = false;\");\n+  }\n+\n+  public void testGoogDefine2() {\n+    String code = CLOSURE_BOILERPLATE +\n+        \"goog.provide('ns');\" +\n+        \"/** @define {boolean} */ goog.define('ns.FLAG', true);\";\n+\n+    CompilerOptions options = createCompilerOptions();\n+\n+    options.closurePass = true;\n+    options.collapseProperties = true;\n+    options.setDefineToBooleanLiteral(\"ns.FLAG\", false);\n+    test(options, code, CLOSURE_COMPILED + \"var ns$FLAG = false;\");\n   }\n \n   public void testCollapseProperties1() {\n--- a/test/com/google/javascript/jscomp/ProcessClosurePrimitivesTest.java\n+++ b/test/com/google/javascript/jscomp/ProcessClosurePrimitivesTest.java\n \n package com.google.javascript.jscomp;\n \n-import com.google.javascript.rhino.Node;\n-import com.google.javascript.jscomp.CheckLevel;\n import static com.google.javascript.jscomp.ProcessClosurePrimitives.BASE_CLASS_ERROR;\n import static com.google.javascript.jscomp.ProcessClosurePrimitives.DUPLICATE_NAMESPACE_ERROR;\n import static com.google.javascript.jscomp.ProcessClosurePrimitives.EXPECTED_OBJECTLIT_ERROR;\n import static com.google.javascript.jscomp.ProcessClosurePrimitives.FUNCTION_NAMESPACE_ERROR;\n import static com.google.javascript.jscomp.ProcessClosurePrimitives.INVALID_ARGUMENT_ERROR;\n+import static com.google.javascript.jscomp.ProcessClosurePrimitives.INVALID_CSS_RENAMING_MAP;\n+import static com.google.javascript.jscomp.ProcessClosurePrimitives.INVALID_DEFINE_NAME_ERROR;\n import static com.google.javascript.jscomp.ProcessClosurePrimitives.INVALID_PROVIDE_ERROR;\n import static com.google.javascript.jscomp.ProcessClosurePrimitives.INVALID_STYLE_ERROR;\n import static com.google.javascript.jscomp.ProcessClosurePrimitives.LATE_PROVIDE_ERROR;\n+import static com.google.javascript.jscomp.ProcessClosurePrimitives.MISSING_DEFINE_ANNOTATION;\n import static com.google.javascript.jscomp.ProcessClosurePrimitives.MISSING_PROVIDE_ERROR;\n import static com.google.javascript.jscomp.ProcessClosurePrimitives.NON_STRING_PASSED_TO_SET_CSS_NAME_MAPPING_ERROR;\n import static com.google.javascript.jscomp.ProcessClosurePrimitives.NULL_ARGUMENT_ERROR;\n import static com.google.javascript.jscomp.ProcessClosurePrimitives.TOO_MANY_ARGUMENTS_ERROR;\n import static com.google.javascript.jscomp.ProcessClosurePrimitives.XMODULE_REQUIRE_ERROR;\n-import static com.google.javascript.jscomp.ProcessClosurePrimitives.INVALID_CSS_RENAMING_MAP;\n+\n+import com.google.javascript.rhino.Node;\n \n /**\n  * Tests for {@link ProcessClosurePrimitives}.\n   public void testProvideRequireSameFile() {\n     test(\"goog.provide('x');\\ngoog.require('x');\", \"var x = {};\");\n   }\n+\n+  public void testDefineCases() {\n+    String jsdoc = \"/** @define {number} */\\n\";\n+    test(jsdoc + \"goog.define('name', 1);\", jsdoc + \"var name = 1\");\n+    test(jsdoc + \"goog.define('ns.name', 1);\", jsdoc + \"ns.name = 1\");\n+  }\n+\n+  public void testDefineErrorCases() {\n+    String jsdoc = \"/** @define {number} */\\n\";\n+    test(\"goog.define('name', 1);\", \"\", MISSING_DEFINE_ANNOTATION);\n+    test(jsdoc + \"goog.define('name.2', 1);\", \"\", INVALID_DEFINE_NAME_ERROR);\n+    test(jsdoc + \"goog.define();\", \"\", NULL_ARGUMENT_ERROR);\n+    test(jsdoc + \"goog.define('value');\", \"\", NULL_ARGUMENT_ERROR);\n+    test(jsdoc + \"goog.define(5);\", \"\", INVALID_ARGUMENT_ERROR);\n+  }\n }\n--- a/test/com/google/javascript/jscomp/SymbolTableTest.java\n+++ b/test/com/google/javascript/jscomp/SymbolTableTest.java\n         assertEquals(\"in1\", ref.getNode().getSourceFileName());\n       }\n     }\n+  }\n+\n+  public void testDottedReferencesInJSDocType() {\n+    SymbolTable table = createSymbolTable(\n+        \"var goog = {};\\n\" +\n+        \"/** @constructor */ goog.Foo = function() {}\\n\" +\n+        \"/** @type {goog.Foo} */ var x;\\n\" +\n+        \"/** @param {goog.Foo} x */ function f(x) {}\\n\" +\n+        \"/** @return {function(): goog.Foo} */ function g() {}\\n\" +\n+        \"/**\\n\" +\n+        \" * @constructor\\n\" +\n+        \" * @extends {goog.Foo}\\n\" +\n+        \" */ function Sub() {}\");\n+    Symbol foo = getGlobalVar(table, \"goog.Foo\");\n+    assertNotNull(foo);\n+\n+    List<Reference> refs = table.getReferenceList(foo);\n+    assertEquals(5, refs.size());\n+\n+    assertEquals(2, refs.get(0).getNode().getLineno());\n+    assertEquals(20, refs.get(0).getNode().getCharno());\n+    assertEquals(8, refs.get(0).getNode().getLength());\n+\n+    assertEquals(3, refs.get(1).getNode().getLineno());\n+    assertEquals(11, refs.get(1).getNode().getCharno());\n+\n+    assertEquals(4, refs.get(2).getNode().getLineno());\n+    assertEquals(12, refs.get(2).getNode().getCharno());\n+\n+    assertEquals(5, refs.get(3).getNode().getLineno());\n+    assertEquals(25, refs.get(3).getNode().getCharno());\n+\n+    assertEquals(8, refs.get(4).getNode().getLineno());\n+    assertEquals(13, refs.get(4).getNode().getCharno());\n   }\n \n   public void testReferencesInJSDocName() {\n--- a/test/com/google/javascript/jscomp/parsing/JsDocInfoParserTest.java\n+++ b/test/com/google/javascript/jscomp/parsing/JsDocInfoParserTest.java\n import com.google.javascript.jscomp.testing.TestErrorReporter;\n import com.google.javascript.rhino.InputId;\n import com.google.javascript.rhino.JSDocInfo;\n+import com.google.javascript.rhino.JSDocInfo.Marker;\n import com.google.javascript.rhino.JSDocInfo.Visibility;\n import com.google.javascript.rhino.JSTypeExpression;\n import com.google.javascript.rhino.Node;\n   public void testParseDefine5() throws Exception {\n     assertTypeEquals(createUnionType(NUMBER_TYPE, BOOLEAN_TYPE),\n         parse(\"@define {number|boolean}*/\").getType());\n+  }\n+\n+  public void testParseDefineDescription() throws Exception {\n+    JSDocInfo doc = parse(\n+        \"@define {string} description of element \\n next line*/\", true);\n+    Marker defineMarker = doc.getMarkers().iterator().next();\n+    assertEquals(\"define\", defineMarker.getAnnotation().getItem());\n+    assertTrue(defineMarker.getDescription().getItem().contains(\"description of element\"));\n+    assertTrue(defineMarker.getDescription().getItem().contains(\"next line\"));\n+  }\n+\n+  public void testParsePrivateDescription() throws Exception {\n+    JSDocInfo doc =\n+        parse(\"@private {string} description \\n next line*/\", true);\n+    Marker defineMarker = doc.getMarkers().iterator().next();\n+    assertEquals(\"private\", defineMarker.getAnnotation().getItem());\n+    assertTrue(defineMarker.getDescription().getItem().contains(\"description \"));\n+    assertTrue(defineMarker.getDescription().getItem().contains(\"next line\"));\n+  }\n+\n+  public void testParseProtectedDescription() throws Exception {\n+    JSDocInfo doc =\n+        parse(\"@protected {string} description \\n next line*/\", true);\n+    Marker defineMarker = doc.getMarkers().iterator().next();\n+    assertEquals(\"protected\", defineMarker.getAnnotation().getItem());\n+    assertTrue(defineMarker.getDescription().getItem().contains(\"description \"));\n+    assertTrue(defineMarker.getDescription().getItem().contains(\"next line\"));\n   }\n \n   public void testParseDefineErrors1() throws Exception {", "timestamp": 1363636739, "metainfo": ""}