{"sha": "441d31de49d1ccfec562a7287b1ff4451c9815e4", "log": "Fixed the problem of generating top scope before closure pass.  R=nicksantos DELTA=63  (33 added, 12 deleted, 18 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=1839   ", "commit": "\n--- a/src/com/google/javascript/jscomp/AbstractCompiler.java\n+++ b/src/com/google/javascript/jscomp/AbstractCompiler.java\n    */\n   abstract void process(CompilerPass pass);\n \n+  /**\n+   * Returns the root node of the AST, which includes both externs and source.\n+   */\n+  abstract Node getRoot();\n }\n--- a/src/com/google/javascript/jscomp/CheckAccessControls.java\n+++ b/src/com/google/javascript/jscomp/CheckAccessControls.java\n   }\n \n   @Override\n-  public void hotSwapScript(Node scriptRoot, Scope globalScope) {\n+  public void hotSwapScript(Node scriptRoot) {\n     NodeTraversal.traverse(compiler, scriptRoot, this);\n   }\n \n--- a/src/com/google/javascript/jscomp/Compiler.java\n+++ b/src/com/google/javascript/jscomp/Compiler.java\n     return errorManager.getWarnings();\n   }\n \n-  /**\n-   * Returns the root node of the AST, which includes both externs and source.\n-   */\n+  @Override\n   public Node getRoot() {\n     return externAndJsRoot;\n   }\n--- a/src/com/google/javascript/jscomp/DefaultPassConfig.java\n+++ b/src/com/google/javascript/jscomp/DefaultPassConfig.java\n           exportedNames = pass.getExportedVariableNames();\n         }\n         @Override\n-        public void hotSwapScript(Node scriptRoot, Scope globalScope) {\n-          pass.hotSwapScript(scriptRoot, globalScope);\n+        public void hotSwapScript(Node scriptRoot) {\n+          pass.hotSwapScript(scriptRoot);\n         }\n       };\n     }\n   };\n \n   /** Creates a typed scope and adds types to the type registry. */\n-  final PassFactory resolveTypes =\n-      new PassFactory(\"resolveTypes\", false) {\n-    @Override\n-    protected CompilerPass createInternal(AbstractCompiler compiler) {\n+  final HotSwapPassFactory resolveTypes =\n+      new HotSwapPassFactory(\"resolveTypes\", false) {\n+    @Override\n+    protected HotSwapCompilerPass createInternal(AbstractCompiler compiler) {\n       return new GlobalTypeResolver(compiler);\n     }\n   };\n           makeTypeInference(compiler).process(externs, root);\n         }\n         @Override\n-        public void hotSwapScript(Node scriptRoot, Scope globalScope) {\n+        public void hotSwapScript(Node scriptRoot) {\n           // TODO(bashir): Extra warnings about undefined types are reported\n           // when doing inferTypes from scriptRoot. One solution is to do\n           // inferTypes from the AST root instead of scriptRoot but that\n           compiler.getErrorManager().setTypedPercent(check.getTypedPercent());\n         }\n         @Override\n-        public void hotSwapScript(Node scriptRoot, Scope globalScope) {\n+        public void hotSwapScript(Node scriptRoot) {\n           makeTypeCheck(compiler).check(scriptRoot, false);\n         }\n       };\n   }\n \n   /** A compiler pass that resolves types in the global scope. */\n-  private class GlobalTypeResolver implements CompilerPass {\n+  private class GlobalTypeResolver implements HotSwapCompilerPass {\n     private final AbstractCompiler compiler;\n \n     GlobalTypeResolver(AbstractCompiler compiler) {\n       } else {\n         compiler.getTypeRegistry().resolveTypesInScope(topScope);\n       }\n+    }\n+    @Override\n+    public void hotSwapScript(Node scriptRoot) {\n+      // We have to rebuild the global scope.\n+      // If this is not fast enough, we'll need to change the interface\n+      // of ScopeCreator so that it can patch new variables into an existing\n+      // scope (right now it can only create new scopes).\n+      regenerateGlobalTypedScope(compiler, compiler.getRoot());\n     }\n   }\n \n--- a/src/com/google/javascript/jscomp/HotSwapCompilerPass.java\n+++ b/src/com/google/javascript/jscomp/HotSwapCompilerPass.java\n  *\n  * <p>It is assumed that {@code Node} argument of {@code hotSwapScript} is the\n  * root of a sub-tree in AST that represents a js file and so is of type\n- * {@code Token.SCRIPT}. Also the global-scope is supposed to be updated based\n- * on new js file prior to this call.\n+ * {@code Token.SCRIPT}.\n  *\n  * @author bashir@google.com (Bashir Sadjad)\n  */\n    * faster compared to corresponding full-compiler passes.\n    * @param scriptRoot Root node corresponding to the file that is modified,\n    *     should be of type {@code Token.SCRIPT}.\n-   * @param globalScope The global scope which is not necessarily types.\n    */\n-  void hotSwapScript(Node scriptRoot, Scope globalScope);\n+  void hotSwapScript(Node scriptRoot);\n \n }\n--- a/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\n+++ b/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\n   }\n \n   @Override\n-  public void hotSwapScript(Node scriptRoot, Scope globalScope) {\n+  public void hotSwapScript(Node scriptRoot) {\n     // TODO(bashir): Implement a real hot-swap version instead and make it fully\n     // consistent with the full version.\n     this.compiler.process(this);\n--- a/src/com/google/javascript/jscomp/VarCheck.java\n+++ b/src/com/google/javascript/jscomp/VarCheck.java\n   }\n \n   @Override\n-  public void hotSwapScript(Node scriptRoot, Scope globalScope) {\n+  public void hotSwapScript(Node scriptRoot) {\n     Preconditions.checkState(scriptRoot.getType() == Token.SCRIPT);\n     NodeTraversal t = new NodeTraversal(compiler, this);\n     // Note we use the global scope to prevent wrong \"undefined-var errors\" on\n     // variables that are defined in other js files.\n-    t.traverseWithScope(scriptRoot, globalScope);\n+    //\n+    // TODO(bashir) Currently VarCheck is the only pass that its hotSwapScript\n+    // needs a global scope and cannot use global typed scope. If other passes\n+    // in future need a similar top scope we have to refactor the next scope\n+    // generation and generate such global scope only once.\n+    Scope scope = new SyntacticScopeCreator(compiler).createScope(\n+        compiler.getRoot(), null);\n+    t.traverseWithScope(scriptRoot, scope);\n     // TODO(bashir) Check if we need to createSynthesizedExternVar like process.\n   }\n ", "timestamp": 1305131994, "metainfo": ""}