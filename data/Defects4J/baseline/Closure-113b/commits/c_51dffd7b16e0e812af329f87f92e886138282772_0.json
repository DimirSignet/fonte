{"sha": "51dffd7b16e0e812af329f87f92e886138282772", "log": "Add support for String.split to peephole optimizations.  R=acleung,johnlenz  ", "commit": "\n--- a/src/com/google/javascript/jscomp/DefaultPassConfig.java\n+++ b/src/com/google/javascript/jscomp/DefaultPassConfig.java\n       final boolean late = false;\n       return new PeepholeOptimizationsPass(compiler,\n             new PeepholeSubstituteAlternateSyntax(late),\n-            new PeepholeReplaceKnownMethods(),\n+            new PeepholeReplaceKnownMethods(late),\n             new PeepholeRemoveDeadCode(),\n             new PeepholeFoldConstants(late),\n             new PeepholeCollectPropertyAssignments());\n             new StatementFusion(),\n             new PeepholeRemoveDeadCode(),\n             new PeepholeSubstituteAlternateSyntax(late),\n-            new PeepholeReplaceKnownMethods(),\n+            new PeepholeReplaceKnownMethods(late),\n             new PeepholeFoldConstants(late),\n             new ReorderConstantExpression());\n     }\n--- a/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java\n+++ b/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java\n import com.google.javascript.rhino.Node;\n import java.util.List;\n import java.util.Locale;\n+import java.util.regex.Pattern;\n \n /**\n  * Just to fold known methods when they are called with constants.\n \n   // The LOCALE independent \"locale\"\n   private static final Locale ROOT_LOCALE = new Locale(\"\");\n-\n+  private final boolean late;\n+\n+  /**\n+   * @param late When late is true, this mean we are currently running after\n+   * most of the other optimizations. In this case we avoid changes that make\n+   * the code larger (but otherwise easier to analyze - such as using string\n+   * splitting).\n+   */\n+  PeepholeReplaceKnownMethods(boolean late) {\n+    this.late = late;\n+  }\n+  \n   @Override\n   Node optimizeSubtree(Node subtree) {\n     if (subtree.isCall() ){\n \n     String functionNameString = functionName.getString();\n     Node firstArg = callTarget.getNext();\n-    if (firstArg == null) {\n+    if (functionNameString.equals(\"split\")) {\n+      subtree = tryFoldStringSplit(subtree, stringNode, firstArg);\n+    } else if (firstArg == null) {\n       if (functionNameString.equals(\"toLowerCase\")) {\n         subtree = tryFoldStringToLowerCase(subtree, stringNode);\n       } else if (functionNameString.equals(\"toUpperCase\")) {\n     reportCodeChange();\n     return resultNode;\n   }\n+  \n+  /**\n+   * Try to fold .split() calls on strings\n+   */\n+  private Node tryFoldStringSplit(Node n, Node stringNode, Node arg1) {\n+    if (late) {\n+      return n;\n+    }\n+    \n+    Preconditions.checkArgument(n.isCall());\n+    Preconditions.checkArgument(stringNode.isString());\n+\n+    String separator = null;\n+    String stringValue = stringNode.getString();\n+    int limit = stringValue.length();\n+\n+    if (arg1 != null) {\n+      if (arg1.isString()) {\n+        separator = arg1.getString();\n+      } else if (!arg1.isNull()) {\n+        return n;\n+      }\n+      \n+      Node arg2 = arg1.getNext();\n+      if (arg2 != null) {\n+        if (arg2.isNumber()) {\n+          limit = (int) arg2.getDouble();\n+          if (limit < 0) {\n+            return n;\n+          }\n+        } else {\n+          return n;\n+        }\n+      }\n+    }\n+    \n+    String[] stringArray;\n+    if (separator != null) {\n+      stringArray = stringValue.split(Pattern.quote(separator));\n+    } else {\n+      stringArray = new String[1];\n+      stringArray[0] = stringValue;\n+    }\n+    \n+    Node arrayOfStrings = IR.arraylit();\n+    for (int i = 0; i < limit && i < stringArray.length; i++) {\n+      arrayOfStrings.addChildToBack(\n+          IR.string(stringArray[i]).srcref(stringNode));\n+    }\n+    \n+    Node parent = n.getParent();\n+    parent.replaceChild(n, arrayOfStrings);\n+    reportCodeChange();\n+    return arrayOfStrings;\n+ }\n }\n--- a/test/com/google/javascript/jscomp/PeepholeReplaceKnownMethodsTest.java\n+++ b/test/com/google/javascript/jscomp/PeepholeReplaceKnownMethodsTest.java\n  */\n public class PeepholeReplaceKnownMethodsTest extends CompilerTestCase {\n \n+  private boolean late = true;\n+  \n   public PeepholeReplaceKnownMethodsTest() {\n     super(\"\");\n   }\n   @Override\n   public CompilerPass getProcessor(final Compiler compiler) {\n     CompilerPass peepholePass = new PeepholeOptimizationsPass(compiler,\n-          new PeepholeReplaceKnownMethods());\n+          new PeepholeReplaceKnownMethods(late));\n     return peepholePass;\n   }\n \n     fold(\"x = '\\\\ud834\\udd1e'.charCodeAt(0)\", \"x = 55348\");\n     fold(\"x = '\\\\ud834\\udd1e'.charCodeAt(1)\", \"x = 56606\");\n   }\n+  \n+  public void testFoldStringSplit() {\n+    late = false;\n+    fold(\"x = 'abcde'.split()\", \"x = ['abcde']\");\n+    fold(\"x = 'abcde'.split(null)\", \"x = ['abcde']\");\n+    fold(\"x = 'a b c d e'.split(' ')\", \"x = ['a','b','c','d','e']\");\n+    fold(\"x = 'a b c d e'.split(' ', 0)\", \"x = []\");\n+    fold(\"x = 'abcde'.split('cd')\", \"x = ['ab','e']\");\n+    fold(\"x = 'a b c d e'.split(' ', 1)\", \"x = ['a']\");\n+    fold(\"x = 'a b c d e'.split(' ', 3)\", \"x = ['a','b','c']\");\n+    fold(\"x = 'a b c d e'.split(null, 1)\", \"x = ['a b c d e']\");\n+    foldSame(\"x = 'abcde'.split(/ /)\");\n+    foldSame(\"x = 'abcde'.split(' ', -1)\");\n+    \n+    late = true;\n+    foldSame(\"x = 'a b c d e'.split(' ')\");\n+  }\n \n   public void testJoinBug() {\n     fold(\"var x = [].join();\", \"var x = '';\");", "timestamp": 1324494658, "metainfo": ""}