{"sha": "dfdbb7db25c17eed1315afbfa0229f339528ffc3", "log": "More \"new String\" \"String\" folding. Contributed by Tim Wintle. Fixes issue 531.  R=acleung DELTA=42  (39 added, 0 deleted, 3 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=3612   ", "commit": "\n--- a/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\n+++ b/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\n \n   /** Returns whether this node must be coerced to a string. */\n   private boolean inForcedStringContext(Node n) {\n-    return n.getParent().getType() == Token.GETELEM &&\n-        n.getParent().getLastChild() == n;\n+    if (n.getParent().getType() == Token.GETELEM &&\n+        n.getParent().getLastChild() == n) {\n+      return true;\n+    }\n+\n+    // we can fold in the case \"\" + new String(\"\")\n+    if (n.getParent().getType() == Token.ADD) {\n+      return true;\n+    }\n+    return false;\n   }\n \n   private Node tryFoldInForcedStringContext(Node n) {\n--- a/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n+++ b/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n       case Token.CALL:\n         Node result =  tryFoldLiteralConstructor(node);\n         if (result == node) {\n-          result = tryFoldImmediateCallToBoundFunction(node);\n+          result = tryFoldSimpleFunctionCall(node);\n+          if (result == node) {\n+            result = tryFoldImmediateCallToBoundFunction(node);\n+          }\n         }\n         return result;\n \n       default:\n         return node; //Nothing changed\n     }\n+  }\n+\n+  private Node tryFoldSimpleFunctionCall(Node n) {\n+    Preconditions.checkState(n.getType() == Token.CALL);\n+    Node callTarget = n.getFirstChild();\n+    if (callTarget != null && callTarget.getType() == Token.NAME &&\n+          callTarget.getString().equals(\"String\")) {\n+      // Fold String(a) to ''+(a) - which allows further optimizations\n+      Node value = callTarget.getNext();\n+      if (value != null) {\n+        Node addition = new Node(Token.ADD);\n+        Node stringNode = Node.newString(\"\").copyInformationFrom(callTarget);\n+        addition.addChildToFront(stringNode);\n+        addition.addChildToBack(value.detachFromParent());\n+        n.getParent().replaceChild(n, addition);\n+        reportCodeChange();\n+        return addition;\n+      }\n+    }\n+    return n;\n   }\n \n   private Node tryFoldImmediateCallToBoundFunction(Node n) {\n--- a/test/com/google/javascript/jscomp/PeepholeFoldConstantsTest.java\n+++ b/test/com/google/javascript/jscomp/PeepholeFoldConstantsTest.java\n     fold(\"x = ob[new String(12)]\", \"x = ob['12']\");\n     fold(\"x = ob[new String(false)]\", \"x = ob['false']\");\n     fold(\"x = ob[new String(null)]\", \"x = ob['null']\");\n+    fold(\"x = 'a' + new String('b')\", \"x = 'ab'\");\n+    fold(\"x = 'a' + new String(23)\", \"x = 'a23'\");\n+    fold(\"x = 2 + new String(1)\", \"x = '21'\");\n     foldSame(\"x = ob[new String(a)]\");\n     foldSame(\"x = new String('a')\");\n     foldSame(\"x = (new String('a'))[3]\");\n--- a/test/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntaxTest.java\n+++ b/test/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntaxTest.java\n     new StringCompareTestCase().testBindToCall3();\n   }\n \n+  public void testSimpleFunctionCall() {\n+    test(\"var a = String(23)\", \"var a = '' + 23\");\n+    test(\"var a = String('hello')\", \"var a = '' + 'hello'\");\n+  }\n+\n   private static class StringCompareTestCase extends CompilerTestCase {\n \n     StringCompareTestCase() {", "timestamp": 1320333176, "metainfo": ""}