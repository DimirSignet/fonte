{"sha": "2427228f43a8ace0d18597ab828f5f4775f5d716", "log": "Give declaration nodes to locally qualified names  R=acleung DELTA=42  (30 added, 1 deleted, 11 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=3328   ", "commit": "\n--- a/src/com/google/javascript/jscomp/ChainableReverseAbstractInterpreter.java\n+++ b/src/com/google/javascript/jscomp/ChainableReverseAbstractInterpreter.java\n \n         JSType origType = node.getJSType();\n         origType = origType == null ? getNativeType(UNKNOWN_TYPE) : origType;\n-        scope.inferQualifiedSlot(qualifiedName, origType, type);\n+        scope.inferQualifiedSlot(node, qualifiedName, origType, type);\n         break;\n \n       default:\n--- a/src/com/google/javascript/jscomp/CheckMissingGetCssName.java\n+++ b/src/com/google/javascript/jscomp/CheckMissingGetCssName.java\n  * Ensures string literals matching certain patterns are only used as\n  * goog.getCssName parameters.\n  *\n+ * @author mkretzschmar@google.com (Martin Kretzschmar)\n  */\n class CheckMissingGetCssName\n     extends AbstractPostOrderCallback implements CompilerPass {\n--- a/src/com/google/javascript/jscomp/FlowScope.java\n+++ b/src/com/google/javascript/jscomp/FlowScope.java\n \n package com.google.javascript.jscomp;\n \n+import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.jstype.JSType;\n import com.google.javascript.rhino.jstype.StaticScope;\n import com.google.javascript.rhino.jstype.StaticSlot;\n-\n \n /**\n  * A symbol table for inferring types during data flow analysis.\n    * type of the slot when we enter the scope, and the current type being\n    * inferred.\n    */\n-  void inferQualifiedSlot(String symbol, JSType bottomType,\n+  void inferQualifiedSlot(Node node, String symbol, JSType bottomType,\n       JSType inferredType);\n \n   /**\n--- a/src/com/google/javascript/jscomp/LinkedFlowScope.java\n+++ b/src/com/google/javascript/jscomp/LinkedFlowScope.java\n   }\n \n   @Override\n-  public void inferQualifiedSlot(String symbol, JSType bottomType,\n+  public void inferQualifiedSlot(Node node, String symbol, JSType bottomType,\n       JSType inferredType) {\n     Scope functionScope = getFunctionScope();\n     if (functionScope.isLocal()) {\n         // already defined even if they haven't been declared in the Scope\n         // object. If the name has not yet been defined in this scope, we\n         // need to define it now before we refine it.\n-        functionScope.declare(symbol, null, bottomType, null);\n+        int firstDot = symbol.indexOf(\".\");\n+        Preconditions.checkState(firstDot != -1);\n+        Var owner = functionScope.getVar(symbol.substring(0, firstDot));\n+        Scope ownerScope = owner == null ? functionScope : owner.getScope();\n+        ownerScope.declare(symbol, node, bottomType, null);\n       }\n \n       inferSlotType(symbol, inferredType);\n--- a/src/com/google/javascript/jscomp/SemanticReverseAbstractInterpreter.java\n+++ b/src/com/google/javascript/jscomp/SemanticReverseAbstractInterpreter.java\n           JSType unknownType = typeRegistry.getNativeType(\n               JSTypeNative.UNKNOWN_TYPE);\n           informed.inferQualifiedSlot(\n-              propertyQualifiedName, unknownType, unknownType);\n+              object, propertyQualifiedName, unknownType, unknownType);\n           return informed;\n         }\n       }\n--- a/src/com/google/javascript/jscomp/SymbolTable.java\n+++ b/src/com/google/javascript/jscomp/SymbolTable.java\n     }\n   }\n \n+  /** Gets all the scopes in this symbol table. */\n+  Collection<SymbolScope> getAllScopes() {\n+    return Collections.unmodifiableCollection(scopes.values());\n+  }\n+\n   /**\n    * Make sure all the symbols and references in {@code otherSymbolTable}\n    * are in this symbol table.\n--- a/src/com/google/javascript/jscomp/TypeInference.java\n+++ b/src/com/google/javascript/jscomp/TypeInference.java\n       case Token.GETPROP:\n         String qualifiedName = left.getQualifiedName();\n         if (qualifiedName != null) {\n-          scope.inferQualifiedSlot(qualifiedName,\n+          scope.inferQualifiedSlot(left, qualifiedName,\n               leftType == null ? getNativeType(UNKNOWN_TYPE) : leftType,\n               resultType);\n         }\n     scope = scope.createChildFlowScope();\n     if (node.getType() == Token.GETPROP) {\n       scope.inferQualifiedSlot(\n-          node.getQualifiedName(), getJSType(node), narrowed);\n+          node, node.getQualifiedName(), getJSType(node), narrowed);\n     } else {\n       redeclareSimpleVar(scope, node, narrowed);\n     }\n--- a/test/com/google/javascript/jscomp/CheckMissingGetCssNameTest.java\n+++ b/test/com/google/javascript/jscomp/CheckMissingGetCssNameTest.java\n package com.google.javascript.jscomp;\n \n /**\n+ * @author mkretzschmar@google.com (Martin Kretzschmar)\n  */\n public class CheckMissingGetCssNameTest extends CompilerTestCase {\n   @Override\n--- a/test/com/google/javascript/jscomp/SymbolTableTest.java\n+++ b/test/com/google/javascript/jscomp/SymbolTableTest.java\n     assertEquals(code.indexOf(\"x */\"), refs.get(1).getNode().getCharno());\n   }\n \n+  public void testGlobalQualifiedNamesInLocalScopes() {\n+    SymbolTable table = createSymbolTable(\n+        \"/** @const */ var x = {}; function f() { x.number = 3; }\");\n+    Symbol xNumber = getLocalVar(table, \"x.number\");\n+    assertNotNull(xNumber);\n+    assertTrue(table.getScope(xNumber).isGlobalScope());\n+\n+    assertEquals(\"?\", xNumber.getType().toString());\n+  }\n+\n+  public void testLocalQualifiedNamesInLocalScopes() {\n+    SymbolTable table = createSymbolTable(\n+        \"function f() { var x = {}; x.number = 3; }\");\n+    Symbol xNumber = getLocalVar(table, \"x.number\");\n+    assertNotNull(xNumber);\n+    assertFalse(table.getScope(xNumber).isGlobalScope());\n+\n+    assertEquals(\"?\", xNumber.getType().toString());\n+  }\n+\n   private Symbol getGlobalVar(SymbolTable table, String name) {\n     return table.getGlobalScope().getSlot(name);\n   }\n \n   private Symbol getLocalVar(SymbolTable table, String name) {\n-    for (Symbol symbol : table.getAllSymbols()) {\n-      if (symbol.getName().equals(name) &&\n-          table.getScope(symbol).getParentScope() != null) {\n-        return symbol;\n+    for (SymbolScope scope : table.getAllScopes()) {\n+      if (!scope.isGlobalScope() && scope.isLexicalScope() &&\n+          scope.getSlot(name) != null) {\n+        return scope.getSlot(name);\n       }\n     }\n     return null;", "timestamp": 1316816558, "metainfo": ""}