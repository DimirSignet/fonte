{"sha": "10c0c9ff36fb717223facd60efec8cf4ad97824f", "log": "Handle constructor aliases in the indexer.  R=johnlenz DELTA=150  (97 added, 47 deleted, 6 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=5539   ", "commit": "\n--- a/src/com/google/javascript/jscomp/SymbolTable.java\n+++ b/src/com/google/javascript/jscomp/SymbolTable.java\n     if (scope.isGlobalScope()) {\n       builder.append(\n           String.format(\"'%s' : in global scope:\\n\", symbol.getName()));\n-    } else {\n+    } else if (scope.getRootNode() != null) {\n       builder.append(\n           String.format(\"'%s' : in scope %s:%d\\n\",\n               symbol.getName(),\n               scope.getRootNode().getSourceFileName(),\n               scope.getRootNode().getLineno()));\n+    } else if (scope.getSymbolForScope() != null) {\n+      builder.append(\n+          String.format(\"'%s' : in scope %s\\n\", symbol.getName(),\n+              scope.getSymbolForScope().getName()));\n+    } else {\n+      builder.append(\n+          String.format(\"'%s' : in unknown scope\\n\", symbol.getName()));\n     }\n \n     int refCount = 0;\n       return true;\n     }\n \n-    // Cosntructors/prototypes\n+    // Constructors/prototypes\n+    // Should this check for\n+    // (type.isNominalConstructor() || type.isFunctionPrototypeType())\n+    // ?\n     if (sym.getName().equals(type.getReferenceName())) {\n       return true;\n     }\n         if (owner != null\n             && owner.getType() != null\n             && (owner.getType().isNominalConstructor() ||\n+                owner.getType().isFunctionPrototypeType() ||\n                 owner.getType().isEnumType())) {\n           removeSymbol(s);\n           continue nextSymbol;\n--- a/src/com/google/javascript/jscomp/TypedScopeCreator.java\n+++ b/src/com/google/javascript/jscomp/TypedScopeCreator.java\n       if (fnType != null &&\n           // We don't want to look at empty function types.\n           !type.isEmptyType()) {\n+\n+        // We want to make sure that when we declare a new instance type\n+        // (with @constructor) that there's actually a ctor for it.\n+        // This doesn't apply to structural constructors (like\n+        // function(new:Array). Checking the constructed type against\n+        // the variable name is a sufficient check for this.\n         if ((fnType.isConstructor() || fnType.isInterface()) &&\n-            !fnType.isEquivalentTo(getNativeType(U2U_CONSTRUCTOR_TYPE))) {\n-          // Declare var.prototype in the scope chain.\n-          FunctionType superClassCtor = fnType.getSuperClassConstructor();\n-          ObjectType.Property prototypeSlot = fnType.getSlot(\"prototype\");\n-\n-          // When we declare the function prototype implicitly, we\n-          // want to make sure that the function and its prototype\n-          // are declared at the same node. We also want to make sure\n-          // that the if a symbol has both a Var and a JSType, they have\n-          // the same node.\n-          //\n-          // This consistency is helpful to users of SymbolTable,\n-          // because everything gets declared at the same place.\n-          prototypeSlot.setNode(n);\n-\n-          String prototypeName = variableName + \".prototype\";\n-\n-          // There are some rare cases where the prototype will already\n-          // be declared. See TypedScopeCreatorTest#testBogusPrototypeInit.\n-          // Fortunately, other warnings will complain if this happens.\n-          Var prototypeVar = scopeToDeclareIn.getVar(prototypeName);\n-          if (prototypeVar != null && prototypeVar.scope == scopeToDeclareIn) {\n-            scopeToDeclareIn.undeclare(prototypeVar);\n-          }\n-\n-          scopeToDeclareIn.declare(prototypeName,\n-              n, prototypeSlot.getType(), input,\n-              /* declared iff there's an explicit supertype */\n-              superClassCtor == null ||\n-              superClassCtor.getInstanceType().isEquivalentTo(\n-                  getNativeType(OBJECT_TYPE)));\n-\n-          // Make sure the variable is initialized to something if\n-          // it constructs itself.\n-          if (newVar.getInitialValue() == null &&\n-              !isExtern &&\n-              // We want to make sure that when we declare a new instance\n-              // type (with @constructor) that there's actually a ctor for it.\n-              // This doesn't apply to structural constructors\n-              // (like function(new:Array). Checking the constructed\n-              // type against the variable name is a sufficient check for\n-              // this.\n-              variableName.equals(\n-                  fnType.getInstanceType().getReferenceName())) {\n-            compiler.report(\n-                JSError.make(sourceName, n,\n-                    fnType.isConstructor() ?\n-                    CTOR_INITIALIZER : IFACE_INITIALIZER,\n-                    variableName));\n-          }\n+            variableName.equals(fnType.getReferenceName())) {\n+          finishConstructorDefinition(n, variableName, fnType, scopeToDeclareIn,\n+                                      input, newVar);\n         }\n       }\n \n         globalThisCtor.getPrototype().clearCachedValues();\n         globalThisCtor\n             .setPrototypeBasedOn((type.toMaybeFunctionType()).getInstanceType());\n+      }\n+    }\n+\n+    private void finishConstructorDefinition(\n+        Node n, String variableName, FunctionType fnType,\n+        Scope scopeToDeclareIn, CompilerInput input, Var newVar) {\n+      // Declare var.prototype in the scope chain.\n+      FunctionType superClassCtor = fnType.getSuperClassConstructor();\n+      ObjectType.Property prototypeSlot = fnType.getSlot(\"prototype\");\n+\n+      // When we declare the function prototype implicitly, we\n+      // want to make sure that the function and its prototype\n+      // are declared at the same node. We also want to make sure\n+      // that the if a symbol has both a Var and a JSType, they have\n+      // the same node.\n+      //\n+      // This consistency is helpful to users of SymbolTable,\n+      // because everything gets declared at the same place.\n+      prototypeSlot.setNode(n);\n+\n+      String prototypeName = variableName + \".prototype\";\n+\n+      // There are some rare cases where the prototype will already\n+      // be declared. See TypedScopeCreatorTest#testBogusPrototypeInit.\n+      // Fortunately, other warnings will complain if this happens.\n+      Var prototypeVar = scopeToDeclareIn.getVar(prototypeName);\n+      if (prototypeVar != null && prototypeVar.scope == scopeToDeclareIn) {\n+        scopeToDeclareIn.undeclare(prototypeVar);\n+      }\n+\n+      scopeToDeclareIn.declare(prototypeName,\n+          n, prototypeSlot.getType(), input,\n+          /* declared iff there's an explicit supertype */\n+          superClassCtor == null ||\n+          superClassCtor.getInstanceType().isEquivalentTo(\n+              getNativeType(OBJECT_TYPE)));\n+\n+      // Make sure the variable is initialized to something if\n+      // it constructs itself.\n+      if (newVar.getInitialValue() == null &&\n+          !n.isFromExterns()) {\n+        compiler.report(\n+            JSError.make(sourceName, n,\n+                fnType.isConstructor() ?\n+                CTOR_INITIALIZER : IFACE_INITIALIZER,\n+                variableName));\n       }\n     }\n \n--- a/test/com/google/javascript/jscomp/SymbolTableTest.java\n+++ b/test/com/google/javascript/jscomp/SymbolTableTest.java\n     assertEquals(Foo, dom.getPropertyScope().getSlot(\"Foo\"));\n   }\n \n+  public void testConstructorAlias() throws Exception {\n+    SymbolTable table = createSymbolTable(\n+        \"/** @constructor */ var Foo = function() {};\\n\" +\n+        \"/** desc */ Foo.prototype.bar = function() {};\\n\" +\n+        \"/** @constructor */ var FooAlias = Foo;\\n\" +\n+        \"/** desc */ FooAlias.prototype.baz = function() {};\\n\");\n+\n+    Symbol foo = getGlobalVar(table, \"Foo\");\n+    Symbol fooAlias = getGlobalVar(table, \"FooAlias\");\n+    Symbol bar = getGlobalVar(table, \"Foo.prototype.bar\");\n+    Symbol baz = getGlobalVar(table, \"Foo.prototype.baz\");\n+    Symbol bazAlias = getGlobalVar(table, \"FooAlias.prototype.baz\");\n+\n+    assertNotNull(foo);\n+    assertNotNull(fooAlias);\n+    assertNotNull(bar);\n+    assertNotNull(baz);\n+    assertNull(bazAlias);\n+\n+    Symbol barScope = table.getSymbolForScope(table.getScope(bar));\n+    assertNotNull(barScope);\n+\n+    Symbol bazScope = table.getSymbolForScope(table.getScope(baz));\n+    assertNotNull(bazScope);\n+\n+    Symbol fooPrototype = foo.getPropertyScope().getSlot(\"prototype\");\n+    assertNotNull(fooPrototype);\n+\n+    assertEquals(fooPrototype, barScope);\n+    assertEquals(fooPrototype, bazScope);\n+  }\n+\n   public void testSymbolForScopeOfNatives() throws Exception {\n     SymbolTable table = createSymbolTable(\"\");\n \n \n       Symbol scope = table.getSymbolForScope(table.getScope(sym));\n       assertTrue(\n-          \"The symbol's scope is a zombie scope that shouldn't exist: \" + sym,\n+          \"The symbol's scope is a zombie scope that shouldn't exist.\\n\" +\n+          \"Symbol: \" + sym + \"\\n\" +\n+          \"Scope: \" + table.getScope(sym),\n           scope == null || allSymbols.contains(scope));\n     }\n ", "timestamp": 1348510404, "metainfo": ""}