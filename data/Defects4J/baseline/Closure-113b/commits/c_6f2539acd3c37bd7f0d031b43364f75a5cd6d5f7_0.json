{"sha": "6f2539acd3c37bd7f0d031b43364f75a5cd6d5f7", "log": "fix some code that was initializing options from flags twice. (and thus re-parsing the js messages bundles) as it turns out, there are a lot of ways to not initialize options. (Nick) R=john DELTA=99  (72 added, 24 deleted, 3 changed)  Revision created by MOE tool push_codebase. MOE_MIGRATION=   ", "commit": "\n--- a/src/com/google/javascript/jscomp/AbstractCommandLineRunner.java\n+++ b/src/com/google/javascript/jscomp/AbstractCommandLineRunner.java\n       options.setCodingConvention(new DefaultCodingConvention());\n     }\n \n+    options.setSummaryDetailLevel(config.summaryDetailLevel);\n+\n     inputCharset = getInputCharset();\n   }\n \n     if (!options.jsOutputFile.isEmpty()) {\n       out = new PrintStream(options.jsOutputFile, inputCharset.name());\n     }\n-\n-    ((PrintStreamErrorManager) compiler.getErrorManager())\n-        .setSummaryDetailLevel(config.summaryDetailLevel);\n \n     List<String> jsFiles = config.js;\n     List<String> moduleSpecs = config.module;\n--- a/src/com/google/javascript/jscomp/Compiler.java\n+++ b/src/com/google/javascript/jscomp/Compiler.java\n *\n  */\n public class Compiler extends AbstractCompiler {\n-  CompilerOptions options_ = createDefaultOptions();\n+  CompilerOptions options_ = null;\n \n   private PassConfig passes = null;\n \n   private static final Logger logger_ =\n       Logger.getLogger(\"com.google.javascript.jscomp\");\n \n+  private final PrintStream outStream;\n+\n   /**\n    * Creates a Compiler that reports errors and warnings to its logger.\n    */\n   public Compiler() {\n+    this((PrintStream) null);\n+  }\n+\n+  /**\n+   * Creates n Compiler that reports errors and warnings to an output\n+   * stream.\n+   */\n+  public Compiler(PrintStream stream) {\n     addChangeHandler(recentChange);\n     this.typeValidator = new TypeValidator(this);\n-    setErrorManager(new LoggerErrorManager(createMessageFormatter(), logger_));\n-  }\n-\n-  /**\n-   * Creates n Compiler that reports errors and warnings to an output\n-   * stream.\n-   */\n-  public Compiler(PrintStream stream) {\n-    this();\n-    setErrorManager(\n-        new PrintStreamErrorManager(createMessageFormatter(), stream));\n+    outStream = stream;\n   }\n \n   /**\n   public Compiler(ErrorManager errorManager) {\n     this();\n     setErrorManager(errorManager);\n-  }\n-\n-  CompilerOptions createDefaultOptions() {\n-    return new CompilerOptions();\n   }\n \n   /**\n   }\n \n   /**\n+   * Initialize the compiler options. Only necessary if you're not doing\n+   * a normal compile() job.\n+   */\n+  public void initOptions(CompilerOptions options) {\n+    options_ = options;\n+    if (errorManager == null) {\n+      if (outStream == null) {\n+        setErrorManager(\n+            new LoggerErrorManager(createMessageFormatter(), logger_));\n+      } else {\n+        PrintStreamErrorManager printer =\n+            new PrintStreamErrorManager(createMessageFormatter(), outStream);\n+        printer.setSummaryDetailLevel(options_.summaryDetailLevel);\n+        setErrorManager(printer);\n+      }\n+    }\n+  }\n+\n+  /**\n    * Initializes the instance state needed for a compile job.\n    */\n   public void init(JSSourceFile[] externs, JSSourceFile[] inputs,\n       CompilerOptions options) {\n+    initOptions(options);\n+    \n     externs_ = makeCompilerInput(externs, true);\n     modules_ = null;\n     moduleGraph_ = null;\n     inputs_ = makeCompilerInput(inputs, false);\n-    options_ = options;\n     initBasedOnOptions();\n \n     initInputsByNameMap();\n    */\n   public void init(JSSourceFile[] externs, JSModule[] modules,\n       CompilerOptions options) {\n+    initOptions(options);\n \n     checkFirstModule(modules);\n \n       return;\n     }\n     inputs_ = getAllInputsFromModules();\n-    options_ = options;\n     initBasedOnOptions();\n \n     initInputsByNameMap();\n   }\n \n   public Node parse(JSSourceFile file) {\n+    initCompilerOptionsIfTesting();\n     addToDebugLog(\"Parsing: \" + file.getName());\n     return new JsAst(file).getAstRoot(this);\n   }\n     return input.getAstRoot(this);\n   }\n \n+  void initCompilerOptionsIfTesting() {\n+    if (options_ == null) {\n+      // initialization for tests that don't initialize the compiler\n+      // by the normal mechanisms.\n+      initOptions(new CompilerOptions());\n+    }\n+  }\n+\n   @Override\n   Node parseSyntheticCode(String fileName, String js) {\n+    initCompilerOptionsIfTesting();\n     return parse(JSSourceFile.fromCode(fileName, js));\n   }\n \n   Node parseTestCode(String js) {\n+    initCompilerOptionsIfTesting();\n     CompilerInput input = new CompilerInput(\n         JSSourceFile.fromCode(\" [testcode] \", js));\n     if (inputsByName_ == null) {\n    */\n   @Override\n   String toSource(Node n) {\n+    initCompilerOptionsIfTesting();\n+    \n     CodePrinter.Builder builder = new CodePrinter.Builder(n);\n     builder.setPrettyPrint(options_.prettyPrint);\n     builder.setLineBreak(options_.lineBreak);\n \n   @Override\n   public ErrorManager getErrorManager() {\n+    if (options_ == null) {\n+      initOptions(new CompilerOptions());\n+    }\n     return errorManager;\n   }\n \n--- a/src/com/google/javascript/jscomp/CompilerOptions.java\n+++ b/src/com/google/javascript/jscomp/CompilerOptions.java\n   public String jsOutputFile;\n \n   private transient ComposeWarningsGuard warningsGuard;\n+\n+  int summaryDetailLevel = 1;\n \n   //--------------------------------\n   // Special Output Options\n     return codingConvention;\n   }\n \n+  /**\n+   * Controls how detailed the compilation summary is. Values:\n+   *  0 (never print summary), 1 (print summary only if there are\n+   * errors or warnings), 2 (print summary if type checking is on,\n+   * see --check_types), 3 (always print summary). The default level\n+   * is 1\n+   */\n+  public void setSummaryDetailLevel(int summaryDetailLevel) {\n+    this.summaryDetailLevel = summaryDetailLevel;\n+  }\n+\n   @Override\n   public Object clone() throws CloneNotSupportedException {\n     CompilerOptions clone = (CompilerOptions) super.clone();\n--- a/test/com/google/javascript/jscomp/CompilerTypeTestCase.java\n+++ b/test/com/google/javascript/jscomp/CompilerTypeTestCase.java\n   @Override\n   protected void setUp() throws Exception {\n     compiler = new Compiler();\n+    compiler.initCompilerOptionsIfTesting();\n     compiler.options_.setWarningLevel(\n         DiagnosticGroups.MISSING_PROPERTIES, CheckLevel.WARNING);\n     registry = compiler.getTypeRegistry();\n--- a/test/com/google/javascript/jscomp/JSModuleTest.java\n+++ b/test/com/google/javascript/jscomp/JSModuleTest.java\n         \"goog.provide('c');goog.require('d')\"));\n     mod.add(JSSourceFile.fromCode(\"d.js\",\n         \"goog.provide('d')\"));\n-    mod.sortInputsByDeps(new Compiler(System.err));\n+    Compiler compiler = new Compiler(System.err);\n+    compiler.initCompilerOptionsIfTesting();\n+    mod.sortInputsByDeps(compiler);\n \n     assertEquals(4, mod.getInputs().size());\n     assertEquals(\"d.js\", mod.getInputs().get(0).getSourceFile().getName());\n--- a/test/com/google/javascript/jscomp/NodeTraversalTest.java\n+++ b/test/com/google/javascript/jscomp/NodeTraversalTest.java\n       @Override protected void printSummary() {\n       }\n     });\n+    compiler.initCompilerOptionsIfTesting();\n \n     NodeTraversal t = new NodeTraversal(compiler, null);\n     DiagnosticType dt = DiagnosticType.warning(\"FOO\", \"{0}, {1} - {2}\");\n--- a/test/com/google/javascript/jscomp/PhaseOptimizerTest.java\n+++ b/test/com/google/javascript/jscomp/PhaseOptimizerTest.java\n   public void setUp() {\n     passesRun.clear();\n     compiler = new Compiler();\n+    compiler.initCompilerOptionsIfTesting();\n     tracker = new PerformanceTracker(new Node(Token.BLOCK), false);\n     optimizer = new PhaseOptimizer(compiler, tracker);\n   }", "timestamp": 1269279708, "metainfo": ""}