{"sha": "8635b820d3333573b3053ffe36b00e9d464dd3c8", "log": "Allow the unknown type and record types in inline type annotations. ------------- Created by MOE: http://code.google.com/p/moe-java MOE_MIGRATED_REVID=53614784", "commit": "\n--- a/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\n+++ b/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\n   public JSDocInfo parseInlineTypeDoc() {\n     skipEOLs();\n \n-    Node typeAst = parseAndRecordTypeNode(next());\n+    JsDocToken token = next();\n+    int lineno = stream.getLineno();\n+    int startCharno = stream.getCharno();\n+    Node typeAst = parseTypeExpression(token);\n+    recordTypeNode(lineno, startCharno, typeAst, token == JsDocToken.LC);\n+\n     JSTypeExpression expr = createJSTypeExpression(typeAst);\n     if (expr != null) {\n       jsdocBuilder.recordType(expr);\n       return retrieveAndResetParsedJSDocInfo();\n     }\n     return null;\n+  }\n+\n+  private void recordTypeNode(int lineno, int startCharno, Node typeAst,\n+      boolean matchingLC) {\n+    if (typeAst != null) {\n+      int endLineno = stream.getLineno();\n+      int endCharno = stream.getCharno();\n+      jsdocBuilder.markTypeNode(\n+          typeAst, lineno, startCharno, endLineno, endCharno, matchingLC);\n+    }\n   }\n \n   /**\n    * @return The type expression found or null if none.\n    */\n   Node parseAndRecordTypeNode(JsDocToken token) {\n-    return parseAndRecordTypeNode(token, token == JsDocToken.LC);\n-  }\n-\n-  /**\n-   * Looks for a type expression at the current token and if found,\n-   * returns it. Note that this method consumes input.\n-   *\n-   * @param token The current token.\n-   * @param matchingLC Whether the type expression starts with a \"{\".\n-   * @return The type expression found or null if none.\n-   */\n-  private Node parseAndRecordTypeNode(JsDocToken token, boolean matchingLC) {\n     return parseAndRecordTypeNode(token, stream.getLineno(), stream.getCharno(),\n-        matchingLC, false);\n+        token == JsDocToken.LC, false);\n   }\n \n   /**\n     int startCharno = stream.getCharno();\n \n     Node typeNode = parseParamTypeExpressionAnnotation(token);\n-    if (typeNode != null) {\n-      int endLineno = stream.getLineno();\n-      int endCharno = stream.getCharno();\n-\n-      jsdocBuilder.markTypeNode(typeNode, lineno, startCharno,\n-          endLineno, endCharno, true);\n-    }\n+    recordTypeNode(lineno, startCharno, typeNode, true);\n     return typeNode;\n   }\n \n       typeNode = parseTypeExpressionAnnotation(token);\n     }\n \n-    if (typeNode != null) {\n-      int endLineno = stream.getLineno();\n-      int endCharno = stream.getCharno();\n-\n-      jsdocBuilder.markTypeNode(\n-          typeNode, lineno, startCharno, endLineno, endCharno, matchingLC);\n-    }\n-\n+    recordTypeNode(lineno, startCharno, typeNode, matchingLC);\n     return typeNode;\n   }\n \n     if (token == JsDocToken.QMARK) {\n       // A QMARK could mean that a type is nullable, or that it's unknown.\n       // We use look-ahead 1 to determine whether it's unknown. Otherwise,\n-      // we assume it means nullable. There are 5 cases:\n+      // we assume it means nullable. There are 8 cases:\n       // {?} - right curly\n       // {?=} - equals\n       // {function(?, number)} - comma\n       // {function(number, ...[?])} - right bracket\n       // {function(): ?|number} - pipe\n       // {Array.<?>} - greater than\n+      // /** ? */ - EOC (inline types)\n       // I'm not a big fan of using look-ahead for this, but it makes\n       // the type language a lot nicer.\n       token = next();\n           token == JsDocToken.RC ||\n           token == JsDocToken.RP ||\n           token == JsDocToken.PIPE ||\n-          token == JsDocToken.GT) {\n+          token == JsDocToken.GT ||\n+          token == JsDocToken.EOC) {\n         restoreLookAhead(token);\n         return newNode(Token.QMARK);\n       }\n--- a/test/com/google/javascript/jscomp/TypeCheckTest.java\n+++ b/test/com/google/javascript/jscomp/TypeCheckTest.java\n   public void testTypeCheck24() throws Exception {\n     testTypes(\"/** @constructor */function MyType(){}\\n\" +\n         \"/** @type {(MyType,Null)} */var foo; foo = null;\");\n+  }\n+\n+\n+  public void testTypeCheck25() throws Exception {\n+    testTypes(\"function foo(/** {a: number} */ obj) {};\"\n+        + \"foo({b: 'abc'});\",\n+        \"actual parameter 1 of foo does not match formal parameter\\n\" +\n+            \"found   : {a: (number|undefined), b: string}\\n\" +\n+            \"required: {a: number}\");\n+  }\n+\n+  public void testTypeCheck26() throws Exception {\n+    testTypes(\"function foo(/** {a: number} */ obj) {};\"\n+        + \"foo({a: 'abc'});\",\n+        \"actual parameter 1 of foo does not match formal parameter\\n\"\n+        + \"found   : {a: (number|string)}\\n\"\n+        + \"required: {a: number}\");\n+\n+  }\n+\n+  public void testTypeCheck27() throws Exception {\n+    testTypes(\"function foo(/** {a: number} */ obj) {};\"\n+        + \"foo({a: 123});\");\n+  }\n+\n+  public void testTypeCheck28() throws Exception {\n+    testTypes(\"function foo(/** ? */ obj) {};\"\n+        + \"foo({a: 123});\");\n   }\n \n   public void testTypeCheckDefaultExterns() throws Exception {\n--- a/test/com/google/javascript/jscomp/parsing/ParserTest.java\n+++ b/test/com/google/javascript/jscomp/parsing/ParserTest.java\n \n   public void testInlineJSDocAttachment2() {\n     Node fn = parse(\n-        \"function f(/**\\n\" +\n-        \" * {string}\\n\" +\n-        \" */ x) {}\").getFirstChild();\n+        \"function f(/** ? */ x) {}\").getFirstChild();\n     assertTrue(fn.isFunction());\n \n     JSDocInfo info =\n         fn.getFirstChild().getNext().getFirstChild().getJSDocInfo();\n     assertNotNull(info);\n-    assertTypeEquals(STRING_TYPE, info.getType());\n+    assertTypeEquals(UNKNOWN_TYPE, info.getType());\n   }\n \n   public void testInlineJSDocAttachment3() {\n     JSDocInfo info = vardecl.getFirstChild().getJSDocInfo();\n     assertNotNull(info);\n     assertTypeEquals(STRING_TYPE, info.getType());\n+  }\n+\n+  public void testInlineJSDocAttachment6() {\n+    Node fn = parse(\"function f(/** {attr: number} */ x) {}\").getFirstChild();\n+    assertTrue(fn.isFunction());\n+\n+    JSDocInfo info =\n+        fn.getFirstChild().getNext().getFirstChild().getJSDocInfo();\n+    assertNotNull(info);\n+    assertTypeEquals(createRecordTypeBuilder().\n+        addProperty(\"attr\", NUMBER_TYPE, null).\n+        build(),\n+        info.getType());\n   }\n \n   public void testIncorrectJSDocDoesNotAlterJSParsing1() throws Exception {", "timestamp": 1380849670, "metainfo": ""}