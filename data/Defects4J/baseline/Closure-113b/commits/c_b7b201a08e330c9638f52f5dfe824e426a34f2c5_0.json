{"sha": "b7b201a08e330c9638f52f5dfe824e426a34f2c5", "log": "Attach types to literals at scope-creation time instead of at inference time. Scope-creation already attaches types to function literals at scope-creation type, so this makes the other literals more consistent with function literals.  R=johnlenz DELTA=167  (102 added, 53 deleted, 12 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=209649   ", "commit": "\n--- a/src/com/google/javascript/jscomp/TypeInference.java\n+++ b/src/com/google/javascript/jscomp/TypeInference.java\n import static com.google.javascript.rhino.jstype.JSTypeNative.NULL_TYPE;\n import static com.google.javascript.rhino.jstype.JSTypeNative.NUMBER_TYPE;\n import static com.google.javascript.rhino.jstype.JSTypeNative.NUMBER_VALUE_OR_OBJECT_TYPE;\n-import static com.google.javascript.rhino.jstype.JSTypeNative.REGEXP_TYPE;\n import static com.google.javascript.rhino.jstype.JSTypeNative.STRING_TYPE;\n import static com.google.javascript.rhino.jstype.JSTypeNative.UNKNOWN_TYPE;\n import static com.google.javascript.rhino.jstype.JSTypeNative.VOID_TYPE;\n         n.setJSType(getNativeType(NUMBER_TYPE));\n         break;\n \n-      case Token.NULL:\n-        n.setJSType(getNativeType(NULL_TYPE));\n-        break;\n-\n-      case Token.VOID:\n-        n.setJSType(getNativeType(VOID_TYPE));\n-        break;\n-\n       case Token.ARRAYLIT:\n         scope = traverseArrayLiteral(n, scope);\n-        break;\n-\n-      case Token.REF_SPECIAL:\n-        n.setJSType(getNativeType(UNKNOWN_TYPE));\n-        break;\n-\n-      case Token.REGEXP:\n-        n.setJSType(getNativeType(REGEXP_TYPE));\n         break;\n \n       case Token.THIS:\n       case Token.DEC:\n       case Token.INC:\n       case Token.BITNOT:\n-      case Token.NUMBER:\n         scope = traverseChildren(n, scope);\n         n.setJSType(getNativeType(NUMBER_TYPE));\n         break;\n         n.setJSType(getJSType(n.getLastChild()));\n         break;\n \n-      case Token.STRING:\n       case Token.TYPEOF:\n         scope = traverseChildren(n, scope);\n         n.setJSType(getNativeType(STRING_TYPE));\n       case Token.SHNE:\n       case Token.INSTANCEOF:\n       case Token.IN:\n-      case Token.TRUE:\n-      case Token.FALSE:\n         scope = traverseChildren(n, scope);\n         n.setJSType(getNativeType(BOOLEAN_TYPE));\n         break;\n   }\n \n   private FlowScope traverseObjectLiteral(Node n, FlowScope scope) {\n-    if (n.getJSType() != null) {\n-      // The node has already been traversed by the data-flow analysis\n-      // framework. Don't re-generate the anonymous object as it might lead to\n-      // pernicious bugs.\n-      return scope;\n-    }\n-    ObjectType objectType = registry.createAnonymousObjectType();\n+    ObjectType objectType = (ObjectType) n.getJSType();\n     for (Node name = n.getFirstChild(); name != null;\n          name = name.getNext().getNext()) {\n       Node value = name.getNext();\n       scope = traverse(value, scope);\n       String memberName = NodeUtil.getStringValue(name);\n       if (memberName != null) {\n-        // TODO(nicksantos): We need to fix the parser so that we can\n-        // attach JSDoc to the individual elements of object literals.\n-        // Right now, this is not possible.\n         objectType.defineInferredProperty(memberName, getJSType(value), false);\n       } else {\n         n.setJSType(getNativeType(UNKNOWN_TYPE));\n         return scope;\n       }\n     }\n-    n.setJSType(objectType);\n     return scope;\n   }\n \n--- a/src/com/google/javascript/jscomp/TypedScopeCreator.java\n+++ b/src/com/google/javascript/jscomp/TypedScopeCreator.java\n import static com.google.javascript.rhino.jstype.JSTypeNative.FUNCTION_FUNCTION_TYPE;\n import static com.google.javascript.rhino.jstype.JSTypeNative.NO_OBJECT_TYPE;\n import static com.google.javascript.rhino.jstype.JSTypeNative.NO_TYPE;\n+import static com.google.javascript.rhino.jstype.JSTypeNative.NULL_TYPE;\n import static com.google.javascript.rhino.jstype.JSTypeNative.NUMBER_OBJECT_FUNCTION_TYPE;\n+import static com.google.javascript.rhino.jstype.JSTypeNative.NUMBER_TYPE;\n import static com.google.javascript.rhino.jstype.JSTypeNative.OBJECT_FUNCTION_TYPE;\n import static com.google.javascript.rhino.jstype.JSTypeNative.OBJECT_TYPE;\n import static com.google.javascript.rhino.jstype.JSTypeNative.RANGE_ERROR_FUNCTION_TYPE;\n import static com.google.javascript.rhino.jstype.JSTypeNative.REFERENCE_ERROR_FUNCTION_TYPE;\n import static com.google.javascript.rhino.jstype.JSTypeNative.REGEXP_FUNCTION_TYPE;\n+import static com.google.javascript.rhino.jstype.JSTypeNative.REGEXP_TYPE;\n import static com.google.javascript.rhino.jstype.JSTypeNative.STRING_OBJECT_FUNCTION_TYPE;\n+import static com.google.javascript.rhino.jstype.JSTypeNative.STRING_TYPE;\n import static com.google.javascript.rhino.jstype.JSTypeNative.SYNTAX_ERROR_FUNCTION_TYPE;\n import static com.google.javascript.rhino.jstype.JSTypeNative.TYPE_ERROR_FUNCTION_TYPE;\n import static com.google.javascript.rhino.jstype.JSTypeNative.U2U_CONSTRUCTOR_TYPE;\n     return null;\n   }\n \n+  private void attachLiteralTypes(Node n) {\n+    switch (n.getType()) {\n+      case Token.NULL:\n+        n.setJSType(getNativeType(NULL_TYPE));\n+        break;\n+\n+      case Token.VOID:\n+        n.setJSType(getNativeType(VOID_TYPE));\n+        break;\n+\n+      case Token.STRING:\n+        n.setJSType(getNativeType(STRING_TYPE));\n+        break;\n+\n+      case Token.NUMBER:\n+        n.setJSType(getNativeType(NUMBER_TYPE));\n+        break;\n+\n+      case Token.TRUE:\n+      case Token.FALSE:\n+        n.setJSType(getNativeType(BOOLEAN_TYPE));\n+        break;\n+\n+      case Token.REGEXP:\n+        n.setJSType(getNativeType(REGEXP_TYPE));\n+        break;\n+\n+      case Token.REF_SPECIAL:\n+        n.setJSType(getNativeType(UNKNOWN_TYPE));\n+        break;\n+\n+      case Token.OBJECTLIT:\n+        n.setJSType(typeRegistry.createAnonymousObjectType());\n+        break;\n+\n+      // NOTE(nicksantos): If we ever support Array tuples,\n+      // we will need to put ARRAYLIT here as well.\n+    }\n+  }\n+\n+  private JSType getNativeType(JSTypeNative nativeType) {\n+    return typeRegistry.getNativeType(nativeType);\n+  }\n+\n   private abstract class AbstractScopeBuilder\n       implements NodeTraversal.Callback {\n \n           CompilerInput input = compiler.getInput(sourceName);\n           Preconditions.checkNotNull(input, sourceName);\n           type = input.isExtern() ?\n-              typeRegistry.getNativeType(UNKNOWN_TYPE) : null;\n+              getNativeType(UNKNOWN_TYPE) : null;\n         } else if (info.hasEnumParameterType()) {\n           type = getEnumType(name.getString(), var, value,\n               info.getEnumParameterType().evaluate(scope, typeRegistry));\n           if (inferred) {\n             globalThis.defineInferredProperty(variableName,\n                 type == null ?\n-                    typeRegistry.getNativeType(JSTypeNative.NO_TYPE) :\n+                    getNativeType(JSTypeNative.NO_TYPE) :\n                     type,\n                 isExtern);\n           } else {\n                 /* declared iff there's an explicit supertype */\n                 superClassCtor == null ||\n                 superClassCtor.getInstanceType().equals(\n-                    typeRegistry.getNativeType(OBJECT_TYPE)));\n+                    getNativeType(OBJECT_TYPE)));\n           }\n         }\n       }\n      * @param parent The parent of n\n      */\n     @Override public void visit(NodeTraversal t, Node n, Node parent) {\n+      attachLiteralTypes(n);\n+\n       switch (n.getType()) {\n         case Token.CALL:\n           checkForClassDefiningCalls(t, n, parent);\n           FunctionParamBuilder functionParamBuilder =\n               new FunctionParamBuilder(typeRegistry);\n           functionParamBuilder.addRequiredParams(\n-              typeRegistry.getNativeType(U2U_CONSTRUCTOR_TYPE));\n+              getNativeType(U2U_CONSTRUCTOR_TYPE));\n           FunctionType findDelegate = typeRegistry.createFunctionType(\n               typeRegistry.createDefaultObjectUnion(delegateBaseObject),\n               functionParamBuilder.build());\n       typeRegistry.declareType(typedef, realType);\n       if (candidate.getType() == Token.GETPROP) {\n         defineSlot(candidate, candidate.getParent(),\n-            typeRegistry.getNativeType(NO_TYPE), false);\n+            getNativeType(NO_TYPE), false);\n       }\n     }\n \n         if (parent.getType() == Token.EXPR_RESULT) {\n           stubDeclarations.add(new StubDeclaration(\n               n, t.getInput().isExtern(), ownerName));\n-        } else if (rhsValue != null &&\n-                   rhsValue.getType() == Token.TRUE) {\n-          // We declare these for delegate proxy method properties.\n-          ObjectType ownerType = getObjectSlot(ownerName);\n-          if (ownerType instanceof FunctionType) {\n-            JSType ownerTypeOfThis = ((FunctionType) ownerType).getTypeOfThis();\n-            String delegateName = codingConvention.getDelegateSuperclassName();\n-            JSType delegateType = delegateName == null ?\n-                null : typeRegistry.getType(delegateName);\n-            if (delegateType != null &&\n-                ownerTypeOfThis.isSubtype(delegateType)) {\n-              defineSlot(n, parent, typeRegistry.getNativeType(BOOLEAN_TYPE),\n-                         true);\n-            }\n-          }\n         }\n \n         return;\n         // If the property is already declared, the error will be\n         // caught when we try to declare it in the current scope.\n         defineSlot(n, parent, valueType, inferred);\n+      } else if (rhsValue != null &&\n+          rhsValue.getType() == Token.TRUE) {\n+        // We declare these for delegate proxy method properties.\n+        ObjectType ownerType = getObjectSlot(ownerName);\n+        if (ownerType instanceof FunctionType) {\n+          JSType ownerTypeOfThis = ((FunctionType) ownerType).getTypeOfThis();\n+          String delegateName = codingConvention.getDelegateSuperclassName();\n+          JSType delegateType = delegateName == null ?\n+              null : typeRegistry.getType(delegateName);\n+          if (delegateType != null &&\n+              ownerTypeOfThis.isSubtype(delegateType)) {\n+            defineSlot(n, parent, getNativeType(BOOLEAN_TYPE),\n+                true);\n+          }\n+        }\n       }\n     }\n \n         return;\n       }\n \n+      attachLiteralTypes(n);\n       switch (n.getType()) {\n         case Token.FUNCTION:\n           // VARs and ASSIGNs are handled separately.\n--- a/test/com/google/javascript/jscomp/TypeInferenceTest.java\n+++ b/test/com/google/javascript/jscomp/TypeInferenceTest.java\n import static com.google.javascript.rhino.jstype.JSTypeNative.NUMBER_OBJECT_TYPE;\n import static com.google.javascript.rhino.jstype.JSTypeNative.NUMBER_TYPE;\n import static com.google.javascript.rhino.jstype.JSTypeNative.OBJECT_TYPE;\n-import static com.google.javascript.rhino.jstype.JSTypeNative.STRING_OBJECT_FUNCTION_TYPE;\n import static com.google.javascript.rhino.jstype.JSTypeNative.STRING_OBJECT_TYPE;\n import static com.google.javascript.rhino.jstype.JSTypeNative.STRING_TYPE;\n import static com.google.javascript.rhino.jstype.JSTypeNative.UNKNOWN_TYPE;\n \n   private void inFunction(String js) {\n     // Parse the body of the function.\n-    Node n = compiler.parseTestCode(\"function() {\" + js + \"}\");\n+    Node root = compiler.parseTestCode(\"(function() {\" + js + \"});\");\n     assertEquals(\"parsing error: \" +\n         Joiner.on(\", \").join(compiler.getErrors()),\n         0, compiler.getErrorCount());\n-    n = n.getFirstChild();\n+\n+    Node n = root.getFirstChild().getFirstChild();\n     // Create the scope with the assumptions.\n-    Scope assumedScope =\n-        new SyntacticScopeCreator(compiler).createScope(n, null);\n+    TypedScopeCreator scopeCreator = new TypedScopeCreator(compiler);\n+    Scope assumedScope = scopeCreator.createScope(\n+        n, scopeCreator.createScope(root, null));\n     for (Map.Entry<String,JSType> entry : assumptions.entrySet()) {\n       assumedScope.declare(entry.getKey(), null, entry.getValue(), null);\n     }\n \n   public void testInstanceOf1() {\n     assuming(\"x\", OBJECT_TYPE);\n-    assuming(\"String\", STRING_OBJECT_FUNCTION_TYPE);\n     inFunction(\"var y = null; if (x instanceof String) y = x;\");\n     verify(\"y\", createNullableType(STRING_OBJECT_TYPE));\n   }\n \n   public void testInstanceOf2() {\n     assuming(\"x\", createNullableType(OBJECT_TYPE));\n-    assuming(\"String\", STRING_OBJECT_FUNCTION_TYPE);\n     inFunction(\"var y = 1; if (x instanceof String) y = x;\");\n     verify(\"y\", createUnionType(STRING_OBJECT_TYPE, NUMBER_TYPE));\n   }\n \n   public void testInstanceOf3() {\n     assuming(\"x\", createUnionType(STRING_OBJECT_TYPE, NUMBER_OBJECT_TYPE));\n-    assuming(\"String\", STRING_OBJECT_FUNCTION_TYPE);\n     inFunction(\"var y = null; if (x instanceof String) y = x;\");\n     verify(\"y\", createNullableType(STRING_OBJECT_TYPE));\n   }\n \n   public void testInstanceOf4() {\n     assuming(\"x\", createUnionType(STRING_OBJECT_TYPE, NUMBER_OBJECT_TYPE));\n-    assuming(\"String\", STRING_OBJECT_FUNCTION_TYPE);\n     inFunction(\"var y = null; if (x instanceof String); else y = x;\");\n     verify(\"y\", createNullableType(NUMBER_OBJECT_TYPE));\n   }\n \n   public void testInstanceOf5() {\n     assuming(\"x\", OBJECT_TYPE);\n-    assuming(\"String\", STRING_OBJECT_FUNCTION_TYPE);\n     inFunction(\"var y = null; if (x instanceof String); else y = x;\");\n     verify(\"y\", createNullableType(OBJECT_TYPE));\n   }\n--- a/test/com/google/javascript/jscomp/TypedScopeCreatorTest.java\n+++ b/test/com/google/javascript/jscomp/TypedScopeCreatorTest.java\n import static com.google.javascript.rhino.jstype.JSTypeNative.STRING_TYPE;\n import static com.google.javascript.rhino.jstype.JSTypeNative.UNKNOWN_TYPE;\n \n+import com.google.common.base.Predicate;\n import com.google.common.collect.Lists;\n import com.google.common.collect.Sets;\n import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n import com.google.javascript.jscomp.Scope.Var;\n import com.google.javascript.jscomp.ScopeCreator;\n import com.google.javascript.rhino.Node;\n+import com.google.javascript.rhino.Token;\n import com.google.javascript.rhino.jstype.EnumType;\n import com.google.javascript.rhino.jstype.FunctionType;\n import com.google.javascript.rhino.jstype.JSType;\n import com.google.javascript.rhino.jstype.ObjectType;\n \n import java.util.Deque;\n-\n \n /**\n  * Tests for {@link TypedScopeCreator} and {@link TypeInference}. Admittedly,\n         findNameType(\"f\", globalScope).toString());\n   }\n \n-  private JSType findNameType(String name, Scope scope) {\n+  public void testLiteralTypesInferred() {\n+    testSame(\"null + true + false + 0 + '' + {}\");\n+    assertEquals(\n+        \"null\", findTokenType(Token.NULL, globalScope).toString());\n+    assertEquals(\n+        \"boolean\", findTokenType(Token.TRUE, globalScope).toString());\n+    assertEquals(\n+        \"boolean\", findTokenType(Token.FALSE, globalScope).toString());\n+    assertEquals(\n+        \"number\", findTokenType(Token.NUMBER, globalScope).toString());\n+    assertEquals(\n+        \"string\", findTokenType(Token.STRING, globalScope).toString());\n+    assertEquals(\n+        \"{}\", findTokenType(Token.OBJECTLIT, globalScope).toString());\n+  }\n+\n+  private JSType findNameType(final String name, Scope scope) {\n+    return findTypeOnMatchedNode(new Predicate<Node>() {\n+      @Override public boolean apply(Node n) {\n+        return name.equals(n.getQualifiedName());\n+      }\n+    }, scope);\n+  }\n+\n+  private JSType findTokenType(final int type, Scope scope) {\n+    return findTypeOnMatchedNode(new Predicate<Node>() {\n+      @Override public boolean apply(Node n) {\n+        return type == n.getType();\n+      }\n+    }, scope);\n+  }\n+\n+  private JSType findTypeOnMatchedNode(Predicate<Node> matcher, Scope scope) {\n     Node root = scope.getRootNode();\n     Deque<Node> queue = Lists.newLinkedList();\n     queue.push(root);\n     while (!queue.isEmpty()) {\n       Node current = queue.pop();\n-      if (name.equals(current.getQualifiedName()) &&\n+      if (matcher.apply(current) &&\n           current.getJSType() != null) {\n         return current.getJSType();\n       }", "timestamp": 1283973974, "metainfo": ""}