{"sha": "41acde3e8e5e8d37ade765b41d9fd29861f03e5e", "log": "Define number keys in object literals to be quoted string nodes. Tagged with NUMBER_PROP Fixes issue 347  R=nicksantos DELTA=229  (157 added, 19 deleted, 53 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=1252   ", "commit": "\n--- a/src/com/google/javascript/jscomp/CodeGenerator.java\n+++ b/src/com/google/javascript/jscomp/CodeGenerator.java\n         Node body = fn.getLastChild();\n \n         // Add the property name.\n-        if (TokenStream.isJSIdentifier(name) &&\n+        if (!n.isQuotedString() &&\n+            TokenStream.isJSIdentifier(name) &&\n             // do not encode literally any non-literal characters that were\n             // unicode escaped.\n             NodeUtil.isLatin(name)) {\n           add(name);\n         } else {\n-          add(jsString(n.getString(), outputCharsetEncoder));\n+          // Determine if the string is a simple number.\n+          double d = getSimpleNumber(name);\n+          if (!Double.isNaN(d)) {\n+            cc.addNumber(d);\n+          } else {\n+            add(jsString(n.getString(), outputCharsetEncoder));\n+          }\n         }\n \n         add(parameters);\n           if (c.getType() == Token.GET || c.getType() == Token.SET) {\n             add(c);\n           } else {\n-            // Object literal property names don't have to be quoted if they are\n-            // not JavaScript keywords\n-            if (c.getType() == Token.STRING &&\n-                !c.isQuotedString() &&\n-                !TokenStream.isKeyword(c.getString()) &&\n-                TokenStream.isJSIdentifier(c.getString()) &&\n-                // do not encode literally any non-literal characters that were\n-                // unicode escaped.\n-                NodeUtil.isLatin(c.getString())) {\n-              add(c.getString());\n+            Preconditions.checkState(c.getType() == Token.STRING);\n+            String key = c.getString();\n+            // Object literal property names don't have to be quoted if they\n+            // are not JavaScript keywords\n+            if (!c.isQuotedString() &&\n+                !TokenStream.isKeyword(key) &&\n+                TokenStream.isJSIdentifier(key) &&\n+                // do not encode literally any non-literal characters that\n+                // were unicode escaped.\n+                NodeUtil.isLatin(key)) {\n+              add(key);\n             } else {\n-              addExpr(c, 1);\n+              // Determine if the string is a simple number.\n+              double d = getSimpleNumber(key);\n+              if (!Double.isNaN(d)) {\n+                cc.addNumber(d);\n+              } else {\n+                addExpr(c, 1);\n+              }\n             }\n             add(\":\");\n             addExpr(c.getFirstChild(), 1);\n     }\n \n     cc.endSourceMapping(n);\n+  }\n+\n+  static boolean isSimpleNumber(String s) {\n+    int len = s.length();\n+    for (int index = 0; index < len; index++) {\n+      char c = s.charAt(index);\n+      if (c < '0' || c > '9') {\n+        return false;\n+      }\n+    }\n+    return len > 0;\n+  }\n+\n+  static double getSimpleNumber(String s) {\n+    if (isSimpleNumber(s)) {\n+      long l = Long.parseLong(s);\n+      if (l < NodeUtil.MAX_POSITIVE_INTEGER_NUMBER) {\n+        return l;\n+      }\n+    }\n+    return Double.NaN;\n   }\n \n   /**\n--- a/src/com/google/javascript/jscomp/NodeUtil.java\n+++ b/src/com/google/javascript/jscomp/NodeUtil.java\n  */\n public final class NodeUtil {\n \n+  static final long MAX_POSITIVE_INTEGER_NUMBER = (long)Math.pow(2, 53);\n+\n   final static String JSC_PROPERTY_NAME_FN = \"JSCompiler_renameProperty\";\n \n   // TODO(user): Eliminate this class and make all of the static methods\n     return TernaryValue.UNKNOWN;\n   }\n \n-\n   /**\n    * Gets the value of a node as a String, or null if it cannot be converted.\n    * When it returns a non-null String, this method effectively emulates the\n         break;\n \n       case Token.NUMBER:\n-        double value = n.getDouble();\n-        long longValue = (long) value;\n-\n-        // Return \"1\" instead of \"1.0\"\n-        if (longValue == value) {\n-          return Long.toString(longValue);\n-        } else {\n-          return Double.toString(n.getDouble());\n-        }\n+        return getStringValue(n.getDouble());\n \n       case Token.FALSE:\n       case Token.TRUE:\n         return \"[object Object]\";\n     }\n     return null;\n+  }\n+\n+  static String getStringValue(double value) {\n+    long longValue = (long) value;\n+\n+    // Return \"1\" instead of \"1.0\"\n+    if (longValue == value) {\n+      return Long.toString(longValue);\n+    } else {\n+      return Double.toString(value);\n+    }\n   }\n \n   /**\n--- a/src/com/google/javascript/jscomp/RenamePrototypes.java\n+++ b/src/com/google/javascript/jscomp/RenamePrototypes.java\n import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n+import com.google.javascript.rhino.TokenStream;\n \n import java.util.Arrays;\n import java.util.Comparator;\n                  child != null;\n                  child = child.getNext()) {\n \n-              if (child.getType() != Token.NUMBER) {\n+              if (TokenStream.isJSIdentifier(child.getString())) {\n                 markObjLitPropertyCandidate(child, t.getInput());\n               }\n             }\n \n             for (Node key = map.getFirstChild();\n                  key != null; key = key.getNext()) {\n-              if (key.getType() != Token.NUMBER) { // May be STRING, GET, or SET\n+              if (TokenStream.isJSIdentifier(key.getString())) {\n+               // May be STRING, GET, or SET\n                 markPrototypePropertyCandidate(key, input);\n               }\n             }\n--- a/src/com/google/javascript/jscomp/parsing/IRFactory.java\n+++ b/src/com/google/javascript/jscomp/parsing/IRFactory.java\n     return irNode;\n   }\n \n+  private Node transformNumberAsString(NumberLiteral literalNode) {\n+    JSDocInfo jsDocInfo = handleJsDoc(literalNode);\n+    Node irNode = newStringNode(getStringValue(literalNode.getNumber()));\n+    if (jsDocInfo != null) {\n+      irNode.setJSDocInfo(jsDocInfo);\n+    }\n+    setSourceInfo(irNode, literalNode);\n+    return irNode;\n+  }\n+\n+  private static String getStringValue(double value) {\n+    long longValue = (long) value;\n+\n+    // Return \"1\" instead of \"1.0\"\n+    if (longValue == value) {\n+      return Long.toString(longValue);\n+    } else {\n+      return Double.toString(value);\n+    }\n+  }\n+\n   private void setSourceInfo(Node irNode, AstNode node) {\n     // If we have a named function, set the position to that of the name.\n     if (irNode.getType() == Token.FUNCTION &&\n       Node ret;\n       if (n instanceof Name) {\n         ret = transformNameAsString((Name)n);\n+      } else if (n instanceof NumberLiteral) {\n+        ret = transformNumberAsString((NumberLiteral)n);\n+        ret.putBooleanProp(Node.QUOTED_PROP, true);\n       } else {\n         ret = transform(n);\n-        Preconditions.checkState(ret.getType() == Token.NUMBER\n-            || ret.getType() == Token.STRING);\n-        if (ret.getType() == Token.STRING) {\n-          ret.putBooleanProp(Node.QUOTED_PROP, true);\n-        }\n-      }\n+        ret.putBooleanProp(Node.QUOTED_PROP, true);\n+      }\n+      Preconditions.checkState(ret.getType() == Token.STRING);\n       return ret;\n     }\n \n--- a/src/com/google/javascript/rhino/Node.java\n+++ b/src/com/google/javascript/rhino/Node.java\n       DIRECT_EVAL        = 48,    // ES5 distinguishes between direct and\n                                   // indirect calls to eval.\n       FREE_CALL          = 49,    // A CALL without an explicit \"this\" value.\n-                                  //\n       LAST_PROP          = 49;\n \n   // values of ISNUMBER_PROP to specify\n         case QUOTED_PROP:        return \"quoted\";\n \n         case SYNTHETIC_BLOCK_PROP: return \"synthetic\";\n-        case EMPTY_BLOCK: return \"empty_block\";\n-        case ORIGINALNAME_PROP: return \"originalname\";\n-        case SIDE_EFFECT_FLAGS: return \"side_effect_flags\";\n+        case EMPTY_BLOCK:        return \"empty_block\";\n+        case ORIGINALNAME_PROP:  return \"originalname\";\n+        case SIDE_EFFECT_FLAGS:  return \"side_effect_flags\";\n \n         case IS_CONSTANT_NAME:   return \"is_constant_name\";\n         case IS_OPTIONAL_PARAM:  return \"is_optional_param\";\n--- a/test/com/google/javascript/jscomp/CodePrinterTest.java\n+++ b/test/com/google/javascript/jscomp/CodePrinterTest.java\n     assertPrint(\"var x={1:1}\", \"var x={1:1}\");\n   }\n \n+  public void testObjectLit2() {\n+    assertPrint(\"var x={1:1}\", \"var x={1:1}\");\n+    assertPrint(\"var x={'1':1}\", \"var x={1:1}\");\n+    assertPrint(\"var x={'1.0':1}\", \"var x={\\\"1.0\\\":1}\");\n+    assertPrint(\"var x={1.5:1}\", \"var x={\\\"1.5\\\":1}\");\n+\n+  }\n+\n+  public void testObjectLit3() {\n+    assertPrint(\"var x={3E9:1}\",\n+                \"var x={3E9:1}\");\n+    assertPrint(\"var x={'3000000000':1}\", // More than 31 bits\n+                \"var x={3E9:1}\");\n+    assertPrint(\"var x={'3000000001':1}\",\n+                \"var x={3000000001:1}\");\n+    assertPrint(\"var x={'6000000001':1}\",  // More than 32 bits\n+                \"var x={6000000001:1}\");\n+    assertPrint(\"var x={\\\"12345678901234567\\\":1}\",  // More than 53 bits\n+                \"var x={\\\"12345678901234567\\\":1}\");\n+  }\n+\n   public void testGetter() {\n     assertPrint(\"var x = {}\", \"var x={}\");\n     assertPrint(\"var x = {get a() {return 1}}\", \"var x={get a(){return 1}}\");\n       \"var x = {get a() {}, get b(){}}\",\n       \"var x={get a(){},get b(){}}\");\n \n-    // Valid ES5 but Rhino doesn't accept this yet.\n-    // assertPrint(\n-    //  \"var x = {get 1() {return 1}}\",\n-    //  \"var x={get \\\"1\\\"(){return 1}}\");\n-\n-    // Valid ES5 but Rhino doesn't accept this yet.\n-    // assertPrint(\n-    //  \"var x = {get \\\"()\\\"() {return 1}}\",\n-    //   \"var x={get \\\"()\\\"(){return 1}}\");\n+    assertPrint(\n+      \"var x = {get 'a'() {return 1}}\",\n+      \"var x={get \\\"a\\\"(){return 1}}\");\n+\n+    assertPrint(\n+      \"var x = {get 1() {return 1}}\",\n+      \"var x={get 1(){return 1}}\");\n+\n+    assertPrint(\n+      \"var x = {get \\\"()\\\"() {return 1}}\",\n+      \"var x={get \\\"()\\\"(){return 1}}\");\n   }\n \n   public void testSetter() {\n     assertPrint(\"var x = {}\", \"var x={}\");\n-    assertPrint(\"var x = {set a(x) {return 1}}\", \"var x={set a(x){return 1}}\");\n-\n-    // Valid ES5 but Rhino doesn't accept this yet.\n-    // assertPrint(\n-    //  \"var x = {set 1(x) {return 1}}\",\n-    //  \"var x={set \\\"1\\\"(x){return 1}}\");\n-\n-    // Valid ES5 but Rhino doesn't accept this yet.\n-    // assertPrint(\n-    //  \"var x = {set \\\"(x)\\\"() {return 1}}\",\n-    //   \"var x={set \\\"(x)\\\"(){return 1}}\");\n+    assertPrint(\n+       \"var x = {set a(y) {return 1}}\",\n+       \"var x={set a(y){return 1}}\");\n+\n+    assertPrint(\n+      \"var x = {get 'a'() {return 1}}\",\n+      \"var x={get \\\"a\\\"(){return 1}}\");\n+\n+    assertPrint(\n+      \"var x = {set 1(y) {return 1}}\",\n+      \"var x={set 1(y){return 1}}\");\n+\n+    assertPrint(\n+      \"var x = {set \\\"(x)\\\"(y) {return 1}}\",\n+      \"var x={set \\\"(x)\\\"(y){return 1}}\");\n   }\n \n   public void testNegCollapse() {\n--- a/test/com/google/javascript/jscomp/FunctionNamesTest.java\n+++ b/test/com/google/javascript/jscomp/FunctionNamesTest.java\n     expectedMap.put(11, \"recliteral.l1.l2\");\n     expectedMap.put(12, \"litnamed\");\n     expectedMap.put(13, \"reclitnamed\");\n-    expectedMap.put(14, \"<anonymous>\");\n-    expectedMap.put(15, \"<anonymous>\");\n+    expectedMap.put(14, \"numliteral.__2\");\n+    expectedMap.put(15, \"recnumliteral.__3.a\");\n     assertEquals(\"Function id/name mismatch\",\n                  expectedMap, idNameMap);\n   }\n--- a/test/com/google/javascript/jscomp/RenamePropertiesTest.java\n+++ b/test/com/google/javascript/jscomp/RenamePropertiesTest.java\n   }\n \n   public void testPrototypePropertiesAsObjLitKeys2() {\n-    // TODO(johnlenz): Add tests when Rhino supports numbers and quoted strings\n-    // for get and set.\n-\n-    // testSame(\"Bar.prototype = {get 2(){}}; bar[2];\");\n-\n-    // testSame(\"Bar.prototype = {get 'a'(){}}; bar['a'];\");\n+    testSame(\"Bar.prototype = {get 2(){}}; bar[2];\");\n+\n+    testSame(\"Bar.prototype = {get 'a'(){}}; bar['a'];\");\n \n     test(\"Bar.prototype = {get getA(){}}; bar.getA;\",\n          \"Bar.prototype = {get a(){}}; bar.a;\");\n   }\n \n   public void testPrototypePropertiesAsObjLitKeys3() {\n-    // TODO(johnlenz): Add tests when Rhino supports numbers and quoted strings\n-    // for get and set.\n-\n-    // testSame(\"Bar.prototype = {set 2(x){}}; bar[2];\");\n-\n-    // testSame(\"Bar.prototype = {set 'a'(x){}}; bar['a'];\");\n+    testSame(\"Bar.prototype = {set 2(x){}}; bar[2];\");\n+\n+    testSame(\"Bar.prototype = {set 'a'(x){}}; bar['a'];\");\n \n     test(\"Bar.prototype = {set getA(x){}}; bar.getA;\",\n          \"Bar.prototype = {set a(x){}}; bar.a;\");\n--- a/test/com/google/javascript/jscomp/RenamePrototypesTest.java\n+++ b/test/com/google/javascript/jscomp/RenamePrototypesTest.java\n     return 1;\n   }\n \n-  public void testRenamePrototypes() {\n+  public void testRenamePrototypes1() {\n+    test(\"Bar.prototype={'getFoo':function(){},2:function(){}}\",\n+         \"Bar.prototype={'a':function(){},2:function(){}}\");\n+  }\n+\n+  public void testRenamePrototypes2() {\n     // Simple\n     test(\"Bar.prototype.getFoo=function(){};Bar.getFoo(b);\" +\n          \"Bar.prototype.getBaz=function(){}\",\n--- a/test/com/google/javascript/jscomp/SimpleDefinitionFinderTest.java\n+++ b/test/com/google/javascript/jscomp/SimpleDefinitionFinderTest.java\n \n     checkDefinitionsInJs(\n       \"({1 : 1}); o[1]\",\n-      ImmutableSet.<String>of());\n+      ImmutableSet.<String>of(\"DEF STRING null -> NUMBER\"));\n \n     checkDefinitionsInJs(\n         \"var a = {b : 1}; a.b\",\n--- a/test/com/google/javascript/jscomp/parsing/IRFactoryTest.java\n+++ b/test/com/google/javascript/jscomp/parsing/IRFactoryTest.java\n     newParse(\"var o = {'a': 'a'}\");\n   }\n \n+  public void testObjectLiteral6() {\n+    testNewParser(\"({1: true})\",\n+      \"SCRIPT 0\\n\" +\n+      \"    EXPR_RESULT 0\\n\" +\n+      \"        OBJECTLIT 0 [parenthesized: true]\\n\" +\n+      \"            STRING 1 0 [quoted: 1]\\n\" +\n+      \"                TRUE 0\\n\");\n+  }\n+\n+  public void testObjectLiteral7() {\n+    mode = LanguageMode.ECMASCRIPT5;\n+\n+    testNewParser(\"({get 1() {}})\",\n+      \"SCRIPT 0\\n\" +\n+      \"    EXPR_RESULT 0\\n\" +\n+      \"        OBJECTLIT 0 [parenthesized: true]\\n\" +\n+      \"            GET 1 0 [quoted: 1]\\n\" +\n+      \"                FUNCTION  0\\n\" +\n+      \"                    NAME  0\\n\" +\n+      \"                    LP 0\\n\" +\n+      \"                    BLOCK 0\\n\");\n+  }\n+\n+  public void testObjectLiteral8() {\n+    mode = LanguageMode.ECMASCRIPT5;\n+\n+    testNewParser(\"({set 1(a) {}})\",\n+      \"SCRIPT 0\\n\" +\n+      \"    EXPR_RESULT 0\\n\" +\n+      \"        OBJECTLIT 0 [parenthesized: true]\\n\" +\n+      \"            SET 1 0 [quoted: 1]\\n\" +\n+      \"                FUNCTION  0\\n\" +\n+      \"                    NAME  0\\n\" +\n+      \"                    LP 0\\n\" +\n+      \"                        NAME a 0\\n\" +\n+      \"                    BLOCK 0\\n\");\n+  }\n+\n+\n   public void testKeywordLiteral() {\n     parse(\"true\");\n   }\n--- a/test/com/google/javascript/jscomp/parsing/ParserTest.java\n+++ b/test/com/google/javascript/jscomp/parsing/ParserTest.java\n     assertEquals(Token.OBJECTLIT, objectLit.getType());\n \n     Node number = objectLit.getFirstChild();\n-    assertEquals(Token.NUMBER, number.getType());\n+    assertEquals(Token.STRING, number.getType());\n     assertNotNull(number.getJSDocInfo());\n   }\n \n \n   public void testGetter() {\n     mode = LanguageMode.ECMASCRIPT3;\n+    parseError(\"var x = {get 1(){}};\",\n+        \"getters are not supported in Internet Explorer\");\n+    parseError(\"var x = {get 'a'(){}};\",\n+        \"getters are not supported in Internet Explorer\");\n     parseError(\"var x = {get a(){}};\",\n         \"getters are not supported in Internet Explorer\");\n     mode = LanguageMode.ECMASCRIPT5;\n+    parse(\"var x = {get 1(){}};\");\n+    parse(\"var x = {get 'a'(){}};\");\n     parse(\"var x = {get a(){}};\");\n     parseError(\"var x = {get a(b){}};\", \"getters may not have parameters\");\n   }\n \n   public void testSetter() {\n     mode = LanguageMode.ECMASCRIPT3;\n+    parseError(\"var x = {set 1(x){}};\",\n+        \"setters are not supported in Internet Explorer\");\n+    parseError(\"var x = {set 'a'(x){}};\",\n+        \"setters are not supported in Internet Explorer\");\n     parseError(\"var x = {set a(x){}};\",\n         \"setters are not supported in Internet Explorer\");\n     mode = LanguageMode.ECMASCRIPT5;\n+    parse(\"var x = {set 1(x){}};\");\n+    parse(\"var x = {set 'a'(x){}};\");\n     parse(\"var x = {set a(x){}};\");\n     parseError(\"var x = {set a(){}};\",\n         \"setters must have exactly one parameter\");", "timestamp": 1301952393, "metainfo": ""}