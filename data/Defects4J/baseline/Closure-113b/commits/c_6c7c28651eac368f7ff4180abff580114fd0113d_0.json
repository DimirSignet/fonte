{"sha": "6c7c28651eac368f7ff4180abff580114fd0113d", "log": "More typos and stuff. Fixes issue 734  R=nicksantos   Revision created by MOE tool push_codebase. MOE_MIGRATION=4844   ", "commit": "\n--- a/src/com/google/javascript/jscomp/AliasExternals.java\n+++ b/src/com/google/javascript/jscomp/AliasExternals.java\n  * <p>Globals are aliased by inserting code like \"var GLOBAL_window = window;\"\n  * and then replacing all other uses of \"window\" with \"GLOBAL_window.\"</p>\n  *\n- * <p>Globals that are lvalues are not aliased.</p>\n+ * <p>Globals that are l-values are not aliased.</p>\n  *\n  */\n class AliasExternals implements CompilerPass {\n \n-  /** Number of times a proprety needs to be accessed in order to alias */\n+  /** Number of times a property needs to be accessed in order to alias */\n   private static final int DEFAULT_REQUIRED_USAGE = 4;\n \n   /** Number of times a property must be referenced in order to be aliased */\n   private int requiredUsage = DEFAULT_REQUIRED_USAGE;\n \n-  /** Minimium property size to be worth renaming */\n+  /** Minimum property size to be worth renaming */\n   private static final int MIN_PROP_SIZE = 4;\n \n   /**\n--- a/src/com/google/javascript/jscomp/DefinitionsRemover.java\n+++ b/src/com/google/javascript/jscomp/DefinitionsRemover.java\n     @Override\n     public Node getLValue() {\n       // TODO(user) revisit: object literal definitions are an example\n-      // of definitions whose lhs doesn't correspond to a node that\n+      // of definitions whose LHS doesn't correspond to a node that\n       // exists in the AST.  We will have to change the return type of\n       // getLValue sooner or later in order to provide this added\n       // flexibility.\n--- a/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java\n+++ b/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java\n         }\n \n         // TODO(user): We only care about calls to functions that\n-        // passes one of the dependent variable to a non-sideeffect free\n+        // passes one of the dependent variable to a non-side-effect free\n         // function.\n         if (n.isCall() && NodeUtil.functionCallHasSideEffects(n)) {\n           return true;\n       }\n \n \n-      // TODO(user): Side-effect is ok sometimes. As long as there are no\n+      // TODO(user): Side-effect is OK sometimes. As long as there are no\n       // side-effect function down all paths to the use. Once we have all the\n       // side-effect analysis tool.\n       if (NodeUtil.mayHaveSideEffects(def.getLastChild())) {\n--- a/src/com/google/javascript/jscomp/MaybeReachingVariableUse.java\n+++ b/src/com/google/javascript/jscomp/MaybeReachingVariableUse.java\n     this.jsScope = jsScope;\n     this.escaped = Sets.newHashSet();\n \n-    // TODO(user): May be comute it somewhere else and re-use the escape\n+    // TODO(user): Maybe compute it somewhere else and re-use the escape\n     // local set here.\n     computeEscaped(jsScope, escaped, compiler);\n   }\n--- a/src/com/google/javascript/jscomp/MustBeReachingVariableDef.java\n+++ b/src/com/google/javascript/jscomp/MustBeReachingVariableDef.java\n             Node obj = n.getFirstChild().getFirstChild();\n             if (obj.isName() && \"arguments\".equals(obj.getString())) {\n               // TODO(user): More accuracy can be introduced\n-              // ie: We know exactly what arguments[x] is if x is a constant\n+              // i.e. We know exactly what arguments[x] is if x is a constant\n               // number.\n               escapeParameters(output);\n             }\n--- a/src/com/google/javascript/jscomp/StripCode.java\n+++ b/src/com/google/javascript/jscomp/StripCode.java\n class StripCode implements CompilerPass {\n \n   // TODO(user): Try eliminating the need for a list of strip names by instead\n-  // recording which field names are assigned to debug types in each js input.\n+  // recording which field names are assigned to debug types in each JS input.\n   private final AbstractCompiler compiler;\n   private final Set<String> stripTypes;\n   private final Set<String> stripNameSuffixes;\n--- a/src/com/google/javascript/jscomp/TightenTypes.java\n+++ b/src/com/google/javascript/jscomp/TightenTypes.java\n \n     // Keep all function types, as restricting to instantiated types will only\n     // keep instance types.\n-    // TODO(user): only keep functions that match the js type.\n+    // TODO(user): only keep functions that match the JS type.\n     for (ConcreteFunctionType functionType : concreteType.getFunctions()) {\n       ret = ret.unionWith(functionType);\n     }\n--- a/src/com/google/javascript/jscomp/TransformAMDToCJSModule.java\n+++ b/src/com/google/javascript/jscomp/TransformAMDToCJSModule.java\n \n /**\n  * Rewrites an AMD module https://github.com/amdjs/amdjs-api/wiki/AMD to a\n- * Common JS module. See {@link ProcessCommonJSModules} for follow up processing\n+ * CommonJS module. See {@link ProcessCommonJSModules} for follow up processing\n  * step.\n  */\n class TransformAMDToCJSModule implements CompilerPass {\n--- a/src/com/google/javascript/jscomp/TypedScopeCreator.java\n+++ b/src/com/google/javascript/jscomp/TypedScopeCreator.java\n       }\n \n       // TODO(nicksantos|user): This is a terrible, terrible hack\n-      // to bail out on recusive typedefs. We'll eventually need\n+      // to bail out on recursive typedefs. We'll eventually need\n       // to handle these properly.\n       typeRegistry.declareType(typedef, getNativeType(UNKNOWN_TYPE));\n \n--- a/src/com/google/javascript/rhino/ErrorReporter.java\n+++ b/src/com/google/javascript/rhino/ErrorReporter.java\n      *\n      * @param message a String describing the warning\n      * @param sourceName a String describing the JavaScript source\n-     * where the warning occured; typically a filename or URL\n+     * where the warning occurred; typically a filename or URL\n      * @param line the line number associated with the warning\n      * @param lineOffset the offset into lineSource where problem was detected\n      */\n      *\n      * @param message a String describing the error\n      * @param sourceName a String describing the JavaScript source\n-     * where the error occured; typically a filename or URL\n+     * where the error occurred; typically a filename or URL\n      * @param line the line number associated with the error\n      * @param lineOffset the offset into lineSource where problem was detected\n      */\n--- a/src/com/google/javascript/rhino/JSDocInfo.java\n+++ b/src/com/google/javascript/rhino/JSDocInfo.java\n   private static final int MASK_IMPLICITCAST  = 0x00002000; // @implicitCast\n   private static final int MASK_NOSIDEEFFECTS = 0x00004000; // @nosideeffects\n   private static final int MASK_EXTERNS       = 0x00008000; // @externs\n-  private static final int MASK_JAVADISPATCH  = 0x00010000; // @javadispath\n+  private static final int MASK_JAVADISPATCH  = 0x00010000; // @javadispatch\n   private static final int MASK_NOCOMPILE     = 0x00020000; // @nocompile\n   // @consistentIdGenerator\n   private static final int MASK_CONSISTIDGEN  = 0x00040000;\n   }\n \n   /**\n-   * Returns whether the {@code @javadispath} annotation is present on this\n+   * Returns whether the {@code @javadispatch} annotation is present on this\n    * {@link JSDocInfo}.\n    */\n   public boolean isJavaDispatch() {\n--- a/src/com/google/javascript/rhino/JSTypeExpression.java\n+++ b/src/com/google/javascript/rhino/JSTypeExpression.java\n \n \n /**\n- * Represents a type expression as a miniture Rhino AST, so that the\n+ * Represents a type expression as a miniature Rhino AST, so that the\n  * type expression can be evaluated later.\n  *\n  * @author nicksantos@google.com (Nick Santos)\n--- a/src/com/google/javascript/rhino/Node.java\n+++ b/src/com/google/javascript/rhino/Node.java\n \n   /**\n    * Clone the properties from the provided node without copying\n-   * the property object.  The recieving node may not have any\n+   * the property object.  The receiving node may not have any\n    * existing properties.\n    * @param other The node to clone properties from.\n    * @return this node.\n   // Iteration\n \n   /**\n-   * <p>Return an iterable object that iterates over this nodes's children.\n+   * <p>Return an iterable object that iterates over this node's children.\n    * The iterator does not support the optional operation\n    * {@link Iterator#remove()}.</p>\n    *\n   }\n \n   /**\n-   * <p>Return an iterable object that iterates over this nodes's siblings.\n+   * <p>Return an iterable object that iterates over this node's siblings.\n    * The iterator does not support the optional operation\n    * {@link Iterator#remove()}.</p>\n    *\n   /**\n    * An inner class that provides back-door access to the license\n    * property of the JSDocInfo property for this node. This is only\n-   * meant to be used for top level script nodes where the\n+   * meant to be used for top-level script nodes where the\n    * {@link com.google.javascript.jscomp.parsing.JsDocInfoParser} needs to\n-   * be able to append directly to the top level node, not just the\n+   * be able to append directly to the top-level node, not just the\n    * current node.\n    */\n   public class FileLevelJsDocBuilder {\n--- a/src/com/google/javascript/rhino/ScriptRuntime.java\n+++ b/src/com/google/javascript/rhino/ScriptRuntime.java\n import java.util.ResourceBundle;\n \n /**\n- * This is the class that implements the runtime.\n+ * This is the class that implements the run-time.\n  *\n  */\n \n \n     // It is public so NativeRegExp can access it .\n     public static boolean isJSLineTerminator(int c) {\n-        // Optimization for faster check for eol character:\n+        // Optimization for faster check for EOL character:\n         // they do not have 0xDFD0 bits set\n         if ((c & 0xDFD0) != 0) {\n             return false;\n \n     /**\n      * If str is a decimal presentation of Uint32 value, return it as long.\n-     * Othewise return -1L;\n+     * Otherwise, return -1L;\n      */\n     public static long testUint32String(String str) {\n         // The length of the decimal string representation of\n         return getMessage(messageId, arguments);\n     }\n \n-    /* OPT there's a noticable delay for the first error!  Maybe it'd\n+    /* OPT there's a noticeable delay for the first error!  Maybe it'd\n      * make sense to use a ListResourceBundle instead of a properties\n      * file to avoid (synchronized) text parsing.\n      */\n \n         Locale locale = Locale.getDefault();\n \n-        // ResourceBundle does cacheing.\n+        // ResourceBundle does caching.\n         ResourceBundle rb = ResourceBundle.getBundle(defaultResource, locale);\n \n         String formatString;\n--- a/src/com/google/javascript/rhino/TokenStream.java\n+++ b/src/com/google/javascript/rhino/TokenStream.java\n                 break partial;\n             case 12: X=\"synchronized\";id=true; break partial;\n             }\n-            // patial match validate the entire string the one possiblity\n+            // partial match validate the entire string the one possibility\n             if (X!=null && X!=s && !X.equals(s)) return false;\n         }\n         return id;\n--- a/src/com/google/javascript/rhino/jstype/ArrowType.java\n+++ b/src/com/google/javascript/rhino/jstype/ArrowType.java\n \n /**\n  * The arrow type is an internal type that models the functional arrow type\n- * seen in typical functional programming languages.  It is used soley for\n+ * seen in typical functional programming languages.  It is used solely for\n  * separating the management of the arrow type from the complex\n  * {@link FunctionType} that models JavaScript's notion of functions.\n  */\n       }\n     }\n \n-    // \"that\" can't be a supertype, because it's missing a required arguement.\n+    // \"that\" can't be a supertype, because it's missing a required argument.\n     if (thisParam != null\n         && !thisParam.isOptionalArg() && !thisParam.isVarArgs()\n         && thatParam == null) {\n--- a/src/com/google/javascript/rhino/jstype/FunctionParamBuilder.java\n+++ b/src/com/google/javascript/rhino/jstype/FunctionParamBuilder.java\n   /**\n    * Add optional parameters of the given type to the end of the param list.\n    * @param types Types for each optional parameter. The builder will make them\n-   *     undefineable.\n+   *     undefine-able.\n    * @return False if this is called after var args are added.\n    */\n   public boolean addOptionalParams(JSType ...types) {\n--- a/src/com/google/javascript/rhino/jstype/FunctionType.java\n+++ b/src/com/google/javascript/rhino/jstype/FunctionType.java\n   private List<ObjectType> implementedInterfaces = ImmutableList.of();\n \n   /**\n-   * The interfaces directly extendeded by this function (for interfaces)\n+   * The interfaces directly extended by this function (for interfaces)\n    * It is only relevant for constructors. May not be {@code null}.\n    */\n   private List<ObjectType> extendedInterfaces = ImmutableList.of();\n         // Define the \"apply\" function lazily.\n         FunctionParamBuilder builder = new FunctionParamBuilder(registry);\n \n-        // Ecma-262 says that apply's second argument must be an Array\n+        // ECMA-262 says that apply's second argument must be an Array\n         // or an arguments object. We don't model the arguments object,\n         // so let's just be forgiving for now.\n         // TODO(nicksantos): Model the Arguments object.\n    * Because sup() and inf() share a lot of logic for functions, we use\n    * a single helper.\n    * @param leastSuper If true, compute the supremum of {@code this} with\n-   *     {@code that}. Otherwise compute the infimum.\n+   *     {@code that}. Otherwise, compute the infimum.\n    * @return The least supertype or greatest subtype.\n    */\n   FunctionType supAndInfHelper(FunctionType that, boolean leastSuper) {\n   private void appendVarArgsString(StringBuilder builder, JSType paramType,\n       boolean forAnnotations) {\n     if (paramType.isUnionType()) {\n-      // Remove the optionalness from the var arg.\n+      // Remove the optionality from the var arg.\n       paramType = paramType.toMaybeUnionType().getRestrictedUnion(\n           registry.getNativeType(JSTypeNative.VOID_TYPE));\n     }\n   private void appendOptionalArgString(\n       StringBuilder builder, JSType paramType, boolean forAnnotations) {\n     if (paramType.isUnionType()) {\n-      // Remove the optionalness from the var arg.\n+      // Remove the optionality from the var arg.\n       paramType = paramType.toMaybeUnionType().getRestrictedUnion(\n           registry.getNativeType(JSTypeNative.VOID_TYPE));\n     }\n     //\n     // TODO(nicksantos): Handle this correctly if we have a UnionType.\n     //\n-    // TODO(nicksantos): In ES3, the runtime coerces \"null\" to the global\n+    // TODO(nicksantos): In ES3, the run-time coerces \"null\" to the global\n     // activation object. In ES5, it leaves it as null. Just punt on this\n     // issue for now by coercing out null. This is complicated by the\n     // fact that when most people write @this {Foo}, they really don't\n--- a/src/com/google/javascript/rhino/jstype/JSType.java\n+++ b/src/com/google/javascript/rhino/jstype/JSType.java\n   }\n \n   /**\n-   * When computing infimums, we may get a situation like\n+   * When computing infima, we may get a situation like\n    * inf(Type1, Type2)\n    * where both types are unresolved, so they're technically\n    * subtypes of one another.\n    * Modify this type so that it matches the specified type.\n    *\n    * This is useful for reverse type-inference, where we want to\n-   * infer that an object literal matches its contraint (much like\n+   * infer that an object literal matches its constraint (much like\n    * how the java compiler does reverse-inference to figure out generics).\n    */\n-  public void matchConstraint(ObjectType contraint) {}\n+  public void matchConstraint(ObjectType constraint) {}\n }\n--- a/src/com/google/javascript/rhino/jstype/JSTypeRegistry.java\n+++ b/src/com/google/javascript/rhino/jstype/JSTypeRegistry.java\n \n   /**\n    * Tells the type system that {@code type} implements interface {@code\n-   * InterfaceInstance}.\n+   * interfaceInstance}.\n    * {@code inter} must be an ObjectType for the instance of the interface as it\n    * could be a named type and not yet have the constructor.\n    */\n   }\n \n   /**\n-   * Flushes out the current resolved and unresovled Named Types from\n+   * Flushes out the current resolved and unresolved Named Types from\n    * the type registry.  This is intended to be used ONLY before a\n    * compile is run.\n    */\n   }\n \n   /**\n-   * Creates a nullabel and undefine-able value of the given type.\n+   * Creates a nullable and undefine-able value of the given type.\n    * @return The union of the type and null and undefined.\n    */\n   public JSType createOptionalNullableType(JSType type) {\n   }\n \n   /**\n-   * Creates a union type whose variants are the builtin types specified\n+   * Creates a union type whose variants are the built-in types specified\n    * by the arguments.\n    */\n   public JSType createUnionType(JSTypeNative... variants) {\n   }\n \n   /**\n-   * Creates a parameterized type.\n+   * Creates a parametrized type.\n    */\n   public ParameterizedType createParameterizedType(\n       ObjectType objectType, JSType parameterType) {\n--- a/src/com/google/javascript/rhino/jstype/NamedType.java\n+++ b/src/com/google/javascript/rhino/jstype/NamedType.java\n  * A {@code NamedType} is a named reference to some other type.  This provides\n  * a convenient mechanism for implementing forward references to types; a\n  * {@code NamedType} can be used as a placeholder until its reference is\n- * resolved.  It is also useful for representing type names in jsdoc type\n+ * resolved.  It is also useful for representing type names in JsDoc type\n  * annotations, some of which may never be resolved (as they may refer to\n  * types in host systems not yet supported by JSCompiler, such as the JVM.)<p>\n  *\n--- a/src/com/google/javascript/rhino/jstype/ObjectType.java\n+++ b/src/com/google/javascript/rhino/jstype/ObjectType.java\n \n   /**\n    * Gets the interfaces extended by the interface associated with this type.\n-   * Intended to be overriden by subclasses.\n+   * Intended to be overridden by subclasses.\n    */\n   public Iterable<ObjectType> getCtorExtendedInterfaces() {\n     return ImmutableSet.of();\n--- a/src/com/google/javascript/rhino/jstype/ParameterizedType.java\n+++ b/src/com/google/javascript/rhino/jstype/ParameterizedType.java\n  * An object type with a declared default element type, such as\n  * <code>Array.<string></code>.\n  *\n- * // TODO(user): Define the subtyping relation for parameterized types. Also,\n- * take parameterized type into account for equality.\n+ * // TODO(user): Define the subtyping relation for parametrized types. Also,\n+ * take parametrized type into account for equality.\n  *\n  */\n final class ParameterizedType extends ProxyObjectType {\n--- a/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java\n+++ b/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java\n   private final boolean nativeType;\n \n   // NOTE(nicksantos): The implicit prototype can change over time.\n-  // Modelling this is a bear. Always call getImplicitPrototype(), because\n+  // Modeling this is a bear. Always call getImplicitPrototype(), because\n   // some subclasses override this to do special resolution handling.\n   private ObjectType implicitPrototypeFallback;\n \n         name, type, inferred, propertyNode);\n     Property oldProp = properties.get(name);\n     if (oldProp != null) {\n-      // This is to keep previously inferred jsdoc info, e.g., in a\n+      // This is to keep previously inferred JsDoc info, e.g., in a\n       // replaceScript scenario.\n       newProp.setJSDocInfo(oldProp.getJSDocInfo());\n     }\n \n   @Override\n   public void matchConstraint(ObjectType constraintObj) {\n-    // We only want to match contraints on anonymous types.\n+    // We only want to match constraints on anonymous types.\n     if (hasReferenceName()) {\n       return;\n     }\n--- a/src/com/google/javascript/rhino/jstype/ProxyObjectType.java\n+++ b/src/com/google/javascript/rhino/jstype/ProxyObjectType.java\n   }\n \n   @Override\n-  public void matchConstraint(ObjectType contraint) {\n-    referencedType.matchConstraint(contraint);\n+  public void matchConstraint(ObjectType constraint) {\n+    referencedType.matchConstraint(constraint);\n   }\n }\n--- a/src/com/google/javascript/rhino/jstype/StaticScope.java\n+++ b/src/com/google/javascript/rhino/jstype/StaticScope.java\n  * The {@code StaticScope} interface must be implemented by any object that\n  * defines variables for the purposes of static analysis.  It is distinguished\n  * from the {@code Scriptable} class that Rhino normally uses to represent a\n- * runtime scope.\n+ * run-time scope.\n  *\n  * @param <T> The type of information stored about the slot\n  */\n--- a/src/com/google/javascript/rhino/jstype/TernaryValue.java\n+++ b/src/com/google/javascript/rhino/jstype/TernaryValue.java\n  * <p>A ternary value expression evaluates to {@link #TRUE} or\n  * {@link #FALSE} only if all replacements of {@link #UNKNOWN} in this\n  * expression yield the same result. Therefore, the ternary logic coincides\n- * with typical boolean logic if the {@link #UNKNOWN} value is not\n+ * with typical Boolean logic if the {@link #UNKNOWN} value is not\n  * present in an expression.</p>\n  *\n  * @see <a href=\"http://en.wikipedia.org/wiki/Ternary_logic\">Ternary Logic</a>\n--- a/src/com/google/javascript/rhino/jstype/UnionType.java\n+++ b/src/com/google/javascript/rhino/jstype/UnionType.java\n /**\n  * The {@code UnionType} implements a common JavaScript idiom in which the\n  * code is specifically designed to work with multiple input types.  Because\n- * JavaScript always knows the runtime type of an object value, this is safer\n+ * JavaScript always knows the run-time type of an object value, this is safer\n  * than a C union.<p>\n  *\n  * For instance, values of the union type {@code (String,boolean)} can be of\n--- a/src/com/google/javascript/rhino/jstype/UnionTypeBuilder.java\n+++ b/src/com/google/javascript/rhino/jstype/UnionTypeBuilder.java\n         }\n \n         // Function types are special, because they have their\n-        // own bizarro sub-lattice. See the commants on\n+        // own bizarre sub-lattice. See the comments on\n         // FunctionType#supAndInf helper and above at functionTypePosition.\n         if (alternate.isFunctionType() && functionTypePosition != -1) {\n           // See the comments on functionTypePosition above.\n--- a/src/com/google/javascript/rhino/testing/BaseJSTypeTestCase.java\n+++ b/src/com/google/javascript/rhino/testing/BaseJSTypeTestCase.java\n \n   /**\n    * A definition of all extern types. This should be kept in sync with\n-   * javascript/externs/es3.js. This is used to check that the builtin types\n+   * javascript/externs/es3.js. This is used to check that the built-in types\n    * declared in {@link JSTypeRegistry} have the same type as that in the\n-   * externs. It can also be used for any tests that want to use builtin types\n+   * externs. It can also be used for any tests that want to use built-in types\n    * in their externs.\n    */\n   public static final String ALL_NATIVE_EXTERN_TYPES =\n--- a/test/com/google/javascript/jscomp/TypeCheckTest.java\n+++ b/test/com/google/javascript/jscomp/TypeCheckTest.java\n         \"found   : function (string): undefined\\n\" +\n         \"required: function (boolean): undefined\");\n     // TODO(user): suppress {duplicate} currently also silence the\n-    // redefining type error in the TypeValidator. May be it needs\n+    // redefining type error in the TypeValidator. Maybe it needs\n     // a new suppress name instead?\n   }\n \n--- a/test/com/google/javascript/rhino/jstype/JSTypeTest.java\n+++ b/test/com/google/javascript/rhino/jstype/JSTypeTest.java\n   }\n \n   /**\n-   * Tests the behavior of the Bottom Object yype.\n+   * Tests the behavior of the Bottom Object type.\n    */\n   public void testNoObjectType() throws Exception {\n     // isXxx\n   }\n \n   /**\n-   * Tests the getGreastestSubtype method for record types.\n+   * Tests the getGreatestSubtype method for record types.\n    */\n   public void testRecordTypeGreatestSubType1() {\n     RecordTypeBuilder builder = new RecordTypeBuilder(registry);\n     assertEquals(NATIVE_PROPERTIES_COUNT + 1, instance.getPropertiesCount());\n   }\n \n-  /** Tests assigning jsdoc on a prototype property. */\n+  /** Tests assigning JsDoc on a prototype property. */\n   public void testJSDocOnPrototypeProperty() throws Exception {\n     subclassCtor.setPropertyJSDocInfo(\"prototype\", new JSDocInfo());\n     assertNull(subclassCtor.getOwnPropertyJSDocInfo(\"prototype\"));\n     assertTypeEquals(CHECKED_UNKNOWN_TYPE, expected);\n   }\n \n-  /** Tests the subclass of an unresolve named type */\n+  /** Tests the subclass of an unresolved named type */\n   public void testSubclassOfUnresolvedNamedType() {\n     assertTrue(subclassOfUnresolvedNamedType.isUnknownType());\n   }", "timestamp": 1337727640, "metainfo": ""}