{"sha": "a2715a52745d816a87c05d3007ed8bfe7ef18491", "log": "delete all trailing whitespace fix up the presubmit to skip generated files  R=johnlenz   Revision created by MOE tool push_codebase. MOE_MIGRATION=822   ", "commit": "\n--- a/gen/com/google/javascript/jscomp/FunctionInfo.java\n+++ b/gen/com/google/javascript/jscomp/FunctionInfo.java\n   static\n     com.google.protobuf.GeneratedMessage.FieldAccessorTable\n       internal_static_jscomp_FunctionInformationMap_Module_fieldAccessorTable;\n-  \n+\n   public static com.google.protobuf.Descriptors.FileDescriptor\n       getDescriptor() {\n     return descriptor;\n         new com.google.protobuf.Descriptors.FileDescriptor[] {\n         }, assigner);\n   }\n-  \n+\n   public static void internalForceInit() {}\n-  \n+\n   // @@protoc_insertion_point(outer_class_scope)\n }\n--- a/gen/com/google/javascript/jscomp/FunctionInformationMap.java\n+++ b/gen/com/google/javascript/jscomp/FunctionInformationMap.java\n     initFields();\n   }\n   private FunctionInformationMap(boolean noInit) {}\n-  \n+\n   private static final FunctionInformationMap defaultInstance;\n   public static FunctionInformationMap getDefaultInstance() {\n     return defaultInstance;\n   }\n-  \n+\n   public FunctionInformationMap getDefaultInstanceForType() {\n     return defaultInstance;\n   }\n-  \n+\n   public static final com.google.protobuf.Descriptors.Descriptor\n       getDescriptor() {\n     return com.google.javascript.jscomp.FunctionInfo.internal_static_jscomp_FunctionInformationMap_descriptor;\n   }\n-  \n+\n   protected com.google.protobuf.GeneratedMessage.FieldAccessorTable\n       internalGetFieldAccessorTable() {\n     return com.google.javascript.jscomp.FunctionInfo.internal_static_jscomp_FunctionInformationMap_fieldAccessorTable;\n   }\n-  \n+\n   public static final class Entry extends\n       com.google.protobuf.GeneratedMessage {\n     // Use Entry.newBuilder() to construct.\n       initFields();\n     }\n     private Entry(boolean noInit) {}\n-    \n+\n     private static final Entry defaultInstance;\n     public static Entry getDefaultInstance() {\n       return defaultInstance;\n     }\n-    \n+\n     public Entry getDefaultInstanceForType() {\n       return defaultInstance;\n     }\n-    \n+\n     public static final com.google.protobuf.Descriptors.Descriptor\n         getDescriptor() {\n       return com.google.javascript.jscomp.FunctionInfo.internal_static_jscomp_FunctionInformationMap_Entry_descriptor;\n     }\n-    \n+\n     protected com.google.protobuf.GeneratedMessage.FieldAccessorTable\n         internalGetFieldAccessorTable() {\n       return com.google.javascript.jscomp.FunctionInfo.internal_static_jscomp_FunctionInformationMap_Entry_fieldAccessorTable;\n     }\n-    \n+\n     // required int32 id = 2;\n     public static final int ID_FIELD_NUMBER = 2;\n     private boolean hasId;\n     private int id_ = 0;\n     public boolean hasId() { return hasId; }\n     public int getId() { return id_; }\n-    \n+\n     // required string source_name = 3;\n     public static final int SOURCE_NAME_FIELD_NUMBER = 3;\n     private boolean hasSourceName;\n     private java.lang.String sourceName_ = \"\";\n     public boolean hasSourceName() { return hasSourceName; }\n     public java.lang.String getSourceName() { return sourceName_; }\n-    \n+\n     // required int32 line_number = 4;\n     public static final int LINE_NUMBER_FIELD_NUMBER = 4;\n     private boolean hasLineNumber;\n     private int lineNumber_ = 0;\n     public boolean hasLineNumber() { return hasLineNumber; }\n     public int getLineNumber() { return lineNumber_; }\n-    \n+\n     // required string module_name = 5;\n     public static final int MODULE_NAME_FIELD_NUMBER = 5;\n     private boolean hasModuleName;\n     private java.lang.String moduleName_ = \"\";\n     public boolean hasModuleName() { return hasModuleName; }\n     public java.lang.String getModuleName() { return moduleName_; }\n-    \n+\n     // required int32 size = 6;\n     public static final int SIZE_FIELD_NUMBER = 6;\n     private boolean hasSize;\n     private int size_ = 0;\n     public boolean hasSize() { return hasSize; }\n     public int getSize() { return size_; }\n-    \n+\n     // required string name = 7;\n     public static final int NAME_FIELD_NUMBER = 7;\n     private boolean hasName;\n     private java.lang.String name_ = \"\";\n     public boolean hasName() { return hasName; }\n     public java.lang.String getName() { return name_; }\n-    \n+\n     // required string compiled_source = 8;\n     public static final int COMPILED_SOURCE_FIELD_NUMBER = 8;\n     private boolean hasCompiledSource;\n     private java.lang.String compiledSource_ = \"\";\n     public boolean hasCompiledSource() { return hasCompiledSource; }\n     public java.lang.String getCompiledSource() { return compiledSource_; }\n-    \n+\n     private void initFields() {\n     }\n     public final boolean isInitialized() {\n       if (!hasCompiledSource) return false;\n       return true;\n     }\n-    \n+\n     public void writeTo(com.google.protobuf.CodedOutputStream output)\n                         throws java.io.IOException {\n       getSerializedSize();\n       }\n       getUnknownFields().writeTo(output);\n     }\n-    \n+\n     private int memoizedSerializedSize = -1;\n     public int getSerializedSize() {\n       int size = memoizedSerializedSize;\n       if (size != -1) return size;\n-    \n+\n       size = 0;\n       if (hasId()) {\n         size += com.google.protobuf.CodedOutputStream\n       memoizedSerializedSize = size;\n       return size;\n     }\n-    \n+\n     public static com.google.javascript.jscomp.FunctionInformationMap.Entry parseFrom(\n         com.google.protobuf.ByteString data)\n         throws com.google.protobuf.InvalidProtocolBufferException {\n       return newBuilder().mergeFrom(input, extensionRegistry)\n                .buildParsed();\n     }\n-    \n+\n     public static Builder newBuilder() { return Builder.create(); }\n     public Builder newBuilderForType() { return newBuilder(); }\n     public static Builder newBuilder(com.google.javascript.jscomp.FunctionInformationMap.Entry prototype) {\n       return newBuilder().mergeFrom(prototype);\n     }\n     public Builder toBuilder() { return newBuilder(this); }\n-    \n+\n     public static final class Builder extends\n         com.google.protobuf.GeneratedMessage.Builder<Builder> {\n       private com.google.javascript.jscomp.FunctionInformationMap.Entry result;\n-      \n+\n       // Construct using com.google.javascript.jscomp.FunctionInformationMap.Entry.newBuilder()\n       private Builder() {}\n-      \n+\n       private static Builder create() {\n         Builder builder = new Builder();\n         builder.result = new com.google.javascript.jscomp.FunctionInformationMap.Entry();\n         return builder;\n       }\n-      \n+\n       protected com.google.javascript.jscomp.FunctionInformationMap.Entry internalGetResult() {\n         return result;\n       }\n-      \n+\n       public Builder clear() {\n         if (result == null) {\n           throw new IllegalStateException(\n         result = new com.google.javascript.jscomp.FunctionInformationMap.Entry();\n         return this;\n       }\n-      \n+\n       public Builder clone() {\n         return create().mergeFrom(result);\n       }\n-      \n+\n       public com.google.protobuf.Descriptors.Descriptor\n           getDescriptorForType() {\n         return com.google.javascript.jscomp.FunctionInformationMap.Entry.getDescriptor();\n       }\n-      \n+\n       public com.google.javascript.jscomp.FunctionInformationMap.Entry getDefaultInstanceForType() {\n         return com.google.javascript.jscomp.FunctionInformationMap.Entry.getDefaultInstance();\n       }\n-      \n+\n       public boolean isInitialized() {\n         return result.isInitialized();\n       }\n         }\n         return buildPartial();\n       }\n-      \n+\n       private com.google.javascript.jscomp.FunctionInformationMap.Entry buildParsed()\n           throws com.google.protobuf.InvalidProtocolBufferException {\n         if (!isInitialized()) {\n         }\n         return buildPartial();\n       }\n-      \n+\n       public com.google.javascript.jscomp.FunctionInformationMap.Entry buildPartial() {\n         if (result == null) {\n           throw new IllegalStateException(\n         result = null;\n         return returnMe;\n       }\n-      \n+\n       public Builder mergeFrom(com.google.protobuf.Message other) {\n         if (other instanceof com.google.javascript.jscomp.FunctionInformationMap.Entry) {\n           return mergeFrom((com.google.javascript.jscomp.FunctionInformationMap.Entry)other);\n           return this;\n         }\n       }\n-      \n+\n       public Builder mergeFrom(com.google.javascript.jscomp.FunctionInformationMap.Entry other) {\n         if (other == com.google.javascript.jscomp.FunctionInformationMap.Entry.getDefaultInstance()) return this;\n         if (other.hasId()) {\n         this.mergeUnknownFields(other.getUnknownFields());\n         return this;\n       }\n-      \n+\n       public Builder mergeFrom(\n           com.google.protobuf.CodedInputStream input,\n           com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n           }\n         }\n       }\n-      \n-      \n+\n+\n       // required int32 id = 2;\n       public boolean hasId() {\n         return result.hasId();\n         result.id_ = 0;\n         return this;\n       }\n-      \n+\n       // required string source_name = 3;\n       public boolean hasSourceName() {\n         return result.hasSourceName();\n         result.sourceName_ = getDefaultInstance().getSourceName();\n         return this;\n       }\n-      \n+\n       // required int32 line_number = 4;\n       public boolean hasLineNumber() {\n         return result.hasLineNumber();\n         result.lineNumber_ = 0;\n         return this;\n       }\n-      \n+\n       // required string module_name = 5;\n       public boolean hasModuleName() {\n         return result.hasModuleName();\n         result.moduleName_ = getDefaultInstance().getModuleName();\n         return this;\n       }\n-      \n+\n       // required int32 size = 6;\n       public boolean hasSize() {\n         return result.hasSize();\n         result.size_ = 0;\n         return this;\n       }\n-      \n+\n       // required string name = 7;\n       public boolean hasName() {\n         return result.hasName();\n         result.name_ = getDefaultInstance().getName();\n         return this;\n       }\n-      \n+\n       // required string compiled_source = 8;\n       public boolean hasCompiledSource() {\n         return result.hasCompiledSource();\n         result.compiledSource_ = getDefaultInstance().getCompiledSource();\n         return this;\n       }\n-      \n+\n       // @@protoc_insertion_point(builder_scope:jscomp.FunctionInformationMap.Entry)\n     }\n-    \n+\n     static {\n       defaultInstance = new Entry(true);\n       com.google.javascript.jscomp.FunctionInfo.internalForceInit();\n       defaultInstance.initFields();\n     }\n-    \n+\n     // @@protoc_insertion_point(class_scope:jscomp.FunctionInformationMap.Entry)\n   }\n-  \n+\n   public static final class Module extends\n       com.google.protobuf.GeneratedMessage {\n     // Use Module.newBuilder() to construct.\n       initFields();\n     }\n     private Module(boolean noInit) {}\n-    \n+\n     private static final Module defaultInstance;\n     public static Module getDefaultInstance() {\n       return defaultInstance;\n     }\n-    \n+\n     public Module getDefaultInstanceForType() {\n       return defaultInstance;\n     }\n-    \n+\n     public static final com.google.protobuf.Descriptors.Descriptor\n         getDescriptor() {\n       return com.google.javascript.jscomp.FunctionInfo.internal_static_jscomp_FunctionInformationMap_Module_descriptor;\n     }\n-    \n+\n     protected com.google.protobuf.GeneratedMessage.FieldAccessorTable\n         internalGetFieldAccessorTable() {\n       return com.google.javascript.jscomp.FunctionInfo.internal_static_jscomp_FunctionInformationMap_Module_fieldAccessorTable;\n     }\n-    \n+\n     // required string name = 102;\n     public static final int NAME_FIELD_NUMBER = 102;\n     private boolean hasName;\n     private java.lang.String name_ = \"\";\n     public boolean hasName() { return hasName; }\n     public java.lang.String getName() { return name_; }\n-    \n+\n     // required string compiled_source = 103;\n     public static final int COMPILED_SOURCE_FIELD_NUMBER = 103;\n     private boolean hasCompiledSource;\n     private java.lang.String compiledSource_ = \"\";\n     public boolean hasCompiledSource() { return hasCompiledSource; }\n     public java.lang.String getCompiledSource() { return compiledSource_; }\n-    \n+\n     private void initFields() {\n     }\n     public final boolean isInitialized() {\n       if (!hasCompiledSource) return false;\n       return true;\n     }\n-    \n+\n     public void writeTo(com.google.protobuf.CodedOutputStream output)\n                         throws java.io.IOException {\n       getSerializedSize();\n       }\n       getUnknownFields().writeTo(output);\n     }\n-    \n+\n     private int memoizedSerializedSize = -1;\n     public int getSerializedSize() {\n       int size = memoizedSerializedSize;\n       if (size != -1) return size;\n-    \n+\n       size = 0;\n       if (hasName()) {\n         size += com.google.protobuf.CodedOutputStream\n       memoizedSerializedSize = size;\n       return size;\n     }\n-    \n+\n     public static com.google.javascript.jscomp.FunctionInformationMap.Module parseFrom(\n         com.google.protobuf.ByteString data)\n         throws com.google.protobuf.InvalidProtocolBufferException {\n       return newBuilder().mergeFrom(input, extensionRegistry)\n                .buildParsed();\n     }\n-    \n+\n     public static Builder newBuilder() { return Builder.create(); }\n     public Builder newBuilderForType() { return newBuilder(); }\n     public static Builder newBuilder(com.google.javascript.jscomp.FunctionInformationMap.Module prototype) {\n       return newBuilder().mergeFrom(prototype);\n     }\n     public Builder toBuilder() { return newBuilder(this); }\n-    \n+\n     public static final class Builder extends\n         com.google.protobuf.GeneratedMessage.Builder<Builder> {\n       private com.google.javascript.jscomp.FunctionInformationMap.Module result;\n-      \n+\n       // Construct using com.google.javascript.jscomp.FunctionInformationMap.Module.newBuilder()\n       private Builder() {}\n-      \n+\n       private static Builder create() {\n         Builder builder = new Builder();\n         builder.result = new com.google.javascript.jscomp.FunctionInformationMap.Module();\n         return builder;\n       }\n-      \n+\n       protected com.google.javascript.jscomp.FunctionInformationMap.Module internalGetResult() {\n         return result;\n       }\n-      \n+\n       public Builder clear() {\n         if (result == null) {\n           throw new IllegalStateException(\n         result = new com.google.javascript.jscomp.FunctionInformationMap.Module();\n         return this;\n       }\n-      \n+\n       public Builder clone() {\n         return create().mergeFrom(result);\n       }\n-      \n+\n       public com.google.protobuf.Descriptors.Descriptor\n           getDescriptorForType() {\n         return com.google.javascript.jscomp.FunctionInformationMap.Module.getDescriptor();\n       }\n-      \n+\n       public com.google.javascript.jscomp.FunctionInformationMap.Module getDefaultInstanceForType() {\n         return com.google.javascript.jscomp.FunctionInformationMap.Module.getDefaultInstance();\n       }\n-      \n+\n       public boolean isInitialized() {\n         return result.isInitialized();\n       }\n         }\n         return buildPartial();\n       }\n-      \n+\n       private com.google.javascript.jscomp.FunctionInformationMap.Module buildParsed()\n           throws com.google.protobuf.InvalidProtocolBufferException {\n         if (!isInitialized()) {\n         }\n         return buildPartial();\n       }\n-      \n+\n       public com.google.javascript.jscomp.FunctionInformationMap.Module buildPartial() {\n         if (result == null) {\n           throw new IllegalStateException(\n         result = null;\n         return returnMe;\n       }\n-      \n+\n       public Builder mergeFrom(com.google.protobuf.Message other) {\n         if (other instanceof com.google.javascript.jscomp.FunctionInformationMap.Module) {\n           return mergeFrom((com.google.javascript.jscomp.FunctionInformationMap.Module)other);\n           return this;\n         }\n       }\n-      \n+\n       public Builder mergeFrom(com.google.javascript.jscomp.FunctionInformationMap.Module other) {\n         if (other == com.google.javascript.jscomp.FunctionInformationMap.Module.getDefaultInstance()) return this;\n         if (other.hasName()) {\n         this.mergeUnknownFields(other.getUnknownFields());\n         return this;\n       }\n-      \n+\n       public Builder mergeFrom(\n           com.google.protobuf.CodedInputStream input,\n           com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n           }\n         }\n       }\n-      \n-      \n+\n+\n       // required string name = 102;\n       public boolean hasName() {\n         return result.hasName();\n         result.name_ = getDefaultInstance().getName();\n         return this;\n       }\n-      \n+\n       // required string compiled_source = 103;\n       public boolean hasCompiledSource() {\n         return result.hasCompiledSource();\n         result.compiledSource_ = getDefaultInstance().getCompiledSource();\n         return this;\n       }\n-      \n+\n       // @@protoc_insertion_point(builder_scope:jscomp.FunctionInformationMap.Module)\n     }\n-    \n+\n     static {\n       defaultInstance = new Module(true);\n       com.google.javascript.jscomp.FunctionInfo.internalForceInit();\n       defaultInstance.initFields();\n     }\n-    \n+\n     // @@protoc_insertion_point(class_scope:jscomp.FunctionInformationMap.Module)\n   }\n-  \n+\n   // repeated group Entry = 1 {\n   public static final int ENTRY_FIELD_NUMBER = 1;\n   private java.util.List<com.google.javascript.jscomp.FunctionInformationMap.Entry> entry_ =\n   public com.google.javascript.jscomp.FunctionInformationMap.Entry getEntry(int index) {\n     return entry_.get(index);\n   }\n-  \n+\n   // repeated group Module = 101 {\n   public static final int MODULE_FIELD_NUMBER = 101;\n   private java.util.List<com.google.javascript.jscomp.FunctionInformationMap.Module> module_ =\n   public com.google.javascript.jscomp.FunctionInformationMap.Module getModule(int index) {\n     return module_.get(index);\n   }\n-  \n+\n   private void initFields() {\n   }\n   public final boolean isInitialized() {\n     }\n     return true;\n   }\n-  \n+\n   public void writeTo(com.google.protobuf.CodedOutputStream output)\n                       throws java.io.IOException {\n     getSerializedSize();\n     }\n     getUnknownFields().writeTo(output);\n   }\n-  \n+\n   private int memoizedSerializedSize = -1;\n   public int getSerializedSize() {\n     int size = memoizedSerializedSize;\n     if (size != -1) return size;\n-  \n+\n     size = 0;\n     for (com.google.javascript.jscomp.FunctionInformationMap.Entry element : getEntryList()) {\n       size += com.google.protobuf.CodedOutputStream\n     memoizedSerializedSize = size;\n     return size;\n   }\n-  \n+\n   public static com.google.javascript.jscomp.FunctionInformationMap parseFrom(\n       com.google.protobuf.ByteString data)\n       throws com.google.protobuf.InvalidProtocolBufferException {\n     return newBuilder().mergeFrom(input, extensionRegistry)\n              .buildParsed();\n   }\n-  \n+\n   public static Builder newBuilder() { return Builder.create(); }\n   public Builder newBuilderForType() { return newBuilder(); }\n   public static Builder newBuilder(com.google.javascript.jscomp.FunctionInformationMap prototype) {\n     return newBuilder().mergeFrom(prototype);\n   }\n   public Builder toBuilder() { return newBuilder(this); }\n-  \n+\n   public static final class Builder extends\n       com.google.protobuf.GeneratedMessage.Builder<Builder> {\n     private com.google.javascript.jscomp.FunctionInformationMap result;\n-    \n+\n     // Construct using com.google.javascript.jscomp.FunctionInformationMap.newBuilder()\n     private Builder() {}\n-    \n+\n     private static Builder create() {\n       Builder builder = new Builder();\n       builder.result = new com.google.javascript.jscomp.FunctionInformationMap();\n       return builder;\n     }\n-    \n+\n     protected com.google.javascript.jscomp.FunctionInformationMap internalGetResult() {\n       return result;\n     }\n-    \n+\n     public Builder clear() {\n       if (result == null) {\n         throw new IllegalStateException(\n       result = new com.google.javascript.jscomp.FunctionInformationMap();\n       return this;\n     }\n-    \n+\n     public Builder clone() {\n       return create().mergeFrom(result);\n     }\n-    \n+\n     public com.google.protobuf.Descriptors.Descriptor\n         getDescriptorForType() {\n       return com.google.javascript.jscomp.FunctionInformationMap.getDescriptor();\n     }\n-    \n+\n     public com.google.javascript.jscomp.FunctionInformationMap getDefaultInstanceForType() {\n       return com.google.javascript.jscomp.FunctionInformationMap.getDefaultInstance();\n     }\n-    \n+\n     public boolean isInitialized() {\n       return result.isInitialized();\n     }\n       }\n       return buildPartial();\n     }\n-    \n+\n     private com.google.javascript.jscomp.FunctionInformationMap buildParsed()\n         throws com.google.protobuf.InvalidProtocolBufferException {\n       if (!isInitialized()) {\n       }\n       return buildPartial();\n     }\n-    \n+\n     public com.google.javascript.jscomp.FunctionInformationMap buildPartial() {\n       if (result == null) {\n         throw new IllegalStateException(\n       result = null;\n       return returnMe;\n     }\n-    \n+\n     public Builder mergeFrom(com.google.protobuf.Message other) {\n       if (other instanceof com.google.javascript.jscomp.FunctionInformationMap) {\n         return mergeFrom((com.google.javascript.jscomp.FunctionInformationMap)other);\n         return this;\n       }\n     }\n-    \n+\n     public Builder mergeFrom(com.google.javascript.jscomp.FunctionInformationMap other) {\n       if (other == com.google.javascript.jscomp.FunctionInformationMap.getDefaultInstance()) return this;\n       if (!other.entry_.isEmpty()) {\n       this.mergeUnknownFields(other.getUnknownFields());\n       return this;\n     }\n-    \n+\n     public Builder mergeFrom(\n         com.google.protobuf.CodedInputStream input,\n         com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n         }\n       }\n     }\n-    \n-    \n+\n+\n     // repeated group Entry = 1 {\n     public java.util.List<com.google.javascript.jscomp.FunctionInformationMap.Entry> getEntryList() {\n       return java.util.Collections.unmodifiableList(result.entry_);\n       result.entry_ = java.util.Collections.emptyList();\n       return this;\n     }\n-    \n+\n     // repeated group Module = 101 {\n     public java.util.List<com.google.javascript.jscomp.FunctionInformationMap.Module> getModuleList() {\n       return java.util.Collections.unmodifiableList(result.module_);\n       result.module_ = java.util.Collections.emptyList();\n       return this;\n     }\n-    \n+\n     // @@protoc_insertion_point(builder_scope:jscomp.FunctionInformationMap)\n   }\n-  \n+\n   static {\n     defaultInstance = new FunctionInformationMap(true);\n     com.google.javascript.jscomp.FunctionInfo.internalForceInit();\n     defaultInstance.initFields();\n   }\n-  \n+\n   // @@protoc_insertion_point(class_scope:jscomp.FunctionInformationMap)\n }\n \n--- a/gen/com/google/javascript/jscomp/Instrumentation.java\n+++ b/gen/com/google/javascript/jscomp/Instrumentation.java\n     initFields();\n   }\n   private Instrumentation(boolean noInit) {}\n-  \n+\n   private static final Instrumentation defaultInstance;\n   public static Instrumentation getDefaultInstance() {\n     return defaultInstance;\n   }\n-  \n+\n   public Instrumentation getDefaultInstanceForType() {\n     return defaultInstance;\n   }\n-  \n+\n   public static final com.google.protobuf.Descriptors.Descriptor\n       getDescriptor() {\n     return com.google.javascript.jscomp.InstrumentationTemplate.internal_static_jscomp_Instrumentation_descriptor;\n   }\n-  \n+\n   protected com.google.protobuf.GeneratedMessage.FieldAccessorTable\n       internalGetFieldAccessorTable() {\n     return com.google.javascript.jscomp.InstrumentationTemplate.internal_static_jscomp_Instrumentation_fieldAccessorTable;\n   }\n-  \n+\n   // optional string report_defined = 1;\n   public static final int REPORT_DEFINED_FIELD_NUMBER = 1;\n   private boolean hasReportDefined;\n   private java.lang.String reportDefined_ = \"\";\n   public boolean hasReportDefined() { return hasReportDefined; }\n   public java.lang.String getReportDefined() { return reportDefined_; }\n-  \n+\n   // optional string report_call = 2;\n   public static final int REPORT_CALL_FIELD_NUMBER = 2;\n   private boolean hasReportCall;\n   private java.lang.String reportCall_ = \"\";\n   public boolean hasReportCall() { return hasReportCall; }\n   public java.lang.String getReportCall() { return reportCall_; }\n-  \n+\n   // optional string report_exit = 6;\n   public static final int REPORT_EXIT_FIELD_NUMBER = 6;\n   private boolean hasReportExit;\n   private java.lang.String reportExit_ = \"\";\n   public boolean hasReportExit() { return hasReportExit; }\n   public java.lang.String getReportExit() { return reportExit_; }\n-  \n+\n   // repeated string declaration_to_remove = 3;\n   public static final int DECLARATION_TO_REMOVE_FIELD_NUMBER = 3;\n   private java.util.List<java.lang.String> declarationToRemove_ =\n   public java.lang.String getDeclarationToRemove(int index) {\n     return declarationToRemove_.get(index);\n   }\n-  \n+\n   // repeated string init = 4;\n   public static final int INIT_FIELD_NUMBER = 4;\n   private java.util.List<java.lang.String> init_ =\n   public java.lang.String getInit(int index) {\n     return init_.get(index);\n   }\n-  \n+\n   // optional string app_name_setter = 5;\n   public static final int APP_NAME_SETTER_FIELD_NUMBER = 5;\n   private boolean hasAppNameSetter;\n   private java.lang.String appNameSetter_ = \"\";\n   public boolean hasAppNameSetter() { return hasAppNameSetter; }\n   public java.lang.String getAppNameSetter() { return appNameSetter_; }\n-  \n+\n   private void initFields() {\n   }\n   public final boolean isInitialized() {\n     return true;\n   }\n-  \n+\n   public void writeTo(com.google.protobuf.CodedOutputStream output)\n                       throws java.io.IOException {\n     getSerializedSize();\n     }\n     getUnknownFields().writeTo(output);\n   }\n-  \n+\n   private int memoizedSerializedSize = -1;\n   public int getSerializedSize() {\n     int size = memoizedSerializedSize;\n     if (size != -1) return size;\n-  \n+\n     size = 0;\n     if (hasReportDefined()) {\n       size += com.google.protobuf.CodedOutputStream\n     memoizedSerializedSize = size;\n     return size;\n   }\n-  \n+\n   public static com.google.javascript.jscomp.Instrumentation parseFrom(\n       com.google.protobuf.ByteString data)\n       throws com.google.protobuf.InvalidProtocolBufferException {\n     return newBuilder().mergeFrom(input, extensionRegistry)\n              .buildParsed();\n   }\n-  \n+\n   public static Builder newBuilder() { return Builder.create(); }\n   public Builder newBuilderForType() { return newBuilder(); }\n   public static Builder newBuilder(com.google.javascript.jscomp.Instrumentation prototype) {\n     return newBuilder().mergeFrom(prototype);\n   }\n   public Builder toBuilder() { return newBuilder(this); }\n-  \n+\n   public static final class Builder extends\n       com.google.protobuf.GeneratedMessage.Builder<Builder> {\n     private com.google.javascript.jscomp.Instrumentation result;\n-    \n+\n     // Construct using com.google.javascript.jscomp.Instrumentation.newBuilder()\n     private Builder() {}\n-    \n+\n     private static Builder create() {\n       Builder builder = new Builder();\n       builder.result = new com.google.javascript.jscomp.Instrumentation();\n       return builder;\n     }\n-    \n+\n     protected com.google.javascript.jscomp.Instrumentation internalGetResult() {\n       return result;\n     }\n-    \n+\n     public Builder clear() {\n       if (result == null) {\n         throw new IllegalStateException(\n       result = new com.google.javascript.jscomp.Instrumentation();\n       return this;\n     }\n-    \n+\n     public Builder clone() {\n       return create().mergeFrom(result);\n     }\n-    \n+\n     public com.google.protobuf.Descriptors.Descriptor\n         getDescriptorForType() {\n       return com.google.javascript.jscomp.Instrumentation.getDescriptor();\n     }\n-    \n+\n     public com.google.javascript.jscomp.Instrumentation getDefaultInstanceForType() {\n       return com.google.javascript.jscomp.Instrumentation.getDefaultInstance();\n     }\n-    \n+\n     public boolean isInitialized() {\n       return result.isInitialized();\n     }\n       }\n       return buildPartial();\n     }\n-    \n+\n     private com.google.javascript.jscomp.Instrumentation buildParsed()\n         throws com.google.protobuf.InvalidProtocolBufferException {\n       if (!isInitialized()) {\n       }\n       return buildPartial();\n     }\n-    \n+\n     public com.google.javascript.jscomp.Instrumentation buildPartial() {\n       if (result == null) {\n         throw new IllegalStateException(\n       result = null;\n       return returnMe;\n     }\n-    \n+\n     public Builder mergeFrom(com.google.protobuf.Message other) {\n       if (other instanceof com.google.javascript.jscomp.Instrumentation) {\n         return mergeFrom((com.google.javascript.jscomp.Instrumentation)other);\n         return this;\n       }\n     }\n-    \n+\n     public Builder mergeFrom(com.google.javascript.jscomp.Instrumentation other) {\n       if (other == com.google.javascript.jscomp.Instrumentation.getDefaultInstance()) return this;\n       if (other.hasReportDefined()) {\n       this.mergeUnknownFields(other.getUnknownFields());\n       return this;\n     }\n-    \n+\n     public Builder mergeFrom(\n         com.google.protobuf.CodedInputStream input,\n         com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n         }\n       }\n     }\n-    \n-    \n+\n+\n     // optional string report_defined = 1;\n     public boolean hasReportDefined() {\n       return result.hasReportDefined();\n       result.reportDefined_ = getDefaultInstance().getReportDefined();\n       return this;\n     }\n-    \n+\n     // optional string report_call = 2;\n     public boolean hasReportCall() {\n       return result.hasReportCall();\n       result.reportCall_ = getDefaultInstance().getReportCall();\n       return this;\n     }\n-    \n+\n     // optional string report_exit = 6;\n     public boolean hasReportExit() {\n       return result.hasReportExit();\n       result.reportExit_ = getDefaultInstance().getReportExit();\n       return this;\n     }\n-    \n+\n     // repeated string declaration_to_remove = 3;\n     public java.util.List<java.lang.String> getDeclarationToRemoveList() {\n       return java.util.Collections.unmodifiableList(result.declarationToRemove_);\n       result.declarationToRemove_ = java.util.Collections.emptyList();\n       return this;\n     }\n-    \n+\n     // repeated string init = 4;\n     public java.util.List<java.lang.String> getInitList() {\n       return java.util.Collections.unmodifiableList(result.init_);\n       result.init_ = java.util.Collections.emptyList();\n       return this;\n     }\n-    \n+\n     // optional string app_name_setter = 5;\n     public boolean hasAppNameSetter() {\n       return result.hasAppNameSetter();\n       result.appNameSetter_ = getDefaultInstance().getAppNameSetter();\n       return this;\n     }\n-    \n+\n     // @@protoc_insertion_point(builder_scope:jscomp.Instrumentation)\n   }\n-  \n+\n   static {\n     defaultInstance = new Instrumentation(true);\n     com.google.javascript.jscomp.InstrumentationTemplate.internalForceInit();\n     defaultInstance.initFields();\n   }\n-  \n+\n   // @@protoc_insertion_point(class_scope:jscomp.Instrumentation)\n }\n \n--- a/gen/com/google/javascript/jscomp/InstrumentationTemplate.java\n+++ b/gen/com/google/javascript/jscomp/InstrumentationTemplate.java\n   static\n     com.google.protobuf.GeneratedMessage.FieldAccessorTable\n       internal_static_jscomp_Instrumentation_fieldAccessorTable;\n-  \n+\n   public static com.google.protobuf.Descriptors.FileDescriptor\n       getDescriptor() {\n     return descriptor;\n         new com.google.protobuf.Descriptors.FileDescriptor[] {\n         }, assigner);\n   }\n-  \n+\n   public static void internalForceInit() {}\n-  \n+\n   // @@protoc_insertion_point(outer_class_scope)\n }\n--- a/src/com/google/javascript/jscomp/CheckRegExp.java\n+++ b/src/com/google/javascript/jscomp/CheckRegExp.java\n /**\n  * Look for references to the global RegExp object that would cause\n  * regular expressions to be unoptimizable.\n- * \n+ *\n  * @author johnlenz@google.com (John Lenz)\n  */\n class CheckRegExp extends AbstractPostOrderCallback implements CompilerPass {\n       String name = n.getString();\n       if (name.equals(\"RegExp\") && t.getScope().getVar(name) == null) {\n         int parentType = parent.getType();\n-        boolean first = (n == parent.getFirstChild()); \n+        boolean first = (n == parent.getFirstChild());\n         if (!((parentType == Token.NEW && first)\n                || (parentType == Token.CALL && first)\n                || (parentType == Token.INSTANCEOF && !first))) {\n--- a/src/com/google/javascript/jscomp/FunctionToBlockMutator.java\n+++ b/src/com/google/javascript/jscomp/FunctionToBlockMutator.java\n \n         Node newRoot = new Node(Token.BLOCK).copyInformationFrom(block);\n         newRoot.addChildrenToBack(label);\n-        \n+\n \n         // The label is now the root.\n         root = newRoot;\n--- a/src/com/google/javascript/jscomp/JoinOp.java\n+++ b/src/com/google/javascript/jscomp/JoinOp.java\n             apply(values.subList(mid, size)));\n       }\n     }\n-    \n+\n     /**\n      * Creates a new lattice that will be the join of two input lattices.\n      *\n--- a/src/com/google/javascript/jscomp/JsMessageVisitor.java\n+++ b/src/com/google/javascript/jscomp/JsMessageVisitor.java\n     JsMessage extractedMessage = builder.build(idGenerator);\n \n     // If asked to check named internal messages.\n-    if (needToCheckDuplications \n-        && !isUnnamedMsg \n+    if (needToCheckDuplications\n+        && !isUnnamedMsg\n         && !extractedMessage.isExternal()) {\n       checkIfMessageDuplicated(traversal.getSourceName(), messageKey, msgNode);\n-    }    \n-    \n+    }\n+\n     if (extractedMessage.isEmpty()) {\n       // value of the message is an empty string. Translators do not like it.\n       compiler.report(traversal.makeError(node, MESSAGE_HAS_NO_TEXT,\n--- a/src/com/google/javascript/jscomp/MakeDeclaredNamesUnique.java\n+++ b/src/com/google/javascript/jscomp/MakeDeclaredNamesUnique.java\n         nameMap.remove(name);\n       }\n     }\n- \n+\n     /**\n      * Find a name usable in the local scope.\n      */\n       String newName = original;\n       int i = 0;\n       while (!isValidName(newName)) {\n-        newName = original + \n+        newName = original +\n             ContextualRenamer.UNIQUE_ID_SEPARATOR + String.valueOf(i++);\n       }\n       return newName;\n   static class BoilerplateRenamer extends ContextualRenamer {\n     private final Supplier<String> uniqueIdSupplier;\n     private final String idPrefix;\n-    \n+\n     BoilerplateRenamer(\n         Supplier<String> uniqueIdSupplier,\n         String idPrefix) {\n--- a/src/com/google/javascript/jscomp/MinimizeExitPoints.java\n+++ b/src/com/google/javascript/jscomp/MinimizeExitPoints.java\n \n   /**\n    * Look for exits (returns, breaks, or continues, depending on the context) at\n-   * the end of a block and removes them by moving the if node's siblings, \n+   * the end of a block and removes them by moving the if node's siblings,\n    * if any, into the opposite condition block.\n    *\n    * @param srcBlock The block to inspect.\n--- a/src/com/google/javascript/jscomp/OptimizeCalls.java\n+++ b/src/com/google/javascript/jscomp/OptimizeCalls.java\n  *   - optimize parameters\n  *   - optimize returns\n  *   - devirtualize prototype methods\n- * \n+ *\n  * @author johnlenz@google.com (John Lenz)\n  */\n class OptimizeCalls implements CompilerPass {\n   List<CallGraphCompilerPass> passes = Lists.newArrayList();\n   private AbstractCompiler compiler;\n-  \n+\n   OptimizeCalls(AbstractCompiler compiler) {\n     this.compiler = compiler;\n   }\n-  \n+\n   OptimizeCalls addPass(CallGraphCompilerPass pass) {\n     passes.add(pass);\n     return this;\n   }\n-  \n+\n   interface CallGraphCompilerPass {\n     void process(Node externs, Node root, SimpleDefinitionFinder definitions);\n   }\n--- a/src/com/google/javascript/jscomp/PeepholeFoldWithTypes.java\n+++ b/src/com/google/javascript/jscomp/PeepholeFoldWithTypes.java\n \n /**\n  * Performs type-aware peephole optimizations.\n- * \n+ *\n  * These peephole optimizations are in their own class because\n  * type information may not always be available (such as during pre-processing)\n  * or may not be turned on.\n- * \n+ *\n  * Currently only Token.TYPEOF is folded -- in the future it may be possible to\n  * fold Token.INSTANCEOF as well. Another possibility is folding when\n  * non-nullable objects are used in boolean logic, such as:\n  * \"if (x) {\" or \"(!x) ? a : b\" or \"x && foo()\"\n- * \n+ *\n  * TODO(dcc): Support folding Token.INSTANCEOF and non-nullable objects\n  * in boolean logic.\n- * \n+ *\n  * @author dcc@google.com (Devin Coughlin)\n  */\n class PeepholeFoldWithTypes extends AbstractPeepholeOptimization {\n         return subtree;\n     }\n   }\n-  \n+\n   /**\n    * Folds \"typeof expression\" based on the JSType of \"expression\" if the\n    * expression  has no side effects.\n-   * \n+   *\n    * <p>E.g.,\n    * <pre>\n    * var x = 6;\n    * if (\"number\" == \"number\") {\n    * }\n    * </pre>\n-   * \n+   *\n    * <p>This method doesn't fold literal values -- we leave that to\n    * PeepholeFoldConstants.\n    */\n   private Node tryFoldTypeof(Node typeofNode) {\n     Preconditions.checkArgument(typeofNode.getType() == Token.TYPEOF);\n     Preconditions.checkArgument(typeofNode.getFirstChild() != null);\n-    \n+\n     Node argumentNode = typeofNode.getFirstChild();\n-    \n+\n     // We'll let PeepholeFoldConstants handle folding literals\n     // and we can't remove arguments with possible side effects.\n     if (!NodeUtil.isLiteralValue(argumentNode, true) &&\n         !mayHaveSideEffects(argumentNode)) {\n       JSType argumentType = argumentNode.getJSType();\n-            \n+\n       String typeName = null;\n-      \n+\n       if (argumentType != null) {\n         // typeof null is \"object\" in JavaScript\n         if (argumentType.isObject() || argumentType.isNullType()) {\n           // in the future.\n           typeName = null;\n         }\n-               \n+\n         if (typeName != null) {\n           Node newNode = Node.newString(typeName);\n           typeofNode.getParent().replaceChild(typeofNode, newNode);\n           reportCodeChange();\n-          \n+\n           return newNode;\n         }\n-      }     \n-    }  \n+      }\n+    }\n     return typeofNode;\n   }\n }\n--- a/src/com/google/javascript/jscomp/ProcessTweaks.java\n+++ b/src/com/google/javascript/jscomp/ProcessTweaks.java\n   private final AbstractCompiler compiler;\n   private final boolean stripTweaks;\n   private final SortedMap<String, Node> compilerDefaultValueOverrides;\n-  \n+\n   private static final CharMatcher ID_MATCHER = CharMatcher.inRange('a', 'z').\n       or(CharMatcher.inRange('A', 'Z')).or(CharMatcher.anyOf(\"0123456789_.\"));\n \n       DiagnosticType.error(\n           \"JSC_NON_LITERAL_TWEAK_ID_ERROR\",\n           \"tweak ID must be a string literal\");\n-  \n+\n   static final DiagnosticType INVALID_TWEAK_DEFAULT_VALUE_WARNING =\n       DiagnosticType.warning(\n           \"JSC_INVALID_TWEAK_DEFAULT_VALUE_WARNING\",\n       DiagnosticType.error(\n           \"JSC_NON_GLOBAL_TWEAK_INIT_ERROR\",\n           \"tweak declaration {0} must occur in the global scope\");\n-  \n+\n   static final DiagnosticType TWEAK_OVERRIDE_AFTER_REGISTERED_ERROR =\n       DiagnosticType.error(\n           \"JSC_TWEAK_OVERRIDE_AFTER_REGISTERED_ERROR\",\n           \"Cannot override the default value of tweak {0} after it has been \" +\n           \"registered\");\n-  \n+\n   static final DiagnosticType TWEAK_WRONG_GETTER_TYPE_WARNING =\n       DiagnosticType.warning(\n           \"JSC_TWEAK_WRONG_GETTER_TYPE_WARNING\",\n     final int validNodeTypeA;\n     final int validNodeTypeB;\n     final TweakFunction registerFunction;\n-    \n+\n     TweakFunction(String name) {\n       this(name, null, Token.ERROR, Token.ERROR, null);\n     }\n-    \n+\n     TweakFunction(String name, String expectedTypeName,\n         int validNodeTypeA) {\n       this(name, expectedTypeName, validNodeTypeA, Token.ERROR, null);\n       this.validNodeTypeB = validNodeTypeB;\n       this.registerFunction = registerFunction;\n     }\n-    \n+\n     boolean isValidNodeType(int type) {\n       return type == validNodeTypeA || type == validNodeTypeB;\n     }\n-    \n+\n     boolean isCorrectRegisterFunction(TweakFunction registerFunction) {\n       Preconditions.checkNotNull(registerFunction);\n       return this.registerFunction == registerFunction;\n     }\n-    \n+\n     boolean isGetterFunction() {\n       return registerFunction != null;\n     }\n     String getExpectedTypeName() {\n       return expectedTypeName;\n     }\n-    \n+\n     Node createDefaultValueNode() {\n       switch (this) {\n         case REGISTER_BOOLEAN:\n       throw new IllegalStateException();\n     }\n   }\n-  \n+\n   // A map of function name -> TweakFunction.\n   private static final Map<String, TweakFunction> TWEAK_FUNCTIONS_MAP;\n   static {\n       TWEAK_FUNCTIONS_MAP.put(func.getName(), func);\n     }\n   }\n-          \n+\n   ProcessTweaks(AbstractCompiler compiler, boolean stripTweaks,\n       Map<String, Node> compilerDefaultValueOverrides) {\n     this.compiler = compiler;\n   }\n \n   /**\n-   * Creates a JS object that holds a map of tweakId -> default value override. \n+   * Creates a JS object that holds a map of tweakId -> default value override.\n    */\n   private Node createCompilerDefaultValueOverridesVarNode(\n       Node sourceInformationNode) {\n   private CollectTweaksResult collectTweaks(Node root) {\n     CollectTweaks pass = new CollectTweaks();\n     NodeTraversal.traverse(compiler, root, pass);\n-    \n+\n     Map<String, TweakInfo> tweakInfos = pass.allTweaks;\n     for (TweakInfo tweakInfo: tweakInfos.values()) {\n       tweakInfo.emitAllWarnings();\n     }\n     return new CollectTweaksResult(tweakInfos, pass.getOverridesCalls);\n   }\n-  \n+\n   private final static class CollectTweaksResult {\n     final Map<String, TweakInfo> tweakInfos;\n     final List<TweakFunctionCall> getOverridesCalls;\n-    \n+\n     CollectTweaksResult(Map<String, TweakInfo> tweakInfos,\n         List<TweakFunctionCall> getOverridesCalls) {\n       this.tweakInfos = tweakInfos;\n       if (tweakFunc == null) {\n         return;\n       }\n-      \n+\n       if (tweakFunc == TweakFunction.GET_COMPILER_OVERRIDES) {\n         getOverridesCalls.add(\n             new TweakFunctionCall(t.getSourceName(), tweakFunc, n));\n         return;\n       }\n       String tweakId = tweakIdNode.getString();\n-      \n+\n       // Make sure there is a TweakInfo structure for it.\n       TweakInfo tweakInfo = allTweaks.get(tweakId);\n       if (tweakInfo == null) {\n         tweakInfo = new TweakInfo(tweakId);\n         allTweaks.put(tweakId, tweakInfo);\n       }\n-      \n+\n       switch (tweakFunc) {\n         case REGISTER_BOOLEAN:\n         case REGISTER_NUMBER:\n                 t.makeError(n, NON_GLOBAL_TWEAK_INIT_ERROR, tweakId));\n             break;\n           }\n-          \n+\n           // Ensure tweaks are registered only once.\n           if (tweakInfo.isRegistered()) {\n             compiler.report(\n                 t.makeError(n, TWEAK_MULTIPLY_REGISTERED_ERROR, tweakId));\n             break;\n           }\n-          \n+\n           Node tweakDefaultValueNode = tweakIdNode.getNext().getNext();\n           tweakInfo.addRegisterCall(t.getSourceName(), tweakFunc, n,\n               tweakDefaultValueNode);\n         Node callNode) {\n       this(sourceName, tweakFunc, callNode, null);\n     }\n-    \n+\n     TweakFunctionCall(String sourceName, TweakFunction tweakFunc, Node callNode,\n         Node valueNode) {\n       this.sourceName = sourceName;\n       this.tweakFunc = tweakFunc;\n       this.valueNode = valueNode;\n     }\n-    \n+\n     Node getIdNode() {\n       return callNode.getFirstChild().getNext();\n     }\n   }\n-  \n+\n   /**\n    * Stores information about a single tweak.\n    */\n     final List<TweakFunctionCall> functionCalls;\n     TweakFunctionCall registerCall;\n     Node defaultValueNode;\n-    \n+\n     TweakInfo(String tweakId) {\n       this.tweakId = tweakId;\n       functionCalls = Lists.newArrayList();\n     }\n-    \n+\n     /**\n      * If this tweak is registered, then looks for type warnings in default\n      * value parameters and getter functions. If it is not registered, emits an\n-     * error for each function call. \n+     * error for each function call.\n      */\n     void emitAllWarnings() {\n       if (isRegistered()) {\n         TweakFunction tweakFunc = call.tweakFunc;\n         TweakFunction registerFunc = registerCall.tweakFunc;\n         if (valueNode != null) {\n-          // For register* and overrideDefaultValue calls, ensure the default  \n+          // For register* and overrideDefaultValue calls, ensure the default\n           // value is a literal of the correct type.\n           if (!registerFunc.isValidNodeType(valueNode.getType())) {\n             compiler.report(JSError.make(call.sourceName,\n         }\n       }\n     }\n-    \n+\n     /**\n      * Emits an error for each function call that was found.\n      */\n           defaultValueNode);\n       functionCalls.add(registerCall);\n     }\n-    \n+\n     void addOverrideDefaultValueCall(String sourceName,\n         TweakFunction tweakFunc, Node callNode, Node defaultValueNode) {\n       functionCalls.add(new TweakFunctionCall(sourceName, tweakFunc, callNode,\n           defaultValueNode));\n       this.defaultValueNode = defaultValueNode;\n     }\n-    \n+\n     void addGetterCall(String sourceName, TweakFunction tweakFunc,\n         Node callNode) {\n       functionCalls.add(new TweakFunctionCall(sourceName, tweakFunc, callNode));\n     boolean isRegistered() {\n       return registerCall != null;\n     }\n-    \n+\n     Node getDefaultValueNode() {\n       Preconditions.checkState(isRegistered());\n       // Use calls to goog.tweak.overrideDefaultValue() first.\n--- a/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\n+++ b/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\n   public Set<Var> getReferencedVariables() {\n     return referenceMap.keySet();\n   }\n-  \n+\n   /**\n    * Gets the reference collection for the given variable.\n    */\n--- a/src/com/google/javascript/jscomp/SideEffectsAnalysis.java\n+++ b/src/com/google/javascript/jscomp/SideEffectsAnalysis.java\n /**\n  * A pass that analyzes side effects to determine when it is safe to move\n  * code from one program point to another.\n- * \n+ *\n  * In its current form, SideEffectsAnalysis is very incomplete; this is\n  * mostly a sketch to prototype the interface and the broad strokes of\n  * a possible implementation based on flow-insensitive MOD and REF sets.\n- * \n+ *\n  * See:\n- * \n+ *\n  * Banning, John. \u201cAn efficient way to find the side effects of procedure\n  *      calls and the aliases of variables.\u201d POPL \u201879.\n- * \n+ *\n  * For an introduction to MOD and REF sets.\n- * \n+ *\n  * @author dcc@google.com (Devin Coughlin)\n  */\n  class SideEffectsAnalysis implements CompilerPass {\n-  \n+\n    /**\n     * The type of location abstraction to use for this analysis.\n     */\n     /** See {@link VisibilityLocationAbstraction} for details. */\n     VISIBILITY_BASED\n   }\n-  \n-  private static final Predicate<Node> NOT_FUNCTION_PREDICATE = \n+\n+  private static final Predicate<Node> NOT_FUNCTION_PREDICATE =\n       new Predicate<Node>() {\n     @Override\n     public boolean apply(Node input) {\n       return !NodeUtil.isFunction(input);\n     }\n   };\n-  \n+\n   private AbstractCompiler compiler;\n-  \n+\n   /** The location abstraction used to calculate the effects of code */\n   private LocationAbstraction locationAbstraction;\n-  \n+\n   /** The kind of location abstraction to use */\n   private final LocationAbstractionMode locationAbstractionIdentifier;\n-  \n+\n   /**\n    * Constructs a new SideEffectsAnalysis with the given location abstraction.\n-   * \n+   *\n    * @param compiler A compiler instance\n    * @param locationAbstractionMode The location abstration to use. {@code\n    *    DEGENERATE} will use {@link DegenerateLocationAbstraction} while\n    *    {@code VISIBILITY_BASED} will use {@link VisibilityLocationAbstraction}\n-   *    \n+   *\n    */\n   public SideEffectsAnalysis(AbstractCompiler compiler,\n       LocationAbstractionMode locationAbstractionMode) {\n     this.compiler = compiler;\n-    \n+\n     this.locationAbstractionIdentifier = locationAbstractionMode;\n   }\n-  \n+\n   public SideEffectsAnalysis(AbstractCompiler compiler) {\n     this(compiler, LocationAbstractionMode.DEGENERATE);\n   }\n-  \n+\n   @Override\n   public void process(Node externs, Node root) {\n     switch(locationAbstractionIdentifier) {\n         locationAbstraction = new DegenerateLocationAbstraction();\n         break;\n       case VISIBILITY_BASED:\n-        locationAbstraction = createVisibilityAbstraction(externs, root); \n+        locationAbstraction = createVisibilityAbstraction(externs, root);\n         break;\n       default:\n         throw new IllegalStateException(\"Unrecognized location abstraction \" +\n             \"identifier: \" + locationAbstractionIdentifier);\n     }\n-    \n+\n     // In the future, this method\n     // will construct a callgraph and calculate side effects summaries\n     // for all functions.\n     // TODO(dcc): Add per-function side effects summaries.\n   }\n-  \n+\n   private LocationAbstraction createVisibilityAbstraction(Node externs,\n       Node root) {\n     VariableVisibilityAnalysis variableVisibility =\n         new VariableVisibilityAnalysis(compiler);\n-  \n+\n     variableVisibility.process(externs, root);\n-  \n+\n     VariableUseDeclarationMap variableMap =\n         new VariableUseDeclarationMap(compiler);\n-  \n+\n     variableMap.mapUses(root);\n-  \n+\n    return new VisibilityLocationAbstraction(compiler,\n        variableVisibility, variableMap);\n   }\n-  \n-  /**\n-   * Determines whether it is safe to move code ({@code source}) across \n+\n+  /**\n+   * Determines whether it is safe to move code ({@code source}) across\n    * an environment to another program point (immediately preceding\n    * {@code destination}).\n-   * \n-   * <p>The notion of \"environment\" is optimization-specific, but it should \n+   *\n+   * <p>The notion of \"environment\" is optimization-specific, but it should\n    * include any code that could be executed between the source program point\n    * and the destination program point.\n-   * \n-   * {@code destination} must not be a descendant of {@code source}. \n-   *  \n+   *\n+   * {@code destination} must not be a descendant of {@code source}.\n+   *\n    * @param source The node that would be moved\n    * @param environment An environment representing the code across which\n    *    the source will be moved.\n    * @param destination The node before which the source would be moved\n    * @return Whether it is safe to move the source to the destination\n    */\n-  public boolean safeToMoveBefore(Node source, \n+  public boolean safeToMoveBefore(Node source,\n       AbstractMotionEnvironment environment,\n       Node destination) {\n     Preconditions.checkNotNull(locationAbstraction);\n     Preconditions.checkArgument(!nodeHasAncestor(destination, source));\n-    \n+\n     // It is always safe to move pure code.\n     if (isPure(source)) {\n       return true;\n     }\n \n-    // Don't currently support interprocedural analysis   \n+    // Don't currently support interprocedural analysis\n     if (nodeHasCall(source)) {\n       return false;\n     }\n-    \n+\n     LocationSummary sourceLocationSummary =\n         locationAbstraction.calculateLocationSummary(source);\n-    \n+\n     EffectLocation sourceModSet = sourceLocationSummary.getModSet();\n \n     // If the source has side effects, then we require that the source\n     EffectLocation sourceRefSet = sourceLocationSummary.getRefSet();\n \n     Set<Node> environmentNodes = environment.calculateEnvironment();\n-    \n+\n     for (Node environmentNode : environmentNodes) {\n       if (nodeHasCall(environmentNode)) {\n         return false;\n       }\n     }\n-      \n+\n     LocationSummary environmentLocationSummary =\n         locationAbstraction.calculateLocationSummary(environmentNodes);\n-    \n+\n     EffectLocation environmentModSet = environmentLocationSummary.getModSet();\n \n     EffectLocation environmentRefSet = environmentLocationSummary.getRefSet();\n         && !environmentRefSet.intersectsLocation(sourceModSet)\n         && !environmentModSet.intersectsLocation(sourceModSet)) {\n       return true;\n-    } \n+    }\n \n     return false;\n   }\n-  \n-  /**\n-   * Returns true if the node is pure, that is it side effect free and does it \n+\n+  /**\n+   * Returns true if the node is pure, that is it side effect free and does it\n    * not depend on its environment?\n    */\n   private boolean isPure(Node node) {\n     // TODO(dcc): Implement isPure().\n     return false;\n   }\n-  \n-  /**\n-   * Returns true if the two nodes have the same control flow properties, \n+\n+  /**\n+   * Returns true if the two nodes have the same control flow properties,\n    * that is, is node1 be executed every time node2 is executed and vice versa?\n    */\n   private static boolean nodesHaveSameControlFlow(Node node1, Node node2) {\n     /*\n      * We conservatively approximate this with the following criteria:\n-     * \n+     *\n      * Define the \"deepest control dependent block\" for a node to be the\n      * closest ancestor whose *parent* is a control structure and where that\n      * ancestor may or may be executed depending on the parent.\n-     * \n+     *\n      * So, for example, in:\n      * if (a) {\n      *  b;\n      * } else {\n      *  c;\n      * }\n-     * \n+     *\n      * a has not deepest control dependent block.\n      * b's deepest control dependent block is the \"then\" block of the IF.\n      * c's deepest control dependent block is the \"else\" block of the IF.\n-     * \n+     *\n      * We'll say two nodes have the same control flow if\n-     * \n+     *\n      * 1) they have the same deepest control dependent block\n      * 2) that block is either a CASE (which can't have early exits) or it\n      * doesn't have any early exits (e.g. breaks, continues, returns.)\n-     * \n-     */\n-    \n+     *\n+     */\n+\n     Node node1DeepestControlDependentBlock =\n         closestControlDependentAncestor(node1);\n-    \n+\n     Node node2DeepestControlDependentBlock =\n       closestControlDependentAncestor(node2);\n-    \n-    if (node1DeepestControlDependentBlock == \n+\n+    if (node1DeepestControlDependentBlock ==\n         node2DeepestControlDependentBlock) {\n-      \n+\n       if (node2DeepestControlDependentBlock != null) {\n         // CASE is complicated because we have to deal with fall through and\n         // because some BREAKs are early exits and some are not.\n         if (node2DeepestControlDependentBlock.getType() == Token.CASE) {\n           return false;\n         }\n-        \n+\n         // Don't allow breaks, continues, returns in control dependent\n         // block because we don't actually create a control-flow graph\n         // and so don't know if early exits site between the source\n         // moving in the following case:\n         // while (a) {\n         //   source();\n-        //  \n+        //\n         //   while(b) {\n         //     break;\n         //   }\n           @Override\n           public boolean apply(Node input) {\n             int nodeType = input.getType();\n-            \n+\n             return nodeType == Token.RETURN\n                 || nodeType == Token.BREAK\n                 || nodeType == Token.CONTINUE;\n           }\n         };\n-        \n+\n         return !NodeUtil.has(node2DeepestControlDependentBlock,\n             isEarlyExitPredicate, NOT_FUNCTION_PREDICATE);\n       } else {\n       return false;\n     }\n   }\n-  \n+\n   /**\n    * Returns true if the number of times the child executes depends on the\n    * parent.\n-   * \n+   *\n    * For example, the guard of an IF is not control dependent on the\n    * IF, but its two THEN/ELSE blocks are.\n-   * \n+   *\n    * Also, the guard of WHILE and DO are control dependent on the parent\n    * since the number of times it executes depends on the parent.\n    */\n   private static boolean isControlDependentChild(Node child) {\n     Node parent = child.getParent();\n-    \n+\n     if (parent == null) {\n       return false;\n     }\n-    \n+\n     ArrayList<Node> siblings = Lists.newArrayList(parent.children());\n-    \n+\n     int indexOfChildInParent = siblings.indexOf(child);\n-    \n+\n     switch(parent.getType()) {\n       case Token.IF:\n       case Token.HOOK:\n         return true;\n       case Token.FUNCTION:\n         return true;\n-      \n+\n       default:\n         return false;\n     }\n   }\n-  \n-  private static Node closestControlDependentAncestor(Node node) { \n+\n+  private static Node closestControlDependentAncestor(Node node) {\n     if (isControlDependentChild(node)) {\n       return node;\n     }\n-    \n+\n     // Note: node is not considered one of its ancestors\n     for (Node ancestor : node.getAncestors()) {\n       if (isControlDependentChild(ancestor)) {\n         return ancestor;\n       }\n     }\n-      \n+\n     return null;\n   }\n-  \n+\n   /**\n    * Returns true if {@code possibleAncestor} is an ancestor of{@code node}.\n    * A node is not considered to be an ancestor of itself.\n    */\n   private static boolean nodeHasAncestor(Node node, Node possibleAncestor) {\n     // Note node is not in node.getAncestors()\n-    \n+\n     for (Node ancestor : node.getAncestors()) {\n       if (ancestor == possibleAncestor) {\n         return true;\n       }\n     }\n-   \n+\n     return false;\n   }\n-  \n+\n   /**\n    * Returns true if a node has a CALL or a NEW descendant.\n    */\n       }},\n       NOT_FUNCTION_PREDICATE);\n   }\n-   \n+\n   /**\n    * Represents an environment across which code might be moved, i.e. the set\n    * of code that could be run in between the source and the destination.\n-   * \n+   *\n    * SideEffectAnalysis characterizes the code to be moved and the environment\n    * in order to determine if they interact in such a way as to make the move\n    * unsafe.\n-   * \n+   *\n    * Since determining the environment for an optimization can be tricky,\n    * we provide several concrete subclasses that common classes of optimizations\n    * may be able to reuse.\n    */\n   public abstract static class AbstractMotionEnvironment {\n-    \n+\n     /**\n      * Calculates the set of nodes that this environment represnts.\n      */\n     public abstract Set<Node> calculateEnvironment();\n   }\n-  \n+\n   /**\n    * An environment for motion within a function. Given a\n    * control flow graph and a source and destination node in the control\n    */\n   public static class IntraproceduralMotionEnvironment\n       extends AbstractMotionEnvironment {\n-       \n+\n     /**\n      * Creates an intraprocedural motion environment.\n-     * \n+     *\n      * @param controlFlowGraph A control flow graph for function in which\n      * code will be moved\n      * @param cfgSource The code to be moved\n-     * @param cfgDestination The node immediately before which cfgSource \n+     * @param cfgDestination The node immediately before which cfgSource\n      * will be moved\n      */\n     public IntraproceduralMotionEnvironment(\n         ControlFlowGraph<Node> controlFlowGraph,\n         Node cfgSource,\n         Node cfgDestination) {\n-      \n-    }\n-    \n+\n+    }\n+\n     @Override\n     public Set<Node> calculateEnvironment() {\n       // TODO(dcc): Implement IntraproceduralMotionEnvironment\n       return null;\n-    } \n-  }\n-  \n+    }\n+  }\n+\n   /**\n    * An environment for motion between modules. Given a\n    * module graph and as well as source and destination nodes and modules,\n \n     /**\n      * Creates a cross module code motion environment.\n-     * \n+     *\n      * @param sourceNode The code to be moved\n      * @param sourceModule The module for the code to be moved\n      * @param destinationNode The node before which sourceNode will be inserted\n         Node destinationNode,\n         JSModule destinationModule,\n         JSModuleGraph moduleGraph) {\n-      \n-    }\n-    \n+\n+    }\n+\n     @Override\n     public Set<Node> calculateEnvironment() {\n       // TODO(dcc): Implement CrossModuleMotionEnvironment\n     public RawMotionEnvironment(Set<Node> environment) {\n       this.environment = environment;\n     }\n-    \n+\n     @Override\n     public Set<Node> calculateEnvironment() {\n       return environment;\n     }\n   }\n-  \n+\n   /*\n    * A combined representation for location set summaries.\n-   * \n+   *\n    * Basically, it is often easier to shuffle MOD/REF around together; this is\n    * a value class for that purpose.\n    */\n   private static class LocationSummary {\n-    \n+\n     private EffectLocation modSet;\n     private EffectLocation refSet;\n-    \n+\n     public LocationSummary(EffectLocation modSet, EffectLocation refSet) {\n       this.modSet = modSet;\n       this.refSet = refSet;\n     }\n-    \n+\n     public EffectLocation getModSet() {\n       return modSet;\n     }\n-    \n+\n     public EffectLocation getRefSet() {\n       return refSet;\n-    }   \n-  }\n-  \n+    }\n+  }\n+\n   /**\n    * Interface representing the notion of an effect location -- an abstract\n    * location that can be modified or referenced.\n-   * \n+   *\n    * <p>Since there are an infinite number of possible concrete locations\n    * in a running program, this abstraction must be imprecise (i.e. there\n    * will be some distinct concrete locations that are indistinguishable\n    * under the abstraction).\n-   * \n+   *\n    * <p>Different location abstractions will provide their\n    * own implementations of this interface, based on the level and kind\n    * of precision they provide.\n    */\n   private static interface EffectLocation {\n-    \n+\n     /**\n      * Does the receiver's effect location intersect a given effect location?\n-     * That is, could any of the concrete storage locations (fields, variables, \n+     * That is, could any of the concrete storage locations (fields, variables,\n      * etc.) represented by the receiver be contained in the set of concrete\n      * storage locations represented by the given abstract effect location.\n      */\n     public boolean intersectsLocation(EffectLocation otherLocation);\n-    \n+\n     /**\n      * Returns the result of merging the given effect location with\n      * the receiver. The concrete locations represented by the result must\n      * introduce a loss of precision).\n      */\n     public EffectLocation join(EffectLocation otherLocation);\n-    \n+\n     /**\n      * Does the effect location represent any possible concrete locations?\n      */\n     public boolean isEmpty();\n   }\n-  \n+\n   /**\n    * An abstract class representing a location abstraction. (Here \"abstraction\"\n    * means an imprecise representation of concrete side effects.)\n-   * \n-   * <p>Implementations of this class will each provide own their \n+   *\n+   * <p>Implementations of this class will each provide own their\n    * implementation(s) of SideEffectLocation and methods to determine the side\n    * effect locations of a given piece of code.\n    */\n   private abstract static class LocationAbstraction  {\n-       \n+\n     /** Calculates the abstraction-specific side effects\n      * for the node.\n      */\n     abstract LocationSummary calculateLocationSummary(Node node);\n-    \n+\n     /**\n      * Returns an abstraction-specific EffectLocation representing\n      * no location.\n-     * \n+     *\n      * <p>The bottom location joined with any location should return\n      * that location.\n      */\n     abstract EffectLocation getBottomLocation();\n \n-    /** \n+    /**\n      * Calculates the abstraction-specific side effects\n      * for the node.\n      */\n-    public LocationSummary calculateLocationSummary(Set<Node> nodes) {     \n+    public LocationSummary calculateLocationSummary(Set<Node> nodes) {\n       EffectLocation modAccumulator = getBottomLocation();\n       EffectLocation refAccumulator = getBottomLocation();\n-          \n+\n       for (Node node : nodes) {\n         LocationSummary nodeLocationSummary = calculateLocationSummary(node);\n-         \n+\n         modAccumulator = modAccumulator.join(nodeLocationSummary.getModSet());\n         refAccumulator = refAccumulator.join(nodeLocationSummary.getRefSet());\n       }\n-     \n+\n       return new LocationSummary(modAccumulator, refAccumulator);\n     }\n   }\n    * A very imprecise location abstraction in which there are only two abstract\n    * locations: one representing all concrete locations and one for bottom\n    * (no concrete locations).\n-   * \n+   *\n    * This implementation is a thin wrapper on NodeUtil.mayHaveSideEffects()\n    * and NodeUtil.canBeSideEffected() -- it doesn't add any real value other\n    * than to prototype the LocationAbstraction interface.\n    */\n-  private static class DegenerateLocationAbstraction \n+  private static class DegenerateLocationAbstraction\n       extends LocationAbstraction {\n-    \n+\n     private static final EffectLocation EVERY_LOCATION =\n         new DegenerateEffectLocation();\n-    \n+\n     private static final EffectLocation NO_LOCATION =\n         new DegenerateEffectLocation();\n-    \n+\n     @Override\n     EffectLocation getBottomLocation() {\n       return NO_LOCATION;\n     }\n-    \n+\n     @Override\n     public LocationSummary calculateLocationSummary(Node node) {\n       return new LocationSummary(calculateModSet(node), calculateRefSet(node));\n     }\n-    \n+\n     EffectLocation calculateRefSet(Node node) {\n       if (NodeUtil.canBeSideEffected(node)) {\n         return EVERY_LOCATION;\n         return NO_LOCATION;\n       }\n     }\n-    \n+\n     EffectLocation calculateModSet(Node node) {\n       if (NodeUtil.mayHaveSideEffects(node)) {\n         return EVERY_LOCATION;\n         return NO_LOCATION;\n       }\n     }\n-    \n+\n     private static class DegenerateEffectLocation implements EffectLocation {\n        public EffectLocation join(EffectLocation otherLocation) {\n         if (otherLocation == EVERY_LOCATION) {\n           return this;\n         }\n       }\n-      \n+\n       public boolean intersectsLocation(EffectLocation otherLocation) {\n         return this == EVERY_LOCATION && otherLocation == EVERY_LOCATION;\n       }\n-      \n+\n       public boolean isEmpty() {\n         return this == NO_LOCATION;\n       }\n     }\n   }\n-  \n+\n   /**\n    * A location abstraction based on the visibility of concrete locations.\n-   * \n+   *\n    * A global variables are treated as one common location, as are all heap\n    * storage locations.\n-   * \n+   *\n    * Local variables are broken up into two classes, one for truly local\n    * variables and one for local variables captured by an inner scope. Each\n    * of these classes has their own separate location representing the\n    * variables in the class.\n-   * \n+   *\n    * Parameter variables are considered to be heap locations since they\n    * can be accessed via the arguments object which itself can be aliased.\n-   * \n+   *\n    * A more precise analysis could:\n    *    1) put parameters on the heap only when \"arguments\" is actually used\n    *        in a method\n    *    2) recognize that GETPROPs cannot access or modify parameters, only\n    *        GETELEMs\n-   *        \n+   *\n    * TODO(dcc): Don't merge parameters with the heap unless necessary.\n-   * \n+   *\n    * Internally, abstract locations are represented as integers\n    * with bits set (masks) representing the storage classes in the location, so\n    * that joining is bit-wise ORing and intersection is bitwise AND.\n    */\n-  private static class VisibilityLocationAbstraction \n+  private static class VisibilityLocationAbstraction\n       extends LocationAbstraction {\n \n     /** The \"bottom\" location. Used to signify an empty location set */\n     private static final int VISIBILITY_LOCATION_NONE = 0;\n-    \n+\n     /** The \"top\" location. Used to signify the set containing all locations */\n     private static final int UNKNOWN_LOCATION_MASK = 0xFFFFFFFF;\n-    \n+\n     private static final int LOCAL_VARIABLE_LOCATION_MASK = 1 << 1;\n-        \n+\n     private static final int CAPTURED_LOCAL_VARIABLE_LOCATION_MASK = 1 << 2;\n-    \n+\n     private static final int GLOBAL_VARIABLE_LOCATION_MASK = 1 << 3;\n-    \n+\n     private static final int HEAP_LOCATION_MASK = 1 << 4;\n-    \n+\n     AbstractCompiler compiler;\n-    \n+\n     VariableVisibilityAnalysis variableVisibilityAnalysis;\n     VariableUseDeclarationMap variableUseMap;\n-    \n+\n     private VisibilityLocationAbstraction(AbstractCompiler compiler,\n         VariableVisibilityAnalysis variableVisibilityAnalysis,\n         VariableUseDeclarationMap variableUseMap) {\n       this.variableVisibilityAnalysis = variableVisibilityAnalysis;\n       this.variableUseMap = variableUseMap;\n     }\n-    \n+\n     /**\n      * Calculates the MOD/REF summary for the given node.\n      */\n     @Override\n     LocationSummary calculateLocationSummary(Node node) {\n       int visibilityRefLocations = VISIBILITY_LOCATION_NONE;\n-      int visibilityModLocations = VISIBILITY_LOCATION_NONE;    \n-      \n+      int visibilityModLocations = VISIBILITY_LOCATION_NONE;\n+\n       for (Node reference : findStorageLocationReferences(node)) {\n         int effectMask;\n-        \n+\n         if (NodeUtil.isName(reference)) {\n           // Variable access\n           effectMask = effectMaskForVariableReference(reference);\n          } else {\n-          // Heap access       \n+          // Heap access\n           effectMask = HEAP_LOCATION_MASK;\n         }\n-        \n+\n         if (storageNodeIsLValue(reference)) {\n           visibilityModLocations |= effectMask;\n         }\n-        \n+\n         if (storageNodeIsRValue(reference)) {\n           visibilityRefLocations |= effectMask;\n         }\n-      }      \n-          \n+      }\n+\n       VisibilityBasedEffectLocation modSet =\n           new VisibilityBasedEffectLocation(visibilityModLocations);\n-      \n+\n       VisibilityBasedEffectLocation refSet =\n         new VisibilityBasedEffectLocation(visibilityRefLocations);\n-            \n+\n       return new LocationSummary(modSet, refSet);\n     }\n \n      */\n     private Set<Node> findStorageLocationReferences(Node root) {\n       final Set<Node> references = Sets.newHashSet();\n- \n+\n       NodeTraversal.traverse(compiler, root, new AbstractShallowCallback() {\n         @Override\n         public void visit(NodeTraversal t, Node n, Node parent) {\n           if (NodeUtil.isGet(n)\n               || (NodeUtil.isName(n) && !NodeUtil.isFunction(parent))) {\n             references.add(n);\n-          } \n-        }       \n+          }\n+        }\n       });\n-      \n+\n       return references;\n     }\n-    \n+\n     /**\n      * Calculates the effect mask for a variable reference.\n      */\n-    private int effectMaskForVariableReference(Node variableReference) { \n+    private int effectMaskForVariableReference(Node variableReference) {\n       Preconditions.checkArgument(NodeUtil.isName(variableReference));\n-      \n+\n       int effectMask = VISIBILITY_LOCATION_NONE;\n-      \n-      Node declaringNameNode = \n+\n+      Node declaringNameNode =\n         variableUseMap.findDeclaringNameNodeForUse(variableReference);\n-      \n+\n       if (declaringNameNode != null) {\n-        VariableVisibility visibility = \n+        VariableVisibility visibility =\n           variableVisibilityAnalysis.getVariableVisibility(declaringNameNode);\n-                  \n+\n         switch (visibility) {\n           case LOCAL:\n             effectMask = LOCAL_VARIABLE_LOCATION_MASK;\n             effectMask = GLOBAL_VARIABLE_LOCATION_MASK;\n             break;\n           default:\n-            throw new IllegalStateException(\"Unrecognized variable\" + \n+            throw new IllegalStateException(\"Unrecognized variable\" +\n                 \" visibility: \" + visibility);\n         }\n       } else {\n         // Couldn't find a variable for the reference\n         effectMask = UNKNOWN_LOCATION_MASK;\n       }\n-           \n+\n       return effectMask;\n     }\n-    \n+\n     @Override\n     EffectLocation getBottomLocation() {\n       return new VisibilityBasedEffectLocation(VISIBILITY_LOCATION_NONE);\n     }\n-    \n+\n     /**\n      * Returns true if the node is a storage node.\n-     * \n+     *\n      * Only NAMEs, GETPROPs, and GETELEMs are storage nodes.\n      */\n     private static boolean isStorageNode(Node node) {\n       return NodeUtil.isName(node) || NodeUtil.isGet(node);\n     }\n-    \n+\n     /**\n      * Return true if the storage node is an r-value.\n      */\n     private static boolean storageNodeIsRValue(Node node) {\n       Preconditions.checkArgument(isStorageNode(node));\n-        \n+\n       // We consider all names to be r-values unless\n       // LHS of Token.ASSIGN\n       // LHS of of for in expression\n       // Child of VAR\n-      \n+\n       Node parent = node.getParent();\n-      \n+\n       if (storageNodeIsLValue(node)) {\n         // Assume l-value is NOT an r-value\n         // unless it is a non-simple assign\n         // or an increment/decrement\n-        \n-        boolean nonSimpleAssign = \n+\n+        boolean nonSimpleAssign =\n           NodeUtil.isAssignmentOp(parent) && parent.getType() != Token.ASSIGN;\n-          \n-        return (nonSimpleAssign \n+\n+        return (nonSimpleAssign\n             || parent.getType() == Token.DEC\n-            || parent.getType() == Token.INC);      \n-      }\n-        \n+            || parent.getType() == Token.INC);\n+      }\n+\n       return true;\n     }\n-    \n+\n     /**\n      * Return true if the storage node is an l-value.\n      */\n     private static boolean storageNodeIsLValue(Node node) {\n       Preconditions.checkArgument(isStorageNode(node));\n-     \n+\n       Node parent = node.getParent();\n-   \n+\n       return (NodeUtil.isAssignmentOp(parent) && parent.getFirstChild() == node)\n           || (NodeUtil.isForIn(parent) && parent.getFirstChild() == node)\n           || NodeUtil.isVar(parent)\n           || parent.getType() == Token.DEC\n           || parent.getType() == Token.INC;\n     }\n-    \n+\n     /**\n      * An abstract effect location based the visibility of the\n      * concrete storage location.\n-     * \n+     *\n      * See {@link VisibilityLocationAbstraction} for deeper description\n      * of this abstraction.\n-     * \n+     *\n      * The effect locations are stored as bits set on an integer, so\n      * intersect, join, etc. are the standard bitwise operations.\n      */\n-    private static class VisibilityBasedEffectLocation \n+    private static class VisibilityBasedEffectLocation\n         implements EffectLocation {\n       int visibilityMask = VISIBILITY_LOCATION_NONE;\n-      \n+\n       public VisibilityBasedEffectLocation(int visibilityMask) {\n         this.visibilityMask = visibilityMask;\n       }\n-      \n+\n       @Override\n       public boolean intersectsLocation(EffectLocation otherLocation) {\n-        Preconditions.checkArgument(otherLocation instanceof \n+        Preconditions.checkArgument(otherLocation instanceof\n             VisibilityBasedEffectLocation);\n-        \n-        int otherMask = \n+\n+        int otherMask =\n             ((VisibilityBasedEffectLocation) otherLocation).visibilityMask;\n-        \n+\n         return (visibilityMask & otherMask) > 0;\n       }\n \n \n       @Override\n       public EffectLocation join(EffectLocation otherLocation) {\n-        Preconditions.checkArgument(otherLocation instanceof \n+        Preconditions.checkArgument(otherLocation instanceof\n             VisibilityBasedEffectLocation);\n-        \n-        int otherMask = \n+\n+        int otherMask =\n             ((VisibilityBasedEffectLocation) otherLocation).visibilityMask;\n-        \n+\n         int joinedMask = visibilityMask | otherMask;\n-        \n-        return new VisibilityBasedEffectLocation(joinedMask);       \n-      }   \n-    }\n-  }\n-  \n+\n+        return new VisibilityBasedEffectLocation(joinedMask);\n+      }\n+    }\n+  }\n+\n   /**\n    * Maps NAME nodes that refer to variables to the NAME\n    * nodes that declared them.\n   private static class VariableUseDeclarationMap {\n \n     private AbstractCompiler compiler;\n-    \n+\n     // Maps a using name to its declaring name\n     private Map<Node, Node> referencesByNameNode;\n-    \n+\n     public VariableUseDeclarationMap(AbstractCompiler compiler) {\n       this.compiler = compiler;\n     }\n-    \n+\n     /**\n      * Adds a map from each use NAME in {@code root} to its corresponding\n      * declaring name, *provided the declaration is also under root*.\n-     * \n+     *\n      * If the declaration is not under root, then the reference will\n      * not be added to the map.\n      */\n     public void mapUses(Node root) {\n       referencesByNameNode = Maps.newHashMap();\n-      \n-      ReferenceCollectingCallback callback = \n-        new ReferenceCollectingCallback(compiler, \n+\n+      ReferenceCollectingCallback callback =\n+        new ReferenceCollectingCallback(compiler,\n             ReferenceCollectingCallback.DO_NOTHING_BEHAVIOR);\n-      \n+\n       NodeTraversal.traverse(compiler, root, callback);\n-      \n+\n       for (Var variable : callback.getReferencedVariables()) {\n         ReferenceCollection referenceCollection =\n             callback.getReferenceCollection(variable);\n-             \n-        for (Reference reference : referenceCollection.references) {      \n+\n+        for (Reference reference : referenceCollection.references) {\n          Node referenceNameNode = reference.getNameNode();\n-          \n+\n           // Note that this counts a declaration as a reference to itself\n           referencesByNameNode.put(referenceNameNode, variable.getNameNode());\n         }\n       }\n     }\n-    \n+\n     /**\n      * Returns the NAME node for the declaration of the variable\n      * that {@code usingNameNode} refers to, if it is in the map,\n      */\n     public Node findDeclaringNameNodeForUse(Node usingNameNode) {\n       Preconditions.checkArgument(NodeUtil.isName(usingNameNode));\n-      \n+\n       return referencesByNameNode.get(usingNameNode);\n     }\n   }\n--- a/src/com/google/javascript/jscomp/SimpleFunctionAliasAnalysis.java\n+++ b/src/com/google/javascript/jscomp/SimpleFunctionAliasAnalysis.java\n /**\n  * Uses {@link SimpleDefinitionFinder} to determine if a function has been\n  * aliased or exposed to .call() or .apply().\n- * \n+ *\n  * @author dcc@google.com (Devin Coughlin)\n  */\n class SimpleFunctionAliasAnalysis {\n   private Set<Node> aliasedFunctions;\n-  \n+\n   private Set<Node> functionsExposedToCallOrApply;\n-  \n+\n   /**\n    * Returns true if the function is aliased.\n-   * \n+   *\n    * Must only be called after {@link #analyze(SimpleDefinitionFinder)}\n    * has been called.\n    */\n   public boolean isAliased(Node functionNode) {\n     Preconditions.checkNotNull(aliasedFunctions);\n     Preconditions.checkArgument(NodeUtil.isFunction(functionNode));\n-    \n+\n     return aliasedFunctions.contains(functionNode);\n   }\n-  \n+\n   /**\n    * Returns true if the function ever exposed to .call() or .apply().\n-   * \n+   *\n    * Must only be called after {@link #analyze(SimpleDefinitionFinder)}\n    * has been called.\n    */\n   public boolean isExposedToCallOrApply(Node functionNode) {\n     Preconditions.checkNotNull(functionsExposedToCallOrApply);\n     Preconditions.checkArgument(NodeUtil.isFunction(functionNode));\n-    \n+\n     return functionsExposedToCallOrApply.contains(functionNode);\n   }\n-  \n+\n   /**\n    * Uses the provided {@link SimpleDefinitionFinder} to determine\n    * which functions are aliased or exposed to .call() or .apply().\n    */\n   public void analyze(SimpleDefinitionFinder finder) {\n     Preconditions.checkState(aliasedFunctions == null);\n-    \n+\n     aliasedFunctions = Sets.newHashSet();\n     functionsExposedToCallOrApply = Sets.newHashSet();\n-    \n+\n     for (DefinitionSite definitionSite : finder.getDefinitionSites()) {\n       Definition definition = definitionSite.definition;\n-      \n+\n       if (!definition.isExtern()) {\n         Node rValue = definition.getRValue();\n-        \n+\n         if (rValue != null && NodeUtil.isFunction(rValue)) {\n           // rValue is a Token.FUNCTION from a definition\n-          \n+\n           for (UseSite useSite : finder.getUseSites(definition)) {\n             updateFunctionForUse(rValue, useSite.node);\n-          }          \n-        }     \n+          }\n+        }\n       }\n-    }   \n+    }\n   }\n-  \n+\n   /**\n    * Updates alias and exposure information based a site where the function is\n    * used.\n-   * \n+   *\n    * Note: this method may be called multiple times per Function, each time\n    * with a different useNode.\n    */\n   private void updateFunctionForUse(Node function, Node useNode) {\n     Node useParent = useNode.getParent();\n     int parentType = useParent.getType();\n-    \n+\n     if ((parentType == Token.CALL || parentType == Token.NEW)\n         && useParent.getFirstChild() == useNode) {\n       // Regular call sites don't count as aliases\n     } else if (NodeUtil.isGet(useParent)) {\n       // GET{PROP,ELEM} don't count as aliases\n       // but we have to check for using them in .call and .apply.\n-      \n+\n       if (NodeUtil.isGetProp(useParent)) {\n         Node gramps = useParent.getParent();\n         if (NodeUtil.isFunctionObjectApply(gramps) ||\n--- a/src/com/google/javascript/jscomp/SpecializationAwareCompilerPass.java\n+++ b/src/com/google/javascript/jscomp/SpecializationAwareCompilerPass.java\n \n /**\n  * Interface indicating a CompilerPass is specialization aware.\n- * \n+ *\n  * See {@link SpecializeModule} for details of module specialization.\n- * \n+ *\n  * @author dcc@google.com (Devin Coughlin)\n  *\n  */\n--- a/src/com/google/javascript/jscomp/Tracer.java\n+++ b/src/com/google/javascript/jscomp/Tracer.java\n  * several useful statistics such as cpu time, wait time, and memory usage.\n  * If you add your own tracing statistics, the output is not quite as pretty,\n  * but includes additional useful information.\n- * <pre>\n- *    31.980 Start        [LockManager] Waiting for user lock\n- *   9 31.989 Done    9 ms    0ms cpu;  5944bytes;  [LockManager] Waiting for user lock\n- *   0 31.989 Start        [CssClientImpl] ThreadGet (1 thread)\n- *   5 31.994 Done    5 ms    0ms cpu;  2832bytes;  [CssClientImpl] ThreadGet (1 thread)\n- *   0 31.994 Start        [MessageSorter] sort\n- *   0 31.994 Done    0 ms    0ms cpu;   600bytes;  [MessageSorter] sort\n- *   0 31.994 Start        [ConversationView] getMessageSummaries\n- *   0 31.994 Start        [ConversationView] creating message summary 0\n- *   1 31.995 Done    1 ms    0ms cpu;  5800bytes;  [ConversationView] creating message summary 0\n- *   0 31.995 Start        [ConversationView] creating message summary 1\n- *   0 31.995 Done    0 ms    0ms cpu;  5464bytes;  [ConversationView] creating message summary 1\n- *   . . .\n- * TOTAL NameDetector 3 (0 ms; 0 ms cpu;  784 bytes)\n- * TOTAL Format 4 (1 ms; 0 ms cpu; 7344 bytes)\n- * TOTAL ConversationView 5 (4 ms; 0 ms cpu; 55456 bytes)\n- </pre>\n \n  * <p>If a Trace is given a type (the first argument to the constructor) and\n  * multiple Traces are done on that type then a \"TOTAL line will be\n    */\n   private static volatile boolean defaultPrettyPrint;\n \n-  /* This list is guaranteed to only increase in length.  It contains a list of additional\n-   * statistics that the user wants to keep track of.\n+  /* This list is guaranteed to only increase in length.  It contains\n+   * a list of additional statistics that the user wants to keep track\n+   * of.\n    */\n   private static List<TracingStatistic> extraTracingStatistics =\n       new CopyOnWriteArrayList<TracingStatistic>();\n     if (tracingStatistic.enable()) {\n       // No synchronization needed, since this is a copy-on-write array.\n       extraTracingStatistics.add(tracingStatistic);\n-      // 99.9% of the time, this will be O(1) and return extraTracingStatistics.length - 1\n+      // 99.9% of the time, this will be O(1) and return\n+      // extraTracingStatistics.length - 1\n       return extraTracingStatistics.lastIndexOf(tracingStatistic);\n     } else {\n       return -1;\n   }\n \n   /**\n-   * For testing purposes only.  These removes all current tracers.  Severe errors can occur\n-   * if there are any active tracers going on when this is called.\n+   * For testing purposes only.  These removes all current tracers.\n+   * Severe errors can occur if there are any active tracers going on\n+   * when this is called.\n    *\n    * The test suite uses this to remove any tracers that it has added.\n    */\n \n     stopTimeMs = clock.currentTimeMillis();\n     if (extraTracingValues != null) {\n-      // We use extraTracingValues.length rather than extraTracingStatistics.size() because\n-      // a new statistic may have been added\n+      // We use extraTracingValues.length rather than\n+      // extraTracingStatistics.size() because a new statistic may\n+      // have been added\n       for (int i = 0; i < extraTracingValues.length; i++) {\n         long value = extraTracingStatistics.get(i).stop(startThread);\n         extraTracingValues[i] = value - extraTracingValues[i];\n       if (prevEventTime == -1) {\n         appendSpaces(sb, digitsColWidth);\n       } else {\n-        sb.append(longToPaddedString(eventTime() - prevEventTime, digitsColWidth));\n+        sb.append(longToPaddedString(\n+            eventTime() - prevEventTime, digitsColWidth));\n       }\n \n       sb.append(' ');\n         }\n \n         if (stat.extraInfo != null && t.extraTracingValues != null) {\n-          int overlapLength = Math.min(stat.extraInfo.length, t.extraTracingValues.length);\n+          int overlapLength =\n+              Math.min(stat.extraInfo.length, t.extraTracingValues.length);\n           for (int i = 0; i < overlapLength; i++) {\n             stat.extraInfo[i] += t.extraTracingValues[i];\n-            AtomicTracerStatMap map = extraTracingStatistics.get(i).getTracingStat();\n+            AtomicTracerStatMap map =\n+                extraTracingStatistics.get(i).getTracingStat();\n             if (map != null) {\n               map.incrementBy(t.type, t.extraTracingValues[i]);\n             }\n   }\n \n   /** Holds the ThreadTrace for each thread.  */\n-  private static ThreadLocal<ThreadTrace> traces = new ThreadLocal<ThreadTrace>();\n+  private static ThreadLocal<ThreadTrace> traces =\n+      new ThreadLocal<ThreadTrace>();\n \n   /**\n    * Get the ThreadTrace for the current thread, creating one if necessary.\n   }\n \n   /**\n-   * A TracingStatistic allows the program to add additional optional statistics to the trace\n-   * output.\n+   * A TracingStatistic allows the program to add additional optional\n+   * statistics to the trace output.\n    *\n-   * The class {@link com.google.monitoring.tracing.TracingStatistics} contains several\n-   * useful tracing statistics\n+   * The class {@link com.google.monitoring.tracing.TracingStatistics}\n+   * contains several useful tracing statistics\n    *\n    */\n   static interface TracingStatistic {\n     /**\n-     * This method is called at the start of the trace.  It should return a numeric result\n-     * indicating the amount of the specific resource in use before the call started\n+     * This method is called at the start of the trace.  It should\n+     * return a numeric result indicating the amount of the specific\n+     * resource in use before the call started\n      * @param thread  The current thread\n-     * @return   A numeric value indicating the amount of the resource already used.\n+     * @return A numeric value indicating the amount of the resource\n+     * already used.\n      */\n     long start(Thread thread);\n \n     /**\n-     * This method is called at the end of the trace.  It should return a numeric result\n-     * indicating the amount of the specific resource in use after the call ends. The actual\n-     * reported result will be the result end() - start()\n+     * This method is called at the end of the trace.  It should\n+     * return a numeric result indicating the amount of the specific\n+     * resource in use after the call ends. The actual reported result\n+     * will be the result end() - start()\n      * @param thread  The current thread\n-     * @return   A numeric value indicating the amount of the resource currently used.\n+     * @return A numeric value indicating the amount of the resource\n+     * currently used.\n      */\n     long stop(Thread thread);\n \n     /**\n-     * Called when this tracing statistic is first enabled.  A return value of True indicates that\n-     * this statistic can successfully run in the current JVM.\n+     * Called when this tracing statistic is first enabled.  A return\n+     * value of True indicates that this statistic can successfully\n+     * run in the current JVM.\n      *\n-     * @return  An indication of whether this statistic can be implemented in the current JVM.\n+     * @return An indication of whether this statistic can be\n+     * implemented in the current JVM.\n      */\n     boolean enable();\n \n      */\n     AtomicTracerStatMap getTracingStat();\n \n-    /** A string that should be appended to the numeric output indicating what this is.\n+    /** A string that should be appended to the numeric output\n+     * indicating what this is.\n      *\n      * @return  A string indicating the units of this statistic and what it is.\n      */\n    *\n    */\n   static final class AtomicTracerStatMap {\n-    private ConcurrentMap<String, Long> map = new ConcurrentHashMap<String, Long>();\n+    private ConcurrentMap<String, Long> map =\n+        new ConcurrentHashMap<String, Long>();\n \n     /**\n      * Atomically increment the specified field by the specified amount.\n      * @param key      the name of the field\n      * @param delta    the amount by which to increment the field\n      */\n-    // Nullness checker is not powerful enough to prove null-safety of this method\n+    // Nullness checker is not powerful enough to prove null-safety of\n+    // this method\n     @SuppressWarnings(\"nullness\")\n         void incrementBy(String key, long delta) {\n       // We use a compareAndSet strategy to update the map, which is much\n           // The slot was still empty when we set it\n           return;\n         } else {\n-          // Someone filled in the slot behind our back.  oldValue has its current value\n+          // Someone filled in the slot behind our back.  oldValue has\n+          // its current value\n         }\n       }\n       while (true) {\n--- a/src/com/google/javascript/jscomp/UnreachableCodeElimination.java\n+++ b/src/com/google/javascript/jscomp/UnreachableCodeElimination.java\n         return;\n \n       case Token.BLOCK:\n-        // BLOCKs are used in several ways including wrapping CATCH blocks in TRYs\n+        // BLOCKs are used in several ways including wrapping CATCH\n+        // blocks in TRYs\n         if (parent.getType() == Token.TRY) {\n           if (NodeUtil.isTryCatchNodeContainer(n)) {\n             return;\n--- a/src/com/google/javascript/jscomp/VariableVisibilityAnalysis.java\n+++ b/src/com/google/javascript/jscomp/VariableVisibilityAnalysis.java\n  * An analysis pass that determines the visibility of variables -- that is,\n  * whether a variable is truly local, a local captured by an inner scope, a\n  * parameter, or a global variable.\n- * \n+ *\n  * SideEffectsAnalysis uses this class to partition a potentially infinite\n  * number of concrete storage locations into a (small) finite number of\n  * abstract storage locations based on a variable's storage visibility.\n- * \n+ *\n  * @author dcc@google.com (Devin Coughlin)\n  */\n class VariableVisibilityAnalysis implements CompilerPass {\n \n   enum VariableVisibility {\n-    \n+\n     /** Local variable, not captured by closure */\n     LOCAL,\n-    \n+\n     /** Local variable captured by a closure */\n     CAPTURED_LOCAL,\n-    \n-    /** \n+\n+    /**\n      * Formal parameter declaration variable\n-     * \n+     *\n      * Parameters are different than local variables because they can be\n      * aliased by elements of the arguments object.\n      */\n     PARAMETER,\n-    \n+\n     /** A global variable */\n     GLOBAL\n   }\n-  \n+\n   private AbstractCompiler compiler;\n-  \n+\n   /**\n    * Maps the declaring name node for a variable to that variable's\n    * visibility.\n    */\n   private Map<Node, VariableVisibility> visibilityByDeclaringNameNode;\n-  \n+\n   public VariableVisibilityAnalysis(AbstractCompiler compiler) {\n     this.compiler = compiler;\n-   \n+\n     visibilityByDeclaringNameNode = Maps.newHashMap();\n   }\n-  \n+\n   /**\n    * Returns the visibility of of a variable, given that variable's declaring\n    * name node.\n-   * \n+   *\n    * The name node's parent must be one of:\n    * <pre>\n    *    Token.VAR (for a variable declaration)\n    *    Token.FUNCTION (for a function declaration)\n    *    Token.LP (for a function formal parameter)\n-   * </pre> \n-   * \n+   * </pre>\n+   *\n    * The returned visibility will be one of:\n    * <pre>\n    *    LOCAL_VARIABLE : the variable is a local variable used only in its\n    *        closure\n    *     PARAMETER_VARIABLE : the variable is a formal parameter\n    *     GLOBAL_VARIABLE : the variable is declared in the global scope\n-   *  </pre>  \n-   *    \n+   *  </pre>\n+   *\n    * @param declaringNameNode The name node for a declaration.\n    */\n   public VariableVisibility getVariableVisibility(Node declaringNameNode) {\n     Node parent = declaringNameNode.getParent();\n-    \n+\n     Preconditions.checkArgument(NodeUtil.isVar(parent)\n         || NodeUtil.isFunction(parent)\n         || parent.getType() == Token.LP);\n-    \n+\n     return visibilityByDeclaringNameNode.get(declaringNameNode);\n   }\n- \n+\n   /**\n    * Determines the visibility class for each variable in root.\n    */\n   @Override\n   public void process(Node externs, Node root) {\n-    ReferenceCollectingCallback callback = \n-      new ReferenceCollectingCallback(compiler, \n+    ReferenceCollectingCallback callback =\n+      new ReferenceCollectingCallback(compiler,\n           ReferenceCollectingCallback.DO_NOTHING_BEHAVIOR);\n-    \n+\n     NodeTraversal.traverse(compiler, root, callback);\n-    \n+\n     for (Var variable : callback.getReferencedVariables()) {\n       ReferenceCollection referenceCollection =\n           callback.getReferenceCollection(variable);\n-      \n+\n       VariableVisibility visibility;\n-      \n+\n       if (variableIsParameter(variable)) {\n-        visibility = VariableVisibility.PARAMETER;     \n+        visibility = VariableVisibility.PARAMETER;\n       } else if (variable.isLocal()) {\n         if (referenceCollection.isEscaped()) {\n-          visibility = VariableVisibility.CAPTURED_LOCAL;        \n+          visibility = VariableVisibility.CAPTURED_LOCAL;\n         } else {\n-          visibility = VariableVisibility.LOCAL;          \n+          visibility = VariableVisibility.LOCAL;\n         }\n       } else if (variable.isGlobal()) {\n         visibility = VariableVisibility.GLOBAL;\n         throw new IllegalStateException(\"Un-handled variable visibility for \" +\n             variable);\n       }\n-      \n+\n       visibilityByDeclaringNameNode.put(variable.getNameNode(), visibility);\n-    }   \n+    }\n   }\n-  \n+\n   /**\n    * Returns true if the variable is a formal parameter.\n    */\n   private static boolean variableIsParameter(Var variable) {\n     Node variableParent = variable.getParentNode();\n-    \n+\n     return variableParent != null && variableParent.getType() == Token.LP;\n   }\n }\n--- a/src/com/google/javascript/jscomp/deps/JsFunctionParser.java\n+++ b/src/com/google/javascript/jscomp/deps/JsFunctionParser.java\n \n /**\n  * A parser that can extract dependency information from a .js file.\n- * \n+ *\n  * @author agrieve@google.com (Andrew Grieve)\n  * @author ielashi@google.com (Islam El-Ashi)\n  */\n public class JsFunctionParser extends JsFileLineParser {\n-  \n+\n   public static class SymbolInfo {\n     public final String functionName;\n     public final String symbol;\n-    \n+\n     private SymbolInfo(String functionName, String symbol) {\n       this.functionName = functionName;\n       this.symbol = symbol;\n     }\n   }\n \n-  private static Logger logger = Logger.getLogger(JsFunctionParser.class.getName());\n+  private static Logger logger =\n+      Logger.getLogger(JsFunctionParser.class.getName());\n \n   /** Pattern for matching functions. */\n   private Pattern pattern;\n \n   /** Symbols parsed. */\n   private Collection<SymbolInfo> symbols;\n-  \n+\n   /** Functions to parse */\n   private Collection<String> functionsToParse;\n \n    * @param functions Functions to parse.\n    * @param errorManager Handles parse errors.\n    */\n-  public JsFunctionParser(Collection<String> functions, ErrorManager errorManager) {\n+  public JsFunctionParser(\n+      Collection<String> functions, ErrorManager errorManager) {\n     super(errorManager);\n     functionsToParse = functions;\n     pattern = getPattern(functions);\n \n   /**\n    * Constructs a pattern to extract the arguments of the given functions.\n-   * \n+   *\n    * @param functions Functions to parse.\n    * @return A pattern to extract {@code functions}' arguments.\n    */\n   private Pattern getPattern(Collection<String> functions) {\n     StringBuilder sb = new StringBuilder(\"(?:^|;)\\\\s*(\");\n-    \n+\n     for (String function : functions) {\n       sb.append(Pattern.quote(function) + \"|\");\n     }\n-    \n+\n     // remove last '|'\n     sb.deleteCharAt(sb.length() - 1);\n     sb.append(\")\\\\s*\\\\((.*?)\\\\)\");\n-    \n+\n     return Pattern.compile(sb.toString());\n   }\n-  \n+\n   /**\n    * Parses the given file and returns the dependency information that it\n    * contained.\n    * @return A collection containing all symbols found in the\n    *     file.\n    */\n-  public Collection<SymbolInfo> parseFile(String filePath, String fileContents) {\n+  public Collection<SymbolInfo> parseFile(\n+      String filePath, String fileContents) {\n     return parseReader(filePath, new StringReader(fileContents));\n   }\n \n-  private Collection<SymbolInfo> parseReader(String filePath, Reader fileContents) {\n+  private Collection<SymbolInfo> parseReader(\n+      String filePath, Reader fileContents) {\n     symbols = Lists.newArrayList();\n \n     logger.fine(\"Parsing Source: \" + filePath);\n \n     return symbols;\n   }\n-  \n+\n   /**\n    * Parses a line of javascript, extracting dependency information.\n    */\n         break;\n       }\n     }\n-    \n+\n     if (parseLine) {\n       matcher.reset(line);\n       while (matcher.find()) {\n         hasFunctions = true;\n         String functionName = matcher.group(1);\n-        String arg = parseJsString(matcher.group(2)); // Parse the param.  \n+        String arg = parseJsString(matcher.group(2)); // Parse the param.\n         symbols.add(new SymbolInfo(functionName, arg));\n       }\n     }\n--- a/src/com/google/javascript/rhino/Decompiler.java\n+++ b/src/com/google/javascript/rhino/Decompiler.java\n-/* \n+/*\n  *\n  * ***** BEGIN LICENSE BLOCK *****\n  * Version: MPL 1.1/GPL 2.0\n             case Token.CONST:\n                 result.append(\"const \");\n                 break;\n-            \n+\n             case Token.NOT:\n                 result.append('!');\n                 break;\n--- a/src/com/google/javascript/rhino/FunctionNode.java\n+++ b/src/com/google/javascript/rhino/FunctionNode.java\n-/* \n+/*\n  *\n  * ***** BEGIN LICENSE BLOCK *****\n  * Version: MPL 1.1/GPL 2.0\n--- a/src/com/google/javascript/rhino/JSDocInfoBuilder.java\n+++ b/src/com/google/javascript/rhino/JSDocInfoBuilder.java\n   /**\n    * Adds a textual block to the current marker.\n    */\n-  public void markText(String text, int startLineno, int startCharno, int endLineno,\n-                int endCharno) {\n+  public void markText(String text, int startLineno, int startCharno,\n+      int endLineno, int endCharno) {\n     if (currentMarker != null) {\n       currentMarker.description = new JSDocInfo.StringPosition();\n       currentMarker.description.setItem(text);\n   /**\n    * Adds a type declaration to the current marker.\n    */\n-  public void markTypeNode(Node typeNode, int lineno, int startCharno, int endCharno,\n-                    boolean hasLC) {\n+  public void markTypeNode(Node typeNode, int lineno, int startCharno,\n+      int endCharno, boolean hasLC) {\n     if (currentMarker != null) {\n       currentMarker.type = new JSDocInfo.TypePosition();\n       currentMarker.type.setItem(typeNode);\n    * @return {@code true} if the parameter's description was recorded and\n    *     {@code false} if a parameter with the same name was already defined\n    */\n-  public boolean recordParameterDescription(String parameterName, String description) {\n+  public boolean recordParameterDescription(\n+      String parameterName, String description) {\n     if (currentInfo.documentParam(parameterName, description)) {\n       populated = true;\n       return true;\n    * @return {@code true} if the type's description was recorded and\n    *     {@code false} if a description with the same type was already defined\n    */\n-  public boolean recordThrowDescription(JSTypeExpression type, String description) {\n+  public boolean recordThrowDescription(\n+      JSTypeExpression type, String description) {\n     if (currentInfo.documentThrows(type, description)) {\n       populated = true;\n       return true;\n--- a/src/com/google/javascript/rhino/Kit.java\n+++ b/src/com/google/javascript/rhino/Kit.java\n-/* \n+/*\n  *\n  * ***** BEGIN LICENSE BLOCK *****\n  * Version: MPL 1.1/GPL 2.0\n--- a/src/com/google/javascript/rhino/ObjArray.java\n+++ b/src/com/google/javascript/rhino/ObjArray.java\n-/* \n+/*\n  *\n  * ***** BEGIN LICENSE BLOCK *****\n  * Version: MPL 1.1/GPL 2.0\n import java.io.ObjectOutputStream;\n \n /**\n-Implementation of resizable array with focus on minimizing memory usage by storing few initial array elements in object fields. Can also be used as a stack.\n-*/\n-\n+ * Implementation of resizable array with focus on minimizing memory\n+ * usage by storing few initial array elements in object fields. Can also\n+ * be used as a stack.\n+ */\n public class ObjArray implements Serializable\n {\n     static final long serialVersionUID = 4174889037736658296L;\n--- a/src/com/google/javascript/rhino/Parser.java\n+++ b/src/com/google/javascript/rhino/Parser.java\n                     decompiler.addEOL(Token.LC);\n \n                     nf.addChildToBack(catchblocks,\n-                        nf.createCatch(varName, nameLineno, nameCharno, catchCond,\n-                             statements(), catchLineno, catchCharno));\n+                        nf.createCatch(\n+                            varName, nameLineno, nameCharno, catchCond,\n+                            statements(), catchLineno, catchCharno));\n \n                     mustMatchToken(Token.RC, \"msg.no.brace.after.body\");\n                     decompiler.addEOL(Token.RC);\n             int lineno = ts.getLineno();\n             int charno = ts.getCharno();\n             decompiler.addToken(Token.BITXOR);\n-            pn = nf.createBinary(Token.BITXOR, pn, bitAndExpr(inForInit), lineno,\n+            pn = nf.createBinary(\n+                Token.BITXOR, pn, bitAndExpr(inForInit), lineno,\n                 charno);\n         }\n         return pn;\n              * do we claim to support?\n              */\n \n-            /* Experimental syntax:  allow an object literal to follow a new expression,\n-             * which will mean a kind of anonymous class built with the JavaAdapter.\n-             * the object literal will be passed as an additional argument to the constructor.\n+            /* Experimental syntax: allow an object literal to follow\n+             * a new expression, which will mean a kind of anonymous\n+             * class built with the JavaAdapter.  the object literal\n+             * will be passed as an additional argument to the\n+             * constructor.\n              */\n             tt = peekToken();\n             if (tt == Token.LC) {\n                             // Dot's position\n                             lineno, charno,\n                             // Name's position\n-                            ts.getLineno(), ts.getCharno());                        break;\n+                            ts.getLineno(), ts.getCharno());\n+                        break;\n \n                       // handles: *, *::name, *::*, *::[expr]\n                       case Token.MUL:\n--- a/src/com/google/javascript/rhino/ScriptOrFnNode.java\n+++ b/src/com/google/javascript/rhino/ScriptOrFnNode.java\n-/* \n+/*\n  *\n  * ***** BEGIN LICENSE BLOCK *****\n  * Version: MPL 1.1/GPL 2.0\n--- a/src/com/google/javascript/rhino/TokenStream.java\n+++ b/src/com/google/javascript/rhino/TokenStream.java\n                 else if (c=='o') { if (s.charAt(0)=='d') {id=Id_do; break L0;} }\n                 break L;\n             case 3: switch (s.charAt(0)) {\n-                case 'f': if (s.charAt(2)=='r' && s.charAt(1)=='o') {id=Id_for; break L0;} break L;\n-                case 'i': if (s.charAt(2)=='t' && s.charAt(1)=='n') {id=Id_int; break L0;} break L;\n-                case 'n': if (s.charAt(2)=='w' && s.charAt(1)=='e') {id=Id_new; break L0;} break L;\n-                case 't': if (s.charAt(2)=='y' && s.charAt(1)=='r') {id=Id_try; break L0;} break L;\n-                case 'v': if (s.charAt(2)=='r' && s.charAt(1)=='a') {id=Id_var; break L0;} break L;\n+                case 'f':\n+                  if (s.charAt(2)=='r' && s.charAt(1)=='o') {\n+                    id=Id_for; break L0;\n+                  } break L;\n+                case 'i':\n+                  if (s.charAt(2)=='t' && s.charAt(1)=='n') {\n+                    id=Id_int; break L0;\n+                  } break L;\n+                case 'n':\n+                  if (s.charAt(2)=='w' && s.charAt(1)=='e') {\n+                    id=Id_new; break L0;\n+                  } break L;\n+                case 't':\n+                  if (s.charAt(2)=='y' && s.charAt(1)=='r') {\n+                    id=Id_try; break L0;\n+                  } break L;\n+                case 'v':\n+                  if (s.charAt(2)=='r' && s.charAt(1)=='a') {\n+                    id=Id_var; break L0;\n+                  } break L;\n                 } break L;\n             case 4: switch (s.charAt(0)) {\n                 case 'b': X=\"byte\";id=Id_byte; break L;\n                 case 'c': c=s.charAt(3);\n                     if (c=='e') { if (s.charAt(2)=='s' && s.charAt(1)=='a') {\n                             id=Id_case; break L0;} }\n-                    else if (c=='r') { if (s.charAt(2)=='a' && s.charAt(1)=='h') {\n-                            id=Id_char; break L0;} }\n+                    else if (c=='r') {\n+                      if (s.charAt(2)=='a' && s.charAt(1)=='h') {\n+                        id=Id_char; break L0;\n+                      }\n+                    }\n                     break L;\n                 case 'e': c=s.charAt(3);\n                     if (c=='e') { if (s.charAt(2)=='s' && s.charAt(1)=='l') {\n                             id=Id_else; break L0;} }\n-                    else if (c=='m') { if (s.charAt(2)=='u' && s.charAt(1)=='n') {\n+                    else if (c=='m') {\n+                      if (s.charAt(2)=='u' && s.charAt(1)=='n') {\n                             id=Id_enum; break L0;} }\n                     break L;\n                 case 'g': X=\"goto\";id=Id_goto; break L;\n                 case 't': c=s.charAt(3);\n                     if (c=='e') { if (s.charAt(2)=='u' && s.charAt(1)=='r') {\n                             id=Id_true; break L0;} }\n-                    else if (c=='s') { if (s.charAt(2)=='i' && s.charAt(1)=='h') {\n+                    else if (c=='s') {\n+                      if (s.charAt(2)=='i' && s.charAt(1)=='h') {\n                             id=Id_this; break L0;} }\n                     break L;\n                 case 'v': X=\"void\";id=Id_void; break L;\n--- a/src/com/google/javascript/rhino/jstype/SimpleSlot.java\n+++ b/src/com/google/javascript/rhino/jstype/SimpleSlot.java\n-/* \n+/*\n  *\n  * ***** BEGIN LICENSE BLOCK *****\n  * Version: MPL 1.1/GPL 2.0\n  * file under either the MPL or the GPL.\n  *\n  * ***** END LICENSE BLOCK ***** */\n- \n+\n package com.google.javascript.rhino.jstype;\n \n /**\n--- a/test/com/google/javascript/jscomp/CallGraphTest.java\n+++ b/test/com/google/javascript/jscomp/CallGraphTest.java\n \n /**\n  * Tests for CallGraph.\n- * \n+ *\n  * @author dcc@google.com (Devin Coughlin)\n  */\n public class CallGraphTest extends CompilerTestCase {\n \n   private CallGraph currentProcessor;\n-  \n+\n   private boolean createForwardCallGraph;\n   private boolean createBackwardCallGraph;\n-  \n+\n   @Override\n   protected CompilerPass getProcessor(Compiler compiler) {\n     // We store the new callgraph so it can be tested later\n     currentProcessor = new CallGraph(compiler, createForwardCallGraph,\n         createBackwardCallGraph);\n-    \n+\n     return currentProcessor;\n   }\n-  \n-  static final String SHARED_EXTERNS = \n+\n+  static final String SHARED_EXTERNS =\n       \"var ExternalFunction = function(a) {}\\n\" +\n       \"var externalnamespace = {}\\n\" +\n       \"externalnamespace.prop = function(){};\\n\";\n-  \n+\n   public void testGetFunctionForAstNode() {\n     String source = \"function A() {};\\n\";\n-    \n-    CallGraph callgraph = compileAndRunForward(source);\n-    \n+\n+    CallGraph callgraph = compileAndRunForward(source);\n+\n     CallGraph.Function functionA = callgraph.getUniqueFunctionWithName(\"A\");\n-    \n+\n     Node functionANode = functionA.getAstNode();\n-    \n+\n     assertEquals(functionA, callgraph.getFunctionForAstNode(functionANode));\n   }\n-  \n-  public void testGetAllFunctions() {  \n-    String source = \n+\n+  public void testGetAllFunctions() {\n+    String source =\n         \"function A() {}\\n\" +\n         \"var B = function() {\\n\" +\n-        \"(function C(){A()})()\\n\" + \n+        \"(function C(){A()})()\\n\" +\n         \"};\\n\";\n-      \n-    CallGraph callgraph = compileAndRunForward(source);\n-    \n+\n+    CallGraph callgraph = compileAndRunForward(source);\n+\n     Collection<CallGraph.Function> functions = callgraph.getAllFunctions();\n-    \n+\n     // 3 Functions, plus one for the main function\n     assertEquals(4, functions.size());\n-    \n-    CallGraph.Function functionA = \n+\n+    CallGraph.Function functionA =\n         callgraph.getUniqueFunctionWithName(\"A\");\n     CallGraph.Function functionB =\n         callgraph.getUniqueFunctionWithName(\"B\");\n     CallGraph.Function functionC =\n         callgraph.getUniqueFunctionWithName(\"C\");\n-    \n+\n     assertEquals(\"A\", NodeUtil.getFunctionName(functionA.getAstNode()));\n     assertEquals(\"B\", NodeUtil.getFunctionName(functionB.getAstNode()));\n     assertEquals(\"C\", NodeUtil.getFunctionName(functionC.getAstNode()));\n   }\n-  \n+\n   public void testGetAllFunctionsContainsNormalFunction() {\n     String source = \"function A(){}\\n\";\n-    \n-    CallGraph callgraph = compileAndRunForward(source);\n-        \n+\n+    CallGraph callgraph = compileAndRunForward(source);\n+\n     Collection<CallGraph.Function> allFunctions = callgraph.getAllFunctions();\n-    \n+\n     // 2 functions: one for A() and one for the main function\n     assertEquals(2, allFunctions.size());\n-    \n+\n    assertTrue(allFunctions.contains(callgraph.getUniqueFunctionWithName(\"A\")));\n    assertTrue(allFunctions.contains(callgraph.getMainFunction()));\n   }\n-  \n+\n   public void testGetAllFunctionsContainsVarAssignedLiteralFunction() {\n     String source = \"var A = function(){}\\n\";\n-    \n-    CallGraph callgraph = compileAndRunForward(source);\n-        \n+\n+    CallGraph callgraph = compileAndRunForward(source);\n+\n     Collection<CallGraph.Function> allFunctions = callgraph.getAllFunctions();\n-    \n+\n     // 2 functions: one for A() and one for the global function\n     assertEquals(2, allFunctions.size());\n \n     Function functionA = callgraph.getUniqueFunctionWithName(\"A\");\n-    assertTrue(allFunctions.contains(functionA));  \n+    assertTrue(allFunctions.contains(functionA));\n     assertTrue(allFunctions.contains(callgraph.getMainFunction()));\n   }\n \n   public void testGetAllFunctionsContainsNamespaceAssignedLiteralFunction() {\n-    String source = \n+    String source =\n         \"var namespace = {};\\n\" +\n         \"namespace.A = function(){};\\n\";\n-    \n-    CallGraph callgraph = compileAndRunForward(source);\n-        \n+\n+    CallGraph callgraph = compileAndRunForward(source);\n+\n     Collection<CallGraph.Function> allFunctions = callgraph.getAllFunctions();\n-    \n+\n     // 2 functions: one for namespace.A() and one for the global function\n     assertEquals(2, allFunctions.size());\n \n     assertTrue(allFunctions.contains(\n-        callgraph.getUniqueFunctionWithName(\"namespace.A\")));  \n+        callgraph.getUniqueFunctionWithName(\"namespace.A\")));\n     assertTrue(allFunctions.contains(callgraph.getMainFunction()));\n   }\n- \n+\n   public void testGetAllFunctionsContainsLocalFunction() {\n-    String source = \n+    String source =\n         \"var A = function(){var B = function(){}};\\n\";\n-    \n-    CallGraph callgraph = compileAndRunForward(source);\n-        \n+\n+    CallGraph callgraph = compileAndRunForward(source);\n+\n     Collection<CallGraph.Function> allFunctions = callgraph.getAllFunctions();\n-    \n+\n     // 3 functions: one for A, B, and global function\n     assertEquals(3, allFunctions.size());\n \n   }\n \n   public void testGetAllFunctionsContainsAnonymousFunction() {\n-    String source = \n+    String source =\n         \"var A = function(){(function(){})();};\\n\";\n-    \n-    CallGraph callgraph = compileAndRunForward(source);\n-        \n+\n+    CallGraph callgraph = compileAndRunForward(source);\n+\n     Collection<CallGraph.Function> allFunctions = callgraph.getAllFunctions();\n-    \n+\n     // 3 functions: A, anonymous, and global function\n     assertEquals(3, allFunctions.size());\n \n         allFunctions.contains(callgraph.getUniqueFunctionWithName(null)));\n     assertTrue(allFunctions.contains(callgraph.getMainFunction()));\n   }\n-  \n+\n   public void testGetCallsiteForAstNode() {\n     String source =\n         \"function A() {B()};\\n\" +\n         \"function B(){};\\n\";\n-    \n+\n     CallGraph callgraph = compileAndRunBackward(source);\n-    \n-    CallGraph.Function functionA = callgraph.getUniqueFunctionWithName(\"A\");   \n+\n+    CallGraph.Function functionA = callgraph.getUniqueFunctionWithName(\"A\");\n     CallGraph.Callsite callToB =\n         functionA.getCallsitesInFunction().iterator().next();\n-    \n+\n     Node callsiteNode = callToB.getAstNode();\n-    \n+\n     assertEquals(callToB, callgraph.getCallsiteForAstNode(callsiteNode));\n   }\n-    \n-  public void testFunctionGetCallsites() {  \n-    String source = \n+\n+  public void testFunctionGetCallsites() {\n+    String source =\n         \"function A() {var x; x()}\\n\" +\n         \"var B = function() {\\n\" +\n-        \"(function C(){A()})()\\n\" + \n+        \"(function C(){A()})()\\n\" +\n         \"};\\n\";\n-      \n-    CallGraph callgraph = compileAndRunForward(source);\n-    \n-    CallGraph.Function functionA = callgraph.getUniqueFunctionWithName(\"A\");  \n+\n+    CallGraph callgraph = compileAndRunForward(source);\n+\n+    CallGraph.Function functionA = callgraph.getUniqueFunctionWithName(\"A\");\n     Collection<CallGraph.Callsite> callsitesInA =\n         functionA.getCallsitesInFunction();\n-    \n+\n     assertEquals(1, callsitesInA.size());\n-    \n+\n     CallGraph.Callsite firstCallsiteInA =\n         callsitesInA.iterator().next();\n-    \n+\n     Node aTargetExpression = firstCallsiteInA.getAstNode().getFirstChild();\n     assertEquals(Token.NAME, aTargetExpression.getType());\n     assertEquals(\"x\", aTargetExpression.getString());\n-       \n+\n     CallGraph.Function functionB =\n         callgraph.getUniqueFunctionWithName(\"B\");\n-    \n+\n     Collection<CallGraph.Callsite> callsitesInB =\n         functionB.getCallsitesInFunction();\n-    \n+\n     assertEquals(1, callsitesInB.size());\n-    \n+\n     CallGraph.Callsite firstCallsiteInB =\n       callsitesInB.iterator().next();\n-    \n+\n     Node bTargetExpression = firstCallsiteInB.getAstNode().getFirstChild();\n     assertEquals(Token.FUNCTION, bTargetExpression.getType());\n     assertEquals(\"C\", NodeUtil.getFunctionName(bTargetExpression));\n-    \n+\n     CallGraph.Function functionC =\n         callgraph.getUniqueFunctionWithName(\"C\");\n-    \n+\n     Collection<CallGraph.Callsite> callsitesInC =\n         functionC.getCallsitesInFunction();\n     assertEquals(1, callsitesInC.size());\n-    \n+\n     CallGraph.Callsite firstCallsiteInC =\n       callsitesInC.iterator().next();\n-    \n+\n     Node cTargetExpression = firstCallsiteInC.getAstNode().getFirstChild();\n     assertEquals(Token.NAME, aTargetExpression.getType());\n     assertEquals(\"A\", cTargetExpression.getString());\n   }\n-  \n+\n   public void testFindNewInFunction() {\n     String source = \"function A() {var x; new x(1,2)}\\n;\";\n-      \n-    CallGraph callgraph = compileAndRunForward(source);\n-  \n+\n+    CallGraph callgraph = compileAndRunForward(source);\n+\n     CallGraph.Function functionA =\n         callgraph.getUniqueFunctionWithName(\"A\");\n     Collection<CallGraph.Callsite> callsitesInA =\n         functionA.getCallsitesInFunction();\n     assertEquals(1, callsitesInA.size());\n-    \n+\n     Node callsiteInA = callsitesInA.iterator().next().getAstNode();\n     assertEquals(Token.NEW, callsiteInA.getType());\n-    \n+\n     Node aTargetExpression = callsiteInA.getFirstChild();\n     assertEquals(Token.NAME, aTargetExpression.getType());\n     assertEquals(\"x\", aTargetExpression.getString());\n   }\n-  \n+\n   public void testFindCallsiteTargetGlobalName() {\n-    String source = \n+    String source =\n       \"function A() {}\\n\" +\n       \"function B() {}\\n\" +\n       \"function C() {A()}\\n\";\n-    \n-    CallGraph callgraph = compileAndRunForward(source);\n-    \n+\n+    CallGraph callgraph = compileAndRunForward(source);\n+\n     CallGraph.Function functionC =\n         callgraph.getUniqueFunctionWithName(\"C\");\n     assertNotNull(functionC);\n-    \n+\n     CallGraph.Callsite callsiteInC =\n         functionC.getCallsitesInFunction().iterator().next();\n     assertNotNull(callsiteInC);\n-    \n+\n     Collection<CallGraph.Function> targetsOfCallsiteInC =\n         callsiteInC.getPossibleTargets();\n-    \n+\n     assertNotNull(targetsOfCallsiteInC);\n-    assertEquals(1, targetsOfCallsiteInC.size());    \n-  }\n-  \n+    assertEquals(1, targetsOfCallsiteInC.size());\n+  }\n+\n   public void testFindCallsiteTargetAliasedGlobalProperty() {\n-    String source = \n+    String source =\n         \"var namespace = {};\\n\" +\n         \"namespace.A = function() {};\\n\" +\n         \"function C() {namespace.A()}\\n\";\n-    \n-    CallGraph callgraph = compileAndRunForward(source);\n-    \n+\n+    CallGraph callgraph = compileAndRunForward(source);\n+\n     CallGraph.Function functionC =\n         callgraph.getUniqueFunctionWithName(\"C\");\n     assertNotNull(functionC);\n-    \n+\n     CallGraph.Callsite callsiteInC =\n         functionC.getCallsitesInFunction().iterator().next();\n-    \n+\n     assertNotNull(callsiteInC);\n-    \n+\n     Collection<CallGraph.Function> targetsOfCallsiteInC =\n         callsiteInC.getPossibleTargets();\n-    \n+\n     assertNotNull(targetsOfCallsiteInC);\n-    assertEquals(1, targetsOfCallsiteInC.size());    \n-  }\n-  \n+    assertEquals(1, targetsOfCallsiteInC.size());\n+  }\n+\n   public void testGetAllCallsitesContainsMultiple() {\n-    String source = \n+    String source =\n         \"function A() {}\\n\" +\n         \"var B = function() {\\n\" +\n-        \"(function (){A()})()\\n\" + \n+        \"(function (){A()})()\\n\" +\n         \"};\\n\" +\n         \"A();\\n\" +\n         \"B();\\n\";\n-    \n+\n     CallGraph callgraph = compileAndRunBackward(source);\n-    \n+\n     Collection<CallGraph.Callsite> allCallsites = callgraph.getAllCallsites();\n-    \n+\n     assertEquals(4, allCallsites.size());\n   }\n-  \n+\n   public void testGetAllCallsitesContainsGlobalSite() {\n     String source =\n         \"function A(){}\\n\" +\n         \"A();\\n\";\n-    \n+\n     CallGraph callgraph = compileAndRunBackward(source);\n-    \n+\n     Collection<CallGraph.Callsite> allCallsites = callgraph.getAllCallsites();\n     assertEquals(1, allCallsites.size());\n-    \n-    Node callsiteNode = allCallsites.iterator().next().getAstNode();\n-    assertEquals(Token.CALL, callsiteNode.getType());\n-    assertEquals(\"A\", callsiteNode.getFirstChild().getString()); \n-  }\n-  \n-  public void testGetAllCallsitesContainsLocalSite() {\n-    String source =\n-        \"function A(){}\\n\" +\n-        \"function B(){A();}\\n\";\n-  \n-    CallGraph callgraph = compileAndRunBackward(source);\n-  \n-    Collection<CallGraph.Callsite> allCallsites = callgraph.getAllCallsites();\n-    assertEquals(1, allCallsites.size());\n-  \n+\n     Node callsiteNode = allCallsites.iterator().next().getAstNode();\n     assertEquals(Token.CALL, callsiteNode.getType());\n     assertEquals(\"A\", callsiteNode.getFirstChild().getString());\n   }\n-  \n+\n+  public void testGetAllCallsitesContainsLocalSite() {\n+    String source =\n+        \"function A(){}\\n\" +\n+        \"function B(){A();}\\n\";\n+\n+    CallGraph callgraph = compileAndRunBackward(source);\n+\n+    Collection<CallGraph.Callsite> allCallsites = callgraph.getAllCallsites();\n+    assertEquals(1, allCallsites.size());\n+\n+    Node callsiteNode = allCallsites.iterator().next().getAstNode();\n+    assertEquals(Token.CALL, callsiteNode.getType());\n+    assertEquals(\"A\", callsiteNode.getFirstChild().getString());\n+  }\n+\n   public void testGetAllCallsitesContainsLiteralSite() {\n     String source = \"function A(){(function(a){})();}\\n\";\n-    \n+\n     CallGraph callgraph = compileAndRunBackward(source);\n \n     Collection<CallGraph.Callsite> allCallsites = callgraph.getAllCallsites();\n \n     Node callsiteNode = allCallsites.iterator().next().getAstNode();\n     assertEquals(Token.CALL, callsiteNode.getType());\n-    assertEquals(Token.FUNCTION, callsiteNode.getFirstChild().getType());    \n-  }\n-  \n+    assertEquals(Token.FUNCTION, callsiteNode.getFirstChild().getType());\n+  }\n+\n   public void testGetAllCallsitesContainsConstructorSite() {\n     String source =\n         \"function A(){}\\n\" +\n     assertEquals(Token.NEW, callsiteNode.getType());\n     assertEquals(\"A\", callsiteNode.getFirstChild().getString());\n   }\n-  \n+\n   /**\n    * Test getting a backward directed graph on a backward call graph\n    * and propagating over it.\n    */\n-  public void testGetDirectedGraph_backwardOnBackward() { \n+  public void testGetDirectedGraph_backwardOnBackward() {\n     // For this test we create a simple callback that when, applied until a\n     // fixedpoint, computes whether a function is \"poisoned\" by an extern.\n     // A function is poisoned if it calls an extern or if it calls another\n     // poisoned function.\n-    \n+\n     String source =\n         \"function A(){};\\n\" +\n         \"function B(){ExternalFunction(6); C(); D();}\\n\" +\n         \"function D(){A();};\\n\" +\n         \"function E(){C()};\\n\" +\n         \"A();\\n\";\n-        \n+\n     CallGraph callgraph = compileAndRunBackward(source);\n-    \n+\n     final Set<Function> poisonedFunctions = Sets.newHashSet();\n-    \n+\n     // Set up initial poisoned functions\n     for (Callsite callsite : callgraph.getAllCallsites()) {\n       if (callsite.hasExternTarget()) {\n         poisonedFunctions.add(callsite.getContainingFunction());\n       }\n     }\n-    \n+\n     // Propagate poison from callees to callers\n     EdgeCallback<CallGraph.Function, CallGraph.Callsite> edgeCallback =\n         new EdgeCallback<CallGraph.Function, CallGraph.Callsite>() {\n           public boolean traverseEdge(Function callee, Callsite callsite,\n               Function caller) {\n             boolean changed;\n-            \n+\n             if (poisonedFunctions.contains(callee)) {\n               changed = poisonedFunctions.add(caller); // Returns true if added\n             } else {\n               changed = false;\n             }\n-            \n+\n             return changed;\n           }\n     };\n-    \n+\n     FixedPointGraphTraversal.newTraversal(edgeCallback)\n-        .computeFixedPoint(callgraph.getBackwardDirectedGraph());  \n-    \n+        .computeFixedPoint(callgraph.getBackwardDirectedGraph());\n+\n     // We expect B, C, and E to poisoned.\n     assertEquals(3, poisonedFunctions.size());\n-    \n+\n     assertTrue(poisonedFunctions.contains(\n         callgraph.getUniqueFunctionWithName(\"B\")));\n     assertTrue(poisonedFunctions.contains(\n         callgraph.getUniqueFunctionWithName(\"C\")));\n     assertTrue(poisonedFunctions.contains(\n-        callgraph.getUniqueFunctionWithName(\"E\")));   \n-  }\n-  \n+        callgraph.getUniqueFunctionWithName(\"E\")));\n+  }\n+\n   /**\n    * Test getting a backward directed graph on a forward call graph\n    * and propagating over it.\n    */\n-  public void testGetDirectedGraph_backwardOnForward() { \n+  public void testGetDirectedGraph_backwardOnForward() {\n     // For this test we create a simple callback that when, applied until a\n     // fixedpoint, computes whether a function is \"poisoned\" by an extern.\n     // A function is poisoned if it calls an extern or if it calls another\n     // poisoned function.\n-    \n+\n     String source =\n         \"function A(){};\\n\" +\n         \"function B(){ExternalFunction(6); C(); D();}\\n\" +\n         \"function D(){A();};\\n\" +\n         \"function E(){C()};\\n\" +\n         \"A();\\n\";\n-        \n-    CallGraph callgraph = compileAndRunForward(source);\n-    \n+\n+    CallGraph callgraph = compileAndRunForward(source);\n+\n     final Set<Function> poisonedFunctions = Sets.newHashSet();\n-    \n+\n     // Set up initial poisoned functions\n     for (Callsite callsite : callgraph.getAllCallsites()) {\n       if (callsite.hasExternTarget()) {\n         poisonedFunctions.add(callsite.getContainingFunction());\n       }\n     }\n-    \n+\n     // Propagate poison from callees to callers\n     EdgeCallback<CallGraph.Function, CallGraph.Callsite> edgeCallback =\n         new EdgeCallback<CallGraph.Function, CallGraph.Callsite>() {\n           public boolean traverseEdge(Function callee, Callsite callsite,\n               Function caller) {\n             boolean changed;\n-            \n+\n             if (poisonedFunctions.contains(callee)) {\n               changed = poisonedFunctions.add(caller); // Returns true if added\n             } else {\n               changed = false;\n             }\n-            \n+\n             return changed;\n           }\n     };\n-    \n+\n     FixedPointGraphTraversal.newTraversal(edgeCallback)\n-        .computeFixedPoint(callgraph.getBackwardDirectedGraph());  \n-    \n+        .computeFixedPoint(callgraph.getBackwardDirectedGraph());\n+\n     // We expect B, C, and E to poisoned.\n     assertEquals(3, poisonedFunctions.size());\n-    \n+\n     assertTrue(poisonedFunctions.contains(\n         callgraph.getUniqueFunctionWithName(\"B\")));\n     assertTrue(poisonedFunctions.contains(\n         callgraph.getUniqueFunctionWithName(\"C\")));\n     assertTrue(poisonedFunctions.contains(\n-        callgraph.getUniqueFunctionWithName(\"E\")));   \n-  }\n-  \n+        callgraph.getUniqueFunctionWithName(\"E\")));\n+  }\n+\n   /**\n    * Test getting a forward directed graph on a forward call graph\n    * and propagating over it.\n    */\n-  public void testGetDirectedGraph_forwardOnForward() { \n+  public void testGetDirectedGraph_forwardOnForward() {\n     // For this test we create a simple callback that when, applied until a\n     // fixedpoint, computes whether a function is reachable from an initial\n     // set of \"root\" nodes.\n-    \n+\n     String source =\n         \"function A(){B()};\\n\" +\n         \"function B(){C();D()}\\n\" +\n         \"function D(){};\\n\" +\n         \"function E(){C()};\\n\" +\n         \"function X(){Y()};\\n\" +\n-        \"function Y(){Z()};\\n\" + \n+        \"function Y(){Z()};\\n\" +\n         \"function Z(){};\" +\n         \"B();\\n\";\n-        \n-    CallGraph callgraph = compileAndRunForward(source);\n-    \n+\n+    CallGraph callgraph = compileAndRunForward(source);\n+\n     final Set<Function> reachableFunctions = Sets.newHashSet();\n-    \n+\n     // We assume the main function and X are our roots\n     reachableFunctions.add(callgraph.getMainFunction());\n     reachableFunctions.add(callgraph.getUniqueFunctionWithName(\"X\"));\n-    \n+\n     // Propagate reachability from callers to callees\n-    \n+\n     EdgeCallback<CallGraph.Function, CallGraph.Callsite> edgeCallback =\n         new EdgeCallback<CallGraph.Function, CallGraph.Callsite>() {\n           @Override\n           public boolean traverseEdge(Function caller, Callsite callsite,\n               Function callee) {\n             boolean changed;\n-            \n+\n             if (reachableFunctions.contains(caller)) {\n               changed = reachableFunctions.add(callee); // Returns true if added\n             } else {\n               changed = false;\n             }\n-            \n+\n             return changed;\n           }\n     };\n-    \n+\n     FixedPointGraphTraversal.newTraversal(edgeCallback)\n-        .computeFixedPoint(callgraph.getForwardDirectedGraph());  \n-    \n+        .computeFixedPoint(callgraph.getForwardDirectedGraph());\n+\n     // We expect B, C, D, X, Y, Z and the main function should be reachable.\n     // A and E should not be reachable.\n-    \n+\n     assertEquals(7, reachableFunctions.size());\n-  \n+\n     assertTrue(reachableFunctions.contains(\n         callgraph.getUniqueFunctionWithName(\"B\")));\n     assertTrue(reachableFunctions.contains(\n         callgraph.getUniqueFunctionWithName(\"Z\")));\n     assertTrue(reachableFunctions.contains(\n         callgraph.getMainFunction()));\n-    \n+\n     assertFalse(reachableFunctions.contains(\n         callgraph.getUniqueFunctionWithName(\"A\")));\n     assertFalse(reachableFunctions.contains(\n-        callgraph.getUniqueFunctionWithName(\"E\"))); \n-  }\n-  \n+        callgraph.getUniqueFunctionWithName(\"E\")));\n+  }\n+\n   /**\n    * Test getting a backward directed graph on a forward call graph\n    * and propagating over it.\n    */\n-  public void testGetDirectedGraph_forwardOnBackward() { \n+  public void testGetDirectedGraph_forwardOnBackward() {\n     // For this test we create a simple callback that when, applied until a\n     // fixedpoint, computes whether a function is reachable from an initial\n     // set of \"root\" nodes.\n-    \n+\n     String source =\n         \"function A(){B()};\\n\" +\n         \"function B(){C();D()}\\n\" +\n         \"function D(){};\\n\" +\n         \"function E(){C()};\\n\" +\n         \"function X(){Y()};\\n\" +\n-        \"function Y(){Z()};\\n\" + \n+        \"function Y(){Z()};\\n\" +\n         \"function Z(){};\" +\n         \"B();\\n\";\n-        \n+\n     CallGraph callgraph = compileAndRunBackward(source);\n-    \n+\n     final Set<Function> reachableFunctions = Sets.newHashSet();\n-    \n+\n     // We assume the main function and X are our roots\n     reachableFunctions.add(callgraph.getMainFunction());\n     reachableFunctions.add(callgraph.getUniqueFunctionWithName(\"X\"));\n-    \n+\n     // Propagate reachability from callers to callees\n-    \n+\n     EdgeCallback<CallGraph.Function, CallGraph.Callsite> edgeCallback =\n         new EdgeCallback<CallGraph.Function, CallGraph.Callsite>() {\n           @Override\n           public boolean traverseEdge(Function caller, Callsite callsite,\n               Function callee) {\n             boolean changed;\n-            \n+\n             if (reachableFunctions.contains(caller)) {\n               changed = reachableFunctions.add(callee); // Returns true if added\n             } else {\n               changed = false;\n             }\n-            \n+\n             return changed;\n           }\n     };\n-    \n+\n     FixedPointGraphTraversal.newTraversal(edgeCallback)\n-        .computeFixedPoint(callgraph.getForwardDirectedGraph());  \n-    \n+        .computeFixedPoint(callgraph.getForwardDirectedGraph());\n+\n     // We expect B, C, D, X, Y, Z and the main function should be reachable.\n     // A and E should not be reachable.\n-    \n+\n     assertEquals(7, reachableFunctions.size());\n-  \n+\n     assertTrue(reachableFunctions.contains(\n         callgraph.getUniqueFunctionWithName(\"B\")));\n     assertTrue(reachableFunctions.contains(\n         callgraph.getUniqueFunctionWithName(\"Z\")));\n     assertTrue(reachableFunctions.contains(\n         callgraph.getMainFunction()));\n-    \n+\n     assertFalse(reachableFunctions.contains(\n         callgraph.getUniqueFunctionWithName(\"A\")));\n     assertFalse(reachableFunctions.contains(\n-        callgraph.getUniqueFunctionWithName(\"E\"))); \n-  }\n-  \n+        callgraph.getUniqueFunctionWithName(\"E\")));\n+  }\n+\n   public void testFunctionIsMain() {\n     String source =\n         \"function A(){};\\n\" +\n         \"A();\\n\";\n-      \n+\n     CallGraph callgraph = compileAndRunForward(source);\n \n     CallGraph.Function mainFunction = callgraph.getMainFunction();\n-    \n+\n     assertTrue(mainFunction.isMain());\n     assertNotNull(mainFunction.getBodyNode());\n     assertTrue(mainFunction.getBodyNode().getType() == Token.BLOCK);\n-    \n+\n     CallGraph.Function functionA = callgraph.getUniqueFunctionWithName(\"A\");\n-    \n+\n     assertFalse(functionA.isMain());\n   }\n-  \n+\n   public void testFunctionGetAstNode() {\n     String source =\n         \"function A(){};\\n\" +\n         \"A();\\n\";\n-      \n-    CallGraph callgraph = compileAndRunForward(source);\n-  \n+\n+    CallGraph callgraph = compileAndRunForward(source);\n+\n     CallGraph.Function mainFunction = callgraph.getMainFunction();\n-    \n+\n     // Main function's AST node should be the global block\n     assertTrue(mainFunction.getAstNode().getType() == Token.BLOCK);\n-    \n+\n     CallGraph.Function functionA = callgraph.getUniqueFunctionWithName(\"A\");\n-    \n+\n     // Regular function's AST node should be the function for A\n     assertTrue(functionA.getAstNode().getType() == Token.FUNCTION);\n     assertEquals(\"A\", NodeUtil.getFunctionName(functionA.getAstNode()));\n   }\n-  \n+\n   public void testFunctionGetBodyNode() {\n     String source =\n         \"function A(){};\\n\" +\n         \"A();\\n\";\n-      \n-    CallGraph callgraph = compileAndRunForward(source);\n-  \n+\n+    CallGraph callgraph = compileAndRunForward(source);\n+\n     CallGraph.Function mainFunction = callgraph.getMainFunction();\n-    \n+\n     // Main function's body node should its AST node\n     assertEquals(mainFunction.getAstNode(), mainFunction.getBodyNode());\n-    \n+\n     CallGraph.Function functionA = callgraph.getUniqueFunctionWithName(\"A\");\n-    \n+\n     // Regular function's body node should be the block for A\n     assertTrue(functionA.getBodyNode().getType() == Token.BLOCK);\n     assertEquals(NodeUtil.getFunctionBody(functionA.getAstNode()),\n         functionA.getBodyNode());\n   }\n- \n+\n   public void testFunctionGetName() {\n     String source =\n         \"function A(){};\\n\" +\n         \"A();\\n\";\n-      \n-    CallGraph callgraph = compileAndRunForward(source);\n-  \n+\n+    CallGraph callgraph = compileAndRunForward(source);\n+\n     CallGraph.Function mainFunction = callgraph.getMainFunction();\n-    \n+\n     // Main function's name should be CallGraph.MAIN_FUNCTION_NAME\n     assertEquals(CallGraph.MAIN_FUNCTION_NAME, mainFunction.getName());\n-    \n+\n     CallGraph.Function functionA = callgraph.getUniqueFunctionWithName(\"A\");\n-    \n+\n     // Regular function's name should be its name\n     assertEquals(NodeUtil.getFunctionName(functionA.getAstNode()),\n         functionA.getName());\n   }\n-  \n+\n   public void testFunctionGetCallsitesInFunction() {\n     String source =\n         \"function A(){};\\n\" +\n         \"function B(){A()};\\n\" +\n         \"A();\\n\" +\n         \"B();\\n\";\n-      \n-    CallGraph callgraph = compileAndRunForward(source);\n-  \n+\n+    CallGraph callgraph = compileAndRunForward(source);\n+\n     // Main function calls A and B\n     CallGraph.Function mainFunction = callgraph.getMainFunction();\n     List<String> callsiteNamesInMain =\n         getCallsiteTargetNames(mainFunction.getCallsitesInFunction());\n-     \n+\n     assertEquals(2, callsiteNamesInMain.size());\n-    assertTrue(callsiteNamesInMain.contains(\"A\"));    \n+    assertTrue(callsiteNamesInMain.contains(\"A\"));\n     assertTrue(callsiteNamesInMain.contains(\"B\"));\n-    \n+\n     // A calls no functions\n-    CallGraph.Function functionA = callgraph.getUniqueFunctionWithName(\"A\");  \n+    CallGraph.Function functionA = callgraph.getUniqueFunctionWithName(\"A\");\n     assertEquals(0, functionA.getCallsitesInFunction().size());\n-    \n+\n     // B calls A\n     CallGraph.Function functionB = callgraph.getUniqueFunctionWithName(\"B\");\n     List<String> callsiteNamesInB =\n         getCallsiteTargetNames(functionB.getCallsitesInFunction());\n-    \n+\n     assertEquals(1, callsiteNamesInB.size());\n     assertTrue(callsiteNamesInMain.contains(\"A\"));\n   }\n-  \n+\n   public void testFunctionGetCallsitesInFunction_ignoreInnerFunction() {\n     String source =\n         \"function A(){var B = function(){C();}};\\n\" +\n         \"function C(){};\\n\";\n-      \n-    CallGraph callgraph = compileAndRunForward(source);\n-  \n+\n+    CallGraph callgraph = compileAndRunForward(source);\n+\n     // A calls no functions (and especially not C)\n-    CallGraph.Function functionA = callgraph.getUniqueFunctionWithName(\"A\");  \n+    CallGraph.Function functionA = callgraph.getUniqueFunctionWithName(\"A\");\n     assertEquals(0, functionA.getCallsitesInFunction().size());\n   }\n-  \n+\n   public void testFunctionGetCallsitesPossiblyTargetingFunction() {\n     String source =\n         \"function A(){B()};\\n\" +\n         \"function B(){C();C();};\\n\" +\n         \"function C(){C()};\\n\" +\n         \"A();\\n\";\n-    \n+\n     CallGraph callgraph = compileAndRunBackward(source);\n-    \n+\n     Function main = callgraph.getMainFunction();\n     Function functionA = callgraph.getUniqueFunctionWithName(\"A\");\n     Function functionB = callgraph.getUniqueFunctionWithName(\"B\");\n     Function functionC = callgraph.getUniqueFunctionWithName(\"C\");\n-    \n+\n     assertEquals(0, main.getCallsitesPossiblyTargetingFunction().size());\n-    \n+\n     Collection<Callsite> callsitesTargetingA =\n         functionA.getCallsitesPossiblyTargetingFunction();\n-       \n+\n     // A is called only from the main function\n     assertEquals(1, callsitesTargetingA.size());\n     assertEquals(main,\n         callsitesTargetingA.iterator().next().getContainingFunction());\n-    \n+\n     Collection<Callsite> callsitesTargetingB =\n       functionB.getCallsitesPossiblyTargetingFunction();\n-  \n+\n     // B is called only from A\n     assertEquals(1, callsitesTargetingB.size());\n     assertEquals(functionA,\n         callsitesTargetingB.iterator().next().getContainingFunction());\n-    \n+\n     Collection<Callsite> callsitesTargetingC =\n       functionC.getCallsitesPossiblyTargetingFunction();\n-    \n+\n     // C is called 3 times: twice from B and once from C\n     assertEquals(3, callsitesTargetingC.size());\n-    \n+\n     Collection<Callsite> expectedFunctionsCallingC =\n         Sets.newHashSet(functionB.getCallsitesInFunction());\n     expectedFunctionsCallingC.addAll(functionC.getCallsitesInFunction());\n-    \n-    assertTrue(callsitesTargetingC.containsAll(expectedFunctionsCallingC)); \n-  }\n-  \n+\n+    assertTrue(callsitesTargetingC.containsAll(expectedFunctionsCallingC));\n+  }\n+\n   public void testFunctionGetCallsitesInFunction_newIsCallsite() {\n     String source =\n         \"function A(){};\\n\" +\n         \"function C(){new A()};\\n\";\n-      \n-    CallGraph callgraph = compileAndRunForward(source);\n-  \n+\n+    CallGraph callgraph = compileAndRunForward(source);\n+\n     // The call to new A() in C() should count as a callsite\n-    CallGraph.Function functionC = callgraph.getUniqueFunctionWithName(\"C\");  \n+    CallGraph.Function functionC = callgraph.getUniqueFunctionWithName(\"C\");\n     assertEquals(1, functionC.getCallsitesInFunction().size());\n   }\n-  \n-  public void testFunctionGetIsAliased() { \n-    // Aliased by VAR assignment   \n+\n+  public void testFunctionGetIsAliased() {\n+    // Aliased by VAR assignment\n     String source =\n         \"function A(){};\\n\" +\n         \"var ns = {};\\n\" +\n         \"var aliasB = ns.B;\\n\" +\n         \"var aliasC = C;\\n\" +\n         \"D();\";\n-      \n+\n     compileAndRunForward(source);\n-  \n+\n     assertFunctionAliased(true, \"A\");\n     assertFunctionAliased(true, \"ns.B\");\n     assertFunctionAliased(true, \"C\");\n     assertFunctionAliased(false, \"D\");\n-    \n-    // Aliased by normal assignment   \n+\n+    // Aliased by normal assignment\n     source =\n         \"function A(){};\\n\" +\n         \"var ns = {};\\n\" +\n         \"var aliasC;\\n\" +\n         \"aliasC = C;\\n\" +\n         \"ns.D();\";\n-      \n+\n     compileAndRunForward(source);\n-  \n+\n     assertFunctionAliased(true, \"A\");\n     assertFunctionAliased(true, \"ns.B\");\n     assertFunctionAliased(true, \"C\");\n     assertFunctionAliased(false, \"ns.D\");\n-    \n-    // Aliased by passing as parameter  \n+\n+    // Aliased by passing as parameter\n     source =\n         \"function A(){};\\n\" +\n         \"var ns = {};\\n\" +\n         \"foo(ns.B)\\n\" +\n         \"foo(C);\\n\" +\n         \"D();\";\n-      \n+\n     compileAndRunForward(source);\n-  \n+\n     assertFunctionAliased(true, \"A\");\n     assertFunctionAliased(true, \"ns.B\");\n     assertFunctionAliased(true, \"C\");\n     assertFunctionAliased(false, \"D\");\n-    \n+\n     // Not aliased by being target of call\n     source =\n         \"function A(){};\\n\" +\n         \"A();\\n\" +\n         \"ns.B();\\n\" +\n         \"C();\\n\";\n-        \n+\n     compileAndRunForward(source);\n-    \n+\n     assertFunctionAliased(false, \"A\");\n     assertFunctionAliased(false, \"ns.B\");\n     assertFunctionAliased(false, \"C\");\n-    \n+\n     // Not aliased by GET{PROP,ELEM}\n     source =\n         \"function A(){};\\n\" +\n         \"A.foo;\\n\" +\n         \"ns.B.prototype;\\n\" +\n         \"C[0];\\n\";\n-        \n+\n     compileAndRunForward(source);\n-    \n+\n     assertFunctionAliased(false, \"A\");\n     assertFunctionAliased(false, \"ns.B\");\n     assertFunctionAliased(false, \"C\");\n   }\n-   \n-  public void testFunctionGetIsExposedToCallOrApply() { \n+\n+  public void testFunctionGetIsExposedToCallOrApply() {\n     // Exposed to call\n     String source =\n         \"function A(){};\\n\" +\n         \"A.call(x);\\n\" +\n         \"B.apply(x);\\n\" +\n         \"C();\\n\";\n-    \n+\n     CallGraph callGraph = compileAndRunForward(source);\n-  \n+\n     Function functionA = callGraph.getUniqueFunctionWithName(\"A\");\n     Function functionB = callGraph.getUniqueFunctionWithName(\"B\");\n     Function functionC = callGraph.getUniqueFunctionWithName(\"C\");\n-    \n+\n     assertTrue(functionA.isExposedToCallOrApply());\n     assertTrue(functionB.isExposedToCallOrApply());\n     assertFalse(functionC.isExposedToCallOrApply());\n   }\n-  \n+\n   public void testCallsiteGetAstNode() {\n     String source =\n       \"function A(){B()};\\n\" +\n       \"function B(){};\\n\";\n-  \n-    CallGraph callgraph = compileAndRunForward(source);\n-    \n-    Function functionA = callgraph.getUniqueFunctionWithName(\"A\");   \n+\n+    CallGraph callgraph = compileAndRunForward(source);\n+\n+    Function functionA = callgraph.getUniqueFunctionWithName(\"A\");\n     Callsite callToB = functionA.getCallsitesInFunction().iterator().next();\n-    \n+\n     assertTrue(callToB.getAstNode().getType() == Token.CALL);\n   }\n-  \n+\n   public void testCallsiteGetContainingFunction() {\n     String source =\n       \"function A(){B()};\\n\" +\n       \"function B(){};\\n\" +\n       \"A();\\n\";\n-  \n-    CallGraph callgraph = compileAndRunForward(source);\n-    \n+\n+    CallGraph callgraph = compileAndRunForward(source);\n+\n     Function mainFunction = callgraph.getMainFunction();\n     Callsite callToA = mainFunction.getCallsitesInFunction().iterator().next();\n     assertEquals(mainFunction, callToA.getContainingFunction());\n-    \n+\n     Function functionA = callgraph.getUniqueFunctionWithName(\"A\");\n     Callsite callToB = functionA.getCallsitesInFunction().iterator().next();\n     assertEquals(functionA, callToB.getContainingFunction());\n   }\n-  \n+\n   public void testCallsiteGetKnownTargets() {\n     String source =\n       \"function A(){B()};\\n\" +\n       \"function B(){};\\n\" +\n       \"A();\\n\";\n-  \n-    CallGraph callgraph = compileAndRunForward(source);\n-    \n+\n+    CallGraph callgraph = compileAndRunForward(source);\n+\n     Function mainFunction = callgraph.getMainFunction();\n     Function functionA = callgraph.getUniqueFunctionWithName(\"A\");\n     Function functionB = callgraph.getUniqueFunctionWithName(\"B\");\n-    \n+\n     Callsite callInMain = mainFunction.getCallsitesInFunction().iterator()\n         .next();\n-    \n+\n     Collection<Function> targetsOfCallInMain = callInMain.getPossibleTargets();\n-    \n+\n     assertEquals(1, targetsOfCallInMain.size());\n     assertTrue(targetsOfCallInMain.contains(functionA));\n-    \n+\n     Callsite callInA = functionA.getCallsitesInFunction().iterator().next();\n     Collection<Function> targetsOfCallInA = callInA.getPossibleTargets();\n-    \n+\n     assertTrue(targetsOfCallInA.contains(functionB));\n   }\n-  \n+\n   public void testCallsiteHasUnknownTarget() {\n     String source =\n       \"var A = externalnamespace.prop;\\n\" +\n       \"function B(){A();};\\n\" +\n       \"B();\\n\";\n-  \n-    CallGraph callgraph = compileAndRunForward(source);\n-    \n+\n+    CallGraph callgraph = compileAndRunForward(source);\n+\n     Function mainFunction = callgraph.getMainFunction();\n     Function functionB = callgraph.getUniqueFunctionWithName(\"B\");\n-    \n+\n     Callsite callInMain =\n         mainFunction.getCallsitesInFunction().iterator().next();\n-    \n+\n     // B()'s target function is known, and it is functionB\n     assertFalse(callInMain.hasUnknownTarget());\n     assertEquals(\"B\", callInMain.getAstNode().getFirstChild().getString());\n-        \n+\n     Callsite callInB = functionB.getCallsitesInFunction().iterator().next();\n-    \n+\n     // A() has an unknown target and no known targets\n     assertTrue(callInB.hasUnknownTarget());\n     assertEquals(0, callInB.getPossibleTargets().size());\n   }\n-  \n+\n   public void testCallsiteHasExternTarget() {\n     String source =\n       \"var A = function(){}\\n\" +\n       \"function B(){ExternalFunction(6);};\\n\" +\n       \"A();\\n\";\n-  \n-    CallGraph callgraph = compileAndRunForward(source);\n-    \n+\n+    CallGraph callgraph = compileAndRunForward(source);\n+\n     Function mainFunction = callgraph.getMainFunction();\n     Function functionB = callgraph.getUniqueFunctionWithName(\"B\");\n-    \n+\n     Callsite callInMain =\n         mainFunction.getCallsitesInFunction().iterator().next();\n-    \n+\n     // A()'s target function is not an extern\n     assertFalse(callInMain.hasExternTarget());\n-    \n+\n     Callsite callInB = functionB.getCallsitesInFunction().iterator().next();\n-    \n+\n     assertEquals(\"ExternalFunction\",\n         callInB.getAstNode().getFirstChild().getString());\n-    \n+\n     // ExternalFunction(6) is a call to an extern function\n     assertTrue(callInB.hasExternTarget());\n-    assertEquals(0, callInB.getPossibleTargets().size());  \n-  }\n-  \n+    assertEquals(0, callInB.getPossibleTargets().size());\n+  }\n+\n   public void testThrowForBackwardOpOnForwardGraph() {\n     String source =\n       \"function A(){B()};\\n\" +\n     Function functionA = callgraph.getUniqueFunctionWithName(\"A\");\n \n     UnsupportedOperationException caughtException = null;\n-    \n+\n     try {\n       functionA.getCallsitesPossiblyTargetingFunction();\n     } catch (UnsupportedOperationException e) {\n       caughtException = e;\n     }\n-   \n-    assertNotNull(caughtException);    \n-  }\n-  \n+\n+    assertNotNull(caughtException);\n+  }\n+\n   public void testThrowForForwardOpOnBackwardGraph() {\n     String source =\n       \"function A(){B()};\\n\" +\n       \"function B(){};\\n\" +\n       \"A();\\n\";\n-  \n+\n     CallGraph callgraph = compileAndRunBackward(source);\n-    \n+\n     Function mainFunction = callgraph.getMainFunction();\n     Function functionA = callgraph.getUniqueFunctionWithName(\"A\");\n-    \n+\n     Callsite callInMain = mainFunction.getCallsitesInFunction().iterator()\n         .next();\n-      \n+\n     UnsupportedOperationException caughtException = null;\n-    \n+\n     try {\n       callInMain.getPossibleTargets();\n     } catch (UnsupportedOperationException e) {\n       return;\n     }\n-    fail();   \n-  }\n-  \n+    fail();\n+  }\n+\n   /**\n    * Helper function that, given a collection of callsites, returns a\n    * collection of the names of the target expression nodes, e.g.\n    * if the callsites are [A(), B.b()], the collection returned is\n    * [\"A\", \"B\"].\n-   * \n+   *\n    * This makes it easier to test methods that return collections of callsites.\n-   * \n+   *\n    * An exception is thrown if the callsite target is not a simple name\n    * (e.g. \"a.bar()\").\n    */\n   private List<String> getCallsiteTargetNames(Collection<Callsite>\n-      callsites) { \n+      callsites) {\n     List<String> result = Lists.newArrayList();\n-    \n+\n     for (Callsite callsite : callsites) {\n       Node targetExpressionNode = callsite.getAstNode().getFirstChild();\n       if (targetExpressionNode.getType() == Token.NAME) {\n             \"a complex callsite.\");\n       }\n     }\n-    \n+\n     return result;\n   }\n- \n+\n   private void assertFunctionAliased(boolean aliased, String name) {\n     Function function = currentProcessor.getUniqueFunctionWithName(name);\n-    \n+\n     assertEquals(aliased, function.isAliased());\n   }\n-  \n+\n   private CallGraph compileAndRunBackward(String js) {\n     return compileAndRun(SHARED_EXTERNS, js, false, true);\n   }\n-  \n+\n   private CallGraph compileAndRunForward(String js) {\n     return compileAndRun(SHARED_EXTERNS, js, true, false);\n   }\n-  \n+\n   private CallGraph compileAndRun(String externs,\n       String js,\n       boolean forward,\n       boolean backward) {\n-    \n+\n     createBackwardCallGraph = backward;\n     createForwardCallGraph = forward;\n-    \n+\n     testSame(externs, js, null);\n-    \n+\n     return currentProcessor;\n   }\n }\n--- a/test/com/google/javascript/jscomp/CheckGlobalNamesTest.java\n+++ b/test/com/google/javascript/jscomp/CheckGlobalNamesTest.java\n     STRICT_MODULE_DEP_QNAME.level = CheckLevel.WARNING;\n   }\n \n-  private static final String GET_NAMES = \n+  private static final String GET_NAMES =\n       \"var a = {get d() {return 1}}; a.b = 3; a.c = {get e() {return 5}};\";\n   private static final String SET_NAMES =\n       \"var a = {set d(x) {}}; a.b = 3; a.c = {set e(y) {}};\";\n     testSame(GET_NAMES + \"alert(a.c.x);\", UNDEFINED_NAME_WARNING);\n     testSame(SET_NAMES + \"alert(a.c.x);\", UNDEFINED_NAME_WARNING);\n   }\n-  \n+\n   public void testRefToUndefinedProperty4() {\n     testSame(NAMES + \"alert(a.d.x);\");\n     testSame(GET_NAMES + \"alert(a.d.x);\");\n     testSame(SET_NAMES + \"alert(a.d.x);\");\n-  }  \n+  }\n \n   public void testRefToDescendantOfUndefinedProperty1() {\n     testSame(NAMES + \"var c = a.x.b;\", UNDEFINED_NAME_WARNING);\n--- a/test/com/google/javascript/jscomp/CheckRegExpTest.java\n+++ b/test/com/google/javascript/jscomp/CheckRegExpTest.java\n \n     // No RegExp reference is ok\n     testReference(\"var x;\", false);\n-    \n+\n     // Local RegExp is ok\n     testReference(\"function f() {var RegExp; RegExp.test();}\", false);\n   }\n--- a/test/com/google/javascript/jscomp/ClosureCodingConventionTest.java\n+++ b/test/com/google/javascript/jscomp/ClosureCodingConventionTest.java\n   public void testInheritanceDetection11() {\n     assertNotClassDefining(\"A.mixin(B)\");\n   }\n-  \n+\n   public void testInheritanceDetection12() {\n     assertNotClassDefining(\"goog.mixin(A.prototype, B)\");\n   }\n-  \n+\n   public void testInheritanceDetection13() {\n     assertNotClassDefining(\"goog.mixin(A, B)\");\n   }\n-  \n+\n   public void testInheritanceDetectionPostCollapseProperties() {\n     assertDefinesClasses(\"goog$inherits(A, B);\", \"A\", \"B\");\n     assertNotClassDefining(\"goog$inherits(A);\");\n--- a/test/com/google/javascript/jscomp/CompilerTest.java\n+++ b/test/com/google/javascript/jscomp/CompilerTest.java\n \n     assertEquals(0, cb.getLineIndex());\n     assertEquals(12, cb.getColumnIndex());\n-    \n+\n     // newline reset the column index\n     cb.append(\"blah();\\ngoo();\");\n \n     assertEquals(1, cb.getLineIndex());\n-    assertEquals(6, cb.getColumnIndex());    \n+    assertEquals(6, cb.getColumnIndex());\n   }\n }\n--- a/test/com/google/javascript/jscomp/InlineVariablesTest.java\n+++ b/test/com/google/javascript/jscomp/InlineVariablesTest.java\n             \"(function() { a++; })(); var z = x;\"});\n     test(\n         new String[] { \"var x = a;\", \"\",\n-            \"function cow() { a++; }; cow(); var z = x;\"}, \n+            \"function cow() { a++; }; cow(); var z = x;\"},\n         new String[] { \"var x = a;\", \"\",\n             \";(function cow(){ a++; })(); var z = x;\"});\n     testSame(\n--- a/test/com/google/javascript/jscomp/JsMessageVisitorTest.java\n+++ b/test/com/google/javascript/jscomp/JsMessageVisitorTest.java\n         \"var MSG_EXTERNAL_2 = goog.getMsg('a')})\" +\n         \"(function () {/** @desc Hello2 */ \" +\n         \"var MSG_EXTERNAL_2 = goog.getMsg('a')})\");\n-  }  \n-  \n+  }\n+\n   private void extractMessagesSafely(String input) {\n     extractMessages(input);\n     JSError[] errors = compiler.getErrors();\n--- a/test/com/google/javascript/jscomp/MemoizedScopeCreatorTest.java\n+++ b/test/com/google/javascript/jscomp/MemoizedScopeCreatorTest.java\n     // Wow, is there really a circular dependency between JSCompiler and\n     // SyntacticScopeCreator?\n     Compiler compiler = new Compiler();\n-    compiler.initOptions(new CompilerOptions());    \n+    compiler.initOptions(new CompilerOptions());\n     ScopeCreator creator = new MemoizedScopeCreator(\n         new SyntacticScopeCreator(compiler));\n     Scope scopeA = creator.createScope(trueNode, null);\n--- a/test/com/google/javascript/jscomp/PeepholeFoldWithTypesTest.java\n+++ b/test/com/google/javascript/jscomp/PeepholeFoldWithTypesTest.java\n \n /**\n  * Tests for {@link ExternExportsPass}.\n- * \n+ *\n  * @author dcc@google.com (Devin Coughlin)\n  */\n public class PeepholeFoldWithTypesTest extends CompilerTestCase {\n   protected CompilerPass getProcessor(Compiler compiler) {\n     return new PeepholeOptimizationsPass(compiler, new PeepholeFoldWithTypes());\n   }\n-  \n+\n   @Override\n   public void setUp() {\n     enableTypeCheck(CheckLevel.WARNING);\n   }\n-  \n+\n   public void testFoldTypeofObject() {\n     test(\"var x = {};typeof x\",\n          \"var x = {};\\\"object\\\"\");\n-    \n+\n     test(\"var x = [];typeof x\",\n          \"var x = [];\\\"object\\\"\");\n-    \n+\n     // typeof null is \"object\" in JavaScript\n     test(\"var x = null;typeof x\",\n          \"var x = null;\\\"object\\\"\");\n   }\n-  \n+\n   public void testFoldTypeofString() {\n     test(\"var x = \\\"foo\\\";typeof x\",\n          \"var x = \\\"foo\\\";\\\"string\\\"\");\n-    \n+\n     test(\"var x = new String(\\\"foo\\\");typeof x\",\n          \"var x = new String(\\\"foo\\\");\\\"object\\\"\");\n   }\n-  \n+\n   public void testFoldTypeofNumber() {\n     test(\"var x = 10;typeof x\",\n          \"var x = 10;\\\"number\\\"\");\n-    \n+\n     test(\"var x = new Number(6);typeof x\",\n          \"var x = new Number(6);\\\"object\\\"\");\n   }\n-  \n+\n   public void testFoldTypeofBoolean() {\n     test(\"var x = false;typeof x\",\n          \"var x = false;\\\"boolean\\\"\");\n-    \n+\n     test(\"var x = new Boolean(true);typeof x\",\n          \"var x = new Boolean(true);\\\"object\\\"\");\n   }\n-  \n+\n   public void testFoldTypeofUndefined() {\n     test(\"var x = undefined;typeof x\",\n-         \"var x = undefined;\\\"undefined\\\"\"); \n+         \"var x = undefined;\\\"undefined\\\"\");\n   }\n-  \n+\n   public void testDontFoldTypeofUnionTypes() {\n     // For now we don't do anything with union types\n     testSame(\"var x = (unknown ? {} : null);typeof x\");\n   }\n-  \n+\n   public void testDontFoldTypeofSideEffects() {\n     // Shouldn't fold if argument to typeof has side effects\n     testSame(\"var x = 6 ;typeof (x++)\");\n--- a/test/com/google/javascript/jscomp/RemoveUnusedPrototypePropertiesTest.java\n+++ b/test/com/google/javascript/jscomp/RemoveUnusedPrototypePropertiesTest.java\n \n       \"function Foo() {}\" +\n       \"Foo.prototype = {};\");\n-    \n+\n     anchorUnusedVars = true;\n     test(\n         \"function Foo() {}\" +\n--- a/test/com/google/javascript/jscomp/RemoveUnusedVarsTest.java\n+++ b/test/com/google/javascript/jscomp/RemoveUnusedVarsTest.java\n     // this.modifyCallSites = false;\n     testSame(\"({set s(a) {}})\");\n   }\n-  \n+\n   public void testRemoveInheritedClass1() {\n     test(\"function goog$inherits(){}\" +\n         \"/**@constructor*/function a(){}\" +\n         \"goog$inherits(b,a); new a\",\n         \"function a(){} new a\");\n   }\n-  \n+\n   public void testRemoveInheritedClass2() {\n     test(\"function goog$inherits(){}\" +\n         \"function goog$mixin(){}\" +\n         \"function c(){}\" +\n         \"goog$mixin(c.prototype,a.prototype); new c\");\n   }\n-  \n+\n   public void testRemoveInheritedClass7() {\n     test(\"function goog$mixin(){}\" +\n         \"/**@constructor*/function a(){alert(goog$mixin(a, a))}\" +\n         \"function goog$mixin(){}\" +\n         \"function a(){alert(goog$mixin(a, a))} new a\");\n   }\n-  \n+\n   public void testRemoveInheritedClass8() {\n     test(\"/**@constructor*/function a(){}\" +\n         \"/**@constructor*/function b(){}\" +\n         \"/**@constructor*/function c(){}\" +\n         \"b.inherits(a);c.mixin(b.prototype);new c\");\n   }\n-  \n+\n   public void testRemoveInheritedClass10() {\n     test(\"function goog$inherits(){}\" +\n         \"/**@constructor*/function a(){}\" +\n         \"function goog$inherits(){}\" +\n         \"function a(){} function b(){} goog$inherits(b,a); new a; new b\");\n   }\n-  \n+\n   public void testRemoveInheritedClass11() {\n     testSame(\"function goog$inherits(){}\" +\n         \"function goog$mixin(a,b){goog$inherits(a,b)}\" +\n--- a/test/com/google/javascript/jscomp/SideEffectsAnalysisTest.java\n+++ b/test/com/google/javascript/jscomp/SideEffectsAnalysisTest.java\n \n /**\n  * Tests for {@link SideEffectsAnalysis}.\n- * \n+ *\n  * @author dcc@google.com (Devin Coughlin)\n  *\n  */\n public class SideEffectsAnalysisTest extends CompilerTestCase {\n \n   private static final String SHARED_EXTERNS = \"var arguments = [];\";\n-  \n+\n   LocationAbstractionMode currentLocationAbstractionIdentifier;\n-  \n+\n   SideEffectsAnalysis currentAnalysis = null;\n-  \n+\n   Compiler currentCompiler = null;\n-  \n+\n   Node currentJsRoot = null;\n-  \n+\n   @Override\n   protected CompilerPass getProcessor(final Compiler compiler) {\n-    currentCompiler = compiler;   \n-   \n+    currentCompiler = compiler;\n+\n     currentAnalysis = new SideEffectsAnalysis(compiler,\n         currentLocationAbstractionIdentifier);\n-    \n+\n     return new CompilerPass() {\n-      \n+\n       @Override\n       public void process(Node externs, Node root) {\n-        \n-        if (currentLocationAbstractionIdentifier == \n+\n+        if (currentLocationAbstractionIdentifier ==\n           LocationAbstractionMode.VISIBILITY_BASED) {\n-          \n+\n           // Run var when using the visibility abstraction\n           // because it is unsound if it fails.\n-          \n+\n           final VarCheck varCheck = new VarCheck(compiler);\n-          \n+\n           varCheck.process(externs, root);\n         }\n-        \n+\n         currentAnalysis.process(externs, root);\n-        \n+\n       }\n     };\n   }\n   @Override\n   public void setUp() throws Exception {\n     super.setUp();\n-    \n+\n     currentAnalysis = null;\n     currentCompiler = null;\n   }\n-  \n-  public void testDegenerateSafeMoves() {      \n+\n+  public void testDegenerateSafeMoves() {\n     // Env is empty\n     assertSafeMoveDegenerate(\"src: 1; env: ; dest: 3;\");\n-    \n+\n     // Src and env pure\n     assertSafeMoveDegenerate(\"src: 1; env: 2; dest: 3;\");\n-    \n+\n     // Only refs\n     assertSafeMoveDegenerate(\"src: 1; env: x; dest: 3;\");\n     assertSafeMoveDegenerate(\"src: x; env: 1; dest: 3;\");\n-    \n+\n     // Only mods\n     assertSafeMoveDegenerate(\"src: 1; env: x++; dest: 3;\");\n-    \n+\n     assertSafeMoveDegenerate(\"src: x++; env: 1; dest: 3;\");\n   }\n-  \n-  public void testVisibilitySafeMoves() {      \n+\n+  public void testVisibilitySafeMoves() {\n     // Env is empty\n     assertSafeMoveVisibility(\"src: 1; env: ; dest: 3;\");\n-    \n+\n     // Src and env pure\n     assertSafeMoveVisibility(\"src: 1; env: 2; dest: 3;\");\n-    \n+\n     // Only refs\n     assertSafeMoveVisibility(\"var x; src: 1; env: x; dest: 3;\");\n     assertSafeMoveVisibility(\"var x; src: x; env: 1; dest: 3;\");\n-    \n+\n     // Only mods\n     assertSafeMoveVisibility(\"var x; src: 1; env: x++; dest: 3;\");\n     assertSafeMoveVisibility(\"var x; src: x++; env: 1; dest: 3;\");\n-    \n+\n     // Source references global, env changes local\n     assertSafeMoveVisibility(\n         \"var x;\" +\n           \"env: y++;\" +\n           \"dest: 3;\" +\n           \"}\");\n-    \n+\n     // Source changes global, env refs local\n     assertSafeMoveVisibility(\n         \"var x;\" +\n           \"env: y;\" +\n           \"dest: 3;\" +\n           \"}\");\n-    \n+\n     // Source references global, env changes local with shadowing\n     assertSafeMoveVisibility(\n         \"var x;\" +\n           \"env: y++;\" +\n           \"dest: 3;\" +\n           \"}\");\n-    \n+\n     // Source changes global, env refs local with shadowing\n     assertSafeMoveVisibility(\n         \"var x;\" +\n           \"env: y;\" +\n           \"dest: 3;\" +\n           \"}\");\n-    \n-    \n+\n+\n     // Source references captured local, env changes local\n     assertSafeMoveVisibility(\n         \"function f(){\" +\n             \"x\" +\n           \"}\" +\n          \"}\");\n-    \n+\n     // Source changes captured local, env refs local\n     assertSafeMoveVisibility(\n         \"function f(){\" +\n             \"x\" +\n           \"}\" +\n         \"}\");\n-    \n+\n     // Source references heap, env changes local\n     assertSafeMoveVisibility(\n         \"var x = {};\" +\n           \"env: y++;\" +\n           \"dest: 3;\" +\n           \"}\");\n-    \n+\n     // Source changes heap, env refs local\n     assertSafeMoveVisibility(\n         \"var x = {};\" +\n           \"env: y;\" +\n           \"dest: 3;\" +\n           \"}\");\n-    \n+\n     // MOD in function expressions shouldn't count\n     assertSafeMoveVisibility(\n         \"var x = {};\" +\n           \"x.a++;\" +\n         \"});\" +\n         \"dest: 3;\");\n-    \n+\n     // REF in function expressions shouldn't count\n     assertSafeMoveVisibility(\n         \"var x = {};\" +\n           \"x.a;\" +\n         \"});\" +\n         \"dest: 3;\");\n-    \n-  }\n-  \n+\n+  }\n+\n   public void testDegenerateUnsafeMoves() {\n-    \n+\n     // Unsafe to move increment across read\n     assertUnsafeMoveDegenerate(\"src: x++; env: foo(y); dest: 3;\");\n-   \n+\n     // Unsafe to move read across increment\n     assertUnsafeMoveDegenerate(\"src: foo(y); env: x++; dest: 3;\");\n-    \n+\n     // Unsafe to move write across write\n     assertUnsafeMoveDegenerate(\"src: x = 7; env: y = 3; dest:3;\");\n   }\n-    \n+\n   public void testVisibilityUnsafeMoves() {\n-    \n+\n     // Unsafe to move increment across read for global variables\n     assertUnsafeMoveVisibility(\"var x,y; src: x++; env: y; dest: 3;\");\n-    \n+\n     // Unsafe to move increment across read for local variables\n     assertUnsafeMoveVisibility(\"function f() {\" +\n         \"var x,y; src: x++; env: y; dest: 3;\" +\n         \"}\");\n-    \n+\n     // Unsafe to move increment across read for captured local variables\n     assertUnsafeMoveVisibility(\n         \"function f() {\" +\n             \"x; y;\" +\n           \"}\" +\n          \"}\");\n-            \n+\n     // Unsafe to move increment across read for heap locations\n     assertUnsafeMoveVisibility(\"var x,y; src: x.a++; env: y.b; dest: 3;\");\n-     \n+\n     // Unsafe to move read across increment of for global variables\n     assertUnsafeMoveVisibility(\"var x,y; src: y; env: x++; dest: 3;\");\n-    \n+\n     // Unsafe to move read across increment for local variables\n     assertUnsafeMoveVisibility(\"function f() {\" +\n         \"var x,y; src: x; env: y++; dest: 3;\" +\n         \"}\");\n-    \n+\n     // Unsafe to move read across increment for captured local variables\n     assertUnsafeMoveVisibility(\n         \"function f() {\" +\n             \"x; y;\" +\n           \"}\" +\n          \"}\");\n-    \n+\n     // Unsafe to move read across increment for heap locations\n     assertUnsafeMoveVisibility(\"var x,y; src: x.a; env: y.b++; dest: 3;\");\n-    \n+\n     // Unsafe to move write across write for globals\n     assertUnsafeMoveVisibility(\"var x,y; src: x = 7; env: y = 3; dest: 3;\");\n-    \n+\n     // Unsafe to move write across write for local variables\n     assertUnsafeMoveVisibility(\"function f() {\" +\n         \"var x,y; src: x = 7; env: y = 3; dest: 3;\" +\n         \"}\");\n-    \n+\n     // Unsafe to move write across write for captured local variables\n     assertUnsafeMoveVisibility(\n         \"function f() {\" +\n             \"x; y;\" +\n           \"}\" +\n          \"}\");\n-    \n+\n     // Unsafe to move write across write for heap locations\n     assertUnsafeMoveVisibility(\"var x,y; src: x.a = 7; env: y.b = 3; dest: 3;\");\n   }\n-  \n+\n   public void testVisibilityMoveCalls() {\n     // Interprocedural side effect analysis isn't implemented yet, so any calls\n     // should make movement unsafe, since we don't know what those calls are\n     // doing.\n-    \n+\n     // TODO(dcc): implement interprocedural side effect analysis.\n-    \n+\n     // Source makes call, env refs global\n     assertUnsafeMoveVisibility(\n         \"var x = {};\" +\n           \"env: x;\" +\n           \"dest: 3;\" +\n           \"}\");\n-    \n+\n     // Source makes refs global, env makes call\n     assertUnsafeMoveVisibility(\n         \"var x = {};\" +\n           \"dest: 3;\" +\n           \"}\");\n   }\n-  \n+\n   public void testVisibilityMergesParametersWithHeap() {\n     // For now, we expect the visibility based location abstraction\n     // to merge parameter variable locations with heap locations because\n     // parameters can be references and modified via the arguments object.\n-    \n+\n     // Source changes heap, env refs parameter\n     assertUnsafeMoveVisibility(\n         \"var x = {};\" +\n           \"env: y;\" +\n           \"dest: 3;\" +\n           \"}\");\n-    \n+\n     // Source refs heap, env changes parameters\n     assertUnsafeMoveVisibility(\n         \"var x = {};\" +\n           \"env: y++;\" +\n           \"dest: 3;\" +\n           \"}\");\n-    \n+\n     // Source changes arguments explicitly, env refs parameter\n     assertUnsafeMoveVisibility(\n         \"var x = {};\" +\n           \"env: y;\" +\n           \"dest: 3;\" +\n           \"}\");\n-    \n+\n     // Source refs arguments explicitly, env changes parameter\n     assertUnsafeMoveVisibility(\n         \"var x = {};\" +\n           \"src: arguments[0];\" +\n           \"env: y++;\" +\n           \"dest: 3;\" +\n-          \"}\");   \n-  }\n-  \n+          \"}\");\n+  }\n+\n   public void testMovedSideEffectsMustHaveSameControlFlow() {\n-    \n+\n     // Safe to move within IF block\n     assertSafeMoveVisibility(\n         \"var a;\" +\n           \"}\" +\n         \"}\"\n     );\n-    \n+\n     // Unsafe to move between two IF blocks\n     assertUnsafeMoveVisibility(\n         \"var a;\" +\n           \"}\" +\n         \"}\"\n     );\n-    \n+\n     // Unsafe to move between then/else of same IF block\n     assertUnsafeMoveVisibility(\n         \"var a;\" +\n           \"}\" +\n         \"}\"\n     );\n-    \n+\n     // Safe to move within WHILE block\n     assertSafeMoveVisibility(\n         \"var a;\" +\n           \"}\" +\n         \"}\"\n     );\n-    \n+\n     // Unsafe to move within WHILE block with BREAK\n     assertUnsafeMoveVisibility(\n         \"var a;\" +\n           \"}\" +\n         \"}\"\n     );\n-    \n+\n     // Unsafe to move within WHILE block with continue\n     assertUnsafeMoveVisibility(\n         \"var a;\" +\n           \"}\" +\n         \"}\"\n     );\n-    \n+\n     // Unsafe to move within WHILE block with continue\n     assertUnsafeMoveVisibility(\n         \"var a;\" +\n           \"}\" +\n         \"}\"\n     );\n-    \n+\n     // Safe to move within DO\n     assertSafeMoveVisibility(\n         \"var a;\" +\n           \"} while(l)\" +\n         \"}\"\n     );\n-    \n+\n     // Unsafe to move outside DO\n     assertUnsafeMoveVisibility(\n         \"var a;\" +\n           \"dest: 3;\" +\n         \"}\"\n     );\n-    \n+\n     // It should be safe to move within CASE\n     // but we disallow for now because analyzing\n     // CASE fall-through and BREAKs is complicated.\n           \"}\" +\n         \"}\"\n     );\n-    \n+\n     // Unsafe to move between CASEs\n     assertUnsafeMoveVisibility(\n         \"var a;\" +\n               \"src: a++;\" +\n               \"env: 3;\" +\n             \"break;\" +\n-            \"case 18:\" + \n+            \"case 18:\" +\n               \"dest: 3;\" +\n             \"break;\" +\n           \"}\" +\n         \"}\"\n     );\n-    \n+\n     // Unsafe to move between FUNCTIONs\n     assertUnsafeMoveVisibility(\n         \"var a;\" +\n         \"}\"\n     );\n   }\n-    \n+\n   private SideEffectsAnalysis.AbstractMotionEnvironment environment(\n       Node ...nodes) {\n-    \n+\n     return new SideEffectsAnalysis.RawMotionEnvironment(\n         ImmutableSet.copyOf(nodes));\n   }\n-  \n+\n   private void assertMove(LocationAbstractionMode abstraction,\n       String src,\n       boolean expected) {\n     SideEffectsAnalysis analysis = compileAndRun(src, abstraction);\n-    \n+\n     Node sourceNode = findLabeledStatement(\"src\");\n     Node environmentNode = findLabeledStatement(\"env\");\n     Node destinationNode = findLabeledStatement(\"dest\");\n-     \n+\n     boolean result = analysis.safeToMoveBefore(sourceNode,\n         environment(environmentNode), destinationNode);\n-    \n+\n     if (expected) {\n       assertTrue(result);\n     } else {\n       assertFalse(result);\n-    }   \n-  }\n-  \n+    }\n+  }\n+\n   private void assertSafeMoveDegenerate(String src) {\n     assertMove(LocationAbstractionMode.DEGENERATE, src, true);\n   }\n-  \n+\n   private void assertUnsafeMoveDegenerate(String src) {\n     assertMove(LocationAbstractionMode.DEGENERATE, src, false);\n   }\n-  \n+\n   private void assertSafeMoveVisibility(String src) {\n     assertMove(LocationAbstractionMode.VISIBILITY_BASED, src, true);\n   }\n-  \n+\n   private void assertUnsafeMoveVisibility(String src) {\n     assertMove(LocationAbstractionMode.VISIBILITY_BASED, src, false);\n   }\n-  \n+\n   private SideEffectsAnalysis compileAndRun(String js,\n       LocationAbstractionMode locationAbstractionIdentifier) {\n-    \n+\n     currentLocationAbstractionIdentifier = locationAbstractionIdentifier;\n-    \n+\n     testSame(SHARED_EXTERNS, js, null);\n-    \n+\n     currentJsRoot = currentCompiler.jsRoot;\n-    \n+\n     return currentAnalysis;\n-  } \n-  \n+  }\n+\n   // Shamelessly stolen from NameReferenceGraphConstructionTest\n   private Node findLabeledStatement(String label) {\n     LabeledStatementSearcher s = new LabeledStatementSearcher(label);\n-      \n+\n     new NodeTraversal(currentCompiler, s).traverse(currentCompiler.jsRoot);\n     assertNotNull(\"Label \" + label + \" should be in the source code\", s.found);\n-    \n+\n     return s.found;\n   }\n-  \n+\n   /**\n    * Quick traversal to find a given labeled statement in the AST.\n-   * \n+   *\n    * Given \"foo\", finds the statement a = x in\n    * foo: a = x;\n    */\n     public void visit(NodeTraversal t, Node n, Node parent) {\n       if (n.getType() == Token.LABEL &&\n           target.equals(n.getFirstChild().getString())) {\n-        \n+\n         found = n.getLastChild();\n       }\n     }\n--- a/test/com/google/javascript/jscomp/SimpleFunctionAliasAnalysisTest.java\n+++ b/test/com/google/javascript/jscomp/SimpleFunctionAliasAnalysisTest.java\n \n /**\n  * Tests for {@link SimpleFunctionAliasAnalysis}.\n- * \n+ *\n  * @author dcc@google.com (Devin Coughlin)\n  */\n public class SimpleFunctionAliasAnalysisTest extends CompilerTestCase {\n-  \n+\n   private SimpleFunctionAliasAnalysis analysis;\n-  \n+\n   private Compiler lastCompiler;\n-  \n+\n   @Override\n   protected CompilerPass getProcessor(final Compiler compiler) {\n       return new CompilerPass() {\n-        \n+\n         @Override\n         public void process(Node externs, Node root) {\n           SimpleDefinitionFinder finder = new SimpleDefinitionFinder(compiler);\n           finder.process(externs, root);\n-          \n+\n           analysis = new SimpleFunctionAliasAnalysis();\n-          \n-          analysis.analyze(finder);  \n-          \n+\n+          analysis.analyze(finder);\n+\n           lastCompiler = compiler;\n         }\n       };\n   }\n \n-  public void testFunctionGetIsAliased() { \n-    // Aliased by VAR assignment   \n+  public void testFunctionGetIsAliased() {\n+    // Aliased by VAR assignment\n     String source =\n         \"function A(){};\\n\" +\n         \"var ns = {};\\n\" +\n         \"var aliasB = ns.B;\\n\" +\n         \"var aliasC = C;\\n\" +\n         \"D();\";\n-      \n-    compileAndRun(source);\n-  \n+\n+    compileAndRun(source);\n+\n     assertFunctionAliased(true, \"A\");\n     assertFunctionAliased(true, \"ns.B\");\n     assertFunctionAliased(true, \"C\");\n     assertFunctionAliased(false, \"D\");\n-    \n-    // Aliased by normal assignment   \n+\n+    // Aliased by normal assignment\n     source =\n         \"function A(){};\\n\" +\n         \"var ns = {};\\n\" +\n         \"var aliasC;\\n\" +\n         \"aliasC = C;\\n\" +\n         \"ns.D();\";\n-      \n-    compileAndRun(source);\n-  \n+\n+    compileAndRun(source);\n+\n     assertFunctionAliased(true, \"A\");\n     assertFunctionAliased(true, \"ns.B\");\n     assertFunctionAliased(true, \"C\");\n     assertFunctionAliased(false, \"ns.D\");\n-    \n-    // Aliased by passing as parameter  \n+\n+    // Aliased by passing as parameter\n     source =\n         \"function A(){};\\n\" +\n         \"var ns = {};\\n\" +\n         \"foo(ns.B)\\n\" +\n         \"foo(C);\\n\" +\n         \"D();\";\n-      \n-    compileAndRun(source);\n-  \n+\n+    compileAndRun(source);\n+\n     assertFunctionAliased(true, \"A\");\n     assertFunctionAliased(true, \"ns.B\");\n     assertFunctionAliased(true, \"C\");\n     assertFunctionAliased(false, \"D\");\n-    \n+\n     // Not aliased by being target of call\n     source =\n         \"function A(){};\\n\" +\n         \"A();\\n\" +\n         \"ns.B();\\n\" +\n         \"C();\\n\";\n-        \n-    compileAndRun(source);\n-    \n+\n+    compileAndRun(source);\n+\n     assertFunctionAliased(false, \"A\");\n     assertFunctionAliased(false, \"ns.B\");\n     assertFunctionAliased(false, \"C\");\n-    \n+\n     // Not aliased by GET{PROP,ELEM}\n     source =\n         \"function A(){};\\n\" +\n         \"A.foo;\\n\" +\n         \"ns.B.prototype;\\n\" +\n         \"C[0];\\n\";\n-        \n-    compileAndRun(source);\n-    \n+\n+    compileAndRun(source);\n+\n     assertFunctionAliased(false, \"A\");\n     assertFunctionAliased(false, \"ns.B\");\n     assertFunctionAliased(false, \"C\");\n   }\n-  \n-  public void testFunctionGetIsExposedToCallOrApply() { \n+\n+  public void testFunctionGetIsExposedToCallOrApply() {\n     // Exposed to call\n     String source =\n         \"function A(){};\\n\" +\n         \"A.call(x);\\n\" +\n         \"B.apply(x);\\n\" +\n         \"C();\\n\";\n-    \n-    compileAndRun(source);\n-  \n+\n+    compileAndRun(source);\n+\n     assertFunctionExposedToCallOrApply(true, \"A\");\n     assertFunctionExposedToCallOrApply(true, \"B\");\n     assertFunctionExposedToCallOrApply(false, \"C\");\n-    \n+\n     source =\n       \"var ns = {};\" +\n       \"ns.A = function(){};\\n\" +\n       \"ns.A.call(x);\\n\" +\n       \"ns.B.apply(x);\\n\" +\n       \"ns.C();\\n\";\n-  \n+\n     compileAndRun(source);\n \n     assertFunctionExposedToCallOrApply(true, \"ns.A\");\n     assertFunctionExposedToCallOrApply(true, \"ns.B\");\n     assertFunctionExposedToCallOrApply(false, \"ns.C\");\n   }\n-  \n+\n   private void assertFunctionAliased(boolean aliasStatus,\n       String functionName) {\n     Node function = findFunction(functionName);\n-    \n+\n     assertEquals(aliasStatus, analysis.isAliased(function));\n   }\n-  \n+\n   private void assertFunctionExposedToCallOrApply(boolean exposure,\n       String functionName) {\n     Node function = findFunction(functionName);\n-    \n+\n     assertEquals(exposure, analysis.isExposedToCallOrApply(function));\n   }\n-  \n+\n   private void compileAndRun(String source) {\n     testSame(source, source, null);\n   }\n-  \n+\n   private Node findFunction(String name) {\n     FunctionFinder f = new FunctionFinder(name);\n     new NodeTraversal(lastCompiler, f).traverse(lastCompiler.jsRoot);\n     assertNotNull(\"Couldn't find \" + name, f.found);\n     return f.found;\n   }\n-  \n+\n   /**\n    * Quick Traversal to find a given function in the AST.\n    */\n     FunctionFinder(String target) {\n       this.target = target;\n     }\n-    \n+\n     @Override\n     public void visit(NodeTraversal t, Node n, Node parent) {\n       if (NodeUtil.isFunction(n)\n         found = n;\n       }\n     }\n-  }  \n+  }\n }\n--- a/test/com/google/javascript/jscomp/SpecializeModuleTest.java\n+++ b/test/com/google/javascript/jscomp/SpecializeModuleTest.java\n \n /**\n  * Tests for {@link SpecializeModule}.\n- * \n+ *\n  * @author dcc@google.com (Devin Coughlin)\n  */\n public class SpecializeModuleTest extends CompilerTestCase {\n           compiler.getUniqueNameIdSupplier(), true, false, true);\n     }\n   };\n-  \n+\n   private PassFactory removeUnusedPrototypeProperties =\n     new PassFactory(\"removeUnusedPrototypeProperties\", true) {\n     @Override\n       return new RemoveUnusedPrototypeProperties(compiler, false, false);\n     }\n   };\n-  \n+\n   private PassFactory devirtualizePrototypeMethods =\n     new PassFactory(\"devirtualizePrototypeMethods\", true) {\n     @Override\n       return new DevirtualizePrototypeMethods(compiler);\n     }\n   };\n-  \n+\n   @Override\n   protected CompilerPass getProcessor(final Compiler compiler) {\n     final SpecializeModule specializeModule = new SpecializeModule(compiler,\n-        devirtualizePrototypeMethods, inlineFunctions, \n+        devirtualizePrototypeMethods, inlineFunctions,\n         removeUnusedPrototypeProperties);\n \n-    return new CompilerPass() {     \n+    return new CompilerPass() {\n       @Override\n       public void process(Node externs, Node root) {\n         specializeModule.process(externs, root);\n \n         /* Make sure variables are declared before used */\n-        new VarCheck(compiler).process(externs, root);       \n+        new VarCheck(compiler).process(externs, root);\n       }\n     };\n   }\n     JSModule[] modules = createModuleStar(\n         // m1\n         /* Recursion in A() prevents inline of A*/\n-        \"var A = function() {alert(B());A()};\" + \n+        \"var A = function() {alert(B());A()};\" +\n         \"var B = function() {return 6};\" +\n-        \"A();\",       \n+        \"A();\",\n         // m2\n         \"A();\" +\n         \"B();\" +\n \n     test(modules, new String[] {\n         // m1\n-        \"var A = function() {alert(6);A()};\" + /* Specialized A */    \n-        \"A();\" +\n-        \"var B;\",    \n+        \"var A = function() {alert(6);A()};\" + /* Specialized A */\n+        \"A();\" +\n+        \"var B;\",\n         // m2\n         \"A = function() {alert(B());A()};\" + /* Unspecialized A */\n         \"B = function() {return 6};\" + /* Removed from m1, so add to m2 */\n         \"B();\"\n     });\n   }\n-  \n+\n   public void testSpecializeCascadedInline() {\n     JSModule[] modules = createModuleStar(\n         // m1\n         /* Recursion in A() prevents inline of A*/\n-        \"var A = function() {alert(B());A()};\" + \n+        \"var A = function() {alert(B());A()};\" +\n         \"var B = function() {return C()};\" +\n         \"var C = function() {return 6};\" +\n-        \"A();\",       \n+        \"A();\",\n         // m2\n         \"B = function() {return 7};\" +\n     \"A();\");\n \n     test(modules, new String[] {\n         // m1\n-        \"var A = function() {alert(6);A()};\" + /* Specialized A */    \n-        \"A();\" +\n-        \"var B, C;\",    \n+        \"var A = function() {alert(6);A()};\" + /* Specialized A */\n+        \"A();\" +\n+        \"var B, C;\",\n         // m2\n         \"A = function() {alert(B());A()};\" + /* Unspecialized A */\n         \"B = function() {return C()};\" + /* Removed from m1, so add to m2 */\n     JSModule[] modules = createModuleStar(\n         // m1\n         /* Recursion in A() prevents inline of A*/\n-        \"var A = function() {alert(B());A()};\" + \n+        \"var A = function() {alert(B());A()};\" +\n         \"var B = function() {return 6};\" +\n-        \"A();\",       \n+        \"A();\",\n         // m2\n         \"B = function() {return 7};\" +\n         \"A();\",\n \n     test(modules, new String[] {\n         // m1\n-        \"var A = function() {alert(6);A()};\" + /* Specialized A */    \n-        \"A();\" +\n-        \"var B;\",    \n+        \"var A = function() {alert(6);A()};\" + /* Specialized A */\n+        \"A();\" +\n+        \"var B;\",\n         // m2\n         \"A = function() {alert(B());A()};\" + /* Unspecialized A */\n         \"B = function() {return 6};\" + /* Removed from m1, so add to m2 */\n         // m1\n         \"var ns = {};\" +\n         /* Recursion in A() prevents inline of A*/\n-        \"ns.A = function() {alert(B());ns.A()};\" + \n+        \"ns.A = function() {alert(B());ns.A()};\" +\n         \"var B = function() {return 6};\" +\n-        \"ns.A();\",       \n+        \"ns.A();\",\n         // m2\n         \"B = function() {return 7};\" +\n     \"ns.A();\");\n     test(modules, new String[] {\n         // m1\n         \"var ns = {};\" +\n-        \"ns.A = function() {alert(6);ns.A()};\" + /* Specialized A */    \n+        \"ns.A = function() {alert(6);ns.A()};\" + /* Specialized A */\n         \"ns.A();\" +\n-        \"var B;\",    \n+        \"var B;\",\n         // m2\n         \"ns.A = function() {alert(B());ns.A()};\" + /* Unspecialized A */\n         \"B = function() {return 6};\" + /* Removed from m1, so add to m2 */\n     JSModule[] modules = createModuleStar(\n         // m1\n         /* Recursion in A() prevents inline of A*/\n-        \"function A() {alert(B());A()}\" + \n+        \"function A() {alert(B());A()}\" +\n         \"function B() {return 6}\" +\n-        \"A();\",       \n+        \"A();\",\n         // m2\n         \"B = function() {return 7};\" +\n     \"A();\");\n \n     test(modules, new String[] {\n         // m1\n-        \"function A() {alert(6);A()}\" + /* Specialized A */    \n-        \"A();\" +\n-        \"var B;\",    \n+        \"function A() {alert(6);A()}\" + /* Specialized A */\n+        \"A();\" +\n+        \"var B;\",\n         // m2\n         \"A = function() {alert(B());A()};\" + /* Unspecialized A */\n         \"B = function() {return 6};\" + /* Removed from m1, so add to m2 */\n     JSModule[] modules = createModuleStar(\n         // m1\n         \"(function(){var noSpecialize = \" +\n-            \"function() {alert(6)};noSpecialize()})()\",       \n+            \"function() {alert(6)};noSpecialize()})()\",\n         // m2\n         \"\");\n \n     test(modules, new String[] {\n         // m1\n         \"(function(){var noSpecialize = \" +\n-            \"function() {alert(6)};noSpecialize()})()\", \n+            \"function() {alert(6)};noSpecialize()})()\",\n         // m2\n         \"\"\n     });\n     JSModule[] modules = createModuleStar(\n         // m1\n         /* Recursion in A() prevents inline of A*/\n-        \"var A = function() {alert(B() + C());A()};\" + \n+        \"var A = function() {alert(B() + C());A()};\" +\n         \"var B = function() {return 6};\" +\n         \"var C = function() {return 8};\" +\n-        \"A();\",       \n+        \"A();\",\n         // m2\n         \"\" +\n     \"A();\");\n \n     test(modules, new String[] {\n         // m1\n-        \"var A = function() {alert(6 + 8);A()};\" + /* Specialized A */    \n-        \"A();\" +\n-        \"var B, C;\",    \n+        \"var A = function() {alert(6 + 8);A()};\" + /* Specialized A */\n+        \"A();\" +\n+        \"var B, C;\",\n         // m2\n         \"A = function() {alert(B() + C());A()};\" + /* Unspecialized A */\n         \"B = function() {return 6};\" + /* Removed from m1, so add to m2 */\n         // m1\n         /* Recursion in A() prevents inline of A*/\n         \"var Foo = function(){};\" + /* constructor */\n-        \"Foo.prototype.a = function() {this.a()};\" + \n+        \"Foo.prototype.a = function() {this.a()};\" +\n         \"Foo.prototype.b = function() {return 6};\" +\n         \"Foo.prototype.c = function() {return 7};\" +\n         \"var aliasA = Foo.prototype.a;\" + // Prevents devirtualization of a\n         \"var x = new Foo();\" +\n-        \"x.a();\",       \n+        \"x.a();\",\n         // m2\n         \"\");\n \n         \"Foo.prototype.a = function() {this.a()};\" +\n         \"var aliasA = Foo.prototype.a;\" +\n         \"var x = new Foo();\" +\n-        \"x.a();\", \n+        \"x.a();\",\n         // m2\n         \"Foo.prototype.b = function() {return 6};\" +\n-        \"Foo.prototype.c = function() {return 7};\"        \n-    });\n-  }\n-  \n+        \"Foo.prototype.c = function() {return 7};\"\n+    });\n+  }\n+\n   public void testDontSpecializeAliasedFunctions_inline() {\n     JSModule[] modules = createModuleStar(\n         // m1\n         /* Recursion in A() prevents inline of A*/\n-        \"function A() {alert(B());A()}\" + \n+        \"function A() {alert(B());A()}\" +\n         \"function B() {return 6}\" +\n         \"var aliasA = A;\" +\n-        \"A();\",       \n+        \"A();\",\n         // m2\n         \"B = function() {return 7};\" +\n         \"B();\");\n     test(modules, new String[] {\n         // m1\n         /* Recursion in A() prevents inline of A*/\n-        \"function A() {alert(B());A()}\" + \n+        \"function A() {alert(B());A()}\" +\n         \"function B() {return 6}\" +\n         \"var aliasA = A;\" +\n-        \"A();\",       \n+        \"A();\",\n         // m2\n         \"B = function() {return 7};\" +\n         \"B();\"\n     JSModule[] modules = createModuleStar(\n         // m1\n         \"var Foo = function(){};\" + /* constructor */\n-        \"Foo.prototype.a = function() {this.a()};\" + \n+        \"Foo.prototype.a = function() {this.a()};\" +\n         \"Foo.prototype.b = function() {return 6};\" +\n         \"var aliasB = Foo.prototype.b;\" +\n         \"Foo.prototype.c = function() {return 7};\" +\n         \"var aliasA = Foo.prototype.a;\" + // Prevents devirtualization of a\n         \"var x = new Foo();\" +\n         \"x.a();\" +\n-        \"var aliasC = (new Foo).c\",       \n+        \"var aliasC = (new Foo).c\",\n         // m2\n         \"\");\n \n         \"var aliasA = Foo.prototype.a;\" + // Prevents devirtualization of a\n         \"var x = new Foo();\" +\n         \"x.a();\" +\n-        \"var aliasC = (new Foo).c\", \n-        // m2\n-        \"Foo.prototype.d = function() {return 7};\"        \n-    });\n-  }\n-  \n+        \"var aliasC = (new Foo).c\",\n+        // m2\n+        \"Foo.prototype.d = function() {return 7};\"\n+    });\n+  }\n+\n   public void testSpecializeDevirtualizePrototypeMethods() {\n     JSModule[] modules = createModuleStar(\n         // m1\n         // m1\n         \"var Foo = function(){};\" + /* constructor */\n         \"var JSCompiler_StaticMethods_a =\" +\n-              \"function(JSCompiler_StaticMethods_a$self) {\" + \n+              \"function(JSCompiler_StaticMethods_a$self) {\" +\n            \"JSCompiler_StaticMethods_a(JSCompiler_StaticMethods_a$self);\" +\n            \"return 7\" +\n         \"};\" +\n         \"Foo.prototype.b = function() {this.a()};\"\n     });\n   }\n-  \n+\n   public void testSpecializeDevirtualizePrototypeMethodsWithInline() {\n     JSModule[] modules = createModuleStar(\n         // m1\n         \"Foo.prototype.a = function() {return 7};\"\n     });\n   }\n-  \n+\n   /**\n    * Tests for {@link SpecializeModule.SpecializationState}.\n    */\n-  public static class SpecializeModuleSpecializationStateTest \n+  public static class SpecializeModuleSpecializationStateTest\n       extends CompilerTestCase {\n-    \n+\n     Compiler lastCompiler;\n-    \n+\n     SpecializationState lastState;\n-    \n+\n     @Override\n     public CompilerPass getProcessor(final Compiler compiler) {\n       lastCompiler = compiler;\n-      \n+\n       return new CompilerPass() {\n-        \n+\n         @Override\n-        public void process(Node externs, Node root) {         \n-          SimpleDefinitionFinder defFinder = \n+        public void process(Node externs, Node root) {\n+          SimpleDefinitionFinder defFinder =\n               new SimpleDefinitionFinder(compiler);\n-          \n+\n           defFinder.process(externs, root);\n-          \n-          SimpleFunctionAliasAnalysis functionAliasAnalysis = \n+\n+          SimpleFunctionAliasAnalysis functionAliasAnalysis =\n               new SimpleFunctionAliasAnalysis();\n-          \n-          functionAliasAnalysis.analyze(defFinder); \n-          \n-          lastState = new SpecializationState(functionAliasAnalysis);       \n+\n+          functionAliasAnalysis.analyze(defFinder);\n+\n+          lastState = new SpecializationState(functionAliasAnalysis);\n         }\n       };\n     }\n-      \n+\n     public void testRemovedFunctions() {\n       testSame(\"function F(){}\\nvar G = function(a){};\");\n-      \n+\n       assertEquals(ImmutableSet.of(), lastState.getRemovedFunctions());\n-      \n+\n       Node functionF = findFunction(\"F\");\n-      \n+\n       lastState.reportRemovedFunction(functionF, functionF.getParent());\n       assertEquals(ImmutableSet.of(functionF), lastState.getRemovedFunctions());\n \n       Node functionG = findFunction(\"F\");\n-      \n+\n       lastState.reportRemovedFunction(functionG, functionF.getParent());\n       assertEquals(ImmutableSet.of(functionF, functionG),\n           lastState.getRemovedFunctions());\n-      \n+\n       assertEquals(ImmutableSet.of(), lastState.getSpecializedFunctions());\n     }\n-    \n+\n     public void testSpecializedFunctions() {\n       testSame(\"function F(){}\\nvar G = function(a){};\");\n-      \n+\n       assertEquals(ImmutableSet.of(), lastState.getSpecializedFunctions());\n-      \n+\n       Node functionF = findFunction(\"F\");\n-      \n+\n       lastState.reportSpecializedFunction(functionF);\n       assertEquals(ImmutableSet.of(functionF),\n           lastState.getSpecializedFunctions());\n \n       Node functionG = findFunction(\"F\");\n-      \n+\n       lastState.reportSpecializedFunction(functionG);\n       assertEquals(ImmutableSet.of(functionF, functionG),\n           lastState.getSpecializedFunctions());\n-      \n+\n       assertEquals(ImmutableSet.of(), lastState.getRemovedFunctions());\n     }\n-    \n+\n     public void testCanFixupFunction() {\n       testSame(\"function F(){}\\n\" +\n                \"var G = function(a){};\\n\" +\n                \"var ns = {};\" +\n-               \"ns.H = function(){};\" + \n+               \"ns.H = function(){};\" +\n                \"var ns2 = {I : function anon1(){}};\" +\n                \"(function anon2(){})();\");\n-      \n+\n       assertTrue(lastState.canFixupFunction(findFunction(\"F\")));\n       assertTrue(lastState.canFixupFunction(findFunction(\"G\")));\n       assertTrue(lastState.canFixupFunction(findFunction(\"ns.H\")));\n       assertFalse(lastState.canFixupFunction(findFunction(\"anon1\")));\n       assertFalse(lastState.canFixupFunction(findFunction(\"anon2\")));\n-      \n+\n       // Can't guarantee safe fixup for aliased functions\n       testSame(\"function A(){}\\n\" +\n           \"var aliasA = A;\\n\");\n \n       assertFalse(lastState.canFixupFunction(findFunction(\"A\")));\n     }\n-    \n+\n     private Node findFunction(String name) {\n       FunctionFinder f = new FunctionFinder(name);\n       new NodeTraversal(lastCompiler, f).traverse(lastCompiler.jsRoot);\n       assertNotNull(\"Couldn't find \" + name, f.found);\n       return f.found;\n     }\n-    \n+\n     /**\n      * Quick Traversal to find a given function in the AST.\n      */\n       FunctionFinder(String target) {\n         this.target = target;\n       }\n-      \n+\n       @Override\n       public void visit(NodeTraversal t, Node n, Node parent) {\n         if (NodeUtil.isFunction(n)\n           found = n;\n         }\n       }\n-    }   \n+    }\n   }\n }\n--- a/test/com/google/javascript/jscomp/TypeCheckFunctionCheckTest.java\n+++ b/test/com/google/javascript/jscomp/TypeCheckFunctionCheckTest.java\n       \"function twoArg(arg1, arg2) {};\" +\n       \"Foo.prototype.prototypeMethod = twoArg;\" +\n       \"Foo.staticMethod = twoArg;\";\n-    \n+\n     // Prototype method with too many arguments.\n     testSame(METHOD_DEFS +\n         \"var f = new Foo();f.prototypeMethod(1, 2, 3);\",\n--- a/test/com/google/javascript/jscomp/VariableVisibilityAnalysisTest.java\n+++ b/test/com/google/javascript/jscomp/VariableVisibilityAnalysisTest.java\n \n /**\n  * Tests of {@link VariableVisibilityAnalysis}.\n- * \n+ *\n  * @author dcc@google.com (Devin Coughlin)\n  */\n public class VariableVisibilityAnalysisTest extends CompilerTestCase {\n \n   private Compiler lastCompiler;\n   private VariableVisibilityAnalysis lastAnalysis;\n-  \n+\n   @Override\n   protected CompilerPass getProcessor(Compiler compiler) {\n     lastAnalysis = new VariableVisibilityAnalysis(compiler);\n     lastCompiler = compiler;\n-    \n+\n     return lastAnalysis;\n   }\n-  \n+\n   public void testCapturedVariables() {\n-    String source = \n+    String source =\n         \"global:var global;\\n\" +\n         \"function Outer() {\\n\" +\n         \"  captured:var captured;\\n\" +\n         \"    alert(captured);\" +\n         \"   }\\n\" +\n         \"}\\n\";\n-    \n-    analyze(source);\n-    \n+\n+    analyze(source);\n+\n     assertIsCapturedLocal(\"captured\");\n     assertIsUncapturedLocal(\"notcaptured\");\n   }\n-  \n+\n   public void testGlobals() {\n-    String source = \n+    String source =\n       \"global:var global;\";\n-    \n-    analyze(source);\n-    \n-    assertIsGlobal(\"global\"); \n-  }\n-  \n+\n+    analyze(source);\n+\n+    assertIsGlobal(\"global\");\n+  }\n+\n   public void testParameters() {\n-    String source = \n+    String source =\n       \"function A(a,b,c) {\\n\" +\n       \"}\\n\";\n \n     analyze(source);\n-    \n+\n     assertIsParameter(\"a\");\n     assertIsParameter(\"b\");\n     assertIsParameter(\"c\");\n   }\n-  \n+\n   public void testFunctions() {\n     String source =\n         \"function global() {\\n\" +\n         \"    (function(){innerCaptured()})()\\n\" +\n         \"  }\\n\" +\n         \"}\\n\";\n-    \n-    analyze(source);\n-    \n+\n+    analyze(source);\n+\n     assertFunctionHasVisibility(\"global\",\n         VariableVisibility.GLOBAL);\n-    \n+\n     assertFunctionHasVisibility(\"inner\",\n         VariableVisibility.LOCAL);\n-    \n+\n     assertFunctionHasVisibility(\"innerCaptured\",\n         VariableVisibility.CAPTURED_LOCAL);\n   }\n-  \n+\n   private void assertFunctionHasVisibility(String functionName,\n       VariableVisibility visibility) {\n-    \n+\n     Node functionNode = searchForFunction(functionName);\n     assertNotNull(functionNode);\n-    \n+\n     Node nameNode = functionNode.getFirstChild();\n-    assertEquals(visibility, lastAnalysis.getVariableVisibility(nameNode));  \n-  }\n-  \n+    assertEquals(visibility, lastAnalysis.getVariableVisibility(nameNode));\n+  }\n+\n   private void assertLabeledVariableHasVisibility(String label,\n       VariableVisibility visibility) {\n     Node labeledVariable = searchLabel(label);\n-    \n+\n     Preconditions.checkState(NodeUtil.isVar(labeledVariable));\n-    \n+\n     // VAR\n-    //   NAME \n+    //   NAME\n     Node nameNode = labeledVariable.getFirstChild();\n-    \n-    assertEquals(visibility, lastAnalysis.getVariableVisibility(nameNode));  \n-  }\n-  \n+\n+    assertEquals(visibility, lastAnalysis.getVariableVisibility(nameNode));\n+  }\n+\n   private void assertIsCapturedLocal(String label) {\n-    assertLabeledVariableHasVisibility(label, \n-        VariableVisibility.CAPTURED_LOCAL); \n-  }\n-  \n+    assertLabeledVariableHasVisibility(label,\n+        VariableVisibility.CAPTURED_LOCAL);\n+  }\n+\n   private void assertIsUncapturedLocal(String label) {\n-    assertLabeledVariableHasVisibility(label, \n-        VariableVisibility.LOCAL); \n-  }\n-  \n+    assertLabeledVariableHasVisibility(label,\n+        VariableVisibility.LOCAL);\n+  }\n+\n   private void assertIsGlobal(String label) {\n-    assertLabeledVariableHasVisibility(label, \n-        VariableVisibility.GLOBAL); \n-  }\n-  \n+    assertLabeledVariableHasVisibility(label,\n+        VariableVisibility.GLOBAL);\n+  }\n+\n   private void assertIsParameter(String parameterName) {\n     Node parameterNode = searchForParameter(parameterName);\n-    \n+\n     assertNotNull(parameterNode);\n-    \n+\n     assertEquals(VariableVisibility.PARAMETER,\n         lastAnalysis.getVariableVisibility(parameterNode));\n   }\n-  \n+\n   private VariableVisibilityAnalysis analyze(String src) {\n     testSame(src);\n-    \n+\n     return lastAnalysis;\n   }\n-  \n+\n   /*\n    * Finds a parameter NAME node with the given name in the source AST.\n-   * \n+   *\n    * Behavior is undefined if there are multiple parameters with\n    * parameterName.\n    */\n   private Node searchForParameter(final String parameterName) {\n     Preconditions.checkArgument(parameterName != null);\n-    \n+\n     final Node[] foundNode = new Node[1];\n-    \n+\n     AbstractPostOrderCallback findParameter = new AbstractPostOrderCallback() {\n-      \n+\n       @Override\n       public void visit(NodeTraversal t, Node n, Node parent) {\n         if (n.getParent().getType() == Token.LP\n             && parameterName.equals(n.getString())) {\n-          \n+\n           foundNode[0] = n;\n         }\n       }\n-    }; \n-      \n+    };\n+\n     new NodeTraversal(lastCompiler, findParameter)\n         .traverse(lastCompiler.jsRoot);\n-    \n+\n     return foundNode[0];\n   }\n \n   /*\n    * Finds a function node with the given name in the source AST.\n-   * \n+   *\n    * Behavior is undefined if there are multiple functions with\n    * parameterName.\n    */\n   private Node searchForFunction(final String functionName) {\n     Preconditions.checkArgument(functionName != null);\n-    \n+\n     final Node[] foundNode = new Node[1];\n-    \n+\n     AbstractPostOrderCallback findFunction = new AbstractPostOrderCallback() {\n-      \n+\n       @Override\n       public void visit(NodeTraversal t, Node n, Node parent) {\n         if (NodeUtil.isFunction(n)\n-            && functionName.equals(NodeUtil.getFunctionName(n))) { \n+            && functionName.equals(NodeUtil.getFunctionName(n))) {\n           foundNode[0] = n;\n         }\n       }\n-    }; \n-      \n+    };\n+\n     new NodeTraversal(lastCompiler, findFunction)\n         .traverse(lastCompiler.jsRoot);\n-    \n+\n     return foundNode[0];\n   }\n-  \n+\n   // Shamelessly stolen from NameReferenceGraphConstructionTest\n   private Node searchLabel(String label) {\n     LabeledVariableSearcher s = new LabeledVariableSearcher(label);\n-      \n+\n     new NodeTraversal(lastCompiler, s).traverse(lastCompiler.jsRoot);\n     assertNotNull(\"Label \" + label + \" should be in the source code\", s.found);\n-    \n+\n     return s.found;\n   }\n-  \n+\n   /**\n    * Quick traversal to find a given labeled variable in the AST.\n-   * \n+   *\n    * Finds the variable for foo in:\n    * foo: var a = ...\n    */\n     public void visit(NodeTraversal t, Node n, Node parent) {\n       if (n.getType() == Token.LABEL &&\n           target.equals(n.getFirstChild().getString())) {\n-        \n+\n         // LABEL\n         //     VAR\n         //       NAME\n-        \n+\n         found = n.getLastChild();\n       }\n     }\n--- a/test/com/google/javascript/jscomp/deps/JsFunctionParserTest.java\n+++ b/test/com/google/javascript/jscomp/deps/JsFunctionParserTest.java\n \n /**\n  * Tests for {@link JsFunctionParser}\n- * \n+ *\n  * @author agrieve@google.com (Andrew Grieve)\n  * @author ielashi@google.com (Islam El-Ashi)\n  */\n       + \"/* blah */goog.provide(\\\"yes2\\\")/* blah*/\\n\"\n       + \"goog.require('yes3'); // goog.provide('no3');\\n\"\n       + \"// goog.provide('no4');\\n\"\n-      + \"goog.require(\\\"bar.data.SuperstarAddStarThreadActionRequestDelegate\\\"); \"\n+      + \"goog.require(\\\"\"\n+      + \"bar.data.SuperstarAddStarThreadActionRequestDelegate\\\"); \"\n       + \"//no new line at eof\";\n \n     Collection<SymbolInfo> symbols = parser.parseFile(SRC_PATH, CONTENTS);\n     SymbolInfo symbolInfo = i.next();\n     assertEquals(symbolInfo.symbol, \"yes1\");\n     assertEquals(symbolInfo.functionName, \"goog.provide\");\n-    \n+\n     symbolInfo = i.next();\n     assertEquals(symbolInfo.symbol, \"yes2\");\n     assertEquals(symbolInfo.functionName, \"goog.provide\");\n-    \n+\n     symbolInfo = i.next();\n     assertEquals(symbolInfo.symbol, \"yes3\");\n     assertEquals(symbolInfo.functionName, \"goog.require\");\n-    \n+\n     symbolInfo = i.next();\n-    assertEquals(symbolInfo.symbol, \"bar.data.SuperstarAddStarThreadActionRequestDelegate\");\n+    assertEquals(symbolInfo.symbol,\n+        \"bar.data.SuperstarAddStarThreadActionRequestDelegate\");\n     assertEquals(symbolInfo.functionName, \"goog.require\");\n-    \n+\n     assertEquals(symbols.size(), 4);\n     assertEquals(0, errorManager.getErrorCount());\n     assertEquals(0, errorManager.getWarningCount());\n         + \"goog.provide('no1');*/goog.provide('yes3');//goog.provide('no2');\";\n \n     Collection<SymbolInfo> symbols = parser.parseFile(SRC_PATH, CONTENTS);\n-    \n+\n     Iterator<SymbolInfo> i = symbols.iterator();\n     SymbolInfo symbolInfo = i.next();\n     assertEquals(symbolInfo.symbol, \"yes1\");\n     assertEquals(symbolInfo.functionName, \"goog.provide\");\n-    \n+\n     symbolInfo = i.next();\n     assertEquals(symbolInfo.symbol, \"yes2\");\n     assertEquals(symbolInfo.functionName, \"goog.provide\");\n-    \n+\n     symbolInfo = i.next();\n     assertEquals(symbolInfo.symbol, \"yes3\");\n     assertEquals(symbolInfo.functionName, \"goog.provide\");\n-    \n+\n     assertEquals(symbols.size(), 3);\n     assertEquals(0, errorManager.getErrorCount());\n     assertEquals(0, errorManager.getWarningCount());\n         + \"goog.provide('no1');\";\n \n     Collection<SymbolInfo> symbols = parser.parseFile(SRC_PATH, CONTENTS);\n-    \n+\n     Iterator<SymbolInfo> i = symbols.iterator();\n     SymbolInfo symbolInfo = i.next();\n     assertEquals(symbolInfo.symbol, \"yes1\");\n     assertEquals(symbolInfo.functionName, \"goog.provide\");\n-    \n+\n     symbolInfo = i.next();\n     assertEquals(symbolInfo.symbol, \"yes2\");\n     assertEquals(symbolInfo.functionName, \"goog.provide\");\n-    \n+\n     assertEquals(symbols.size(), 2);\n     assertEquals(0, errorManager.getErrorCount());\n     assertEquals(0, errorManager.getWarningCount());\n     final String CONTENTS = \"/** goog.provide('no1'); \\n\" +\n         \" * goog.provide('no2');\\n */\\n\"\n         + \"goog.provide('yes1');\\n\";\n-    \n+\n     Collection<SymbolInfo> symbols = parser.parseFile(SRC_PATH, CONTENTS);\n-    \n+\n     Iterator<SymbolInfo> i = symbols.iterator();\n     SymbolInfo symbolInfo = i.next();\n     assertEquals(symbolInfo.symbol, \"yes1\");\n     assertEquals(symbolInfo.functionName, \"goog.provide\");\n-    \n+\n     assertEquals(symbols.size(), 1);\n     assertEquals(0, errorManager.getErrorCount());\n     assertEquals(0, errorManager.getWarningCount());\n     final String CONTENTS = \"/**\\n\" +\n         \" * goog.provide('no1');\\n */\\n\"\n         + \"goog.provide('yes1');\\n\";\n-    \n+\n     Collection<SymbolInfo> symbols = parser.parseFile(SRC_PATH, CONTENTS);\n-    \n+\n     Iterator<SymbolInfo> i = symbols.iterator();\n     SymbolInfo symbolInfo = i.next();\n     assertEquals(symbolInfo.symbol, \"yes1\");\n--- a/test/com/google/javascript/jscomp/jsonml/JsonMLValidationTest.java\n+++ b/test/com/google/javascript/jscomp/jsonml/JsonMLValidationTest.java\n             \"['DataProp',{'name':'y'},\" +\n                 \"['LiteralExpr',{'type':'number','value':2}]]]\");\n     // wrong types of children\n-    TagType[] tags = \n+    TagType[] tags =\n         {TagType.DataProp, TagType.GetterProp, TagType.SetterProp };\n     testWrongChildTypeValidation(\"\" +\n         \"['ObjectExpr',{},\" +\n--- a/test/com/google/javascript/rhino/JSDocInfoTest.java\n+++ b/test/com/google/javascript/rhino/JSDocInfoTest.java\n     info = new JSDocInfo(true);\n     info.setModifies(Sets.newHashSet(\"arguments\"));\n     assertEquals(Sets.newHashSet(\"arguments\"), info.getModifies());\n-  }  \n+  }\n \n   /** Gets the type expression for a simple type name. */\n   private JSTypeExpression fromString(String s) {\n--- a/test/com/google/javascript/rhino/TokenStreamTest.java\n+++ b/test/com/google/javascript/rhino/TokenStreamTest.java\n     testJSDocTokenStream(\"@param { Object = }*/\", tokens, strings);\n     testJSDocTokenStream(\"@param {Object=  }*/\", tokens, strings);\n   }\n-  \n+\n   public void testJSDocLinenoCharno1() throws Exception {\n     TokenStream stream = stream(\" * @type {string}\\n  *   @private\");\n     testNextJSDocTokenPosition(stream, STAR, 0, 1);", "timestamp": 1299800095, "metainfo": ""}