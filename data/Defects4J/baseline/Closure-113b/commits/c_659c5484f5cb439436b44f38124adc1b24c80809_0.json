{"sha": "659c5484f5cb439436b44f38124adc1b24c80809", "log": "Introduce an experimental option to use externs to export mutable properties and/or properties not on global names.  This differs from @expose in that it does not interfere with CollapseProperties or other optimizations that can ignore externs (generally, objects known not to escape) and pattern matching that doesn't expect GETELEM.  A finalized version of this combined with a @nocollapse annotation will allow us to remove @expose support.  Several simplification are made here: 1) only properties that would not otherwise have been legal to export are exportable using this new approach so this can't introduce problems for existing @export usage. 2) the properties are \"exported\" by creating synthetic properties on \"Object.prototype\".  Exporting on \"Object.prototype\" is not ideal as it prevents property disambiguation and thus renaming of the property globally, however it is sufficient to validate this approach. What should happen, once we have a mechanism for adding an synthetic interface declaration, is that each \"class\" would implement a specific \"exports\" interface just for that class.  Only object literal properties would be exported to Object.prototype.  Alternately, in an ES5 world these properties could be exported by introducing ES5 getters/setters for the properties to \"alias\" the name (this gets a little tricky as we would need to handle the case where the property is not actually renamed). ------------- Created by MOE: http://code.google.com/p/moe-java MOE_MIGRATED_REVID=50904100", "commit": "\n--- a/src/com/google/javascript/jscomp/CompilerOptions.java\n+++ b/src/com/google/javascript/jscomp/CompilerOptions.java\n   public boolean recordFunctionInformation;\n \n   public boolean generateExports;\n+\n+  boolean exportLocalPropertyDefinitions;\n \n   /** Map used in the renaming of CSS class names. */\n   public CssRenamingMap cssRenamingMap;\n     appNameStr = \"\";\n     recordFunctionInformation = false;\n     generateExports = false;\n+    exportLocalPropertyDefinitions = false;\n     cssRenamingMap = null;\n     cssRenamingWhitelist = null;\n     processObjectPropertyString = false;\n \n   public void setGenerateExports(boolean generateExports) {\n     this.generateExports = generateExports;\n+  }\n+\n+  public void setExportLocalPropertyDefinitions(boolean export) {\n+    this.exportLocalPropertyDefinitions = export;\n   }\n \n   public void setAngularPass(boolean angularPass) {\n--- a/src/com/google/javascript/jscomp/DefaultPassConfig.java\n+++ b/src/com/google/javascript/jscomp/DefaultPassConfig.java\n \n   static final DiagnosticType CANNOT_USE_PROTOTYPE_AND_VAR =\n       DiagnosticType.error(\"JSC_CANNOT_USE_PROTOTYPE_AND_VAR\",\n-          \"Rename prototypes and inline variables cannot be used together\");\n+          \"Rename prototypes and inline variables cannot be used together.\");\n+\n+  static final DiagnosticType CANNOT_USE_EXPORT_LOCALS_AND_EXTERN_PROP_REMOVAL =\n+      DiagnosticType.error(\"JSC_CANNOT_USE_EXPORT_LOCALS_AND_EXTERN_PROP_REMOVAL\",\n+          \"remove_unused_prototype_properties_in_externs \" +\n+          \"and export_local_property_definitions cannot be used together.\");\n \n   // Miscellaneous errors.\n   static final DiagnosticType REPORT_PATH_IO_ERROR =\n   final PassFactory generateExports = new PassFactory(\"generateExports\", true) {\n     @Override\n     protected CompilerPass create(AbstractCompiler compiler) {\n+      if (options.removeUnusedPrototypePropertiesInExterns\n+          && options.exportLocalPropertyDefinitions) {\n+        return new ErrorPass(\n+            compiler, CANNOT_USE_EXPORT_LOCALS_AND_EXTERN_PROP_REMOVAL);\n+      }\n+\n       CodingConvention convention = compiler.getCodingConvention();\n       if (convention.getExportSymbolFunction() != null &&\n           convention.getExportPropertyFunction() != null) {\n         return new GenerateExports(compiler,\n+            options.exportLocalPropertyDefinitions,\n             convention.getExportSymbolFunction(),\n             convention.getExportPropertyFunction());\n       } else {\n--- a/src/com/google/javascript/jscomp/FindExportableNodes.java\n+++ b/src/com/google/javascript/jscomp/FindExportableNodes.java\n package com.google.javascript.jscomp;\n \n import com.google.common.collect.Maps;\n+import com.google.common.collect.Sets;\n import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n import com.google.javascript.rhino.JSDocInfo;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n \n import java.util.LinkedHashMap;\n+import java.util.Set;\n \n /**\n  * Records all of the symbols and properties that should be exported.\n  * to all the variables or only the first one.\n  *\n  */\n-public class FindExportableNodes extends AbstractPostOrderCallback {\n+class FindExportableNodes extends AbstractPostOrderCallback {\n \n   static final DiagnosticType NON_GLOBAL_ERROR =\n       DiagnosticType.error(\"JSC_NON_GLOBAL_ERROR\",\n           \"@export only applies to symbols/properties defined in the \" +\n           \"global scope.\");\n \n+  static final DiagnosticType EXPORT_ANNOTATION_NOT_ALLOWED =\n+      DiagnosticType.error(\"JSC_EXPORT_ANNOTATION_NOT_ALLOWED\",\n+          \"@export is not supported on this expression.\");\n+\n+  private final AbstractCompiler compiler;\n+\n   /**\n    * It's convenient to be able to iterate over exports in the order in which\n    * they are encountered.\n    */\n-  private final LinkedHashMap<String, GenerateNodeContext> exports;\n+  private final LinkedHashMap<String, GenerateNodeContext> exports =\n+      Maps.newLinkedHashMap();\n \n-  private final AbstractCompiler compiler;\n+  private Set<String> externProps = Sets.newLinkedHashSet();\n \n-  public FindExportableNodes(AbstractCompiler compiler) {\n+  private final boolean allowLocalExports;\n+\n+  FindExportableNodes(\n+      AbstractCompiler compiler, boolean allowLocalExports) {\n     this.compiler = compiler;\n-    this.exports = Maps.newLinkedHashMap();\n+    this.allowLocalExports = allowLocalExports;\n   }\n \n   @Override\n         case Token.FUNCTION:\n           if (parent.isScript()) {\n             export = NodeUtil.getFunctionName(n);\n-            context = new GenerateNodeContext(n, parent, n);\n+            context = new GenerateNodeContext(n, Mode.EXPORT);\n           }\n           break;\n+\n         case Token.ASSIGN:\n           Node grandparent = parent.getParent();\n-          if (grandparent != null && grandparent.isScript() &&\n-              parent.isExprResult() &&\n+          if (parent.isExprResult() &&\n               !n.getLastChild().isAssign()) {\n-            export = n.getFirstChild().getQualifiedName();\n-            context = new GenerateNodeContext(n, grandparent, parent);\n+            if (grandparent != null && grandparent.isScript() &&\n+                n.getFirstChild().isQualifiedName()) {\n+              export = n.getFirstChild().getQualifiedName();\n+              context = new GenerateNodeContext(n, Mode.EXPORT);\n+            } else if (allowLocalExports && n.getFirstChild().isGetProp()) {\n+              Node target = n.getFirstChild();\n+              export = target.getLastChild().getString();\n+              context = new GenerateNodeContext(n, Mode.EXTERN);\n+            }\n           }\n           break;\n+\n         case Token.VAR:\n           if (parent.isScript()) {\n             if (n.getFirstChild().hasChildren() &&\n                 !n.getFirstChild().getFirstChild().isAssign()) {\n               export = n.getFirstChild().getString();\n-              context = new GenerateNodeContext(n, parent, n);\n+              context = new GenerateNodeContext(n, Mode.EXPORT);\n             }\n           }\n+          break;\n+\n+        case Token.GETPROP:\n+          if (allowLocalExports && parent.isExprResult()) {\n+            export = n.getLastChild().getString();\n+            context = new GenerateNodeContext(n, Mode.EXTERN);\n+          }\n+          break;\n+\n+        case Token.STRING_KEY:\n+          if (allowLocalExports) {\n+            export = n.getString();\n+            context = new GenerateNodeContext(n, Mode.EXTERN);\n+          }\n+          break;\n       }\n \n       if (export != null) {\n         exports.put(export, context);\n       } else {\n-        compiler.report(t.makeError(n, NON_GLOBAL_ERROR));\n+        if (allowLocalExports) {\n+          compiler.report(t.makeError(n, EXPORT_ANNOTATION_NOT_ALLOWED));\n+        } else {\n+          compiler.report(t.makeError(n, NON_GLOBAL_ERROR));\n+        }\n       }\n     }\n   }\n \n-  public LinkedHashMap<String, GenerateNodeContext> getExports() {\n+  LinkedHashMap<String, GenerateNodeContext> getExports() {\n     return exports;\n+  }\n+\n+  static enum Mode {\n+    EXPORT,\n+    EXTERN\n   }\n \n   /**\n    * Context holding the node references required for generating the export\n    * calls.\n    */\n-  public static class GenerateNodeContext {\n-    private final Node scriptNode;\n-    private final Node contextNode;\n+  static class GenerateNodeContext {\n     private final Node node;\n+    private final Mode mode;\n \n-    public GenerateNodeContext(Node node, Node scriptNode, Node contextNode) {\n+    GenerateNodeContext(\n+        Node node, Mode mode) {\n       this.node = node;\n-      this.scriptNode = scriptNode;\n-      this.contextNode = contextNode;\n+      this.mode = mode;\n     }\n \n-    public Node getNode() {\n+    Node getNode() {\n       return node;\n     }\n \n-    public Node getScriptNode() {\n-      return scriptNode;\n-    }\n-\n-    public Node getContextNode() {\n-      return contextNode;\n+    public Mode getMode() {\n+      return mode;\n     }\n   }\n }\n--- a/src/com/google/javascript/jscomp/GenerateExports.java\n+++ b/src/com/google/javascript/jscomp/GenerateExports.java\n \n import com.google.common.base.Preconditions;\n import com.google.javascript.jscomp.FindExportableNodes.GenerateNodeContext;\n+import com.google.javascript.jscomp.FindExportableNodes.Mode;\n import com.google.javascript.rhino.IR;\n import com.google.javascript.rhino.Node;\n \n   private final String exportSymbolFunction;\n \n   private final String exportPropertyFunction;\n+\n+  private final boolean allowNonGlobalExports;\n \n   /**\n    * Creates a new generate exports compiler pass.\n    * @param exportSymbolFunction function used for exporting symbols.\n    * @param exportPropertyFunction function used for exporting property names.\n    */\n-  GenerateExports(AbstractCompiler compiler, String exportSymbolFunction,\n+  GenerateExports(\n+      AbstractCompiler compiler,\n+      boolean allowNonGlobalExports,\n+      String exportSymbolFunction,\n       String exportPropertyFunction) {\n     Preconditions.checkNotNull(compiler);\n     Preconditions.checkNotNull(exportSymbolFunction);\n     Preconditions.checkNotNull(exportPropertyFunction);\n \n     this.compiler = compiler;\n+    this.allowNonGlobalExports = allowNonGlobalExports;\n     this.exportSymbolFunction = exportSymbolFunction;\n     this.exportPropertyFunction = exportPropertyFunction;\n   }\n \n   @Override\n   public void process(Node externs, Node root) {\n-    FindExportableNodes findExportableNodes = new FindExportableNodes(compiler);\n+    FindExportableNodes findExportableNodes = new FindExportableNodes(\n+        compiler, allowNonGlobalExports);\n     NodeTraversal.traverse(compiler, root, findExportableNodes);\n     Map<String, GenerateNodeContext> exports = findExportableNodes\n         .getExports();\n \n-    CodingConvention convention = compiler.getCodingConvention();\n     for (Map.Entry<String, GenerateNodeContext> entry : exports.entrySet()) {\n       String export = entry.getKey();\n       GenerateNodeContext context = entry.getValue();\n \n-      // Emit the proper CALL expression.\n-      // This is an optimization to avoid exporting everything as a symbol\n-      // because exporting a property is significantly simpler/faster.\n-      // Only export the property if the parent is being exported or\n-      // if the parent is \"prototype\" and the grandparent is being exported.\n-      String parent = null;\n-      String grandparent = null;\n-\n-      Node node = context.getNode().getFirstChild();\n-      if (node.isGetProp()) {\n-        parent = node.getFirstChild().getQualifiedName();\n-        if (node.getFirstChild().isGetProp() &&\n-            getPropertyName(node.getFirstChild()).equals(PROTOTYPE_PROPERTY)) {\n-          grandparent = node.getFirstChild().getFirstChild().getQualifiedName();\n-        }\n+      if (context.getMode() == Mode.EXPORT) {\n+        addExportMethod(exports, export, context);\n+      } else if (context.getMode() == Mode.EXTERN) {\n+        addExtern(export);\n       }\n-\n-      boolean useExportSymbol = true;\n-      if (grandparent != null && exports.containsKey(grandparent)) {\n-        useExportSymbol = false;\n-      } else if (parent != null && exports.containsKey(parent)) {\n-        useExportSymbol = false;\n+    }\n+  }\n+\n+  private Node qualifiedNameNode(String qname) {\n+    return NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), qname);\n+  }\n+\n+  private void addExtern(String export) {\n+    Node propstmt = IR.exprResult(\n+        IR.getprop(qualifiedNameNode(\"Object.prototype\"), IR.string(export)));\n+    getSynthesizedExternsRoot().addChildToBack(propstmt);\n+    compiler.reportCodeChange();\n+  }\n+\n+  private void addExportMethod(Map<String, GenerateNodeContext> exports,\n+      String export, GenerateNodeContext context) {\n+    CodingConvention convention = compiler.getCodingConvention();\n+\n+    // Emit the proper CALL expression.\n+    // This is an optimization to avoid exporting everything as a symbol\n+    // because exporting a property is significantly simpler/faster.\n+    // Only export the property if the parent is being exported or\n+    // if the parent is \"prototype\" and the grandparent is being exported.\n+    String parent = null;\n+    String grandparent = null;\n+\n+    Node node = context.getNode().getFirstChild();\n+    if (node.isGetProp()) {\n+      Node parentNode = node.getFirstChild();\n+      parent = parentNode.getQualifiedName();\n+      if (parentNode.isGetProp()\n+          && parentNode.getLastChild().getString().equals(PROTOTYPE_PROPERTY)) {\n+        grandparent = parentNode.getFirstChild().getQualifiedName();\n       }\n-\n-      Node call;\n-      if (useExportSymbol) {\n-        // exportSymbol(publicPath, object);\n-        call = IR.call(\n-            NodeUtil.newQualifiedNameNode(\n-                convention, exportSymbolFunction,\n-                context.getNode(), export),\n-            IR.string(export),\n-            NodeUtil.newQualifiedNameNode(\n-                convention, export,\n-                context.getNode(), export));\n+    }\n+\n+    boolean useExportSymbol = true;\n+    if (grandparent != null && exports.containsKey(grandparent)) {\n+      // grandparent is only set for properties exported off a prototype obj.\n+      useExportSymbol = false;\n+    } else if (parent != null && exports.containsKey(parent)) {\n+      useExportSymbol = false;\n+    }\n+\n+    Node call;\n+    if (useExportSymbol) {\n+      // exportSymbol(publicPath, object);\n+      call = IR.call(\n+          NodeUtil.newQualifiedNameNode(\n+              convention, exportSymbolFunction,\n+              context.getNode(), export),\n+          IR.string(export),\n+          NodeUtil.newQualifiedNameNode(\n+              convention, export,\n+              context.getNode(), export));\n+    } else {\n+      // exportProperty(object, publicName, symbol);\n+      String property = getPropertyName(node);\n+      call = IR.call(\n+          NodeUtil.newQualifiedNameNode(\n+              convention, exportPropertyFunction,\n+              context.getNode(), exportPropertyFunction),\n+          NodeUtil.newQualifiedNameNode(\n+              convention, parent,\n+              context.getNode(), exportPropertyFunction),\n+          IR.string(property),\n+          NodeUtil.newQualifiedNameNode(\n+              convention, export,\n+              context.getNode(), exportPropertyFunction));\n+    }\n+\n+    Node expression = IR.exprResult(call);\n+    annotate(expression);\n+\n+    addStatement(context, expression);\n+\n+    compiler.reportCodeChange();\n+  }\n+\n+  private void addStatement(GenerateNodeContext context, Node stmt) {\n+    CodingConvention convention = compiler.getCodingConvention();\n+\n+    Node n = context.getNode();\n+    Node exprRoot = n;\n+    while (!NodeUtil.isStatementBlock(exprRoot.getParent())) {\n+      exprRoot = exprRoot.getParent();\n+    }\n+\n+    // It's important that any class-building calls (goog.inherits)\n+    // come right after the class definition, so move the export after that.\n+    while (true) {\n+      Node next = exprRoot.getNext();\n+      if (next != null\n+          && NodeUtil.isExprCall(next)\n+          && convention.getClassesDefinedByCall(next.getFirstChild()) != null) {\n+        exprRoot = next;\n       } else {\n-        // exportProperty(object, publicName, symbol);\n-        String property = getPropertyName(node);\n-        call = IR.call(\n-            NodeUtil.newQualifiedNameNode(\n-                convention, exportPropertyFunction,\n-                context.getNode(), exportPropertyFunction),\n-            NodeUtil.newQualifiedNameNode(\n-                convention, parent,\n-                context.getNode(), exportPropertyFunction),\n-            IR.string(property),\n-            NodeUtil.newQualifiedNameNode(\n-                convention, export,\n-                context.getNode(), exportPropertyFunction));\n+        break;\n       }\n-\n-      Node expression = IR.exprResult(call);\n-      annotate(expression);\n-\n-      // It's important that any class-building calls (goog.inherits)\n-      // come right after the class definition, so move the export after that.\n-      Node insertionPoint = context.getContextNode().getNext();\n-      while (insertionPoint != null &&\n-          NodeUtil.isExprCall(insertionPoint) &&\n-          convention.getClassesDefinedByCall(\n-              insertionPoint.getFirstChild()) != null) {\n-        insertionPoint = insertionPoint.getNext();\n-      }\n-\n-      if (insertionPoint == null) {\n-        context.getScriptNode().addChildToBack(expression);\n-      } else {\n-        context.getScriptNode().addChildBefore(expression, insertionPoint);\n-      }\n-      compiler.reportCodeChange();\n-    }\n+    }\n+\n+    Node block = exprRoot.getParent();\n+    block.addChildAfter(stmt, exprRoot);\n   }\n \n   private void annotate(Node node) {\n     Preconditions.checkArgument(node.isGetProp());\n     return node.getLastChild().getString();\n   }\n+\n+  /** Lazily create a \"new\" externs root for undeclared variables. */\n+  private Node getSynthesizedExternsRoot() {\n+    return  compiler.getSynthesizedExternsInput().getAstRoot(compiler);\n+  }\n }\n--- a/src/com/google/javascript/jscomp/VarCheck.java\n+++ b/src/com/google/javascript/jscomp/VarCheck.java\n     DiagnosticType.warning(\n       \"JSC_UNDEFINED_EXTERN_VAR_ERROR\",\n       \"name {0} is not undefined in the externs.\");\n-\n-  private Node synthesizedExternsRoot = null;\n \n   // Vars that still need to be declared in externs. These will be declared\n   // at the end of the pass, or when we see the equivalent var declared\n         } else {\n           createSynthesizedExternVar(varName);\n           scope.getGlobalScope().declare(varName, n,\n-              null, getSynthesizedExternsInput());\n+              null, compiler.getSynthesizedExternsInput());\n         }\n       }\n       return;\n     }\n   }\n \n-  /** Lazily create a \"new\" externs input for undeclared variables. */\n-  private CompilerInput getSynthesizedExternsInput() {\n-    return compiler.getSynthesizedExternsInput();\n-  }\n-\n   /** Lazily create a \"new\" externs root for undeclared variables. */\n   private Node getSynthesizedExternsRoot() {\n-    if (synthesizedExternsRoot == null) {\n-      CompilerInput synthesizedExterns = getSynthesizedExternsInput();\n-      synthesizedExternsRoot = synthesizedExterns.getAstRoot(compiler);\n-    }\n-    return synthesizedExternsRoot;\n+    return  compiler.getSynthesizedExternsInput().getAstRoot(compiler);\n   }\n }\n--- a/test/com/google/javascript/jscomp/GenerateExportsTest.java\n+++ b/test/com/google/javascript/jscomp/GenerateExportsTest.java\n \n package com.google.javascript.jscomp;\n \n+import com.google.common.collect.ImmutableList;\n+import com.google.javascript.rhino.Node;\n+\n /**\n  * Generate exports unit test.\n  *\n       \"function google_exportSymbol(a, b) {}; \" +\n       \"goog.exportProperty = function(a, b, c) {}; \";\n \n+  private boolean allowNonGlobalExports = true;\n+\n   public GenerateExportsTest() {\n     super(EXTERNS);\n   }\n \n   @Override\n   protected CompilerPass getProcessor(Compiler compiler) {\n-    return new GenerateExports(compiler,\n+    return new GenerateExports(compiler, allowNonGlobalExports,\n         \"google_exportSymbol\", \"goog.exportProperty\");\n   }\n \n   public void setUp() throws Exception {\n     super.setUp();\n     super.enableLineNumberCheck(false);\n+\n+    this.allowNonGlobalExports  = true;\n   }\n \n   public void testExportSymbol() {\n    * @see FindExportableNodes\n    */\n   public void testNestedVarAssign() {\n+    this.allowNonGlobalExports = false;\n     test(\"var BAR;\\n/** @export */var FOO = BAR = 5\",\n          null, FindExportableNodes.NON_GLOBAL_ERROR);\n+\n+    this.allowNonGlobalExports = true;\n+    test(\"var BAR;\\n/** @export */var FOO = BAR = 5\",\n+        null, FindExportableNodes.EXPORT_ANNOTATION_NOT_ALLOWED);\n+\n   }\n \n   /**\n    * @see FindExportableNodes\n    */\n   public void testNestedAssign() {\n+    this.allowNonGlobalExports = false;\n     test(\"var BAR;var FOO = {};\\n/** @export */FOO.test = BAR = 5\",\n          null, FindExportableNodes.NON_GLOBAL_ERROR);\n+\n+    this.allowNonGlobalExports = true;\n+    test(\"var BAR;var FOO = {};\\n/** @export */FOO.test = BAR = 5\",\n+         null, FindExportableNodes.EXPORT_ANNOTATION_NOT_ALLOWED);\n   }\n \n   public void testNonGlobalScopeExport() {\n+    this.allowNonGlobalExports = false;\n     test(\"(function() { /** @export */var FOO = 5 })()\",\n          null, FindExportableNodes.NON_GLOBAL_ERROR);\n+\n+    this.allowNonGlobalExports = true;\n+    test(\"(function() { /** @export */var FOO = 5 })()\",\n+        null, FindExportableNodes.EXPORT_ANNOTATION_NOT_ALLOWED);\n   }\n \n   public void testExportClass() {\n          \"/** @enum {string}\\n @export */ var E = {A:1, B:2};\" +\n          \"google_exportSymbol('E', E);\");\n   }\n+\n+  public void testExportObjectLit1() {\n+    allowExternsChanges(true);\n+    String code = \"var E = {/** @export */ A:1, B:2};\";\n+    testSame(code);\n+    checkSynthesizedExtern(code, \"Object.prototype.A;\");\n+  }\n+\n+  public void testExportClassMember1() {\n+    allowExternsChanges(true);\n+    String code = \"var E = function() { /** @export */ this.foo = 1; };\";\n+    testSame(code);\n+    checkSynthesizedExtern(code, \"Object.prototype.foo;\");\n+  }\n+\n+  public void testExportClassMemberStub() {\n+    allowExternsChanges(true);\n+    String code = \"var E = function() { /** @export */ this.foo; };\";\n+    testSame(code);\n+    checkSynthesizedExtern(code, \"Object.prototype.foo;\");\n+  }\n+\n+  public void checkSynthesizedExtern(\n+      String input, String expectedExtern) {\n+    checkSynthesizedExtern(\"\", input, expectedExtern);\n+  }\n+\n+\n+  // TODO(johnlenz): make this common code and unify with the VarCheckTest\n+  public void checkSynthesizedExtern(\n+      String extern, String input, String expectedExtern) {\n+    Compiler compiler = createCompiler();\n+    CompilerOptions options = getOptions();\n+    compiler.init(\n+        ImmutableList.of(SourceFile.fromCode(\"extern\", extern)),\n+        ImmutableList.of(SourceFile.fromCode(\"input\", input)),\n+        options);\n+    compiler.parseInputs();\n+    assertFalse(compiler.hasErrors());\n+\n+    Node externsAndJs = compiler.getRoot();\n+    Node root = externsAndJs.getLastChild();\n+\n+    Node externs = externsAndJs.getFirstChild();\n+\n+    Node expected = compiler.parseTestCode(expectedExtern);\n+    assertFalse(compiler.hasErrors());\n+\n+    (getProcessor(compiler))\n+        .process(externs, root);\n+\n+    String externsCode = compiler.toSource(externs);\n+    String expectedCode = compiler.toSource(expected);\n+\n+    assertEquals(expectedCode, externsCode);\n+  }\n }\n--- a/test/com/google/javascript/jscomp/IntegrationTest.java\n+++ b/test/com/google/javascript/jscomp/IntegrationTest.java\n     test(options, code, result);\n   }\n \n+  public void testExports() {\n+    CompilerOptions options = createCompilerOptions();\n+    CompilationLevel level = CompilationLevel.ADVANCED_OPTIMIZATIONS;\n+    level.setOptionsForCompilationLevel(options);\n+    WarningLevel warnings = WarningLevel.DEFAULT;\n+    warnings.setOptionsForWarningLevel(options);\n+\n+    String code = \"\" +\n+        \"/** @constructor */ var X = function() {\" +\n+           \"/** @export */ this.abc = 1;};\\n\" +\n+        \"/** @constructor */ var Y = function() {\" +\n+           \"/** @export */ this.abc = 1;};\\n\" +\n+        \"alert(new X().abc + new Y().abc);\";\n+\n+    // no export enabled, property name not preserved\n+    test(options, code,\n+        \"alert((new function(){this.a = 1}).a + \" +\n+            \"(new function(){this.a = 1}).a);\");\n+\n+    options.generateExports = true;\n+\n+    // exports enabled, but not local exports\n+    test(options,\n+        \"/** @constructor */ var X = function() {\" +\n+        \"/** @export */ this.abc = 1;};\\n\",\n+        FindExportableNodes.NON_GLOBAL_ERROR);\n+\n+    options.exportLocalPropertyDefinitions = true;\n+\n+    // Local exports enabled, but removeUnusedPrototypePropertiesInExterns not\n+    // disabled.\n+    test(options, code,\n+        DefaultPassConfig.CANNOT_USE_EXPORT_LOCALS_AND_EXTERN_PROP_REMOVAL);\n+\n+    options.removeUnusedPrototypePropertiesInExterns = false;\n+\n+    // property name preserved due to export\n+    test(options, code,\n+        \"alert((new function(){this.abc = 1}).abc + \" +\n+            \"(new function(){this.abc = 1}).abc);\");\n+\n+    // unreferenced property not removed due to export.\n+    test(options, \"\" +\n+        \"/** @constructor */ var X = function() {\" +\n+        \"/** @export */ this.abc = 1;};\\n\" +\n+        \"/** @constructor */ var Y = function() {\" +\n+        \"/** @export */ this.abc = 1;};\\n\" +\n+        \"alert(new X() + new Y());\",\n+        \"alert((new function(){this.abc = 1}) + \" +\n+            \"(new function(){this.abc = 1}));\");\n+\n+    // disambiguate and ambiguate properties respect the exports.\n+    options.checkTypes = true;\n+    options.disambiguateProperties = true;\n+    options.ambiguateProperties = true;\n+    options.propertyInvalidationErrors = ImmutableMap.of(\n+        \"abc\", CheckLevel.ERROR);\n+\n+    test(options, code,\n+        \"alert((new function(){this.abc = 1}).abc + \" +\n+            \"(new function(){this.abc = 1}).abc);\");\n+\n+    // unreferenced property not removed due to export.\n+    test(options, \"\" +\n+        \"/** @constructor */ var X = function() {\" +\n+        \"/** @export */ this.abc = 1;};\\n\" +\n+        \"/** @constructor */ var Y = function() {\" +\n+        \"/** @export */ this.abc = 1;};\\n\" +\n+        \"alert(new X() + new Y());\",\n+        \"alert((new function(){this.abc = 1}) + \" +\n+            \"(new function(){this.abc = 1}));\");\n+  }\n+\n   public void testManyAdds() {\n     CompilerOptions options = createCompilerOptions();\n     CompilationLevel level = CompilationLevel.SIMPLE_OPTIMIZATIONS;", "timestamp": 1376615284, "metainfo": ""}