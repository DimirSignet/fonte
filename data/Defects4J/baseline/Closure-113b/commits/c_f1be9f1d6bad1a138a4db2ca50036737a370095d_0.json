{"sha": "f1be9f1d6bad1a138a4db2ca50036737a370095d", "log": "Fix a nasty bug where properties on one prototype were leaking onto unrelated prototypes  R=acleung DELTA=84  (65 added, 1 deleted, 18 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=4450   ", "commit": "\n--- a/src/com/google/javascript/jscomp/TypeCheck.java\n+++ b/src/com/google/javascript/jscomp/TypeCheck.java\n         if (type.hasProperty(property) &&\n             !type.isPropertyTypeInferred(property) &&\n             !propertyIsImplicitCast(type, property)) {\n-          validator.expectCanAssignToPropertyOf(\n-              t, assign, getJSType(rvalue),\n-              type.getPropertyType(property), object, property);\n-          return;\n+          JSType expectedType = type.getPropertyType(property);\n+          if (!expectedType.isUnknownType()) {\n+            validator.expectCanAssignToPropertyOf(\n+                t, assign, getJSType(rvalue),\n+                expectedType, object, property);\n+            return;\n+          }\n         }\n       }\n     }\n       Var var = t.getScope().getVar(lvalue.getQualifiedName());\n       if (var != null) {\n         if (var.isTypeInferred()) {\n+          return;\n+        }\n+\n+        if (NodeUtil.getRootOfQualifiedName(lvalue).isThis() &&\n+            t.getScope() != var.getScope()) {\n+          // Don't look at \"this.foo\" variables from other scopes.\n           return;\n         }\n \n--- a/src/com/google/javascript/rhino/jstype/FunctionType.java\n+++ b/src/com/google/javascript/rhino/jstype/FunctionType.java\n   public ObjectType getPrototype() {\n     // lazy initialization of the prototype field\n     if (prototypeSlot == null) {\n-      setPrototype(\n-          new PrototypeObjectType(\n-              registry,\n-              this.getReferenceName() + \".prototype\",\n-              registry.getNativeObjectType(OBJECT_TYPE),\n-              isNativeObjectType()),\n-          null);\n+      String refName = getReferenceName();\n+      if (refName == null) {\n+        // Someone is trying to access the prototype of a structural function.\n+        // We don't want to give real properties to this prototype, because\n+        // then it would propagate to all structural functions.\n+        setPrototype(\n+           registry.getNativeObjectType(JSTypeNative.UNKNOWN_TYPE),\n+           null);\n+      } else {\n+        setPrototype(\n+            new PrototypeObjectType(\n+                registry,\n+                this.getReferenceName() + \".prototype\",\n+                registry.getNativeObjectType(OBJECT_TYPE),\n+                isNativeObjectType()),\n+            null);\n+      }\n     }\n     return (ObjectType) prototypeSlot.getType();\n   }\n     // In the second case, we just use the anonymous object as the prototype.\n     if (baseType.hasReferenceName() ||\n         isNativeObjectType() ||\n-        baseType.isFunctionPrototypeType() ||\n-        !(baseType instanceof PrototypeObjectType)) {\n+        baseType.isFunctionPrototypeType()) {\n \n       baseType = new PrototypeObjectType(\n           registry, this.getReferenceName() + \".prototype\", baseType);\n     }\n-    setPrototype((PrototypeObjectType) baseType, propertyNode);\n+    setPrototype(baseType, propertyNode);\n   }\n \n   /**\n    * @param prototype the prototype. If this value is {@code null} it will\n    *        silently be discarded.\n    */\n-  boolean setPrototype(PrototypeObjectType prototype, Node propertyNode) {\n+  boolean setPrototype(ObjectType prototype, Node propertyNode) {\n     if (prototype == null) {\n       return false;\n     }\n       return false;\n     }\n \n-    PrototypeObjectType oldPrototype = prototypeSlot == null\n-        ? null : (PrototypeObjectType) prototypeSlot.getType();\n+    ObjectType oldPrototype = prototypeSlot == null\n+        ? null : (ObjectType) prototypeSlot.getType();\n     boolean replacedPrototype = oldPrototype != null;\n \n     this.prototypeSlot = new Property(\"prototype\", prototype, true,\n       }\n \n       if (prototypeSlot != null) {\n-        ((PrototypeObjectType) prototypeSlot.getType()).clearCachedValues();\n+        ((ObjectType) prototypeSlot.getType()).clearCachedValues();\n       }\n     }\n   }\n--- a/src/com/google/javascript/rhino/jstype/ObjectType.java\n+++ b/src/com/google/javascript/rhino/jstype/ObjectType.java\n     return null;\n   }\n \n+  /** Sets the owner function. By default, does nothing. */\n+  void setOwnerFunction(FunctionType type) {}\n+\n   /**\n    * Gets the interfaces implemented by the ctor associated with this type.\n    * Intended to be overridden by subclasses.\n--- a/test/com/google/javascript/jscomp/TypeCheckTest.java\n+++ b/test/com/google/javascript/jscomp/TypeCheckTest.java\n         \"/** @return {string} */\" +\n         \"F.prototype.bar = function() { return this.x_; };\",\n         \"assignment to property x_ of F\\n\" +\n+        \"found   : number\\n\" +\n+        \"required: string\");\n+  }\n+\n+  public void testPropertyInference9() throws Exception {\n+    testTypes(\n+        \"/** @constructor */ function A() {}\" +\n+        \"/** @return {function(): ?} */ function f() { \" +\n+        \"  return function() {};\" +\n+        \"}\" +\n+        \"var g = f();\" +\n+        \"/** @type {number} */ g.prototype.bar_ = null;\",\n+        \"assignment\\n\" +\n+        \"found   : null\\n\" +\n+        \"required: number\");\n+  }\n+\n+  public void testPropertyInference10() throws Exception {\n+    // NOTE(nicksantos): There used to be a bug where a property\n+    // on the prototype of one structural function would leak onto\n+    // the prototype of other variables with the same structural\n+    // function type.\n+    testTypes(\n+        \"/** @constructor */ function A() {}\" +\n+        \"/** @return {function(): ?} */ function f() { \" +\n+        \"  return function() {};\" +\n+        \"}\" +\n+        \"var g = f();\" +\n+        \"/** @type {number} */ g.prototype.bar_ = 1;\" +\n+        \"var h = f();\" +\n+        \"/** @type {string} */ h.prototype.bar_ = 1;\",\n+        \"assignment\\n\" +\n         \"found   : number\\n\" +\n         \"required: string\");\n   }\n         \"  x.onload = function() {\" +\n         \"    x.onload = null;\" +\n         \"  };\" +\n+        \"}\");\n+  }\n+\n+  public void testQualifiedNameInference12() throws Exception {\n+    // We should be able to tell that the two 'this' properties\n+    // are different.\n+    testTypes(\n+        \"/** @param {function(this:Object)} x */ function f(x) {}\" +\n+        \"/** @constructor */ function Foo() {\" +\n+        \"  /** @type {number} */ this.bar = 3;\" +\n+        \"  f(function() { this.bar = true; });\" +\n         \"}\");\n   }\n \n--- a/test/com/google/javascript/rhino/jstype/JSTypeTest.java\n+++ b/test/com/google/javascript/rhino/jstype/JSTypeTest.java\n    */\n   public void testFunctionPrototypeAndImplicitPrototype1() {\n     FunctionType constructor =\n-        registry.createConstructorType(null, null, null, null);\n+        registry.createConstructorType(\"Foo\", null, null, null);\n     ObjectType instance = constructor.getInstanceType();\n \n     // adding one property on the prototype", "timestamp": 1333075324, "metainfo": ""}