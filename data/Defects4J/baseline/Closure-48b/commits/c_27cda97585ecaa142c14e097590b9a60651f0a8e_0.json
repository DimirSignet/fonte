{"sha": "27cda97585ecaa142c14e097590b9a60651f0a8e", "log": "Wrote code to reverse the sourcemap; lookups from source to target mappings are now O(1) instead of O(n).  I tested w/: git5 export --sq --tap-project=jscompiler  R=johnlenz   Revision created by MOE tool push_codebase. MOE_MIGRATION=2966   ", "commit": "\n--- a/src/com/google/debugging/sourcemap/SourceMapConsumerV3.java\n+++ b/src/com/google/debugging/sourcemap/SourceMapConsumerV3.java\n import java.util.Arrays;\n import java.util.Collection;\n import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n \n /**\n  * Class for parsing version 3 of the SourceMap format, as produced by the\n  * http://code.google.com/p/closure-compiler/wiki/SourceMaps\n  * @author johnlenz@google.com (John Lenz)\n  */\n-public class SourceMapConsumerV3 implements SourceMapConsumer, SourceMappingReversable {\n+public class SourceMapConsumerV3 implements SourceMapConsumer,\n+    SourceMappingReversable {\n   static final int UNMAPPED = -1;\n \n   private String[] sources;\n   private int lineCount;\n   // Slots in the lines list will be null if the line does not have any entries.\n   private ArrayList<ArrayList<Entry>> lines = null;\n+  /** originalFile path ==> original line ==> target mappings */\n+  private Map<String, Map<Integer, Collection<OriginalMapping>>>\n+      reverseSourceMapping;\n \n   public SourceMapConsumerV3() {\n \n   }\n \n   @Override\n-  /**\n-   * TODO(user): this implementation is a prototype. It does an O(n) search of the lines list,\n-   * instead of reversing the source map and doing O(1) lookups. It also does not currently make use\n-   * of the column parameter.\n-   */\n-  public Collection<OriginalMapping> getReverseMapping(String originalFile, int line, int column) {\n-    int sourceFileId = Arrays.binarySearch(sources, originalFile);\n-\n-    if (sourceFileId < 0) {\n+  public Collection<OriginalMapping> getReverseMapping(String originalFile,\n+      int line, int column) {\n+    // TODO(user): This implementation currently does not make use of the column\n+    // parameter.\n+\n+    // Synchronization needs to be handled by callers.\n+    if (reverseSourceMapping == null) {\n+      createReverseMapping();\n+    }\n+\n+    Map<Integer, Collection<OriginalMapping>> sourceLineToCollectionMap =\n+        reverseSourceMapping.get(originalFile);\n+\n+    if (sourceLineToCollectionMap == null) {\n       return Collections.emptyList();\n-    }\n-\n-    for (ArrayList<Entry> entries : lines) {\n-      if (entries != null) {\n-        for (Entry entry : entries) {\n-          if (entry.getSourceFileId() == sourceFileId) {\n-            if (entry.getSourceLine() == line) {\n-              Builder builder = OriginalMapping.newBuilder()\n-                .setOriginalFile(sources[entry.getSourceFileId()])\n-                .setLineNumber(entry.getSourceLine())\n-                .setColumnPosition(entry.getSourceColumn());\n-\n-              OriginalMapping mapping = builder.build();\n-\n-              return Collections.singletonList(mapping);\n-            }\n-          }\n-        }\n-      }\n-    }\n-\n-    return Collections.emptyList();\n+    } else {\n+      Collection<OriginalMapping> mappings =\n+          sourceLineToCollectionMap.get(line);\n+\n+      if (mappings == null) {\n+        return Collections.emptyList();\n+      } else {\n+        return mappings;\n+      }\n+    }\n   }\n \n   private String[] getJavaStringArray(JSONArray array) throws JSONException {\n   }\n \n   /**\n+   * Reverse the source map; the created mapping will allow us to quickly go\n+   * from a source file and line number to a collection of target\n+   * OriginalMappings.\n+   */\n+  private void createReverseMapping() {\n+    reverseSourceMapping =\n+        new HashMap<String, Map<Integer, Collection<OriginalMapping>>>();\n+\n+    for (int targetLine = 0; targetLine < lines.size(); targetLine++) {\n+      ArrayList<Entry> entries = lines.get(targetLine);\n+\n+      if (entries != null) {\n+        for (Entry entry : entries) {\n+          if (entry.getSourceFileId() != UNMAPPED\n+              && entry.getSourceLine() != UNMAPPED) {\n+            String originalFile = sources[entry.getSourceFileId()];\n+\n+            if (!reverseSourceMapping.containsKey(originalFile)) {\n+              reverseSourceMapping.put(originalFile,\n+                  new HashMap<Integer, Collection<OriginalMapping>>());\n+            }\n+\n+            Map<Integer, Collection<OriginalMapping>> lineToCollectionMap =\n+                reverseSourceMapping.get(originalFile);\n+\n+            int sourceLine = entry.getSourceLine();\n+\n+            if (!lineToCollectionMap.containsKey(sourceLine)) {\n+              lineToCollectionMap.put(sourceLine,\n+                  new ArrayList<OriginalMapping>(1));\n+            }\n+\n+            Collection<OriginalMapping> mappings =\n+                lineToCollectionMap.get(sourceLine);\n+\n+            Builder builder = OriginalMapping.newBuilder().setLineNumber(\n+                targetLine).setColumnPosition(entry.getGeneratedColumn());\n+\n+            mappings.add(builder.build());\n+          }\n+        }\n+      }\n+    }\n+  }\n+\n+  /**\n    * A implementation of the Base64VLQ CharIterator used for decoding the\n    * mappings encoded in the JSON string.\n    */", "timestamp": 1312913864, "metainfo": ""}