{"sha": "7c44f228de588387734227a0c08be36d11bf2b17", "log": "Fix a couple of classes to handle !0 and !1 as TRUE and FALSE.  R=acleung DELTA=118  (82 added, 32 deleted, 4 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=751   ", "commit": "\n--- a/src/com/google/javascript/jscomp/CollapseVariableDeclarations.java\n+++ b/src/com/google/javascript/jscomp/CollapseVariableDeclarations.java\n           return !isLValue || value.getFirstChild().getType() == Token.THIS;\n \n         case Token.NAME:\n-        case Token.NUMBER:\n-        case Token.TRUE:\n-        case Token.FALSE:\n-        case Token.NULL:\n-        case Token.STRING:\n           return true;\n-      }\n-\n-      return false;\n+\n+        default:\n+          return NodeUtil.isImmutableValue(value);\n+      }\n     }\n \n     /**\n             }\n             return false;\n \n-          case Token.NUMBER:\n-          case Token.TRUE:\n-          case Token.FALSE:\n-          case Token.NULL:\n-          case Token.STRING:\n-            if (value.getType() == next.getType()) {\n-              if ((next.getType() == Token.STRING ||\n-                      next.getType() == Token.NUMBER) &&\n-                  !next.isEquivalentTo(value)) {\n-                return false;\n-              }\n-\n-              // If the r-value of the expr assign is an immutable value,\n-              // and the value is used again shortly, then we can exploit\n-              // the assign here.\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n-            return false;\n-\n           case Token.ASSIGN:\n             // Assigns are really tricky. In lots of cases, we want to inline\n             // into the right side of the assign. But the left side of the\n             }\n \n           default:\n+            if (NodeUtil.isImmutableValue(next)\n+                && next.checkTreeEqualsSilent(value)) {\n+              // If the r-value of the expr assign is an immutable value,\n+              // and the value is used again shortly, then we can exploit\n+              // the assign here.\n+              exprParent.removeChild(expr);\n+              expr.removeChild(assign);\n+              parent.replaceChild(next, assign);\n+              return true;\n+            }\n             // Return without inlining a thing\n             return false;\n         }\n--- a/src/com/google/javascript/jscomp/FunctionArgumentInjector.java\n+++ b/src/com/google/javascript/jscomp/FunctionArgumentInjector.java\n             String name = cArg.getString();\n             safe = !(convention.isExported(name));\n             break;\n-          case Token.NULL:\n-          case Token.VOID:\n           case Token.THIS:\n-          case Token.FALSE:\n-          case Token.TRUE:\n-          case Token.NUMBER:\n             safe = true;\n             break;\n           case Token.STRING:\n             safe = (cArg.getString().length() < 2);\n             break;\n           default:\n-            safe = false;\n+            safe = NodeUtil.isImmutableValue(cArg);\n             break;\n         }\n       }\n--- a/test/com/google/javascript/jscomp/CollapseVariableDeclarationsTest.java\n+++ b/test/com/google/javascript/jscomp/CollapseVariableDeclarationsTest.java\n     testSame(\"if (x) var a = 1; else var a = 2;\");\n   }\n \n+  public void testExprExploitationTypes() {\n+    test(\"a = true; b = true\",\n+         \"b = a = true\");\n+    test(\"a = !0; b = !0\",\n+         \"b = a = !0\");\n+    test(\"a = !1; b = !1\",\n+         \"b = a = !1\");\n+    test(\"a = void 0; b = void 0\",\n+         \"b = a = void 0\");\n+    test(\"a = -Infinity; b = -Infinity\",\n+         \"b = a = -Infinity\");\n+  }\n+\n+  public void testExprExploitationTypes2() {\n+    test(\"a = !0; b = !0\",\n+         \"b = a = !0\");\n+  }\n+\n   public void testExprExploitation() {\n     test(\"a = null; b = null; var c = b\",\n          \"var c = b = a = null\");\n          \"this.foo = a = null\");\n     test(\"function f(){ a = null; return null; }\",\n          \"function f(){return a = null}\");\n+\n     test(\"a = true; if (a) { foo(); }\",\n          \"if (a = true) { foo() }\");\n     test(\"a = true; if (a && a) { foo(); }\",\n          \"if ((a = true) && a) { foo() }\");\n     test(\"a = false; if (a) { foo(); }\",\n          \"if (a = false) { foo() }\");\n+\n+    test(\"a = !0; if (a) { foo(); }\",\n+        \"if (a = !0) { foo() }\");\n+    test(\"a = !0; if (a && a) { foo(); }\",\n+        \"if ((a = !0) && a) { foo() }\");\n+    test(\"a = !1; if (a) { foo(); }\",\n+        \"if (a = !1) { foo() }\");\n+\n     testSame(\"a = this.foo; a();\");\n     test(\"a = b; b = a;\",\n          \"b = a = b\");\n     testSame(\"this.foo = function() {}; this.foo();\");\n   }\n \n+  public void testBadCollapse() {\n+    testSame(\"this.$e$ = []; this.$b$ = null;\");\n+  }\n+\n   @Override\n   protected CompilerPass getProcessor(Compiler compiler) {\n     return new CollapseVariableDeclarations(compiler);\n--- a/test/com/google/javascript/jscomp/FunctionArgumentInjectorTest.java\n+++ b/test/com/google/javascript/jscomp/FunctionArgumentInjectorTest.java\n         Sets.newHashSet(\"b\"));\n   }\n \n+  public void testMaybeAddTempsForCallArguments28() {\n+    // true/false are don't need temps\n+    testNeededTemps(\n+        \"function foo(a){a;a;}; foo(true);\",\n+        \"foo\",\n+        EMPTY_STRING_SET);\n+  }\n+\n+  public void testMaybeAddTempsForCallArguments29() {\n+    // true/false are don't need temps\n+    testNeededTemps(\n+        \"function foo(a){a;a;}; foo(false);\",\n+        \"foo\",\n+        EMPTY_STRING_SET);\n+  }\n+\n+  public void testMaybeAddTempsForCallArguments30() {\n+    // true/false are don't need temps\n+    testNeededTemps(\n+        \"function foo(a){a;a;}; foo(!0);\",\n+        \"foo\",\n+        EMPTY_STRING_SET);\n+  }\n+\n+  public void testMaybeAddTempsForCallArguments31() {\n+    // true/false are don't need temps\n+    testNeededTemps(\n+        \"function foo(a){a;a;}; foo(!1);\",\n+        \"foo\",\n+        EMPTY_STRING_SET);\n+  }\n+\n+  public void testMaybeAddTempsForCallArguments32() {\n+    // void 0 doesn't need a temp\n+    testNeededTemps(\n+        \"function foo(a){a;a;}; foo(void 0);\",\n+        \"foo\",\n+        EMPTY_STRING_SET);\n+  }\n+\n   public void testMaybeAddTempsForCallArgumentsInLoops() {\n     // A mutable parameter referenced in loop needs a\n     // temporary.", "timestamp": 1299109288, "metainfo": ""}