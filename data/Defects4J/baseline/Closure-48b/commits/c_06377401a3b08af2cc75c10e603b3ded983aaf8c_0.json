{"sha": "06377401a3b08af2cc75c10e603b3ded983aaf8c", "log": "Fix for issue #75.  Re-introduce the debugging option for name coalescing, now that its issues have been fixed.    ", "commit": "\n--- a/src/com/google/javascript/jscomp/CoalesceVariableNames.java\n+++ b/src/com/google/javascript/jscomp/CoalesceVariableNames.java\n \n package com.google.javascript.jscomp;\n \n+import com.google.common.base.Join;\n import com.google.common.collect.Lists;\n+import com.google.common.collect.Sets;\n import com.google.javascript.jscomp.ControlFlowGraph.AbstractCfgNodeTraversalCallback;\n import com.google.javascript.jscomp.ControlFlowGraph.Branch;\n import com.google.javascript.jscomp.DataFlowAnalysis.FlowState;\n import com.google.javascript.jscomp.NodeTraversal.ScopedCallback;\n import com.google.javascript.jscomp.Scope.Var;\n import com.google.javascript.jscomp.graph.GraphColoring;\n+import com.google.javascript.jscomp.graph.GraphNode;\n import com.google.javascript.jscomp.graph.LinkedUndirectedGraph;\n-import com.google.javascript.jscomp.graph.GraphNode;\n+import com.google.javascript.jscomp.graph.UndiGraph;\n import com.google.javascript.jscomp.graph.DiGraph.DiGraphNode;\n import com.google.javascript.jscomp.graph.GraphColoring.GreedyGraphColoring;\n-import com.google.javascript.jscomp.graph.UndiGraph;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n \n     CompilerPass, ScopedCallback {\n \n   private final AbstractCompiler compiler;\n-  private final Deque<GraphColoring<Var, ?>> colorings;\n-\n-  /** Logs all name assignments */\n-  private StringBuilder coalescedLog;\n+  private final Deque<GraphColoring<Var, Void>> colorings;\n+  private final boolean usePseudoNames;\n \n   private static final Comparator<Var> coloringTieBreaker =\n       new Comparator<Var>() {\n     }\n   };\n \n-  CoalesceVariableNames(AbstractCompiler compiler) {\n+  /**\n+   * @param usePseudoNames For debug purposes, when merging variable foo and bar\n+   * to foo, rename both variable to foo_bar.\n+   */\n+  CoalesceVariableNames(AbstractCompiler compiler, boolean usePseudoNames) {\n     this.compiler = compiler;\n     colorings = Lists.newLinkedList();\n-    coalescedLog = new StringBuilder();\n+    this.usePseudoNames = usePseudoNames;\n   }\n \n   @Override\n   public void process(Node externs, Node root) {\n     NodeTraversal.traverse(compiler, root, this);\n-\n-    // Lastly, write the report to the debug log.\n-    compiler.addToDebugLog(\"JS vars coalesced:\\n\" + coalescedLog.toString());\n-    coalescedLog = new StringBuilder();\n   }\n \n   @Override\n         computeVariableNamesInterferenceGraph(\n             t, cfg, liveness.getEscapedLocals());\n \n-    GraphColoring<Var, ?> coloring =\n+    GraphColoring<Var, Void> coloring =\n         new GreedyGraphColoring<Var, Void>(interferenceGraph,\n             coloringTieBreaker);\n \n       return;\n     }\n     Var coalescedVar = colorings.peek().getPartitionSuperNode(var);\n-    if (vNode.getValue().equals(coalescedVar)) {\n-      // The coalesced name is itself, nothing to do.\n-      return;\n-    }\n-\n-    if (var.getNameNode() == n) {\n-      coalescedLog.append(n.getString()).append(\" => \")\n-          .append(coalescedVar.name).append(\" in \")\n-          .append(t.getSourceName()).append(':')\n-          .append(n.getLineno()).append('\\n');\n-    }\n-\n-    // Rename.\n-    n.setString(coalescedVar.name);\n-    compiler.reportCodeChange();\n-\n-    if (NodeUtil.isVar(parent)) {\n-      removeVarDeclaration(n);\n+    \n+    if (!usePseudoNames) {\n+      if (vNode.getValue().equals(coalescedVar)) {\n+        // The coalesced name is itself, nothing to do.\n+        return;\n+      }\n+\n+      // Rename.\n+      n.setString(coalescedVar.name);\n+      compiler.reportCodeChange();\n+\n+      if (NodeUtil.isVar(parent)) {\n+        removeVarDeclaration(n);\n+      }\n+    } else {\n+      // This code block is slow but since usePseudoName is for debugging,\n+      // we should not sacrifice performance for non-debugging compilation to\n+      // make this fast.\n+      String pseudoName = null;\n+      Set<String> allMergedNames = Sets.newTreeSet();\n+      for (Iterator<Var> i = t.getScope().getVars(); i.hasNext();) {\n+        Var iVar = i.next();\n+        \n+        // Look for all the variables that can be merged (in the graph by now)\n+        // and it is merged with the current coalscedVar.\n+        if (colorings.peek().getGraph().getNode(iVar) != null &&\n+            coalescedVar.equals(colorings.peek().getPartitionSuperNode(iVar))) {\n+          allMergedNames.add(iVar.name);\n+        }\n+      }\n+      \n+      // Keep its original name.\n+      if (allMergedNames.size() == 1) {\n+        return;\n+      }\n+      \n+      pseudoName = Join.join(\"_\", allMergedNames);\n+      \n+      while (t.getScope().isDeclared(pseudoName, true)) {\n+        pseudoName += \"$\";\n+      }\n+      \n+      n.setString(pseudoName);\n+      compiler.reportCodeChange();\n+\n+      if (!vNode.getValue().equals(coalescedVar) && NodeUtil.isVar(parent)) {\n+        removeVarDeclaration(n);\n+      }\n     }\n   }\n \n--- a/src/com/google/javascript/jscomp/DefaultPassConfig.java\n+++ b/src/com/google/javascript/jscomp/DefaultPassConfig.java\n       new PassFactory(\"coalesceVariableNames\", true) {\n     @Override\n     protected CompilerPass createInternal(AbstractCompiler compiler) {\n-      return new CoalesceVariableNames(compiler);\n+      return new CoalesceVariableNames(compiler, options.generatePseudoNames);\n     }\n   };\n \n--- a/src/com/google/javascript/jscomp/FoldConstants.java\n+++ b/src/com/google/javascript/jscomp/FoldConstants.java\n     if (left.getType() == Token.ARRAYLIT) {\n \n       if (right.getType() != Token.NUMBER) {\n-        error(t, INVALID_GETELEM_INDEX_ERROR, right);\n+        // Sometimes people like to use complex expressions to index into\n+        // arrays, or strings to index into array methods.\n         return;\n       }\n \n--- a/test/com/google/javascript/jscomp/CoalesceVariableNamesTest.java\n+++ b/test/com/google/javascript/jscomp/CoalesceVariableNamesTest.java\n   // The spacing in this file is not exactly standard but it greatly helps\n   // picking out which variable names are merged.\n \n+  private boolean usePseudoName = false;\n+  \n+  @Override\n+  protected int getNumRepetitions() {\n+   return 1;\n+  }  \n+  \n+  @Override\n+  public void setUp() {\n+    usePseudoName = false;\n+  }\n+  \n   @Override\n   public CompilerPass getProcessor(final Compiler compiler) {\n     return new CompilerPass() {\n       public void process(Node externs, Node js) {\n         NodeTraversal.traverse(compiler, js,\n-            new CoalesceVariableNames(compiler));\n+            new CoalesceVariableNames(compiler, usePseudoName));\n       }\n     };\n   }\n         \"   this.load();\");\n   }\n \n+  public void testUsePseduoNames() {\n+    usePseudoName = true;\n+    inFunction(\"var x   = 0; print(x  ); var   y = 1; print(  y)\",\n+               \"var x_y = 0; print(x_y);     x_y = 1; print(x_y)\");\n+    \n+    inFunction(\"var x_y = 1; var x   = 0; print(x  ); var     y = 1;\" + \n+               \"print(  y); print(x_y);\",\n+\n+               \"var x_y = 1; var x_y$ = 0; print(x_y$);     x_y$ = 1;\" + \"\" +\n+               \"print(x_y$); print(x_y);\");\n+    \n+    inFunction(\"var x_y = 1; function f() {\" +\n+               \"var x    = 0; print(x  ); var y = 1; print( y);\" +\n+               \"print(x_y);}\",\n+\n+               \"var x_y = 1; function f() {\" +\n+               \"var x_y$ = 0; print(x_y$); x_y$ = 1; print(x_y$);\" +\n+               \"print(x_y);}\");\n+    \n+    inFunction(\"var x   = 0; print(x  ); var   y = 1; print(  y); \" +\n+               \"var closure_var; function bar() { print(closure_var); }\",\n+               \"var x_y = 0; print(x_y);     x_y = 1; print(x_y); \" +\n+               \"var closure_var; function bar() { print(closure_var); }\");\n+  }\n+  \n   private void inFunction(String src) {\n     inFunction(src, src);\n   }\n--- a/test/com/google/javascript/jscomp/FoldConstantsTest.java\n+++ b/test/com/google/javascript/jscomp/FoldConstantsTest.java\n   public void testFoldGetElem() {\n     fold(\"x = [10, 20][0]\", \"x = 10\");\n     fold(\"x = [10, 20][1]\", \"x = 20\");\n-    fold(\"x = [10, 20]['abc']\", \"\", FoldConstants.INVALID_GETELEM_INDEX_ERROR);\n+    fold(\"x = [10, 20][0.5]\", \"\", FoldConstants.INVALID_GETELEM_INDEX_ERROR);\n     fold(\"x = [10, 20][-1]\",    \"\", FoldConstants.INDEX_OUT_OF_BOUNDS_ERROR);\n     fold(\"x = [10, 20][2]\",     \"\", FoldConstants.INDEX_OUT_OF_BOUNDS_ERROR);\n   }", "timestamp": 1261017423, "metainfo": ""}