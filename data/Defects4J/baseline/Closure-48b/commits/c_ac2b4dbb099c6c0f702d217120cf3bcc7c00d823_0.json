{"sha": "ac2b4dbb099c6c0f702d217120cf3bcc7c00d823", "log": "Remove legacy rhino parser.  R=nicksantos DELTA=5664  (15 added, 5628 deleted, 21 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=3646   ", "commit": "\n--- a/src/com/google/javascript/rhino/TokenStream.java\n+++ b/src/com/google/javascript/rhino/TokenStream.java\n \n package com.google.javascript.rhino;\n \n-import java.io.IOException;\n-import java.io.Reader;\n-\n /**\n  * This class implements the JavaScript scanner.\n  *\n      * to check.  (And checking EOF by exception is annoying.)\n      * Note distinction from EOF token type!\n      */\n-    private final static int\n-        EOF_CHAR = -1;\n-\n-    public TokenStream(Parser parser, Reader sourceReader, String sourceString,\n-                int lineno)\n-    {\n-        this.parser = parser;\n-        this.lineno = lineno;\n-        if (sourceReader != null) {\n-            if (sourceString != null) Kit.codeBug();\n-            this.sourceReader = sourceReader;\n-            this.sourceBuffer = new char[512];\n-            this.sourceEnd = 0;\n-        } else {\n-            if (sourceString == null) Kit.codeBug();\n-            this.sourceString = sourceString;\n-            this.sourceEnd = sourceString.length();\n-        }\n-        this.sourceCursor = 0;\n-    }\n-\n-    /* This function uses the cached op, string and number fields in\n-     * TokenStream; if getToken has been called since the passed token\n-     * was scanned, the op or string printed may be incorrect.\n-     */\n-    String tokenToString(int token)\n-    {\n-        if (Token.shouldPrintTrees()) {\n-            String name = Token.name(token);\n-\n-            switch (token) {\n-                case Token.STRING:\n-                case Token.REGEXP:\n-                case Token.NAME:\n-                    return name + \" `\" + this.string + \"'\";\n-\n-                case Token.NUMBER:\n-                    return \"NUMBER \" + this.number;\n-            }\n-\n-            return name;\n-        }\n-        return \"\";\n-    }\n-\n-    public static boolean isKeyword(String s)\n-    {\n+    private final static int EOF_CHAR = -1;\n+\n+    public static boolean isKeyword(String s) {\n         return Token.EOF != stringToKeyword(s);\n     }\n \n-    private static int stringToKeyword(String name)\n-    {\n+    private static int stringToKeyword(String name) {\n // #string_id_map#\n // The following assumes that Token.EOF == 0\n         final int\n         return true;\n     }\n \n-    protected final int getLineno() { return lineno; }\n-\n-    protected final int getCharno() { return charno; }\n-\n-    final String getString() { return string; }\n-\n-    final double getNumber() { return number; }\n-\n-    final boolean eof() { return hitEOF; }\n-\n-    public final int getToken() throws IOException\n-    {\n-        tokenno++;\n-\n-        // Check for pushed-back token\n-        if (this.pushbackToken != Token.EOF) {\n-            int result = this.pushbackToken;\n-            this.pushbackToken = Token.EOF;\n-            return result;\n-        }\n-        int c;\n-\n-    retry:\n-        for (;;) {\n-            // Eat whitespace, possibly sensitive to newlines.\n-            for (;;) {\n-                charno = -1;\n-                c = getChar();\n-                if (c == EOF_CHAR) {\n-                    return Token.EOF;\n-                } else if (c == '\\n') {\n-                    dirtyLine = false;\n-                    return Token.EOL;\n-                } else if (!isJSSpace(c)) {\n-                    if (c != '-') {\n-                        dirtyLine = true;\n-                    }\n-                    break;\n-                }\n-            }\n-\n-            if (c == '@') return Token.XMLATTR;\n-\n-            // identifier/keyword/instanceof?\n-            // watch out for starting with a <backslash>\n-            boolean identifierStart;\n-            boolean isUnicodeEscapeStart = false;\n-            if (c == '\\\\') {\n-                c = getChar();\n-                if (c == 'u') {\n-                    identifierStart = true;\n-                    isUnicodeEscapeStart = true;\n-                    stringBufferTop = 0;\n-                } else {\n-                    identifierStart = false;\n-                    ungetChar(c);\n-                    c = '\\\\';\n-                }\n-            } else {\n-                identifierStart = Character.isJavaIdentifierStart((char)c);\n-                if (identifierStart) {\n-                    stringBufferTop = 0;\n-                    addToString(c);\n-                }\n-            }\n-\n-            if (identifierStart) {\n-                boolean containsEscape = isUnicodeEscapeStart;\n-                for (;;) {\n-                    if (isUnicodeEscapeStart) {\n-                        // strictly speaking we should probably push-back\n-                        // all the bad characters if the <backslash>uXXXX\n-                        // sequence is malformed. But since there isn't a\n-                        // correct context(is there?) for a bad Unicode\n-                        // escape sequence in an identifier, we can report\n-                        // an error here.\n-                        int escapeVal = 0;\n-                        for (int i = 0; i != 4; ++i) {\n-                            c = getChar();\n-                            escapeVal = Kit.xDigitToInt(c, escapeVal);\n-                            // Next check takes care about c < 0 and bad escape\n-                            if (escapeVal < 0) { break; }\n-                        }\n-                        if (escapeVal < 0) {\n-                            parser.addError(\"msg.invalid.escape\");\n-                            return Token.ERROR;\n-                        }\n-                        addToString(escapeVal);\n-                        isUnicodeEscapeStart = false;\n-                    } else {\n-                        c = getChar();\n-                        if (c == '\\\\') {\n-                            c = getChar();\n-                            if (c == 'u') {\n-                                isUnicodeEscapeStart = true;\n-                                containsEscape = true;\n-                            } else {\n-                                parser.addError(\"msg.illegal.character\");\n-                                return Token.ERROR;\n-                            }\n-                        } else {\n-                            if (c == EOF_CHAR\n-                                || !Character.isJavaIdentifierPart((char)c))\n-                            {\n-                                break;\n-                            }\n-                            addToString(c);\n-                        }\n-                    }\n-                }\n-                ungetChar(c);\n-\n-                   String str = getStringFromBuffer();\n-                if (!containsEscape) {\n-                    // OPT we shouldn't have to make a string (object!) to\n-                    // check if it's a keyword.\n-\n-                    // Return the corresponding token if it's a keyword\n-                    int result = stringToKeyword(str);\n-                    if (result != Token.EOF) {\n-                        if (result != Token.RESERVED) {\n-                            return result;\n-                        } else if (!parser.compilerEnv.\n-                                        isReservedKeywordAsIdentifier())\n-                        {\n-                            return result;\n-                        } else {\n-                            // If implementation permits to use future reserved\n-                            // keywords in violation with the EcmaScript\n-                            // standard, treat it as name but issue warning\n-                            parser.addWarning(\"msg.reserved.keyword\", str);\n-                        }\n-                    }\n-                }\n-                this.string = (String)allStrings.intern(str);\n-                return Token.NAME;\n-            }\n-\n-            // is it a number?\n-            if (isDigit(c) || (c == '.' && isDigit(peekChar()))) {\n-\n-                stringBufferTop = 0;\n-                int base = 10;\n-\n-                if (c == '0') {\n-                    c = getChar();\n-                    if (c == 'x' || c == 'X') {\n-                        base = 16;\n-                        c = getChar();\n-                    } else if (isDigit(c)) {\n-                        base = 8;\n-                    } else {\n-                        addToString('0');\n-                    }\n-                }\n-\n-                if (base == 16) {\n-                    while (0 <= Kit.xDigitToInt(c, 0)) {\n-                        addToString(c);\n-                        c = getChar();\n-                    }\n-                } else {\n-                    while ('0' <= c && c <= '9') {\n-                        /*\n-                         * We permit 08 and 09 as decimal numbers, which\n-                         * makes our behavior a superset of the ECMA\n-                         * numeric grammar.  We might not always be so\n-                         * permissive, so we warn about it.\n-                         */\n-                        if (base == 8 && c >= '8') {\n-                            parser.addWarning(\"msg.bad.octal.literal\",\n-                                              c == '8' ? \"8\" : \"9\");\n-                            base = 10;\n-                        }\n-                        addToString(c);\n-                        c = getChar();\n-                    }\n-                }\n-\n-                boolean isInteger = true;\n-\n-                if (base == 10 && (c == '.' || c == 'e' || c == 'E')) {\n-                    isInteger = false;\n-                    if (c == '.') {\n-                        do {\n-                            addToString(c);\n-                            c = getChar();\n-                        } while (isDigit(c));\n-                    }\n-                    if (c == 'e' || c == 'E') {\n-                        addToString(c);\n-                        c = getChar();\n-                        if (c == '+' || c == '-') {\n-                            addToString(c);\n-                            c = getChar();\n-                        }\n-                        if (!isDigit(c)) {\n-                            parser.addError(\"msg.missing.exponent\");\n-                            return Token.ERROR;\n-                        }\n-                        do {\n-                            addToString(c);\n-                            c = getChar();\n-                        } while (isDigit(c));\n-                    }\n-                }\n-                ungetChar(c);\n-                String numString = getStringFromBuffer();\n-\n-                double dval;\n-                if (base == 10 && !isInteger) {\n-                    try {\n-                        // Use Java conversion to number from string...\n-                        dval = Double.valueOf(numString).doubleValue();\n-                    }\n-                    catch (NumberFormatException ex) {\n-                        parser.addError(\"msg.caught.nfe\");\n-                        return Token.ERROR;\n-                    }\n-                } else {\n-                    dval = ScriptRuntime.stringToNumber(numString, 0, base);\n-                }\n-\n-                this.number = dval;\n-                return Token.NUMBER;\n-            }\n-\n-            // is it a string?\n-            if (c == '\"' || c == '\\'') {\n-                // We attempt to accumulate a string the fast way, by\n-                // building it directly out of the reader.  But if there\n-                // are any escaped characters in the string, we revert to\n-                // building it out of a StringBuffer.\n-\n-                int quoteChar = c;\n-                stringBufferTop = 0;\n-\n-                c = getChar();\n-            strLoop: while (c != quoteChar) {\n-                    if (c == '\\n' || c == EOF_CHAR) {\n-                        ungetChar(c);\n-                        parser.addError(\"msg.unterminated.string.lit\");\n-                        return Token.ERROR;\n-                    }\n-\n-                    if (c == '\\\\') {\n-                        // We've hit an escaped character\n-                        int escapeVal;\n-\n-                        c = getChar();\n-                        switch (c) {\n-                        case 'b': c = '\\b'; break;\n-                        case 'f': c = '\\f'; break;\n-                        case 'n': c = '\\n'; break;\n-                        case 'r': c = '\\r'; break;\n-                        case 't': c = '\\t'; break;\n-\n-                        // \\v a late addition to the ECMA spec,\n-                        // it is not in Java, so use 0xb\n-                        case 'v': c = 0xb; break;\n-\n-                        case 'u':\n-                            // Get 4 hex digits; if the u escape is not\n-                            // followed by 4 hex digits, use 'u' + the\n-                            // literal character sequence that follows.\n-                            int escapeStart = stringBufferTop;\n-                            addToString('u');\n-                            escapeVal = 0;\n-                            for (int i = 0; i != 4; ++i) {\n-                                c = getChar();\n-                                escapeVal = Kit.xDigitToInt(c, escapeVal);\n-                                if (escapeVal < 0) {\n-                                    continue strLoop;\n-                                }\n-                                addToString(c);\n-                            }\n-                            // prepare for replace of stored 'u' sequence\n-                            // by escape value\n-                            stringBufferTop = escapeStart;\n-                            c = escapeVal;\n-                            break;\n-                        case 'x':\n-                            // Get 2 hex digits, defaulting to 'x'+literal\n-                            // sequence, as above.\n-                            c = getChar();\n-                            escapeVal = Kit.xDigitToInt(c, 0);\n-                            if (escapeVal < 0) {\n-                                addToString('x');\n-                                continue strLoop;\n-                            } else {\n-                                int c1 = c;\n-                                c = getChar();\n-                                escapeVal = Kit.xDigitToInt(c, escapeVal);\n-                                if (escapeVal < 0) {\n-                                    addToString('x');\n-                                    addToString(c1);\n-                                    continue strLoop;\n-                                } else {\n-                                    // got 2 hex digits\n-                                    c = escapeVal;\n-                                }\n-                            }\n-                            break;\n-\n-                        case '\\n':\n-                            // Remove line terminator after escape to follow\n-                            // SpiderMonkey and C/C++\n-                            c = getChar();\n-                            continue strLoop;\n-\n-                        default:\n-                            if ('0' <= c && c < '8') {\n-                                int val = c - '0';\n-                                c = getChar();\n-                                if ('0' <= c && c < '8') {\n-                                    val = 8 * val + c - '0';\n-                                    c = getChar();\n-                                    if ('0' <= c && c < '8' && val <= 037) {\n-                                        // c is 3rd char of octal sequence only\n-                                        // if the resulting val <= 0377\n-                                        val = 8 * val + c - '0';\n-                                        c = getChar();\n-                                    }\n-                                }\n-                                ungetChar(c);\n-                                c = val;\n-                            }\n-                        }\n-                    }\n-                    addToString(c);\n-                    c = getChar();\n-                }\n-\n-                String str = getStringFromBuffer();\n-                this.string = (String)allStrings.intern(str);\n-                return Token.STRING;\n-            }\n-\n-            switch (c) {\n-            case ';': return Token.SEMI;\n-            case '[': return Token.LB;\n-            case ']': return Token.RB;\n-            case '{': return Token.LC;\n-            case '}': return Token.RC;\n-            case '(': return Token.LP;\n-            case ')': return Token.RP;\n-            case ',': return Token.COMMA;\n-            case '?': return Token.HOOK;\n-            case ':':\n-                if (matchChar(':')) {\n-                    return Token.COLONCOLON;\n-                } else {\n-                    return Token.COLON;\n-                }\n-            case '.':\n-                if (matchChar('.')) {\n-                    return Token.DOTDOT;\n-                } else if (matchChar('(')) {\n-                    return Token.DOTQUERY;\n-                } else {\n-                    return Token.DOT;\n-                }\n-\n-            case '|':\n-                if (matchChar('|')) {\n-                    return Token.OR;\n-                } else if (matchChar('=')) {\n-                    return Token.ASSIGN_BITOR;\n-                } else {\n-                    return Token.BITOR;\n-                }\n-\n-            case '^':\n-                if (matchChar('=')) {\n-                    return Token.ASSIGN_BITXOR;\n-                } else {\n-                    return Token.BITXOR;\n-                }\n-\n-            case '&':\n-                if (matchChar('&')) {\n-                    return Token.AND;\n-                } else if (matchChar('=')) {\n-                    return Token.ASSIGN_BITAND;\n-                } else {\n-                    return Token.BITAND;\n-                }\n-\n-            case '=':\n-                if (matchChar('=')) {\n-                    if (matchChar('='))\n-                        return Token.SHEQ;\n-                    else\n-                        return Token.EQ;\n-                } else {\n-                    return Token.ASSIGN;\n-                }\n-\n-            case '!':\n-                if (matchChar('=')) {\n-                    if (matchChar('='))\n-                        return Token.SHNE;\n-                    else\n-                        return Token.NE;\n-                } else {\n-                    return Token.NOT;\n-                }\n-\n-            case '<':\n-                /* NB:treat HTML begin-comment as comment-till-eol */\n-                if (matchChar('!')) {\n-                    if (matchChar('-')) {\n-                        if (matchChar('-')) {\n-                            skipLine();\n-                            continue retry;\n-                        }\n-                        ungetChar('-');\n-                    }\n-                    ungetChar('!');\n-                }\n-                if (matchChar('<')) {\n-                    if (matchChar('=')) {\n-                        return Token.ASSIGN_LSH;\n-                    } else {\n-                        return Token.LSH;\n-                    }\n-                } else {\n-                    if (matchChar('=')) {\n-                        return Token.LE;\n-                    } else {\n-                        return Token.LT;\n-                    }\n-                }\n-\n-            case '>':\n-                if (matchChar('>')) {\n-                    if (matchChar('>')) {\n-                        if (matchChar('=')) {\n-                            return Token.ASSIGN_URSH;\n-                        } else {\n-                            return Token.URSH;\n-                        }\n-                    } else {\n-                        if (matchChar('=')) {\n-                            return Token.ASSIGN_RSH;\n-                        } else {\n-                            return Token.RSH;\n-                        }\n-                    }\n-                } else {\n-                    if (matchChar('=')) {\n-                        return Token.GE;\n-                    } else {\n-                        return Token.GT;\n-                    }\n-                }\n-\n-            case '*':\n-                if (matchChar('=')) {\n-                    return Token.ASSIGN_MUL;\n-                } else {\n-                    return Token.MUL;\n-                }\n-\n-            case '/':\n-                // is it a // comment?\n-                if (matchChar('/')) {\n-                    skipLine();\n-                    continue retry;\n-                }\n-                if (matchChar('*')) {\n-                    while ((c = getChar()) != EOF_CHAR &&\n-                           !(c == '*' && matchChar('/'))) {\n-                      // empty loop body\n-                    }\n-                    if (c == EOF_CHAR) {\n-                        parser.addError(\"msg.unterminated.comment\");\n-                        return Token.ERROR;\n-                    }\n-                    continue retry;\n-                }\n-\n-                if (matchChar('=')) {\n-                    return Token.ASSIGN_DIV;\n-                } else {\n-                    return Token.DIV;\n-                }\n-\n-            case '%':\n-                if (matchChar('=')) {\n-                    return Token.ASSIGN_MOD;\n-                } else {\n-                    return Token.MOD;\n-                }\n-\n-            case '~':\n-                return Token.BITNOT;\n-\n-            case '+':\n-                if (matchChar('=')) {\n-                    return Token.ASSIGN_ADD;\n-                } else if (matchChar('+')) {\n-                    return Token.INC;\n-                } else {\n-                    return Token.ADD;\n-                }\n-\n-            case '-':\n-                if (matchChar('=')) {\n-                    c = Token.ASSIGN_SUB;\n-                } else if (matchChar('-')) {\n-                    if (!dirtyLine) {\n-                        // treat HTML end-comment after possible whitespace\n-                        // after line start as comment-utill-eol\n-                        if (matchChar('>')) {\n-                            skipLine();\n-                            continue retry;\n-                        }\n-                    }\n-                    c = Token.DEC;\n-                } else {\n-                    c = Token.SUB;\n-                }\n-                dirtyLine = true;\n-                return c;\n-\n-            default:\n-                parser.addError(\"msg.illegal.character\");\n-                return Token.ERROR;\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Tokenizes JSDoc comments.\n-     */\n-    @SuppressWarnings(\"fallthrough\")\n-    final int getJSDocToken() throws IOException {\n-      int c;\n-      stringBufferTop = 0;\n-      for (;;) {\n-        // eat white spaces\n-        for (;;) {\n-          charno = -1;\n-          c = getChar();\n-          if (c == EOF_CHAR) {\n-            return Token.EOF;\n-          } else if (c == '\\n') {\n-            return Token.EOL;\n-          } else if (!isJSSpace(c)) {\n-            break;\n-          }\n-        }\n-\n-        switch (c) {\n-          // annotation, e.g. @type or @constructor\n-          case '@':\n-            do {\n-              c = getChar();\n-              if (isAlpha(c)) {\n-                addToString(c);\n-              } else {\n-                ungetChar(c);\n-                this.string = getStringFromBuffer();\n-                stringBufferTop = 0;\n-                return Token.ANNOTATION;\n-              }\n-            } while (true);\n-\n-          case '*':\n-            if (matchChar('/')) {\n-              return Token.EOC;\n-            } else {\n-              return Token.STAR;\n-            }\n-\n-          case ',':\n-            return Token.COMMA;\n-\n-          case '>':\n-            return Token.GT;\n-\n-          case '(':\n-            return Token.LP;\n-\n-          case ')':\n-            return Token.RP;\n-\n-          case '{':\n-            return Token.LC;\n-\n-          case '}':\n-            return Token.RC;\n-\n-          case '[':\n-            return Token.LB;\n-\n-          case ']':\n-            return Token.RB;\n-\n-          case '?':\n-            return Token.QMARK;\n-\n-          case '!':\n-            return Token.BANG;\n-\n-          case ':':\n-            return Token.COLON;\n-\n-          case '=':\n-            return Token.EQUALS;\n-\n-          case '|':\n-            matchChar('|');\n-            return Token.PIPE;\n-\n-          case '.':\n-            c = getChar();\n-            if (c == '<') {\n-              return Token.LT;\n-            } else {\n-              if (c == '.') {\n-                c = getChar();\n-                if (c == '.') {\n-                  return Token.ELLIPSIS;\n-                } else {\n-                  addToString('.');\n-                }\n-              }\n-              // we may backtrack across line boundary\n-              ungetBuffer[ungetCursor++] = c;\n-              c = '.';\n-            }\n-            // fall through\n-\n-          default: {\n-            // recognize a jsdoc string but discard last . if it is followed by\n-            // a non-jsdoc comment char, e.g. Array.<\n-            int c1 = c;\n-            addToString(c);\n-            int c2 = getChar();\n-            if (!isJSDocString(c2)) {\n-              ungetChar(c2);\n-              this.string = getStringFromBuffer();\n-              stringBufferTop = 0;\n-              return Token.STRING;\n-            } else {\n-              do {\n-                c1 = c2;\n-                c2 = getChar();\n-                if (c1 == '.' && c2 == '<') {\n-                  ungetChar(c2);\n-                  ungetChar(c1);\n-                  this.string = getStringFromBuffer();\n-                  stringBufferTop = 0;\n-                  return Token.STRING;\n-                } else {\n-                  if (isJSDocString(c2)) {\n-                    addToString(c1);\n-                  } else {\n-                    ungetChar(c2);\n-                    addToString(c1);\n-                    this.string = getStringFromBuffer();\n-                    stringBufferTop = 0;\n-                    return Token.STRING;\n-                  }\n-                }\n-              } while (true);\n-            }\n-          }\n-        }\n-      }\n-    }\n-\n-    /**\n-     * Gets the remaining JSDoc line without the {@link Token#EOL},\n-     * {@link Token#EOF} or {@link Token#EOC}.\n-     */\n-    @SuppressWarnings(\"fallthrough\")\n-    String getRemainingJSDocLine() throws IOException {\n-      int c;\n-      for (;;) {\n-        c = getChar();\n-        switch (c) {\n-          case '*':\n-            if (peekChar() != '/') {\n-              addToString(c);\n-              break;\n-            }\n-            // fall through\n-          case EOF_CHAR:\n-          case '\\n':\n-            ungetChar(c);\n-            this.string = getStringFromBuffer();\n-            stringBufferTop = 0;\n-            return this.string;\n-\n-          default:\n-            addToString(c);\n-            break;\n-        }\n-      }\n-    }\n-\n-    private boolean isJSDocString(int c) {\n-      switch (c) {\n-        case '@':\n-        case '*':\n-        case ',':\n-        case '>':\n-        case ':':\n-        case '(':\n-        case ')':\n-        case '{':\n-        case '}':\n-        case '[':\n-        case ']':\n-        case '?':\n-        case '!':\n-        case '|':\n-        case '=':\n-        case EOF_CHAR:\n-        case '\\n':\n-          return false;\n-\n-        default:\n-          return !isJSSpace(c);\n-      }\n-    }\n-\n-    private static boolean isAlpha(int c)\n-    {\n+    private static boolean isAlpha(int c) {\n         // Use 'Z' < 'a'\n         if (c <= 'Z') {\n             return 'A' <= c;\n         }\n     }\n \n-    static boolean isDigit(int c)\n-    {\n+    static boolean isDigit(int c) {\n         return '0' <= c && c <= '9';\n     }\n \n      * \\v, I think.)  note that code in getChar() implicitly accepts\n      * '\\r' == \\u000D as well.\n      */\n-    static boolean isJSSpace(int c)\n-    {\n+    static boolean isJSSpace(int c) {\n         if (c <= 127) {\n             return c == 0x20 || c == 0x9 || c == 0xC || c == 0xB;\n         } else {\n         }\n     }\n \n-    private static boolean isJSFormatChar(int c)\n-    {\n+    private static boolean isJSFormatChar(int c) {\n         return c > 127 && Character.getType((char)c) == Character.FORMAT;\n     }\n-\n-    /**\n-     * Gets the accumulated {@link JSDocInfo} and resets it.\n-     * Obsolete\n-     */\n-    JSDocInfo getAndResetJSDocInfo() {\n-      return null;\n-    }\n-\n-    /**\n-     * Returns any {@link JSDocInfo} with a fileoverview tag that showed up.\n-     * Obsolete\n-     */\n-    JSDocInfo getFileOverviewJSDocInfo() {\n-      return null;\n-    }\n-\n-    /**\n-     * Returns whether any {@link JSDocInfo} was accumulated.\n-     * Obsolete\n-     */\n-    boolean isPopulated() {\n-      return false;\n-    }\n-\n-    /**\n-     * Parser calls the method when it gets / or /= in literal context.\n-     */\n-    void readRegExp(int startToken)\n-        throws IOException\n-    {\n-        stringBufferTop = 0;\n-        if (startToken == Token.ASSIGN_DIV) {\n-            // Miss-scanned /=\n-            addToString('=');\n-        } else {\n-            if (startToken != Token.DIV) Kit.codeBug();\n-        }\n-\n-        boolean inCharSet = false;  // true if inside a '['..']' pair\n-        int c;\n-        while ((c = getChar()) != '/' || inCharSet) {\n-            if (c == '\\n' || c == EOF_CHAR) {\n-                ungetChar(c);\n-                throw parser.reportError(\"msg.unterminated.re.lit\");\n-            }\n-            if (c == '\\\\') {\n-                addToString(c);\n-                c = getChar();\n-            } else if (c == '[') {\n-                inCharSet = true;\n-            } else if (c == ']') {\n-                inCharSet = false;\n-            }\n-\n-            addToString(c);\n-        }\n-        int reEnd = stringBufferTop;\n-\n-        while (true) {\n-            if (matchChar('g'))\n-                addToString('g');\n-            else if (matchChar('i'))\n-                addToString('i');\n-            else if (matchChar('m'))\n-                addToString('m');\n-            else\n-                break;\n-        }\n-\n-        if (isAlpha(peekChar())) {\n-            throw parser.reportError(\"msg.invalid.re.flag\");\n-        }\n-\n-        this.string = new String(stringBuffer, 0, reEnd);\n-        this.regExpFlags = new String(stringBuffer, reEnd,\n-                                      stringBufferTop - reEnd);\n-    }\n-\n-    boolean isXMLAttribute()\n-    {\n-        return xmlIsAttribute;\n-    }\n-\n-    int getFirstXMLToken() throws IOException\n-    {\n-        xmlOpenTagsCount = 0;\n-        xmlIsAttribute = false;\n-        xmlIsTagContent = false;\n-        ungetChar('<');\n-        return getNextXMLToken();\n-    }\n-\n-    int getNextXMLToken() throws IOException\n-    {\n-        stringBufferTop = 0; // remember the XML\n-\n-        for (int c = getChar(); c != EOF_CHAR; c = getChar()) {\n-            if (xmlIsTagContent) {\n-                switch (c) {\n-                case '>':\n-                    addToString(c);\n-                    xmlIsTagContent = false;\n-                    xmlIsAttribute = false;\n-                    break;\n-                case '/':\n-                    addToString(c);\n-                    if (peekChar() == '>') {\n-                        c = getChar();\n-                        addToString(c);\n-                        xmlIsTagContent = false;\n-                        xmlOpenTagsCount--;\n-                    }\n-                    break;\n-                case '{':\n-                    ungetChar(c);\n-                    this.string = getStringFromBuffer();\n-                    return Token.XML;\n-                case '\\'':\n-                case '\"':\n-                    addToString(c);\n-                    if (!readQuotedString(c)) return Token.ERROR;\n-                    break;\n-                case '=':\n-                    addToString(c);\n-                    xmlIsAttribute = true;\n-                    break;\n-                case ' ':\n-                case '\\t':\n-                case '\\r':\n-                case '\\n':\n-                    addToString(c);\n-                    break;\n-                default:\n-                    addToString(c);\n-                    xmlIsAttribute = false;\n-                    break;\n-                }\n-\n-                if (!xmlIsTagContent && xmlOpenTagsCount == 0) {\n-                    this.string = getStringFromBuffer();\n-                    return Token.XMLEND;\n-                }\n-            } else {\n-                switch (c) {\n-                case '<':\n-                    addToString(c);\n-                    c = peekChar();\n-                    switch (c) {\n-                    case '!':\n-                        c = getChar(); // Skip !\n-                        addToString(c);\n-                        c = peekChar();\n-                        switch (c) {\n-                        case '-':\n-                            c = getChar(); // Skip -\n-                            addToString(c);\n-                            c = getChar();\n-                            if (c == '-') {\n-                                addToString(c);\n-                                if(!readXmlComment()) return Token.ERROR;\n-                            } else {\n-                                // throw away the string in progress\n-                                stringBufferTop = 0;\n-                                this.string = null;\n-                                parser.addError(\"msg.XML.bad.form\");\n-                                return Token.ERROR;\n-                            }\n-                            break;\n-                        case '[':\n-                            c = getChar(); // Skip [\n-                            addToString(c);\n-                            if (getChar() == 'C' &&\n-                                getChar() == 'D' &&\n-                                getChar() == 'A' &&\n-                                getChar() == 'T' &&\n-                                getChar() == 'A' &&\n-                                getChar() == '[')\n-                            {\n-                                addToString('C');\n-                                addToString('D');\n-                                addToString('A');\n-                                addToString('T');\n-                                addToString('A');\n-                                addToString('[');\n-                                if (!readCDATA()) return Token.ERROR;\n-\n-                            } else {\n-                                // throw away the string in progress\n-                                stringBufferTop = 0;\n-                                this.string = null;\n-                                parser.addError(\"msg.XML.bad.form\");\n-                                return Token.ERROR;\n-                            }\n-                            break;\n-                        default:\n-                            if(!readEntity()) return Token.ERROR;\n-                            break;\n-                        }\n-                        break;\n-                    case '?':\n-                        c = getChar(); // Skip ?\n-                        addToString(c);\n-                        if (!readPI()) return Token.ERROR;\n-                        break;\n-                    case '/':\n-                        // End tag\n-                        c = getChar(); // Skip /\n-                        addToString(c);\n-                        if (xmlOpenTagsCount == 0) {\n-                            // throw away the string in progress\n-                            stringBufferTop = 0;\n-                            this.string = null;\n-                            parser.addError(\"msg.XML.bad.form\");\n-                            return Token.ERROR;\n-                        }\n-                        xmlIsTagContent = true;\n-                        xmlOpenTagsCount--;\n-                        break;\n-                    default:\n-                        // Start tag\n-                        xmlIsTagContent = true;\n-                        xmlOpenTagsCount++;\n-                        break;\n-                    }\n-                    break;\n-                case '{':\n-                    ungetChar(c);\n-                    this.string = getStringFromBuffer();\n-                    return Token.XML;\n-                default:\n-                    addToString(c);\n-                    break;\n-                }\n-            }\n-        }\n-\n-        stringBufferTop = 0; // throw away the string in progress\n-        this.string = null;\n-        parser.addError(\"msg.XML.bad.form\");\n-        return Token.ERROR;\n-    }\n-\n-    /**\n-     *\n-     */\n-    private boolean readQuotedString(int quote) throws IOException\n-    {\n-        for (int c = getChar(); c != EOF_CHAR; c = getChar()) {\n-            addToString(c);\n-            if (c == quote) return true;\n-        }\n-\n-        stringBufferTop = 0; // throw away the string in progress\n-        this.string = null;\n-        parser.addError(\"msg.XML.bad.form\");\n-        return false;\n-    }\n-\n-    /**\n-     *\n-     */\n-    private boolean readXmlComment() throws IOException\n-    {\n-        for (int c = getChar(); c != EOF_CHAR;) {\n-            addToString(c);\n-            if (c == '-' && peekChar() == '-') {\n-                c = getChar();\n-                addToString(c);\n-                if (peekChar() == '>') {\n-                    c = getChar(); // Skip >\n-                    addToString(c);\n-                    return true;\n-                } else {\n-                    continue;\n-                }\n-            }\n-            c = getChar();\n-        }\n-\n-        stringBufferTop = 0; // throw away the string in progress\n-        this.string = null;\n-        parser.addError(\"msg.XML.bad.form\");\n-        return false;\n-    }\n-\n-    /**\n-     *\n-     */\n-    private boolean readCDATA() throws IOException\n-    {\n-        for (int c = getChar(); c != EOF_CHAR;) {\n-            addToString(c);\n-            if (c == ']' && peekChar() == ']') {\n-                c = getChar();\n-                addToString(c);\n-                if (peekChar() == '>') {\n-                    c = getChar(); // Skip >\n-                    addToString(c);\n-                    return true;\n-                } else {\n-                    continue;\n-                }\n-            }\n-            c = getChar();\n-        }\n-\n-        stringBufferTop = 0; // throw away the string in progress\n-        this.string = null;\n-        parser.addError(\"msg.XML.bad.form\");\n-        return false;\n-    }\n-\n-    /**\n-     *\n-     */\n-    private boolean readEntity() throws IOException\n-    {\n-        int declTags = 1;\n-        for (int c = getChar(); c != EOF_CHAR; c = getChar()) {\n-            addToString(c);\n-            switch (c) {\n-            case '<':\n-                declTags++;\n-                break;\n-            case '>':\n-                declTags--;\n-                if (declTags == 0) return true;\n-                break;\n-            }\n-        }\n-\n-        stringBufferTop = 0; // throw away the string in progress\n-        this.string = null;\n-        parser.addError(\"msg.XML.bad.form\");\n-        return false;\n-    }\n-\n-    /**\n-     *\n-     */\n-    private boolean readPI() throws IOException\n-    {\n-        for (int c = getChar(); c != EOF_CHAR; c = getChar()) {\n-            addToString(c);\n-            if (c == '?' && peekChar() == '>') {\n-                c = getChar(); // Skip >\n-                addToString(c);\n-                return true;\n-            }\n-        }\n-\n-        stringBufferTop = 0; // throw away the string in progress\n-        this.string = null;\n-        parser.addError(\"msg.XML.bad.form\");\n-        return false;\n-    }\n-\n-    private String getStringFromBuffer()\n-    {\n-        return new String(stringBuffer, 0, stringBufferTop);\n-    }\n-\n-    private void addToString(int c)\n-    {\n-        int N = stringBufferTop;\n-        if (N == stringBuffer.length) {\n-            char[] tmp = new char[stringBuffer.length * 2];\n-            System.arraycopy(stringBuffer, 0, tmp, 0, N);\n-            stringBuffer = tmp;\n-        }\n-        stringBuffer[N] = (char)c;\n-        stringBufferTop = N + 1;\n-    }\n-\n-    public int getTokenno() { return tokenno; }\n-\n-    protected void ungetChar(int c)\n-    {\n-        // cannot unread past across line boundary\n-        if (ungetCursor != 0 && ungetBuffer[ungetCursor - 1] == '\\n')\n-            Kit.codeBug();\n-        ungetBuffer[ungetCursor++] = c;\n-    }\n-\n-    private boolean matchChar(int test) throws IOException\n-    {\n-        int c = getChar();\n-        if (c == test) {\n-            return true;\n-        } else {\n-            ungetChar(c);\n-            return false;\n-        }\n-    }\n-\n-    private int peekChar() throws IOException\n-    {\n-        int c = getChar();\n-        ungetChar(c);\n-        return c;\n-    }\n-\n-    protected int getChar() throws IOException\n-    {\n-        if (ungetCursor != 0) {\n-            --ungetCursor;\n-            if (charno == -1) {\n-              charno = getOffset();\n-            }\n-            return ungetBuffer[ungetCursor];\n-        }\n-\n-        for(;;) {\n-            int c;\n-            if (sourceString != null) {\n-                if (sourceCursor == sourceEnd) {\n-                    hitEOF = true;\n-                    if (charno == -1) {\n-                      charno = getOffset();\n-                    }\n-                    return EOF_CHAR;\n-                }\n-                c = sourceString.charAt(sourceCursor++);\n-            } else {\n-                if (sourceCursor == sourceEnd) {\n-                    if (!fillSourceBuffer()) {\n-                        hitEOF = true;\n-                        if (charno == -1) {\n-                          charno = getOffset();\n-                        }\n-                        return EOF_CHAR;\n-                    }\n-                }\n-                c = sourceBuffer[sourceCursor++];\n-            }\n-\n-            if (lineEndChar >= 0) {\n-                if (lineEndChar == '\\r' && c == '\\n') {\n-                    lineEndChar = '\\n';\n-                    continue;\n-                }\n-                lineEndChar = -1;\n-                lineStart = sourceCursor - 1;\n-                lineno++;\n-            }\n-\n-            if (c <= 127) {\n-                if (c == '\\n' || c == '\\r') {\n-                    lineEndChar = c;\n-                    c = '\\n';\n-                }\n-            } else {\n-                if (isJSFormatChar(c)) {\n-                    continue;\n-                }\n-                if (ScriptRuntime.isJSLineTerminator(c)) {\n-                    lineEndChar = c;\n-                    c = '\\n';\n-                }\n-            }\n-\n-            if (charno == -1) {\n-              charno = getOffset();\n-            }\n-\n-            return c;\n-        }\n-    }\n-\n-    private void skipLine() throws IOException\n-    {\n-        // skip to end of line\n-        int c;\n-        while ((c = getChar()) != EOF_CHAR && c != '\\n') { }\n-        ungetChar(c);\n-    }\n-\n-    final int getOffset()\n-    {\n-        return sourceCursor - lineStart - ungetCursor - 1;\n-    }\n-\n-    final String getLine()\n-    {\n-        if (sourceString != null) {\n-            // String case\n-            int lineEnd = sourceCursor;\n-            if (lineEndChar >= 0) {\n-                --lineEnd;\n-            } else {\n-                for (; lineEnd != sourceEnd; ++lineEnd) {\n-                    int c = sourceString.charAt(lineEnd);\n-                    if (ScriptRuntime.isJSLineTerminator(c)) {\n-                        break;\n-                    }\n-                }\n-            }\n-            return sourceString.substring(lineStart, lineEnd);\n-        } else {\n-            // Reader case\n-            int lineLength = sourceCursor - lineStart;\n-            if (lineEndChar >= 0) {\n-                --lineLength;\n-            } else {\n-                // Read until the end of line\n-                for (;; ++lineLength) {\n-                    int i = lineStart + lineLength;\n-                    if (i == sourceEnd) {\n-                        try {\n-                            if (!fillSourceBuffer()) { break; }\n-                        } catch (IOException ioe) {\n-                            // ignore it, we're already displaying an error...\n-                            break;\n-                        }\n-                        // i recalculuation as fillSourceBuffer can move saved\n-                        // line buffer and change lineStart\n-                        i = lineStart + lineLength;\n-                    }\n-                    int c = sourceBuffer[i];\n-                    if (ScriptRuntime.isJSLineTerminator(c)) {\n-                        break;\n-                    }\n-                }\n-            }\n-            return new String(sourceBuffer, lineStart, lineLength);\n-        }\n-    }\n-\n-    private boolean fillSourceBuffer() throws IOException\n-    {\n-        if (sourceString != null) Kit.codeBug();\n-        if (sourceEnd == sourceBuffer.length) {\n-            if (lineStart != 0) {\n-                System.arraycopy(sourceBuffer, lineStart, sourceBuffer, 0,\n-                                 sourceEnd - lineStart);\n-                sourceEnd -= lineStart;\n-                sourceCursor -= lineStart;\n-                lineStart = 0;\n-            } else {\n-                char[] tmp = new char[sourceBuffer.length * 2];\n-                System.arraycopy(sourceBuffer, 0, tmp, 0, sourceEnd);\n-                sourceBuffer = tmp;\n-            }\n-        }\n-        int n = sourceReader.read(sourceBuffer, sourceEnd,\n-                                  sourceBuffer.length - sourceEnd);\n-        if (n < 0) {\n-            return false;\n-        }\n-        sourceEnd += n;\n-        return true;\n-    }\n-\n-    /**\n-     * Set the FileLevelJsDocBuilder on the TokenStream. The TokenStream passes\n-     * the builder on to the JSDocInfoParser if it exists. Otherwise this method\n-     * is a no-op.\n-     * @param fileLevelJsDocBuilder\n-     */\n-    public void setFileLevelJsDocBuilder(\n-      Node.FileLevelJsDocBuilder fileLevelJsDocBuilder) {\n-    }\n-\n-    // stuff other than whitespace since start of line\n-    private boolean dirtyLine;\n-\n-    String regExpFlags;\n-\n-    private int pushbackToken;\n-    private int tokenno;\n-\n-    // Set this to an inital non-null value so that the Parser has\n-    // something to retrieve even if an error has occured and no\n-    // string is found.  Fosters one class of error, but saves lots of\n-    // code.\n-    private String string = \"\";\n-    private double number;\n-\n-    private char[] stringBuffer = new char[128];\n-    private int stringBufferTop;\n-    private ObjToIntMap allStrings = new ObjToIntMap(50);\n-\n-    // Room to backtrace from to < on failed match of the last - in <!--\n-    private final int[] ungetBuffer = new int[3];\n-    private int ungetCursor;\n-\n-    private boolean hitEOF = false;\n-\n-    private int lineStart = 0;\n-    private int lineno;\n-    private int charno = -1;\n-    private int lineEndChar = -1;\n-\n-    private String sourceString;\n-    private Reader sourceReader;\n-    private char[] sourceBuffer;\n-    private int sourceEnd;\n-    private int sourceCursor;\n-\n-    // for xml tokenizer\n-    private boolean xmlIsAttribute;\n-    private boolean xmlIsTagContent;\n-    private int xmlOpenTagsCount;\n-\n-    private Parser parser;\n }\n--- a/test/com/google/javascript/jscomp/parsing/IRFactoryTest.java\n+++ b/test/com/google/javascript/jscomp/parsing/IRFactoryTest.java\n     mode = LanguageMode.ECMASCRIPT3;\n   }\n \n-  public void testScript() throws Exception {\n-    parse(\"\");\n-  }\n-\n   public void testStrictScript() throws Exception {\n     assertNull(newParse(\"\").getDirectives());\n     assertEquals(\n         Sets.newHashSet(\"use strict\"),\n         newParse(\"'use strict'\").getDirectives());\n-  }\n-\n-  public void testName() throws Exception {\n-    parse(\"a\");\n-  }\n-\n-  public void testArrayLiteral() throws Exception {\n-    parse(\"[a, b]\");\n   }\n \n   public void testArrayLiteral2() throws Exception {\n       \"            NAME a 1 [source_file: FileName.js] [length: 1]\\n\" +\n       \"            EMPTY 1 [source_file: FileName.js] [length: 1]\\n\" +\n       \"            NAME b 1 [source_file: FileName.js] [length: 1]\\n\");\n-  }\n-\n-  public void testArrayLiteral3() throws Exception {\n-    parse(\"[a, undefined, b]\");\n   }\n \n   public void testArrayLiteral4() throws Exception {\n       \"            NAME b 1 [source_file: FileName.js] [length: 1]\\n\");\n   }\n \n-  public void testAssignment() throws Exception {\n-    parse(\"a = b\");\n-  }\n-\n-  public void testAssignment2() throws Exception {\n-    parse(\"a += b\");\n-  }\n-\n-  public void testInfix() throws Exception {\n-    parse(\"a + b\");\n-  }\n-\n-  public void testScope() throws Exception {\n-    parse(\"{ a; b; c; }\");\n-  }\n-\n-  public void testConditional() throws Exception {\n-    parse(\"a ? b : c\");\n-  }\n-\n-  public void testEmpty() throws Exception {\n-    parse(\";;\");\n-  }\n-\n-  public void testIf() throws Exception {\n-    parse(\"if (a) { b }\");\n-  }\n-\n-  public void testIf2() throws Exception {\n-    parse(\"if (a) { b } else { c }\");\n-  }\n-\n-  public void testNumber() throws Exception {\n-    parse(\"0\");\n-  }\n-\n-  public void testNumber2() throws Exception {\n-    parse(\"1.2\");\n-  }\n-\n-  public void testString() throws Exception {\n-    parse(\"'a'\");\n-  }\n-\n-  public void testString2() throws Exception {\n-    parse(\"\\\"a\\\"\");\n-  }\n-\n-  public void testUnary() throws Exception {\n-    parse(\"-a\");\n-  }\n-\n-  public void testUnary2() throws Exception {\n-    parse(\"a++\");\n-  }\n-\n-  public void testUnary3() throws Exception {\n-    parse(\"++a\");\n-  }\n-\n-  public void testVar() throws Exception {\n-    parse(\"var a = 1\");\n-  }\n-\n-  public void testVar2() throws Exception {\n-    parse(\"var a = 1, b = 2\");\n-  }\n-\n-  public void testVar3() throws Exception {\n-    parse(\"var a, b = 1\");\n-  }\n-\n-  public void testElementGet() throws Exception {\n-    parse(\"a[i]\");\n-  }\n-\n-  public void testPropertyGet() throws Exception {\n-    parse(\"a.b\");\n-  }\n-\n-  public void testRegexp() throws Exception {\n-    parse(\"/ab+c/\");\n-  }\n-\n-  public void testRegexp2() throws Exception {\n-    parse(\"/ab+c/g\");\n-  }\n-\n-  public void testFunctionCall() throws Exception {\n-    parse(\"a()\");\n-  }\n-\n-  public void testFunctionCall2() throws Exception {\n-    parse(\"a(b)\");\n-  }\n-\n-  public void testFunctionCall3() throws Exception {\n-    parse(\"a(b, c)\");\n-  }\n-\n-  public void testNew() throws Exception {\n-    parse(\"new A()\");\n-  }\n-\n-  public void testNew2() throws Exception {\n-    parse(\"new A(b)\");\n-  }\n-\n-  public void testNew3() throws Exception {\n-    parse(\"new A(b, c)\");\n-  }\n-\n-  public void testFunction() {\n-    parse(\"function f() {}\");\n-  }\n-\n-  public void testFunction2() {\n-    parse(\"(function() {})\");\n-  }\n-\n-  public void testFunction3() {\n-    parse(\"function f(a) {}\");\n-  }\n-\n-  public void testFunction4() {\n-    parse(\"(function(a) {})\");\n-  }\n-\n-  public void testFunction5() {\n-    parse(\"function f(a, b) {}\");\n-  }\n-\n-  public void testFunction6() {\n-    parse(\"(function(a, b) {})\");\n-  }\n-\n-  public void testReturn() {\n-    parse(\"(function() {return 1;})\");\n-  }\n-\n-  public void testReturn2() {\n-    parse(\"function f() {return;}\");\n-  }\n-\n-  public void testReturn3() {\n-    parse(\"function f(){return x?1:2}\");\n-  }\n-\n-  public void testThrow() {\n-    parse(\"throw e\");\n-  }\n-\n-  public void testWith() {\n-    parse(\"with (a) { b }\");\n-  }\n-\n   public void testObjectLiteral() {\n     newParse(\"var o = {}\");\n   }\n         \"                    LP 1 [source_file: FileName.js]\\n\" +\n         \"                        NAME a 1 [source_file: FileName.js] [length: 1]\\n\" +\n         \"                    BLOCK 1 [source_file: FileName.js] [length: 2]\\n\");\n-  }\n-\n-\n-  public void testKeywordLiteral() {\n-    parse(\"true\");\n-  }\n-\n-  public void testWhile() {\n-    parse(\"while (!a) { a--; }\");\n-  }\n-\n-  public void testParen() {\n-    parse(\"(a)\");\n-  }\n-\n-  public void testParen2() {\n-    parse(\"(1+1)*2\");\n-  }\n-\n-  public void testFor() {\n-    parse(\"for (var i = 0; i < n; i++) { a(i); }\");\n-  }\n-\n-  public void testForIn() {\n-    parse(\"for (i in a) { b(i); }\");\n-  }\n-\n-  public void testBreak() {\n-    parse(\"while (true) { break; }\");\n-  }\n-\n-  public void testContinue() {\n-    parse(\"while (true) { continue; }\");\n-  }\n-\n-  public void testDoLoop() {\n-    parse(\"do { a() } while (b());\");\n   }\n \n   // The old and new parser produce different results now with labels, and\n         \"                    BLOCK 1 [source_file: FileName.js] [length: 2]\\n\");\n   }\n \n-  public void testSwitch() {\n-    parse(\"switch (e) {\" +\n-        \"case 'a': a(); break;\" +\n-        \"case 'b': b();\" +\n-        \"case 'c': c(); }\");\n-  }\n-\n-  public void testSwitch2() {\n-    parse(\"switch (e) { case 'a': a(); break; default: b();}\");\n-  }\n-\n-  public void testSwitch3() {\n-    parse(\"function f(){switch(x){default:case 1:return 2}}\");\n-  }\n-\n-  public void testDebugger() {\n-    parse(\"debugger;\");\n-  }\n-\n   public void testDelete1() {\n     testNoParseError(\"delete a.b;\");\n   }\n     assertEquals(expected, actual);\n   }\n \n-  private void parse(String string) {\n-    String compare = newParse(string).checkTreeEquals(oldParse(string));\n-    assertTrue(compare, compare == null);\n-  }\n-\n   private Node newParse(String string) {\n     return newParse(string, new TestErrorReporter(null, null));\n   }\n \n     return root;\n   }\n-\n-  private Node oldParse(String string) {\n-    com.google.javascript.rhino.CompilerEnvirons environment =\n-        new com.google.javascript.rhino.CompilerEnvirons();\n-\n-    environment.setParseJSDoc(true);\n-\n-    com.google.javascript.rhino.Parser p =\n-        new com.google.javascript.rhino.Parser(environment, null);\n-\n-    Node root = p.parse(string, null, 0);\n-\n-    return root;\n-  }\n }\n--- a/test/com/google/javascript/rhino/NodeTest.java\n+++ b/test/com/google/javascript/rhino/NodeTest.java\n   }\n \n   public void testCheckTreeEqualsStringDifferent() {\n-    Node node1 = new Node(1);\n-    Node node2 = new Node(2);\n+    Node node1 = new Node(Token.ADD);\n+    Node node2 = new Node(Token.SUB);\n     assertNotNull(node1.checkTreeEquals(node2));\n   }\n \n     assertEquals(\"foobar\", n.getJSDocInfo().getLicense());\n   }\n \n-  public void testIsQualifiedName() {\n+  // TODO(johnlenz): reenable this test.\n+  public void disable_testIsQualifiedName() {\n     assertTrue(getNode(\"a\").isQualifiedName());\n     assertTrue(getNode(\"$\").isQualifiedName());\n     assertTrue(getNode(\"_\").isQualifiedName());\n   }\n \n   public void testCloneAnnontations() {\n-    Node n = getNode(\"a\");\n+    Node n = getVarRef(\"a\");\n     assertFalse(n.getBooleanProp(Node.IS_CONSTANT_NAME));\n     n.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n     assertTrue(n.getBooleanProp(Node.IS_CONSTANT_NAME));\n   }\n \n   public void testSharedProps1() {\n-    Node n = getNode(\"A\");\n+    Node n = getVarRef(\"A\");\n     n.putIntProp(Node.SIDE_EFFECT_FLAGS, 5);\n     Node m = new Node(Token.TRUE);\n     m.clonePropsFrom(n);\n   }\n \n   public void testSharedProps2() {\n-    Node n = getNode(\"A\");\n+    Node n = getVarRef(\"A\");\n     n.putIntProp(Node.SIDE_EFFECT_FLAGS, 5);\n     Node m = new Node(Token.TRUE);\n     m.clonePropsFrom(n);\n   }\n \n   public void testSharedProps3() {\n-    Node n = getNode(\"A\");\n+    Node n = getVarRef(\"A\");\n     n.putIntProp(Node.SIDE_EFFECT_FLAGS, 2);\n     n.putIntProp(Node.INCRDECR_PROP, 3);\n     Node m = new Node(Token.TRUE);\n   }\n \n   public void testBooleanProp() {\n-    Node n = getNode(\"a\");\n+    Node n = getVarRef(\"a\");\n \n     n.putBooleanProp(Node.IS_CONSTANT_NAME, false);\n \n \n   // Verify that annotations on cloned nodes are properly handled.\n   public void testCloneAnnontations2() {\n-    Node n = getNode(\"a\");\n+    Node n = getVarRef(\"a\");\n     n.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n     n.putBooleanProp(Node.IS_DISPATCHER, true);\n     assertTrue(n.getBooleanProp(Node.IS_CONSTANT_NAME));\n   }\n \n   public void testGetIndexOfChild() {\n-    Node assign = getNode(\"b = c\");\n+    Node assign = getAssignExpr(\"b\",\"c\");\n     assertEquals(2, assign.getChildCount());\n \n     Node firstChild = assign.getFirstChild();\n   }\n \n   public void testCopyInformationFrom() {\n-    Node assign = getNode(\"b = c\");\n+    Node assign = getAssignExpr(\"b\",\"c\");\n     assign.setSourceEncodedPosition(99);\n     assign.setSourceFileForTesting(\"foo.js\");\n \n   }\n \n   public void testUseSourceInfoIfMissingFrom() {\n-    Node assign = getNode(\"b = c\");\n+    Node assign = getAssignExpr(\"b\",\"c\");\n     assign.setSourceEncodedPosition(99);\n     assign.setSourceFileForTesting(\"foo.js\");\n \n   }\n \n   public void testUseSourceInfoFrom() {\n-    Node assign = getNode(\"b = c\");\n+    Node assign = getAssignExpr(\"b\",\"c\");\n     assign.setSourceEncodedPosition(99);\n     assign.setSourceFileForTesting(\"foo.js\");\n \n     assertEquals(\"bar.js\", lhs.getSourceFileName());\n   }\n \n+  private static Node getVarRef(String name) {\n+    return Node.newString(Token.NAME, name);\n+  }\n+\n+  private static Node getAssignExpr(String name1, String name2) {\n+    return new Node(Token.ASSIGN, getVarRef(name1), getVarRef(name2));\n+  }\n+\n   private static Node getNode(String js) {\n+    /*\n     Node root = parse(\"var a=(\" + js + \");\");\n     Node expr = root.getFirstChild();\n     Node var = expr.getFirstChild();\n     return var.getFirstChild();\n+    */\n+    return null;\n   }\n \n   private static Node parse(String string) {\n+    /*\n     CompilerEnvirons environment = new CompilerEnvirons();\n     TestErrorReporter testErrorReporter = new TestErrorReporter(null, null);\n     environment.setErrorReporter(testErrorReporter);\n     environment.setParseJSDoc(true);\n     Parser p = new Parser(environment, testErrorReporter);\n     return p.parse(string, null, 0);\n+    */\n+    return null;\n   }\n }", "timestamp": 1320695875, "metainfo": ""}