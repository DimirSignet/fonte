{"sha": "5bde370c377946671edd3408878413d236399944", "log": "Change on 2010/04/20 by adam          Change detection of goog.events.getUniqueId to instead look for a         qualified name whose last component is .getUniqueId.          R=mark         DELTA=9  (3 added, 0 deleted, 6 changed)  Change on 2010/04/20 by nick          Make getDefaultExterns public and static.          R=robert         DELTA=1  (0 added, 0 deleted, 1 changed)  Change on 2010/04/20 by nick          Make NamedType package-private.          R=john         DELTA=80  (20 added, 38 deleted, 22 changed)  Change on 2010/04/21 by nick          Add a bunch of missing externs annotations.          R=alan         DELTA=58  (24 added, 9 deleted, 25 changed)  Change on 2010/04/21 by john          Prevent duplicate \"@implements\" annotations in TypedCodeGenerator output.         Correct parameter names in function type declarations to match normalized parameter names.          R=robert         DELTA=15  (9 added, 2 deleted, 4 changed)  Change on 2010/04/21 by alan          Disable extra prototype prop in SIMPLE mode.          R=nick         DELTA=1  (0 added, 1 deleted, 0 changed)  Change on 2010/04/21 by alan          Move LatticeElement to its own file.          R=nick         DELTA=44  (29 added, 10 deleted, 5 changed)  Change on 2010/04/21 by nick          Fiddle around with the order of externs.         As it turns out, order matters. When we resolve an @override function,         we need to be able to find the function that it overrides.          R=alan         DELTA=80  (47 added, 31 deleted, 2 changed)    Revision created by MOE tool push_codebase. MOE_MIGRATION=bncqsx   ", "commit": "\n--- a/src/com/google/javascript/jscomp/AmbiguateProperties.java\n+++ b/src/com/google/javascript/jscomp/AmbiguateProperties.java\n     return objType == null\n         || invalidatingTypes.contains(objType)\n         || !objType.hasReferenceName()\n-        || (objType.isNamedType() && objType.isUnknownType())\n+        || objType.isUnknownType() /* unresolved types */\n         || objType.isEnumType() || objType.autoboxesTo() != null;\n   }\n \n--- a/src/com/google/javascript/jscomp/CheckMissingGetCssName.java\n+++ b/src/com/google/javascript/jscomp/CheckMissingGetCssName.java\n   private final Matcher blacklist;\n \n   static final String GET_CSS_NAME_FUNCTION = \"goog.getCssName\";\n-  static final String GET_UNIQUE_ID_FUNCTION = \"goog.events.getUniqueId\";\n+  static final String GET_UNIQUE_ID_FUNCTION = \".getUniqueId\";\n \n   static final DiagnosticType MISSING_GETCSSNAME =\n       DiagnosticType.disabled(\n   }\n \n   /**\n-   * Returns whether the node is an argument of a goog.events.getUniqueId\n-   * call.\n+   * Returns whether the node is an argument of a function that returns\n+   * a unique id (the last part of the qualified name matches\n+   * GET_UNIQUE_ID_FUNCTION).\n    */\n   private boolean insideGetUniqueIdCall(Node n, Node parent) {\n-    return parent.getType() == Token.CALL &&\n-        GET_UNIQUE_ID_FUNCTION.equals(\n-            parent.getFirstChild().getQualifiedName());\n+    String name = parent.getType() == Token.CALL ?\n+        parent.getFirstChild().getQualifiedName() : null;\n+\n+    return name != null && name.endsWith(GET_UNIQUE_ID_FUNCTION);\n   }\n \n   /**\n--- a/src/com/google/javascript/jscomp/CommandLineRunner.java\n+++ b/src/com/google/javascript/jscomp/CommandLineRunner.java\n    * @return a mutable list\n    * @throws IOException\n    */\n-  private List<JSSourceFile> getDefaultExterns() throws IOException {\n+  public static List<JSSourceFile> getDefaultExterns() throws IOException {\n     InputStream input = CommandLineRunner.class.getResourceAsStream(\n         \"/externs.zip\");\n     ZipInputStream zip = new ZipInputStream(input);\n--- a/src/com/google/javascript/jscomp/CompilationLevel.java\n+++ b/src/com/google/javascript/jscomp/CompilationLevel.java\n     options.removeConstantExpressions = true;\n     options.coalesceVariableNames = true;\n     options.deadAssignmentElimination = true;\n-    options.extractPrototypeMemberDeclarations = true;\n     options.collapseVariableDeclarations = true;\n     options.convertToDottedProperties = true;\n     options.labelRenaming = true;\n--- a/src/com/google/javascript/jscomp/ConcreteType.java\n+++ b/src/com/google/javascript/jscomp/ConcreteType.java\n import com.google.common.base.Preconditions;\n import com.google.common.collect.Lists;\n import com.google.common.collect.Sets;\n-import com.google.javascript.jscomp.DataFlowAnalysis.LatticeElement;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n import com.google.javascript.rhino.jstype.FunctionPrototypeType;\n--- a/src/com/google/javascript/jscomp/DataFlowAnalysis.java\n+++ b/src/com/google/javascript/jscomp/DataFlowAnalysis.java\n  * <li>JOIN Operation: Implement\n  *    {@link JoinOp#join(LatticeElement, LatticeElement)}.\n  * <li>Flow Equations: Implement\n- * {@link #flowThrough(Object, DataFlowAnalysis.LatticeElement)}.\n+ * {@link #flowThrough(Object, LatticeElement)}.\n  * <li>Initial Entry Value: Implement {@link #createEntryLattice()}.\n  * <li>Initial Estimate: Implement {@link #createInitialEstimateLattice()}.\n  * </ol>\n  * @param <N> The control flow graph's node value type.\n  * @param <L> Lattice element type.\n  */\n-abstract class DataFlowAnalysis<N, L extends DataFlowAnalysis.LatticeElement> {\n-\n-  /**\n-   * A lattice element in the data flow analysis.\n-   */\n-  static interface LatticeElement {\n-  }\n+abstract class DataFlowAnalysis<N, L extends LatticeElement> {\n \n   static interface JoinOp<L extends LatticeElement>\n       extends Function<List<L>, L> {\n--- a/src/com/google/javascript/jscomp/DisambiguateProperties.java\n+++ b/src/com/google/javascript/jscomp/DisambiguateProperties.java\n \n     @Override public boolean isInvalidatingType(JSType type) {\n       if (type == null || invalidatingTypes.contains(type) ||\n-          (type.isNamedType() && type.isUnknownType())) {\n+          type.isUnknownType() /* unresolved types */) {\n         return true;\n       }\n \n--- a/src/com/google/javascript/jscomp/FlowScope.java\n+++ b/src/com/google/javascript/jscomp/FlowScope.java\n \n package com.google.javascript.jscomp;\n \n-import com.google.javascript.jscomp.DataFlowAnalysis.LatticeElement;\n import com.google.javascript.rhino.jstype.JSType;\n import com.google.javascript.rhino.jstype.StaticScope;\n import com.google.javascript.rhino.jstype.StaticSlot;\n--- /dev/null\n+++ b/src/com/google/javascript/jscomp/LatticeElement.java\n+/*\n+ * Copyright 2010 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+/**\n+ * A lattice element.\n+ * \n+*\n+ */\n+interface LatticeElement {\n+\n+}\n--- a/src/com/google/javascript/jscomp/LiveVariablesAnalysis.java\n+++ b/src/com/google/javascript/jscomp/LiveVariablesAnalysis.java\n    * point in the program. The whole lattice is the power set of all local\n    * variables and a variable is live if it is in the set.\n    */\n-  static class LiveVariableLattice implements DataFlowAnalysis.LatticeElement {\n+  static class LiveVariableLattice implements LatticeElement {\n     private final BitSet liveSet;\n \n     /**\n--- a/src/com/google/javascript/jscomp/MaybeReachingVariableUse.java\n+++ b/src/com/google/javascript/jscomp/MaybeReachingVariableUse.java\n    *\n    * At N_3, reads of A in {N_4, N_5} are said to be upward exposed.\n    */\n-  static final class ReachingUses implements DataFlowAnalysis.LatticeElement {\n+  static final class ReachingUses implements LatticeElement {\n     final Multimap<Var, Node> mayUseMap;\n \n     public ReachingUses() {\n--- a/src/com/google/javascript/jscomp/MustBeReachingVariableDef.java\n+++ b/src/com/google/javascript/jscomp/MustBeReachingVariableDef.java\n \n package com.google.javascript.jscomp;\n \n-import javax.annotation.Nullable;\n import com.google.common.base.Preconditions;\n import com.google.common.collect.Maps;\n import com.google.common.collect.Sets;\n import java.util.Map;\n import java.util.Set;\n \n+import javax.annotation.Nullable;\n+\n /**\n  * Computes reaching definition for all use of each variables.\n  *\n    *          (BOTTOM)\n    *\n    */\n-  static final class MustDef implements DataFlowAnalysis.LatticeElement {\n+  static final class MustDef implements LatticeElement {\n \n     // TODO(user): Use bit vector instead of maps might get better\n     // performance. Change it after this is tested to be fully functional.\n--- a/src/com/google/javascript/jscomp/TypeCheck.java\n+++ b/src/com/google/javascript/jscomp/TypeCheck.java\n import com.google.javascript.rhino.jstype.JSType;\n import com.google.javascript.rhino.jstype.JSTypeNative;\n import com.google.javascript.rhino.jstype.JSTypeRegistry;\n-import com.google.javascript.rhino.jstype.NamedType;\n import com.google.javascript.rhino.jstype.ObjectType;\n import com.google.javascript.rhino.jstype.TernaryValue;\n-import com.google.javascript.rhino.jstype.UnionType;\n \n import java.util.Iterator;\n \n       nullCount++;\n     } else if (type.isUnknownType()) {\n       if (reportUnknownTypes.isOn()) {\n-        String unresolvedReference = getUnresolvedReference(type);\n-        if (unresolvedReference != null) {\n-          compiler.report(\n-              t.makeError(n, reportUnknownTypes,\n-                  UNRESOLVED_TYPE, unresolvedReference));\n-        } else {\n-          compiler.report(\n-              t.makeError(n, reportUnknownTypes, UNKNOWN_EXPR_TYPE));\n-        }\n+        compiler.report(\n+            t.makeError(n, reportUnknownTypes, UNKNOWN_EXPR_TYPE));\n       }\n       unknownCount++;\n     } else {\n       typedCount++;\n     }\n-  }\n-\n-  /**\n-   * Looks through the type to see if it contains an unresolved reference.  This\n-   * is often the reason that a type is unresolved, and it can occur because of\n-   * a simple misspelling of a type name.\n-   */\n-  private String getUnresolvedReference(JSType type) {\n-    if (type.isNamedType()) {\n-      NamedType namedType = (NamedType) type;\n-      if (!namedType.isResolved()) {\n-        return namedType.getReferenceName();\n-      }\n-    } else if (type.isUnionType()) {\n-      for (JSType alt : ((UnionType) type).getAlternates()) {\n-        if (alt.isUnknownType()) {\n-          String unresolvedReference = getUnresolvedReference(alt);\n-          if (unresolvedReference != null) {\n-            return unresolvedReference;\n-          }\n-        }\n-      }\n-    }\n-    return null;\n   }\n \n   /**\n--- a/src/com/google/javascript/jscomp/TypedCodeGenerator.java\n+++ b/src/com/google/javascript/jscomp/TypedCodeGenerator.java\n \n package com.google.javascript.jscomp;\n \n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.Sets;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n-import com.google.javascript.rhino.jstype.FunctionPrototypeType;\n import com.google.javascript.rhino.jstype.FunctionType;\n import com.google.javascript.rhino.jstype.JSType;\n import com.google.javascript.rhino.jstype.ObjectType;\n \n import java.nio.charset.Charset;\n+import java.util.Set;\n \n \n /**\n         add(getFunctionAnnotation(n));\n       } else if (n.getType() == Token.EXPR_RESULT\n           && n.getFirstChild().getType() == Token.ASSIGN) {\n-        Node rhs = n.getFirstChild().getFirstChild();\n+        Node rhs = n.getFirstChild().getLastChild();\n         add(getTypeAnnotation(rhs));\n       } else if (n.getType() == Token.VAR\n           && n.getFirstChild().getFirstChild() != null\n   /**\n    * @param node A node for a function for which to generate a type annotation\n    */\n-  private String getFunctionAnnotation(Node node) {\n+  private String getFunctionAnnotation(Node fnNode) {\n+    Preconditions.checkState(fnNode.getType() == Token.FUNCTION);\n     StringBuilder sb = new StringBuilder(\"/**\\n\");\n \n-    JSType type = node.getJSType();\n+    JSType type = fnNode.getJSType();\n \n     if (type == null || type.isUnknownType()) {\n       return \"\";\n     }\n \n-    FunctionType funType = (FunctionType) node.getJSType();\n+    FunctionType funType = (FunctionType) fnNode.getJSType();\n \n     // We need to use the child nodes of the function as the nodes for the\n     // parameters of the function type do not have the real parameter names.\n     //   LP\n     //     NAME param1\n     //     NAME param2\n-    Node fnNode = funType.getSource();\n     if (fnNode != null) {\n       Node paramNode = NodeUtil.getFnParameters(fnNode).getFirstChild();\n \n         }\n       }\n \n+      // Avoid duplicates, add implemented type to a set first\n+      Set<String> interfaces = Sets.newTreeSet();\n       for (ObjectType interfaze : funType.getImplementedInterfaces()) {\n+        interfaces.add(interfaze.toString());\n+      }\n+      for (String interfaze : interfaces) {\n         sb.append(\" * @implements {\"  + interfaze + \"}\\n\");\n       }\n \n--- a/src/com/google/javascript/rhino/jstype/JSType.java\n+++ b/src/com/google/javascript/rhino/jstype/JSType.java\n     return false;\n   }\n \n-  public boolean isNamedType() {\n+  boolean isNamedType() {\n     return false;\n   }\n \n--- a/src/com/google/javascript/rhino/jstype/JSTypeRegistry.java\n+++ b/src/com/google/javascript/rhino/jstype/JSTypeRegistry.java\n \n package com.google.javascript.rhino.jstype;\n \n+import static com.google.javascript.rhino.jstype.JSTypeNative.ALL_TYPE;\n+import static com.google.javascript.rhino.jstype.JSTypeNative.ARRAY_TYPE;\n+import static com.google.javascript.rhino.jstype.JSTypeNative.NO_TYPE;\n+import static com.google.javascript.rhino.jstype.JSTypeNative.UNKNOWN_TYPE;\n+import static com.google.javascript.rhino.jstype.JSTypeNative.VOID_TYPE;\n+\n+import com.google.common.annotations.VisibleForTesting;\n import com.google.common.collect.ArrayListMultimap;\n import com.google.common.collect.HashMultimap;\n import com.google.common.collect.Maps;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.ScriptRuntime;\n import com.google.javascript.rhino.Token;\n-import static com.google.javascript.rhino.jstype.JSTypeNative.ALL_TYPE;\n-import static com.google.javascript.rhino.jstype.JSTypeNative.ARRAY_TYPE;\n-import static com.google.javascript.rhino.jstype.JSTypeNative.NO_TYPE;\n-import static com.google.javascript.rhino.jstype.JSTypeNative.UNKNOWN_TYPE;\n-import static com.google.javascript.rhino.jstype.JSTypeNative.VOID_TYPE;\n \n import java.io.Serializable;\n import java.util.Collection;\n   public ParameterizedType createParameterizedType(\n       ObjectType objectType, JSType parameterType) {\n     return new ParameterizedType(this, objectType, parameterType);\n+  }\n+\n+  /**\n+   * Creates a named type.\n+   */\n+  @VisibleForTesting\n+  public JSType createNamedType(String reference,\n+      String sourceName, int lineno, int charno) {\n+    return new NamedType(this, reference, sourceName, lineno, charno);\n   }\n \n   /**\n--- a/src/com/google/javascript/rhino/jstype/NamedType.java\n+++ b/src/com/google/javascript/rhino/jstype/NamedType.java\n *\n *\n  */\n-public class NamedType extends ProxyObjectType {\n+class NamedType extends ProxyObjectType {\n   private static final long serialVersionUID = 1L;\n \n   private final String reference;\n   /**\n    * Create a named type based on the reference.\n    */\n-  public NamedType(JSTypeRegistry registry, String reference,\n+  NamedType(JSTypeRegistry registry, String reference,\n       String sourceName, int lineno, int charno) {\n     super(registry, registry.getNativeObjectType(JSTypeNative.UNKNOWN_TYPE));\n \n   }\n \n   @Override\n-  public boolean isNamedType() {\n+  boolean isNamedType() {\n     return true;\n   }\n \n--- a/test/com/google/javascript/jscomp/CheckMissingGetCssNameTest.java\n+++ b/test/com/google/javascript/jscomp/CheckMissingGetCssNameTest.java\n \n   public void testIgnoreGetUniqueIdArguments() {\n     testNotMissing(\"var s = goog.events.getUniqueId('goog-some-event')\");\n+    testNotMissing(\"var s = joe.random.getUniqueId('joe-is-a-goob')\");\n   }\n \n   public void testIgnoreAssignmentsToIdConstant() {\n--- a/test/com/google/javascript/jscomp/DataFlowAnalysisTest.java\n+++ b/test/com/google/javascript/jscomp/DataFlowAnalysisTest.java\n import com.google.javascript.jscomp.DataFlowAnalysis.BranchedFlowState;\n import com.google.javascript.jscomp.DataFlowAnalysis.BranchedForwardDataFlowAnalysis;\n import com.google.javascript.jscomp.DataFlowAnalysis.FlowState;\n-import com.google.javascript.jscomp.DataFlowAnalysis.LatticeElement;\n import com.google.javascript.jscomp.DataFlowAnalysis.MaxIterationsExceededException;\n import com.google.javascript.jscomp.graph.GraphNode;\n import com.google.javascript.jscomp.graph.DiGraph.DiGraphEdge;\n--- a/test/com/google/javascript/jscomp/parsing/JsDocInfoParserTest.java\n+++ b/test/com/google/javascript/jscomp/parsing/JsDocInfoParserTest.java\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n import com.google.javascript.rhino.jstype.JSType;\n-import com.google.javascript.rhino.jstype.NamedType;\n import com.google.javascript.rhino.jstype.ObjectType;\n import com.google.javascript.rhino.testing.BaseJSTypeTestCase;\n \n \n   public void testParseNullableModifiers9() throws Exception {\n     JSDocInfo info = parse(\"@type {foo.Hello.World?}*/\");\n-    assertTypeEquals(createNullableType(new NamedType(\n-        registry, \"foo.Hello.World\", null, -1, -1)),\n+    assertTypeEquals(\n+        createNullableType(\n+            registry.createNamedType(\n+                \"foo.Hello.World\", null, -1, -1)),\n         info.getType());\n   }\n \n     JSDocInfo info =\n         parse(\"@this {goog.foo.Bar}*/\");\n     assertTypeEquals(\n-        new NamedType(registry, \"goog.foo.Bar\", null, -1, -1),\n+        registry.createNamedType(\"goog.foo.Bar\", null, -1, -1),\n         info.getThisType());\n   }\n \n     JSDocInfo info =\n         parse(\"@this goog.foo.Bar*/\");\n     assertTypeEquals(\n-        new NamedType(registry, \"goog.foo.Bar\", null, -1, -1),\n+        registry.createNamedType(\"goog.foo.Bar\", null, -1, -1),\n         info.getThisType());\n   }\n \n   public void testParseExtends2() throws Exception {\n     JSDocInfo info = parse(\"@extends com.google.Foo.Bar.Hello.World*/\");\n     assertTypeEquals(\n-        new NamedType(registry, \"com.google.Foo.Bar.Hello.World\", null, -1, -1),\n+        registry.createNamedType(\n+            \"com.google.Foo.Bar.Hello.World\", null, -1, -1),\n         info.getBaseType());\n   }\n \n     JSDocInfo info =\n         parse(\"@extends com.google.Foo.Bar.Hello.World.<Boolean,number>*/\");\n     assertTypeEquals(\n-        new NamedType(registry, \"com.google.Foo.Bar.Hello.World\", null, -1, -1),\n+        registry.createNamedType(\n+            \"com.google.Foo.Bar.Hello.World\", null, -1, -1),\n         info.getBaseType());\n   }\n \n         parse(\"@implements {SomeInterface.<*>} */\")\n         .getImplementedInterfaces();\n     assertEquals(1, interfaces.size());\n-    assertTypeEquals(new NamedType(registry, \"SomeInterface\", null, -1, -1),\n+    assertTypeEquals(registry.createNamedType(\"SomeInterface\", null, -1, -1),\n         interfaces.get(0));\n   }\n \n     // If this is fixed in the future, change this test to check for a\n     // warning/error message.\n     assertTypeEquals(\n-        new NamedType(registry, \"some_++#%$%_UglyString\", null, -1, -1),\n+        registry.createNamedType(\"some_++#%$%_UglyString\", null, -1, -1),\n         parse(\"@extends {some_++#%$%_UglyString} */\").getBaseType());\n   }\n \n         \" * @extends FooBar\\n\" +\n         \" */\");\n \n-    assertTypeEquals(new NamedType(registry, \"FooBar\", null, 0, 0),\n+    assertTypeEquals(registry.createNamedType(\"FooBar\", null, 0, 0),\n         jsdoc.getBaseType());\n     assertFalse(jsdoc.isConstant());\n     assertNull(jsdoc.getDescription());\n     List<JSTypeExpression> interfaces = parse(\"@implements {SomeInterface}*/\")\n         .getImplementedInterfaces();\n     assertEquals(1, interfaces.size());\n-    assertTypeEquals(new NamedType(registry, \"SomeInterface\", null, -1, -1),\n+    assertTypeEquals(registry.createNamedType(\"SomeInterface\", null, -1, -1),\n         interfaces.get(0));\n   }\n \n             \"*/\")\n         .getImplementedInterfaces();\n     assertEquals(2, interfaces.size());\n-    assertTypeEquals(new NamedType(registry, \"SomeInterface1\", null, -1, -1),\n+    assertTypeEquals(registry.createNamedType(\"SomeInterface1\", null, -1, -1),\n         interfaces.get(0));\n-    assertTypeEquals(new NamedType(registry, \"SomeInterface2\", null, -1, -1),\n+    assertTypeEquals(registry.createNamedType(\"SomeInterface2\", null, -1, -1),\n         interfaces.get(1));\n   }\n \n          \" * @interface \\n\" +\n          \" * @extends {Extended} */\");\n     assertTrue(jsdoc.isInterface());\n-    assertTypeEquals(new NamedType(registry, \"Extended\", null, -1, -1),\n+    assertTypeEquals(registry.createNamedType(\"Extended\", null, -1, -1),\n         jsdoc.getBaseType());\n   }\n \n   JSDocInfo jsdoc = parse(\"@implements {Disposable?}\\n * @constructor */\",\n       \"expected closing }\");\n     assertTrue(jsdoc.isConstructor());\n-    assertTypeEquals(new NamedType(registry, \"Disposable\", null, -1, -1),\n+    assertTypeEquals(registry.createNamedType(\"Disposable\", null, -1, -1),\n         jsdoc.getImplementedInterfaces().get(0));\n   }\n ", "timestamp": 1271893733, "metainfo": ""}