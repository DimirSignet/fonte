{"sha": "3fc66a99d98015dc798215a666f6b5ad268028c2", "log": "Refactor out of replace known methods.  R=zhuyi DELTA=1555  (825 added, 729 deleted, 1 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=2281   ", "commit": "\n--- a/src/com/google/javascript/jscomp/DefaultPassConfig.java\n+++ b/src/com/google/javascript/jscomp/DefaultPassConfig.java\n     protected CompilerPass createInternal(AbstractCompiler compiler) {\n       return new PeepholeOptimizationsPass(compiler,\n             new PeepholeSubstituteAlternateSyntax(true),\n+            new PeepholeReplaceKnownMethods(),\n             new PeepholeRemoveDeadCode(),\n             new PeepholeFoldConstants(),\n             new PeepholeCollectPropertyAssignments());\n             new StatementFusion(),\n             new PeepholeRemoveDeadCode(),\n             new PeepholeSubstituteAlternateSyntax(false),\n+            new PeepholeReplaceKnownMethods(),\n             new PeepholeFoldConstants());\n     }\n   };\n--- a/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\n+++ b/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\n package com.google.javascript.jscomp;\n \n import com.google.common.base.Preconditions;\n-import com.google.common.collect.Lists;\n import com.google.javascript.jscomp.mozilla.rhino.ScriptRuntime;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n import com.google.javascript.rhino.jstype.TernaryValue;\n-\n-import java.util.List;\n-import java.util.Locale;\n \n /**\n  * Peephole optimization to fold constants (e.g. x + 1 + 7 --> x + 8).\n \n   private static final double MAX_FOLD_NUMBER = Math.pow(2, 53);\n \n-  // The LOCALE independent \"locale\"\n-  private static final Locale ROOT_LOCALE = new Locale(\"\");\n-\n   @Override\n   Node optimizeSubtree(Node subtree) {\n     switch(subtree.getType()) {\n-      case Token.CALL:\n-        return tryFoldKnownMethods(subtree);\n-\n       case Token.NEW:\n         return tryFoldCtorCall(subtree);\n \n     return n;\n   }\n \n-  private Node tryFoldKnownMethods(Node subtree) {\n-    // For now we only support string methods .join(),\n-    // .indexOf(), .substring() and .substr()\n-    // and numeric methods parseInt() and parseFloat().\n-\n-    subtree = tryFoldArrayJoin(subtree);\n-\n-    if (subtree.getType() == Token.CALL) {\n-      Node callTarget = subtree.getFirstChild();\n-      if (callTarget == null) {\n-        return subtree;\n-      }\n-\n-      if (NodeUtil.isGet(callTarget)) {\n-        subtree = tryFoldKnownStringMethods(subtree);\n-      } else {\n-        subtree = tryFoldKnownNumericMethods(subtree);\n-      }\n-    }\n-\n-    return subtree;\n-  }\n-\n-  /**\n-   * Try to evaluate known String methods\n-   *    .indexOf(), .substr(), .substring()\n-   */\n-  private Node tryFoldKnownStringMethods(Node subtree) {\n-    Preconditions.checkArgument(subtree.getType() == Token.CALL);\n-\n-    // check if this is a call on a string method\n-    // then dispatch to specific folding method.\n-    Node callTarget = subtree.getFirstChild();\n-    if (callTarget == null) {\n-      return subtree;\n-    }\n-\n-    if (!NodeUtil.isGet(callTarget)) {\n-      return subtree;\n-    }\n-\n-    Node stringNode = callTarget.getFirstChild();\n-    Node functionName = stringNode.getNext();\n-\n-    if ((stringNode.getType() != Token.STRING) ||\n-        (functionName.getType() != Token.STRING)) {\n-      return subtree;\n-    }\n-\n-    String functionNameString = functionName.getString();\n-    Node firstArg = callTarget.getNext();\n-    if (firstArg == null) {\n-      if (functionNameString.equals(\"toLowerCase\")) {\n-        subtree = tryFoldStringToLowerCase(subtree, stringNode);\n-      } else if (functionNameString.equals(\"toUpperCase\")) {\n-        subtree = tryFoldStringToUpperCase(subtree, stringNode);\n-      }\n-      return subtree;\n-    } else if (NodeUtil.isImmutableValue(firstArg)) {\n-      if (functionNameString.equals(\"indexOf\") ||\n-          functionNameString.equals(\"lastIndexOf\")) {\n-        subtree = tryFoldStringIndexOf(subtree, functionNameString,\n-            stringNode, firstArg);\n-      } else if (functionNameString.equals(\"substr\")) {\n-        subtree = tryFoldStringSubstr(subtree, stringNode, firstArg);\n-      } else if (functionNameString.equals(\"substring\")) {\n-        subtree = tryFoldStringSubstring(subtree, stringNode, firstArg);\n-      }\n-    }\n-\n-    return subtree;\n-  }\n-\n-  /**\n-   * Try to evaluate known Numeric methods\n-   *    .parseInt(), parseFloat()\n-   */\n-  private Node tryFoldKnownNumericMethods(Node subtree) {\n-    Preconditions.checkArgument(subtree.getType() == Token.CALL);\n-\n-    if (isASTNormalized()) {\n-      // check if this is a call on a string method\n-      // then dispatch to specific folding method.\n-      Node callTarget = subtree.getFirstChild();\n-\n-      if (!NodeUtil.isName(callTarget)) {\n-        return subtree;\n-      }\n-\n-      String functionNameString = callTarget.getString();\n-      Node firstArgument = callTarget.getNext();\n-      if ((firstArgument != null) &&\n-          (firstArgument.getType() == Token.STRING ||\n-           firstArgument.getType() == Token.NUMBER)) {\n-        if (functionNameString.equals(\"parseInt\") ||\n-            functionNameString.equals(\"parseFloat\")) {\n-          subtree = tryFoldParseNumber(subtree, functionNameString,\n-              firstArgument);\n-        }\n-      }\n-    }\n-    return subtree;\n-  }\n-\n-  /**\n-   * @return The lowered string Node.\n-   */\n-  private Node tryFoldStringToLowerCase(Node subtree, Node stringNode) {\n-    // From Rhino, NativeString.java. See ECMA 15.5.4.11\n-    String lowered = stringNode.getString().toLowerCase(ROOT_LOCALE);\n-    Node replacement = Node.newString(lowered);\n-    subtree.getParent().replaceChild(subtree, replacement);\n-    reportCodeChange();\n-    return replacement;\n-  }\n-\n-  /**\n-   * @return The uppered string Node.\n-   */\n-  private Node tryFoldStringToUpperCase(Node subtree, Node stringNode) {\n-    // From Rhino, NativeString.java. See ECMA 15.5.4.12\n-    String uppered = stringNode.getString().toUpperCase(ROOT_LOCALE);\n-    Node replacement = Node.newString(uppered);\n-    subtree.getParent().replaceChild(subtree, replacement);\n-    reportCodeChange();\n-    return replacement;\n-  }\n-\n-  /**\n-   * @param input string representation of a number\n-   * @return string with leading and trailing zeros removed\n-   */\n-  private String normalizeNumericString(String input) {\n-    if (input == null || input.length() == 0) {\n-      return input;\n-    }\n-\n-    int startIndex = 0, endIndex = input.length() - 1;\n-    while (startIndex < input.length() && input.charAt(startIndex) == '0') {\n-      startIndex++;\n-    }\n-    while (endIndex >= 0 && input.charAt(endIndex) == '0') {\n-      endIndex--;\n-    }\n-    if (startIndex >= endIndex) {\n-      return input;\n-    }\n-\n-    return input.substring(startIndex, endIndex + 1);\n-  }\n-\n-  /**\n-   * Try to evaluate parseInt, parseFloat:\n-   *     parseInt(\"1\") -> 1\n-   *     parseInt(\"1\", 10) -> 1\n-   *     parseFloat(\"1.11\") -> 1.11\n-   */\n-  private Node tryFoldParseNumber(\n-      Node n, String functionName, Node firstArg) {\n-    Preconditions.checkArgument(n.getType() == Token.CALL);\n-\n-    boolean isParseInt = functionName.equals(\"parseInt\");\n-    Node secondArg = firstArg.getNext();\n-\n-    // Second argument is only used as the radix for parseInt\n-    int radix = 0;\n-    if (secondArg != null) {\n-      if (!isParseInt) {\n-        return n;\n-      }\n-\n-      // Third-argument and non-numeric second arg are problematic. Discard.\n-      if ((secondArg.getNext() != null) ||\n-          (secondArg.getType() != Token.NUMBER)) {\n-        return n;\n-      } else {\n-        double tmpRadix = secondArg.getDouble();\n-        if (tmpRadix != (int)tmpRadix)\n-          return n;\n-        radix = (int)tmpRadix;\n-        if (radix < 0 || radix == 1 || radix > 36) {\n-          return n;\n-        }\n-      }\n-    }\n-\n-    // stringVal must be a valid string.\n-    String stringVal = null;\n-    Double checkVal;\n-    if (firstArg.getType() == Token.NUMBER) {\n-      checkVal = NodeUtil.getNumberValue(firstArg);\n-      if (!(radix == 0 || radix == 10) && isParseInt) {\n-        //Convert a numeric first argument to a different base\n-        stringVal = String.valueOf(checkVal.intValue());\n-      } else {\n-        // If parseFloat is called with a numeric argument,\n-        // replace it with just the number.\n-        // If parseInt is called with a numeric first argument and the radix\n-        // is 10 or omitted, just replace it with the number\n-        Node numericNode;\n-        if (isParseInt) {\n-          numericNode = Node.newNumber(checkVal.intValue());\n-        } else {\n-          numericNode = Node.newNumber(checkVal);\n-        }\n-        n.getParent().replaceChild(n, numericNode);\n-        reportCodeChange();\n-        return numericNode;\n-      }\n-    } else {\n-      stringVal = NodeUtil.getStringValue(firstArg);\n-      if (stringVal == null) {\n-        return n;\n-      }\n-\n-      //Check that the string is in a format we can recognize\n-      checkVal = NodeUtil.getStringNumberValue(stringVal);\n-      if (checkVal == null || checkVal == Double.NaN) {\n-        return n;\n-      }\n-\n-      stringVal = NodeUtil.trimJsWhiteSpace(stringVal);\n-    }\n-\n-    Node newNode;\n-    if (isParseInt) {\n-      if (radix == 0 || radix == 16) {\n-        if (stringVal.length() > 1 &&\n-            stringVal.substring(0, 2).equalsIgnoreCase(\"0x\")) {\n-          radix = 16;\n-          stringVal = stringVal.substring(2);\n-        } else if (radix == 0) {\n-          // if a radix is not specified or is 0 and the most\n-          // significant digit is \"0\", the string will parse\n-          // with a radix of 8 on some browsers, so leave\n-          // this case alone. This check does not apply in\n-          // script mode ECMA5 or greater\n-          if (!isEcmaScript5OrGreater() &&\n-              stringVal.substring(0, 1).equals(\"0\")) {\n-            return n;\n-          }\n-\n-          radix = 10;\n-        }\n-      }\n-      int newVal = 0;\n-      try {\n-        newVal = Integer.parseInt(stringVal, radix);\n-      } catch (NumberFormatException e) {\n-        return n;\n-      }\n-\n-      newNode = Node.newNumber(newVal);\n-    } else {\n-      String normalizedNewVal = \"0\";\n-      try {\n-        double newVal = Double.parseDouble(stringVal);\n-        newNode = Node.newNumber(newVal);\n-        normalizedNewVal = normalizeNumericString(String.valueOf(newVal));\n-      }\n-      catch(NumberFormatException e) {\n-        return n;\n-      }\n-      // Make sure that the parsed number matches the original string\n-      // This prevents rounding differences between the java implementation\n-      // and native script.\n-      if (!normalizeNumericString(stringVal).equals(normalizedNewVal)) {\n-        return n;\n-      }\n-    }\n-\n-    n.getParent().replaceChild(n, newNode);\n-\n-    reportCodeChange();\n-\n-    return newNode;\n-  }\n-\n-  /**\n-   * Try to evaluate String.indexOf/lastIndexOf:\n-   *     \"abcdef\".indexOf(\"bc\") -> 1\n-   *     \"abcdefbc\".indexOf(\"bc\", 3) -> 6\n-   */\n-  private Node tryFoldStringIndexOf(\n-      Node n, String functionName, Node lstringNode, Node firstArg) {\n-    Preconditions.checkArgument(n.getType() == Token.CALL);\n-    Preconditions.checkArgument(lstringNode.getType() == Token.STRING);\n-\n-    String lstring = NodeUtil.getStringValue(lstringNode);\n-    boolean isIndexOf = functionName.equals(\"indexOf\");\n-    Node secondArg = firstArg.getNext();\n-    String searchValue = NodeUtil.getStringValue(firstArg);\n-    // searchValue must be a valid string.\n-    if (searchValue == null) {\n-      return n;\n-    }\n-    int fromIndex = isIndexOf ? 0 : lstring.length();\n-    if (secondArg != null) {\n-      // Third-argument and non-numeric second arg are problematic. Discard.\n-      if ((secondArg.getNext() != null) ||\n-          (secondArg.getType() != Token.NUMBER)) {\n-        return n;\n-      } else {\n-        fromIndex = (int) secondArg.getDouble();\n-      }\n-    }\n-    int indexVal = isIndexOf ? lstring.indexOf(searchValue, fromIndex)\n-                             : lstring.lastIndexOf(searchValue, fromIndex);\n-    Node newNode = Node.newNumber(indexVal);\n-    n.getParent().replaceChild(n, newNode);\n-\n-    reportCodeChange();\n-\n-    return newNode;\n-  }\n-\n-  /**\n-   * Try to fold an array join: ['a', 'b', 'c'].join('') -> 'abc';\n-   */\n-  private Node tryFoldArrayJoin(Node n) {\n-    Node callTarget = n.getFirstChild();\n-\n-    if (callTarget == null || !NodeUtil.isGetProp(callTarget)) {\n-      return n;\n-    }\n-\n-    Node right = callTarget.getNext();\n-    if (right != null && !NodeUtil.isImmutableValue(right)) {\n-      return n;\n-    }\n-\n-    Node arrayNode = callTarget.getFirstChild();\n-    Node functionName = arrayNode.getNext();\n-\n-    if ((arrayNode.getType() != Token.ARRAYLIT) ||\n-        !functionName.getString().equals(\"join\")) {\n-      return n;\n-    }\n-\n-    String joinString = (right == null) ? \",\" : NodeUtil.getStringValue(right);\n-    List<Node> arrayFoldedChildren = Lists.newLinkedList();\n-    StringBuilder sb = null;\n-    int foldedSize = 0;\n-    Node prev = null;\n-    Node elem = arrayNode.getFirstChild();\n-    // Merges adjacent String nodes.\n-    while (elem != null) {\n-      if (NodeUtil.isImmutableValue(elem) || elem.getType() == Token.EMPTY) {\n-        if (sb == null) {\n-          sb = new StringBuilder();\n-        } else {\n-          sb.append(joinString);\n-        }\n-        sb.append(NodeUtil.getArrayElementStringValue(elem));\n-      } else {\n-        if (sb != null) {\n-          Preconditions.checkNotNull(prev);\n-          // + 2 for the quotes.\n-          foldedSize += sb.length() + 2;\n-          arrayFoldedChildren.add(\n-              Node.newString(sb.toString()).copyInformationFrom(prev));\n-          sb = null;\n-        }\n-        foldedSize += InlineCostEstimator.getCost(elem);\n-        arrayFoldedChildren.add(elem);\n-      }\n-      prev = elem;\n-      elem = elem.getNext();\n-    }\n-\n-    if (sb != null) {\n-      Preconditions.checkNotNull(prev);\n-      // + 2 for the quotes.\n-      foldedSize += sb.length() + 2;\n-      arrayFoldedChildren.add(\n-          Node.newString(sb.toString()).copyInformationFrom(prev));\n-    }\n-    // one for each comma.\n-    foldedSize += arrayFoldedChildren.size() - 1;\n-\n-    int originalSize = InlineCostEstimator.getCost(n);\n-    switch (arrayFoldedChildren.size()) {\n-      case 0:\n-        Node emptyStringNode = Node.newString(\"\");\n-        n.getParent().replaceChild(n, emptyStringNode);\n-        reportCodeChange();\n-        return emptyStringNode;\n-      case 1:\n-        Node foldedStringNode = arrayFoldedChildren.remove(0);\n-        if (foldedSize > originalSize) {\n-          return n;\n-        }\n-        arrayNode.detachChildren();\n-        if (foldedStringNode.getType() != Token.STRING) {\n-          // If the Node is not a string literal, ensure that\n-          // it is coerced to a string.\n-          Node replacement = new Node(Token.ADD,\n-              Node.newString(\"\").copyInformationFrom(n),\n-              foldedStringNode);\n-          foldedStringNode = replacement;\n-        }\n-        n.getParent().replaceChild(n, foldedStringNode);\n-        reportCodeChange();\n-        return foldedStringNode;\n-      default:\n-        // No folding could actually be performed.\n-        if (arrayFoldedChildren.size() == arrayNode.getChildCount()) {\n-          return n;\n-        }\n-        int kJoinOverhead = \"[].join()\".length();\n-        foldedSize += kJoinOverhead;\n-        foldedSize += (right != null) ? InlineCostEstimator.getCost(right) : 0;\n-        if (foldedSize > originalSize) {\n-          return n;\n-        }\n-        arrayNode.detachChildren();\n-        for (Node node : arrayFoldedChildren) {\n-          arrayNode.addChildToBack(node);\n-        }\n-        reportCodeChange();\n-        break;\n-    }\n-\n-    return n;\n-  }\n-\n-  /**\n-   * Try to fold .substr() calls on strings\n-   */\n-  private Node tryFoldStringSubstr(Node n, Node stringNode, Node arg1) {\n-    Preconditions.checkArgument(n.getType() == Token.CALL);\n-    Preconditions.checkArgument(stringNode.getType() == Token.STRING);\n-\n-    int start, length;\n-    String stringAsString = stringNode.getString();\n-\n-    // TODO(nicksantos): We really need a NodeUtil.getNumberValue\n-    // function.\n-    if (arg1 != null && arg1.getType() == Token.NUMBER) {\n-      start = (int) arg1.getDouble();\n-    } else {\n-      return n;\n-    }\n-\n-    Node arg2 = arg1.getNext();\n-    if (arg2 != null) {\n-      if (arg2.getType() == Token.NUMBER) {\n-        length = (int) arg2.getDouble();\n-      } else {\n-        return n;\n-      }\n-\n-      if (arg2.getNext() != null) {\n-        // If we got more args than we expected, bail out.\n-        return n;\n-      }\n-    } else {\n-      // parameter 2 not passed\n-      length = stringAsString.length() - start;\n-    }\n-\n-    // Don't handle these cases. The specification actually does\n-    // specify the behavior in some of these cases, but we haven't\n-    // done a thorough investigation that it is correctly implemented\n-    // in all browsers.\n-    if ((start + length) > stringAsString.length() ||\n-        (length < 0) ||\n-        (start < 0)) {\n-      return n;\n-    }\n-\n-    String result = stringAsString.substring(start, start + length);\n-    Node resultNode = Node.newString(result);\n-\n-    Node parent = n.getParent();\n-    parent.replaceChild(n, resultNode);\n-    reportCodeChange();\n-    return resultNode;\n-  }\n-\n-  /**\n-   * Try to fold .substring() calls on strings\n-   */\n-  private Node tryFoldStringSubstring(Node n, Node stringNode, Node arg1) {\n-    Preconditions.checkArgument(n.getType() == Token.CALL);\n-    Preconditions.checkArgument(stringNode.getType() == Token.STRING);\n-\n-    int start, end;\n-    String stringAsString = stringNode.getString();\n-\n-    if (arg1 != null && arg1.getType() == Token.NUMBER) {\n-      start = (int) arg1.getDouble();\n-    } else {\n-      return n;\n-    }\n-\n-    Node arg2 = arg1.getNext();\n-    if (arg2 != null) {\n-      if (arg2.getType() == Token.NUMBER) {\n-        end = (int) arg2.getDouble();\n-      } else {\n-        return n;\n-      }\n-\n-      if (arg2.getNext() != null) {\n-        // If we got more args than we expected, bail out.\n-        return n;\n-      }\n-    } else {\n-      // parameter 2 not passed\n-      end = stringAsString.length();\n-    }\n-\n-    // Don't handle these cases. The specification actually does\n-    // specify the behavior in some of these cases, but we haven't\n-    // done a thorough investigation that it is correctly implemented\n-    // in all browsers.\n-    if ((end > stringAsString.length()) ||\n-        (start > stringAsString.length()) ||\n-        (end < 0) ||\n-        (start < 0)) {\n-      return n;\n-    }\n-\n-    String result = stringAsString.substring(start, end);\n-    Node resultNode = Node.newString(result);\n-\n-    Node parent = n.getParent();\n-    parent.replaceChild(n, resultNode);\n-    reportCodeChange();\n-    return resultNode;\n-  }\n+\n \n   /**\n    * Try to fold array-element. e.g [1, 2, 3][10];\n     reportCodeChange();\n     return n;\n   }\n-}\n+}\n--- /dev/null\n+++ b/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java\n+/*\n+ * Copyright 2011 The Closure Compiler Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.Lists;\n+import com.google.javascript.rhino.Node;\n+import com.google.javascript.rhino.Token;\n+\n+import java.util.List;\n+import java.util.Locale;\n+\n+/**\n+ * Just to fold known methods when they are called with constants.\n+ *\n+ */\n+class PeepholeReplaceKnownMethods extends AbstractPeepholeOptimization{\n+\n+  // The LOCALE independent \"locale\"\n+  private static final Locale ROOT_LOCALE = new Locale(\"\");\n+\n+  @Override\n+  Node optimizeSubtree(Node subtree) {\n+    if (NodeUtil.isCall(subtree) ){\n+      return tryFoldKnownMethods(subtree);\n+    }\n+    return subtree;\n+  }\n+\n+  private Node tryFoldKnownMethods(Node subtree) {\n+    // For now we only support string methods .join(),\n+    // .indexOf(), .substring() and .substr()\n+    // and numeric methods parseInt() and parseFloat().\n+\n+    subtree = tryFoldArrayJoin(subtree);\n+\n+    if (subtree.getType() == Token.CALL) {\n+      Node callTarget = subtree.getFirstChild();\n+      if (callTarget == null) {\n+        return subtree;\n+      }\n+\n+      if (NodeUtil.isGet(callTarget)) {\n+        subtree = tryFoldKnownStringMethods(subtree);\n+      } else {\n+        subtree = tryFoldKnownNumericMethods(subtree);\n+      }\n+    }\n+\n+    return subtree;\n+  }\n+\n+  /**\n+   * Try to evaluate known String methods\n+   *    .indexOf(), .substr(), .substring()\n+   */\n+  private Node tryFoldKnownStringMethods(Node subtree) {\n+    Preconditions.checkArgument(subtree.getType() == Token.CALL);\n+\n+    // check if this is a call on a string method\n+    // then dispatch to specific folding method.\n+    Node callTarget = subtree.getFirstChild();\n+    if (callTarget == null) {\n+      return subtree;\n+    }\n+\n+    if (!NodeUtil.isGet(callTarget)) {\n+      return subtree;\n+    }\n+\n+    Node stringNode = callTarget.getFirstChild();\n+    Node functionName = stringNode.getNext();\n+\n+    if ((stringNode.getType() != Token.STRING) ||\n+        (functionName.getType() != Token.STRING)) {\n+      return subtree;\n+    }\n+\n+    String functionNameString = functionName.getString();\n+    Node firstArg = callTarget.getNext();\n+    if (firstArg == null) {\n+      if (functionNameString.equals(\"toLowerCase\")) {\n+        subtree = tryFoldStringToLowerCase(subtree, stringNode);\n+      } else if (functionNameString.equals(\"toUpperCase\")) {\n+        subtree = tryFoldStringToUpperCase(subtree, stringNode);\n+      }\n+      return subtree;\n+    } else if (NodeUtil.isImmutableValue(firstArg)) {\n+      if (functionNameString.equals(\"indexOf\") ||\n+          functionNameString.equals(\"lastIndexOf\")) {\n+        subtree = tryFoldStringIndexOf(subtree, functionNameString,\n+            stringNode, firstArg);\n+      } else if (functionNameString.equals(\"substr\")) {\n+        subtree = tryFoldStringSubstr(subtree, stringNode, firstArg);\n+      } else if (functionNameString.equals(\"substring\")) {\n+        subtree = tryFoldStringSubstring(subtree, stringNode, firstArg);\n+      }\n+    }\n+\n+    return subtree;\n+  }\n+\n+  /**\n+   * Try to evaluate known Numeric methods\n+   *    .parseInt(), parseFloat()\n+   */\n+  private Node tryFoldKnownNumericMethods(Node subtree) {\n+    Preconditions.checkArgument(subtree.getType() == Token.CALL);\n+\n+    if (isASTNormalized()) {\n+      // check if this is a call on a string method\n+      // then dispatch to specific folding method.\n+      Node callTarget = subtree.getFirstChild();\n+\n+      if (!NodeUtil.isName(callTarget)) {\n+        return subtree;\n+      }\n+\n+      String functionNameString = callTarget.getString();\n+      Node firstArgument = callTarget.getNext();\n+      if ((firstArgument != null) &&\n+          (firstArgument.getType() == Token.STRING ||\n+           firstArgument.getType() == Token.NUMBER)) {\n+        if (functionNameString.equals(\"parseInt\") ||\n+            functionNameString.equals(\"parseFloat\")) {\n+          subtree = tryFoldParseNumber(subtree, functionNameString,\n+              firstArgument);\n+        }\n+      }\n+    }\n+    return subtree;\n+  }\n+\n+  /**\n+   * @return The lowered string Node.\n+   */\n+  private Node tryFoldStringToLowerCase(Node subtree, Node stringNode) {\n+    // From Rhino, NativeString.java. See ECMA 15.5.4.11\n+    String lowered = stringNode.getString().toLowerCase(ROOT_LOCALE);\n+    Node replacement = Node.newString(lowered);\n+    subtree.getParent().replaceChild(subtree, replacement);\n+    reportCodeChange();\n+    return replacement;\n+  }\n+\n+  /**\n+   * @return The uppered string Node.\n+   */\n+  private Node tryFoldStringToUpperCase(Node subtree, Node stringNode) {\n+    // From Rhino, NativeString.java. See ECMA 15.5.4.12\n+    String uppered = stringNode.getString().toUpperCase(ROOT_LOCALE);\n+    Node replacement = Node.newString(uppered);\n+    subtree.getParent().replaceChild(subtree, replacement);\n+    reportCodeChange();\n+    return replacement;\n+  }\n+\n+  /**\n+   * @param input string representation of a number\n+   * @return string with leading and trailing zeros removed\n+   */\n+  private String normalizeNumericString(String input) {\n+    if (input == null || input.length() == 0) {\n+      return input;\n+    }\n+\n+    int startIndex = 0, endIndex = input.length() - 1;\n+    while (startIndex < input.length() && input.charAt(startIndex) == '0') {\n+      startIndex++;\n+    }\n+    while (endIndex >= 0 && input.charAt(endIndex) == '0') {\n+      endIndex--;\n+    }\n+    if (startIndex >= endIndex) {\n+      return input;\n+    }\n+\n+    return input.substring(startIndex, endIndex + 1);\n+  }\n+\n+  /**\n+   * Try to evaluate parseInt, parseFloat:\n+   *     parseInt(\"1\") -> 1\n+   *     parseInt(\"1\", 10) -> 1\n+   *     parseFloat(\"1.11\") -> 1.11\n+   */\n+  private Node tryFoldParseNumber(\n+      Node n, String functionName, Node firstArg) {\n+    Preconditions.checkArgument(n.getType() == Token.CALL);\n+\n+    boolean isParseInt = functionName.equals(\"parseInt\");\n+    Node secondArg = firstArg.getNext();\n+\n+    // Second argument is only used as the radix for parseInt\n+    int radix = 0;\n+    if (secondArg != null) {\n+      if (!isParseInt) {\n+        return n;\n+      }\n+\n+      // Third-argument and non-numeric second arg are problematic. Discard.\n+      if ((secondArg.getNext() != null) ||\n+          (secondArg.getType() != Token.NUMBER)) {\n+        return n;\n+      } else {\n+        double tmpRadix = secondArg.getDouble();\n+        if (tmpRadix != (int)tmpRadix)\n+          return n;\n+        radix = (int)tmpRadix;\n+        if (radix < 0 || radix == 1 || radix > 36) {\n+          return n;\n+        }\n+      }\n+    }\n+\n+    // stringVal must be a valid string.\n+    String stringVal = null;\n+    Double checkVal;\n+    if (firstArg.getType() == Token.NUMBER) {\n+      checkVal = NodeUtil.getNumberValue(firstArg);\n+      if (!(radix == 0 || radix == 10) && isParseInt) {\n+        //Convert a numeric first argument to a different base\n+        stringVal = String.valueOf(checkVal.intValue());\n+      } else {\n+        // If parseFloat is called with a numeric argument,\n+        // replace it with just the number.\n+        // If parseInt is called with a numeric first argument and the radix\n+        // is 10 or omitted, just replace it with the number\n+        Node numericNode;\n+        if (isParseInt) {\n+          numericNode = Node.newNumber(checkVal.intValue());\n+        } else {\n+          numericNode = Node.newNumber(checkVal);\n+        }\n+        n.getParent().replaceChild(n, numericNode);\n+        reportCodeChange();\n+        return numericNode;\n+      }\n+    } else {\n+      stringVal = NodeUtil.getStringValue(firstArg);\n+      if (stringVal == null) {\n+        return n;\n+      }\n+\n+      //Check that the string is in a format we can recognize\n+      checkVal = NodeUtil.getStringNumberValue(stringVal);\n+      if (checkVal == null || checkVal == Double.NaN) {\n+        return n;\n+      }\n+\n+      stringVal = NodeUtil.trimJsWhiteSpace(stringVal);\n+    }\n+\n+    Node newNode;\n+    if (isParseInt) {\n+      if (radix == 0 || radix == 16) {\n+        if (stringVal.length() > 1 &&\n+            stringVal.substring(0, 2).equalsIgnoreCase(\"0x\")) {\n+          radix = 16;\n+          stringVal = stringVal.substring(2);\n+        } else if (radix == 0) {\n+          // if a radix is not specified or is 0 and the most\n+          // significant digit is \"0\", the string will parse\n+          // with a radix of 8 on some browsers, so leave\n+          // this case alone. This check does not apply in\n+          // script mode ECMA5 or greater\n+          if (!isEcmaScript5OrGreater() &&\n+              stringVal.substring(0, 1).equals(\"0\")) {\n+            return n;\n+          }\n+\n+          radix = 10;\n+        }\n+      }\n+      int newVal = 0;\n+      try {\n+        newVal = Integer.parseInt(stringVal, radix);\n+      } catch (NumberFormatException e) {\n+        return n;\n+      }\n+\n+      newNode = Node.newNumber(newVal);\n+    } else {\n+      String normalizedNewVal = \"0\";\n+      try {\n+        double newVal = Double.parseDouble(stringVal);\n+        newNode = Node.newNumber(newVal);\n+        normalizedNewVal = normalizeNumericString(String.valueOf(newVal));\n+      }\n+      catch(NumberFormatException e) {\n+        return n;\n+      }\n+      // Make sure that the parsed number matches the original string\n+      // This prevents rounding differences between the java implementation\n+      // and native script.\n+      if (!normalizeNumericString(stringVal).equals(normalizedNewVal)) {\n+        return n;\n+      }\n+    }\n+\n+    n.getParent().replaceChild(n, newNode);\n+\n+    reportCodeChange();\n+\n+    return newNode;\n+  }\n+\n+  /**\n+   * Try to evaluate String.indexOf/lastIndexOf:\n+   *     \"abcdef\".indexOf(\"bc\") -> 1\n+   *     \"abcdefbc\".indexOf(\"bc\", 3) -> 6\n+   */\n+  private Node tryFoldStringIndexOf(\n+      Node n, String functionName, Node lstringNode, Node firstArg) {\n+    Preconditions.checkArgument(n.getType() == Token.CALL);\n+    Preconditions.checkArgument(lstringNode.getType() == Token.STRING);\n+\n+    String lstring = NodeUtil.getStringValue(lstringNode);\n+    boolean isIndexOf = functionName.equals(\"indexOf\");\n+    Node secondArg = firstArg.getNext();\n+    String searchValue = NodeUtil.getStringValue(firstArg);\n+    // searchValue must be a valid string.\n+    if (searchValue == null) {\n+      return n;\n+    }\n+    int fromIndex = isIndexOf ? 0 : lstring.length();\n+    if (secondArg != null) {\n+      // Third-argument and non-numeric second arg are problematic. Discard.\n+      if ((secondArg.getNext() != null) ||\n+          (secondArg.getType() != Token.NUMBER)) {\n+        return n;\n+      } else {\n+        fromIndex = (int) secondArg.getDouble();\n+      }\n+    }\n+    int indexVal = isIndexOf ? lstring.indexOf(searchValue, fromIndex)\n+                             : lstring.lastIndexOf(searchValue, fromIndex);\n+    Node newNode = Node.newNumber(indexVal);\n+    n.getParent().replaceChild(n, newNode);\n+\n+    reportCodeChange();\n+\n+    return newNode;\n+  }\n+\n+  /**\n+   * Try to fold an array join: ['a', 'b', 'c'].join('') -> 'abc';\n+   */\n+  private Node tryFoldArrayJoin(Node n) {\n+    Node callTarget = n.getFirstChild();\n+\n+    if (callTarget == null || !NodeUtil.isGetProp(callTarget)) {\n+      return n;\n+    }\n+\n+    Node right = callTarget.getNext();\n+    if (right != null && !NodeUtil.isImmutableValue(right)) {\n+      return n;\n+    }\n+\n+    Node arrayNode = callTarget.getFirstChild();\n+    Node functionName = arrayNode.getNext();\n+\n+    if ((arrayNode.getType() != Token.ARRAYLIT) ||\n+        !functionName.getString().equals(\"join\")) {\n+      return n;\n+    }\n+\n+    String joinString = (right == null) ? \",\" : NodeUtil.getStringValue(right);\n+    List<Node> arrayFoldedChildren = Lists.newLinkedList();\n+    StringBuilder sb = null;\n+    int foldedSize = 0;\n+    Node prev = null;\n+    Node elem = arrayNode.getFirstChild();\n+    // Merges adjacent String nodes.\n+    while (elem != null) {\n+      if (NodeUtil.isImmutableValue(elem) || elem.getType() == Token.EMPTY) {\n+        if (sb == null) {\n+          sb = new StringBuilder();\n+        } else {\n+          sb.append(joinString);\n+        }\n+        sb.append(NodeUtil.getArrayElementStringValue(elem));\n+      } else {\n+        if (sb != null) {\n+          Preconditions.checkNotNull(prev);\n+          // + 2 for the quotes.\n+          foldedSize += sb.length() + 2;\n+          arrayFoldedChildren.add(\n+              Node.newString(sb.toString()).copyInformationFrom(prev));\n+          sb = null;\n+        }\n+        foldedSize += InlineCostEstimator.getCost(elem);\n+        arrayFoldedChildren.add(elem);\n+      }\n+      prev = elem;\n+      elem = elem.getNext();\n+    }\n+\n+    if (sb != null) {\n+      Preconditions.checkNotNull(prev);\n+      // + 2 for the quotes.\n+      foldedSize += sb.length() + 2;\n+      arrayFoldedChildren.add(\n+          Node.newString(sb.toString()).copyInformationFrom(prev));\n+    }\n+    // one for each comma.\n+    foldedSize += arrayFoldedChildren.size() - 1;\n+\n+    int originalSize = InlineCostEstimator.getCost(n);\n+    switch (arrayFoldedChildren.size()) {\n+      case 0:\n+        Node emptyStringNode = Node.newString(\"\");\n+        n.getParent().replaceChild(n, emptyStringNode);\n+        reportCodeChange();\n+        return emptyStringNode;\n+      case 1:\n+        Node foldedStringNode = arrayFoldedChildren.remove(0);\n+        if (foldedSize > originalSize) {\n+          return n;\n+        }\n+        arrayNode.detachChildren();\n+        if (foldedStringNode.getType() != Token.STRING) {\n+          // If the Node is not a string literal, ensure that\n+          // it is coerced to a string.\n+          Node replacement = new Node(Token.ADD,\n+              Node.newString(\"\").copyInformationFrom(n),\n+              foldedStringNode);\n+          foldedStringNode = replacement;\n+        }\n+        n.getParent().replaceChild(n, foldedStringNode);\n+        reportCodeChange();\n+        return foldedStringNode;\n+      default:\n+        // No folding could actually be performed.\n+        if (arrayFoldedChildren.size() == arrayNode.getChildCount()) {\n+          return n;\n+        }\n+        int kJoinOverhead = \"[].join()\".length();\n+        foldedSize += kJoinOverhead;\n+        foldedSize += (right != null) ? InlineCostEstimator.getCost(right) : 0;\n+        if (foldedSize > originalSize) {\n+          return n;\n+        }\n+        arrayNode.detachChildren();\n+        for (Node node : arrayFoldedChildren) {\n+          arrayNode.addChildToBack(node);\n+        }\n+        reportCodeChange();\n+        break;\n+    }\n+\n+    return n;\n+  }\n+\n+  /**\n+   * Try to fold .substr() calls on strings\n+   */\n+  private Node tryFoldStringSubstr(Node n, Node stringNode, Node arg1) {\n+    Preconditions.checkArgument(n.getType() == Token.CALL);\n+    Preconditions.checkArgument(stringNode.getType() == Token.STRING);\n+\n+    int start, length;\n+    String stringAsString = stringNode.getString();\n+\n+    // TODO(nicksantos): We really need a NodeUtil.getNumberValue\n+    // function.\n+    if (arg1 != null && arg1.getType() == Token.NUMBER) {\n+      start = (int) arg1.getDouble();\n+    } else {\n+      return n;\n+    }\n+\n+    Node arg2 = arg1.getNext();\n+    if (arg2 != null) {\n+      if (arg2.getType() == Token.NUMBER) {\n+        length = (int) arg2.getDouble();\n+      } else {\n+        return n;\n+      }\n+\n+      if (arg2.getNext() != null) {\n+        // If we got more args than we expected, bail out.\n+        return n;\n+      }\n+    } else {\n+      // parameter 2 not passed\n+      length = stringAsString.length() - start;\n+    }\n+\n+    // Don't handle these cases. The specification actually does\n+    // specify the behavior in some of these cases, but we haven't\n+    // done a thorough investigation that it is correctly implemented\n+    // in all browsers.\n+    if ((start + length) > stringAsString.length() ||\n+        (length < 0) ||\n+        (start < 0)) {\n+      return n;\n+    }\n+\n+    String result = stringAsString.substring(start, start + length);\n+    Node resultNode = Node.newString(result);\n+\n+    Node parent = n.getParent();\n+    parent.replaceChild(n, resultNode);\n+    reportCodeChange();\n+    return resultNode;\n+  }\n+\n+  /**\n+   * Try to fold .substring() calls on strings\n+   */\n+  private Node tryFoldStringSubstring(Node n, Node stringNode, Node arg1) {\n+    Preconditions.checkArgument(n.getType() == Token.CALL);\n+    Preconditions.checkArgument(stringNode.getType() == Token.STRING);\n+\n+    int start, end;\n+    String stringAsString = stringNode.getString();\n+\n+    if (arg1 != null && arg1.getType() == Token.NUMBER) {\n+      start = (int) arg1.getDouble();\n+    } else {\n+      return n;\n+    }\n+\n+    Node arg2 = arg1.getNext();\n+    if (arg2 != null) {\n+      if (arg2.getType() == Token.NUMBER) {\n+        end = (int) arg2.getDouble();\n+      } else {\n+        return n;\n+      }\n+\n+      if (arg2.getNext() != null) {\n+        // If we got more args than we expected, bail out.\n+        return n;\n+      }\n+    } else {\n+      // parameter 2 not passed\n+      end = stringAsString.length();\n+    }\n+\n+    // Don't handle these cases. The specification actually does\n+    // specify the behavior in some of these cases, but we haven't\n+    // done a thorough investigation that it is correctly implemented\n+    // in all browsers.\n+    if ((end > stringAsString.length()) ||\n+        (start > stringAsString.length()) ||\n+        (end < 0) ||\n+        (start < 0)) {\n+      return n;\n+    }\n+\n+    String result = stringAsString.substring(start, end);\n+    Node resultNode = Node.newString(result);\n+\n+    Node parent = n.getParent();\n+    parent.replaceChild(n, resultNode);\n+    reportCodeChange();\n+    return resultNode;\n+  }\n+\n+}\n--- a/test/com/google/javascript/jscomp/PeepholeFoldConstantsTest.java\n+++ b/test/com/google/javascript/jscomp/PeepholeFoldConstantsTest.java\n     foldSame(\"x = (new String('a'))[3]\");\n   }\n \n-  public void testStringIndexOf() {\n-    fold(\"x = 'abcdef'.indexOf('b')\", \"x = 1\");\n-    fold(\"x = 'abcdefbe'.indexOf('b', 2)\", \"x = 6\");\n-    fold(\"x = 'abcdef'.indexOf('bcd')\", \"x = 1\");\n-    fold(\"x = 'abcdefsdfasdfbcdassd'.indexOf('bcd', 4)\", \"x = 13\");\n-\n-    fold(\"x = 'abcdef'.lastIndexOf('b')\", \"x = 1\");\n-    fold(\"x = 'abcdefbe'.lastIndexOf('b')\", \"x = 6\");\n-    fold(\"x = 'abcdefbe'.lastIndexOf('b', 5)\", \"x = 1\");\n-\n-    // Both elements must be string. Dont do anything if either one is not\n-    // string.\n-    fold(\"x = 'abc1def'.indexOf(1)\", \"x = 3\");\n-    fold(\"x = 'abcNaNdef'.indexOf(NaN)\", \"x = 3\");\n-    fold(\"x = 'abcundefineddef'.indexOf(undefined)\", \"x = 3\");\n-    fold(\"x = 'abcnulldef'.indexOf(null)\", \"x = 3\");\n-    fold(\"x = 'abctruedef'.indexOf(true)\", \"x = 3\");\n-\n-    // The following testcase fails with JSC_PARSE_ERROR. Hence omitted.\n-    // foldSame(\"x = 1.indexOf('bcd');\");\n-    foldSame(\"x = NaN.indexOf('bcd')\");\n-    foldSame(\"x = undefined.indexOf('bcd')\");\n-    foldSame(\"x = null.indexOf('bcd')\");\n-    foldSame(\"x = true.indexOf('bcd')\");\n-    foldSame(\"x = false.indexOf('bcd')\");\n-\n-    // Avoid dealing with regex or other types.\n-    foldSame(\"x = 'abcdef'.indexOf(/b./)\");\n-    foldSame(\"x = 'abcdef'.indexOf({a:2})\");\n-    foldSame(\"x = 'abcdef'.indexOf([1,2])\");\n-  }\n-\n-  public void testStringJoinAddSparse() {\n-    fold(\"x = [,,'a'].join(',')\", \"x = ',,a'\");\n-  }\n-\n-  public void testStringJoinAdd() {\n-    fold(\"x = ['a', 'b', 'c'].join('')\", \"x = \\\"abc\\\"\");\n-    fold(\"x = [].join(',')\", \"x = \\\"\\\"\");\n-    fold(\"x = ['a'].join(',')\", \"x = \\\"a\\\"\");\n-    fold(\"x = ['a', 'b', 'c'].join(',')\", \"x = \\\"a,b,c\\\"\");\n-    fold(\"x = ['a', foo, 'b', 'c'].join(',')\",\n-        \"x = [\\\"a\\\",foo,\\\"b,c\\\"].join(\\\",\\\")\");\n-    fold(\"x = [foo, 'a', 'b', 'c'].join(',')\",\n-        \"x = [foo,\\\"a,b,c\\\"].join(\\\",\\\")\");\n-    fold(\"x = ['a', 'b', 'c', foo].join(',')\",\n-        \"x = [\\\"a,b,c\\\",foo].join(\\\",\\\")\");\n-\n-    // Works with numbers\n-    fold(\"x = ['a=', 5].join('')\", \"x = \\\"a=5\\\"\");\n-    fold(\"x = ['a', '5'].join(7)\", \"x = \\\"a75\\\"\");\n-\n-    // Works on boolean\n-    fold(\"x = ['a=', false].join('')\", \"x = \\\"a=false\\\"\");\n-    fold(\"x = ['a', '5'].join(true)\", \"x = \\\"atrue5\\\"\");\n-    fold(\"x = ['a', '5'].join(false)\", \"x = \\\"afalse5\\\"\");\n-\n-    // Only optimize if it's a size win.\n-    fold(\"x = ['a', '5', 'c'].join('a very very very long chain')\",\n-         \"x = [\\\"a\\\",\\\"5\\\",\\\"c\\\"].join(\\\"a very very very long chain\\\")\");\n-\n-    // TODO(user): Its possible to fold this better.\n-    foldSame(\"x = ['', foo].join(',')\");\n-    foldSame(\"x = ['', foo, ''].join(',')\");\n-\n-    fold(\"x = ['', '', foo, ''].join(',')\", \"x = [',', foo, ''].join(',')\");\n-    fold(\"x = ['', '', foo, '', ''].join(',')\",\n-         \"x = [',', foo, ','].join(',')\");\n-\n-    fold(\"x = ['', '', foo, '', '', bar].join(',')\",\n-         \"x = [',', foo, ',', bar].join(',')\");\n-\n-    fold(\"x = [1,2,3].join('abcdef')\",\n-         \"x = '1abcdef2abcdef3'\");\n-\n-    fold(\"x = [1,2].join()\", \"x = '1,2'\");\n-    fold(\"x = [null,undefined,''].join(',')\", \"x = ',,'\");\n-    fold(\"x = [null,undefined,0].join(',')\", \"x = ',,0'\");\n-    // This can be folded but we don't currently.\n-    foldSame(\"x = [[1,2],[3,4]].join()\"); // would like: \"x = '1,2,3,4'\"\n-  }\n-\n-  public void testStringJoinAdd_b1992789() {\n-    fold(\"x = ['a'].join('')\", \"x = \\\"a\\\"\");\n-    fold(\"x = [foo()].join('')\", \"x = '' + foo()\");\n-    fold(\"[foo()].join('')\", \"'' + foo()\");\n-  }\n-\n-  public void testFoldStringSubstr() {\n-    fold(\"x = 'abcde'.substr(0,2)\", \"x = 'ab'\");\n-    fold(\"x = 'abcde'.substr(1,2)\", \"x = 'bc'\");\n-    fold(\"x = 'abcde'['substr'](1,3)\", \"x = 'bcd'\");\n-    fold(\"x = 'abcde'.substr(2)\", \"x = 'cde'\");\n-\n-    // we should be leaving negative indexes alone for now\n-    foldSame(\"x = 'abcde'.substr(-1)\");\n-    foldSame(\"x = 'abcde'.substr(1, -2)\");\n-    foldSame(\"x = 'abcde'.substr(1, 2, 3)\");\n-    foldSame(\"x = 'a'.substr(0, 2)\");\n-  }\n-\n-  public void testFoldStringSubstring() {\n-    fold(\"x = 'abcde'.substring(0,2)\", \"x = 'ab'\");\n-    fold(\"x = 'abcde'.substring(1,2)\", \"x = 'b'\");\n-    fold(\"x = 'abcde'['substring'](1,3)\", \"x = 'bc'\");\n-    fold(\"x = 'abcde'.substring(2)\", \"x = 'cde'\");\n-\n-    // we should be leaving negative indexes alone for now\n-    foldSame(\"x = 'abcde'.substring(-1)\");\n-    foldSame(\"x = 'abcde'.substring(1, -2)\");\n-    foldSame(\"x = 'abcde'.substring(1, 2, 3)\");\n-    foldSame(\"x = 'a'.substring(0, 2)\");\n-  }\n-\n   public void testFoldArithmetic() {\n     fold(\"x = 10 + 20\", \"x = 30\");\n     fold(\"x = 2 / 4\", \"x = 0.5\");\n     fold(\"void x()\", \"void x()\");\n   }\n \n-  public void testJoinBug() {\n-    fold(\"var x = [].join();\", \"var x = '';\");\n-    fold(\"var x = [x].join();\", \"var x = '' + x;\");\n-    foldSame(\"var x = [x,y].join();\");\n-    foldSame(\"var x = [x,y,z].join();\");\n-\n-    foldSame(\"shape['matrix'] = [\\n\" +\n-            \"    Number(headingCos2).toFixed(4),\\n\" +\n-            \"    Number(-headingSin2).toFixed(4),\\n\" +\n-            \"    Number(headingSin2 * yScale).toFixed(4),\\n\" +\n-            \"    Number(headingCos2 * yScale).toFixed(4),\\n\" +\n-            \"    0,\\n\" +\n-            \"    0\\n\" +\n-            \"  ].join()\");\n-  }\n-\n-  public void testToUpper() {\n-    fold(\"'a'.toUpperCase()\", \"'A'\");\n-    fold(\"'A'.toUpperCase()\", \"'A'\");\n-    fold(\"'aBcDe'.toUpperCase()\", \"'ABCDE'\");\n-  }\n-\n-  public void testToLower() {\n-    fold(\"'A'.toLowerCase()\", \"'a'\");\n-    fold(\"'a'.toLowerCase()\", \"'a'\");\n-    fold(\"'aBcDe'.toLowerCase()\", \"'abcde'\");\n-  }\n-\n   public void testObjectLiteral() {\n     test(\"(!{})\", \"false\");\n     test(\"(!{a:1})\", \"false\");\n     test(\"(![1])\", \"false\");\n     test(\"(![a])\", \"false\");\n     testSame(\"(![foo()])\");\n-  }\n-\n-  public void testFoldParseNumbers() {\n-    enableNormalize();\n-    enableEcmaScript5(true);\n-\n-    fold(\"x = parseInt('123')\", \"x = 123\");\n-    fold(\"x = parseInt(' 123')\", \"x = 123\");\n-    fold(\"x = parseInt('123', 10)\", \"x = 123\");\n-    fold(\"x = parseInt('0xA')\", \"x = 10\");\n-    fold(\"x = parseInt('0xA', 16)\", \"x = 10\");\n-    fold(\"x = parseInt('07', 8)\", \"x = 7\");\n-    fold(\"x = parseInt('08')\", \"x = 8\");\n-    fold(\"x = parseFloat('1.23')\", \"x = 1.23\");\n-    fold(\"x = parseFloat('1.2300')\", \"x = 1.23\");\n-    fold(\"x = parseFloat(' 0.3333')\", \"x = 0.3333\");\n-\n-    //Mozilla Dev Center test cases\n-    fold(\"x = parseInt(' 0xF', 16)\", \"x = 15\");\n-    fold(\"x = parseInt(' F', 16)\", \"x = 15\");\n-    fold(\"x = parseInt('17', 8)\", \"x = 15\");\n-    fold(\"x = parseInt('015', 10)\", \"x = 15\");\n-    fold(\"x = parseInt('1111', 2)\", \"x = 15\");\n-    fold(\"x = parseInt('12', 13)\", \"x = 15\");\n-    fold(\"x = parseInt(021, 8)\", \"x = 15\");\n-    fold(\"x = parseInt(15.99, 10)\", \"x = 15\");\n-    fold(\"x = parseFloat('3.14')\", \"x = 3.14\");\n-    fold(\"x = parseFloat(3.14)\", \"x = 3.14\");\n-\n-    //Valid calls - unable to fold\n-    foldSame(\"x = parseInt('FXX123', 16)\");\n-    foldSame(\"x = parseInt('15*3', 10)\");\n-    foldSame(\"x = parseInt('15e2', 10)\");\n-    foldSame(\"x = parseInt('15px', 10)\");\n-    foldSame(\"x = parseInt('-0x08')\");\n-    foldSame(\"x = parseInt('1', -1)\");\n-    foldSame(\"x = parseFloat('3.14more non-digit characters')\");\n-    foldSame(\"x = parseFloat('314e-2')\");\n-    foldSame(\"x = parseFloat('0.0314E+2')\");\n-    foldSame(\"x = parseFloat('3.333333333333333333333333')\");\n-\n-    //Invalid calls\n-    foldSame(\"x = parseInt('0xa', 10)\");\n-\n-    enableEcmaScript5(false);\n-    foldSame(\"x = parseInt('08')\");\n   }\n \n   public void testFoldObjectLiteralRef() {\n--- /dev/null\n+++ b/test/com/google/javascript/jscomp/PeepholeReplaceKnownMethodsTest.java\n+/*\n+ * Copyright 2011 The Closure Compiler Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+/**\n+ * Unit tests for {#link {@link PeepholeReplaceKnownMethods}\n+ *\n+ */\n+public class PeepholeReplaceKnownMethodsTest extends CompilerTestCase {\n+\n+  public PeepholeReplaceKnownMethodsTest() {\n+    super(\"\");\n+  }\n+\n+  @Override\n+  public void setUp() {\n+    enableLineNumberCheck(true);\n+  }\n+\n+  @Override\n+  public CompilerPass getProcessor(final Compiler compiler) {\n+    CompilerPass peepholePass = new PeepholeOptimizationsPass(compiler,\n+          new PeepholeReplaceKnownMethods());\n+    return peepholePass;\n+  }\n+\n+  public void testStringIndexOf() {\n+    fold(\"x = 'abcdef'.indexOf('b')\", \"x = 1\");\n+    fold(\"x = 'abcdefbe'.indexOf('b', 2)\", \"x = 6\");\n+    fold(\"x = 'abcdef'.indexOf('bcd')\", \"x = 1\");\n+    fold(\"x = 'abcdefsdfasdfbcdassd'.indexOf('bcd', 4)\", \"x = 13\");\n+\n+    fold(\"x = 'abcdef'.lastIndexOf('b')\", \"x = 1\");\n+    fold(\"x = 'abcdefbe'.lastIndexOf('b')\", \"x = 6\");\n+    fold(\"x = 'abcdefbe'.lastIndexOf('b', 5)\", \"x = 1\");\n+\n+    // Both elements must be string. Dont do anything if either one is not\n+    // string.\n+    fold(\"x = 'abc1def'.indexOf(1)\", \"x = 3\");\n+    fold(\"x = 'abcNaNdef'.indexOf(NaN)\", \"x = 3\");\n+    fold(\"x = 'abcundefineddef'.indexOf(undefined)\", \"x = 3\");\n+    fold(\"x = 'abcnulldef'.indexOf(null)\", \"x = 3\");\n+    fold(\"x = 'abctruedef'.indexOf(true)\", \"x = 3\");\n+\n+    // The following testcase fails with JSC_PARSE_ERROR. Hence omitted.\n+    // foldSame(\"x = 1.indexOf('bcd');\");\n+    foldSame(\"x = NaN.indexOf('bcd')\");\n+    foldSame(\"x = undefined.indexOf('bcd')\");\n+    foldSame(\"x = null.indexOf('bcd')\");\n+    foldSame(\"x = true.indexOf('bcd')\");\n+    foldSame(\"x = false.indexOf('bcd')\");\n+\n+    // Avoid dealing with regex or other types.\n+    foldSame(\"x = 'abcdef'.indexOf(/b./)\");\n+    foldSame(\"x = 'abcdef'.indexOf({a:2})\");\n+    foldSame(\"x = 'abcdef'.indexOf([1,2])\");\n+  }\n+\n+  public void testStringJoinAddSparse() {\n+    fold(\"x = [,,'a'].join(',')\", \"x = ',,a'\");\n+  }\n+\n+  public void testStringJoinAdd() {\n+    fold(\"x = ['a', 'b', 'c'].join('')\", \"x = \\\"abc\\\"\");\n+    fold(\"x = [].join(',')\", \"x = \\\"\\\"\");\n+    fold(\"x = ['a'].join(',')\", \"x = \\\"a\\\"\");\n+    fold(\"x = ['a', 'b', 'c'].join(',')\", \"x = \\\"a,b,c\\\"\");\n+    fold(\"x = ['a', foo, 'b', 'c'].join(',')\",\n+        \"x = [\\\"a\\\",foo,\\\"b,c\\\"].join(\\\",\\\")\");\n+    fold(\"x = [foo, 'a', 'b', 'c'].join(',')\",\n+        \"x = [foo,\\\"a,b,c\\\"].join(\\\",\\\")\");\n+    fold(\"x = ['a', 'b', 'c', foo].join(',')\",\n+        \"x = [\\\"a,b,c\\\",foo].join(\\\",\\\")\");\n+\n+    // Works with numbers\n+    fold(\"x = ['a=', 5].join('')\", \"x = \\\"a=5\\\"\");\n+    fold(\"x = ['a', '5'].join(7)\", \"x = \\\"a75\\\"\");\n+\n+    // Works on boolean\n+    fold(\"x = ['a=', false].join('')\", \"x = \\\"a=false\\\"\");\n+    fold(\"x = ['a', '5'].join(true)\", \"x = \\\"atrue5\\\"\");\n+    fold(\"x = ['a', '5'].join(false)\", \"x = \\\"afalse5\\\"\");\n+\n+    // Only optimize if it's a size win.\n+    fold(\"x = ['a', '5', 'c'].join('a very very very long chain')\",\n+         \"x = [\\\"a\\\",\\\"5\\\",\\\"c\\\"].join(\\\"a very very very long chain\\\")\");\n+\n+    // TODO(user): Its possible to fold this better.\n+    foldSame(\"x = ['', foo].join(',')\");\n+    foldSame(\"x = ['', foo, ''].join(',')\");\n+\n+    fold(\"x = ['', '', foo, ''].join(',')\", \"x = [',', foo, ''].join(',')\");\n+    fold(\"x = ['', '', foo, '', ''].join(',')\",\n+         \"x = [',', foo, ','].join(',')\");\n+\n+    fold(\"x = ['', '', foo, '', '', bar].join(',')\",\n+         \"x = [',', foo, ',', bar].join(',')\");\n+\n+    fold(\"x = [1,2,3].join('abcdef')\",\n+         \"x = '1abcdef2abcdef3'\");\n+\n+    fold(\"x = [1,2].join()\", \"x = '1,2'\");\n+    fold(\"x = [null,undefined,''].join(',')\", \"x = ',,'\");\n+    fold(\"x = [null,undefined,0].join(',')\", \"x = ',,0'\");\n+    // This can be folded but we don't currently.\n+    foldSame(\"x = [[1,2],[3,4]].join()\"); // would like: \"x = '1,2,3,4'\"\n+  }\n+\n+  public void testStringJoinAdd_b1992789() {\n+    fold(\"x = ['a'].join('')\", \"x = \\\"a\\\"\");\n+    fold(\"x = [foo()].join('')\", \"x = '' + foo()\");\n+    fold(\"[foo()].join('')\", \"'' + foo()\");\n+  }\n+\n+  public void testFoldStringSubstr() {\n+    fold(\"x = 'abcde'.substr(0,2)\", \"x = 'ab'\");\n+    fold(\"x = 'abcde'.substr(1,2)\", \"x = 'bc'\");\n+    fold(\"x = 'abcde'['substr'](1,3)\", \"x = 'bcd'\");\n+    fold(\"x = 'abcde'.substr(2)\", \"x = 'cde'\");\n+\n+    // we should be leaving negative indexes alone for now\n+    foldSame(\"x = 'abcde'.substr(-1)\");\n+    foldSame(\"x = 'abcde'.substr(1, -2)\");\n+    foldSame(\"x = 'abcde'.substr(1, 2, 3)\");\n+    foldSame(\"x = 'a'.substr(0, 2)\");\n+  }\n+\n+  public void testFoldStringSubstring() {\n+    fold(\"x = 'abcde'.substring(0,2)\", \"x = 'ab'\");\n+    fold(\"x = 'abcde'.substring(1,2)\", \"x = 'b'\");\n+    fold(\"x = 'abcde'['substring'](1,3)\", \"x = 'bc'\");\n+    fold(\"x = 'abcde'.substring(2)\", \"x = 'cde'\");\n+\n+    // we should be leaving negative indexes alone for now\n+    foldSame(\"x = 'abcde'.substring(-1)\");\n+    foldSame(\"x = 'abcde'.substring(1, -2)\");\n+    foldSame(\"x = 'abcde'.substring(1, 2, 3)\");\n+    foldSame(\"x = 'a'.substring(0, 2)\");\n+  }\n+\n+  public void testJoinBug() {\n+    fold(\"var x = [].join();\", \"var x = '';\");\n+    fold(\"var x = [x].join();\", \"var x = '' + x;\");\n+    foldSame(\"var x = [x,y].join();\");\n+    foldSame(\"var x = [x,y,z].join();\");\n+\n+    foldSame(\"shape['matrix'] = [\\n\" +\n+            \"    Number(headingCos2).toFixed(4),\\n\" +\n+            \"    Number(-headingSin2).toFixed(4),\\n\" +\n+            \"    Number(headingSin2 * yScale).toFixed(4),\\n\" +\n+            \"    Number(headingCos2 * yScale).toFixed(4),\\n\" +\n+            \"    0,\\n\" +\n+            \"    0\\n\" +\n+            \"  ].join()\");\n+  }\n+\n+  public void testToUpper() {\n+    fold(\"'a'.toUpperCase()\", \"'A'\");\n+    fold(\"'A'.toUpperCase()\", \"'A'\");\n+    fold(\"'aBcDe'.toUpperCase()\", \"'ABCDE'\");\n+  }\n+\n+  public void testToLower() {\n+    fold(\"'A'.toLowerCase()\", \"'a'\");\n+    fold(\"'a'.toLowerCase()\", \"'a'\");\n+    fold(\"'aBcDe'.toLowerCase()\", \"'abcde'\");\n+  }\n+\n+  public void testFoldParseNumbers() {\n+    enableNormalize();\n+    enableEcmaScript5(true);\n+\n+    fold(\"x = parseInt('123')\", \"x = 123\");\n+    fold(\"x = parseInt(' 123')\", \"x = 123\");\n+    fold(\"x = parseInt('123', 10)\", \"x = 123\");\n+    fold(\"x = parseInt('0xA')\", \"x = 10\");\n+    fold(\"x = parseInt('0xA', 16)\", \"x = 10\");\n+    fold(\"x = parseInt('07', 8)\", \"x = 7\");\n+    fold(\"x = parseInt('08')\", \"x = 8\");\n+    fold(\"x = parseFloat('1.23')\", \"x = 1.23\");\n+    fold(\"x = parseFloat('1.2300')\", \"x = 1.23\");\n+    fold(\"x = parseFloat(' 0.3333')\", \"x = 0.3333\");\n+\n+    //Mozilla Dev Center test cases\n+    fold(\"x = parseInt(' 0xF', 16)\", \"x = 15\");\n+    fold(\"x = parseInt(' F', 16)\", \"x = 15\");\n+    fold(\"x = parseInt('17', 8)\", \"x = 15\");\n+    fold(\"x = parseInt('015', 10)\", \"x = 15\");\n+    fold(\"x = parseInt('1111', 2)\", \"x = 15\");\n+    fold(\"x = parseInt('12', 13)\", \"x = 15\");\n+    fold(\"x = parseInt(021, 8)\", \"x = 15\");\n+    fold(\"x = parseInt(15.99, 10)\", \"x = 15\");\n+    fold(\"x = parseFloat('3.14')\", \"x = 3.14\");\n+    fold(\"x = parseFloat(3.14)\", \"x = 3.14\");\n+\n+    //Valid calls - unable to fold\n+    foldSame(\"x = parseInt('FXX123', 16)\");\n+    foldSame(\"x = parseInt('15*3', 10)\");\n+    foldSame(\"x = parseInt('15e2', 10)\");\n+    foldSame(\"x = parseInt('15px', 10)\");\n+    foldSame(\"x = parseInt('-0x08')\");\n+    foldSame(\"x = parseInt('1', -1)\");\n+    foldSame(\"x = parseFloat('3.14more non-digit characters')\");\n+    foldSame(\"x = parseFloat('314e-2')\");\n+    foldSame(\"x = parseFloat('0.0314E+2')\");\n+    foldSame(\"x = parseFloat('3.333333333333333333333333')\");\n+\n+    //Invalid calls\n+    foldSame(\"x = parseInt('0xa', 10)\");\n+\n+    enableEcmaScript5(false);\n+    foldSame(\"x = parseInt('08')\");\n+  }\n+\n+  @Override\n+  protected int getNumRepetitions() {\n+    // Reduce this to 2 if we get better expression evaluators.\n+    return 2;\n+  }\n+\n+  private void foldSame(String js) {\n+    testSame(js);\n+  }\n+\n+  private void fold(String js, String expected) {\n+    test(js, expected);\n+  }\n+}", "timestamp": 1308097789, "metainfo": ""}