{"sha": "f6607996d6d3bd6820ce3848d147991b27600a12", "log": "If a property is defined on a global name, but in a local scope, declare that property in the global scope. this goes most of the way towards fixing issue 66.  R=johnlenz DELTA=84  (78 added, 1 deleted, 5 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=219633   ", "commit": "\n--- a/src/com/google/javascript/jscomp/NodeUtil.java\n+++ b/src/com/google/javascript/jscomp/NodeUtil.java\n   }\n \n   /**\n+   * Gets the root node of a qualified name. Must be either NAME or THIS.\n+   */\n+  static Node getRootOfQualifiedName(Node qName) {\n+    for (Node current = qName; true;\n+         current = current.getFirstChild()) {\n+      int type = current.getType();\n+      if (type == Token.NAME || type == Token.THIS) {\n+        return current;\n+      }\n+      Preconditions.checkState(type == Token.GETPROP);\n+    }\n+  }\n+\n+  /**\n    * Sets the debug information (source file info and orignal name)\n    * on the given node.\n    *\n--- a/src/com/google/javascript/jscomp/TypedScopeCreator.java\n+++ b/src/com/google/javascript/jscomp/TypedScopeCreator.java\n       String variableName = n.getQualifiedName();\n       Preconditions.checkArgument(!variableName.isEmpty());\n \n+      // If n is a property, then we should really declare it in the\n+      // scope where the root object appears. This helps out people\n+      // who declare \"global\" names in an anonymous namespace.\n+      Scope scopeToDeclareIn = scope;\n+      if (n.getType() == Token.GETPROP && !scope.isGlobal() &&\n+          isQnameRootedInGlobalScope(n)) {\n+        Scope globalScope = scope.getGlobalScope();\n+\n+        // don't try to declare in the global scope if there's\n+        // already a symbol there with this name.\n+        if (!globalScope.isDeclared(variableName, false)) {\n+          scopeToDeclareIn = scope.getGlobalScope();\n+        }\n+      }\n+\n       // declared in closest scope?\n-      if (scope.isDeclared(variableName, false)) {\n-        Var oldVar = scope.getVar(variableName);\n+      if (scopeToDeclareIn.isDeclared(variableName, false)) {\n+        Var oldVar = scopeToDeclareIn.getVar(variableName);\n         validator.expectUndeclaredVariable(\n             sourceName, n, parent, oldVar, variableName, type);\n       } else {\n           setDeferredType(n, type);\n         }\n         CompilerInput input = compiler.getInput(sourceName);\n-        scope.declare(variableName, n, type, input, inferred);\n+        scopeToDeclareIn.declare(variableName, n, type, input, inferred);\n \n         if (shouldDeclareOnGlobalThis) {\n           ObjectType globalThis =\n \n         // If we're in the global scope, also declare var.prototype\n         // in the scope chain.\n-        if (scope.isGlobal() && type instanceof FunctionType) {\n+        if (scopeToDeclareIn.isGlobal() && type instanceof FunctionType) {\n           FunctionType fnType = (FunctionType) type;\n           if (fnType.isConstructor() || fnType.isInterface()) {\n             FunctionType superClassCtor = fnType.getSuperClassConstructor();\n-            scope.declare(variableName + \".prototype\", n,\n+            scopeToDeclareIn.declare(variableName + \".prototype\", n,\n                 fnType.getPrototype(), compiler.getInput(sourceName),\n                 /* declared iff there's an explicit supertype */\n                 superClassCtor == null ||\n           }\n         }\n       }\n+    }\n+\n+    /**\n+     * Check if the given node is a property of a name in the global scope.\n+     */\n+    private boolean isQnameRootedInGlobalScope(Node n) {\n+      Node root = NodeUtil.getRootOfQualifiedName(n);\n+      if (root.getType() == Token.NAME) {\n+        Var var = scope.getVar(root.getString());\n+        if (var != null) {\n+          return var.isGlobal();\n+        }\n+      }\n+      return false;\n     }\n \n     /**\n--- a/test/com/google/javascript/jscomp/TypeCheckTest.java\n+++ b/test/com/google/javascript/jscomp/TypeCheckTest.java\n         \"Foo.prototype.bar = function() {\" +\n         \"  if (this.x_) { f(this.x_); }\" +\n         \"};\");\n+  }\n+\n+  public void testQualifiedNameInference5() throws Exception {\n+    testTypes(\n+        \"var ns = {}; \" +\n+        \"(function() { \" +\n+        \"    /** @param {number} x */ ns.foo = function(x) {}; })();\" +\n+        \"(function() { ns.foo(true); })();\",\n+        \"actual parameter 1 of ns.foo does not match formal parameter\\n\" +\n+        \"found   : boolean\\n\" +\n+        \"required: number\");\n+  }\n+\n+  public void testQualifiedNameInference6() throws Exception {\n+    testTypes(\n+        \"var ns = {}; \" +\n+        \"/** @param {number} x */ ns.foo = function(x) {};\" +\n+        \"(function() { \" +\n+        \"    ns.foo = function(x) {};\" +\n+        \"    ns.foo(true); })();\",\n+        \"actual parameter 1 of ns.foo does not match formal parameter\\n\" +\n+        \"found   : boolean\\n\" +\n+        \"required: number\");\n   }\n \n   public void testSheqRefinedScope() throws Exception {\n--- a/test/com/google/javascript/jscomp/TypedScopeCreatorTest.java\n+++ b/test/com/google/javascript/jscomp/TypedScopeCreatorTest.java\n         \"{}\", findTokenType(Token.OBJECTLIT, globalScope).toString());\n   }\n \n+  public void testGlobalQualifiedNameInLocalScope() {\n+    testSame(\n+        \"var ns = {}; \" +\n+        \"(function() { \" +\n+        \"    /** @param {number} x */ ns.foo = function(x) {}; })();\" +\n+        \"(function() { ns.foo(3); })();\");\n+    assertNotNull(globalScope.getVar(\"ns.foo\"));\n+    assertEquals(\n+        \"function (number): undefined\",\n+        globalScope.getVar(\"ns.foo\").getType().toString());\n+  }\n+\n   private JSType findNameType(final String name, Scope scope) {\n     return findTypeOnMatchedNode(new Predicate<Node>() {\n       @Override public boolean apply(Node n) {", "timestamp": 1284562236, "metainfo": ""}