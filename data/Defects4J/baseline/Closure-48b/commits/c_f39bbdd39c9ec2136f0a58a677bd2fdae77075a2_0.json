{"sha": "f39bbdd39c9ec2136f0a58a677bd2fdae77075a2", "log": "Fix a nasty bug in collapseproperties. The problem is that the declaration-updater conflates \"can i always collapse this name?\" with \"can i sometimes collapse children of this name?\" There are a few rare cases where they are not equivalent, like if you have /** @constructor */ a.b.c = function() {}; where a is collapsed and a.b.c is collapsed (because constructors are always collapsed), but a.b is not. Fixes issue 389  R=acleung DELTA=140  (112 added, 0 deleted, 28 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=1138   ", "commit": "\n--- a/src/com/google/javascript/jscomp/CollapseProperties.java\n+++ b/src/com/google/javascript/jscomp/CollapseProperties.java\n     boolean canCollapseChildNames = n.canCollapseUnannotatedChildNames();\n \n     // Handle this name first so that nested object literals get unrolled.\n-    if (n.canCollapse() && canCollapseChildNames) {\n-      updateObjLitOrFunctionDeclaration(n, alias);\n+    if (n.canCollapse()) {\n+      updateObjLitOrFunctionDeclaration(n, alias, canCollapseChildNames);\n     }\n \n     if (n.props != null) {\n    * This involves flattening the global name (if it's not just a global\n    * variable name already), collapsing object literal keys into global\n    * variables, declaring stub global variables for properties added later\n-   * in a local scope, and eliminating the global name entirely (if possible).\n+   * in a local scope.\n+   *\n+   * It may seem odd that this function also takes care of declaring stubs\n+   * for direct children. The ultimate goal of this function is to eliminate\n+   * the global name entirely (when possible), so that \"middlemen\" namespaces\n+   * disappear, and to do that we need to make sure that all the direct children\n+   * will be collapsed as well.\n    *\n    * @param n An object representing a global name (e.g. \"a\", \"a.b.c\")\n    * @param alias The flattened name for {@code n} (e.g. \"a\", \"a$b$c\")\n-   */\n-  private void updateObjLitOrFunctionDeclaration(Name n, String alias) {\n+   * @param canCollapseChildNames Whether it's possible to collapse children of\n+   *     this name. (This is mostly passed for convenience; it's equivalent to\n+   *     n.canCollapseChildNames()).\n+   */\n+  private void updateObjLitOrFunctionDeclaration(\n+      Name n, String alias, boolean canCollapseChildNames) {\n+    if (n.declaration == null) {\n+      // Some names do not have declarations, because they\n+      // are only defined in local scopes.\n+      return;\n+    }\n+\n+    if (n.declaration.getTwin() != null) {\n+      // Twin declarations will get handled when normal references\n+      // are handled.\n+      return;\n+    }\n+\n     switch (n.declaration.node.getParent().getType()) {\n       case Token.ASSIGN:\n-        updateObjLitOrFunctionDeclarationAtAssignNode(n, alias);\n+        updateObjLitOrFunctionDeclarationAtAssignNode(\n+            n, alias, canCollapseChildNames);\n         break;\n       case Token.VAR:\n-        updateObjLitOrFunctionDeclarationAtVarNode(n);\n+        updateObjLitOrFunctionDeclarationAtVarNode(n, canCollapseChildNames);\n         break;\n       case Token.FUNCTION:\n-        updateFunctionDeclarationAtFunctionNode(n);\n+        updateFunctionDeclarationAtFunctionNode(n, canCollapseChildNames);\n         break;\n     }\n   }\n    * @param alias The flattened name for {@code n} (e.g. \"a\", \"a$b$c\")\n    */\n   private void updateObjLitOrFunctionDeclarationAtAssignNode(\n-      Name n, String alias) {\n+      Name n, String alias, boolean canCollapseChildNames) {\n     // NOTE: It's important that we don't add additional nodes\n     // (e.g. a var node before the exprstmt) because the exprstmt might be\n     // the child of an if statement that's not inside a block).\n     Node varParent = ref.node.getAncestor(3);\n     Node gramps = ref.node.getAncestor(2);\n     boolean isObjLit = rvalue.getType() == Token.OBJECTLIT;\n+    boolean insertedVarNode = false;\n \n     if (isObjLit && n.canEliminate()) {\n       // Eliminate the object literal altogether.\n       varParent.replaceChild(gramps, varNode);\n       ref.node = null;\n-\n-    } else {\n+      insertedVarNode = true;\n+\n+    } else if (!n.isSimpleName()) {\n+      // Create a VAR node to declare the name.\n       if (rvalue.getType() == Token.FUNCTION) {\n         checkForHosedThisReferences(rvalue, n.docInfo, n);\n       }\n \n       // Update the node ancestry stored in the reference.\n       ref.node = nameNode;\n-    }\n-\n-    if (isObjLit) {\n-      declareVarsForObjLitValues(\n-          n, alias, rvalue,\n-          varNode, varParent.getChildBefore(varNode), varParent);\n-    }\n-\n-    addStubsForUndeclaredProperties(n, alias, varParent, varNode);\n-\n-    if (!varNode.hasChildren()) {\n-      varParent.removeChild(varNode);\n-    }\n-\n-    compiler.reportCodeChange();\n+      insertedVarNode = true;\n+    }\n+\n+    if (canCollapseChildNames) {\n+      if (isObjLit) {\n+        declareVarsForObjLitValues(\n+            n, alias, rvalue,\n+            varNode, varParent.getChildBefore(varNode), varParent);\n+      }\n+\n+      addStubsForUndeclaredProperties(n, alias, varParent, varNode);\n+    }\n+\n+    if (insertedVarNode) {\n+      if (!varNode.hasChildren()) {\n+        varParent.removeChild(varNode);\n+      }\n+      compiler.reportCodeChange();\n+    }\n   }\n \n   /**\n    *\n    * @param n An object representing a global name (e.g. \"a\")\n    */\n-  private void updateObjLitOrFunctionDeclarationAtVarNode(Name n) {\n+  private void updateObjLitOrFunctionDeclarationAtVarNode(\n+      Name n, boolean canCollapseChildNames) {\n+    if (!canCollapseChildNames) {\n+      return;\n+    }\n+\n     Ref ref = n.declaration;\n     String name = ref.node.getString();\n     Node rvalue = ref.node.getFirstChild();\n    *\n    * @param n An object representing a global name (e.g. \"a\")\n    */\n-  private void updateFunctionDeclarationAtFunctionNode(Name n) {\n+  private void updateFunctionDeclarationAtFunctionNode(\n+      Name n, boolean canCollapseChildNames) {\n+    if (!canCollapseChildNames) {\n+      return;\n+    }\n+\n     Ref ref = n.declaration;\n     String fnName = ref.node.getString();\n     addStubsForUndeclaredProperties(\n    */\n   private int addStubsForUndeclaredProperties(\n       Name n, String alias, Node parent, Node addAfter) {\n+    Preconditions.checkState(n.canCollapseUnannotatedChildNames());\n     Preconditions.checkArgument(NodeUtil.isStatementBlock(parent));\n     Preconditions.checkNotNull(addAfter);\n     int numStubs = 0;\n--- a/test/com/google/javascript/jscomp/CollapsePropertiesTest.java\n+++ b/test/com/google/javascript/jscomp/CollapsePropertiesTest.java\n   public void testPropertyOnGlobalFunction() {\n     testSame(\"function Map() {} Map.foo = 3; Map;\");\n   }\n+\n+  public void testIssue389() {\n+    test(\n+        \"function alias() {}\" +\n+        \"var dojo = {};\" +\n+        \"dojo.gfx = {};\" +\n+        \"dojo.declare = function() {};\" +\n+        \"/** @constructor */\" +\n+        \"dojo.gfx.Shape = function() {};\" +\n+        \"dojo.gfx.Shape = dojo.declare('dojo.gfx.Shape');\" +\n+        \"alias(dojo);\",\n+        \"function alias() {}\" +\n+        \"var dojo = {};\" +\n+        \"dojo.gfx = {};\" +\n+        \"dojo.declare = function() {};\" +\n+        \"/** @constructor */\" +\n+        \"var dojo$gfx$Shape = function() {};\" +\n+        \"dojo$gfx$Shape = dojo.declare('dojo.gfx.Shape');\" +\n+        \"alias(dojo);\",\n+        null,\n+        CollapseProperties.UNSAFE_NAMESPACE_WARNING);\n+  }\n+\n+  public void testAliasedTopLevelName() {\n+    testSame(\n+        \"function alias() {}\" +\n+        \"var dojo = {};\" +\n+        \"dojo.gfx = {};\" +\n+        \"dojo.declare = function() {};\" +\n+        \"dojo.gfx.Shape = {SQUARE: 2};\" +\n+        \"dojo.gfx.Shape = dojo.declare('dojo.gfx.Shape');\" +\n+        \"alias(dojo);\" +\n+        \"alias(dojo$gfx$Shape$SQUARE);\");\n+  }\n+\n+  public void testAliasedTopLevelEnum() {\n+    test(\n+        \"function alias() {}\" +\n+        \"var dojo = {};\" +\n+        \"dojo.gfx = {};\" +\n+        \"dojo.declare = function() {};\" +\n+        \"/** @enum {number} */\" +\n+        \"dojo.gfx.Shape = {SQUARE: 2};\" +\n+        \"dojo.gfx.Shape = dojo.declare('dojo.gfx.Shape');\" +\n+        \"alias(dojo);\" +\n+        \"alias(dojo.gfx.Shape.SQUARE);\",\n+        \"function alias() {}\" +\n+        \"var dojo = {};\" +\n+        \"dojo.gfx = {};\" +\n+        \"dojo.declare = function() {};\" +\n+        \"/** @constructor */\" +\n+        \"var dojo$gfx$Shape = {SQUARE: 2};\" +\n+        \"dojo$gfx$Shape = dojo.declare('dojo.gfx.Shape');\" +\n+        \"alias(dojo);\" +\n+        \"alias(dojo$gfx$Shape.SQUARE);\",\n+        null,\n+        CollapseProperties.UNSAFE_NAMESPACE_WARNING);\n+  }\n+\n+  public void testAssignFunctionBeforeDefinition() {\n+    testSame(\n+        \"f = function() {};\" +\n+        \"var f = null;\");\n+  }\n+\n+  public void testObjectLitBeforeDefinition() {\n+    testSame(\n+        \"a = {b: 3};\" +\n+        \"var a = null;\" +\n+        \"this.c = a.b;\");\n+  }\n }", "timestamp": 1301442391, "metainfo": ""}