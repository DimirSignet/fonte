{"sha": "b6e3f5c01de00915df7682dba4e9a7f733630d34", "log": "Shadows variables  R=johnlenz,nicksantos DELTA=580  (531 added, 7 deleted, 42 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=639   ", "commit": "\n--- a/src/com/google/javascript/jscomp/DefaultPassConfig.java\n+++ b/src/com/google/javascript/jscomp/DefaultPassConfig.java\n         options.variableRenaming == VariableRenamingPolicy.LOCAL,\n         preserveAnonymousFunctionNames,\n         options.generatePseudoNames,\n+        /** Shadowing */ false,\n         prevVariableMap,\n         reservedChars,\n         exportedNames);\n--- a/src/com/google/javascript/jscomp/RenameVars.java\n+++ b/src/com/google/javascript/jscomp/RenameVars.java\n import javax.annotation.Nullable;\n \n /**\n- * RenameVars renames all the variables names into short names, to reduce\n- * code size and also to obfuscate the code.\n+ * RenameVars renames all the variables names into short names, to reduce code\n+ * size and also to obfuscate the code.\n  *\n  */\n final class RenameVars implements CompilerPass {\n       ArrayListMultimap.create();\n \n   class Assignment {\n+    // TODO(user): The input seems useless.\n     final CompilerInput input;\n     final String oldName;\n     final int orderOfOccurrence;\n     String newName;\n-    int count;                          // Number of times this is referenced\n+    int count; // Number of times this is referenced\n \n     Assignment(String name, CompilerInput input) {\n       this.input = input;\n   /**\n    * Whether function expression names should be preserved. Typically, for\n    * debugging purposes.\n+   *\n    * @see NameAnonymousFunctions\n    */\n   private boolean preserveFunctionExpressionNames;\n+\n+  private final boolean shouldShadow;\n \n   /** Characters that shouldn't be used in variable names. */\n   private final char[] reservedCharacters;\n \n   /** A prefix to distinguish temporary local names from global names */\n-  private static final String LOCAL_VAR_PREFIX = \"L \";\n-\n-  RenameVars(AbstractCompiler compiler,\n-      String prefix,\n-      boolean localRenamingOnly,\n-      boolean preserveFunctionExpressionNames,\n-      boolean generatePseudoNames,\n+  // TODO(user): No longer needs to be public when shadowing doesn't use it.\n+  public static final String LOCAL_VAR_PREFIX = \"L \";\n+\n+  RenameVars(AbstractCompiler compiler, String prefix,\n+      boolean localRenamingOnly, boolean preserveFunctionExpressionNames,\n+      boolean generatePseudoNames, boolean shouldShadow,\n       VariableMap prevUsedRenameMap,\n       @Nullable char[] reservedCharacters,\n       @Nullable Set<String> reservedNames) {\n     }\n     this.prevUsedRenameMap = prevUsedRenameMap;\n     this.reservedCharacters = reservedCharacters;\n+    this.shouldShadow = shouldShadow;\n     if (reservedNames == null) {\n       this.reservedNames = Sets.newHashSet();\n     } else {\n       }\n \n       // Are we renaming function expression names?\n-      if (preserveFunctionExpressionNames\n-          && var != null\n+      if (preserveFunctionExpressionNames && var != null\n           && NodeUtil.isFunctionExpression(var.getParentNode())) {\n         reservedNames.add(name);\n         return;\n       if (!okToRenameVar(name, local)) {\n         if (local) {\n           // Blindly de-uniquify for the Prototype library for issue 103.\n-          String newName =\n-            MakeDeclaredNamesUnique.ContextualRenameInverter.getOrginalName(\n-                name);\n+          String newName = MakeDeclaredNamesUnique.ContextualRenameInverter\n+              .getOrginalName(name);\n           if (!newName.equals(name)) {\n             n.setString(newName);\n           }\n         incCount(tempName, null);\n         localNameNodes.add(n);\n         n.setString(tempName);\n-      } else if (var != null) {  // Not an extern\n+      } else if (var != null) { // Not an extern\n         // If it's global, increment global count\n         incCount(name, var.input);\n         globalNameNodes.add(n);\n   }\n \n   /**\n-   * Sorts Assignment objects by their count, breaking ties by their\n-   * order of occurrence in the source to ensure a deterministic total\n-   * ordering.\n+   * Sorts Assignment objects by their count, breaking ties by their order of\n+   * occurrence in the source to ensure a deterministic total ordering.\n    */\n   private static final Comparator<Assignment> FREQUENCY_COMPARATOR =\n-    new Comparator<Assignment>() {\n-      public int compare(Assignment a1, Assignment a2) {\n-        if (a1.count != a2.count) {\n-          return a2.count - a1.count;\n-        }\n-        // Break a tie using the order in which the variable first appears in\n-        // the source.\n-        return ORDER_OF_OCCURRENCE_COMPARATOR.compare(a1, a2);\n-      }\n-    };\n+      new Comparator<Assignment>() {\n+    public int compare(Assignment a1, Assignment a2) {\n+      if (a1.count != a2.count) {\n+        return a2.count - a1.count;\n+      }\n+      // Break a tie using the order in which the variable first appears in\n+      // the source.\n+      return ORDER_OF_OCCURRENCE_COMPARATOR.compare(a1, a2);\n+    }\n+  };\n \n   /**\n    * Sorts Assignment objects by the order the variable name first appears in\n    * the source.\n    */\n   private static final Comparator<Assignment> ORDER_OF_OCCURRENCE_COMPARATOR =\n-    new Comparator<Assignment>() {\n-      public int compare(Assignment a1, Assignment a2) {\n-        return a1.orderOfOccurrence - a2.orderOfOccurrence;\n-      }\n-    };\n+      new Comparator<Assignment>() {\n+        public int compare(Assignment a1, Assignment a2) {\n+          return a1.orderOfOccurrence - a2.orderOfOccurrence;\n+        }\n+      };\n \n   @Override\n   public void process(Node externs, Node root) {\n     SortedSet<Assignment> varsByFrequency =\n         new TreeSet<Assignment>(FREQUENCY_COMPARATOR);\n     varsByFrequency.addAll(assignments.values());\n+\n+    if (shouldShadow) {\n+      new ShadowVariables(\n+          compiler, assignments, varsByFrequency, pseudoNameMap).process(\n+              externs, root);\n+    }\n \n     // First try to reuse names from an earlier compilation.\n     if (prevUsedRenameMap != null) {\n         continue;\n       }\n \n-      if (a.oldName.startsWith(LOCAL_VAR_PREFIX) ||\n-          (!externNames.contains(a.oldName) &&\n-           prevNewName.startsWith(prefix))) {\n+      if (a.oldName.startsWith(LOCAL_VAR_PREFIX)\n+          || (!externNames.contains(a.oldName)\n+              && prevNewName.startsWith(prefix))) {\n         reservedNames.add(prevNewName);\n         finalizeNameAssignment(a, prevNewName);\n       }\n         new NameGenerator(reservedNames, prefix, reservedCharacters);\n \n     // Local variables never need a prefix.\n-    NameGenerator localNameGenerator = prefix.isEmpty() ?\n-        globalNameGenerator : new NameGenerator(reservedNames, \"\",\n-        reservedCharacters);\n+    NameGenerator localNameGenerator =\n+        prefix.isEmpty() ? globalNameGenerator : new NameGenerator(\n+            reservedNames, \"\", reservedCharacters);\n \n     // Generated names and the assignments for non-local vars.\n     List<Assignment> pendingAssignments = new ArrayList<Assignment>();\n       // Add k number of Assignment to the set, where k is the number of\n       // generated names of the same length.\n       int len = generatedNamesForAssignments.get(i).length();\n-      for (int j = i;\n-           j < numPendingAssignments &&\n-               generatedNamesForAssignments.get(j).length() == len;\n-           j++) {\n+      for (int j = i; j < numPendingAssignments\n+          && generatedNamesForAssignments.get(j).length() == len; j++) {\n         varsByOrderOfOccurrence.add(pendingAssignments.get(j));\n       }\n \n     renameMap.put(a.oldName, newName);\n \n     // Log the mapping\n-    assignmentLog.append(a.oldName).append(\" => \").append(newName).\n-        append('\\n');\n+    assignmentLog.append(a.oldName).append(\" => \").append(newName).append('\\n');\n   }\n \n   /**\n--- /dev/null\n+++ b/src/com/google/javascript/jscomp/ShadowVariables.java\n+/*\n+ * Copyright 2011 The Closure Compiler Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+import com.google.common.collect.HashMultimap;\n+import com.google.common.collect.Multimap;\n+import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n+import com.google.javascript.jscomp.NodeTraversal.ScopedCallback;\n+import com.google.javascript.jscomp.RenameVars.Assignment;\n+import com.google.javascript.jscomp.Scope.Var;\n+import com.google.javascript.rhino.Node;\n+\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.SortedMap;\n+import java.util.SortedSet;\n+\n+/**\n+ * Tries to compute a list of variables that can shadow a variable in the\n+ * outer scope.\n+ *\n+ * For example:\n+ *\n+ * <code>\n+ * var a = function() {\n+ *   var b = getB();\n+ *   b();\n+ *   return function(y) {};\n+ * };\n+ * </code>\n+ *\n+ * Normally, b would be mapped to variable L0, y would be L1.\n+ *\n+ * Instead we are going to make y shadows L0 in hope of using less variables\n+ * and reusing frequently used local names.\n+ *\n+ */\n+class ShadowVariables implements CompilerPass {\n+\n+  // Keep a map of Upward Referencing name nodes of each scope.\n+  // A name is upward referencing name of a scope if:\n+  //\n+  // 1) It refers to (or defines) a name that is defined in the current\n+  // scope or any scope above the current scope that isn't the\n+  // global scope.\n+  //\n+  // 2) It is a upward referencing name of a child scope of this scope.\n+  //\n+  // Example:\n+  // var x; var y; function foo(a) { function bar(b) { x, a } }\n+  // The upward referencing names in scope 'foo' is bar, b, x and a;\n+  // The key to this map is the root node of the scope.\n+  //\n+  // We can see that for any variable x in the current scope, we can shadow\n+  // a variable y in an outer scope given that y is not a upward referencing\n+  // name of the current scope.\n+\n+  // TODO(user): Maps scope to string instead of Node to string.\n+  // Make sure of scope memorization to minimize scope creation cost.\n+  private final Multimap<Node, String> scopeUpRefMap = HashMultimap.create();\n+\n+  // Maps all local Scope.Var to all of its referencing NAME node\n+  // in any scope.\n+  private final Multimap<Var, Node> varToNameUsage = HashMultimap.create();\n+\n+  private final AbstractCompiler compiler;\n+\n+  // All the information used for renaming.\n+  private final SortedSet<Assignment> varsByFrequency;\n+  private final SortedMap<String, Assignment> assignments;\n+  private final Map<Node, String> pseudoNameMap;\n+\n+  /**\n+   * @param assignments Map of old variable names to its assignment Objects.\n+   * @param varsByFrequency Sorted variable assignments by Frequency.\n+   * @param pseudoNameMap The current psedo name map so this pass can update\n+   *     it accordingly.\n+   */\n+  ShadowVariables(\n+      AbstractCompiler compiler,\n+      SortedMap<String, Assignment> assignments,\n+      SortedSet<Assignment> varsByFrequency,\n+      Map<Node, String> pseudoNameMap) {\n+    this.compiler = compiler;\n+    this.assignments = assignments;\n+    this.varsByFrequency = varsByFrequency;\n+    this.pseudoNameMap = pseudoNameMap;\n+  }\n+\n+\n+  @Override\n+  public void process(Node externs, Node root) {\n+\n+    // The algorithm is divided into two stages:\n+    //\n+    // 1. Information gathering (variable usage, upward referencing)\n+    //\n+    // 2. Tries to find shadows for each variables, updates the\n+    //    variable usage frequency map.\n+    NodeTraversal.traverse(compiler, root, new GatherReferenceInfo());\n+    NodeTraversal.traverse(compiler, root, new DoShadowVariables());\n+  }\n+\n+  private class GatherReferenceInfo extends AbstractPostOrderCallback {\n+    @Override\n+    public void visit(NodeTraversal t, Node n, Node parent) {\n+      // Skipping over non-name nodes and empty function names.\n+      if (!NodeUtil.isReferenceName(n)) {\n+        return;\n+      }\n+\n+      // We focus on shadowing local variables as their name occurs much more\n+      // than global names.\n+      // TODO(user): Alternatively, we could experiment with using a local\n+      // name to shadow a global variable.\n+      if (t.inGlobalScope()) {\n+        return;\n+      }\n+\n+      Var var = t.getScope().getVar(n.getString());\n+      if (var == null) {\n+        // extern name or undefined name.\n+        return;\n+      }\n+\n+      if (var.getScope().isGlobal()) {\n+        // We will not shadow a global variable name.\n+        return;\n+      }\n+\n+      // Using the definition of upward referencing, fill in the map.\n+      if (var.getScope() != t.getScope()) {\n+        for (Scope s = t.getScope();\n+            s != var.getScope() && s.isLocal(); s = s.getParent()) {\n+          scopeUpRefMap.put(s.getRootNode(), var.name);\n+        }\n+      }\n+\n+      if (var.getScope() == t.getScope()) {\n+        scopeUpRefMap.put(t.getScopeRoot(), var.name);\n+      }\n+\n+      // Find in the usage map that tracks a var and all of its usage.\n+      varToNameUsage.put(var, n);\n+    }\n+  }\n+\n+  private class DoShadowVariables extends AbstractPostOrderCallback\n+      implements ScopedCallback {\n+\n+    @Override\n+    public void enterScope(NodeTraversal t) {\n+      Scope s = t.getScope();\n+      if (!s.isLocal()) {\n+        return;\n+      }\n+\n+      // Since we don't shadow global, there is nothing to be done in the\n+      // first immediate local scope as well.\n+      if (s.getParent().isGlobal()) {\n+        return;\n+      }\n+\n+      for (Iterator<Var> vars = s.getVars(); vars.hasNext();) {\n+        Var var = vars.next();\n+\n+        // Don't shadow variables that is bleed-out to fix an IE bug.\n+        if (var.isBleedingFunction()) {\n+          continue;\n+        }\n+\n+        // Try to look for the best shadow for the current candidate.\n+        Assignment bestShadow = findBestShadow(s, var);\n+        if (bestShadow == null) {\n+          continue;\n+        }\n+\n+        // The name assignment being shadowed.\n+        Assignment localAssignment = assignments.get(var.getName());\n+\n+        // Only shadow if this increases the number of occurrences of the\n+        // shadowed variable.\n+        if (bestShadow.count < localAssignment.count) {\n+          continue; // Hope the next local variable would have a smaller count.\n+        }\n+\n+        doShadow(localAssignment, bestShadow, var);\n+\n+        if (pseudoNameMap != null) {\n+          String targetPseudoName =\n+            pseudoNameMap.get(s.getVar(bestShadow.oldName).nameNode);\n+          for (Node use : varToNameUsage.get(var)) {\n+            pseudoNameMap.put(use, targetPseudoName);\n+          }\n+        }\n+      }\n+    }\n+\n+    @Override\n+    public void exitScope(NodeTraversal t) {}\n+\n+    @Override\n+    public void visit(NodeTraversal t, Node n, Node parent) {}\n+\n+    /**\n+     * @returns An assignment that can be used as a shadow for a local variable\n+     *     in the scope defined by curScopeRoot.\n+     */\n+    private Assignment findBestShadow(Scope curScope, Var candidate) {\n+      // Search for the candidate starting from the most used local.\n+      TARGET: for (Assignment assignment : varsByFrequency) {\n+        if (assignment.oldName.startsWith(RenameVars.LOCAL_VAR_PREFIX)) {\n+          if (!scopeUpRefMap.get(curScope.getRootNode()).contains(\n+              assignment.oldName)) {\n+            if (curScope.isDeclared(assignment.oldName, true)) {\n+              return assignment;\n+            }\n+          }\n+        }\n+      }\n+      return null;\n+    }\n+\n+    private void doShadow(Assignment original, Assignment toShadow, Var var) {\n+      Scope s = var.getScope();\n+      // We are now shadowing 'bestShadow' with localAssignment.\n+      // All of the reference NAME node of this variable.\n+      Collection<Node> references = varToNameUsage.get(var);\n+\n+      // First remove both assignments from the sorted list since they need\n+      // to be re-sorted.\n+      varsByFrequency.remove(original);\n+      varsByFrequency.remove(toShadow);\n+\n+      // Adjust the count offset by the inner scope variable.\n+      original.count -= references.size();\n+      toShadow.count += references.size();\n+\n+      // Add it back to the sorted list after re-adjustment.\n+      varsByFrequency.add(original);\n+      varsByFrequency.add(toShadow);\n+\n+      // This is an important step. If variable L7 is going to be renamed to\n+      // L1, by definition of upward referencing, The name L1 is now in the\n+      // set of upward referencing names of the current scope up to the\n+      // declaring scope of the best shadow variable.\n+      Var shadowed = s.getVar(toShadow.oldName);\n+      if (shadowed != null) {\n+        for (Scope curScope = s; curScope != shadowed.scope;\n+            curScope = curScope.getParent()) {\n+          scopeUpRefMap.put(curScope.getRootNode(), toShadow.oldName);\n+        }\n+      }\n+\n+      // Mark all the references as shadowed.\n+      for (Node n : references) {\n+        n.setString(toShadow.oldName);\n+        Node cur = n;\n+        while(cur != s.getRootNode()) {\n+          cur = cur.getParent();\n+          if (NodeUtil.isFunction(cur)) {\n+            scopeUpRefMap.put(cur, toShadow.oldName);\n+          }\n+        }\n+      }\n+    }\n+  }\n+}\n--- a/test/com/google/javascript/jscomp/RenameLocalVarsTest.java\n+++ b/test/com/google/javascript/jscomp/RenameLocalVarsTest.java\n   @Override\n   protected CompilerPass getProcessor(Compiler compiler) {\n     return new RenameVars(\n-        compiler, prefix, true, false, false, null, null, null);\n+        compiler, prefix, true, false, false, false, null, null, null);\n   }\n \n   public void testRenameSimple() {\n          \"(function (a, b) {}); (function (a, b) {});\");\n     test(\"function f1(v1, v2) {}; function f2(v3, v4) {};\",\n          \"function f1(a, b) {}; function f2(a, b) {};\");\n-    \n+\n   }\n \n   public void testRenameLocalsClashingWithGlobals() {\n--- a/test/com/google/javascript/jscomp/RenameVarsTest.java\n+++ b/test/com/google/javascript/jscomp/RenameVarsTest.java\n   private boolean preserveFunctionExpressionNames = false;\n   private boolean useGoogleCodingConvention = true;\n   private boolean generatePseudoNames = false;\n+  private boolean shouldShadow = false;\n \n   @Override\n   protected CodingConvention getCodingConvention() {\n     } else {\n       return renameVars = new RenameVars(compiler, prefix,\n           localRenamingOnly, preserveFunctionExpressionNames,\n-          generatePseudoNames,\n+          generatePseudoNames, shouldShadow,\n           previouslyUsedMap, null, null);\n     }\n   }\n     localRenamingOnly = false;\n     preserveFunctionExpressionNames = false;\n     generatePseudoNames = false;\n+    shouldShadow = false;\n \n     // TODO(johnlenz): Enable Normalize during these tests.\n   }\n           new ProcessClosurePrimitives(compiler, CheckLevel.WARNING, true);\n       closurePass.process(externs, root);\n       renameVars = new RenameVars(compiler, prefix,\n-          false, false, false, previouslyUsedMap, null,\n+          false, false, false, false, previouslyUsedMap, null,\n           closurePass.getExportedVariableNames());\n       renameVars.process(externs, root);\n     }\n--- /dev/null\n+++ b/test/com/google/javascript/jscomp/ShadowVariablesTest.java\n+/*\n+ * Copyright 2011 The Closure Compiler Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+/**\n+ * Unit tests for {@link ShadowVariableTest}.\n+ *\n+ *\n+ */\n+public class ShadowVariablesTest extends CompilerTestCase{\n+  // Use psedo names to make test easier to read.\n+  private boolean generatePseudoNames = false;\n+  @Override\n+  protected CompilerPass getProcessor(Compiler compiler) {\n+      return new RenameVars(\n+          compiler, \"\", false, false,\n+          generatePseudoNames, true, null, null, null);\n+  }\n+\n+  @Override\n+  protected int getNumRepetitions() {\n+    return 1;\n+  }\n+\n+  @Override\n+  protected void setUp() throws Exception {\n+    super.setUp();\n+    generatePseudoNames = false;\n+  }\n+\n+  public void testShadowSimple1() {\n+    test(\"function foo(x) { return function (y) {} }\",\n+         \"function   b(a) { return function (a) {} }\");\n+\n+    generatePseudoNames = true;\n+\n+    test(\"function  foo  ( x  ) { return function ( y  ) {} }\",\n+         \"function $foo$$($x$$) { return function ($x$$) {} }\");\n+\n+  }\n+\n+  public void testShadowSimple2() {\n+    test(\"function foo(x,y) { return function (y,z) {} }\",\n+         \"function   c(a,b) { return function (a,b) {} }\");\n+\n+    generatePseudoNames = true;\n+\n+    test(\"function  foo  ( x  , y  ) { return function ( y  , z  ) {} }\",\n+         \"function $foo$$($x$$,$y$$) { return function ($x$$,$y$$) {} }\");\n+  }\n+\n+  /**\n+   * If we have a choice, pick out the most used variable to shadow.\n+   */\n+  public void testShadowMostUsedVar() {\n+    generatePseudoNames = true;\n+    test(\"function  foo  () {var  x  ; var  y  ;  y  ; y  ; y  ; x  ;\" +\n+         \"  return function ( k  ) {} }\",\n+\n+         \"function $foo$$() {var $x$$; var $y$$; $y$$;$y$$;$y$$;$x$$;\" +\n+         \"  return function ($y$$) {} }\");\n+  }\n+\n+  public void testNoShadowReferencedVariables() {\n+    generatePseudoNames = true;\n+    test(\"function  f1  () { var  x  ; x  ; x  ; x  ;\" +\n+         \"  return function  f2  ( y  ) {\" +\n+         \"    return function  f3  () { x  } }}\",\n+         \"function $f1$$() { var $x$$;$x$$;$x$$;$x$$;\" +\n+         \"  return function $f2$$($y$$) {\" +\n+         \"    return function $f3$$() {$x$$} }}\");\n+  }\n+\n+  public void testNoShadowGlobalVariables() {\n+    generatePseudoNames = true;\n+    test(\"var  x  ;  x  ; function  foo  () { return function ( y  ) {}}\",\n+         \"var $x$$; $x$$; function $foo$$() { return function ($y$$) {}}\");\n+  }\n+\n+  public void testShadowBleedInFunctionName() {\n+    generatePseudoNames = true;\n+    test(\"function  foo  () { function  b  ( y  ) { y  }  b  ;  b  ;}\",\n+         \"function $foo$$() { function $b$$($b$$) {$b$$} $b$$; $b$$;}\");\n+   }\n+\n+  public void testNoShadowLessPopularName() {\n+    generatePseudoNames = true;\n+    // We make sure that y doesn't pick x as a shadow and remains to be renamed\n+    // to 'a'.\n+    // If we do shadow y with whatever x renames to (say b) we will\n+    // get 4 b's and 7 a's while currently we get 3 b's and 8 a's.\n+    // I believe this arrangement will always be better for gzipping.\n+    test(\"function  f1  ( x  ) {\" +\n+         \"  function  f2  ( y  ) {}  x  ; x  ;}\" +\n+         \"function  f3  ( i  ) {\" +\n+         \"  var  k  ; var  j  ; j  ; j  ; j  ; j  ; j  ; j  ;}\",\n+\n+         \"function $f1$$($x$$) {\" +\n+         \"  function $f2$$($y$$) {} $x$$;$x$$;}\" +\n+         \"function $f3$$($i$$) {\" +\n+         \"  var $k$$; var $j$$;$j$$;$j$$;$j$$;$j$$;$j$$;$j$$;}\");\n+  }\n+\n+  public void testShadowFunctionName() {\n+    generatePseudoNames = true;\n+    test(\"var  g   = function() {\" +\n+         \"  var  x  ; return function(){function  y  (){}}}\",\n+         \"var $g$$ = function() {\" +\n+         \"  var $x$$; return function(){function $x$$(){}}}\");\n+  }\n+\n+  public void testShadowLotsOfScopes1() {\n+    generatePseudoNames = true;\n+    test(\"var  g   = function( x  ) { return function() { return function() {\" +\n+         \" return function() { var  y   }}}}\",\n+         \"var $g$$ = function($x$$) { return function() { return function() {\" +\n+         \" return function() { var $x$$ }}}}\");\n+  }\n+\n+  public void testShadowLotsOfScopes2() {\n+    generatePseudoNames = true;\n+    // 'y' does't have a candidate to shadow due to upward referencing.\n+    test(\"var  g   = function( x  ) { return function( y  ) \" +\n+         \" {return function() {return function() {  x   }}}}\",\n+         \"var $g$$ = function($x$$) { return function($y$$) \" +\n+         \" {return function() {return function() { $x$$ }}}}\");\n+\n+    test(\"var  g   = function( x  ) { return function() \" +\n+        \" {return function( y  ) {return function() {  x   }}}}\",\n+        \"var $g$$ = function($x$$) { return function() \" +\n+        \" {return function($y$$) {return function() { $x$$ }}}}\");\n+\n+    test(\"var  g   = function( x  ) { return function() \" +\n+        \" {return function() {return function( y  ) {  x   }}}}\",\n+        \"var $g$$ = function($x$$) { return function() \" +\n+        \" {return function() {return function($y$$) { $x$$ }}}}\");\n+  }\n+\n+  public void testShadowLotsOfScopes3() {\n+    generatePseudoNames = true;\n+    // 'y' does't have a candidate to shadow due to upward referencing.\n+    test(\"var  g   = function( x  ) { return function() \" +\n+        \" {return function() {return function() {  x   }; var  y   }}}\",\n+        \"var $g$$ = function($x$$) { return function() \" +\n+        \" {return function() {return function() { $x$$ }; var $y$$}}}\");\n+    test(\"var  g   = function( x  ) { return function() \" +\n+        \" {return function() {return function() {  x   }}; var  y   }}\",\n+        \"var $g$$ = function($x$$) { return function() \" +\n+        \" {return function() {return function() { $x$$ }}; var $y$$}}\");\n+    test(\"var  g   = function( x  ) { return function() \" +\n+        \" {return function() {return function() {  x   }}}; var  y   }\",\n+        \"var $g$$ = function($x$$) { return function() \" +\n+        \" {return function() {return function() { $x$$ }}}; var $y$$}\");\n+  }\n+\n+  public void testShadowLotsOfScopes4() {\n+    // Make sure we do get the optimal shadowing scheme where\n+    test(\"var g = function(x) { return function() { return function() {\" +\n+         \" return function(){return function(){};var m};var n};var o}}\",\n+         \"var b = function(a) { return function() { return function() {\" +\n+         \" return function(){return function(){};var a};var a};var a}}\");\n+  }\n+\n+  public void testShadowLotsOfScopes5() {\n+    generatePseudoNames = true;\n+    test(\"var  g   = function( x  ) {\" +\n+         \" return function() { return function() {\" +\n+         \" return function() { return function() {\" +\n+         \"      x  }; o  };var  n  };var  o  };var  p  }\",\n+         \"var $g$$ = function($x$$) {\" +\n+         \" return function() { return function() {\" +\n+         \" return function() { return function() {\" +\n+         \"     $x$$};$o$$};var $p$$};var $o$$};var $p$$}\");\n+\n+    test(\"var  g   = function( x  ) {\" +\n+        \" return function() { return function() {\" +\n+        \" return function() { return function() {\" +\n+        \"      x  }; p  };var  n  };var  o  };var  p  }\",\n+        \"var $g$$ = function($x$$) {\" +\n+        \" return function() { return function() {\" +\n+        \" return function() { return function() {\" +\n+        \"     $x$$};$p$$};var $o$$};var $o$$};var $p$$}\");\n+  }\n+\n+  public void testShadowWithShadowAlready() {\n+    test(\"var g = function(x) { return function() { return function() {\" +\n+         \" return function(){return function(){x}};var p};var o};var p}\",\n+         \"var c = function(b) { return function() { return function() {\" +\n+         \" return function(){return function(){b}};var a};var a};var a}\");\n+\n+    test(\"var g = function(x) { return function() { return function() {\" +\n+         \" return function(){return function(){x};p};var p};var o};var p}\",\n+         \"var c = function(b) { return function() { return function() {\" +\n+         \" return function(){return function(){b};a};var a};var a};var a}\");\n+  }\n+\n+  public void testShadowBug1() {\n+    generatePseudoNames = true;\n+    test(\"function  f  ( x  ) { return function( y  ) {\" +\n+         \"    return function( x  ) {  x   +  y  ; }}}\",\n+         \"function $f$$($x$$) { return function($y$$) {\" +\n+         \"    return function($x$$) { $x$$ + $y$$; }}}\");\n+  }\n+\n+  public void testOptimal() {\n+    // A test for a case that wasn't optimal in a single pass algorithm.\n+    test(\"function f(x) { function g(y) { function h(x) {}}}\",\n+         \"function c(a) { function b(a) { function b(a) {}}}\");\n+  }\n+\n+  public void testSharingAcrossInnerScopes() {\n+    test(\"function f() {var f=function g(){g()}; var x=function y(){y()}}\",\n+         \"function c() {var d=function a(){a()}; var e=function b(){b()}}\");\n+    test(\"function f(x) { return x ? function(y){} : function(z) {} }\",\n+         \"function b(a) { return a ? function(a){} : function(a) {} }\");\n+\n+  }\n+}", "timestamp": 1298415486, "metainfo": ""}