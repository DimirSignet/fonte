{"sha": "9a10c240033a531f462312c0af96e0af901f63fc", "log": "define a natural ordering of symbols, for when order matters  R=acleung DELTA=102  (96 added, 0 deleted, 6 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=3424   ", "commit": "\n--- a/src/com/google/javascript/jscomp/SymbolTable.java\n+++ b/src/com/google/javascript/jscomp/SymbolTable.java\n import com.google.common.collect.Iterables;\n import com.google.common.collect.Lists;\n import com.google.common.collect.Maps;\n+import com.google.common.collect.Ordering;\n import com.google.common.collect.Sets;\n import com.google.common.collect.Table;\n import com.google.javascript.rhino.JSDocInfo;\n     return Collections.unmodifiableCollection(symbols.values());\n   }\n \n+  /**\n+   * Gets the 'natural' ordering of symbols.\n+   *\n+   * Right now, we only guarantee that symbols in the global scope will come\n+   * before symbols in local scopes. After that, the order is deterministic but\n+   * undefined.\n+   */\n+  public Ordering<Symbol> getNaturalSymbolOrdering() {\n+    return SYMBOL_ORDERING;\n+  }\n+\n   @Override\n   public SymbolScope getScope(Symbol slot) {\n     return slot.scope;\n     private final SymbolScope parent;\n     private final JSType typeOfThis;\n     private final Map<String, Symbol> ownSymbols = Maps.newHashMap();\n+    private final int scopeDepth;\n \n     SymbolScope(\n         Node rootNode,\n       this.rootNode = rootNode;\n       this.parent = parent;\n       this.typeOfThis = typeOfThis;\n+      this.scopeDepth = parent == null ? 0 : (parent.getScopeDepth() + 1);\n     }\n \n     @Override\n \n     public boolean isLexicalScope() {\n       return getRootNode() != null;\n+    }\n+\n+    public int getScopeDepth() {\n+      return scopeDepth;\n     }\n   }\n \n       }\n     }\n   }\n+\n+  // Comparators\n+  private final Ordering<String> SOURCE_NAME_ORDERING =\n+      Ordering.natural().nullsFirst();\n+\n+  private final Ordering<Node> NODE_ORDERING = new Ordering<Node>() {\n+    @Override\n+    public int compare(Node a, Node b) {\n+      int result = SOURCE_NAME_ORDERING.compare(a.getSourceFileName(), b.getSourceFileName());\n+      if (result != 0) {\n+        return result;\n+      }\n+\n+      return a.getSourcePosition() - b.getSourcePosition();\n+    }\n+  };\n+\n+  private final Ordering<Symbol> SYMBOL_ORDERING = new Ordering<Symbol>() {\n+    @Override\n+    public int compare(Symbol a, Symbol b) {\n+      SymbolScope scopeA = getScope(a);\n+      SymbolScope scopeB = getScope(b);\n+      int result = scopeA.getScopeDepth() - scopeB.getScopeDepth();\n+      if (result != 0) {\n+        return result;\n+      }\n+\n+      if (scopeA.isLexicalScope() && !scopeB.isLexicalScope()) {\n+        return -1;\n+      }\n+\n+      if (scopeB.isLexicalScope() && !scopeA.isLexicalScope()) {\n+        return 1;\n+      }\n+\n+      return NODE_ORDERING.compare(\n+          a.getDeclaration().getNode(),  b.getDeclaration().getNode());\n+    }\n+  };\n }\n--- a/test/com/google/javascript/jscomp/SymbolTableTest.java\n+++ b/test/com/google/javascript/jscomp/SymbolTableTest.java\n \n import com.google.common.collect.Iterables;\n import com.google.common.collect.Lists;\n+import com.google.common.collect.Ordering;\n import com.google.javascript.jscomp.SymbolTable.Reference;\n import com.google.javascript.jscomp.SymbolTable.Symbol;\n import com.google.javascript.jscomp.SymbolTable.SymbolScope;\n     assertEquals(\"?\", xNumber.getType().toString());\n   }\n \n+  public void testNaturalSymbolOrdering() {\n+    SymbolTable table = createSymbolTable(\n+        \"/** @const */ var a = {};\" +\n+        \"/** @const */ a.b = {};\" +\n+        \"/** @param {number} x */ function f(x) {}\");\n+    Symbol a = getGlobalVar(table, \"a\");\n+    Symbol ab = getGlobalVar(table, \"a.b\");\n+    Symbol f = getGlobalVar(table, \"f\");\n+    Symbol x = getLocalVar(table, \"x\");\n+    Ordering<Symbol> ordering = table.getNaturalSymbolOrdering();\n+    assertSymmetricOrdering(ordering, a, ab);\n+    assertSymmetricOrdering(ordering, a, f);\n+    assertSymmetricOrdering(ordering, ab, f);\n+    assertSymmetricOrdering(ordering, f, x);\n+  }\n+\n+  private void assertSymmetricOrdering(\n+      Ordering<Symbol> ordering, Symbol first, Symbol second) {\n+    assertTrue(ordering.compare(first, first) == 0);\n+    assertTrue(ordering.compare(second, second) == 0);\n+    assertTrue(ordering.compare(first, second) < 0);\n+    assertTrue(ordering.compare(second, first) > 0);\n+  }\n+\n   private Symbol getGlobalVar(SymbolTable table, String name) {\n     return table.getGlobalScope().getSlot(name);\n   }", "timestamp": 1318008409, "metainfo": ""}