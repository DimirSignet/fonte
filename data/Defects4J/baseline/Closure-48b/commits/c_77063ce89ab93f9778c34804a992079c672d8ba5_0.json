{"sha": "77063ce89ab93f9778c34804a992079c672d8ba5", "log": "Move reflection-detecting code into SimpleDefinitionFinder  R=johnlenz DELTA=115  (62 added, 45 deleted, 8 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=1508   ", "commit": "\n--- a/src/com/google/javascript/jscomp/OptimizeParameters.java\n+++ b/src/com/google/javascript/jscomp/OptimizeParameters.java\n     }\n \n     // Assume an exported method result is used.\n-    if (SimpleDefinitionFinder.maybeExported(compiler, definition)) {\n+    if (!defFinder.canModifyDefinition(definition)) {\n       return false;\n     }\n \n--- a/src/com/google/javascript/jscomp/OptimizeReturns.java\n+++ b/src/com/google/javascript/jscomp/OptimizeReturns.java\n       return true;\n     }\n \n-    // Assume an exported method result is used.\n-    if (SimpleDefinitionFinder.maybeExported(compiler, definition)) {\n+    if (!defFinder.canModifyDefinition(definition)) {\n       return true;\n     }\n \n     Collection<UseSite> useSites = defFinder.getUseSites(definition);\n-\n-    // Don't modify unused definitions for two reasons:\n-    // 1) It causes unnecessary churn\n-    // 2) Other definitions might be used to reflect on this one using\n-    //    goog.reflect.object (the check for definitions with uses is below).\n-    if (useSites.isEmpty()) {\n-      return true;\n-    }\n-\n     for (UseSite site : useSites) {\n-      // This catches the case where an object literal in goog.reflect.object\n-      // and a prototype method have the same property name.\n-\n-      // TODO(johnlenz): The keys of one object can be used to reflect on\n-      // another using \"goog.reflect.object\" or similar.  It seems like this\n-      // should be prohibited but TrogEdit uses this.\n-\n-      Node nameNode = site.node;\n-      Collection<Definition> singleSiteDefinitions =\n-          defFinder.getDefinitionsReferencedAt(nameNode);\n-      if (singleSiteDefinitions.size() > 1) {\n-        return true;\n-      }\n-\n       // Assume indirect definitions references use the result\n       Node useNodeParent = site.node.getParent();\n       if (isCall(site)) {\n--- a/src/com/google/javascript/jscomp/RemoveUnusedVars.java\n+++ b/src/com/google/javascript/jscomp/RemoveUnusedVars.java\n \n       // Check all the call sites.\n       for (UseSite site : defFinder.getUseSites(definition)) {\n-        if (isModifableCallSite(site)) {\n+        if (isModifiableCallSite(site)) {\n           Node arg = getArgumentForCallOrNewOrDotCall(site, argIndex);\n           // TODO(johnlenz): try to remove parameters with side-effects by\n           // decomposing the call expression.\n       Definition definition = getFunctionDefinition(function);\n \n       for (UseSite site : defFinder.getUseSites(definition)) {\n-        if (isModifableCallSite(site)) {\n+        if (isModifiableCallSite(site)) {\n           Node arg = getArgumentForCallOrNewOrDotCall(site, argIndex);\n           if (arg != null) {\n             Node argParent = arg.getParent();\n     private void tryRemoveAllFollowingArgs(Node function, final int argIndex) {\n       Definition definition = getFunctionDefinition(function);\n       for (UseSite site : defFinder.getUseSites(definition)) {\n-        if (!isModifableCallSite(site)) {\n+        if (!isModifiableCallSite(site)) {\n           continue;\n         }\n         Node arg = getArgumentForCallOrNewOrDotCall(site, argIndex + 1);\n         return false;\n       }\n \n-      // Assume an exported method result is used, and the definition might be\n-      // changed.\n-      if (SimpleDefinitionFinder.maybeExported(compiler, definition)) {\n-        return false;\n-      }\n-\n-      Collection<UseSite> useSites = defFinder.getUseSites(definition);\n-      for (UseSite site : useSites) {\n-        // Multiple definitions prevent rewrite.\n-        // TODO(johnlenz): Allow rewrite all definitions are valid.\n-        Node nameNode = site.node;\n-        Collection<Definition> singleSiteDefinitions =\n-            defFinder.getDefinitionsReferencedAt(nameNode);\n-        if (singleSiteDefinitions.size() > 1) {\n-          return false;\n-        }\n-        Preconditions.checkState(!singleSiteDefinitions.isEmpty());\n-        Preconditions.checkState(singleSiteDefinitions.contains(definition));\n-      }\n-\n-      return true;\n+      return defFinder.canModifyDefinition(definition);\n     }\n \n     /**\n      * @param site The site to inspect\n      * @return Whether the call site is suitable for modification\n      */\n-    private static boolean isModifableCallSite(UseSite site) {\n+    private static boolean isModifiableCallSite(UseSite site) {\n       return SimpleDefinitionFinder.isCallOrNewSite(site)\n           && !NodeUtil.isFunctionObjectApply(site.node.getParent());\n     }\n--- a/src/com/google/javascript/jscomp/SimpleDefinitionFinder.java\n+++ b/src/com/google/javascript/jscomp/SimpleDefinitionFinder.java\n     return NodeUtil.isCallOrNew(call) && call.getFirstChild() == use.node;\n   }\n \n+  boolean canModifyDefinition(Definition definition) {\n+    if (isExported(definition)) {\n+      return false;\n+    }\n+\n+    // Don't modify unused definitions for two reasons:\n+    // 1) It causes unnecessary churn\n+    // 2) Other definitions might be used to reflect on this one using\n+    //    goog.reflect.object (the check for definitions with uses is below).\n+    Collection<UseSite> useSites = getUseSites(definition);\n+    if (useSites.isEmpty()) {\n+      return false;\n+    }\n+\n+    for (UseSite site : useSites) {\n+      // This catches the case where an object literal in goog.reflect.object\n+      // and a prototype method have the same property name.\n+\n+      // NOTE(nicksantos): Maps and trogedit both do this by different\n+      // mechanisms.\n+\n+      Node nameNode = site.node;\n+      Collection<Definition> singleSiteDefinitions =\n+          getDefinitionsReferencedAt(nameNode);\n+      if (singleSiteDefinitions.size() > 1) {\n+        return false;\n+      }\n+\n+      Preconditions.checkState(!singleSiteDefinitions.isEmpty());\n+      Preconditions.checkState(singleSiteDefinitions.contains(definition));\n+    }\n+\n+    return true;\n+  }\n+\n   /**\n    * @return Whether the definition is directly exported.\n    */\n-  static boolean maybeExported(\n-      AbstractCompiler compiler, Definition definition) {\n+  private boolean isExported(Definition definition) {\n     // Assume an exported method result is used.\n     Node lValue = definition.getLValue();\n     if (lValue == null) {\n--- a/test/com/google/javascript/jscomp/CommandLineRunnerTest.java\n+++ b/test/com/google/javascript/jscomp/CommandLineRunnerTest.java\n          \"function f(a) { return a; } f();\");\n   }\n \n+  public void testReflectedMethods() {\n+    args.add(\"--compilation_level=ADVANCED_OPTIMIZATIONS\");\n+    test(\n+        \"/** @constructor */\" +\n+        \"function Foo() {}\" +\n+        \"Foo.prototype.handle = function(x, y) { alert(y); };\" +\n+        \"var x = goog.reflect.object(Foo, {handle: 1});\" +\n+        \"for (var i in x) { x[i].call(x); }\" +\n+        \"window['Foo'] = Foo;\",\n+        \"function a() {}\" +\n+        \"a.prototype.a = function(e, d) { alert(d); };\" +\n+        \"var b = goog.c.b(a, {a: 1}),c;\" +\n+        \"for (c in b) { b[c].call(b); }\" +\n+        \"window.Foo = a;\");\n+  }\n+\n   public void testTypeCheckingOnWithVerbose() {\n     args.add(\"--warning_level=VERBOSE\");\n     test(\"function f(x) { return x; } f();\", TypeCheck.WRONG_ARGUMENT_COUNT);\n--- a/test/com/google/javascript/jscomp/RemoveUnusedVarsTest.java\n+++ b/test/com/google/javascript/jscomp/RemoveUnusedVarsTest.java\n         \"var b = {};\" +\n         \"goog$inherits(b.foo, a)\");\n   }\n+\n+  public void testReflectedMethods() {\n+    this.modifyCallSites = true;\n+    testSame(\n+        \"/** @constructor */\" +\n+        \"function Foo() {}\" +\n+        \"Foo.prototype.handle = function(x, y) { alert(y); };\" +\n+        \"var x = goog.reflect.object(Foo, {handle: 1});\" +\n+        \"for (var i in x) { x[i].call(x); }\" +\n+        \"window['Foo'] = Foo;\");\n+  }\n }", "timestamp": 1303312590, "metainfo": ""}