{"sha": "9bdcfea1676482926734227bf479302182165b2f", "log": "PeepholeReplaceKnownMethods: ('A'.charCodeAt(0)) -> 65 and similarly for str.charAt(#)  R=johnlenz DELTA=100  (98 added, 1 deleted, 1 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=3463   ", "commit": "\n--- a/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java\n+++ b/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java\n         subtree = tryFoldStringSubstr(subtree, stringNode, firstArg);\n       } else if (functionNameString.equals(\"substring\")) {\n         subtree = tryFoldStringSubstring(subtree, stringNode, firstArg);\n+      } else if (functionNameString.equals(\"charAt\")) {\n+        subtree = tryFoldStringCharAt(subtree, stringNode, firstArg);\n+      } else if (functionNameString.equals(\"charCodeAt\")) {\n+        subtree = tryFoldStringCharCodeAt(subtree, stringNode, firstArg);\n       }\n     }\n \n \n       //Check that the string is in a format we can recognize\n       checkVal = NodeUtil.getStringNumberValue(stringVal);\n-      if (checkVal == null || checkVal == Double.NaN) {\n+      if (checkVal == null) {\n         return n;\n       }\n \n     return resultNode;\n   }\n \n+  /**\n+   * Try to fold .charAt() calls on strings\n+   */\n+  private Node tryFoldStringCharAt(Node n, Node stringNode, Node arg1) {\n+    Preconditions.checkArgument(n.getType() == Token.CALL);\n+    Preconditions.checkArgument(stringNode.getType() == Token.STRING);\n+\n+    int index;\n+    String stringAsString = stringNode.getString();\n+\n+    if (arg1 != null && arg1.getType() == Token.NUMBER\n+        && arg1.getNext() == null) {\n+      index = (int) arg1.getDouble();\n+    } else {\n+      return n;\n+    }\n+\n+    if (index < 0 || stringAsString.length() <= index) {\n+      // http://es5.github.com/#x15.5.4.4 says \"\" is returned when index is\n+      // out of bounds but we bail.\n+      return n;\n+    }\n+\n+    Node resultNode = Node.newString(\n+        stringAsString.substring(index, index + 1));\n+    Node parent = n.getParent();\n+    parent.replaceChild(n, resultNode);\n+    reportCodeChange();\n+    return resultNode;\n+  }\n+\n+  /**\n+   * Try to fold .charCodeAt() calls on strings\n+   */\n+  private Node tryFoldStringCharCodeAt(Node n, Node stringNode, Node arg1) {\n+    Preconditions.checkArgument(n.getType() == Token.CALL);\n+    Preconditions.checkArgument(stringNode.getType() == Token.STRING);\n+\n+    int index;\n+    String stringAsString = stringNode.getString();\n+\n+    if (arg1 != null && arg1.getType() == Token.NUMBER\n+        && arg1.getNext() == null) {\n+      index = (int) arg1.getDouble();\n+    } else {\n+      return n;\n+    }\n+\n+    if (index < 0 || stringAsString.length() <= index) {\n+      // http://es5.github.com/#x15.5.4.5 says NaN is returned when index is\n+      // out of bounds but we bail.\n+      return n;\n+    }\n+\n+    Node resultNode = Node.newNumber(stringAsString.charAt(index));\n+    Node parent = n.getParent();\n+    parent.replaceChild(n, resultNode);\n+    reportCodeChange();\n+    return resultNode;\n+  }\n }\n--- a/test/com/google/javascript/jscomp/PeepholeReplaceKnownMethodsTest.java\n+++ b/test/com/google/javascript/jscomp/PeepholeReplaceKnownMethodsTest.java\n     foldSame(\"x = 'a'.substring(0, 2)\");\n   }\n \n+  public void testFoldStringCharAt() {\n+    fold(\"x = 'abcde'.charAt(0)\", \"x = 'a'\");\n+    fold(\"x = 'abcde'.charAt(1)\", \"x = 'b'\");\n+    fold(\"x = 'abcde'.charAt(2)\", \"x = 'c'\");\n+    fold(\"x = 'abcde'.charAt(3)\", \"x = 'd'\");\n+    fold(\"x = 'abcde'.charAt(4)\", \"x = 'e'\");\n+    foldSame(\"x = 'abcde'.charAt(5)\");  // or x = ''\n+    foldSame(\"x = 'abcde'.charAt(-1)\");  // or x = ''\n+    foldSame(\"x = 'abcde'.charAt(y)\");\n+    foldSame(\"x = 'abcde'.charAt()\");  // or x = 'a'\n+    foldSame(\"x = 'abcde'.charAt(0, ++z)\");  // or (++z, 'a')\n+    foldSame(\"x = 'abcde'.charAt(null)\");  // or x = 'a'\n+    foldSame(\"x = 'abcde'.charAt(true)\");  // or x = 'b'\n+    fold(\"x = '\\\\ud834\\udd1e'.charAt(0)\", \"x = '\\\\ud834'\");\n+    fold(\"x = '\\\\ud834\\udd1e'.charAt(1)\", \"x = '\\\\udd1e'\");\n+  }\n+\n+  public void testFoldStringCharCodeAt() {\n+    fold(\"x = 'abcde'.charCodeAt(0)\", \"x = 97\");\n+    fold(\"x = 'abcde'.charCodeAt(1)\", \"x = 98\");\n+    fold(\"x = 'abcde'.charCodeAt(2)\", \"x = 99\");\n+    fold(\"x = 'abcde'.charCodeAt(3)\", \"x = 100\");\n+    fold(\"x = 'abcde'.charCodeAt(4)\", \"x = 101\");\n+    foldSame(\"x = 'abcde'.charCodeAt(5)\");  // or x = (0/0)\n+    foldSame(\"x = 'abcde'.charCodeAt(-1)\");  // or x = (0/0)\n+    foldSame(\"x = 'abcde'.charCodeAt(y)\");\n+    foldSame(\"x = 'abcde'.charCodeAt()\");  // or x = 97\n+    foldSame(\"x = 'abcde'.charCodeAt(0, ++z)\");  // or (++z, 97)\n+    foldSame(\"x = 'abcde'.charCodeAt(null)\");  // or x = 97\n+    foldSame(\"x = 'abcde'.charCodeAt(true)\");  // or x = 98\n+    fold(\"x = '\\\\ud834\\udd1e'.charCodeAt(0)\", \"x = 55348\");\n+    fold(\"x = '\\\\ud834\\udd1e'.charCodeAt(1)\", \"x = 56606\");\n+  }\n+\n   public void testJoinBug() {\n     fold(\"var x = [].join();\", \"var x = '';\");\n     fold(\"var x = [x].join();\", \"var x = '' + x;\");", "timestamp": 1318524959, "metainfo": ""}