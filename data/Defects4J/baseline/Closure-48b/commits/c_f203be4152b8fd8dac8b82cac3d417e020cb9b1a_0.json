{"sha": "f203be4152b8fd8dac8b82cac3d417e020cb9b1a", "log": "Part 2: source name/input id splitting. Require an input id on all AST classes and SCRIPT nodes.  R=nicksantos DELTA=112  (95 added, 6 deleted, 11 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=2895   ", "commit": "\n--- a/src/com/google/javascript/jscomp/AstValidator.java\n+++ b/src/com/google/javascript/jscomp/AstValidator.java\n \n package com.google.javascript.jscomp;\n \n+import com.google.javascript.rhino.InputId;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n \n     validateNodeType(Token.SCRIPT, n);\n     validateIsSynthetic(n);\n     validateHasSourceName(n);\n+    validateHasInputId(n);\n     for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n       validateStatement(c);\n     }\n     }\n   }\n \n+  private void validateHasInputId(Node n) {\n+    InputId inputId = n.getInputId();\n+    if (inputId == null) {\n+      violation(\"Missing 'input id' annotation.\", n);\n+    }\n+  }\n+\n   private void validateLabel(Node n) {\n     validateNodeType(Token.LABEL, n);\n     validateChildCount(n, 2);\n--- a/src/com/google/javascript/jscomp/CompilerInput.java\n+++ b/src/com/google/javascript/jscomp/CompilerInput.java\n import com.google.common.collect.Sets;\n import com.google.javascript.jscomp.deps.DependencyInfo;\n import com.google.javascript.jscomp.deps.JsFileParser;\n+import com.google.javascript.rhino.InputId;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n import com.google.javascript.rhino.jstype.StaticSourceFile;\n   // Info about where the file lives.\n   private JSModule module;\n   final private String name;\n+  final private InputId id;\n \n   // The AST.\n   private final SourceAst ast;\n \n   public CompilerInput(SourceAst ast, String inputName, boolean isExtern) {\n     this.ast = ast;\n+    this.id = ast.getInputId();\n     this.name = inputName;\n \n     // TODO(nicksantos): Add a precondition check here. People are passing\n     this(new JsAst(file), file.getName(), isExtern);\n   }\n \n+  /** Returns a id for this input. Must be unique across all inputs. */\n+  @Override\n+  public InputId getInputId() {\n+    return id;\n+  }\n+\n   /** Returns a name for this input. Must be unique across all inputs. */\n   @Override\n   public String getName() {\n \n   @Override\n   public Node getAstRoot(AbstractCompiler compiler) {\n-    return ast.getAstRoot(compiler);\n+    Node root = ast.getAstRoot(compiler);\n+    // The root maybe null if the AST can not be created.\n+    if (root != null) {\n+      Preconditions.checkState(root.getType() == Token.SCRIPT);\n+      Preconditions.checkNotNull(root.getInputId());\n+    }\n+    return root;\n   }\n \n   @Override\n--- a/src/com/google/javascript/jscomp/JsAst.java\n+++ b/src/com/google/javascript/jscomp/JsAst.java\n \n import com.google.javascript.jscomp.parsing.ParserRunner;\n \n+import com.google.javascript.rhino.InputId;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n \n   private static final Logger logger_ = Logger.getLogger(JsAst.class.getName());\n   private static final long serialVersionUID = 1L;\n \n+  private transient InputId inputId;\n   private transient SourceFile sourceFile;\n   private String fileName;\n   private Node root;\n \n   public JsAst(SourceFile sourceFile) {\n+    this.inputId = new InputId(sourceFile.getName());\n     this.sourceFile = sourceFile;\n     this.fileName = sourceFile.getName();\n   }\n   public Node getAstRoot(AbstractCompiler compiler) {\n     if (root == null) {\n       parse(compiler);\n+      root.setInputId(inputId);\n     }\n     return root;\n   }\n     // the assumption that if we're dumping the parse tree, then we probably\n     // assume regenerating everything else is a smart idea also.\n     sourceFile.clearCachedSource();\n+  }\n+\n+  @Override\n+  public InputId getInputId() {\n+    return inputId;\n   }\n \n   @Override\n \n     if (root == null || compiler.hasHaltingErrors()) {\n       // There was a parse error or IOException, so use a dummy block.\n-      root = new Node(Token.BLOCK);\n+      root = new Node(Token.SCRIPT);\n     } else {\n       compiler.prepareAst(root);\n     }\n--- a/src/com/google/javascript/jscomp/SourceAst.java\n+++ b/src/com/google/javascript/jscomp/SourceAst.java\n \n package com.google.javascript.jscomp;\n \n+import com.google.javascript.rhino.InputId;\n import com.google.javascript.rhino.Node;\n \n import java.io.Serializable;\n    */\n   public void clearAst();\n \n+  /** @return The input id associated with this AST */\n+  public InputId getInputId();\n+\n   /** Returns the source file the generated AST represents. */\n   public SourceFile getSourceFile();\n \n--- a/src/com/google/javascript/jscomp/SyntheticAst.java\n+++ b/src/com/google/javascript/jscomp/SyntheticAst.java\n \n package com.google.javascript.jscomp;\n \n+import com.google.javascript.rhino.InputId;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n \n public class SyntheticAst implements SourceAst {\n   private static final long serialVersionUID = 1L;\n \n+  private final InputId inputId;\n   private final SourceFile sourceFile;\n \n   private Node root;\n \n   SyntheticAst(String sourceName) {\n+    this.inputId = new InputId(sourceName);\n     this.sourceFile = new SourceFile(sourceName);\n     clearAst();\n   }\n   @Override\n   public void clearAst() {\n     root = new Node(Token.SCRIPT);\n+    root.setInputId(inputId);\n     root.setIsSyntheticBlock(true);\n     root.setStaticSourceFile(sourceFile);\n+  }\n+\n+  @Override\n+  public InputId getInputId() {\n+    return inputId;\n   }\n \n   @Override\n--- a/src/com/google/javascript/jscomp/jsonml/JsonMLAst.java\n+++ b/src/com/google/javascript/jscomp/jsonml/JsonMLAst.java\n import com.google.javascript.jscomp.AstValidator;\n import com.google.javascript.jscomp.SourceAst;\n import com.google.javascript.jscomp.SourceFile;\n+import com.google.javascript.rhino.InputId;\n import com.google.javascript.rhino.Node;\n \n import java.util.ArrayDeque;\n   private Node root;\n \n   private final SourceFile sourceFile;\n+  private final InputId inputId;\n \n   public JsonMLAst(JsonML jsonml) {\n     this.jsonml = jsonml;\n+    this.inputId = new InputId(getSourceName());\n     this.sourceFile = new SourceFile(getSourceName());\n   }\n \n     translator.setRootElement(jsonml);\n     try {\n       root = translator.parse(compiler);\n+      root.setInputId(inputId);\n       root.setStaticSourceFile(sourceFile);\n       new AstValidator().validateScript(root);\n     } catch (JsonMLException e) {\n       this.childno = childno;\n     }\n   }\n+\n+  @Override\n+  public InputId getInputId() {\n+    return inputId;\n+  }\n }\n--- a/test/com/google/javascript/jscomp/AstValidatorTest.java\n+++ b/test/com/google/javascript/jscomp/AstValidatorTest.java\n package com.google.javascript.jscomp;\n \n import com.google.javascript.jscomp.AstValidator.ViolationHandler;\n+import com.google.javascript.rhino.InputId;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n \n     expectInvalid(n, Check.SCRIPT);\n     n.setIsSyntheticBlock(true);\n     expectInvalid(n, Check.SCRIPT);\n+    n.setInputId(new InputId(\"something_input\"));\n     n.putProp(Node.SOURCENAME_PROP, \"something\");\n     expectValid(n, Check.SCRIPT);\n     expectInvalid(n, Check.STATEMENT);\n--- a/test/com/google/javascript/jscomp/CodePrinterTest.java\n+++ b/test/com/google/javascript/jscomp/CodePrinterTest.java\n package com.google.javascript.jscomp;\n \n import com.google.javascript.jscomp.CompilerOptions.LanguageMode;\n+import com.google.javascript.rhino.InputId;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n \n       DefaultPassConfig passConfig = new DefaultPassConfig(null);\n       CompilerPass typeResolver = passConfig.resolveTypes.create(compiler);\n       Node externs = new Node(Token.SCRIPT);\n+      externs.setInputId(new InputId(\"externs\"));\n       externs.setIsSyntheticBlock(true);\n       Node externAndJsRoot = new Node(Token.BLOCK, externs, n);\n       externAndJsRoot.setIsSyntheticBlock(true);\n--- a/test/com/google/javascript/jscomp/GlobalVarReferenceMapTest.java\n+++ b/test/com/google/javascript/jscomp/GlobalVarReferenceMapTest.java\n import com.google.javascript.jscomp.ReferenceCollectingCallback.Reference;\n import com.google.javascript.jscomp.ReferenceCollectingCallback.ReferenceCollection;\n import com.google.javascript.jscomp.Scope.Var;\n+import com.google.javascript.rhino.InputId;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n import com.google.javascript.rhino.jstype.ObjectType;\n public class GlobalVarReferenceMapTest extends TestCase {\n \n   private static final CompilerInput INPUT1 =\n-      new CompilerInput(null, \"input1\", false);\n+      new CompilerInput(JSSourceFile.fromCode(\"input1\", \"\"), false);\n   private static final CompilerInput INPUT2 =\n-      new CompilerInput(null, \"input2\", false);\n+      new CompilerInput(JSSourceFile.fromCode(\"input2\", \"\"), false);\n   private static final CompilerInput INPUT3 =\n-      new CompilerInput(null, \"input3\", false);\n+      new CompilerInput(JSSourceFile.fromCode(\"input3\", \"\"), false);\n   private static final CompilerInput EXTERN1 =\n-    new CompilerInput(null, \"extern1\", true);\n+    new CompilerInput(JSSourceFile.fromCode(\"externs1\", \"\"), true);\n \n   private final GlobalVarReferenceMap map = new GlobalVarReferenceMap(\n       Lists.newArrayList(INPUT1, INPUT2, INPUT3), Lists.newArrayList(EXTERN1));\n   private final Map<Var, ReferenceCollection> globalMap = Maps.newHashMap();\n   private final Node root = new Node(Token.BLOCK);\n   private final Scope globalScope = new Scope(root, (ObjectType) null);\n-  Node scriptRoot = new Node(Token.SCRIPT);\n+  private Node scriptRoot = new Node(Token.SCRIPT);\n \n   // In the initial setUp we have 3 references to var1 (one in each input) and\n   // 2 references to var2 (in first and third inputs), and 2 references to var3\n     globalMap.put(globalScope.getVar(VAR2), var2TempRefs);\n     globalMap.put(globalScope.getVar(VAR3), var3TempRefs);\n     map.updateGlobalVarReferences(globalMap, root);\n+    scriptRoot.setInputId(new InputId(INPUT2.getName()));\n     scriptRoot.putProp(Node.SOURCENAME_PROP, INPUT2.getName());\n   }\n \n--- a/test/com/google/javascript/jscomp/LiveVariableAnalysisTest.java\n+++ b/test/com/google/javascript/jscomp/LiveVariableAnalysisTest.java\n \n import com.google.javascript.jscomp.DataFlowAnalysis.FlowState;\n import com.google.javascript.jscomp.Scope.Var;\n+import com.google.javascript.rhino.InputId;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n \n     src = \"function _FUNCTION(param1, param2){\" + src + \"}\";\n     Node n = compiler.parseTestCode(src).removeFirstChild();\n     Node script = new Node(Token.SCRIPT, n);\n+    script.setInputId(new InputId(\"test\"));\n     assertEquals(0, compiler.getErrorCount());\n     Scope scope = new SyntacticScopeCreator(compiler).createScope(\n         n, new Scope(script, compiler));\n--- a/test/com/google/javascript/jscomp/LooseTypeCheckTest.java\n+++ b/test/com/google/javascript/jscomp/LooseTypeCheckTest.java\n import com.google.common.collect.Lists;\n import com.google.javascript.jscomp.CheckLevel;\n import com.google.javascript.jscomp.Scope.Var;\n+import com.google.javascript.rhino.InputId;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n import com.google.javascript.rhino.jstype.FunctionType;\n   private JSType testNameNode(String name) {\n     Node node = Node.newString(Token.NAME, name);\n     Node parent = new Node(Token.SCRIPT, node);\n-\n-    Node externs = new Node(Token.BLOCK);\n+    parent.setInputId(new InputId(\"code\"));\n+\n+    Node externs = new Node(Token.SCRIPT);\n+    externs.setInputId(new InputId(\"externs\"));\n+\n     Node externAndJsRoot = new Node(Token.BLOCK, externs, parent);\n     externAndJsRoot.setIsSyntheticBlock(true);\n \n--- a/test/com/google/javascript/jscomp/TypeCheckTest.java\n+++ b/test/com/google/javascript/jscomp/TypeCheckTest.java\n import com.google.common.base.Joiner;\n import com.google.common.collect.Lists;\n import com.google.javascript.jscomp.Scope.Var;\n+import com.google.javascript.rhino.InputId;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n import com.google.javascript.rhino.jstype.FunctionType;\n   private JSType testNameNode(String name) {\n     Node node = Node.newString(Token.NAME, name);\n     Node parent = new Node(Token.SCRIPT, node);\n-\n-    Node externs = new Node(Token.BLOCK);\n+    parent.setInputId(new InputId(\"code\"));\n+\n+    Node externs = new Node(Token.SCRIPT);\n+    externs.setInputId(new InputId(\"externs\"));\n+\n     Node externAndJsRoot = new Node(Token.BLOCK, externs, parent);\n     externAndJsRoot.setIsSyntheticBlock(true);\n ", "timestamp": 1312404905, "metainfo": ""}