{"sha": "7faf5924ea9c2ea0910cac2f6be17faa843ccf54", "log": "Resync SVN to perforce. MOE exploded, and we lost a bunch of changelist descriptions. Argh.  Fixes issue 175 Fixes issue 191  Revision created by MOE tool push_codebase. MOE_MIGRATION=   ", "commit": "\n--- a/src/com/google/javascript/jscomp/AliasKeywords.java\n+++ b/src/com/google/javascript/jscomp/AliasKeywords.java\n      * throw. The function throws the object.\n      */\n     private static Node createAliasFunctionNode(String aliasName) {\n-      Node parameterName = Node.newString(Token.NAME, \"t\");\n+      Node parameterName = Node.newString(Token.NAME, \"jscomp_throw_param\");\n       List<Node> parameters = Lists.newArrayList(parameterName.cloneNode());\n       Node throwStatement = new Node(Token.THROW, parameterName);\n       Node body = new Node(Token.BLOCK, throwStatement);\n--- a/src/com/google/javascript/jscomp/CodeChangeHandler.java\n+++ b/src/com/google/javascript/jscomp/CodeChangeHandler.java\n       hasChanged = false;\n     }\n   }\n+\n+  /**\n+   * A change handler that throws an exception if any changes are made.\n+   */\n+  static final class ForbiddenChange implements CodeChangeHandler {\n+    public void reportChange() {\n+      throw new IllegalStateException(\"Code changes forbidden\");\n+    }\n+  }\n }\n--- a/src/com/google/javascript/jscomp/DefaultPassConfig.java\n+++ b/src/com/google/javascript/jscomp/DefaultPassConfig.java\n \n     passes.add(createEmptyPass(\"beforeStandardOptimizations\"));\n \n-    if (!options.replaceStringsFunctionDescriptions.isEmpty()) {\n-      passes.add(replaceStrings);\n-    }\n-\n     if (!options.idGenerators.isEmpty()) {\n       passes.add(replaceIdGenerators);\n     }\n       passes.add(checkConsts);\n     }\n \n+    // ReplaceStrings needs the strings literals to be at in CALL to\n+    // replace them so do this after constants have been inlined.\n+    if (!options.replaceStringsFunctionDescriptions.isEmpty()) {\n+      passes.add(replaceStrings);\n+    }\n+\n     // The Caja library adds properties to Object.prototype, which breaks\n     // most for-in loops.  This adds a check to each loop that skips\n     // any property matching /___$/.\n     protected CompilerPass createInternal(AbstractCompiler compiler) {\n       return new AmbiguateProperties(\n           compiler, options.anonymousFunctionNaming.getReservedCharacters());\n+    }\n+  };\n+\n+  /**\n+   * Mark the point at which the normalized AST assumptions no longer hold.\n+   */\n+  private final PassFactory markUnnormalized =\n+      new PassFactory(\"markUnnormalized\", true) {\n+    @Override\n+    protected CompilerPass createInternal(final AbstractCompiler compiler) {\n+      return new CompilerPass() {\n+        @Override public void process(Node externs, Node root) {\n+          compiler.setUnnormalized();\n+        }\n+      };\n     }\n   };\n \n--- a/src/com/google/javascript/jscomp/MakeDeclaredNamesUnique.java\n+++ b/src/com/google/javascript/jscomp/MakeDeclaredNamesUnique.java\n   private final Renamer rootRenamer;\n \n   MakeDeclaredNamesUnique() {\n-    this.rootRenamer = new ContextualRenamer();\n+    this(new ContextualRenamer());\n   }\n \n   MakeDeclaredNamesUnique(Renamer renamer) {\n     }\n   }\n \n+  /**\n+   * For injecting boilerplate libraries. Leaves global names alone\n+   * and renames local names like InlineRenamer.\n+   */\n+  static class BoilerplateRenamer extends ContextualRenamer {\n+    private final Supplier<String> uniqueIdSupplier;\n+    private final String idPrefix;\n+    \n+    BoilerplateRenamer(\n+        Supplier<String> uniqueIdSupplier,\n+        String idPrefix) {\n+      this.uniqueIdSupplier = uniqueIdSupplier;\n+      this.idPrefix = idPrefix;\n+    }\n+\n+    @Override\n+    public Renamer forChildScope() {\n+      return new InlineRenamer(uniqueIdSupplier, idPrefix, false);\n+    }\n+  }\n+\n }\n--- a/src/com/google/javascript/jscomp/Normalize.java\n+++ b/src/com/google/javascript/jscomp/Normalize.java\n import com.google.common.base.Preconditions;\n import com.google.common.collect.Lists;\n import com.google.common.collect.Maps;\n+import com.google.javascript.jscomp.MakeDeclaredNamesUnique.BoilerplateRenamer;\n import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n import com.google.javascript.jscomp.NodeTraversal.Callback;\n import com.google.javascript.jscomp.Scope.Var;\n import com.google.javascript.rhino.Token;\n \n import java.util.Map;\n-\n \n /**\n  * The goal with this pass is to simplify the other passes,\n \n     // TODO(nicksantos): assertOnChange should only be true if the tree\n     // is normalized.\n+  }\n+\n+  static Node parseAndNormalizeSyntheticCode(\n+      AbstractCompiler compiler, String code, String prefix) {\n+    Node js = compiler.parseSyntheticCode(code);\n+    NodeTraversal.traverse(compiler, js,\n+        new Normalize.NormalizeStatements(compiler, false));\n+    NodeTraversal.traverse(\n+        compiler, js,\n+        new MakeDeclaredNamesUnique(\n+            new BoilerplateRenamer(\n+                compiler.getUniqueNameIdSupplier(),\n+                prefix)));\n+    return js;\n   }\n \n   private void reportCodeChange(String changeDescription) {\n--- /dev/null\n+++ b/src/com/google/javascript/jscomp/PeepholeFoldWithTypes.java\n+/*\n+ * Copyright 2010 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.javascript.rhino.Node;\n+import com.google.javascript.rhino.Token;\n+import com.google.javascript.rhino.jstype.JSType;\n+\n+/**\n+ * Performs type-aware peephole optimizations.\n+ * \n+ * These peephole optimizations are in their own class because\n+ * type information may not always be available (such as during pre-processing)\n+ * or may not be turned on.\n+ * \n+ * Currently only Token.TYPEOF is folded -- in the future it may be possible to\n+ * fold Token.INSTANCEOF as well. Another possibility is folding when\n+ * non-nullable objects are used in boolean logic, such as:\n+ * \"if (x) {\" or \"(!x) ? a : b\" or \"x && foo()\"\n+ * \n+ * TODO(dcc): Support folding Token.INSTANCEOF and non-nullable objects\n+ * in boolean logic.\n+ * \n+ * @author dcc@google.com (Devin Coughlin)\n+ */\n+public class PeepholeFoldWithTypes extends AbstractPeepholeOptimization {\n+\n+  @Override\n+  Node optimizeSubtree(Node subtree) {\n+    switch (subtree.getType()) {\n+      case Token.TYPEOF:\n+        return tryFoldTypeof(subtree);\n+      default:\n+        return subtree;\n+    }\n+  }\n+  \n+  /**\n+   * Folds \"typeof expression\" based on the JSType of \"expression\" if the\n+   * expression  has no side effects.\n+   * \n+   * <p>E.g.,\n+   * <pre>\n+   * var x = 6;\n+   * if (typeof(x) == \"number\") {\n+   * }\n+   * </pre>\n+   * folds to\n+   * <pre>\n+   * var x = 6;\n+   * if (\"number\" == \"number\") {\n+   * }\n+   * </pre>\n+   * \n+   * <p>This method doesn't fold literal values -- we leave that to\n+   * PeepholeFoldConstants.\n+   */\n+  private Node tryFoldTypeof(Node typeofNode) {\n+    Preconditions.checkArgument(typeofNode.getType() == Token.TYPEOF);\n+    Preconditions.checkArgument(typeofNode.getFirstChild() != null);\n+    \n+    Node argumentNode = typeofNode.getFirstChild();\n+    \n+    // We'll let PeepholeFoldConstants handle folding literals\n+    // and we can't remove arguments with possible side effects.\n+    if (!NodeUtil.isLiteralValue(argumentNode) &&\n+        !NodeUtil.mayHaveSideEffects(argumentNode)) {\n+      JSType argumentType = argumentNode.getJSType();\n+            \n+      String typeName = null;\n+      \n+      if (argumentType != null) {\n+        // typeof null is \"object\" in JavaScript\n+        if (argumentType.isObject() || argumentType.isNullType()) {\n+          typeName = \"object\";\n+        } else if (argumentType.isStringValueType()) {\n+          typeName = \"string\";\n+        } else if (argumentType.isNumberValueType()) {\n+          typeName = \"number\";\n+        } else if (argumentType.isBooleanValueType()) {\n+          typeName = \"boolean\";\n+        } else if (argumentType.isVoidType()) {\n+           typeName = \"undefined\";\n+        } else if (argumentType.isUnionType()) {\n+          // TODO(dcc): We don't handle union types, for now,\n+          // but could support, say, unions of different object types\n+          // in the future.\n+          typeName = null;\n+        }\n+               \n+        if (typeName != null) {\n+          Node newNode = Node.newString(typeName);\n+          typeofNode.getParent().replaceChild(typeofNode, newNode);\n+          reportCodeChange();\n+          \n+          return newNode;\n+        }\n+      }     \n+    }  \n+    return typeofNode;\n+  }\n+}\n--- a/src/com/google/javascript/jscomp/ReplaceStrings.java\n+++ b/src/com/google/javascript/jscomp/ReplaceStrings.java\n             Collection<String> classes = methods.get(methodName);\n             if (classes != null) {\n               Node lhs = calledFn.getFirstChild();\n-              JSType type = lhs.getJSType().restrictByNotNullOrUndefined();\n-              Config config = findMatchingClass(type, classes);\n-              if (config != null) {\n-                doSubstitutions(t, config, n);\n-                return;\n+              if (lhs.getJSType() != null) {\n+                JSType type = lhs.getJSType().restrictByNotNullOrUndefined();\n+                Config config = findMatchingClass(type, classes);\n+                if (config != null) {\n+                  doSubstitutions(t, config, n);\n+                  return;\n+                }\n               }\n             }\n           }\n         Preconditions.checkState(replacementParameter == -1);\n         replacementParameter = paramCount;\n       } else {\n-        Preconditions.checkState(param.isEmpty(), \"Unknown marker\");\n+        // TODO(johnlenz): report an error.\n+        Preconditions.checkState(param.isEmpty(), \"Unknown marker\", param);\n       }\n     }\n \n--- a/src/com/google/javascript/jscomp/RuntimeTypeCheck.java\n+++ b/src/com/google/javascript/jscomp/RuntimeTypeCheck.java\n   }\n \n   private void addBoilerplateCode() {\n-    String boilerplateCode = getBoilerplateCode(logFunction);\n-\n-    Node js = compiler.parseSyntheticCode(boilerplateCode);\n-    NodeTraversal.traverse(compiler, js,\n-        new Normalize.NormalizeStatements(compiler, false));\n-\n+    Node js = getBoilerplateCode(compiler, logFunction);\n     compiler.getNodeForCodeInsertion(null).addChildrenToFront(\n         js.removeChildren());\n-\n     compiler.reportCodeChange();\n   }\n \n   }\n \n   @VisibleForTesting\n-  static String getBoilerplateCode(@Nullable String logFunction) {\n+  static Node getBoilerplateCode(\n+      AbstractCompiler compiler, @Nullable String logFunction) {\n     String boilerplateCode;\n     try {\n       boilerplateCode = CharStreams.toString(new InputStreamReader(\n     boilerplateCode = boilerplateCode.replace(\"%%LOG%%\",\n         logFunction == null ? \"function(warning, expr) {}\" : logFunction);\n \n-    return boilerplateCode;\n+    return Normalize.parseAndNormalizeSyntheticCode(\n+        compiler, boilerplateCode, \"jscomp_runtimeTypeCheck_\");\n   }\n }\n--- a/src/com/google/javascript/jscomp/SanityCheck.java\n+++ b/src/com/google/javascript/jscomp/SanityCheck.java\n       \"----------------------------------------\\n\" +\n       \"Expected:\\n{0}\\n\" +\n       \"----------------------------------------\\n\" +\n-      \"Actual\\n{1}\");\n+      \"Actual:\\n{1}\");\n \n   private final AbstractCompiler compiler;\n \n     if (compiler.hasHaltingErrors()) {\n       compiler.report(JSError.make(CANNOT_PARSE_GENERATED_CODE,\n               Strings.truncateAtMaxLength(source, 100, true)));\n-      return null;\n+\n+      // Throw an exception, so that the infrastructure will tell us\n+      // which pass violated the sanity check.\n+      throw new IllegalStateException(\"Sanity Check failed\");\n     }\n \n     String source2 = compiler.toSource(root2);\n       compiler.report(JSError.make(GENERATED_BAD_CODE,\n               Strings.truncateAtMaxLength(source, 1000, true),\n               Strings.truncateAtMaxLength(source2, 1000, true)));\n+\n+      // Throw an exception, so that the infrastructure will tell us\n+      // which pass violated the sanity check.\n+      throw new IllegalStateException(\"Sanity Check failed\");\n     }\n \n     return root2;\n    */\n   private void sanityCheckNormalization(Node externs, Node root) {\n     // Verify nothing has inappropriately denormalize the AST.\n-    CodeChangeHandler.RecentChange handler =\n-        new CodeChangeHandler.RecentChange();\n+    CodeChangeHandler handler =\n+        new CodeChangeHandler.ForbiddenChange();\n     compiler.addChangeHandler(handler);\n \n     // TODO(johnlenz): Change these normalization checks Preconditions and\n     // Exceptions into Errors so that it is easier to find the root cause\n     // when there are cascading issues.\n     new PrepareAst(compiler, true).process(null, root);\n-    Preconditions.checkState(!handler.hasCodeChanged(),\n-        \"This should never fire, NodeTypeNormalizer should assert first.\");\n-\n     if (compiler.isNormalized()) {\n       (new Normalize(compiler, true)).process(externs, root);\n-      Preconditions.checkState(!handler.hasCodeChanged(),\n-          \"This should never fire, Normalize should assert first.\");\n \n       boolean checkUserDeclarations = true;\n       CompilerPass pass = new Normalize.VerifyConstants(\n--- a/test/com/google/javascript/jscomp/AliasKeywordsTest.java\n+++ b/test/com/google/javascript/jscomp/AliasKeywordsTest.java\n   @Override\n   public void setUp() {\n     super.enableLineNumberCheck(false);\n+    super.enableNormalize();\n   }\n \n   @Override\n     StringBuilder sb = new StringBuilder();\n     sb.append(\"function \");\n     sb.append(AliasKeywords.ALIAS_THROW);\n-    sb.append(\"(t){throw t;}\");\n+    sb.append(\"(jscomp_throw_param){throw jscomp_throw_param;}\");\n     sb.append(code);\n     for (int i = 0; i < repetitions; i++) {\n       sb.append(AliasKeywords.ALIAS_THROW);\n--- a/test/com/google/javascript/jscomp/CompilerTestCase.java\n+++ b/test/com/google/javascript/jscomp/CompilerTestCase.java\n \n         // Only run the normalize pass once, if asked.\n         if (normalizeEnabled && i == 0) {\n-          Normalize normalize = new Normalize(compiler, false);\n-          normalize.process(externsRoot, mainRoot);\n-          compiler.setNormalized();\n+          normalizeActualCode(compiler, externsRoot, mainRoot);\n         }\n \n         if (markNoSideEffects && i == 0) {\n       }\n \n       if (normalizeEnabled) {\n-        Normalize normalize = new Normalize(compiler, false);\n-        normalize.process(externsRootClone, mainRootClone);\n+        normalizeActualCode(compiler, externsRootClone, mainRootClone);\n       }\n \n       if (mainRootClone.checkTreeEqualsSilent(mainRoot)) {\n     }\n   }\n \n+  private void normalizeActualCode(\n+      Compiler compiler, Node externsRoot, Node mainRoot) {\n+    Normalize normalize = new Normalize(compiler, false);\n+    normalize.process(externsRoot, mainRoot);\n+  }\n+\n   /**\n    * Parses expected js inputs and returns the root of the parse tree.\n    */\n-  private Node parseExpectedJs(String[] expected) {\n+  Node parseExpectedJs(String[] expected) {\n     Compiler compiler = createCompiler();\n     JSSourceFile[] inputs = new JSSourceFile[expected.length];\n     for (int i = 0; i < expected.length; i++) {\n     if (normalizeEnabled && normalizeExpected && !compiler.hasErrors()) {\n       Normalize normalize = new Normalize(compiler, false);\n       normalize.process(externsRoot, mainRoot);\n-      compiler.setNormalized();\n     }\n     return mainRoot;\n   }\n--- a/test/com/google/javascript/jscomp/NormalizeTest.java\n+++ b/test/com/google/javascript/jscomp/NormalizeTest.java\n \n package com.google.javascript.jscomp;\n \n+import com.google.common.collect.Lists;\n import com.google.javascript.rhino.Node;\n \n /**\n          \"}\");\n   }\n \n+  public void testNormalizeSyntheticCode() {\n+    Compiler compiler = new Compiler();\n+    compiler.init(\n+        Lists.<JSSourceFile>newArrayList(),\n+        Lists.<JSSourceFile>newArrayList(), new CompilerOptions());\n+    Node code = Normalize.parseAndNormalizeSyntheticCode(\n+        compiler, \"function f(x) {} function g(x) {}\", \"prefix_\");\n+    assertEquals(\n+        \"function f(x$$prefix_0){}function g(x$$prefix_1){}\",\n+        compiler.toSource(code));\n+  }\n+\n   public void testRenamingConstantProperties() {\n     // In order to detecte that foo.BAR is a constant, we need collapse\n     // properties to run first so that we can tell if the initial value is\n--- /dev/null\n+++ b/test/com/google/javascript/jscomp/PeepholeFoldWithTypesTest.java\n+/*\n+ * Copyright 2010 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+/**\n+ * Tests for {@link ExternExportsPass}.\n+ * \n+ * @author dcc@google.com (Devin Coughlin)\n+ */\n+public class PeepholeFoldWithTypesTest extends CompilerTestCase {\n+\n+  @Override\n+  protected CompilerPass getProcessor(Compiler compiler) {\n+    return new PeepholeOptimizationsPass(compiler, new PeepholeFoldWithTypes());\n+  }\n+  \n+  @Override\n+  public void setUp() {\n+    enableTypeCheck(CheckLevel.WARNING);\n+  }\n+  \n+  public void testFoldTypeofObject() {\n+    test(\"var x = {};typeof x\",\n+         \"var x = {};\\\"object\\\"\");\n+    \n+    test(\"var x = [];typeof x\",\n+         \"var x = [];\\\"object\\\"\");\n+    \n+    // typeof null is \"object\" in JavaScript\n+    test(\"var x = null;typeof x\",\n+         \"var x = null;\\\"object\\\"\");\n+  }\n+  \n+  public void testFoldTypeofString() {\n+    test(\"var x = \\\"foo\\\";typeof x\",\n+         \"var x = \\\"foo\\\";\\\"string\\\"\");\n+    \n+    test(\"var x = new String(\\\"foo\\\");typeof x\",\n+         \"var x = new String(\\\"foo\\\");\\\"object\\\"\");\n+  }\n+  \n+  public void testFoldTypeofNumber() {\n+    test(\"var x = 10;typeof x\",\n+         \"var x = 10;\\\"number\\\"\");\n+    \n+    test(\"var x = new Number(6);typeof x\",\n+         \"var x = new Number(6);\\\"object\\\"\");\n+  }\n+  \n+  public void testFoldTypeofBoolean() {\n+    test(\"var x = false;typeof x\",\n+         \"var x = false;\\\"boolean\\\"\");\n+    \n+    test(\"var x = new Boolean(true);typeof x\",\n+         \"var x = new Boolean(true);\\\"object\\\"\");\n+  }\n+  \n+  public void testFoldTypeofUndefined() {\n+    test(\"var x = undefined;typeof x\",\n+         \"var x = undefined;\\\"undefined\\\"\"); \n+  }\n+  \n+  public void testDontFoldTypeofUnionTypes() {\n+    // For now we don't do anything with union types\n+    testSame(\"var x = (unknown ? {} : null);typeof x\");\n+  }\n+  \n+  public void testDontFoldTypeofSideEffects() {\n+    // Shouldn't fold if argument to typeof has side effects\n+    testSame(\"var x = 6 ;typeof (x++)\");\n+  }\n+\n+  public void testDontFoldTypeofWithTypeCheckDisabled() {\n+    disableTypeCheck();\n+    testSame(\"var x = {};typeof x\");\n+  }\n+}\n--- a/test/com/google/javascript/jscomp/RuntimeTypeCheckTest.java\n+++ b/test/com/google/javascript/jscomp/RuntimeTypeCheckTest.java\n \n package com.google.javascript.jscomp;\n \n+import com.google.common.collect.Lists;\n import com.google.javascript.rhino.Node;\n \n /**\n  */\n public class RuntimeTypeCheckTest extends CompilerTestCase {\n \n+  private Node runtimeTypeCheckCode = null;\n+\n   public RuntimeTypeCheckTest() {\n     enableTypeCheck(CheckLevel.WARNING);\n   }\n   @Override\n   protected void setUp() {\n     super.enableLineNumberCheck(false);\n+    enableNormalize();\n   }\n \n   public void testValue() {\n   }\n \n   public void testInnerClasses() {\n-    enableNormalize(false);\n     testChecks(\n         \"function f() { /** @constructor */ function inner() {} }\" +\n         \"function g() { /** @constructor */ function inner() {} }\",\n   }\n \n   private void testChecks(String js, String expected) {\n-    String boilerplateCode = RuntimeTypeCheck.getBoilerplateCode(null);\n     Compiler compiler = new Compiler();\n-    compiler.init(new JSSourceFile[0], new JSSourceFile[0],\n-        new CompilerOptions());\n-    Node ast = compiler.parseSyntheticCode(boilerplateCode + expected);\n-    NodeTraversal.traverse(compiler, ast,\n-        new Normalize.NormalizeStatements(compiler, false));\n-\n-    test(js, compiler.toSource(ast));\n+    compiler.init(Lists.<JSSourceFile>newArrayList(),\n+                  Lists.<JSSourceFile>newArrayList(),\n+                  new CompilerOptions());\n+    Node boilerplateCode =\n+        RuntimeTypeCheck.getBoilerplateCode(compiler, null);\n+    test(js, compiler.toSource(boilerplateCode) + \";\" + expected);\n   }\n \n   @Override", "timestamp": 1278040253, "metainfo": ""}