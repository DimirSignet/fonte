{"sha": "5f8de0b972f1c3c359ee7a0441729691105a3d62", "log": "Fix smart name removal to handle aliases formed through function calls.  R=nicksantos DELTA=124  (115 added, 1 deleted, 8 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=693   ", "commit": "\n--- a/src/com/google/javascript/jscomp/NameAnalyzer.java\n+++ b/src/com/google/javascript/jscomp/NameAnalyzer.java\n package com.google.javascript.jscomp;\n \n import com.google.common.base.Preconditions;\n+import com.google.common.base.Predicate;\n import com.google.common.collect.ImmutableSet;\n import com.google.common.collect.Lists;\n import com.google.common.collect.Maps;\n     }\n   }\n \n+  private static final Predicate<Node> NON_LOCAL_RESULT_PREDICATE =\n+      new Predicate<Node>() {\n+        @Override\n+        public boolean apply(Node input) {\n+          if (input.getType() == Token.CALL) {\n+            return false;\n+          }\n+          // TODO(johnlenz): handle NEW calls that record their 'this'\n+          // in global scope and effectly return an alias.\n+          // Other non-local references are handled by this pass.\n+          return true;\n+        }\n+      };\n+\n   /**\n    * <p>Identifies all references between global names.\n    *\n                       : referring.name;\n       }\n \n+      String name = nameInfo.name;\n+\n+      // A value whose result is the return value of a function call\n+      // can be an alias to global object.\n+      // Here we add a alias to the general \"global\" object\n+      // to act as a placeholder for the actual (unnamed) value.\n+      if (maybeHiddenAlias(name, n)) {\n+        recordAlias(name, WINDOW);\n+      }\n+\n       // An externally referenceable name must always be defined, so we add a\n       // reference to it from the global scope (a.k.a. window).\n-      String name = nameInfo.name;\n       if (nameInfo.isExternallyReferenceable) {\n         recordReference(WINDOW, name, RefType.REGULAR);\n         maybeRecordAlias(name, parent, referring, referringName);\n           }\n         }\n       }\n+    }\n+\n+    /**\n+     * A value whose result is the return value of a function call\n+     * can be an alias to global object. The dependency on the call target will\n+     * prevent the removal of the function and its dependent values, but won't\n+     * prevent the alias' removal.\n+     */\n+    private boolean maybeHiddenAlias(String name, Node n) {\n+      Node parent = n.getParent();\n+      if (NodeUtil.isLhs(n, parent)) {\n+        Node rhs = (parent.getType() == Token.VAR)\n+            ? n.getFirstChild() : parent.getLastChild();\n+        return (rhs != null && !NodeUtil.evaluatesToLocalValue(\n+            rhs, NON_LOCAL_RESULT_PREDICATE));\n+      }\n+      return false;\n     }\n \n     /**\n--- a/test/com/google/javascript/jscomp/NameAnalyzerTest.java\n+++ b/test/com/google/javascript/jscomp/NameAnalyzerTest.java\n public class NameAnalyzerTest extends CompilerTestCase {\n \n   private static String kExterns =\n-      \"var window, top; var Function; var externfoo; methods.externfoo;\";\n+      \"var window, top;\" +\n+      \"var document;\" +\n+      \"var Function; var externfoo; methods.externfoo;\";\n \n   public NameAnalyzerTest() {\n     super(kExterns);\n          \"\");\n   }\n \n-  public void testRhsAssignWithHook1() {\n+  public void testAssignWithOr1() {\n+    testSame(\"var foo = null;\" +\n+        \"var f = window.a || function () {return foo}; f()\");\n+  }\n+\n+  public void testAssignWithOr2() {\n+    test(\"var foo = null;\" +\n+        \"var f = window.a || function () {return foo};\",\n+        \"var foo = null\"); // why is this left?\n+  }\n+\n+  public void testAssignWithAnd1() {\n+    testSame(\"var foo = null;\" +\n+        \"var f = window.a && function () {return foo}; f()\");\n+  }\n+\n+  public void testAssignWithAnd2() {\n+    test(\"var foo = null;\" +\n+        \"var f = window.a && function () {return foo};\",\n+        \"var foo = null;\");  // why is this left?\n+  }\n+\n+  public void testAssignWithHook1() {\n     testSame(\"function Foo(){} var foo = null;\" +\n         \"var f = window.a ? \" +\n         \"    function () {return new Foo()} : function () {return foo}; f()\");\n   }\n \n-  public void testRhsAssignWithHook2() {\n+  public void testAssignWithHook2() {\n     test(\"function Foo(){} var foo = null;\" +\n         \"var f = window.a ? \" +\n         \"    function () {return new Foo()} : function () {return foo};\",\n         \"\");\n   }\n \n-  public void testRhsAssignWithHook3() {\n+  public void testAssignWithHook3() {\n     testSame(\"function Foo(){} var foo = null; var f = {};\" +\n         \"f.b = window.a ? \" +\n         \"    function () {return new Foo()} : function () {return foo}; f.b()\");\n   }\n \n-  public void testRhsAssignWithHook4() {\n+  public void testAssignWithHook4() {\n     test(\"function Foo(){} var foo = null; var f = {};\" +\n         \"f.b = window.a ? \" +\n         \"    function () {return new Foo()} : function () {return foo};\",\n         \"\");\n   }\n \n-  public void testRhsAssignWithHook5() {\n+  public void testAssignWithHook5() {\n     testSame(\"function Foo(){} var foo = null; var f = {};\" +\n         \"f.b = window.a ? function () {return new Foo()} :\" +\n         \"    window.b ? function () {return foo} :\" +\n         \"    function() { return Foo }; f.b()\");\n   }\n \n-  public void testRhsAssignWithHook6() {\n+  public void testAssignWithHook6() {\n     test(\"function Foo(){} var foo = null; var f = {};\" +\n         \"f.b = window.a ? function () {return new Foo()} :\" +\n         \"    window.b ? function () {return foo} :\" +\n \n   // TODO(user): Make NameAnalyzer handle this. The OR subexpressions may\n   // modify global state.\n-  // public void disable_testConditionallyDefinedFunction3() {\n+  // public void testConditionallyDefinedFunction3() {\n   //    test(\"var a = {};\" +\n   //         \"rand() % 2 || (a.f = function() { externfoo = 1; } || alert());\",\n   //         \"rand() % 2 || function() { externfoo = 1; } || alert();\");\n     testSame(\n         \"var self_ = window;\\n\" +\n         \"self_['qs'] = function() {};\");\n+  }\n+\n+  public void testNoRemoveAlias0() {\n+    testSame(\n+        \"var x = {}; function f() { return x; }; \" +\n+        \"f().style.display = 'block';\" +\n+        \"alert(x.style)\");\n+  }\n+\n+  public void testNoRemoveAlias1() {\n+    testSame(\n+        \"var x = {}; function f() { return x; };\" +\n+        \"var map = f();\\n\" +\n+        \"map.style.display = 'block';\" +\n+        \"alert(x.style)\");\n+  }\n+\n+  public void testNoRemoveAlias2() {\n+    testSame(\n+        \"var x = {};\" +\n+        \"var map = (function () { return x; })();\\n\" +\n+        \"map.style = 'block';\" +\n+        \"alert(x.style)\");\n+  }\n+\n+  public void testNoRemoveAlias3() {\n+    testSame(\n+        \"var x = {}; function f() { return x; };\" +\n+        \"var map = {}\\n\" +\n+        \"map[1] = f();\\n\" +\n+        \"map[1].style.display = 'block';\");\n+  }\n+\n+  public void testNoRemoveAliasOfExternal0() {\n+    testSame(\n+        \"document.getElementById('foo').style.display = 'block';\");\n+  }\n+\n+  public void testNoRemoveAliasOfExternal1() {\n+    testSame(\n+        \"var map = document.getElementById('foo');\\n\" +\n+        \"map.style.display = 'block';\");\n+  }\n+\n+  public void testNoRemoveAliasOfExternal2() {\n+    testSame(\n+        \"var map = {}\\n\" +\n+        \"map[1] = document.getElementById('foo');\\n\" +\n+        \"map[1].style.display = 'block';\");\n   }\n \n   @Override", "timestamp": 1298914214, "metainfo": ""}