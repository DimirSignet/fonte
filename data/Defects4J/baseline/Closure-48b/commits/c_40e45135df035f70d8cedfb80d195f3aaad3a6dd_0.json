{"sha": "40e45135df035f70d8cedfb80d195f3aaad3a6dd", "log": "fix a typo  R=johnlenz DELTA=1212  (606 added, 606 deleted, 0 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=1189199   ", "commit": "\n--- /dev/null\n+++ b/test/com/google/javascript/jscomp/ExpressionDecomposerTest.java\n+/*\n+ * Copyright 2009 The Closure Compiler Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+import com.google.common.collect.Sets;\n+import com.google.javascript.jscomp.ExpressionDecomposer.DecompositionType;\n+import com.google.javascript.rhino.Node;\n+import com.google.javascript.rhino.Token;\n+\n+import junit.framework.TestCase;\n+\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Unit tests for ExpressionDecomposer\n+ * @author johnlenz@google.com (John Lenz)\n+ */\n+public class ExpressionDecomposerTest extends TestCase {\n+  // Note: functions \"foo\" and \"goo\" are external functions\n+  // in the helper.\n+\n+  public void testCanExposeExpression1() {\n+    // Can't move or decompose some classes of expressions.\n+    helperCanExposeExpression(\n+        DecompositionType.UNDECOMPOSABLE, \"while(foo());\", \"foo\");\n+    helperCanExposeExpression(\n+        DecompositionType.UNDECOMPOSABLE, \"while(x = goo()&&foo()){}\", \"foo\");\n+    helperCanExposeExpression(\n+        DecompositionType.UNDECOMPOSABLE, \"while(x += goo()&&foo()){}\", \"foo\");\n+\n+    helperCanExposeExpression(\n+        DecompositionType.UNDECOMPOSABLE, \"do{}while(foo());\", \"foo\");\n+    helperCanExposeExpression(\n+        DecompositionType.UNDECOMPOSABLE, \"for(;foo(););\", \"foo\");\n+    // This case could be supported for loops without conditional continues\n+    // by moving the increment into the loop body.\n+    helperCanExposeExpression(\n+        DecompositionType.UNDECOMPOSABLE, \"for(;;foo());\", \"foo\");\n+    // FOR initializer could be supported but they never occur\n+    // as they are normalized away.\n+\n+    // This is potentially doable but a bit too complex currently.\n+    helperCanExposeExpression(\n+        DecompositionType.UNDECOMPOSABLE, \"switch(1){case foo():;}\", \"foo\");\n+  }\n+\n+  public void testCanExposeExpression2() {\n+    helperCanExposeExpression(\n+        DecompositionType.MOVABLE, \"foo()\", \"foo\");\n+    helperCanExposeExpression(\n+        DecompositionType.MOVABLE, \"x = foo()\", \"foo\");\n+    helperCanExposeExpression(\n+        DecompositionType.MOVABLE, \"var x = foo()\", \"foo\");\n+    helperCanExposeExpression(\n+        DecompositionType.MOVABLE, \"if(foo()){}\", \"foo\");\n+    helperCanExposeExpression(\n+        DecompositionType.MOVABLE, \"switch(foo()){}\", \"foo\");\n+    helperCanExposeExpression(\n+        DecompositionType.MOVABLE, \"switch(foo()){}\", \"foo\");\n+    helperCanExposeExpression(\n+        DecompositionType.MOVABLE, \"function (){ return foo();}\", \"foo\");\n+\n+    helperCanExposeExpression(\n+        DecompositionType.MOVABLE, \"x = foo() && 1\", \"foo\");\n+    helperCanExposeExpression(\n+        DecompositionType.MOVABLE, \"x = foo() || 1\", \"foo\");\n+    helperCanExposeExpression(\n+        DecompositionType.MOVABLE, \"x = foo() ? 0 : 1\", \"foo\");\n+    helperCanExposeExpression(\n+        DecompositionType.MOVABLE, \"(function(a){b = a})(foo())\", \"foo\");\n+  }\n+\n+  public void testCanExposeExpression3() {\n+    helperCanExposeExpression(\n+        DecompositionType.DECOMPOSABLE, \"x = 0 && foo()\", \"foo\");\n+    helperCanExposeExpression(\n+        DecompositionType.DECOMPOSABLE, \"x = 1 || foo()\", \"foo\");\n+    helperCanExposeExpression(\n+        DecompositionType.DECOMPOSABLE, \"var x = 1 ? foo() : 0\", \"foo\");\n+\n+    helperCanExposeExpression(\n+        DecompositionType.DECOMPOSABLE, \"goo() && foo()\", \"foo\");\n+    helperCanExposeExpression(\n+        DecompositionType.DECOMPOSABLE, \"x = goo() && foo()\", \"foo\");\n+    helperCanExposeExpression(\n+        DecompositionType.DECOMPOSABLE, \"x += goo() && foo()\", \"foo\");\n+    helperCanExposeExpression(\n+        DecompositionType.DECOMPOSABLE, \"var x = goo() && foo()\", \"foo\");\n+    helperCanExposeExpression(\n+        DecompositionType.DECOMPOSABLE, \"if(goo() && foo()){}\", \"foo\");\n+    helperCanExposeExpression(\n+        DecompositionType.DECOMPOSABLE, \"switch(goo() && foo()){}\", \"foo\");\n+    helperCanExposeExpression(\n+        DecompositionType.DECOMPOSABLE, \"switch(goo() && foo()){}\", \"foo\");\n+    helperCanExposeExpression(\n+        DecompositionType.DECOMPOSABLE, \"switch(x = goo() && foo()){}\", \"foo\");\n+    helperCanExposeExpression(\n+        DecompositionType.DECOMPOSABLE,\n+        \"function (){ return goo() && foo();}\", \"foo\");\n+  }\n+\n+  public void testCanExposeExpression4() {\n+    // 'this' must be preserved in call.\n+    helperCanExposeExpression(\n+        DecompositionType.UNDECOMPOSABLE, \"if (goo.a(1, foo()));\", \"foo\");\n+  }\n+\n+  public void testCanExposeExpression5() {\n+    // 'this' must be preserved in call.\n+    helperCanExposeExpression(\n+        DecompositionType.UNDECOMPOSABLE, \"if (goo['a'](foo()));\", \"foo\");\n+  }\n+\n+  public void testCanExposeExpression6() {\n+    // 'this' must be preserved in call.\n+    helperCanExposeExpression(\n+        DecompositionType.UNDECOMPOSABLE, \"z:if (goo.a(1, foo()));\", \"foo\");\n+  }\n+\n+  public void testCanExposeExpression7() {\n+    // Verify calls to function expressions are movable.\n+    helperCanExposeFunctionExpression(\n+        DecompositionType.MOVABLE,\n+        \"(function(map){descriptions_=map})(\\n\" +\n+            \"function(){\\n\" +\n+                \"var ret={};\\n\" +\n+                \"ret[INIT]='a';\\n\" +\n+                \"ret[MIGRATION_BANNER_DISMISS]='b';\\n\" +\n+                \"return ret\\n\" +\n+            \"}()\\n\" +\n+        \");\", 2);\n+  }\n+\n+  public void testMoveExpression1() {\n+    // There isn't a reason to do this, but it works.\n+    helperMoveExpression(\"foo()\", \"foo\", \"var temp$$0 = foo(); temp$$0;\");\n+  }\n+\n+  public void testMoveExpression2() {\n+    helperMoveExpression(\n+        \"x = foo()\",\n+        \"foo\",\n+        \"var temp$$0 = foo(); x = temp$$0;\");\n+  }\n+\n+  public void testMoveExpression3() {\n+    helperMoveExpression(\n+        \"var x = foo()\",\n+        \"foo\",\n+        \"var temp$$0 = foo(); var x = temp$$0;\");\n+  }\n+\n+  public void testMoveExpression4() {\n+    helperMoveExpression(\n+        \"if(foo()){}\",\n+        \"foo\",\n+        \"var temp$$0 = foo(); if (temp$$0);\");\n+  }\n+\n+  public void testMoveExpression5() {\n+    helperMoveExpression(\n+        \"switch(foo()){}\",\n+        \"foo\",\n+        \"var temp$$0 = foo(); switch(temp$$0){}\");\n+  }\n+\n+  public void testMoveExpression6() {\n+    helperMoveExpression(\n+        \"switch(1 + foo()){}\",\n+        \"foo\",\n+        \"var temp$$0 = foo(); switch(1 + temp$$0){}\");\n+  }\n+\n+  public void testMoveExpression7() {\n+    helperMoveExpression(\n+        \"function (){ return foo();}\",\n+        \"foo\",\n+        \"function (){ var temp$$0 = foo(); return temp$$0;}\");\n+  }\n+\n+  public void testMoveExpression8() {\n+    helperMoveExpression(\n+        \"x = foo() && 1\",\n+        \"foo\",\n+        \"var temp$$0 = foo(); x = temp$$0 && 1\");\n+  }\n+\n+  public void testMoveExpression9() {\n+    helperMoveExpression(\n+        \"x = foo() || 1\",\n+        \"foo\",\n+        \"var temp$$0 = foo(); x = temp$$0 || 1\");\n+  }\n+\n+  public void testMoveExpression10() {\n+    helperMoveExpression(\n+        \"x = foo() ? 0 : 1\",\n+        \"foo\",\n+        \"var temp$$0 = foo(); x = temp$$0 ? 0 : 1\");\n+  }\n+\n+  /* Decomposition tests. */\n+\n+  public void testExposeExpression1() {\n+    helperExposeExpression(\n+        \"x = 0 && foo()\",\n+        \"foo\",\n+        \"var temp$$0; if (temp$$0 = 0) temp$$0 = foo(); x = temp$$0;\");\n+  }\n+\n+  public void testExposeExpression2() {\n+    helperExposeExpression(\n+        \"x = 1 || foo()\",\n+        \"foo\",\n+        \"var temp$$0; if (temp$$0 = 1); else temp$$0 = foo(); x = temp$$0;\");\n+  }\n+\n+  public void testExposeExpression3() {\n+    helperExposeExpression(\n+        \"var x = 1 ? foo() : 0\",\n+        \"foo\",\n+        \"var temp$$0;\" +\n+        \" if (1) temp$$0 = foo(); else temp$$0 = 0;var x = temp$$0;\");\n+  }\n+\n+  public void testExposeExpression4() {\n+    helperExposeExpression(\n+        \"goo() && foo()\",\n+        \"foo\",\n+        \"if (goo()) foo();\");\n+  }\n+\n+  public void testExposeExpression5() {\n+    helperExposeExpression(\n+        \"x = goo() && foo()\",\n+        \"foo\",\n+        \"var temp$$0; if (temp$$0 = goo()) temp$$0 = foo(); x = temp$$0;\");\n+  }\n+\n+  public void testExposeExpression6() {\n+    helperExposeExpression(\n+        \"var x = 1 + (goo() && foo())\",\n+        \"foo\",\n+        \"var temp$$0; if (temp$$0 = goo()) temp$$0 = foo();\" +\n+        \"var x = 1 + temp$$0;\");\n+  }\n+\n+  public void testExposeExpression7() {\n+    helperExposeExpression(\n+        \"if(goo() && foo());\",\n+        \"foo\",\n+        \"var temp$$0;\" +\n+        \"if (temp$$0 = goo()) temp$$0 = foo();\" +\n+        \"if(temp$$0);\");\n+  }\n+\n+  public void testExposeExpression8() {\n+    helperExposeExpression(\n+        \"switch(goo() && foo()){}\",\n+        \"foo\",\n+        \"var temp$$0;\" +\n+        \"if (temp$$0 = goo()) temp$$0 = foo();\" +\n+        \"switch(temp$$0){}\");\n+  }\n+\n+  public void testExposeExpression9() {\n+    helperExposeExpression(\n+        \"switch(1 + goo() + foo()){}\",\n+        \"foo\",\n+        \"var temp_const$$0 = 1 + goo();\" +\n+        \"switch(temp_const$$0 + foo()){}\");\n+  }\n+\n+  public void testExposeExpression10() {\n+    helperExposeExpression(\n+        \"function (){ return goo() && foo();}\",\n+        \"foo\",\n+        \"function (){\" +\n+          \"var temp$$0; if (temp$$0 = goo()) temp$$0 = foo();\" +\n+          \"return temp$$0;\" +\n+         \"}\");\n+  }\n+\n+  public void testExposeExpression11() {\n+    // TODO(johnlenz): We really want a constant marking pass.\n+    // The value \"goo\" should be constant, but it isn't known to be so.\n+    helperExposeExpression(\n+        \"if (goo(1, goo(2), (1 ? foo() : 0)));\",\n+        \"foo\",\n+        \"var temp_const$$1 = goo;\" +\n+        \"var temp_const$$0 = goo(2);\" +\n+        \"var temp$$2;\" +\n+        \"if (1) temp$$2 = foo(); else temp$$2 = 0;\" +\n+        \"if (temp_const$$1(1, temp_const$$0, temp$$2));\");\n+  }\n+\n+  // Simple name on LHS of assignment-op.\n+  public void testExposePlusEquals1() {\n+    helperExposeExpression(\n+        \"var x = 0; x += foo() + 1\",\n+        \"foo\",\n+        \"var x = 0; var temp_const$$0 = x;\" +\n+        \"x = temp_const$$0 + (foo() + 1);\");\n+\n+    helperExposeExpression(\n+        \"var x = 0; y = (x += foo()) + x\",\n+        \"foo\",\n+        \"var x = 0; var temp_const$$0 = x;\" +\n+        \"y = (x = temp_const$$0 + foo()) + x\");\n+  }\n+\n+  // Structure on LHS of assignment-op.\n+  public void testExposePlusEquals2() {\n+    helperExposeExpression(\n+        \"var x = {}; x.a += foo() + 1\",\n+        \"foo\",\n+        \"var x = {}; var temp_const$$0 = x;\" +\n+        \"var temp_const$$1 = temp_const$$0.a;\" +\n+        \"temp_const$$0.a = temp_const$$1 + (foo() + 1);\");\n+\n+    helperExposeExpression(\n+        \"var x = {}; y = (x.a += foo()) + x.a\",\n+        \"foo\",\n+        \"var x = {}; var temp_const$$0 = x;\" +\n+        \"var temp_const$$1 = temp_const$$0.a;\" +\n+        \"y = (temp_const$$0.a = temp_const$$1 + foo()) + x.a\");\n+  }\n+\n+  // Constant object on LHS of assignment-op.\n+  public void testExposePlusEquals3() {\n+    helperExposeExpression(\n+        \"var XX = {};\\n\" +\n+        \"XX.a += foo() + 1\",\n+        \"foo\",\n+        \"var XX = {}; var temp_const$$0 = XX.a;\" +\n+        \"XX.a = temp_const$$0 + (foo() + 1);\");\n+\n+    helperExposeExpression(\n+        \"var XX = {}; y = (XX.a += foo()) + XX.a\",\n+        \"foo\",\n+        \"var XX = {}; var temp_const$$0 = XX.a;\" +\n+        \"y = (XX.a = temp_const$$0 + foo()) + XX.a\");\n+  }\n+\n+  // Function all on LHS of assignment-op.\n+  public void testExposePlusEquals4() {\n+    helperExposeExpression(\n+        \"var x = {}; goo().a += foo() + 1\",\n+        \"foo\",\n+        \"var x = {};\" +\n+        \"var temp_const$$0 = goo();\" +\n+        \"var temp_const$$1 = temp_const$$0.a;\" +\n+        \"temp_const$$0.a = temp_const$$1 + (foo() + 1);\");\n+\n+    helperExposeExpression(\n+        \"var x = {}; y = (goo().a += foo()) + goo().a\",\n+        \"foo\",\n+        \"var x = {};\" +\n+        \"var temp_const$$0 = goo();\" +\n+        \"var temp_const$$1 = temp_const$$0.a;\" +\n+        \"y = (temp_const$$0.a = temp_const$$1 + foo()) + goo().a\");\n+  }\n+\n+  // Test mulitple levels\n+  public void testExposePlusEquals5() {\n+    helperExposeExpression(\n+        \"var x = {}; goo().a.b += foo() + 1\",\n+        \"foo\",\n+        \"var x = {};\" +\n+        \"var temp_const$$0 = goo().a;\" +\n+        \"var temp_const$$1 = temp_const$$0.b;\" +\n+        \"temp_const$$0.b = temp_const$$1 + (foo() + 1);\");\n+\n+    helperExposeExpression(\n+        \"var x = {}; y = (goo().a.b += foo()) + goo().a\",\n+        \"foo\",\n+        \"var x = {};\" +\n+        \"var temp_const$$0 = goo().a;\" +\n+        \"var temp_const$$1 = temp_const$$0.b;\" +\n+        \"y = (temp_const$$0.b = temp_const$$1 + foo()) + goo().a\");\n+  }\n+\n+  /** Test case helpers. */\n+\n+  private void helperCanExposeExpression(\n+      DecompositionType expectedResult,\n+      String code,\n+      String fnName\n+      ) {\n+    helperCanExposeExpression(expectedResult, code, fnName, null);\n+  }\n+\n+  private void helperCanExposeFunctionExpression(\n+      DecompositionType expectedResult, String code, int call) {\n+    Compiler compiler = new Compiler();\n+    Set<String> knownConstants = Sets.newHashSet();\n+    ExpressionDecomposer decomposer = new ExpressionDecomposer(\n+        compiler, compiler.getUniqueNameIdSupplier(), knownConstants);\n+    Node tree = parse(compiler, code);\n+    assertNotNull(tree);\n+\n+    Node externsRoot = parse(compiler,\n+        \"function goo() {}\" +\n+        \"function foo() {}\");\n+    assertNotNull(externsRoot);\n+    Node mainRoot = tree;\n+\n+    Node callSite = findCall(tree, null, 2);\n+    assertNotNull(\"Call \" + call + \" was not found.\", callSite);\n+\n+    compiler.resetUniqueNameId();\n+    DecompositionType result = decomposer.canExposeExpression(\n+        callSite);\n+    assertEquals(expectedResult, result);\n+  }\n+\n+  private void helperCanExposeExpression(\n+      DecompositionType expectedResult,\n+      String code,\n+      String fnName,\n+      Set<String> knownConstants\n+      ) {\n+    Compiler compiler = new Compiler();\n+    if (knownConstants == null) {\n+      knownConstants = Sets.newHashSet();\n+    }\n+    ExpressionDecomposer decomposer = new ExpressionDecomposer(\n+        compiler, compiler.getUniqueNameIdSupplier(), knownConstants);\n+    Node tree = parse(compiler, code);\n+    assertNotNull(tree);\n+\n+    Node externsRoot = parse(compiler,\n+        \"function goo() {}\" +\n+        \"function foo() {}\");\n+    assertNotNull(externsRoot);\n+    Node mainRoot = tree;\n+\n+    Node callSite = findCall(tree, fnName);\n+    assertNotNull(\"Call to \" + fnName + \" was not found.\", callSite);\n+\n+    compiler.resetUniqueNameId();\n+    DecompositionType result = decomposer.canExposeExpression(\n+        callSite);\n+    assertEquals(expectedResult, result);\n+  }\n+\n+  private void helperExposeExpression(\n+      String code,\n+      String fnName,\n+      String expectedResult\n+      ) {\n+    helperExposeExpression(\n+        code, fnName, expectedResult, null);\n+  }\n+\n+  private void validateSourceInfo(Compiler compiler, Node subtree) {\n+    (new LineNumberCheck(compiler)).setCheckSubTree(subtree);\n+    // Source information problems are reported as compiler errors.\n+    if (compiler.getErrorCount() != 0) {\n+      String msg = \"Error encountered: \";\n+      for (JSError err : compiler.getErrors()) {\n+        msg += err.toString() + \"\\n\";\n+      }\n+      assertTrue(msg, compiler.getErrorCount() == 0);\n+    }\n+  }\n+\n+  private void helperExposeExpression(\n+      String code,\n+      String fnName,\n+      String expectedResult,\n+      Set<String> knownConstants\n+      ) {\n+    Compiler compiler = new Compiler();\n+    if (knownConstants == null) {\n+      knownConstants = Sets.newHashSet();\n+    }\n+    ExpressionDecomposer decomposer = new ExpressionDecomposer(\n+        compiler, compiler.getUniqueNameIdSupplier(), knownConstants);\n+    decomposer.setTempNamePrefix(\"temp\");\n+    Node expectedRoot = parse(compiler, expectedResult);\n+    Node tree = parse(compiler, code);\n+    assertNotNull(tree);\n+\n+    Node externsRoot = new Node(Token.EMPTY);\n+    Node mainRoot = tree;\n+\n+    Node callSite = findCall(tree, fnName);\n+    assertNotNull(\"Call to \" + fnName + \" was not found.\", callSite);\n+\n+    DecompositionType result = decomposer.canExposeExpression(callSite);\n+    assertTrue(result == DecompositionType.DECOMPOSABLE);\n+\n+    compiler.resetUniqueNameId();\n+    decomposer.exposeExpression(callSite);\n+    validateSourceInfo(compiler, tree);\n+    String explanation = expectedRoot.checkTreeEquals(tree);\n+    assertNull(\"\\nExpected: \" + compiler.toSource(expectedRoot) +\n+        \"\\nResult: \" + compiler.toSource(tree) +\n+        \"\\n\" + explanation, explanation);\n+  }\n+\n+  private void helperMoveExpression(\n+      String code,\n+      String fnName,\n+      String expectedResult\n+      ) {\n+    helperMoveExpression(\n+        code, fnName, expectedResult, null);\n+  }\n+\n+  private void helperMoveExpression(\n+      String code,\n+      String fnName,\n+      String expectedResult,\n+      Set<String> knownConstants\n+      ) {\n+    Compiler compiler = new Compiler();\n+    if (knownConstants == null) {\n+      knownConstants = Sets.newHashSet();\n+    }\n+\n+    ExpressionDecomposer decomposer = new ExpressionDecomposer(\n+        compiler, compiler.getUniqueNameIdSupplier(), knownConstants);\n+    decomposer.setTempNamePrefix(\"temp\");\n+    Node expectedRoot = parse(compiler, expectedResult);\n+    Node tree = parse(compiler, code);\n+    assertNotNull(tree);\n+\n+    Node externsRoot = new Node(Token.EMPTY);\n+    Node mainRoot = tree;\n+\n+    Node callSite = findCall(tree, fnName);\n+    assertNotNull(\"Call to \" + fnName + \" was not found.\", callSite);\n+\n+    compiler.resetUniqueNameId();\n+    decomposer.moveExpression(callSite);\n+    validateSourceInfo(compiler, tree);\n+    String explanation = expectedRoot.checkTreeEquals(tree);\n+    assertNull(\"\\nExpected: \" + compiler.toSource(expectedRoot) +\n+        \"\\nResult: \" + compiler.toSource(tree) +\n+        \"\\n\" + explanation, explanation);\n+  }\n+\n+  private static Node findCall(Node n, String name) {\n+    return findCall(n, name, 1);\n+  }\n+\n+  /**\n+   * @param name The name to look for.\n+   * @param call The call to look for.\n+   * @return The return the Nth CALL node to name found in a pre-order\n+   * traversal.\n+   */\n+  private static Node findCall(\n+      Node root, @Nullable final String name, final int call) {\n+    class Find {\n+      int found = 0;\n+      Node find(Node n) {\n+        if (n.getType() == Token.CALL) {\n+          Node callee = n.getFirstChild();\n+          if (name == null || (callee.getType() == Token.NAME\n+              && callee.getString().equals(name))) {\n+            found++;\n+            if (found == call) {\n+              return n;\n+            }\n+          }\n+        }\n+\n+        for (Node c : n.children()) {\n+          Node result = find(c);\n+          if (result != null) {\n+            return result;\n+          }\n+        }\n+\n+        return null;\n+      }\n+    }\n+\n+    return (new Find()).find(root);\n+  }\n+\n+  private static Node parse(Compiler compiler, String js) {\n+    Node n = compiler.parseTestCode(js);\n+    assertEquals(0, compiler.getErrorCount());\n+    return n;\n+  }\n+}", "timestamp": 1289584016, "metainfo": ""}