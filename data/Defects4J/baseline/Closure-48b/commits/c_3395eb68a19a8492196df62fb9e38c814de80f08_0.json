{"sha": "3395eb68a19a8492196df62fb9e38c814de80f08", "log": "Collect aliases before collecting usages Fixes issue 548  R=johnlenz DELTA=148  (92 added, 30 deleted, 26 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=3188   ", "commit": "\n--- a/src/com/google/javascript/jscomp/Scope.java\n+++ b/src/com/google/javascript/jscomp/Scope.java\n     return vars.values().iterator();\n   }\n \n+  /**\n+   * Return an iterable over all of the variables declared in this scope.\n+   */\n+  Iterable<Var> getVarIterable() {\n+    return vars.values();\n+  }\n+\n   @Override\n   public Iterable<Var> getReferences(Var var) {\n     return ImmutableList.of(var);\n--- a/src/com/google/javascript/jscomp/ScopedAliases.java\n+++ b/src/com/google/javascript/jscomp/ScopedAliases.java\n import com.google.javascript.rhino.SourcePosition;\n import com.google.javascript.rhino.Token;\n \n+import java.util.Collection;\n import java.util.List;\n import java.util.Map;\n \n       }\n \n       // Remove the alias definitions.\n-      for (Node aliasDefinition : traversal.getAliasDefinitions()) {\n+      for (Node aliasDefinition : traversal.getAliasDefinitionsInOrder()) {\n         if (aliasDefinition.getParent().getType() == Token.VAR &&\n             aliasDefinition.getParent().hasOneChild()) {\n           aliasDefinition.getParent().detachFromParent();\n       }\n \n       if (traversal.getAliasUsages().size() > 0 ||\n-          traversal.getAliasDefinitions().size() > 0 ||\n+          traversal.getAliasDefinitionsInOrder().size() > 0 ||\n           traversal.getScopeCalls().size() > 0) {\n         compiler.reportCodeChange();\n       }\n \n   private class Traversal implements NodeTraversal.ScopedCallback {\n     // The job of this class is to collect these three data sets.\n-    private final List<Node> aliasDefinitions = Lists.newArrayList();\n+\n+    // The order of this list determines the order that aliases are applied.\n+    private final List<Node> aliasDefinitionsInOrder = Lists.newArrayList();\n \n     private final List<Node> scopeCalls = Lists.newArrayList();\n \n \n     private AliasTransformation transformation = null;\n \n-    List<Node> getAliasDefinitions() {\n-      return aliasDefinitions;\n+    Collection<Node> getAliasDefinitionsInOrder() {\n+      return aliasDefinitionsInOrder;\n     }\n \n     private List<AliasUsage> getAliasUsages() {\n       if (n != null && isCallToScopeMethod(n)) {\n         transformation = transformationHandler.logAliasTransformation(\n             n.getSourceFileName(), getSourceRegion(n));\n+        findAliases(t);\n       }\n     }\n \n       hasErrors = true;\n     }\n \n-    @Override\n-    public void visit(NodeTraversal t, Node n, Node parent) {\n-      if (isCallToScopeMethod(n)) {\n-        if (preprocessorSymbolTable != null) {\n-          preprocessorSymbolTable.addReference(n.getFirstChild());\n-        }\n-        if (!NodeUtil.isExpressionNode(parent)) {\n-          report(t, n, GOOG_SCOPE_USED_IMPROPERLY);\n-        }\n-        if (n.getChildCount() != 2) {\n-          // The goog.scope call should have exactly 1 parameter.  The first\n-          // child is the \"goog.scope\" and the second should be the parameter.\n-          report(t, n, GOOG_SCOPE_HAS_BAD_PARAMETERS);\n-        } else {\n-          Node anonymousFnNode = n.getChildAtIndex(1);\n-          if (!NodeUtil.isFunction(anonymousFnNode) ||\n-              NodeUtil.getFunctionName(anonymousFnNode) != null ||\n-              NodeUtil.getFunctionParameters(anonymousFnNode).hasChildren()) {\n-            report(t, anonymousFnNode, GOOG_SCOPE_HAS_BAD_PARAMETERS);\n-          } else {\n-            scopeCalls.add(n);\n-          }\n-        }\n-      }\n-\n-\n-      if (t.getScopeDepth() == 2) {\n+    private void findAliases(NodeTraversal t) {\n+      Scope scope = t.getScope();\n+      for (Var v : scope.getVarIterable()) {\n+        Node n = v.getNode();\n         int type = n.getType();\n-        if (type == Token.NAME && parent.getType() == Token.VAR) {\n+        Node parent = n.getParent();\n+        if (parent.getType() == Token.VAR) {\n           if (n.hasChildren() && n.getFirstChild().isQualifiedName()) {\n             String name = n.getString();\n-            Var aliasVar = t.getScope().getVar(name);\n+            Var aliasVar = scope.getVar(name);\n             aliases.put(name, aliasVar);\n-            aliasDefinitions.add(n);\n+\n             String qualifiedName =\n                 aliasVar.getInitialValue().getQualifiedName();\n             transformation.addAlias(name, qualifiedName);\n-            return;\n           } else {\n             // TODO(robbyw): Support using locals for private variables.\n             report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n           }\n         }\n-\n-        if (type == Token.NAME && NodeUtil.isAssignmentOp(parent) &&\n-            n == parent.getFirstChild()) {\n-          report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n+      }\n+    }\n+\n+    private void validateScopeCall(NodeTraversal t, Node n, Node parent) {\n+      if (preprocessorSymbolTable != null) {\n+        preprocessorSymbolTable.addReference(n.getFirstChild());\n+      }\n+      if (!NodeUtil.isExpressionNode(parent)) {\n+        report(t, n, GOOG_SCOPE_USED_IMPROPERLY);\n+      }\n+      if (n.getChildCount() != 2) {\n+        // The goog.scope call should have exactly 1 parameter.  The first\n+        // child is the \"goog.scope\" and the second should be the parameter.\n+        report(t, n, GOOG_SCOPE_HAS_BAD_PARAMETERS);\n+      } else {\n+        Node anonymousFnNode = n.getChildAtIndex(1);\n+        if (!NodeUtil.isFunction(anonymousFnNode) ||\n+            NodeUtil.getFunctionName(anonymousFnNode) != null ||\n+            NodeUtil.getFunctionParameters(anonymousFnNode).hasChildren()) {\n+          report(t, anonymousFnNode, GOOG_SCOPE_HAS_BAD_PARAMETERS);\n+        } else {\n+          scopeCalls.add(n);\n+        }\n+      }\n+    }\n+\n+    @Override\n+    public void visit(NodeTraversal t, Node n, Node parent) {\n+      if (isCallToScopeMethod(n)) {\n+        validateScopeCall(t, n, n.getParent());\n+      }\n+\n+      if (t.getScopeDepth() < 2) {\n+        return;\n+      }\n+\n+      int type = n.getType();\n+      Var aliasVar = null;\n+      if (type == Token.NAME) {\n+        String name = n.getString();\n+        Var lexicalVar = t.getScope().getVar(n.getString());\n+        if (lexicalVar != null && lexicalVar == aliases.get(name)) {\n+          aliasVar = lexicalVar;\n+        }\n+      }\n+\n+      // Validate the top level of the goog.scope block.\n+      if (t.getScopeDepth() == 2) {\n+        if (aliasVar != null && NodeUtil.isLValue(n)) {\n+          if (aliasVar.getNode() == n) {\n+            aliasDefinitionsInOrder.add(n);\n+\n+            // Return early, to ensure that we don't record a definition\n+            // twice.\n+            return;\n+          } else {\n+            report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n+          }\n         }\n \n         if (type == Token.RETURN) {\n         }\n       }\n \n+      // Validate all descendent scopes of the goog.scope block.\n       if (t.getScopeDepth() >= 2) {\n-        if (n.getType() == Token.NAME) {\n-          String name = n.getString();\n-          Var aliasVar = aliases.get(name);\n-\n-          // Check if this name points to an alias.\n-          if (aliasVar != null &&\n-              t.getScope().getVar(name) == aliasVar) {\n-            // Note, to support the transitive case, it's important we don't\n-            // clone aliasedNode here.  For example,\n-            // var g = goog; var d = g.dom; d.createElement('DIV');\n-            // The node in aliasedNode (which is \"g\") will be replaced in the\n-            // changes pass above with \"goog\".  If we cloned here, we'd end up\n-            // with <code>g.dom.createElement('DIV')</code>.\n-            Node aliasedNode = aliasVar.getInitialValue();\n-            aliasUsages.add(new AliasedNode(n, aliasedNode));\n-          }\n+        // Check if this name points to an alias.\n+        if (aliasVar != null) {\n+          // Note, to support the transitive case, it's important we don't\n+          // clone aliasedNode here.  For example,\n+          // var g = goog; var d = g.dom; d.createElement('DIV');\n+          // The node in aliasedNode (which is \"g\") will be replaced in the\n+          // changes pass above with \"goog\".  If we cloned here, we'd end up\n+          // with <code>g.dom.createElement('DIV')</code>.\n+          Node aliasedNode = aliasVar.getInitialValue();\n+          aliasUsages.add(new AliasedNode(n, aliasedNode));\n         }\n \n         JSDocInfo info = n.getJSDocInfo();\n--- a/test/com/google/javascript/jscomp/ScopedAliasesTest.java\n+++ b/test/com/google/javascript/jscomp/ScopedAliasesTest.java\n \n   private void testTypes(String aliases, String code) {\n     testScopedNoChanges(aliases, code);\n+    verifyTypes();\n+  }\n+\n+  private void verifyTypes() {\n     Compiler lastCompiler = getLastCompiler();\n     new TypeVerifyingPass(lastCompiler).process(lastCompiler.externsRoot,\n         lastCompiler.jsRoot);\n         \"\"\n         + \"/** @type {function() : x} */ types.actual;\"\n         + \"/** @type {function() : goog.Timer} */ types.expected;\");\n+  }\n+\n+  public void testForwardJsDoc() {\n+    testScoped(\n+        \"/**\\n\" +\n+        \" * @constructor\\n\" +\n+        \" */\\n\" +\n+        \"foo.Foo = function() {};\" +\n+        \"/** @param {Foo.Bar} x */ function actual(x) {3}\" +\n+        \"var Foo = foo.Foo;\" +\n+        \"/** @constructor */ Foo.Bar = function() {};\" +\n+        \"/** @param {foo.Foo.Bar} x */ function expected(x) {}\",\n+\n+        \"/**\\n\" +\n+        \" * @constructor\\n\" +\n+        \" */\\n\" +\n+        \"foo.Foo = function() {};\" +\n+        \"/** @param {foo.Foo.Bar} x */ function actual(x) {3}\" +\n+        \"/** @constructor */ foo.Foo.Bar = function() {};\" +\n+        \"/** @param {foo.Foo.Bar} x */ function expected(x) {}\");\n+    verifyTypes();\n   }\n \n   public void testTestTypes() {", "timestamp": 1315353547, "metainfo": ""}