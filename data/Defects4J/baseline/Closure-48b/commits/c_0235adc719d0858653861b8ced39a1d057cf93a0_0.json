{"sha": "0235adc719d0858653861b8ced39a1d057cf93a0", "log": "Make DELPROP of a non-reference a parser error  R=acleung DELTA=73  (30 added, 39 deleted, 4 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=2230   ", "commit": "\n--- a/src/com/google/javascript/jscomp/TypeCheck.java\n+++ b/src/com/google/javascript/jscomp/TypeCheck.java\n   //\n   // User errors\n   //\n+  // TODO(nicksantos): delete this\n   static final DiagnosticType BAD_DELETE =\n-      // TODO(user): make this an error\n       DiagnosticType.warning(\n           \"JSC_BAD_DELETE_OPERAND\",\n           \"delete operator needs a reference operand\");\n         break;\n \n       case Token.DELPROP:\n-        if (!isReference(n.getFirstChild())) {\n-          report(t, n, BAD_DELETE);\n-        }\n         ensureTyped(t, n, BOOLEAN_TYPE);\n         break;\n \n     }\n   }\n \n-\n-  /**\n-   * This predicate is used to determine if the node represents an expression\n-   * that is a Reference according to JavaScript definitions.\n-   *\n-   * @param n The node being checked.\n-   * @return true if the sub-tree n is a reference, false otherwise.\n-   */\n-  private static boolean isReference(Node n) {\n-    switch (n.getType()) {\n-      case Token.GETELEM:\n-      case Token.GETPROP:\n-      case Token.NAME:\n-        return true;\n-\n-      default:\n-        return false;\n-    }\n-\n-  }\n-\n   /**\n    * This method gets the JSType from the Node argument and verifies that it is\n    * present.\n--- a/src/com/google/javascript/jscomp/parsing/IRFactory.java\n+++ b/src/com/google/javascript/jscomp/parsing/IRFactory.java\n         operand.setDouble(-operand.getDouble());\n         return operand;\n       } else {\n-        if (type == Token.INC || type == Token.DEC) {\n+        if (type == Token.DELPROP &&\n+            !(operand.getType() == Token.GETPROP ||\n+              operand.getType() == Token.GETELEM ||\n+              operand.getType() == Token.NAME)) {\n+          String msg =\n+              \"Invalid delete operand. Only properties can be deleted.\";;\n+          errorReporter.error(\n+              msg,\n+              sourceName,\n+              operand.getLineno(), \"\", 0);\n+        } else  if (type == Token.INC || type == Token.DEC) {\n           if (!validAssignmentTarget(operand)) {\n             String msg = (type == Token.INC)\n                 ? \"invalid increment target\"\n                 : \"invalid decrement target\";\n             errorReporter.error(\n-              msg,\n-              sourceName,\n-              operand.getLineno(), \"\", 0);\n+                msg,\n+                sourceName,\n+                operand.getLineno(), \"\", 0);\n           }\n         }\n \n--- a/test/com/google/javascript/jscomp/LooseTypeCheckTest.java\n+++ b/test/com/google/javascript/jscomp/LooseTypeCheckTest.java\n     testTypes(\n         \"/**@return {void}*/function foo(){\" +\n         \"/** @type {undefined|number} */var a;if (a == foo())return;}\");\n-  }\n-\n-  public void testTypeCheck7() throws Exception {\n-    testTypes(\"function foo() {delete 'abc';}\",\n-        TypeCheck.BAD_DELETE);\n   }\n \n   public void testTypeCheck8() throws Exception {\n--- a/test/com/google/javascript/jscomp/TypeCheckTest.java\n+++ b/test/com/google/javascript/jscomp/TypeCheckTest.java\n     testTypes(\n         \"/**@return {void}*/function foo(){\" +\n         \"/** @type {undefined|number} */var a;if (a == foo())return;}\");\n-  }\n-\n-  public void testTypeCheck7() throws Exception {\n-    testTypes(\"function foo() {delete 'abc';}\",\n-        TypeCheck.BAD_DELETE);\n   }\n \n   public void testTypeCheck8() throws Exception {\n--- a/test/com/google/javascript/jscomp/jsonml/JsonMLConversionTest.java\n+++ b/test/com/google/javascript/jscomp/jsonml/JsonMLConversionTest.java\n   public void testDelete() throws Exception {\n     testConversion(\"delete a\");\n     testConversion(\"delete a.x\");\n-    testConversion(\"delete f()\");\n     testConversion(\"delete a[0]\");\n-    testConversion(\"delete a.x()\");\n     testConversion(\"delete a.x[0]\");\n-    testConversion(\"delete a.x[0]()\");\n-    testConversion(\"delete (a.x[0]())('a', 'b')\");\n   }\n \n   public void testDirectives() throws Exception {\n--- a/test/com/google/javascript/jscomp/parsing/IRFactoryTest.java\n+++ b/test/com/google/javascript/jscomp/parsing/IRFactoryTest.java\n     parse(\"debugger;\");\n   }\n \n+  public void testDelete1() {\n+    testNoParseError(\"delete a.b;\");\n+  }\n+\n+  public void testDelete2() {\n+    testNoParseError(\"delete a['b'];\");\n+  }\n+\n+  public void testDelete3() {\n+    // This is allowed in ES3 and ES5, but not in ES5/strict. There\n+    // is a strict mode check for this.\n+    testNoParseError(\"delete a;\");\n+  }\n+\n+  public void testDelete4() {\n+    testParseError(\"delete 'x';\",\n+        \"Invalid delete operand. Only properties can be deleted.\");\n+  }\n+\n   public void testCommentPositions1() {\n     Node root = newParse(\"/** @param {string} x */function a(x) {};\" +\n         \"/** @param {string} x */function b(x) {}\");", "timestamp": 1307646116, "metainfo": ""}