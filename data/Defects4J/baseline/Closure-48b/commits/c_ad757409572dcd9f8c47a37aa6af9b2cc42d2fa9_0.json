{"sha": "ad757409572dcd9f8c47a37aa6af9b2cc42d2fa9", "log": "Fix source map generation when used with the module set interface. - allow the generation of empty source maps - maintain source column information when a CodeBuilder is \"reset\".  R=chrisn DELTA=107  (97 added, 6 deleted, 4 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=89003   ", "commit": "\n--- a/src/com/google/javascript/jscomp/Compiler.java\n+++ b/src/com/google/javascript/jscomp/Compiler.java\n   public static class CodeBuilder {\n     private final StringBuilder sb = new StringBuilder();\n     private int lineCount = 0;\n+    private int colCount = 0;\n \n     /** Removes all text, but leaves the line count unchanged. */\n     void reset() {\n     CodeBuilder append(String str) {\n       sb.append(str);\n \n-      // Move the line count to the end of the new text.\n+      // Adjust the line and column information for the new text.\n       int index = -1;\n+      int lastIndex = index;\n       while ((index = str.indexOf('\\n', index + 1)) >= 0) {\n         ++lineCount;\n+        lastIndex = index;\n+      }\n+\n+      if (lastIndex == -1) {\n+        // No new lines, append the new characters added.\n+        colCount += str.length();\n+      } else {\n+        colCount = str.length() - (lastIndex + 1);\n       }\n \n       return this;\n \n     /** Returns the (zero-based) index of the last column in the text buffer. */\n     int getColumnIndex() {\n-      int index = sb.lastIndexOf(\"\\n\");\n-      return (index >= 0) ? sb.length() - (index + 1) : sb.length();\n+      return colCount;\n     }\n \n     /** Determines whether the text ends with the given suffix. */\n--- a/src/com/google/javascript/jscomp/SourceMap.java\n+++ b/src/com/google/javascript/jscomp/SourceMap.java\n   private List<Mapping> mappings = Lists.newArrayList();\n \n   /**\n+   * For validation store the start of the last mapping added.\n+   */\n+  private Mapping lastMapping;\n+\n+  /**\n    * The position that the current source map is offset in the\n    * buffer being used to generated the compiled source file.\n    */\n                        endPosition.getCharacterIndex() + endOffsetPosition);\n     }\n \n+    // Validate the mappings are in a proper order.\n+    if (lastMapping != null) {\n+      int lastLine = lastMapping.startPosition.getLineNumber();\n+      int lastColumn = lastMapping.startPosition.getCharacterIndex();\n+      int nextLine = mapping.startPosition.getLineNumber();\n+      int nextColumn = mapping.startPosition.getCharacterIndex();\n+      Preconditions.checkState(nextLine > lastLine\n+          || (nextLine == lastLine && nextColumn >= lastColumn),\n+          \"Incorrect source mappings order, previous : (%s,%s)\\n\"\n+          + \"new : (%s,%s)\\nnode : %s\",\n+          lastLine, lastColumn, nextLine, nextColumn, node);\n+    }\n+\n+    lastMapping = mapping;\n     mappings.add(mapping);\n   }\n \n    * @param offsetIndex The column index of the current character being printed.\n    */\n   void setStartingPosition(int offsetLine, int offsetIndex) {\n-    // TODO(johnlenz): correct this.\n-    // Preconditions.checkState(mappings.isEmpty(),\n-    //     \"Must be set prior to adding mappings\");\n+    Preconditions.checkState(offsetLine >= 0);\n+    Preconditions.checkState(offsetIndex >= 0);\n     offsetPosition = new Position(offsetLine, offsetIndex);\n   }\n \n    */\n   public void reset() {\n     mappings = Lists.newArrayList();\n+    lastMapping = null;\n     offsetPosition = new Position(0, 0);\n     prefixPosition = new Position(0, 0);\n   }\n \n     // Append the line mapping entries.\n     void appendLineMappings() throws IOException {\n-      Preconditions.checkState(!mappings.isEmpty());\n-\n       // Start the first line.\n       openLine();\n \n \n     // Append the line mapping entries.\n     void traverse(MappingVisitor v) throws IOException {\n-      Preconditions.checkState(!mappings.isEmpty());\n-\n       // The mapping list is ordered as a pre-order traversal.  The mapping\n       // positions give us enough information to rebuild the stack and this\n       // allows the building of the source map in O(n) time.\n--- /dev/null\n+++ b/test/com/google/javascript/jscomp/CompilerTest.java\n+/*\n+ * Copyright 2010 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+import com.google.javascript.rhino.Node;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * @author johnlenz@google.com (John Lenz)\n+ */\n+public class CompilerTest extends TestCase {\n+\n+  public void testCodeBuilderColumnAfterResetDummy() {\n+    Compiler compiler = new Compiler();\n+    Node n = compiler.parseTestCode(\"\");\n+    Compiler.CodeBuilder cb = new Compiler.CodeBuilder();\n+  }\n+\n+  // Verify the line and column information is maintained after a reset\n+  public void testCodeBuilderColumnAfterReset() {\n+    Compiler.CodeBuilder cb = new Compiler.CodeBuilder();\n+    String js = \"foo();\\ngoo();\";\n+    cb.append(js);\n+    assertEquals(js, cb.toString());\n+    assertEquals(1, cb.getLineIndex());\n+    assertEquals(6, cb.getColumnIndex());\n+\n+    cb.reset();\n+\n+    assertTrue(cb.toString().isEmpty());\n+    assertEquals(1, cb.getLineIndex());\n+    assertEquals(6, cb.getColumnIndex());\n+  }\n+\n+  public void testCodeBuilderAppend() {\n+    Compiler.CodeBuilder cb = new Compiler.CodeBuilder();\n+    cb.append(\"foo();\");\n+    assertEquals(0, cb.getLineIndex());\n+    assertEquals(6, cb.getColumnIndex());\n+\n+    cb.append(\"goo();\");\n+\n+    assertEquals(0, cb.getLineIndex());\n+    assertEquals(12, cb.getColumnIndex());\n+    \n+    // newline reset the column index\n+    cb.append(\"blah();\\ngoo();\");\n+\n+    assertEquals(1, cb.getLineIndex());\n+    assertEquals(6, cb.getColumnIndex());    \n+  }\n+}", "timestamp": 1280951332, "metainfo": ""}