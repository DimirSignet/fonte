{"sha": "d7a094a288f86ca58bf05c9867320096e468c45e", "log": "Change on 2010/05/26 by nicksantos  \topen up JsMessageExtractor  \tR=johnlenz \tDELTA=33  (29 added, 2 deleted, 2 changed)    Revision created by MOE tool push_codebase. MOE_MIGRATION=14001   ", "commit": "\n--- /dev/null\n+++ b/src/com/google/javascript/jscomp/JsMessageExtractor.java\n+/*\n+ * Copyright 2004 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Iterables;\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.Sets;\n+import com.google.javascript.rhino.Node;\n+\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.List;\n+\n+\n+/**\n+ * Extracts messages and message comments from JS code, and writes them to a\n+ * properties file, an XMB file, or an XLB, to facilitate translation.\n+ *\n+ * <p> Uses a special prefix (e.g. {@code MSG_}) to determine which variables\n+ * are messages. Here are the recognized formats:\n+ *\n+ *   <code>\n+ *   var MSG_FOO = \"foo\";\n+ *   var MSG_FOO_HELP = \"this message is used for foo\";\n+ *   </code>\n+ *\n+ *   <code>\n+ *   var MSG_BAR = function(a, b) {\n+ *     return a + \" bar \" + b;\n+ *   }\n+ *   var MSG_BAR_HELP = \"the bar message\";\n+ *   </code>\n+ *\n+ * <p>This class enforces the policy that message variable names must be unique\n+ * across all JS files.\n+ *\n+*\n+*\n+ */\n+public class JsMessageExtractor {\n+\n+  private final JsMessage.Style style;\n+  private final JsMessage.IdGenerator idGenerator;\n+\n+  public JsMessageExtractor(JsMessage.IdGenerator idGenerator,\n+      JsMessage.Style style) {\n+    this.idGenerator = idGenerator;\n+    this.style = style;\n+  }\n+\n+  /**\n+   * Visitor that collects messages.\n+   */\n+  private class ExtractMessagesVisitor extends JsMessageVisitor {\n+    // We use List here as we want to preserve insertion-order for found\n+    // messages.\n+    // Take into account that messages with the same id could be present in the\n+    // result list. Message could have the same id only in case if they are\n+    // unnamed and have the same text but located in different source files.\n+    private final List<JsMessage> messages = Lists.newLinkedList();\n+\n+    private ExtractMessagesVisitor(AbstractCompiler compiler) {\n+      super(compiler, true, style, idGenerator);\n+    }\n+\n+    @Override\n+    protected void processJsMessage(JsMessage message,\n+        JsMessageDefinition definition) {\n+      if (!message.isExternal()) {\n+        messages.add(message);\n+      }\n+    }\n+\n+    /**\n+     * Returns extracted messages.\n+     *\n+     * @return collection of JsMessage objects that was found in js sources.\n+     */\n+    public Collection<JsMessage> getMessages() {\n+      return messages;\n+    }\n+  }\n+\n+  /**\n+   * Extracts js messages from javascript code.\n+   */\n+  public Collection<JsMessage> extractMessages(JSSourceFile... inputs)\n+      throws IOException {\n+    return extractMessages(ImmutableList.copyOf(inputs));\n+  }\n+\n+\n+  /**\n+   * Extracts js messages from javascript code.\n+   *\n+   * @param inputs  the javascript source code inputs\n+   * @return the extracted messages collection\n+   * @throws IOException if there is a problem reading the js code\n+   * @throws RuntimeException if there are problems parsing the js code or the\n+   *     js messages, or if two messages have the same key\n+   */\n+  public Collection<JsMessage> extractMessages(\n+      Iterable<JSSourceFile> inputs) throws IOException {\n+\n+    Compiler compiler = new Compiler();\n+    compiler.init(\n+        new JSSourceFile[] {},\n+        Iterables.toArray(inputs, JSSourceFile.class),\n+        new CompilerOptions());\n+\n+    ExtractMessagesVisitor extractCompilerPass =\n+        new ExtractMessagesVisitor(compiler);\n+    for (JSSourceFile input : inputs) {\n+      // Parse the js files individually, to prevent out-of-memory\n+      // problems.\n+      Node root = new JsAst(input).getAstRoot(compiler);\n+\n+      // Traverse the returned nodes and extract messages.\n+      extractCompilerPass.process(null, root);\n+    }\n+\n+    JSError[] errors = compiler.getErrors();\n+    // Check for errors.\n+    if (errors.length > 0) {\n+      StringBuilder msg = new StringBuilder(\"JSCompiler errors\\n\");\n+      MessageFormatter formatter = new LightweightMessageFormatter(compiler);\n+      for (JSError e : errors) {\n+        msg.append(formatter.formatError(e));\n+      }\n+      throw new RuntimeException(msg.toString());\n+    }\n+\n+    return extractCompilerPass.getMessages();\n+  }\n+}\n--- a/src/com/google/javascript/jscomp/parsing/IRFactory.java\n+++ b/src/com/google/javascript/jscomp/parsing/IRFactory.java\n         // Old Rhino tagged the empty name node with the line number of the\n         // declaration.\n         newName.setLineno(functionNode.getLineno());\n-        // TODO(user) Mark line number of paren correctly.\n+        // TODO(bowdidge) Mark line number of paren correctly.\n         // Same problem as below - the left paren might not be on the\n         // same line as the function keyword.\n         int lpColumn = functionNode.getAbsolutePosition() +\n       // appeared on.  We know the paren has to appear on the same line as the\n       // function name (or else a semicolon will be inserted.)  If there's no\n       // function name, assume the paren was on the same line as the function.\n-      // TODO(user): Mark line number of paren correctly.\n+      // TODO(bowdidge): Mark line number of paren correctly.\n       Name fnName = functionNode.getFunctionName();\n       if (fnName != null) {\n         lp.setLineno(fnName.getLineno());\n--- /dev/null\n+++ b/test/com/google/javascript/jscomp/JsMessageExtractorTest.java\n+/*\n+ * Copyright 2004 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+import static com.google.javascript.jscomp.JsMessage.Style.RELAX;\n+\n+import com.google.common.base.Joiner;\n+\n+import junit.framework.TestCase;\n+\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.Iterator;\n+\n+/**\n+ * Unit test for {@link JsMessageExtractor}.\n+ *\n+*\n+ */\n+public class JsMessageExtractorTest extends TestCase {\n+\n+  private Collection<JsMessage> extractMessages(String... js) {\n+    try {\n+      String sourceCode = Joiner.on(\"\\n\").join(js);\n+      return new JsMessageExtractor(null, RELAX)\n+          .extractMessages(JSSourceFile.fromCode(\"testcode\", sourceCode));\n+    } catch (IOException e) {\n+      fail(e.getMessage());\n+      return null;\n+    }\n+  }\n+\n+  private JsMessage extractMessage(String... js) {\n+    Collection<JsMessage> messages = extractMessages(js);\n+    assertEquals(1, messages.size());\n+    return messages.iterator().next();\n+  }\n+\n+  public void testSyntaxError1() {\n+    try {\n+      extractMessage(\"if (true) {}}\");\n+      fail(\"Expected exception\");\n+    } catch (RuntimeException e) {\n+      assertEquals(\"JSCompiler errors\\n\" +\n+          \"testcode:1: ERROR - Parse error. syntax error\\n\", e.getMessage());\n+    }\n+  }\n+\n+  public void testSyntaxError2() {\n+    try {\n+      extractMessage(\"\", \"if (true) {}}\");\n+      fail(\"Expected exception\");\n+    } catch (RuntimeException e) {\n+      assertEquals(\"JSCompiler errors\\n\" +\n+          \"testcode:2: ERROR - Parse error. syntax error\\n\", e.getMessage());\n+    }\n+  }\n+\n+  public void testExtractNewStyleMessage1() {\n+    // A simple message with no description.\n+    assertEquals(\n+        new JsMessage.Builder(\"MSG_SILLY\")\n+            .appendStringPart(\"silly test message\")\n+            .build(),\n+        extractMessage(\"var MSG_SILLY = goog.getMsg('silly test message');\"));\n+  }\n+\n+  public void testExtractNewStyleMessage2() {\n+    // A message with placeholders and meta data.\n+    assertEquals(\n+        new JsMessage.Builder(\"MSG_WELCOME\")\n+            .appendStringPart(\"Hi \")\n+            .appendPlaceholderReference(\"userName\")\n+            .appendStringPart(\"! Welcome to \")\n+            .appendPlaceholderReference(\"product\")\n+            .appendStringPart(\".\")\n+            .setDesc(\"The welcome message.\")\n+            .setIsHidden(true)\n+            .build(),\n+        extractMessage(\n+            \"/**\",\n+            \" * @desc The welcome\",\n+            \" *   message.\",\n+            \" *\",\n+            \" * @hidden\",\n+            \" */\",\n+            \"var MSG_WELCOME = goog.getMsg(\",\n+            \"    'Hi {$userName}! Welcome to {$product}.',\",\n+            \"    {userName: someUserName, product: getProductName()});\"));\n+  }\n+\n+  public void testExtractOldStyleMessage1() {\n+    // Description before the message.\n+    assertEquals(\n+        new JsMessage.Builder(\"MSG_SILLY\")\n+            .appendStringPart(\"silly test message\")\n+            .setDesc(\"Description.\")\n+            .build(),\n+        extractMessage(\n+            \"var MSG_SILLY_HELP = 'Description.';\",\n+            \"var MSG_SILLY = 'silly test message';\"));\n+  }\n+\n+  public void testExtractOldStyleMessage2() {\n+    // Description after the message, broken into parts.\n+    assertEquals(\n+        new JsMessage.Builder(\"MSG_SILLY\")\n+            .appendStringPart(\"silly test message\")\n+            .setDesc(\"Description.\")\n+            .build(),\n+        extractMessage(\n+            \"var MSG_SILLY = 'silly test message';\",\n+            \"var MSG_SILLY_HELP = 'Descrip' + 'tion.';\"));\n+  }\n+\n+  public void testExtractOldStyleMessage3() {\n+    // Function-style message with two placeholders and no description.\n+    assertEquals(\n+        new JsMessage.Builder(\"MSG_SILLY\")\n+            .appendPlaceholderReference(\"one\")\n+            .appendStringPart(\", \")\n+            .appendPlaceholderReference(\"two\")\n+            .appendStringPart(\", buckle my shoe\")\n+            .build(),\n+        extractMessage(\n+            \"var MSG_SILLY = function(one, two) {\",\n+            \"  return one + ', ' + two + ', buckle my shoe';\",\n+            \"};\"));\n+  }\n+\n+  public void testExtractMixedMessages() {\n+    // Several mixed-style messages in succession, one containing newlines.\n+    Iterator<JsMessage> msgs = extractMessages(\n+        \"var MSG_MONEY = function(amount) {\",\n+        \"  return 'You owe $' + amount +\",\n+        \"         ' to the credit card company.';\",\n+        \"};\",\n+        \"var MSG_TIME = goog.getMsg('You need to finish your work in ' +\",\n+        \"                           '{$duration} hours.', {'duration': d});\",\n+        \"var MSG_NAG = 'Clean your room.\\\\n\\\\nWash your clothes.';\",\n+        \"var MSG_NAG_HELP = 'Just some ' +\",\n+        \"                   'nags.';\").iterator();\n+\n+    assertEquals(\n+        new JsMessage.Builder(\"MSG_MONEY\")\n+            .appendStringPart(\"You owe $\")\n+            .appendPlaceholderReference(\"amount\")\n+            .appendStringPart(\" to the credit card company.\")\n+            .build(),\n+        msgs.next());\n+    assertEquals(\n+        new JsMessage.Builder(\"MSG_TIME\")\n+            .appendStringPart(\"You need to finish your work in \")\n+            .appendPlaceholderReference(\"duration\")\n+            .appendStringPart(\" hours.\")\n+            .build(),\n+        msgs.next());\n+    assertEquals(\n+        new JsMessage.Builder(\"MSG_NAG\")\n+            .appendStringPart(\"Clean your room.\\n\\nWash your clothes.\")\n+            .setDesc(\"Just some nags.\")\n+            .build(),\n+        msgs.next());\n+  }\n+\n+  public void testDuplicateUnnamedVariables() {\n+    // Make sure that duplicate unnamed variables don't get swallowed when using\n+    // a Google-specific ID generator.\n+    Collection<JsMessage> msgs = extractMessages(\n+        \"function a() {\",\n+        \"  var MSG_UNNAMED_2 = goog.getMsg('foo');\",\n+        \"}\",\n+        \"function b() {\",\n+        \"  var MSG_UNNAMED_2 = goog.getMsg('bar');\",\n+        \"}\");\n+\n+    assertEquals(2, msgs.size());\n+    final Iterator<JsMessage> iter = msgs.iterator();\n+    assertEquals(\"foo\", iter.next().toString());\n+    assertEquals(\"bar\", iter.next().toString());\n+  }\n+\n+  private void assertEquals(JsMessage expected, JsMessage actual) {\n+    assertEquals(expected.getKey(), actual.getKey());\n+    assertEquals(expected.parts(), actual.parts());\n+    assertEquals(expected.placeholders(), actual.placeholders());\n+    assertEquals(expected.getDesc(), actual.getDesc());\n+    assertEquals(expected.isHidden(), actual.isHidden());\n+  }\n+}\n--- a/test/com/google/javascript/jscomp/parsing/IRFactoryTest.java\n+++ b/test/com/google/javascript/jscomp/parsing/IRFactoryTest.java\n     assertNodePosition(1, 0, forNode);\n     assertNodePosition(2, 0, initClause);\n     assertNodePosition(3, 0, condClause);\n-    // TODO(user) Incorrectly gets charno position when EmptyExpression\n+    // TODO(bowdidge) Incorrectly gets charno position when EmptyExpression\n     // has its absolute position on the carriage return.  For now, the\n     // line number gets reported correctly (on the next line) but the\n     // character position is -1, so the overall line/char pair in our tree\n     Node lastNameComponent = firstNameComponent.getNext();\n \n     assertNodePosition(3, 4, functionCall);\n-    // TODO(user) New Rhino doesn't keep the position of the dot handy.\n+    // TODO(bowdidge) New Rhino doesn't keep the position of the dot handy.\n     // New Rhino treats the location of the qualified name as the beginning of\n     // the whole name.\n     // assertNodePosition(1, 0, firstNameComponent);\n     Node fnName = fnNode.getFirstChild();\n \n     assertNodePosition(2, 1, fnAssignment);\n-    // TODO(user) New Rhino doesn't keep track of the position of the dot.\n+    // TODO(bowdidge) New Rhino doesn't keep track of the position of the dot.\n     //assertNodePosition(1, 1, aDotbName);\n     assertNodePosition(1, 0, aName);\n     assertNodePosition(2, 0, bName);", "timestamp": 1274897790, "metainfo": ""}