{"sha": "a430f6187fd62e57fccbab1a2e4555ac6a555eeb", "log": "Add the ablity to consume V3 index maps.  R=jschorr DELTA=270  (247 added, 8 deleted, 15 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=1965   ", "commit": "\n--- a/src/com/google/debugging/sourcemap/SourceMapConsumerFactory.java\n+++ b/src/com/google/debugging/sourcemap/SourceMapConsumerFactory.java\n    */\n   public static SourceMapping parse(String contents)\n       throws SourceMapParseException {\n+     return parse(contents, null);\n+  }\n+\n+  /**\n+   * @param contents The string representing the source map file contents.\n+   * @param supplier A supplier for any referenced maps.\n+   * @return The parsed source map.\n+   * @throws SourceMapParseException\n+   */\n+  public static SourceMapping parse(String contents, SourceMapSupplier supplier)\n+      throws SourceMapParseException {\n     // Version 1, starts with a magic string\n     if (contents.startsWith(\"/** Begin line maps. **/\")) {\n       SourceMapConsumerV1 consumer =  new SourceMapConsumerV1();\n           }\n           case 3: {\n             SourceMapConsumerV3 consumer =  new SourceMapConsumerV3();\n-            consumer.parse(sourceMapRoot);\n+            consumer.parse(sourceMapRoot, supplier);\n             return consumer;\n           }\n           default:\n--- a/src/com/google/debugging/sourcemap/SourceMapConsumerV3.java\n+++ b/src/com/google/debugging/sourcemap/SourceMapConsumerV3.java\n import org.json.JSONException;\n import org.json.JSONObject;\n \n+import java.io.IOException;\n import java.util.ArrayList;\n \n /**\n \n   }\n \n+  static class DefaultSourceMapSupplier implements SourceMapSupplier {\n+    @Override\n+    public String getSourceMap(String url) {\n+      return null;\n+    }\n+  }\n+\n   /**\n    * Parses the given contents containing a source map.\n    */\n   public void parse(String contents) throws SourceMapParseException {\n+    parse(contents, null);\n+  }\n+\n+  /**\n+   * Parses the given contents containing a source map.\n+   */\n+  public void parse(String contents, SourceMapSupplier sectionSupplier)\n+      throws SourceMapParseException {\n     try {\n       JSONObject sourceMapRoot = new JSONObject(contents);\n-      parse(sourceMapRoot);\n+      parse(sourceMapRoot, sectionSupplier);\n     } catch (JSONException ex) {\n       throw new SourceMapParseException(\"JSON parse exception: \" + ex);\n     }\n    * Parses the given contents containing a source map.\n    */\n   public void parse(JSONObject sourceMapRoot) throws SourceMapParseException {\n+    parse(sourceMapRoot, null);\n+  }\n+\n+  /**\n+   * Parses the given contents containing a source map.\n+   */\n+  public void parse(JSONObject sourceMapRoot, SourceMapSupplier sectionSupplier)\n+      throws SourceMapParseException {\n     try {\n       // Check basic assertions about the format.\n       int version = sourceMapRoot.getInt(\"version\");\n         throw new SourceMapParseException(\"File entry is missing or empty\");\n       }\n \n+      if (sourceMapRoot.has(\"sections\")) {\n+        // Looks like a index map, try to parse it that way.\n+        parseMetaMap(sourceMapRoot, sectionSupplier);\n+        return;\n+      }\n+\n       lineCount = sourceMapRoot.getInt(\"lineCount\");\n       String lineMap = sourceMapRoot.getString(\"mappings\");\n \n       lines = Lists.newArrayListWithCapacity(lineCount);\n \n       new MappingBuilder(lineMap).build();\n+    } catch (JSONException ex) {\n+      throw new SourceMapParseException(\"JSON parse exception: \" + ex);\n+    }\n+  }\n+\n+  /**\n+   * @param sourceMapRoot\n+   * @throws SourceMapParseException\n+   */\n+  private void parseMetaMap(\n+      JSONObject sourceMapRoot, SourceMapSupplier sectionSupplier)\n+      throws SourceMapParseException {\n+    if (sectionSupplier == null) {\n+      sectionSupplier = new DefaultSourceMapSupplier();\n+    }\n+\n+    try {\n+      // Check basic assertions about the format.\n+      int version = sourceMapRoot.getInt(\"version\");\n+      if (version != 3) {\n+        throw new SourceMapParseException(\"Unknown version: \" + version);\n+      }\n+\n+      String file = sourceMapRoot.getString(\"file\");\n+      if (file.isEmpty()) {\n+        throw new SourceMapParseException(\"File entry is missing or empty\");\n+      }\n+\n+      if (sourceMapRoot.has(\"lineCount\")\n+          || sourceMapRoot.has(\"mappings\")\n+          || sourceMapRoot.has(\"sources\")\n+          || sourceMapRoot.has(\"names\")) {\n+        throw new SourceMapParseException(\"Invalid map format\");\n+      }\n+\n+      SourceMapGeneratorV3 generator = new SourceMapGeneratorV3();\n+      JSONArray sections = sourceMapRoot.getJSONArray(\"sections\");\n+      for (int i = 0, count = sections.length(); i < count; i++) {\n+        JSONObject section = sections.getJSONObject(i);\n+        String url = section.getString(\"url\");\n+        JSONObject offset = section.getJSONObject(\"offset\");\n+        int line = offset.getInt(\"line\");\n+        int column = offset.getInt(\"column\");\n+\n+        String mapSectionContents = sectionSupplier.getSourceMap(url);\n+        if (mapSectionContents == null) {\n+          throw new SourceMapParseException(\"Unable to retrieve: \" + url);\n+        }\n+        generator.mergeMapSection(line, column, mapSectionContents);\n+      }\n+\n+      StringBuilder sb = new StringBuilder();\n+      try {\n+        generator.appendTo(sb, file);\n+      } catch (IOException e) {\n+        // Can't happen.\n+        throw new RuntimeException(e);\n+      }\n+\n+      parse(sb.toString());\n+    } catch (IOException ex) {\n+      throw new SourceMapParseException(\"IO exception: \" + ex);\n     } catch (JSONException ex) {\n       throw new SourceMapParseException(\"JSON parse exception: \" + ex);\n     }\n       return getPreviousMapping(lineNumber);\n     }\n \n-    int index = search(entries, column, 0, entries.size() -1);\n-    Preconditions.checkState(index >= 0, \"unexpected:\"+index);\n+    int index = search(entries, column, 0, entries.size() - 1);\n+    Preconditions.checkState(index >= 0, \"unexpected:\" + index);\n     return getOriginalMappingForEntry(entries.get(index));\n   }\n \n   private String[] getJavaStringArray(JSONArray array) throws JSONException {\n     int len = array.length();\n     String[] result = new String[len];\n-    for(int i = 0; i< len; i++) {\n+    for(int i = 0; i < len; i++) {\n       result[i] = array.getString(i);\n     }\n     return result;\n   }\n \n   private class MappingBuilder {\n-    private final static int MAX_ENTRY_VALUES = 5;\n+    private static final int MAX_ENTRY_VALUES = 5;\n     private final StringCharIterator content;\n     private int line = 0;\n     private int previousCol = 0;\n       lineNumber--;\n     } while (lines.get(lineNumber) == null);\n     ArrayList<Entry> entries = lines.get(lineNumber);\n-    return getOriginalMappingForEntry(entries.get(entries.size() -1));\n+    return getOriginalMappingForEntry(entries.get(entries.size() - 1));\n   }\n \n   /**\n--- /dev/null\n+++ b/src/com/google/debugging/sourcemap/SourceMapSupplier.java\n+/*\n+ * Copyright 2011 The Closure Compiler Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.debugging.sourcemap;\n+\n+import java.io.IOException;\n+\n+\n+/**\n+ * A class for mapping source map names to the actual contents. Used\n+ * when parsing index maps.\n+ *\n+ * @author johnlenz@google.com (John Lenz)\n+ */\n+public interface SourceMapSupplier {\n+\n+  /**\n+   * @param url The url of the source map.\n+   * @return The contents of the map associated with the url\n+   * @throws IOException\n+   */\n+  String getSourceMap(String url) throws IOException;\n+}\n--- a/test/com/google/debugging/sourcemap/SourceMapGeneratorV3Test.java\n+++ b/test/com/google/debugging/sourcemap/SourceMapGeneratorV3Test.java\n \n package com.google.debugging.sourcemap;\n \n+import com.google.common.collect.Lists;\n import com.google.common.collect.Maps;\n import com.google.javascript.jscomp.SourceMap;\n import com.google.javascript.jscomp.SourceMap.Format;\n \n import java.io.IOException;\n+import java.io.StringWriter;\n import java.util.LinkedHashMap;\n+import java.util.List;\n \n \n /**\n     assertEquals(files1, files2);\n   }\n \n+  public void testWriteMetaMap() throws IOException {\n+    StringWriter out = new StringWriter();\n+    String name = \"./app.js\";\n+    List<SourceMapSection> appSections = Lists.newArrayList(\n+        new SourceMapSection(\"src1\", 0, 0),\n+        new SourceMapSection(\"src2\", 100, 10),\n+        new SourceMapSection(\"src3\", 150, 5));\n+\n+    SourceMapGeneratorV3 generator = new SourceMapGeneratorV3();\n+    generator.appendIndexMapTo(out, name, appSections);\n+\n+    assertEquals(\n+            \"{\\n\" +\n+            \"\\\"version\\\":3,\\n\" +\n+            \"\\\"file\\\":\\\"./app.js\\\",\\n\" +\n+            \"\\\"sections\\\":[\\n\" +\n+            \"{\\n\" +\n+            \"\\\"offset\\\":{\\n\" +\n+            \"\\\"line\\\":0,\\n\" +\n+            \"\\\"column\\\":0\\n\" +\n+            \"},\\n\" +\n+            \"\\\"url\\\":\\\"src1\\\"\\n\" +\n+            \"},\\n\" +\n+            \"{\\n\" +\n+            \"\\\"offset\\\":{\\n\" +\n+            \"\\\"line\\\":100,\\n\" +\n+            \"\\\"column\\\":10\\n\" +\n+            \"},\\n\" +\n+            \"\\\"url\\\":\\\"src2\\\"\\n\" +\n+            \"},\\n\" +\n+            \"{\\n\" +\n+            \"\\\"offset\\\":{\\n\" +\n+            \"\\\"line\\\":150,\\n\" +\n+            \"\\\"column\\\":5\\n\" +\n+            \"},\\n\" +\n+            \"\\\"url\\\":\\\"src3\\\"\\n\" +\n+            \"}\\n\" +\n+            \"]\\n\" +\n+            \"}\\n\",\n+            out.toString());\n+  }\n+\n+  public void testParseSourceMetaMap() throws Exception {\n+    final String INPUT1 = \"file1\";\n+    final String INPUT2 = \"file2\";\n+    LinkedHashMap<String, String> inputs = Maps.newLinkedHashMap();\n+    inputs.put(INPUT1, \"var __FOO__ = 1;\");\n+    inputs.put(INPUT2, \"var __BAR__ = 2;\");\n+    RunResult result1 = compile(inputs.get(INPUT1), INPUT1);\n+    RunResult result2 = compile(inputs.get(INPUT2), INPUT2);\n+\n+    final String MAP1 = \"map1\";\n+    final String MAP2 = \"map2\";\n+    final LinkedHashMap<String, String> maps = Maps.newLinkedHashMap();\n+    maps.put(MAP1, result1.sourceMapFileContent);\n+    maps.put(MAP2, result2.sourceMapFileContent);\n+\n+    List<SourceMapSection> sections = Lists.newArrayList();\n+\n+    StringBuilder output = new StringBuilder();\n+    FilePosition offset = appendAndCount(output, result1.generatedSource);\n+    sections.add(new SourceMapSection(MAP1, 0, 0));\n+    output.append(result2.generatedSource);\n+    sections.add(\n+         new SourceMapSection(MAP2, offset.getLine(), offset.getColumn()));\n+\n+    SourceMapGeneratorV3 generator = new SourceMapGeneratorV3();\n+    StringBuilder mapContents = new StringBuilder();\n+    generator.appendIndexMapTo(mapContents, \"out.js\", sections);\n+\n+    check(inputs, output.toString(), mapContents.toString(),\n+      new SourceMapSupplier() {\n+        @Override\n+        public String getSourceMap(String url){\n+          return maps.get(url);\n+      }});\n+  }\n+\n   public void testSourceMapMerging() throws Exception {\n     final String INPUT1 = \"file1\";\n     final String INPUT2 = \"file2\";\n     check(inputs, output.toString(), mapContents.toString());\n   }\n \n-  FilePosition appendAndCount(Appendable out, String js) throws IOException {\n+  FilePosition count(String js) {\n     int line = 0, column = 0;\n     for (int i = 0; i < js.length(); i++) {\n       if (js.charAt(i) == '\\n') {\n         column++;\n       }\n     }\n+    return new FilePosition(line, column);\n+  }\n+\n+  FilePosition appendAndCount(Appendable out, String js) throws IOException {\n     out.append(js);\n-    return new FilePosition(line, column);\n-  }\n-\n+    return count(js);\n+  }\n }\n--- a/test/com/google/debugging/sourcemap/SourceMapTestCase.java\n+++ b/test/com/google/debugging/sourcemap/SourceMapTestCase.java\n   protected void check(\n       String inputName, String input, String output,\n       String sourceMapFileContent) {\n-    Map<String, String> inputMap = new LinkedHashMap<String,String>();\n+    Map<String, String> inputMap = new LinkedHashMap<String, String>();\n     inputMap.put(inputName, input);\n     check(inputMap, output, sourceMapFileContent);\n   }\n \n   protected void check(\n-      Map<String,String> originalInputs, String generatedSource,\n+      Map<String, String> originalInputs, String generatedSource,\n       String sourceMapFileContent) {\n+    check(originalInputs, generatedSource, sourceMapFileContent, null);\n+  }\n+\n+  protected void check(\n+      Map<String, String> originalInputs, String generatedSource,\n+      String sourceMapFileContent, SourceMapSupplier supplier) {\n     // Find all instances of the __XXX__ pattern in the original\n     // source code.\n     Map<String, Token> originalTokens = findTokens(originalInputs);\n     // Ensure the token counts match.\n     assertEquals(originalTokens.size(), resultTokens.size());\n \n-    SourceMapConsumer reader = getSourceMapConsumer();\n+    SourceMapping reader;\n     try {\n-      reader.parse(sourceMapFileContent);\n+      reader = SourceMapConsumerFactory.parse(sourceMapFileContent, supplier);\n     } catch (SourceMapParseException e) {\n       throw new RuntimeException(\"unexpected exception\", e);\n     }", "timestamp": 1305924658, "metainfo": ""}