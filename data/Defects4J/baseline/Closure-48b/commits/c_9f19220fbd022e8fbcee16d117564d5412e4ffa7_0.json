{"sha": "9f19220fbd022e8fbcee16d117564d5412e4ffa7", "log": "Better line number information from goog.provide/require handlers  R=johnlenz DELTA=27  (14 added, 6 deleted, 7 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=1251   ", "commit": "\n--- a/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\n+++ b/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\n      */\n     private Node createDeclarationNode() {\n       if (namespace.indexOf('.') == -1) {\n-        return makeVarDeclNode(namespace, firstNode);\n+        return makeVarDeclNode();\n       } else {\n-        return makeAssignmentExprNode(namespace, firstNode);\n+        return makeAssignmentExprNode();\n       }\n     }\n \n     /**\n      * Creates a simple namespace variable declaration\n      * (e.g. <code>var foo = {};</code>).\n-     *\n-     * @param namespace A simple namespace (must be a valid js identifier)\n-     * @param sourceNode The node to get source information from.\n      */\n-    private Node makeVarDeclNode(String namespace, Node sourceNode) {\n+    private Node makeVarDeclNode() {\n       Node name = Node.newString(Token.NAME, namespace);\n       name.addChildToFront(createNamespaceLiteral());\n \n       }\n \n       Preconditions.checkState(isNamespacePlaceholder(decl));\n-      decl.copyInformationFromForTree(sourceNode);\n+      decl.copyInformationFromForTree(getSourceInfoNode());\n       return decl;\n     }\n \n     /**\n      * Creates a dotted namespace assignment expression\n      * (e.g. <code>foo.bar = {};</code>).\n-     *\n-     * @param namespace A dotted namespace\n-     * @param node A node from which to copy source info.\n      */\n-    private Node makeAssignmentExprNode(String namespace, Node node) {\n+    private Node makeAssignmentExprNode() {\n+      Node sourceInfoNode = getSourceInfoNode();\n       Node decl = new Node(Token.EXPR_RESULT,\n           new Node(Token.ASSIGN,\n               NodeUtil.newQualifiedNameNode(\n-                  compiler.getCodingConvention(), namespace, node, namespace),\n+                  compiler.getCodingConvention(), namespace,\n+                  sourceInfoNode, namespace),\n               createNamespaceLiteral()));\n       decl.putBooleanProp(Node.IS_NAMESPACE, true);\n       Preconditions.checkState(isNamespacePlaceholder(decl));\n-      decl.copyInformationFromForTree(node);\n+      decl.copyInformationFromForTree(sourceInfoNode);\n       return decl;\n+    }\n+\n+    /**\n+     * Get the node to pull source info from.\n+     * On incremental compiles, this may not be the original goog.provde node.\n+     * It may be a node that's in the process of being modified.\n+     */\n+    private Node getSourceInfoNode() {\n+      return (firstNode.getFirstChild() != null &&\n+              NodeUtil.isExprCall(firstNode)) ?\n+          firstNode.getFirstChild().getLastChild() :\n+          firstNode;\n     }\n   }\n ", "timestamp": 1301951454, "metainfo": ""}