{"sha": "ae7d21635654f1e93e4b732983d633af46f53b73", "log": "Merge branch 'master' of https://github.com/jhy/jsoup", "commit": "\n--- a/src/main/java/org/jsoup/examples/HtmlToPlainText.java\n+++ b/src/main/java/org/jsoup/examples/HtmlToPlainText.java\n package org.jsoup.examples;\n \n import org.jsoup.Jsoup;\n-import org.jsoup.helper.StringUtil;\n+import org.jsoup.internal.StringUtil;\n import org.jsoup.helper.Validate;\n import org.jsoup.nodes.Document;\n import org.jsoup.nodes.Element;\n--- a/src/main/java/org/jsoup/helper/DataUtil.java\n+++ b/src/main/java/org/jsoup/helper/DataUtil.java\n \n import org.jsoup.UncheckedIOException;\n import org.jsoup.internal.ConstrainableInputStream;\n+import org.jsoup.internal.StringUtil;\n import org.jsoup.nodes.Comment;\n import org.jsoup.nodes.Document;\n import org.jsoup.nodes.Element;\n--- a/src/main/java/org/jsoup/helper/HttpConnection.java\n+++ b/src/main/java/org/jsoup/helper/HttpConnection.java\n import org.jsoup.UncheckedIOException;\n import org.jsoup.UnsupportedMimeTypeException;\n import org.jsoup.internal.ConstrainableInputStream;\n+import org.jsoup.internal.StringUtil;\n import org.jsoup.nodes.Document;\n import org.jsoup.parser.Parser;\n import org.jsoup.parser.TokenQueue;\n--- a/src/main/java/org/jsoup/helper/W3CDom.java\n+++ b/src/main/java/org/jsoup/helper/W3CDom.java\n package org.jsoup.helper;\n \n+import org.jsoup.internal.StringUtil;\n import org.jsoup.nodes.Attribute;\n import org.jsoup.nodes.Attributes;\n import org.jsoup.select.NodeTraversor;\n--- /dev/null\n+++ b/src/main/java/org/jsoup/internal/StringUtil.java\n+package org.jsoup.internal;\n+\n+import org.jsoup.helper.Validate;\n+\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.Stack;\n+\n+/**\n+ * A minimal String utility class. Designed for internal jsoup use only.\n+ */\n+public final class StringUtil {\n+    // memoised padding up to 21\n+    static final String[] padding = {\"\", \" \", \"  \", \"   \", \"    \", \"     \", \"      \", \"       \", \"        \",\n+        \"         \", \"          \", \"           \", \"            \", \"             \", \"              \", \"               \",\n+        \"                \", \"                 \", \"                  \", \"                   \", \"                    \"};\n+\n+    /**\n+     * Join a collection of strings by a separator\n+     * @param strings collection of string objects\n+     * @param sep string to place between strings\n+     * @return joined string\n+     */\n+    public static String join(Collection strings, String sep) {\n+        return join(strings.iterator(), sep);\n+    }\n+\n+    /**\n+     * Join a collection of strings by a separator\n+     * @param strings iterator of string objects\n+     * @param sep string to place between strings\n+     * @return joined string\n+     */\n+    public static String join(Iterator strings, String sep) {\n+        if (!strings.hasNext())\n+            return \"\";\n+\n+        String start = strings.next().toString();\n+        if (!strings.hasNext()) // only one, avoid builder\n+            return start;\n+\n+        StringBuilder sb = StringUtil.borrowBuilder().append(start);\n+        while (strings.hasNext()) {\n+            sb.append(sep);\n+            sb.append(strings.next());\n+        }\n+        return StringUtil.releaseBuilder(sb);\n+    }\n+\n+    /**\n+     * Join an array of strings by a separator\n+     * @param strings collection of string objects\n+     * @param sep string to place between strings\n+     * @return joined string\n+     */\n+    public static String join(String[] strings, String sep) {\n+        return join(Arrays.asList(strings), sep);\n+    }\n+\n+    /**\n+     * Returns space padding\n+     * @param width amount of padding desired\n+     * @return string of spaces * width\n+     */\n+    public static String padding(int width) {\n+        if (width < 0)\n+            throw new IllegalArgumentException(\"width must be > 0\");\n+\n+        if (width < padding.length)\n+            return padding[width];\n+        char[] out = new char[width];\n+        for (int i = 0; i < width; i++)\n+            out[i] = ' ';\n+        return String.valueOf(out);\n+    }\n+\n+    /**\n+     * Tests if a string is blank: null, empty, or only whitespace (\" \", \\r\\n, \\t, etc)\n+     * @param string string to test\n+     * @return if string is blank\n+     */\n+    public static boolean isBlank(String string) {\n+        if (string == null || string.length() == 0)\n+            return true;\n+\n+        int l = string.length();\n+        for (int i = 0; i < l; i++) {\n+            if (!StringUtil.isWhitespace(string.codePointAt(i)))\n+                return false;\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Tests if a string is numeric, i.e. contains only digit characters\n+     * @param string string to test\n+     * @return true if only digit chars, false if empty or null or contains non-digit chars\n+     */\n+    public static boolean isNumeric(String string) {\n+        if (string == null || string.length() == 0)\n+            return false;\n+\n+        int l = string.length();\n+        for (int i = 0; i < l; i++) {\n+            if (!Character.isDigit(string.codePointAt(i)))\n+                return false;\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Tests if a code point is \"whitespace\" as defined in the HTML spec. Used for output HTML.\n+     * @param c code point to test\n+     * @return true if code point is whitespace, false otherwise\n+     * @see #isActuallyWhitespace(int)\n+     */\n+    public static boolean isWhitespace(int c){\n+        return c == ' ' || c == '\\t' || c == '\\n' || c == '\\f' || c == '\\r';\n+    }\n+\n+    /**\n+     * Tests if a code point is \"whitespace\" as defined by what it looks like. Used for Element.text etc.\n+     * @param c code point to test\n+     * @return true if code point is whitespace, false otherwise\n+     */\n+    public static boolean isActuallyWhitespace(int c){\n+        return c == ' ' || c == '\\t' || c == '\\n' || c == '\\f' || c == '\\r' || c == 160;\n+        // 160 is &nbsp; (non-breaking space). Not in the spec but expected.\n+    }\n+\n+    public static boolean isInvisibleChar(int c) {\n+        return Character.getType(c) == 16 && (c == 8203 || c == 8204 || c == 8205 || c == 173);\n+        // zero width sp, zw non join, zw join, soft hyphen\n+    }\n+\n+    /**\n+     * Normalise the whitespace within this string; multiple spaces collapse to a single, and all whitespace characters\n+     * (e.g. newline, tab) convert to a simple space\n+     * @param string content to normalise\n+     * @return normalised string\n+     */\n+    public static String normaliseWhitespace(String string) {\n+        StringBuilder sb = StringUtil.borrowBuilder();\n+        appendNormalisedWhitespace(sb, string, false);\n+        return StringUtil.releaseBuilder(sb);\n+    }\n+\n+    /**\n+     * After normalizing the whitespace within a string, appends it to a string builder.\n+     * @param accum builder to append to\n+     * @param string string to normalize whitespace within\n+     * @param stripLeading set to true if you wish to remove any leading whitespace\n+     */\n+    public static void appendNormalisedWhitespace(StringBuilder accum, String string, boolean stripLeading) {\n+        boolean lastWasWhite = false;\n+        boolean reachedNonWhite = false;\n+\n+        int len = string.length();\n+        int c;\n+        for (int i = 0; i < len; i+= Character.charCount(c)) {\n+            c = string.codePointAt(i);\n+            if (isActuallyWhitespace(c)) {\n+                if ((stripLeading && !reachedNonWhite) || lastWasWhite)\n+                    continue;\n+                accum.append(' ');\n+                lastWasWhite = true;\n+            }\n+            else if (!isInvisibleChar(c)) {\n+                accum.appendCodePoint(c);\n+                lastWasWhite = false;\n+                reachedNonWhite = true;\n+            }\n+        }\n+    }\n+\n+    public static boolean in(final String needle, final String... haystack) {\n+        final int len = haystack.length;\n+        for (int i = 0; i < len; i++) {\n+            if (haystack[i].equals(needle))\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    public static boolean inSorted(String needle, String[] haystack) {\n+        return Arrays.binarySearch(haystack, needle) >= 0;\n+    }\n+\n+    /**\n+     * Create a new absolute URL, from a provided existing absolute URL and a relative URL component.\n+     * @param base the existing absolute base URL\n+     * @param relUrl the relative URL to resolve. (If it's already absolute, it will be returned)\n+     * @return the resolved absolute URL\n+     * @throws MalformedURLException if an error occurred generating the URL\n+     */\n+    public static URL resolve(URL base, String relUrl) throws MalformedURLException {\n+        // workaround: java resolves '//path/file + ?foo' to '//path/?foo', not '//path/file?foo' as desired\n+        if (relUrl.startsWith(\"?\"))\n+            relUrl = base.getPath() + relUrl;\n+        // workaround: //example.com + ./foo = //example.com/./foo, not //example.com/foo\n+        if (relUrl.indexOf('.') == 0 && base.getFile().indexOf('/') != 0) {\n+            base = new URL(base.getProtocol(), base.getHost(), base.getPort(), \"/\" + base.getFile());\n+        }\n+        return new URL(base, relUrl);\n+    }\n+\n+    /**\n+     * Create a new absolute URL, from a provided existing absolute URL and a relative URL component.\n+     * @param baseUrl the existing absolute base URL\n+     * @param relUrl the relative URL to resolve. (If it's already absolute, it will be returned)\n+     * @return an absolute URL if one was able to be generated, or the empty string if not\n+     */\n+    public static String resolve(final String baseUrl, final String relUrl) {\n+        URL base;\n+        try {\n+            try {\n+                base = new URL(baseUrl);\n+            } catch (MalformedURLException e) {\n+                // the base is unsuitable, but the attribute/rel may be abs on its own, so try that\n+                URL abs = new URL(relUrl);\n+                return abs.toExternalForm();\n+            }\n+            return resolve(base, relUrl).toExternalForm();\n+        } catch (MalformedURLException e) {\n+            return \"\";\n+        }\n+    }\n+\n+    private static final Stack<StringBuilder> builders = new Stack<>();\n+\n+    /**\n+     * Maintains cached StringBuilders in a flyweight pattern, to minimize new StringBuilder GCs. The StringBuilder is\n+     * prevented from growing too large.\n+     * <p>\n+     * Care must be taken to release the builder once its work has been completed, with {@see #releaseBuilder}\n+     * @return an empty StringBuilder\n+     * @\n+     */\n+    public static StringBuilder borrowBuilder() {\n+        synchronized (builders) {\n+            return builders.empty() ?\n+                new StringBuilder(MaxCachedBuilderSize) :\n+                builders.pop();\n+        }\n+    }\n+\n+    /**\n+     * Release a borrowed builder. Care must be taken not to use the builder after it has been returned, as its\n+     * contents may be changed by this method, or by a concurrent thread.\n+     * @param sb the StringBuilder to release.\n+     * @return the string value of the released String Builder (as an incentive to release it!).\n+     */\n+    public static String releaseBuilder(StringBuilder sb) {\n+        Validate.notNull(sb);\n+        String string = sb.toString();\n+\n+        if (sb.length() > MaxCachedBuilderSize)\n+            sb = new StringBuilder(MaxCachedBuilderSize); // make sure it hasn't grown too big\n+        else\n+            sb.delete(0, sb.length()); // make sure it's emptied on release\n+\n+        synchronized (builders) {\n+            builders.push(sb);\n+\n+            while (builders.size() > MaxIdleBuilders) {\n+                builders.pop();\n+            }\n+        }\n+        return string;\n+    }\n+\n+    private static final int MaxCachedBuilderSize = 8 * 1024;\n+    private static final int MaxIdleBuilders = 8;\n+}\n--- a/src/main/java/org/jsoup/nodes/Attribute.java\n+++ b/src/main/java/org/jsoup/nodes/Attribute.java\n package org.jsoup.nodes;\n \n import org.jsoup.SerializationException;\n-import org.jsoup.helper.StringUtil;\n+import org.jsoup.internal.StringUtil;\n import org.jsoup.helper.Validate;\n \n import java.io.IOException;\n--- a/src/main/java/org/jsoup/nodes/Attributes.java\n+++ b/src/main/java/org/jsoup/nodes/Attributes.java\n package org.jsoup.nodes;\n \n import org.jsoup.SerializationException;\n-import org.jsoup.helper.StringUtil;\n+import org.jsoup.internal.StringUtil;\n import org.jsoup.helper.Validate;\n \n import java.io.IOException;\n--- a/src/main/java/org/jsoup/nodes/Document.java\n+++ b/src/main/java/org/jsoup/nodes/Document.java\n package org.jsoup.nodes;\n \n-import org.jsoup.helper.StringUtil;\n+import org.jsoup.internal.StringUtil;\n import org.jsoup.helper.Validate;\n import org.jsoup.parser.ParseSettings;\n import org.jsoup.parser.Parser;\n--- a/src/main/java/org/jsoup/nodes/DocumentType.java\n+++ b/src/main/java/org/jsoup/nodes/DocumentType.java\n package org.jsoup.nodes;\n \n-import org.jsoup.helper.StringUtil;\n+import org.jsoup.internal.StringUtil;\n import org.jsoup.helper.Validate;\n import org.jsoup.nodes.Document.OutputSettings.Syntax;\n \n--- a/src/main/java/org/jsoup/nodes/Element.java\n+++ b/src/main/java/org/jsoup/nodes/Element.java\n package org.jsoup.nodes;\n \n import org.jsoup.helper.ChangeNotifyingArrayList;\n-import org.jsoup.helper.StringUtil;\n+import org.jsoup.internal.StringUtil;\n import org.jsoup.helper.Validate;\n import org.jsoup.parser.ParseSettings;\n import org.jsoup.parser.Tag;\n--- a/src/main/java/org/jsoup/nodes/Entities.java\n+++ b/src/main/java/org/jsoup/nodes/Entities.java\n package org.jsoup.nodes;\n \n import org.jsoup.SerializationException;\n-import org.jsoup.helper.StringUtil;\n+import org.jsoup.internal.StringUtil;\n import org.jsoup.helper.Validate;\n import org.jsoup.parser.CharacterReader;\n import org.jsoup.parser.Parser;\n--- a/src/main/java/org/jsoup/nodes/Node.java\n+++ b/src/main/java/org/jsoup/nodes/Node.java\n package org.jsoup.nodes;\n \n import org.jsoup.SerializationException;\n-import org.jsoup.helper.StringUtil;\n+import org.jsoup.internal.StringUtil;\n import org.jsoup.helper.Validate;\n import org.jsoup.select.NodeFilter;\n import org.jsoup.select.NodeTraversor;\n--- a/src/main/java/org/jsoup/nodes/TextNode.java\n+++ b/src/main/java/org/jsoup/nodes/TextNode.java\n package org.jsoup.nodes;\n \n-import org.jsoup.helper.StringUtil;\n+import org.jsoup.internal.StringUtil;\n import org.jsoup.helper.Validate;\n \n import java.io.IOException;\n--- a/src/main/java/org/jsoup/nodes/XmlDeclaration.java\n+++ b/src/main/java/org/jsoup/nodes/XmlDeclaration.java\n package org.jsoup.nodes;\n \n import org.jsoup.SerializationException;\n-import org.jsoup.helper.StringUtil;\n+import org.jsoup.internal.StringUtil;\n import org.jsoup.helper.Validate;\n \n import java.io.IOException;\n--- a/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java\n+++ b/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java\n package org.jsoup.parser;\n \n-import org.jsoup.helper.StringUtil;\n+import org.jsoup.internal.StringUtil;\n import org.jsoup.helper.Validate;\n import org.jsoup.nodes.CDataNode;\n import org.jsoup.nodes.Comment;\n import java.util.ArrayList;\n import java.util.List;\n \n-import static org.jsoup.helper.StringUtil.inSorted;\n+import static org.jsoup.internal.StringUtil.inSorted;\n \n /**\n  * HTML Tree Builder; creates a DOM from Tokens.\n--- a/src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java\n+++ b/src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java\n package org.jsoup.parser;\n \n-import org.jsoup.helper.StringUtil;\n+import org.jsoup.internal.StringUtil;\n import org.jsoup.nodes.Attribute;\n import org.jsoup.nodes.Attributes;\n import org.jsoup.nodes.Document;\n--- a/src/main/java/org/jsoup/parser/TokenQueue.java\n+++ b/src/main/java/org/jsoup/parser/TokenQueue.java\n package org.jsoup.parser;\n \n-import org.jsoup.helper.StringUtil;\n+import org.jsoup.internal.StringUtil;\n import org.jsoup.helper.Validate;\n \n /**\n--- a/src/main/java/org/jsoup/parser/Tokeniser.java\n+++ b/src/main/java/org/jsoup/parser/Tokeniser.java\n package org.jsoup.parser;\n \n-import org.jsoup.helper.StringUtil;\n+import org.jsoup.internal.StringUtil;\n import org.jsoup.helper.Validate;\n import org.jsoup.nodes.Entities;\n \n--- a/src/main/java/org/jsoup/select/CombiningEvaluator.java\n+++ b/src/main/java/org/jsoup/select/CombiningEvaluator.java\n package org.jsoup.select;\n \n-import org.jsoup.helper.StringUtil;\n+import org.jsoup.internal.StringUtil;\n import org.jsoup.nodes.Element;\n \n import java.util.ArrayList;\n--- a/src/main/java/org/jsoup/select/Elements.java\n+++ b/src/main/java/org/jsoup/select/Elements.java\n package org.jsoup.select;\n \n-import org.jsoup.helper.StringUtil;\n+import org.jsoup.internal.StringUtil;\n import org.jsoup.helper.Validate;\n import org.jsoup.nodes.Element;\n import org.jsoup.nodes.FormElement;\n--- a/src/main/java/org/jsoup/select/QueryParser.java\n+++ b/src/main/java/org/jsoup/select/QueryParser.java\n package org.jsoup.select;\n \n-import org.jsoup.helper.StringUtil;\n+import org.jsoup.internal.StringUtil;\n import org.jsoup.helper.Validate;\n import org.jsoup.parser.TokenQueue;\n \n--- a/src/test/java/org/jsoup/integration/UrlConnectTest.java\n+++ b/src/test/java/org/jsoup/integration/UrlConnectTest.java\n import org.jsoup.HttpStatusException;\n import org.jsoup.Jsoup;\n import org.jsoup.UnsupportedMimeTypeException;\n-import org.jsoup.helper.StringUtil;\n+import org.jsoup.internal.StringUtil;\n import org.jsoup.helper.W3CDom;\n import org.jsoup.nodes.Document;\n import org.jsoup.nodes.FormElement;\n--- a/src/test/java/org/jsoup/integration/servlets/EchoServlet.java\n+++ b/src/test/java/org/jsoup/integration/servlets/EchoServlet.java\n \n import org.eclipse.jetty.server.Request;\n import org.jsoup.helper.DataUtil;\n-import org.jsoup.helper.StringUtil;\n+import org.jsoup.internal.StringUtil;\n import org.jsoup.integration.TestServer;\n \n import javax.servlet.MultipartConfigElement;\n--- /dev/null\n+++ b/src/test/java/org/jsoup/internal/StringUtilTest.java\n+package org.jsoup.internal;\n+\n+import org.jsoup.Jsoup;\n+import org.jsoup.internal.StringUtil;\n+import org.junit.Test;\n+\n+import java.util.Arrays;\n+\n+import static org.jsoup.internal.StringUtil.*;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n+\n+public class StringUtilTest {\n+\n+    @Test public void join() {\n+        assertEquals(\"\", StringUtil.join(Arrays.asList(\"\"), \" \"));\n+        assertEquals(\"one\", StringUtil.join(Arrays.asList(\"one\"), \" \"));\n+        assertEquals(\"one two three\", StringUtil.join(Arrays.asList(\"one\", \"two\", \"three\"), \" \"));\n+    }\n+\n+    @Test public void padding() {\n+        assertEquals(\"\", StringUtil.padding(0));\n+        assertEquals(\" \", StringUtil.padding(1));\n+        assertEquals(\"  \", StringUtil.padding(2));\n+        assertEquals(\"               \", StringUtil.padding(15));\n+        assertEquals(\"                                             \", StringUtil.padding(45));\n+    }\n+\n+    @Test public void paddingInACan() {\n+        String[] padding = StringUtil.padding;\n+        assertEquals(21, padding.length);\n+        for (int i = 0; i < padding.length; i++) {\n+            assertEquals(i, padding[i].length());\n+        }\n+    }\n+\n+    @Test public void isBlank() {\n+        assertTrue(StringUtil.isBlank(null));\n+        assertTrue(StringUtil.isBlank(\"\"));\n+        assertTrue(StringUtil.isBlank(\"      \"));\n+        assertTrue(StringUtil.isBlank(\"   \\r\\n  \"));\n+\n+        assertFalse(StringUtil.isBlank(\"hello\"));\n+        assertFalse(StringUtil.isBlank(\"   hello   \"));\n+    }\n+\n+    @Test public void isNumeric() {\n+        assertFalse(StringUtil.isNumeric(null));\n+        assertFalse(StringUtil.isNumeric(\" \"));\n+        assertFalse(StringUtil.isNumeric(\"123 546\"));\n+        assertFalse(StringUtil.isNumeric(\"hello\"));\n+        assertFalse(StringUtil.isNumeric(\"123.334\"));\n+\n+        assertTrue(StringUtil.isNumeric(\"1\"));\n+        assertTrue(StringUtil.isNumeric(\"1234\"));\n+    }\n+\n+    @Test public void isWhitespace() {\n+        assertTrue(StringUtil.isWhitespace('\\t'));\n+        assertTrue(StringUtil.isWhitespace('\\n'));\n+        assertTrue(StringUtil.isWhitespace('\\r'));\n+        assertTrue(StringUtil.isWhitespace('\\f'));\n+        assertTrue(StringUtil.isWhitespace(' '));\n+        \n+        assertFalse(StringUtil.isWhitespace('\\u00a0'));\n+        assertFalse(StringUtil.isWhitespace('\\u2000'));\n+        assertFalse(StringUtil.isWhitespace('\\u3000'));\n+    }\n+\n+    @Test public void normaliseWhiteSpace() {\n+        assertEquals(\" \", normaliseWhitespace(\"    \\r \\n \\r\\n\"));\n+        assertEquals(\" hello there \", normaliseWhitespace(\"   hello   \\r \\n  there    \\n\"));\n+        assertEquals(\"hello\", normaliseWhitespace(\"hello\"));\n+        assertEquals(\"hello there\", normaliseWhitespace(\"hello\\nthere\"));\n+    }\n+\n+    @Test public void normaliseWhiteSpaceHandlesHighSurrogates() {\n+        String test71540chars = \"\\ud869\\udeb2\\u304b\\u309a  1\";\n+        String test71540charsExpectedSingleWhitespace = \"\\ud869\\udeb2\\u304b\\u309a 1\";\n+\n+        assertEquals(test71540charsExpectedSingleWhitespace, normaliseWhitespace(test71540chars));\n+        String extractedText = Jsoup.parse(test71540chars).text();\n+        assertEquals(test71540charsExpectedSingleWhitespace, extractedText);\n+    }\n+\n+    @Test public void resolvesRelativeUrls() {\n+        assertEquals(\"http://example.com/one/two?three\", resolve(\"http://example.com\", \"./one/two?three\"));\n+        assertEquals(\"http://example.com/one/two?three\", resolve(\"http://example.com?one\", \"./one/two?three\"));\n+        assertEquals(\"http://example.com/one/two?three#four\", resolve(\"http://example.com\", \"./one/two?three#four\"));\n+        assertEquals(\"https://example.com/one\", resolve(\"http://example.com/\", \"https://example.com/one\"));\n+        assertEquals(\"http://example.com/one/two.html\", resolve(\"http://example.com/two/\", \"../one/two.html\"));\n+        assertEquals(\"https://example2.com/one\", resolve(\"https://example.com/\", \"//example2.com/one\"));\n+        assertEquals(\"https://example.com:8080/one\", resolve(\"https://example.com:8080\", \"./one\"));\n+        assertEquals(\"https://example2.com/one\", resolve(\"http://example.com/\", \"https://example2.com/one\"));\n+        assertEquals(\"https://example.com/one\", resolve(\"wrong\", \"https://example.com/one\"));\n+        assertEquals(\"https://example.com/one\", resolve(\"https://example.com/one\", \"\"));\n+        assertEquals(\"\", resolve(\"wrong\", \"also wrong\"));\n+        assertEquals(\"ftp://example.com/one\", resolve(\"ftp://example.com/two/\", \"../one\"));\n+        assertEquals(\"ftp://example.com/one/two.c\", resolve(\"ftp://example.com/one/\", \"./two.c\"));\n+        assertEquals(\"ftp://example.com/one/two.c\", resolve(\"ftp://example.com/one/\", \"two.c\"));\n+    }\n+}\n--- a/src/test/java/org/jsoup/parser/HtmlParserTest.java\n+++ b/src/test/java/org/jsoup/parser/HtmlParserTest.java\n \n import org.jsoup.Jsoup;\n import org.jsoup.TextUtil;\n-import org.jsoup.helper.StringUtil;\n+import org.jsoup.internal.StringUtil;\n import org.jsoup.integration.ParseTest;\n import org.jsoup.nodes.CDataNode;\n import org.jsoup.nodes.Comment;\n--- a/src/test/java/org/jsoup/parser/XmlTreeBuilderTest.java\n+++ b/src/test/java/org/jsoup/parser/XmlTreeBuilderTest.java\n \n import org.jsoup.Jsoup;\n import org.jsoup.TextUtil;\n-import org.jsoup.helper.StringUtil;\n+import org.jsoup.internal.StringUtil;\n import org.jsoup.nodes.CDataNode;\n import org.jsoup.nodes.Document;\n import org.jsoup.nodes.Element;\n--- a/src/test/java/org/jsoup/integration/ConnectTest.java\n+++ b/src/test/java/org/jsoup/integration/ConnectTest.java\n         assertEquals(\"secondPart\", ihVal(\"Part secondPart Name\", res));\n         assertEquals(\"google-ipod.html\", ihVal(\"Part secondPart Filename\", res));\n         assertEquals(\"43963\", ihVal(\"Part secondPart Size\", res));\n-        // if this is failing as 43972 it is because git has normalized the html line endings to crlf (windows)\n-        // disable that:\n-        // git config --global core.eol lf\n-        // git config --global core.autocrlf input\n-        // (and rm cached and reset)\n \n         assertEquals(\"image/jpeg\", ihVal(\"Part firstPart ContentType\", res));\n         assertEquals(\"firstPart\", ihVal(\"Part firstPart Name\", res));", "timestamp": 1526098856, "metainfo": ""}