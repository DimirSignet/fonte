{"sha": "850a9cc02fb72cc450d1a9dc41912fa80fee9020", "log": "Maintain the Parser used when parsing a Document  Allows appropriate fragment parsing as XML or HTML, and remembers case sensitivity choice.  Fixes #769", "commit": "\n--- a/src/main/java/org/jsoup/nodes/Document.java\n+++ b/src/main/java/org/jsoup/nodes/Document.java\n import org.jsoup.helper.StringUtil;\n import org.jsoup.helper.Validate;\n import org.jsoup.parser.ParseSettings;\n+import org.jsoup.parser.Parser;\n import org.jsoup.parser.Tag;\n import org.jsoup.select.Elements;\n \n  @author Jonathan Hedley, jonathan@hedley.net */\n public class Document extends Element {\n     private OutputSettings outputSettings = new OutputSettings();\n+    private Parser parser; // the parser used to parse this document\n     private QuirksMode quirksMode = QuirksMode.noQuirks;\n     private String location;\n     private boolean updateMetaCharset = false;\n         Validate.notNull(baseUri);\n \n         Document doc = new Document(baseUri);\n+        doc.parser = doc.parser();\n         Element html = doc.appendElement(\"html\");\n         html.appendElement(\"head\");\n         html.appendElement(\"body\");\n         this.quirksMode = quirksMode;\n         return this;\n     }\n+\n+    /**\n+     * Get the parser that was used to parse this document.\n+     * @return the parser\n+     */\n+    public Parser parser() {\n+        return parser;\n+    }\n+\n+    /**\n+     * Set the parser used to create this document. This parser is then used when further parsing within this document\n+     * is required.\n+     * @param parser the configured parser to use when further parsing is required for this document.\n+     * @return this document, for chaining.\n+     */\n+    public Document parser(Parser parser) {\n+        this.parser = parser;\n+        return this;\n+    }\n }\n--- a/src/main/java/org/jsoup/nodes/Element.java\n+++ b/src/main/java/org/jsoup/nodes/Element.java\n import org.jsoup.helper.StringUtil;\n import org.jsoup.helper.Validate;\n import org.jsoup.parser.ParseSettings;\n-import org.jsoup.parser.Parser;\n import org.jsoup.parser.Tag;\n import org.jsoup.select.Collector;\n import org.jsoup.select.Elements;\n      */\n     public Element tagName(String tagName) {\n         Validate.notEmpty(tagName, \"Tag name must not be empty.\");\n-        tag = Tag.valueOf(tagName, ParseSettings.preserveCase); // preserve the requested tag case\n+        tag = Tag.valueOf(tagName, getParser().settings()); // maintains the case option of the original parse\n         return this;\n     }\n \n      *  {@code parent.appendElement(\"h1\").attr(\"id\", \"header\").text(\"Welcome\");}\n      */\n     public Element appendElement(String tagName) {\n-        Element child = new Element(Tag.valueOf(tagName), baseUri());\n+        Element child = new Element(Tag.valueOf(tagName, getParser().settings()), baseUri());\n         appendChild(child);\n         return child;\n     }\n      *  {@code parent.prependElement(\"h1\").attr(\"id\", \"header\").text(\"Welcome\");}\n      */\n     public Element prependElement(String tagName) {\n-        Element child = new Element(Tag.valueOf(tagName), baseUri());\n+        Element child = new Element(Tag.valueOf(tagName, getParser().settings()), baseUri());\n         prependChild(child);\n         return child;\n     }\n      */\n     public Element append(String html) {\n         Validate.notNull(html);\n-\n-        List<Node> nodes = Parser.parseFragment(html, this, baseUri());\n+        List<Node> nodes = getParser().parseFragmentInput(html, this, baseUri());\n         addChildren(nodes.toArray(new Node[nodes.size()]));\n         return this;\n     }\n      */\n     public Element prepend(String html) {\n         Validate.notNull(html);\n-        \n-        List<Node> nodes = Parser.parseFragment(html, this, baseUri());\n+        List<Node> nodes = getParser().parseFragmentInput(html, this, baseUri());\n         addChildren(0, nodes.toArray(new Node[nodes.size()]));\n         return this;\n     }\n--- a/src/main/java/org/jsoup/nodes/Node.java\n+++ b/src/main/java/org/jsoup/nodes/Node.java\n import org.jsoup.SerializationException;\n import org.jsoup.helper.StringUtil;\n import org.jsoup.helper.Validate;\n+import org.jsoup.parser.HtmlTreeBuilder;\n import org.jsoup.parser.Parser;\n import org.jsoup.select.NodeFilter;\n import org.jsoup.select.NodeTraversor;\n \n     /**\n      * Set an attribute (key=value). If the attribute already exists, it is replaced. The attribute key comparison is\n-     * <b>case insensitive</b>.\n+     * <b>case insensitive</b>. The key will be set with case sensitivity as set in the parser settings.\n      * @param attributeKey The attribute key.\n      * @param attributeValue The attribute value.\n      * @return this (for chaining)\n      */\n     public Node attr(String attributeKey, String attributeValue) {\n+        attributeKey = getParser().settings().normalizeAttribute(attributeKey);\n         attributes().putIgnoreCase(attributeKey, attributeValue);\n         return this;\n     }\n         Validate.notNull(parentNode);\n \n         Element context = parent() instanceof Element ? (Element) parent() : null;\n-        List<Node> nodes = Parser.parseFragment(html, context, baseUri());\n+        List<Node> nodes = getParser().parseFragmentInput(html, context, baseUri());\n         parentNode.addChildren(index, nodes.toArray(new Node[nodes.size()]));\n     }\n \n         Validate.notEmpty(html);\n \n         Element context = parent() instanceof Element ? (Element) parent() : null;\n-        List<Node> wrapChildren = Parser.parseFragment(html, context, baseUri());\n+        List<Node> wrapChildren = getParser().parseFragmentInput(html, context, baseUri());\n         Node wrapNode = wrapChildren.get(0);\n         if (wrapNode == null || !(wrapNode instanceof Element)) // nothing to wrap with; noop\n             return null;\n         return owner != null ? owner.outputSettings() : (new Document(\"\")).outputSettings();\n     }\n \n+    Parser getParser() {\n+        Document doc = ownerDocument();\n+        return doc != null && doc.parser() != null ? doc.parser() : new Parser(new HtmlTreeBuilder());\n+    }\n+\n     /**\n      Get the outer HTML of this node.\n      @param accum accumulator to place HTML into\n--- a/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java\n+++ b/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java\n     }\n \n     @Override\n-    protected void initialiseParse(Reader input, String baseUri, ParseErrorList errors, ParseSettings settings) {\n-        super.initialiseParse(input, baseUri, errors, settings);\n+    protected void initialiseParse(Reader input, String baseUri, Parser parser) {\n+        super.initialiseParse(input, baseUri, parser);\n \n         // this is a bit mucky. todo - probably just create new parser objects to ensure all reset.\n         state = HtmlTreeBuilderState.Initial;\n         fragmentParsing = false;\n     }\n \n-    List<Node> parseFragment(String inputFragment, Element context, String baseUri, ParseErrorList errors, ParseSettings settings) {\n+    List<Node> parseFragment(String inputFragment, Element context, String baseUri, Parser parser) {\n         // context may be null\n         state = HtmlTreeBuilderState.Initial;\n-        initialiseParse(new StringReader(inputFragment), baseUri, errors, settings);\n+        initialiseParse(new StringReader(inputFragment), baseUri, parser);\n         contextElement = context;\n         fragmentParsing = true;\n         Element root = null;\n     }\n \n     void error(HtmlTreeBuilderState state) {\n-        if (errors.canAddError())\n-            errors.add(new ParseError(reader.pos(), \"Unexpected token [%s] when in state [%s]\", currentToken.tokenType(), state));\n+        if (parser.getErrors().canAddError())\n+            parser.getErrors().add(new ParseError(reader.pos(), \"Unexpected token [%s] when in state [%s]\", currentToken.tokenType(), state));\n     }\n \n     Element insert(Token.StartTag startTag) {\n--- a/src/main/java/org/jsoup/parser/ParseSettings.java\n+++ b/src/main/java/org/jsoup/parser/ParseSettings.java\n         preserveAttributeCase = attribute;\n     }\n \n-    String normalizeTag(String name) {\n+    public String normalizeTag(String name) {\n         name = name.trim();\n         if (!preserveTagCase)\n             name = lowerCase(name);\n         return name;\n     }\n \n-    String normalizeAttribute(String name) {\n+    public String normalizeAttribute(String name) {\n         name = name.trim();\n         if (!preserveAttributeCase)\n             name = lowerCase(name);\n--- a/src/main/java/org/jsoup/parser/Parser.java\n+++ b/src/main/java/org/jsoup/parser/Parser.java\n     private static final int DEFAULT_MAX_ERRORS = 0; // by default, error tracking is disabled.\n     \n     private TreeBuilder treeBuilder;\n-    private int maxErrors = DEFAULT_MAX_ERRORS;\n     private ParseErrorList errors;\n     private ParseSettings settings;\n \n     public Parser(TreeBuilder treeBuilder) {\n         this.treeBuilder = treeBuilder;\n         settings = treeBuilder.defaultSettings();\n+        errors = ParseErrorList.noTracking();\n     }\n     \n     public Document parseInput(String html, String baseUri) {\n-        errors = isTrackErrors() ? ParseErrorList.tracking(maxErrors) : ParseErrorList.noTracking();\n-        return treeBuilder.parse(new StringReader(html), baseUri, errors, settings);\n+        return treeBuilder.parse(new StringReader(html), baseUri, this);\n     }\n \n     public Document parseInput(Reader inputHtml, String baseUri) {\n-        errors = isTrackErrors() ? ParseErrorList.tracking(maxErrors) : ParseErrorList.noTracking();\n-        return treeBuilder.parse(inputHtml, baseUri, errors, settings);\n-    }\n-\n+        return treeBuilder.parse(inputHtml, baseUri, this);\n+    }\n+\n+    public List<Node> parseFragmentInput(String fragment, Element context, String baseUri) {\n+        return treeBuilder.parseFragment(fragment, context, baseUri, this);\n+    }\n     // gets & sets\n     /**\n      * Get the TreeBuilder currently in use.\n      */\n     public Parser setTreeBuilder(TreeBuilder treeBuilder) {\n         this.treeBuilder = treeBuilder;\n+        treeBuilder.parser = this;\n         return this;\n     }\n \n      * @return current track error state.\n      */\n     public boolean isTrackErrors() {\n-        return maxErrors > 0;\n+        return errors.getMaxSize() > 0;\n     }\n \n     /**\n      * @return this, for chaining\n      */\n     public Parser setTrackErrors(int maxErrors) {\n-        this.maxErrors = maxErrors;\n+        errors = maxErrors > 0 ? ParseErrorList.tracking(maxErrors) : ParseErrorList.noTracking();\n         return this;\n     }\n \n      * Retrieve the parse errors, if any, from the last parse.\n      * @return list of parse errors, up to the size of the maximum errors tracked.\n      */\n-    public List<ParseError> getErrors() {\n+    public ParseErrorList getErrors() {\n         return errors;\n     }\n \n      */\n     public static Document parse(String html, String baseUri) {\n         TreeBuilder treeBuilder = new HtmlTreeBuilder();\n-        return treeBuilder.parse(new StringReader(html), baseUri, ParseErrorList.noTracking(), treeBuilder.defaultSettings());\n+        return treeBuilder.parse(new StringReader(html), baseUri, new Parser(treeBuilder));\n     }\n \n     /**\n      */\n     public static List<Node> parseFragment(String fragmentHtml, Element context, String baseUri) {\n         HtmlTreeBuilder treeBuilder = new HtmlTreeBuilder();\n-        return treeBuilder.parseFragment(fragmentHtml, context, baseUri, ParseErrorList.noTracking(), treeBuilder.defaultSettings());\n+        return treeBuilder.parseFragment(fragmentHtml, context, baseUri, new Parser(treeBuilder));\n     }\n \n     /**\n      */\n     public static List<Node> parseFragment(String fragmentHtml, Element context, String baseUri, ParseErrorList errorList) {\n         HtmlTreeBuilder treeBuilder = new HtmlTreeBuilder();\n-        return treeBuilder.parseFragment(fragmentHtml, context, baseUri, errorList, treeBuilder.defaultSettings());\n+        Parser parser = new Parser(treeBuilder);\n+        parser.errors = errorList;\n+        return treeBuilder.parseFragment(fragmentHtml, context, baseUri, parser);\n     }\n \n     /**\n      */\n     public static List<Node> parseXmlFragment(String fragmentXml, String baseUri) {\n         XmlTreeBuilder treeBuilder = new XmlTreeBuilder();\n-        return treeBuilder.parseFragment(fragmentXml, baseUri, ParseErrorList.noTracking(), treeBuilder.defaultSettings());\n+        return treeBuilder.parseFragment(fragmentXml, baseUri, new Parser(treeBuilder));\n     }\n \n     /**\n--- a/src/main/java/org/jsoup/parser/TreeBuilder.java\n+++ b/src/main/java/org/jsoup/parser/TreeBuilder.java\n import org.jsoup.nodes.Attributes;\n import org.jsoup.nodes.Document;\n import org.jsoup.nodes.Element;\n+import org.jsoup.nodes.Node;\n \n import java.io.Reader;\n import java.util.ArrayList;\n+import java.util.List;\n \n /**\n  * @author Jonathan Hedley\n  */\n abstract class TreeBuilder {\n+    protected Parser parser;\n     CharacterReader reader;\n     Tokeniser tokeniser;\n     protected Document doc; // current doc we are building into\n     protected ArrayList<Element> stack; // the stack of open elements\n     protected String baseUri; // current base uri, for creating new elements\n     protected Token currentToken; // currentToken is used only for error tracking.\n-    protected ParseErrorList errors; // null when not tracking errors\n     protected ParseSettings settings;\n \n     private Token.StartTag start = new Token.StartTag(); // start tag to process\n     private Token.EndTag end  = new Token.EndTag();\n-\n     abstract ParseSettings defaultSettings();\n \n-    protected void initialiseParse(Reader input, String baseUri, ParseErrorList errors, ParseSettings settings) {\n+    protected void initialiseParse(Reader input, String baseUri, Parser parser) {\n         Validate.notNull(input, \"String input must not be null\");\n         Validate.notNull(baseUri, \"BaseURI must not be null\");\n \n         doc = new Document(baseUri);\n-        this.settings = settings;\n+        doc.parser(parser);\n+        this.parser = parser;\n+        settings = parser.settings();\n         reader = new CharacterReader(input);\n-        this.errors = errors;\n         currentToken = null;\n-        tokeniser = new Tokeniser(reader, errors);\n+        tokeniser = new Tokeniser(reader, parser.getErrors());\n         stack = new ArrayList<>(32);\n         this.baseUri = baseUri;\n     }\n \n-    Document parse(Reader input, String baseUri, ParseErrorList errors, ParseSettings settings) {\n-        initialiseParse(input, baseUri, errors, settings);\n+    Document parse(Reader input, String baseUri, Parser parser) {\n+        initialiseParse(input, baseUri, parser);\n         runParser();\n         return doc;\n     }\n+\n+    abstract List<Node> parseFragment(String inputFragment, Element context, String baseUri, Parser parser);\n \n     protected void runParser() {\n         while (true) {\n--- a/src/main/java/org/jsoup/parser/XmlTreeBuilder.java\n+++ b/src/main/java/org/jsoup/parser/XmlTreeBuilder.java\n \n import org.jsoup.Jsoup;\n import org.jsoup.helper.Validate;\n-import org.jsoup.nodes.*;\n+import org.jsoup.nodes.CDataNode;\n+import org.jsoup.nodes.Comment;\n+import org.jsoup.nodes.Document;\n+import org.jsoup.nodes.DocumentType;\n+import org.jsoup.nodes.Element;\n+import org.jsoup.nodes.Node;\n+import org.jsoup.nodes.TextNode;\n+import org.jsoup.nodes.XmlDeclaration;\n \n import java.io.Reader;\n import java.io.StringReader;\n         return ParseSettings.preserveCase;\n     }\n \n+    @Override\n+    protected void initialiseParse(Reader input, String baseUri, Parser parser) {\n+        super.initialiseParse(input, baseUri, parser);\n+        stack.add(doc); // place the document onto the stack. differs from HtmlTreeBuilder (not on stack)\n+        doc.outputSettings().syntax(Document.OutputSettings.Syntax.xml);\n+    }\n+\n     Document parse(Reader input, String baseUri) {\n-        return parse(input, baseUri, ParseErrorList.noTracking(), ParseSettings.preserveCase);\n+        return parse(input, baseUri, new Parser(this));\n     }\n \n     Document parse(String input, String baseUri) {\n-        return parse(new StringReader(input), baseUri, ParseErrorList.noTracking(), ParseSettings.preserveCase);\n-    }\n-\n-    @Override\n-    protected void initialiseParse(Reader input, String baseUri, ParseErrorList errors, ParseSettings settings) {\n-        super.initialiseParse(input, baseUri, errors, settings);\n-        stack.add(doc); // place the document onto the stack. differs from HtmlTreeBuilder (not on stack)\n-        doc.outputSettings().syntax(Document.OutputSettings.Syntax.xml);\n+        return parse(new StringReader(input), baseUri, new Parser(this));\n     }\n \n     @Override\n         }\n     }\n \n-    List<Node> parseFragment(String inputFragment, String baseUri, ParseErrorList errors, ParseSettings settings) {\n-        initialiseParse(new StringReader(inputFragment), baseUri, errors, settings);\n+\n+    List<Node> parseFragment(String inputFragment, String baseUri, Parser parser) {\n+        initialiseParse(new StringReader(inputFragment), baseUri, parser);\n         runParser();\n         return doc.childNodes();\n     }\n+\n+    List<Node> parseFragment(String inputFragment, Element context, String baseUri, Parser parser) {\n+        return parseFragment(inputFragment, baseUri, parser);\n+    }\n }\n--- a/src/test/java/org/jsoup/nodes/ElementTest.java\n+++ b/src/test/java/org/jsoup/nodes/ElementTest.java\n         Element div = doc.getElementById(\"1\");\n         div.appendElement(\"p\").text(\"there\");\n         div.appendElement(\"P\").attr(\"CLASS\", \"second\").text(\"now\");\n-        // manually specifying tag and attributes should now preserve case, regardless of parse mode\n-        assertEquals(\"<html><head></head><body><div id=\\\"1\\\"><p>Hello</p><p>there</p><P CLASS=\\\"second\\\">now</P></div></body></html>\",\n+        // manually specifying tag and attributes should maintain case based on parser settings\n+        assertEquals(\"<html><head></head><body><div id=\\\"1\\\"><p>Hello</p><p>there</p><p class=\\\"second\\\">now</p></div></body></html>\",\n                 TextUtil.stripNewlines(doc.html()));\n \n         // check sibling index (with short circuit on reindexChildren):\n--- a/src/test/java/org/jsoup/parser/HtmlParserTest.java\n+++ b/src/test/java/org/jsoup/parser/HtmlParserTest.java\n         String html = \"<!doctype HTML><DIV ID=1>One</DIV>\";\n         Document doc = Jsoup.parse(html);\n         assertEquals(\"<!doctype html> <html> <head></head> <body> <div id=\\\"1\\\"> One </div> </body> </html>\", StringUtil.normaliseWhitespace(doc.outerHtml()));\n+\n+        Element div = doc.selectFirst(\"#1\");\n+        div.after(\"<TaG>One</TaG>\");\n+        assertEquals(\"<tag>One</tag>\", TextUtil.stripNewlines(div.nextElementSibling().outerHtml()));\n     }\n \n     @Test public void canPreserveTagCase() {\n         parser.settings(new ParseSettings(true, false));\n         Document doc = parser.parseInput(\"<div id=1><SPAN ID=2>\", \"\");\n         assertEquals(\"<html> <head></head> <body> <div id=\\\"1\\\"> <SPAN id=\\\"2\\\"></SPAN> </div> </body> </html>\", StringUtil.normaliseWhitespace(doc.outerHtml()));\n+\n+        Element div = doc.selectFirst(\"#1\");\n+        div.after(\"<TaG ID=one>One</TaG>\");\n+        assertEquals(\"<TaG id=\\\"one\\\">One</TaG>\", TextUtil.stripNewlines(div.nextElementSibling().outerHtml()));\n     }\n \n     @Test public void canPreserveAttributeCase() {\n         parser.settings(new ParseSettings(false, true));\n         Document doc = parser.parseInput(\"<div id=1><SPAN ID=2>\", \"\");\n         assertEquals(\"<html> <head></head> <body> <div id=\\\"1\\\"> <span ID=\\\"2\\\"></span> </div> </body> </html>\", StringUtil.normaliseWhitespace(doc.outerHtml()));\n+\n+        Element div = doc.selectFirst(\"#1\");\n+        div.after(\"<TaG ID=one>One</TaG>\");\n+        assertEquals(\"<tag ID=\\\"one\\\">One</tag>\", TextUtil.stripNewlines(div.nextElementSibling().outerHtml()));\n     }\n \n     @Test public void canPreserveBothCase() {\n         parser.settings(new ParseSettings(true, true));\n         Document doc = parser.parseInput(\"<div id=1><SPAN ID=2>\", \"\");\n         assertEquals(\"<html> <head></head> <body> <div id=\\\"1\\\"> <SPAN ID=\\\"2\\\"></SPAN> </div> </body> </html>\", StringUtil.normaliseWhitespace(doc.outerHtml()));\n+\n+        Element div = doc.selectFirst(\"#1\");\n+        div.after(\"<TaG ID=one>One</TaG>\");\n+        assertEquals(\"<TaG ID=\\\"one\\\">One</TaG>\", TextUtil.stripNewlines(div.nextElementSibling().outerHtml()));\n     }\n \n     @Test public void handlesControlCodeInAttributeName() {\n--- a/src/test/java/org/jsoup/parser/XmlTreeBuilderTest.java\n+++ b/src/test/java/org/jsoup/parser/XmlTreeBuilderTest.java\n import org.jsoup.nodes.Node;\n import org.jsoup.nodes.TextNode;\n import org.jsoup.nodes.XmlDeclaration;\n+import org.jsoup.select.Elements;\n import org.junit.Ignore;\n import org.junit.Test;\n \n     }\n \n     @Test\n+    public void appendPreservesCaseByDefault() {\n+        String xml = \"<One>One</One>\";\n+        Document doc = Jsoup.parse(xml, \"\", Parser.xmlParser());\n+        Elements one = doc.select(\"One\");\n+        one.append(\"<Two ID=2>Two</Two>\");\n+        assertEquals(\"<One>One<Two ID=\\\"2\\\">Two</Two></One>\", TextUtil.stripNewlines(doc.html()));\n+    }\n+\n+    @Test\n     public void canNormalizeCase() {\n         String xml = \"<TEST ID=1>Check</TEST>\";\n         Document doc = Jsoup.parse(xml, \"\", Parser.xmlParser().settings(ParseSettings.htmlDefault));", "timestamp": 1524966703, "metainfo": ""}