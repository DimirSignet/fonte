{"sha": "f1b885d238d8576d91d71a09f8658358dd846921", "log": "Spring cleaning", "commit": "\n--- a/src/main/java/org/jsoup/helper/DataUtil.java\n+++ b/src/main/java/org/jsoup/helper/DataUtil.java\n import java.io.InputStream;\n import java.io.InputStreamReader;\n import java.io.OutputStream;\n-import java.io.RandomAccessFile;\n import java.nio.Buffer;\n import java.nio.ByteBuffer;\n import java.nio.charset.Charset;\n         return input.readToByteBuffer(maxSize);\n     }\n \n-    static ByteBuffer readToByteBuffer(InputStream inStream) throws IOException {\n-        return readToByteBuffer(inStream, 0);\n-    }\n-\n-    static ByteBuffer readFileToByteBuffer(File file) throws IOException {\n-        RandomAccessFile randomAccessFile = null;\n-        try {\n-            randomAccessFile = new RandomAccessFile(file, \"r\");\n-            byte[] bytes = new byte[(int) randomAccessFile.length()];\n-            randomAccessFile.readFully(bytes);\n-            return ByteBuffer.wrap(bytes);\n-        } finally {\n-            if (randomAccessFile != null)\n-                randomAccessFile.close();\n-        }\n-    }\n-\n     static ByteBuffer emptyByteBuffer() {\n         return ByteBuffer.allocate(0);\n     }\n--- a/src/main/java/org/jsoup/helper/HttpConnection.java\n+++ b/src/main/java/org/jsoup/helper/HttpConnection.java\n import org.jsoup.parser.Parser;\n import org.jsoup.parser.TokenQueue;\n \n-import javax.net.ssl.HostnameVerifier;\n import javax.net.ssl.HttpsURLConnection;\n-import javax.net.ssl.SSLSession;\n import javax.net.ssl.SSLSocketFactory;\n import java.io.BufferedInputStream;\n import java.io.BufferedWriter;\n         private boolean ignoreContentType = false;\n         private Parser parser;\n         private boolean parserDefined = false; // called parser(...) vs initialized in ctor\n-        private boolean validateTSLCertificates = true;\n         private String postDataCharset = DataUtil.defaultCharset;\n         private SSLSocketFactory sslSocketFactory;\n \n             return ignoreHttpErrors;\n         }\n \n-        public boolean validateTLSCertificates() {\n-            return validateTSLCertificates;\n-        }\n-\n-        public void validateTLSCertificates(boolean value) {\n-            validateTSLCertificates = value;\n-        }\n-\n         public SSLSocketFactory sslSocketFactory() {\n             return sslSocketFactory;\n         }\n \n     public static class Response extends HttpConnection.Base<Connection.Response> implements Connection.Response {\n         private static final int MAX_REDIRECTS = 20;\n-        private static SSLSocketFactory sslSocketFactory;\n         private static final String LOCATION = \"Location\";\n         private int statusCode;\n         private String statusMessage;\n                     bodyStream = null;\n                 }\n             }\n-        }\n-\n-        /**\n-         * Instantiate Hostname Verifier that does nothing.\n-         * This is used for connections with disabled SSL certificates validation.\n-         *\n-         * @return Hostname Verifier that does nothing and accepts all hostnames\n-         */\n-        private static HostnameVerifier getInsecureVerifier() {\n-            return new HostnameVerifier() {\n-                public boolean verify(String urlHostName, SSLSession session) {\n-                    return true;\n-                }\n-            };\n         }\n \n         // set up url, method, header, cookies\n--- a/src/main/java/org/jsoup/nodes/Comment.java\n+++ b/src/main/java/org/jsoup/nodes/Comment.java\n         XmlDeclaration decl = null;\n         if (doc.childNodeSize() > 0) {\n             Element el = doc.child(0);\n-            decl = new XmlDeclaration(doc.getParser().settings().normalizeTag(el.tagName()), data.startsWith(\"!\"));\n+            decl = new XmlDeclaration(NodeUtils.parser(doc).settings().normalizeTag(el.tagName()), data.startsWith(\"!\"));\n             decl.attributes().addAll(el.attributes());\n         }\n         return decl;\n--- a/src/main/java/org/jsoup/nodes/Element.java\n+++ b/src/main/java/org/jsoup/nodes/Element.java\n      */\n     public Element tagName(String tagName) {\n         Validate.notEmpty(tagName, \"Tag name must not be empty.\");\n-        tag = Tag.valueOf(tagName, getParser().settings()); // maintains the case option of the original parse\n+        tag = Tag.valueOf(tagName, NodeUtils.parser(this).settings()); // maintains the case option of the original parse\n         return this;\n     }\n \n      *  {@code parent.appendElement(\"h1\").attr(\"id\", \"header\").text(\"Welcome\");}\n      */\n     public Element appendElement(String tagName) {\n-        Element child = new Element(Tag.valueOf(tagName, getParser().settings()), baseUri());\n+        Element child = new Element(Tag.valueOf(tagName, NodeUtils.parser(this).settings()), baseUri());\n         appendChild(child);\n         return child;\n     }\n      *  {@code parent.prependElement(\"h1\").attr(\"id\", \"header\").text(\"Welcome\");}\n      */\n     public Element prependElement(String tagName) {\n-        Element child = new Element(Tag.valueOf(tagName, getParser().settings()), baseUri());\n+        Element child = new Element(Tag.valueOf(tagName, NodeUtils.parser(this).settings()), baseUri());\n         prependChild(child);\n         return child;\n     }\n      */\n     public Element append(String html) {\n         Validate.notNull(html);\n-        List<Node> nodes = getParser().parseFragmentInput(html, this, baseUri());\n+        List<Node> nodes = NodeUtils.parser(this).parseFragmentInput(html, this, baseUri());\n         addChildren(nodes.toArray(new Node[nodes.size()]));\n         return this;\n     }\n      */\n     public Element prepend(String html) {\n         Validate.notNull(html);\n-        List<Node> nodes = getParser().parseFragmentInput(html, this, baseUri());\n+        List<Node> nodes = NodeUtils.parser(this).parseFragmentInput(html, this, baseUri());\n         addChildren(0, nodes.toArray(new Node[nodes.size()]));\n         return this;\n     }\n     }\n \n     private static <E extends Element> int indexInList(Element search, List<E> elements) {\n-        for (int i = 0; i < elements.size(); i++) {\n+        final int size = elements.size();\n+        for (int i = 0; i < size; i++) {\n             if (elements.get(i) == search)\n                 return i;\n         }\n \n     static boolean preserveWhitespace(Node node) {\n         // looks only at this element and five levels up, to prevent recursion & needless stack searches\n-        if (node != null && node instanceof Element) {\n+        if (node instanceof Element) {\n             Element el = (Element) node;\n             int i = 0;\n             do {\n     public String html() {\n         StringBuilder accum = StringUtil.stringBuilder();\n         html(accum);\n-        return getOutputSettings().prettyPrint() ? accum.toString().trim() : accum.toString();\n-    }\n-\n-    private void html(StringBuilder accum) {\n-        for (Node node : childNodes)\n-            node.outerHtml(accum);\n-    }\n-\n-    /**\n-     * {@inheritDoc}\n-     */\n+        return NodeUtils.outputSettings(this).prettyPrint() ? accum.toString().trim() : accum.toString();\n+    }\n+\n     @Override\n     public <T extends Appendable> T html(T appendable) {\n-        for (Node node : childNodes)\n-            node.outerHtml(appendable);\n+        final int size = childNodes.size();\n+        for (int i = 0; i < size; i++)\n+            childNodes.get(i).outerHtml(appendable);\n \n         return appendable;\n     }\n         empty();\n         append(html);\n         return this;\n-    }\n-\n-\tpublic String toString() {\n-        return outerHtml();\n     }\n \n     @Override\n--- a/src/main/java/org/jsoup/nodes/Node.java\n+++ b/src/main/java/org/jsoup/nodes/Node.java\n import org.jsoup.SerializationException;\n import org.jsoup.helper.StringUtil;\n import org.jsoup.helper.Validate;\n-import org.jsoup.parser.HtmlTreeBuilder;\n-import org.jsoup.parser.Parser;\n import org.jsoup.select.NodeFilter;\n import org.jsoup.select.NodeTraversor;\n import org.jsoup.select.NodeVisitor;\n      * @return this (for chaining)\n      */\n     public Node attr(String attributeKey, String attributeValue) {\n-        attributeKey = getParser().settings().normalizeAttribute(attributeKey);\n+        attributeKey = NodeUtils.parser(this).settings().normalizeAttribute(attributeKey);\n         attributes().putIgnoreCase(attributeKey, attributeValue);\n         return this;\n     }\n         Validate.notNull(parentNode);\n \n         Element context = parent() instanceof Element ? (Element) parent() : null;\n-        List<Node> nodes = getParser().parseFragmentInput(html, context, baseUri());\n+        List<Node> nodes = NodeUtils.parser(this).parseFragmentInput(html, context, baseUri());\n         parentNode.addChildren(index, nodes.toArray(new Node[nodes.size()]));\n     }\n \n         Validate.notEmpty(html);\n \n         Element context = parent() instanceof Element ? (Element) parent() : null;\n-        List<Node> wrapChildren = getParser().parseFragmentInput(html, context, baseUri());\n+        List<Node> wrapChildren = NodeUtils.parser(this).parseFragmentInput(html, context, baseUri());\n         Node wrapNode = wrapChildren.get(0);\n-        if (wrapNode == null || !(wrapNode instanceof Element)) // nothing to wrap with; noop\n+        if (!(wrapNode instanceof Element)) // nothing to wrap with; noop\n             return null;\n \n         Element wrap = (Element) wrapNode;\n     }\n \n     /**\n-     Get the outer HTML of this node.\n-     @return HTML\n+     Get the outer HTML of this node. For example, on a {@code p} element, may return {@code <p>Para</p>}.\n+     @return outer HTML\n+     @see Element#html()\n+     @see Element#text()\n      */\n     public String outerHtml() {\n-        StringBuilder accum = new StringBuilder(128);\n+        StringBuilder accum = StringUtil.stringBuilder();\n         outerHtml(accum);\n         return accum.toString();\n     }\n \n     protected void outerHtml(Appendable accum) {\n-        NodeTraversor.traverse(new OuterHtmlVisitor(accum, getOutputSettings()), this);\n-    }\n-\n-    // if this node has no document (or parent), retrieve the default output settings\n-    Document.OutputSettings getOutputSettings() {\n-        Document owner = ownerDocument();\n-        return owner != null ? owner.outputSettings() : (new Document(\"\")).outputSettings();\n-    }\n-\n-    Parser getParser() {\n-        Document doc = ownerDocument();\n-        return doc != null && doc.parser() != null ? doc.parser() : new Parser(new HtmlTreeBuilder());\n+        NodeTraversor.traverse(new OuterHtmlVisitor(accum, NodeUtils.outputSettings(this)), this);\n     }\n \n     /**\n         return appendable;\n     }\n \n+    /**\n+     * Gets this node's outer HTML.\n+     * @return outer HTML.\n+     * @see #outerHtml()\n+     */\n \tpublic String toString() {\n         return outerHtml();\n     }\n      * @param o other object to compare to\n      * @return true if the content of this node is the same as the other\n      */\n-\n     public boolean hasSameValue(Object o) {\n         if (this == o) return true;\n         if (o == null || getClass() != o.getClass()) return false;\n--- /dev/null\n+++ b/src/main/java/org/jsoup/nodes/NodeUtils.java\n+package org.jsoup.nodes;\n+\n+import org.jsoup.parser.HtmlTreeBuilder;\n+import org.jsoup.parser.Parser;\n+\n+/**\n+ * Internal helpers for Nodes, to keep the actual node APIs relatively clean. A jsoup internal class, so don't use it as\n+ * there is no contract API).\n+ */\n+final class NodeUtils {\n+    /**\n+     * Get the output setting for this node,  or if this node has no document (or parent), retrieve the default output\n+     * settings\n+     */\n+    static Document.OutputSettings outputSettings(Node node) {\n+        Document owner = node.ownerDocument();\n+        return owner != null ? owner.outputSettings() : (new Document(\"\")).outputSettings();\n+    }\n+\n+    /**\n+     * Get the parser that was used to make this node, or the default HTML parser if it has no parent.\n+     */\n+    static Parser parser(Node node) {\n+        Document doc = node.ownerDocument();\n+        return doc != null && doc.parser() != null ? doc.parser() : new Parser(new HtmlTreeBuilder());\n+    }\n+}\n--- a/src/main/java/org/jsoup/nodes/PseudoTextElement.java\n+++ b/src/main/java/org/jsoup/nodes/PseudoTextElement.java\n package org.jsoup.nodes;\n \n import org.jsoup.parser.Tag;\n-\n-import java.io.IOException;\n \n /**\n  * Represents a {@link TextNode} as an {@link Element}, to enable text nodes to be selected with\n     }\n \n     @Override\n-    void outerHtmlHead(Appendable accum, int depth, Document.OutputSettings out) throws IOException {\n+    void outerHtmlHead(Appendable accum, int depth, Document.OutputSettings out) {\n     }\n \n     @Override\n-    void outerHtmlTail(Appendable accum, int depth, Document.OutputSettings out) throws IOException {\n+    void outerHtmlTail(Appendable accum, int depth, Document.OutputSettings out) {\n     }\n }\n--- a/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java\n+++ b/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java\n         return pendingTableCharacters;\n     }\n \n-    void setPendingTableCharacters(List<String> pendingTableCharacters) {\n-        this.pendingTableCharacters = pendingTableCharacters;\n-    }\n-\n     /**\n      11.2.5.2 Closing elements that have implied end tags<p/>\n      When the steps below require the UA to generate implied end tags, then, while the current node is a dd element, a\n--- a/src/main/java/org/jsoup/parser/Parser.java\n+++ b/src/main/java/org/jsoup/parser/Parser.java\n  * in {@link org.jsoup.Jsoup}.\n  */\n public class Parser {\n-    private static final int DEFAULT_MAX_ERRORS = 0; // by default, error tracking is disabled.\n-    \n     private TreeBuilder treeBuilder;\n     private ParseErrorList errors;\n     private ParseSettings settings;\n--- a/src/main/java/org/jsoup/safety/Whitelist.java\n+++ b/src/main/java/org/jsoup/safety/Whitelist.java\n         Validate.isTrue(attributes.length > 0, \"No attribute names supplied.\");\n \n         TagName tagName = TagName.valueOf(tag);\n-        if (!tagNames.contains(tagName))\n-            tagNames.add(tagName);\n+        tagNames.add(tagName);\n         Set<AttributeKey> attributeSet = new HashSet<>();\n         for (String key : attributes) {\n             Validate.notEmpty(key);\n         Validate.notEmpty(value);\n \n         TagName tagName = TagName.valueOf(tag);\n-        if (!tagNames.contains(tagName))\n-            tagNames.add(tagName);\n+        tagNames.add(tagName);\n         AttributeKey attrKey = AttributeKey.valueOf(attribute);\n         AttributeValue attrVal = AttributeValue.valueOf(value);\n \n             if (getClass() != obj.getClass()) return false;\n             TypedValue other = (TypedValue) obj;\n             if (value == null) {\n-                if (other.value != null) return false;\n-            } else if (!value.equals(other.value)) return false;\n-            return true;\n+                return other.value == null;\n+            } else return value.equals(other.value);\n         }\n \n         @Override", "timestamp": 1525027399, "metainfo": ""}