{"sha": "c07c0eead5ec708303b7bfb54c28df2e7cad19e9", "log": "Preserve CDATA sections  Fixes #406 Fixes #965", "commit": "\n--- a/src/main/java/org/jsoup/helper/StringUtil.java\n+++ b/src/main/java/org/jsoup/helper/StringUtil.java\n     }\n \n     /**\n-     * Maintains a cached StringBuilder, to minimize new StringBuilder GCs. Prevents it from growing to big per thread.\n+     * Maintains a cached StringBuilder, to minimize new StringBuilder GCs. Prevents it from growing too big per thread.\n      * Care must be taken to not grab more than one in the same stack (not locked or mutexed or anything).\n      * @return an empty StringBuilder\n      */\n--- /dev/null\n+++ b/src/main/java/org/jsoup/nodes/CDataNode.java\n+package org.jsoup.nodes;\n+\n+import org.jsoup.UncheckedIOException;\n+\n+import java.io.IOException;\n+\n+/**\n+ * A Character Data node, to support CDATA sections.\n+ */\n+public class CDataNode extends TextNode {\n+    public CDataNode(String text) {\n+        super(text);\n+    }\n+\n+    @Override\n+    public String nodeName() {\n+        return \"#cdata\";\n+    }\n+\n+    /**\n+     * Get the unencoded, <b>non-normalized</b> text content of this CDataNode.\n+     * @return unencoded, non-normalized text\n+     */\n+    @Override\n+    public String text() {\n+        return getWholeText();\n+    }\n+\n+    @Override\n+    void outerHtmlHead(Appendable accum, int depth, Document.OutputSettings out) throws IOException {\n+        accum\n+            .append(\"<![CDATA[\")\n+            .append(getWholeText());\n+    }\n+\n+    @Override\n+    void outerHtmlTail(Appendable accum, int depth, Document.OutputSettings out) {\n+        try {\n+            accum.append(\"]]>\");\n+        } catch (IOException e) {\n+            throw new UncheckedIOException(e);\n+        }\n+    }\n+}\n--- a/src/main/java/org/jsoup/nodes/Element.java\n+++ b/src/main/java/org/jsoup/nodes/Element.java\n     private static void appendNormalisedText(StringBuilder accum, TextNode textNode) {\n         String text = textNode.getWholeText();\n \n-        if (preserveWhitespace(textNode.parentNode))\n+        if (preserveWhitespace(textNode.parentNode) || textNode instanceof CDataNode)\n             accum.append(text);\n         else\n             StringUtil.appendNormalisedWhitespace(accum, text, TextNode.lastCharIsWhitespace(accum));\n                 Element element = (Element) childNode;\n                 String elementData = element.data();\n                 sb.append(elementData);\n+            } else if (childNode instanceof CDataNode) {\n+                // this shouldn't really happen because the html parser won't see the cdata as anything special when parsing script.\n+                // but incase another type gets through.\n+                CDataNode cDataNode = (CDataNode) childNode;\n+                sb.append(cDataNode.getWholeText());\n             }\n         }\n         return sb.toString();\n--- a/src/main/java/org/jsoup/nodes/TextNode.java\n+++ b/src/main/java/org/jsoup/nodes/TextNode.java\n      * @see TextNode#getWholeText()\n      */\n     public String text() {\n-        return normaliseWhitespace(getWholeText());\n+        return StringUtil.normaliseWhitespace(getWholeText());\n     }\n     \n     /**\n--- a/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java\n+++ b/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java\n \n import org.jsoup.helper.StringUtil;\n import org.jsoup.helper.Validate;\n+import org.jsoup.nodes.CDataNode;\n import org.jsoup.nodes.Comment;\n import org.jsoup.nodes.DataNode;\n import org.jsoup.nodes.Document;\n     void insert(Token.Character characterToken) {\n         Node node;\n         // characters in script and style go in as datanodes, not text nodes\n-        String tagName = currentElement().tagName();\n-        if (tagName.equals(\"script\") || tagName.equals(\"style\"))\n-            node = new DataNode(characterToken.getData());\n+        final String tagName = currentElement().tagName();\n+        final String data = characterToken.getData();\n+\n+        if (characterToken.isCData())\n+            node = new CDataNode(data);\n+        else if (tagName.equals(\"script\") || tagName.equals(\"style\"))\n+            node = new DataNode(data);\n         else\n-            node = new TextNode(characterToken.getData());\n+            node = new TextNode(data);\n         currentElement().appendChild(node); // doesn't use insertNode, because we don't foster these; and will always have a stack.\n     }\n \n--- a/src/main/java/org/jsoup/parser/Token.java\n+++ b/src/main/java/org/jsoup/parser/Token.java\n         }\n     }\n \n-    final static class Character extends Token {\n+    static class Character extends Token {\n         private String data;\n \n         Character() {\n         }\n     }\n \n+    final static class CData extends Character {\n+        CData(String data) {\n+            super();\n+            this.data(data);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"<![CDATA[\" + getData() + \"]]>\";\n+        }\n+\n+    }\n+\n     final static class EOF extends Token {\n         EOF() {\n             type = Token.TokenType.EOF;\n \n     final boolean isCharacter() {\n         return type == TokenType.Character;\n+    }\n+\n+    final boolean isCData() {\n+        return this instanceof CData;\n     }\n \n     final Character asCharacter() {\n         StartTag,\n         EndTag,\n         Comment,\n-        Character,\n+        Character, // note no CData - treated in builder as an extension of Character\n         EOF\n     }\n }\n--- a/src/main/java/org/jsoup/parser/TokeniserState.java\n+++ b/src/main/java/org/jsoup/parser/TokeniserState.java\n                 // todo: should actually check current namepspace, and only non-html allows cdata. until namespace\n                 // is implemented properly, keep handling as cdata\n                 //} else if (!t.currentNodeInHtmlNS() && r.matchConsume(\"[CDATA[\")) {\n+                t.createTempBuffer();\n                 t.transition(CdataSection);\n             } else {\n                 t.error(this);\n     CdataSection {\n         void read(Tokeniser t, CharacterReader r) {\n             String data = r.consumeTo(\"]]>\");\n-            t.emit(data);\n+            t.dataBuffer.append(data);\n             if (r.matchConsume(\"]]>\") || r.isEmpty()) {\n+                t.emit(new Token.CData(t.dataBuffer.toString()));\n                 t.transition(Data);\n             }// otherwise, buffer underrun, stay in data section\n         }\n--- a/src/main/java/org/jsoup/parser/XmlTreeBuilder.java\n+++ b/src/main/java/org/jsoup/parser/XmlTreeBuilder.java\n         insertNode(insert);\n     }\n \n-    void insert(Token.Character characterToken) {\n-        Node node = new TextNode(characterToken.getData());\n-        insertNode(node);\n+    void insert(Token.Character token) {\n+        final String data = token.getData();\n+        insertNode(token.isCData() ? new CDataNode(data) : new TextNode(data));\n     }\n \n     void insert(Token.Doctype d) {\n--- a/src/test/java/org/jsoup/parser/HtmlParserTest.java\n+++ b/src/test/java/org/jsoup/parser/HtmlParserTest.java\n import org.jsoup.TextUtil;\n import org.jsoup.helper.StringUtil;\n import org.jsoup.integration.ParseTest;\n+import org.jsoup.nodes.CDataNode;\n import org.jsoup.nodes.Comment;\n+import org.jsoup.nodes.DataNode;\n import org.jsoup.nodes.Document;\n import org.jsoup.nodes.Element;\n import org.jsoup.nodes.Entities;\n \n     @Test public void handlesCdata() {\n         // todo: as this is html namespace, should actually treat as bogus comment, not cdata. keep as cdata for now\n-        String h = \"<div id=1><![CDATA[<html>\\n<foo><&amp;]]></div>\"; // the &amp; in there should remain literal\n+        String h = \"<div id=1><![CDATA[<html>\\n <foo><&amp;]]></div>\"; // the &amp; in there should remain literal\n         Document doc = Jsoup.parse(h);\n         Element div = doc.getElementById(\"1\");\n-        assertEquals(\"<html> <foo><&amp;\", div.text());\n+        assertEquals(\"<html>\\n <foo><&amp;\", div.text());\n         assertEquals(0, div.children().size());\n         assertEquals(1, div.childNodeSize()); // no elements, one text node\n+    }\n+\n+    @Test public void roundTripsCdata() {\n+        String h = \"<div id=1><![CDATA[\\n<html>\\n <foo><&amp;]]></div>\";\n+        Document doc = Jsoup.parse(h);\n+        Element div = doc.getElementById(\"1\");\n+        assertEquals(\"<html>\\n <foo><&amp;\", div.text());\n+        assertEquals(0, div.children().size());\n+        assertEquals(1, div.childNodeSize()); // no elements, one text node\n+\n+        assertEquals(\"<div id=\\\"1\\\"><![CDATA[\\n<html>\\n <foo><&amp;]]>\\n</div>\", div.outerHtml());\n+\n+        CDataNode cdata = (CDataNode) div.textNodes().get(0);\n+        assertEquals(\"\\n<html>\\n <foo><&amp;\", cdata.text());\n+    }\n+\n+    @Test public void handlesCdataAcrossBuffer() {\n+        StringBuilder sb = new StringBuilder();\n+        while (sb.length() <= CharacterReader.maxBufferLen) {\n+            sb.append(\"A suitable amount of CData.\\n\");\n+        }\n+        String cdata = sb.toString();\n+        String h = \"<div><![CDATA[\" + cdata + \"]]></div>\";\n+        Document doc = Jsoup.parse(h);\n+        Element div = doc.selectFirst(\"div\");\n+\n+        CDataNode node = (CDataNode) div.textNodes().get(0);\n+        assertEquals(cdata, node.text());\n+    }\n+\n+    @Test public void handlesCdataInScript() {\n+        String html = \"<script type=\\\"text/javascript\\\">//<![CDATA[\\n\\n  foo();\\n//]]></script>\";\n+        Document doc = Jsoup.parse(html);\n+\n+        String data = \"//<![CDATA[\\n\\n  foo();\\n//]]>\";\n+        Element script = doc.selectFirst(\"script\");\n+        assertEquals(\"\", script.text()); // won't be parsed as cdata because in script data section\n+        assertEquals(data, script.data());\n+        assertEquals(html, script.outerHtml());\n+\n+        DataNode dataNode = (DataNode) script.childNode(0);\n+        assertEquals(data, dataNode.getWholeData());\n+        // see - not a cdata node, because in script. contrast with XmlTreeBuilder - will be cdata.\n     }\n \n     @Test public void handlesUnclosedCdataAtEOF() {\n--- a/src/test/java/org/jsoup/parser/XmlTreeBuilderTest.java\n+++ b/src/test/java/org/jsoup/parser/XmlTreeBuilderTest.java\n import org.jsoup.Jsoup;\n import org.jsoup.TextUtil;\n import org.jsoup.helper.StringUtil;\n+import org.jsoup.nodes.CDataNode;\n import org.jsoup.nodes.Document;\n+import org.jsoup.nodes.Element;\n import org.jsoup.nodes.Node;\n import org.jsoup.nodes.TextNode;\n import org.jsoup.nodes.XmlDeclaration;\n         Document doc = Jsoup.parse(xml, \"\", Parser.xmlParser().settings(ParseSettings.htmlDefault));\n         assertEquals(\"<test id=\\\"1\\\">Check</test>\", TextUtil.stripNewlines(doc.html()));\n     }\n+\n+    @Test public void roundTripsCdata() {\n+        String xml = \"<div id=1><![CDATA[\\n<html>\\n <foo><&amp;]]></div>\";\n+        Document doc = Jsoup.parse(xml, \"\", Parser.xmlParser());\n+\n+        Element div = doc.getElementById(\"1\");\n+        assertEquals(\"<html>\\n <foo><&amp;\", div.text());\n+        assertEquals(0, div.children().size());\n+        assertEquals(1, div.childNodeSize()); // no elements, one text node\n+\n+        assertEquals(\"<div id=\\\"1\\\"><![CDATA[\\n<html>\\n <foo><&amp;]]>\\n</div>\", div.outerHtml());\n+\n+        CDataNode cdata = (CDataNode) div.textNodes().get(0);\n+        assertEquals(\"\\n<html>\\n <foo><&amp;\", cdata.text());\n+    }\n+\n+    @Test public void cdataPreservesWhiteSpace() {\n+        String xml = \"<script type=\\\"text/javascript\\\">//<![CDATA[\\n\\n  foo();\\n//]]></script>\";\n+        Document doc = Jsoup.parse(xml, \"\", Parser.xmlParser());\n+        assertEquals(xml, doc.outerHtml());\n+\n+        assertEquals(\"//\\n\\n  foo();\\n//\", doc.selectFirst(\"script\").text());\n+    }\n }", "timestamp": 1511472884, "metainfo": ""}