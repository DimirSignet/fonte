{"sha": "26adfcbcb07bca87f0d50084aaca7549c97abb0c", "log": "Merge branch 'pr/1054'", "commit": "\n--- a/src/main/java/org/jsoup/nodes/Element.java\n+++ b/src/main/java/org/jsoup/nodes/Element.java\n     }\n \n     /**\n+     * Get each of the sibling elements that come after this element.\n+     *\n+     * @return each of the element siblings after this element, or an empty list if there are no next sibling elements\n+     */\n+    public Elements nextElementSiblings() {\n+        return nextElementSiblings(true);\n+    }\n+\n+    /**\n      * Gets the previous element sibling of this element.\n      * @return the previous element, or null if there is no previous element\n      * @see #nextElementSibling()\n             return siblings.get(index-1);\n         else\n             return null;\n+    }\n+\n+    /**\n+     * Get each of the element siblings before this element.\n+     *\n+     * @return the previous element siblings, or an empty list if there are none.\n+     */\n+    public Elements previousElementSiblings() {\n+        return nextElementSiblings(false);\n+    }\n+\n+    private Elements nextElementSiblings(boolean next) {\n+        Elements els = new Elements();\n+        if (parentNode == null)\n+            return  els;\n+        els.add(this);\n+        return next ?  els.nextAll() : els.prevAll();\n     }\n \n     /**\n--- a/src/main/java/org/jsoup/select/Elements.java\n+++ b/src/main/java/org/jsoup/select/Elements.java\n     }\n \n     /**\n-     * Get all of the following element siblings of each element in this list.\n+     * Get each of the following element siblings of each element in this list.\n      * @return all following element siblings.\n      */\n     public Elements nextAll() {\n     }\n \n     /**\n-     * Get all of the following element siblings of each element in this list, filtered by the query.\n+     * Get each of the following element siblings of each element in this list, that match the query.\n      * @param query CSS query to match siblings against\n      * @return all following element siblings.\n      */\n     }\n \n     /**\n-     * Get all of the previous element siblings of each element in this list.\n+     * Get each of the previous element siblings of each element in this list.\n      * @return all previous element siblings.\n      */\n     public Elements prevAll() {\n     }\n \n     /**\n-     * Get all of the previous element siblings of each element in this list, filtered by the query.\n+     * Get each of the previous element siblings of each element in this list, that match the query.\n      * @param query CSS query to match siblings against\n      * @return all previous element siblings.\n      */\n--- a/src/test/java/org/jsoup/nodes/ElementTest.java\n+++ b/src/test/java/org/jsoup/nodes/ElementTest.java\n import java.util.Map;\n import java.util.Set;\n \n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertFalse;\n-import static org.junit.Assert.assertNotNull;\n-import static org.junit.Assert.assertNull;\n-import static org.junit.Assert.assertTrue;\n-import static org.junit.Assert.fail;\n+import static org.junit.Assert.*;\n \n /**\n  * Tests for Element (DOM stuff mostly).\n         assertEquals(\"One Two\", doc.text());\n     }\n \n+    @Test\n+    public void testNextElementSiblings() {\n+        Document doc = Jsoup.parse(\"<ul id='ul'>\" +\n+            \"<li id='a'>a</li>\" +\n+            \"<li id='b'>b</li>\" +\n+            \"<li id='c'>c</li>\" +\n+            \"</ul> Not An Element but a node\" +\n+            \"<div id='div'>\" +\n+            \"<li id='d'>d</li>\" +\n+            \"</div>\");\n+\n+        Element element = doc.getElementById(\"a\");\n+        Elements elementSiblings = element.nextElementSiblings();\n+        assertNotNull(elementSiblings);\n+        assertEquals(2, elementSiblings.size());\n+        assertEquals(\"b\", elementSiblings.get(0).id());\n+        assertEquals(\"c\", elementSiblings.get(1).id());\n+\n+        Element element1 = doc.getElementById(\"b\");\n+        List<Element> elementSiblings1 = element1.nextElementSiblings();\n+        assertNotNull(elementSiblings1);\n+        assertEquals(1, elementSiblings1.size());\n+        assertEquals(\"c\", elementSiblings1.get(0).id());\n+\n+        Element element2 = doc.getElementById(\"c\");\n+        List<Element> elementSiblings2 = element2.nextElementSiblings();\n+        assertEquals(0, elementSiblings2.size());\n+\n+        Element ul = doc.getElementById(\"ul\");\n+        List<Element> elementSiblings3 = ul.nextElementSiblings();\n+        assertNotNull(elementSiblings3);\n+        assertEquals(1, elementSiblings3.size());\n+        assertEquals(\"div\", elementSiblings3.get(0).id());\n+\n+        Element div = doc.getElementById(\"div\");\n+        List<Element> elementSiblings4 = div.nextElementSiblings();\n+        assertEquals(0, elementSiblings4.size());\n+    }\n+\n+    @Test\n+    public void testPreviousElementSiblings() {\n+        Document doc = Jsoup.parse(\"<ul id='ul'>\" +\n+            \"<li id='a'>a</li>\" +\n+            \"<li id='b'>b</li>\" +\n+            \"<li id='c'>c</li>\" +\n+            \"</ul>\" +\n+            \"<div id='div'>\" +\n+            \"<li id='d'>d</li>\" +\n+            \"</div>\");\n+\n+        Element element = doc.getElementById(\"b\");\n+        Elements elementSiblings = element.previousElementSiblings();\n+        assertNotNull(elementSiblings);\n+        assertEquals(1, elementSiblings.size());\n+        assertEquals(\"a\", elementSiblings.get(0).id());\n+\n+        Element element1 = doc.getElementById(\"a\");\n+        List<Element> elementSiblings1 = element1.previousElementSiblings();\n+        assertEquals(0, elementSiblings1.size());\n+\n+        Element element2 = doc.getElementById(\"c\");\n+        List<Element> elementSiblings2 = element2.previousElementSiblings();\n+        assertNotNull(elementSiblings2);\n+        assertEquals(2, elementSiblings2.size());\n+        assertEquals(\"a\", elementSiblings2.get(0).id());\n+        assertEquals(\"b\", elementSiblings2.get(1).id());\n+\n+        Element ul = doc.getElementById(\"ul\");\n+        List<Element> elementSiblings3 = ul.previousElementSiblings();\n+        assertEquals(0, elementSiblings3.size());\n+    }\n }\n--- a/src/main/java/org/jsoup/examples/HtmlToPlainText.java\n+++ b/src/main/java/org/jsoup/examples/HtmlToPlainText.java\n package org.jsoup.examples;\n \n import org.jsoup.Jsoup;\n-import org.jsoup.helper.StringUtil;\n+import org.jsoup.internal.StringUtil;\n import org.jsoup.helper.Validate;\n import org.jsoup.nodes.Document;\n import org.jsoup.nodes.Element;\n--- a/src/main/java/org/jsoup/helper/DataUtil.java\n+++ b/src/main/java/org/jsoup/helper/DataUtil.java\n \n import org.jsoup.UncheckedIOException;\n import org.jsoup.internal.ConstrainableInputStream;\n+import org.jsoup.internal.StringUtil;\n import org.jsoup.nodes.Comment;\n import org.jsoup.nodes.Document;\n import org.jsoup.nodes.Element;\n      * Creates a random string, suitable for use as a mime boundary\n      */\n     static String mimeBoundary() {\n-        final StringBuilder mime = new StringBuilder(boundaryLength);\n+        final StringBuilder mime = StringUtil.borrowBuilder();\n         final Random rand = new Random();\n         for (int i = 0; i < boundaryLength; i++) {\n             mime.append(mimeBoundaryChars[rand.nextInt(mimeBoundaryChars.length)]);\n         }\n-        return mime.toString();\n+        return StringUtil.releaseBuilder(mime);\n     }\n \n     private static BomCharset detectCharsetFromBom(final ByteBuffer byteData) {\n--- a/src/main/java/org/jsoup/helper/HttpConnection.java\n+++ b/src/main/java/org/jsoup/helper/HttpConnection.java\n import org.jsoup.UncheckedIOException;\n import org.jsoup.UnsupportedMimeTypeException;\n import org.jsoup.internal.ConstrainableInputStream;\n+import org.jsoup.internal.StringUtil;\n import org.jsoup.nodes.Document;\n import org.jsoup.parser.Parser;\n import org.jsoup.parser.TokenQueue;\n         return con;\n     }\n \n+    public HttpConnection() {\n+        req = new Request();\n+        res = new Response();\n+    }\n+\n     /**\n      * Encodes the input URL into a safe ASCII URL string\n      * @param url unescaped URL\n \n     private Connection.Request req;\n     private Connection.Response res;\n-\n-\tprivate HttpConnection() {\n-        req = new Request();\n-        res = new Response();\n-    }\n \n     public Connection url(URL url) {\n         req.url(url);\n         private String statusMessage;\n         private ByteBuffer byteData;\n         private InputStream bodyStream;\n+        private HttpURLConnection conn;\n         private String charset;\n         private String contentType;\n         private boolean executed = false;\n \n         static Response execute(Connection.Request req, Response previousResponse) throws IOException {\n             Validate.notNull(req, \"Request must not be null\");\n+            Validate.notNull(req.url(), \"URL must be specified to connect\");\n             String protocol = req.url().getProtocol();\n             if (!protocol.equals(\"http\") && !protocol.equals(\"https\"))\n                 throw new MalformedURLException(\"Only http & https protocols supported\");\n          * Call on completion of stream read, to close the body (or error) stream\n          */\n         private void safeClose() {\n+            if (conn != null) {\n+                conn.disconnect();\n+                conn = null;\n+            }\n             if (bodyStream != null) {\n                 try {\n                     bodyStream.close();\n         }\n \n         // set up url, method, header, cookies\n-        private void setupFromConnection(HttpURLConnection conn, Connection.Response previousResponse) throws IOException {\n+        private void setupFromConnection(HttpURLConnection conn, HttpConnection.Response previousResponse) throws IOException {\n+            this.conn = conn;\n             method = Method.valueOf(conn.getRequestMethod());\n             url = conn.getURL();\n             statusCode = conn.getResponseCode();\n                     if (!hasCookie(prevCookie.getKey()))\n                         cookie(prevCookie.getKey(), prevCookie.getValue());\n                 }\n+                previousResponse.safeClose();\n             }\n         }\n \n         }\n \n         private static String getRequestCookieString(Connection.Request req) {\n-            StringBuilder sb = StringUtil.stringBuilder();\n+            StringBuilder sb = StringUtil.borrowBuilder();\n             boolean first = true;\n             for (Map.Entry<String, String> cookie : req.cookies().entrySet()) {\n                 if (!first)\n                 sb.append(cookie.getKey()).append('=').append(cookie.getValue());\n                 // todo: spec says only ascii, no escaping / encoding defined. validate on set? or escape somehow here?\n             }\n-            return sb.toString();\n+            return StringUtil.releaseBuilder(sb);\n         }\n \n         // for get url reqs, serialise the data map into the url\n         private static void serialiseRequestUrl(Connection.Request req) throws IOException {\n             URL in = req.url();\n-            StringBuilder url = StringUtil.stringBuilder();\n+            StringBuilder url = StringUtil.borrowBuilder();\n             boolean first = true;\n             // reconstitute the query, ready for appends\n             url\n                     .append('=')\n                     .append(URLEncoder.encode(keyVal.value(), DataUtil.defaultCharset));\n             }\n-            req.url(new URL(url.toString()));\n+            req.url(new URL(StringUtil.releaseBuilder(url)));\n             req.data().clear(); // moved into url as get params\n         }\n     }\n \n     private static boolean needsMultipart(Connection.Request req) {\n         // multipart mode, for files. add the header if we see something with an inputstream, and return a non-null boundary\n-        boolean needsMulti = false;\n         for (Connection.KeyVal keyVal : req.data()) {\n-            if (keyVal.hasInputStream()) {\n-                needsMulti = true;\n-                break;\n-            }\n-        }\n-        return needsMulti;\n+            if (keyVal.hasInputStream())\n+                return true;\n+        }\n+        return false;\n     }\n \n     public static class KeyVal implements Connection.KeyVal {\n--- a/src/main/java/org/jsoup/helper/W3CDom.java\n+++ b/src/main/java/org/jsoup/helper/W3CDom.java\n package org.jsoup.helper;\n \n+import org.jsoup.internal.StringUtil;\n import org.jsoup.nodes.Attribute;\n import org.jsoup.nodes.Attributes;\n import org.jsoup.select.NodeTraversor;\n--- /dev/null\n+++ b/src/main/java/org/jsoup/internal/StringUtil.java\n+package org.jsoup.internal;\n+\n+import org.jsoup.helper.Validate;\n+\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.Stack;\n+\n+/**\n+ * A minimal String utility class. Designed for internal jsoup use only.\n+ */\n+public final class StringUtil {\n+    // memoised padding up to 21\n+    static final String[] padding = {\"\", \" \", \"  \", \"   \", \"    \", \"     \", \"      \", \"       \", \"        \",\n+        \"         \", \"          \", \"           \", \"            \", \"             \", \"              \", \"               \",\n+        \"                \", \"                 \", \"                  \", \"                   \", \"                    \"};\n+\n+    /**\n+     * Join a collection of strings by a separator\n+     * @param strings collection of string objects\n+     * @param sep string to place between strings\n+     * @return joined string\n+     */\n+    public static String join(Collection strings, String sep) {\n+        return join(strings.iterator(), sep);\n+    }\n+\n+    /**\n+     * Join a collection of strings by a separator\n+     * @param strings iterator of string objects\n+     * @param sep string to place between strings\n+     * @return joined string\n+     */\n+    public static String join(Iterator strings, String sep) {\n+        if (!strings.hasNext())\n+            return \"\";\n+\n+        String start = strings.next().toString();\n+        if (!strings.hasNext()) // only one, avoid builder\n+            return start;\n+\n+        StringBuilder sb = StringUtil.borrowBuilder().append(start);\n+        while (strings.hasNext()) {\n+            sb.append(sep);\n+            sb.append(strings.next());\n+        }\n+        return StringUtil.releaseBuilder(sb);\n+    }\n+\n+    /**\n+     * Join an array of strings by a separator\n+     * @param strings collection of string objects\n+     * @param sep string to place between strings\n+     * @return joined string\n+     */\n+    public static String join(String[] strings, String sep) {\n+        return join(Arrays.asList(strings), sep);\n+    }\n+\n+    /**\n+     * Returns space padding\n+     * @param width amount of padding desired\n+     * @return string of spaces * width\n+     */\n+    public static String padding(int width) {\n+        if (width < 0)\n+            throw new IllegalArgumentException(\"width must be > 0\");\n+\n+        if (width < padding.length)\n+            return padding[width];\n+        char[] out = new char[width];\n+        for (int i = 0; i < width; i++)\n+            out[i] = ' ';\n+        return String.valueOf(out);\n+    }\n+\n+    /**\n+     * Tests if a string is blank: null, empty, or only whitespace (\" \", \\r\\n, \\t, etc)\n+     * @param string string to test\n+     * @return if string is blank\n+     */\n+    public static boolean isBlank(String string) {\n+        if (string == null || string.length() == 0)\n+            return true;\n+\n+        int l = string.length();\n+        for (int i = 0; i < l; i++) {\n+            if (!StringUtil.isWhitespace(string.codePointAt(i)))\n+                return false;\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Tests if a string is numeric, i.e. contains only digit characters\n+     * @param string string to test\n+     * @return true if only digit chars, false if empty or null or contains non-digit chars\n+     */\n+    public static boolean isNumeric(String string) {\n+        if (string == null || string.length() == 0)\n+            return false;\n+\n+        int l = string.length();\n+        for (int i = 0; i < l; i++) {\n+            if (!Character.isDigit(string.codePointAt(i)))\n+                return false;\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Tests if a code point is \"whitespace\" as defined in the HTML spec. Used for output HTML.\n+     * @param c code point to test\n+     * @return true if code point is whitespace, false otherwise\n+     * @see #isActuallyWhitespace(int)\n+     */\n+    public static boolean isWhitespace(int c){\n+        return c == ' ' || c == '\\t' || c == '\\n' || c == '\\f' || c == '\\r';\n+    }\n+\n+    /**\n+     * Tests if a code point is \"whitespace\" as defined by what it looks like. Used for Element.text etc.\n+     * @param c code point to test\n+     * @return true if code point is whitespace, false otherwise\n+     */\n+    public static boolean isActuallyWhitespace(int c){\n+        return c == ' ' || c == '\\t' || c == '\\n' || c == '\\f' || c == '\\r' || c == 160;\n+        // 160 is &nbsp; (non-breaking space). Not in the spec but expected.\n+    }\n+\n+    public static boolean isInvisibleChar(int c) {\n+        return Character.getType(c) == 16 && (c == 8203 || c == 8204 || c == 8205 || c == 173);\n+        // zero width sp, zw non join, zw join, soft hyphen\n+    }\n+\n+    /**\n+     * Normalise the whitespace within this string; multiple spaces collapse to a single, and all whitespace characters\n+     * (e.g. newline, tab) convert to a simple space\n+     * @param string content to normalise\n+     * @return normalised string\n+     */\n+    public static String normaliseWhitespace(String string) {\n+        StringBuilder sb = StringUtil.borrowBuilder();\n+        appendNormalisedWhitespace(sb, string, false);\n+        return StringUtil.releaseBuilder(sb);\n+    }\n+\n+    /**\n+     * After normalizing the whitespace within a string, appends it to a string builder.\n+     * @param accum builder to append to\n+     * @param string string to normalize whitespace within\n+     * @param stripLeading set to true if you wish to remove any leading whitespace\n+     */\n+    public static void appendNormalisedWhitespace(StringBuilder accum, String string, boolean stripLeading) {\n+        boolean lastWasWhite = false;\n+        boolean reachedNonWhite = false;\n+\n+        int len = string.length();\n+        int c;\n+        for (int i = 0; i < len; i+= Character.charCount(c)) {\n+            c = string.codePointAt(i);\n+            if (isActuallyWhitespace(c)) {\n+                if ((stripLeading && !reachedNonWhite) || lastWasWhite)\n+                    continue;\n+                accum.append(' ');\n+                lastWasWhite = true;\n+            }\n+            else if (!isInvisibleChar(c)) {\n+                accum.appendCodePoint(c);\n+                lastWasWhite = false;\n+                reachedNonWhite = true;\n+            }\n+        }\n+    }\n+\n+    public static boolean in(final String needle, final String... haystack) {\n+        final int len = haystack.length;\n+        for (int i = 0; i < len; i++) {\n+            if (haystack[i].equals(needle))\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    public static boolean inSorted(String needle, String[] haystack) {\n+        return Arrays.binarySearch(haystack, needle) >= 0;\n+    }\n+\n+    /**\n+     * Create a new absolute URL, from a provided existing absolute URL and a relative URL component.\n+     * @param base the existing absolute base URL\n+     * @param relUrl the relative URL to resolve. (If it's already absolute, it will be returned)\n+     * @return the resolved absolute URL\n+     * @throws MalformedURLException if an error occurred generating the URL\n+     */\n+    public static URL resolve(URL base, String relUrl) throws MalformedURLException {\n+        // workaround: java resolves '//path/file + ?foo' to '//path/?foo', not '//path/file?foo' as desired\n+        if (relUrl.startsWith(\"?\"))\n+            relUrl = base.getPath() + relUrl;\n+        // workaround: //example.com + ./foo = //example.com/./foo, not //example.com/foo\n+        if (relUrl.indexOf('.') == 0 && base.getFile().indexOf('/') != 0) {\n+            base = new URL(base.getProtocol(), base.getHost(), base.getPort(), \"/\" + base.getFile());\n+        }\n+        return new URL(base, relUrl);\n+    }\n+\n+    /**\n+     * Create a new absolute URL, from a provided existing absolute URL and a relative URL component.\n+     * @param baseUrl the existing absolute base URL\n+     * @param relUrl the relative URL to resolve. (If it's already absolute, it will be returned)\n+     * @return an absolute URL if one was able to be generated, or the empty string if not\n+     */\n+    public static String resolve(final String baseUrl, final String relUrl) {\n+        URL base;\n+        try {\n+            try {\n+                base = new URL(baseUrl);\n+            } catch (MalformedURLException e) {\n+                // the base is unsuitable, but the attribute/rel may be abs on its own, so try that\n+                URL abs = new URL(relUrl);\n+                return abs.toExternalForm();\n+            }\n+            return resolve(base, relUrl).toExternalForm();\n+        } catch (MalformedURLException e) {\n+            return \"\";\n+        }\n+    }\n+\n+    private static final Stack<StringBuilder> builders = new Stack<>();\n+\n+    /**\n+     * Maintains cached StringBuilders in a flyweight pattern, to minimize new StringBuilder GCs. The StringBuilder is\n+     * prevented from growing too large.\n+     * <p>\n+     * Care must be taken to release the builder once its work has been completed, with {@see #releaseBuilder}\n+     * @return an empty StringBuilder\n+     * @\n+     */\n+    public static StringBuilder borrowBuilder() {\n+        synchronized (builders) {\n+            return builders.empty() ?\n+                new StringBuilder(MaxCachedBuilderSize) :\n+                builders.pop();\n+        }\n+    }\n+\n+    /**\n+     * Release a borrowed builder. Care must be taken not to use the builder after it has been returned, as its\n+     * contents may be changed by this method, or by a concurrent thread.\n+     * @param sb the StringBuilder to release.\n+     * @return the string value of the released String Builder (as an incentive to release it!).\n+     */\n+    public static String releaseBuilder(StringBuilder sb) {\n+        Validate.notNull(sb);\n+        String string = sb.toString();\n+\n+        if (sb.length() > MaxCachedBuilderSize)\n+            sb = new StringBuilder(MaxCachedBuilderSize); // make sure it hasn't grown too big\n+        else\n+            sb.delete(0, sb.length()); // make sure it's emptied on release\n+\n+        synchronized (builders) {\n+            builders.push(sb);\n+\n+            while (builders.size() > MaxIdleBuilders) {\n+                builders.pop();\n+            }\n+        }\n+        return string;\n+    }\n+\n+    private static final int MaxCachedBuilderSize = 8 * 1024;\n+    private static final int MaxIdleBuilders = 8;\n+}\n--- a/src/main/java/org/jsoup/nodes/Attribute.java\n+++ b/src/main/java/org/jsoup/nodes/Attribute.java\n package org.jsoup.nodes;\n \n import org.jsoup.SerializationException;\n+import org.jsoup.internal.StringUtil;\n import org.jsoup.helper.Validate;\n \n import java.io.IOException;\n      @return HTML\n      */\n     public String html() {\n-        StringBuilder accum = new StringBuilder();\n+        StringBuilder sb = StringUtil.borrowBuilder();\n         \n         try {\n-        \thtml(accum, (new Document(\"\")).outputSettings());\n+        \thtml(sb, (new Document(\"\")).outputSettings());\n         } catch(IOException exception) {\n         \tthrow new SerializationException(exception);\n         }\n-        return accum.toString();\n+        return StringUtil.releaseBuilder(sb);\n     }\n \n     protected static void html(String key, String val, Appendable accum, Document.OutputSettings out) throws IOException {\n--- a/src/main/java/org/jsoup/nodes/Attributes.java\n+++ b/src/main/java/org/jsoup/nodes/Attributes.java\n package org.jsoup.nodes;\n \n import org.jsoup.SerializationException;\n+import org.jsoup.internal.StringUtil;\n import org.jsoup.helper.Validate;\n \n import java.io.IOException;\n      @throws SerializationException if the HTML representation of the attributes cannot be constructed.\n      */\n     public String html() {\n-        StringBuilder accum = new StringBuilder();\n+        StringBuilder sb = StringUtil.borrowBuilder();\n         try {\n-            html(accum, (new Document(\"\")).outputSettings()); // output settings a bit funky, but this html() seldom used\n+            html(sb, (new Document(\"\")).outputSettings()); // output settings a bit funky, but this html() seldom used\n         } catch (IOException e) { // ought never happen\n             throw new SerializationException(e);\n         }\n-        return accum.toString();\n+        return StringUtil.releaseBuilder(sb);\n     }\n \n     final void html(final Appendable accum, final Document.OutputSettings out) throws IOException {\n--- a/src/main/java/org/jsoup/nodes/Document.java\n+++ b/src/main/java/org/jsoup/nodes/Document.java\n package org.jsoup.nodes;\n \n-import org.jsoup.helper.StringUtil;\n+import org.jsoup.internal.StringUtil;\n import org.jsoup.helper.Validate;\n import org.jsoup.parser.ParseSettings;\n import org.jsoup.parser.Parser;\n--- a/src/main/java/org/jsoup/nodes/DocumentType.java\n+++ b/src/main/java/org/jsoup/nodes/DocumentType.java\n package org.jsoup.nodes;\n \n-import org.jsoup.helper.StringUtil;\n+import org.jsoup.internal.StringUtil;\n import org.jsoup.helper.Validate;\n import org.jsoup.nodes.Document.OutputSettings.Syntax;\n \n--- a/src/main/java/org/jsoup/nodes/Element.java\n+++ b/src/main/java/org/jsoup/nodes/Element.java\n package org.jsoup.nodes;\n \n import org.jsoup.helper.ChangeNotifyingArrayList;\n-import org.jsoup.helper.StringUtil;\n+import org.jsoup.internal.StringUtil;\n import org.jsoup.helper.Validate;\n import org.jsoup.parser.ParseSettings;\n import org.jsoup.parser.Tag;\n      * @see #textNodes()\n      */\n     public String text() {\n-        final StringBuilder accum = new StringBuilder();\n+        final StringBuilder accum = StringUtil.borrowBuilder();\n         NodeTraversor.traverse(new NodeVisitor() {\n             public void head(Node node, int depth) {\n                 if (node instanceof TextNode) {\n \n             }\n         }, this);\n-        return accum.toString().trim();\n+\n+        return StringUtil.releaseBuilder(accum).trim();\n     }\n \n     /**\n      * @see #text()\n      */\n     public String wholeText() {\n-        final StringBuilder accum = new StringBuilder();\n+        final StringBuilder accum = StringUtil.borrowBuilder();\n         NodeTraversor.traverse(new NodeVisitor() {\n             public void head(Node node, int depth) {\n                 if (node instanceof TextNode) {\n             public void tail(Node node, int depth) {\n             }\n         }, this);\n-        return accum.toString();\n+\n+        return StringUtil.releaseBuilder(accum);\n     }\n \n     /**\n      * @see #textNodes()\n      */\n     public String ownText() {\n-        StringBuilder sb = new StringBuilder();\n+        StringBuilder sb = StringUtil.borrowBuilder();\n         ownText(sb);\n-        return sb.toString().trim();\n+        return StringUtil.releaseBuilder(sb).trim();\n     }\n \n     private void ownText(StringBuilder accum) {\n      * @see #dataNodes()\n      */\n     public String data() {\n-        StringBuilder sb = new StringBuilder();\n+        StringBuilder sb = StringUtil.borrowBuilder();\n \n         for (Node childNode : childNodes) {\n             if (childNode instanceof DataNode) {\n                 sb.append(cDataNode.getWholeText());\n             }\n         }\n-        return sb.toString();\n+        return StringUtil.releaseBuilder(sb);\n     }   \n \n     /**\n      * @see #outerHtml()\n      */\n     public String html() {\n-        StringBuilder accum = StringUtil.stringBuilder();\n+        StringBuilder accum = StringUtil.borrowBuilder();\n         html(accum);\n-        return NodeUtils.outputSettings(this).prettyPrint() ? accum.toString().trim() : accum.toString();\n+        String html = StringUtil.releaseBuilder(accum);\n+        return NodeUtils.outputSettings(this).prettyPrint() ? html.trim() : html;\n     }\n \n     @Override\n--- a/src/main/java/org/jsoup/nodes/Entities.java\n+++ b/src/main/java/org/jsoup/nodes/Entities.java\n package org.jsoup.nodes;\n \n import org.jsoup.SerializationException;\n-import org.jsoup.helper.StringUtil;\n+import org.jsoup.internal.StringUtil;\n import org.jsoup.helper.Validate;\n import org.jsoup.parser.CharacterReader;\n import org.jsoup.parser.Parser;\n     public static String escape(String string, Document.OutputSettings out) {\n         if (string == null)\n             return \"\";\n-        StringBuilder accum = new StringBuilder(string.length() * 2);\n+        StringBuilder accum = StringUtil.borrowBuilder();\n         try {\n             escape(accum, string, out, false, false, false);\n         } catch (IOException e) {\n             throw new SerializationException(e); // doesn't happen\n         }\n-        return accum.toString();\n+        return StringUtil.releaseBuilder(accum);\n     }\n \n     /**\n--- a/src/main/java/org/jsoup/nodes/Node.java\n+++ b/src/main/java/org/jsoup/nodes/Node.java\n package org.jsoup.nodes;\n \n import org.jsoup.SerializationException;\n-import org.jsoup.helper.StringUtil;\n+import org.jsoup.internal.StringUtil;\n import org.jsoup.helper.Validate;\n import org.jsoup.select.NodeFilter;\n import org.jsoup.select.NodeTraversor;\n      @see Element#text()\n      */\n     public String outerHtml() {\n-        StringBuilder accum = StringUtil.stringBuilder();\n+        StringBuilder accum = StringUtil.borrowBuilder();\n         outerHtml(accum);\n-        return accum.toString();\n+        return StringUtil.releaseBuilder(accum);\n     }\n \n     protected void outerHtml(Appendable accum) {\n--- a/src/main/java/org/jsoup/nodes/TextNode.java\n+++ b/src/main/java/org/jsoup/nodes/TextNode.java\n package org.jsoup.nodes;\n \n-import org.jsoup.helper.StringUtil;\n+import org.jsoup.internal.StringUtil;\n import org.jsoup.helper.Validate;\n \n import java.io.IOException;\n--- a/src/main/java/org/jsoup/nodes/XmlDeclaration.java\n+++ b/src/main/java/org/jsoup/nodes/XmlDeclaration.java\n package org.jsoup.nodes;\n \n import org.jsoup.SerializationException;\n+import org.jsoup.internal.StringUtil;\n import org.jsoup.helper.Validate;\n \n import java.io.IOException;\n      * @return XML declaration\n      */\n     public String getWholeDeclaration() {\n-        StringBuilder sb = new StringBuilder();\n+        StringBuilder sb = StringUtil.borrowBuilder();\n         try {\n             getWholeDeclaration(sb, new Document.OutputSettings());\n         } catch (IOException e) {\n             throw new SerializationException(e);\n         }\n-        return sb.toString().trim();\n+        return StringUtil.releaseBuilder(sb).trim();\n     }\n \n     private void getWholeDeclaration(Appendable accum, Document.OutputSettings out) throws IOException {\n--- a/src/main/java/org/jsoup/parser/CharacterReader.java\n+++ b/src/main/java/org/jsoup/parser/CharacterReader.java\n     }\n \n     private void bufferUp() {\n-        if (bufPos < bufSplitPoint)\n+        final int pos = bufPos;\n+        if (pos < bufSplitPoint)\n             return;\n \n         try {\n-            reader.skip(bufPos);\n+            reader.skip(pos);\n             reader.mark(maxBufferLen);\n             final int read = reader.read(charBuf);\n             reader.reset();\n             if (read != -1) {\n                 bufLength = read;\n-                readerPos += bufPos;\n+                readerPos += pos;\n                 bufPos = 0;\n                 bufMark = 0;\n                 bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength;\n      */\n     public String consumeToAny(final char... chars) {\n         bufferUp();\n-        final int start = bufPos;\n+        int pos = bufPos;\n+        final int start = pos;\n         final int remaining = bufLength;\n         final char[] val = charBuf;\n-\n-        OUTER: while (bufPos < remaining) {\n-            for (char c : chars) {\n-                if (val[bufPos] == c)\n+        final int charLen = chars.length;\n+        int i;\n+\n+        OUTER: while (pos < remaining) {\n+            for (i = 0; i < charLen; i++) {\n+                if (val[pos] == chars[i])\n                     break OUTER;\n             }\n-            bufPos++;\n-        }\n-\n-        return bufPos > start ? cacheString(charBuf, stringCache, start, bufPos -start) : \"\";\n+            pos++;\n+        }\n+\n+        bufPos = pos;\n+        return pos > start ? cacheString(charBuf, stringCache, start, pos -start) : \"\";\n     }\n \n     String consumeToAnySorted(final char... chars) {\n         bufferUp();\n-        final int start = bufPos;\n+        int pos = bufPos;\n+        final int start = pos;\n         final int remaining = bufLength;\n         final char[] val = charBuf;\n \n-        while (bufPos < remaining) {\n-            if (Arrays.binarySearch(chars, val[bufPos]) >= 0)\n+        while (pos < remaining) {\n+            if (Arrays.binarySearch(chars, val[pos]) >= 0)\n                 break;\n-            bufPos++;\n-        }\n-\n-        return bufPos > start ? cacheString(charBuf, stringCache, start, bufPos -start) : \"\";\n+            pos++;\n+        }\n+        bufPos = pos;\n+        return bufPos > start ? cacheString(charBuf, stringCache, start, pos -start) : \"\";\n     }\n \n     String consumeData() {\n         // &, <, null\n-        bufferUp();\n-        final int start = bufPos;\n+        //bufferUp(); // no need to bufferUp, just called consume()\n+        int pos = bufPos;\n+        final int start = pos;\n         final int remaining = bufLength;\n         final char[] val = charBuf;\n \n-        while (bufPos < remaining) {\n-            final char c = val[bufPos];\n-            if (c == '&'|| c ==  '<' || c ==  TokeniserState.nullChar)\n-                break;\n-            bufPos++;\n-        }\n-\n-        return bufPos > start ? cacheString(charBuf, stringCache, start, bufPos -start) : \"\";\n+        OUTER: while (pos < remaining) {\n+            switch (val[pos]) {\n+                case '&':\n+                case '<':\n+                case TokeniserState.nullChar:\n+                    break OUTER;\n+                default:\n+                    pos++;\n+            }\n+        }\n+        bufPos = pos;\n+        return pos > start ? cacheString(charBuf, stringCache, start, pos -start) : \"\";\n     }\n \n     String consumeTagName() {\n         // '\\t', '\\n', '\\r', '\\f', ' ', '/', '>', nullChar\n         // NOTE: out of spec, added '<' to fix common author bugs\n         bufferUp();\n-        final int start = bufPos;\n+        int pos = bufPos;\n+        final int start = pos;\n         final int remaining = bufLength;\n         final char[] val = charBuf;\n \n-        while (bufPos < remaining) {\n-            final char c = val[bufPos];\n-            if (c == '\\t'|| c ==  '\\n'|| c ==  '\\r'|| c ==  '\\f'|| c ==  ' '|| c ==  '/'|| c ==  '>'|| c == '<' || c ==  TokeniserState.nullChar)\n-                break;\n-            bufPos++;\n-        }\n-\n-        return bufPos > start ? cacheString(charBuf, stringCache, start, bufPos -start) : \"\";\n+        OUTER: while (pos < remaining) {\n+            switch (val[pos]) {\n+                case '\\t':\n+                case '\\n':\n+                case '\\r':\n+                case '\\f':\n+                case ' ':\n+                case '/':\n+                case '>':\n+                case '<':\n+                case TokeniserState.nullChar:\n+                    break OUTER;\n+            }\n+            pos++;\n+        }\n+\n+        bufPos = pos;\n+        return pos > start ? cacheString(charBuf, stringCache, start, pos -start) : \"\";\n     }\n \n     String consumeToEnd() {\n--- a/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java\n+++ b/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java\n package org.jsoup.parser;\n \n-import org.jsoup.helper.StringUtil;\n+import org.jsoup.internal.StringUtil;\n import org.jsoup.helper.Validate;\n import org.jsoup.nodes.CDataNode;\n import org.jsoup.nodes.Comment;\n import java.util.ArrayList;\n import java.util.List;\n \n-import static org.jsoup.helper.StringUtil.inSorted;\n+import static org.jsoup.internal.StringUtil.inSorted;\n \n /**\n  * HTML Tree Builder; creates a DOM from Tokens.\n     }\n \n     void insert(Token.Character characterToken) {\n-        Node node;\n-        // characters in script and style go in as datanodes, not text nodes\n-        final String tagName = currentElement().tagName();\n+        final Node node;\n+        final Element el = currentElement();\n+        final String tagName = el.tagName();\n         final String data = characterToken.getData();\n \n         if (characterToken.isCData())\n             node = new DataNode(data);\n         else\n             node = new TextNode(data);\n-        currentElement().appendChild(node); // doesn't use insertNode, because we don't foster these; and will always have a stack.\n+        el.appendChild(node); // doesn't use insertNode, because we don't foster these; and will always have a stack.\n     }\n \n     private void insertNode(Node node) {\n--- a/src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java\n+++ b/src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java\n package org.jsoup.parser;\n \n-import org.jsoup.helper.StringUtil;\n+import org.jsoup.internal.StringUtil;\n import org.jsoup.nodes.Attribute;\n import org.jsoup.nodes.Attributes;\n import org.jsoup.nodes.Document;\n                 Token.EndTag endTag = t.asEndTag();\n                 String name = endTag.normalName();\n \n-                if (StringUtil.in(name, \"td\", \"th\")) {\n+                if (StringUtil.inSorted(name, Constants.InCellNames)) {\n                     if (!tb.inTableScope(name)) {\n                         tb.error(this);\n                         tb.transition(InRow); // might not be in scope if empty: <td /> and processing fake end tag\n                     tb.popStackToClose(name);\n                     tb.clearFormattingElementsToLastMarker();\n                     tb.transition(InRow);\n-                } else if (StringUtil.in(name, \"body\", \"caption\", \"col\", \"colgroup\", \"html\")) {\n+                } else if (StringUtil.inSorted(name, Constants.InCellBody)) {\n                     tb.error(this);\n                     return false;\n-                } else if (StringUtil.in(name, \"table\", \"tbody\", \"tfoot\", \"thead\", \"tr\")) {\n+                } else if (StringUtil.inSorted(name, Constants.InCellTable)) {\n                     if (!tb.inTableScope(name)) {\n                         tb.error(this);\n                         return false;\n                     return anythingElse(t, tb);\n                 }\n             } else if (t.isStartTag() &&\n-                    StringUtil.in(t.asStartTag().normalName(),\n-                            \"caption\", \"col\", \"colgroup\", \"tbody\", \"td\", \"tfoot\", \"th\", \"thead\", \"tr\")) {\n+                    StringUtil.inSorted(t.asStartTag().normalName(), Constants.InCellCol)) {\n                 if (!(tb.inTableScope(\"td\") || tb.inTableScope(\"th\"))) {\n                     tb.error(this);\n                     return false;\n             \"nav\", \"ol\", \"pre\", \"section\", \"summary\", \"ul\"};\n         static final String[] InBodyEndAdoptionFormatters = new String[]{\"a\", \"b\", \"big\", \"code\", \"em\", \"font\", \"i\", \"nobr\", \"s\", \"small\", \"strike\", \"strong\", \"tt\", \"u\"};\n         static final String[] InBodyEndTableFosters = new String[]{\"table\", \"tbody\", \"tfoot\", \"thead\", \"tr\"};\n+        static final String[] InCellNames = new String[]{\"td\", \"th\"};\n+        static final String[] InCellBody = new String[]{\"body\", \"caption\", \"col\", \"colgroup\", \"html\"};\n+        static final String[] InCellTable = new String[]{ \"table\", \"tbody\", \"tfoot\", \"thead\", \"tr\"};\n+        static final String[] InCellCol = new String[]{\"caption\", \"col\", \"colgroup\", \"tbody\", \"td\", \"tfoot\", \"th\", \"thead\", \"tr\"};\n     }\n }\n--- a/src/main/java/org/jsoup/parser/TokenQueue.java\n+++ b/src/main/java/org/jsoup/parser/TokenQueue.java\n package org.jsoup.parser;\n \n-import org.jsoup.helper.StringUtil;\n+import org.jsoup.internal.StringUtil;\n import org.jsoup.helper.Validate;\n \n /**\n      * @return unescaped string\n      */\n     public static String unescape(String in) {\n-        StringBuilder out = StringUtil.stringBuilder();\n+        StringBuilder out = StringUtil.borrowBuilder();\n         char last = 0;\n         for (char c : in.toCharArray()) {\n             if (c == ESC) {\n                 out.append(c);\n             last = c;\n         }\n-        return out.toString();\n+        return StringUtil.releaseBuilder(out);\n     }\n \n     /**\n--- a/src/main/java/org/jsoup/parser/Tokeniser.java\n+++ b/src/main/java/org/jsoup/parser/Tokeniser.java\n package org.jsoup.parser;\n \n-import org.jsoup.helper.StringUtil;\n+import org.jsoup.internal.StringUtil;\n import org.jsoup.helper.Validate;\n import org.jsoup.nodes.Entities;\n \n      * @return unescaped string from reader\n      */\n     String unescapeEntities(boolean inAttribute) {\n-        StringBuilder builder = StringUtil.stringBuilder();\n+        StringBuilder builder = StringUtil.borrowBuilder();\n         while (!reader.isEmpty()) {\n             builder.append(reader.consumeTo('&'));\n             if (reader.matches('&')) {\n \n             }\n         }\n-        return builder.toString();\n+        return StringUtil.releaseBuilder(builder);\n     }\n }\n--- a/src/main/java/org/jsoup/select/CombiningEvaluator.java\n+++ b/src/main/java/org/jsoup/select/CombiningEvaluator.java\n package org.jsoup.select;\n \n-import org.jsoup.helper.StringUtil;\n+import org.jsoup.internal.StringUtil;\n import org.jsoup.nodes.Element;\n \n import java.util.ArrayList;\n--- a/src/main/java/org/jsoup/select/Elements.java\n+++ b/src/main/java/org/jsoup/select/Elements.java\n package org.jsoup.select;\n \n+import org.jsoup.internal.StringUtil;\n import org.jsoup.helper.Validate;\n import org.jsoup.nodes.Element;\n import org.jsoup.nodes.FormElement;\n      * @see #eachText()\n      */\n     public String text() {\n-        StringBuilder sb = new StringBuilder();\n+        StringBuilder sb = StringUtil.borrowBuilder();\n         for (Element element : this) {\n             if (sb.length() != 0)\n                 sb.append(\" \");\n             sb.append(element.text());\n         }\n-        return sb.toString();\n+        return StringUtil.releaseBuilder(sb);\n     }\n \n     /**\n      * @see #outerHtml()\n      */\n     public String html() {\n-        StringBuilder sb = new StringBuilder();\n+        StringBuilder sb = StringUtil.borrowBuilder();\n         for (Element element : this) {\n             if (sb.length() != 0)\n                 sb.append(\"\\n\");\n             sb.append(element.html());\n         }\n-        return sb.toString();\n+        return StringUtil.releaseBuilder(sb);\n     }\n     \n     /**\n      * @see #html()\n      */\n     public String outerHtml() {\n-        StringBuilder sb = new StringBuilder();\n+        StringBuilder sb = StringUtil.borrowBuilder();\n         for (Element element : this) {\n             if (sb.length() != 0)\n                 sb.append(\"\\n\");\n             sb.append(element.outerHtml());\n         }\n-        return sb.toString();\n+        return StringUtil.releaseBuilder(sb);\n     }\n \n     /**\n--- a/src/main/java/org/jsoup/select/QueryParser.java\n+++ b/src/main/java/org/jsoup/select/QueryParser.java\n package org.jsoup.select;\n \n-import org.jsoup.helper.StringUtil;\n+import org.jsoup.internal.StringUtil;\n import org.jsoup.helper.Validate;\n import org.jsoup.parser.TokenQueue;\n \n     }\n \n     private String consumeSubQuery() {\n-        StringBuilder sq = new StringBuilder();\n+        StringBuilder sq = StringUtil.borrowBuilder();\n         while (!tq.isEmpty()) {\n             if (tq.matches(\"(\"))\n                 sq.append(\"(\").append(tq.chompBalanced('(', ')')).append(\")\");\n             else\n                 sq.append(tq.consume());\n         }\n-        return sq.toString();\n+        return StringUtil.releaseBuilder(sq);\n     }\n \n     private void findElements() {\n--- a/src/test/java/org/jsoup/helper/HttpConnectionTest.java\n+++ b/src/test/java/org/jsoup/helper/HttpConnectionTest.java\n         URL url2 = HttpConnection.encodeUrl(url1);\n         assertEquals(\"http://test.com/?q=white%20space\", url2.toExternalForm());\n     }\n+\n+    @Test public void noUrlThrowsValidationError() throws IOException {\n+        HttpConnection con = new HttpConnection();\n+        boolean threw = false;\n+        try {\n+            con.execute();\n+        } catch (IllegalArgumentException e) {\n+            threw = true;\n+            assertEquals(\"URL must be specified to connect\", e.getMessage());\n+        }\n+        assertTrue(threw);\n+    }\n }\n--- a/src/test/java/org/jsoup/integration/ConnectTest.java\n+++ b/src/test/java/org/jsoup/integration/ConnectTest.java\n         assertEquals(\"secondPart\", ihVal(\"Part secondPart Name\", res));\n         assertEquals(\"google-ipod.html\", ihVal(\"Part secondPart Filename\", res));\n         assertEquals(\"43963\", ihVal(\"Part secondPart Size\", res));\n-        // if this is failing as 43972 it is because git has normalized the html line endings to crlf (windows)\n-        // disable that:\n-        // git config --global core.eol lf\n-        // git config --global core.autocrlf input\n-        // (and rm cached and reset)\n \n         assertEquals(\"image/jpeg\", ihVal(\"Part firstPart ContentType\", res));\n         assertEquals(\"firstPart\", ihVal(\"Part firstPart Name\", res));\n--- a/src/test/java/org/jsoup/integration/UrlConnectTest.java\n+++ b/src/test/java/org/jsoup/integration/UrlConnectTest.java\n import org.jsoup.HttpStatusException;\n import org.jsoup.Jsoup;\n import org.jsoup.UnsupportedMimeTypeException;\n-import org.jsoup.helper.StringUtil;\n+import org.jsoup.internal.StringUtil;\n import org.jsoup.helper.W3CDom;\n import org.jsoup.nodes.Document;\n import org.jsoup.nodes.FormElement;\n--- a/src/test/java/org/jsoup/integration/servlets/EchoServlet.java\n+++ b/src/test/java/org/jsoup/integration/servlets/EchoServlet.java\n \n import org.eclipse.jetty.server.Request;\n import org.jsoup.helper.DataUtil;\n-import org.jsoup.helper.StringUtil;\n+import org.jsoup.internal.StringUtil;\n import org.jsoup.integration.TestServer;\n \n import javax.servlet.MultipartConfigElement;\n--- /dev/null\n+++ b/src/test/java/org/jsoup/internal/StringUtilTest.java\n+package org.jsoup.internal;\n+\n+import org.jsoup.Jsoup;\n+import org.jsoup.internal.StringUtil;\n+import org.junit.Test;\n+\n+import java.util.Arrays;\n+\n+import static org.jsoup.internal.StringUtil.*;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n+\n+public class StringUtilTest {\n+\n+    @Test public void join() {\n+        assertEquals(\"\", StringUtil.join(Arrays.asList(\"\"), \" \"));\n+        assertEquals(\"one\", StringUtil.join(Arrays.asList(\"one\"), \" \"));\n+        assertEquals(\"one two three\", StringUtil.join(Arrays.asList(\"one\", \"two\", \"three\"), \" \"));\n+    }\n+\n+    @Test public void padding() {\n+        assertEquals(\"\", StringUtil.padding(0));\n+        assertEquals(\" \", StringUtil.padding(1));\n+        assertEquals(\"  \", StringUtil.padding(2));\n+        assertEquals(\"               \", StringUtil.padding(15));\n+        assertEquals(\"                                             \", StringUtil.padding(45));\n+    }\n+\n+    @Test public void paddingInACan() {\n+        String[] padding = StringUtil.padding;\n+        assertEquals(21, padding.length);\n+        for (int i = 0; i < padding.length; i++) {\n+            assertEquals(i, padding[i].length());\n+        }\n+    }\n+\n+    @Test public void isBlank() {\n+        assertTrue(StringUtil.isBlank(null));\n+        assertTrue(StringUtil.isBlank(\"\"));\n+        assertTrue(StringUtil.isBlank(\"      \"));\n+        assertTrue(StringUtil.isBlank(\"   \\r\\n  \"));\n+\n+        assertFalse(StringUtil.isBlank(\"hello\"));\n+        assertFalse(StringUtil.isBlank(\"   hello   \"));\n+    }\n+\n+    @Test public void isNumeric() {\n+        assertFalse(StringUtil.isNumeric(null));\n+        assertFalse(StringUtil.isNumeric(\" \"));\n+        assertFalse(StringUtil.isNumeric(\"123 546\"));\n+        assertFalse(StringUtil.isNumeric(\"hello\"));\n+        assertFalse(StringUtil.isNumeric(\"123.334\"));\n+\n+        assertTrue(StringUtil.isNumeric(\"1\"));\n+        assertTrue(StringUtil.isNumeric(\"1234\"));\n+    }\n+\n+    @Test public void isWhitespace() {\n+        assertTrue(StringUtil.isWhitespace('\\t'));\n+        assertTrue(StringUtil.isWhitespace('\\n'));\n+        assertTrue(StringUtil.isWhitespace('\\r'));\n+        assertTrue(StringUtil.isWhitespace('\\f'));\n+        assertTrue(StringUtil.isWhitespace(' '));\n+        \n+        assertFalse(StringUtil.isWhitespace('\\u00a0'));\n+        assertFalse(StringUtil.isWhitespace('\\u2000'));\n+        assertFalse(StringUtil.isWhitespace('\\u3000'));\n+    }\n+\n+    @Test public void normaliseWhiteSpace() {\n+        assertEquals(\" \", normaliseWhitespace(\"    \\r \\n \\r\\n\"));\n+        assertEquals(\" hello there \", normaliseWhitespace(\"   hello   \\r \\n  there    \\n\"));\n+        assertEquals(\"hello\", normaliseWhitespace(\"hello\"));\n+        assertEquals(\"hello there\", normaliseWhitespace(\"hello\\nthere\"));\n+    }\n+\n+    @Test public void normaliseWhiteSpaceHandlesHighSurrogates() {\n+        String test71540chars = \"\\ud869\\udeb2\\u304b\\u309a  1\";\n+        String test71540charsExpectedSingleWhitespace = \"\\ud869\\udeb2\\u304b\\u309a 1\";\n+\n+        assertEquals(test71540charsExpectedSingleWhitespace, normaliseWhitespace(test71540chars));\n+        String extractedText = Jsoup.parse(test71540chars).text();\n+        assertEquals(test71540charsExpectedSingleWhitespace, extractedText);\n+    }\n+\n+    @Test public void resolvesRelativeUrls() {\n+        assertEquals(\"http://example.com/one/two?three\", resolve(\"http://example.com\", \"./one/two?three\"));\n+        assertEquals(\"http://example.com/one/two?three\", resolve(\"http://example.com?one\", \"./one/two?three\"));\n+        assertEquals(\"http://example.com/one/two?three#four\", resolve(\"http://example.com\", \"./one/two?three#four\"));\n+        assertEquals(\"https://example.com/one\", resolve(\"http://example.com/\", \"https://example.com/one\"));\n+        assertEquals(\"http://example.com/one/two.html\", resolve(\"http://example.com/two/\", \"../one/two.html\"));\n+        assertEquals(\"https://example2.com/one\", resolve(\"https://example.com/\", \"//example2.com/one\"));\n+        assertEquals(\"https://example.com:8080/one\", resolve(\"https://example.com:8080\", \"./one\"));\n+        assertEquals(\"https://example2.com/one\", resolve(\"http://example.com/\", \"https://example2.com/one\"));\n+        assertEquals(\"https://example.com/one\", resolve(\"wrong\", \"https://example.com/one\"));\n+        assertEquals(\"https://example.com/one\", resolve(\"https://example.com/one\", \"\"));\n+        assertEquals(\"\", resolve(\"wrong\", \"also wrong\"));\n+        assertEquals(\"ftp://example.com/one\", resolve(\"ftp://example.com/two/\", \"../one\"));\n+        assertEquals(\"ftp://example.com/one/two.c\", resolve(\"ftp://example.com/one/\", \"./two.c\"));\n+        assertEquals(\"ftp://example.com/one/two.c\", resolve(\"ftp://example.com/one/\", \"two.c\"));\n+    }\n+}\n--- a/src/test/java/org/jsoup/parser/HtmlParserTest.java\n+++ b/src/test/java/org/jsoup/parser/HtmlParserTest.java\n \n import org.jsoup.Jsoup;\n import org.jsoup.TextUtil;\n-import org.jsoup.helper.StringUtil;\n+import org.jsoup.internal.StringUtil;\n import org.jsoup.integration.ParseTest;\n import org.jsoup.nodes.CDataNode;\n import org.jsoup.nodes.Comment;\n--- a/src/test/java/org/jsoup/parser/HtmlTreeBuilderStateTest.java\n+++ b/src/test/java/org/jsoup/parser/HtmlTreeBuilderStateTest.java\n             Constants.InBodyStartDrop,\n             Constants.InBodyEndClosers,\n             Constants.InBodyEndAdoptionFormatters,\n-            Constants.InBodyEndTableFosters\n+            Constants.InBodyEndTableFosters,\n+            Constants.InCellNames,\n+            Constants.InCellBody,\n+            Constants.InCellTable,\n+            Constants.InCellCol,\n         };\n \n         for (String[] array : arrays) {\n--- a/src/test/java/org/jsoup/parser/XmlTreeBuilderTest.java\n+++ b/src/test/java/org/jsoup/parser/XmlTreeBuilderTest.java\n \n import org.jsoup.Jsoup;\n import org.jsoup.TextUtil;\n-import org.jsoup.helper.StringUtil;\n+import org.jsoup.internal.StringUtil;\n import org.jsoup.nodes.CDataNode;\n import org.jsoup.nodes.Document;\n import org.jsoup.nodes.Element;", "timestamp": 1526103267, "metainfo": ""}