{"sha": "05a57e1e0bef36b76b7e936078b01a315bc2e8d1", "log": "Tenfold improvement in performance for leftPad, rightPad and repeat when repeat is over a String of length 1, by implementation of a padding method. The padding method is kept private for the moment.  Also a modification of containsOnly so it has a partner method indexOfAnyBut. Unit Test added for indexOfAnyBut.  Submitted by:\tRobert Simpson   ", "commit": "\n--- a/src/java/org/apache/commons/lang/StringUtils.java\n+++ b/src/java/org/apache/commons/lang/StringUtils.java\n  * @author <a href=\"mailto:hps@intermeta.de\">Henning P. Schmiedehausen</a>\n  * @author Arun Mammen Thomas\n  * @since 1.0\n- * @version $Id: StringUtils.java,v 1.43 2003/04/10 00:01:21 ggregory Exp $\n+ * @version $Id: StringUtils.java,v 1.44 2003/04/16 04:37:33 bayard Exp $\n  */\n public class StringUtils {\n+\n+    /**\n+     * <p>The maximum size to which the padding constant(s) can expand.</p>\n+     */\n+    private static int PAD_LIMIT = 8192;\n+\n+    /**\n+     * <p>A <code>String</code> containing all blank characters.</p>\n+     *\n+     * <p>Used for efficient blank padding.  The length of the string expands as needed.</p>\n+     */\n+    private static String blanks = new String(\" \");\n+\n+    /**\n+     * <p>An array of <code>String</code>s used for padding.</p>\n+     *\n+     * <p>Used for efficient blank padding.  The length of each string expands as needed.</p>\n+     */\n+    private final static String[] padding = new String[Character.MAX_VALUE];\n+       // String.concat about twice as fast as StringBuffer.append\n \n     /**\n      * <p><code>StringUtils<code> instances should NOT be constructed in\n      * @throws NullPointerException if str is <code>null</code>\n      */\n     public static String repeat(String str, int repeat) {\n+        if (str.length() == 1 && repeat <= PAD_LIMIT) {\n+           return padding(repeat, str.charAt(0));\n+        }\n+\n         StringBuffer buffer = new StringBuffer(repeat * str.length());\n         for (int i = 0; i < repeat; i++) {\n             buffer.append(str);\n     }\n \n     /**\n+     * <p>Returns blank padding with a given length.</p>\n+     *\n+     * @param repeat number of times to repeat a blank\n+     * @return String with repeated character\n+     * @throws IndexOutOfBoundsException if repeat < 0\n+     */\n+    private static String padding(int repeat) {\n+        while (blanks.length() < repeat)  {\n+            blanks = blanks.concat(blanks);\n+        }\n+        return blanks.substring(0, repeat);\n+    }\n+\n+    /**\n+     * <p>Returns padding using the specified delimiter repeated to a given length.\n+     * </p>\n+     *\n+     * @param repeat number of times to repeat delim\n+     * @param delim character to repeat\n+     * @return String with repeated character\n+     * @throws NullPointerException if delim is <code>null</code>\n+     * @throws IndexOutOfBoundsException if repeat < 0\n+     */\n+\n+    private static String padding(int repeat, char delim) {\n+        if (padding[delim] == null) {\n+            padding[delim] = String.valueOf(delim);\n+        }\n+        while (padding[delim].length() < repeat) {\n+            padding[delim] = padding[delim].concat(padding[delim]);\n+        }\n+        return padding[delim].substring(0, repeat);\n+    }\n+\n+    /**\n      * <p>Right pad a String with spaces.</p>\n      *\n      * <p>The String is padded to the size of <code>n</code>.</p>\n      * \n-     * @param str String to repeat\n+     * @param str String to pad out\n      * @param size number of times to repeat str\n-     * @return right padded String\n+     * @return right padded String or original String if no padding is necessary\n      * @throws NullPointerException if str is <code>null</code>\n      */\n     public static String rightPad(String str, int size) {\n-        return rightPad(str, size, \" \");\n-    }\n-    \n+        int pads = size - str.length();\n+        if (pads <= 0) {\n+            return str; // returns original string when possible\n+        }\n+        if (pads > PAD_LIMIT) {\n+            return rightPad(str, size, \" \");\n+        }\n+        return str + padding(pads);\n+    }\n+\n+    /**\n+     * <p>Right pad a String with a specified character.</p>\n+     *\n+     * <p>The String is padded to the size of <code>n</code>.</p>\n+     *\n+     * @param str String to pad out\n+     * @param size size to pad to\n+     * @param delim character to pad with\n+     * @return right padded String or original String if no padding is necessary\n+     * @throws NullPointerException if str or delim is <code>null<code>\n+     */\n+    public static String rightPad(String str, int size, char delim) {\n+        int pads = size - str.length();\n+        if (pads <= 0) {\n+            return str; // returns original string when possible\n+        }\n+        if (pads > PAD_LIMIT) {\n+            return rightPad(str, size, String.valueOf(delim));\n+        }\n+        return str + padding(pads, delim);\n+    }\n+\n     /**\n      * <p>Right pad a String with a specified string.</p>\n      *\n      * @param str String to pad out\n      * @param size size to pad to\n      * @param delim String to pad with\n-     * @return right padded String\n+     * @return right padded String or original String if no padding is necessary\n      * @throws NullPointerException if str or delim is <code>null<code>\n      * @throws ArithmeticException if delim is the empty String\n      */\n     public static String rightPad(String str, int size, String delim) {\n+        if (delim.length() == 1 && size - str.length() <= PAD_LIMIT) {\n+           return rightPad(str, size, delim.charAt(0));\n+        }\n+\n         size = (size - str.length()) / delim.length();\n         if (size > 0) {\n             str += repeat(delim, size);\n      *\n      * @param str String to pad out\n      * @param size size to pad to\n-     * @return left padded String\n+     * @return left padded String or original String if no padding is necessary\n      * @throws NullPointerException if str or delim is <code>null<code>\n      */\n     public static String leftPad(String str, int size) {\n-        return leftPad(str, size, \" \");\n-    }\n+        int pads = size - str.length();\n+        if (pads <= 0) { \n+            return str; // returns original string when possible\n+        }\n+        if (pads > PAD_LIMIT) {\n+            return leftPad(str, size, \" \");\n+        }\n+        return padding(pads).concat(str);\n+    }\n+\n+    /**\n+     * Left pad a String with a specified character. Pad to a size of n.\n+     *\n+     * @param str String to pad out\n+     * @param size size to pad to\n+     * @param delim character to pad with\n+     * @return left padded String or original String if no padding is necessary\n+     * @throws NullPointerException if str or delim is <code>null</code>\n+     */\n+    public static String leftPad(String str, int size, char delim) {\n+        int pads = size - str.length();\n+        if (pads <= 0) {\n+            return str; // returns original string when possible\n+        }\n+        if (pads > PAD_LIMIT) {\n+            return leftPad(str, size, \" \");\n+        }\n+        return padding(pads, delim).concat(str);\n+    }\n+\n     /**\n      * Left pad a String with a specified string. Pad to a size of n.\n      *\n      * @param str String to pad out\n      * @param size size to pad to\n      * @param delim String to pad with\n-     * @return left padded String\n+     * @return left padded String or original String if no padding is necessary\n      * @throws NullPointerException if str or delim is null\n      * @throws ArithmeticException if delim is the empty string\n      */\n     public static String leftPad(String str, int size, String delim) {\n+        if (delim.length() == 1 && size - str.length() <= PAD_LIMIT)\n+           return leftPad(str, size, delim.charAt(0));\n         size = (size - str.length()) / delim.length();\n         if (size > 0) {\n             str = repeat(delim, size) + str;\n      * @param validChars an array of valid chars\n      * @return true if it only contains valid chars and is non-null\n      */\n+     /* rewritten\n     public static boolean containsOnly(String str, char[] validChars) {\n         if (str == null || validChars == null) {\n             return false;\n         }\n         return true;\n     }\n+    */\n \n     /**\n      * <p>Checks that the String does not contain certain chars.</p>\n         return true;\n     }\n \n+    /**\n+     * <p>Checks if the String contains only certain chars.</p>\n+     *\n+     * @param str the String to check\n+     * @param valid an array of valid chars\n+     * @return true if it only contains valid chars and is non-null\n+     */\n+    public static boolean containsOnly(String str, char[] valid) {\n+        // All these pre-checks are to maintain API with an older version\n+        if( (valid == null) || (str == null) ) {\n+            return false;\n+        }\n+        if(str.length() == 0) {\n+            return true;\n+        }\n+        if(valid.length == 0) {\n+            return false;\n+        }\n+        return indexOfAnyBut(str, valid) == -1;\n+    }\n+\n+    /**\n+     * <p>Search a String to find the first index of any\n+     * character not in the given set of characters.</p>\n+     * \n+     * @param str  the String to check\n+     * @param searchChars  the chars to search for\n+     * @return the index of any of the chars\n+     * @throws NullPointerException if either str or searchChars is <code>null</code>\n+     */\n+     public static int indexOfAnyBut(String str, char[] searchChars) {\n+         if(searchChars == null) {\n+             return -1;\n+         }\n+         return indexOfAnyBut(str, new String(searchChars));\n+     }\n+\n+    /**\n+     * <p>Search a String to find the first index of any\n+     * character not in the given set of characters.</p>\n+     * \n+     * @param str  the String to check\n+     * @param searchChars  a String containing the chars to search for\n+     * @return the last index of any of the chars\n+     * @throws NullPointerException if either str or searchChars is <code>null</code>\n+     */\n+    public static int indexOfAnyBut(String str, String searchChars) {\n+        if (str == null || searchChars == null) {\n+            return -1;\n+        }\n+\n+        for (int i = 0; i < str.length(); i ++) {\n+           if (searchChars.indexOf(str.charAt(i)) < 0) {\n+               return i;\n+           }\n+        }\n+\n+        return -1;\n+    }\n+\n     // Defaults\n     //--------------------------------------------------------------------------\n     \n      * In no case will it return a string of length greater than maxWidth.\n      *\n      * @param maxWidth maximum length of result string\n-     **/\n+     */\n     public static String abbreviate(String s, int maxWidth) {\n         return abbreviate(s, 0, maxWidth);\n     }\n      *\n      * @param offset left edge of source string\n      * @param maxWidth maximum length of result string\n-     **/\n+     */\n     public static String abbreviate(String s, int offset, int maxWidth) {\n         if (maxWidth < 4)\n             throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n     }\n \n }\n+\n--- a/src/test/org/apache/commons/lang/StringUtilsTest.java\n+++ b/src/test/org/apache/commons/lang/StringUtilsTest.java\n  * @author <a href=\"mailto:fredrik@westermarck.com>Fredrik Westermarck</a>\n  * @author Holger Krauth\n  * @author <a href=\"hps@intermeta.de\">Henning P. Schmiedehausen</a>\n- * @version $Id: StringUtilsTest.java,v 1.18 2003/04/09 18:45:29 alex Exp $\n+ * @version $Id: StringUtilsTest.java,v 1.19 2003/04/16 04:37:33 bayard Exp $\n  */\n public class StringUtilsTest extends TestCase {\n \n         assertEquals(\"containsNone(str3, chars3)\", true, StringUtils.containsNone(str3, chars3));\n     }\n \n+    public void testIndexOfAnyBut() {\n+        String str1 = \"a\";\n+        String str2 = \"b\";\n+        String str3 = \"ab\";\n+        String chars1= \"b\";\n+        String chars2= \"a\";\n+        String chars3= \"ab\";\n+        String emptyChars = \"\";\n+        assertEquals(\"indexOfAnyBut(null, null)\", -1, StringUtils.indexOfAnyBut(null, (String) null));\n+        assertEquals(\"indexOfAnyBut(empty-string, null)\", -1, StringUtils.indexOfAnyBut(\"\", (String) null));\n+        assertEquals(\"indexOfAnyBut(null, empty-string)\", -1, StringUtils.indexOfAnyBut(null, emptyChars));\n+        assertEquals(\"indexOfAnyBut(str1, empty-char-array)\", 0, StringUtils.indexOfAnyBut(str1, emptyChars));\n+        assertEquals(\"indexOfAnyBut(empty-string, empty-char-array)\", -1, StringUtils.indexOfAnyBut(\"\", emptyChars));\n+        assertEquals(\"indexOfAnyBut(empty-string, chars1)\", -1, StringUtils.indexOfAnyBut(\"\", chars1));\n+        assertEquals(\"indexOfAnyBut(str1, chars1)\", 0, StringUtils.indexOfAnyBut(str1, chars1));\n+        assertEquals(\"indexOfAnyBut(str1, chars2)\", -1, StringUtils.indexOfAnyBut(str1, chars2));\n+        assertEquals(\"indexOfAnyBut(str1, chars3)\", -1, StringUtils.indexOfAnyBut(str1, chars3));\n+        assertEquals(\"indexOfAnyBut(str2, chars1)\", -1, StringUtils.indexOfAnyBut(str2, chars1));\n+        assertEquals(\"indexOfAnyBut(str2, chars2)\", 0, StringUtils.indexOfAnyBut(str2, chars2));\n+        assertEquals(\"indexOfAnyBut(str2, chars3)\", -1, StringUtils.indexOfAnyBut(str2, chars3));\n+        assertEquals(\"indexOfAnyBut(String3, chars1)\", 0, StringUtils.indexOfAnyBut(str3, chars1));\n+        assertEquals(\"indexOfAnyBut(String3, chars2)\", 1, StringUtils.indexOfAnyBut(str3, chars2));\n+        assertEquals(\"indexOfAnyBut(String3, chars3)\", -1, StringUtils.indexOfAnyBut(str3, chars3));\n+    }\n+\n     public void testAbbreviate()\n     {\n         assertEquals(\"abbreviate(String,int) failed\",", "timestamp": 1050467853, "metainfo": ""}