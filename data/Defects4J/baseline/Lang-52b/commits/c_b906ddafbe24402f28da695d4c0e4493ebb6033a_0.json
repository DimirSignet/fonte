{"sha": "b906ddafbe24402f28da695d4c0e4493ebb6033a", "log": "Adding new excludeFields functionality for EqualsBuilder and HashCodeBuilder, as submitted by Pete Gieser, Bugzilla: #39315  ", "commit": "\n--- a/src/java/org/apache/commons/lang/builder/EqualsBuilder.java\n+++ b/src/java/org/apache/commons/lang/builder/EqualsBuilder.java\n import java.lang.reflect.AccessibleObject;\n import java.lang.reflect.Field;\n import java.lang.reflect.Modifier;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n \n /**\n  * <p>Assists in implementing {@link Object#equals(Object)} methods.</p>\n      * @return <code>true</code> if the two Objects have tested equals.\n      */\n     public static boolean reflectionEquals(Object lhs, Object rhs) {\n-        return reflectionEquals(lhs, rhs, false, null);\n+        return reflectionEquals(lhs, rhs, false, null, null);\n     }\n \n     /**\n      * a security manager, if the permissions are not set up correctly. It is also\n      * not as efficient as testing explicitly.</p>\n      *\n+     * <p>Transient members will be not be tested, as they are likely derived\n+     * fields, and not part of the value of the Object.</p>\n+     *\n+     * <p>Static fields will not be tested. Superclass fields will be included.</p>\n+     *\n+     * @param lhs  <code>this</code> object\n+     * @param rhs  the other object\n+     * @param excludeFields  array of field names to exclude from testing\n+     * @return <code>true</code> if the two Objects have tested equals.\n+     */\n+    public static boolean reflectionEquals(Object lhs, Object rhs, String[] excludeFields) {\n+        return reflectionEquals(lhs, rhs, false, null, excludeFields);\n+    }\n+\n+    /**\n+     * <p>This method uses reflection to determine if the two <code>Object</code>s\n+     * are equal.</p>\n+     *\n+     * <p>It uses <code>AccessibleObject.setAccessible</code> to gain access to private\n+     * fields. This means that it will throw a security exception if run under\n+     * a security manager, if the permissions are not set up correctly. It is also\n+     * not as efficient as testing explicitly.</p>\n+     *\n      * <p>If the TestTransients parameter is set to <code>true</code>, transient\n      * members will be tested, otherwise they are ignored, as they are likely\n      * derived fields, and not part of the value of the <code>Object</code>.</p>\n      * @return <code>true</code> if the two Objects have tested equals.\n      */\n     public static boolean reflectionEquals(Object lhs, Object rhs, boolean testTransients) {\n-        return reflectionEquals(lhs, rhs, testTransients, null);\n+        return reflectionEquals(lhs, rhs, testTransients, null, null);\n     }\n \n     /**\n      * @since 2.0\n      */\n     public static boolean reflectionEquals(Object lhs, Object rhs, boolean testTransients, Class reflectUpToClass) {\n+        return reflectionEquals(lhs, rhs, testTransients, reflectUpToClass, null);\n+    }\n+\n+    /**\n+     * <p>This method uses reflection to determine if the two <code>Object</code>s\n+     * are equal.</p>\n+     *\n+     * <p>It uses <code>AccessibleObject.setAccessible</code> to gain access to private\n+     * fields. This means that it will throw a security exception if run under\n+     * a security manager, if the permissions are not set up correctly. It is also\n+     * not as efficient as testing explicitly.</p>\n+     *\n+     * <p>If the testTransients parameter is set to <code>true</code>, transient\n+     * members will be tested, otherwise they are ignored, as they are likely\n+     * derived fields, and not part of the value of the <code>Object</code>.</p>\n+     *\n+     * <p>Static fields will not be included. Superclass fields will be appended\n+     * up to and including the specified superclass. A null superclass is treated\n+     * as java.lang.Object.</p>\n+     *\n+     * @param lhs  <code>this</code> object\n+     * @param rhs  the other object\n+     * @param testTransients  whether to include transient fields\n+     * @param reflectUpToClass  the superclass to reflect up to (inclusive),\n+     *  may be <code>null</code>\n+     * @param excludeFields  array of field names to exclude from testing\n+     * @return <code>true</code> if the two Objects have tested equals.\n+     * @since 2.0\n+     */\n+    public static boolean reflectionEquals(Object lhs, Object rhs, boolean testTransients, Class reflectUpToClass,\n+            String[] excludeFields) {\n         if (lhs == rhs) {\n             return true;\n         }\n         }\n         EqualsBuilder equalsBuilder = new EqualsBuilder();\n         try {\n-            reflectionAppend(lhs, rhs, testClass, equalsBuilder, testTransients);\n+            reflectionAppend(lhs, rhs, testClass, equalsBuilder, testTransients, excludeFields);\n             while (testClass.getSuperclass() != null && testClass != reflectUpToClass) {\n                 testClass = testClass.getSuperclass();\n-                reflectionAppend(lhs, rhs, testClass, equalsBuilder, testTransients);\n+                reflectionAppend(lhs, rhs, testClass, equalsBuilder, testTransients, excludeFields);\n             }\n         } catch (IllegalArgumentException e) {\n             // In this case, we tried to test a subclass vs. a superclass and\n      * @param clazz  the class to append details of\n      * @param builder  the builder to append to\n      * @param useTransients  whether to test transient fields\n+     * @param excludeFields  array of field names to exclude from testing\n      */\n     private static void reflectionAppend(\n         Object lhs,\n         Object rhs,\n         Class clazz,\n         EqualsBuilder builder,\n-        boolean useTransients) {\n+        boolean useTransients,\n+        String[] excludeFields) {\n         Field[] fields = clazz.getDeclaredFields();\n+        List excludedFieldList = excludeFields != null ? Arrays.asList(excludeFields) : Collections.EMPTY_LIST;\n         AccessibleObject.setAccessible(fields, true);\n         for (int i = 0; i < fields.length && builder.isEquals; i++) {\n             Field f = fields[i];\n-            if ((f.getName().indexOf('$') == -1)\n+            if (!excludedFieldList.contains(f.getName())\n+                && (f.getName().indexOf('$') == -1)\n                 && (useTransients || !Modifier.isTransient(f.getModifiers()))\n                 && (!Modifier.isStatic(f.getModifiers()))) {\n                 try {\n--- a/src/java/org/apache/commons/lang/builder/HashCodeBuilder.java\n+++ b/src/java/org/apache/commons/lang/builder/HashCodeBuilder.java\n import java.lang.reflect.AccessibleObject;\n import java.lang.reflect.Field;\n import java.lang.reflect.Modifier;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n \n /**\n  * <p>Assists in implementing {@link Object#hashCode()} methods.</p>\n      * @throws IllegalArgumentException if the object is <code>null</code>\n      */\n     public static int reflectionHashCode(Object object) {\n-        return reflectionHashCode(17, 37, object, false, null);\n+        return reflectionHashCode(17, 37, object, false, null, null);\n+    }\n+\n+    /**\n+     * <p>This method uses reflection to build a valid hash code.</p>\n+     *\n+     * <p>This constructor uses two hard coded choices for the constants\n+     * needed to build a hash code.</p>\n+     *\n+     * <p>It uses <code>AccessibleObject.setAccessible</code> to gain access to private\n+     * fields. This means that it will throw a security exception if run under\n+     * a security manager, if the permissions are not set up correctly. It is\n+     * also not as efficient as testing explicitly.</p>\n+     *\n+     * <p>Transient members will be not be used, as they are likely derived\n+     * fields, and not part of the value of the <code>Object</code>.</p>\n+     *\n+     * <p>Static fields will not be tested. Superclass fields will be included.</p>\n+     *\n+     * @param object  the Object to create a <code>hashCode</code> for\n+     * @param excludeFields  array of field names to exclude from use in calculation of hash code\n+     * @return int hash code\n+     * @throws IllegalArgumentException if the object is <code>null</code>\n+     */\n+    public static int reflectionHashCode(Object object, String[] excludeFields) {\n+        return reflectionHashCode(17, 37, object, false, null, excludeFields);\n     }\n \n     /**\n      * @throws IllegalArgumentException if the object is <code>null</code>\n      */\n     public static int reflectionHashCode(Object object, boolean testTransients) {\n-        return reflectionHashCode(17, 37, object, testTransients, null);\n+        return reflectionHashCode(17, 37, object, testTransients, null, null);\n     }\n \n     /**\n      */\n     public static int reflectionHashCode(\n             int initialNonZeroOddNumber, int multiplierNonZeroOddNumber, Object object) {\n-        return reflectionHashCode(initialNonZeroOddNumber, multiplierNonZeroOddNumber, object, false, null);\n+        return reflectionHashCode(initialNonZeroOddNumber, multiplierNonZeroOddNumber, object, false, null, null);\n     }\n \n     /**\n     public static int reflectionHashCode(\n             int initialNonZeroOddNumber, int multiplierNonZeroOddNumber,\n             Object object, boolean testTransients) {\n-        return reflectionHashCode(initialNonZeroOddNumber, multiplierNonZeroOddNumber, object, testTransients, null);\n+        return reflectionHashCode(initialNonZeroOddNumber, multiplierNonZeroOddNumber, object, testTransients, null, null);\n     }\n             \n     /**\n      * @param testTransients  whether to include transient fields\n      * @param reflectUpToClass  the superclass to reflect up to (inclusive),\n      *  may be <code>null</code>\n+     * @param excludeFields  array of field names to exclude from use in calculation of hash code\n      * @return int hash code\n      * @throws IllegalArgumentException if the Object is <code>null</code>\n      * @throws IllegalArgumentException if the number is zero or even\n         int multiplierNonZeroOddNumber,\n         Object object,\n         boolean testTransients,\n-        Class reflectUpToClass) {\n+        Class reflectUpToClass,\n+        String[] excludeFields) {\n \n         if (object == null) {\n             throw new IllegalArgumentException(\"The object to build a hash code for must not be null\");\n         }\n         HashCodeBuilder builder = new HashCodeBuilder(initialNonZeroOddNumber, multiplierNonZeroOddNumber);\n         Class clazz = object.getClass();\n-        reflectionAppend(object, clazz, builder, testTransients);\n+        reflectionAppend(object, clazz, builder, testTransients, excludeFields);\n         while (clazz.getSuperclass() != null && clazz != reflectUpToClass) {\n             clazz = clazz.getSuperclass();\n-            reflectionAppend(object, clazz, builder, testTransients);\n+            reflectionAppend(object, clazz, builder, testTransients, excludeFields);\n         }\n         return builder.toHashCode();\n     }\n      * @param builder  the builder to append to\n      * @param useTransients  whether to use transient fields\n      */\n-    private static void reflectionAppend(Object object, Class clazz, HashCodeBuilder builder, boolean useTransients) {\n+    private static void reflectionAppend(\n+            Object object, \n+            Class clazz, \n+            HashCodeBuilder builder, \n+            boolean useTransients,\n+            String[] excludeFields) {\n         Field[] fields = clazz.getDeclaredFields();\n+        List excludedFieldList = excludeFields != null ? Arrays.asList(excludeFields) : Collections.EMPTY_LIST;\n         AccessibleObject.setAccessible(fields, true);\n         for (int i = 0; i < fields.length; i++) {\n             Field f = fields[i];\n-            if ((f.getName().indexOf('$') == -1)\n+            if (!excludedFieldList.contains(f.getName())\n+                && (f.getName().indexOf('$') == -1)\n                 && (useTransients || !Modifier.isTransient(f.getModifiers()))\n                 && (!Modifier.isStatic(f.getModifiers()))) {\n                 try {\n--- a/src/test/org/apache/commons/lang/builder/EqualsBuilderTest.java\n+++ b/src/test/org/apache/commons/lang/builder/EqualsBuilderTest.java\n  */\n package org.apache.commons.lang.builder;\n \n+import java.lang.reflect.Field;\n import java.util.Arrays;\n \n import junit.framework.Test;\n         // http://issues.apache.org/bugzilla/show_bug.cgi?id=33067\n         new EqualsBuilder().append(x1, x2);\n     }\n+\n+    public void testReflectionEqualsExcludeFields() throws Exception {\n+        TestObjectWithMultipleFields x1 = new TestObjectWithMultipleFields(1, 2, 3);\n+        TestObjectWithMultipleFields x2 = new TestObjectWithMultipleFields(1, 3, 4);\n+\n+        // not equal when including all fields\n+        assertTrue(!EqualsBuilder.reflectionEquals(x1, x2));\n+\n+        // doesn't barf on null, empty array, or non-existent field, but still tests as not equal\n+        assertTrue(!EqualsBuilder.reflectionEquals(x1, x2, null));\n+        assertTrue(!EqualsBuilder.reflectionEquals(x1, x2, new String[] {}));\n+        assertTrue(!EqualsBuilder.reflectionEquals(x1, x2, new String[] {\"xxx\"}));\n+\n+        // not equal if only one of the differing fields excluded\n+        assertTrue(!EqualsBuilder.reflectionEquals(x1, x2, new String[] {\"two\"}));\n+        assertTrue(!EqualsBuilder.reflectionEquals(x1, x2, new String[] {\"three\"}));\n+\n+        // equal if both differing fields excluded\n+        assertTrue(EqualsBuilder.reflectionEquals(x1, x2, new String[] {\"two\", \"three\"}));\n+\n+        // still equal as long as both differing fields are among excluded\n+        assertTrue(EqualsBuilder.reflectionEquals(x1, x2, new String[] {\"one\", \"two\", \"three\"}));\n+        assertTrue(EqualsBuilder.reflectionEquals(x1, x2, new String[] {\"one\", \"two\", \"three\", \"xxx\"}));\n+    }\n+\n+    static class TestObjectWithMultipleFields {\n+        private TestObject one;\n+        private TestObject two;\n+        private TestObject three;\n+\n+        public TestObjectWithMultipleFields(int one, int two, int three) {\n+            this.one = new TestObject(one);\n+            this.two = new TestObject(two);\n+            this.three = new TestObject(three);\n+        }\n+    }\n }\n--- a/src/test/org/apache/commons/lang/builder/HashCodeBuilderTest.java\n+++ b/src/test/org/apache/commons/lang/builder/HashCodeBuilderTest.java\n         assertEquals( (((17 * 37 + 0) * 37 + 1) * 37 + 1), new HashCodeBuilder(17, 37).append(obj).toHashCode());\n     }\n \n+    public void testReflectionHashCodeExcludeFields() throws Exception {\n+        TestObjectWithMultipleFields x = new TestObjectWithMultipleFields(1, 2, 3);\n+\n+        assertEquals((((17 * 37 + 1) * 37 + 2) * 37 + 3), HashCodeBuilder.reflectionHashCode(x));\n+\n+        assertEquals((((17 * 37 + 1) * 37 + 2) * 37 + 3), HashCodeBuilder.reflectionHashCode(x, null));\n+        assertEquals((((17 * 37 + 1) * 37 + 2) * 37 + 3), HashCodeBuilder.reflectionHashCode(x, new String[] {}));\n+        assertEquals((((17 * 37 + 1) * 37 + 2) * 37 + 3), HashCodeBuilder.reflectionHashCode(x, new String[] {\"xxx\"}));\n+\n+        assertEquals(((17 * 37 + 1) * 37 + 3), HashCodeBuilder.reflectionHashCode(x, new String[] {\"two\"}));\n+        assertEquals(((17 * 37 + 1) * 37 + 2), HashCodeBuilder.reflectionHashCode(x, new String[] {\"three\"}));\n+\n+        assertEquals((17 * 37 + 1), HashCodeBuilder.reflectionHashCode(x, new String[] {\"two\", \"three\"}));\n+\n+        assertEquals(17, HashCodeBuilder.reflectionHashCode(x, new String[] {\"one\", \"two\", \"three\"}));\n+        assertEquals(17, HashCodeBuilder.reflectionHashCode(x, new String[] {\"one\", \"two\", \"three\", \"xxx\"}));\n+    }\n+\n+    static class TestObjectWithMultipleFields {\n+        private int one = 0;\n+        private int two = 0;\n+        private int three = 0;\n+\n+        public TestObjectWithMultipleFields(int one, int two, int three) {\n+            this.one = one;\n+            this.two = two;\n+            this.three = three;\n+        }\n+    }\n }", "timestamp": 1145862000, "metainfo": ""}