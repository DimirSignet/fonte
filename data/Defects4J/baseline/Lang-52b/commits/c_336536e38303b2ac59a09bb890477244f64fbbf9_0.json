{"sha": "336536e38303b2ac59a09bb890477244f64fbbf9", "log": "Remove StrTokenizer.Matcher, replace with StrMatcher  ", "commit": "\n--- a/src/java/org/apache/commons/lang/text/StrTokenizer.java\n+++ b/src/java/org/apache/commons/lang/text/StrTokenizer.java\n package org.apache.commons.lang.text;\n \n import java.util.ArrayList;\n-import java.util.Arrays;\n import java.util.List;\n import java.util.ListIterator;\n \n  */\n public class StrTokenizer implements ListIterator, Cloneable {\n \n-    /**\n-     * Matches the comma character.\n-     * Best used for <code>delimiter</code>.\n-     */\n-    public static final Matcher COMMA_MATCHER = new CharMatcher(',');\n-    /**\n-     * Matches the tab character.\n-     * Best used for <code>delimiter</code>.\n-     */\n-    public static final Matcher TAB_MATCHER = new CharMatcher('\\t');\n-    /**\n-     * Matches the space character.\n-     * Best used for <code>delimiter</code>.\n-     */\n-    public static final Matcher SPACE_MATCHER = new CharMatcher(' ');\n-    /**\n-     * Matches the same characters as StringTokenizer,\n-     * namely space, tab, newline, formfeed.\n-     * Best used for <code>delimiter</code>.\n-     */\n-    public static final Matcher SPLIT_MATCHER = createCharSetMatcher(\" \\t\\n\\r\\f\");\n-    /**\n-     * Matches the double quote character.\n-     * Best used for <code>quote</code>.\n-     */\n-    public static final Matcher SINGLE_QUOTE_MATCHER = new CharMatcher('\\'');\n-    /**\n-     * Matches the double quote character.\n-     * Best used for <code>quote</code>.\n-     */\n-    public static final Matcher DOUBLE_QUOTE_MATCHER = new CharMatcher('\"');\n-    /**\n-     * Matches the String trim() whitespace characters.\n-     * Best used for <code>trimmer</code>.\n-     */\n-    public static final Matcher TRIM_MATCHER = new TrimMatcher();\n-    /**\n-     * Matches no characters. Don't use this for delimiters!\n-     * Best used for <code>trimmer</code>.\n-     */\n-    public static final Matcher NONE_MATCHER = new NoMatcher();\n-\n     private static final StrTokenizer CSV_TOKENIZER_PROTOTYPE;\n     private static final StrTokenizer TSV_TOKENIZER_PROTOTYPE;\n     static {\n         CSV_TOKENIZER_PROTOTYPE = new StrTokenizer();\n-        CSV_TOKENIZER_PROTOTYPE.setDelimiterMatcher(COMMA_MATCHER);\n-        CSV_TOKENIZER_PROTOTYPE.setQuoteMatcher(DOUBLE_QUOTE_MATCHER);\n-        CSV_TOKENIZER_PROTOTYPE.setIgnoredMatcher(NONE_MATCHER);\n-        CSV_TOKENIZER_PROTOTYPE.setTrimmerMatcher(TRIM_MATCHER);\n+        CSV_TOKENIZER_PROTOTYPE.setDelimiterMatcher(StrMatcher.commaMatcher());\n+        CSV_TOKENIZER_PROTOTYPE.setQuoteMatcher(StrMatcher.doubleQuoteMatcher());\n+        CSV_TOKENIZER_PROTOTYPE.setIgnoredMatcher(StrMatcher.noneMatcher());\n+        CSV_TOKENIZER_PROTOTYPE.setTrimmerMatcher(StrMatcher.trimMatcher());\n         CSV_TOKENIZER_PROTOTYPE.setEmptyTokenAsNull(false);\n         CSV_TOKENIZER_PROTOTYPE.setIgnoreEmptyTokens(false);\n \n         TSV_TOKENIZER_PROTOTYPE = new StrTokenizer();\n-        TSV_TOKENIZER_PROTOTYPE.setDelimiterMatcher(TAB_MATCHER);\n-        TSV_TOKENIZER_PROTOTYPE.setQuoteMatcher(DOUBLE_QUOTE_MATCHER);\n-        TSV_TOKENIZER_PROTOTYPE.setIgnoredMatcher(NONE_MATCHER);\n-        TSV_TOKENIZER_PROTOTYPE.setTrimmerMatcher(TRIM_MATCHER);\n+        TSV_TOKENIZER_PROTOTYPE.setDelimiterMatcher(StrMatcher.tabMatcher());\n+        TSV_TOKENIZER_PROTOTYPE.setQuoteMatcher(StrMatcher.doubleQuoteMatcher());\n+        TSV_TOKENIZER_PROTOTYPE.setIgnoredMatcher(StrMatcher.noneMatcher());\n+        TSV_TOKENIZER_PROTOTYPE.setTrimmerMatcher(StrMatcher.trimMatcher());\n         TSV_TOKENIZER_PROTOTYPE.setEmptyTokenAsNull(false);\n         TSV_TOKENIZER_PROTOTYPE.setIgnoreEmptyTokens(false);\n     }\n     private int tokenPos;\n \n     /** The delimiter matcher */\n-    private Matcher delim = SPLIT_MATCHER;\n+    private StrMatcher delim = StrMatcher.splitMatcher();\n     /** The quote matcher */\n-    private Matcher quote = NONE_MATCHER;\n+    private StrMatcher quote = StrMatcher.noneMatcher();\n     /** The ignored matcher */\n-    private Matcher ignored = NONE_MATCHER;\n+    private StrMatcher ignored = StrMatcher.noneMatcher();\n     /** The trimmer matcher */\n-    private Matcher trimmer = NONE_MATCHER;\n+    private StrMatcher trimmer = StrMatcher.noneMatcher();\n \n     /** Whether to return empty tokens as null */\n     private boolean emptyAsNull = false;\n     /** Whether to ignore empty tokens */\n     private boolean ignoreEmptyTokens = true;\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Constructor that creates a matcher from a set of characters.\n-     *\n-     * @param chars  the characters to match, must not be null\n-     * @return A new matcher for the given char[].\n-     * @throws IllegalArgumentException if the character set is null or empty\n-     */\n-    public static Matcher createCharSetMatcher(char[] chars) {\n-        if (chars == null || chars.length == 0) {\n-            throw new IllegalArgumentException(\"Characters must not be null or empty\");\n-        }\n-        if (chars.length == 1) {\n-            return new CharMatcher(chars[0]);\n-        }\n-        return new CharSetMatcher(chars);\n-    }\n-\n-    /**\n-     * Constructor that creates a matcher from a string representing a set of characters.\n-     *\n-     * @param chars  the characters to match, must not be null\n-     * @return A new Matcher for the given characters.\n-     * @throws IllegalArgumentException if the character set is null or empty\n-     */\n-    public static Matcher createCharSetMatcher(String chars) {\n-        if (chars == null || chars.length() == 0) {\n-            throw new IllegalArgumentException(\"Characters must not be null or empty\");\n-        }\n-        if (chars.length() == 1) {\n-            return new CharMatcher(chars.charAt(0));\n-        }\n-        return new CharSetMatcher(chars.toCharArray());\n-    }\n-\n-    /**\n-     * Constructor that creates a matcher from a character.\n-     *\n-     * @param ch  the character to match, must not be null\n-     * @return A new Matcher for the given char.\n-     */\n-    public static Matcher createCharMatcher(char ch) {\n-        return new CharMatcher(ch);\n-    }\n-\n-    /**\n-     * Constructor that creates a matcher from a string.\n-     *\n-     * @param str  the string to match, must not be null\n-     * @return A new Matcher for the given String.\n-     * @throws IllegalArgumentException if the string is null or empty\n-     */\n-    public static Matcher createStringMatcher(String str) {\n-        if (str == null || str.length() == 0) {\n-            throw new IllegalArgumentException(\"String must not be null or empty\");\n-        }\n-        return new StringMatcher(str);\n-    }\n \n     //-----------------------------------------------------------------------\n \n      * @param input  the string which is to be parsed\n      * @param delim  the field delimiter matcher\n      */\n-    public StrTokenizer(String input, Matcher delim) {\n+    public StrTokenizer(String input, StrMatcher delim) {\n         this(input);\n         setDelimiterMatcher(delim);\n     }\n      * @param delim  the field delimiter matcher\n      * @param quote  the field quoted string matcher\n      */\n-    public StrTokenizer(String input, Matcher delim, Matcher quote) {\n+    public StrTokenizer(String input, StrMatcher delim, StrMatcher quote) {\n         this(input, delim);\n         setQuoteMatcher(quote);\n     }\n      * @param input  the string which is to be parsed, cloned\n      * @param delim  the field delimiter matcher\n      */\n-    public StrTokenizer(char[] input, Matcher delim) {\n+    public StrTokenizer(char[] input, StrMatcher delim) {\n         this(input);\n         setDelimiterMatcher(delim);\n     }\n      * @param delim  the field delimiter character\n      * @param quote  the field quoted string character\n      */\n-    public StrTokenizer(char[] input, Matcher delim, Matcher quote) {\n+    public StrTokenizer(char[] input, StrMatcher delim, StrMatcher quote) {\n         this(input, delim);\n         setQuoteMatcher(quote);\n     }\n             // Handle the special case where the very last\n             // character is a delimiter, in which case, we\n             // need another empty string\n-            if (start == len && delim.isMatch(chars, len, start - 1) == 1) {\n+            if (start == len && delim.isMatch(chars, start - 1, 0, len) == 1) {\n                 // Add the token, following the rules\n                 // in this object\n                 addToken(tokens, \"\");\n         int delimLen = 0;\n         int quoteLen = 0;\n         while (start < len &&\n-                (ignoreLen = ignored.isMatch(chars, len, start)) >= 1 &&\n-                (delimLen = delim.isMatch(chars, len, start)) < 1 &&\n-                (quoteLen = quote.isMatch(chars, len, start)) < 1) {\n+                (ignoreLen = ignored.isMatch(chars, start, 0, len)) >= 1 &&\n+                (delimLen = delim.isMatch(chars, start, 0, len)) < 1 &&\n+                (quoteLen = quote.isMatch(chars, start, 0, len)) < 1) {\n             start += ignoreLen;\n         }\n \n             return start;\n         } else {\n             // lengths not setup\n-            if ((delimLen = delim.isMatch(chars, len, start)) >= 1) {\n+            if ((delimLen = delim.isMatch(chars, start, 0, len)) >= 1) {\n                 start += delimLen;\n-            } else if ((quoteLen = quote.isMatch(chars, len, start)) >= 1) {\n+            } else if ((quoteLen = quote.isMatch(chars, start, 0, len)) >= 1) {\n                 start = readQuoted(start + quoteLen, cbuf, token);\n             } else {\n                 start = readUnquoted(start, token);\n                 // followed by a second quote.  If so, then we need\n                 // to actually put the quote character into the token\n                 // rather than end the token.\n-                if ((quoteLen = quote.isMatch(chars, len, pos)) >= 1) {\n+                if ((quoteLen = quote.isMatch(chars, pos, 0, len)) >= 1) {\n                     if (pos + 1 < len && chars[pos + 1] == chars[pos]) {\n                         cbuf[cbufcnt++] = chars[pos];\n                         pos += 2;\n             // the character\n             else {\n                 // If we're\n-                if ((delimLen = delim.isMatch(chars, len, pos)) >= 1) {\n+                if ((delimLen = delim.isMatch(chars, pos, 0, len)) >= 1) {\n                     done = true;\n                 } else {\n-                    if ((quoteLen = quote.isMatch(chars, len, pos)) >= 1) {\n+                    if ((quoteLen = quote.isMatch(chars, pos, 0, len)) >= 1) {\n                         quoting = true;\n                         pos += quoteLen;\n                     } else {\n         int len = chars.length;\n         int pos = start;\n         int delimLen = 0;\n-        while (pos < len && (delimLen = delim.isMatch(chars, len, pos)) < 1) {\n+        while (pos < len && (delimLen = delim.isMatch(chars, pos, 0, len)) < 1) {\n             pos++;\n         }\n \n         /* Trim string based on the trimmer matcher */\n-        while (trimmer.isMatch(chars, 1, start) > 0) {\n+        while (trimmer.isMatch(chars, start, 0, len) > 0) {\n             start++;\n         }\n \n         int length = Math.min(pos, len) - start;\n \n-        while (trimmer.isMatch(chars, 1, start + length - 1) > 0) {\n+        while (trimmer.isMatch(chars, start + length - 1, 0, len) > 0) {\n             length--;\n         }\n \n         for (int i=0;i<length;i++) {\n-            if (ignored.isMatch(chars, 1, start + i) == 0) {\n+            if (ignored.isMatch(chars, start + i, 0, len) == 0) {\n                 token.append(chars[start + i]);\n             }\n         }\n      *\n      * @return the delimiter matcher in use\n      */\n-    public Matcher getDelimiterMatcher() {\n+    public StrMatcher getDelimiterMatcher() {\n         return delim;\n     }\n \n      *\n      * @param delim  the delimiter matcher to use\n      */\n-    public void setDelimiterMatcher(Matcher delim) {\n+    public void setDelimiterMatcher(StrMatcher delim) {\n         if (delim == null) {\n-            this.delim = NONE_MATCHER;\n+            this.delim = StrMatcher.noneMatcher();\n         } else {\n             this.delim = delim;\n         }\n      * @param delim  the delimiter character to use\n      */\n     public void setDelimiterChar(char delim) {\n-        setDelimiterMatcher(new CharMatcher(delim));\n+        setDelimiterMatcher(StrMatcher.charMatcher(delim));\n     }\n \n     /**\n      * @param delim  the delimiter character to use\n      */\n     public void setDelimiterString(String delim) {\n-        if (delim == null || delim.length() == 0) {\n-            setDelimiterMatcher(NONE_MATCHER);\n-        } else if (delim.length() == 1) {\n-            setDelimiterMatcher(new CharMatcher(delim.charAt(0)));\n-        } else {\n-            setDelimiterMatcher(new StringMatcher(delim));\n-        }\n+        setDelimiterMatcher(StrMatcher.stringMatcher(delim));\n     }\n \n     // Quote\n      *\n      * @return the quote matcher in use\n      */\n-    public Matcher getQuoteMatcher() {\n+    public StrMatcher getQuoteMatcher() {\n         return quote;\n     }\n \n      *\n      * @param quote  the quote matcher to use, null ignored\n      */\n-    public void setQuoteMatcher(Matcher quote) {\n+    public void setQuoteMatcher(StrMatcher quote) {\n         if (quote != null) {\n             this.quote = quote;\n         }\n      * @param quote  the quote character to use\n      */\n     public void setQuoteChar(char quote) {\n-        setQuoteMatcher(new CharMatcher(quote));\n+        setQuoteMatcher(StrMatcher.charMatcher(quote));\n     }\n \n     // Ignored\n      *\n      * @return the ignored matcher in use\n      */\n-    public Matcher getIgnoredMatcher() {\n+    public StrMatcher getIgnoredMatcher() {\n         return ignored;\n     }\n \n      *\n      * @param ignored  the ignored matcher to use, null ignored\n      */\n-    public void setIgnoredMatcher(Matcher ignored) {\n+    public void setIgnoredMatcher(StrMatcher ignored) {\n         if (ignored != null) {\n             this.ignored = ignored;\n         }\n      * @param ignored  the ignored character to use\n      */\n     public void setIgnoredChar(char ignored) {\n-        setIgnoredMatcher(new CharMatcher(ignored));\n+        setIgnoredMatcher(StrMatcher.charMatcher(ignored));\n     }\n \n     // Trimmer\n      *\n      * @return the trimmer matcher in use\n      */\n-    public Matcher getTrimmerMatcher() {\n+    public StrMatcher getTrimmerMatcher() {\n         return trimmer;\n     }\n \n      *\n      * @param trimmer  the trimmer matcher to use, null ignored\n      */\n-    public void setTrimmerMatcher(Matcher trimmer) {\n+    public void setTrimmerMatcher(StrMatcher trimmer) {\n         if (trimmer != null) {\n             this.trimmer = trimmer;\n         }\n         }\n     }\n \n-    //-----------------------------------------------------------------------\n-    /**\n-     * Defines the interface used to match a set of characters during tokenization.\n-     * Standard implementations of this interface are provided in the library.\n-     * These are accessed via the create*() factory methods on StrTokenizer.\n-     * If your application needs more unusual matching, implement this interface directly.\n-     */\n-    public static interface Matcher {\n-        /**\n-         * Returns the number of matching characters, zero for no match.\n-         * <p>\n-         * This method is called to check for a match.\n-         * The parameter <code>pos</code> represents the current position to be\n-         * checked in the string <code>text</code> (a character array which must\n-         * not be changed).\n-         * The text length is also provided for efficiency.\n-         * The API guarantees that <code>pos</code> is a valid index for <code>text</code>.\n-         * <p>\n-         * The matching code may check one character or many.\n-         * It must return zero for no match, or a positive number if a match was found.\n-         * The number indicates the number of characters that matched.\n-         *\n-         * @param text  the text content to match against, do not change\n-         * @param textLen  the length of the text\n-         * @param pos  the starting position for the match, valid for text\n-         * @return the number of matching characters, zero for no match\n-         */\n-        int isMatch(char[] text, int textLen, int pos);\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Class used to define a set of characters for matching purposes.\n-     */\n-    public static final class CharSetMatcher implements Matcher {\n-        private char[] chars;\n-\n-        /**\n-         * Constructor that creates a matcher from a character array.\n-         *\n-         * @param chars  the characters to match, must not be null\n-         */\n-        public CharSetMatcher(char chars[]) {\n-            super();\n-            this.chars = (char[]) chars.clone();\n-            Arrays.sort(this.chars);\n-        }\n-\n-        /**\n-         * Returns whether or not the given charatcer matches.\n-         *\n-         * @param text  the text content to match against\n-         * @param textLen  the length of the text\n-         * @param pos  the starting position\n-         * @return the number of matching characters, zero for no match\n-         */\n-        public int isMatch(char[] text, int textLen, int pos) {\n-            return Arrays.binarySearch(chars, text[pos]) >= 0 ? 1 : 0;\n-        }\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Class used to define a character for matching purposes.\n-     */\n-    static final class CharMatcher implements Matcher {\n-        private char ch;\n-\n-        /**\n-         * Constructor that creates a matcher that matches a single character.\n-         *\n-         * @param ch  the character to match\n-         */\n-        CharMatcher(char ch) {\n-            super();\n-            this.ch = ch;\n-        }\n-\n-        /**\n-         * Returns whether or not the given character matches.\n-         *\n-         * @param text  the text content to match against\n-         * @param textLen  the length of the text\n-         * @param pos  the starting position\n-         * @return the number of matching characters, zero for no match\n-         */\n-        public int isMatch(char[] text, int textLen, int pos) {\n-            return ch == text[pos] ? 1 : 0;\n-        }\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Class used to define a set of characters for matching purposes.\n-     */\n-    static final class StringMatcher implements Matcher {\n-        private char[] chars;\n-\n-        /**\n-         * Constructor that creates a matcher from a String.\n-         *\n-         * @param str  the string to match, must not be null\n-         */\n-        StringMatcher(String str) {\n-            super();\n-            chars = str.toCharArray();\n-        }\n-\n-        /**\n-         * Returns whether or not the given text matches the stored string.\n-         *\n-         * @param text  the text content to match against\n-         * @param textLen  the length of the text\n-         * @param pos  the starting position\n-         * @return the number of matching characters, zero for no match\n-         */\n-        public int isMatch(char[] text, int textLen, int pos) {\n-            int len = chars.length;\n-            if (pos + len > textLen) {\n-                return 0;\n-            }\n-            for (int i = 0; i < chars.length; i++, pos++) {\n-                if (chars[i] != text[pos]) {\n-                    return 0;\n-                }\n-            }\n-            return len;\n-        }\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Class used to match no characters.\n-     */\n-    static final class NoMatcher implements Matcher {\n-\n-        /**\n-         * Constructs a new instance of <code>NoMatcher</code>.\n-         */\n-        NoMatcher() {\n-            super();\n-        }\n-\n-        /**\n-         * Always returns <code>false</code>.\n-         *\n-         * @param text  the text content to match against\n-         * @param textLen  the length of the text\n-         * @param pos  the starting position\n-         * @return the number of matching characters, zero for no match\n-         */\n-        public int isMatch(char[] text, int textLen, int pos) {\n-            return 0;\n-        }\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Class used to match whitespace as per trim().\n-     */\n-    static final class TrimMatcher implements Matcher {\n-\n-        /**\n-         * Constructs a new instance of <code>TrimMatcher</code>.\n-         */\n-        TrimMatcher() {\n-            super();\n-        }\n-\n-        /**\n-         * Returns whether or not the given charatcer matches.\n-         *\n-         * @param text  the text content to match against\n-         * @param textLen  the length of the text\n-         * @param pos  the starting position\n-         * @return the number of matching characters, zero for no match\n-         */\n-        public int isMatch(char[] text, int textLen, int pos) {\n-            return text[pos] <= 32 ? 1 : 0;\n-        }\n-    }\n-\n }\n--- a/src/java/org/apache/commons/lang/text/VariableFormatter.java\n+++ b/src/java/org/apache/commons/lang/text/VariableFormatter.java\n         private int endIndex;\n \n         /** Stores the matcher for escaped variable start tokens. */\n-        private StrTokenizer.Matcher escVarMatcher;\n+        private StrMatcher escVarMatcher;\n \n         /** Stores the length of the data. */\n         private int length;\n         private LinkedList tokenList;\n \n         /** Stores the matcher for variable end tokens. */\n-        private StrTokenizer.Matcher varEndMatcher;\n+        private StrMatcher varEndMatcher;\n \n         /** Stores the matcher for variable start tokens. */\n-        private StrTokenizer.Matcher varStartMatcher;\n+        private StrMatcher varStartMatcher;\n \n         /**\n          * Creates a new instance of <code>VariableParser</code> and initializes it.\n          * @param length\n          *            the length of the source data\n          */\n-        public VariableParser(StrTokenizer.Matcher startMatcher, StrTokenizer.Matcher endMatcher,\n-                StrTokenizer.Matcher escMatcher, int startPos, int length) {\n+        public VariableParser(StrMatcher startMatcher, StrMatcher endMatcher,\n+                StrMatcher escMatcher, int startPos, int length) {\n             this.setVarStartMatcher(startMatcher);\n             this.setVarEndMatcher(endMatcher);\n             this.setEscVarMatcher(escMatcher);\n         /**\n          * @return Returns the escVarMatcher.\n          */\n-        private StrTokenizer.Matcher getEscVarMatcher() {\n+        private StrMatcher getEscVarMatcher() {\n             return this.escVarMatcher;\n         }\n \n         /**\n          * @return Returns the varEndMatcher.\n          */\n-        private StrTokenizer.Matcher getVarEndMatcher() {\n+        private StrMatcher getVarEndMatcher() {\n             return this.varEndMatcher;\n         }\n \n         /**\n          * @return Returns the varStartMatcher.\n          */\n-        private StrTokenizer.Matcher getVarStartMatcher() {\n+        private StrMatcher getVarStartMatcher() {\n             return this.varStartMatcher;\n         }\n \n                 int startPos = getPos();\n                 int tokenLen;\n                 while (hasNext() && getTokenList().isEmpty()) {\n-                    if ((tokenLen = getEscVarMatcher().isMatch(data, getLength(), getPos())) > 0) {\n+                    if ((tokenLen = getEscVarMatcher().isMatch(data, getPos(), 0, getLength())) > 0) {\n                         checkTextToken(startPos);\n                         getTokenList().addLast(VariableParser.newEscapedVariableToken(getPos(), tokenLen));\n                         setPos(getPos() + tokenLen);\n-                    } else if ((tokenLen = getVarStartMatcher().isMatch(data, getLength(), getPos())) > 0) {\n+                    } else if ((tokenLen = getVarStartMatcher().isMatch(data, getPos(), 0, getLength())) > 0) {\n                         checkTextToken(startPos);\n                         setPos(getPos() + tokenLen);\n                         int varStart = getPos(), endLen = 0;\n-                        while (hasNext() && (endLen = getVarEndMatcher().isMatch(data, getLength(), getPos())) <= 0) {\n+                        while (hasNext() && (endLen = getVarEndMatcher().isMatch(data, getPos(), 0, getLength())) <= 0) {\n                             setPos(getPos() + 1);\n                         }\n                         if (endLen <= 0) {\n          * @param escVarMatcher\n          *            The escVarMatcher to set.\n          */\n-        private void setEscVarMatcher(StrTokenizer.Matcher escVarMatcher) {\n+        private void setEscVarMatcher(StrMatcher escVarMatcher) {\n             this.escVarMatcher = escVarMatcher;\n         }\n \n          * @param varEndMatcher\n          *            The varEndMatcher to set.\n          */\n-        private void setVarEndMatcher(StrTokenizer.Matcher varEndMatcher) {\n+        private void setVarEndMatcher(StrMatcher varEndMatcher) {\n             this.varEndMatcher = varEndMatcher;\n         }\n \n          * @param varStartMatcher\n          *            The varStartMatcher to set.\n          */\n-        private void setVarStartMatcher(StrTokenizer.Matcher varStartMatcher) {\n+        private void setVarStartMatcher(StrMatcher varStartMatcher) {\n             this.varStartMatcher = varStartMatcher;\n         }\n     }\n      * @return the parser\n      */\n     protected VariableParser createParser(char[] data, int offset, int length) {\n-        return new VariableParser(new StrTokenizer.StringMatcher(getVariablePrefix()), new StrTokenizer.StringMatcher(\n-                getVariableSuffix()), new StrTokenizer.StringMatcher(String.valueOf(getEscapeCharacter())\n-            + getVariablePrefix()), offset, length);\n+        return new VariableParser(\n+                StrMatcher.stringMatcher(getVariablePrefix()),\n+                StrMatcher.stringMatcher(getVariableSuffix()),\n+                StrMatcher.stringMatcher(String.valueOf(getEscapeCharacter()) + getVariablePrefix()), offset, length);\n     }\n \n     /**\n--- a/src/test/org/apache/commons/lang/text/StrTokenizerTest.java\n+++ b/src/test/org/apache/commons/lang/text/StrTokenizerTest.java\n         StrTokenizer tok = new StrTokenizer(input);\n         tok.setDelimiterChar(';');\n         tok.setQuoteChar('\"');\n-        tok.setIgnoredMatcher(StrTokenizer.TRIM_MATCHER);\n+        tok.setIgnoredMatcher(StrMatcher.trimMatcher());\n         tok.setIgnoreEmptyTokens(false);\n         String tokens[] = tok.getAllTokens();\n \n         StrTokenizer tok = new StrTokenizer(input);\n         tok.setDelimiterChar(';');\n         tok.setQuoteChar('\"');\n-        tok.setIgnoredMatcher(StrTokenizer.NONE_MATCHER);\n+        tok.setIgnoredMatcher(StrMatcher.noneMatcher());\n         tok.setIgnoreEmptyTokens(false);\n         String tokens[] = tok.getAllTokens();\n \n         StrTokenizer tok = new StrTokenizer(input);\n         tok.setDelimiterChar(';');\n         tok.setQuoteChar('\"');\n-        tok.setIgnoredMatcher(StrTokenizer.NONE_MATCHER);\n+        tok.setIgnoredMatcher(StrMatcher.noneMatcher());\n         tok.setIgnoreEmptyTokens(false);\n         String tokens[] = tok.getAllTokens();\n \n         StrTokenizer tok = new StrTokenizer(input);\n         tok.setDelimiterChar(';');\n         tok.setQuoteChar('\"');\n-        tok.setIgnoredMatcher(StrTokenizer.TRIM_MATCHER);\n+        tok.setIgnoredMatcher(StrMatcher.trimMatcher());\n         tok.setIgnoreEmptyTokens(true);\n         String tokens[] = tok.getAllTokens();\n \n         StrTokenizer tok = new StrTokenizer(input);\n         tok.setDelimiterChar(';');\n         tok.setQuoteChar('\"');\n-        tok.setIgnoredMatcher(StrTokenizer.TRIM_MATCHER);\n+        tok.setIgnoredMatcher(StrMatcher.trimMatcher());\n         tok.setIgnoreEmptyTokens(false);\n         tok.setEmptyTokenAsNull(true);\n         String tokens[] = tok.getAllTokens();\n         StrTokenizer tok = new StrTokenizer(input);\n         tok.setDelimiterChar(';');\n         tok.setQuoteChar('\"');\n-        tok.setIgnoredMatcher(StrTokenizer.TRIM_MATCHER);\n+        tok.setIgnoredMatcher(StrMatcher.trimMatcher());\n         tok.setIgnoreEmptyTokens(false);\n         // tok.setTreatingEmptyAsNull(true);\n         String tokens[] = tok.getAllTokens();\n \n         String input = \"a   b c \\\"d e\\\" f \";\n         StrTokenizer tok = new StrTokenizer(input);\n-        tok.setDelimiterMatcher(StrTokenizer.SPACE_MATCHER);\n-        tok.setQuoteMatcher(StrTokenizer.DOUBLE_QUOTE_MATCHER);\n-        tok.setIgnoredMatcher(StrTokenizer.NONE_MATCHER);\n+        tok.setDelimiterMatcher(StrMatcher.spaceMatcher());\n+        tok.setQuoteMatcher(StrMatcher.doubleQuoteMatcher());\n+        tok.setIgnoredMatcher(StrMatcher.noneMatcher());\n         tok.setIgnoreEmptyTokens(false);\n         String tokens[] = tok.getAllTokens();\n \n \n         String input = \"a   b c \\\"d e\\\" f \";\n         StrTokenizer tok = new StrTokenizer(input);\n-        tok.setDelimiterMatcher(StrTokenizer.SPACE_MATCHER);\n-        tok.setQuoteMatcher(StrTokenizer.DOUBLE_QUOTE_MATCHER);\n-        tok.setIgnoredMatcher(StrTokenizer.NONE_MATCHER);\n+        tok.setDelimiterMatcher(StrMatcher.spaceMatcher());\n+        tok.setQuoteMatcher(StrMatcher.doubleQuoteMatcher());\n+        tok.setIgnoredMatcher(StrMatcher.noneMatcher());\n         tok.setIgnoreEmptyTokens(true);\n         String tokens[] = tok.getAllTokens();\n \n         assertEquals(input, tok.getContent());\n     }\n \n-    public void testMatcher() {\n-        assertEquals(1, StrTokenizer.SPACE_MATCHER.isMatch(new char[]{' '}, 1, 0));\n-        assertEquals(0, StrTokenizer.SPACE_MATCHER.isMatch(new char[]{'\\n'}, 1, 0));\n-        assertEquals(0, StrTokenizer.SPACE_MATCHER.isMatch(new char[]{'\\u0001'}, 1, 0));\n-\n-        assertEquals(1, StrTokenizer.TRIM_MATCHER.isMatch(new char[]{' '}, 1, 0));\n-        assertEquals(1, StrTokenizer.TRIM_MATCHER.isMatch(new char[]{'\\n'}, 1, 0));\n-        assertEquals(1, StrTokenizer.TRIM_MATCHER.isMatch(new char[]{'\\u0001'}, 1, 0));\n-\n-        assertEquals(1, StrTokenizer.SPLIT_MATCHER.isMatch(new char[]{' '}, 1, 0));\n-        assertEquals(1, StrTokenizer.SPLIT_MATCHER.isMatch(new char[]{'\\n'}, 1, 0));\n-        assertEquals(0, StrTokenizer.SPLIT_MATCHER.isMatch(new char[]{'\\u0001'}, 1, 0));\n-    }\n-\n     public void testReset() {\n         String input = \"a b c\";\n         StrTokenizer tok = new StrTokenizer(input);\n         tok.reset(\"f g\".toCharArray());\n         assertEquals(\"f\", tok.next());\n         assertEquals(\"g\", tok.next());\n-    }\n-    \n-    public void testStringMatcher() {\n-        // build test fixture\n-        char[] data = new char[26];\n-        for(int i = 0; i < data.length; i++) {\n-            data[i] = (char) (i + 'a');\n-        }        \n-        // perform tests\n-        StrTokenizer.Matcher matcher = new StrTokenizer.StringMatcher(\"z\");\n-        for(int i = 0; i < data.length - 1; i++) {\n-            assertEquals(0, matcher.isMatch(data, data.length, i));\n-        }\n-        assertEquals(1, matcher.isMatch(data, data.length, data.length - 1));\n-        // test bad pos argument.\n-        assertEquals(0, matcher.isMatch(data, data.length, data.length +100));\n     }\n \n     public void testTSV() {\n         assertEquals(3, tokenizer.size());\n     }\n \n+    public void testIteration() {\n+        StrTokenizer tkn = new StrTokenizer(\"a b c\");\n+        assertEquals(true, tkn.hasNext());\n+        assertEquals(\"a\", tkn.next());\n+        try {\n+            tkn.remove();\n+            fail();\n+        } catch (UnsupportedOperationException ex) {}\n+        try {\n+            tkn.set(\"x\");\n+            fail();\n+        } catch (UnsupportedOperationException ex) {}\n+        try {\n+            tkn.add(\"y\");\n+            fail();\n+        } catch (UnsupportedOperationException ex) {}\n+        assertEquals(true, tkn.hasNext());\n+        assertEquals(\"b\", tkn.next());\n+        assertEquals(true, tkn.hasNext());\n+        assertEquals(\"c\", tkn.next());\n+        assertEquals(false, tkn.hasNext());\n+    }\n+\n }", "timestamp": 1124139503, "metainfo": ""}