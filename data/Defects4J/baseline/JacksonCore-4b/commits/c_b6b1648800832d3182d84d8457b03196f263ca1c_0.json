{"sha": "b6b1648800832d3182d84d8457b03196f263ca1c", "log": "...", "commit": "\n--- a/src/test/java/com/fasterxml/jackson/core/sym/TestJsonParserSymbols.java\n+++ b/src/test/java/com/fasterxml/jackson/core/sym/TestJsonParserSymbols.java\n package com.fasterxml.jackson.core.sym;\n \n import java.io.IOException;\n+\n+import org.junit.Assert;\n \n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.core.json.ReaderBasedJsonParser;\n         assertEquals(3, f.byteSymbolCount());\n     }\n \n+    public void testHashCalc() throws Exception\n+    {\n+        CharsToNameCanonicalizer sym = CharsToNameCanonicalizer.createRoot(123);\n+        char[] str1 = \"foo\".toCharArray();\n+        char[] str2 = \" foo \".toCharArray();\n+\n+        assertEquals(sym.calcHash(str1, 0, 3), sym.calcHash(str2, 1, 3));\n+    }\n+    \n     public void testCharSymbolsWithClose() throws Exception\n     {\n         _testWithClose(false);\n--- a/src/test/java/com/fasterxml/jackson/core/sym/TestSymbolTables.java\n+++ b/src/test/java/com/fasterxml/jackson/core/sym/TestSymbolTables.java\n     public void testSyntheticWithBytes() throws IOException\n     {\n         // pass seed, to keep results consistent:\n+        final int SEED = 33333;\n         BytesToNameCanonicalizer symbols =\n-                BytesToNameCanonicalizer.createRoot(33333).makeChild(JsonFactory.Feature.collectDefaults());\n+                BytesToNameCanonicalizer.createRoot(SEED).makeChild(JsonFactory.Feature.collectDefaults());\n         final int COUNT = 6000;\n         for (int i = 0; i < COUNT; ++i) {\n             String id = fieldNameFor(i);\n--- a/src/test/java/failing/TestHashCollision.java\n+++ b/src/test/java/failing/TestHashCollision.java\n     {\n         StringBuilder sb = new StringBuilder();\n         List<String> coll = collisions();\n-\n-        // First just verify we got collisions for JDK too\n-        // ... only works if we use 31\n-        /*\n-        int hash = coll.get(0).hashCode();\n-        for (int i = 1, end = coll.size(); i < end; ++i) {\n-            if (coll.get(i).hashCode() != hash) {\n-                fail(\"String #\"+i+\" has different hash (0x\"+Integer.toHexString(coll.get(i).hashCode())\n-                        +\"), expected 0x\"+Integer.toHexString(hash));\n-            }\n-        }\n-        */\n         \n         for (String field : coll) {\n             if (sb.length() == 0) {\n         }\n         sb.append(\"}\");\n \n+        // First: attempt with exceptions turned on; should catch an exception\n+\n         JsonFactory jf = new JsonFactory();\n+\n         JsonParser jp = jf.createParser(sb.toString());\n+        jf.enable(JsonFactory.Feature.FAIL_ON_SYMBOL_HASH_OVERFLOW);\n+\n+        try {\n+            while (jp.nextToken() != null) {\n+                ;\n+            }\n+            fail(\"Should have failed\");\n+        } catch (IllegalStateException e) {\n+            verifyException(e, \"foo\");\n+        }\n+        jp.close();\n+\n+        // but then without feature, should pass\n+        jf = new JsonFactory();\n+        jf.disable(JsonFactory.Feature.FAIL_ON_SYMBOL_HASH_OVERFLOW);\n         while (jp.nextToken() != null) {\n             ;\n         }\n-        // and if we got here, fine\n         jp.close();\n     }\n ", "timestamp": 1400917189, "metainfo": ""}