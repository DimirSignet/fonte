{"sha": "3532520e176babbe54141d8d826ff82fd46de823", "log": "more work with hash collision handling", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java\n                     }\n                     break;\n                 }\n-                hash = (hash * 31) + ch;\n+                hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n                 ++ptr;\n             } while (ptr < inputLen);\n         }\n                     }\n                 }\n             }\n-            hash = (hash * 31) + i;\n+            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i;\n             // Ok, let's add char to output:\n             outBuf[outPtr++] = c;\n \n                     _inputPtr = ptr;\n                     return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                 }\n-                hash = (hash * 31) + ch;\n+                hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n                 ++ptr;\n             } while (ptr < inputLen);\n         }\n                 if (ch < maxCode && codes[ch] != 0) {\n                     break;\n                 }\n-                hash = (hash * 31) + ch;\n+                hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n                 ++ptr;\n             } while (ptr < inputLen);\n         }\n                 break;\n             }\n             ++_inputPtr;\n-            hash = (hash * 31) + i;\n+            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i;\n             // Ok, let's add char to output:\n             outBuf[outPtr++] = c;\n \n--- a/src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java\n+++ b/src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java\n     /**********************************************************\n      */\n \n-    final BytesToNameCanonicalizer _parent;\n-\n+    final protected BytesToNameCanonicalizer _parent;\n+\n+    /**\n+     * Seed value we use as the base to make hash codes non-static between\n+     * different runs, but still stable for lifetime of a single symbol table\n+     * instance.\n+     * This is done for security reasons, to avoid potential DoS attack via\n+     * hash collisions.\n+     * \n+     * @since 2.1\n+     */\n+    final private int _hashSeed;\n+    \n     /*\n     /**********************************************************\n     /* Main table state\n     /**********************************************************\n      */\n \n+    /**\n+     * Factory method to call to create a symbol table instance with a\n+     * randomized seed value.\n+     */\n     public static BytesToNameCanonicalizer createRoot()\n     {\n-        return new BytesToNameCanonicalizer(DEFAULT_TABLE_SIZE, true);\n-    }\n-\n+        /* [Issue-21]: Need to use a variable seed, to thwart hash-collision\n+         * based attacks.\n+         */\n+        long now = System.currentTimeMillis();\n+        // ensure it's not 0; and might as well require to be odd so:\n+        int seed = (((int) now) + ((int) now >>> 32)) | 1;\n+        return createRoot(seed);\n+    }\n+\n+    /**\n+     * Factory method that should only be called from unit tests, where seed\n+     * value should remain the same.\n+     */\n+    protected static BytesToNameCanonicalizer createRoot(int hashSeed) {\n+        return new BytesToNameCanonicalizer(DEFAULT_TABLE_SIZE, true, hashSeed);\n+    }\n+    \n     /**\n      * @param intern Whether canonical symbol Strings should be interned\n      *   or not\n     public synchronized BytesToNameCanonicalizer makeChild(boolean canonicalize,\n         boolean intern)\n     {\n-        return new BytesToNameCanonicalizer(this, intern);\n+        return new BytesToNameCanonicalizer(this, intern, _hashSeed);\n     }\n \n     /**\n         }\n     }\n \n-    private BytesToNameCanonicalizer(int hashSize, boolean intern)\n+    private BytesToNameCanonicalizer(int hashSize, boolean intern, int seed)\n     {\n         _parent = null;\n+        _hashSeed = seed;\n         _intern = intern;\n-        /* Sanity check: let's now allow hash sizes below certain\n-         * min. value\n-         */\n+        // Sanity check: let's now allow hash sizes below certain minimum value\n         if (hashSize < MIN_HASH_SIZE) {\n             hashSize = MIN_HASH_SIZE;\n         } else {\n     /**\n      * Constructor used when creating a child instance\n      */\n-    private BytesToNameCanonicalizer(BytesToNameCanonicalizer parent, boolean intern)\n+    private BytesToNameCanonicalizer(BytesToNameCanonicalizer parent, boolean intern,\n+            int seed)\n     {\n         _parent = parent;\n+        _hashSeed = seed;\n         _intern = intern;\n \n         // First, let's copy the state as is:\n      * may have gotten additional entries. Used for checking to see\n      * if a child table should be merged into shared table.\n      */\n-    public boolean maybeDirty()\n-    {\n+    public boolean maybeDirty() {\n         return !_mainHashShared;\n     }\n \n+    /**\n+     * @since 2.1\n+     */\n+    public int hashSeed() { return _hashSeed; }\n+    \n     /**\n      * Method mostly needed by unit tests; calculates number of\n      * entries that are in collision list. Value can be at most\n      */\n     public Name findName(int[] quads, int qlen)\n     {\n-        /* // Not needed, never gets called\n         if (qlen < 3) { // another sanity check\n             return findName(quads[0], (qlen < 2) ? 0 : quads[1]);\n         }\n-        */\n         int hash = calcHash(quads, qlen);\n         // (for rest of comments regarding logic, see method above)\n         int ix = (hash & _mainHashMask);\n         if (_intern) {\n             symbolStr = InternCache.instance.intern(symbolStr);\n         }\n-        int hash = calcHash(quads, qlen);\n+        int hash;\n+        if (qlen < 3) {\n+            hash = (qlen == 1) ? calcHash(quads[0]) : calcHash(quads[0], quads[1]);\n+        } else {\n+            hash = calcHash(quads, qlen);\n+        }\n         Name symbol = constructName(hash, symbolStr, quads, qlen);\n         _addSymbol(hash, symbol);\n         return symbol;\n     /**********************************************************\n      */\n \n-    \n-    // JDK uses 33; other fine choices are 31 and 65599\n+    /* Note on hash calculation: we try to make it more difficult to\n+     * generate collisions automatically; part of this is to avoid\n+     * simple \"multiply-add\" algorithm (like JDK String.hashCode()),\n+     * and add bit of shifting. And other part is to make this\n+     * non-linear, at least for shorter symbols.\n+     */\n+    \n+    // JDK uses 31; other fine choices are 33 and 65599, let's use 33\n+    // as it seems to give fewest collisions for us\n     // (see [http://www.cse.yorku.ca/~oz/hash.html] for details)\n     private final static int MULT = 33;\n     \n-    public final static int calcHash(int firstQuad)\n-    {\n+    public final int calcHash(int firstQuad)\n+    {\n+        int hash = firstQuad ^ _hashSeed;\n+        hash += (hash >>> 15); // to xor hi- and low- 16-bits\n+        hash ^= (hash >>> 9); // as well as lowest 2 bytes\n+        return hash;\n+    }\n+\n+    public final int calcHash(int firstQuad, int secondQuad)\n+    {\n+        /* For two quads, let's change algorithm a bit, to spice\n+         * things up (can do bit more processing anyway)\n+         */\n+        \n         int hash = firstQuad;\n-        hash ^= (hash >>> 16); // to xor hi- and low- 16-bits\n-        hash ^= (hash >>> 8); // as well as lowest 2 bytes\n+        hash += (hash >>> 15); // try mixing first and second byte pairs first\n+        hash ^= ((secondQuad + _hashSeed) * MULT); // then add second quad\n+        hash += (hash >>> 9); // and shuffle some more\n         return hash;\n     }\n \n-    public final static int calcHash(int firstQuad, int secondQuad)\n-    {\n-        int hash = (firstQuad * MULT) + secondQuad;\n-\n-        // If this was called for single-quad instance:\n-        //int hash = (secondQuad == 0) ? firstQuad : ((firstQuad * MULT) + secondQuad);\n-\n-        hash ^= (hash >>> 16); // to xor hi- and low- 16-bits\n-        hash ^= (hash >>> 8); // as well as lowest 2 bytes\n-        return hash;\n-    }\n-\n-    public final static int calcHash(int[] quads, int qlen)\n-    {\n-        // Note: may be called for qlen < 3\n+    public final int calcHash(int[] quads, int qlen)\n+    {\n+        // Note: may be called for qlen < 3; but has at least one int\n+        if (qlen < 3) {\n+            throw new IllegalArgumentException();\n+        }\n+\n+        /* And then change handling again for \"multi-quad\" case; mostly\n+         * to make calculation of collisions less fun. For example,\n+         * add seed bit later in the game, and switch plus/xor around,\n+         * use different shift lengths.\n+         */\n         int hash = quads[0];\n-        for (int i = 1; i < qlen; ++i) {\n-            hash = (hash * MULT) + quads[i];\n-        }\n-\n-        hash ^= (hash >>> 16); // to xor hi- and low- 16-bits\n-        hash ^= (hash >>> 8); // as well as lowest 2 bytes\n+        hash ^= (hash >>> 9);\n+        hash += ((quads[1] + _hashSeed) * MULT);\n+        hash ^= (hash >>> 15);\n+        hash ^= (quads[2] * MULT);\n+        hash += (hash >>> 17);\n+        \n+        for (int i = 3; i < qlen; ++i) {\n+            hash = (hash * MULT) + (quads[i] + 1);\n+            // for longer entries, mess a bit in-between too\n+            hash ^= (hash >>> 3);\n+        }\n+\n+        // and finally shuffle some more once done\n+        hash += (hash >>> 15); // to get high-order bits to mix more\n+        hash ^= (hash >>> 9); // as well as lowest 2 bytes\n         return hash;\n     }\n \n--- a/src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java\n+++ b/src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java\n  */\n public final class CharsToNameCanonicalizer\n {\n+    /* If we use \"multiply-add\" based hash algorithm, this is the multiplier\n+     * we use.\n+     */\n+    public final static int HASH_MULT = 33;\n+    \n     /**\n      * Default initial table size. Shouldn't be miniscule (as there's\n      * cost to both array realloc and rehashing), but let's keep\n      * \n      * @since 2.1\n      */\n-    final protected int _hashSeed;\n+    final private int _hashSeed;\n     \n     /**\n      * Whether canonical symbol Strings are to be intern()ed before added\n          * based attacks.\n          */\n         long now = System.currentTimeMillis();\n-        int seed = ((int) now) + ((int) now >>> 32);\n+        // ensure it's not 0; and might as well require to be odd so:\n+        int seed = (((int) now) + ((int) now >>> 32)) | 1;\n         return createRoot(seed);\n     }\n     \n     /**********************************************************\n      */\n \n-    public String findSymbol(char[] buffer, int start, int len, int hash)\n+    public String findSymbol(char[] buffer, int start, int len, int h)\n     {\n         if (len < 1) { // empty Strings are simplest to handle up front\n             return \"\";\n             return new String(buffer, start, len);\n         }\n \n-        hash &= _indexMask;\n-\n-        String sym = _symbols[hash];\n+        /* Related to problems with sub-standard hashing (somewhat\n+         * relevant for collision attacks too), let's try little\n+         * bit of shuffling to improve hash codes.\n+         * (note, however, that this can't help with full collisions)\n+         */\n+        int index = _hashToIndex(h);\n+        String sym = _symbols[index];\n \n         // Optimal case; checking existing primary symbol for hash index:\n         if (sym != null) {\n                 }\n             }\n             // How about collision bucket?\n-            Bucket b = _buckets[hash >> 1];\n+            Bucket b = _buckets[index >> 1];\n             if (b != null) {\n                 sym = b.find(buffer, start, len);\n                 if (sym != null) {\n             _dirty = true;\n         } else if (_size >= _sizeThreshold) { // Need to expand?\n            rehash();\n-            /* Need to recalc hash; rare occurence (index mask has been\n-             * recalculated as part of rehash)\n-             */\n-            hash = calcHash(buffer, start, len) & _indexMask;\n+           /* Need to recalc hash; rare occurence (index mask has been\n+            * recalculated as part of rehash)\n+            */\n+           index = _hashToIndex(calcHash(buffer, start, len));\n         }\n \n         String newSymbol = new String(buffer, start, len);\n         }\n         ++_size;\n         // Ok; do we need to add primary entry, or a bucket?\n-        if (_symbols[hash] == null) {\n-            _symbols[hash] = newSymbol;\n+        if (_symbols[index] == null) {\n+            _symbols[index] = newSymbol;\n         } else {\n-            int bix = (hash >> 1);\n+            int bix = (index >> 1);\n             Bucket newB = new Bucket(newSymbol, _buckets[bix]);\n             _buckets[bix] = newB;\n             _longestCollisionList = Math.max(newB.length(), _longestCollisionList);\n         return newSymbol;\n     }\n \n+    /**\n+     * Helper method that takes in a \"raw\" hash value, shuffles it as necessary,\n+     * and truncates to be used as the index.\n+     */\n+    public final int _hashToIndex(int rawHash)\n+    {\n+        rawHash += (rawHash >>> 15); // this seems to help quite a bit, at least for our tests\n+        return (rawHash & _indexMask);\n+    }\n+    \n     /**\n      * Implementation of a hashing method for variable length\n      * Strings. Most of the time intention is that this calculation\n      * @param len Length of String; has to be at least 1 (caller guarantees\n      *   this pre-condition)\n      */\n-    public int calcHash(char[] buffer, int start, int len) {\n+    public int calcHash(char[] buffer, int start, int len)\n+    {\n         int hash = _hashSeed;\n         for (int i = 0; i < len; ++i) {\n-            hash = (hash * 31) + (int) buffer[i];\n-        }\n-        return hash;\n-    }\n-\n-    public int calcHash(String key) {\n+            hash = (hash * HASH_MULT) + (int) buffer[i];\n+        }\n+        // NOTE: shuffling, if any, is done in 'findSymbol()', not here:\n+        return (hash == 0) ? 1 : hash;\n+    }\n+\n+    public int calcHash(String key)\n+    {\n+        final int len = key.length();\n+        \n         int hash = _hashSeed;\n-        for (int i = 0, len = key.length(); i < len; ++i) {\n-            hash = (hash * 31) + (int) key.charAt(i);\n-        }\n-        return hash;\n+        for (int i = 0; i < len; ++i) {\n+            hash = (hash * HASH_MULT) + (int) key.charAt(i);\n+        }\n+        // NOTE: shuffling, if any, is done in 'findSymbol()', not here:\n+        return (hash == 0) ? 1 : hash;\n     }\n \n     /*\n             String symbol = oldSyms[i];\n             if (symbol != null) {\n                 ++count;\n-                int index = calcHash(symbol) & _indexMask;\n+                int index = _hashToIndex(calcHash(symbol));\n                 if (_symbols[index] == null) {\n                     _symbols[index] = symbol;\n                 } else {\n             while (b != null) {\n                 ++count;\n                 String symbol = b.getSymbol();\n-                int index = calcHash(symbol) & _indexMask;\n+                int index = _hashToIndex(calcHash(symbol));\n                 if (_symbols[index] == null) {\n                     _symbols[index] = symbol;\n                 } else {\n--- a/src/main/java/com/fasterxml/jackson/core/util/InternCache.java\n+++ b/src/main/java/com/fasterxml/jackson/core/util/InternCache.java\n {\n     /**\n      * Size to use is somewhat arbitrary, so let's choose something that's\n-     * neither too small (low hit ratio) nor too large (waste of memory)\n+     * neither too small (low hit ratio) nor too large (waste of memory).\n+     *<p>\n+     * 11-Jul-2012, tatu: Also, consider the nasty case of String hashCode()\n+     *    collisions; size needs to be small enough to survive linear list\n+     *    lookup... so let's go down a notch (from 192 to 100)\n      */\n-    private final static int MAX_ENTRIES = 192;\n+    private final static int MAX_ENTRIES = 100;\n \n     public final static InternCache instance = new InternCache();\n \n--- /dev/null\n+++ b/src/test/java/CollGenerator.java\n+import java.util.HashSet;\n+\n+\n+public class CollGenerator\n+{\n+    protected final HashFunc hashFunc;\n+    \n+    public CollGenerator(HashFunc hashFunc)\n+    {\n+        this.hashFunc = hashFunc;\n+    }\n+\n+    public static void main(String[] args)\n+    {\n+//        final int TARGET_HASH_CODE = 0xBEEF; // or (1 << 20)\n+        final int TARGET_HASH_CODE = 0xFFFF; // or (1 << 20)\n+//        final int TARGET_HASH_CODE = (1 << 20);\n+        final int COLLISIONS_TO_GENERATE = 20;\n+        \n+        // first, Java default (seed=0, mult=31)\n+//        new CollGenerator(new MultPlusHashFunc(0, 31))\n+//        new CollGenerator(new MultPlusHashFunc(0x77654321, 31))\n+        new CollGenerator(new MultPlusHashFunc(0, 31))\n+            .generate3(TARGET_HASH_CODE, COLLISIONS_TO_GENERATE, false);\n+\n+        /*\n+        // then alternative, djb2 (see [http://www.cse.yorku.ca/~oz/hash.html]),\n+        // (see=5381, mult=33)\n+        new CollGenerator(new MultPlusHashFunc(5381, 33))\n+            .generate3(1<<20, COLLISIONS_TO_GENERATE, false);\n+        new CollGenerator(new MultXorHashFunc(5381, 33))\n+            .generate3(TARGET_HASH_CODE, COLLISIONS_TO_GENERATE, false);\n+\n+        // one more, \"sdbm\" (from [http://www.cse.yorku.ca/~oz/hash.html] as well)\n+        new CollGenerator(new MultPlusHashFunc(5381, 65599))\n+            .generate3(0xff0000, COLLISIONS_TO_GENERATE, false);\n+        new CollGenerator(new MultXorHashFunc(0, 65599))\n+            .generate3(TARGET_HASH_CODE, COLLISIONS_TO_GENERATE, false);\n+            */\n+    }\n+    \n+    /**\n+     * @param targetHash the hash code of the generated strings\n+     */\n+    public void generate3(int targetHash, int maxEntries,\n+            boolean isStdHash)\n+    {\n+        final char minChar = 0x21; // after space\n+//      final int maxChar = Character.MAX_VALUE;\n+        final int maxChar = 0x7f;\n+      \n+        System.out.println(\"// target hash=0x\"+Integer.toHexString(targetHash)+\", with-> \"+hashFunc);\n+        System.out.println(\"final static String[] COLLISIONS = {\");\n+\n+        final HashFunc modHashFunc = hashFunc.withSeed(hashFunc.getSeed() + 0x7FFF);\n+        \n+        int count = 0;\n+\n+        StringBuilder sb = new StringBuilder();\n+        \n+        // first try simple analytic solutions...\n+        final HashSet<String> found = new HashSet<String>();\n+        \n+        main_loop:\n+        for (int c0 = minChar; c0 <= maxChar; ++c0) {\n+            for (int c1 = minChar; c1 <= maxChar; ++c1) {\n+                // first, see if there's an \"easy solution\"\n+                int c2 = hashFunc.findLastChar(c0, c1, targetHash);\n+//                if (c2 < 0 || c2 > 0xFFFF) {\n+                if (c2 < minChar || c2 > maxChar) {\n+                    continue;\n+                }\n+                String key = new String(new char[] { (char) c0, (char) c1, (char) c2 } );\n+\n+                // double-check for fun:\n+                if (isStdHash) {\n+                    if (key.hashCode() != targetHash) {\n+                        throw new RuntimeException(\"Should get STD hash of 0x\"+Integer.toHexString(targetHash)\n+                                +\" for \"+asQuoted(key)+\"; instead got 0x\"+Integer.toHexString(key.hashCode()));\n+                    }\n+                } else {\n+                    int actual = hashFunc.hashCode(key.charAt(0), key.charAt(1), key.charAt(2));\n+                    if (actual != targetHash) {\n+                        throw new RuntimeException(\"Should get hash of 0x\"+Integer.toHexString(targetHash)\n+                                +\" for \"+asQuoted(key)+\"; instead got 0x\"+Integer.toHexString(actual));\n+                    }\n+                }\n+                found.add(key);\n+                sb.append(asQuoted(key));\n+                // also, indicate alternate hash\n+                int altHash = modHashFunc.hashCode(key);\n+                sb.append(\"/*0x\").append(Integer.toHexString(altHash)).append(\"*/\");\n+\n+                if (++count >= maxEntries) {\n+                    break main_loop;\n+                }\n+                \n+                sb.append(\", \");\n+                if (sb.length() > 72) {\n+                    System.out.println(sb.toString());\n+                    sb.setLength(0);\n+                }\n+            }\n+        }\n+\n+        System.out.println(sb.toString());\n+        \n+        // enough?\n+        if (found.size() < maxEntries) {\n+            System.out.println(\" // not enough easy entries found... have to work harder?\");\n+        }\n+        System.out.println(\"};\");\n+    }\n+\n+    private final static char[] HEX = \"0123456789ABCDEF\".toCharArray();\n+\n+    private String asQuoted(String s) {\n+      StringBuilder result = new StringBuilder().append('\"');\n+      for (int i = 0; i < s.length(); ++i) {\n+          char c = s.charAt(i);\n+          if (c == '\"' || c == '\\\\') {\n+              result.append('\\\\');\n+              result.append(c);\n+          } else if (c < 32 || c > 127) {\n+              result.append('\\\\').append('u');\n+              result.append(HEX[(c >> 12)]);\n+              result.append(HEX[(c >> 8) & 0xF]);\n+              result.append(HEX[(c >> 4) & 0xF]);\n+              result.append(HEX[c & 0xF]);\n+          } else {\n+              result.append(c);\n+          }\n+      }\n+      return result.append('\"').toString();\n+    }\n+\n+    abstract static class HashFunc\n+    {\n+        protected final int seed;\n+\n+        protected HashFunc(int s) {\n+            seed = s;\n+        }\n+\n+        public abstract HashFunc withSeed(int s);\n+        \n+        public int getSeed() { return seed; }\n+        \n+        public final int hashCode(String key) {\n+            return hashCode(key.charAt(0), key.charAt(1), key.charAt(2));\n+        }\n+        \n+        public abstract int hashCode(int c0, int c1, int c2);\n+\n+        public abstract int findLastChar(int c0, int c1, int targetHash);\n+    }\n+\n+    abstract static class MultHashFunc extends HashFunc\n+    {\n+        protected final int multiplier;\n+\n+        protected final int base;\n+        \n+        protected MultHashFunc(int s, int mult)\n+        {\n+            super(s);\n+            multiplier = mult;\n+            base = (s * mult);\n+        }\n+    }\n+    \n+    final static class MultPlusHashFunc extends MultHashFunc\n+    {\n+        protected final boolean multiplySeed;\n+\n+\n+        public MultPlusHashFunc(int s, int mult)\n+        {\n+            this(s, mult, false);\n+        }\n+        \n+        public MultPlusHashFunc(int s, int mult, boolean multSeed)\n+        {\n+            super(s, mult);\n+            multiplySeed = multSeed;\n+        }\n+\n+        @Override\n+        public MultPlusHashFunc withSeed(int newSeed) {\n+            if (newSeed == seed) throw new IllegalArgumentException(\"Should not re-create with same seed\");\n+            return new MultPlusHashFunc(newSeed, multiplier, true);\n+        }\n+        \n+        @Override\n+        public int hashCode(int c0, int c1, int c2)\n+        {\n+            int h1 = multiplySeed ? (base * c0) : (base + c0);\n+            int h2 = (h1 * multiplier) + c1;\n+            return (h2 * multiplier) + c2;\n+        }\n+\n+        @Override\n+        public int findLastChar(int c0, int c1, int targetHash)\n+        {\n+            int afterC1 = ((base + c0) * multiplier) + c1;\n+            int afterC1Mult = afterC1 * multiplier;\n+            \n+            // we know that 'hash = (afterC1 * MULT) + c2',\n+            // so ignoring overflow, easy solution would be\n+            // 'c2 = targetHash - (afterC1 * MULT)'\n+            if (afterC1Mult >= 0) {\n+                return targetHash - afterC1Mult;\n+            }\n+            // otherwise there's overflow; simple enough...\n+            return targetHash - (afterC1 * multiplier);\n+        }\n+        \n+        @Override\n+        public String toString() \n+        {\n+            return \"seed: \"+seed+\", multiplier: \"+multiplier+\" (0x\"\n+                    +Integer.toHexString(multiplier)+\", operation: +)\";\n+        }\n+    }\n+\n+    final static class MultXorHashFunc extends MultHashFunc\n+    {\n+        public MultXorHashFunc(int s, int mult)\n+        {\n+            super(s, mult);\n+        }\n+\n+        @Override\n+        public MultXorHashFunc withSeed(int newSeed) {\n+            if (newSeed == seed) throw new IllegalArgumentException(\"Should not re-create with same seed\");\n+            return new MultXorHashFunc(newSeed, multiplier);\n+        }\n+        \n+        @Override\n+        public int hashCode(int c0, int c1, int c2)\n+        {\n+            int h1 = base + c0;\n+            int h2 = (h1 * multiplier) ^ c1;\n+            return (h2 * multiplier) ^ c2;\n+        }\n+ \n+        @Override\n+        public int findLastChar(int c0, int c1, int targetHash)\n+        {\n+            int afterC1 = ((base + c0) * multiplier) ^ c1;\n+            // we know that 'hash = (afterC1 * MULT) ^ c2',\n+            // so ignoring overflow, easy solution would be\n+            // 'c2 = targetHash ^ (afterC1 * MULT)'\n+            return targetHash ^ (afterC1 * multiplier);\n+        }\n+\n+        @Override\n+        public String toString() \n+        {\n+            return \"seed: \"+seed+\", multiplier: \"+multiplier+\" (0x\"\n+                    +Integer.toHexString(multiplier)+\", operation: ^)\";\n+        }\n+    }\n+}\n+\n--- a/src/test/java/com/fasterxml/jackson/core/sym/TestSymbolTables.java\n+++ b/src/test/java/com/fasterxml/jackson/core/sym/TestSymbolTables.java\n     // 11 3-char snippets that hash to 0xFFFF (with default JDK hashCode() calc),\n     // and which can be combined as\n     // sequences, like, say, 11x11x11 (1331) 9-character thingies\n-    final static String[] CHAR_COLLISION_SNIPPETS = {\n-        \"@~}\", \"@\u007f^\", \"A_}\", \"A`^\", \n+    final static String[] CHAR_COLLISION_SNIPPETS_31 = {\n+        \"@~}\", \"@\\u007f^\", \"A_}\", \"A`^\", \n         \"Aa?\", \"B@}\", \"BA^\", \"BB?\", \n         \"C!}\", \"C\\\"^\", \"C#?\"\n     };\n+\n     final static String[] CHAR_COLLISIONS;\n     static {\n-        final int len = CHAR_COLLISION_SNIPPETS.length;\n+        final String[] SNIPPETS = CHAR_COLLISION_SNIPPETS_31;\n+        \n+        final int len = SNIPPETS.length;\n         CHAR_COLLISIONS = new String[len*len*len];\n         int ix = 0;\n         for (int i1 = 0; i1 < len; ++i1) {\n             for (int i2 = 0; i2 < len; ++i2) {\n                 for (int i3 = 0; i3 < len; ++i3) {\n-                    CHAR_COLLISIONS[ix++] = CHAR_COLLISION_SNIPPETS[i1]\n-                            +CHAR_COLLISION_SNIPPETS[i2] + CHAR_COLLISION_SNIPPETS[i3];\n+                    CHAR_COLLISIONS[ix++] = SNIPPETS[i1]+SNIPPETS[i2] + SNIPPETS[i3];\n                 }\n             }\n         }\n     }\n-    \n+\n+    /*\n     public void testCharBasedCollisions()\n     {\n         CharsToNameCanonicalizer sym = CharsToNameCanonicalizer.createRoot(0);\n             assertEquals(CharsToNameCanonicalizer.MAX_COLL_CHAIN_LENGTH+2, sym.size());\n         }\n     }\n+    */\n \n     // Test for verifying stability of hashCode, wrt collisions, using\n     // synthetic field name generation and character-based input\n     public void testSyntheticWithChars()\n     {\n-        CharsToNameCanonicalizer symbols = CharsToNameCanonicalizer.createRoot(0);\n-        for (int i = 0; i < 5000; ++i) {\n+        // pass seed, to keep results consistent:\n+        CharsToNameCanonicalizer symbols = CharsToNameCanonicalizer.createRoot(1);\n+        final int COUNT = 6000;\n+        for (int i = 0; i < COUNT; ++i) {\n             String id = fieldNameFor(i);\n             char[] ch = id.toCharArray();\n             symbols.findSymbol(ch, 0, ch.length, symbols.calcHash(id));\n         }\n \n         assertEquals(8192, symbols.bucketCount());\n-        assertEquals(5000, symbols.size());\n-        // holy guacamoley... there are way too many:\n-        assertEquals(3053, symbols.collisionCount());\n-        // but spread more evenly than byte-based ones?\n-        assertEquals(29, symbols.maxCollisionLength());\n+        assertEquals(COUNT, symbols.size());\n+        \n+//System.out.printf(\"Char stuff: collisions %d, max-coll %d\\n\", symbols.collisionCount(), symbols.maxCollisionLength());\n+        \n+        // holy guacamoley... there are way too many. 31 gives 3567 (!), 33 gives 2747\n+        // ... at least before shuffling. Shuffling helps quite a lot, so:\n+        assertEquals(1401, symbols.collisionCount());\n+        // esp. with collisions; first got about 30\n+        assertEquals(4, symbols.maxCollisionLength());\n     }\n \n     // Test for verifying stability of hashCode, wrt collisions, using\n     // synthetic field name generation and byte-based input (UTF-8)\n     public void testSyntheticWithBytes() throws IOException\n     {\n-        BytesToNameCanonicalizer symbols = BytesToNameCanonicalizer.createRoot();\n-        for (int i = 0; i < 5000; ++i) {\n+        // pass seed, to keep results consistent:\n+        BytesToNameCanonicalizer symbols = BytesToNameCanonicalizer.createRoot(1);\n+        final int COUNT = 6000;\n+        for (int i = 0; i < COUNT; ++i) {\n             String id = fieldNameFor(i);\n             int[] quads = BytesToNameCanonicalizer.calcQuads(id.getBytes(\"UTF-8\"));\n             symbols.addName(id, quads, quads.length);\n         }\n-        assertEquals(5000, symbols.size());\n+        assertEquals(COUNT, symbols.size());\n         assertEquals(8192, symbols.bucketCount());\n-        \n-        // holy guacamoley... even here we have too many; but surprisingly (?)\n-        // less than with chars\n-        assertEquals(1697, symbols.collisionCount());\n+\n+//System.out.printf(\"Byte stuff: collisions %d, max-coll %d\\n\", symbols.collisionCount(), symbols.maxCollisionLength());\n+    \n+        // Fewer collisions than with chars, but still quite a few\n+        assertEquals(1770, symbols.collisionCount());\n+        // but not super long collision chains:\n         assertEquals(9, symbols.maxCollisionLength());\n     }\n }", "timestamp": 1342236202, "metainfo": ""}