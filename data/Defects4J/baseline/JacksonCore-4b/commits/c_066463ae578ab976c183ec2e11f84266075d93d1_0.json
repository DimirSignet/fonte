{"sha": "066463ae578ab976c183ec2e11f84266075d93d1", "log": "Removing one more unneeded inner class", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/core/JsonToken.java\n+++ b/src/main/java/com/fasterxml/jackson/core/JsonToken.java\n      * they can not block to wait for more data to parse and\n      * must return something.\n      */\n-    NOT_AVAILABLE(null, '?'),\n+    NOT_AVAILABLE(null, JsonTokenId.ID_NOT_AVAILABLE),\n \n     /**\n      * START_OBJECT is returned when encountering '{'\n      * which signals starting of an Object value.\n      */\n-    START_OBJECT(\"{\", '('),\n+    START_OBJECT(\"{\", JsonTokenId.ID_START_OBJECT),\n         \n     /**\n      * END_OBJECT is returned when encountering '}'\n      * which signals ending of an Object value\n      */\n-    END_OBJECT(\"}\", ')'),\n-        \n+    END_OBJECT(\"}\", JsonTokenId.ID_END_OBJECT),\n+\n     /**\n      * START_ARRAY is returned when encountering '['\n      * which signals starting of an Array value\n      */\n-    START_ARRAY(\"[\", '('),\n+    START_ARRAY(\"[\", JsonTokenId.ID_START_ARRAY),\n \n     /**\n      * END_ARRAY is returned when encountering ']'\n      * which signals ending of an Array value\n      */\n-    END_ARRAY(\"]\", ')'),\n+    END_ARRAY(\"]\", JsonTokenId.ID_END_ARRAY),\n         \n     /**\n      * FIELD_NAME is returned when a String token is encountered\n      * as a field name (same lexical value, different function)\n      */\n-    FIELD_NAME(null, '?'),\n-        \n+    FIELD_NAME(null, JsonTokenId.ID_FIELD_NAME),\n+    \n     /**\n      * Placeholder token returned when the input source has a concept\n      * of embedded Object that are not accessible as usual structure\n      * only by readers that expose other kinds of source (like\n      * <code>JsonNode</code>-based JSON trees, Maps, Lists and such).\n      */\n-    VALUE_EMBEDDED_OBJECT(null, 's'),\n+    VALUE_EMBEDDED_OBJECT(null, JsonTokenId.ID_EMBEDDED_OBJECT),\n \n     /**\n      * VALUE_STRING is returned when a String token is encountered\n      * in value context (array element, field value, or root-level\n      * stand-alone value)\n      */\n-    VALUE_STRING(null, 's'),\n+    VALUE_STRING(null, JsonTokenId.ID_STRING),\n \n     /**\n      * VALUE_NUMBER_INT is returned when an integer numeric token is\n      * not have floating point or exponent marker in it (consists\n      * only of an optional sign, followed by one or more digits)\n      */\n-    VALUE_NUMBER_INT(null, 'n'),\n+    VALUE_NUMBER_INT(null, JsonTokenId.ID_NUMBER_INT),\n \n     /**\n      * VALUE_NUMBER_INT is returned when a numeric token other\n      * have floating point or exponent marker in it, in addition\n      * to one or more digits.\n      */\n-    VALUE_NUMBER_FLOAT(null, 'n'),\n-\n+    VALUE_NUMBER_FLOAT(null, JsonTokenId.ID_NUMBER_FLOAT),\n+    \n     /**\n      * VALUE_TRUE is returned when encountering literal \"true\" in\n      * value context\n      */\n-    VALUE_TRUE(\"true\", 'b'),\n+    VALUE_TRUE(\"true\", JsonTokenId.ID_TRUE),\n \n     /**\n      * VALUE_FALSE is returned when encountering literal \"false\" in\n      * value context\n      */\n-    VALUE_FALSE(\"false\", 'b'),\n+    VALUE_FALSE(\"false\", JsonTokenId.ID_FALSE),\n \n     /**\n      * VALUE_NULL is returned when encountering literal \"null\" in\n      * value context\n      */\n-    VALUE_NULL(\"null\", '0'),\n+    VALUE_NULL(\"null\", JsonTokenId.ID_NULL),\n         ;\n-\n+    \n     final String _serialized;\n \n     final char[] _serializedChars;\n \n     final byte[] _serializedBytes;\n \n+    final int _id;\n+    \n     final boolean _isStructStart, _isStructEnd;\n-\n-    final boolean _isNull;\n \n     final boolean _isNumber;\n \n      * @param token representation for this token, if there is a\n      *   single static representation; null otherwise\n      */\n-    JsonToken(String token, char typeChar)\n+    JsonToken(String token, int id)\n     {\n         if (token == null) {\n             _serialized = null;\n                 _serializedBytes[i] = (byte) _serializedChars[i];\n             }\n         }\n-        _isBoolean = (typeChar == 'b');\n-        _isNull = (typeChar == '0');\n-        _isNumber = (typeChar == 'n');\n-        _isScalar = \"bns0\".indexOf(typeChar) >= 0;\n-\n-        _isStructStart = (typeChar == '(');\n-        _isStructEnd = (typeChar == ')');\n-    }\n-\n-    public String asString() { return _serialized; }\n-    public char[] asCharArray() { return _serializedChars; }\n-    public byte[] asByteArray() { return _serializedBytes; }\n-\n-    public boolean isNumeric() {\n+        _id = id;\n+        \n+        _isBoolean = (id == JsonTokenId.ID_FALSE || id == JsonTokenId.ID_TRUE);\n+        _isNumber = (id == JsonTokenId.ID_NUMBER_INT || id == JsonTokenId.ID_NUMBER_FLOAT);\n+\n+        _isStructStart = (id == JsonTokenId.ID_START_OBJECT || id == JsonTokenId.ID_START_ARRAY);\n+        _isStructEnd = (id == JsonTokenId.ID_END_OBJECT || id == JsonTokenId.ID_END_ARRAY);\n+\n+        _isScalar = !_isStructStart && !_isStructEnd\n+                && (id != JsonTokenId.ID_FIELD_NAME)\n+                && (id != JsonTokenId.ID_NOT_AVAILABLE);\n+    }\n+\n+    public final int id() { return _id; }\n+    \n+    public final String asString() { return _serialized; }\n+    public final char[] asCharArray() { return _serializedChars; }\n+    public final byte[] asByteArray() { return _serializedBytes; }\n+\n+    public final boolean isNumeric() {\n         return _isNumber;\n     }\n \n     /**\n+     * Accessor that is functionally equivalent to:\n+     * <code>\n+     *    this == JsonToken.START_OBJECT || this == JsonToken.START_ARRAY\n+     * </code>\n+     * \n      * @since 2.3\n      */\n-    public boolean isStructStart() {\n+    public final boolean isStructStart() {\n         return _isStructStart;\n     }\n \n     /**\n+     * Accessor that is functionally equivalent to:\n+     * <code>\n+     *    this == JsonToken.END_OBJECT || this == JsonToken.END_ARRAY\n+     * </code>\n+     * \n      * @since 2.3\n      */\n-    public boolean isStructEnd() {\n+    public final boolean isStructEnd() {\n         return _isStructEnd;\n     }\n-    \n+\n     /**\n      * Method that can be used to check whether this token represents\n      * a valid non-structured value. This means all tokens other than\n      * Object/Array start/end markers all field names.\n      */\n-    public boolean isScalarValue() {\n+    public final boolean isScalarValue() {\n         return _isScalar;\n     }\n \n-    public boolean isBoolean() {\n+    public final boolean isBoolean() {\n         return _isBoolean;\n     }\n-\n-    public boolean isNull() {\n-        return _isNull;\n-    }\n }\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/core/JsonTokenId.java\n+package com.fasterxml.jackson.core;\n+\n+/**\n+ * Interface defined to contain ids accessible with {@link JsonToken#id()}.\n+ * Needed because it is impossible to define these constants in\n+ * {@link JsonToken} itself, as static constants (oddity of how Enums\n+ * are implemented by JVM).\n+ * \n+ * @since 2.3\n+ */\n+public interface JsonTokenId\n+{\n+    public final static int ID_NOT_AVAILABLE = 0;\n+\n+    public final static int ID_START_OBJECT = 1;\n+    public final static int ID_END_OBJECT = 2;\n+    public final static int ID_START_ARRAY = 3;\n+    public final static int ID_END_ARRAY = 4;\n+\n+    public final static int ID_FIELD_NAME = 5;\n+\n+    public final static int ID_STRING = 6;\n+    public final static int ID_NUMBER_INT = 7;\n+    public final static int ID_NUMBER_FLOAT = 8;\n+    public final static int ID_TRUE = 9;\n+    public final static int ID_FALSE = 10;\n+    public final static int ID_NULL = 11;\n+\n+    public final static int ID_EMBEDDED_OBJECT = 12;\n+}\n--- a/src/main/java/com/fasterxml/jackson/core/SerializableString.java\n+++ b/src/main/java/com/fasterxml/jackson/core/SerializableString.java\n  * Typically implementations store possible serialized version(s) so that\n  * serialization of String can be done more efficiently, especially when\n  * used multiple times.\n+ *<p>\n+ * Note that \"quoted\" in methods means quoting of 'special' characters using\n+ * JSON backlash notation (and not use of actual double quotes).\n  * \n  * @see com.fasterxml.jackson.core.io.SerializedString\n  */\n      */\n     int charLength();\n \n-    \n     /*\n     /**********************************************************\n     /* Accessors for byte sequences\n      */\n     \n     /**\n-     * Returns JSON quoted form of the String, as character array. Result\n-     * can be embedded as-is in textual JSON as property name or JSON String.\n+     * Returns JSON quoted form of the String, as character array.\n+     * Result can be embedded as-is in textual JSON as property name or JSON String.\n      */\n     char[] asQuotedChars();\n \n--- a/src/main/java/com/fasterxml/jackson/core/base/GeneratorBase.java\n+++ b/src/main/java/com/fasterxml/jackson/core/base/GeneratorBase.java\n import com.fasterxml.jackson.core.json.JsonWriteContext;\n import com.fasterxml.jackson.core.util.DefaultPrettyPrinter;\n import com.fasterxml.jackson.core.util.VersionUtil;\n+\n+import static com.fasterxml.jackson.core.JsonTokenId.*;\n \n /**\n  * This base class implements part of API that a JSON generator exposes\n         if (t == null) {\n             _reportError(\"No current event to copy\");\n         }\n-        switch(t) {\n-        case START_OBJECT:\n+        switch (t.id()) {\n+        case ID_NOT_AVAILABLE:\n+            _reportError(\"No current event to copy\");\n+        case ID_START_OBJECT:\n             writeStartObject();\n             break;\n-        case END_OBJECT:\n+        case ID_END_OBJECT:\n             writeEndObject();\n             break;\n-        case START_ARRAY:\n+        case ID_START_ARRAY:\n             writeStartArray();\n             break;\n-        case END_ARRAY:\n+        case ID_END_ARRAY:\n             writeEndArray();\n             break;\n-        case FIELD_NAME:\n+        case ID_FIELD_NAME:\n             writeFieldName(jp.getCurrentName());\n             break;\n-        case VALUE_STRING:\n+        case ID_STRING:\n             if (jp.hasTextCharacters()) {\n                 writeString(jp.getTextCharacters(), jp.getTextOffset(), jp.getTextLength());\n             } else {\n                 writeString(jp.getText());\n             }\n             break;\n-        case VALUE_NUMBER_INT:\n-            {\n-                NumberType n = jp.getNumberType();\n-                if (n == NumberType.INT) {\n-                    writeNumber(jp.getIntValue());\n-                } else if (n == NumberType.BIG_INTEGER) {\n-                    writeNumber(jp.getBigIntegerValue());\n-                } else {\n-                    writeNumber(jp.getLongValue());\n-                }\n-            }\n-            break;\n-        case VALUE_NUMBER_FLOAT:\n-            {\n-                NumberType n = jp.getNumberType();\n-                if (n == NumberType.BIG_DECIMAL) {\n-                    writeNumber(jp.getDecimalValue());\n-                } else if (n == NumberType.FLOAT) {\n-                    writeNumber(jp.getFloatValue());\n-                } else {\n-                    writeNumber(jp.getDoubleValue());\n-                }\n-            }\n-            break;\n-        case VALUE_TRUE:\n+        case ID_NUMBER_INT:\n+        {\n+            NumberType n = jp.getNumberType();\n+            if (n == NumberType.INT) {\n+                writeNumber(jp.getIntValue());\n+            } else if (n == NumberType.BIG_INTEGER) {\n+                writeNumber(jp.getBigIntegerValue());\n+            } else {\n+                writeNumber(jp.getLongValue());\n+            }\n+            break;\n+        }\n+        case ID_NUMBER_FLOAT:\n+        {\n+            NumberType n = jp.getNumberType();\n+            if (n == NumberType.BIG_DECIMAL) {\n+                writeNumber(jp.getDecimalValue());\n+            } else if (n == NumberType.FLOAT) {\n+                writeNumber(jp.getFloatValue());\n+            } else {\n+                writeNumber(jp.getDoubleValue());\n+            }\n+            break;\n+        }\n+        case ID_TRUE:\n             writeBoolean(true);\n             break;\n-        case VALUE_FALSE:\n+        case ID_FALSE:\n             writeBoolean(false);\n             break;\n-        case VALUE_NULL:\n+        case ID_NULL:\n             writeNull();\n             break;\n-        case VALUE_EMBEDDED_OBJECT:\n+        case ID_EMBEDDED_OBJECT:\n             writeObject(jp.getEmbeddedObject());\n             break;\n         default:\n         throws IOException, JsonProcessingException\n     {\n         JsonToken t = jp.getCurrentToken();\n+        if (t == null) {\n+            _reportError(\"No current event to copy\");\n+        }\n         // Let's handle field-name separately first\n-        if (t == JsonToken.FIELD_NAME) {\n+        int id = t.id();\n+        if (id == ID_FIELD_NAME) {\n             writeFieldName(jp.getCurrentName());\n             t = jp.nextToken();\n+            id = t.id();\n             // fall-through to copy the associated value\n         }\n-        if (t == JsonToken.START_OBJECT) {\n+        switch (id) {\n+        case ID_START_OBJECT:\n             writeStartObject();\n             while (jp.nextToken() != JsonToken.END_OBJECT) {\n                 copyCurrentStructure(jp);\n             }\n             writeEndObject();\n-        } else if (t == JsonToken.START_ARRAY) {\n+            break;\n+        case ID_START_ARRAY:\n             writeStartArray();\n             while (jp.nextToken() != JsonToken.END_ARRAY) {\n                 copyCurrentStructure(jp);\n             }\n             writeEndArray();\n-        } else {\n+            break;\n+        default:\n             copyCurrentEvent(jp);\n         }\n     }\n--- a/src/main/java/com/fasterxml/jackson/core/base/ParserBase.java\n+++ b/src/main/java/com/fasterxml/jackson/core/base/ParserBase.java\n /**\n  * Intermediate base class used by all Jackson {@link JsonParser}\n  * implementations. Contains most common things that are independent\n- * of actual underlying input source\n- *\n- * @author Tatu Saloranta\n+ * of actual underlying input source.\n  */\n public abstract class ParserBase\n     extends ParserMinimalBase\n--- a/src/main/java/com/fasterxml/jackson/core/base/ParserMinimalBase.java\n+++ b/src/main/java/com/fasterxml/jackson/core/base/ParserMinimalBase.java\n import com.fasterxml.jackson.core.io.NumberInput;\n import com.fasterxml.jackson.core.util.ByteArrayBuilder;\n import com.fasterxml.jackson.core.util.VersionUtil;\n+\n+import static com.fasterxml.jackson.core.JsonTokenId.*;\n \n /**\n  * Intermediate base class used by all Jackson {@link JsonParser}\n     {\n         JsonToken t = _currToken;\n         if (t != null) {\n-            if (t.isBoolean()) {\n-                return (t == JsonToken.VALUE_TRUE);\n-            }\n-            if (t == JsonToken.VALUE_NUMBER_INT) {\n+            switch (t.id()) {\n+            case ID_STRING:\n+                String str = getText().trim();\n+                if (\"true\".equals(str)) {\n+                    return true;\n+                }\n+                if (\"false\".equals(str)) {\n+                    return false;\n+                }\n+                if (_hasTextualNull(str)) {\n+                    return false;\n+                }\n+                break;\n+            case ID_NUMBER_INT:\n                 return getIntValue() != 0;\n-            }\n-            if (t == JsonToken.VALUE_EMBEDDED_OBJECT) {\n+            case ID_TRUE:\n+                return true;\n+            case ID_FALSE:\n+            case ID_NULL:\n+                return false;\n+            case ID_EMBEDDED_OBJECT:\n                 Object value = this.getEmbeddedObject();\n                 if (value instanceof Boolean) {\n                     return (Boolean) value;\n                 }\n-            } else if (t == JsonToken.VALUE_STRING) {\n-                String str = getText().trim();\n-                if (\"true\".equals(str)) {\n-                    return true;\n-                }\n-                if (\"false\".equals(str)) {\n-                    return false;\n-                }\n-                if (_hasTextualNull(str)) {\n-                    return false;\n-                }\n+                break;\n+            default:\n             }\n         }\n         return defaultValue;\n     {\n         JsonToken t = _currToken;\n         if (t != null) {\n-            if (t.isNumeric()) {\n-                return getIntValue();\n-            }\n-            if (t.isBoolean()) {\n-                return (t == JsonToken.VALUE_TRUE) ? 1 : 0;\n-            }\n-            if (t.isNull()) {\n-                return 0;\n-            }\n-            if (t == JsonToken.VALUE_STRING) {\n+            switch (t.id()) {\n+            case ID_STRING:\n                 String str = getText();\n                 if (_hasTextualNull(str)) {\n                     return 0;\n                 }\n                 return NumberInput.parseAsInt(str, defaultValue);\n-            }\n-            if (t == JsonToken.VALUE_EMBEDDED_OBJECT) {\n+            case ID_NUMBER_INT:\n+            case ID_NUMBER_FLOAT:\n+                return getIntValue();\n+            case ID_TRUE:\n+                return 1;\n+            case ID_FALSE:\n+                return 0;\n+            case ID_NULL:\n+                return 0;\n+            case ID_EMBEDDED_OBJECT:\n                 Object value = this.getEmbeddedObject();\n                 if (value instanceof Number) {\n                     return ((Number) value).intValue();\n     {\n         JsonToken t = _currToken;\n         if (t != null) {\n-            if (t.isNumeric()) {\n-                return getLongValue();\n-            }\n-            if (t.isBoolean()) {\n-                return (t == JsonToken.VALUE_TRUE) ? 1L : 0L;\n-            }\n-            if (t.isNull()) {\n-                return 0L;\n-            }\n-            if (t == JsonToken.VALUE_STRING) {\n+            switch (t.id()) {\n+            case ID_STRING:\n                 String str = getText();\n                 if (_hasTextualNull(str)) {\n-                    return 0;\n+                    return 0L;\n                 }\n                 return NumberInput.parseAsLong(str, defaultValue);\n-            }\n-            if (t == JsonToken.VALUE_EMBEDDED_OBJECT) {\n+            case ID_NUMBER_INT:\n+            case ID_NUMBER_FLOAT:\n+                return getLongValue();\n+            case ID_TRUE:\n+                return 1L;\n+            case ID_FALSE:\n+            case ID_NULL:\n+                return 0L;\n+            case ID_EMBEDDED_OBJECT:\n                 Object value = this.getEmbeddedObject();\n                 if (value instanceof Number) {\n                     return ((Number) value).longValue();\n     {\n         JsonToken t = _currToken;\n         if (t != null) {\n-            if (t.isNumeric()) {\n-                return getDoubleValue();\n-            }\n-            if (t.isBoolean()) {\n-                return (t == JsonToken.VALUE_TRUE) ? 1.0 : 0.0;\n-            }\n-            if (t.isNull()) {\n-                return 0L;\n-            }\n-            if (t == JsonToken.VALUE_STRING) {\n+            switch (t.id()) {\n+            case ID_STRING:\n                 String str = getText();\n                 if (_hasTextualNull(str)) {\n-                    return 0;\n+                    return 0L;\n                 }\n                 return NumberInput.parseAsDouble(str, defaultValue);\n-            }\n-            if (t == JsonToken.VALUE_EMBEDDED_OBJECT) {\n+            case ID_NUMBER_INT:\n+            case ID_NUMBER_FLOAT:\n+                return getDoubleValue();\n+            case ID_TRUE:\n+                return 1.0;\n+            case ID_FALSE:\n+            case ID_NULL:\n+                return 0.0;\n+            case ID_EMBEDDED_OBJECT:\n                 Object value = this.getEmbeddedObject();\n                 if (value instanceof Number) {\n                     return ((Number) value).doubleValue();\n--- a/src/main/java/com/fasterxml/jackson/core/io/SerializedString.java\n+++ b/src/main/java/com/fasterxml/jackson/core/io/SerializedString.java\n      *   enough to omit volatiles here, given how simple lazy initialization is.\n      *   This can be compared to how {@link String#intern} works; lazily and\n      *   without synchronization or use of volatile keyword.\n+     *   \n+     *   Change to remove volatile was a request by implementors of a high-throughput\n+     *   search framework; and they believed this is an important optimization for\n+     *   heaviest, multi-core deployed use cases.\n+     */\n+    /*\n+     * 22-Sep-2013, tatu: FWIW, there have been no reports of problems in this\n+     *   area, or anything pointing to it. So I think we are safe up to JDK7\n      */\n     \n     protected /*volatile*/ byte[] _quotedUTF8Ref;\n--- a/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java\n import com.fasterxml.jackson.core.io.IOContext;\n import com.fasterxml.jackson.core.sym.CharsToNameCanonicalizer;\n import com.fasterxml.jackson.core.util.*;\n+\n+import static com.fasterxml.jackson.core.JsonTokenId.*;\n \n /**\n  * This is a concrete implementation of {@link JsonParser}, which is\n         }\n         return super.getValueAsString(defValue);\n     }\n-    \n-    \n+\n     protected String _getText2(JsonToken t)\n     {\n         if (t == null) {\n             return null;\n         }\n-        switch (t) {\n-        case FIELD_NAME:\n+        switch (t.id()) {\n+        case ID_FIELD_NAME:\n             return _parsingContext.getCurrentName();\n \n-        case VALUE_STRING:\n+        case ID_STRING:\n             // fall through\n-        case VALUE_NUMBER_INT:\n-        case VALUE_NUMBER_FLOAT:\n+        case ID_NUMBER_INT:\n+        case ID_NUMBER_FLOAT:\n             return _textBuffer.contentsAsString();\n         default:\n             return t.asString();\n         throws IOException, JsonParseException\n     {\n         if (_currToken != null) { // null only before/after document\n-            switch (_currToken) {\n-                \n-            case FIELD_NAME:\n+            switch (_currToken.id()) {\n+            case ID_FIELD_NAME:\n                 if (!_nameCopied) {\n                     String name = _parsingContext.getCurrentName();\n                     int nameLen = name.length();\n                 }\n                 return _nameCopyBuffer;\n     \n-            case VALUE_STRING:\n+            case ID_STRING:\n                 if (_tokenIncomplete) {\n                     _tokenIncomplete = false;\n                     _finishString(); // only strings can be incomplete\n                 }\n                 // fall through\n-            case VALUE_NUMBER_INT:\n-            case VALUE_NUMBER_FLOAT:\n+            case ID_NUMBER_INT:\n+            case ID_NUMBER_FLOAT:\n                 return _textBuffer.getTextBuffer();\n                 \n             default:\n         throws IOException, JsonParseException\n     {\n         if (_currToken != null) { // null only before/after document\n-            switch (_currToken) {\n+            switch (_currToken.id()) {\n                 \n-            case FIELD_NAME:\n+            case ID_FIELD_NAME:\n                 return _parsingContext.getCurrentName().length();\n-            case VALUE_STRING:\n+            case ID_STRING:\n                 if (_tokenIncomplete) {\n                     _tokenIncomplete = false;\n                     _finishString(); // only strings can be incomplete\n                 }\n                 // fall through\n-            case VALUE_NUMBER_INT:\n-            case VALUE_NUMBER_FLOAT:\n+            case ID_NUMBER_INT:\n+            case ID_NUMBER_FLOAT:\n                 return _textBuffer.size();\n                 \n             default:\n     {\n         // Most have offset of 0, only some may have other values:\n         if (_currToken != null) {\n-            switch (_currToken) {\n-            case FIELD_NAME:\n+            switch (_currToken.id()) {\n+            case ID_FIELD_NAME:\n                 return 0;\n-            case VALUE_STRING:\n+            case ID_STRING:\n                 if (_tokenIncomplete) {\n                     _tokenIncomplete = false;\n                     _finishString(); // only strings can be incomplete\n                 }\n                 // fall through\n-            case VALUE_NUMBER_INT:\n-            case VALUE_NUMBER_FLOAT:\n+            case ID_NUMBER_INT:\n+            case ID_NUMBER_FLOAT:\n                 return _textBuffer.getTextOffset();\n             default:\n             }\n         return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getLongValue() : defaultValue;\n     }\n \n-    // note: identical to one in Utf8StreamParser\n+    // note: identical to one in UTF8StreamJsonParser\n     @Override\n     public Boolean nextBooleanValue()\n         throws IOException, JsonParseException\n             }\n             return null;\n         }\n-        switch (nextToken()) {\n-        case VALUE_TRUE:\n-            return Boolean.TRUE;\n-        case VALUE_FALSE:\n-            return Boolean.FALSE;\n-        default:\n-        \treturn null;\n-        }\n+        JsonToken t = nextToken();\n+        if (t != null) {\n+            int id = t.id();\n+            if (id == ID_TRUE) return Boolean.TRUE;\n+            if (id == ID_FALSE) return Boolean.FALSE;\n+        }\n+        return null;\n     }\n     \n     @Override", "timestamp": 1379905045, "metainfo": ""}