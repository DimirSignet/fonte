{"sha": "2343927df4929441e817e356fec2a3624a0c5b1c", "log": "trying to clean up code, to trim unneeded code", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/core/JsonGenerator.java\n+++ b/src/main/java/com/fasterxml/jackson/core/JsonGenerator.java\n     /**\n      * Accessor for finding out version of the bundle that provided this generator instance.\n      */\n-//  @Override\n+    @Override\n     public abstract Version version();\n \n     /**\n      * target (output stream, writer), and to flush the target itself\n      * as well.\n      */\n+    @Override\n     public abstract void flush() throws IOException;\n \n     /**\n      * If either of above is true, the target is also closed. Otherwise\n      * (not managing, feature not enabled), target is not closed.\n      */\n-//    @Override\n+    @Override\n     public abstract void close() throws IOException;\n }\n--- a/src/main/java/com/fasterxml/jackson/core/JsonParser.java\n+++ b/src/main/java/com/fasterxml/jackson/core/JsonParser.java\n      * Accessor for getting version of the core package, given a parser instance.\n      * Left for sub-classes to implement.\n      */\n-//  @Override\n+    @Override\n     public abstract Version version();\n     \n     /*\n      * {@link java.io.File} or {@link java.net.URL} and creates\n      * stream or reader it does own them.\n      */\n-//  @Override\n+    @Override\n     public abstract void close() throws IOException;\n \n     /*\n--- a/src/main/java/com/fasterxml/jackson/core/Version.java\n+++ b/src/main/java/com/fasterxml/jackson/core/Version.java\n             ;\n     }\n \n-//  @Override\n+    @Override\n     public int compareTo(Version other)\n     {\n         if (other == this) return 0;\n--- a/src/main/java/com/fasterxml/jackson/core/base/GeneratorBase.java\n+++ b/src/main/java/com/fasterxml/jackson/core/base/GeneratorBase.java\n             writeNull();\n         } else {\n             if (_objectCodec == null) {\n-                throw new IllegalStateException(\"No ObjectCodec defined for the generator, can not serialize JsonNode-based trees\");\n+                throw new IllegalStateException(\"No ObjectCodec defined\");\n             }\n             _objectCodec.writeValue(this, rootNode);\n         }\n             writeObject(jp.getEmbeddedObject());\n             break;\n         default:\n-            _cantHappen();\n+            _throwInternal();\n         }\n     }\n \n         throws JsonGenerationException\n     {\n         throw new JsonGenerationException(msg);\n-    }\n-\n-    protected void _cantHappen()\n-    {\n-        throw new RuntimeException(\"Internal error: should never end up through this code path\");\n     }\n \n     /**\n--- a/src/main/java/com/fasterxml/jackson/core/base/ParserBase.java\n+++ b/src/main/java/com/fasterxml/jackson/core/base/ParserBase.java\n import com.fasterxml.jackson.core.io.IOContext;\n import com.fasterxml.jackson.core.io.NumberInput;\n import com.fasterxml.jackson.core.json.JsonReadContext;\n+import com.fasterxml.jackson.core.json.PackageVersion;\n import com.fasterxml.jackson.core.util.ByteArrayBuilder;\n import com.fasterxml.jackson.core.util.TextBuffer;\n \n         _textBuffer = ctxt.constructTextBuffer();\n         _parsingContext = JsonReadContext.createRootContext();\n     }\n-    \n+\n+    @Override\n+    public Version version() {\n+        return PackageVersion.VERSION;\n+    }\n+\n     /*\n     /**********************************************************\n     /* JsonParser impl\n \n     /*\n     /**********************************************************\n-    /* Public API, access to token information, text\n+    /* Public API, access to token information, text and similar\n     /**********************************************************\n      */\n \n             return _nameCopied;\n         }\n         return false;\n+    }\n+\n+    // No embedded objects with base impl...\n+    @Override\n+    public Object getEmbeddedObject() throws IOException, JsonParseException {\n+        return null;\n     }\n     \n     /*\n--- a/src/main/java/com/fasterxml/jackson/core/format/InputAccessor.java\n+++ b/src/main/java/com/fasterxml/jackson/core/format/InputAccessor.java\n             _bufferedEnd = start+len;\n         }\n         \n-//      @Override\n+        @Override\n         public boolean hasMoreBytes() throws IOException\n         {\n             if (_ptr < _bufferedEnd) { // already got more\n             return true;\n         }\n \n-//      @Override\n+       @Override\n         public byte nextByte() throws IOException\n         {\n             // should we just try loading more automatically?\n             return _buffer[_ptr++];\n         }\n \n-//      @Override\n+        @Override\n         public void reset() {\n             _ptr = _bufferedStart;\n         }\n--- a/src/main/java/com/fasterxml/jackson/core/io/IOContext.java\n+++ b/src/main/java/com/fasterxml/jackson/core/io/IOContext.java\n         _managedResource = managedResource;\n     }\n \n-    public void setEncoding(JsonEncoding enc)\n-    {\n+    public void setEncoding(JsonEncoding enc) {\n         _encoding = enc;\n     }\n \n     public Object getSourceReference() { return _sourceRef; }\n     public JsonEncoding getEncoding() { return _encoding; }\n     public boolean isResourceManaged() { return _managedResource; }\n-    \n+\n     /*\n     /**********************************************************\n     /* Public API, buffer management\n      */\n     public byte[] allocReadIOBuffer()\n     {\n-        if (_readIOBuffer != null) {\n-            throw new IllegalStateException(\"Trying to call allocReadIOBuffer() second time\");\n-        }\n-        _readIOBuffer = _bufferRecycler.allocByteBuffer(BufferRecycler.ByteBufferType.READ_IO_BUFFER);\n-        return _readIOBuffer;\n+        _verifyAlloc(_readIOBuffer);\n+        return (_readIOBuffer = _bufferRecycler.allocByteBuffer(BufferRecycler.ByteBufferType.READ_IO_BUFFER));\n     }\n \n     public byte[] allocWriteEncodingBuffer()\n     {\n-        if (_writeEncodingBuffer != null) {\n-            throw new IllegalStateException(\"Trying to call allocWriteEncodingBuffer() second time\");\n-        }\n-        _writeEncodingBuffer = _bufferRecycler.allocByteBuffer(BufferRecycler.ByteBufferType.WRITE_ENCODING_BUFFER);\n-        return _writeEncodingBuffer;\n+        _verifyAlloc(_writeEncodingBuffer);\n+        return (_writeEncodingBuffer = _bufferRecycler.allocByteBuffer(BufferRecycler.ByteBufferType.WRITE_ENCODING_BUFFER));\n     }\n \n     /**\n      */\n     public byte[] allocBase64Buffer()\n     {\n-        if (_base64Buffer != null) {\n-            throw new IllegalStateException(\"Trying to call allocBase64Buffer() second time\");\n-        }\n-        _base64Buffer = _bufferRecycler.allocByteBuffer(BufferRecycler.ByteBufferType.BASE64_CODEC_BUFFER);\n-        return _base64Buffer;\n+        _verifyAlloc(_base64Buffer);\n+        return (_base64Buffer = _bufferRecycler.allocByteBuffer(BufferRecycler.ByteBufferType.BASE64_CODEC_BUFFER));\n     }\n     \n     public char[] allocTokenBuffer()\n     {\n-        if (_tokenCBuffer != null) {\n-            throw new IllegalStateException(\"Trying to call allocTokenBuffer() second time\");\n-        }\n-        _tokenCBuffer = _bufferRecycler.allocCharBuffer(BufferRecycler.CharBufferType.TOKEN_BUFFER);\n-        return _tokenCBuffer;\n+        _verifyAlloc(_tokenCBuffer);\n+        return (_tokenCBuffer = _bufferRecycler.allocCharBuffer(BufferRecycler.CharBufferType.TOKEN_BUFFER));\n     }\n \n     public char[] allocConcatBuffer()\n     {\n-        if (_concatCBuffer != null) {\n-            throw new IllegalStateException(\"Trying to call allocConcatBuffer() second time\");\n-        }\n-        _concatCBuffer = _bufferRecycler.allocCharBuffer(BufferRecycler.CharBufferType.CONCAT_BUFFER);\n-        return _concatCBuffer;\n+        _verifyAlloc(_concatCBuffer);\n+        return (_concatCBuffer = _bufferRecycler.allocCharBuffer(BufferRecycler.CharBufferType.CONCAT_BUFFER));\n     }\n \n     public char[] allocNameCopyBuffer(int minSize)\n     {\n-        if (_nameCopyBuffer != null) {\n-            throw new IllegalStateException(\"Trying to call allocNameCopyBuffer() second time\");\n-        }\n-        _nameCopyBuffer = _bufferRecycler.allocCharBuffer(BufferRecycler.CharBufferType.NAME_COPY_BUFFER, minSize);\n-        return _nameCopyBuffer;\n+        _verifyAlloc(_nameCopyBuffer);\n+        return (_nameCopyBuffer = _bufferRecycler.allocCharBuffer(BufferRecycler.CharBufferType.NAME_COPY_BUFFER, minSize));\n     }\n \n     /**\n             /* Let's do sanity checks to ensure once-and-only-once release,\n              * as well as avoiding trying to release buffers not owned\n              */\n-            if (buf != _readIOBuffer) {\n-                throw new IllegalArgumentException(\"Trying to release buffer not owned by the context\");\n-            }\n+            _verifyRelease(buf, _readIOBuffer);\n             _readIOBuffer = null;\n             _bufferRecycler.releaseByteBuffer(BufferRecycler.ByteBufferType.READ_IO_BUFFER, buf);\n         }\n             /* Let's do sanity checks to ensure once-and-only-once release,\n              * as well as avoiding trying to release buffers not owned\n              */\n-            if (buf != _writeEncodingBuffer) {\n-                throw new IllegalArgumentException(\"Trying to release buffer not owned by the context\");\n-            }\n+            _verifyRelease(buf, _writeEncodingBuffer);\n             _writeEncodingBuffer = null;\n             _bufferRecycler.releaseByteBuffer(BufferRecycler.ByteBufferType.WRITE_ENCODING_BUFFER, buf);\n         }\n     public void releaseBase64Buffer(byte[] buf)\n     {\n         if (buf != null) { // sanity checks, release once-and-only-once, must be one owned\n-            if (buf != _base64Buffer) {\n-                throw new IllegalArgumentException(\"Trying to release buffer not owned by the context\");\n-            }\n+            _verifyRelease(buf, _base64Buffer);\n             _base64Buffer = null;\n             _bufferRecycler.releaseByteBuffer(BufferRecycler.ByteBufferType.BASE64_CODEC_BUFFER, buf);\n         }\n     public void releaseTokenBuffer(char[] buf)\n     {\n         if (buf != null) {\n-            if (buf != _tokenCBuffer) {\n-                throw new IllegalArgumentException(\"Trying to release buffer not owned by the context\");\n-            }\n+            _verifyRelease(buf, _tokenCBuffer);\n             _tokenCBuffer = null;\n             _bufferRecycler.releaseCharBuffer(BufferRecycler.CharBufferType.TOKEN_BUFFER, buf);\n         }\n     public void releaseConcatBuffer(char[] buf)\n     {\n         if (buf != null) {\n-            if (buf != _concatCBuffer) {\n-                throw new IllegalArgumentException(\"Trying to release buffer not owned by the context\");\n-            }\n+            _verifyRelease(buf, _concatCBuffer);\n             _concatCBuffer = null;\n             _bufferRecycler.releaseCharBuffer(BufferRecycler.CharBufferType.CONCAT_BUFFER, buf);\n         }\n     public void releaseNameCopyBuffer(char[] buf)\n     {\n         if (buf != null) {\n-            if (buf != _nameCopyBuffer) {\n-                throw new IllegalArgumentException(\"Trying to release buffer not owned by the context\");\n-            }\n+            _verifyRelease(buf, _nameCopyBuffer);\n             _nameCopyBuffer = null;\n             _bufferRecycler.releaseCharBuffer(BufferRecycler.CharBufferType.NAME_COPY_BUFFER, buf);\n         }\n     }\n+\n+    /*\n+    /**********************************************************\n+    /* Internal helpers\n+    /**********************************************************\n+     */\n+\n+    private final void _verifyAlloc(Object buffer)\n+    {\n+        if (buffer != null) {\n+            throw new IllegalStateException(\"Trying to call same allocXxx() method second time\");\n+        }\n+    }\n+    \n+    private final void _verifyRelease(Object toRelease, Object src)\n+    {\n+        if (toRelease != src) {\n+            throw new IllegalArgumentException(\"Trying to release buffer not owned by the context\");\n+        }\n+    }\n }\n--- a/src/main/java/com/fasterxml/jackson/core/io/JsonStringEncoder.java\n+++ b/src/main/java/com/fasterxml/jackson/core/io/JsonStringEncoder.java\n                     ch = (0x80 | (ch & 0x3f));\n                 } else { // yes, surrogate pair\n                     if (ch > SURR1_LAST) { // must be from first range\n-                        _throwIllegalSurrogate(ch);\n+                        _illegalSurrogate(ch);\n                     }\n                     // and if so, followed by another from next range\n                     if (inputPtr >= inputEnd) {\n-                        _throwIllegalSurrogate(ch);\n+                        _illegalSurrogate(ch);\n                     }\n                     ch = _convertSurrogate(ch, text.charAt(inputPtr++));\n                     if (ch > 0x10FFFF) { // illegal, as per RFC 4627\n-                        _throwIllegalSurrogate(ch);\n+                        _illegalSurrogate(ch);\n                     }\n                     outputBuffer[outputPtr++] = (byte) (0xf0 | (ch >> 18));\n                     if (outputPtr >= outputBuffer.length) {\n                     outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                 } else { // yes, surrogate pair\n                     if (c > SURR1_LAST) { // must be from first range\n-                        _throwIllegalSurrogate(c);\n+                        _illegalSurrogate(c);\n                     }\n                     // and if so, followed by another from next range\n                     if (inputPtr >= inputEnd) {\n-                        _throwIllegalSurrogate(c);\n+                        _illegalSurrogate(c);\n                     }\n                     c = _convertSurrogate(c, text.charAt(inputPtr++));\n                     if (c > 0x10FFFF) { // illegal, as per RFC 4627\n-                        _throwIllegalSurrogate(c);\n+                        _illegalSurrogate(c);\n                     }\n                     outputBuffer[outputPtr++] = (byte) (0xf0 | (c >> 18));\n                     if (outputPtr >= outputEnd) {\n         }\n         return byteBuilder.getCurrentSegmentLength();\n     }\n-    \n-    /**\n-     * Method called to calculate UTF code point, from a surrogate pair.\n-     */\n-    private int _convertSurrogate(int firstPart, int secondPart)\n+\n+    protected static int _convertSurrogate(int firstPart, int secondPart)\n     {\n         // Ok, then, is the second part valid?\n         if (secondPart < SURR2_FIRST || secondPart > SURR2_LAST) {\n         }\n         return 0x10000 + ((firstPart - SURR1_FIRST) << 10) + (secondPart - SURR2_FIRST);\n     }\n-    \n-    private void _throwIllegalSurrogate(int code)\n-    {\n-        if (code > 0x10FFFF) { // over max?\n-            throw new IllegalArgumentException(\"Illegal character point (0x\"+Integer.toHexString(code)+\") to output; max is 0x10FFFF as per RFC 4627\");\n-        }\n-        if (code >= SURR1_FIRST) {\n-            if (code <= SURR1_LAST) { // Unmatched first part (closing without second part?)\n-                throw new IllegalArgumentException(\"Unmatched first part of surrogate pair (0x\"+Integer.toHexString(code)+\")\");\n-            }\n-            throw new IllegalArgumentException(\"Unmatched second part of surrogate pair (0x\"+Integer.toHexString(code)+\")\");\n-        }\n-        // should we ever get this?\n-        throw new IllegalArgumentException(\"Illegal character point (0x\"+Integer.toHexString(code)+\") to output\");\n+\n+    protected static void _illegalSurrogate(int code) {\n+        throw new IllegalArgumentException(UTF8Writer.illegalSurrogateDesc(code));\n     }\n }\n--- a/src/main/java/com/fasterxml/jackson/core/io/SegmentedStringWriter.java\n+++ b/src/main/java/com/fasterxml/jackson/core/io/SegmentedStringWriter.java\n     @Override\n     public Writer append(CharSequence csq)\n     {\n-\tString str = csq.toString();\n-\t_buffer.append(str, 0, str.length());\n+        String str = csq.toString();\n+        _buffer.append(str, 0, str.length());\n         return this;\n     }\n \n     @Override\n     public Writer append(CharSequence csq, int start, int end)\n     {\n-\tString str = csq.subSequence(start, end).toString();\n-\t_buffer.append(str, 0, str.length());\n+        String str = csq.subSequence(start, end).toString();\n+        _buffer.append(str, 0, str.length());\n         return this;\n     }\n \n--- a/src/main/java/com/fasterxml/jackson/core/io/UTF8Writer.java\n+++ b/src/main/java/com/fasterxml/jackson/core/io/UTF8Writer.java\n \n import java.io.*;\n \n-\n-public final class UTF8Writer\n-    extends Writer\n+public final class UTF8Writer extends Writer\n {\n     final static int SURR1_FIRST = 0xD800;\n     final static int SURR1_LAST = 0xDBFF;\n     final static int SURR2_FIRST = 0xDC00;\n     final static int SURR2_LAST = 0xDFFF;\n \n-    final protected IOContext _context;\n-\n-    OutputStream _out;\n-\n-    byte[] _outBuffer;\n-\n-    final int _outBufferEnd;\n-\n-    int _outPtr;\n+    final private IOContext _context;\n+\n+    private OutputStream _out;\n+\n+    private byte[] _outBuffer;\n+\n+    final private int _outBufferEnd;\n+\n+    private int _outPtr;\n \n     /**\n      * When outputting chars from BMP, surrogate pairs need to be coalesced.\n      * To do this, both pairs must be known first; and since it is possible\n      * pairs may be split, we need temporary storage for the first half\n      */\n-    int _surrogate = 0;\n+    private int _surrogate = 0;\n \n     public UTF8Writer(IOContext ctxt, OutputStream out)\n     {\n             int code = _surrogate;\n             _surrogate = 0;\n             if (code > 0) {\n-                throwIllegal(code);\n+                illegalSurrogate(code);\n             }\n         }\n     }\n                 // Yup, a surrogate:\n                 if (c > SURR1_LAST) { // must be from first range\n                     _outPtr = outPtr;\n-                    throwIllegal(c);\n+                    illegalSurrogate(c);\n                 }\n                 _surrogate = c;\n                 // and if so, followed by another from next range\n                 c = convertSurrogate(cbuf[off++]);\n                 if (c > 0x10FFFF) { // illegal in JSON as well as in XML\n                     _outPtr = outPtr;\n-                    throwIllegal(c);\n+                    illegalSurrogate(c);\n                 }\n                 outBuf[outPtr++] = (byte) (0xf0 | (c >> 18));\n                 outBuf[outPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n         } else if (c >= SURR1_FIRST && c <= SURR2_LAST) {\n             // Illegal to get second part without first:\n             if (c > SURR1_LAST) {\n-                throwIllegal(c);\n+                illegalSurrogate(c);\n             }\n             // First part just needs to be held for now\n             _surrogate = c;\n                 _outBuffer[ptr++] = (byte) (0x80 | (c & 0x3f));\n             } else { // 4 bytes\n                 if (c > 0x10FFFF) { // illegal\n-                    throwIllegal(c);\n+                    illegalSurrogate(c);\n                 }\n                 _outBuffer[ptr++] = (byte) (0xf0 | (c >> 18));\n                 _outBuffer[ptr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n                 // Yup, a surrogate:\n                 if (c > SURR1_LAST) { // must be from first range\n                     _outPtr = outPtr;\n-                    throwIllegal(c);\n+                    illegalSurrogate(c);\n                 }\n                 _surrogate = c;\n                 // and if so, followed by another from next range\n                 c = convertSurrogate(str.charAt(off++));\n                 if (c > 0x10FFFF) { // illegal, as per RFC 4627\n                     _outPtr = outPtr;\n-                    throwIllegal(c);\n+                    illegalSurrogate(c);\n                 }\n                 outBuf[outPtr++] = (byte) (0xf0 | (c >> 18));\n                 outBuf[outPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n     /**\n      * Method called to calculate UTF codepoint, from a surrogate pair.\n      */\n-    private int convertSurrogate(int secondPart)\n+    protected int convertSurrogate(int secondPart)\n         throws IOException\n     {\n         int firstPart = _surrogate;\n         }\n         return 0x10000 + ((firstPart - SURR1_FIRST) << 10) + (secondPart - SURR2_FIRST);\n     }\n-\n-    private void throwIllegal(int code)\n-        throws IOException\n+    \n+    protected static void illegalSurrogate(int code) throws IOException {\n+        throw new IOException(illegalSurrogateDesc(code));\n+    }\n+    \n+    protected static String illegalSurrogateDesc(int code)\n     {\n         if (code > 0x10FFFF) { // over max?\n-            throw new IOException(\"Illegal character point (0x\"+Integer.toHexString(code)+\") to output; max is 0x10FFFF as per RFC 4627\");\n+            return \"Illegal character point (0x\"+Integer.toHexString(code)+\") to output; max is 0x10FFFF as per RFC 4627\";\n         }\n         if (code >= SURR1_FIRST) {\n             if (code <= SURR1_LAST) { // Unmatched first part (closing without second part?)\n-                throw new IOException(\"Unmatched first part of surrogate pair (0x\"+Integer.toHexString(code)+\")\");\n-            }\n-            throw new IOException(\"Unmatched second part of surrogate pair (0x\"+Integer.toHexString(code)+\")\");\n-        }\n-\n+                return \"Unmatched first part of surrogate pair (0x\"+Integer.toHexString(code)+\")\";\n+            }\n+            return \"Unmatched second part of surrogate pair (0x\"+Integer.toHexString(code)+\")\";\n+        }\n         // should we ever get this?\n-        throw new IOException(\"Illegal character point (0x\"+Integer.toHexString(code)+\") to output\");\n+        return \"Illegal character point (0x\"+Integer.toHexString(code)+\") to output\";\n     }\n }\n--- a/src/main/java/com/fasterxml/jackson/core/json/ByteSourceJsonBootstrapper.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/ByteSourceJsonBootstrapper.java\n         return true;\n     }\n }\n-\n--- a/src/main/java/com/fasterxml/jackson/core/json/JsonGeneratorImpl.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/JsonGeneratorImpl.java\n         writeFieldName(fieldName);\n         writeString(value);\n     }\n-    \n }\n--- a/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java\n         _symbols = st;\n         _hashSeed = st.hashSeed();\n     }\n-\n-    @Override\n-    public Version version() {\n-        return PackageVersion.VERSION;\n-    }\n     \n     /*\n     /**********************************************************\n     /* Base method defs, overrides\n     /**********************************************************\n      */\n-    \n+\n     @Override\n     public ObjectCodec getCodec() {\n         return _objectCodec;\n     }\n \n     @Override\n-    public Object getEmbeddedObject() throws IOException, JsonParseException {\n-        return null;\n-    }\n-\n-    @Override\n     public byte[] getBinaryValue(Base64Variant b64variant)\n         throws IOException, JsonParseException\n     {\n         }\n     }\n \n-    protected int _readBinary(Base64Variant b64variant, OutputStream out,\n-                              byte[] buffer)\n+    protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer)\n             throws IOException, JsonParseException\n     {\n         int outputPtr = 0;\n      */\n \n     protected void _reportInvalidToken(String matchedPart)\n-\t\t    throws IOException, JsonParseException {\n-    \t_reportInvalidToken(matchedPart, \"'null', 'true', 'false' or NaN\");\n+            throws IOException, JsonParseException {\n+        _reportInvalidToken(matchedPart, \"'null', 'true', 'false' or NaN\");\n     }\n     \n     protected void _reportInvalidToken(String matchedPart, String msg)\n--- a/src/main/java/com/fasterxml/jackson/core/json/UTF8JsonGenerator.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/UTF8JsonGenerator.java\n             }\n             break;\n         default:\n-            _cantHappen();\n+            _throwInternal();\n             break;\n         }\n     }\n--- a/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java\n     @Override\n     public void setCodec(ObjectCodec c) {\n         _objectCodec = c;\n-    }\n-\n-    @Override\n-    public Version version() {\n-        return PackageVersion.VERSION;\n     }\n     \n     /*\n             }\n         }\n         return 0;\n-    }\n-\n-    // No embedded objects with base impl...\n-    @Override\n-    public Object getEmbeddedObject() throws IOException, JsonParseException {\n-        return null;\n     }\n     \n     @Override\n--- a/src/main/java/com/fasterxml/jackson/core/json/WriterBasedJsonGenerator.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/WriterBasedJsonGenerator.java\n             }\n             break;\n         default:\n-            _cantHappen();\n+            _throwInternal();\n             break;\n         }\n     }\n--- a/src/main/java/com/fasterxml/jackson/core/util/JsonGeneratorDelegate.java\n+++ b/src/main/java/com/fasterxml/jackson/core/util/JsonGeneratorDelegate.java\n     public boolean isClosed() {\n         return delegate.isClosed();\n     }\n-    \n }", "timestamp": 1365306258, "metainfo": ""}