{"sha": "44a48d9f82f4ffbea1100f35c8b24a7b5b65d091", "log": "tweak with keyword matching", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java\n         return null;\n     }\n \n-    // 30-Apr-2014, tatu: It would seem that doing it explicitly would be the way to\n-    //    go, but for some reason it can really mess up HotSpot. So...\n-/*    \n+    protected final void _matchToken(String matchStr, int i) throws IOException\n+    {\n+        final int len = matchStr.length();\n+        if ((_inputPtr + len) >= _inputEnd) {\n+            _matchToken2(matchStr, i);\n+            return;\n+        }\n+        do {\n+            if (_inputBuffer[_inputPtr] != matchStr.charAt(i)) {\n+                _reportInvalidToken(matchStr.substring(0, i));\n+            }\n+            ++_inputPtr;\n+        } while (++i < len);\n     \n-    private final  void _matchFalse() throws IOException {\n-        int ptr = _inputPtr;\n-        if ((ptr + 4) < _inputEnd) {\n-            final byte[] b = _inputBuffer;\n-            if (b[ptr] == INT_a && b[++ptr] == INT_l && b[++ptr] == INT_s && b[++ptr] == INT_e) {\n-                int c = b[++ptr] & 0xFF;\n-                if (c < '0' || c == ']' || c == '}') { // expected/allowed chars\n-                    _inputPtr = ptr;\n-                    return;\n-                }\n-            }\n-        }\n-        // buffer boundary, or problem, offline\n-        _matchToken(\"false\", 1);\n-    }\n-\n-    private final void _matchNull() throws IOException {\n-        int ptr = _inputPtr;\n-        if ((ptr + 3) < _inputEnd) {\n-            final byte[] b = _inputBuffer;\n-            if (b[ptr] == INT_u && b[++ptr] == INT_l && b[++ptr] == INT_l) {\n-                int c = b[++ptr] & 0xFF;\n-                if (c < '0' || c == ']' || c == '}') { // expected/allowed chars\n-                    _inputPtr = ptr;\n-                    return;\n-                }\n-            }\n-        }\n-        _matchToken(\"null\", 1);\n-    }\n-\n-    private final void _matchTrue() throws IOException {\n-        int ptr = _inputPtr;\n-        if ((ptr + 3) < _inputEnd) {\n-            final byte[] b = _inputBuffer;\n-            if (b[ptr] == INT_r && b[++ptr] == INT_u && b[++ptr] == INT_e) {\n-                int c = b[++ptr] & 0xFF;\n-                if (c < '0' || c == ']' || c == '}') { // expected/allowed chars\n-                    _inputPtr = ptr;\n-                    return;\n-                }\n-            }\n-        }\n-        _matchToken(\"true\", 1);\n-    }\n-    */\n-\n-    protected void _matchToken(String matchStr, int i) throws IOException\n+        int ch = _inputBuffer[_inputPtr] & 0xFF;\n+        if (ch >= '0' && ch != ']' && ch != '}') { // expected/allowed chars\n+            _checkMatchEnd(matchStr, i, ch);\n+        }\n+    }\n+\n+    private final void _matchToken2(String matchStr, int i) throws IOException\n     {\n         final int len = matchStr.length();\n         do {\n             return;\n         }\n         int ch = _inputBuffer[_inputPtr] & 0xFF;\n-        if (ch < '0' || ch == ']' || ch == '}') { // expected/allowed chars\n-            return;\n-        }\n+        if (ch >= '0' && ch != ']' && ch != '}') { // expected/allowed chars\n+            _checkMatchEnd(matchStr, i, ch);\n+        }\n+    }\n+\n+    private final void _checkMatchEnd(String matchStr, int i, int ch) throws IOException {\n         // but actually only alphanums are problematic\n         char c = (char) _decodeCharForError(ch);\n         if (Character.isJavaIdentifierPart(c)) {\n             _reportInvalidToken(matchStr.substring(0, i));\n         }\n     }\n-\n+    \n     /*\n     /**********************************************************\n     /* Internal methods, ws skipping, escape/unescape", "timestamp": 1398924992, "metainfo": ""}