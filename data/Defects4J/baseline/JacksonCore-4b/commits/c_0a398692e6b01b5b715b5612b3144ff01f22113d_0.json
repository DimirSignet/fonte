{"sha": "0a398692e6b01b5b715b5612b3144ff01f22113d", "log": "Finished #47 implementation", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/core/base/ParserMinimalBase.java\n+++ b/src/main/java/com/fasterxml/jackson/core/base/ParserMinimalBase.java\n  * Note that 'minimal' here mostly refers to minimal number of fields\n  * (size) and functionality that is specific to certain types\n  * of parser implementations; but not necessarily to number of methods.\n- *\n- * @author Tatu Saloranta\n  */\n public abstract class ParserMinimalBase\n     extends JsonParser\n--- a/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java\n public final class ReaderBasedJsonParser\n     extends ParserBase\n {\n+    // Latin1 encoding is not supported, but we do use 8-bit subset for\n+    // pre-processing task, to simplify first pass, keep it fast.\n+    protected final static int[] _icLatin1 = CharTypes.getInputCodeLatin1();\n+\n+    // White-space processing is done all the time, pre-fetch as well\n+    private final static int[] _icWS = CharTypes.getInputCodeWS();\n+\n     /*\n     /**********************************************************\n     /* Input configuration\n         case '7':\n         case '8':\n         case '9':\n-            t = parseNumberText(i);\n+            t = _parseNumber(i);\n             break;\n         default:\n-            t = _handleUnexpectedValue(i);\n+            t = _handleOddValue(i);\n             break;\n         }\n \n     /*\n     /**********************************************************\n     /* Internal methods, number parsing\n-    /* (note: in 1.8 and prior, part of \"ReaderBasedNumericParser\"\n     /**********************************************************\n      */\n \n      * deferred, since it is usually the most complicated and costliest\n      * part of processing.\n      */\n-    protected JsonToken parseNumberText(int ch)\n-        throws IOException, JsonParseException\n+    protected JsonToken _parseNumber(int ch) throws IOException\n     {\n         /* Although we will always be complete with respect to textual\n          * representation (that is, all characters will be parsed),\n         } while (false);\n \n         _inputPtr = negative ? (startPtr+1) : startPtr;\n-        return parseNumberText2(negative);\n+        return _parseNumber2(negative);\n     }\n \n     /**\n      * that it has to explicitly copy contents to the text buffer\n      * instead of just sharing the main input buffer.\n      */\n-    private JsonToken parseNumberText2(boolean negative)\n-        throws IOException, JsonParseException\n+    private JsonToken _parseNumber2(boolean negative) throws IOException\n     {\n         char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n         int outPtr = 0;\n      * Method called when we have seen one zero, and want to ensure\n      * it is not followed by another\n      */\n-    private char _verifyNoLeadingZeroes()\n-        throws IOException, JsonParseException\n+    private char _verifyNoLeadingZeroes() throws IOException\n     {\n         // Ok to have plain \"0\"\n         if (_inputPtr >= _inputEnd && !loadMore()) {\n      * Method called if expected numeric value (due to leading sign) does not\n      * look like a number\n      */\n-    protected JsonToken _handleInvalidNumberStart(int ch, boolean negative)\n-        throws IOException, JsonParseException\n+    protected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException\n     {\n         if (ch == 'I') {\n             if (_inputPtr >= _inputEnd) {\n         final int inputLen = _inputEnd;\n \n         if (ptr < inputLen) {\n-            final int[] codes = CharTypes.getInputCodeLatin1();\n+            final int[] codes = _icLatin1;\n             final int maxCode = codes.length;\n \n             do {\n \n         int start = _inputPtr;\n         _inputPtr = ptr;\n-        return _parseFieldName2(start, hash, INT_QUOTE);\n-    }\n-\n-    private String _parseFieldName2(int startPtr, int hash, int endChar) throws IOException\n+        return _parseName2(start, hash, INT_QUOTE);\n+    }\n+\n+    private String _parseName2(int startPtr, int hash, int endChar) throws IOException\n     {\n         _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n \n         final int inputLen = _inputEnd;\n \n         if (ptr < inputLen) {\n-            final int[] codes = CharTypes.getInputCodeLatin1();\n+            final int[] codes = _icLatin1;\n             final int maxCode = codes.length;\n \n             do {\n         int start = _inputPtr;\n         _inputPtr = ptr;\n \n-        return _parseFieldName2(start, hash, '\\'');\n+        return _parseName2(start, hash, '\\'');\n     }\n \n     /**\n      * Method for handling cases where first non-space character\n      * of an expected value token is not legal for standard JSON content.\n      */\n-    protected JsonToken _handleUnexpectedValue(int i) throws IOException\n+    protected JsonToken _handleOddValue(int i) throws IOException\n     {\n         // Most likely an error, unless we are to allow single-quote-strings\n         switch (i) {\n         final int inputLen = _inputEnd;\n \n         if (ptr < inputLen) {\n-            final int[] codes = CharTypes.getInputCodeLatin1();\n+            final int[] codes = _icLatin1;\n             final int maxCode = codes.length;\n \n             do {\n \n     private int _skipWS() throws IOException\n     {\n+        final int[] codes = _icWS;\n         while (_inputPtr < _inputEnd || loadMore()) {\n             int i = (int) _inputBuffer[_inputPtr++];\n-            if (i > INT_SPACE) {\n-                if (i != INT_SLASH) {\n+            if (i >= 64) {\n+                return i;\n+            }\n+            switch (codes[i]) {\n+            case -1:\n+                _throwInvalidSpace(i);\n+            case 0:\n+                return i;\n+            case 1:\n+                continue;\n+            case '\\n':\n+                ++_currInputRow;\n+                _currInputRowStart = _inputPtr;\n+                break;\n+            case '\\r':\n+                _skipCR();\n+                break;\n+            case '/':\n+                _skipComment();\n+                break;\n+            case '#':\n+                if (!_skipYAMLComment()) {\n                     return i;\n                 }\n+                break;\n+            }\n+        }\n+        throw _constructError(\"Unexpected end-of-input within/between \"+_parsingContext.getTypeDesc()+\" entries\");\n+    }\n+\n+    private int _skipWSOrEnd() throws IOException\n+    {\n+        final int[] codes = _icWS;\n+        while (_inputPtr < _inputEnd || loadMore()) {\n+            int i = (int) _inputBuffer[_inputPtr++];\n+            if (i >= 64) {\n+                return i;\n+            }\n+            switch (codes[i]) {\n+            case -1:\n+                _throwInvalidSpace(i);\n+            case 0:\n+                return i;\n+            case 1:\n+                continue;\n+            case '\\n':\n+                ++_currInputRow;\n+                _currInputRowStart = _inputPtr;\n+                break;\n+            case '\\r':\n+                _skipCR();\n+                break;\n+            case '/':\n                 _skipComment();\n-            } else if (i != INT_SPACE) {\n-                if (i == INT_LF) {\n-                    ++_currInputRow;\n-                    _currInputRowStart = _inputPtr;\n-                } else if (i == INT_CR) {\n-                    _skipCR();\n-                } else if (i != INT_TAB) {\n-                    _throwInvalidSpace(i);\n-                }\n-            }\n-        }\n-        throw _constructError(\"Unexpected end-of-input within/between \"+_parsingContext.getTypeDesc()+\" entries\");\n-    }\n-\n-    private int _skipWSOrEnd() throws IOException\n-    {\n-        while ((_inputPtr < _inputEnd) || loadMore()) {\n-            int i = (int) _inputBuffer[_inputPtr++];\n-            if (i > INT_SPACE) {\n-                 if (i == INT_SLASH) {\n-                     _skipComment();\n-                     continue;\n-                }\n-                 return i;\n-            }\n-            if (i != INT_SPACE) {\n-                if (i == INT_LF) {\n-                    ++_currInputRow;\n-                    _currInputRowStart = _inputPtr;\n-                } else if (i == INT_CR) {\n-                    _skipCR();\n-                } else if (i != INT_TAB) {\n-                    _throwInvalidSpace(i);\n-                }\n+                break;\n+            case '#':\n+                if (!_skipYAMLComment()) {\n+                    return i;\n+                }\n+                break;\n             }\n         }\n         // We ran out of input...\n         }\n         char c = _inputBuffer[_inputPtr++];\n         if (c == '/') {\n-            _skipCppComment();\n+            _skipLine();\n         } else if (c == '*') {\n             _skipCComment();\n         } else {\n         _reportInvalidEOF(\" in a comment\");\n     }\n \n-    private void _skipCppComment() throws IOException\n+    private boolean _skipYAMLComment() throws IOException\n+    {\n+        if (!isEnabled(Feature.ALLOW_YAML_COMMENTS)) {\n+            return false;\n+        }\n+        _skipLine();\n+        return true;\n+    }\n+    \n+    private void _skipLine() throws IOException\n     {\n         // Ok: need to find EOF or linefeed\n         while ((_inputPtr < _inputEnd) || loadMore()) {\n--- a/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java\n {\n     final static byte BYTE_LF = (byte) '\\n';\n \n-    private final static int[] sInputCodesUtf8 = CharTypes.getInputCodeUtf8();\n-\n-    /**\n-     * Latin1 encoding is not supported, but we do use 8-bit subset for\n-     * pre-processing task, to simplify first pass, keep it fast.\n-     */\n-    private final static int[] sInputCodesLatin1 = CharTypes.getInputCodeLatin1();\n+    // This is the main input-code lookup table, fetched eagerly\n+    private final static int[] _icUTF8 = CharTypes.getInputCodeUtf8();\n+\n+    // Latin1 encoding is not supported, but we do use 8-bit subset for\n+    // pre-processing task, to simplify first pass, keep it fast.\n+    protected final static int[] _icLatin1 = CharTypes.getInputCodeLatin1();\n+\n+    // White-space processing is done all the time, pre-fetch as well\n+    private final static int[] _icWS = CharTypes.getInputCodeWS();\n     \n     /*\n     /**********************************************************\n         throws IOException, JsonParseException\n     {\n         if (i != INT_QUOTE) {\n-            return _handleUnusualFieldName(i);\n+            return _handleOddName(i);\n         }\n         // First: can we optimize out bounds checks?\n         if ((_inputPtr + 9) > _inputEnd) { // Need 8 chars, plus one trailing (quote)\n-            return slowParseFieldName();\n+            return slowParseName();\n         }\n \n         // If so, can also unroll loops nicely\n          *   later on), and just handle quotes and backslashes here.\n          */\n         final byte[] input = _inputBuffer;\n-        final int[] codes = sInputCodesLatin1;\n+        final int[] codes = _icLatin1;\n \n         int q = input[_inputPtr++] & 0xFF;\n \n                         i = input[_inputPtr++] & 0xFF;\n                         if (codes[i] == 0) {\n                             _quad1 = q;\n-                            return parseMediumFieldName(i, codes);\n+                            return parseMediumName(i, codes);\n                         }\n                         if (i == INT_QUOTE) { // one byte/char case or broken\n                             return findName(q, 4);\n                         }\n-                        return parseFieldName(q, i, 4);\n+                        return parseName(q, i, 4);\n                     }\n                     if (i == INT_QUOTE) { // one byte/char case or broken\n                         return findName(q, 3);\n                     }\n-                    return parseFieldName(q, i, 3);\n+                    return parseName(q, i, 3);\n                 }                \n                 if (i == INT_QUOTE) { // one byte/char case or broken\n                     return findName(q, 2);\n                 }\n-                return parseFieldName(q, i, 2);\n+                return parseName(q, i, 2);\n             }\n             if (i == INT_QUOTE) { // one byte/char case or broken\n                 return findName(q, 1);\n             }\n-            return parseFieldName(q, i, 1);\n+            return parseName(q, i, 1);\n         }     \n         if (q == INT_QUOTE) { // special case, \"\"\n             return BytesToNameCanonicalizer.getEmptyName();\n         }\n-        return parseFieldName(0, q, 0); // quoting or invalid char\n-    }\n-\n-    protected Name parseMediumFieldName(int q2, final int[] codes)\n+        return parseName(0, q, 0); // quoting or invalid char\n+    }\n+\n+    protected Name parseMediumName(int q2, final int[] codes)\n         throws IOException, JsonParseException\n     {\n         // Ok, got 5 name bytes so far\n             if (i == INT_QUOTE) { // 5 bytes\n                 return findName(_quad1, q2, 1);\n             }\n-            return parseFieldName(_quad1, q2, i, 1); // quoting or invalid char\n+            return parseName(_quad1, q2, i, 1); // quoting or invalid char\n         }\n         q2 = (q2 << 8) | i;\n         i = _inputBuffer[_inputPtr++] & 0xFF;\n             if (i == INT_QUOTE) { // 6 bytes\n                 return findName(_quad1, q2, 2);\n             }\n-            return parseFieldName(_quad1, q2, i, 2);\n+            return parseName(_quad1, q2, i, 2);\n         }\n         q2 = (q2 << 8) | i;\n         i = _inputBuffer[_inputPtr++] & 0xFF;\n             if (i == INT_QUOTE) { // 7 bytes\n                 return findName(_quad1, q2, 3);\n             }\n-            return parseFieldName(_quad1, q2, i, 3);\n+            return parseName(_quad1, q2, i, 3);\n         }\n         q2 = (q2 << 8) | i;\n         i = _inputBuffer[_inputPtr++] & 0xFF;\n             if (i == INT_QUOTE) { // 8 bytes\n                 return findName(_quad1, q2, 4);\n             }\n-            return parseFieldName(_quad1, q2, i, 4);\n+            return parseName(_quad1, q2, i, 4);\n         }\n         _quadBuffer[0] = _quad1;\n         _quadBuffer[1] = q2;\n-        return parseLongFieldName(i);\n-    }\n-\n-    protected Name parseLongFieldName(int q)\n+        return parseLongName(i);\n+    }\n+\n+    protected Name parseLongName(int q)\n         throws IOException, JsonParseException\n     {\n         // As explained above, will ignore UTF-8 encoding at this point\n-        final int[] codes = sInputCodesLatin1;\n+        final int[] codes = _icLatin1;\n         int qlen = 2;\n \n         while (true) {\n              * and may not always be possible)\n              */\n             if ((_inputEnd - _inputPtr) < 4) {\n-                return parseEscapedFieldName(_quadBuffer, qlen, 0, q, 0);\n+                return parseEscapedName(_quadBuffer, qlen, 0, q, 0);\n             }\n             // Otherwise can skip boundary checks for 4 bytes in loop\n \n                 if (i == INT_QUOTE) {\n                     return findName(_quadBuffer, qlen, q, 1);\n                 }\n-                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 1);\n+                return parseEscapedName(_quadBuffer, qlen, q, i, 1);\n             }\n \n             q = (q << 8) | i;\n                 if (i == INT_QUOTE) {\n                     return findName(_quadBuffer, qlen, q, 2);\n                 }\n-                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 2);\n+                return parseEscapedName(_quadBuffer, qlen, q, i, 2);\n             }\n \n             q = (q << 8) | i;\n                 if (i == INT_QUOTE) {\n                     return findName(_quadBuffer, qlen, q, 3);\n                 }\n-                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 3);\n+                return parseEscapedName(_quadBuffer, qlen, q, i, 3);\n             }\n \n             q = (q << 8) | i;\n                 if (i == INT_QUOTE) {\n                     return findName(_quadBuffer, qlen, q, 4);\n                 }\n-                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 4);\n+                return parseEscapedName(_quadBuffer, qlen, q, i, 4);\n             }\n \n             // Nope, no end in sight. Need to grow quad array etc\n      * to come consequtively. Happens rarely, so this is offlined;\n      * plus we'll also do full checks for escaping etc.\n      */\n-    protected Name slowParseFieldName()\n+    protected Name slowParseName()\n         throws IOException, JsonParseException\n     {\n         if (_inputPtr >= _inputEnd) {\n         if (i == INT_QUOTE) { // special case, \"\"\n             return BytesToNameCanonicalizer.getEmptyName();\n         }\n-        return parseEscapedFieldName(_quadBuffer, 0, 0, i, 0);\n-    }\n-\n-    private Name parseFieldName(int q1, int ch, int lastQuadBytes)\n+        return parseEscapedName(_quadBuffer, 0, 0, i, 0);\n+    }\n+\n+    private Name parseName(int q1, int ch, int lastQuadBytes)\n         throws IOException, JsonParseException\n     {\n-        return parseEscapedFieldName(_quadBuffer, 0, q1, ch, lastQuadBytes);\n-    }\n-\n-    private Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes)\n+        return parseEscapedName(_quadBuffer, 0, q1, ch, lastQuadBytes);\n+    }\n+\n+    private Name parseName(int q1, int q2, int ch, int lastQuadBytes)\n         throws IOException, JsonParseException\n     {\n         _quadBuffer[0] = q1;\n-        return parseEscapedFieldName(_quadBuffer, 1, q2, ch, lastQuadBytes);\n+        return parseEscapedName(_quadBuffer, 1, q2, ch, lastQuadBytes);\n     }\n \n     /**\n      * needs to be able to handle more exceptional cases, gets\n      * slower, and hance is offlined to a separate method.\n      */\n-    protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch,\n-                                         int currQuadBytes)\n+    protected Name parseEscapedName(int[] quads, int qlen, int currQuad, int ch,\n+            int currQuadBytes)\n         throws IOException, JsonParseException\n     {\n         /* 25-Nov-2008, tatu: This may seem weird, but here we do\n          *   assume that part is ok (if not it will get caught\n          *   later on), and just handle quotes and backslashes here.\n          */\n-        final int[] codes = sInputCodesLatin1;\n+        final int[] codes = _icLatin1;\n \n         while (true) {\n             if (codes[ch] != 0) {\n      * In standard mode will just throw an expection; but\n      * in non-standard modes may be able to parse name.\n      */\n-    protected Name _handleUnusualFieldName(int ch)\n+    protected Name _handleOddName(int ch)\n         throws IOException, JsonParseException\n     {\n         // [JACKSON-173]: allow single quotes\n         if (ch == '\\'' && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\n-            return _parseApostropheFieldName();\n+            return _parseAposName();\n         }\n         // [JACKSON-69]: allow unquoted names if feature enabled:\n         if (!isEnabled(Feature.ALLOW_UNQUOTED_FIELD_NAMES)) {\n      * for valid JSON -- more alternatives, more code, generally\n      * bit slower execution.\n      */\n-    protected Name _parseApostropheFieldName()\n+    protected Name _parseAposName()\n         throws IOException, JsonParseException\n     {\n         if (_inputPtr >= _inputEnd) {\n \n         // Copied from parseEscapedFieldName, with minor mods:\n \n-        final int[] codes = sInputCodesLatin1;\n+        final int[] codes = _icLatin1;\n \n         while (true) {\n             if (ch == '\\'') {\n         }\n         int outPtr = 0;\n         char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n-        final int[] codes = sInputCodesUtf8;\n+        final int[] codes = _icUTF8;\n \n         final int max = Math.min(_inputEnd, (ptr + outBuf.length));\n         final byte[] inputBuffer = _inputBuffer;\n         int c;\n \n         // Here we do want to do full decoding, hence:\n-        final int[] codes = sInputCodesUtf8;\n+        final int[] codes = _icUTF8;\n         final byte[] inputBuffer = _inputBuffer;\n \n         main_loop:\n         _tokenIncomplete = false;\n \n         // Need to be fully UTF-8 aware here:\n-        final int[] codes = sInputCodesUtf8;\n+        final int[] codes = _icUTF8;\n         final byte[] inputBuffer = _inputBuffer;\n \n         main_loop:\n         char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n \n         // Here we do want to do full decoding, hence:\n-        final int[] codes = sInputCodesUtf8;\n+        final int[] codes = _icUTF8;\n         final byte[] inputBuffer = _inputBuffer;\n \n         main_loop:\n     /* Internal methods, ws skipping, escape/unescape\n     /**********************************************************\n      */\n-\n+    \n     private final int _skipWS() throws IOException\n     {\n-        final int[] codes = CharTypes.getInputCodeWS();\n+        final int[] codes = _icWS;\n         while (_inputPtr < _inputEnd || loadMore()) {\n             final int i = _inputBuffer[_inputPtr++] & 0xFF;\n             switch (codes[i]) {\n                 _skipComment();\n                 break;\n             case '#':\n-                if (!_skipHashComment()) {\n+                if (!_skipYAMLComment()) {\n                     return i;\n                 }\n                 break;\n \n     private int _skipWSOrEnd() throws IOException\n     {\n-        final int[] codes = CharTypes.getInputCodeWS();\n+        final int[] codes = _icWS;\n         while ((_inputPtr < _inputEnd) || loadMore()) {\n             final int i = _inputBuffer[_inputPtr++] & 0xFF;\n             switch (codes[i]) {\n                 _skipComment();\n                 break;\n             case '#':\n-                if (!_skipHashComment()) {\n+                if (!_skipYAMLComment()) {\n                     return i;\n                 }\n                 break;\n         }\n         int c = _inputBuffer[_inputPtr++] & 0xFF;\n         if (c == '/') {\n-            _skipCppComment();\n+            _skipLine();\n         } else if (c == '*') {\n             _skipCComment();\n         } else {\n         _reportInvalidEOF(\" in a comment\");\n     }\n \n-    private void _skipCppComment() throws IOException\n+    private boolean _skipYAMLComment() throws IOException\n+    {\n+        if (!isEnabled(Feature.ALLOW_YAML_COMMENTS)) {\n+            return false;\n+        }\n+        _skipLine();\n+        return true;\n+    }\n+\n+    /**\n+     * Method for skipping contents of an input line; usually for CPP\n+     * and YAML style comments.\n+     */\n+    private void _skipLine() throws IOException\n     {\n         // Ok: need to find EOF or linefeed\n         final int[] codes = CharTypes.getInputCodeComment();\n                     _skipUtf8_4(i);\n                     break;\n                 default: // e.g. -1\n-                    // Is this good enough error message?\n-                    _reportInvalidChar(i);\n-                }\n-            }\n-        }\n-    }\n-\n-    protected boolean _skipHashComment() throws IOException\n-    {\n-        if (!isEnabled(Feature.ALLOW_YAML_COMMENTS)) {\n-            return false;\n-        }\n-        // would plain UTF-8 work?\n-        final int[] codes = CharTypes.getInputCodeComment();\n-        // Skip until line-feed\n-        while ((_inputPtr < _inputEnd) || loadMore()) {\n-            int i = (int) _inputBuffer[_inputPtr++] & 0xFF;\n-            int code = codes[i];\n-            if (code != 0) {\n-                switch (code) {\n-                case '\\n':\n-                    ++_currInputRow;\n-                    _currInputRowStart = _inputPtr;\n-                    return true;\n-                case '\\r':\n-                    _skipCR();\n-                    return true;\n-                case 2: // 2-byte UTF\n-                    _skipUtf8_2(i);\n-                    break;\n-                case 3: // 3-byte UTF\n-                    _skipUtf8_3(i);\n-                    break;\n-                case 4: // 4-byte UTF\n-                    _skipUtf8_4(i);\n-                    break;\n-                default: // e.g. -1\n-                    // Is this good enough error message?\n-                    _reportInvalidChar(i);\n-                }\n-            }\n-        }\n-        return true;\n+                    if (code < 0) {\n+                        // Is this good enough error message?\n+                        _reportInvalidChar(i);\n+                    }\n+                }\n+            }\n+        }\n     }\n     \n     @Override", "timestamp": 1379617931, "metainfo": ""}