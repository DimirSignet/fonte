{"sha": "40a439636007af5692b439220daf734a28923df3", "log": "Fixing [Issue#42]", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/core/io/UTF32Reader.java\n+++ b/src/main/java/com/fasterxml/jackson/core/io/UTF32Reader.java\n  * Since JDK does not come with UTF-32/UCS-4, let's implement a simple\n  * decoder to use.\n  */\n-public final class UTF32Reader\n+public class UTF32Reader\n     extends BaseReader\n {\n-    final boolean mBigEndian;\n+    protected final boolean _bigEndian;\n \n     /**\n      * Although input is fine with full Unicode set, Java still uses\n      * 16-bit chars, so we may have to split high-order chars into\n      * surrogate pairs.\n      */\n-    char mSurrogate = NULL_CHAR;\n+    protected char _surrogate = NULL_CHAR;\n \n     /**\n      * Total read character count; used for error reporting purposes\n      */\n-    int mCharCount = 0;\n+    protected int _charCount = 0;\n \n     /**\n      * Total read byte count; used for error reporting purposes\n      */\n-    int mByteCount = 0;\n-\n+    protected int _byteCount = 0;\n+\n+    protected final boolean _managedBuffers;\n+    \n     /*\n-    ////////////////////////////////////////\n-    // Life-cycle\n-    ////////////////////////////////////////\n-    */\n+    /**********************************************************\n+    /* Life-cycle\n+    /**********************************************************\n+     */\n \n     public UTF32Reader(IOContext ctxt,\n-                       InputStream in, byte[] buf, int ptr, int len,\n-                       boolean isBigEndian)\n+            InputStream in, byte[] buf, int ptr, int len,\n+            boolean isBigEndian)\n     {\n         super(ctxt, in, buf, ptr, len);\n-        mBigEndian = isBigEndian;\n+        _bigEndian = isBigEndian;\n+        _managedBuffers = (in != null);\n     }\n \n     /*\n-    ////////////////////////////////////////\n-    // Public API\n-    ////////////////////////////////////////\n-    */\n+    /**********************************************************\n+    /* Public API\n+    /**********************************************************\n+     */\n \n     @Override\n \tpublic int read(char[] cbuf, int start, int len)\n         int outPtr = start;\n \n         // Ok, first; do we have a surrogate from last round?\n-        if (mSurrogate != NULL_CHAR) {\n-            cbuf[outPtr++] = mSurrogate;\n-            mSurrogate = NULL_CHAR;\n+        if (_surrogate != NULL_CHAR) {\n+            cbuf[outPtr++] = _surrogate;\n+            _surrogate = NULL_CHAR;\n             // No need to load more, already got one char\n         } else {\n             /* Note: we'll try to avoid blocking as much as possible. As a\n             int ptr = _ptr;\n             int ch;\n \n-            if (mBigEndian) {\n+            if (_bigEndian) {\n                 ch = (_buffer[ptr] << 24) | ((_buffer[ptr+1] & 0xFF) << 16)\n                     | ((_buffer[ptr+2] & 0xFF) << 8) | (_buffer[ptr+3] & 0xFF);\n             } else {\n                 ch = (0xDC00 | (ch & 0x03FF));\n                 // Room for second part?\n                 if (outPtr >= len) { // nope\n-                    mSurrogate = (char) ch;\n+                    _surrogate = (char) ch;\n                     break main_loop;\n                 }\n             }\n         }\n \n         len = outPtr - start;\n-        mCharCount += len;\n+        _charCount += len;\n         return len;\n     }\n \n     /*\n-    ////////////////////////////////////////\n-    // Internal methods\n-    ////////////////////////////////////////\n-    */\n+    /**********************************************************\n+    /* Internal methods\n+    /**********************************************************\n+     */\n \n     private void reportUnexpectedEOF(int gotBytes, int needed)\n         throws IOException\n     {\n-        int bytePos = mByteCount + gotBytes;\n-        int charPos = mCharCount;\n+        int bytePos = _byteCount + gotBytes;\n+        int charPos = _charCount;\n \n         throw new CharConversionException(\"Unexpected EOF in the middle of a 4-byte UTF-32 char: got \"\n-                                          +gotBytes+\", needed \"+needed\n-                                          +\", at char #\"+charPos+\", byte #\"+bytePos+\")\");\n+                +gotBytes+\", needed \"+needed+\", at char #\"+charPos+\", byte #\"+bytePos+\")\");\n     }\n \n     private void reportInvalid(int value, int offset, String msg)\n         throws IOException\n     {\n-        int bytePos = mByteCount + _ptr - 1;\n-        int charPos = mCharCount + offset;\n+        int bytePos = _byteCount + _ptr - 1;\n+        int charPos = _charCount + offset;\n \n         throw new CharConversionException(\"Invalid UTF-32 character 0x\"\n-                                          +Integer.toHexString(value)\n-                                          +msg+\" at char #\"+charPos+\", byte #\"+bytePos+\")\");\n+                +Integer.toHexString(value)+msg+\" at char #\"+charPos+\", byte #\"+bytePos+\")\");\n     }\n \n     /**\n     private boolean loadMore(int available)\n         throws IOException\n     {\n-        mByteCount += (_length - available);\n+        _byteCount += (_length - available);\n \n         // Bytes that need to be moved to the beginning of buffer?\n         if (available > 0) {\n              * so let's do a separate read right away:\n              */\n             _ptr = 0;\n-            int count = _in.read(_buffer);\n+            int count = (_in == null) ? -1 : _in.read(_buffer);\n             if (count < 1) {\n                 _length = 0;\n                 if (count < 0) { // -1\n-                    freeBuffers(); // to help GC?\n+                    if (_managedBuffers) {\n+                        freeBuffers(); // to help GC?\n+                    }\n                     return false;\n                 }\n                 // 0 count is no good; let's err out\n          * error.\n          */\n         while (_length < 4) {\n-            int count = _in.read(_buffer, _length, _buffer.length - _length);\n+            int count = (_in == null) ? -1 : _in.read(_buffer, _length, _buffer.length - _length);\n             if (count < 1) {\n                 if (count < 0) { // -1, EOF... no good!\n-                    freeBuffers(); // to help GC?\n+                    if (_managedBuffers) {\n+                        freeBuffers(); // to help GC?\n+                    }\n                     reportUnexpectedEOF(_length, 4);\n                 }\n                 // 0 count is no good; let's err out\n         return true;\n     }\n }\n-\n--- a/src/test/java/com/fasterxml/jackson/core/json/TestJsonParser.java\n+++ b/src/test/java/com/fasterxml/jackson/core/json/TestJsonParser.java\n             // should still know the field name\n             assertEquals(\"doc\", jp.getCurrentName());\n             assertToken(JsonToken.END_OBJECT, jp.nextToken());\n+            assertNull(jp.nextToken());\n             jp.close();\n         }\n     }", "timestamp": 1353029693, "metainfo": ""}