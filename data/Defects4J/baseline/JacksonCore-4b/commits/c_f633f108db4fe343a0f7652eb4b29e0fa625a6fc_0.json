{"sha": "f633f108db4fe343a0f7652eb4b29e0fa625a6fc", "log": "bit of source code sanitization", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/core/io/IOContext.java\n+++ b/src/main/java/com/fasterxml/jackson/core/io/IOContext.java\n     public byte[] allocReadIOBuffer()\n     {\n         _verifyAlloc(_readIOBuffer);\n-        return (_readIOBuffer = _bufferRecycler.allocByteBuffer(BufferRecycler.ByteBufferType.READ_IO_BUFFER));\n+        return (_readIOBuffer = _bufferRecycler.allocByteBuffer(BufferRecycler.BYTE_READ_IO_BUFFER));\n     }\n \n     public byte[] allocWriteEncodingBuffer()\n     {\n         _verifyAlloc(_writeEncodingBuffer);\n-        return (_writeEncodingBuffer = _bufferRecycler.allocByteBuffer(BufferRecycler.ByteBufferType.WRITE_ENCODING_BUFFER));\n+        return (_writeEncodingBuffer = _bufferRecycler.allocByteBuffer(BufferRecycler.BYTE_WRITE_ENCODING_BUFFER));\n     }\n \n     /**\n     public byte[] allocBase64Buffer()\n     {\n         _verifyAlloc(_base64Buffer);\n-        return (_base64Buffer = _bufferRecycler.allocByteBuffer(BufferRecycler.ByteBufferType.BASE64_CODEC_BUFFER));\n+        return (_base64Buffer = _bufferRecycler.allocByteBuffer(BufferRecycler.BYTE_BASE64_CODEC_BUFFER));\n     }\n     \n     public char[] allocTokenBuffer()\n     {\n         _verifyAlloc(_tokenCBuffer);\n-        return (_tokenCBuffer = _bufferRecycler.allocCharBuffer(BufferRecycler.CharBufferType.TOKEN_BUFFER));\n+        return (_tokenCBuffer = _bufferRecycler.allocCharBuffer(BufferRecycler.CHAR_TOKEN_BUFFER));\n     }\n \n     public char[] allocConcatBuffer()\n     {\n         _verifyAlloc(_concatCBuffer);\n-        return (_concatCBuffer = _bufferRecycler.allocCharBuffer(BufferRecycler.CharBufferType.CONCAT_BUFFER));\n+        return (_concatCBuffer = _bufferRecycler.allocCharBuffer(BufferRecycler.CHAR_CONCAT_BUFFER));\n     }\n \n     public char[] allocNameCopyBuffer(int minSize)\n     {\n         _verifyAlloc(_nameCopyBuffer);\n-        return (_nameCopyBuffer = _bufferRecycler.allocCharBuffer(BufferRecycler.CharBufferType.NAME_COPY_BUFFER, minSize));\n+        return (_nameCopyBuffer = _bufferRecycler.allocCharBuffer(BufferRecycler.CHAR_NAME_COPY_BUFFER, minSize));\n     }\n \n     /**\n              */\n             _verifyRelease(buf, _readIOBuffer);\n             _readIOBuffer = null;\n-            _bufferRecycler.releaseByteBuffer(BufferRecycler.ByteBufferType.READ_IO_BUFFER, buf);\n+            _bufferRecycler.releaseByteBuffer(BufferRecycler.BYTE_READ_IO_BUFFER, buf);\n         }\n     }\n \n              */\n             _verifyRelease(buf, _writeEncodingBuffer);\n             _writeEncodingBuffer = null;\n-            _bufferRecycler.releaseByteBuffer(BufferRecycler.ByteBufferType.WRITE_ENCODING_BUFFER, buf);\n+            _bufferRecycler.releaseByteBuffer(BufferRecycler.BYTE_WRITE_ENCODING_BUFFER, buf);\n         }\n     }\n \n         if (buf != null) { // sanity checks, release once-and-only-once, must be one owned\n             _verifyRelease(buf, _base64Buffer);\n             _base64Buffer = null;\n-            _bufferRecycler.releaseByteBuffer(BufferRecycler.ByteBufferType.BASE64_CODEC_BUFFER, buf);\n+            _bufferRecycler.releaseByteBuffer(BufferRecycler.BYTE_BASE64_CODEC_BUFFER, buf);\n         }\n     }\n     \n         if (buf != null) {\n             _verifyRelease(buf, _tokenCBuffer);\n             _tokenCBuffer = null;\n-            _bufferRecycler.releaseCharBuffer(BufferRecycler.CharBufferType.TOKEN_BUFFER, buf);\n+            _bufferRecycler.releaseCharBuffer(BufferRecycler.CHAR_TOKEN_BUFFER, buf);\n         }\n     }\n \n         if (buf != null) {\n             _verifyRelease(buf, _concatCBuffer);\n             _concatCBuffer = null;\n-            _bufferRecycler.releaseCharBuffer(BufferRecycler.CharBufferType.CONCAT_BUFFER, buf);\n+            _bufferRecycler.releaseCharBuffer(BufferRecycler.CHAR_CONCAT_BUFFER, buf);\n         }\n     }\n \n         if (buf != null) {\n             _verifyRelease(buf, _nameCopyBuffer);\n             _nameCopyBuffer = null;\n-            _bufferRecycler.releaseCharBuffer(BufferRecycler.CharBufferType.NAME_COPY_BUFFER, buf);\n+            _bufferRecycler.releaseCharBuffer(BufferRecycler.CHAR_NAME_COPY_BUFFER, buf);\n         }\n     }\n \n--- a/src/main/java/com/fasterxml/jackson/core/util/BufferRecycler.java\n+++ b/src/main/java/com/fasterxml/jackson/core/util/BufferRecycler.java\n  */\n public class BufferRecycler\n {\n-    public final static int DEFAULT_WRITE_CONCAT_BUFFER_LEN = 2000;\n+//    public final static int DEFAULT_WRITE_CONCAT_BUFFER_LEN = 2000;\n+\n+    /**\n+     * Buffer used for reading byte-based input.\n+     */\n+    public final static int BYTE_READ_IO_BUFFER = 0;\n+\n+    /**\n+     * Buffer used for temporarily storing encoded content; used\n+     * for example by UTF-8 encoding writer\n+     */\n+    public final static int BYTE_WRITE_ENCODING_BUFFER = 1;\n+\n+    /**\n+     * Buffer used for temporarily concatenating output; used for\n+     * example when requesting output as byte array.\n+     */\n+    public final static int BYTE_WRITE_CONCAT_BUFFER = 2;\n+\n+    /**\n+     * Buffer used for concatenating binary data that is either being\n+     * encoded as base64 output, or decoded from base64 input.\n+     * \n+     * @since 2.1\n+     */\n+    public final static int BYTE_BASE64_CODEC_BUFFER = 3;\n+\n+    public final static int CHAR_TOKEN_BUFFER = 0;  // Tokenizable input\n+    public final static int CHAR_CONCAT_BUFFER = 1; // concatenated output\n+    public final static int CHAR_TEXT_BUFFER = 2; // Text content from input\n+    public final static int CHAR_NAME_COPY_BUFFER = 3; // Temporary buffer for getting name characters\n+\n+    private final static int[] BYTE_BUFFER_LENGTHS = new int[] { 4000, 4000, 2000, 2000 };\n+    private final static int[] CHAR_BUFFER_LENGTHS = new int[] { 2000, 2000, 200, 200 };\n     \n-    public enum ByteBufferType {\n-        READ_IO_BUFFER(4000)\n-        /**\n-         * Buffer used for temporarily storing encoded content; used\n-         * for example by UTF-8 encoding writer\n-         */\n-        ,WRITE_ENCODING_BUFFER(4000)\n-\n-        /**\n-         * Buffer used for temporarily concatenating output; used for\n-         * example when requesting output as byte array.\n-         */\n-        ,WRITE_CONCAT_BUFFER(2000)\n-        \n-        /**\n-         * Buffer used for concatenating binary data that is either being\n-         * encoded as base64 output, or decoded from base64 input.\n-         * \n-         * @since 2.1\n-         */\n-        ,BASE64_CODEC_BUFFER(2000)\n-        ;\n-            \n-        protected final int size;\n-\n-        ByteBufferType(int size) { this.size = size; }\n-    }\n-\n-    public enum CharBufferType {\n-        TOKEN_BUFFER(2000) // Tokenizable input\n-            ,CONCAT_BUFFER(2000) // concatenated output\n-            ,TEXT_BUFFER(200) // Text content from input\n-            ,NAME_COPY_BUFFER(200) // Temporary buffer for getting name characters\n-            ;\n-        \n-        protected final int size;\n-\n-        CharBufferType(int size) { this.size = size; }\n-    }\n-\n-    final protected byte[][] _byteBuffers = new byte[ByteBufferType.values().length][];\n-    final protected char[][] _charBuffers = new char[CharBufferType.values().length][];\n+    final protected byte[][] _byteBuffers = new byte[4][];\n+    final protected char[][] _charBuffers = new char[4][];\n \n     public BufferRecycler() { }\n \n-    public final byte[] allocByteBuffer(ByteBufferType type)\n+    /**\n+     * @param ix One of <code>READ_IO_BUFFER</code> constants.\n+     */\n+    public final byte[] allocByteBuffer(int ix)\n     {\n-        int ix = type.ordinal();\n         byte[] buffer = _byteBuffers[ix];\n         if (buffer == null) {\n-            buffer = balloc(type.size);\n+            buffer = balloc(BYTE_BUFFER_LENGTHS[ix]);\n         } else {\n             _byteBuffers[ix] = null;\n         }\n         return buffer;\n     }\n \n-    public final void releaseByteBuffer(ByteBufferType type, byte[] buffer)\n-    {\n-        _byteBuffers[type.ordinal()] = buffer;\n+    public final void releaseByteBuffer(int ix, byte[] buffer) {\n+        _byteBuffers[ix] = buffer;\n     }\n \n-    public final char[] allocCharBuffer(CharBufferType type)\n-    {\n-        return allocCharBuffer(type, 0);\n+    public final char[] allocCharBuffer(int ix) {\n+        return allocCharBuffer(ix, 0);\n     }\n \n-    public final char[] allocCharBuffer(CharBufferType type, int minSize)\n+    public final char[] allocCharBuffer(int ix, int minSize)\n     {\n-        if (type.size > minSize) {\n-            minSize = type.size;\n+        final int DEF_SIZE = CHAR_BUFFER_LENGTHS[ix];\n+        if (minSize < DEF_SIZE) {\n+            minSize = DEF_SIZE;\n         }\n-        int ix = type.ordinal();\n         char[] buffer = _charBuffers[ix];\n         if (buffer == null || buffer.length < minSize) {\n             buffer = calloc(minSize);\n         return buffer;\n     }\n \n-    public final void releaseCharBuffer(CharBufferType type, char[] buffer)\n-    {\n-        _charBuffers[type.ordinal()] = buffer;\n+    public final void releaseCharBuffer(int ix, char[] buffer) {\n+        _charBuffers[ix] = buffer;\n     }\n \n     /*\n     /**********************************************************\n      */\n \n-    private byte[] balloc(int size)\n-    {\n-        return new byte[size];\n-    }\n-\n-    private char[] calloc(int size)\n-    {\n-        return new char[size];\n-    }\n+    private byte[] balloc(int size) { return new byte[size]; }\n+    private char[] calloc(int size) { return new char[size]; }\n }\n--- a/src/main/java/com/fasterxml/jackson/core/util/ByteArrayBuilder.java\n+++ b/src/main/java/com/fasterxml/jackson/core/util/ByteArrayBuilder.java\n  * Helper class that is similar to {@link java.io.ByteArrayOutputStream}\n  * in usage, but more geared to Jackson use cases internally.\n  * Specific changes include segment storage (no need to have linear\n- * backing buffer, can avoid reallocs, copying), as well API\n+ * backing buffer, can avoid reallocations, copying), as well API\n  * not based on {@link java.io.OutputStream}. In short, a very much\n  * specialized builder object.\n  *<p>\n- * Since version 1.5, also implements {@link OutputStream} to allow\n+ * Also implements {@link OutputStream} to allow\n  * efficient aggregation of output content as a byte array, similar\n  * to how {@link java.io.ByteArrayOutputStream} works, but somewhat more\n  * efficiently for many use cases.\n  */\n-public final class ByteArrayBuilder\n-    extends OutputStream\n+public final class ByteArrayBuilder extends OutputStream\n {\n     private final static byte[] NO_BYTES = new byte[0];\n     \n-    /**\n-     * Size of the first block we will allocate.\n-     */\n+    // Size of the first block we will allocate.\n     private final static int INITIAL_BLOCK_SIZE = 500;\n     \n-    /**\n-     * Maximum block size we will use for individual non-aggregated\n-     * blocks. Let's limit to using 256k chunks.\n-     */\n+    // Maximum block size we will use for individual non-aggregated\n+    // blocks. Let's limit to using 256k chunks.\n     private final static int MAX_BLOCK_SIZE = (1 << 18);\n     \n     final static int DEFAULT_BLOCK_ARRAY_SIZE = 40;\n \n-    /**\n-     * Optional buffer recycler instance that we can use for allocating\n-     * the first block.\n-     */\n+    // Optional buffer recycler instance that we can use for allocating the first block.\n     private final BufferRecycler _bufferRecycler;\n-    \n     private final LinkedList<byte[]> _pastBlocks = new LinkedList<byte[]>();\n     \n-    /**\n-     * Number of bytes within byte arrays in {@link _pastBlocks}.\n-     */\n+    // Number of bytes within byte arrays in {@link _pastBlocks}.\n     private int _pastLen;\n-\n     private byte[] _currBlock;\n-\n     private int _currBlockPtr;\n     \n     public ByteArrayBuilder() { this(null); }\n-\n     public ByteArrayBuilder(BufferRecycler br) { this(br, INITIAL_BLOCK_SIZE); }\n-\n     public ByteArrayBuilder(int firstBlockSize) { this(null, firstBlockSize); }\n \n-    public ByteArrayBuilder(BufferRecycler br, int firstBlockSize)\n-    {\n+    public ByteArrayBuilder(BufferRecycler br, int firstBlockSize) {\n         _bufferRecycler = br;\n-        if (br == null) {\n-            _currBlock = new byte[firstBlockSize];\n-        } else {\n-            _currBlock = br.allocByteBuffer(BufferRecycler.ByteBufferType.WRITE_CONCAT_BUFFER);\n-        }\n-    }\n-\n-    public void reset()\n-    {\n+        _currBlock = (br == null) ? new byte[firstBlockSize] : br.allocByteBuffer(BufferRecycler.BYTE_WRITE_CONCAT_BUFFER);\n+    }\n+\n+    public void reset() {\n         _pastLen = 0;\n         _currBlockPtr = 0;\n \n     public void release() {\n         reset();\n         if (_bufferRecycler != null && _currBlock != null) {\n-            _bufferRecycler.releaseByteBuffer(BufferRecycler.ByteBufferType.WRITE_CONCAT_BUFFER, _currBlock);\n+            _bufferRecycler.releaseByteBuffer(BufferRecycler.BYTE_WRITE_CONCAT_BUFFER, _currBlock);\n             _currBlock = null;\n         }\n     }\n \n-    public void append(int i)\n-    {\n+    public void append(int i) {\n         if (_currBlockPtr >= _currBlock.length) {\n             _allocMore();\n         }\n         _currBlock[_currBlockPtr++] = (byte) i;\n     }\n \n-    public void appendTwoBytes(int b16)\n-    {\n+    public void appendTwoBytes(int b16) {\n         if ((_currBlockPtr + 1) < _currBlock.length) {\n             _currBlock[_currBlockPtr++] = (byte) (b16 >> 8);\n             _currBlock[_currBlockPtr++] = (byte) b16;\n         }\n     }\n \n-    public void appendThreeBytes(int b24)\n-    {\n+    public void appendThreeBytes(int b24) {\n         if ((_currBlockPtr + 2) < _currBlock.length) {\n             _currBlock[_currBlockPtr++] = (byte) (b24 >> 16);\n             _currBlock[_currBlockPtr++] = (byte) (b24 >> 8);\n      * \n      * @return Coalesced contents\n      */\n-    public byte[] completeAndCoalesce(int lastBlockLength)\n-    {\n+    public byte[] completeAndCoalesce(int lastBlockLength) {\n         _currBlockPtr = lastBlockLength;\n         return toByteArray();\n     }\n \n-    public byte[] getCurrentSegment() {\n-        return _currBlock;\n-    }\n-\n-    public void setCurrentSegmentLength(int len) {\n-        _currBlockPtr = len;\n-    }\n-\n-    public int getCurrentSegmentLength() {\n-        return _currBlockPtr;\n-    }\n+    public byte[] getCurrentSegment() { return _currBlock; }\n+    public void setCurrentSegmentLength(int len) { _currBlockPtr = len; }\n+    public int getCurrentSegmentLength() { return _currBlockPtr; }\n     \n     /*\n     /**********************************************************\n     }\n \n     @Override public void close() { /* NOP */ }\n-\n     @Override public void flush() { /* NOP */ }\n \n     /*\n--- a/src/main/java/com/fasterxml/jackson/core/util/InternCache.java\n+++ b/src/main/java/com/fasterxml/jackson/core/util/InternCache.java\n      * cases where multiple threads might try to concurrently\n      * flush the map.\n      */\n-    private final static Object _flushLock = new Object();\n+    private final Object _flushLock = new Object();\n     \n     private InternCache() {\n         super(MAX_ENTRIES, 0.8f, 4);\n--- a/src/main/java/com/fasterxml/jackson/core/util/JsonGeneratorDelegate.java\n+++ b/src/main/java/com/fasterxml/jackson/core/util/JsonGeneratorDelegate.java\n     /**********************************************************\n      */\n \n-    public JsonGenerator getDelegate() {\n-        return delegate;\n-    }\n+    public JsonGenerator getDelegate() { return delegate; }\n     \n     /*\n     /**********************************************************\n     /**********************************************************\n      */\n     \n-    @Override\n-    public ObjectCodec getCodec() {\n-        return delegate.getCodec();\n-    }\n-\n-    @Override\n-    public JsonGenerator setCodec(ObjectCodec oc) {\n+    @Override public ObjectCodec getCodec() { return delegate.getCodec(); }\n+\n+    @Override public JsonGenerator setCodec(ObjectCodec oc) {\n         delegate.setCodec(oc);\n         return this;\n     }\n     \n-    @Override\n-    public void setSchema(FormatSchema schema) {\n-        delegate.setSchema(schema);\n-    }\n-\n-    @Override\n-    public FormatSchema getSchema() {\n-        return delegate.getSchema();\n-    }\n-\n-    @Override\n-    public Version version() {\n-        return delegate.version();\n-    }\n-\n-    @Override\n-    public Object getOutputTarget() {\n-        return delegate.getOutputTarget();\n-    }\n+    @Override public void setSchema(FormatSchema schema) { delegate.setSchema(schema); }\n+    @Override public FormatSchema getSchema() { return delegate.getSchema(); }\n+    @Override public Version version() { return delegate.version(); }\n+    @Override public Object getOutputTarget() { return delegate.getOutputTarget(); }\n \n     /*\n     /**********************************************************\n      */\n \n     @Override\n-    public boolean canUseSchema(FormatSchema schema) {\n-        return delegate.canUseSchema(schema);\n-    }\n-\n-    @Override\n-    public boolean canWriteTypeId() {\n-        return delegate.canWriteTypeId();\n-    }\n-\n-    @Override\n-    public boolean canWriteObjectId() {\n-        return delegate.canWriteObjectId();\n-    }\n-\n-    @Override\n-    public boolean canWriteBinaryNatively() {\n-        return delegate.canWriteBinaryNatively();\n-    }\n-    \n-    @Override\n-    public boolean canOmitFields() {\n-        return delegate.canOmitFields();\n-    }\n+    public boolean canUseSchema(FormatSchema schema) { return delegate.canUseSchema(schema); }\n+\n+    @Override\n+    public boolean canWriteTypeId() { return delegate.canWriteTypeId(); }\n+\n+    @Override\n+    public boolean canWriteObjectId() { return delegate.canWriteObjectId(); }\n+\n+    @Override\n+    public boolean canWriteBinaryNatively() { return delegate.canWriteBinaryNatively(); }\n+    \n+    @Override\n+    public boolean canOmitFields() { return delegate.canOmitFields(); }\n     \n     /*\n     /**********************************************************\n     }\n \n     @Override\n-    public boolean isEnabled(Feature f) {\n-        return delegate.isEnabled(f);\n-    }\n+    public boolean isEnabled(Feature f) { return delegate.isEnabled(f); }\n \n     // final, can't override (and no need to)\n     //public final JsonGenerator configure(Feature f, boolean state)\n \n     @Override\n-    public int getFeatureMask() {\n-        return delegate.getFeatureMask();\n-    }\n+    public int getFeatureMask() { return delegate.getFeatureMask(); }\n \n     @Override\n     public JsonGenerator setFeatureMask(int mask) {\n     }\n \n     @Override\n-    public int getHighestEscapedChar() {\n-        return delegate.getHighestEscapedChar();\n-    }\n-\n-    @Override\n-    public CharacterEscapes getCharacterEscapes() {\n-        return delegate.getCharacterEscapes();\n-    }\n+    public int getHighestEscapedChar() { return delegate.getHighestEscapedChar(); }\n+\n+    @Override\n+    public CharacterEscapes getCharacterEscapes() {  return delegate.getCharacterEscapes(); }\n \n     @Override\n     public JsonGenerator setCharacterEscapes(CharacterEscapes esc) {\n      */\n \n     @Override\n-    public void writeStartArray() throws IOException, JsonGenerationException {\n-         delegate.writeStartArray();\n-    }\n-\n-\n-    @Override\n-    public void writeEndArray() throws IOException, JsonGenerationException {\n-        delegate.writeEndArray();\n-    }\n-\n-    @Override\n-    public void writeStartObject() throws IOException, JsonGenerationException {\n-        delegate.writeStartObject();\n-    }\n-    \n-    @Override\n-    public void writeEndObject() throws IOException, JsonGenerationException {\n-        delegate.writeEndObject();\n-    }\n-\n-    @Override\n-    public void writeFieldName(String name)\n-        throws IOException, JsonGenerationException\n-    {\n-        delegate.writeFieldName(name);\n-    }\n-\n-    @Override\n-    public void writeFieldName(SerializableString name)\n-        throws IOException, JsonGenerationException\n-    {\n-        delegate.writeFieldName(name);\n-    }\n+    public void writeStartArray() throws IOException, JsonGenerationException { delegate.writeStartArray(); }\n+\n+    @Override\n+    public void writeEndArray() throws IOException, JsonGenerationException { delegate.writeEndArray(); }\n+\n+    @Override\n+    public void writeStartObject() throws IOException, JsonGenerationException { delegate.writeStartObject(); }\n+    \n+    @Override\n+    public void writeEndObject() throws IOException, JsonGenerationException { delegate.writeEndObject(); }\n+\n+    @Override\n+    public void writeFieldName(String name) throws IOException, JsonGenerationException { delegate.writeFieldName(name); }\n+\n+    @Override\n+    public void writeFieldName(SerializableString name) throws IOException, JsonGenerationException { delegate.writeFieldName(name); }\n     \n     /*\n     /**********************************************************\n      */\n \n     @Override\n-    public void writeString(String text) throws IOException,JsonGenerationException {\n-        delegate.writeString(text);\n-    }\n-\n-    @Override\n-    public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException {\n-        delegate.writeString(text, offset, len);\n-    }\n-\n-    @Override\n-    public void writeString(SerializableString text) throws IOException, JsonGenerationException {\n-        delegate.writeString(text);\n-    }\n-\n-    @Override\n-    public void writeRawUTF8String(byte[] text, int offset, int length)\n-        throws IOException, JsonGenerationException\n-    {\n+    public void writeString(String text) throws IOException,JsonGenerationException { delegate.writeString(text); }\n+\n+    @Override\n+    public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException { delegate.writeString(text, offset, len); }\n+\n+    @Override\n+    public void writeString(SerializableString text) throws IOException, JsonGenerationException { delegate.writeString(text); }\n+\n+    @Override\n+    public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException {\n         delegate.writeRawUTF8String(text, offset, length);\n     }\n \n     @Override\n-    public void writeUTF8String(byte[] text, int offset, int length)\n-        throws IOException, JsonGenerationException\n-    {\n+    public void writeUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException {\n         delegate.writeUTF8String(text, offset, length);\n     }\n \n      */\n \n     @Override\n-    public void writeRaw(String text) throws IOException, JsonGenerationException {\n-        delegate.writeRaw(text);\n-    }\n-\n-    @Override\n-    public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException {\n-        delegate.writeRaw(text, offset, len);\n-    }\n-\n-    @Override\n-    public void writeRaw(SerializableString raw)\n-        throws IOException, JsonGenerationException {\n+    public void writeRaw(String text) throws IOException, JsonGenerationException { delegate.writeRaw(text); }\n+\n+    @Override\n+    public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException { delegate.writeRaw(text, offset, len); }\n+\n+    @Override\n+    public void writeRaw(SerializableString raw) throws IOException, JsonGenerationException {\n         delegate.writeRaw(raw);\n     }\n     \n     }\n \n     @Override\n-    public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len)\n-        throws IOException, JsonGenerationException\n+    public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException\n     {\n         delegate.writeBinary(b64variant, data, offset, len);\n     }\n \n     @Override\n-    public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength)\n-        throws IOException, JsonGenerationException {\n+    public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException {\n         return delegate.writeBinary(b64variant, data, dataLength);\n     }\n     \n     }\n \n     @Override\n-    public void writeNumber(BigInteger v) throws IOException,\n-            JsonGenerationException {\n-        delegate.writeNumber(v);\n-    }\n-\n-    @Override\n-    public void writeNumber(double v) throws IOException,\n-            JsonGenerationException {\n-        delegate.writeNumber(v);\n-    }\n-\n-    @Override\n-    public void writeNumber(float v) throws IOException,\n-            JsonGenerationException {\n-        delegate.writeNumber(v);\n-    }\n-\n-    @Override\n-    public void writeNumber(BigDecimal v) throws IOException,\n-            JsonGenerationException {\n+    public void writeNumber(BigInteger v) throws IOException, JsonGenerationException {\n+        delegate.writeNumber(v);\n+    }\n+\n+    @Override\n+    public void writeNumber(double v) throws IOException, JsonGenerationException {\n+        delegate.writeNumber(v);\n+    }\n+\n+    @Override\n+    public void writeNumber(float v) throws IOException, JsonGenerationException {\n+        delegate.writeNumber(v);\n+    }\n+\n+    @Override\n+    public void writeNumber(BigDecimal v) throws IOException, JsonGenerationException {\n         delegate.writeNumber(v);\n     }\n \n     /**********************************************************\n      */\n \n-    @Override\n-    public JsonStreamContext getOutputContext() {\n-        return delegate.getOutputContext();\n-    }\n+    @Override public JsonStreamContext getOutputContext() { return delegate.getOutputContext(); }\n \n     /*\n     /**********************************************************\n     /**********************************************************\n      */\n     \n-    @Override\n-    public void flush() throws IOException {\n-        delegate.flush();\n-    }\n-    \n-    @Override\n-    public void close() throws IOException {\n-        delegate.close();\n-    }\n+    @Override public void flush() throws IOException { delegate.flush(); }\n+    @Override public void close() throws IOException { delegate.close(); }\n \n     /*\n     /**********************************************************\n     /**********************************************************\n      */\n     \n-    @Override\n-    public boolean isClosed() {\n-        return delegate.isClosed();\n-    }\n+    @Override public boolean isClosed() { return delegate.isClosed(); }\n }\n--- a/src/main/java/com/fasterxml/jackson/core/util/JsonParserDelegate.java\n+++ b/src/main/java/com/fasterxml/jackson/core/util/JsonParserDelegate.java\n     /**********************************************************\n      */\n \n-    @Override\n-    public void setCodec(ObjectCodec c) {\n-        delegate.setCodec(c);\n-    }\n-\n-    @Override\n-    public ObjectCodec getCodec() {\n-        return delegate.getCodec();\n-    }\n+    @Override public void setCodec(ObjectCodec c) { delegate.setCodec(c); }\n+    @Override public ObjectCodec getCodec() { return delegate.getCodec(); }\n \n     @Override\n     public JsonParser enable(Feature f) {\n         return this;\n     }\n  \n-    @Override\n-    public boolean isEnabled(Feature f) {\n-        return delegate.isEnabled(f);\n-    }\n-\n-    @Override\n-    public int getFeatureMask() {\n-        return delegate.getFeatureMask();\n-    }\n+    @Override public boolean isEnabled(Feature f) { return delegate.isEnabled(f); }\n+    @Override public int getFeatureMask() { return delegate.getFeatureMask(); }\n \n     @Override\n     public JsonParser setFeatureMask(int mask) {\n         return this;\n     }\n \n-    @Override\n-    public FormatSchema getSchema() {\n-        return delegate.getSchema();\n-    }\n-    \n-    @Override\n-    public void setSchema(FormatSchema schema) {\n-        delegate.setSchema(schema);\n-    }\n-\n-    @Override\n-    public boolean canUseSchema(FormatSchema schema) {\n-        return delegate.canUseSchema(schema);\n-    }\n-    \n-    @Override\n-    public Version version() {\n-        return delegate.version();\n-    }\n-\n-    @Override\n-    public Object getInputSource() {\n-        return delegate.getInputSource();\n-    }\n+    @Override public FormatSchema getSchema() { return delegate.getSchema(); }\n+    @Override public void setSchema(FormatSchema schema) { delegate.setSchema(schema); }\n+    @Override public boolean canUseSchema(FormatSchema schema) {  return delegate.canUseSchema(schema); }\n+    @Override public Version version() { return delegate.version(); }\n+    @Override public Object getInputSource() { return delegate.getInputSource(); }\n \n     /*\n     /**********************************************************\n     /**********************************************************\n      */\n \n-    @Override\n-    public boolean requiresCustomCodec() {\n-        return delegate.requiresCustomCodec();\n-    }\n+    @Override public boolean requiresCustomCodec() { return delegate.requiresCustomCodec(); }\n \n     /*\n     /**********************************************************\n     /**********************************************************\n      */\n \n-    @Override\n-    public void close() throws IOException {\n-        delegate.close();\n-    }\n-\n-    @Override\n-    public boolean isClosed() {\n-        return delegate.isClosed();\n-    }\n+    @Override public void close() throws IOException { delegate.close(); }\n+    @Override public boolean isClosed() { return delegate.isClosed(); }\n \n     /*\n     /**********************************************************\n     /**********************************************************\n      */\n \n-    @Override\n-    public JsonToken getCurrentToken() {\n-        return delegate.getCurrentToken();\n-    }\n-\n-    @Override\n-    public int getCurrentTokenId() {\n-        return delegate.getCurrentTokenId();\n-    }\n-    \n-    @Override\n-    public boolean hasCurrentToken() {\n-        return delegate.hasCurrentToken();\n-    }\n-\n-    @Override\n-    public String getCurrentName() throws IOException, JsonParseException {\n-        return delegate.getCurrentName();\n-    }\n-\n-    @Override\n-    public JsonLocation getCurrentLocation() {\n-        return delegate.getCurrentLocation();\n-    }\n-\n-    @Override\n-    public JsonStreamContext getParsingContext() {\n-        return delegate.getParsingContext();\n-    }\n+    @Override public JsonToken getCurrentToken() { return delegate.getCurrentToken(); }\n+    @Override public int getCurrentTokenId() { return delegate.getCurrentTokenId(); }\n+    @Override public boolean hasCurrentToken() { return delegate.hasCurrentToken(); }\n+    @Override public String getCurrentName() throws IOException, JsonParseException { return delegate.getCurrentName(); }\n+    @Override public JsonLocation getCurrentLocation() { return delegate.getCurrentLocation(); }\n+    @Override public JsonStreamContext getParsingContext() { return delegate.getParsingContext(); }\n \n     /*\n     /**********************************************************\n     /**********************************************************\n      */\n     \n-    @Override\n-    public void clearCurrentToken() {\n-        delegate.clearCurrentToken();        \n-    }\n-\n-    @Override\n-    public JsonToken getLastClearedToken() {\n-        return delegate.getLastClearedToken();\n-    }\n-    \n-    @Override\n-    public void overrideCurrentName(String name) {\n-        delegate.overrideCurrentName(name);\n-    }\n+    @Override public void clearCurrentToken() { delegate.clearCurrentToken(); }\n+    @Override public JsonToken getLastClearedToken() { return delegate.getLastClearedToken(); }\n+    @Override public void overrideCurrentName(String name) { delegate.overrideCurrentName(name); }\n \n     /*\n     /**********************************************************\n     /**********************************************************\n      */\n \n-    @Override\n-    public String getText() throws IOException, JsonParseException {\n-        return delegate.getText();\n-    }\n-\n-    @Override\n-    public boolean hasTextCharacters() {\n-        return delegate.hasTextCharacters();\n-    }\n-    \n-    @Override\n-    public char[] getTextCharacters() throws IOException, JsonParseException {\n-        return delegate.getTextCharacters();\n-    }\n-\n-    @Override\n-    public int getTextLength() throws IOException, JsonParseException {\n-        return delegate.getTextLength();\n-    }\n-\n-    @Override\n-    public int getTextOffset() throws IOException, JsonParseException {\n-        return delegate.getTextOffset();\n-    }\n+    @Override public String getText() throws IOException, JsonParseException { return delegate.getText();  }\n+    @Override public boolean hasTextCharacters() { return delegate.hasTextCharacters(); }\n+    @Override public char[] getTextCharacters() throws IOException, JsonParseException { return delegate.getTextCharacters(); }\n+    @Override public int getTextLength() throws IOException, JsonParseException { return delegate.getTextLength(); }\n+    @Override public int getTextOffset() throws IOException, JsonParseException { return delegate.getTextOffset(); }\n \n     /*\n     /**********************************************************\n      */\n     \n     @Override\n-    public BigInteger getBigIntegerValue() throws IOException,JsonParseException {\n-        return delegate.getBigIntegerValue();\n-    }\n-\n-    @Override\n-    public boolean getBooleanValue() throws IOException, JsonParseException {\n-        return delegate.getBooleanValue();\n-    }\n-    \n-    @Override\n-    public byte getByteValue() throws IOException, JsonParseException {\n-        return delegate.getByteValue();\n-    }\n-\n-    @Override\n-    public short getShortValue() throws IOException, JsonParseException {\n-        return delegate.getShortValue();\n-    }\n-\n-    @Override\n-    public BigDecimal getDecimalValue() throws IOException, JsonParseException {\n-        return delegate.getDecimalValue();\n-    }\n-\n-    @Override\n-    public double getDoubleValue() throws IOException, JsonParseException {\n-        return delegate.getDoubleValue();\n-    }\n-\n-    @Override\n-    public float getFloatValue() throws IOException, JsonParseException {\n-        return delegate.getFloatValue();\n-    }\n-\n-    @Override\n-    public int getIntValue() throws IOException, JsonParseException {\n-        return delegate.getIntValue();\n-    }\n-\n-    @Override\n-    public long getLongValue() throws IOException, JsonParseException {\n-        return delegate.getLongValue();\n-    }\n-\n-    @Override\n-    public NumberType getNumberType() throws IOException, JsonParseException {\n-        return delegate.getNumberType();\n-    }\n-\n-    @Override\n-    public Number getNumberValue() throws IOException, JsonParseException {\n-        return delegate.getNumberValue();\n-    }\n+    public BigInteger getBigIntegerValue() throws IOException,JsonParseException { return delegate.getBigIntegerValue(); }\n+\n+    @Override\n+    public boolean getBooleanValue() throws IOException, JsonParseException { return delegate.getBooleanValue(); }\n+    \n+    @Override\n+    public byte getByteValue() throws IOException, JsonParseException { return delegate.getByteValue(); }\n+\n+    @Override\n+    public short getShortValue() throws IOException, JsonParseException { return delegate.getShortValue(); }\n+\n+    @Override\n+    public BigDecimal getDecimalValue() throws IOException, JsonParseException { return delegate.getDecimalValue(); }\n+\n+    @Override\n+    public double getDoubleValue() throws IOException, JsonParseException { return delegate.getDoubleValue(); }\n+\n+    @Override\n+    public float getFloatValue() throws IOException, JsonParseException { return delegate.getFloatValue(); }\n+\n+    @Override\n+    public int getIntValue() throws IOException, JsonParseException { return delegate.getIntValue(); }\n+\n+    @Override\n+    public long getLongValue() throws IOException, JsonParseException { return delegate.getLongValue(); }\n+\n+    @Override\n+    public NumberType getNumberType() throws IOException, JsonParseException { return delegate.getNumberType(); }\n+\n+    @Override\n+    public Number getNumberValue() throws IOException, JsonParseException { return delegate.getNumberValue(); }\n \n     /*\n     /**********************************************************\n     /**********************************************************\n      */\n     \n-    @Override\n-    public int getValueAsInt() throws IOException, JsonParseException {\n-        return delegate.getValueAsInt();\n-    }\n-    \n-    @Override\n-    public int getValueAsInt(int defaultValue) throws IOException, JsonParseException {\n-        return delegate.getValueAsInt(defaultValue);\n-    }\n-\n-    @Override\n-    public long getValueAsLong() throws IOException, JsonParseException {\n-        return delegate.getValueAsLong();\n-    }\n-    \n-    @Override\n-    public long getValueAsLong(long defaultValue) throws IOException, JsonParseException {\n-        return delegate.getValueAsLong(defaultValue);\n-    }\n-    \n-    @Override\n-    public double getValueAsDouble() throws IOException, JsonParseException {\n-        return delegate.getValueAsDouble();\n-    }\n-    \n-    @Override\n-    public double getValueAsDouble(double defaultValue) throws IOException, JsonParseException {\n-        return delegate.getValueAsDouble(defaultValue);\n-    }\n-\n-    @Override\n-    public boolean getValueAsBoolean() throws IOException, JsonParseException {\n-        return delegate.getValueAsBoolean();\n-    }\n-\n-    @Override\n-    public boolean getValueAsBoolean(boolean defaultValue) throws IOException, JsonParseException {\n-        return delegate.getValueAsBoolean(defaultValue);\n-    }\n-\n-    @Override\n-    public String getValueAsString() throws IOException, JsonParseException {\n-        return delegate.getValueAsString();\n-    }\n-    \n-    @Override\n-    public String getValueAsString(String defaultValue) throws IOException, JsonParseException {\n-        return delegate.getValueAsString(defaultValue);\n-    }\n+    @Override public int getValueAsInt() throws IOException, JsonParseException { return delegate.getValueAsInt(); }\n+    @Override public int getValueAsInt(int defaultValue) throws IOException, JsonParseException { return delegate.getValueAsInt(defaultValue); }\n+    @Override public long getValueAsLong() throws IOException, JsonParseException { return delegate.getValueAsLong(); }\n+    @Override public long getValueAsLong(long defaultValue) throws IOException, JsonParseException { return delegate.getValueAsLong(defaultValue); }\n+    @Override public double getValueAsDouble() throws IOException, JsonParseException { return delegate.getValueAsDouble(); }\n+    @Override public double getValueAsDouble(double defaultValue) throws IOException, JsonParseException { return delegate.getValueAsDouble(defaultValue); }\n+    @Override public boolean getValueAsBoolean() throws IOException, JsonParseException { return delegate.getValueAsBoolean(); }\n+    @Override public boolean getValueAsBoolean(boolean defaultValue) throws IOException, JsonParseException { return delegate.getValueAsBoolean(defaultValue); }\n+    @Override public String getValueAsString() throws IOException, JsonParseException { return delegate.getValueAsString(); }\n+    @Override public String getValueAsString(String defaultValue) throws IOException, JsonParseException { return delegate.getValueAsString(defaultValue); }\n     \n     /*\n     /**********************************************************\n     /**********************************************************\n      */\n \n-    @Override\n-    public Object getEmbeddedObject() throws IOException, JsonParseException {\n-        return delegate.getEmbeddedObject();\n-    }\n-    \n-    @Override\n-    public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException {\n-        return delegate.getBinaryValue(b64variant);\n-    }\n-\n-    @Override\n-    public int readBinaryValue(Base64Variant b64variant, OutputStream out)\n-            throws IOException, JsonParseException {\n-        return delegate.readBinaryValue(b64variant, out);\n-    }\n-    \n-    @Override\n-    public JsonLocation getTokenLocation() {\n-        return delegate.getTokenLocation();\n-    }\n-\n-    @Override\n-    public JsonToken nextToken() throws IOException, JsonParseException {\n-        return delegate.nextToken();\n-    }\n-\n-    @Override\n-    public JsonToken nextValue() throws IOException, JsonParseException {\n-        return delegate.nextValue();\n-    }\n+    @Override public Object getEmbeddedObject() throws IOException, JsonParseException { return delegate.getEmbeddedObject(); }\n+    @Override public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException { return delegate.getBinaryValue(b64variant); }\n+    @Override public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException { return delegate.readBinaryValue(b64variant, out); }\n+    @Override public JsonLocation getTokenLocation() { return delegate.getTokenLocation(); }\n+    @Override public JsonToken nextToken() throws IOException, JsonParseException { return delegate.nextToken(); }\n+    @Override public JsonToken nextValue() throws IOException, JsonParseException { return delegate.nextValue(); }\n     \n     @Override\n     public JsonParser skipChildren() throws IOException, JsonParseException {\n     /**********************************************************\n      */\n \n-    @Override\n-    public boolean canReadObjectId() {\n-        return delegate.canReadObjectId();\n-    }\n-\n-    @Override\n-    public boolean canReadTypeId() {\n-        return delegate.canReadTypeId();\n-    }\n-\n-    @Override\n-    public Object getObjectId() throws IOException, JsonGenerationException {\n-        return delegate.getObjectId();\n-    }\n-\n-    @Override\n-    public Object getTypeId() throws IOException, JsonGenerationException {\n-        return delegate.getTypeId();\n-    }\n+    @Override public boolean canReadObjectId() { return delegate.canReadObjectId(); }\n+    @Override public boolean canReadTypeId() { return delegate.canReadTypeId(); }\n+    @Override public Object getObjectId() throws IOException, JsonGenerationException { return delegate.getObjectId(); }\n+    @Override public Object getTypeId() throws IOException, JsonGenerationException { return delegate.getTypeId(); }\n }\n--- a/src/main/java/com/fasterxml/jackson/core/util/JsonParserSequence.java\n+++ b/src/main/java/com/fasterxml/jackson/core/util/JsonParserSequence.java\n      */\n     \n     @Override\n-    public void close() throws IOException\n-    {\n-        do {\n-            delegate.close();\n-        } while (switchToNext());\n+    public void close() throws IOException {\n+        do { delegate.close(); } while (switchToNext());\n     }\n \n     @Override\n--- a/src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java\n+++ b/src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java\n                 // And then return that array\n                 char[] buf = _currentSegment;\n                 _currentSegment = null;\n-                _allocator.releaseCharBuffer(BufferRecycler.CharBufferType.TEXT_BUFFER, buf);\n+                _allocator.releaseCharBuffer(BufferRecycler.CHAR_TEXT_BUFFER, buf);\n             }\n         }\n     }\n     private char[] findBuffer(int needed)\n     {\n         if (_allocator != null) {\n-            return _allocator.allocCharBuffer(BufferRecycler.CharBufferType.TEXT_BUFFER, needed);\n+            return _allocator.allocCharBuffer(BufferRecycler.CHAR_TEXT_BUFFER, needed);\n         }\n         return new char[Math.max(needed, MIN_SEGMENT_LEN)];\n     }\n      * Convenience method for converting contents of the buffer\n      * into a Double value.\n      */\n-    public double contentsAsDouble()\n-        throws NumberFormatException\n-    {\n+    public double contentsAsDouble() throws NumberFormatException {\n         return NumberInput.parseDouble(contentsAsString());\n     }\n \n         return curr;\n     }\n \n-    public int getCurrentSegmentSize() {\n-        return _currentSize;\n-    }\n-\n-    public void setCurrentLength(int len) {\n-        _currentSize = len;\n-    }\n-\n-    public char[] finishCurrentSegment()\n-    {\n+    public int getCurrentSegmentSize() { return _currentSize; }\n+    public void setCurrentLength(int len) { _currentSize = len; }\n+\n+    public char[] finishCurrentSegment() {\n         if (_segments == null) {\n             _segments = new ArrayList<char[]>();\n         }\n      * {@link #contentsAsString}, since it's not guaranteed that resulting\n      * String is cached.\n      */\n-    @Override\n-    public String toString() {\n-         return contentsAsString();\n-    }\n+    @Override public String toString() { return contentsAsString(); }\n \n     /*\n     /**********************************************************\n         return result;\n     }\n \n-    private char[] _charArray(int len) {\n-        return new char[len];\n-    }\n+    private char[] _charArray(int len) { return new char[len]; }\n }\n--- a/src/test/java/com/fasterxml/jackson/core/util/TestDelegates.java\n+++ b/src/test/java/com/fasterxml/jackson/core/util/TestDelegates.java\n         jg.copyCurrentStructure(jp);\n         jg.flush();\n         assertEquals(\"[{\\\"a-test\\\":true,\\\"a\\\":[1,2,{\\\"b-test\\\":true,\\\"b\\\":3}],\\\"c-test\\\":true,\\\"c\\\":\\\"d\\\"},{\\\"e-test\\\":true,\\\"e\\\":false},null]\", sw.toString());\n+        jp.close();\n+        jg.close();\n     }\n }", "timestamp": 1386998124, "metainfo": ""}