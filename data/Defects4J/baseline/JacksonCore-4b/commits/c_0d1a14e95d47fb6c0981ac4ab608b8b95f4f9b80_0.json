{"sha": "0d1a14e95d47fb6c0981ac4ab608b8b95f4f9b80", "log": "streamline ws skipping", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java\n         if (_tokenIncomplete) {\n             _skipString(); // only strings can be partial\n         }\n-\n         int i = _skipWSOrEnd();\n         if (i < 0) { // end-of-input\n             // Close/release things like input source, symbol table and recyclable buffers\n         _parsingContext.setCurrentName(n.getName());\n         _currToken = JsonToken.FIELD_NAME;\n \n-        // Let's do a quickie check:\n-        if (_inputPtr < _inputEnd && _inputBuffer[_inputPtr] == ':') {\n-            ++_inputPtr;\n-        } else {\n-            i = _skipWS();\n-            if (i != INT_COLON) {\n-                _reportUnexpectedChar(i, \"was expecting a colon to separate field name and value\");\n-            }\n-        }\n-        i = _skipWS();\n+        i = _skipColon();\n \n         // Ok: we must have a value... what is it? Strings are very common, check first:\n         if (i == INT_QUOTE) {\n         throws IOException, JsonParseException\n     {\n         // very first thing: common case, colon, value, no white space\n-        int i;\n-        if (_inputPtr < (_inputEnd-1) && _inputBuffer[_inputPtr] == INT_COLON) { // fast case first\n-            i = _inputBuffer[++_inputPtr];\n-            ++_inputPtr;\n-            if (i == INT_QUOTE) {\n-                _tokenIncomplete = true;\n-                _nextToken = JsonToken.VALUE_STRING;\n-                return;\n-            }\n-            if (i == INT_LCURLY) {\n-                _nextToken = JsonToken.START_OBJECT;\n-                return;\n-            }\n-            if (i == INT_LBRACKET) {\n-                _nextToken = JsonToken.START_ARRAY;\n-                return;\n-            }\n-            i &= 0xFF;\n-            if (i <= INT_SPACE || i == INT_SLASH) {\n-            \t--_inputPtr;\n-                i = _skipWS();\n-            }\n-        } else {\n-            i = _skipColon();\n-        }\n+        int i = _skipColon();\n         switch (i) {\n         case '\"':\n             _tokenIncomplete = true;\n             switch (codes[i]) {\n             case 0: // done!\n                 return i;\n-            case 1: // skip\n+            case 1: // white space, skip\n                 continue;\n-            case 2: // 2-byte UTF\n-                _skipUtf8_2(i);\n-                break;\n-            case 3: // 3-byte UTF\n-                _skipUtf8_3(i);\n-                break;\n-            case 4: // 4-byte UTF\n-                _skipUtf8_4(i);\n-                break;\n+            case 2: // 2/3/4-byte UTF: done\n+            case 3:\n+            case 4:\n+                return i;\n             case INT_LF:\n                 ++_currInputRow;\n                 _currInputRowStart = _inputPtr;\n             case INT_CR:\n                 _skipCR();\n                 break;\n-            case '/':\n+            case INT_SLASH:\n                 _skipComment();\n                 break;\n             case '#':\n         _handleEOF();\n         return -1;\n     }\n-\n-    /**\n-     * Helper method for matching and skipping a colon character,\n-     * optionally surrounded by white space\n-     */\n+    \n     private final int _skipColon() throws IOException\n     {\n-        if (_inputPtr >= _inputEnd) {\n-            loadMoreGuaranteed();\n-        }\n-        // first fast case: we just got a colon without white space:\n-        int i = _inputBuffer[_inputPtr++];\n+        if ((_inputPtr + 4) >= _inputEnd) {\n+            return _skipColon2(false);\n+        }\n+        // Fast path: colon with optional single-space/tab before and/or after:\n+        int i = _inputBuffer[_inputPtr];\n+        if (i == INT_COLON) { // common case, no leading space\n+            i = _inputBuffer[++_inputPtr];\n+            if (i > INT_SPACE) { // nor trailing\n+                ++_inputPtr;\n+                return i;\n+            }\n+            if (i == INT_SPACE || i == INT_TAB) {\n+                i = (int) _inputBuffer[++_inputPtr];\n+                if (i > INT_SPACE) {\n+                    ++_inputPtr;                    \n+                    return i;\n+                }\n+            }\n+            return _skipColon2(true); // true -> skipped colon\n+        }\n+        if (i == INT_SPACE || i == INT_TAB) {\n+            i = _inputBuffer[++_inputPtr];\n+        }\n         if (i == INT_COLON) {\n-            if (_inputPtr < _inputEnd) {\n-                i = _inputBuffer[_inputPtr] & 0xFF;\n-                if (i > INT_SPACE && i != INT_SLASH) {\n+            i = _inputBuffer[++_inputPtr];\n+            if (i > 32) {\n+                ++_inputPtr;\n+                return i;\n+            }\n+            if (i == INT_SPACE || i == INT_TAB) {\n+                i = (int) _inputBuffer[++_inputPtr];\n+                if (i > INT_SPACE) {\n                     ++_inputPtr;\n                     return i;\n                 }\n             }\n-        } else {\n-            // need to skip potential leading space\n-            i &= 0xFF;\n-            \n-            space_loop:\n-            while (true) {\n-                switch (i) {\n-                case ' ':\n-                case '\\t':\n-                    break;\n-                case INT_CR:\n-                    _skipCR();\n-                    break;\n-                case INT_LF:\n-                    ++_currInputRow;\n-                    _currInputRowStart = _inputPtr;\n-                    break;\n-                case '/':\n-                    _skipComment();\n-                    break;\n-                default:\n+            return _skipColon2(true);\n+        }\n+        return _skipColon2(false);\n+    }\n+    \n+    private final int _skipColon2(boolean gotColon) throws IOException\n+    {\n+        while (_inputPtr < _inputEnd || loadMore()) {\n+            int i = _inputBuffer[_inputPtr++] & 0xFF;\n+            switch (i) {\n+            case ' ':\n+            case '\\t':\n+                break;\n+            case INT_CR:\n+                _skipCR();\n+                break;\n+            case INT_LF:\n+                ++_currInputRow;\n+                _currInputRowStart = _inputPtr;\n+                break;\n+            case INT_SLASH:\n+                _skipComment();\n+                break;\n+            case '#':\n+                if (!_skipYAMLComment()) {\n+                    return i;\n+                }\n+                break;\n+            default:\n+                if (gotColon) {\n+                    return i;\n+                }\n+                if (i != INT_COLON) {\n                     if (i < INT_SPACE) {\n                         _throwInvalidSpace(i);\n                     }\n-                    break space_loop;\n-                }\n-                if (_inputPtr >= _inputEnd) {\n-                    loadMoreGuaranteed();\n-                }\n-                i = _inputBuffer[_inputPtr++] & 0xFF;\n-            }\n-            if (i != INT_COLON) {\n-                _reportUnexpectedChar(i, \"was expecting a colon to separate field name and value\");\n-            }\n-        }\n-\n-            // either way, found colon, skip through trailing WS\n-        while (_inputPtr < _inputEnd || loadMore()) {\n-            i = _inputBuffer[_inputPtr++] & 0xFF;\n-            if (i > INT_SPACE) {\n-                if (i != INT_SLASH) {\n-                    return i;\n-                }\n-                _skipComment();\n-            } else if (i != INT_SPACE) {\n-                if (i == INT_LF) {\n-                    ++_currInputRow;\n-                    _currInputRowStart = _inputPtr;\n-                } else if (i == INT_CR) {\n-                    _skipCR();\n-                } else if (i != INT_TAB) {\n-                    _throwInvalidSpace(i);\n-                }\n+                    _reportUnexpectedChar(i, \"was expecting a colon to separate field name and value\");\n+                }\n+                gotColon = true;\n             }\n         }\n         throw _constructError(\"Unexpected end-of-input within/between \"+_parsingContext.getTypeDesc()+\" entries\");\n     }\n-    \n+\n     private final void _skipComment() throws IOException\n     {\n         if (!isEnabled(Feature.ALLOW_COMMENTS)) {", "timestamp": 1398318116, "metainfo": ""}