{"sha": "e17a4dd4ffcb6b21162d7a9daa5c7c49cb414e58", "log": "Improve byte-source hash collision protection same way as char-based (but don't know how to test actual collisions)", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java\n+++ b/src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java\n package com.fasterxml.jackson.core.sym;\n \n import java.util.Arrays;\n+import java.util.BitSet;\n import java.util.concurrent.atomic.AtomicReference;\n \n import com.fasterxml.jackson.core.JsonFactory;\n     /**\n      * Also: to thwart attacks based on hash collisions (which may or may not\n      * be cheap to calculate), we will need to detect \"too long\"\n-     * collision chains. Let's start with static value of 255 entries\n-     * for the longest legal chain.\n+     * collision chains.\n      *<p>\n      * Note: longest chain we have been able to produce without malicious\n-     * intent has been 60 (with \"com.fasterxml.jackson.core.main.TestWithTonsaSymbols\");\n+     * intent has been 10 (with \"com.fasterxml.jackson.core.sym.TestSymbolTables\");\n      * our setting should be reasonable here.\n+     *<p>\n+     * Also note that value was lowered from 255 (2.3 and earlier) to 100 for 2.4\n      * \n      * @since 2.1\n      */\n-    private final static int MAX_COLL_CHAIN_LENGTH = 255;\n-\n-    /**\n-     * And to reduce likelihood of accidental collisions causing\n-     * exceptions, let's prevent reuse of tables with long collision\n-     * overflow lists as well.\n-     * \n-     * @since 2.1\n-     */\n-    final static int MAX_COLL_CHAIN_FOR_REUSE  = 63;\n-\n-    /**\n-     * No point in trying to construct tiny tables, just need to resize\n-     * soon.\n+    private final static int MAX_COLL_CHAIN_LENGTH = 100;\n+\n+    /**\n+     * No point in trying to construct tiny tables, just need to resize soon.\n      */\n     final static int MIN_HASH_SIZE = 16;\n \n     \n     /*\n     /**********************************************************\n+    /* Configuration\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Whether canonical symbol Strings are to be intern()ed before added\n+     * to the table or not.\n+     *<p>\n+     * NOTE: non-final to allow disabling intern()ing in case of excessive\n+     * collisions.\n+     */\n+    protected boolean _intern;\n+\n+    /**\n+     * Flag that indicates whether we should throw an exception if enough \n+     * hash collisions are detected (true); or just worked around (false).\n+     * \n+     * @since 2.4\n+     */\n+    protected final boolean _failOnDoS;\n+    \n+    /*\n+    /**********************************************************\n     /* Main table state\n     /**********************************************************\n      */\n-\n-    /**\n-     * Whether canonical symbol Strings are to be intern()ed before added\n-     * to the table or not\n-     */\n-    protected final boolean _intern;\n     \n     // // // First, global information\n \n \n     /*\n     /**********************************************************\n+    /* Bit of DoS detection goodness\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Lazily constructed structure that is used to keep track of\n+     * collision buckets that have overflowed once: this is used\n+     * to detect likely attempts at denial-of-service attacks that\n+     * uses hash collisions.\n+     * \n+     * @since 2.4\n+     */\n+    protected BitSet _overflows;\n+    \n+    /*\n+    /**********************************************************\n     /* Life-cycle: constructors\n     /**********************************************************\n      */\n      * @param seed Random seed valued used to make it more difficult to cause\n      *   collisions (used for collision-based DoS attacks).\n      */\n-    private BytesToNameCanonicalizer(int sz, boolean intern, int seed) {\n+    private BytesToNameCanonicalizer(int sz, boolean intern, boolean failOnDoS, int seed) {\n         _parent = null;\n         _seed = seed;\n         _intern = intern;\n+        _failOnDoS = failOnDoS;\n         // Sanity check: let's now allow hash sizes below certain minimum value\n         if (sz < MIN_HASH_SIZE) {\n             sz = MIN_HASH_SIZE;\n     /**\n      * Constructor used when creating a child instance\n      */\n-    private BytesToNameCanonicalizer(BytesToNameCanonicalizer parent, boolean intern, int seed, TableInfo state)\n+    private BytesToNameCanonicalizer(BytesToNameCanonicalizer parent, boolean intern, boolean failOnDoS,\n+            int seed, TableInfo state)\n     {\n         _parent = parent;\n         _seed = seed;\n         _intern = intern;\n+        _failOnDoS = failOnDoS;\n         _tableInfo = null; // not used by child tables\n \n         // Then copy shared state\n      * value should remain the same.\n      */\n     protected static BytesToNameCanonicalizer createRoot(int seed) {\n-        return new BytesToNameCanonicalizer(DEFAULT_T_SIZE, true, seed);\n+        return new BytesToNameCanonicalizer(DEFAULT_T_SIZE, true, true, seed);\n     }\n     \n     /**\n      * use for parsing.\n      */\n     public BytesToNameCanonicalizer makeChild(int flags) {\n-        return new BytesToNameCanonicalizer(this, JsonFactory.Feature.INTERN_FIELD_NAMES.enabledIn(flags),\n+        return new BytesToNameCanonicalizer(this,\n+                JsonFactory.Feature.INTERN_FIELD_NAMES.enabledIn(flags),\n+                JsonFactory.Feature.FAIL_ON_SYMBOL_HASH_OVERFLOW.enabledIn(flags),\n                 _seed, _tableInfo.get());\n     }\n \n     {\n         final int childCount = childState.count;\n         TableInfo currState = _tableInfo.get();\n-        \n-        // Only makes sense if child actually has more entries\n-        if (childCount <= currState.count) {\n+\n+        /* Should usually grow; but occasionally could also shrink if\n+         * (but only if) collision list overflow ends up clearing\n+         * some collision lists.\n+         */\n+        if (childCount == currState.count) {\n             return;\n         }\n \n          * One way to do this is to just purge tables if they grow\n          * too large, and that's what we'll do here.\n          */\n-        if (childCount > MAX_ENTRIES_FOR_REUSE\n-                || childState.longestCollisionList > MAX_COLL_CHAIN_FOR_REUSE) {\n+        if (childCount > MAX_ENTRIES_FOR_REUSE) {\n             /* Should there be a way to get notified about this\n              * event, to log it or such? (as it's somewhat abnormal\n              * thing to happen)\n             \n             // And then just need to link the new bucket entry in\n             Bucket newB = new Bucket(symbol, _collList[bucket]);\n-            _collList[bucket] = newB;\n-            // but, be careful wrt attacks\n-            _longestCollisionList = Math.max(newB.length(), _longestCollisionList);\n-            if (_longestCollisionList > MAX_COLL_CHAIN_LENGTH) {\n-                reportTooManyCollisions(MAX_COLL_CHAIN_LENGTH);\n+            int collLen = newB.length;\n+            if (collLen > MAX_COLL_CHAIN_LENGTH) {\n+                /* 23-May-2014, tatu: Instead of throwing an exception right away, let's handle\n+                 *   in bit smarter way.\n+                 */\n+                _handleSpillOverflow(bucket, newB);\n+            } else {\n+                _collList[bucket] = newB;\n+                // but, be careful wrt attacks\n+                _longestCollisionList = Math.max(newB.length, _longestCollisionList);\n             }\n         }\n \n         }\n     }\n \n+    private void _handleSpillOverflow(int bindex, Bucket newBucket)\n+    {\n+        if (_overflows == null) {\n+            _overflows = new BitSet();\n+            _overflows.set(bindex);\n+        } else {\n+            if (_overflows.get(bindex)) {\n+                // Has happened once already, so not a coincident...\n+                if (_failOnDoS) {\n+                    reportTooManyCollisions(MAX_COLL_CHAIN_LENGTH);\n+                }\n+                // but even if we don't fail, we will stop intern()ing\n+                _intern = false;\n+            } else {\n+                _overflows.set(bindex);\n+            }\n+        }\n+        // regardless, if we get this far, clear up the bucket, adjust size appropriately.\n+        _collList[bindex] = null;\n+        _count -= (newBucket.length);\n+        // we could calculate longest; but for now just mark as invalid\n+        _longestCollisionList = -1;\n+    }\n+    \n     private void rehash()\n     {\n         _needRehash = false;        \n         Bucket[] oldBuckets = _collList;\n         _collList = new Bucket[oldBuckets.length];\n         for (int i = 0; i < oldEnd; ++i) {\n-            for (Bucket curr = oldBuckets[i]; curr != null; curr = curr._next) {\n+            for (Bucket curr = oldBuckets[i]; curr != null; curr = curr.next) {\n                 ++symbolsSeen;\n-                Name symbol = curr._name;\n+                Name symbol = curr.name;\n                 int hash = symbol.hashCode();\n                 int ix = (hash & _hashMask);\n                 int val = _hash[ix];\n                     // And then just need to link the new bucket entry in\n                     Bucket newB = new Bucket(symbol, _collList[bucket]);\n                     _collList[bucket] = newB;\n-                    maxColl = Math.max(maxColl, newB.length());\n+                    maxColl = Math.max(maxColl, newB.length);\n                 }\n             } // for (... buckets in the chain ...)\n         } // for (... list of bucket heads ... )\n         int bestIx = -1;\n \n         for (int i = 0, len = _collEnd; i < len; ++i) {\n-            int count = buckets[i].length();\n+            int count = buckets[i].length;\n             if (count < bestCount) {\n                 if (count == 1) { // best possible\n                     return i;\n     \n     final private static class Bucket\n     {\n-        protected final Name _name;\n-        protected final Bucket _next;\n-        private final int _hash;\n-        private final int _length;\n+        protected final Name name;\n+        protected final Bucket next;\n+        private final int hash;\n+        private final int length;\n \n         Bucket(Name name, Bucket next) {\n-            _name = name;\n-            _next = next;\n-            _length = (next == null) ? 1 : next._length+1;\n-            _hash = name.hashCode();\n-        }\n-\n-        public int length() { return _length; }\n-\n-        public Name find(int hash, int firstQuad, int secondQuad)\n-        {\n-            if (_hash == hash) {\n-                if (_name.equals(firstQuad, secondQuad)) {\n-                    return _name;\n+            this.name = name;\n+            this.next = next;\n+            length = (next == null) ? 1 : next.length+1;\n+            hash = name.hashCode();\n+        }\n+\n+        public Name find(int h, int firstQuad, int secondQuad) {\n+            if (hash == h) {\n+                if (name.equals(firstQuad, secondQuad)) {\n+                    return name;\n                 }\n             }\n-            for (Bucket curr = _next; curr != null; curr = curr._next) {\n-                if (curr._hash == hash) {\n-                    Name currName = curr._name;\n+            for (Bucket curr = next; curr != null; curr = curr.next) {\n+                if (curr.hash == h) {\n+                    Name currName = curr.name;\n                     if (currName.equals(firstQuad, secondQuad)) {\n                         return currName;\n                     }\n             return null;\n         }\n \n-        public Name find(int hash, int[] quads, int qlen)\n-        {\n-            if (_hash == hash) {\n-                if (_name.equals(quads, qlen)) {\n-                    return _name;\n+        public Name find(int h, int[] quads, int qlen) {\n+            if (hash == h) {\n+                if (name.equals(quads, qlen)) {\n+                    return name;\n                 }\n             }\n-            for (Bucket curr = _next; curr != null; curr = curr._next) {\n-                if (curr._hash == hash) {\n-                    Name currName = curr._name;\n+            for (Bucket curr = next; curr != null; curr = curr.next) {\n+                if (curr.hash == h) {\n+                    Name currName = curr.name;\n                     if (currName.equals(quads, qlen)) {\n                         return currName;\n                     }\n--- a/src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java\n+++ b/src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java\n      * Note: longest chain we have been able to produce without malicious\n      * intent has been 38 (with \"com.fasterxml.jackson.core.main.TestWithTonsaSymbols\");\n      * our setting should be reasonable here.\n+     *<p>\n+     * Also note that value was lowered from 255 (2.3 and earlier) to 100 for 2.4\n      * \n      * @since 2.1\n      */\n         _buckets[bindex] = null;\n         // newBucket contains new symbol; but we wil \n         _size -= (newBucket.length);\n+        // we could calculate longest; but for now just mark as invalid\n+        _longestCollisionList = -1;\n     }\n \n     /**\n--- a/src/test/java/com/fasterxml/jackson/core/sym/TestByteBasedSymbols.java\n+++ b/src/test/java/com/fasterxml/jackson/core/sym/TestByteBasedSymbols.java\n      * This unit test checks that [JACKSON-5] is fixed; if not, a\n      * symbol table corruption should result in odd problems.\n      */\n-    public void testSharedSymbols()\n-        throws Exception\n+    public void testSharedSymbols() throws Exception\n     {\n         // MUST share a single json factory\n         JsonFactory jf = new JsonFactory();\n--- a/src/test/java/com/fasterxml/jackson/core/sym/TestJsonParserSymbols.java\n+++ b/src/test/java/com/fasterxml/jackson/core/sym/TestJsonParserSymbols.java\n package com.fasterxml.jackson.core.sym;\n \n import java.io.IOException;\n-\n-import org.junit.Assert;\n \n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.core.json.ReaderBasedJsonParser;", "timestamp": 1400973498, "metainfo": ""}