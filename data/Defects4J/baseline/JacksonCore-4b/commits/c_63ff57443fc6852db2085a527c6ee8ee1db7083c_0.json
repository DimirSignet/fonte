{"sha": "63ff57443fc6852db2085a527c6ee8ee1db7083c", "log": "Start work on incremental binary/base64 generation", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/core/JsonGenerator.java\n+++ b/src/main/java/com/fasterxml/jackson/core/JsonGenerator.java\n      * (which is {@link Base64Variants#MIME_NO_LINEFEEDS}).\n      * \n      * @param data InputStream to use for reading binary data to write.\n-     *    Will be closed after successful write operation\n+     *    Will not be closed after successful write operation\n      * @param dataLength (optional) number of bytes that will be available;\n      *    or -1 to be indicate it is not known. Note that implementations\n      *    need not support cases where length is not known in advance; this\n      * \n      * @param b64variant Base64 variant to use\n      * @param data InputStream to use for reading binary data to write.\n-     *    Will be closed after successful write operation\n+     *    Will not be closed after successful write operation\n      * @param dataLength (optional) number of bytes that will be available;\n-     *    or -1 to be indicate it is not known. Note that implementations\n+     *    or -1 to be indicate it is not known.\n+     *    If a positive length is given, {@link data} MUST provide at least\n+     *    that many bytes: if not, an exception will be thrown.\n+     *    Note that implementations\n      *    need not support cases where length is not known in advance; this\n      *    depends on underlying data format: JSON output does NOT require length,\n-     *    other formats may\n+     *    other formats may.\n      * \n      * @return Number of bytes read from {@link data} and written as binary payload\n      * \n--- a/src/main/java/com/fasterxml/jackson/core/JsonParseException.java\n+++ b/src/main/java/com/fasterxml/jackson/core/JsonParseException.java\n public class JsonParseException\n     extends JsonProcessingException\n {\n+    @SuppressWarnings(\"hiding\")\n     final static long serialVersionUID = 123; // Stupid eclipse...\n \n     public JsonParseException(String msg, JsonLocation loc)\n--- a/src/main/java/com/fasterxml/jackson/core/base/GeneratorBase.java\n+++ b/src/main/java/com/fasterxml/jackson/core/base/GeneratorBase.java\n     /**********************************************************\n      */\n \n+    @Override\n     public void writeFieldName(SerializableString name) throws IOException, JsonGenerationException {\n         writeFieldName(name.getValue());\n     }\n--- a/src/main/java/com/fasterxml/jackson/core/json/UTF8JsonGenerator.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/UTF8JsonGenerator.java\n         byte[] encodingBuffer = _ioContext.allocBase64Buffer();\n         int bytes;\n         try {\n-            bytes = _writeBinary(b64variant, data, dataLength, encodingBuffer);\n+            if (dataLength < 0) { // length unknown\n+                bytes = _writeBinary(b64variant, data, encodingBuffer);\n+            } else {\n+                int missing = _writeBinary(b64variant, data, encodingBuffer, dataLength);\n+                if (missing > 0) {\n+                    _reportError(\"Too few bytes available: missing \"+missing+\" bytes (out of \"+dataLength+\")\");\n+                }\n+                bytes = dataLength;\n+            }\n         } finally {\n             _ioContext.releaseBase64Buffer(encodingBuffer);\n         }\n                  } else if (escape == CharacterEscapes.ESCAPE_CUSTOM) {\n                      SerializableString esc = customEscapes.getEscapeSequence(ch);\n                      if (esc == null) {\n-                         throw new JsonGenerationException(\"Invalid custom escape definitions; custom escape not found for character code 0x\"\n+                         _reportError(\"Invalid custom escape definitions; custom escape not found for character code 0x\"\n                                  +Integer.toHexString(ch)+\", although was supposed to have one\");\n                      }\n                      outputPtr = _writeCustomEscape(outputBuffer, outputPtr, esc, end-offset);\n         }\n     }\n \n+    // write-method called when length is definitely known\n     protected int _writeBinary(Base64Variant b64variant,\n-            InputStream data, int dataLength, byte[] encodingBuffer)\n-        throws IOException, JsonGenerationException\n-    {\n-        // Encoding is by chunks of 3 input, 4 output chars, so:\n-        int safeInputEnd = inputEnd - 3;\n+            InputStream data, byte[] readBuffer, int bytesLeft)\n+        throws IOException, JsonGenerationException\n+    {\n+        int inputPtr = 0;\n+        int inputEnd = 0;\n+        int lastFullOffset = -3;       \n+        \n         // Let's also reserve room for possible (and quoted) lf char each round\n         int safeOutputEnd = _outputEnd - 6;\n         int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n \n-        // Ok, first we loop through all full triplets of data:\n-        while (inputPtr <= safeInputEnd) {\n+        while (bytesLeft > 2) { // main loop for full triplets\n+            if (inputPtr > lastFullOffset) {\n+                inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n+                inputPtr = 0;\n+                if (inputEnd < 3) { // required to try to read to have at least 3 bytes\n+                    break;\n+                }\n+                lastFullOffset = inputEnd-3;\n+            }\n             if (_outputTail > safeOutputEnd) { // need to flush\n                 _flushBuffer();\n             }\n-            // First, mash 3 bytes into lsb of 32-bit int\n-            int b24 = ((int) input[inputPtr++]) << 8;\n-            b24 |= ((int) input[inputPtr++]) & 0xFF;\n-            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n+            int b24 = ((int) readBuffer[inputPtr++]) << 8;\n+            b24 |= ((int) readBuffer[inputPtr++]) & 0xFF;\n+            b24 = (b24 << 8) | (((int) readBuffer[inputPtr++]) & 0xFF);\n+            bytesLeft -= 3;\n             _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n             if (--chunksBeforeLF <= 0) {\n-                // note: must quote in JSON value\n                 _outputBuffer[_outputTail++] = '\\\\';\n                 _outputBuffer[_outputTail++] = 'n';\n                 chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n             }\n         }\n-\n+        \n         // And then we may have 1 or 2 leftover bytes to encode\n-        int inputLeft = inputEnd - inputPtr; // 0, 1 or 2\n-        if (inputLeft > 0) { // yes, but do we have room for output?\n+        if (bytesLeft > 0) {\n+            inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n+            inputPtr = 0;\n+            if (inputEnd > 0) { // yes, but do we have room for output?\n+                if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n+                    _flushBuffer();\n+                }\n+                int b24 = ((int) readBuffer[inputPtr++]) << 16;\n+                int amount;\n+                if (inputPtr < inputEnd) {\n+                    b24 |= (((int) readBuffer[inputPtr]) & 0xFF) << 8;\n+                    amount = 2;\n+                } else {\n+                    amount = 1;\n+                }\n+                _outputTail = b64variant.encodeBase64Partial(b24, amount, _outputBuffer, _outputTail);\n+                bytesLeft -= amount;\n+            }\n+        }\n+        return bytesLeft;\n+    }\n+\n+    // write method when length is unknown\n+    protected int _writeBinary(Base64Variant b64variant,\n+            InputStream data, byte[] readBuffer)\n+        throws IOException, JsonGenerationException\n+    {\n+        int inputPtr = 0;\n+        int inputEnd = 0;\n+        int lastFullOffset = -3;\n+        int bytesDone = 0;\n+        \n+        // Let's also reserve room for possible (and quoted) LF char each round\n+        int safeOutputEnd = _outputEnd - 6;\n+        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n+\n+        // Ok, first we loop through all full triplets of data:\n+        while (true) {\n+            if (inputPtr > lastFullOffset) { // need to load more\n+                inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, readBuffer.length);\n+                inputPtr = 0;\n+                if (inputEnd < 3) { // required to try to read to have at least 3 bytes\n+                    break;\n+                }\n+                lastFullOffset = inputEnd-3;\n+            }\n+            if (_outputTail > safeOutputEnd) { // need to flush\n+                _flushBuffer();\n+            }\n+            // First, mash 3 bytes into lsb of 32-bit int\n+            int b24 = ((int) readBuffer[inputPtr++]) << 8;\n+            b24 |= ((int) readBuffer[inputPtr++]) & 0xFF;\n+            b24 = (b24 << 8) | (((int) readBuffer[inputPtr++]) & 0xFF);\n+            bytesDone += 3;\n+            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n+            if (--chunksBeforeLF <= 0) {\n+                _outputBuffer[_outputTail++] = '\\\\';\n+                _outputBuffer[_outputTail++] = 'n';\n+                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n+            }\n+        }\n+\n+        // And then we may have 1 or 2 leftover bytes to encode\n+        if (inputPtr < inputEnd) { // yes, but do we have room for output?\n             if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n                 _flushBuffer();\n             }\n-            int b24 = ((int) input[inputPtr++]) << 16;\n-            if (inputLeft == 2) {\n-                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n-            }\n-            _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail);\n-        }\n-    }\n-\n+            int b24 = ((int) readBuffer[inputPtr++]) << 16;\n+            int amount = 1;\n+            if (inputPtr < inputEnd) {\n+                b24 |= (((int) readBuffer[inputPtr]) & 0xFF) << 8;\n+                amount = 2;\n+            }\n+            bytesDone += amount;\n+            _outputTail = b64variant.encodeBase64Partial(b24, amount, _outputBuffer, _outputTail);\n+        }\n+        return bytesDone;\n+    }\n+    \n+    private int _readMore(InputStream in,\n+            byte[] readBuffer, int inputPtr, int inputEnd,\n+            int maxRead) throws IOException\n+    {\n+        // anything to shift to front?\n+        int i = 0;\n+        while (inputPtr < inputEnd) {\n+            readBuffer[i++]  = readBuffer[inputPtr++];\n+        }\n+        inputPtr = 0;\n+        inputEnd = i;\n+        maxRead = Math.min(maxRead, readBuffer.length);\n+        \n+        do {\n+            int count = in.read(readBuffer, inputEnd, maxRead - inputEnd);\n+            if (count < 0) {\n+                return inputEnd;\n+            }\n+            inputEnd += count;\n+        } while (inputEnd < 3);\n+        return inputEnd;\n+    }\n+    \n     /*\n     /**********************************************************\n     /* Internal methods, character escapes/encoding\n--- a/src/main/java/com/fasterxml/jackson/core/json/WriterBasedJsonGenerator.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/WriterBasedJsonGenerator.java\n         _outputBuffer[_outputTail++] = '\"';\n     }\n \n+    @Override\n+    public int writeBinary(Base64Variant b64variant,\n+            InputStream data, int dataLength)\n+        throws IOException, JsonGenerationException\n+    {\n+        _verifyValueWrite(\"write binary value\");\n+        // Starting quotes\n+        if (_outputTail >= _outputEnd) {\n+            _flushBuffer();\n+        }\n+        _outputBuffer[_outputTail++] = '\"';\n+        byte[] encodingBuffer = _ioContext.allocBase64Buffer();\n+        int bytes;\n+        try {\n+            if (dataLength < 0) { // length unknown\n+                bytes = _writeBinary(b64variant, data, encodingBuffer);\n+            } else {\n+                int missing = _writeBinary(b64variant, data, encodingBuffer, dataLength);\n+                if (missing > 0) {\n+                    _reportError(\"Too few bytes available: missing \"+missing+\" bytes (out of \"+dataLength+\")\");\n+                }\n+                bytes = dataLength;\n+            }\n+        } finally {\n+            _ioContext.releaseBase64Buffer(encodingBuffer);\n+        }\n+        // and closing quotes\n+        if (_outputTail >= _outputEnd) {\n+            _flushBuffer();\n+        }\n+        _outputBuffer[_outputTail++] = '\"';\n+        return bytes;\n+    }\n+    \n     /*\n     /**********************************************************\n     /* Output method implementations, primitive\n         }\n     }\n \n+    // write-method called when length is definitely known\n+    protected int _writeBinary(Base64Variant b64variant,\n+            InputStream data, byte[] readBuffer, int bytesLeft)\n+        throws IOException, JsonGenerationException\n+    {\n+        int inputPtr = 0;\n+        int inputEnd = 0;\n+        int lastFullOffset = -3;       \n+        \n+        // Let's also reserve room for possible (and quoted) lf char each round\n+        int safeOutputEnd = _outputEnd - 6;\n+        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n+\n+        while (bytesLeft > 2) { // main loop for full triplets\n+            if (inputPtr > lastFullOffset) {\n+                inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n+                inputPtr = 0;\n+                if (inputEnd < 3) { // required to try to read to have at least 3 bytes\n+                    break;\n+                }\n+                lastFullOffset = inputEnd-3;\n+            }\n+            if (_outputTail > safeOutputEnd) { // need to flush\n+                _flushBuffer();\n+            }\n+            int b24 = ((int) readBuffer[inputPtr++]) << 8;\n+            b24 |= ((int) readBuffer[inputPtr++]) & 0xFF;\n+            b24 = (b24 << 8) | (((int) readBuffer[inputPtr++]) & 0xFF);\n+            bytesLeft -= 3;\n+            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n+            if (--chunksBeforeLF <= 0) {\n+                _outputBuffer[_outputTail++] = '\\\\';\n+                _outputBuffer[_outputTail++] = 'n';\n+                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n+            }\n+        }\n+        \n+        // And then we may have 1 or 2 leftover bytes to encode\n+        if (bytesLeft > 0) {\n+            inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, bytesLeft);\n+            inputPtr = 0;\n+            if (inputEnd > 0) { // yes, but do we have room for output?\n+                if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n+                    _flushBuffer();\n+                }\n+                int b24 = ((int) readBuffer[inputPtr++]) << 16;\n+                int amount;\n+                if (inputPtr < inputEnd) {\n+                    b24 |= (((int) readBuffer[inputPtr]) & 0xFF) << 8;\n+                    amount = 2;\n+                } else {\n+                    amount = 1;\n+                }\n+                _outputTail = b64variant.encodeBase64Partial(b24, amount, _outputBuffer, _outputTail);\n+                bytesLeft -= amount;\n+            }\n+        }\n+        return bytesLeft;\n+    }\n+    \n+    // write method when length is unknown\n+    protected int _writeBinary(Base64Variant b64variant,\n+            InputStream data, byte[] readBuffer)\n+        throws IOException, JsonGenerationException\n+    {\n+        int inputPtr = 0;\n+        int inputEnd = 0;\n+        int lastFullOffset = -3;\n+        int bytesDone = 0;\n+        \n+        // Let's also reserve room for possible (and quoted) LF char each round\n+        int safeOutputEnd = _outputEnd - 6;\n+        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n+\n+        // Ok, first we loop through all full triplets of data:\n+        while (true) {\n+            if (inputPtr > lastFullOffset) { // need to load more\n+                inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, readBuffer.length);\n+                inputPtr = 0;\n+                if (inputEnd < 3) { // required to try to read to have at least 3 bytes\n+                    break;\n+                }\n+                lastFullOffset = inputEnd-3;\n+            }\n+            if (_outputTail > safeOutputEnd) { // need to flush\n+                _flushBuffer();\n+            }\n+            // First, mash 3 bytes into lsb of 32-bit int\n+            int b24 = ((int) readBuffer[inputPtr++]) << 8;\n+            b24 |= ((int) readBuffer[inputPtr++]) & 0xFF;\n+            b24 = (b24 << 8) | (((int) readBuffer[inputPtr++]) & 0xFF);\n+            bytesDone += 3;\n+            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n+            if (--chunksBeforeLF <= 0) {\n+                _outputBuffer[_outputTail++] = '\\\\';\n+                _outputBuffer[_outputTail++] = 'n';\n+                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n+            }\n+        }\n+\n+        // And then we may have 1 or 2 leftover bytes to encode\n+        if (inputPtr < inputEnd) { // yes, but do we have room for output?\n+            if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n+                _flushBuffer();\n+            }\n+            int b24 = ((int) readBuffer[inputPtr++]) << 16;\n+            int amount = 1;\n+            if (inputPtr < inputEnd) {\n+                b24 |= (((int) readBuffer[inputPtr]) & 0xFF) << 8;\n+                amount = 2;\n+            }\n+            bytesDone += amount;\n+            _outputTail = b64variant.encodeBase64Partial(b24, amount, _outputBuffer, _outputTail);\n+        }\n+        return bytesDone;\n+    }\n+    \n+    private int _readMore(InputStream in,\n+            byte[] readBuffer, int inputPtr, int inputEnd,\n+            int maxRead) throws IOException\n+    {\n+        // anything to shift to front?\n+        int i = 0;\n+        while (inputPtr < inputEnd) {\n+            readBuffer[i++]  = readBuffer[inputPtr++];\n+        }\n+        inputPtr = 0;\n+        inputEnd = i;\n+        maxRead = Math.min(maxRead, readBuffer.length);\n+        \n+        do {\n+            int count = in.read(readBuffer, inputEnd, maxRead - inputEnd);\n+            if (count < 0) {\n+                return inputEnd;\n+            }\n+            inputEnd += count;\n+        } while (inputEnd < 3);\n+        return inputEnd;\n+    }\n+    \n     /*\n     /**********************************************************\n     /* Internal methods, low-level writing, other\n--- a/src/main/java/com/fasterxml/jackson/core/util/JsonGeneratorDelegate.java\n+++ b/src/main/java/com/fasterxml/jackson/core/util/JsonGeneratorDelegate.java\n     }\n \n     @Override\n-    public int writeBinary(Base64Variant b64variant, InputStream data)\n+    public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength)\n         throws IOException, JsonGenerationException {\n-        return delegate.writeBinary(b64variant, data);\n+        return delegate.writeBinary(b64variant, data, dataLength);\n     }\n     \n     @Override\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/core/json/TestBase64Generation.java\n+package com.fasterxml.jackson.core.json;\n+\n+import java.io.*;\n+\n+import com.fasterxml.jackson.core.*;\n+\n+public class TestBase64Generation\n+    extends com.fasterxml.jackson.test.BaseTest\n+{\n+    static class ThrottledInputStream extends FilterInputStream\n+    {\n+        protected final int _maxBytes;\n+\n+        public ThrottledInputStream(byte[] data, int maxBytes)\n+        {\n+            this(new ByteArrayInputStream(data), maxBytes);\n+        }\n+        \n+        public ThrottledInputStream(InputStream in, int maxBytes)\n+        {\n+            super(in);\n+            _maxBytes = maxBytes;\n+        }\n+\n+        @Override\n+        public int read(byte[] buf) throws IOException {\n+            return read(buf, 0, buf.length);\n+        }\n+        \n+        @Override\n+        public int read(byte[] buf, int offset, int len) throws IOException {\n+            return in.read(buf, offset, Math.min(_maxBytes, len));\n+        }\n+        \n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Test methods\n+    /**********************************************************\n+     */\n+\n+    public void testStreamingWrites() throws Exception\n+    {\n+        final JsonFactory f = new JsonFactory();\n+//        _testStreamingWrites(f, true);\n+        _testStreamingWrites(f, false);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Helper methods\n+    /**********************************************************\n+     */\n+\n+    private final static Base64Variant[] VARIANTS = {\n+            Base64Variants.MIME,\n+            Base64Variants.MIME_NO_LINEFEEDS,\n+            Base64Variants.MODIFIED_FOR_URL,\n+            Base64Variants.PEM\n+    };\n+\n+    private final static String TEXT = \"Some content so that we can test encoding of base64 data; must\"\n+            +\" be long enough include a line wrap or two...\";\n+    private final static String TEXT4 = TEXT + TEXT + TEXT + TEXT;\n+\n+    private void _testStreamingWrites(JsonFactory jf, boolean useBytes) throws Exception\n+    {\n+        final byte[] INPUT = TEXT4.getBytes(\"UTF-8\");\n+        for (Base64Variant variant : VARIANTS) {\n+            final String EXP_OUTPUT = \"[\" + quote(variant.encode(INPUT))+\"]\";\n+            for (boolean passLength : new boolean[] { true, false }) {\n+                for (int chunkSize : new int[] { 1, 2, 3, 4, 7, 11, 29, 5000 }) {\n+//System.err.println(\"\"+variant+\", length \"+passLength+\", chunk \"+chunkSize);\n+                    \n+                    JsonGenerator jgen;\n+                    \n+                    final ByteArrayOutputStream bytes = new ByteArrayOutputStream();\n+                    if (useBytes) {\n+                        jgen = jf.createJsonGenerator(bytes);\n+                    } else {\n+                        jgen = jf.createJsonGenerator(new OutputStreamWriter(bytes, \"UTF-8\"));\n+                    }\n+                    jgen.writeStartArray();\n+                    int length = passLength ? INPUT.length : -1;\n+                    InputStream data = new ThrottledInputStream(INPUT, chunkSize);\n+                    jgen.writeBinary(variant, data, length);\n+                    jgen.writeEndArray();\n+                    jgen.close();\n+                    String JSON = bytes.toString(\"UTF-8\");\n+                    assertEquals(EXP_OUTPUT, JSON);\n+                }\n+            }\n+        }\n+    }\n+}", "timestamp": 1339216230, "metainfo": ""}