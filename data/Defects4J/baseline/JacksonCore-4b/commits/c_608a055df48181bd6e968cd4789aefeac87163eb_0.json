{"sha": "608a055df48181bd6e968cd4789aefeac87163eb", "log": "trying to improve char-symbol handling", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java\n+++ b/src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java\n         \n         for (Bucket bucket : _buckets) {\n             if (bucket != null) {\n-                count += bucket.length();\n+                count += bucket.length;\n             }\n         }\n         return count;\n             // Let's inline primary String equality checking:\n             if (sym.length() == len) {\n                 int i = 0;\n-                do {\n+                while (true) {\n                     if (sym.charAt(i) != buffer[start+i]) {\n                         break;\n                     }\n-                } while (++i < len);\n-                // Optimal case; primary match found\n-                if (i == len) {\n-                    return sym;\n+                    // Optimal case; primary match found\n+                    if (++i == len) {\n+                        return sym;\n+                    }\n                 }\n             }\n-            // How about collision bucket?\n-            Bucket b = _buckets[index >> 1];\n+            return _findSymbol2(buffer, start, len, h, index);\n+        }\n+        return _addSymbol(buffer, start, len, h, index);\n+    }\n+\n+    private String _findSymbol2(char[] buffer, int start, int len, int h, int index) {\n+        // How about collision bucket?\n+        Bucket b = _buckets[index >> 1];\n+        if (b != null) {\n+            String sym = b.has(buffer, start, len);\n+            if (sym != null) {\n+                return sym;\n+            }\n+            b = b.next;\n             if (b != null) {\n-                sym = b.find(buffer, start, len);\n+                sym = b.has(buffer, start, len);\n                 if (sym != null) {\n                     return sym;\n                 }\n-            }\n-        }\n-\n+                while ((b = b.next) != null) {\n+                    sym = b.has(buffer, start, len);\n+                    if (sym != null) {\n+                        return sym;\n+                    }\n+                }\n+            }\n+        }\n+        return _addSymbol(buffer, start, len, h, index);\n+    }\n+    \n+    private String _addSymbol(char[] buffer, int start, int len, int h, int index)\n+    {\n         if (!_dirty) { //need to do copy-on-write?\n             copyArrays();\n             _dirty = true;\n             int bix = (index >> 1);\n             Bucket newB = new Bucket(newSymbol, _buckets[bix]);\n             _buckets[bix] = newB;\n-            _longestCollisionList = Math.max(newB.length(), _longestCollisionList);\n+            _longestCollisionList = Math.max(newB.length, _longestCollisionList);\n             if (_longestCollisionList > MAX_COLL_CHAIN_LENGTH) {\n                 reportTooManyCollisions(MAX_COLL_CHAIN_LENGTH);\n             }\n                     int bix = (index >> 1);\n                     Bucket newB = new Bucket(symbol, _buckets[bix]);\n                     _buckets[bix] = newB;\n-                    maxColl = Math.max(maxColl, newB.length());\n+                    maxColl = Math.max(maxColl, newB.length);\n                 }\n             }\n         }\n             Bucket b = oldBuckets[i];\n             while (b != null) {\n                 ++count;\n-                String symbol = b.getSymbol();\n+                String symbol = b.symbol;\n                 int index = _hashToIndex(calcHash(symbol));\n                 if (_symbols[index] == null) {\n                     _symbols[index] = symbol;\n                     int bix = (index >> 1);\n                     Bucket newB = new Bucket(symbol, _buckets[bix]);\n                     _buckets[bix] = newB;\n-                    maxColl = Math.max(maxColl, newB.length());\n+                    maxColl = Math.max(maxColl, newB.length);\n                 }\n-                b = b.getNext();\n+                b = b.next;\n             }\n         }\n         _longestCollisionList = maxColl;\n      */\n     static final class Bucket\n     {\n-        private final String _symbol;\n-        private final Bucket _next;\n-        private final int _length;\n-\n-        public Bucket(String symbol, Bucket next) {\n-            _symbol = symbol;\n-            _next = next;\n-            _length = (next == null) ? 1 : next._length+1;\n-        }\n-\n-        public String getSymbol() { return _symbol; }\n-        public Bucket getNext() { return _next; }\n-        public int length() { return _length; }\n-\n+        private final String symbol;\n+        private final Bucket next;\n+        private final int length;\n+\n+        public Bucket(String s, Bucket n) {\n+            symbol = s;\n+            next = n;\n+            length = (n == null) ? 1 : n.length+1;\n+        }\n+\n+        public String has(char[] buf, int start, int len) {\n+            if (symbol.length() != len) {\n+                return null;\n+            }\n+            int i = 0;\n+            do {\n+                if (symbol.charAt(i) != buf[start+i]) {\n+                    return null;\n+                }\n+            } while (++i < len);\n+            return symbol;\n+        }\n+\n+        /*\n         public String find(char[] buf, int start, int len) {\n-            String sym = _symbol;\n-            Bucket b = _next;\n+            String sym = symbol;\n+            Bucket b = next;\n \n             while (true) { // Inlined equality comparison:\n                 if (sym.length() == len) {\n                 if (b == null) {\n                     break;\n                 }\n-                sym = b.getSymbol();\n-                b = b.getNext();\n+                sym = b.symbol;\n+                b = b.next;\n             }\n             return null;\n         }\n+        */\n     }\n }", "timestamp": 1398049190, "metainfo": ""}