{"sha": "4983fd1c21df0b132c5dde2643fa9569bb43a943", "log": "split positive/negative number cases", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java\n \n         switch (i) {\n         case '-':\n+            t = _parseNegNumber();\n+            break;\n+\n             /* Should we have separate handling for plus? Although\n              * it is not allowed per se, it may be erroneously used,\n              * and could be indicate by a more specific error message.\n         case '7':\n         case '8':\n         case '9':\n-            t = _parseNumber(i);\n+            t = _parsePosNumber(i);\n             break;\n         case 'f':\n             _matchToken(\"false\", 1);\n             _matchToken(\"null\", 1);\n             return (_currToken = JsonToken.VALUE_NULL);\n         case '-':\n+            return (_currToken = _parseNegNumber());\n             /* Should we have separate handling for plus? Although\n              * it is not allowed per se, it may be erroneously used,\n              * and could be indicated by a more specific error message.\n         case '7':\n         case '8':\n         case '9':\n-            return (_currToken = _parseNumber(i));\n+            return (_currToken = _parsePosNumber(i));\n         }\n         return (_currToken = _handleUnexpectedValue(i));\n     }\n             _nextToken = JsonToken.VALUE_NULL;\n             return;\n         case '-':\n+            _nextToken = _parseNegNumber();\n+            return;\n         case '0':\n         case '1':\n         case '2':\n         case '7':\n         case '8':\n         case '9':\n-            _nextToken = _parseNumber(i);\n+            _nextToken = _parsePosNumber(i);\n             return;\n         }\n         _nextToken = _handleUnexpectedValue(i);\n             _matchToken(\"null\", 1);\n             t = JsonToken.VALUE_NULL;\n             break;\n-\n         case '-':\n+            t = _parseNegNumber();\n+            break;\n         case '0':\n         case '1':\n         case '2':\n         case '7':\n         case '8':\n         case '9':\n-\n-            t = _parseNumber(i);\n+            t = _parsePosNumber(i);\n             break;\n         default:\n             t = _handleUnexpectedValue(i);\n      * deferred, since it is usually the most complicated and costliest\n      * part of processing.\n      */\n-    protected JsonToken _parseNumber(int c) throws IOException\n+    protected JsonToken _parsePosNumber(int c) throws IOException\n     {\n         char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n         int outPtr = 0;\n-        boolean negative = (c == INT_MINUS);\n-\n-        // Need to prepend sign?\n-        if (negative) {\n-            outBuf[outPtr++] = '-';\n-            // Must have something after sign too\n-            if (_inputPtr >= _inputEnd) {\n-                loadMoreGuaranteed();\n-            }\n-            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n-            // Note: must be followed by a digit\n-            if (c < INT_0 || c > INT_9) {\n-                return _handleInvalidNumberStart(c, true);\n-            }\n-        }\n-\n         // One special case: if first char is 0, must not be followed by a digit\n         if (c == INT_0) {\n             c = _verifyNoLeadingZeroes();\n         }\n-        \n         // Ok: we can first just add digit we saw first:\n         outBuf[outPtr++] = (char) c;\n         int intLen = 1;\n-\n         // And then figure out how far we can read without further checks\n         // for either input or output\n         int end = _inputPtr + outBuf.length;\n         if (end > _inputEnd) {\n             end = _inputEnd;\n         }\n+        // With this, we have a nice and tight loop:\n+        while (true) {\n+            if (_inputPtr >= end) { // split across boundary, offline\n+                return _parseNumber2(outBuf, outPtr, false, intLen);\n+            }\n+            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n+            if (c < INT_0 || c > INT_9) {\n+                break;\n+            }\n+            ++intLen;\n+            outBuf[outPtr++] = (char) c;\n+        }\n+        if (c == '.' || c == 'e' || c == 'E') {\n+            return _parseFloat(outBuf, outPtr, c, false, intLen);\n+        }\n+        --_inputPtr; // to push back trailing char (comma etc)\n+        _textBuffer.setCurrentLength(outPtr);\n+        // As per #105, need separating space between root values; check here\n+        if (_parsingContext.inRoot()) {\n+            _verifyRootSpace(c);\n+        }\n+        // And there we have it!\n+        return resetInt(false, intLen);\n+    }\n+    \n+    protected JsonToken _parseNegNumber() throws IOException\n+    {\n+        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n+        int outPtr = 0;\n+\n+        // Need to prepend sign?\n+        outBuf[outPtr++] = '-';\n+        // Must have something after sign too\n+        if (_inputPtr >= _inputEnd) {\n+            loadMoreGuaranteed();\n+        }\n+        int c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n+        // Note: must be followed by a digit\n+        if (c < INT_0 || c > INT_9) {\n+            return _handleInvalidNumberStart(c, true);\n+        }\n+\n+        // One special case: if first char is 0, must not be followed by a digit\n+        if (c == INT_0) {\n+            c = _verifyNoLeadingZeroes();\n+        }\n+        \n+        // Ok: we can first just add digit we saw first:\n+        outBuf[outPtr++] = (char) c;\n+        int intLen = 1;\n+\n+        // And then figure out how far we can read without further checks\n+        // for either input or output\n+        int end = _inputPtr + outBuf.length;\n+        if (end > _inputEnd) {\n+            end = _inputEnd;\n+        }\n \n         // With this, we have a nice and tight loop:\n         while (true) {\n             if (_inputPtr >= end) {\n                 // Long enough to be split across boundary, so:\n-                return _parseNumber2(outBuf, outPtr, negative, intLen);\n+                return _parseNumber2(outBuf, outPtr, true, intLen);\n             }\n             c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n             if (c < INT_0 || c > INT_9) {\n             outBuf[outPtr++] = (char) c;\n         }\n         if (c == '.' || c == 'e' || c == 'E') {\n-            return _parseFloat(outBuf, outPtr, c, negative, intLen);\n+            return _parseFloat(outBuf, outPtr, c, true, intLen);\n         }\n         \n         --_inputPtr; // to push back trailing char (comma etc)\n         }\n \n         // And there we have it!\n-        return resetInt(negative, intLen);\n-    }\n-    \n+        return resetInt(true, intLen);\n+    }\n+\n     /**\n      * Method called to handle parsing when input is split across buffer boundary\n      * (or output is longer than segment used to store it)", "timestamp": 1399094415, "metainfo": ""}