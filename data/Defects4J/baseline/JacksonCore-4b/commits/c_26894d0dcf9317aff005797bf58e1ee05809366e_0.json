{"sha": "26894d0dcf9317aff005797bf58e1ee05809366e", "log": "Merge addition of Base64Variant.decode() from 2.2.3", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/core/Base64Variant.java\n+++ b/src/main/java/com/fasterxml/jackson/core/Base64Variant.java\n package com.fasterxml.jackson.core;\n \n import java.util.Arrays;\n+\n+import com.fasterxml.jackson.core.util.ByteArrayBuilder;\n \n /**\n  * Abstract base class used to define specific details of which\n public final class Base64Variant\n     implements java.io.Serializable\n {\n+    private final static int INT_SPACE = 0x20;\n+    \n     // We'll only serialize name\n     private static final long serialVersionUID = 1L;\n \n         return outPtr;\n     }\n \n+    /*\n+    /**********************************************************\n+    /* Convenience conversion methods for String to/from bytes\n+    /* use case.\n+    /**********************************************************\n+     */\n+    \n     /**\n      * Convenience method for converting given byte array as base64 encoded\n      * String using this variant's settings.\n     }\n \n     /**\n-     * Convenience method for converting given byte array as base64 encoded\n-     * String using this variant's settings, optionally enclosed in\n-     * double-quotes.\n+     * Convenience method for converting given byte array as base64 encoded String\n+     * using this variant's settings,\n+     * optionally enclosed in double-quotes.\n      * \n      * @param input Byte array to encode\n      * @param addQuotes Whether to surround resulting value in double quotes or not\n         }\n         return sb.toString();\n     }\n-    \n-    /*\n-    /**********************************************************\n-    /* other methods\n+\n+    /**\n+     * Convenience method for decoding contents of a Base64-encoded String,\n+     * using this variant's settings.\n+     * \n+     * @param input\n+     * \n+     * @since 2.2.3\n+     *\n+     * @throws IllegalArgumentException if input is not valid base64 encoded data\n+     */\n+    public byte[] decode(String input) throws IllegalArgumentException\n+    {\n+        ByteArrayBuilder b = new ByteArrayBuilder();\n+        decode(input, b);\n+        return b.toByteArray();\n+    }\n+\n+    /**\n+     * Convenience method for decoding contents of a Base64-encoded String,\n+     * using this variant's settings\n+     * and appending decoded binary data using provided {@link ByteArrayBuilder}.\n+     *<p>\n+     * NOTE: builder will NOT be reset before decoding (nor cleared afterwards);\n+     * assumption is that caller will ensure it is given in proper state, and\n+     * used as appropriate afterwards.\n+     * \n+     * @since 2.2.3\n+     *\n+     * @throws IllegalArgumentException if input is not valid base64 encoded data\n+     */\n+    public void decode(String str, ByteArrayBuilder builder) throws IllegalArgumentException\n+    {\n+        int ptr = 0;\n+        int len = str.length();\n+        \n+        main_loop:\n+        while (ptr < len) {\n+            // first, we'll skip preceding white space, if any\n+            char ch;\n+            do {\n+                ch = str.charAt(ptr++);\n+                if (ptr >= len) {\n+                    break main_loop;\n+                }\n+            } while (ch <= INT_SPACE);\n+            int bits = decodeBase64Char(ch);\n+            if (bits < 0) {\n+                _reportInvalidBase64(ch, 0, null);\n+            }\n+            int decodedData = bits;\n+            // then second base64 char; can't get padding yet, nor ws\n+            if (ptr >= len) {\n+                _reportBase64EOF();\n+            }\n+            ch = str.charAt(ptr++);\n+            bits = decodeBase64Char(ch);\n+            if (bits < 0) {\n+                _reportInvalidBase64(ch, 1, null);\n+            }\n+            decodedData = (decodedData << 6) | bits;\n+            // third base64 char; can be padding, but not ws\n+            if (ptr >= len) {\n+                // but as per [JACKSON-631] can be end-of-input, iff not using padding\n+                if (!usesPadding()) {\n+                    decodedData >>= 4;\n+                    builder.append(decodedData);\n+                    break;\n+                }\n+                _reportBase64EOF();\n+            }\n+            ch = str.charAt(ptr++);\n+            bits = decodeBase64Char(ch);\n+            \n+            // First branch: can get padding (-> 1 byte)\n+            if (bits < 0) {\n+                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n+                    _reportInvalidBase64(ch, 2, null);\n+                }\n+                // Ok, must get padding\n+                if (ptr >= len) {\n+                    _reportBase64EOF();\n+                }\n+                ch = str.charAt(ptr++);\n+                if (!usesPaddingChar(ch)) {\n+                    _reportInvalidBase64(ch, 3, \"expected padding character '\"+getPaddingChar()+\"'\");\n+                }\n+                // Got 12 bits, only need 8, need to shift\n+                decodedData >>= 4;\n+                builder.append(decodedData);\n+                continue;\n+            }\n+            // Nope, 2 or 3 bytes\n+            decodedData = (decodedData << 6) | bits;\n+            // fourth and last base64 char; can be padding, but not ws\n+            if (ptr >= len) {\n+                // but as per [JACKSON-631] can be end-of-input, iff not using padding\n+                if (!usesPadding()) {\n+                    decodedData >>= 2;\n+                    builder.appendTwoBytes(decodedData);\n+                    break;\n+                }\n+                _reportBase64EOF();\n+            }\n+            ch = str.charAt(ptr++);\n+            bits = decodeBase64Char(ch);\n+            if (bits < 0) {\n+                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n+                    _reportInvalidBase64(ch, 3, null);\n+                }\n+                decodedData >>= 2;\n+                builder.appendTwoBytes(decodedData);\n+            } else {\n+                // otherwise, our triple is now complete\n+                decodedData = (decodedData << 6) | bits;\n+                builder.appendThreeBytes(decodedData);\n+            }\n+        }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Overridden standard methods\n     /**********************************************************\n      */\n \n     @Override\n     public String toString() { return _name; }\n+    \n+    @Override\n+    public boolean equals(Object o) {\n+        // identity comparison should be dine\n+        return (o == this);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return _name.hashCode();\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Internal helper methods\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * @param bindex Relative index within base64 character unit; between 0\n+     *   and 3 (as unit has exactly 4 characters)\n+     */\n+    protected void _reportInvalidBase64(char ch, int bindex, String msg)\n+        throws IllegalArgumentException\n+    {\n+        String base;\n+        if (ch <= INT_SPACE) {\n+            base = \"Illegal white space character (code 0x\"+Integer.toHexString(ch)+\") as character #\"+(bindex+1)+\" of 4-char base64 unit: can only used between units\";\n+        } else if (usesPaddingChar(ch)) {\n+            base = \"Unexpected padding character ('\"+getPaddingChar()+\"') as character #\"+(bindex+1)+\" of 4-char base64 unit: padding only legal as 3rd or 4th character\";\n+        } else if (!Character.isDefined(ch) || Character.isISOControl(ch)) {\n+            // Not sure if we can really get here... ? (most illegal xml chars are caught at lower level)\n+            base = \"Illegal character (code 0x\"+Integer.toHexString(ch)+\") in base64 content\";\n+        } else {\n+            base = \"Illegal character '\"+ch+\"' (code 0x\"+Integer.toHexString(ch)+\") in base64 content\";\n+        }\n+        if (msg != null) {\n+            base = base + \": \" + msg;\n+        }\n+        throw new IllegalArgumentException(base);\n+    }\n+\n+    protected void _reportBase64EOF() throws IllegalArgumentException {\n+        throw new IllegalArgumentException(\"Unexpected end-of-String in base64 content\");\n+    }\n }\n \n--- a/src/main/java/com/fasterxml/jackson/core/base/ParserMinimalBase.java\n+++ b/src/main/java/com/fasterxml/jackson/core/base/ParserMinimalBase.java\n         return t;\n     }\n \n+    @SuppressWarnings(\"incomplete-switch\")\n     @Override\n     public JsonParser skipChildren() throws IOException, JsonParseException\n     {\n     /**********************************************************\n      */\n \n+    @SuppressWarnings(\"incomplete-switch\")\n     @Override\n     public boolean getValueAsBoolean(boolean defaultValue) throws IOException, JsonParseException\n     {\n         return defaultValue;\n     }\n     \n+    @SuppressWarnings(\"incomplete-switch\")\n     @Override\n     public int getValueAsInt(int defaultValue) throws IOException, JsonParseException\n     {\n                         return ((Number) value).longValue();\n                     }\n                 }\n+            default:\n             }\n         }\n         return defaultValue;\n     }\n \n+    @SuppressWarnings(\"incomplete-switch\")\n     @Override\n     public double getValueAsDouble(double defaultValue) throws IOException, JsonParseException\n     {\n     protected void _decodeBase64(String str, ByteArrayBuilder builder, Base64Variant b64variant)\n         throws IOException, JsonParseException\n     {\n-        int ptr = 0;\n-        int len = str.length();\n-        \n-        main_loop:\n-        while (ptr < len) {\n-            // first, we'll skip preceding white space, if any\n-            char ch;\n-            do {\n-                ch = str.charAt(ptr++);\n-                if (ptr >= len) {\n-                    break main_loop;\n-                }\n-            } while (ch <= INT_SPACE);\n-            int bits = b64variant.decodeBase64Char(ch);\n-            if (bits < 0) {\n-                _reportInvalidBase64(b64variant, ch, 0, null);\n-            }\n-            int decodedData = bits;\n-            // then second base64 char; can't get padding yet, nor ws\n-            if (ptr >= len) {\n-                _reportBase64EOF();\n-            }\n-            ch = str.charAt(ptr++);\n-            bits = b64variant.decodeBase64Char(ch);\n-            if (bits < 0) {\n-                _reportInvalidBase64(b64variant, ch, 1, null);\n-            }\n-            decodedData = (decodedData << 6) | bits;\n-            // third base64 char; can be padding, but not ws\n-            if (ptr >= len) {\n-                // but as per [JACKSON-631] can be end-of-input, iff not using padding\n-                if (!b64variant.usesPadding()) {\n-                    decodedData >>= 4;\n-                    builder.append(decodedData);\n-                    break;\n-                }\n-                _reportBase64EOF();\n-            }\n-            ch = str.charAt(ptr++);\n-            bits = b64variant.decodeBase64Char(ch);\n-            \n-            // First branch: can get padding (-> 1 byte)\n-            if (bits < 0) {\n-                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n-                    _reportInvalidBase64(b64variant, ch, 2, null);\n-                }\n-                // Ok, must get padding\n-                if (ptr >= len) {\n-                    _reportBase64EOF();\n-                }\n-                ch = str.charAt(ptr++);\n-                if (!b64variant.usesPaddingChar(ch)) {\n-                    _reportInvalidBase64(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n-                }\n-                // Got 12 bits, only need 8, need to shift\n-                decodedData >>= 4;\n-                builder.append(decodedData);\n-                continue;\n-            }\n-            // Nope, 2 or 3 bytes\n-            decodedData = (decodedData << 6) | bits;\n-            // fourth and last base64 char; can be padding, but not ws\n-            if (ptr >= len) {\n-                // but as per [JACKSON-631] can be end-of-input, iff not using padding\n-                if (!b64variant.usesPadding()) {\n-                    decodedData >>= 2;\n-                    builder.appendTwoBytes(decodedData);\n-                    break;\n-                }\n-                _reportBase64EOF();\n-            }\n-            ch = str.charAt(ptr++);\n-            bits = b64variant.decodeBase64Char(ch);\n-            if (bits < 0) {\n-                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n-                    _reportInvalidBase64(b64variant, ch, 3, null);\n-                }\n-                decodedData >>= 2;\n-                builder.appendTwoBytes(decodedData);\n-            } else {\n-                // otherwise, our triple is now complete\n-                decodedData = (decodedData << 6) | bits;\n-                builder.appendThreeBytes(decodedData);\n-            }\n+        // just call helper method introduced in 2.2.3\n+        try {\n+            b64variant.decode(str, builder);\n+        } catch (IllegalArgumentException e) {\n+            _reportError(e.getMessage());\n         }\n     }\n \n     /**\n      * @param bindex Relative index within base64 character unit; between 0\n      *   and 3 (as unit has exactly 4 characters)\n-     */\n+     *   \n+     * @deprecated in 2.2.3; should migrate away\n+     */\n+    @Deprecated\n     protected void _reportInvalidBase64(Base64Variant b64variant, char ch, int bindex, String msg)\n         throws JsonParseException\n     {\n         throw _constructError(base);\n     }\n \n+    /**\n+     *   \n+     * @deprecated in 2.2.3; should migrate away\n+     */\n+    @Deprecated\n     protected void _reportBase64EOF() throws JsonParseException {\n         throw _constructError(\"Unexpected end-of-String in base64 content\");\n     }\n-    \n     \n     /*\n     /**********************************************************", "timestamp": 1372809805, "metainfo": ""}