{"sha": "0c8d86eab3670535dfcb5ad4d80f090f001aca14", "log": "minor addition to TextBuffer", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java\n+++ b/src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java\n     /**********************************************************\n      */\n \n-    public TextBuffer(BufferRecycler allocator)\n-    {\n+    public TextBuffer(BufferRecycler allocator) {\n         _allocator = allocator;\n     }\n \n         if (_hasSegments) {\n             clearSegments();\n         } else if (_currentSegment == null) {\n-            _currentSegment = findBuffer(len);\n+            _currentSegment = buf(len);\n         }\n         _currentSize = _segmentSize = 0;\n         append(buf, start, len);\n      * Helper method used to find a buffer to use, ideally one\n      * recycled earlier.\n      */\n-    private char[] findBuffer(int needed)\n+    private char[] buf(int needed)\n     {\n         if (_allocator != null) {\n             return _allocator.allocCharBuffer(BufferRecycler.CHAR_TEXT_BUFFER, needed);\n         return _segmentSize + _currentSize;\n     }\n \n-    public int getTextOffset()\n-    {\n+    public int getTextOffset() {\n         /* Only shared input buffer can have non-zero offset; buffer\n          * segments start at 0, and if we have to create a combo buffer,\n          * that too will start from beginning of the buffer\n     public boolean hasTextAsCharacters()\n     {\n         // if we have array in some form, sure\n-        if (_inputStart >= 0 || _resultArray != null) {\n-            return true;\n-        }\n+        if (_inputStart >= 0 || _resultArray != null)  return true;\n         // not if we have String as value\n-        if (_resultString != null) {\n-            return false;\n-        }\n+        if (_resultString != null) return false;\n         return true;\n     }\n     \n     public char[] getTextBuffer()\n     {\n         // Are we just using shared input buffer?\n-        if (_inputStart >= 0) {\n-            return _inputBuffer;\n-        }\n-        if (_resultArray != null) {\n-            return _resultArray;\n-        }\n+        if (_inputStart >= 0) return _inputBuffer;\n+        if (_resultArray != null)  return _resultArray;\n         if (_resultString != null) {\n             return (_resultArray = _resultString.toCharArray());\n         }\n         // Nope; but does it fit in just one segment?\n-        if (!_hasSegments) {\n-            return _currentSegment;\n-        }\n+        if (!_hasSegments)  return _currentSegment;\n         // Nope, need to have/create a non-segmented array and return it\n         return contentsAsArray();\n     }\n         return _resultString;\n     }\n  \n-    public char[] contentsAsArray()\n-    {\n+    public char[] contentsAsArray() {\n         char[] result = _resultArray;\n         if (result == null) {\n-            _resultArray = result = buildResultArray();\n+            _resultArray = result = resultArray();\n         }\n         return result;\n     }\n      * Convenience method for converting contents of the buffer\n      * into a {@link BigDecimal}.\n      */\n-    public BigDecimal contentsAsDecimal()\n-        throws NumberFormatException\n+    public BigDecimal contentsAsDecimal() throws NumberFormatException\n     {\n         // Already got a pre-cut array?\n         if (_resultArray != null) {\n         } else {\n             char[] curr = _currentSegment;\n             if (curr == null) {\n-                _currentSegment = findBuffer(0);\n+                _currentSegment = buf(0);\n             } else if (_currentSize >= curr.length) {\n                 // Plus, we better have room for at least one more char\n                 expand(1);\n         }\n         char[] curr = _currentSegment;\n         if (curr == null) {\n-            _currentSegment = curr = findBuffer(0);\n+            _currentSegment = curr = buf(0);\n         }\n         return curr;\n     }\n         _segmentSize += oldLen;\n         // Let's grow segments by 50%\n         int newLen = Math.min(oldLen + (oldLen >> 1), MAX_SEGMENT_LEN);\n-        char[] curr = _charArray(newLen);\n+        char[] curr = carr(newLen);\n         _currentSize = 0;\n         _currentSegment = curr;\n         return curr;\n         // Let's grow by 50%\n         final int len = curr.length;\n         // Must grow by at least 1 char, no matter what\n-        int newLen = (len == MAX_SEGMENT_LEN) ?\n-            (MAX_SEGMENT_LEN + 1) : Math.min(MAX_SEGMENT_LEN, len + (len >> 1));\n+        int newLen = (len == MAX_SEGMENT_LEN) ? (MAX_SEGMENT_LEN+1) : Math.min(MAX_SEGMENT_LEN, len + (len >> 1));\n         return (_currentSegment = Arrays.copyOf(curr, newLen));\n+    }\n+\n+    /**\n+     * Method called to expand size of the current segment, to\n+     * accommodate for more contiguous content. Usually only\n+     * used when parsing tokens like names if even then.\n+     * \n+     * @param minSize Required minimum strength of the current segment\n+     *\n+     * @since 2.4.0\n+     */\n+    public char[] expandCurrentSegment(int minSize) {\n+        char[] curr = _currentSegment;\n+        if (curr.length >= minSize) return curr;\n+        _currentSegment = curr = Arrays.copyOf(curr, minSize);\n+        return curr;\n     }\n \n     /*\n         // Is buffer big enough, or do we need to reallocate?\n         int needed = sharedLen+needExtra;\n         if (_currentSegment == null || needed > _currentSegment.length) {\n-            _currentSegment = findBuffer(needed);\n+            _currentSegment = buf(needed);\n         }\n         if (sharedLen > 0) {\n             System.arraycopy(inputBuf, start, _currentSegment, 0, sharedLen);\n             sizeAddition = minNewSegmentSize;\n         }\n         _currentSize = 0;\n-        _currentSegment = _charArray(Math.min(MAX_SEGMENT_LEN, oldLen + sizeAddition));\n-    }\n-\n-    private char[] buildResultArray()\n+        _currentSegment = carr(Math.min(MAX_SEGMENT_LEN, oldLen + sizeAddition));\n+    }\n+\n+    private char[] resultArray()\n     {\n         if (_resultString != null) { // Can take a shortcut...\n             return _resultString.toCharArray();\n             return NO_CHARS;\n         }\n         int offset = 0;\n-        final char[] result = _charArray(size);\n+        final char[] result = carr(size);\n         if (_segments != null) {\n             for (int i = 0, len = _segments.size(); i < len; ++i) {\n                 char[] curr = (char[]) _segments.get(i);\n         return result;\n     }\n \n-    private char[] _charArray(int len) { return new char[len]; }\n+    private char[] carr(int len) { return new char[len]; }\n }", "timestamp": 1390188521, "metainfo": ""}