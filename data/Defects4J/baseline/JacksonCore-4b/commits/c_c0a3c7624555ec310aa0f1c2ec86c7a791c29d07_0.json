{"sha": "c0a3c7624555ec310aa0f1c2ec86c7a791c29d07", "log": "Trim some more constants", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/core/base/ParserBase.java\n+++ b/src/main/java/com/fasterxml/jackson/core/base/ParserBase.java\n \n     // Digits, numeric\n     final protected static int INT_0 = '0';\n-    final protected static int INT_1 = '1';\n-    final protected static int INT_2 = '2';\n-    final protected static int INT_3 = '3';\n-    final protected static int INT_4 = '4';\n-    final protected static int INT_5 = '5';\n-    final protected static int INT_6 = '6';\n-    final protected static int INT_7 = '7';\n-    final protected static int INT_8 = '8';\n     final protected static int INT_9 = '9';\n \n     final protected static int INT_MINUS = '-';\n--- a/src/main/java/com/fasterxml/jackson/core/base/ParserMinimalBase.java\n+++ b/src/main/java/com/fasterxml/jackson/core/base/ParserMinimalBase.java\n     protected final static int INT_SLASH = '/';\n     protected final static int INT_COLON = ':';\n     protected final static int INT_COMMA = ',';\n-    protected final static int INT_ASTERISK = '*';\n-    protected final static int INT_APOSTROPHE = '\\'';\n-\n-    // Letters we need\n-    protected final static int INT_b = 'b';\n-    protected final static int INT_f = 'f';\n-    protected final static int INT_n = 'n';\n-    protected final static int INT_r = 'r';\n-    protected final static int INT_t = 't';\n-    protected final static int INT_u = 'u';\n \n     /*\n     /**********************************************************\n--- a/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java\n         JsonToken t;\n \n         switch (i) {\n-        case INT_QUOTE:\n+        case '\"':\n             _tokenIncomplete = true;\n             t = JsonToken.VALUE_STRING;\n             break;\n-        case INT_LBRACKET:\n+        case '[':\n             if (!inObject) {\n                 _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n             }\n             t = JsonToken.START_ARRAY;\n             break;\n-        case INT_LCURLY:\n+        case '{':\n             if (!inObject) {\n                 _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n             }\n             t = JsonToken.START_OBJECT;\n             break;\n-        case INT_RBRACKET:\n-        case INT_RCURLY:\n+        case ']':\n+        case '}':\n             // Error: neither is valid at this point; valid closers have\n             // been handled earlier\n             _reportUnexpectedChar(i, \"expected a value\");\n-        case INT_t:\n+        case 't':\n             _matchToken(\"true\", 1);\n             t = JsonToken.VALUE_TRUE;\n             break;\n-        case INT_f:\n+        case 'f':\n             _matchToken(\"false\", 1);\n             t = JsonToken.VALUE_FALSE;\n             break;\n-        case INT_n:\n+        case 'n':\n             _matchToken(\"null\", 1);\n             t = JsonToken.VALUE_NULL;\n             break;\n \n-        case INT_MINUS:\n+        case '-':\n             /* Should we have separate handling for plus? Although\n              * it is not allowed per se, it may be erroneously used,\n              * and could be indicate by a more specific error message.\n              */\n-        case INT_0:\n-        case INT_1:\n-        case INT_2:\n-        case INT_3:\n-        case INT_4:\n-        case INT_5:\n-        case INT_6:\n-        case INT_7:\n-        case INT_8:\n-        case INT_9:\n+        case '0':\n+        case '1':\n+        case '2':\n+        case '3':\n+        case '4':\n+        case '5':\n+        case '6':\n+        case '7':\n+        case '8':\n+        case '9':\n+\n             t = parseNumberText(i);\n             break;\n         default:\n         throws IOException, JsonParseException\n     {\n         // [JACKSON-173]: allow single quotes\n-        if (i == INT_APOSTROPHE && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\n+        if (i == '\\'' && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\n             return _parseApostropheFieldName();\n         }\n         // [JACKSON-69]: allow unquoted names if feature enabled:\n         int start = _inputPtr;\n         _inputPtr = ptr;\n \n-        return _parseFieldName2(start, hash, INT_APOSTROPHE);\n+        return _parseFieldName2(start, hash, '\\'');\n     }\n \n     /**\n             }\n             char c = _inputBuffer[_inputPtr++];\n             int i = (int) c;\n-            if (i <= INT_BACKSLASH) {\n-                if (i == INT_BACKSLASH) {\n+            if (i <= '\\'') {\n+                if (i == '\\'') {\n                     /* Although chars outside of BMP are to be escaped as\n                      * an UTF-16 surrogate pair, does that affect decoding?\n                      * For now let's assume it does not.\n                      */\n                     c = _decodeEscaped();\n-                } else if (i <= INT_APOSTROPHE) {\n-                    if (i == INT_APOSTROPHE) {\n+                } else if (i <= '\\'') {\n+                    if (i == '\\'') {\n                         break;\n                     }\n                     if (i < INT_SPACE) {\n         main_loop:\n         while ((_inputPtr < _inputEnd) || loadMore()) {\n             int i = (int) _inputBuffer[_inputPtr++];\n-            if (i <= INT_ASTERISK) {\n-                if (i == INT_ASTERISK) { // end?\n+            if (i <= '*') {\n+                if (i == '*') { // end?\n                     if ((_inputPtr >= _inputEnd) && !loadMore()) {\n                         break main_loop;\n                     }\n \n         switch ((int) c) {\n             // First, ones that are mapped\n-        case INT_b:\n+        case 'b':\n             return '\\b';\n-        case INT_t:\n+        case 't':\n             return '\\t';\n-        case INT_n:\n+        case 'n':\n             return '\\n';\n-        case INT_f:\n+        case 'f':\n             return '\\f';\n-        case INT_r:\n+        case 'r':\n             return '\\r';\n \n             // And these are to be returned as they are\n-        case INT_QUOTE:\n-        case INT_SLASH:\n-        case INT_BACKSLASH:\n+        case '\"':\n+        case '/':\n+        case '\\\\':\n             return c;\n \n-        case INT_u: // and finally hex-escaped\n+        case 'u': // and finally hex-escaped\n             break;\n \n         default:\n--- a/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java\n         JsonToken t;\n \n         switch (i) {\n-        case INT_LBRACKET:\n+        case '[':\n             t = JsonToken.START_ARRAY;\n             break;\n-        case INT_LCURLY:\n+        case '{':\n             t = JsonToken.START_OBJECT;\n             break;\n-        case INT_RBRACKET:\n-        case INT_RCURLY:\n+        case ']':\n+        case '}':\n             // Error: neither is valid at this point; valid closers have\n             // been handled earlier\n             _reportUnexpectedChar(i, \"expected a value\");\n-        case INT_t:\n+        case 't':\n             _matchToken(\"true\", 1);\n             t = JsonToken.VALUE_TRUE;\n             break;\n-        case INT_f:\n+        case 'f':\n             _matchToken(\"false\", 1);\n              t = JsonToken.VALUE_FALSE;\n             break;\n-        case INT_n:\n+        case 'n':\n             _matchToken(\"null\", 1);\n             t = JsonToken.VALUE_NULL;\n             break;\n \n-        case INT_MINUS:\n+        case '-':\n             /* Should we have separate handling for plus? Although\n              * it is not allowed per se, it may be erroneously used,\n              * and could be indicate by a more specific error message.\n              */\n-        case INT_0:\n-        case INT_1:\n-        case INT_2:\n-        case INT_3:\n-        case INT_4:\n-        case INT_5:\n-        case INT_6:\n-        case INT_7:\n-        case INT_8:\n-        case INT_9:\n+        case '0':\n+        case '1':\n+        case '2':\n+        case '3':\n+        case '4':\n+        case '5':\n+        case '6':\n+        case '7':\n+        case '8':\n+        case '9':\n             t = parseNumberText(i);\n             break;\n         default:\n             return (_currToken = JsonToken.VALUE_STRING);\n         }\n         switch (i) {\n-        case INT_LBRACKET:\n+        case '[':\n             _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n             return (_currToken = JsonToken.START_ARRAY);\n-        case INT_LCURLY:\n+        case '{':\n             _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n             return (_currToken = JsonToken.START_OBJECT);\n-        case INT_RBRACKET:\n-        case INT_RCURLY:\n+        case ']':\n+        case '}':\n             // Error: neither is valid at this point; valid closers have\n             // been handled earlier\n             _reportUnexpectedChar(i, \"expected a value\");\n-        case INT_t:\n+        case 't':\n             _matchToken(\"true\", 1);\n             return (_currToken = JsonToken.VALUE_TRUE);\n-        case INT_f:\n+        case 'f':\n             _matchToken(\"false\", 1);\n             return (_currToken = JsonToken.VALUE_FALSE);\n-        case INT_n:\n+        case 'n':\n             _matchToken(\"null\", 1);\n             return (_currToken = JsonToken.VALUE_NULL);\n-        case INT_MINUS:\n+        case '-':\n             /* Should we have separate handling for plus? Although\n              * it is not allowed per se, it may be erroneously used,\n              * and could be indicate by a more specific error message.\n              */\n-        case INT_0:\n-        case INT_1:\n-        case INT_2:\n-        case INT_3:\n-        case INT_4:\n-        case INT_5:\n-        case INT_6:\n-        case INT_7:\n-        case INT_8:\n-        case INT_9:\n+        case '0':\n+        case '1':\n+        case '2':\n+        case '3':\n+        case '4':\n+        case '5':\n+        case '6':\n+        case '7':\n+        case '8':\n+        case '9':\n             return (_currToken = parseNumberText(i));\n         }\n         return (_currToken = _handleUnexpectedValue(i));\n             i = _skipColon();\n         }\n         switch (i) {\n-        case INT_QUOTE:\n+        case '\"':\n             _tokenIncomplete = true;\n             _nextToken = JsonToken.VALUE_STRING;\n             return;\n-        case INT_LBRACKET:\n+        case '[':\n             _nextToken = JsonToken.START_ARRAY;\n             return;\n-        case INT_LCURLY:\n+        case '{':\n             _nextToken = JsonToken.START_OBJECT;\n             return;\n-        case INT_RBRACKET:\n-        case INT_RCURLY:\n+        case ']':\n+        case '}':\n             _reportUnexpectedChar(i, \"expected a value\");\n-        case INT_t:\n+        case 't':\n             _matchToken(\"true\", 1);\n             _nextToken = JsonToken.VALUE_TRUE;\n             return;\n-        case INT_f:\n+        case 'f':\n             _matchToken(\"false\", 1);\n             _nextToken = JsonToken.VALUE_FALSE;\n             return;\n-        case INT_n:\n+        case 'n':\n             _matchToken(\"null\", 1);\n             _nextToken = JsonToken.VALUE_NULL;\n             return;\n-        case INT_MINUS:\n-        case INT_0:\n-        case INT_1:\n-        case INT_2:\n-        case INT_3:\n-        case INT_4:\n-        case INT_5:\n-        case INT_6:\n-        case INT_7:\n-        case INT_8:\n-        case INT_9:\n+        case '-':\n+        case '0':\n+        case '1':\n+        case '2':\n+        case '3':\n+        case '4':\n+        case '5':\n+        case '6':\n+        case '7':\n+        case '8':\n+        case '9':\n             _nextToken = parseNumberText(i);\n             return;\n         }\n         JsonToken t;\n \n         switch (i) {\n-        case INT_LBRACKET:\n+        case '[':\n             t = JsonToken.START_ARRAY;\n             break;\n-        case INT_LCURLY:\n+        case '{':\n             t = JsonToken.START_OBJECT;\n             break;\n-        case INT_RBRACKET:\n-        case INT_RCURLY:\n+        case ']':\n+        case '}':\n             _reportUnexpectedChar(i, \"expected a value\");\n-        case INT_t:\n+        case 't':\n             _matchToken(\"true\", 1);\n             t = JsonToken.VALUE_TRUE;\n             break;\n-        case INT_f:\n+        case 'f':\n             _matchToken(\"false\", 1);\n              t = JsonToken.VALUE_FALSE;\n             break;\n-        case INT_n:\n+        case 'n':\n             _matchToken(\"null\", 1);\n             t = JsonToken.VALUE_NULL;\n             break;\n \n-        case INT_MINUS:\n-        case INT_0:\n-        case INT_1:\n-        case INT_2:\n-        case INT_3:\n-        case INT_4:\n-        case INT_5:\n-        case INT_6:\n-        case INT_7:\n-        case INT_8:\n-        case INT_9:\n+        case '-':\n+        case '0':\n+        case '1':\n+        case '2':\n+        case '3':\n+        case '4':\n+        case '5':\n+        case '6':\n+        case '7':\n+        case '8':\n+        case '9':\n+\n             t = parseNumberText(i);\n             break;\n         default:\n         throws IOException, JsonParseException\n     {\n         // [JACKSON-173]: allow single quotes\n-        if (ch == INT_APOSTROPHE && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\n+        if (ch == '\\'' && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\n             return _parseApostropheFieldName();\n         }\n         // [JACKSON-69]: allow unquoted names if feature enabled:\n             }\n         }\n         int ch = _inputBuffer[_inputPtr++] & 0xFF;\n-        if (ch == INT_APOSTROPHE) { // special case, ''\n+        if (ch == '\\'') { // special case, ''\n             return BytesToNameCanonicalizer.getEmptyName();\n         }\n         int[] quads = _quadBuffer;\n         final int[] codes = sInputCodesLatin1;\n \n         while (true) {\n-            if (ch == INT_APOSTROPHE) {\n+            if (ch == '\\'') {\n                 break;\n             }\n             // additional check to skip handling of double-quotes\n-            if (ch != INT_QUOTE && codes[ch] != 0) {\n-                if (ch != INT_BACKSLASH) {\n+            if (ch != '\"' && codes[ch] != 0) {\n+                if (ch != '\\\\') {\n                     // Unquoted white space?\n                     // As per [JACKSON-208], call can now return:\n                     _throwUnquotedSpace(ch, \"name\");\n                 }\n                 while (_inputPtr < max) {\n                     c = (int) inputBuffer[_inputPtr++] & 0xFF;\n-                    if (c == INT_APOSTROPHE || codes[c] != 0) {\n+                    if (c == '\\'' || codes[c] != 0) {\n                         break ascii_loop;\n                     }\n                     outBuf[outPtr++] = (char) c;\n             }\n \n             // Ok: end marker, escape or multi-byte?\n-            if (c == INT_APOSTROPHE) {\n+            if (c == '\\'') {\n                 break main_loop;\n             }\n \n             switch (codes[c]) {\n             case 1: // backslash\n-                if (c != INT_QUOTE) { // marked as special, isn't here\n+                if (c != '\\'') { // marked as special, isn't here\n                     c = _decodeEscaped();\n                 }\n                 break;\n             space_loop:\n             while (true) {\n                 switch (i) {\n-                case INT_SPACE:\n-                case INT_TAB:\n+                case ' ':\n+                case '\\t':\n                     break;\n                 case INT_CR:\n                     _skipCR();\n                 case INT_LF:\n                     _skipLF();\n                     break;\n-                case INT_SLASH:\n+                case '/':\n                     _skipComment();\n                     break;\n                 default:\n             _reportInvalidEOF(\" in a comment\");\n         }\n         int c = _inputBuffer[_inputPtr++] & 0xFF;\n-        if (c == INT_SLASH) {\n+        if (c == '/') {\n             _skipCppComment();\n-        } else if (c == INT_ASTERISK) {\n+        } else if (c == '*') {\n             _skipCComment();\n         } else {\n             _reportUnexpectedChar(c, \"was expecting either '*' or '/' for a comment\");\n             int code = codes[i];\n             if (code != 0) {\n                 switch (code) {\n-                case INT_ASTERISK:\n+                case '*':\n                     if (_inputPtr >= _inputEnd && !loadMore()) {\n                         break main_loop;\n                     }\n                 case INT_CR:\n                     _skipCR();\n                     return;\n-                case INT_ASTERISK: // nop for these comments\n+                case '*': // nop for these comments\n                     break;\n                 case 2: // 2-byte UTF\n                     _skipUtf8_2(i);\n \n         switch ((int) c) {\n             // First, ones that are mapped\n-        case INT_b:\n+        case 'b':\n             return '\\b';\n-        case INT_t:\n+        case 't':\n             return '\\t';\n-        case INT_n:\n+        case 'n':\n             return '\\n';\n-        case INT_f:\n+        case 'f':\n             return '\\f';\n-        case INT_r:\n+        case 'r':\n             return '\\r';\n \n             // And these are to be returned as they are\n-        case INT_QUOTE:\n-        case INT_SLASH:\n-        case INT_BACKSLASH:\n+        case '\"':\n+        case '/':\n+        case '\\\\':\n             return (char) c;\n \n-        case INT_u: // and finally hex-escaped\n+        case 'u': // and finally hex-escaped\n             break;\n \n         default:", "timestamp": 1379561245, "metainfo": ""}