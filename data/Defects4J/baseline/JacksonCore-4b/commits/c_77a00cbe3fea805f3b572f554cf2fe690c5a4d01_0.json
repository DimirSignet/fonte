{"sha": "77a00cbe3fea805f3b572f554cf2fe690c5a4d01", "log": "Merge pull request #12 from dlew/master  Fix for JsonParser.getValueAsLong()", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/core/JsonParser.java\n+++ b/src/main/java/com/fasterxml/jackson/core/JsonParser.java\n      * default value of <b>0</b> will be returned; no exceptions are thrown.\n      */\n     public long getValueAsLong() throws IOException, JsonParseException {\n-        return getValueAsInt(0);\n+        return getValueAsLong(0);\n     }\n     \n     /**\n--- a/src/main/java/com/fasterxml/jackson/core/JsonFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/core/JsonFactory.java\n     /**********************************************************\n      */\n \n-    @Override\n+//  @Override\n     public Version version() {\n         return CoreVersion.instance.version();\n     }\n--- a/src/main/java/com/fasterxml/jackson/core/JsonGenerator.java\n+++ b/src/main/java/com/fasterxml/jackson/core/JsonGenerator.java\n         throw new UnsupportedOperationException(\"Generator of type \"+getClass().getName()+\" does not support schema of type '\"\n                 +schema.getSchemaType()+\"'\");\n     }\n+\n+    /**\n+     * Method for accessing Schema that this parser uses, if any.\n+     * Default implementation returns null.\n+     *\n+     * @since 2.1\n+     */\n+    public FormatSchema getSchema() {\n+\treturn null;\n+    }\n     \n     /**\n      * Method that can be used to verify that given schema can be used with\n     /**\n      * Accessor for finding out version of the bundle that provided this generator instance.\n      */\n-    @Override\n+//  @Override\n     public abstract Version version();\n \n     /**\n      * If either of above is true, the target is also closed. Otherwise\n      * (not managing, feature not enabled), target is not closed.\n      */\n-    @Override\n-    public abstract void close()\n-        throws IOException;\n+//    @Override\n+    public abstract void close() throws IOException;\n }\n--- a/src/main/java/com/fasterxml/jackson/core/JsonParser.java\n+++ b/src/main/java/com/fasterxml/jackson/core/JsonParser.java\n         throw new UnsupportedOperationException(\"Parser of type \"+getClass().getName()+\" does not support schema of type '\"\n                 +schema.getSchemaType()+\"'\");\n     }\n+\n+    /**\n+     * Method for accessing Schema that this parser uses, if any.\n+     * Default implementation returns null.\n+     *\n+     * @since 2.1\n+     */\n+    public FormatSchema getSchema() {\n+\treturn null;\n+    }\n     \n     /**\n      * Method that can be used to verify that given schema can be used with\n      * Accessor for getting version of the core package, given a parser instance.\n      * Left for sub-classes to implement.\n      */\n-    @Override\n+//  @Override\n     public abstract Version version();\n \n     /**\n      * {@link java.io.File} or {@link java.net.URL} and creates\n      * stream or reader it does own them.\n      */\n-    @Override\n+//  @Override\n     public abstract void close() throws IOException;\n \n     /*\n--- a/src/main/java/com/fasterxml/jackson/core/Version.java\n+++ b/src/main/java/com/fasterxml/jackson/core/Version.java\n             ;\n     }\n \n-    @Override\n+//  @Override\n     public int compareTo(Version other)\n     {\n         if (other == this) return 0;\n--- a/src/main/java/com/fasterxml/jackson/core/base/ParserBase.java\n+++ b/src/main/java/com/fasterxml/jackson/core/base/ParserBase.java\n     /**********************************************************\n      */\n \n-    public final long getTokenCharacterOffset() { return _tokenInputTotal; }\n-    public final int getTokenLineNr() { return _tokenInputRow; }\n-    public final int getTokenColumnNr() {\n+    public long getTokenCharacterOffset() { return _tokenInputTotal; }\n+    public int getTokenLineNr() { return _tokenInputRow; }\n+    public int getTokenColumnNr() {\n         // note: value of -1 means \"not available\"; otherwise convert from 0-based to 1-based\n         int col = _tokenInputCol;\n         return (col < 0) ? col : (col + 1);\n--- a/src/main/java/com/fasterxml/jackson/core/format/InputAccessor.java\n+++ b/src/main/java/com/fasterxml/jackson/core/format/InputAccessor.java\n             _bufferedAmount = inputDocument.length;\n         }\n         \n-        @Override\n+//      @Override\n         public boolean hasMoreBytes() throws IOException\n         {\n             if (_ptr < _bufferedAmount) { // already got more\n             return true;\n         }\n \n-        @Override\n+//      @Override\n         public byte nextByte() throws IOException\n         {\n             // should we just try loading more automatically?\n             return _buffer[_ptr++];\n         }\n \n-        @Override\n+//      @Override\n         public void reset() {\n             _ptr = 0;\n         }\n--- a/src/main/java/com/fasterxml/jackson/core/io/NumberInput.java\n+++ b/src/main/java/com/fasterxml/jackson/core/io/NumberInput.java\n     public final static double parseDouble(String numStr) throws NumberFormatException\n     {\n         // [JACKSON-486]: avoid some nasty float representations... but should it be MIN_NORMAL or MIN_VALUE?\n+        /* as per [JACKSON-827], let's use MIN_VALUE as it is available on all JDKs; normalized\n+         * only in JDK 1.6. In practice, should not really matter.\n+         */\n         if (NASTY_SMALL_DOUBLE.equals(numStr)) {\n-            return Double.MIN_NORMAL;\n+            return Double.MIN_VALUE;\n         }\n         return Double.parseDouble(numStr);\n     }\n--- a/src/main/java/com/fasterxml/jackson/core/io/SerializedString.java\n+++ b/src/main/java/com/fasterxml/jackson/core/io/SerializedString.java\n     /**********************************************************\n      */\n \n-    @Override\n+//  @Override\n     public final String getValue() { return _value; }\n     \n     /**\n      * Returns length of the String as characters\n      */\n-    @Override\n+//  @Override\n     public final int charLength() { return _value.length(); }\n     \n-    @Override\n+//  @Override\n     public final char[] asQuotedChars()\n     {\n         char[] result = _quotedChars;\n      * Accessor for accessing value that has been quoted using JSON\n      * quoting rules, and encoded using UTF-8 encoding.\n      */\n-    @Override\n+//  @Override\n     public final byte[] asUnquotedUTF8()\n     {\n         byte[] result = _unquotedUTF8Ref;\n      * Accessor for accessing value as is (without JSON quoting)\n      * encoded using UTF-8 encoding.\n      */\n-    @Override\n+//  @Override\n     public final byte[] asQuotedUTF8()\n     {\n         byte[] result = _quotedUTF8Ref;\n     /* Additional 2.0 methods for appending/writing contents\n     /**********************************************************\n      */\n-    @Override\n+\n+//  @Override\n     public int appendQuotedUTF8(byte[] buffer, int offset)\n     {\n         byte[] result = _quotedUTF8Ref;\n         return length;\n     }\n \n-    @Override\n+//  @Override\n     public int appendQuoted(char[] buffer, int offset)\n     {\n         char[] result = _quotedChars;\n         return length;\n     }\n \n-    @Override\n+//  @Override\n     public int appendUnquotedUTF8(byte[] buffer, int offset)\n     {\n         byte[] result = _unquotedUTF8Ref;\n         return length;\n     }\n \n-    @Override\n+//  @Override\n     public int appendUnquoted(char[] buffer, int offset)\n     {\n         String str = _value;\n         return length;\n     }\n \n-    @Override\n+//  @Override\n     public int writeQuotedUTF8(OutputStream out) throws IOException\n     {\n         byte[] result = _quotedUTF8Ref;\n         return length;\n     }\n \n-    @Override\n+//  @Override\n     public int writeUnquotedUTF8(OutputStream out) throws IOException\n     {\n         byte[] result = _unquotedUTF8Ref;\n         return length;\n     }\n \n-    @Override\n+//  @Override\n     public int putQuotedUTF8(ByteBuffer buffer)\n     {\n         byte[] result = _quotedUTF8Ref;\n         return length;\n     }\n \n-    @Override\n+//  @Override\n     public int putUnquotedUTF8(ByteBuffer buffer)\n     {\n         byte[] result = _unquotedUTF8Ref;\n--- a/src/main/java/com/fasterxml/jackson/core/type/TypeReference.java\n+++ b/src/main/java/com/fasterxml/jackson/core/type/TypeReference.java\n      * of <code>Comparable</code>) is to prevent constructing a\n      * reference without type information.\n      */\n-    @Override\n+//  @Override\n     public int compareTo(TypeReference<T> o) {\n         // just need an implementation, not a good one... hence:\n         return 0;\n--- a/src/main/java/com/fasterxml/jackson/core/util/DefaultPrettyPrinter.java\n+++ b/src/main/java/com/fasterxml/jackson/core/util/DefaultPrettyPrinter.java\n     /**********************************************************\n      */\n \n-    @Override\n+//  @Override\n     public void writeRootValueSeparator(JsonGenerator jg)\n         throws IOException, JsonGenerationException\n     {\n         jg.writeRaw(' ');\n     }\n \n-    @Override\n+//  @Override\n     public void writeStartObject(JsonGenerator jg)\n         throws IOException, JsonGenerationException\n     {\n         }\n     }\n \n-    @Override\n+//  @Override\n     public void beforeObjectEntries(JsonGenerator jg)\n         throws IOException, JsonGenerationException\n     {\n      * to output a colon as well, but can surround that with other\n      * (white-space) decoration.\n      */\n-    @Override\n+//  @Override\n     public void writeObjectFieldValueSeparator(JsonGenerator jg)\n         throws IOException, JsonGenerationException\n     {\n      * to output a comma as well, but can surround that with other\n      * (white-space) decoration.\n      */\n-    @Override\n+//  @Override\n     public void writeObjectEntrySeparator(JsonGenerator jg)\n         throws IOException, JsonGenerationException\n     {\n         _objectIndenter.writeIndentation(jg, _nesting);\n     }\n \n-    @Override\n+//  @Override\n     public void writeEndObject(JsonGenerator jg, int nrOfEntries)\n         throws IOException, JsonGenerationException\n     {\n         jg.writeRaw('}');\n     }\n \n-    @Override\n+//  @Override\n     public void writeStartArray(JsonGenerator jg)\n         throws IOException, JsonGenerationException\n     {\n         jg.writeRaw('[');\n     }\n \n-    @Override\n+//  @Override\n     public void beforeArrayValues(JsonGenerator jg)\n         throws IOException, JsonGenerationException\n     {\n      * to output a comma as well, but can surround that with other\n      * (white-space) decoration.\n      */\n-    @Override\n+//  @Override\n     public void writeArrayValueSeparator(JsonGenerator jg)\n         throws IOException, JsonGenerationException\n     {\n         _arrayIndenter.writeIndentation(jg, _nesting);\n     }\n \n-    @Override\n+//  @Override\n     public void writeEndArray(JsonGenerator jg, int nrOfValues)\n         throws IOException, JsonGenerationException\n     {\n         implements Indenter\n     {\n         public NopIndenter() { }\n-        @Override\n+//      @Override\n         public void writeIndentation(JsonGenerator jg, int level) { }\n-        @Override\n+//      @Override\n         public boolean isInline() { return true; }\n     }\n \n     {\n         public FixedSpaceIndenter() { }\n \n-        @Override\n+//      @Override\n         public void writeIndentation(JsonGenerator jg, int level)\n             throws IOException, JsonGenerationException\n         {\n             jg.writeRaw(' ');\n         }\n \n-        @Override\n+//      @Override\n         public boolean isInline() { return true; }\n     }\n \n \n         public Lf2SpacesIndenter() { }\n \n-        @Override\n+//      @Override\n         public boolean isInline() { return false; }\n \n-        @Override\n+//      @Override\n         public void writeIndentation(JsonGenerator jg, int level)\n             throws IOException, JsonGenerationException\n         {\n--- a/src/main/java/com/fasterxml/jackson/core/util/MinimalPrettyPrinter.java\n+++ b/src/main/java/com/fasterxml/jackson/core/util/MinimalPrettyPrinter.java\n     /**********************************************************\n      */\n \n-    @Override\n+//  @Override\n     public void writeRootValueSeparator(JsonGenerator jg) throws IOException, JsonGenerationException\n     {\n         if (_rootValueSeparator != null) {\n         }\n     }\n     \n-    @Override\n+//  @Override\n     public void writeStartObject(JsonGenerator jg)\n         throws IOException, JsonGenerationException\n     {\n         jg.writeRaw('{');\n     }\n     \n-    @Override\n+//  @Override\n     public void beforeObjectEntries(JsonGenerator jg)\n         throws IOException, JsonGenerationException\n     {\n      * Default handling will just output a single\n      * colon to separate the two, without additional spaces.\n      */\n-    @Override\n+//  @Override\n     public void writeObjectFieldValueSeparator(JsonGenerator jg)\n         throws IOException, JsonGenerationException\n     {\n      * Default handling (without pretty-printing) will output a single\n      * comma to separate the two.\n      */\n-    @Override\n+//  @Override\n     public void writeObjectEntrySeparator(JsonGenerator jg)\n         throws IOException, JsonGenerationException\n     {\n         jg.writeRaw(',');\n     }\n \n-    @Override\n+//  @Override\n     public void writeEndObject(JsonGenerator jg, int nrOfEntries)\n         throws IOException, JsonGenerationException\n     {\n         jg.writeRaw('}');\n     }\n     \n-    @Override\n+//  @Override\n     public void writeStartArray(JsonGenerator jg)\n         throws IOException, JsonGenerationException\n     {\n         jg.writeRaw('[');\n     }\n     \n-    @Override\n+//  @Override\n     public void beforeArrayValues(JsonGenerator jg)\n         throws IOException, JsonGenerationException\n     {\n      * Default handling (without pretty-printing) will output a single\n      * comma to separate values.\n      */\n-    @Override\n+//  @Override\n     public void writeArrayValueSeparator(JsonGenerator jg)\n         throws IOException, JsonGenerationException\n     {\n         jg.writeRaw(',');\n     }\n     \n-    @Override\n+//  @Override\n     public void writeEndArray(JsonGenerator jg, int nrOfValues)\n         throws IOException, JsonGenerationException\n     {\n--- a/src/test/java/com/fasterxml/jackson/core/TestVersions.java\n+++ b/src/test/java/com/fasterxml/jackson/core/TestVersions.java\n         assertEquals(MAJOR_VERSION, v.getMajorVersion());\n         assertEquals(MINOR_VERSION, v.getMinorVersion());\n         // Check patch level initially, comment out for maint versions\n-        assertEquals(0, v.getPatchLevel());\n+//        assertEquals(0, v.getPatchLevel());\n \n         // also, group & artifact ids should match:\n         assertEquals(GROUP_ID, v.getGroupId());", "timestamp": 1334685992, "metainfo": ""}