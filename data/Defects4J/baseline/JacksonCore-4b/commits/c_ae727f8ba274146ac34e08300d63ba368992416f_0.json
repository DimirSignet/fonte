{"sha": "ae727f8ba274146ac34e08300d63ba368992416f", "log": "Merge branch 'master' of github.com:FasterXML/jackson-core", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/core/JsonParser.java\n+++ b/src/main/java/com/fasterxml/jackson/core/JsonParser.java\n \n     /*\n     /**********************************************************\n-    /* Minimal generic state\n-    /**********************************************************\n-     */\n-\n-    /**\n-     * Last token retrieved via {@link #nextToken}, if any.\n-     * Null before the first call to <code>nextToken()</code>,\n-     * as well as if token has been explicitly cleared\n-     * (by call to {@link #clearCurrentToken})\n-     */\n-    protected JsonToken _currToken;\n-\n-    /**\n-     * Last cleared token, if any: that is, value that was in\n-     * effect when {@link #clearCurrentToken} was called.\n-     */\n-    protected JsonToken _lastClearedToken;\n-\n-    /*\n-    /**********************************************************\n     /* Construction, configuration, initialization\n     /**********************************************************\n      */\n      *   parsers, {@link JsonToken#NOT_AVAILABLE} if no tokens were\n      *   available yet)\n      */\n-    public JsonToken nextValue()\n-        throws IOException, JsonParseException\n-    {\n-        /* Implementation should be as trivial as follows; only\n-         * needs to change if we are to skip other tokens (for\n-         * example, if comments were exposed as tokens)\n-         */\n-        JsonToken t = nextToken();\n-        if (t == JsonToken.FIELD_NAME) {\n-            t = nextToken();\n-        }\n-        return t;\n-    }\n+    public abstract JsonToken nextValue()\n+        throws IOException, JsonParseException;\n \n     /**\n      * Method that fetches next token (as if calling {@link #nextToken}) and\n      *   after end-of-input has been encountered, as well as\n      *   if the current token has been explicitly cleared.\n      */\n-    public JsonToken getCurrentToken() {\n-        return _currToken;\n-    }\n+    public abstract JsonToken getCurrentToken();\n \n     /**\n      * Method for checking whether parser currently points to\n      *   and returned null from {@link #nextToken}, or the token\n      *   has been consumed)\n      */\n-    public boolean hasCurrentToken() {\n-        return _currToken != null;\n-    }\n-\n+    public abstract boolean hasCurrentToken();\n \n     /**\n      * Method called to \"consume\" the current token by effectively\n      * it has to be able to consume last token used for binding (so that\n      * it will not be used again).\n      */\n-    public void clearCurrentToken() {\n-        if (_currToken != null) {\n-            _lastClearedToken = _currToken;\n-            _currToken = null;\n-        }\n-    }\n+    public abstract void clearCurrentToken();\n \n     /**\n      * Method that can be called to get the name associated with\n      * Will return null if no tokens have been cleared,\n      * or if parser has been closed.\n      */\n-    public JsonToken getLastClearedToken() {\n-        return _lastClearedToken;\n-    }\n+    public abstract JsonToken getLastClearedToken();\n \n     /**\n      * Specialized accessor that can be used to verify that the current\n      *   be efficiently returned via {@link #getTextCharacters}; false\n      *   means that it may or may not exist\n      */\n-    public boolean hasTextCharacters() {\n-        return false;\n-    }\n+    public abstract boolean hasTextCharacters();\n     \n     /*\n     /**********************************************************\n     public boolean getBooleanValue()\n         throws IOException, JsonParseException\n     {\n-        if (_currToken == JsonToken.VALUE_TRUE) return true;\n-        if (_currToken == JsonToken.VALUE_FALSE) return false;\n-        throw new JsonParseException(\"Current token (\"+_currToken+\") not of boolean type\", getCurrentLocation());\n+        JsonToken t = getCurrentToken();\n+        if (t == JsonToken.VALUE_TRUE) return true;\n+        if (t == JsonToken.VALUE_FALSE) return false;\n+        throw new JsonParseException(\"Current token (\"+t+\") not of boolean type\", getCurrentLocation());\n     }\n \n     /**\n      * embedding of objects (usually ones that are facades on top\n      * of non-streaming sources, such as object trees).\n      */\n-    public Object getEmbeddedObject()\n-        throws IOException, JsonParseException\n-    {\n-        // By default we will always return null\n-        return null;\n-    }\n+    public abstract Object getEmbeddedObject()\n+        throws IOException, JsonParseException;\n \n     /*\n     /**********************************************************\n--- a/src/main/java/com/fasterxml/jackson/core/base/ParserBase.java\n+++ b/src/main/java/com/fasterxml/jackson/core/base/ParserBase.java\n      * Index of character after last available one in the buffer.\n      */\n     protected int _inputEnd = 0;\n-\n+    \n     /*\n     /**********************************************************\n     /* Current input location information\n      * the next token is to be parsed (root, array, object).\n      */\n     protected JsonReadContext _parsingContext;\n-\n+    \n     /**\n      * Secondary token related to the next token after current one;\n      * used if its type is known. This may be value token that\n--- a/src/main/java/com/fasterxml/jackson/core/base/ParserMinimalBase.java\n+++ b/src/main/java/com/fasterxml/jackson/core/base/ParserMinimalBase.java\n \n     /*\n     /**********************************************************\n+    /* Minimal generally useful state\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Last token retrieved via {@link #nextToken}, if any.\n+     * Null before the first call to <code>nextToken()</code>,\n+     * as well as if token has been explicitly cleared\n+     * (by call to {@link #clearCurrentToken})\n+     */\n+    protected JsonToken _currToken;\n+\n+    /**\n+     * Last cleared token, if any: that is, value that was in\n+     * effect when {@link #clearCurrentToken} was called.\n+     */\n+    protected JsonToken _lastClearedToken;\n+    \n+    /*\n+    /**********************************************************\n     /* Life-cycle\n     /**********************************************************\n      */\n     @Override\n     public abstract JsonToken nextToken() throws IOException, JsonParseException;\n \n-    //public final JsonToken nextValue()\n+    @Override\n+    public JsonToken getCurrentToken() {\n+        return _currToken;\n+    }\n+\n+    @Override\n+    public boolean hasCurrentToken() {\n+        return _currToken != null;\n+    }\n+    \n+    @Override\n+    public void clearCurrentToken() {\n+        if (_currToken != null) {\n+            _lastClearedToken = _currToken;\n+            _currToken = null;\n+        }\n+    }\n+\n+    @Override\n+    public JsonToken getLastClearedToken() {\n+        return _lastClearedToken;\n+    }\n+    \n+    @Override\n+    public JsonToken nextValue()\n+        throws IOException, JsonParseException\n+    {\n+        /* Implementation should be as trivial as follows; only\n+         * needs to change if we are to skip other tokens (for\n+         * example, if comments were exposed as tokens)\n+         */\n+        JsonToken t = nextToken();\n+        if (t == JsonToken.FIELD_NAME) {\n+            t = nextToken();\n+        }\n+        return t;\n+    }\n \n     @Override\n     public JsonParser skipChildren() throws IOException, JsonParseException\n--- a/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java\n             }\n         }\n         return 0;\n+    }\n+\n+    @Override\n+    public Object getEmbeddedObject() throws IOException, JsonParseException {\n+        return null;\n     }\n \n     @Override\n--- a/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java\n         return 0;\n     }\n \n+    // No embedded objects with base impl...\n+    @Override\n+    public Object getEmbeddedObject() throws IOException, JsonParseException {\n+        return null;\n+    }\n+    \n     @Override\n     public byte[] getBinaryValue(Base64Variant b64variant)\n         throws IOException, JsonParseException\n--- a/src/main/java/com/fasterxml/jackson/core/util/JsonParserDelegate.java\n+++ b/src/main/java/com/fasterxml/jackson/core/util/JsonParserDelegate.java\n  * to allow for simple overridability of basic parsing functionality.\n  * The idea is that any functionality to be modified can be simply\n  * overridden; and anything else will be delegated by default.\n- * \n- * @since 1.4\n  */\n public class JsonParserDelegate extends JsonParser\n {\n     }\n \n     @Override\n+    public boolean hasTextCharacters() {\n+        return delegate.hasTextCharacters();\n+    }\n+    \n+    @Override\n     public char[] getTextCharacters() throws IOException, JsonParseException {\n         return delegate.getTextCharacters();\n     }\n         return delegate.getTextOffset();\n     }\n \n-\n     /*\n     /**********************************************************\n     /* Public API, access to token information, numeric\n     }\n \n     @Override\n+    public boolean getBooleanValue() throws IOException, JsonParseException {\n+        return delegate.getBooleanValue();\n+    }\n+    \n+    @Override\n     public byte getByteValue() throws IOException, JsonParseException {\n         return delegate.getByteValue();\n     }\n         return delegate.getNumberValue();\n     }\n \n+    /*\n+    /**********************************************************\n+    /* Public API, access to token values, other\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public Object getEmbeddedObject() throws IOException, JsonParseException {\n+        return delegate.getEmbeddedObject();\n+    }\n+    \n     @Override\n     public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException {\n         return delegate.getBinaryValue(b64variant);\n     @Override\n     public JsonToken nextToken() throws IOException, JsonParseException {\n         return delegate.nextToken();\n+    }\n+\n+    @Override\n+    public JsonToken nextValue() throws IOException, JsonParseException {\n+        return delegate.nextValue();\n     }\n     \n     @Override\n--- a/src/main/java/com/fasterxml/jackson/core/util/VersionUtil.java\n+++ b/src/main/java/com/fasterxml/jackson/core/util/VersionUtil.java\n package com.fasterxml.jackson.core.util;\n \n import java.io.*;\n+import java.util.Properties;\n import java.util.regex.Pattern;\n \n import com.fasterxml.jackson.core.Version;\n     }\n \n     /**\n+     * Will attempt to load the maven version for the given groupId and\n+     * artifactId.  Maven puts a pom.properties file in\n+     * META-INF/maven/groupId/artifactId, containing the groupId,\n+     * artifactId and version of the library.\n+     *\n+     * @param classLoader the ClassLoader to load the pom.properties file from\n+     * @param groupId the groupId of the library\n+     * @param artifactId the artifactId of the library\n+     * @return The version\n+     */\n+    public static Version mavenVersionFor(ClassLoader classLoader, String groupId, String artifactId) {\n+        InputStream pomPoperties = classLoader.getResourceAsStream(\"META-INF/maven/\" + groupId.replaceAll(\"\\\\.\", \"/\")\n+                + \"/\" + artifactId + \"/pom.properties\");\n+        if (pomPoperties != null) {\n+            try {\n+                Properties props = new Properties();\n+                props.load(pomPoperties);\n+                String versionStr = props.getProperty(\"version\");\n+                String pomPropertiesArtifactId = props.getProperty(\"artifactId\");\n+                String pomPropertiesGroupId = props.getProperty(\"groupId\");\n+                return parseVersion(versionStr, pomPropertiesGroupId, pomPropertiesArtifactId);\n+            } catch (IOException e) {\n+                // Ignore\n+            } finally {\n+                try {\n+                    pomPoperties.close();\n+                } catch (IOException e) {\n+                    // Ignore\n+                }\n+            }\n+        }\n+        return Version.unknownVersion();\n+    }\n+\n+    /**\n      * Use variant that takes three arguments instead\n      * \n      * @deprecated\n--- a/src/test/java/com/fasterxml/jackson/core/util/TestVersionUtil.java\n+++ b/src/test/java/com/fasterxml/jackson/core/util/TestVersionUtil.java\n package com.fasterxml.jackson.core.util;\n \n import com.fasterxml.jackson.core.Version;\n-import com.fasterxml.jackson.core.util.VersionUtil;\n \n public class TestVersionUtil extends com.fasterxml.jackson.test.BaseTest\n {\n         assertEquals(new Version(1, 2, 15, \"foo\", \"group\", \"artifact\"),\n                 VersionUtil.parseVersion(\"1.2.15-foo\", \"group\", \"artifact\"));\n     }\n+\n+    public void testMavenVersionParsing() {\n+        assertEquals(new Version(1, 2, 3, \"SNAPSHOT\", \"foo.bar\", \"foo-bar\"),\n+                VersionUtil.mavenVersionFor(TestVersionUtil.class.getClassLoader(), \"foo.bar\", \"foo-bar\"));\n+    }\n }\n--- a/src/test/java/com/fasterxml/jackson/core/util/TestVersionUtil.java\n+++ b/src/test/java/com/fasterxml/jackson/core/util/TestVersionUtil.java\n \n     public void testVersionParsing()\n     {\n-        assertEquals(new Version(1, 2, 15, \"foo\"), VersionUtil.parseVersion(\"1.2.15-foo\"));\n+        assertEquals(new Version(1, 2, 15, \"foo\", \"group\", \"artifact\"),\n+                VersionUtil.parseVersion(\"1.2.15-foo\", \"group\", \"artifact\"));\n     }\n \n     public void testMavenVersionParsing() {", "timestamp": 1326846992, "metainfo": ""}