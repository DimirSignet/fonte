{"sha": "8c4a625cdec89e6b1fa452fbb73c6f8d4c56b701", "log": "Implement ScopedAliases to record Aliases from goog.scope blocks. Easymock Dependency pulleded out for now to get the Changes working.  Will pull in and update tests as soon as dependency can be added to builds.  R=nicksantos DELTA=206  (188 added, 2 deleted, 16 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=1371   ", "commit": "\n--- a/src/com/google/javascript/jscomp/CompilerOptions.java\n+++ b/src/com/google/javascript/jscomp/CompilerOptions.java\n import com.google.common.collect.Multimap;\n import com.google.common.collect.Sets;\n import com.google.javascript.rhino.Node;\n+import com.google.javascript.rhino.SourcePosition;\n import com.google.javascript.rhino.Token;\n \n import java.io.Serializable;\n   public interface AliasTransformationHandler {\n \n     /**\n-     * Builds an AliasCodeChange implementation and returns it to the caller.\n+     * Builds an AliasTransformation implementation and returns it to the\n+     * caller.\n      * <p>\n      * Callers are allowed to request multiple AliasTransformation instances for\n      * the same file, though it is expected that the first and last char values\n      * implementor did not create\n      *\n      * @param sourceFile the source file the aliases re contained in.\n-     * @param firstChar the first character in the file to which the aliases are\n-     *        mapped.\n-     * @param lastChar the last character in the file to which the aliases are\n-     *        mapped.\n+     * @param position the region of the source file associated with the\n+     *        goog.scope call. The item of the SourcePosition is the returned\n+     *        AliasTransformation\n      */\n-    public AliasTransformation logAliasChangeSet(\n-        String sourceFile, int firstChar, int lastChar);\n+    public AliasTransformation logAliasTransformation(\n+        String sourceFile, SourcePosition<AliasTransformation> position);\n   }\n \n   /**\n         new NullAliasTransformation();\n \n     @Override\n-    public AliasTransformation logAliasChangeSet(\n-        String sourceFile, int firstChar, int lastChar) {\n+    public AliasTransformation logAliasTransformation(\n+        String sourceFile, SourcePosition<AliasTransformation> position) {\n+      position.setItem(NULL_ALIAS_TRANSFORMATION);\n       return NULL_ALIAS_TRANSFORMATION;\n     }\n \n--- a/src/com/google/javascript/jscomp/ScopedAliases.java\n+++ b/src/com/google/javascript/jscomp/ScopedAliases.java\n \n import com.google.common.collect.Lists;\n import com.google.common.collect.Maps;\n+import com.google.javascript.jscomp.CompilerOptions.AliasTransformation;\n import com.google.javascript.jscomp.CompilerOptions.AliasTransformationHandler;\n import com.google.javascript.jscomp.Scope.Var;\n import com.google.javascript.rhino.JSDocInfo;\n import com.google.javascript.rhino.Node;\n+import com.google.javascript.rhino.SourcePosition;\n import com.google.javascript.rhino.Token;\n \n import java.util.List;\n   static final String SCOPING_METHOD_NAME = \"goog.scope\";\n \n   private final AbstractCompiler compiler;\n+  private final AliasTransformationHandler transformationHandler;\n \n   // Errors\n   static final DiagnosticType GOOG_SCOPE_USED_IMPROPERLY = DiagnosticType.error(\n       \"JSC_GOOG_SCOPE_NON_ALIAS_LOCAL\",\n       \"The local variable {0} is in a goog.scope and is not an alias.\");\n \n-  ScopedAliases(\n-      AbstractCompiler compiler, AliasTransformationHandler codeChanges) {\n+  ScopedAliases(AbstractCompiler compiler,\n+      AliasTransformationHandler transformationHandler) {\n     this.compiler = compiler;\n+    this.transformationHandler = transformationHandler;\n   }\n \n   @Override\n     NodeTraversal.traverse(compiler, root, traversal);\n \n     if (!traversal.hasErrors()) {\n+\n       // Apply the aliases.\n       for (AliasUsage aliasUsage : traversal.getAliasUsages()) {\n         aliasUsage.applyAlias();\n \n     private boolean hasErrors = false;\n \n+    private AliasTransformation transformation = null;\n+\n     List<Node> getAliasDefinitions() {\n       return aliasDefinitions;\n     }\n \n     @Override\n     public void enterScope(NodeTraversal t) {\n+      Node n = t.getCurrentNode().getParent();\n+      if (n != null && isCallToScopeMethod(n)) {\n+        transformation = transformationHandler.logAliasTransformation(\n+            n.getProp(Node.SOURCENAME_PROP).toString(), getSourceRegion(n));\n+      }\n     }\n \n     @Override\n     public void exitScope(NodeTraversal t) {\n       if (t.getScopeDepth() == 2) {\n         aliases.clear();\n+        transformation = null;\n       }\n     }\n \n         }\n       }\n       return true;\n+    }\n+\n+    private SourcePosition<AliasTransformation> getSourceRegion(Node n) {\n+      Node testNode = n;\n+      Node next = null;\n+      for (; next != null || testNode.getType() == Token.SCRIPT;) {\n+        next = testNode.getNext();\n+        testNode = testNode.getParent();\n+      }\n+\n+      int endLine = next == null ? Integer.MAX_VALUE : next.getLineno();\n+      int endChar = next == null ? Integer.MAX_VALUE : next.getCharno();\n+      SourcePosition<AliasTransformation> pos =\n+          new SourcePosition<AliasTransformation>() {};\n+      pos.setPositionInformation(\n+          n.getLineno(), n.getCharno(), endLine, endChar);\n+      return pos;\n     }\n \n     private void report(NodeTraversal t, Node n, DiagnosticType error,\n         }\n       }\n \n+\n       if (t.getScopeDepth() == 2) {\n         int type = n.getType();\n         if (type == Token.NAME && parent.getType() == Token.VAR) {\n           if (n.hasChildren() && n.getFirstChild().isQualifiedName()) {\n-            aliases.put(n.getString(), t.getScope().getVar(n.getString()));\n+            String name = n.getString();\n+            Var aliasVar = t.getScope().getVar(name);\n+            aliases.put(name, aliasVar);\n             aliasDefinitions.add(n);\n-\n-            // If we found an alias, we are done.\n+            String qualifiedName =\n+                aliasVar.getInitialValue().getQualifiedName();\n+            transformation.addAlias(name, qualifiedName);\n             return;\n           } else {\n             // TODO(robbyw): Support using locals for private variables.\n--- a/test/com/google/javascript/jscomp/ScopedAliasesTest.java\n+++ b/test/com/google/javascript/jscomp/ScopedAliasesTest.java\n package com.google.javascript.jscomp;\n \n import com.google.common.collect.Lists;\n+import com.google.common.collect.Maps;\n+import com.google.javascript.jscomp.CompilerOptions.AliasTransformation;\n+import com.google.javascript.jscomp.CompilerOptions.AliasTransformationHandler;\n import com.google.javascript.rhino.JSDocInfo;\n import com.google.javascript.rhino.Node;\n+import com.google.javascript.rhino.SourcePosition;\n+\n import java.util.Collection;\n import java.util.List;\n+import java.util.Map;\n \n /**\n  * Tests for {@link ScopedAliases}\n  */\n public class ScopedAliasesTest extends CompilerTestCase {\n \n+  private static final String GOOG_SCOPE_START_BLOCK =\n+      \"goog.scope(function() {\";\n+  private static final String GOOG_SCOPE_END_BLOCK = \"});\";\n+  private static final int GOOG_SCOPE_LEN = \"goog.scope\".length();\n+\n   private static String EXTERNS = \"var window;\";\n+\n+  AliasTransformationHandler transformationHandler =\n+      CompilerOptions.NULL_ALIAS_TRANSFORMATION_HANDLER;\n \n   public ScopedAliasesTest() {\n     super(EXTERNS);\n   }\n \n   private void testScoped(String code, String expected) {\n-    test(\"goog.scope(function() {\" + code + \"});\", expected);\n+    test(GOOG_SCOPE_START_BLOCK + code + GOOG_SCOPE_END_BLOCK, expected);\n   }\n \n   private void testScopedNoChanges(String aliases, String code) {\n     test(\n         \"goog.scope(function() {var g = goog;g.method()});\" +\n         \"goog.scope(function() {g.method();});\",\n-\n         \"goog.method();g.method();\");\n   }\n \n         ScopedAliases.GOOG_SCOPE_NON_ALIAS_LOCAL);\n   }\n \n+  // Alias Recording Tests\n+  // TODO(tylerg) : update these to EasyMock style tests once available\n+  public void testNoGoogScope() {\n+    String fullJsCode =\n+        \"var g = goog;\\n g.dom.createElement(g.dom.TagName.DIV);\";\n+    TransformationHandlerSpy spy = new TransformationHandlerSpy();\n+    transformationHandler = spy;\n+    test(fullJsCode, fullJsCode);\n+\n+    assertTrue(spy.observedPositions.isEmpty());\n+  }\n+\n+  public void testRecordOneAlias() {\n+    String fullJsCode = GOOG_SCOPE_START_BLOCK\n+        + \"var g = goog;\\n g.dom.createElement(g.dom.TagName.DIV);\\n\"\n+        + GOOG_SCOPE_END_BLOCK;\n+    String expectedJsCode = \"goog.dom.createElement(goog.dom.TagName.DIV);\\n\";\n+\n+    TransformationHandlerSpy spy = new TransformationHandlerSpy();\n+    transformationHandler = spy;\n+    test(fullJsCode, expectedJsCode);\n+\n+    assertTrue(spy.observedPositions.containsKey(\"testcode\"));\n+    List<SourcePosition<AliasTransformation>> positions =\n+        spy.observedPositions.get(\"testcode\");\n+    assertEquals(1, positions.size());\n+    verifyAliasTransformationPosition(\n+        1, GOOG_SCOPE_LEN, 2, 1, positions.get(0));\n+\n+    assertEquals(1, spy.constructedAliases.size());\n+    AliasSpy aliasSpy = (AliasSpy) spy.constructedAliases.get(0);\n+    assertEquals(\"goog\", aliasSpy.observedDefinitions.get(\"g\"));\n+  }\n+\n+  public void testRecordMultipleAliases() {\n+    String fullJsCode = GOOG_SCOPE_START_BLOCK\n+        + \"var g = goog;\\n var b= g.bar;\\n var f = goog.something.foo;\"\n+        + \"g.dom.createElement(g.dom.TagName.DIV);\\n b.foo();\"\n+        + GOOG_SCOPE_END_BLOCK;\n+    String expectedJsCode =\n+        \"goog.dom.createElement(goog.dom.TagName.DIV);\\n goog.bar.foo();\";\n+    TransformationHandlerSpy spy = new TransformationHandlerSpy();\n+    transformationHandler = spy;\n+    test(fullJsCode, expectedJsCode);\n+\n+    assertTrue(spy.observedPositions.containsKey(\"testcode\"));\n+    List<SourcePosition<AliasTransformation>> positions =\n+        spy.observedPositions.get(\"testcode\");\n+    assertEquals(1, positions.size());\n+    verifyAliasTransformationPosition(\n+        1, GOOG_SCOPE_LEN, 3, 1, positions.get(0));\n+\n+    assertEquals(1, spy.constructedAliases.size());\n+    AliasSpy aliasSpy = (AliasSpy) spy.constructedAliases.get(0);\n+    assertEquals(\"goog\", aliasSpy.observedDefinitions.get(\"g\"));\n+    assertEquals(\"g.bar\", aliasSpy.observedDefinitions.get(\"b\"));\n+    assertEquals(\"goog.something.foo\", aliasSpy.observedDefinitions.get(\"f\"));\n+  }\n+\n+  public void testRecordAliasFromMultipleGoogScope() {\n+    String firstGoogScopeBlock = GOOG_SCOPE_START_BLOCK\n+        + \"\\n var g = goog;\\n g.dom.createElement(g.dom.TagName.DIV);\\n\"\n+        + GOOG_SCOPE_END_BLOCK;\n+    String fullJsCode = firstGoogScopeBlock + \"\\n\\nvar l = abc.def;\\n\\n\"\n+        + GOOG_SCOPE_START_BLOCK\n+        + \"\\n var z = namespace.Zoo;\\n z.getAnimals(l);\\n\"\n+        + GOOG_SCOPE_END_BLOCK;\n+\n+    String expectedJsCode = \"goog.dom.createElement(goog.dom.TagName.DIV);\\n\"\n+        + \"\\n\\nvar l = abc.def;\\n\\n\" + \"\\n namespace.Zoo.getAnimals(l);\\n\";\n+\n+    TransformationHandlerSpy spy = new TransformationHandlerSpy();\n+    transformationHandler = spy;\n+    test(fullJsCode, expectedJsCode);\n+\n+\n+    assertTrue(spy.observedPositions.containsKey(\"testcode\"));\n+    List<SourcePosition<AliasTransformation>> positions =\n+        spy.observedPositions.get(\"testcode\");\n+    assertEquals(2, positions.size());\n+\n+    verifyAliasTransformationPosition(\n+        1, GOOG_SCOPE_LEN, 6, 0, positions.get(0));\n+\n+    verifyAliasTransformationPosition(\n+        8, GOOG_SCOPE_LEN, 11, 4, positions.get(1));\n+\n+    assertEquals(2, spy.constructedAliases.size());\n+    AliasSpy aliasSpy = (AliasSpy) spy.constructedAliases.get(0);\n+    assertEquals(\"goog\", aliasSpy.observedDefinitions.get(\"g\"));\n+\n+    aliasSpy = (AliasSpy) spy.constructedAliases.get(1);\n+    assertEquals(\"namespace.Zoo\", aliasSpy.observedDefinitions.get(\"z\"));\n+  }\n+\n+  private void verifyAliasTransformationPosition(int startLine, int startChar,\n+      int endLine, int endChar, SourcePosition<AliasTransformation> pos) {\n+    assertEquals(startLine, pos.getStartLine());\n+    assertEquals(startChar, pos.getPositionOnStartLine());\n+    assertTrue(\n+        \"expected endline >= \" + endLine + \".  Found \" + pos.getEndLine(),\n+        pos.getEndLine() >= endLine);\n+    assertTrue(\"expected endChar >= \" + endChar + \".  Found \"\n+        + pos.getPositionOnEndLine(), pos.getPositionOnEndLine() >= endChar);\n+  }\n+\n   @Override\n   protected ScopedAliases getProcessor(Compiler compiler) {\n-    return new ScopedAliases(\n-        compiler, CompilerOptions.NULL_ALIAS_TRANSFORMATION_HANDLER);\n+    return new ScopedAliases(compiler, transformationHandler);\n+  }\n+\n+  private static class TransformationHandlerSpy\n+      implements AliasTransformationHandler {\n+\n+    private final Map<String, List<SourcePosition<AliasTransformation>>>\n+        observedPositions = Maps.newHashMap();\n+\n+    public final List<AliasTransformation> constructedAliases =\n+        Lists.newArrayList();\n+\n+    @Override\n+    public AliasTransformation logAliasTransformation(\n+        String sourceFile, SourcePosition<AliasTransformation> position) {\n+      if(!observedPositions.containsKey(sourceFile)) {\n+        observedPositions.put(sourceFile,\n+            Lists.<SourcePosition<AliasTransformation>> newArrayList());\n+      }\n+      observedPositions.get(sourceFile).add(position);\n+      AliasTransformation spy = new AliasSpy();\n+      constructedAliases.add(spy);\n+      return spy;\n+    }\n+  }\n+\n+  private static class AliasSpy implements AliasTransformation {\n+    public final Map<String, String> observedDefinitions = Maps.newHashMap();\n+\n+    @Override\n+    public void addAlias(String alias, String definition) {\n+      observedDefinitions.put(alias, definition);\n+    }\n   }\n \n   private static class TypeVerifyingPass", "timestamp": 1302633962, "metainfo": ""}