{"sha": "e5d3e5e012871b87d2f2a59985bc6522bb571ee2", "log": "switch over to args4j (Nick) Fixes issue 11.  Revision created by MOE tool push_codebase. MOE_MIGRATION=   ", "commit": "\n--- a/src/com/google/javascript/jscomp/AbstractCommandLineRunner.java\n+++ b/src/com/google/javascript/jscomp/AbstractCommandLineRunner.java\n import com.google.common.collect.ImmutableList;\n import com.google.common.collect.Lists;\n import com.google.common.collect.Maps;\n-import com.google.common.flags.DocLevel;\n-import com.google.common.flags.Flag;\n-import com.google.common.flags.FlagSpec;\n-import com.google.common.flags.Flags;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.TokenStream;\n import com.google.protobuf.CodedOutputStream;\n \n   private final RunTimeStats runTimeStats = new RunTimeStats();\n \n-  AbstractCommandLineRunner(CommandLineConfig config) {\n-    this(config, System.out, System.err);\n-  }\n-\n-  AbstractCommandLineRunner(\n-      CommandLineConfig config, PrintStream out, PrintStream err) {\n-    this.config = config;\n+  AbstractCommandLineRunner() {\n+    this(System.out, System.err);\n+  }\n+\n+  AbstractCommandLineRunner(PrintStream out, PrintStream err) {\n+    this.config = new CommandLineConfig();\n     this.out = out;\n     this.err = err;\n+  }\n+\n+  /**\n+   * Get the command line config, so that it can be initialized.\n+   */\n+  protected CommandLineConfig getCommandLineConfig() {\n+    return config;\n   }\n \n   /**\n--- a/src/com/google/javascript/jscomp/CommandLineRunner.java\n+++ b/src/com/google/javascript/jscomp/CommandLineRunner.java\n package com.google.javascript.jscomp;\n \n import com.google.common.collect.Lists;\n-import com.google.common.flags.DocLevel;\n-import com.google.common.flags.Flag;\n-import com.google.common.flags.FlagSpec;\n-import com.google.common.flags.Flags;\n+import com.google.common.collect.Sets;\n import com.google.common.io.LimitInputStream;\n import com.google.javascript.jscomp.AbstractCommandLineRunner.CommandLineConfig;\n+\n+import org.kohsuke.args4j.CmdLineException;\n+import org.kohsuke.args4j.CmdLineParser;\n+import org.kohsuke.args4j.Option;\n+import org.kohsuke.args4j.OptionDef;\n+import org.kohsuke.args4j.spi.OptionHandler;\n+import org.kohsuke.args4j.spi.Parameters;\n+import org.kohsuke.args4j.spi.Setter;\n \n import java.io.IOException;\n import java.io.InputStream;\n import java.io.PrintStream;\n import java.util.List;\n+import java.util.Set;\n import java.util.logging.Level;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n import java.util.zip.ZipEntry;\n import java.util.zip.ZipInputStream;\n \n public class CommandLineRunner extends\n     AbstractCommandLineRunner<Compiler, CompilerOptions> {\n \n-  @FlagSpec(help = \"Prints out the parse tree and exits\",\n-      docLevel = DocLevel.SECRET)\n-  static final Flag<Boolean> FLAG_print_tree = Flag.value(false);\n-\n-  @FlagSpec(help = \"Runs the compile job many times, then prints out the \" +\n-      \"best phase ordering from this run\",\n-      docLevel = DocLevel.SECRET)\n-  static final Flag<Boolean> FLAG_compute_phase_ordering =\n-      Flag.value(false);\n-\n-  @FlagSpec(help = \"Prints a dot file describing the internal abstract syntax\"\n-      + \" tree and exits\",\n-      docLevel = DocLevel.SECRET)\n-  static final Flag<Boolean> FLAG_print_ast = Flag.value(false);\n-\n-  @FlagSpec(help = \"Prints a dot file describing the passes that will get run\"\n-      + \" and exits\",\n-      docLevel = DocLevel.SECRET)\n-  static final Flag<Boolean> FLAG_print_pass_graph = Flag.value(false);\n-\n-  @FlagSpec(help = \"Turns on extra sanity checks\", altName = \"dev_mode\",\n-      docLevel = DocLevel.SECRET)\n-  static final Flag<CompilerOptions.DevMode> FLAG_jscomp_dev_mode =\n-      Flag.value(CompilerOptions.DevMode.OFF);\n-\n-  // TODO(nicksantos): Make the next 2 flags package-private.\n-  @FlagSpec(help = \"The logging level (standard java.util.logging.Level\"\n-      + \" values) for Compiler progress. Does not control errors or\"\n-      + \" warnings for the JavaScript code under compilation\",\n-      docLevel = DocLevel.SECRET)\n-  public static final Flag<String> FLAG_logging_level =\n-      Flag.value(Level.WARNING.getName());\n-\n-  @FlagSpec(help = \"The file containing javascript externs. You may specify\"\n-      + \" multiple\")\n-  public static final Flag<List<String>> FLAG_externs = Flag.stringCollector();\n-\n-  @FlagSpec(help = \"The javascript filename. You may specify multiple\")\n-  static final Flag<List<String>> FLAG_js = Flag.stringCollector();\n-\n-  @FlagSpec(help = \"Primary output filename. If not specified, output is \" +\n-            \"written to stdout\")\n-  static final Flag<String> FLAG_js_output_file = Flag.value(\"\");\n-\n-  @FlagSpec(help = \"A javascript module specification. The format is \"\n-      + \"<name>:<num-js-files>[:[<dep>,...][:]]]. Module names must be \"\n-      + \"unique. Each dep is the name of a module that this module \"\n-      + \"depends on. Modules must be listed in dependency order, and js \"\n-      + \"source files must be listed in the corresponding order. Where \"\n-      + \"--module flags occur in relation to --js flags is unimportant\")\n-  static final Flag<List<String>> FLAG_module = Flag.stringCollector();\n-\n-  @FlagSpec(help = \"File containing the serialized version of the variable \"\n-      + \"renaming map produced by a previous compilation\")\n-  static final Flag<String> FLAG_variable_map_input_file =\n-      Flag.value(\"\");\n-\n-  @FlagSpec(help = \"File containing the serialized version of the property \"\n-      + \"renaming map produced by a previous compilation\",\n-      docLevel = DocLevel.SECRET)\n-  static final Flag<String> FLAG_property_map_input_file =\n-      Flag.value(\"\");\n-\n-  @FlagSpec(help = \"File where the serialized version of the variable \"\n-      + \"renaming map produced should be saved\",\n-      docLevel = DocLevel.SECRET)\n-  static final Flag<String> FLAG_variable_map_output_file =\n-      Flag.value(\"\");\n-\n-  @FlagSpec(help = \"If true, variable renaming and property renaming map \"\n-      + \"files will be produced as {binary name}_vars_map.out and \"\n-      + \"{binary name}_props_map.out. Note that this flag cannot be used \"\n-      + \"in conjunction with either variable_map_output_file or \"\n-      + \"property_map_output_file\",\n-      docLevel = DocLevel.SECRET)\n-  static final Flag<Boolean> FLAG_create_name_map_files =\n-      Flag.value(false);\n-\n-  @FlagSpec(help = \"File where the serialized version of the property \"\n-      + \"renaming map produced should be saved\")\n-  static final Flag<String> FLAG_property_map_output_file =\n-      Flag.value(\"\");\n-\n-  @FlagSpec(help = \"Check source validity but do not enforce Closure style \"\n-      + \"rules and conventions\")\n-  static final Flag<Boolean> FLAG_third_party = Flag.value(false);\n-\n-\n-  @FlagSpec(help = \"Controls how detailed the compilation summary is. Values:\"\n-      + \" 0 (never print summary), 1 (print summary only if there are \"\n-      + \"errors or warnings), 2 (print summary if type checking is on, \"\n-      + \"see --check_types), 3 (always print summary). The default level \"\n-      + \"is 1\")\n-  static final Flag<Integer> FLAG_summary_detail_level = Flag.value(1);\n-\n-  @FlagSpec(help = \"Interpolate output into this string at the place denoted\"\n-      + \" by the marker token %output%. See --output_wrapper_marker\")\n-  static final Flag<String> FLAG_output_wrapper = Flag.value(\"\");\n-\n-  @FlagSpec(help = \"Use this token as output marker in the value of\"\n-      + \" --output_wrapper\")\n-  static final Flag<String> FLAG_output_wrapper_marker =\n-      Flag.value(\"%output%\");\n-\n-  @FlagSpec(help = \"An output wrapper for a javascript module (optional). \"\n-      + \"The format is <name>:<wrapper>. The module name must correspond \"\n-      + \"with a module specified using --module. The wrapper must \"\n-      + \"contain %s as the code placeholder\")\n-  static final Flag<List<String>> FLAG_module_wrapper =\n-      Flag.stringCollector();\n-\n-  @FlagSpec(help = \"Prefix for filenames of compiled js modules. \"\n-      + \"<module-name>.js will be appended to this prefix. Directories \"\n-      + \"will be created as needed. Use with --module\")\n-  static final Flag<String> FLAG_module_output_path_prefix =\n-      Flag.value(\"./\");\n-\n-  @FlagSpec(help = \"If specified, a source map file mapping the generated \" +\n-            \"source files back to the original source file will be \" +\n-            \"output to the specified path. The %outname% placeholder will \" +\n-            \"expand to the name of the output file that the source map \" +\n-            \"corresponds to.\")\n-  static final Flag<String> FLAG_create_source_map =\n-      Flag.value(\"\");\n-\n-  @FlagSpec(help = \"Make the named class of warnings an error. Options:\" +\n-      DiagnosticGroups.DIAGNOSTIC_GROUP_NAMES)\n-  static final Flag<List<String>> FLAG_jscomp_error =\n-      Flag.stringCollector();\n-\n-  @FlagSpec(help = \"Make the named class of warnings a normal warning. \" +\n-                \"Options:\" + DiagnosticGroups.DIAGNOSTIC_GROUP_NAMES)\n-  static final Flag<List<String>> FLAG_jscomp_warning =\n-      Flag.stringCollector();\n-\n-  @FlagSpec(help = \"Turn off the named class of warnings. Options:\" +\n-      DiagnosticGroups.DIAGNOSTIC_GROUP_NAMES)\n-  static final Flag<List<String>> FLAG_jscomp_off =\n-      Flag.stringCollector();\n-\n-  @FlagSpec(altName = \"D\",\n-      help = \"Override the value of a variable annotated @define. \" +\n-      \"The format is <name>[=<val>], where <name> is the name of a @define \" +\n-      \"variable and <val> is a boolean, number, or a single-quoted string \" +\n-      \"that contains no single quotes. If [=<val>] is omitted, \" +\n-      \"the variable is marked true\")\n-  static final Flag<List<String>> FLAG_define = Flag.stringCollector();\n-\n-  @FlagSpec(help = \"Input charset for all files.\")\n-  static final Flag<String> FLAG_charset = Flag.value(\"\");\n-\n-  @FlagSpec(help = \"Specifies the compilation level to use. Options: \" +\n-            \"WHITESPACE_ONLY, SIMPLE_OPTIMIZATIONS, ADVANCED_OPTIMIZATIONS\")\n-  static final Flag<CompilationLevel> FLAG_compilation_level\n-      = Flag.value(CompilationLevel.SIMPLE_OPTIMIZATIONS);\n-\n-  @FlagSpec(help = \"Specifies the warning level to use. Options: \" +\n-            \"QUIET, DEFAULT, VERBOSE\")\n-  static final Flag<WarningLevel> FLAG_warning_level\n-      = Flag.value(WarningLevel.DEFAULT);\n-\n-  @FlagSpec(help = \"Specifies whether the default externs should be excluded\")\n-  static final Flag<Boolean> FLAG_use_only_custom_externs\n-      = Flag.value(false);\n-\n-  @FlagSpec(help = \"Enable debugging options\")\n-  static final Flag<Boolean> FLAG_debug = Flag.value(false);\n+  private static class Flags {\n+    @Option(name = \"--print_tree\",\n+        handler = BooleanOptionHandler.class,\n+        usage = \"Prints out the parse tree and exits\")\n+    private boolean print_tree = false;\n+\n+    @Option(name = \"--compute_phase_ordering\",\n+        handler = BooleanOptionHandler.class,\n+        usage = \"Runs the compile job many times, then prints out the \" +\n+        \"best phase ordering from this run\")\n+    private boolean compute_phase_ordering = false;\n+\n+    @Option(name = \"--print_ast\",\n+        handler = BooleanOptionHandler.class,\n+        usage = \"Prints a dot file describing the internal abstract syntax\"\n+        + \" tree and exits\")\n+    private boolean print_ast = false;\n+\n+    @Option(name = \"--print_pass_graph\",\n+        usage = \"Prints a dot file describing the passes that will get run\"\n+        + \" and exits\")\n+    private boolean print_pass_graph = false;\n+\n+    @Option(name = \"--jscomp_dev_mode\",\n+        usage = \"Turns on extra sanity checks\",\n+        aliases = {\"--dev_mode\"})\n+    private CompilerOptions.DevMode jscomp_dev_mode =\n+        CompilerOptions.DevMode.OFF;\n+\n+    // TODO(nicksantos): Make the next 2 flags package-private.\n+    @Option(name = \"--logging_level\",\n+        usage = \"The logging level (standard java.util.logging.Level\"\n+        + \" values) for Compiler progress. Does not control errors or\"\n+        + \" warnings for the JavaScript code under compilation\")\n+    private String logging_level = Level.WARNING.getName();\n+\n+    @Option(name = \"--externs\",\n+        usage = \"The file containing javascript externs. You may specify\"\n+        + \" multiple\")\n+    private List<String> externs = Lists.newArrayList();\n+\n+    @Option(name = \"--js\",\n+        usage = \"The javascript filename. You may specify multiple\")\n+    private List<String> js = Lists.newArrayList();\n+\n+    @Option(name = \"--js_output_file\",\n+        usage = \"Primary output filename. If not specified, output is \" +\n+        \"written to stdout\")\n+    private String js_output_file = \"\";\n+\n+    @Option(name = \"--module\",\n+        usage = \"A javascript module specification. The format is \"\n+        + \"<name>:<num-js-files>[:[<dep>,...][:]]]. Module names must be \"\n+        + \"unique. Each dep is the name of a module that this module \"\n+        + \"depends on. Modules must be listed in dependency order, and js \"\n+        + \"source files must be listed in the corresponding order. Where \"\n+        + \"--module flags occur in relation to --js flags is unimportant\")\n+    private List<String> module = Lists.newArrayList();\n+\n+    @Option(name = \"--variable_map_input_file\",\n+        usage = \"File containing the serialized version of the variable \"\n+        + \"renaming map produced by a previous compilation\")\n+    private String variable_map_input_file = \"\";\n+\n+    @Option(name = \"--property_map_input_file\",\n+        usage = \"File containing the serialized version of the property \"\n+        + \"renaming map produced by a previous compilation\")\n+    private String property_map_input_file = \"\";\n+\n+    @Option(name = \"--variable_map_output_file\",\n+        usage = \"File where the serialized version of the variable \"\n+        + \"renaming map produced should be saved\")\n+    private String variable_map_output_file = \"\";\n+\n+    @Option(name = \"--create_name_map_files\",\n+        handler = BooleanOptionHandler.class,\n+        usage = \"If true, variable renaming and property renaming map \"\n+        + \"files will be produced as {binary name}_vars_map.out and \"\n+        + \"{binary name}_props_map.out. Note that this flag cannot be used \"\n+        + \"in conjunction with either variable_map_output_file or \"\n+        + \"property_map_output_file\")\n+    private boolean create_name_map_files = false;\n+\n+    @Option(name = \"--property_map_output_file\",\n+        usage = \"File where the serialized version of the property \"\n+        + \"renaming map produced should be saved\")\n+    private String property_map_output_file = \"\";\n+\n+    @Option(name = \"--third_party\",\n+        handler = BooleanOptionHandler.class,\n+        usage = \"Check source validity but do not enforce Closure style \"\n+        + \"rules and conventions\")\n+    private boolean third_party = false;\n+\n+\n+    @Option(name = \"--summary_detail_level\",\n+        usage = \"Controls how detailed the compilation summary is. Values:\"\n+        + \" 0 (never print summary), 1 (print summary only if there are \"\n+        + \"errors or warnings), 2 (print summary if type checking is on, \"\n+        + \"see --check_types), 3 (always print summary). The default level \"\n+        + \"is 1\")\n+    private int summary_detail_level = 1;\n+\n+    @Option(name = \"--output_wrapper\",\n+        usage = \"Interpolate output into this string at the place denoted\"\n+        + \" by the marker token %output%. See --output_wrapper_marker\")\n+    private String output_wrapper = \"\";\n+\n+    @Option(name = \"--output_wrapper_marker\",\n+        usage = \"Use this token as output marker in the value of\"\n+        + \" --output_wrapper\")\n+    private String output_wrapper_marker = \"%output%\";\n+\n+    @Option(name = \"--module_wrapper\",\n+        usage = \"An output wrapper for a javascript module (optional). \"\n+        + \"The format is <name>:<wrapper>. The module name must correspond \"\n+        + \"with a module specified using --module. The wrapper must \"\n+        + \"contain %s as the code placeholder\")\n+    private List<String> module_wrapper = Lists.newArrayList();\n+\n+    @Option(name = \"--module_output_path_prefix\",\n+        usage = \"Prefix for filenames of compiled js modules. \"\n+        + \"<module-name>.js will be appended to this prefix. Directories \"\n+        + \"will be created as needed. Use with --module\")\n+    private String module_output_path_prefix = \"./\";\n+\n+    @Option(name = \"--create_source_map\",\n+        usage = \"If specified, a source map file mapping the generated \" +\n+        \"source files back to the original source file will be \" +\n+        \"output to the specified path. The %outname% placeholder will \" +\n+        \"expand to the name of the output file that the source map \" +\n+        \"corresponds to.\")\n+    private String create_source_map = \"\";\n+\n+    @Option(name = \"--jscomp_error\",\n+        usage = \"Make the named class of warnings an error. Options:\" +\n+        DiagnosticGroups.DIAGNOSTIC_GROUP_NAMES)\n+    private List<String> jscomp_error = Lists.newArrayList();\n+\n+    @Option(name = \"--jscomp_warning\",\n+        usage = \"Make the named class of warnings a normal warning. \" +\n+        \"Options:\" + DiagnosticGroups.DIAGNOSTIC_GROUP_NAMES)\n+    private List<String> jscomp_warning =  Lists.newArrayList();\n+\n+    @Option(name = \"--jscomp_off\",\n+        usage = \"Turn off the named class of warnings. Options:\" +\n+        DiagnosticGroups.DIAGNOSTIC_GROUP_NAMES)\n+    private List<String> jscomp_off = Lists.newArrayList();\n+\n+    @Option(name = \"--define\",\n+        aliases = {\"--D\"},\n+        usage = \"Override the value of a variable annotated @define. \" +\n+        \"The format is <name>[=<val>], where <name> is the name of a @define \" +\n+        \"variable and <val> is a boolean, number, or a single-quoted string \" +\n+        \"that contains no single quotes. If [=<val>] is omitted, \" +\n+        \"the variable is marked true\")\n+    private List<String> define = Lists.newArrayList();\n+\n+    @Option(name = \"--charset\",\n+        usage = \"Input charset for all files.\")\n+    private String charset = \"\";\n+\n+    @Option(name = \"--compilation_level\",\n+        usage = \"Specifies the compilation level to use. Options: \" +\n+        \"WHITESPACE_ONLY, SIMPLE_OPTIMIZATIONS, ADVANCED_OPTIMIZATIONS\")\n+    private CompilationLevel compilation_level =\n+        CompilationLevel.SIMPLE_OPTIMIZATIONS;\n+\n+    @Option(name = \"--warning_level\",\n+        usage = \"Specifies the warning level to use. Options: \" +\n+        \"QUIET, DEFAULT, VERBOSE\")\n+    private WarningLevel warning_level = WarningLevel.DEFAULT;\n+\n+    @Option(name = \"--use_only_custom_externs\",\n+        handler = BooleanOptionHandler.class,\n+        usage = \"Specifies whether the default externs should be excluded\")\n+    private boolean use_only_custom_externs = false;\n+\n+    @Option(name = \"--debug\",\n+        handler = BooleanOptionHandler.class,\n+        usage = \"Enable debugging options\")\n+    private boolean debug = false;\n+\n+    @Option(name = \"--formatting\",\n+        usage = \"Specifies which formatting options, if any, should be \"\n+        + \"applied to the output JS. Options: \"\n+        + \"PRETTY_PRINT, PRINT_INPUT_DELIMITER\")\n+    private List<FormattingOption> formatting = Lists.newArrayList();\n+\n+    @Option(name = \"--process_closure_primitives\",\n+        handler = BooleanOptionHandler.class,\n+        usage = \"Processes built-ins from the Closure library, such as \"\n+        + \"goog.require(), goog.provide(), and goog.exportSymbol()\")\n+    private boolean process_closure_primitives = true;\n+\n+    // Our own option parser to be backwards-compatible.\n+    // It needs to be public because of the crazy reflection that args4j does.\n+    public static class BooleanOptionHandler extends OptionHandler<Boolean> {\n+      private static final Set<String> TRUES =\n+          Sets.newHashSet(\"true\", \"on\", \"yes\", \"1\");\n+      private static final Set<String> FALSES =\n+          Sets.newHashSet(\"false\", \"off\", \"no\", \"0\");\n+\n+      public BooleanOptionHandler(\n+          CmdLineParser parser, OptionDef option,\n+          Setter<? super Boolean> setter) {\n+        super(parser, option, setter);\n+      }\n+\n+      @Override\n+      public int parseArguments(Parameters params) throws CmdLineException {\n+        String param = params.getParameter(0);\n+        if (param == null) {\n+          setter.addValue(true);\n+          return 0;\n+        } else {\n+          String lowerParam = param.toLowerCase();\n+          if (TRUES.contains(lowerParam)) {\n+            setter.addValue(true);\n+          } else if (FALSES.contains(lowerParam)) {\n+            setter.addValue(false);\n+          } else {\n+            throw new CmdLineException(owner,\n+               \"Illegal boolean value: \" + lowerParam);\n+          }\n+          return 1;\n+        }\n+      }\n+\n+      @Override\n+      public String getDefaultMetaVariable() {\n+        return null;\n+      }\n+    }\n+  }\n \n   /**\n    * Set of options that can be used with the --formatting flag.\n     }\n   }\n \n-  @FlagSpec(help = \"Specifies which formatting options, if any, should be \"\n-      + \"applied to the output JS. Options: \"\n-      + \"PRETTY_PRINT, PRINT_INPUT_DELIMITER\")\n-  static final Flag<List<FormattingOption>> FLAG_formatting\n-      = Flag.enumList(FormattingOption.class);\n-\n-  @FlagSpec(help = \"Processes built-ins from the Closure library, such as \"\n-      + \"goog.require(), goog.provide(), and goog.exportSymbol()\")\n-  static final Flag<Boolean> FLAG_process_closure_primitives\n-      = Flag.value(true);\n+  private final Flags flags = new Flags();\n \n   /**\n    * Create a new command-line runner. You should only need to call\n    * the constructor if you're extending this class. Otherwise, the main\n    * method should instantiate it.\n    */\n-  protected CommandLineRunner(String[] args) {\n-    super(readConfigFromFlags(args));\n-  }\n-\n-  protected CommandLineRunner(String[] args, PrintStream out, PrintStream err) {\n-    super(readConfigFromFlags(args), out, err);\n-  }\n-\n-  private static CommandLineConfig readConfigFromFlags(String[] args) {\n-    Flags.parse(args);\n-    return new CommandLineConfig()\n-        .setPrintTree(FLAG_print_tree.get())\n-        .setComputePhaseOrdering(FLAG_compute_phase_ordering.get())\n-        .setPrintAst(FLAG_print_ast.get())\n-        .setPrintPassGraph(FLAG_print_pass_graph.get())\n-        .setJscompDevMode(FLAG_jscomp_dev_mode.get())\n-        .setLoggingLevel(FLAG_logging_level.get())\n-        .setExterns(FLAG_externs.get())\n-        .setJs(FLAG_js.get())\n-        .setJsOutputFile(FLAG_js_output_file.get())\n-        .setModule(FLAG_module.get())\n-        .setVariableMapInputFile(FLAG_variable_map_input_file.get())\n-        .setPropertyMapInputFile(FLAG_property_map_input_file.get())\n-        .setVariableMapOutputFile(FLAG_variable_map_output_file.get())\n-        .setCreateNameMapFiles(FLAG_create_name_map_files.get())\n-        .setPropertyMapOutputFile(FLAG_property_map_output_file.get())\n-        .setThirdParty(FLAG_third_party.get())\n-        .setSummaryDetailLevel(FLAG_summary_detail_level.get())\n-        .setOutputWrapper(FLAG_output_wrapper.get())\n-        .setOutputWrapperMarker(FLAG_output_wrapper_marker.get())\n-        .setModuleWrapper(FLAG_module_wrapper.get())\n-        .setModuleOutputPathPrefix(FLAG_module_output_path_prefix.get())\n-        .setCreateSourceMap(FLAG_create_source_map.get())\n-        .setJscompError(FLAG_jscomp_error.get())\n-        .setJscompWarning(FLAG_jscomp_warning.get())\n-        .setJscompOff(FLAG_jscomp_off.get())\n-        .setDefine(FLAG_define.get())\n-        .setCharset(FLAG_charset.get());\n+  protected CommandLineRunner(String[] args)\n+      throws CmdLineException {\n+    super();\n+    initConfigFromFlags(args, System.err);\n+  }\n+\n+  protected CommandLineRunner(String[] args, PrintStream out, PrintStream err)\n+      throws CmdLineException {\n+    super(out, err);\n+    initConfigFromFlags(args, err);\n+  }\n+\n+  private void initConfigFromFlags(\n+      String[] args, PrintStream err)\n+      throws CmdLineException {\n+    // Args4j has a different format that the old command-line parser.\n+    // So we use some voodoo to get the args into the format that args4j\n+    // expects.\n+    Pattern argPattern = Pattern.compile(\"(--[a-zA-Z_]+)=(.*)\");\n+    Pattern quotesPattern = Pattern.compile(\"^['\\\"](.*)['\\\"]$\");\n+    List<String> processedArgs = Lists.newArrayList();\n+    for (String arg : args) {\n+      Matcher matcher = argPattern.matcher(arg);\n+      if (matcher.matches()) {\n+        processedArgs.add(matcher.group(1));\n+\n+        String value = matcher.group(2);\n+        Matcher quotesMatcher = quotesPattern.matcher(value);\n+        if (quotesMatcher.matches()) {\n+          processedArgs.add(quotesMatcher.group(1));\n+        } else {\n+          processedArgs.add(value);\n+        }\n+      } else {\n+        processedArgs.add(arg);\n+      }\n+    }\n+\n+    CmdLineParser parser = new CmdLineParser(flags);\n+    try {\n+      parser.parseArgument(processedArgs.toArray(new String[] {}));\n+    } catch (CmdLineException e) {\n+      err.println(e.getMessage());\n+      parser.printUsage(err);\n+      throw e;\n+    }\n+    getCommandLineConfig()\n+        .setPrintTree(flags.print_tree)\n+        .setComputePhaseOrdering(flags.compute_phase_ordering)\n+        .setPrintAst(flags.print_ast)\n+        .setPrintPassGraph(flags.print_pass_graph)\n+        .setJscompDevMode(flags.jscomp_dev_mode)\n+        .setLoggingLevel(flags.logging_level)\n+        .setExterns(flags.externs)\n+        .setJs(flags.js)\n+        .setJsOutputFile(flags.js_output_file)\n+        .setModule(flags.module)\n+        .setVariableMapInputFile(flags.variable_map_input_file)\n+        .setPropertyMapInputFile(flags.property_map_input_file)\n+        .setVariableMapOutputFile(flags.variable_map_output_file)\n+        .setCreateNameMapFiles(flags.create_name_map_files)\n+        .setPropertyMapOutputFile(flags.property_map_output_file)\n+        .setThirdParty(flags.third_party)\n+        .setSummaryDetailLevel(flags.summary_detail_level)\n+        .setOutputWrapper(flags.output_wrapper)\n+        .setOutputWrapperMarker(flags.output_wrapper_marker)\n+        .setModuleWrapper(flags.module_wrapper)\n+        .setModuleOutputPathPrefix(flags.module_output_path_prefix)\n+        .setCreateSourceMap(flags.create_source_map)\n+        .setJscompError(flags.jscomp_error)\n+        .setJscompWarning(flags.jscomp_warning)\n+        .setJscompOff(flags.jscomp_off)\n+        .setDefine(flags.define)\n+        .setCharset(flags.charset);\n   }\n \n   @Override\n   protected CompilerOptions createOptions() {\n     CompilerOptions options = new CompilerOptions();\n     options.setCodingConvention(new ClosureCodingConvention());\n-    CompilationLevel level = FLAG_compilation_level.get();\n+    CompilationLevel level = flags.compilation_level;\n     level.setOptionsForCompilationLevel(options);\n-    if (FLAG_debug.get()) {\n+    if (flags.debug) {\n       level.setDebugOptionsForCompilationLevel(options);\n     }\n \n-    WarningLevel wLevel = FLAG_warning_level.get();\n+    WarningLevel wLevel = flags.warning_level;\n     wLevel.setOptionsForWarningLevel(options);\n-    for (FormattingOption formattingOption : FLAG_formatting.get()) {\n+    for (FormattingOption formattingOption : flags.formatting) {\n       formattingOption.applyToOptions(options);\n     }\n-    if (FLAG_process_closure_primitives.get()) {\n+    if (flags.process_closure_primitives) {\n       options.closurePass = true;\n     }\n \n   protected List<JSSourceFile> createExterns() throws FlagUsageException,\n       IOException {\n     List<JSSourceFile> externs = super.createExterns();\n-    if (!FLAG_use_only_custom_externs.get()) {\n+    if (!flags.use_only_custom_externs) {\n       List<JSSourceFile> defaultExterns = getDefaultExterns();\n       defaultExterns.addAll(externs);\n       return defaultExterns;\n    * Runs the Compiler. Exits cleanly in the event of an error.\n    */\n   public static void main(String[] args) {\n-    (new CommandLineRunner(args)).run();\n+    try {\n+      (new CommandLineRunner(args)).run();\n+    } catch (CmdLineException e) {\n+      System.exit(-1);\n+    }\n   }\n }\n--- a/test/com/google/javascript/jscomp/CommandLineRunnerTest.java\n+++ b/test/com/google/javascript/jscomp/CommandLineRunnerTest.java\n \n import com.google.common.base.Joiner;\n import com.google.common.collect.Lists;\n-import com.google.common.flags.Flags;\n import com.google.javascript.rhino.Node;\n \n import junit.framework.TestCase;\n \n+import org.kohsuke.args4j.CmdLineException;\n+\n import java.io.IOException;\n+import java.util.List;\n \n /**\n  * Tests for {@link CommandLineRunner}.\n \n   // If set to true, uses comparison by string instead of by AST.\n   private boolean useStringComparison = false;\n+\n+  private List<String> args = Lists.newArrayList();\n \n   /** Externs for the test */\n   private final JSSourceFile[] externs = new JSSourceFile[] {\n   @Override\n   public void setUp() throws Exception {\n     super.setUp();\n-    Flags.disableStateCheckingForTest();\n-    Flags.resetAllFlagsForTest();\n     lastCompiler = null;\n     useStringComparison = false;\n+    args.clear();\n   }\n \n   @Override\n   public void tearDown() throws Exception {\n-    Flags.resetAllFlagsForTest();\n-\n-    // NOTE(nicksantos): ANT needs this for some weird reason.\n-    CommandLineRunner.FLAG_define.resetForTest();\n-    CommandLineRunner.FLAG_jscomp_off.resetForTest();\n-    CommandLineRunner.FLAG_jscomp_warning.resetForTest();\n-    CommandLineRunner.FLAG_jscomp_error.resetForTest();\n-\n-    Flags.enableStateCheckingForTest();\n     super.tearDown();\n   }\n \n   }\n \n   public void testTypeCheckingOnWithVerbose() {\n-    CommandLineRunner.FLAG_warning_level.setForTest(WarningLevel.VERBOSE);\n+    args.add(\"--warning_level=VERBOSE\");\n     test(\"function f(x) { return x; } f();\", TypeCheck.WRONG_ARGUMENT_COUNT);\n   }\n \n   public void testTypeCheckOverride1() {\n-    CommandLineRunner.FLAG_warning_level.setForTest(WarningLevel.VERBOSE);\n-    CommandLineRunner.FLAG_jscomp_off.setForTest(\n-        Lists.newArrayList(\"checkTypes\"));\n+    args.add(\"--warning_level=VERBOSE\");\n+    args.add(\"--jscomp_off=checkTypes\");\n     testSame(\"var x = x || {}; x.f = function() {}; x.f(3);\");\n   }\n \n   public void testTypeCheckOverride2() {\n-    CommandLineRunner.FLAG_warning_level.setForTest(WarningLevel.DEFAULT);\n+    args.add(\"--warning_level=DEFAULT\");\n     testSame(\"var x = x || {}; x.f = function() {}; x.f(3);\");\n \n-    CommandLineRunner.FLAG_jscomp_warning.setForTest(\n-        Lists.newArrayList(\"checkTypes\"));\n+    args.add(\"--jscomp_warning=checkTypes\");\n     test(\"var x = x || {}; x.f = function() {}; x.f(3);\",\n          TypeCheck.WRONG_ARGUMENT_COUNT);\n   }\n \n   public void testCheckSymbolsOffForDefault() {\n-    CommandLineRunner.FLAG_warning_level.setForTest(WarningLevel.DEFAULT);\n+    args.add(\"--warning_level=DEFAULT\");\n     test(\"x = 3; var y; var y;\", \"x=3; var y;\");\n   }\n \n   public void testCheckSymbolsOnForVerbose() {\n-    CommandLineRunner.FLAG_warning_level.setForTest(WarningLevel.VERBOSE);\n+    args.add(\"--warning_level=VERBOSE\");\n     test(\"x = 3;\", VarCheck.UNDEFINED_VAR_ERROR);\n     test(\"var y; var y;\", SyntacticScopeCreator.VAR_MULTIPLY_DECLARED_ERROR);\n   }\n \n   public void testCheckSymbolsOverrideForVerbose() {\n-    CommandLineRunner.FLAG_warning_level.setForTest(WarningLevel.VERBOSE);\n-    CommandLineRunner.FLAG_jscomp_off.setForTest(\n-        Lists.newArrayList(\"undefinedVars\"));\n+    args.add(\"--warning_level=VERBOSE\");\n+    args.add(\"--jscomp_off=undefinedVars\");\n     testSame(\"x = 3;\");\n   }\n \n   public void testCheckUndefinedProperties() {\n-    CommandLineRunner.FLAG_warning_level.setForTest(WarningLevel.VERBOSE);\n-    CommandLineRunner.FLAG_jscomp_error.setForTest(\n-        Lists.newArrayList(\"missingProperties\"));\n+    args.add(\"--warning_level=VERBOSE\");\n+    args.add(\"--jscomp_error=missingProperties\");\n     test(\"var x = {}; var y = x.bar;\", TypeCheck.INEXISTENT_PROPERTY);\n   }\n \n   }\n \n   public void testDefineFlag() {\n-    CommandLineRunner.FLAG_define.setForTest(\n-        Lists.newArrayList(\"FOO\", \"BAR=5\"));\n+    args.add(\"--define=FOO\");\n+    args.add(\"--define=\\\"BAR=5\\\"\");\n     test(\"/** @define {boolean} */ var FOO = false;\" +\n          \"/** @define {number} */ var BAR = 3;\",\n          \"var FOO = true, BAR = 5;\");\n   }\n \n   public void testQuietMode() {\n-    CommandLineRunner.FLAG_warning_level.setForTest(WarningLevel.DEFAULT);\n+    args.add(\"--warning_level=DEFAULT\");\n     test(\"/** @type { not a type name } */ var x;\",\n          RhinoErrorReporter.PARSE_ERROR);\n-    CommandLineRunner.FLAG_warning_level.setForTest(WarningLevel.QUIET);\n+    args.add(\"--warning_level=QUIET\");\n     testSame(\"/** @type { not a type name } */ var x;\");\n   }\n \n   }\n \n   public void testIssue81() {\n-    CommandLineRunner.FLAG_compilation_level.setForTest(\n-        CompilationLevel.ADVANCED_OPTIMIZATIONS);\n+    args.add(\"--compilation_level=ADVANCED_OPTIMIZATIONS\");\n     useStringComparison = true;\n     test(\"eval('1'); var x = eval; x('2');\",\n          \"eval(\\\"1\\\");(0,eval)(\\\"2\\\");\");\n   }\n \n   public void testIssue115() {\n-    CommandLineRunner.FLAG_compilation_level.setForTest(\n-        CompilationLevel.SIMPLE_OPTIMIZATIONS);\n-    CommandLineRunner.FLAG_warning_level.setForTest(\n-        WarningLevel.VERBOSE);\n+    args.add(\"--compilation_level=SIMPLE_OPTIMIZATIONS\");\n+    args.add(\"--warning_level=VERBOSE\");\n     test(\"function f() { \" +\n          \"  var arguments = Array.prototype.slice.call(arguments, 0);\" +\n          \"  return arguments[0]; \" +\n   }\n \n   public void testDebugFlag1() {\n-    CommandLineRunner.FLAG_compilation_level.setForTest(\n-        CompilationLevel.SIMPLE_OPTIMIZATIONS);\n-    CommandLineRunner.FLAG_debug.setForTest(false);\n+    args.add(\"--compilation_level=SIMPLE_OPTIMIZATIONS\");\n+    args.add(\"--debug=false\");\n     testSame(\"function foo(a) {}\");\n   }\n \n   public void testDebugFlag2() {\n-    CommandLineRunner.FLAG_compilation_level.setForTest(\n-        CompilationLevel.SIMPLE_OPTIMIZATIONS);\n-    CommandLineRunner.FLAG_debug.setForTest(true);\n+    args.add(\"--compilation_level=SIMPLE_OPTIMIZATIONS\");\n+    args.add(\"--debug=true\");\n     test(\"function foo(a) {}\",\n          \"function foo($a$$) {}\");\n   }\n \n   public void testDebugFlag3() {\n-    CommandLineRunner.FLAG_compilation_level.setForTest(\n-        CompilationLevel.ADVANCED_OPTIMIZATIONS);\n-    CommandLineRunner.FLAG_warning_level.setForTest(\n-        WarningLevel.QUIET);\n-    CommandLineRunner.FLAG_debug.setForTest(false);\n+    args.add(\"--compilation_level=ADVANCED_OPTIMIZATIONS\");\n+    args.add(\"--warning_level=QUIET\");\n+    args.add(\"--debug=false\");\n     test(\"function Foo() {};\" +\n          \"Foo.x = 1;\" +\n          \"function f() {throw new Foo().x;} f();\",\n   }\n \n   public void testDebugFlag4() {\n-    CommandLineRunner.FLAG_compilation_level.setForTest(\n-        CompilationLevel.ADVANCED_OPTIMIZATIONS);\n-    CommandLineRunner.FLAG_warning_level.setForTest(\n-        WarningLevel.QUIET);\n-    CommandLineRunner.FLAG_debug.setForTest(true);\n+    args.add(\"--compilation_level=ADVANCED_OPTIMIZATIONS\");\n+    args.add(\"--warning_level=QUIET\");\n+    args.add(\"--debug=true\");\n     test(\"function Foo() {};\" +\n         \"Foo.x = 1;\" +\n         \"function f() {throw new Foo().x;} f();\",\n   }\n \n   private Compiler compile(String[] original) {\n-    CommandLineRunner runner = new CommandLineRunner(new String[] {});\n+    String[] argStrings = args.toArray(new String[] {});\n+    CommandLineRunner runner = null;\n+    try {\n+      runner = new CommandLineRunner(argStrings);\n+    } catch (CmdLineException e) {\n+      throw new RuntimeException(e);\n+    }\n     Compiler compiler = runner.createCompiler();\n     lastCompiler = compiler;\n     JSSourceFile[] inputs = new JSSourceFile[original.length];\n   }\n \n   private Node parse(String[] original) {\n-    CommandLineRunner runner = new CommandLineRunner(new String[] {});\n+    String[] argStrings = args.toArray(new String[] {});\n+    CommandLineRunner runner = null;\n+    try {\n+      runner = new CommandLineRunner(argStrings);\n+    } catch (CmdLineException e) {\n+      throw new RuntimeException(e);\n+    }\n     Compiler compiler = runner.createCompiler();\n     JSSourceFile[] inputs = new JSSourceFile[original.length];\n     for (int i = 0; i < inputs.length; i++) {", "timestamp": 1267839219, "metainfo": ""}