{"sha": "cc628d6050107e3dfcc7bd2748708c12ef15b4e0", "log": "Add multiple extends annotations for interfaces in JsDoc  R=nicksantos,johnlenz DELTA=151  (143 added, 1 deleted, 7 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=1505   ", "commit": "\n--- a/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\n+++ b/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\n \n import com.google.common.base.Preconditions;\n import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Lists;\n import com.google.common.collect.Sets;\n import com.google.javascript.jscomp.mozilla.rhino.ErrorReporter;\n import com.google.javascript.jscomp.mozilla.rhino.ast.Comment;\n import java.util.HashSet;\n import java.util.Map;\n import java.util.Set;\n+import java.util.List;\n \n /**\n  * A parser for JSDoc comments.\n \n     JsDocToken token = next();\n \n+    List<ExtendedTypeInfo> extendedTypes = Lists.newArrayList();\n+\n     // Always record that we have a comment.\n     if (jsdocBuilder.shouldParseDocumentation()) {\n       ExtractionInfo blockInfo = extractBlockComment(token);\n                     type = createJSTypeExpression(typeNode);\n \n                     if (annotation == Annotation.EXTENDS) {\n-                      if (!jsdocBuilder.recordBaseType(type)) {\n-                        parser.addTypeWarning(\n-                            \"msg.jsdoc.incompat.type\", lineno, charno);\n-                      }\n+                      // record the extended type, check later\n+                      extendedTypes.add(new ExtendedTypeInfo(\n+                          type, stream.getLineno(), stream.getCharno()));\n                     } else {\n                       Preconditions.checkState(\n                           annotation == Annotation.IMPLEMENTS);\n           if (hasParsedFileOverviewDocInfo()) {\n             fileOverviewJSDocInfo = retrieveAndResetParsedJSDocInfo();\n           }\n-\n+          checkExtendedTypes(extendedTypes);\n           return true;\n \n         case EOF:\n           jsdocBuilder.build(null);\n           parser.addParserWarning(\"msg.unexpected.eof\",\n               stream.getLineno(), stream.getCharno());\n+          checkExtendedTypes(extendedTypes);\n           return false;\n \n         case EOL:\n \n       // next token\n       token = next();\n+    }\n+  }\n+\n+  private void checkExtendedTypes(List<ExtendedTypeInfo> extendedTypes) {\n+    for (ExtendedTypeInfo typeInfo : extendedTypes) {\n+      // If interface, record the multiple extended interfaces\n+      if (jsdocBuilder.isInterfaceRecorded()) {\n+        if (!jsdocBuilder.recordExtendedInterface(typeInfo.type)) {\n+          parser.addParserWarning(\"msg.jsdoc.extends.duplicate\",\n+              typeInfo.lineno, typeInfo.charno);\n+        }\n+      }\n+\n+      // For interfaces, still record the first extended type as base type\n+      // It's the temporary setting and will be changed when multiple\n+      // extends for interfaces are done\n+      if (!jsdocBuilder.recordBaseType(typeInfo.type) &&\n+          !jsdocBuilder.isInterfaceRecorded()) {\n+        parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n+            typeInfo.lineno, typeInfo.charno);\n+      }\n     }\n   }\n \n     public ExtractionInfo(String string, JsDocToken token) {\n       this.string = string;\n       this.token = token;\n+    }\n+  }\n+\n+  /**\n+   * Tuple for recording extended types\n+   */\n+  private static class ExtendedTypeInfo {\n+    final JSTypeExpression type;\n+    final int lineno;\n+    final int charno;\n+\n+    public ExtendedTypeInfo(JSTypeExpression type, int lineno, int charno) {\n+      this.type = type;\n+      this.lineno = lineno;\n+      this.charno = charno;\n     }\n   }\n \n--- a/src/com/google/javascript/rhino/JSDocInfo.java\n+++ b/src/com/google/javascript/rhino/JSDocInfo.java\n \n     // Function information\n     JSTypeExpression baseType = null;\n+    List<JSTypeExpression> extendedInterfaces = null;\n     List<JSTypeExpression> implementedInterfaces = null;\n     Map<String, JSTypeExpression> parameters = null;\n     List<JSTypeExpression> thrownTypes = null;\n   }\n \n   /**\n+   * Adds an extended interface (for interface only).\n+   * Returns whether the type was added.\n+   * if the type was already present in the list, it won't get added again.\n+   */\n+  boolean addExtendedInterface(JSTypeExpression type) {\n+    lazyInitInfo();\n+    if (info.extendedInterfaces == null) {\n+      info.extendedInterfaces = Lists.newArrayListWithCapacity(2);\n+    }\n+    if (info.extendedInterfaces.contains(type)) {\n+      return false;\n+    }\n+    info.extendedInterfaces.add(type);\n+    return true;\n+  }\n+\n+  /**\n+   * Returns the interfaces extended by an interface\n+   *\n+   * @return An immutable list of JSTypeExpression objects that can\n+   *    be resolved to types.\n+   */\n+  public List<JSTypeExpression> getExtendedInterfaces() {\n+    if (info == null || info.extendedInterfaces == null) {\n+      return ImmutableList.of();\n+    }\n+    return Collections.unmodifiableList(info.extendedInterfaces);\n+  }\n+\n+  /**\n+   * Gets the number of extended interfaces specified\n+   */\n+  public int getExtendedInterfacesCount() {\n+    if (info == null || info.extendedInterfaces == null) {\n+      return 0;\n+    }\n+    return info.extendedInterfaces.size();\n+  }\n+\n+  /**\n    * Returns the deprecation reason or null if none specified.\n    */\n   public String getDeprecationReason() {\n     if (info != null) {\n       if (info.baseType != null) {\n         nodes.add(info.baseType.getRoot());\n+      }\n+\n+      if (info.extendedInterfaces != null) {\n+        for (JSTypeExpression interfaceType : info.extendedInterfaces) {\n+          nodes.add(interfaceType.getRoot());\n+        }\n       }\n \n       if (info.implementedInterfaces != null) {\n--- a/src/com/google/javascript/rhino/JSDocInfoBuilder.java\n+++ b/src/com/google/javascript/rhino/JSDocInfoBuilder.java\n   }\n \n   /**\n+   * Records an extended interface type.\n+   */\n+  public boolean recordExtendedInterface(JSTypeExpression interfaceType) {\n+    if (currentInfo.addExtendedInterface(interfaceType)) {\n+      populated = true;\n+      return true;\n+    } else {\n+      return false;\n+    }\n+  }\n+\n+  /**\n    * Records that we're lending to another name.\n    */\n   public boolean recordLends(String name) {\n         currentInfo.getParameterCount() > 0 ||\n         currentInfo.hasReturnType() ||\n         currentInfo.hasBaseType() ||\n+        currentInfo.getExtendedInterfacesCount() > 0 ||\n         currentInfo.getLendsName() != null ||\n         currentInfo.hasThisType() ||\n         hasAnySingletonTypeTags();\n--- a/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java\n+++ b/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java\n     /**  The JSDocInfo for this property. */\n     private JSDocInfo docInfo = null;\n \n-    private Property(JSType type, boolean inferred, boolean inExterns, Node propertyNode) {\n+    private Property(JSType type, boolean inferred, boolean inExterns,\n+        Node propertyNode) {\n       this.type = type;\n       this.inferred = inferred;\n       this.inExterns = inExterns;\n--- a/test/com/google/javascript/jscomp/DisambiguatePropertiesTest.java\n+++ b/test/com/google/javascript/jscomp/DisambiguatePropertiesTest.java\n     String js = \"\"\n         + \"/** @interface */ function I() {};\\n\"\n         + \"I.prototype.a;\\n\"\n-        + \"/** @interface \\n @implements I */ function I2() {};\\n\"\n+        + \"/** @interface \\n @extends I */ function I2() {};\\n\"\n         + \"/** @constructor \\n @implements I2 */\"\n         + \"function Foo() {};\\n\"\n         + \"Foo.prototype.a = 0;\\n\"\n--- a/test/com/google/javascript/jscomp/parsing/JsDocInfoParserTest.java\n+++ b/test/com/google/javascript/jscomp/parsing/JsDocInfoParserTest.java\n          \" * @interface \\n\" +\n          \" * @extends {Extended} */\");\n     assertTrue(jsdoc.isInterface());\n+    assertEquals(1, jsdoc.getExtendedInterfacesCount());\n+    List<JSTypeExpression> types = jsdoc.getExtendedInterfaces();\n     assertTypeEquals(registry.createNamedType(\"Extended\", null, -1, -1),\n-        jsdoc.getBaseType());\n+        types.get(0));\n+  }\n+\n+  public void testInterfaceMultiExtends1() throws Exception {\n+    JSDocInfo jsdoc = parse(\n+        \" * @interface \\n\" +\n+        \" * @extends {Extended1} \\n\" +\n+        \" * @extends {Extended2} */\");\n+    assertTrue(jsdoc.isInterface());\n+    assertEquals(2, jsdoc.getExtendedInterfacesCount());\n+    List<JSTypeExpression> types = jsdoc.getExtendedInterfaces();\n+    assertTypeEquals(registry.createNamedType(\"Extended1\", null, -1, -1),\n+       types.get(0));\n+    assertTypeEquals(registry.createNamedType(\"Extended2\", null, -1, -1),\n+        types.get(1));\n+  }\n+\n+  public void testInterfaceMultiExtends2() throws Exception {\n+    JSDocInfo jsdoc = parse(\n+        \" * @extends {Extended1} \\n\" +\n+        \" * @interface \\n\" +\n+        \" * @extends {Extended2} \\n\" +\n+        \" * @extends {Extended3} */\");\n+    assertTrue(jsdoc.isInterface());\n+    assertEquals(3, jsdoc.getExtendedInterfacesCount());\n+    List<JSTypeExpression> types = jsdoc.getExtendedInterfaces();\n+    assertTypeEquals(registry.createNamedType(\"Extended1\", null, -1, -1),\n+       types.get(0));\n+    assertTypeEquals(registry.createNamedType(\"Extended2\", null, -1, -1),\n+        types.get(1));\n+    assertTypeEquals(registry.createNamedType(\"Extended3\", null, -1, -1),\n+        types.get(2));\n+  }\n+\n+  public void testBadClassMultiExtends() throws Exception {\n+    parse(\" * @extends {Extended1} \\n\" +\n+        \" * @constructor \\n\" +\n+        \" * @extends {Extended2} */\",\n+        \"Bad type annotation. type annotation incompatible with other \" +\n+        \"annotations\");\n   }\n \n   public void testBadExtendsWithNullable() throws Exception {", "timestamp": 1303243506, "metainfo": ""}