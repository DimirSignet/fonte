{"sha": "1c438ecc7aabda089f109a9b7d51295439570615", "log": "Avoid unneccessary revisits in CheckPathsBetweenNodes  R=nicksantos DELTA=62  (62 added, 0 deleted, 0 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=642   ", "commit": "\n--- a/src/com/google/javascript/jscomp/CheckPathsBetweenNodes.java\n+++ b/src/com/google/javascript/jscomp/CheckPathsBetweenNodes.java\n \n   // A non-tree edge in the DFS that connects a node to one of its ancestors.\n   private static final Annotation BACK_EDGE = new Annotation() {};\n+  private static final Annotation VISITED_EDGE = new Annotation() {};\n+\n   // Not yet visited.\n   private static final Annotation WHITE = null;\n   // Being visited.\n       return false;\n     }\n     for (DiGraphEdge<N, E> e : a.getOutEdges()) {\n+      // Once we visited that edge once, we no longer need to\n+      // re-visit it again.\n+      if (e.getAnnotation() == VISITED_EDGE) {\n+        continue;\n+      }\n+      e.setAnnotation(VISITED_EDGE);\n+\n       if (ignoreEdge(e)) {\n         continue;\n       }\n       if (e.getAnnotation() == BACK_EDGE) {\n         continue;\n       }\n+\n       DiGraphNode<N, E> next = e.getDestination();\n       if (!checkAllPathsWithoutBackEdges(next, b)) {\n         return false;\n       return false;\n     }\n     for (DiGraphEdge<N, E> e : a.getOutEdges()) {\n+      // Once we visited that edge once, we no longer need to\n+      // re-visit it again.\n+      if (e.getAnnotation() == VISITED_EDGE) {\n+        continue;\n+      }\n+      e.setAnnotation(VISITED_EDGE);\n+\n       if (ignoreEdge(e)) {\n         continue;\n       }\n       if (e.getAnnotation() == BACK_EDGE) {\n         continue;\n       }\n+\n       DiGraphNode<N, E> next = e.getDestination();\n       if (checkSomePathsWithoutBackEdges(next, b)) {\n         return true;\n--- a/test/com/google/javascript/jscomp/CheckPathsBetweenNodesTest.java\n+++ b/test/com/google/javascript/jscomp/CheckPathsBetweenNodesTest.java\n         .somePathsSatisfyPredicate());\n   }\n \n+  public void testSomePathRevisiting() {\n+    DiGraph<String, String> g = LinkedDirectedGraph.create();\n+    g.createDirectedGraphNode(\"1\");\n+    g.createDirectedGraphNode(\"2a\");\n+    g.createDirectedGraphNode(\"2b\");\n+    g.createDirectedGraphNode(\"3\");\n+    g.createDirectedGraphNode(\"4a\");\n+    g.createDirectedGraphNode(\"4b\");\n+    g.createDirectedGraphNode(\"5\");\n+    g.connect(\"1\", \"-\", \"2a\");\n+    g.connect(\"1\", \"-\", \"2b\");\n+    g.connect(\"2a\", \"-\", \"3\");\n+    g.connect(\"2b\", \"-\", \"3\");\n+    g.connect(\"3\", \"-\", \"4a\");\n+    g.connect(\"3\", \"-\", \"4b\");\n+    g.connect(\"4a\", \"-\", \"5\");\n+    g.connect(\"4b\", \"-\", \"5\");\n+\n+    CountingPredicate<String> p =\n+      new CountingPredicate<String>(Predicates.equalTo(\"4a\"));\n+\n+    assertTrue(createTest(g, \"1\", \"5\", p, ALL_EDGE)\n+        .somePathsSatisfyPredicate());\n+\n+    // Make sure we are not doing more traversals than we have to.\n+    assertEquals(4, p.count);\n+  }\n+\n   public void testNonInclusive() {\n     // No Paths between nodes, by definition, always false.\n     DiGraph<String, String> g = LinkedDirectedGraph.create();\n       }\n     };\n   }\n+\n+  private static class CountingPredicate<T> implements Predicate<T> {\n+\n+    private int count = 0;\n+    private final Predicate<T> delegate;\n+\n+    private CountingPredicate(Predicate<T> delegate) {\n+      this.delegate = delegate;\n+    }\n+    @Override\n+    public boolean apply(T input) {\n+      count ++;\n+      return delegate.apply(input);\n+    }\n+\n+  }\n }", "timestamp": 1298451857, "metainfo": ""}