{"sha": "02735e27d8059f27e4722af97011f03fda3a38fd", "log": "Re-roll the groundwork for the bind rewriting change.  R=acleung DELTA=82  (82 added, 0 deleted, 0 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=2402   ", "commit": "\n--- a/src/com/google/javascript/jscomp/AbstractPeepholeOptimization.java\n+++ b/src/com/google/javascript/jscomp/AbstractPeepholeOptimization.java\n   }\n \n   /**\n+   * @return the current coding convention.\n+   */\n+  CodingConvention getCodingConvention() {\n+    // Note: this assumes a thread safe coding convention object.\n+    return currentTraversal.getCompiler().getCodingConvention();\n+  }\n+\n+  /**\n    * Check if the specified node is null or is still in the AST.\n    */\n   @VisibleForTesting\n--- a/src/com/google/javascript/jscomp/ClosureCodingConvention.java\n+++ b/src/com/google/javascript/jscomp/ClosureCodingConvention.java\n             JSTypeNative.OBJECT_TYPE)\n     );\n   }\n+\n+  @Override\n+  public Bind describeFunctionBind(Node n) {\n+    // It would be nice to be able to identify a fn.bind call\n+    // but that requires knowing the type of \"fn\".\n+\n+    if (n.getType() != Token.CALL) {\n+      return null;\n+    }\n+\n+    Node callTarget = n.getFirstChild();\n+    String name = callTarget.getQualifiedName();\n+    if (name != null) {\n+      if (name.equals(\"goog.bind\") || name.equals(\"goog$bind\")) {\n+        // goog.bind(fn, self, args...);\n+        Node fn = callTarget.getNext();\n+        Node thisValue = safeNext(fn);\n+        Node parameters = safeNext(thisValue);\n+        return new Bind(fn, thisValue, parameters);\n+      }\n+\n+      if (name.equals(\"goog.partial\") || name.equals(\"goog$partial\")) {\n+        // goog.partial(fn, args...);\n+        Node fn = callTarget.getNext();\n+        Node thisValue = null;\n+        Node parameters = safeNext(fn);\n+        return new Bind(fn, thisValue, parameters);\n+      }\n+    }\n+\n+    if (callTarget.getType() == Token.GETPROP\n+        && callTarget.getLastChild().getString().equals(\"bind\")\n+        && callTarget.getFirstChild().getType() == Token.FUNCTION) {\n+      // (function(){}).bind(self, args...);\n+      Node fn = callTarget.getFirstChild();\n+      Node thisValue = callTarget.getNext();\n+      Node parameters = safeNext(thisValue);\n+      return new Bind(fn, thisValue, parameters);\n+    }\n+\n+    return null;\n+  }\n+\n+  private Node safeNext(Node n) {\n+    if (n != null) {\n+      return n.getNext();\n+    }\n+    return null;\n+  }\n }\n--- a/src/com/google/javascript/jscomp/CodingConvention.java\n+++ b/src/com/google/javascript/jscomp/CodingConvention.java\n   public String getGlobalObject();\n \n   /**\n+   * A Bind instance or null.\n+   */\n+  public Bind describeFunctionBind(Node n);\n+\n+  public static class Bind {\n+    // The target of the bind action\n+    final Node target;\n+    // The node representing the \"this\" value, maybe null\n+    final Node thisValue;\n+    // The head of a Node list representing the parameters\n+    final Node parameters;\n+\n+    public Bind(Node target, Node thisValue, Node parameters) {\n+      this.target = target;\n+      this.thisValue = thisValue;\n+      this.parameters = parameters;\n+    }\n+  }\n+\n+  /**\n    * Whether this CALL function is testing for the existence of a property.\n    */\n   public boolean isPropertyTestFunction(Node call);\n--- a/src/com/google/javascript/jscomp/DefaultCodingConvention.java\n+++ b/src/com/google/javascript/jscomp/DefaultCodingConvention.java\n   public Collection<AssertionFunctionSpec> getAssertionFunctions() {\n     return Collections.emptySet();\n   }\n+\n+  @Override\n+  public Bind describeFunctionBind(Node n) {\n+    return null;\n+  }\n }", "timestamp": 1308862421, "metainfo": ""}