{"sha": "c2824ce4565143140d6b93d0241a6f7e6c81c3a0", "log": "Brings back check property order.  R=nicksantos DELTA=820  (820 added, 0 deleted, 0 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=475   ", "commit": "\n--- /dev/null\n+++ b/src/com/google/javascript/jscomp/CheckPropertyOrder.java\n+/*\n+ * Copyright 2008 The Closure Compiler Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+import com.google.common.base.Joiner;\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.Sets;\n+import com.google.javascript.jscomp.DataFlowAnalysis.FlowState;\n+import com.google.javascript.jscomp.JoinOp.BinaryJoinOp;\n+import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n+import com.google.javascript.jscomp.graph.Annotation;\n+import com.google.javascript.rhino.Node;\n+import com.google.javascript.rhino.Token;\n+import com.google.javascript.rhino.jstype.FunctionType;\n+import com.google.javascript.rhino.jstype.ObjectType;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.Stack;\n+\n+/**\n+ * Checks that all paths through a constructor add properties in the same order.\n+ *\n+ * Background: one of the key elements of the design of V8 that improves\n+ * performance is that it attempts to discover the classes of the objects\n+ * created at run time.  Rather than implementing an object as a hash table,\n+ * most objects have a reference to a \"hidden class\" that stores the list of\n+ * properties so that the object itself can maintain only a list of property\n+ * values.  If many objects share the same hidden class, then this reduces\n+ * memory usage.  Furthermore, at a get-prop site, if only one hidden class ever\n+ * occurs for the receiver, then it can speed up the dispatch process, compiling\n+ * it into only 3 instructions.  (For more information, see this\n+ * <a href=\"http://www.youtube.com/watch?v=hWhMKalEicY\">video</a>.)\n+ *\n+ * The key point relating to this pass is that a hidden class is not a set of\n+ * properties but rather an ordered list.  This is necesary so that iterating\n+ * over an object produces its keys in insertion order, as expected.  As a\n+ * result, if two different paths through the constructor generate different\n+ * ordered lists of properties, then the objects created via those paths will\n+ * have different hidden classes, defeating the optimizations described above.\n+ * This pass attempts to find and warn the user about such code.\n+ *\n+ */\n+class CheckPropertyOrder extends AbstractPostOrderCallback\n+    implements CompilerPass {\n+  static final DiagnosticType UNASSIGNED_PROPERTY = DiagnosticType.error(\n+      \"UNASSIGNED_PROPERTY\",\n+      \"not all control paths assign property {1} in function {0}\");\n+  static final DiagnosticType UNEQUAL_PROPERTIES = DiagnosticType.error(\n+      \"UNEQUAL_PROPERTIES\",\n+      \"different control paths produce different (ordered) property lists:\"\n+      + \" {0} vs. {1}\");\n+\n+  private final AbstractCompiler compiler;\n+  private final CheckLevel level;\n+  private final boolean onlyOneError;\n+  private int errorCount;\n+\n+  CheckPropertyOrder(AbstractCompiler compiler, CheckLevel level) {\n+    this(compiler, level, false);\n+  }\n+\n+  CheckPropertyOrder(\n+      AbstractCompiler compiler, CheckLevel level, boolean onlyOneError) {\n+    this.compiler = compiler;\n+    this.level = level;\n+    this.onlyOneError = onlyOneError;\n+  }\n+\n+  public void process(Node externs, Node root) {\n+    NodeTraversal.traverse(compiler, root, this);\n+  }\n+\n+  public void visit(NodeTraversal t, Node n, Node parent) {\n+    // Look for both top-level functions and assignments of functions to\n+    // qualified names.\n+    Node func = null;\n+    String funcName = null;\n+    if (NodeUtil.isFunction(n) && isConstructor(n)) {\n+      func = n;\n+      funcName = n.getFirstChild().getString();\n+    } else if (NodeUtil.isAssign(n)\n+               && NodeUtil.isFunction(n.getFirstChild().getNext())\n+               && isConstructor(n)) {\n+      func = n.getFirstChild().getNext();\n+      funcName = n.getFirstChild().getQualifiedName();\n+    }\n+\n+    if (func != null) {\n+      FunctionType funcType = (FunctionType) func.getJSType();\n+      checkConstructor(\n+          func, (funcType != null) ? funcType.getInstanceType() : null,\n+          t.getSourceName(), funcName);\n+    }\n+  }\n+\n+  /** Determines whether the given node is jsdoc-ed as a constructor. */\n+  private static boolean isConstructor(Node n) {\n+    return (n.getJSDocInfo() != null) && n.getJSDocInfo().isConstructor();\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  private void checkConstructor(Node func, ObjectType objType,\n+                                String sourceName, String funcName) {\n+    Preconditions.checkArgument(NodeUtil.isFunction(func));\n+\n+    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, false);\n+    cfa.process(null, func.getFirstChild().getNext().getNext());\n+    ControlFlowGraph<Node> cfg = cfa.getCfg();\n+\n+    new PropertyOrdersFlowAnalysis(cfa.getCfg()).analyze();\n+\n+    Annotation ann = cfa.getCfg().getImplicitReturn().getAnnotation();\n+    List<String>[] orders =\n+        ((FlowState<PropertyOrders>) ann).getIn().getOrders();\n+    if (orders.length == 0) {\n+      throw new AssertionError(\n+          \"no paths through constructor \" + funcName + \"?\");\n+    }\n+    if (orders.length > 1) {\n+      report(sourceName, func, UNEQUAL_PROPERTIES,\n+             reverse(orders[0]).toString(), reverse(orders[1]).toString());\n+    }\n+    if (objType != null) {\n+      for (String propName : objType.getOwnPropertyNames()) {\n+        if (!orders[0].contains(propName)) {\n+          report(sourceName, func, UNASSIGNED_PROPERTY, funcName, propName);\n+        }\n+      }\n+    }\n+  }\n+\n+  /** Reports the given error. Returns whether to continue. */\n+  private void report(\n+      String srcName, Node node, DiagnosticType type, String... args) {\n+    if (!onlyOneError || (++errorCount <= 1)) {\n+      compiler.report(JSError.make(srcName, node, level, type, args));\n+    }\n+  }\n+\n+  /** Returns the given List in the reverse order. */\n+  private static <T> List<T> reverse(List<T> seq) {\n+    if (seq.isEmpty()) {\n+      return seq;\n+    }\n+    List<T> rev = Lists.newArrayList(seq);\n+    Collections.reverse(seq);\n+    return rev;\n+  }\n+\n+  private static class OrdersJoinOp extends BinaryJoinOp<PropertyOrders> {\n+    @Override\n+    public PropertyOrders apply(PropertyOrders a, PropertyOrders b) {\n+      return new PropertyOrders(\n+          Sets.newHashSet(Sets.union(a.orders, b.orders)));\n+    }\n+  }\n+\n+  /**\n+   * Stores all possible (ordered) lists of properties that may have been added\n+   * to <code>this</code> at some point in the code.\n+   *\n+   * The bottom element of the lattice is an empty set, meaning no\n+   * possibilities.  At the first statement in the constructor, we start with a\n+   * set containing only one possibility: an empty list of properties.  (Note\n+   * that we do not model the properties of the superclass, if any.)  Each\n+   * assignment, say, <code>this.a = ...</code> adds <code>a</code> to the end\n+   * of all lists in the set.  Joining two results in the union of the\n+   * possibilities of those results.\n+   *\n+   * For example, if the constructor body contained just the code <code><pre>\n+   *   if (x) {\n+   *     this.a = 1;\n+   *     this.b = 2;\n+   *   } else {\n+   *     this.b = 2;\n+   *     this.a = 1;\n+   *   }\n+   * </pre></code>, then at the end of the constructor, the possibilities would\n+   * be {['a', 'b'], ['b', 'a']} because there are two possible orderings,\n+   * based on which path is taken in the <code>if</code>.\n+   */\n+  private static class PropertyOrders implements LatticeElement {\n+    /** The bottom element of the lattice: an empty set of lists. */\n+    public static final PropertyOrders EMPTY =\n+        new PropertyOrders(Sets.<List<String>>newHashSet());\n+\n+    /** A set of possible ordered lists of properties. */\n+    private final Set<List<String>> orders;\n+\n+    private PropertyOrders(Set<List<String>> orders) {\n+      this.orders = orders;\n+    }\n+\n+    @Override\n+    public boolean equals(Object other) {\n+      if (!(other instanceof PropertyOrders)) {\n+        return false;\n+      }\n+      return orders.equals(((PropertyOrders) other).orders);\n+    }\n+\n+    /**\n+     * Returns a new set of possible orders with the given string added at the\n+     * end of each possibility.\n+     */\n+    public PropertyOrders copyAndAdd(String propName) {\n+      Set<List<String>> orders = Sets.newHashSet();\n+      for (List<String> order : this.orders) {\n+        if (!order.contains(propName)) {\n+          List<String> nOrder = Lists.newArrayList(order);\n+          nOrder.add(propName);\n+          order = nOrder;\n+        }\n+        orders.add(order);\n+      }\n+      return new PropertyOrders(orders);\n+    }\n+\n+    /**\n+     * Returns all possible orders over the first N properties that are\n+     * definitely assigned over all paths.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public List<String>[] getOrders() {\n+      int minSize = Integer.MAX_VALUE;\n+      for (List<String> seq : this.orders) {\n+        minSize = Math.min(minSize, seq.size());\n+      }\n+      Set<List<String>> orders = Sets.newHashSet();\n+      for (List<String> seq : this.orders) {\n+        //orders.add(seq.subList(seq.size() - minSize, seq.size()));\n+        orders.add(seq.subList(0, minSize));\n+      }\n+      return orders.toArray(\n+          (List<String>[]) new List<?>[orders.size()]);\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return \"{\" + Joiner.on(\", \").join(orders) + \"}\";\n+    }\n+  }\n+\n+  /** Implements a data flow analysis over PropertyOrders. */\n+  private static class PropertyOrdersFlowAnalysis\n+      extends DataFlowAnalysis<Node, PropertyOrders> {\n+    public PropertyOrdersFlowAnalysis(ControlFlowGraph<Node> cfg) {\n+      super(cfg, new OrdersJoinOp());\n+    }\n+\n+    @Override\n+    public boolean isForward() { return true; }\n+\n+    @Override\n+    public PropertyOrders createInitialEstimateLattice() {\n+      // An empty orders means no possibilities at all.\n+      return PropertyOrders.EMPTY;\n+    }\n+\n+    @Override\n+    public PropertyOrders createEntryLattice() {\n+      // Initially, we have only one possibility:  no properties.\n+      Set<List<String>> orders = Sets.newHashSet();\n+      orders.add(new Stack<String>());\n+      return new PropertyOrders(orders);\n+    }\n+\n+    /** Computes the orders after executing the given node. */\n+    @Override\n+    public PropertyOrders flowThrough(Node node, PropertyOrders input) {\n+      switch (node.getType()) {\n+        case Token.BLOCK:\n+        case Token.LABEL:\n+        case Token.FUNCTION:\n+          return input;\n+\n+        case Token.IF:\n+        case Token.WHILE:\n+        case Token.DO:\n+          return flowThrough(NodeUtil.getConditionExpression(node), input);\n+\n+        case Token.SWITCH:\n+        case Token.WITH:\n+          return flowThrough(node.getFirstChild(), input);\n+\n+        case Token.FOR:\n+          if (node.getChildCount() == 4) {\n+            // Note that the post-loop expression is not considered here.  That\n+            // is handled in the branched version above.\n+            Node pre = node.getFirstChild(), cond = pre.getNext();\n+            return flowThrough(cond, flowThrough(pre, input));\n+          } else {\n+            Node lhs = node.getFirstChild(), rhs = lhs.getNext();\n+            return flowThrough(rhs, flowThrough(lhs, input));\n+          }\n+\n+        case Token.HOOK:\n+          Node cond = node.getFirstChild();\n+          input = flowThrough(cond, input);\n+          Node ifTrue = cond.getNext(), ifFalse = ifTrue.getNext();\n+          return join(flowThrough(ifTrue, input), flowThrough(ifFalse, input));\n+\n+        case Token.AND:\n+        case Token.OR:\n+          Node left = node.getFirstChild(), right = left.getNext();\n+          input = flowThrough(left, input);\n+          return join(input, flowThrough(right, input));\n+\n+        case Token.ASSIGN:\n+          // If the left hand side is \"this.x\", then add x to the lists.\n+          Node lhs = node.getFirstChild(), rhs = lhs.getNext();\n+          if (lhs.getType() == Token.GETPROP) {\n+            Node llhs = lhs.getFirstChild(), lrhs = llhs.getNext();\n+            if ((llhs.getType() == Token.THIS)\n+                && (lrhs.getType() == Token.STRING)\n+                && (lrhs.getNext() == null)) {\n+              return flowThrough(rhs, input.copyAndAdd(lrhs.getString()));\n+            }\n+          }\n+          return flowThrough(rhs, flowThrough(lhs, input));\n+\n+        default:\n+          for (node = node.getFirstChild();\n+               node != null;\n+               node = node.getNext()) {\n+            input = flowThrough(node, input);\n+          }\n+          return input;\n+      }\n+    }\n+  }\n+}\n--- /dev/null\n+++ b/test/com/google/javascript/jscomp/CheckPropertyOrderTest.java\n+/*\n+ * Copyright 2008 The Closure Compiler Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+/**\n+ * Unit test for the JSCompiler CheckPropertyOrder pass.\n+ *\n+ */\n+public class CheckPropertyOrderTest extends CompilerTestCase {\n+  public CheckPropertyOrderTest() {\n+    super(\"\", true);\n+    enableTypeCheck(CheckLevel.WARNING);\n+  }\n+\n+  @Override\n+  public CompilerPass getProcessor(Compiler compiler) {\n+    return new CheckPropertyOrder(\n+        compiler, CheckLevel.WARNING, true);\n+  }\n+\n+  @Override\n+  protected int getNumRepetitions() {\n+    return 1;\n+  }\n+\n+  public void testNoBranches() {\n+    testSame(\"var a = {};\"\n+             + \"/** @constructor */\"\n+             + \"a.F = function() {\"\n+             + \"  this.a = 'a';\"\n+             + \"  this.b = 3;\"\n+             + \"  this.c = null;\"\n+             + \"};\");\n+  }\n+\n+  public void testIfBranchDifference() {\n+    testSame(\"var a = {};\"\n+             + \"/** @constructor */\"\n+             + \"a.F = function(a) {\"\n+             + \"  if (a < 10) {\"\n+             + \"    this.a = a;\"\n+             + \"  }\"\n+             + \"};\",\n+             CheckPropertyOrder.UNASSIGNED_PROPERTY);\n+  }\n+\n+  public void testIfBranchNoDifference() {\n+    testSame(\"var a = {};\"\n+             + \"/** @constructor */\"\n+             + \"a.F = function(a) {\"\n+             + \"  if (a < 10) {\"\n+             + \"    this.a = a;\"\n+             + \"  } else {\"\n+             + \"    this.a = 10;\"\n+             + \"  }\"\n+             + \"};\");\n+  }\n+\n+  public void testHookBranchDifference() {\n+    testSame(\"var a = {};\"\n+             + \"/** @constructor */\"\n+             + \"a.F = function(a) {\"\n+             + \"  var b = (a < 10) ? (this.a = 1) : 2\"\n+             + \"};\",\n+             CheckPropertyOrder.UNASSIGNED_PROPERTY);\n+  }\n+\n+  public void testHookBranchNoDifference() {\n+    testSame(\"var a = {};\"\n+             + \"/** @constructor */\"\n+             + \"a.F = function(a) {\"\n+             + \"  var b = (a < 10) ? (this.a = 1) : (this.a = 2)\"\n+             + \"};\");\n+  }\n+\n+  public void testAndBranchDifference() {\n+    testSame(\"var a = {};\"\n+             + \"/** @constructor */\"\n+             + \"a.F = function(a) {\"\n+             + \"  (a < 10) && (this.a = 1);\"\n+             + \"};\",\n+             CheckPropertyOrder.UNASSIGNED_PROPERTY);\n+  }\n+\n+  public void testOrBranchDifference() {\n+    testSame(\"var a = {};\"\n+             + \"/** @constructor */\"\n+             + \"a.F = function(a) {\"\n+             + \"  (a < 10) || (this.a = 1);\"\n+             + \"};\",\n+             CheckPropertyOrder.UNASSIGNED_PROPERTY);\n+  }\n+\n+  public void testAndOrBranchNoDifference() {\n+    testSame(\"var a = {};\"\n+             + \"/** @constructor */\"\n+             + \"a.F = function() {\"\n+             + \"  (this.a = 0) && (this.a = 1);\"\n+             + \"  (this.b = 2) || (this.b = 3);\"\n+             + \"};\");\n+  }\n+\n+  public void testWhileBranchDifference() {\n+    testSame(\"var a = {};\"\n+             + \"/** @constructor */\"\n+             + \"a.F = function() {\"\n+             + \"  this.a = 0;\"\n+             + \"  while (this.a < 10) {\"\n+             + \"    this.b = 3;\"\n+             + \"    ++this.a;\"\n+             + \"  }\"\n+             + \"};\",\n+             CheckPropertyOrder.UNASSIGNED_PROPERTY);\n+  }\n+\n+  public void testWhileBranchNoDifference() {\n+    testSame(\"var a = {};\"\n+             + \"/** @constructor */\"\n+             + \"a.F = function() {\"\n+             + \"  this.a = 0;\"\n+             + \"  this.b = 0;\"\n+             + \"  while (this.a < 10) {\"\n+             + \"    this.b = 3;\"\n+             + \"    ++this.a;\"\n+             + \"  }\"\n+             + \"};\");\n+  }\n+\n+  public void testForBranchDifference() {\n+    testSame(\"var a = {};\"\n+             + \"/** @constructor */\"\n+             + \"a.F = function() {\"\n+             + \"  for (this.a = 0; this.a < 10; ++this.a) {\"\n+             + \"    this.b = 3;\"\n+             + \"  }\"\n+             + \"};\",\n+             CheckPropertyOrder.UNASSIGNED_PROPERTY);\n+    testSame(\"var a = {};\"\n+             + \"/** @constructor */\"\n+             + \"a.F = function() {\"\n+             + \"  for (; !this.b; this.b = 1) {}\"\n+             + \"  this.a = 1;\"\n+             + \"};\",\n+             CheckPropertyOrder.UNEQUAL_PROPERTIES);\n+  }\n+\n+  public void testForBranchNoDifference() {\n+    testSame(\"var a = {};\"\n+             + \"/** @constructor */\"\n+             + \"a.F = function() {\"\n+             + \"  this.b = 0;\"\n+             + \"  for (this.a = 0; this.a < 10; ++this.a) {\"\n+             + \"    this.b = 3;\"\n+             + \"  }\"\n+             + \"};\");\n+  }\n+\n+  public void testDoBranchNoDifference() {\n+    testSame(\"var a = {};\"\n+             + \"/** @constructor */\"\n+             + \"a.F = function() {\"\n+             + \"  this.a = 1;\"\n+             + \"  do {\"\n+             + \"    this.a = 2;\"\n+             + \"  } while (false);\"\n+             + \"};\");\n+  }\n+\n+  public void testReturnBranchDifference() {\n+    testSame(\"var a = {};\"\n+             + \"/** @constructor */\"\n+             + \"a.F = function(a) {\"\n+             + \"  this.a = 1;\"\n+             + \"  if (a < 10) return;\"\n+             + \"  this.b = 2;\"\n+             + \"};\",\n+             CheckPropertyOrder.UNASSIGNED_PROPERTY);\n+  }\n+\n+  public void testReturnBranchNoDifference() {\n+    testSame(\"var a = {};\"\n+             + \"/** @constructor */\"\n+             + \"a.F = function(a) {\"\n+             + \"  this.a = 1;\"\n+             + \"  if (a < 10) return;\"\n+             + \"  this.a = 2;\"\n+             + \"};\");\n+  }\n+\n+// TODO(user): The type registery is behaves a bit different than before.\n+// The .b property is no longer on the InstanceObject instead, it is stored in\n+// JSTypeRegistry.typesIndexedByProperty. Fix this when we want to use this\n+// pass for real.\n+//  public void testUnassigned() {\n+//    testSame(\"var a = {};\"\n+//             + \"/** @constructor */\"\n+//             + \"a.F = function() {\"\n+//             + \"  this.a = 10;\"\n+//             + \"};\"\n+//             + \"function bar() {\"\n+//             + \"  var f = new a.F();\"\n+//             + \"  f.b = 11;\"\n+//             + \"}\",\n+//             CheckPropertyOrder.UNASSIGNED_PROPERTY);\n+//  }\n+\n+  public void testUnequalProperty() {\n+    testSame(\"var a = {};\"\n+             + \"/** @constructor */\"\n+             + \"a.F = function() {\"\n+             + \"  if (1) { this.a = 1; }\"\n+             + \"  else { this.b = 1; }\"\n+             + \"};\",\n+             CheckPropertyOrder.UNEQUAL_PROPERTIES);\n+  }\n+\n+  public void testAssignedAfterMerge() {\n+    testSame(\"var a = {};\"\n+             + \"/** @constructor */\"\n+             + \"a.F = function(a) {\"\n+             + \"  if (a > 0) { this.a = 1; }\"\n+             + \"  this.a = 2;\"\n+             + \"};\");\n+  }\n+\n+  public void testBreakBranchNoDifference() {\n+    testSame(\"var a = {};\"\n+             + \"/** @constructor */\"\n+             + \"a.F = function() {\"\n+             + \"  this.a = 1;\"\n+             + \"  do {\"\n+             + \"    if (true) {\"\n+             + \"      this.a = 2;\"\n+             + \"      break;\"\n+             + \"    }\"\n+             + \"  } while (false);\"\n+             + \"};\");\n+  }\n+\n+  public void testContinueBranchNoDifference() {\n+    testSame(\"var a = {};\"\n+             + \"/** @constructor */\"\n+             + \"a.F = function() {\"\n+             + \"  this.a = 1;\"\n+             + \"  do {\"\n+             + \"    if (true) {\"\n+             + \"      this.a = 2;\"\n+             + \"      continue;\"\n+             + \"    }\"\n+             + \"  } while (false);\"\n+             + \"};\");\n+  }\n+\n+  public void testLabeledBreakBranchNoDifference() {\n+    testSame(\"var a = {};\"\n+             + \"/** @constructor */\"\n+             + \"a.F = function() {\"\n+             + \"  this.a = 1;\"\n+             + \"  foo: while (1) {\"\n+             + \"    while (0) {\"\n+             + \"      this.a = 2;\"\n+             + \"      break foo;\"\n+             + \"    }\"\n+             + \"  }\"\n+             + \"};\");\n+  }\n+\n+  public void testLabeledContinueBranchNoDifference() {\n+    testSame(\"var a = {};\"\n+             + \"/** @constructor */\"\n+             + \"a.F = function() {\"\n+             + \"  this.a = 1;\"\n+             + \"  foo: while (1) {\"\n+             + \"    while (0) {\"\n+             + \"      this.a = 2;\"\n+             + \"      continue foo;\"\n+             + \"    }\"\n+             + \"  }\"\n+             + \"};\");\n+  }\n+\n+  public void testSwitchBranchDifference() {\n+    testSame(\"var a = {};\"\n+             + \"/** @constructor */\"\n+             + \"a.F = function(a) {\"\n+             + \"  switch (a) {\"\n+             + \"    case 0:\"\n+             + \"    case 1:\"\n+             + \"      break;\"\n+             + \"    case 2:\"\n+             + \"      this.a = 2;\"\n+             + \"      break;\"\n+             + \"    default:\"\n+             + \"      this.a = 3;\"\n+             + \"  }\"\n+             + \"};\",\n+             CheckPropertyOrder.UNASSIGNED_PROPERTY);\n+    testSame(\"var a = {};\"\n+             + \"/** @constructor */\"\n+             + \"a.F = function(a) {\"\n+             + \"  switch (a) {\"\n+             + \"    case 0:\"\n+             + \"    case 1:\"\n+             + \"      this.a = 1;\"\n+             + \"      break;\"\n+             + \"    case 2:\"\n+             + \"      break;\"\n+             + \"    default:\"\n+             + \"      this.a = 3;\"\n+             + \"  }\"\n+             + \"};\",\n+             CheckPropertyOrder.UNASSIGNED_PROPERTY);\n+    testSame(\"var a = {};\"\n+             + \"/** @constructor */\"\n+             + \"a.F = function(a) {\"\n+             + \"  switch (a) {\"\n+             + \"    case 0:\"\n+             + \"    case 1:\"\n+             + \"      this.a = 1;\"\n+             + \"      break;\"\n+             + \"    case 2:\"\n+             + \"      this.a = 2;\"\n+             + \"      break;\"\n+             + \"    default:\"\n+             + \"  }\"\n+             + \"};\",\n+             CheckPropertyOrder.UNASSIGNED_PROPERTY);\n+  }\n+\n+  public void testSwitchBranchNoDifference() {\n+    testSame(\"var a = {};\"\n+             + \"/** @constructor */\"\n+             + \"a.F = function(a) {\"\n+             + \"  switch (a) {\"\n+             + \"    case 0:\"\n+             + \"    case 1:\"\n+             + \"      this.a = 1;\"\n+             + \"      break;\"\n+             + \"    case 2:\"\n+             + \"      this.a = 2;\"\n+             + \"      break;\"\n+             + \"    default:\"\n+             + \"      this.a = 3;\"\n+             + \"  }\"\n+             + \"};\");\n+    testSame(\"var a = {};\"\n+             + \"/** @constructor */\"\n+             + \"a.F = function(a) {\"\n+             + \"  switch (a) {\"\n+             + \"    case 0:\"\n+             + \"    case 1:\"\n+             + \"      this.a = 1;\"\n+             + \"      break;\"\n+             + \"    case 2:\"\n+             + \"      this.a = 2;\"\n+             + \"    default:\"\n+             + \"      this.a = 3;\"\n+             + \"  }\"\n+             + \"};\");\n+  }\n+\n+  public void testTryCatchBranchDifference() {\n+    testSame(\"var a = {};\"\n+             + \"/** @constructor */\"\n+             + \"a.F = function(a) {\"\n+             + \"  try { if (1){ throw Error(); } }\"\n+             + \"  catch (ex) { this.a = 1; }\"\n+             + \"};\",\n+             CheckPropertyOrder.UNASSIGNED_PROPERTY);\n+  }\n+\n+  public void testTryCatchBranchNoDifference() {\n+    testSame(\"var a = {};\"\n+             + \"/** @constructor */\"\n+             + \"a.F = function(a) {\"\n+             + \"  try { throw Error(); }\"\n+             + \"  catch (ex) { this.a = 1; }\"\n+             + \"};\");\n+    // TODO(user): Fix this test case.\n+    //testSame(\"var a = {};\"\n+    //         + \"/** @constructor */\"\n+    //         + \"a.F = function(a) {\"\n+    //         + \"  try {}\"\n+    //         + \"  catch (ex) { this.a = 1; }\"  // never executed\n+    //         + \"};\",\n+    //         CheckPropertyOrder.UNASSIGNED_PROPERTY);\n+  }\n+\n+  public void testTryFinallyBranchNoDifference() {\n+    testSame(\"var a = {};\"\n+             + \"/** @constructor */\"\n+             + \"a.F = function(a) {\"\n+             + \"  if (1) {\"\n+             + \"    try { this.a = 2; }\"\n+             + \"    finally { }\"\n+             + \"  } else {\"\n+             + \"    this.a = 3;\"\n+             + \"  }\"\n+             + \"};\");\n+    testSame(\"var a = {};\"\n+             + \"/** @constructor */\"\n+             + \"a.F = function(a) {\"\n+             + \"  if (1) {\"\n+             + \"    try {}\"\n+             + \"    finally { this.a = 2; }\"\n+             + \"  } else {\"\n+             + \"    this.a = 3;\"\n+             + \"  }\"\n+             + \"};\");\n+    testSame(\"var a = {};\"\n+             + \"/** @constructor */\"\n+             + \"a.F = function(a) {\"\n+             + \"  if (1) {\"\n+             + \"    do {\"\n+             + \"      try { break; }\"\n+             + \"      finally {this.a = 2; }\"\n+             + \"    } while(1);\"\n+             + \"  } else {\"\n+             + \"    this.a = 3;\"\n+             + \"  }\"\n+             + \"};\");\n+    testSame(\"var a = {};\"\n+             + \"/** @constructor */\"\n+             + \"a.F = function(a) {\"\n+             + \"  if (a) {\"\n+             + \"    this.a = 1;\"\n+             + \"  } else {\"\n+             + \"    try {\"\n+             + \"      this.a = (function() { throw 1; })();\"\n+             + \"    } finally {\"\n+             + \"    }\"\n+             + \"  }\"\n+             + \"};\");\n+  }\n+\n+  public void testGlobalFunction() {\n+    testSame(\"/** @constructor */\"\n+             + \"function F(a) {\"\n+             + \"  if (a < 10) {\"\n+             + \"    this.a = a;\"\n+             + \"  } else {\"\n+             + \"    this.a = 10;\"\n+             + \"  }\"\n+             + \"};\");\n+    testSame(\"/** @constructor */\"\n+             + \"function F(a) {\"\n+             + \"  if (a < 10) {\"\n+             + \"    this.a = a;\"\n+             + \"  }\"\n+             + \"};\",\n+             CheckPropertyOrder.UNASSIGNED_PROPERTY);\n+  }\n+}", "timestamp": 1297197390, "metainfo": ""}