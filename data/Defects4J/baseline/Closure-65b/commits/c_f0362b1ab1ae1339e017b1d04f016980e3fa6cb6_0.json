{"sha": "f0362b1ab1ae1339e017b1d04f016980e3fa6cb6", "log": "fix a bug where NodeUtil was reporting function literals as immutable. functions are mutable. Make isLiteralValue a bit more flexible, so that it can identify function literals. do some additional folding on function literals.  R=acleung DELTA=68  (35 added, 1 deleted, 32 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=64001   ", "commit": "\n--- a/src/com/google/javascript/jscomp/CrossModuleCodeMotion.java\n+++ b/src/com/google/javascript/jscomp/CrossModuleCodeMotion.java\n     // c) a function, or\n     // d) an array/object literal of movable values.\n     // e) a function stub generated by CrossModuleMethodMotion.\n-    if (n == null || NodeUtil.isLiteralValue(n) ||\n+    if (n == null || NodeUtil.isLiteralValue(n, true) ||\n         n.getType() == Token.FUNCTION) {\n       return true;\n     } else if (n.getType() == Token.CALL) {\n--- a/src/com/google/javascript/jscomp/InlineGetters.java\n+++ b/src/com/google/javascript/jscomp/InlineGetters.java\n             if (isPropertyTree(returned)) {\n               logger.fine(\"Inlining property accessor: \" + callName);\n               inlinePropertyReturn(parent, callNode, returned);\n-            } else if (NodeUtil.isLiteralValue(returned) &&\n+            } else if (NodeUtil.isLiteralValue(returned, false) &&\n               !NodeUtil.mayHaveSideEffects(callNode.getFirstChild())) {\n               logger.fine(\"Inlining constant accessor: \" + callName);\n               inlineConstReturn(parent, callNode, returned);\n--- a/src/com/google/javascript/jscomp/InlineVariables.java\n+++ b/src/com/google/javascript/jscomp/InlineVariables.java\n     private boolean canMoveAggressively(Node value) {\n       // Function expressions and other mutable objects can move within\n       // the same basic block.\n-      return NodeUtil.isLiteralValue(value)\n+      return NodeUtil.isLiteralValue(value, true)\n           || value.getType() == Token.FUNCTION;\n     }\n \n             initialization.getGrandparent(),  // EXPR_RESULT\n             initialization.getGrandparent().getParent()); // EXPR container\n       } else {\n-        throw new IllegalStateException(\"Unexpected initialiation parent\");\n+        throw new IllegalStateException(\"Unexpected initialization parent \" +\n+            initialization.getParent().toStringTree());\n       }\n       Node targetName = reference.getNameNode();\n       while (it.hasNext()) {\n--- a/src/com/google/javascript/jscomp/NodeUtil.java\n+++ b/src/com/google/javascript/jscomp/NodeUtil.java\n    * Returns true if this is a literal value. We define a literal value\n    * as any node that evaluates to the same thing regardless of when or\n    * where it is evaluated. So /xyz/ and [3, 5] are literals, but\n-   * function() { return a; } is not.\n-   */\n-  static boolean isLiteralValue(Node n) {\n-    // TODO(nicksantos): Refine this function to catch more literals.\n+   * the name a is not.\n+   *\n+   * Function literals do not meet this definition, because they\n+   * lexically capture variables. For example, if you have\n+   * <code>\n+   * function() { return a; }\n+   * </code>\n+   * If it is evaluated in a different scope, then it\n+   * captures a different variable. Even if the function did not read\n+   * any captured vairables directly, it would still fail this definition,\n+   * because it affects the lifecycle of variables in the enclosing scope.\n+   *\n+   * However, a function literal with respect to a particular scope is\n+   * a literal.\n+   *\n+   * @param includeFunctions If true, all function expressions will be\n+   *     treated as literals.\n+   */\n+  static boolean isLiteralValue(Node n, boolean includeFunctions) {\n     switch (n.getType()) {\n       case Token.ARRAYLIT:\n       case Token.OBJECTLIT:\n         // Return true only if all children are const.\n         for (Node child = n.getFirstChild(); child != null;\n              child = child.getNext()) {\n-          if (!isLiteralValue(child)) {\n+          if (!isLiteralValue(child, includeFunctions)) {\n             return false;\n           }\n         }\n         return true;\n+\n+      case Token.FUNCTION:\n+        return includeFunctions && !NodeUtil.isFunctionDeclaration(n);\n \n       default:\n         return isImmutableValue(n);\n         // Function expressions don't have side-effects, but function\n         // declarations change the namespace. Either way, we don't need to\n         // check the children, since they aren't executed at declaration time.\n-        return !isFunctionExpression(n);\n+        return checkForNewObjects || !isFunctionExpression(n);\n \n       case Token.NEW:\n         if (checkForNewObjects) {\n                current.getType() == Token.GETELEM;\n                current = current.getFirstChild()) { }\n \n-          return !(isLiteralValue(current) ||\n-              current.getType() == Token.FUNCTION);\n+          return !isLiteralValue(current, true);\n         }\n \n         return true;\n--- a/src/com/google/javascript/jscomp/OptimizeParameters.java\n+++ b/src/com/google/javascript/jscomp/OptimizeParameters.java\n \n   private void buildParameterList(List<Parameter> parameters, Node cur) {\n     while ((cur = cur.getNext()) != null) {\n-      parameters.add(new Parameter(cur, NodeUtil.isLiteralValue(cur)));\n+      parameters.add(new Parameter(cur, NodeUtil.isLiteralValue(cur, false)));\n     }\n   }\n \n--- a/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\n+++ b/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\n     Preconditions.checkArgument(originalTypeofNode.getType() == Token.TYPEOF);\n \n     Node argumentNode = originalTypeofNode.getFirstChild();\n-    if (argumentNode == null || !NodeUtil.isLiteralValue(argumentNode)) {\n+    if (argumentNode == null || !NodeUtil.isLiteralValue(argumentNode, true)) {\n       return originalTypeofNode;\n     }\n \n     String typeNameString = null;\n \n     switch (argumentNode.getType()) {\n+      case Token.FUNCTION:\n+        typeNameString = \"function\";\n+        break;\n       case Token.STRING:\n         typeNameString = \"string\";\n         break;\n \n     // TODO(johnlenz) Use type information if available to fold\n     // instanceof.\n-    if (NodeUtil.isLiteralValue(left)\n+    if (NodeUtil.isLiteralValue(left, true)\n         && !NodeUtil.mayHaveSideEffects(right)) {\n \n       Node replacementNode = null;\n    */\n   private Node tryFoldLeftChildAdd(Node n, Node left, Node right) {\n \n-    if (NodeUtil.isLiteralValue(right) &&\n+    if (NodeUtil.isLiteralValue(right, false) &&\n         left.getType() == Token.ADD &&\n         left.getChildCount() == 2) {\n \n   private Node tryFoldAdd(Node node, Node left, Node right) {\n     Preconditions.checkArgument(node.getType() == Token.ADD);\n \n-    if (NodeUtil.isLiteralValue(left) && NodeUtil.isLiteralValue(right)) {\n+    if (NodeUtil.isLiteralValue(left, false) &&\n+        NodeUtil.isLiteralValue(right, false)) {\n       // 6 + 7\n       return tryFoldAddConstant(node, left, right);\n     } else {\n    */\n   @SuppressWarnings(\"fallthrough\")\n   private Node tryFoldComparison(Node n, Node left, Node right) {\n-    if (!NodeUtil.isLiteralValue(left) || !NodeUtil.isLiteralValue(right)) {\n+    if (!NodeUtil.isLiteralValue(left, false) ||\n+        !NodeUtil.isLiteralValue(right, false)) {\n       // We only handle non-literal operands for LT and GT.\n       if (n.getType() != Token.GT && n.getType() != Token.LT) {\n         return n;\n \n     // TODO(johnlenz): Use the JSType to compare nodes of different types.\n \n-    boolean rightLiteral = NodeUtil.isLiteralValue(right);\n+    boolean rightLiteral = NodeUtil.isLiteralValue(right, false);\n     boolean undefinedRight = ((Token.NAME == right.getType()\n           && right.getString().equals(\"undefined\"))\n           || (Token.VOID == right.getType()\n-              && NodeUtil.isLiteralValue(right.getFirstChild())));\n+              && NodeUtil.isLiteralValue(right.getFirstChild(), false)));\n \n     switch (left.getType()) {\n       case Token.VOID:\n-        if (!NodeUtil.isLiteralValue(left.getFirstChild())) {\n+        if (!NodeUtil.isLiteralValue(left.getFirstChild(), false)) {\n           return n;\n         } else if (!rightLiteral) {\n           return n;\n--- a/src/com/google/javascript/jscomp/PeepholeFoldWithTypes.java\n+++ b/src/com/google/javascript/jscomp/PeepholeFoldWithTypes.java\n     \n     // We'll let PeepholeFoldConstants handle folding literals\n     // and we can't remove arguments with possible side effects.\n-    if (!NodeUtil.isLiteralValue(argumentNode) &&\n+    if (!NodeUtil.isLiteralValue(argumentNode, true) &&\n         !NodeUtil.mayHaveSideEffects(argumentNode)) {\n       JSType argumentType = argumentNode.getJSType();\n             \n--- a/src/com/google/javascript/jscomp/PeepholeRemoveDeadCode.java\n+++ b/src/com/google/javascript/jscomp/PeepholeRemoveDeadCode.java\n     }\n \n     // Try transforms that apply to both IF and HOOK.\n-    if (!NodeUtil.isLiteralValue(cond)) {\n+    if (!NodeUtil.isLiteralValue(cond, true)) {\n       return n;  // We can't remove branches otherwise!\n     }\n \n--- a/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n+++ b/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n     /* If the condition is a literal, we'll let other\n      * optimizations try to remove useless code.\n      */\n-    if (NodeUtil.isLiteralValue(cond)) {\n+    if (NodeUtil.isLiteralValue(cond, true)) {\n       return n;\n     }\n \n--- a/src/com/google/javascript/jscomp/RemoveUnusedVars.java\n+++ b/src/com/google/javascript/jscomp/RemoveUnusedVars.java\n         if (var.getParentNode().getType() == Token.VAR) {\n           Node value = var.getInitialValue();\n           assignedToUnknownValue = value != null &&\n-              !NodeUtil.isLiteralValue(value);\n+              !NodeUtil.isLiteralValue(value, true);\n         } else {\n           // This was initialized to a function arg or a catch param.\n           assignedToUnknownValue = true;\n           if (assign.isPropertyAssign) {\n             hasPropertyAssign = true;\n           } else if (!NodeUtil.isLiteralValue(\n-              assign.assignNode.getLastChild())) {\n+              assign.assignNode.getLastChild(), true)) {\n             assignedToUnknownValue = true;\n           }\n         }\n--- a/test/com/google/javascript/jscomp/NodeUtilTest.java\n+++ b/test/com/google/javascript/jscomp/NodeUtilTest.java\n   }\n \n   public void assertLiteralAndImmutable(Node n) {\n-    assertTrue(NodeUtil.isLiteralValue(n));\n+    assertTrue(NodeUtil.isLiteralValue(n, true));\n+    assertTrue(NodeUtil.isLiteralValue(n, false));\n     assertTrue(NodeUtil.isImmutableValue(n));\n   }\n \n   public void assertLiteralButNotImmutable(Node n) {\n-    assertTrue(NodeUtil.isLiteralValue(n));\n+    assertTrue(NodeUtil.isLiteralValue(n, true));\n+    assertTrue(NodeUtil.isLiteralValue(n, false));\n     assertFalse(NodeUtil.isImmutableValue(n));\n   }\n \n   public void assertNotLiteral(Node n) {\n-    assertFalse(NodeUtil.isLiteralValue(n));\n+    assertFalse(NodeUtil.isLiteralValue(n, true));\n+    assertFalse(NodeUtil.isLiteralValue(n, false));\n     assertFalse(NodeUtil.isImmutableValue(n));\n   }\n \n     assertMutableState(true, \"if(true){a()}\");\n \n     assertMutableState(false, \"if(true){a}\");\n-    assertMutableState(false, \"(function() { })\");\n-    assertMutableState(false, \"(function() { i++ })\");\n+    assertMutableState(true, \"(function() { })\");\n+    assertMutableState(true, \"(function() { i++ })\");\n     assertMutableState(true, \"[function a(){}]\");\n \n     assertMutableState(false, \"a\");\n     assertMutableState(false, \"'a' + a.name\");\n     assertMutableState(false, \"1, 2, 3\");\n     assertMutableState(false, \"a, b, 3\");\n-    assertMutableState(false, \"(function(a, b) {  })\");\n+    assertMutableState(true, \"(function(a, b) {  })\");\n     assertMutableState(false, \"a ? c : d\");\n     assertMutableState(false, \"'1' + navigator.userAgent\");\n \n--- a/test/com/google/javascript/jscomp/PeepholeFoldConstantsTest.java\n+++ b/test/com/google/javascript/jscomp/PeepholeFoldConstantsTest.java\n     fold(\"x = typeof [1]\", \"x = \\\"object\\\"\");\n     fold(\"x = typeof [1,[]]\", \"x = \\\"object\\\"\");\n     fold(\"x = typeof {}\", \"x = \\\"object\\\"\");\n+    fold(\"x = typeof function() {}\", \"x = 'function'\");\n \n     foldSame(\"x = typeof[1,[foo()]]\");\n     foldSame(\"x = typeof{bathwater:baby()}\");\n     // These would require type information to fold.\n     foldSame(\"[] instanceof Foo\");\n     foldSame(\"({}) instanceof Foo\");\n+\n+    fold(\"(function() {}) instanceof Object\", \"true\");\n   }\n \n   public void testDivision() {\n--- a/test/com/google/javascript/jscomp/RemoveUnusedVarsTest.java\n+++ b/test/com/google/javascript/jscomp/RemoveUnusedVarsTest.java\n          \"var x={foo:bar()};x[\\\"foo\\\"]=5\");\n   }\n \n+  public void testUnusedPropAssign6() {\n+    test(\"var x = function() {}; x.prototype.bar = function() {};\",\n+         \"(function(){})\");\n+  }\n+\n   public void testUsedPropAssign1() {\n     test(\"function f(x) { x.bar = 3; } f({});\",\n          \"function f(x){x.bar=3}f({})\");", "timestamp": 1279921755, "metainfo": ""}