{"sha": "9925370292834ea846727f1f9db76af0d40261df", "log": "Change on 2010/06/28 12:25:08 by dcc          Split up FoldConstants unit tests.          R=acleung         DELTA=2778  (1508 added, 1270 deleted, 0 changed)  Change on 2010/06/28 15:47:46 by johnlenz          Prevent COMMAs with more than two children.          R=acleung         DELTA=1  (1 added, 0 deleted, 0 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=44002   ", "commit": "\n--- a/src/com/google/javascript/jscomp/CodeGenerator.java\n+++ b/src/com/google/javascript/jscomp/CodeGenerator.java\n         break;\n \n       case Token.COMMA:\n+        Preconditions.checkState(childCount == 2);\n         addList(first, false, context);\n         break;\n \n--- a/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\n+++ b/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\n     if (left == null) {\n       return n;\n     }\n+    \n+    // TODO(dcc): Just dropping the unary op makes some tests\n+    // (e.g. PeepholeIntegration.testMinimizeExpr) very confusing because it\n+    // leads to transformations like \"!!true\" --> \"!false\" --> \"false\".\n+    // Do we really need to do this here?\n     \n     if (NodeUtil.isExpressionNode(parent)) {\n       // If the value isn't used, then just throw\n--- /dev/null\n+++ b/test/com/google/javascript/jscomp/PeepholeFoldConstantsTest.java\n+/*\n+ * Copyright 2004 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+/**\n+ * Tests for PeepholeFoldConstants in isolation. Tests for the interaction of\n+ * multiple peephole passes are in PeepholeIntegrationTest.\n+ */\n+public class PeepholeFoldConstantsTest extends CompilerTestCase {\n+\n+  // TODO(user): Remove this when we no longer need to do string comparison.\n+  private PeepholeFoldConstantsTest(boolean compareAsTree) {\n+    super(\"\", compareAsTree);\n+  }\n+\n+  public PeepholeFoldConstantsTest() {\n+    super(\"\");\n+  }\n+\n+  @Override\n+  public void setUp() {\n+    enableLineNumberCheck(true);\n+  }\n+\n+  @Override\n+  public CompilerPass getProcessor(final Compiler compiler) {\n+    CompilerPass peepholePass = new PeepholeOptimizationsPass(compiler,\n+          new PeepholeFoldConstants());\n+\n+    return peepholePass;\n+  }\n+\n+  @Override\n+  protected int getNumRepetitions() {\n+    // Reduce this to 2 if we get better expression evaluators.\n+    return 2;\n+  }\n+\n+  private void foldSame(String js) {\n+    testSame(js);\n+  }\n+\n+  private void fold(String js, String expected) {\n+    test(js, expected);\n+  }\n+\n+  private void fold(String js, String expected, DiagnosticType warning) {\n+    test(js, expected, warning);\n+  }\n+\n+  // TODO(user): This is same as fold() except it uses string comparison. Any\n+  // test that needs tell us where a folding is constructing an invalid AST.\n+  private void assertResultString(String js, String expected) {\n+    PeepholeFoldConstantsTest scTest = new PeepholeFoldConstantsTest(false);\n+\n+    scTest.test(js, expected);\n+  }\n+\n+  public void testUndefinedComparison() {\n+    fold(\"undefined == undefined\", \"true\");\n+    fold(\"undefined == null\", \"true\");\n+    fold(\"undefined == void 0\", \"true\");\n+\n+    fold(\"undefined == 0\", \"false\");\n+    fold(\"undefined == 1\", \"false\");\n+    fold(\"undefined == 'hi'\", \"false\");\n+    fold(\"undefined == true\", \"false\");\n+    fold(\"undefined == false\", \"false\");\n+\n+    fold(\"undefined === undefined\", \"true\");\n+    fold(\"undefined === null\", \"false\");\n+    fold(\"undefined === void 0\", \"true\");\n+\n+    foldSame(\"undefined == this\");\n+    foldSame(\"undefined == x\");\n+\n+    fold(\"undefined != undefined\", \"false\");\n+    fold(\"undefined != null\", \"false\");\n+    fold(\"undefined != void 0\", \"false\");\n+\n+    fold(\"undefined != 0\", \"true\");\n+    fold(\"undefined != 1\", \"true\");\n+    fold(\"undefined != 'hi'\", \"true\");\n+    fold(\"undefined != true\", \"true\");\n+    fold(\"undefined != false\", \"true\");\n+\n+    fold(\"undefined !== undefined\", \"false\");\n+    fold(\"undefined !== void 0\", \"false\");\n+    fold(\"undefined !== null\", \"true\");\n+\n+    foldSame(\"undefined != this\");\n+    foldSame(\"undefined != x\");\n+\n+    fold(\"undefined < undefined\", \"false\");\n+    fold(\"undefined > undefined\", \"false\");\n+    fold(\"undefined >= undefined\", \"false\");\n+    fold(\"undefined <= undefined\", \"false\");\n+\n+    fold(\"0 < undefined\", \"false\");\n+    fold(\"true > undefined\", \"false\");\n+    fold(\"'hi' >= undefined\", \"false\");\n+    fold(\"null <= undefined\", \"false\");\n+\n+    fold(\"undefined < 0\", \"false\");\n+    fold(\"undefined > true\", \"false\");\n+    fold(\"undefined >= 'hi'\", \"false\");\n+    fold(\"undefined <= null\", \"false\");\n+\n+    fold(\"null == undefined\", \"true\");\n+    fold(\"0 == undefined\", \"false\");\n+    fold(\"1 == undefined\", \"false\");\n+    fold(\"'hi' == undefined\", \"false\");\n+    fold(\"true == undefined\", \"false\");\n+    fold(\"false == undefined\", \"false\");\n+    fold(\"null === undefined\", \"false\");\n+    fold(\"void 0 === undefined\", \"true\");\n+\n+    foldSame(\"this == undefined\");\n+    foldSame(\"x == undefined\");\n+  }\n+\n+  public void testUnaryOps() {\n+    fold(\"!foo()\", \"foo()\");\n+    fold(\"~foo()\", \"foo()\");\n+    fold(\"-foo()\", \"foo()\");\n+    fold(\"a=!true\", \"a=false\");\n+    fold(\"a=!10\", \"a=false\");\n+    fold(\"a=!false\", \"a=true\");\n+    fold(\"a=!foo()\", \"a=!foo()\");\n+    fold(\"a=-0\", \"a=0\");\n+    fold(\"a=-Infinity\", \"a=-Infinity\");\n+    fold(\"a=-NaN\", \"a=NaN\");\n+    fold(\"a=-foo()\", \"a=-foo()\");\n+    fold(\"a=~~0\", \"a=0\");\n+    fold(\"a=~~10\", \"a=10\");\n+    fold(\"a=~-7\", \"a=6\");\n+    fold(\"a=~0x100000000\", \"a=~0x100000000\",\n+         PeepholeFoldConstants.BITWISE_OPERAND_OUT_OF_RANGE);\n+    fold(\"a=~-0x100000000\", \"a=~-0x100000000\",\n+         PeepholeFoldConstants.BITWISE_OPERAND_OUT_OF_RANGE);\n+    fold(\"a=~.5\", \"~.5\", PeepholeFoldConstants.FRACTIONAL_BITWISE_OPERAND);\n+  }\n+\n+  public void testUnaryOpsStringCompare() {\n+    // Negatives are folded into a single number node.\n+    assertResultString(\"a=-1\", \"a=-1\");\n+    assertResultString(\"a=~0\", \"a=-1\");\n+    assertResultString(\"a=~1\", \"a=-2\");\n+    assertResultString(\"a=~101\", \"a=-102\");\n+  }\n+\n+  public void testFoldLogicalOp() {\n+    fold(\"x = true && x\", \"x = x\");\n+    fold(\"x = false && x\", \"x = false\");\n+    fold(\"x = true || x\", \"x = true\");\n+    fold(\"x = false || x\", \"x = x\");\n+    fold(\"x = 0 && x\", \"x = 0\");\n+    fold(\"x = 3 || x\", \"x = 3\");\n+    fold(\"x = false || 0\", \"x = 0\");\n+\n+    // surprisingly unfoldable\n+    fold(\"a = x && true\", \"a=x&&true\");\n+    fold(\"a = x && false\", \"a=x&&false\");\n+    fold(\"a = x || 3\", \"a=x||3\");\n+    fold(\"a = x || false\", \"a=x||false\");\n+    fold(\"a = b ? c : x || false\", \"a=b?c:x||false\");\n+    fold(\"a = b ? x || false : c\", \"a=b?x||false:c\");\n+    fold(\"a = b ? c : x && true\", \"a=b?c:x&&true\");\n+    fold(\"a = b ? x && true : c\", \"a=b?x&&true:c\");\n+\n+    // foldable, analogous to if().\n+    fold(\"a = x || false ? b : c\", \"a=x?b:c\");\n+    fold(\"a = x && true ? b : c\", \"a=x?b:c\");\n+\n+    fold(\"x = foo() || true || bar()\", \"x = foo()||true\");\n+    fold(\"x = foo() || false || bar()\", \"x = foo()||bar()\");\n+    fold(\"x = foo() || true && bar()\", \"x = foo()||bar()\");\n+    fold(\"x = foo() || false && bar()\", \"x = foo()||false\");\n+    fold(\"x = foo() && false && bar()\", \"x = foo()&&false\");\n+    fold(\"x = foo() && true && bar()\", \"x = foo()&&bar()\");\n+    fold(\"x = foo() && false || bar()\", \"x = foo()&&false||bar()\");\n+\n+    // Really not foldable, because it would change the type of the\n+    // expression if foo() returns something equivalent, but not\n+    // identical, to true. Cf. FoldConstants.tryFoldAndOr().\n+    foldSame(\"x = foo() && true || bar()\");\n+    foldSame(\"foo() && true || bar()\");\n+\n+  }\n+\n+  public void testFoldBitwiseOp() {\n+    fold(\"x = 1 & 1\", \"x = 1\");\n+    fold(\"x = 1 & 2\", \"x = 0\");\n+    fold(\"x = 3 & 1\", \"x = 1\");\n+    fold(\"x = 3 & 3\", \"x = 3\");\n+\n+    fold(\"x = 1 | 1\", \"x = 1\");\n+    fold(\"x = 1 | 2\", \"x = 3\");\n+    fold(\"x = 3 | 1\", \"x = 3\");\n+    fold(\"x = 3 | 3\", \"x = 3\");\n+\n+    fold(\"x = -1 & 0\", \"x = 0\");\n+    fold(\"x = 0 & -1\", \"x = 0\");\n+    fold(\"x = 1 & 4\", \"x = 0\");\n+    fold(\"x = 2 & 3\", \"x = 2\");\n+\n+    // make sure we fold only when we are supposed to -- not when doing so would\n+    // lose information or when it is performed on nonsensical arguments.\n+    fold(\"x = 1 & 1.1\", \"x = 1&1.1\");\n+    fold(\"x = 1.1 & 1\", \"x = 1.1&1\");\n+    fold(\"x = 1 & 3000000000\", \"x = 1&3000000000\");\n+    fold(\"x = 3000000000 & 1\", \"x = 3000000000&1\");\n+\n+    // Try some cases with | as well\n+    fold(\"x = 1 | 4\", \"x = 5\");\n+    fold(\"x = 1 | 3\", \"x = 3\");\n+    fold(\"x = 1 | 1.1\", \"x = 1|1.1\");\n+    fold(\"x = 1 | 3000000000\", \"x = 1|3000000000\");\n+  }\n+\n+  public void testFoldBitwiseOpStringCompare() {\n+    assertResultString(\"x = -1 | 0\", \"x=-1\");\n+    // EXPR_RESULT case is in in PeepholeIntegrationTest\n+  }\n+\n+  public void testFoldBitShifts() {\n+    fold(\"x = 1 << 0\", \"x = 1\");\n+    fold(\"x = 1 << 1\", \"x = 2\");\n+    fold(\"x = 3 << 1\", \"x = 6\");\n+    fold(\"x = 1 << 8\", \"x = 256\");\n+\n+    fold(\"x = 1 >> 0\", \"x = 1\");\n+    fold(\"x = 1 >> 1\", \"x = 0\");\n+    fold(\"x = 2 >> 1\", \"x = 1\");\n+    fold(\"x = 5 >> 1\", \"x = 2\");\n+    fold(\"x = 127 >> 3\", \"x = 15\");\n+    fold(\"x = 3 >> 1\", \"x = 1\");\n+    fold(\"x = 3 >> 2\", \"x = 0\");\n+    fold(\"x = 10 >> 1\", \"x = 5\");\n+    fold(\"x = 10 >> 2\", \"x = 2\");\n+    fold(\"x = 10 >> 5\", \"x = 0\");\n+\n+    fold(\"x = 10 >>> 1\", \"x = 5\");\n+    fold(\"x = 10 >>> 2\", \"x = 2\");\n+    fold(\"x = 10 >>> 5\", \"x = 0\");\n+    fold(\"x = -1 >>> 1\", \"x = \" + 0x7fffffff);\n+\n+    fold(\"3000000000 << 1\", \"3000000000<<1\",\n+         PeepholeFoldConstants.BITWISE_OPERAND_OUT_OF_RANGE);\n+    fold(\"1 << 32\", \"1<<32\",\n+        PeepholeFoldConstants.SHIFT_AMOUNT_OUT_OF_BOUNDS);\n+    fold(\"1 << -1\", \"1<<32\",\n+        PeepholeFoldConstants.SHIFT_AMOUNT_OUT_OF_BOUNDS);\n+    fold(\"3000000000 >> 1\", \"3000000000>>1\",\n+        PeepholeFoldConstants.BITWISE_OPERAND_OUT_OF_RANGE);\n+    fold(\"1 >> 32\", \"1>>32\",\n+        PeepholeFoldConstants.SHIFT_AMOUNT_OUT_OF_BOUNDS);\n+    fold(\"1.5 << 0\",  \"1.5<<0\",\n+        PeepholeFoldConstants.FRACTIONAL_BITWISE_OPERAND);\n+    fold(\"1 << .5\",   \"1.5<<0\",\n+        PeepholeFoldConstants.FRACTIONAL_BITWISE_OPERAND);\n+    fold(\"1.5 >>> 0\", \"1.5>>>0\",\n+        PeepholeFoldConstants.FRACTIONAL_BITWISE_OPERAND);\n+    fold(\"1 >>> .5\",  \"1.5>>>0\",\n+        PeepholeFoldConstants.FRACTIONAL_BITWISE_OPERAND);\n+    fold(\"1.5 >> 0\",  \"1.5>>0\",\n+        PeepholeFoldConstants.FRACTIONAL_BITWISE_OPERAND);\n+    fold(\"1 >> .5\",   \"1.5>>0\",\n+        PeepholeFoldConstants.FRACTIONAL_BITWISE_OPERAND);\n+  }\n+\n+  public void testFoldBitShiftsStringCompare() {\n+    // Negative numbers.\n+    assertResultString(\"x = -1 << 1\", \"x=-2\");\n+    assertResultString(\"x = -1 << 8\", \"x=-256\");\n+    assertResultString(\"x = -1 >> 1\", \"x=-1\");\n+    assertResultString(\"x = -2 >> 1\", \"x=-1\");\n+    assertResultString(\"x = -1 >> 0\", \"x=-1\");\n+  }\n+\n+  public void testStringAdd() {\n+    fold(\"x = 'a' + \\\"bc\\\"\", \"x = \\\"abc\\\"\");\n+    fold(\"x = 'a' + 5\", \"x = \\\"a5\\\"\");\n+    fold(\"x = 5 + 'a'\", \"x = \\\"5a\\\"\");\n+    fold(\"x = 'a' + ''\", \"x = \\\"a\\\"\");\n+    fold(\"x = \\\"a\\\" + foo()\", \"x = \\\"a\\\"+foo()\");\n+    fold(\"x = foo() + 'a' + 'b'\", \"x = foo()+\\\"ab\\\"\");\n+    fold(\"x = (foo() + 'a') + 'b'\", \"x = foo()+\\\"ab\\\"\");  // believe it!\n+    fold(\"x = foo() + 'a' + 'b' + 'cd' + bar()\", \"x = foo()+\\\"abcd\\\"+bar()\");\n+    fold(\"x = foo() + 2 + 'b'\", \"x = foo()+2+\\\"b\\\"\");  // don't fold!\n+    fold(\"x = foo() + 'a' + 2\", \"x = foo()+\\\"a2\\\"\");\n+    fold(\"x = '' + null\", \"x = \\\"null\\\"\");\n+    fold(\"x = true + '' + false\", \"x = \\\"truefalse\\\"\");\n+    fold(\"x = '' + []\", \"x = \\\"\\\"+[]\");      // cannot fold (but nice if we can)\n+  }\n+\n+  public void testStringIndexOf() {\n+    fold(\"x = 'abcdef'.indexOf('b')\", \"x = 1\");\n+    fold(\"x = 'abcdefbe'.indexOf('b', 2)\", \"x = 6\");\n+    fold(\"x = 'abcdef'.indexOf('bcd')\", \"x = 1\");\n+    fold(\"x = 'abcdefsdfasdfbcdassd'.indexOf('bcd', 4)\", \"x = 13\");\n+\n+    fold(\"x = 'abcdef'.lastIndexOf('b')\", \"x = 1\");\n+    fold(\"x = 'abcdefbe'.lastIndexOf('b')\", \"x = 6\");\n+    fold(\"x = 'abcdefbe'.lastIndexOf('b', 5)\", \"x = 1\");\n+\n+    // Both elements must be string. Dont do anything if either one is not\n+    // string.\n+    fold(\"x = 'abc1def'.indexOf(1)\", \"x = 3\");\n+    fold(\"x = 'abcNaNdef'.indexOf(NaN)\", \"x = 3\");\n+    fold(\"x = 'abcundefineddef'.indexOf(undefined)\", \"x = 3\");\n+    fold(\"x = 'abcnulldef'.indexOf(null)\", \"x = 3\");\n+    fold(\"x = 'abctruedef'.indexOf(true)\", \"x = 3\");\n+\n+    // The following testcase fails with JSC_PARSE_ERROR. Hence omitted.\n+    // foldSame(\"x = 1.indexOf('bcd');\");\n+    foldSame(\"x = NaN.indexOf('bcd')\");\n+    foldSame(\"x = undefined.indexOf('bcd')\");\n+    foldSame(\"x = null.indexOf('bcd')\");\n+    foldSame(\"x = true.indexOf('bcd')\");\n+    foldSame(\"x = false.indexOf('bcd')\");\n+\n+    // Avoid dealing with regex or other types.\n+    foldSame(\"x = 'abcdef'.indexOf(/b./)\");\n+    foldSame(\"x = 'abcdef'.indexOf({a:2})\");\n+    foldSame(\"x = 'abcdef'.indexOf([1,2])\");\n+  }\n+\n+  public void testStringJoinAdd() {\n+    fold(\"x = ['a', 'b', 'c'].join('')\", \"x = \\\"abc\\\"\");\n+    fold(\"x = [].join(',')\", \"x = \\\"\\\"\");\n+    fold(\"x = ['a'].join(',')\", \"x = \\\"a\\\"\");\n+    fold(\"x = ['a', 'b', 'c'].join(',')\", \"x = \\\"a,b,c\\\"\");\n+    fold(\"x = ['a', foo, 'b', 'c'].join(',')\",\n+        \"x = [\\\"a\\\",foo,\\\"b,c\\\"].join(\\\",\\\")\");\n+    fold(\"x = [foo, 'a', 'b', 'c'].join(',')\",\n+        \"x = [foo,\\\"a,b,c\\\"].join(\\\",\\\")\");\n+    fold(\"x = ['a', 'b', 'c', foo].join(',')\",\n+        \"x = [\\\"a,b,c\\\",foo].join(\\\",\\\")\");\n+\n+    // Works with numbers\n+    fold(\"x = ['a=', 5].join('')\", \"x = \\\"a=5\\\"\");\n+    fold(\"x = ['a', '5'].join(7)\", \"x = \\\"a75\\\"\");\n+\n+    // Works on boolean\n+    fold(\"x = ['a=', false].join('')\", \"x = \\\"a=false\\\"\");\n+    fold(\"x = ['a', '5'].join(true)\", \"x = \\\"atrue5\\\"\");\n+    fold(\"x = ['a', '5'].join(false)\", \"x = \\\"afalse5\\\"\");\n+\n+    // Only optimize if it's a size win.\n+    fold(\"x = ['a', '5', 'c'].join('a very very very long chain')\",\n+         \"x = [\\\"a\\\",\\\"5\\\",\\\"c\\\"].join(\\\"a very very very long chain\\\")\");\n+\n+    // TODO(user): Its possible to fold this better.\n+    foldSame(\"x = ['', foo].join(',')\");\n+    foldSame(\"x = ['', foo, ''].join(',')\");\n+\n+    fold(\"x = ['', '', foo, ''].join(',')\", \"x = [',', foo, ''].join(',')\");\n+    fold(\"x = ['', '', foo, '', ''].join(',')\",\n+         \"x = [',', foo, ','].join(',')\");\n+\n+    fold(\"x = ['', '', foo, '', '', bar].join(',')\",\n+         \"x = [',', foo, ',', bar].join(',')\");\n+\n+    fold(\"x = [1,2,3].join('abcdef')\",\n+         \"x = '1abcdef2abcdef3'\");\n+  }\n+\n+  public void testStringJoinAdd_b1992789() {\n+    fold(\"x = ['a'].join('')\", \"x = \\\"a\\\"\");\n+    fold(\"x = [foo()].join('')\", \"x = '' + foo()\");\n+    fold(\"[foo()].join('')\", \"'' + foo()\");\n+  }\n+\n+  public void testFoldArithmetic() {\n+    fold(\"x = 10 + 20\", \"x = 30\");\n+    fold(\"x = 2 / 4\", \"x = 0.5\");\n+    fold(\"x = 2.25 * 3\", \"x = 6.75\");\n+    fold(\"z = x * y\", \"z = x * y\");\n+    fold(\"x = y * 5\", \"x = y * 5\");\n+    fold(\"x = 1 / 0\", \"\", PeepholeFoldConstants.DIVIDE_BY_0_ERROR);\n+  }\n+\n+  public void testFoldArithmeticStringComp() {\n+    // Negative Numbers.\n+    assertResultString(\"x = 10 - 20\", \"x=-10\");\n+  }\n+\n+  public void testFoldComparison() {\n+    fold(\"x = 0 == 0\", \"x = true\");\n+    fold(\"x = 1 == 2\", \"x = false\");\n+    fold(\"x = 'abc' == 'def'\", \"x = false\");\n+    fold(\"x = 'abc' == 'abc'\", \"x = true\");\n+    fold(\"x = \\\"\\\" == ''\", \"x = true\");\n+    fold(\"x = foo() == bar()\", \"x = foo()==bar()\");\n+\n+    fold(\"x = 1 != 0\", \"x = true\");\n+    fold(\"x = 'abc' != 'def'\", \"x = true\");\n+    fold(\"x = 'a' != 'a'\", \"x = false\");\n+\n+    fold(\"x = 1 < 20\", \"x = true\");\n+    fold(\"x = 3 < 3\", \"x = false\");\n+    fold(\"x = 10 > 1.0\", \"x = true\");\n+    fold(\"x = 10 > 10.25\", \"x = false\");\n+    fold(\"x = y == y\", \"x = y==y\");\n+    fold(\"x = y < y\", \"x = false\");\n+    fold(\"x = y > y\", \"x = false\");\n+    fold(\"x = 1 <= 1\", \"x = true\");\n+    fold(\"x = 1 <= 0\", \"x = false\");\n+    fold(\"x = 0 >= 0\", \"x = true\");\n+    fold(\"x = -1 >= 9\", \"x = false\");\n+\n+    fold(\"x = true == true\", \"x = true\");\n+    fold(\"x = true == true\", \"x = true\");\n+    fold(\"x = false == null\", \"x = false\");\n+    fold(\"x = false == true\", \"x = false\");\n+    fold(\"x = true == null\", \"x = false\");\n+\n+    fold(\"0 == 0\", \"true\");\n+    fold(\"1 == 2\", \"false\");\n+    fold(\"'abc' == 'def'\", \"false\");\n+    fold(\"'abc' == 'abc'\", \"true\");\n+    fold(\"\\\"\\\" == ''\", \"true\");\n+    foldSame(\"foo() == bar()\");\n+\n+    fold(\"1 != 0\", \"true\");\n+    fold(\"'abc' != 'def'\", \"true\");\n+    fold(\"'a' != 'a'\", \"false\");\n+\n+    fold(\"1 < 20\", \"true\");\n+    fold(\"3 < 3\", \"false\");\n+    fold(\"10 > 1.0\", \"true\");\n+    fold(\"10 > 10.25\", \"false\");\n+    foldSame(\"x == x\");\n+    fold(\"x < x\", \"false\");\n+    fold(\"x > x\", \"false\");\n+    fold(\"1 <= 1\", \"true\");\n+    fold(\"1 <= 0\", \"false\");\n+    fold(\"0 >= 0\", \"true\");\n+    fold(\"-1 >= 9\", \"false\");\n+\n+    fold(\"true == true\", \"true\");\n+    fold(\"false == null\", \"false\");\n+    fold(\"false == true\", \"false\");\n+    fold(\"true == null\", \"false\");\n+  }\n+\n+  // ===, !== comparison tests\n+  public void testFoldComparison2() {\n+    fold(\"x = 0 === 0\", \"x = true\");\n+    fold(\"x = 1 === 2\", \"x = false\");\n+    fold(\"x = 'abc' === 'def'\", \"x = false\");\n+    fold(\"x = 'abc' === 'abc'\", \"x = true\");\n+    fold(\"x = \\\"\\\" === ''\", \"x = true\");\n+    fold(\"x = foo() === bar()\", \"x = foo()===bar()\");\n+\n+    fold(\"x = 1 !== 0\", \"x = true\");\n+    fold(\"x = 'abc' !== 'def'\", \"x = true\");\n+    fold(\"x = 'a' !== 'a'\", \"x = false\");\n+\n+    fold(\"x = y === y\", \"x = y===y\");\n+\n+    fold(\"x = true === true\", \"x = true\");\n+    fold(\"x = true === true\", \"x = true\");\n+    fold(\"x = false === null\", \"x = false\");\n+    fold(\"x = false === true\", \"x = false\");\n+    fold(\"x = true === null\", \"x = false\");\n+\n+    fold(\"0 === 0\", \"true\");\n+    fold(\"1 === 2\", \"false\");\n+    fold(\"'abc' === 'def'\", \"false\");\n+    fold(\"'abc' === 'abc'\", \"true\");\n+    fold(\"\\\"\\\" === ''\", \"true\");\n+    foldSame(\"foo() === bar()\");\n+\n+    // TODO(johnlenz): It would be nice to handle these cases as well.\n+    foldSame(\"1 === '1'\");\n+    foldSame(\"1 === true\");\n+    foldSame(\"1 !== '1'\");\n+    foldSame(\"1 !== true\");\n+\n+    fold(\"1 !== 0\", \"true\");\n+    fold(\"'abc' !== 'def'\", \"true\");\n+    fold(\"'a' !== 'a'\", \"false\");\n+\n+    foldSame(\"x === x\");\n+\n+    fold(\"true === true\", \"true\");\n+    fold(\"false === null\", \"false\");\n+    fold(\"false === true\", \"false\");\n+    fold(\"true === null\", \"false\");\n+  }\n+\n+  public void testFoldGetElem() {\n+    fold(\"x = [10, 20][0]\", \"x = 10\");\n+    fold(\"x = [10, 20][1]\", \"x = 20\");\n+    fold(\"x = [10, 20][0.5]\", \"\",\n+        PeepholeFoldConstants.INVALID_GETELEM_INDEX_ERROR);\n+    fold(\"x = [10, 20][-1]\",    \"\",\n+        PeepholeFoldConstants.INDEX_OUT_OF_BOUNDS_ERROR);\n+    fold(\"x = [10, 20][2]\",     \"\",\n+        PeepholeFoldConstants.INDEX_OUT_OF_BOUNDS_ERROR);\n+  }\n+\n+  public void testFoldComplex() {\n+    fold(\"x = (3 / 1.0) + (1 * 2)\", \"x = 5\");\n+    fold(\"x = (1 == 1.0) && foo() && true\", \"x = foo()&&true\");\n+    fold(\"x = 'abc' + 5 + 10\", \"x = \\\"abc510\\\"\");\n+  }\n+\n+  public void testFoldArrayLength() {\n+    // Can fold\n+    fold(\"x = [].length\", \"x = 0\");\n+    fold(\"x = [1,2,3].length\", \"x = 3\");\n+    fold(\"x = [a,b].length\", \"x = 2\");\n+\n+    // Cannot fold\n+    fold(\"x = [foo(), 0].length\", \"x = [foo(),0].length\");\n+    fold(\"x = y.length\", \"x = y.length\");\n+  }\n+\n+  public void testFoldStringLength() {\n+    // Can fold basic strings.\n+    fold(\"x = ''.length\", \"x = 0\");\n+    fold(\"x = '123'.length\", \"x = 3\");\n+\n+    // Test unicode escapes are accounted for.\n+    fold(\"x = '123\\u01dc'.length\", \"x = 4\");\n+  }\n+\n+  public void testFoldTypeof() {\n+    fold(\"x = typeof 1\", \"x = \\\"number\\\"\");\n+    fold(\"x = typeof 'foo'\", \"x = \\\"string\\\"\");\n+    fold(\"x = typeof true\", \"x = \\\"boolean\\\"\");\n+    fold(\"x = typeof false\", \"x = \\\"boolean\\\"\");\n+    fold(\"x = typeof null\", \"x = \\\"object\\\"\");\n+    fold(\"x = typeof undefined\", \"x = \\\"undefined\\\"\");\n+    fold(\"x = typeof []\", \"x = \\\"object\\\"\");\n+    fold(\"x = typeof [1]\", \"x = \\\"object\\\"\");\n+    fold(\"x = typeof [1,[]]\", \"x = \\\"object\\\"\");\n+    fold(\"x = typeof {}\", \"x = \\\"object\\\"\");\n+\n+    foldSame(\"x = typeof[1,[foo()]]\");\n+    foldSame(\"x = typeof{bathwater:baby()}\");\n+  }\n+\n+  public void testFoldInstanceOf() {\n+    // Non object types are never instances of anything.\n+    fold(\"64 instanceof Object\", \"false\");\n+    fold(\"64 instanceof Number\", \"false\");\n+    fold(\"'' instanceof Object\", \"false\");\n+    fold(\"'' instanceof String\", \"false\");\n+    fold(\"true instanceof Object\", \"false\");\n+    fold(\"true instanceof Boolean\", \"false\");\n+    fold(\"false instanceof Object\", \"false\");\n+    fold(\"null instanceof Object\", \"false\");\n+    fold(\"undefined instanceof Object\", \"false\");\n+    fold(\"NaN instanceof Object\", \"false\");\n+    fold(\"Infinity instanceof Object\", \"false\");\n+\n+    // Array and object literals are known to be objects.\n+    fold(\"[] instanceof Object\", \"true\");\n+    fold(\"({}) instanceof Object\", \"true\");\n+\n+    // These cases is foldable, but no handled currently.\n+    foldSame(\"new Foo() instanceof Object\");\n+    // These would require type information to fold.\n+    foldSame(\"[] instanceof Foo\");\n+    foldSame(\"({}) instanceof Foo\");\n+  }\n+\n+  public void testDivision() {\n+    // Make sure the 1/3 does not expand to 0.333333\n+    fold(\"print(1/3)\", \"print(1/3)\");\n+\n+    // Decimal form is preferable to fraction form when strings are the\n+    // same length.\n+    fold(\"print(1/2)\", \"print(0.5)\");\n+  }\n+\n+  public void testAssignOps() {\n+    fold(\"x=x+y\", \"x+=y\");\n+    fold(\"x=x*y\", \"x*=y\");\n+    fold(\"x.y=x.y+z\", \"x.y+=z\");\n+    foldSame(\"next().x = next().x + 1\");\n+  }\n+}\n--- /dev/null\n+++ b/test/com/google/javascript/jscomp/PeepholeIntegrationTest.java\n+/*\n+ * Copyright 2004 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+/**\n+ * Tests for the interaction between multiple peephole passes.\n+ */\n+public class PeepholeIntegrationTest extends CompilerTestCase {\n+\n+  // TODO(user): Remove this when we no longer need to do string comparison.\n+  private PeepholeIntegrationTest(boolean compareAsTree) {\n+    super(\"\", compareAsTree);\n+  }\n+\n+  public PeepholeIntegrationTest() {\n+    super(\"\");\n+  }\n+\n+  @Override\n+  public void setUp() throws Exception {\n+    super.setUp();\n+\n+    enableLineNumberCheck(true);\n+\n+    // TODO(nicksantos): Turn this on. There are some normalizations\n+    // that cause weirdness here.\n+    disableNormalize();\n+  }\n+\n+  @Override\n+  public CompilerPass getProcessor(final Compiler compiler) {\n+    PeepholeOptimizationsPass peepholePass =\n+      new PeepholeOptimizationsPass(compiler,\n+        new PeepholeSubstituteAlternateSyntax(),\n+        new PeepholeRemoveDeadCode(),\n+        new PeepholeFoldConstants()\n+      );\n+\n+    return peepholePass;\n+  }\n+\n+  @Override\n+  protected int getNumRepetitions() {\n+    // Reduce this to 2 if we get better expression evaluators.\n+    return 2;\n+  }\n+\n+  private void foldSame(String js) {\n+    testSame(js);\n+  }\n+\n+  private void fold(String js, String expected) {\n+    test(js, expected);\n+  }\n+\n+  // TODO(user): This is same as fold() except it uses string comparison. Any\n+  // test that needs tell us where a folding is constructing an invalid AST.\n+  private void assertResultString(String js, String expected) {\n+    PeepholeIntegrationTest scTest = new PeepholeIntegrationTest(false);\n+\n+    scTest.disableNormalize();\n+\n+    scTest.test(js, expected);\n+  }\n+\n+  /** Check that removing blocks with 1 child works */\n+  public void testFoldOneChildBlocksIntegration() {\n+     fold(\"function(){switch(x){default:{break}}}\",\n+          \"function(){switch(x){default:break}}\");\n+\n+     fold(\"function(){switch(x){default:x;case 1:return 2}}\",\n+          \"function(){switch(x){default:case 1:return 2}}\");\n+\n+     // ensure that block folding does not break hook ifs\n+     fold(\"if(x){if(true){foo();foo()}else{bar();bar()}}\",\n+          \"if(x){foo();foo()}\");\n+\n+     fold(\"if(x){if(false){foo();foo()}else{bar();bar()}}\",\n+          \"if(x){bar();bar()}\");\n+\n+     // Cases where the then clause has no side effects.\n+     fold(\"if(x()){}\", \"x()\");\n+\n+     fold(\"if(x()){} else {x()}\", \"x()||x()\");\n+     fold(\"if(x){}\", \"\"); // Even the condition has no side effect.\n+     fold(\"if(a()){A()} else if (b()) {} else {C()}\",\n+          \"if(a())A();else b()||C()\");\n+\n+     fold(\"if(a()){} else if (b()) {} else {C()}\",\n+          \"a()||b()||C()\");\n+     fold(\"if(a()){A()} else if (b()) {} else if (c()) {} else{D()}\",\n+          \"if(a())A();else b()||c()||D()\");\n+     fold(\"if(a()){} else if (b()) {} else if (c()) {} else{D()}\",\n+          \"a()||b()||c()||D()\");\n+     fold(\"if(a()){A()} else if (b()) {} else if (c()) {} else{}\",\n+          \"if(a())A();else b()||c()\");\n+\n+     // Verify that non-global scope works.\n+     fold(\"function foo(){if(x()){}}\", \"function foo(){x()}\");\n+\n+  }\n+\n+  public void testFoldOneChildBlocksStringCompare() {\n+    // The expected parse tree has a BLOCK structure around the true branch.\n+    assertResultString(\"if(x){if(y){var x;}}else{var z;}\",\n+        \"if(x){if(y)var x}else var z\");\n+  }\n+\n+  /** Test a particularly hairy edge case. */\n+  public void testNecessaryDanglingElse() {\n+    // The extra block is added by CodeGenerator. The logic to avoid ambiguous\n+    // else clauses used to be in FoldConstants, so the test is here for\n+    // legacy reasons.\n+    assertResultString(\n+        \"if(x)if(y){y();z()}else;else x()\", \"if(x){if(y){y();z()}}else x()\");\n+  }\n+\n+  /** Try to minimize returns */\n+  public void testFoldReturnsIntegration() {\n+    // if-then-else duplicate statement removal handles this case:\n+    fold(\"function(){if(x)return;else return}\",\n+         \"function(){return}\");\n+  }\n+\n+  public void testBug1059649() {\n+    // ensure that folding blocks with a single var node doesn't explode\n+    fold(\"if(x){var y=3;}var z=5\", \"if(x)var y=3;var z=5\");\n+\n+    // With normalization, we no longer have this case.\n+    foldSame(\"if(x){var y=3;}else{var y=4;}var z=5\");\n+    fold(\"while(x){var y=3;}var z=5\", \"while(x)var y=3;var z=5\");\n+    fold(\"for(var i=0;i<10;i++){var y=3;}var z=5\",\n+         \"for(var i=0;i<10;i++)var y=3;var z=5\");\n+    fold(\"for(var i in x){var y=3;}var z=5\",\n+         \"for(var i in x)var y=3;var z=5\");\n+    fold(\"do{var y=3;}while(x);var z=5\", \"do var y=3;while(x);var z=5\");\n+  }\n+\n+  public void testHookIfIntegration() {\n+    fold(\"if (false){ x = 1; } else if (cond) { x = 2; } else { x = 3; }\",\n+         \"x=cond?2:3\");\n+\n+    fold(\"x?void 0:y()\", \"x||y()\");\n+    fold(\"!x?void 0:y()\", \"x&&y()\");\n+    fold(\"x?y():void 0\", \"x&&y()\");\n+  }\n+\n+  public void testRemoveDuplicateStatementsIntegration() {\n+    fold(\"function z() {if (a) { return true }\" +\n+         \"else if (b) { return true }\" +\n+         \"else { return true }}\",\n+         \"function z() {return true;}\");\n+\n+    fold(\"function z() {if (a()) { return true }\" +\n+         \"else if (b()) { return true }\" +\n+         \"else { return true }}\",\n+         \"function z() {a()||b();return true;}\");\n+  }\n+\n+  public void testFoldLogicalOpIntegration() {\n+    test(\"if(x && true) z()\", \"x&&z()\");\n+    test(\"if(x && false) z()\", \"\");\n+    fold(\"if(x || 3) z()\", \"z()\");\n+    fold(\"if(x || false) z()\", \"x&&z()\");\n+    test(\"if(x==y && false) z()\", \"\");\n+\n+    // This would be foldable, but it isn't detected, because 'if' isn't\n+    // the parent of 'x || 3'. Cf. FoldConstants.tryFoldAndOr().\n+    fold(\"if(y() || x || 3) z()\", \"if(y()||x||1)z()\");\n+  }\n+\n+  public void testFoldBitwiseOpStringCompareIntegration() {\n+    assertResultString(\"-1 | 0\", \"1\");\n+  }\n+\n+  public void testVarLiftingIntegration() {\n+    fold(\"if(true);else var a;\", \"var a\");\n+    fold(\"if(false) foo();else var a;\", \"var a\");\n+    fold(\"if(true)var a;else;\", \"var a\");\n+    fold(\"if(false)var a;else;\", \"var a\");\n+    fold(\"if(false)var a,b;\", \"var b; var a\");\n+    fold(\"if(false){var a;var a;}\", \"var a\");\n+    fold(\"if(false)var a=function(){var b};\", \"var a\");\n+    fold(\"if(a)if(false)var a;else var b;\", \"var a;if(a)var b\");\n+  }\n+\n+  public void testBug1438784() throws Exception {\n+    fold(\"for(var i=0;i<10;i++)if(x)x.y;\", \"for(var i=0;i<10;i++);\");\n+  }\n+\n+  public void testFoldUselessWhileIntegration() {\n+    fold(\"while(!true) { foo() }\", \"\");\n+    fold(\"while(!false) foo() \", \"while(1) foo()\");\n+    fold(\"while(!void 0) foo()\", \"while(1) foo()\");\n+\n+    // Make sure proper empty nodes are inserted.\n+    fold(\"if(foo())while(false){foo()}else bar()\", \"foo()||bar()\");\n+  }\n+\n+  public void testFoldUselessForIntegration() {\n+    fold(\"for(;!true;) { foo() }\", \"\");\n+    fold(\"for(;void 0;) { foo() }\", \"\");\n+    fold(\"for(;undefined;) { foo() }\", \"\");\n+    fold(\"for(;1;) foo()\", \"for(;;) foo()\");\n+    fold(\"for(;!void 0;) foo()\", \"for(;;) foo()\");\n+\n+    // Make sure proper empty nodes are inserted.\n+    fold(\"if(foo())for(;false;){foo()}else bar()\", \"foo()||bar()\");\n+  }\n+\n+  public void testFoldUselessDoIntegration() {\n+    test(\"do { foo() } while(!true);\", \"foo()\");\n+    fold(\"do { foo() } while(void 0);\", \"foo()\");\n+    fold(\"do { foo() } while(undefined);\", \"foo()\");\n+    fold(\"do { foo() } while(!void 0);\", \"do { foo() } while(1);\");\n+\n+    // Make sure proper empty nodes are inserted.\n+    test(\"if(foo())do {foo()} while(false) else bar()\", \"foo()?foo():bar()\");\n+  }\n+\n+  public void testMinimizeWhileConstantConditionIntegration() {\n+    fold(\"while(!false) foo()\", \"while(1) foo()\");\n+    fold(\"while(202) foo()\", \"while(1) foo()\");\n+    fold(\"while(Infinity) foo()\", \"while(1) foo()\");\n+    fold(\"while('text') foo()\", \"while(1) foo()\");\n+    fold(\"while([]) foo()\", \"while(1) foo()\");\n+    fold(\"while({}) foo()\", \"while(1) foo()\");\n+    fold(\"while(/./) foo()\", \"while(1) foo()\");\n+  }\n+\n+  public void testMinimizeExpr() {\n+    /* This test is surprising.\n+     *\n+     * What is happening is this:\n+     * First PeepholeFoldConstants.tryFoldUnaryOperator is folding\n+     * the inner \"!true\" to \"false\", so the whole expression  becomes\n+     * !false.\n+     * Then, on the next iteration, tryFoldUnaryOperator sees the parent of\n+     * !false is a Token.EXPR_RESULT and is therefore not used,\n+     * so it drops the NOT, leaving false, which is then converted to 0.\n+     */\n+    test(\"!!true\", \"0\");\n+\n+    fold(\"!!x\", \"x\");\n+    test(\"!(!x&&!y)\", \"!x&&!y\");\n+    fold(\"x||!!y\", \"x||y\");\n+\n+    /* This is similar to the !!true case */\n+    fold(\"!(!!x&&y)\", \"x&&y\");\n+  }\n+\n+  public void testBug1509085() {\n+    PeepholeIntegrationTest oneRepetitiontest = new PeepholeIntegrationTest() {\n+      @Override\n+      protected int getNumRepetitions() {\n+        return 1;\n+      }\n+    };\n+\n+    oneRepetitiontest.test(\"x ? x() : void 0\", \"x&&x();\");\n+    oneRepetitiontest.foldSame(\"y = x ? x() : void 0\");\n+  }\n+\n+  public void testBugIssue3() {\n+    foldSame(\"function foo() {\" +\n+             \"  if(sections.length != 1) children[i] = 0;\" +\n+             \"  else var selectedid = children[i]\" +\n+             \"}\");\n+  }\n+\n+  public void testBugIssue43() {\n+    foldSame(\"function foo() {\" +\n+             \"  if (a) { var b = 1; } else { a.b = 1; }\" +\n+             \"}\");\n+  }\n+\n+  public void testFoldNegativeBug() {\n+    fold(\"(-3);\", \"1;\");\n+  }\n+\n+  public void testNoNormalizeLabeledExpr() {\n+    enableNormalize(true);\n+    foldSame(\"var x; foo:{x = 3;}\");\n+    foldSame(\"var x; foo:x = 3;\");\n+  }\n+}\n--- /dev/null\n+++ b/test/com/google/javascript/jscomp/PeepholeRemoveDeadCodeTest.java\n+/*\n+ * Copyright 2004 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+/**\n+ * Tests for PeepholeRemoveDeadCodeTest in isolation. Tests for the interaction\n+ * of multiple peephole passes are in PeepholeIntegrationTest.\n+ */\n+public class PeepholeRemoveDeadCodeTest extends CompilerTestCase {\n+  \n+  public PeepholeRemoveDeadCodeTest() {\n+    super(\"\");\n+  }\n+\n+  @Override\n+  public void setUp() throws Exception {\n+    super.setUp();\n+    enableLineNumberCheck(true);\n+  }\n+\n+  @Override\n+  public CompilerPass getProcessor(final Compiler compiler) {\n+    PeepholeOptimizationsPass peepholePass =\n+      new PeepholeOptimizationsPass(compiler, new PeepholeRemoveDeadCode());\n+    \n+    return peepholePass;\n+  }\n+\n+  @Override\n+  protected int getNumRepetitions() {\n+    // Reduce this to 2 if we get better expression evaluators.\n+    return 2;\n+  }\n+\n+  private void foldSame(String js) {  \n+    testSame(js);\n+  }\n+\n+  private void fold(String js, String expected) {\n+    test(js, expected);\n+  }\n+  \n+  public void testFoldBlock() {\n+    fold(\"{{foo()}}\", \"foo()\");\n+    fold(\"{foo();{}}\", \"foo()\");\n+    fold(\"{{foo()}{}}\", \"foo()\");\n+    fold(\"{{foo()}{bar()}}\", \"foo();bar()\");\n+    fold(\"{if(false)foo(); {bar()}}\", \"bar()\");\n+    fold(\"{if(false)if(false)if(false)foo(); {bar()}}\", \"bar()\");\n+\n+    fold(\"{'hi'}\", \"\");\n+    fold(\"{x==3}\", \"\");\n+    fold(\"{ (function(){x++}) }\", \"\");\n+    fold(\"function(){return;}\", \"function(){return;}\");\n+    fold(\"function(){return 3;}\", \"function(){return 3}\");\n+    fold(\"function(){if(x)return; x=3; return; }\",\n+         \"function(){if(x)return; x=3; return; }\");\n+    fold(\"{x=3;;;y=2;;;}\", \"x=3;y=2\");\n+\n+    // Cases to test for empty block.\n+    fold(\"while(x()){x}\", \"while(x());\");\n+    fold(\"while(x()){x()}\", \"while(x())x()\");\n+    fold(\"for(x=0;x<100;x++){x}\", \"for(x=0;x<100;x++);\");\n+    fold(\"for(x in y){x}\", \"for(x in y);\");\n+  }\n+\n+  /** Try to remove spurious blocks with multiple children */\n+  public void testFoldBlocksWithManyChildren() {\n+    fold(\"function f() { if (false) {} }\", \"function f(){}\");\n+    fold(\"function f() { { if (false) {} if (true) {} {} } }\",\n+         \"function f(){}\");\n+    fold(\"{var x; var y; var z; function f() { { var a; { var b; } } } }\",\n+         \"var x;var y;var z;function f(){var a;var b}\");\n+  }\n+  \n+  public void testHookIf() {\n+    fold(\"if (1){ x=1; } else { x = 2;}\", \"x=1\");\n+    fold(\"if (false){ x = 1; } else { x = 2; }\", \"x=2\");\n+    fold(\"if (undefined){ x = 1; } else { x = 2; }\", \"x=2\");\n+    fold(\"if (null){ x = 1; } else { x = 2; }\", \"x=2\");\n+    fold(\"if (void 0){ x = 1; } else { x = 2; }\", \"x=2\");\n+    // foldSame(\"if (void foo()){ x = 1; } else { x = 2; }\");\n+    fold(\"if (false){ x = 1; } else if (true) { x = 3; } else { x = 2; }\",\n+         \"x=3\");\n+    \n+    fold(\"var x = (true) ? 1 : 0\", \"var x=1\");\n+    fold(\"var y = (true) ? ((false) ? 12 : (cond ? 1 : 2)) : 13\",\n+         \"var y=cond?1:2\");\n+    fold(\"if (x){ x = 1; } else if (false) { x = 3; }\", \"if(x)x=1\");\n+    \n+    foldSame(\"var z=x?void 0:y()\");\n+    foldSame(\"z=x?void 0:y()\");\n+    foldSame(\"z*=x?void 0:y()\");\n+    \n+    foldSame(\"var z=x?y():void 0\");\n+    foldSame(\"(w?x:void 0).y=z\");\n+    foldSame(\"(w?x:void 0).y+=z\");\n+  }\n+  \n+  public void testVarLifting() {\n+    fold(\"if(true)var a\", \"var a\");\n+    fold(\"if(false)var a\", \"var a\");\n+   \n+    // More var lifting tests in PeepholeIntegrationTests\n+  }\n+  \n+  public void testFoldUselessWhile() {\n+    fold(\"while(false) { foo() }\", \"\");\n+    \n+    fold(\"while(void 0) { foo() }\", \"\");\n+    fold(\"while(undefined) { foo() }\", \"\");\n+    \n+    foldSame(\"while(true) foo()\");\n+    \n+    fold(\"while(false) { var a = 0; }\", \"var a\");\n+    \n+    // Make sure it plays nice with minimizing\n+    fold(\"while(false) { foo(); continue }\", \"\");\n+      \n+    fold(\"while(0) { foo() }\", \"\");\n+  }\n+\n+  public void testFoldUselessFor() {\n+    fold(\"for(;false;) { foo() }\", \"\");\n+    fold(\"for(;void 0;) { foo() }\", \"\");\n+    fold(\"for(;undefined;) { foo() }\", \"\");\n+    fold(\"for(;true;) foo() \", \"for(;;) foo() \");\n+    foldSame(\"for(;;) foo()\");\n+    fold(\"for(;false;) { var a = 0; }\", \"var a\");\n+    \n+    // Make sure it plays nice with minimizing\n+    fold(\"for(;false;) { foo(); continue }\", \"\");\n+  }\n+  \n+  public void testFoldUselessDo() {\n+    fold(\"do { foo() } while(false);\", \"foo()\");\n+    fold(\"do { foo() } while(void 0);\", \"foo()\");\n+    fold(\"do { foo() } while(undefined);\", \"foo()\");\n+    fold(\"do { foo() } while(true);\", \"do { foo() } while(true);\");\n+    fold(\"do { var a = 0; } while(false);\", \"var a=0\");\n+\n+    // Can't fold with break or continues.\n+    foldSame(\"do { foo(); continue; } while(0)\");\n+    foldSame(\"do { foo(); break; } while(0)\");\n+    }\n+  \n+  public void testMinimizeWhileConstantCondition() {\n+    fold(\"while(true) foo()\", \"while(true) foo()\");\n+    fold(\"while(0) foo()\", \"\");\n+    fold(\"while(0.0) foo()\", \"\");\n+    fold(\"while(NaN) foo()\", \"\");\n+    fold(\"while(null) foo()\", \"\");\n+    fold(\"while(undefined) foo()\", \"\");\n+    fold(\"while('') foo()\", \"\");\n+  }\n+  \n+  public void testFoldConstantCommaExpressions() {\n+    fold(\"if (true, false) {foo()}\", \"\");\n+    fold(\"if (false, true) {foo()}\", \"foo()\");\n+    fold(\"true, foo()\", \"foo()\");\n+    fold(\"(1 + 2 + ''), foo()\", \"foo()\");\n+  }\n+  \n+  public void testSplitCommaExpressions() {\n+    // Don't try to split in expressions.\n+    foldSame(\"if (foo(), true) boo()\");\n+    foldSame(\"var a = (foo(), true);\");\n+    foldSame(\"a = (foo(), true);\");\n+\n+    fold(\"(x=2), foo()\", \"x=2; foo()\");\n+    fold(\"foo(), boo();\", \"foo(); boo()\");\n+    fold(\"(a(), b()), (c(), d());\", \"a(); b(); c(); d();\");\n+    // TODO(johnlenz): interestingly we don't remove side-effect free expression\n+    // in a script block (as it is currently part of block folding), so \"1;\"\n+    // is left.\n+    fold(\"foo(), true\", \"foo();true\");\n+    fold(\"function x(){foo(), true}\", \"function x(){foo();}\");\n+  }\n+}\n--- /dev/null\n+++ b/test/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntaxTest.java\n+/*\n+ * Copyright 2004 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+/**\n+ * Tests for PeepholeSubstituteAlternateSyntaxTest in isolation. \n+ * Tests for the interaction of multiple peephole passes are in \n+ * PeepholeIntegrationTest.\n+ */\n+public class PeepholeSubstituteAlternateSyntaxTest extends CompilerTestCase {\n+  \n+  // Externs for builtin constructors\n+  // Needed for testFoldLiteralConstructors() and testFoldRegExp...()\n+  private static final String FOLD_CONSTANTS_TEST_EXTERNS = \n+      \"var Object = function(){};\\n\" +\n+      \"var RegExp = function(a){};\\n\" +\n+      \"var Array = function(a){};\\n\";\n+\n+  // TODO(user): Remove this when we no longer need to do string comparison.\n+  private PeepholeSubstituteAlternateSyntaxTest(boolean compareAsTree) {\n+    super(FOLD_CONSTANTS_TEST_EXTERNS, compareAsTree);\n+  }\n+\n+  public PeepholeSubstituteAlternateSyntaxTest() {\n+    super(FOLD_CONSTANTS_TEST_EXTERNS);\n+  }\n+\n+  @Override\n+  public void setUp() throws Exception {\n+    super.setUp();\n+    \n+    enableLineNumberCheck(true);\n+  }\n+\n+  @Override\n+  public CompilerPass getProcessor(final Compiler compiler) {\n+    CompilerPass peepholePass =\n+      new PeepholeOptimizationsPass(compiler,\n+          new PeepholeSubstituteAlternateSyntax());\n+    \n+    return peepholePass;\n+  }\n+\n+  @Override\n+  protected int getNumRepetitions() {\n+    // Reduce this to 2 if we get better expression evaluators.\n+    return 2;\n+  }\n+\n+  private void foldSame(String js) {\n+    testSame(js);\n+  }\n+\n+  private void fold(String js, String expected) {\n+    test(js, expected);\n+  }\n+\n+  private void fold(String js, String expected, DiagnosticType warning) {\n+    test(js, expected, warning);\n+  }\n+\n+  void assertResultString(String js, String expected) {\n+    assertResultString(js, expected, false);\n+  }\n+  \n+  // TODO(user): This is same as fold() except it uses string comparison. Any\n+  // test that needs tell us where a folding is constructing an invalid AST.\n+  void assertResultString(String js, String expected, boolean normalize) {\n+    PeepholeSubstituteAlternateSyntaxTest scTest \n+        = new PeepholeSubstituteAlternateSyntaxTest(false);\n+    \n+    if (normalize) {\n+      scTest.enableNormalize();\n+    } else {\n+      scTest.disableNormalize();\n+    }\n+    \n+    scTest.test(js, expected);\n+  }\n+  \n+  /** Check that removing blocks with 1 child works */\n+  public void testFoldOneChildBlocks() {\n+    fold(\"function(){if(x)a();x=3}\",\n+        \"function(){x&&a();x=3}\");\n+    fold(\"function(){if(x){a()}x=3}\",\n+        \"function(){x&&a();x=3}\");\n+    fold(\"function(){if(x){return 3}}\",\n+        \"function(){if(x)return 3}\");\n+    fold(\"function(){if(x){a()}}\",\n+        \"function(){x&&a()}\");\n+    fold(\"function(){if(x){throw 1}}\", \"function(){if(x)throw 1;}\");\n+\n+    // Try it out with functions\n+    fold(\"function(){if(x){foo()}}\", \"function(){x&&foo()}\");\n+    fold(\"function(){if(x){foo()}else{bar()}}\",\n+         \"function(){x?foo():bar()}\");\n+\n+    // Try it out with properties and methods\n+    fold(\"function(){if(x){a.b=1}}\", \"function(){if(x)a.b=1}\");\n+    fold(\"function(){if(x){a.b*=1}}\", \"function(){if(x)a.b*=1}\");\n+    fold(\"function(){if(x){a.b+=1}}\", \"function(){if(x)a.b+=1}\");\n+    fold(\"function(){if(x){++a.b}}\", \"function(){x&&++a.b}\");\n+    fold(\"function(){if(x){a.foo()}}\", \"function(){x&&a.foo()}\");\n+\n+    // Try it out with throw/catch/finally [which should not change]\n+    fold(\"function(){try{foo()}catch(e){bar(e)}finally{baz()}}\",\n+         \"function(){try{foo()}catch(e){bar(e)}finally{baz()}}\");\n+\n+    // Try it out with switch statements\n+    fold(\"function(){switch(x){case 1:break}}\",\n+         \"function(){switch(x){case 1:break}}\");\n+    \n+    // Do while loops stay in a block if that's where they started\n+    fold(\"function(){if(e1){do foo();while(e2)}else foo2()}\",\n+         \"function(){if(e1){do foo();while(e2)}else foo2()}\");\n+    // Test an obscure case with do and while\n+    fold(\"if(x){do{foo()}while(y)}else bar()\",\n+         \"if(x){do foo();while(y)}else bar()\");\n+\n+    // Play with nested IFs\n+    fold(\"function(){if(x){if(y)foo()}}\",\n+         \"function(){x&&y&&foo()}\");\n+    fold(\"function(){if(x){if(y)foo();else bar()}}\",\n+         \"function(){if(x)y?foo():bar()}\");\n+    fold(\"function(){if(x){if(y)foo()}else bar()}\",\n+         \"function(){if(x)y&&foo();else bar()}\");\n+    fold(\"function(){if(x){if(y)foo();else bar()}else{baz()}}\",\n+         \"function(){if(x)y?foo():bar();else baz()}\");\n+\n+    fold(\"if(e1){while(e2){if(e3){foo()}}}else{bar()}\",\n+         \"if(e1)while(e2)e3&&foo();else bar()\");\n+\n+    fold(\"if(e1){with(e2){if(e3){foo()}}}else{bar()}\",\n+         \"if(e1)with(e2)e3&&foo();else bar()\");\n+\n+    fold(\"if(x){if(y){var x;}}\", \"if(x)if(y)var x\");\n+    fold(\"if(x){ if(y){var x;}else{var z;} }\",\n+         \"if(x)if(y)var x;else var z\");\n+\n+    // NOTE - technically we can remove the blocks since both the parent\n+    // and child have elses. But we don't since it causes ambiguities in\n+    // some cases where not all descendent ifs having elses\n+    fold(\"if(x){ if(y){var x;}else{var z;} }else{var w}\",\n+         \"if(x)if(y)var x;else var z;else var w\");\n+    fold(\"if (x) {var x;}else { if (y) { var y;} }\",\n+         \"if(x)var x;else if(y)var y\");\n+\n+    // Here's some of the ambiguous cases\n+    fold(\"if(a){if(b){f1();f2();}else if(c){f3();}}else {if(d){f4();}}\",\n+         \"if(a)if(b){f1();f2()}else c&&f3();else d&&f4()\");\n+\n+    fold(\"function(){foo()}\", \"function(){foo()}\");\n+    fold(\"switch(x){case y: foo()}\", \"switch(x){case y:foo()}\");\n+    fold(\"try{foo()}catch(ex){bar()}finally{baz()}\",\n+         \"try{foo()}catch(ex){bar()}finally{baz()}\");\n+  }\n+\n+  /** Try to minimize returns */\n+  public void testFoldReturns() {\n+    fold(\"function(){if(x)return 1;else return 2}\",\n+         \"function(){return x?1:2}\");\n+    fold(\"function(){if(x)return 1+x;else return 2-x}\",\n+         \"function(){return x?1+x:2-x}\");\n+    fold(\"function(){if(x)return y += 1;else return y += 2}\",\n+         \"function(){return x?(y+=1):(y+=2)}\");\n+\n+    // don't touch cases where either side doesn't return a value\n+    foldSame(\"function(){if(x)return;else return 2-x}\");\n+    foldSame(\"function(){if(x)return x;else return}\");\n+  }\n+\n+  /** Try to minimize assignments */\n+  public void testFoldAssignments() {\n+    fold(\"function(){if(x)y=3;else y=4;}\", \"function(){y=x?3:4}\");\n+    fold(\"function(){if(x)y=1+a;else y=2+a;}\", \"function(){y=x?1+a:2+a}\");\n+\n+    // and operation assignments\n+    fold(\"function(){if(x)y+=1;else y+=2;}\", \"function(){y+=x?1:2}\");\n+    fold(\"function(){if(x)y-=1;else y-=2;}\", \"function(){y-=x?1:2}\");\n+    fold(\"function(){if(x)y%=1;else y%=2;}\", \"function(){y%=x?1:2}\");\n+    fold(\"function(){if(x)y|=1;else y|=2;}\", \"function(){y|=x?1:2}\");\n+\n+    // sanity check, don't fold if the 2 ops don't match\n+    foldSame(\"function(){if(x)y-=1;else y+=2}\");\n+\n+    // sanity check, don't fold if the 2 LHS don't match\n+    foldSame(\"function(){if(x)y-=1;else z-=1}\");\n+\n+    // sanity check, don't fold if there are potential effects\n+    foldSame(\"function(){if(x)y().a=3;else y().a=4}\");\n+  }\n+\n+  public void testRemoveDuplicateStatements() {\n+    fold(\"if (a) { x = 1; x++ } else { x = 2; x++ }\",\n+         \"x=(a) ? 1 : 2; x++\");\n+    fold(\"if (a) { x = 1; x++; y += 1; z = pi; }\" +\n+         \" else  { x = 2; x++; y += 1; z = pi; }\",\n+         \"x=(a) ? 1 : 2; x++; y += 1; z = pi;\");\n+    fold(\"function z() {\" +\n+         \"if (a) { foo(); return true } else { goo(); return true }\" +\n+         \"}\",\n+         \"function z() {(a) ? foo() : goo(); return true}\");\n+    fold(\"function z() {if (a) { foo(); x = true; return true \" +\n+         \"} else { goo(); x = true; return true }}\",\n+         \"function z() {(a) ? foo() : goo(); x = true; return true}\");\n+    \n+    fold(\"function z() {\" +\n+         \"  if (a) { bar(); foo(); return true }\" +\n+         \"    else { bar(); goo(); return true }\" +\n+         \"}\",\n+         \"function z() {\" +\n+         \"  if (a) { bar(); foo(); }\" +\n+         \"    else { bar(); goo(); }\" +\n+         \"  return true;\" +\n+         \"}\");\n+  }\n+\n+  public void testNotCond() {\n+    fold(\"function(){if(!x)foo()}\", \"function(){x||foo()}\");\n+    fold(\"function(){if(!x)b=1}\", \"function(){x||(b=1)}\");\n+    fold(\"if(!x)z=1;else if(y)z=2\", \"if(x){if(y)z=2}else z=1\");\n+    foldSame(\"function(){if(!(x=1))a.b=1}\");\n+  }\n+\n+  public void testAndParenthesesCount() {\n+    foldSame(\"function(){if(x||y)a.foo()}\");\n+  }\n+\n+  public void testFoldLogicalOpStringCompare() {\n+    // side-effects\n+    // There is two way to parse two &&'s and both are correct.\n+    assertResultString(\"if(foo() && false) z()\", \"foo()&&0&&z()\");\n+  }\n+\n+  public void testFoldNot() {\n+    fold(\"while(!(x==y)){a=b;}\" , \"while(x!=y){a=b;}\");\n+    fold(\"while(!(x!=y)){a=b;}\" , \"while(x==y){a=b;}\");\n+    fold(\"while(!(x===y)){a=b;}\", \"while(x!==y){a=b;}\");\n+    fold(\"while(!(x!==y)){a=b;}\", \"while(x===y){a=b;}\");\n+    // Because !(x<NaN) != x>=NaN don't fold < and > cases.\n+    foldSame(\"while(!(x>y)){a=b;}\");\n+    foldSame(\"while(!(x>=y)){a=b;}\");\n+    foldSame(\"while(!(x<y)){a=b;}\");\n+    foldSame(\"while(!(x<=y)){a=b;}\");\n+    foldSame(\"while(!(x<=NaN)){a=b;}\");\n+  }\n+\n+  public void testFoldRegExpConstructor() {    \n+    enableNormalize();\n+    \n+    // Cannot fold all the way to a literal because there are too few arguments.\n+    fold(\"x = new RegExp\",                    \"x = RegExp()\");\n+    // Empty regexp should not fold to // since that is a line comment in js\n+    fold(\"x = new RegExp(\\\"\\\")\",              \"x = RegExp(\\\"\\\")\");\n+    fold(\"x = new RegExp(\\\"\\\", \\\"i\\\")\",       \"x = RegExp(\\\"\\\",\\\"i\\\")\");\n+    // Bogus flags should not fold\n+    fold(\"x = new RegExp(\\\"foobar\\\", \\\"bogus\\\")\",\n+         \"x = RegExp(\\\"foobar\\\",\\\"bogus\\\")\",\n+         PeepholeSubstituteAlternateSyntax.INVALID_REGULAR_EXPRESSION_FLAGS);\n+    // Don't fold if the flags contain 'g'\n+    fold(\"x = new RegExp(\\\"foobar\\\", \\\"g\\\")\",\n+         \"x = RegExp(\\\"foobar\\\",\\\"g\\\")\");\n+    fold(\"x = new RegExp(\\\"foobar\\\", \\\"ig\\\")\",\n+         \"x = RegExp(\\\"foobar\\\",\\\"ig\\\")\");\n+\n+    // Can Fold\n+    fold(\"x = new RegExp(\\\"foobar\\\")\",        \"x = /foobar/\");\n+    fold(\"x = RegExp(\\\"foobar\\\")\",            \"x = /foobar/\");\n+    fold(\"x = new RegExp(\\\"foobar\\\", \\\"i\\\")\", \"x = /foobar/i\");\n+    // Make sure that escaping works\n+    fold(\"x = new RegExp(\\\"\\\\\\\\.\\\", \\\"i\\\")\",  \"x = /\\\\./i\");\n+    fold(\"x = new RegExp(\\\"/\\\", \\\"\\\")\",       \"x = /\\\\//\");\n+    fold(\"x = new RegExp(\\\"///\\\", \\\"\\\")\",     \"x = /\\\\/\\\\/\\\\//\");\n+    fold(\"x = new RegExp(\\\"\\\\\\\\\\\\/\\\", \\\"\\\")\", \"x = /\\\\//\");\n+    // Don't fold things that crash older versions of Safari and that don't work\n+    // as regex literals on recent versions of Safari\n+    fold(\"x = new RegExp(\\\"\\\\u2028\\\")\", \"x = RegExp(\\\"\\\\u2028\\\")\");\n+    fold(\"x = new RegExp(\\\"\\\\\\\\\\\\\\\\u2028\\\")\", \"x = /\\\\\\\\u2028/\");\n+\n+    // Don't fold really long regexp literals, because Opera 9.2's\n+    // regexp parser will explode.\n+    String longRegexp = \"\";\n+    for (int i = 0; i < 200; i++) longRegexp += \"x\";\n+    foldSame(\"x = RegExp(\\\"\" + longRegexp + \"\\\")\");\n+    \n+    // Shouldn't fold RegExp unnormalized because\n+    // we can't be sure that RegExp hasn't been redefined     \n+    disableNormalize();\n+       \n+    foldSame(\"x = new RegExp(\\\"foobar\\\")\");\n+  }\n+\n+  public void testFoldRegExpConstructorStringCompare() {\n+    // Might have something to do with the internal representation of \\n and how\n+    // it is used in node comparison.\n+    assertResultString(\"x=new RegExp(\\\"\\\\n\\\", \\\"i\\\")\", \"x=/\\\\n/i\", true);\n+  }\n+  \n+  public void testContainsUnicodeEscape() throws Exception {\n+    assertTrue(!PeepholeSubstituteAlternateSyntax.containsUnicodeEscape(\"\"));\n+    assertTrue(!PeepholeSubstituteAlternateSyntax.containsUnicodeEscape(\"foo\"));\n+    assertTrue(PeepholeSubstituteAlternateSyntax.containsUnicodeEscape(\n+        \"\\u2028\"));\n+    assertTrue(PeepholeSubstituteAlternateSyntax.containsUnicodeEscape(\n+        \"\\\\u2028\"));\n+    assertTrue(\n+        PeepholeSubstituteAlternateSyntax.containsUnicodeEscape(\"foo\\\\u2028\"));\n+    assertTrue(!PeepholeSubstituteAlternateSyntax.containsUnicodeEscape(\n+        \"foo\\\\\\\\u2028\"));\n+    assertTrue(PeepholeSubstituteAlternateSyntax.containsUnicodeEscape(\n+            \"foo\\\\\\\\u2028bar\\\\u2028\"));\n+  }\n+\n+  public void testFoldLiteralConstructors() {\n+    enableNormalize();\n+    \n+    // Can fold when normalized\n+    fold(\"x = new Array\", \"x = []\");\n+    fold(\"x = new Array()\", \"x = []\");\n+    fold(\"x = Array()\", \"x = []\");\n+    fold(\"x = new Object\", \"x = ({})\");\n+    fold(\"x = new Object()\", \"x = ({})\");\n+    fold(\"x = Object()\", \"x = ({})\");\n+\n+    disableNormalize();\n+    // Cannot fold above when not normalized\n+    foldSame(\"x = new Array\");\n+    foldSame(\"x = new Array()\");\n+    foldSame(\"x = Array()\");\n+    foldSame(\"x = new Object\");\n+    foldSame(\"x = new Object()\");\n+    foldSame(\"x = Object()\");\n+    \n+    enableNormalize();\n+    // Cannot fold, there are arguments\n+    fold(\"x = new Array(7)\", \"x = Array(7)\");\n+\n+    // Cannot fold, the constructor being used is actually a local function\n+    foldSame(\"x = \" +\n+         \"(function(){function Object(){this.x=4};return new Object();})();\");\n+  }\n+ \n+  public void testMinimizeCondition() {\n+    // This test uses constant folding logic, so is only here for completeness.\n+    fold(\"while(!!true) foo()\", \"while(1) foo()\");\n+    // These test tryMinimizeCondition\n+    fold(\"while(!!x) foo()\", \"while(x) foo()\");\n+    fold(\"while(!(!x&&!y)) foo()\", \"while(x||y) foo()\");\n+    fold(\"while(x||!!y) foo()\", \"while(x||y) foo()\");\n+    fold(\"while(!(!!x&&y)) foo()\", \"while(!(x&&y)) foo()\");\n+  }\n+\n+  public void testMinimizeCondition_example1() {\n+    // Based on a real failing code sample.\n+    fold(\"if(!!(f() > 20)) {foo();foo()}\", \"if(f() > 20){foo();foo()}\");\n+  }\n+\n+  public void testFoldConditionalVarDeclaration() {\n+    fold(\"if(x) var y=1;else y=2\", \"var y=x?1:2\");\n+    fold(\"if(x) y=1;else var y=2\", \"var y=x?1:2\");\n+\n+    foldSame(\"if(x) var y = 1; z = 2\");\n+    foldSame(\"if(x) y = 1; var z = 2\");\n+\n+    foldSame(\"if(x) { var y = 1; print(y)} else y = 2 \");\n+    foldSame(\"if(x) var y = 1; else {y = 2; print(y)}\");\n+  }\n+\n+  public void testFoldReturnResult() {\n+    foldSame(\"function f(){return false;}\");\n+    foldSame(\"function f(){return null;}\");\n+    fold(\"function f(){return void 0;}\",\n+         \"function f(){return}\");\n+    foldSame(\"function f(){return void foo();}\");\n+    fold(\"function f(){return undefined;}\",\n+         \"function f(){return}\");\n+    fold(\"function(){if(a()){return undefined;}}\",\n+         \"function(){if(a()){return}}\");\n+  }\n+\n+  public void testFoldStandardConstructors() {\n+    foldSame(\"new Foo('a')\");\n+    foldSame(\"var x = new goog.Foo(1)\");\n+    foldSame(\"var x = new String(1)\");\n+    foldSame(\"var x = new Number(1)\");\n+    foldSame(\"var x = new Boolean(1)\");\n+    \n+    enableNormalize();\n+    \n+    fold(\"var x = new Object('a')\", \"var x = Object('a')\");\n+    fold(\"var x = new RegExp('')\", \"var x = RegExp('')\");\n+    fold(\"var x = new Error('20')\", \"var x = Error(\\\"20\\\")\");\n+    fold(\"var x = new Array('20')\", \"var x = Array(\\\"20\\\")\");\n+  }\n+}", "timestamp": 1277771400, "metainfo": ""}