{"sha": "170b23fa89cdcc38411fc29ec4453935e0903b16", "log": "Change on 2010/05/24 by johnlenz  \tSimplify function inlining compiler options: remove \tdecompose_expressions and inline_anonymouse_function_expression \toptions.  \tR=anatol,nicksantos \tDELTA=40  (0 added, 34 deleted, 6 changed)  Change on 2010/05/24 by johnlenz  \tHave flow sensitive inlining follow the default in the regtests so it \tdoesn't block pending CLs due to its current brokeness.  \tR=acleung \tDELTA=1  (0 added, 1 deleted, 0 changed)  Change on 2010/05/24 by johnlenz  \tThe ReplaceDebugStrings pass folds \"new Error\" to \"Error\", I don't want this \tin the general version of that pass so add it in a general fold to \tFoldConstants.  It should be in the \"reshaping pass\" when FoldConstants \tin refactored.  \tR=acleung \tDELTA=90  (68 added, 0 deleted, 22 changed)  Change on 2010/05/24 by nicksantos  \tDelete SymbolTable. \tI was never able to make this approach work. The savings were \tmarginal and not worth the extra complexity.  \tR=johnlenz \tDELTA=484  (0 added, 483 deleted, 1 changed)    Revision created by MOE tool push_codebase. MOE_MIGRATION=11004   ", "commit": "\n--- a/src/com/google/javascript/jscomp/AbstractCompiler.java\n+++ b/src/com/google/javascript/jscomp/AbstractCompiler.java\n   abstract void prepareAst(Node root);\n \n   /**\n-   * Acquires the symbol table.\n-   */\n-  abstract SymbolTable acquireSymbolTable();\n-\n-  /**\n    * Gets the error manager.\n    */\n   abstract public ErrorManager getErrorManager();\n--- a/src/com/google/javascript/jscomp/CompilationLevel.java\n+++ b/src/com/google/javascript/jscomp/CompilationLevel.java\n     options.variableRenaming = VariableRenamingPolicy.LOCAL;\n     options.inlineLocalVariables = true;\n     options.inlineLocalFunctions = true;\n-    options.inlineAnonymousFunctionExpressions = true;\n-    options.decomposeExpressions = true;\n     options.checkGlobalThisLevel = CheckLevel.OFF;\n     options.foldConstants = true;\n     options.removeConstantExpressions = true;\n     options.inlineConstantVars = true;\n     options.inlineFunctions = true;\n     options.inlineLocalFunctions = true;\n-    options.inlineAnonymousFunctionExpressions = true;\n-    options.decomposeExpressions = true;\n     options.inlineGetters = true;\n     options.inlineVariables = true;\n     options.removeConstantExpressions = true;\n--- a/src/com/google/javascript/jscomp/Compiler.java\n+++ b/src/com/google/javascript/jscomp/Compiler.java\n   // error manager to which error management is delegated\n   private ErrorManager errorManager;\n \n-  // Cached data structures.\n-  private SymbolTable symbolTable = null;\n-\n   // Parse tree root nodes\n   Node externsRoot;\n   Node jsRoot;\n   public Compiler(ErrorManager errorManager) {\n     this();\n     setErrorManager(errorManager);\n-  }\n-\n-  /**\n-   * Acquires the symbol table.\n-   */\n-  @Override\n-  SymbolTable acquireSymbolTable() {\n-    if (symbolTable == null) {\n-      symbolTable = new SymbolTable(this);\n-    }\n-    symbolTable.acquire();\n-    return symbolTable;\n   }\n \n   /**\n--- a/src/com/google/javascript/jscomp/DefaultPassConfig.java\n+++ b/src/com/google/javascript/jscomp/DefaultPassConfig.java\n           compiler.getUniqueNameIdSupplier(),\n           options.inlineFunctions,\n           options.inlineLocalFunctions,\n-          options.inlineAnonymousFunctionExpressions,\n-          enableBlockInlining,\n-          options.decomposeExpressions);\n+          enableBlockInlining);\n     }\n   };\n \n--- a/src/com/google/javascript/jscomp/FoldConstants.java\n+++ b/src/com/google/javascript/jscomp/FoldConstants.java\n \n import com.google.common.base.Preconditions;\n import com.google.common.base.Predicates;\n+import com.google.common.collect.ImmutableSet;\n import com.google.common.collect.Lists;\n import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n import com.google.javascript.jscomp.NodeTraversal.AbstractShallowCallback;\n             break;\n         }\n         return;\n-    } else if (type == Token.NEW) {\n+    } \n+\n+    if (type == Token.NEW) {\n+      tryFoldStandardConstructors(t, n);\n+\n+      // The type might have changed from NEW to CALL, update it\n+      // and continue.\n+      type = n.getType();\n+    }\n+\n+    if (type == Token.NEW || type == Token.CALL) {\n       if (Token.NAME == left.getType()) {\n         String className = left.getString();\n         if (\"RegExp\".equals(className)) {\n-          tryFoldRegularExpressionConstructor(t, n, parent);\n+          if (tryFoldRegularExpressionConstructor(t, n, parent)) {\n+            return;\n+          }\n         } else if (left.getNext() == null) {\n           if (\"Array\".equals(className)) {\n-            tryFoldLiteralConstructor(\n-                t, n, parent, className, Token.ARRAYLIT);\n+            if (tryFoldLiteralConstructor(\n+                t, n, parent, className, Token.ARRAYLIT)) {\n+              return;\n+            }\n           } else if (\"Object\".equals(className)) {\n-            tryFoldLiteralConstructor(\n-                t, n, parent, className, Token.OBJECTLIT);\n+            if (tryFoldLiteralConstructor(\n+                t, n, parent, className, Token.OBJECTLIT)) {\n+              return;\n+            }\n           }\n         }\n       }\n     }\n \n     // other types aren't handled\n+  }\n+\n+  private static final ImmutableSet<String> STANDARD_OBJECT_CONSTRUCTORS =\n+    // String, Number, and Boolean functions return non-object types, whereas\n+    // new String, new Number, and new Boolean return object types, so don't\n+    // include them here.\n+    ImmutableSet.of(\n+      \"Object\",\n+      \"Array\",\n+      \"RegExp\",\n+      \"Error\"\n+      );\n+  \n+  /**\n+   * Fold \"new Object()\" to \"Object()\".\n+   */\n+  private void tryFoldStandardConstructors(NodeTraversal t, Node n) {\n+    Preconditions.checkState(n.getType() == Token.NEW);\n+    \n+    if (n.getFirstChild().getType() == Token.NAME) {\n+      String className = n.getFirstChild().getString();\n+      if (STANDARD_OBJECT_CONSTRUCTORS.contains(className)) {\n+        // The var check isn't really needed here due to name normalizations\n+        // but we do it here to simplify unit testing.\n+        Scope.Var var = t.getScope().getVar(className);\n+        if (var == null || var.isGlobal()) {\n+          n.setType(Token.CALL);\n+          compiler.reportCodeChange();\n+        }    \n+      }\n+    }\n   }\n \n   private void tryFoldComma(\n   /**\n    * Try to fold a RegExp constructor to a regular expression literal.\n    */\n-  void tryFoldRegularExpressionConstructor(\n+  private boolean tryFoldRegularExpressionConstructor(\n       NodeTraversal t, Node n, Node parent) {\n     Node constructor = n.getFirstChild();\n     Node pattern = constructor.getNext();  // e.g.  ^foobar$\n \n     if (null == pattern || (null != flags && null != flags.getNext())) {\n       // too few or too many arguments\n-      return;\n+      return false;\n     }\n \n     if (// is pattern folded\n         // fold to /foobar/gi\n         if (!areValidRegexpFlags(flags.getString())) {\n           error(t, INVALID_REGULAR_EXPRESSION_FLAGS, flags);\n-          return;\n+          return false;\n         }\n         if (!areSafeFlagsToFold(flags.getString())) {\n-          return;\n+          return false;\n         }\n         n.removeChild(flags);\n         regexLiteral = new Node(Token.REGEXP, pattern, flags);\n \n       parent.replaceChild(n, regexLiteral);\n       t.getCompiler().reportCodeChange();\n-    }\n+      return true;\n+    }\n+\n+    return false;\n   }\n \n   private static final Pattern REGEXP_FLAGS_RE = Pattern.compile(\"^[gmi]*$\");\n    * @param parent\n    * @param type type of object literal to replace the new call node with\n    */\n-  void tryFoldLiteralConstructor(\n+  boolean tryFoldLiteralConstructor(\n       NodeTraversal t, Node n, Node parent, String className, int type) {\n     // Ignore calls to local functions with the same name.\n     Scope.Var var = t.getScope().getVar(className);\n     if (var != null && var.isLocal()) {\n-      return;\n+      // no change.\n+      return false;\n     }\n \n     Node literalNode = new Node(type);\n     parent.replaceChild(n, literalNode);\n     t.getCompiler().reportCodeChange();\n+    return true;\n   }\n \n   /**\n--- a/src/com/google/javascript/jscomp/InlineFunctions.java\n+++ b/src/com/google/javascript/jscomp/InlineFunctions.java\n   private final FunctionInjector injector;\n \n   private final boolean blockFunctionInliningEnabled;\n-  private final boolean inlineFunctionExpressions;\n   private final boolean inlineGlobalFunctions;\n   private final boolean inlineLocalFunctions;\n \n       Supplier<String> safeNameIdSupplier,\n       boolean inlineGlobalFunctions,\n       boolean inlineLocalFunctions,\n-      boolean inlineFunctionExpressions,\n-      boolean blockFunctionInliningEnabled,\n-      boolean enableExpressionDecomposition) {\n+      boolean blockFunctionInliningEnabled) {\n     Preconditions.checkArgument(compiler != null);\n     Preconditions.checkArgument(safeNameIdSupplier != null);\n     this.compiler = compiler;\n \n     this.inlineGlobalFunctions = inlineGlobalFunctions;\n     this.inlineLocalFunctions = inlineLocalFunctions;\n-    this.inlineFunctionExpressions =\n-      inlineFunctionExpressions;\n     this.blockFunctionInliningEnabled = blockFunctionInliningEnabled;\n \n-    this.injector = new FunctionInjector(\n-        compiler, safeNameIdSupplier, enableExpressionDecomposition);\n+    this.injector = new FunctionInjector(compiler, safeNameIdSupplier, true);\n   }\n \n   FunctionState getOrCreateFunctionState(String fnName) {\n         NodeTraversal nodeTraversal, Node n, Node parent) {\n       // Don't traverse into function bodies\n       // if we aren't inlining local functions.\n-      return inlineLocalFunctions || inlineFunctionExpressions\n-         || parent == null || NodeUtil.isControlStructure(parent)\n-         || NodeUtil.isStatementBlock(parent);\n+      return inlineLocalFunctions || nodeTraversal.inGlobalScope();\n     }\n \n     public void visit(NodeTraversal t, Node n, Node parent) {\n           || (!t.inGlobalScope() && inlineLocalFunctions)) {\n         findNamedFunctions(t, n, parent);\n \n-        if (inlineFunctionExpressions) {\n-          findFunctionExpressions(t, n);\n-        }\n+        findFunctionExpressions(t, n);\n       }\n     }\n \n--- a/src/com/google/javascript/jscomp/SanityCheck.java\n+++ b/src/com/google/javascript/jscomp/SanityCheck.java\n \n   public void process(Node externs, Node root) {\n     sanityCheckNormalization(externs, root);\n-    Node reparsedRoot = sanityCheckCodeGeneration(root);\n-    if (reparsedRoot != null) {\n-      Node clonedExterns = externs.cloneTree();\n-      sanityCheckSymbolTable(\n-          new Node(Token.BLOCK,\n-              clonedExterns,\n-              new Node(Token.BLOCK, reparsedRoot)),\n-          root.getParent());\n-    }\n-  }\n-\n-  /**\n-   * Sanity checks that symbol table is up-to-date.\n-   */\n-  private void sanityCheckSymbolTable(Node reparsedRoot, Node originalRoot) {\n-    SymbolTable table = compiler.acquireSymbolTable();\n-    table.verify(reparsedRoot, originalRoot);\n-    table.release();\n+    sanityCheckCodeGeneration(root);\n   }\n \n   /**\n--- a/test/com/google/javascript/jscomp/CompilerTestCase.java\n+++ b/test/com/google/javascript/jscomp/CompilerTestCase.java\n           new BlackHoleErrorManager(compiler);\n       Node expectedRoot = parseExpectedJs(expected);\n       expectedRoot.detachFromParent();\n-      SymbolTable table = compiler.acquireSymbolTable();\n-      table.verify(\n-          new Node(Token.BLOCK, externsRoot.cloneTree(), expectedRoot),\n-          mainRoot.getParent());\n-      table.release();\n \n       JSError[] stErrors = symbolTableErrorManager.getErrors();\n       if (expectedSymbolTableError != null) {\n--- a/test/com/google/javascript/jscomp/FoldConstantsTest.java\n+++ b/test/com/google/javascript/jscomp/FoldConstantsTest.java\n   public void testFoldRegExpConstructor() {\n     // Cannot fold\n     // Too few arguments\n-    fold(\"x = new RegExp\",                    \"x = new RegExp\");\n+    fold(\"x = new RegExp\",                    \"x = RegExp()\");\n     // Empty regexp should not fold to // since that is a line comment in js\n-    fold(\"x = new RegExp(\\\"\\\")\",              \"x = new RegExp(\\\"\\\")\");\n-    fold(\"x = new RegExp(\\\"\\\", \\\"i\\\")\",       \"x = new RegExp(\\\"\\\",\\\"i\\\")\");\n+    fold(\"x = new RegExp(\\\"\\\")\",              \"x = RegExp(\\\"\\\")\");\n+    fold(\"x = new RegExp(\\\"\\\", \\\"i\\\")\",       \"x = RegExp(\\\"\\\",\\\"i\\\")\");\n     // Bogus flags should not fold\n     fold(\"x = new RegExp(\\\"foobar\\\", \\\"bogus\\\")\",\n-         \"x = new RegExp(\\\"foobar\\\",\\\"bogus\\\")\",\n+         \"x = RegExp(\\\"foobar\\\",\\\"bogus\\\")\",\n          FoldConstants.INVALID_REGULAR_EXPRESSION_FLAGS);\n     // Don't fold if the flags contain 'g'\n     fold(\"x = new RegExp(\\\"foobar\\\", \\\"g\\\")\",\n-         \"x = new RegExp(\\\"foobar\\\",\\\"g\\\")\");\n+         \"x = RegExp(\\\"foobar\\\",\\\"g\\\")\");\n     fold(\"x = new RegExp(\\\"foobar\\\", \\\"ig\\\")\",\n-         \"x = new RegExp(\\\"foobar\\\",\\\"ig\\\")\");\n+         \"x = RegExp(\\\"foobar\\\",\\\"ig\\\")\");\n \n     // Can Fold\n     fold(\"x = new RegExp(\\\"foobar\\\")\",        \"x = /foobar/\");\n+    fold(\"x = RegExp(\\\"foobar\\\")\",            \"x = /foobar/\");\n     fold(\"x = new RegExp(\\\"foobar\\\", \\\"i\\\")\", \"x = /foobar/i\");\n     // Make sure that escaping works\n     fold(\"x = new RegExp(\\\"\\\\\\\\.\\\", \\\"i\\\")\",  \"x = /\\\\./i\");\n     fold(\"x = new RegExp(\\\"\\\\\\\\\\\\/\\\", \\\"\\\")\", \"x = /\\\\//\");\n     // Don't fold things that crash older versions of Safari and that don't work\n     // as regex literals on recent versions of Safari\n-    fold(\"x = new RegExp(\\\"\\\\u2028\\\")\", \"x = new RegExp(\\\"\\\\u2028\\\")\");\n+    fold(\"x = new RegExp(\\\"\\\\u2028\\\")\", \"x = RegExp(\\\"\\\\u2028\\\")\");\n     fold(\"x = new RegExp(\\\"\\\\\\\\\\\\\\\\u2028\\\")\", \"x = /\\\\\\\\u2028/\");\n \n     // Don't fold really long regexp literals, because Opera 9.2's\n     // regexp parser will explode.\n     String longRegexp = \"\";\n     for (int i = 0; i < 200; i++) longRegexp += \"x\";\n-    foldSame(\"x = new RegExp(\\\"\" + longRegexp + \"\\\")\");\n+    foldSame(\"x = RegExp(\\\"\" + longRegexp + \"\\\")\");\n   }\n \n   public void testFoldRegExpConstructorStringCompare() {\n     // Can fold\n     fold(\"x = new Array\", \"x = []\");\n     fold(\"x = new Array()\", \"x = []\");\n+    fold(\"x = Array()\", \"x = []\");\n     fold(\"x = new Object\", \"x = ({})\");\n     fold(\"x = new Object()\", \"x = ({})\");\n+    fold(\"x = Object()\", \"x = ({})\");\n \n     // Cannot fold, there are arguments\n-    fold(\"x = new Array(7)\", \"x = new Array(7)\");\n+    fold(\"x = new Array(7)\", \"x = Array(7)\");\n \n     // Cannot fold, the constructor being used is actually a local function\n     fold(\"x = \" +\n     fold(\"foo(), true\", \"foo();1\");\n     fold(\"function x(){foo(), true}\", \"function x(){foo();}\");\n   }\n+\n+  public void testFoldStandardConstructors() {\n+    foldSame(\"new Foo('a')\");\n+    foldSame(\"var x = new goog.Foo(1)\");\n+    foldSame(\"var x = new String(1)\");\n+    foldSame(\"var x = new Number(1)\");\n+    foldSame(\"var x = new Boolean(1)\");\n+    fold(\"var x = new Object('a')\", \"var x = Object('a')\");\n+    fold(\"var x = new RegExp('')\", \"var x = RegExp('')\");\n+    fold(\"var x = new Error('20')\", \"var x = Error(\\\"20\\\")\");\n+    fold(\"var x = new Array('20')\", \"var x = Array(\\\"20\\\")\");\n+  }\n }\n--- a/test/com/google/javascript/jscomp/InlineFunctionsTest.java\n+++ b/test/com/google/javascript/jscomp/InlineFunctionsTest.java\n         compiler.getUniqueNameIdSupplier(),\n         allowGlobalFunctionInlining,\n         allowLocalFunctionInlining,\n-        allowFunctionExpressionInlining,\n-        allowBlockInlining,\n-        allowExpressionDecomposition);\n+        allowBlockInlining);\n   }\n \n   /**\n--- a/test/com/google/javascript/jscomp/SanityCheckTest.java\n+++ b/test/com/google/javascript/jscomp/SanityCheckTest.java\n     }\n     assertTrue(exceptionCaught);\n   }\n-\n-  public void testSymbolTable() throws Exception {\n-    otherPass = new CompilerPass() {\n-      @Override public void process(Node externs, Node root) {\n-        SymbolTable st = getLastCompiler().acquireSymbolTable();\n-        st.createScope(root.getParent(), null);\n-        Node script = root.getFirstChild();\n-        script.removeChild(script.getFirstChild());\n-        st.release();\n-      }\n-    };\n-\n-    test(\"var x;\", null, SymbolTable.VARIABLE_COUNT_MISMATCH);\n-  }\n-\n-  public void testSymbolTableWrongRoot() throws Exception {\n-    otherPass = new CompilerPass() {\n-      @Override public void process(Node externs, Node root) {\n-        SymbolTable st = getLastCompiler().acquireSymbolTable();\n-        st.createScope(root, null);\n-        st.release();\n-      }\n-    };\n-\n-    try {\n-      testSame(\"var x;\");\n-    } catch (IllegalArgumentException e) {\n-      assertEquals(\n-          \"May only create scopes for the global node and functions\",\n-          e.getMessage());\n-    }\n-  }\n }", "timestamp": 1274809909, "metainfo": ""}