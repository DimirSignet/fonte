{"sha": "f78e933dbc678936ed5fcf453ab3c80b87d1e59d", "log": "Don't do local type inference on local vars that are assigned in inner scopes, because it's pretty close to impossible to do it right.    ", "commit": "\n--- a/src/com/google/javascript/jscomp/Scope.java\n+++ b/src/com/google/javascript/jscomp/Scope.java\n     }\n \n     /**\n+     * Gets the scope where this variable is declared.\n+     */\n+    Scope getScope() {\n+      return scope;\n+    }\n+\n+    /**\n      * Returns the index within the scope stack.\n      * e.g. function Foo(a) { var b; function c(d) { } }\n      * a = 0, b = 1, c = 2, d = 3\n--- a/src/com/google/javascript/jscomp/TypeInference.java\n+++ b/src/com/google/javascript/jscomp/TypeInference.java\n import static com.google.javascript.rhino.jstype.JSTypeNative.VOID_TYPE;\n \n import com.google.common.base.Preconditions;\n+import com.google.common.collect.HashMultimap;\n+import com.google.common.collect.ImmutableSet;\n import com.google.common.collect.Lists;\n+import com.google.common.collect.Multimap;\n+import com.google.common.collect.Sets;\n import com.google.javascript.jscomp.ControlFlowGraph.Branch;\n import com.google.javascript.jscomp.Scope.Var;\n import com.google.javascript.jscomp.graph.DiGraph.DiGraphEdge;\n import com.google.javascript.rhino.jstype.StaticSlot;\n import com.google.javascript.rhino.jstype.UnionType;\n \n+import java.util.Collection;\n import java.util.Iterator;\n import java.util.List;\n-\n+import java.util.Set;\n \n /**\n  * Type inference within a script node or a function body, using the data-flow\n   private final FlowScope functionScope;\n   private final FlowScope bottomScope;\n \n+  /**\n+   * Local variables that do not belong to this scope, but are assigned\n+   * in this scope.\n+   */\n+  private final Multimap<Scope, Var> assignedOuterLocalVars =\n+      HashMultimap.create();\n+\n+  /**\n+   * Vars that we should not map out type flow for.\n+   */\n+  private final Set<String> unflowableVarNames = Sets.newHashSet();\n+\n   TypeInference(AbstractCompiler compiler, ControlFlowGraph<Node> cfg,\n                 ReverseAbstractInterpreter reverseInterpreter,\n                 Scope functionScope) {\n+    this(compiler, cfg, reverseInterpreter, functionScope,\n+         ImmutableSet.<Var>of());\n+  }\n+\n+  /**\n+   * @param unflowableVars Do not do infer flow on the types of these vars.\n+   */\n+  // TODO(nicksantos): Create a builder for this class.\n+  TypeInference(AbstractCompiler compiler, ControlFlowGraph<Node> cfg,\n+                ReverseAbstractInterpreter reverseInterpreter,\n+                Scope functionScope, Collection<Var> unflowableVars) {\n     super(cfg, new LinkedFlowScope.FlowScopeJoinOp());\n     this.compiler = compiler;\n     this.registry = compiler.getTypeRegistry();\n     this.reverseInterpreter = reverseInterpreter;\n     this.syntacticScope = functionScope;\n     this.functionScope = LinkedFlowScope.createEntryLattice(functionScope);\n+\n+    for (Var unflowableVar : unflowableVars) {\n+      this.unflowableVarNames.add(unflowableVar.getName());\n+    }\n+\n     Iterator<Var> varIt = functionScope.getVars();\n     while (varIt.hasNext()) {\n       Var var = varIt.next();\n+      if (this.unflowableVarNames.contains(var.getName())) {\n+        continue;\n+      }\n \n       // For each local variable declared with the VAR keyword, the entry\n       // type is VOID.\n   @Override\n   FlowScope createEntryLattice() {\n     return functionScope;\n+  }\n+\n+  /**\n+   * @return Local variables assigned in this scope, but which are declared in\n+   *     a scope outside of it. Hashed by the scope they're declared in.\n+   */\n+  Multimap<Scope, Var> getAssignedOuterLocalVars() {\n+    return assignedOuterLocalVars;\n   }\n \n   @Override\n       case Token.NAME:\n         String varName = left.getString();\n         Var var = syntacticScope.getVar(varName);\n+        if (var != null && var.isLocal() && var.getScope() != syntacticScope) {\n+          assignedOuterLocalVars.put(var.getScope(), var);\n+        }\n \n         // When looking at VAR initializers for declared VARs, we trust\n         // the declared type over the type it's being initialized to.\n     if (varType == null) {\n       varType = getNativeType(JSTypeNative.UNKNOWN_TYPE);\n     }\n+    if (unflowableVarNames.contains(varName)) {\n+      return;\n+    }\n     scope.inferSlotType(varName, varType);\n   }\n \n--- a/src/com/google/javascript/jscomp/TypeInferencePass.java\n+++ b/src/com/google/javascript/jscomp/TypeInferencePass.java\n package com.google.javascript.jscomp;\n \n import com.google.common.base.Preconditions;\n+import com.google.common.collect.HashMultimap;\n+import com.google.common.collect.Multimap;\n import com.google.javascript.jscomp.NodeTraversal.ScopedCallback;\n+import com.google.javascript.jscomp.Scope.Var;\n import com.google.javascript.rhino.Node;\n-\n \n /**\n  * A compiler pass to run the type inference analysis.\n   private final ReverseAbstractInterpreter reverseInterpreter;\n   private Scope topScope;\n   private ScopeCreator scopeCreator;\n+\n+  /**\n+   * Local variables that are declared in an outer scope, but are assigned in\n+   * an inner scope. We cannot do type inference on these vars.\n+   */\n+  private final Multimap<Scope, Var> escapedLocalVars = HashMultimap.create();\n \n   TypeInferencePass(AbstractCompiler compiler,\n       ReverseAbstractInterpreter reverseInterpreter,\n \n   void inferTypes(NodeTraversal t, Node n, Scope scope) {\n     TypeInference typeInference =\n-        new TypeInference(compiler, computeCfg(n), reverseInterpreter, scope);\n+        new TypeInference(\n+            compiler, computeCfg(n), reverseInterpreter, scope,\n+            escapedLocalVars.get(scope));\n     try {\n       typeInference.analyze();\n+      escapedLocalVars.putAll(typeInference.getAssignedOuterLocalVars());\n \n       // Resolve any new type names found during the inference.\n       compiler.getTypeRegistry().resolveTypesInScope(scope);\n     public void enterScope(NodeTraversal t) {\n       Scope scope = t.getScope();\n       Node node = t.getCurrentNode();\n-      inferTypes(t, node, scope);\n+      if (scope.isGlobal()) {\n+        inferTypes(t, node, scope);\n+      }\n     }\n \n-    public void exitScope(NodeTraversal t) {}\n+    public void exitScope(NodeTraversal t) {\n+      Scope scope = t.getScope();\n+      Node node = t.getCurrentNode();\n+      if (scope.isLocal()) {\n+        inferTypes(t, node, scope);\n+      }\n+    }\n \n     public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n       return true;\n--- a/test/com/google/javascript/jscomp/TypeCheckTest.java\n+++ b/test/com/google/javascript/jscomp/TypeCheckTest.java\n         \"/** @this {Date} */ var f;\",\n         \"f\",\n         \"function (this:Date): ?\");\n+  }\n+\n+  public void testInnerFunction1() throws Exception {\n+    testTypes(\n+        \"function f() {\" +\n+        \" /** @type {number} */ var x = 3;\\n\" +\n+        \" function g() { x = null; }\" +\n+        \" return x;\" +\n+        \"}\",\n+        \"assignment\\n\" +\n+        \"found   : null\\n\" +\n+        \"required: number\");\n+  }\n+\n+  public void testInnerFunction2() throws Exception {\n+    testTypes(\n+        \"/** @return {number} */\\n\" +\n+        \"function f() {\" +\n+        \" var x = null;\\n\" +\n+        \" function g() { x = 3; }\" +\n+        \" g();\" +\n+        \" return x;\" +\n+        \"}\",\n+        \"inconsistent return type\\n\" +\n+        \"found   : (null|number)\\n\" +\n+        \"required: number\");\n+  }\n+\n+  public void testInnerFunction3() throws Exception {\n+    testTypes(\n+        \"var x = null;\" +\n+        \"/** @return {number} */\\n\" +\n+        \"function f() {\" +\n+        \" x = 3;\\n\" +\n+        \" /** @return {number} */\\n\" +\n+        \" function g() { x = true; return x; }\" +\n+        \" return x;\" +\n+        \"}\",\n+        \"inconsistent return type\\n\" +\n+        \"found   : boolean\\n\" +\n+        \"required: number\");\n+  }\n+\n+  public void testInnerFunction4() throws Exception {\n+    testTypes(\n+        \"var x = null;\" +\n+        \"/** @return {number} */\\n\" +\n+        \"function f() {\" +\n+        \" x = '3';\\n\" +\n+        \" /** @return {number} */\\n\" +\n+        \" function g() { x = 3; return x; }\" +\n+        \" return x;\" +\n+        \"}\",\n+        \"inconsistent return type\\n\" +\n+        \"found   : string\\n\" +\n+        \"required: number\");\n+  }\n+\n+  public void testInnerFunction5() throws Exception {\n+    testTypes(\n+        \"/** @return {number} */\\n\" +\n+        \"function f() {\" +\n+        \" var x = 3;\\n\" +\n+        \" /** @return {number} */\" +\n+        \" function g() { var x = 3;x = true; return x; }\" +\n+        \" return x;\" +\n+        \"}\",\n+        \"inconsistent return type\\n\" +\n+        \"found   : boolean\\n\" +\n+        \"required: number\");\n   }\n \n   public void testAbstractMethodHandling1() throws Exception {", "timestamp": 1265069398, "metainfo": ""}