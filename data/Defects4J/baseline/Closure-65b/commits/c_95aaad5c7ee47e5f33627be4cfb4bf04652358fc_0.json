{"sha": "95aaad5c7ee47e5f33627be4cfb4bf04652358fc", "log": "Allow new RegExp('foobar', 'g') -> /foobar/g and new RegExp('\\\\u1234') -> /\\u1234/ when ES5 syntax is enabled.  I don't know if this is the ideal flag, but it might be good to sunset these exclusions that were added to workaround old browser (Safari 2 and IE 6) quirks.  R=johnlenz DELTA=123  (89 added, 15 deleted, 19 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=1364   ", "commit": "\n--- a/src/com/google/javascript/jscomp/AbstractPeepholeOptimization.java\n+++ b/src/com/google/javascript/jscomp/AbstractPeepholeOptimization.java\n   }\n \n   /**\n+   * @return Whether the source code version is EcmaScript 5 or later.\n+   *     Workarounds for quirks in browsers that do not support ES5 can be\n+   *     ignored when this is true.\n+   */\n+  boolean isEcmaScript5OrGreater() {\n+    return currentTraversal != null\n+        && currentTraversal.getCompiler().acceptEcmaScript5();\n+  }\n+\n+  /**\n    * Check if the specified node is null or is still in the AST.\n    */\n   @VisibleForTesting\n--- a/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n+++ b/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n       if (n.getFirstChild().getType() == Token.NAME) {\n         String className = n.getFirstChild().getString();\n         if (STANDARD_OBJECT_CONSTRUCTORS.contains(className)) {\n-            n.setType(Token.CALL);\n-            reportCodeChange();\n+          n.setType(Token.CALL);\n+          reportCodeChange();\n         }\n       }\n     }\n     Node pattern = constructor.getNext();  // e.g.  ^foobar$\n     Node flags = null != pattern ? pattern.getNext() : null;  // e.g. gi\n \n-    // Only run on normalized AST to make sure RegExp() is actually\n-    // the RegExp we expect (if the AST has been normalized then\n-    // other RegExp's will have been renamed to something like RegExp$1)\n-    if (!isASTNormalized()) {\n-      return n;\n-    }\n-\n     if (null == pattern || (null != flags && null != flags.getNext())) {\n       // too few or too many arguments\n       return n;\n         && (null == flags || flags.getType() == Token.STRING)\n         // don't escape patterns with unicode escapes since Safari behaves badly\n         // (read can't parse or crashes) on regex literals with unicode escapes\n-        && !containsUnicodeEscape(pattern.getString())) {\n-\n-      // Make sure that / is escaped, so that it will fit safely in /brackets/.\n+        && (isEcmaScript5OrGreater()\n+            || !containsUnicodeEscape(pattern.getString()))) {\n+\n+      // Make sure that / is escaped, so that it will fit safely in /brackets/\n+      // and make sure that no LineTerminatorCharacters appear literally inside\n+      // the pattern.\n       // pattern is a string value with \\\\ and similar already escaped\n       pattern = makeForwardSlashBracketSafe(pattern);\n \n    * property contains the state of last execution, so replacing\n    * 'new RegExp('foobar','g')' with '/foobar/g' may change the behavior of\n    * the program if the RegExp is used inside a loop, for example.\n-   */\n-  private static boolean areSafeFlagsToFold(String flags) {\n-    return flags.indexOf('g') < 0;\n+   * <p>\n+   * EmcaScript 5 explicitly disallows pooling of regular expression literals so\n+   * in EcmaScript 5, {@code /foo/g} and {@code new RegExp('foo', 'g')} are\n+   * equivalent.\n+   * From section 7.8.5:\n+   * \"Then each time the literal is evaluated, a new object is created as if by\n+   * the expression new RegExp(Pattern, Flags) where RegExp is the standard\n+   * built-in constructor with that name.\"\n+   */\n+  private boolean areSafeFlagsToFold(String flags) {\n+    return isEcmaScript5OrGreater() || flags.indexOf('g') < 0;\n   }\n \n   /**\n     // sb contains everything in s[0:pos]\n     StringBuilder sb = null;\n     int pos = 0;\n+    boolean isEscaped = false, inCharset = false;\n     for (int i = 0; i < s.length(); ++i) {\n-      switch (s.charAt(i)) {\n-        case '\\\\':  // skip over the next char after a '\\\\'.\n-          ++i;\n+      char ch = s.charAt(i);\n+      switch (ch) {\n+        case '\\\\':\n+          isEscaped = !isEscaped;\n+          continue;\n+        case '/':\n+          // Escape a literal forward slash if it is not already escaped and is\n+          // not inside a character set.\n+          //     new RegExp('/') -> /\\//\n+          // but the following do not need extra escaping\n+          //     new RegExp('\\\\/') -> /\\//\n+          //     new RegExp('[/]') -> /[/]/\n+          if (!isEscaped && !inCharset) {\n+            if (null == sb) { sb = new StringBuilder(s.length() + 16); }\n+            sb.append(s, pos, i).append('\\\\');\n+            pos = i;\n+          }\n           break;\n-        case '/':  // escape it\n+        case '[':\n+          if (!isEscaped) {\n+            inCharset = true;\n+          }\n+          break;\n+        case ']':\n+          if (!isEscaped) {\n+            inCharset = false;\n+          }\n+          break;\n+        case '\\r': case '\\n': case '\\u2028': case '\\u2029':\n+          // LineTerminators cannot appear raw inside a regular\n+          // expression literal.\n+          // They can't appear legally in a quoted string, but when\n+          // the quoted string from\n+          //     new RegExp('\\n')\n+          // reaches here, the quoting has been removed.\n+          // Requote just these code-points.\n           if (null == sb) { sb = new StringBuilder(s.length() + 16); }\n-          sb.append(s, pos, i).append('\\\\');\n-          pos = i;\n+          if (isEscaped) {\n+            sb.append(s, pos, i - 1);\n+          } else {\n+            sb.append(s, pos, i);\n+          }\n+          switch (ch) {\n+            case '\\r': sb.append(\"\\\\r\"); break;\n+            case '\\n': sb.append(\"\\\\n\"); break;\n+            case '\\u2028': sb.append(\"\\\\u2028\"); break;\n+            case '\\u2029': sb.append(\"\\\\u2029\"); break;\n+          }\n+          pos = i + 1;\n           break;\n       }\n-    }\n-\n-    // don't discard useful line-number info if there were no changes\n+      isEscaped = false;\n+    }\n+\n     if (null == sb) { return n.cloneTree(); }\n \n     sb.append(s, pos, s.length());\n--- a/test/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntaxTest.java\n+++ b/test/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntaxTest.java\n     fold(\"x = new RegExp(\\\"foobar\\\", \\\"bogus\\\")\",\n          \"x = RegExp(\\\"foobar\\\",\\\"bogus\\\")\",\n          PeepholeSubstituteAlternateSyntax.INVALID_REGULAR_EXPRESSION_FLAGS);\n-    // Don't fold if the flags contain 'g'\n-    fold(\"x = new RegExp(\\\"foobar\\\", \\\"g\\\")\",\n-         \"x = RegExp(\\\"foobar\\\",\\\"g\\\")\");\n-    fold(\"x = new RegExp(\\\"foobar\\\", \\\"ig\\\")\",\n-         \"x = RegExp(\\\"foobar\\\",\\\"ig\\\")\");\n-\n     // Can Fold\n     fold(\"x = new RegExp(\\\"foobar\\\")\",        \"x = /foobar/\");\n     fold(\"x = RegExp(\\\"foobar\\\")\",            \"x = /foobar/\");\n     // Make sure that escaping works\n     fold(\"x = new RegExp(\\\"\\\\\\\\.\\\", \\\"i\\\")\",  \"x = /\\\\./i\");\n     fold(\"x = new RegExp(\\\"/\\\", \\\"\\\")\",       \"x = /\\\\//\");\n+    fold(\"x = new RegExp(\\\"[/]\\\", \\\"\\\")\",     \"x = /[/]/\");\n     fold(\"x = new RegExp(\\\"///\\\", \\\"\\\")\",     \"x = /\\\\/\\\\/\\\\//\");\n     fold(\"x = new RegExp(\\\"\\\\\\\\\\\\/\\\", \\\"\\\")\", \"x = /\\\\//\");\n-    // Don't fold things that crash older versions of Safari and that don't work\n-    // as regex literals on recent versions of Safari\n-    fold(\"x = new RegExp(\\\"\\\\u2028\\\")\", \"x = RegExp(\\\"\\\\u2028\\\")\");\n-    fold(\"x = new RegExp(\\\"\\\\\\\\\\\\\\\\u2028\\\")\", \"x = /\\\\\\\\u2028/\");\n+    fold(\"x = new RegExp(\\\"\\\\n\\\")\",           \"x = /\\\\n/\");\n+    fold(\"x = new RegExp('\\\\\\\\\\\\r')\",         \"x = /\\\\r/\");\n \n     // Don't fold really long regexp literals, because Opera 9.2's\n     // regexp parser will explode.\n     disableNormalize();\n \n     foldSame(\"x = new RegExp(\\\"foobar\\\")\");\n+  }\n+\n+  public void testVersionSpecificRegExpQuirks() {\n+    enableNormalize();\n+\n+    // Don't fold if the flags contain 'g'\n+    enableEcmaScript5(false);\n+    fold(\"x = new RegExp(\\\"foobar\\\", \\\"g\\\")\",\n+         \"x = RegExp(\\\"foobar\\\",\\\"g\\\")\");\n+    fold(\"x = new RegExp(\\\"foobar\\\", \\\"ig\\\")\",\n+         \"x = RegExp(\\\"foobar\\\",\\\"ig\\\")\");\n+    // ... unless in EcmaScript 5 mode per section 7.8.5 of EcmaScript 5.\n+    enableEcmaScript5(true);\n+    fold(\"x = new RegExp(\\\"foobar\\\", \\\"ig\\\")\",\n+         \"x = /foobar/ig\");\n+    // Don't fold things that crash older versions of Safari and that don't work\n+    // as regex literals on other old versions of Safari\n+    enableEcmaScript5(false);\n+    fold(\"x = new RegExp(\\\"\\\\u2028\\\")\", \"x = RegExp(\\\"\\\\u2028\\\")\");\n+    fold(\"x = new RegExp(\\\"\\\\\\\\\\\\\\\\u2028\\\")\", \"x = /\\\\\\\\u2028/\");\n+    // Sunset Safari exclusions for EcmaScript 5 and later.\n+    enableEcmaScript5(true);\n+    fold(\"x = new RegExp(\\\"\\\\u2028\\\\u2029\\\")\", \"x = /\\\\u2028\\\\u2029/\");\n+    fold(\"x = new RegExp(\\\"\\\\\\\\u2028\\\")\", \"x = /\\\\u2028/\");\n+    fold(\"x = new RegExp(\\\"\\\\\\\\\\\\\\\\u2028\\\")\", \"x = /\\\\\\\\u2028/\");\n   }\n \n   public void testFoldRegExpConstructorStringCompare() {", "timestamp": 1302552850, "metainfo": ""}