{"sha": "d1459d88d5a1b3e79724b2302e8e5a537e150532", "log": "handle the case where an @enum is aliased. this caused a compiler crash because CollapseProperties happens in two steps: 1) Collapse all references 2) Collapse all declarations Sometimes, during step (2), we need to create aliases to object literal keys. Introducing these new aliases changes whether or not a property should be collapsed. So we need to modify the predicate for deciding whether a property should be collapsed so that it is consistent over the life of the pass.  R=acleung DELTA=71  (61 added, 5 deleted, 5 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=372006   ", "commit": "\n--- a/src/com/google/javascript/jscomp/CollapseProperties.java\n+++ b/src/com/google/javascript/jscomp/CollapseProperties.java\n     }\n \n     if (isObjLit) {\n-      boolean discardKeys = n.aliasingGets == 0;\n       declareVarsForObjLitValues(\n           n, alias, rvalue,\n-          varNode, varParent.getChildBefore(varNode), varParent,\n-          discardKeys);\n+          varNode, varParent.getChildBefore(varNode), varParent);\n     }\n \n     addStubsForUndeclaredProperties(n, alias, varParent, varNode);\n     int numChanges = 0;\n \n     if (isObjLit) {\n-      boolean discardKeys = n.aliasingGets == 0;\n       numChanges += declareVarsForObjLitValues(\n           n, name, rvalue, varNode, gramps.getChildBefore(varNode),\n-          gramps, discardKeys);\n+          gramps);\n     }\n \n     numChanges += addStubsForUndeclaredProperties(n, name, gramps, varNode);\n    * @param nameToAddAfter The child of {@code varNode} after which new\n    *     variables should be added (may be null)\n    * @param varParent {@code varNode}'s parent\n-   * @param discardKeys Whether to eliminate the object literal's keys after\n-   *     declaring variables for its values\n    * @return The number of variables added\n    */\n   private int declareVarsForObjLitValues(\n       Name objlitName, String alias, Node objlit, Node varNode,\n-      Node nameToAddAfter, Node varParent, boolean discardKeys) {\n+      Node nameToAddAfter, Node varParent) {\n     int numVars = 0;\n     int arbitraryNameCounter = 0;\n+    boolean discardKeys = !objlitName.shouldKeepKeys();\n \n     for (Node key = objlit.getFirstChild(), nextKey; key != null;\n          key = nextKey) {\n--- a/src/com/google/javascript/jscomp/GlobalNamespace.java\n+++ b/src/com/google/javascript/jscomp/GlobalNamespace.java\n       if (isClassOrEnum) {\n         return true;\n       }\n-      return (type == Type.FUNCTION || aliasingGets == 0) &&\n-          (parent == null || parent.canCollapseUnannotatedChildNames());\n+\n+      // If this is a key of an aliased object literal, then it will be aliased\n+      // later. So we won't be able to collapse its properties.\n+      if (parent != null && parent.shouldKeepKeys()) {\n+        return false;\n+      }\n+\n+      // If this is aliased, and its not a function, then its properties\n+      // can't be collapsed either.\n+      if (type != Type.FUNCTION && aliasingGets > 0) {\n+        return false;\n+      }\n+\n+      return (parent == null || parent.canCollapseUnannotatedChildNames());\n+    }\n+\n+    /** Whether this is an object literal that needs to keep its keys. */\n+    boolean shouldKeepKeys() {\n+      return type == Type.OBJECTLIT && aliasingGets > 0;\n     }\n \n     boolean needsToBeStubbed() {\n--- a/src/com/google/javascript/jscomp/SanityCheck.java\n+++ b/src/com/google/javascript/jscomp/SanityCheck.java\n   public void process(Node externs, Node root) {\n     sanityCheckNormalization(externs, root);\n     sanityCheckCodeGeneration(root);\n+    sanityCheckVars(externs, root);\n+  }\n+\n+  private void sanityCheckVars(Node externs, Node root) {\n+    if (compiler.isNormalized()) {\n+      (new VarCheck(compiler, true)).process(externs, root);\n+    }\n   }\n \n   /**\n--- a/test/com/google/javascript/jscomp/CollapsePropertiesTest.java\n+++ b/test/com/google/javascript/jscomp/CollapsePropertiesTest.java\n          null, CollapseProperties.UNSAFE_NAMESPACE_WARNING);\n   }\n \n+  public void testAliasCreatedForEnumOfObjects() {\n+    test(\"var a = {}; \" +\n+         \"/** @enum {Object} */ a.b = {c: {d: 1}}; a.b.c;\" +\n+         \"searchEnum(a.b);\",\n+         \"var a$b$c = {d: 1};var a$b = {c: a$b$c}; a$b$c; \" +\n+         \"searchEnum(a$b)\");\n+  }\n+\n+  public void testAliasCreatedForEnumOfObjects2() {\n+    test(\"var a = {}; \" +\n+         \"/** @enum {Object} */ a.b = {c: {d: 1}}; a.b.c.d;\" +\n+         \"searchEnum(a.b);\",\n+         \"var a$b$c = {d: 1};var a$b = {c: a$b$c}; a$b$c.d; \" +\n+         \"searchEnum(a$b)\");\n+  }\n+\n+  public void testAliasCreatedForPropertyOfEnumOfObjects() {\n+    test(\"var a = {}; \" +\n+         \"/** @enum {Object} */ a.b = {c: {d: 1}}; a.b.c;\" +\n+         \"searchEnum(a.b.c);\",\n+         \"var a$b$c = {d: 1}; a$b$c; searchEnum(a$b$c);\");\n+  }\n+\n+  public void testAliasCreatedForPropertyOfEnumOfObjects2() {\n+    test(\"var a = {}; \" +\n+         \"/** @enum {Object} */ a.b = {c: {d: 1}}; a.b.c.d;\" +\n+         \"searchEnum(a.b.c);\",\n+         \"var a$b$c = {d: 1}; a$b$c.d; searchEnum(a$b$c);\");\n+  }\n+\n   public void testMisusedEnumTag() {\n     testSame(\"var a = {}; var d = a; a.b = function() {};\" +\n              \"/** @enum */ a.b.c = 0; a.b.c;\");\n          \"new f(a.b); a.b.c;\",\n          \"var a$b = {}; var a$b$c = function(){}; new f(a$b); a$b$c;\",\n          null, CollapseProperties.UNSAFE_NAMESPACE_WARNING);\n+  }\n+\n+  public void testAliasCreatedForClassProperty() {\n+    test(\"var a = {}; /** @constructor */ a.b = function(){};\" +\n+         \"a.b.c = {d: 3}; new f(a.b.c); a.b.c.d;\",\n+         \"var a$b = function(){}; var a$b$c = {d:3}; new f(a$b$c); a$b$c.d;\");\n   }\n \n   public void testNestedObjLit() {", "timestamp": 1287620056, "metainfo": ""}